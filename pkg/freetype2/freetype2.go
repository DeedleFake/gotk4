// Code generated by girgen. DO NOT EDIT.

package freetype2

import (
	"runtime"
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
//
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{

		// Records
		// Skipped Bitmap.
		// Skipped Face.
		// Skipped Library.

	})
}

type Int32 int32

func LibraryVersion() {

	C.FT_Library_Version()
}

type Bitmap struct {
	native *C.FT_Bitmap
}

// WrapBitmap wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapBitmap(ptr unsafe.Pointer) *Bitmap {
	p := (*C.FT_Bitmap)(ptr)
	v := Bitmap{native: p}

	runtime.SetFinalizer(&v, nil)
	runtime.SetFinalizer(&v, (*Bitmap).free)

	return &v
}

func marshalBitmap(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapBitmap(unsafe.Pointer(b))
}

func (b *Bitmap) free() {
	C.free(b.Native())
}

// Native returns the underlying source pointer.
func (b *Bitmap) Native() unsafe.Pointer {
	return unsafe.Pointer(b.native)
}

// Native returns the pointer to *C.FT_Bitmap. The caller is expected to
// cast.
func (b *Bitmap) Native() unsafe.Pointer {
	return unsafe.Pointer(b.native)
}

type Face struct {
	native *C.FT_Face
}

// WrapFace wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFace(ptr unsafe.Pointer) *Face {
	p := (*C.FT_Face)(ptr)
	v := Face{native: p}

	runtime.SetFinalizer(&v, nil)
	runtime.SetFinalizer(&v, (*Face).free)

	return &v
}

func marshalFace(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapFace(unsafe.Pointer(b))
}

func (f *Face) free() {
	C.free(f.Native())
}

// Native returns the underlying source pointer.
func (f *Face) Native() unsafe.Pointer {
	return unsafe.Pointer(f.native)
}

// Native returns the pointer to *C.FT_Face. The caller is expected to
// cast.
func (f *Face) Native() unsafe.Pointer {
	return unsafe.Pointer(f.native)
}

type Library struct {
	native *C.FT_Library
}

// WrapLibrary wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapLibrary(ptr unsafe.Pointer) *Library {
	p := (*C.FT_Library)(ptr)
	v := Library{native: p}

	runtime.SetFinalizer(&v, nil)
	runtime.SetFinalizer(&v, (*Library).free)

	return &v
}

func marshalLibrary(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapLibrary(unsafe.Pointer(b))
}

func (l *Library) free() {
	C.free(l.Native())
}

// Native returns the underlying source pointer.
func (l *Library) Native() unsafe.Pointer {
	return unsafe.Pointer(l.native)
}

// Native returns the pointer to *C.FT_Library. The caller is expected to
// cast.
func (l *Library) Native() unsafe.Pointer {
	return unsafe.Pointer(l.native)
}
