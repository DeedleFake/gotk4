// Code generated by girgen. DO NOT EDIT.

package gdkpixbuf

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gdk-pixbuf-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <gdk-pixbuf/gdk-pixbuf.h>
import "C"

// Pixbuf: a pixel buffer.
//
// `GdkPixbuf` contains information about an image's pixel data, its color
// space, bits per sample, width and height, and the rowstride (the number of
// bytes between the start of one row and the start of the next).
//
// Creating new `GdkPixbuf`
//
// The most basic way to create a pixbuf is to wrap an existing pixel buffer
// with a [class@GdkPixbuf.Pixbuf] instance. You can use the
// [`ctor@GdkPixbuf.Pixbuf.new_from_data`] function to do this.
//
// Every time you create a new `GdkPixbuf` instance for some data, you will need
// to specify the destroy notification function that will be called when the
// data buffer needs to be freed; this will happen when a `GdkPixbuf` is
// finalized by the reference counting functions. If you have a chunk of static
// data compiled into your application, you can pass in `NULL` as the destroy
// notification function so that the data will not be freed.
//
// The [`ctor@GdkPixbuf.Pixbuf.new`] constructor function can be used as a
// convenience to create a pixbuf with an empty buffer; this is equivalent to
// allocating a data buffer using `malloc()` and then wrapping it with
// `gdk_pixbuf_new_from_data()`. The `gdk_pixbuf_new()` function will compute an
// optimal rowstride so that rendering can be performed with an efficient
// algorithm.
//
// As a special case, you can use the
// [`ctor@GdkPixbuf.Pixbuf.new_from_xpm_data`] function to create a pixbuf from
// inline XPM image data.
//
// You can also copy an existing pixbuf with the [method@Pixbuf.copy] function.
// This is not the same as just acquiring a reference to the old pixbuf
// instance: the copy function will actually duplicate the pixel data in memory
// and create a new [class@Pixbuf] instance for it.
//
//
// Reference counting
//
// `GdkPixbuf` structures are reference counted. This means that an application
// can share a single pixbuf among many parts of the code. When a piece of the
// program needs to use a pixbuf, it should acquire a reference to it by calling
// `g_object_ref()`; when it no longer needs the pixbuf, it should release the
// reference it acquired by calling `g_object_unref()`. The resources associated
// with a `GdkPixbuf` will be freed when its reference count drops to zero.
// Newly-created `GdkPixbuf` instances start with a reference count of one.
//
//
// Image Data
//
// Image data in a pixbuf is stored in memory in an uncompressed, packed format.
// Rows in the image are stored top to bottom, and in each row pixels are stored
// from left to right.
//
// There may be padding at the end of a row.
//
// The "rowstride" value of a pixbuf, as returned by
// [`method@GdkPixbuf.Pixbuf.get_rowstride`], indicates the number of bytes
// between rows.
//
// **NOTE**: If you are copying raw pixbuf data with `memcpy()` note that the
// last row in the pixbuf may not be as wide as the full rowstride, but rather
// just as wide as the pixel data needs to be; that is: it is unsafe to do
// `memcpy (dest, pixels, rowstride * height)` to copy a whole pixbuf. Use
// [method@GdkPixbuf.Pixbuf.copy] instead, or compute the width in bytes of the
// last row as:
//
// “`c last_row = width * ((n_channels * bits_per_sample + 7) / 8); “`
//
// The same rule applies when iterating over each row of a `GdkPixbuf` pixels
// array.
//
// The following code illustrates a simple `put_pixel()` function for RGB
// pixbufs with 8 bits per channel with an alpha channel.
//
// “`c static void put_pixel (GdkPixbuf *pixbuf, int x, int y, guchar red,
// guchar green, guchar blue, guchar alpha) { int n_channels =
// gdk_pixbuf_get_n_channels (pixbuf);
//
//    // Ensure that the pixbuf is valid
//    g_assert (gdk_pixbuf_get_colorspace (pixbuf) == GDK_COLORSPACE_RGB);
//    g_assert (gdk_pixbuf_get_bits_per_sample (pixbuf) == 8);
//    g_assert (gdk_pixbuf_get_has_alpha (pixbuf));
//    g_assert (n_channels == 4);
//
//    int width = gdk_pixbuf_get_width (pixbuf);
//    int height = gdk_pixbuf_get_height (pixbuf);
//
//    // Ensure that the coordinates are in a valid range
//    g_assert (x >= 0 && x < width);
//    g_assert (y >= 0 && y < height);
//
//    int rowstride = gdk_pixbuf_get_rowstride (pixbuf);
//
//    // The pixel buffer in the GdkPixbuf instance
//    guchar *pixels = gdk_pixbuf_get_pixels (pixbuf);
//
//    // The pixel we wish to modify
//    guchar *p = pixels + y * rowstride + x * n_channels;
//    p[0] = red;
//    p[1] = green;
//    p[2] = blue;
//    p[3] = alpha;
//
// } “`
//
//
// Loading images
//
// The `GdkPixBuf` class provides a simple mechanism for loading an image from a
// file in synchronous and asynchronous fashion.
//
// For GUI applications, it is recommended to use the asynchronous stream API to
// avoid blocking the control flow of the application.
//
// Additionally, `GdkPixbuf` provides the [class@GdkPixbuf.PixbufLoader`] API
// for progressive image loading.
//
//
// Saving images
//
// The `GdkPixbuf` class provides methods for saving image data in a number of
// file formats. The formatted data can be written to a file or to a memory
// buffer. `GdkPixbuf` can also call a user-defined callback on the data, which
// allows to e.g. write the image to a socket or store it in a database.
type Pixbuf interface {
	gextras.Objector
	gio.Icon

	// Composite creates a transformation of the source image @src by scaling by
	// @scale_x and @scale_y then translating by @offset_x and @offset_y.
	//
	// This gives an image in the coordinates of the destination pixbuf. The
	// rectangle (@dest_x, @dest_y, @dest_width, @dest_height) is then alpha
	// blended onto the corresponding rectangle of the original destination
	// image.
	//
	// When the destination rectangle contains parts not in the source image,
	// the data at the edges of the source image is replicated to infinity.
	//
	// ! (composite.png)
	Composite(dest Pixbuf, destX int, destY int, destWidth int, destHeight int, offsetX float64, offsetY float64, scaleX float64, scaleY float64, interpType InterpType, overallAlpha int)
	// CompositeColor creates a transformation of the source image @src by
	// scaling by @scale_x and @scale_y then translating by @offset_x and
	// @offset_y, then alpha blends the rectangle (@dest_x ,@dest_y,
	// @dest_width, @dest_height) of the resulting image with a checkboard of
	// the colors @color1 and @color2 and renders it onto the destination image.
	//
	// If the source image has no alpha channel, and @overall_alpha is 255, a
	// fast path is used which omits the alpha blending and just performs the
	// scaling.
	//
	// See gdk_pixbuf_composite_color_simple() for a simpler variant of this
	// function suitable for many tasks.
	CompositeColor(dest Pixbuf, destX int, destY int, destWidth int, destHeight int, offsetX float64, offsetY float64, scaleX float64, scaleY float64, interpType InterpType, overallAlpha int, checkX int, checkY int, checkSize int, color1 uint32, color2 uint32)
	// CopyArea copies a rectangular area from `src_pixbuf` to `dest_pixbuf`.
	//
	// Conversion of pixbuf formats is done automatically.
	//
	// If the source rectangle overlaps the destination rectangle on the same
	// pixbuf, it will be overwritten during the copy operation. Therefore, you
	// can not use this function to scroll a pixbuf.
	CopyArea(srcX int, srcY int, width int, height int, destPixbuf Pixbuf, destX int, destY int)
	// CopyOptions copies the key/value pair options attached to a `GdkPixbuf`
	// to another `GdkPixbuf`.
	//
	// This is useful to keep original metadata after having manipulated a file.
	// However be careful to remove metadata which you've already applied, such
	// as the "orientation" option after rotating the image.
	CopyOptions(destPixbuf Pixbuf) bool
	// Fill clears a pixbuf to the given RGBA value, converting the RGBA value
	// into the pixbuf's pixel format.
	//
	// The alpha component will be ignored if the pixbuf doesn't have an alpha
	// channel.
	Fill(pixel uint32)
	// BitsPerSample queries the number of bits per color sample in a pixbuf.
	BitsPerSample() int
	// ByteLength returns the length of the pixel data, in bytes.
	ByteLength() uint
	// HasAlpha queries whether a pixbuf has an alpha channel (opacity
	// information).
	HasAlpha() bool
	// Height queries the height of a pixbuf.
	Height() int
	// NChannels queries the number of channels of a pixbuf.
	NChannels() int
	// Option looks up @key in the list of options that may have been attached
	// to the @pixbuf when it was loaded, or that may have been attached by
	// another function using gdk_pixbuf_set_option().
	//
	// For instance, the ANI loader provides "Title" and "Artist" options. The
	// ICO, XBM, and XPM loaders provide "x_hot" and "y_hot" hot-spot options
	// for cursor definitions. The PNG loader provides the tEXt ancillary chunk
	// key/value pairs as options. Since 2.12, the TIFF and JPEG loaders return
	// an "orientation" option string that corresponds to the embedded TIFF/Exif
	// orientation tag (if present). Since 2.32, the TIFF loader sets the
	// "multipage" option string to "yes" when a multi-page TIFF is loaded.
	// Since 2.32 the JPEG and PNG loaders set "x-dpi" and "y-dpi" if the file
	// contains image density information in dots per inch. Since 2.36.6, the
	// JPEG loader sets the "comment" option with the comment EXIF tag.
	Option(key string) string
	// PixelsWithLength queries a pointer to the pixel data of a pixbuf.
	//
	// This function will cause an implicit copy of the pixbuf data if the
	// pixbuf was created from read-only data.
	//
	// Please see the section on image data (#image-data) for information about
	// how the pixel data is stored in memory.
	PixelsWithLength() []byte
	// Rowstride queries the rowstride of a pixbuf, which is the number of bytes
	// between the start of a row and the start of the next row.
	Rowstride() int
	// Width queries the width of a pixbuf.
	Width() int
	// ReadPixels provides a read-only pointer to the raw pixel data.
	//
	// This function allows skipping the implicit copy that must be made if
	// gdk_pixbuf_get_pixels() is called on a read-only pixbuf.
	ReadPixels() *byte
	// RemoveOption removes the key/value pair option attached to a `GdkPixbuf`.
	RemoveOption(key string) bool
	// SaturateAndPixelate modifies saturation and optionally pixelates `src`,
	// placing the result in `dest`.
	//
	// The `src` and `dest` pixbufs must have the same image format, size, and
	// rowstride.
	//
	// The `src` and `dest` arguments may be the same pixbuf with no ill
	// effects.
	//
	// If `saturation` is 1.0 then saturation is not changed. If it's less than
	// 1.0, saturation is reduced (the image turns toward grayscale); if greater
	// than 1.0, saturation is increased (the image gets more vivid colors).
	//
	// If `pixelate` is `TRUE`, then pixels are faded in a checkerboard pattern
	// to create a pixelated image.
	SaturateAndPixelate(dest Pixbuf, saturation float32, pixelate bool)
	// Scale creates a transformation of the source image @src by scaling by
	// @scale_x and @scale_y then translating by @offset_x and @offset_y, then
	// renders the rectangle (@dest_x, @dest_y, @dest_width, @dest_height) of
	// the resulting image onto the destination image replacing the previous
	// contents.
	//
	// Try to use gdk_pixbuf_scale_simple() first; this function is the
	// industrial-strength power tool you can fall back to, if
	// gdk_pixbuf_scale_simple() isn't powerful enough.
	//
	// If the source rectangle overlaps the destination rectangle on the same
	// pixbuf, it will be overwritten during the scaling which results in
	// rendering artifacts.
	Scale(dest Pixbuf, destX int, destY int, destWidth int, destHeight int, offsetX float64, offsetY float64, scaleX float64, scaleY float64, interpType InterpType)
	// SetOption attaches a key/value pair as an option to a `GdkPixbuf`.
	//
	// If `key` already exists in the list of options attached to the `pixbuf`,
	// the new value is ignored and `FALSE` is returned.
	SetOption(key string, value string) bool
}

// pixbuf implements the Pixbuf class.
type pixbuf struct {
	gextras.Objector
	gio.Icon
}

var _ Pixbuf = (*pixbuf)(nil)

// WrapPixbuf wraps a GObject to the right type. It is
// primarily used internally.
func WrapPixbuf(obj *externglib.Object) Pixbuf {
	return pixbuf{
		Objector: obj,
		gio.Icon: gio.WrapIcon(obj),
	}
}

func marshalPixbuf(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPixbuf(obj), nil
}

// Composite creates a transformation of the source image @src by scaling by
// @scale_x and @scale_y then translating by @offset_x and @offset_y.
//
// This gives an image in the coordinates of the destination pixbuf. The
// rectangle (@dest_x, @dest_y, @dest_width, @dest_height) is then alpha
// blended onto the corresponding rectangle of the original destination
// image.
//
// When the destination rectangle contains parts not in the source image,
// the data at the edges of the source image is replicated to infinity.
//
// ! (composite.png)
func (s pixbuf) Composite(dest Pixbuf, destX int, destY int, destWidth int, destHeight int, offsetX float64, offsetY float64, scaleX float64, scaleY float64, interpType InterpType, overallAlpha int) {
	var _arg0 *C.GdkPixbuf     // out
	var _arg1 *C.GdkPixbuf     // out
	var _arg2 C.int            // out
	var _arg3 C.int            // out
	var _arg4 C.int            // out
	var _arg5 C.int            // out
	var _arg6 C.double         // out
	var _arg7 C.double         // out
	var _arg8 C.double         // out
	var _arg9 C.double         // out
	var _arg10 C.GdkInterpType // out
	var _arg11 C.int           // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(dest.Native()))
	_arg2 = C.int(destX)
	_arg3 = C.int(destY)
	_arg4 = C.int(destWidth)
	_arg5 = C.int(destHeight)
	_arg6 = C.double(offsetX)
	_arg7 = C.double(offsetY)
	_arg8 = C.double(scaleX)
	_arg9 = C.double(scaleY)
	_arg10 = (C.GdkInterpType)(interpType)
	_arg11 = C.int(overallAlpha)

	C.gdk_pixbuf_composite(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11)
}

// CompositeColor creates a transformation of the source image @src by
// scaling by @scale_x and @scale_y then translating by @offset_x and
// @offset_y, then alpha blends the rectangle (@dest_x ,@dest_y,
// @dest_width, @dest_height) of the resulting image with a checkboard of
// the colors @color1 and @color2 and renders it onto the destination image.
//
// If the source image has no alpha channel, and @overall_alpha is 255, a
// fast path is used which omits the alpha blending and just performs the
// scaling.
//
// See gdk_pixbuf_composite_color_simple() for a simpler variant of this
// function suitable for many tasks.
func (s pixbuf) CompositeColor(dest Pixbuf, destX int, destY int, destWidth int, destHeight int, offsetX float64, offsetY float64, scaleX float64, scaleY float64, interpType InterpType, overallAlpha int, checkX int, checkY int, checkSize int, color1 uint32, color2 uint32) {
	var _arg0 *C.GdkPixbuf     // out
	var _arg1 *C.GdkPixbuf     // out
	var _arg2 C.int            // out
	var _arg3 C.int            // out
	var _arg4 C.int            // out
	var _arg5 C.int            // out
	var _arg6 C.double         // out
	var _arg7 C.double         // out
	var _arg8 C.double         // out
	var _arg9 C.double         // out
	var _arg10 C.GdkInterpType // out
	var _arg11 C.int           // out
	var _arg12 C.int           // out
	var _arg13 C.int           // out
	var _arg14 C.int           // out
	var _arg15 C.guint32       // out
	var _arg16 C.guint32       // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(dest.Native()))
	_arg2 = C.int(destX)
	_arg3 = C.int(destY)
	_arg4 = C.int(destWidth)
	_arg5 = C.int(destHeight)
	_arg6 = C.double(offsetX)
	_arg7 = C.double(offsetY)
	_arg8 = C.double(scaleX)
	_arg9 = C.double(scaleY)
	_arg10 = (C.GdkInterpType)(interpType)
	_arg11 = C.int(overallAlpha)
	_arg12 = C.int(checkX)
	_arg13 = C.int(checkY)
	_arg14 = C.int(checkSize)
	_arg15 = C.guint32(color1)
	_arg16 = C.guint32(color2)

	C.gdk_pixbuf_composite_color(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11, _arg12, _arg13, _arg14, _arg15, _arg16)
}

// CopyArea copies a rectangular area from `src_pixbuf` to `dest_pixbuf`.
//
// Conversion of pixbuf formats is done automatically.
//
// If the source rectangle overlaps the destination rectangle on the same
// pixbuf, it will be overwritten during the copy operation. Therefore, you
// can not use this function to scroll a pixbuf.
func (s pixbuf) CopyArea(srcX int, srcY int, width int, height int, destPixbuf Pixbuf, destX int, destY int) {
	var _arg0 *C.GdkPixbuf // out
	var _arg1 C.int        // out
	var _arg2 C.int        // out
	var _arg3 C.int        // out
	var _arg4 C.int        // out
	var _arg5 *C.GdkPixbuf // out
	var _arg6 C.int        // out
	var _arg7 C.int        // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	_arg1 = C.int(srcX)
	_arg2 = C.int(srcY)
	_arg3 = C.int(width)
	_arg4 = C.int(height)
	_arg5 = (*C.GdkPixbuf)(unsafe.Pointer(destPixbuf.Native()))
	_arg6 = C.int(destX)
	_arg7 = C.int(destY)

	C.gdk_pixbuf_copy_area(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
}

// CopyOptions copies the key/value pair options attached to a `GdkPixbuf`
// to another `GdkPixbuf`.
//
// This is useful to keep original metadata after having manipulated a file.
// However be careful to remove metadata which you've already applied, such
// as the "orientation" option after rotating the image.
func (s pixbuf) CopyOptions(destPixbuf Pixbuf) bool {
	var _arg0 *C.GdkPixbuf // out
	var _arg1 *C.GdkPixbuf // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(destPixbuf.Native()))

	var _cret C.gboolean // in

	_cret = C.gdk_pixbuf_copy_options(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Fill clears a pixbuf to the given RGBA value, converting the RGBA value
// into the pixbuf's pixel format.
//
// The alpha component will be ignored if the pixbuf doesn't have an alpha
// channel.
func (p pixbuf) Fill(pixel uint32) {
	var _arg0 *C.GdkPixbuf // out
	var _arg1 C.guint32    // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))
	_arg1 = C.guint32(pixel)

	C.gdk_pixbuf_fill(_arg0, _arg1)
}

// BitsPerSample queries the number of bits per color sample in a pixbuf.
func (p pixbuf) BitsPerSample() int {
	var _arg0 *C.GdkPixbuf // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var _cret C.int // in

	_cret = C.gdk_pixbuf_get_bits_per_sample(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// ByteLength returns the length of the pixel data, in bytes.
func (p pixbuf) ByteLength() uint {
	var _arg0 *C.GdkPixbuf // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var _cret C.gsize // in

	_cret = C.gdk_pixbuf_get_byte_length(_arg0)

	var _gsize uint // out

	_gsize = (uint)(_cret)

	return _gsize
}

// HasAlpha queries whether a pixbuf has an alpha channel (opacity
// information).
func (p pixbuf) HasAlpha() bool {
	var _arg0 *C.GdkPixbuf // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var _cret C.gboolean // in

	_cret = C.gdk_pixbuf_get_has_alpha(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Height queries the height of a pixbuf.
func (p pixbuf) Height() int {
	var _arg0 *C.GdkPixbuf // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var _cret C.int // in

	_cret = C.gdk_pixbuf_get_height(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// NChannels queries the number of channels of a pixbuf.
func (p pixbuf) NChannels() int {
	var _arg0 *C.GdkPixbuf // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var _cret C.int // in

	_cret = C.gdk_pixbuf_get_n_channels(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Option looks up @key in the list of options that may have been attached
// to the @pixbuf when it was loaded, or that may have been attached by
// another function using gdk_pixbuf_set_option().
//
// For instance, the ANI loader provides "Title" and "Artist" options. The
// ICO, XBM, and XPM loaders provide "x_hot" and "y_hot" hot-spot options
// for cursor definitions. The PNG loader provides the tEXt ancillary chunk
// key/value pairs as options. Since 2.12, the TIFF and JPEG loaders return
// an "orientation" option string that corresponds to the embedded TIFF/Exif
// orientation tag (if present). Since 2.32, the TIFF loader sets the
// "multipage" option string to "yes" when a multi-page TIFF is loaded.
// Since 2.32 the JPEG and PNG loaders set "x-dpi" and "y-dpi" if the file
// contains image density information in dots per inch. Since 2.36.6, the
// JPEG loader sets the "comment" option with the comment EXIF tag.
func (p pixbuf) Option(key string) string {
	var _arg0 *C.GdkPixbuf // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret *C.gchar // in

	_cret = C.gdk_pixbuf_get_option(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// PixelsWithLength queries a pointer to the pixel data of a pixbuf.
//
// This function will cause an implicit copy of the pixbuf data if the
// pixbuf was created from read-only data.
//
// Please see the section on image data (#image-data) for information about
// how the pixel data is stored in memory.
func (p pixbuf) PixelsWithLength() []byte {
	var _arg0 *C.GdkPixbuf // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var _cret *C.guchar
	var _arg1 C.guint // in

	_cret = C.gdk_pixbuf_get_pixels_with_length(_arg0, &_arg1)

	var _guint8s []byte

	{
		src := unsafe.Slice(_cret, _arg1)
		_guint8s = make([]byte, _arg1)
		for i := 0; i < int(_arg1); i++ {
			_guint8s[i] = (byte)(src[i])
		}
	}

	return _guint8s
}

// Rowstride queries the rowstride of a pixbuf, which is the number of bytes
// between the start of a row and the start of the next row.
func (p pixbuf) Rowstride() int {
	var _arg0 *C.GdkPixbuf // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var _cret C.int // in

	_cret = C.gdk_pixbuf_get_rowstride(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Width queries the width of a pixbuf.
func (p pixbuf) Width() int {
	var _arg0 *C.GdkPixbuf // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var _cret C.int // in

	_cret = C.gdk_pixbuf_get_width(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// ReadPixels provides a read-only pointer to the raw pixel data.
//
// This function allows skipping the implicit copy that must be made if
// gdk_pixbuf_get_pixels() is called on a read-only pixbuf.
func (p pixbuf) ReadPixels() *byte {
	var _arg0 *C.GdkPixbuf // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var _cret *C.guint8 // in

	_cret = C.gdk_pixbuf_read_pixels(_arg0)

	var _guint8 *byte // out

	_guint8 = (*byte)(_cret)

	return _guint8
}

// RemoveOption removes the key/value pair option attached to a `GdkPixbuf`.
func (p pixbuf) RemoveOption(key string) bool {
	var _arg0 *C.GdkPixbuf // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret C.gboolean // in

	_cret = C.gdk_pixbuf_remove_option(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SaturateAndPixelate modifies saturation and optionally pixelates `src`,
// placing the result in `dest`.
//
// The `src` and `dest` pixbufs must have the same image format, size, and
// rowstride.
//
// The `src` and `dest` arguments may be the same pixbuf with no ill
// effects.
//
// If `saturation` is 1.0 then saturation is not changed. If it's less than
// 1.0, saturation is reduced (the image turns toward grayscale); if greater
// than 1.0, saturation is increased (the image gets more vivid colors).
//
// If `pixelate` is `TRUE`, then pixels are faded in a checkerboard pattern
// to create a pixelated image.
func (s pixbuf) SaturateAndPixelate(dest Pixbuf, saturation float32, pixelate bool) {
	var _arg0 *C.GdkPixbuf // out
	var _arg1 *C.GdkPixbuf // out
	var _arg2 C.gfloat     // out
	var _arg3 C.gboolean   // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(dest.Native()))
	_arg2 = C.gfloat(saturation)
	if pixelate {
		_arg3 = C.TRUE
	}

	C.gdk_pixbuf_saturate_and_pixelate(_arg0, _arg1, _arg2, _arg3)
}

// Scale creates a transformation of the source image @src by scaling by
// @scale_x and @scale_y then translating by @offset_x and @offset_y, then
// renders the rectangle (@dest_x, @dest_y, @dest_width, @dest_height) of
// the resulting image onto the destination image replacing the previous
// contents.
//
// Try to use gdk_pixbuf_scale_simple() first; this function is the
// industrial-strength power tool you can fall back to, if
// gdk_pixbuf_scale_simple() isn't powerful enough.
//
// If the source rectangle overlaps the destination rectangle on the same
// pixbuf, it will be overwritten during the scaling which results in
// rendering artifacts.
func (s pixbuf) Scale(dest Pixbuf, destX int, destY int, destWidth int, destHeight int, offsetX float64, offsetY float64, scaleX float64, scaleY float64, interpType InterpType) {
	var _arg0 *C.GdkPixbuf     // out
	var _arg1 *C.GdkPixbuf     // out
	var _arg2 C.int            // out
	var _arg3 C.int            // out
	var _arg4 C.int            // out
	var _arg5 C.int            // out
	var _arg6 C.double         // out
	var _arg7 C.double         // out
	var _arg8 C.double         // out
	var _arg9 C.double         // out
	var _arg10 C.GdkInterpType // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(dest.Native()))
	_arg2 = C.int(destX)
	_arg3 = C.int(destY)
	_arg4 = C.int(destWidth)
	_arg5 = C.int(destHeight)
	_arg6 = C.double(offsetX)
	_arg7 = C.double(offsetY)
	_arg8 = C.double(scaleX)
	_arg9 = C.double(scaleY)
	_arg10 = (C.GdkInterpType)(interpType)

	C.gdk_pixbuf_scale(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10)
}

// SetOption attaches a key/value pair as an option to a `GdkPixbuf`.
//
// If `key` already exists in the list of options attached to the `pixbuf`,
// the new value is ignored and `FALSE` is returned.
func (p pixbuf) SetOption(key string, value string) bool {
	var _arg0 *C.GdkPixbuf // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.gchar     // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg2))

	var _cret C.gboolean // in

	_cret = C.gdk_pixbuf_set_option(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}
