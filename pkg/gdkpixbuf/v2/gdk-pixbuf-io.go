// Code generated by girgen. DO NOT EDIT.

package gdkpixbuf

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/box"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gdk-pixbuf-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <gdk-pixbuf/gdk-pixbuf.h>
// #include <glib-object.h>
import "C"

// PixbufFormatFlags flags which allow a module to specify further details about
// the supported operations.
type PixbufFormatFlags int

const (
	// PixbufFormatFlagsWritable: the module can write out images in the format.
	PixbufFormatFlagsWritable PixbufFormatFlags = 0b1
	// PixbufFormatFlagsScalable: the image format is scalable
	PixbufFormatFlagsScalable PixbufFormatFlags = 0b10
	// PixbufFormatFlagsThreadsafe: the module is threadsafe. gdk-pixbuf ignores
	// modules that are not marked as threadsafe. (Since 2.28).
	PixbufFormatFlagsThreadsafe PixbufFormatFlags = 0b100
)

// PixbufModulePreparedFunc defines the type of the function that gets called
// once the initial setup of @pixbuf is done.
//
// PixbufLoader uses a function of this type to emit the "<link
// linkend="GdkPixbufLoader-area-prepared">area_prepared</link>" signal.
type PixbufModulePreparedFunc func(pixbuf *PixbufClass, anim *PixbufAnimationClass, userData interface{})

//export gotk4_PixbufModulePreparedFunc
func gotk4_PixbufModulePreparedFunc(arg0 *C.GdkPixbuf, arg1 *C.GdkPixbufAnimation, arg2 C.gpointer) {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var pixbuf *PixbufClass        // out
	var anim *PixbufAnimationClass // out
	var userData interface{}       // out

	pixbuf = (gextras.CastObject(externglib.Take(unsafe.Pointer(arg0)))).(*PixbufClass)
	anim = (gextras.CastObject(externglib.Take(unsafe.Pointer(arg1)))).(*PixbufAnimationClass)
	userData = box.Get(uintptr(arg2))

	fn := v.(PixbufModulePreparedFunc)
	fn(pixbuf, anim, userData)
}

// PixbufModuleSizeFunc defines the type of the function that gets called once
// the size of the loaded image is known.
//
// The function is expected to set @width and @height to the desired size to
// which the image should be scaled. If a module has no efficient way to achieve
// the desired scaling during the loading of the image, it may either ignore the
// size request, or only approximate it - gdk-pixbuf will then perform the
// required scaling on the completely loaded image.
//
// If the function sets @width or @height to zero, the module should interpret
// this as a hint that it will be closed soon and shouldn't allocate further
// resources. This convention is used to implement gdk_pixbuf_get_file_info()
// efficiently.
type PixbufModuleSizeFunc func(width *int, height *int, userData interface{})

//export gotk4_PixbufModuleSizeFunc
func gotk4_PixbufModuleSizeFunc(arg0 *C.gint, arg1 *C.gint, arg2 C.gpointer) {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var width *int           // out
	var height *int          // out
	var userData interface{} // out

	width = (*int)(unsafe.Pointer(arg0))
	height = (*int)(unsafe.Pointer(arg1))
	userData = box.Get(uintptr(arg2))

	fn := v.(PixbufModuleSizeFunc)
	fn(width, height, userData)
}

// PixbufModuleUpdatedFunc defines the type of the function that gets called
// every time a region of @pixbuf is updated.
//
// PixbufLoader uses a function of this type to emit the "<link
// linkend="GdkPixbufLoader-area-updated">area_updated</link>" signal.
type PixbufModuleUpdatedFunc func(pixbuf *PixbufClass, x int, y int, width int, height int, userData interface{})

//export gotk4_PixbufModuleUpdatedFunc
func gotk4_PixbufModuleUpdatedFunc(arg0 *C.GdkPixbuf, arg1 C.int, arg2 C.int, arg3 C.int, arg4 C.int, arg5 C.gpointer) {
	v := box.Get(uintptr(arg5))
	if v == nil {
		panic(`callback not found`)
	}

	var pixbuf *PixbufClass  // out
	var x int                // out
	var y int                // out
	var width int            // out
	var height int           // out
	var userData interface{} // out

	pixbuf = (gextras.CastObject(externglib.Take(unsafe.Pointer(arg0)))).(*PixbufClass)
	x = int(arg1)
	y = int(arg2)
	width = int(arg3)
	height = int(arg4)
	userData = box.Get(uintptr(arg5))

	fn := v.(PixbufModuleUpdatedFunc)
	fn(pixbuf, x, y, width, height, userData)
}
