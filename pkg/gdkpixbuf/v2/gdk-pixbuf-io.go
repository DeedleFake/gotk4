// Code generated by girgen. DO NOT EDIT.

package gdkpixbuf

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	"github.com/diamondburned/gotk4/internal/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gdk-pixbuf-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <stdbool.h>
// #include <gdk-pixbuf/gdk-pixbuf.h>
//
// extern void gotk4_PixbufModulePreparedFunc(GdkPixbuf* _0, GdkPixbufAnimation* _1, gpointer _2);
// extern void gotk4_PixbufModuleSizeFunc(gint* _0, gint* _1, gpointer _2);
// extern void gotk4_PixbufModuleUpdatedFunc(GdkPixbuf* _0, int _1, int _2, int _3, int _4, gpointer _5);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gdk_pixbuf_format_get_type()), F: marshalPixbufFormat},
	})
}

// PixbufFormatFlags flags which allow a module to specify further details about
// the supported operations.
type PixbufFormatFlags int

const (
	// PixbufFormatFlagsWritable: the module can write out images in the format.
	PixbufFormatFlagsWritable PixbufFormatFlags = 0b1
	// PixbufFormatFlagsScalable: the image format is scalable
	PixbufFormatFlagsScalable PixbufFormatFlags = 0b10
	// PixbufFormatFlagsThreadsafe: the module is threadsafe. gdk-pixbuf ignores
	// modules that are not marked as threadsafe. (Since 2.28).
	PixbufFormatFlagsThreadsafe PixbufFormatFlags = 0b100
)

// PixbufModulePreparedFunc defines the type of the function that gets called
// once the initial setup of @pixbuf is done.
//
// PixbufLoader uses a function of this type to emit the "<link
// linkend="GdkPixbufLoader-area-prepared">area_prepared</link>" signal.
type PixbufModulePreparedFunc func(pixbuf Pixbuf, anim PixbufAnimation)

//export gotk4_PixbufModulePreparedFunc
func gotk4_PixbufModulePreparedFunc(arg0 *C.GdkPixbuf, arg1 *C.GdkPixbufAnimation, arg2 C.gpointer) {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var pixbuf Pixbuf
	var anim PixbufAnimation

	pixbuf = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(Pixbuf)

	anim = gextras.CastObject(externglib.Take(unsafe.Pointer(arg1.Native()))).(PixbufAnimation)

	v.(PixbufModulePreparedFunc)(pixbuf, anim)
}

// PixbufModuleSizeFunc defines the type of the function that gets called once
// the size of the loaded image is known.
//
// The function is expected to set @width and @height to the desired size to
// which the image should be scaled. If a module has no efficient way to achieve
// the desired scaling during the loading of the image, it may either ignore the
// size request, or only approximate it - gdk-pixbuf will then perform the
// required scaling on the completely loaded image.
//
// If the function sets @width or @height to zero, the module should interpret
// this as a hint that it will be closed soon and shouldn't allocate further
// resources. This convention is used to implement gdk_pixbuf_get_file_info()
// efficiently.
type PixbufModuleSizeFunc func(width int, height int)

//export gotk4_PixbufModuleSizeFunc
func gotk4_PixbufModuleSizeFunc(arg0 *C.gint, arg1 *C.gint, arg2 C.gpointer) {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var width int
	var height int

	width = int(arg0)

	height = int(arg1)

	v.(PixbufModuleSizeFunc)(width, height)
}

// PixbufModuleUpdatedFunc defines the type of the function that gets called
// every time a region of @pixbuf is updated.
//
// PixbufLoader uses a function of this type to emit the "<link
// linkend="GdkPixbufLoader-area-updated">area_updated</link>" signal.
type PixbufModuleUpdatedFunc func(pixbuf Pixbuf, x int, y int, width int, height int)

//export gotk4_PixbufModuleUpdatedFunc
func gotk4_PixbufModuleUpdatedFunc(arg0 *C.GdkPixbuf, arg1 C.int, arg2 C.int, arg3 C.int, arg4 C.int, arg5 C.gpointer) {
	v := box.Get(uintptr(arg5))
	if v == nil {
		panic(`callback not found`)
	}

	var pixbuf Pixbuf
	var x int
	var y int
	var width int
	var height int

	pixbuf = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(Pixbuf)

	x = int(arg1)

	y = int(arg2)

	width = int(arg3)

	height = int(arg4)

	v.(PixbufModuleUpdatedFunc)(pixbuf, x, y, width, height)
}

// PixbufFormat: a `GdkPixbufFormat` contains information about the image format
// accepted by a module.
//
// Only modules should access the fields directly, applications should use the
// `gdk_pixbuf_format_*` family of functions.
type PixbufFormat struct {
	native C.GdkPixbufFormat
}

// WrapPixbufFormat wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPixbufFormat(ptr unsafe.Pointer) *PixbufFormat {
	if ptr == nil {
		return nil
	}

	return (*PixbufFormat)(ptr)
}

func marshalPixbufFormat(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapPixbufFormat(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (p *PixbufFormat) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

// Signature gets the field inside the struct.
func (p *PixbufFormat) Signature() *PixbufModulePattern {
	var ret *PixbufModulePattern
	{
		ret = WrapPixbufModulePattern(unsafe.Pointer(p.native.signature))
	}
	return ret
}

// Domain gets the field inside the struct.
func (p *PixbufFormat) Domain() string {
	var ret string
	ret = C.GoString(p.native.domain)
	return ret
}

// Flags gets the field inside the struct.
func (p *PixbufFormat) Flags() uint32 {
	var ret uint32
	ret = uint32(p.native.flags)
	return ret
}

// Disabled gets the field inside the struct.
func (p *PixbufFormat) Disabled() bool {
	var ret bool
	ret = C.bool(p.native.disabled) != 0
	return ret
}

// Copy creates a copy of `format`.
func (f *PixbufFormat) Copy() *PixbufFormat {
	var arg0 *C.GdkPixbufFormat

	arg0 = (*C.GdkPixbufFormat)(f.Native())

	ret := C.gdk_pixbuf_format_copy(arg0)

	var ret0 *PixbufFormat

	{
		ret0 = WrapPixbufFormat(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *PixbufFormat) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Free frees the resources allocated when copying a `GdkPixbufFormat` using
// gdk_pixbuf_format_copy()
func (f *PixbufFormat) Free() {
	var arg0 *C.GdkPixbufFormat

	arg0 = (*C.GdkPixbufFormat)(f.Native())

	C.gdk_pixbuf_format_free(arg0)
}

// Description returns a description of the format.
func (f *PixbufFormat) Description() string {
	var arg0 *C.GdkPixbufFormat

	arg0 = (*C.GdkPixbufFormat)(f.Native())

	ret := C.gdk_pixbuf_format_get_description(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Extensions returns the filename extensions typically used for files in the
// given format.
func (f *PixbufFormat) Extensions() []string {
	var arg0 *C.GdkPixbufFormat

	arg0 = (*C.GdkPixbufFormat)(f.Native())

	ret := C.gdk_pixbuf_format_get_extensions(arg0)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// License returns information about the license of the image loader for the
// format.
//
// The returned string should be a shorthand for a well known license, e.g.
// "LGPL", "GPL", "QPL", "GPL/QPL", or "other" to indicate some other license.
func (f *PixbufFormat) License() string {
	var arg0 *C.GdkPixbufFormat

	arg0 = (*C.GdkPixbufFormat)(f.Native())

	ret := C.gdk_pixbuf_format_get_license(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// MIMETypes returns the mime types supported by the format.
func (f *PixbufFormat) MIMETypes() []string {
	var arg0 *C.GdkPixbufFormat

	arg0 = (*C.GdkPixbufFormat)(f.Native())

	ret := C.gdk_pixbuf_format_get_mime_types(arg0)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// Name returns the name of the format.
func (f *PixbufFormat) Name() string {
	var arg0 *C.GdkPixbufFormat

	arg0 = (*C.GdkPixbufFormat)(f.Native())

	ret := C.gdk_pixbuf_format_get_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// IsDisabled returns whether this image format is disabled.
//
// See gdk_pixbuf_format_set_disabled().
func (f *PixbufFormat) IsDisabled() bool {
	var arg0 *C.GdkPixbufFormat

	arg0 = (*C.GdkPixbufFormat)(f.Native())

	ret := C.gdk_pixbuf_format_is_disabled(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// IsSaveOptionSupported returns `TRUE` if the save option specified by
// @option_key is supported when saving a pixbuf using the module implementing
// @format.
//
// See gdk_pixbuf_save() for more information about option keys.
func (f *PixbufFormat) IsSaveOptionSupported(optionKey string) bool {
	var arg0 *C.GdkPixbufFormat
	var arg1 *C.gchar

	arg0 = (*C.GdkPixbufFormat)(f.Native())
	arg1 = (*C.gchar)(C.CString(optionKey))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gdk_pixbuf_format_is_save_option_supported(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// IsScalable returns whether this image format is scalable.
//
// If a file is in a scalable format, it is preferable to load it at the desired
// size, rather than loading it at the default size and scaling the resulting
// pixbuf to the desired size.
func (f *PixbufFormat) IsScalable() bool {
	var arg0 *C.GdkPixbufFormat

	arg0 = (*C.GdkPixbufFormat)(f.Native())

	ret := C.gdk_pixbuf_format_is_scalable(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// IsWritable returns whether pixbufs can be saved in the given format.
func (f *PixbufFormat) IsWritable() bool {
	var arg0 *C.GdkPixbufFormat

	arg0 = (*C.GdkPixbufFormat)(f.Native())

	ret := C.gdk_pixbuf_format_is_writable(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// SetDisabled disables or enables an image format.
//
// If a format is disabled, GdkPixbuf won't use the image loader for this format
// to load images.
//
// Applications can use this to avoid using image loaders with an inappropriate
// license, see gdk_pixbuf_format_get_license().
func (f *PixbufFormat) SetDisabled(disabled bool) {
	var arg0 *C.GdkPixbufFormat
	var arg1 C.gboolean

	arg0 = (*C.GdkPixbufFormat)(f.Native())
	if disabled {
		arg1 = C.TRUE
	}

	C.gdk_pixbuf_format_set_disabled(arg0, arg1)
}

// PixbufModulePattern: the signature prefix for a module.
//
// The signature of a module is a set of prefixes. Prefixes are encoded as pairs
// of ordinary strings, where the second string, called the mask, if not `NULL`,
// must be of the same length as the first one and may contain ' ', '!', 'x',
// 'z', and 'n' to indicate bytes that must be matched, not matched,
// "don't-care"-bytes, zeros and non-zeros, respectively.
//
// Each prefix has an associated integer that describes the relevance of the
// prefix, with 0 meaning a mismatch and 100 a "perfect match".
//
// Starting with gdk-pixbuf 2.8, the first byte of the mask may be '*',
// indicating an unanchored pattern that matches not only at the beginning, but
// also in the middle. Versions prior to 2.8 will interpret the '*' like an 'x'.
//
// The signature of a module is stored as an array of `GdkPixbufModulePatterns`.
// The array is terminated by a pattern where the `prefix` is `NULL`.
//
// “`c GdkPixbufModulePattern *signature[] = { { "abcdx", " !x z", 100 }, {
// "bla", NULL, 90 }, { NULL, NULL, 0 } }; “`
//
// In the example above, the signature matches e.g. "auud\0" with relevance 100,
// and "blau" with relevance 90.
type PixbufModulePattern struct {
	native C.GdkPixbufModulePattern
}

// WrapPixbufModulePattern wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPixbufModulePattern(ptr unsafe.Pointer) *PixbufModulePattern {
	if ptr == nil {
		return nil
	}

	return (*PixbufModulePattern)(ptr)
}

func marshalPixbufModulePattern(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapPixbufModulePattern(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (p *PixbufModulePattern) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

// Prefix gets the field inside the struct.
func (p *PixbufModulePattern) Prefix() string {
	var ret string
	ret = C.GoString(p.native.prefix)
	return ret
}

// Mask gets the field inside the struct.
func (p *PixbufModulePattern) Mask() string {
	var ret string
	ret = C.GoString(p.native.mask)
	return ret
}

// Relevance gets the field inside the struct.
func (p *PixbufModulePattern) Relevance() int {
	var ret int
	ret = int(p.native.relevance)
	return ret
}
