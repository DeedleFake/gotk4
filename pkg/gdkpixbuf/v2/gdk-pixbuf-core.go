// Code generated by girgen. DO NOT EDIT.

package gdkpixbuf

import (
	"runtime/cgo"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gdk-pixbuf-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <gdk-pixbuf/gdk-pixbuf.h>
// #include <glib-object.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gdk_colorspace_get_type()), F: marshalColorspace},
		{T: externglib.Type(C.gdk_pixbuf_alpha_mode_get_type()), F: marshalPixbufAlphaMode},
		{T: externglib.Type(C.gdk_pixbuf_error_get_type()), F: marshalPixbufError},
	})
}

// Colorspace: this enumeration defines the color spaces that are supported by
// the gdk-pixbuf library.
//
// Currently only RGB is supported.
type Colorspace int

const (
	// RGB indicates a red/green/blue additive color space.
	ColorspaceRGB Colorspace = iota
)

func marshalColorspace(p uintptr) (interface{}, error) {
	return Colorspace(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PixbufAlphaMode: control the alpha channel for drawables.
//
// These values can be passed to gdk_pixbuf_xlib_render_to_drawable_alpha() in
// gdk-pixbuf-xlib to control how the alpha channel of an image should be
// handled.
//
// This function can create a bilevel clipping mask (black and white) and use it
// while painting the image.
//
// In the future, when the X Window System gets an alpha channel extension, it
// will be possible to do full alpha compositing onto arbitrary drawables. For
// now both cases fall back to a bilevel clipping mask.
//
// Deprecated: There is no user of GdkPixbufAlphaMode in GdkPixbuf, and the Xlib
// utility functions have been split out to their own library, gdk-pixbuf-xlib.
type PixbufAlphaMode int

const (
	// Bilevel clipping mask (black and white) will be created and used to draw
	// the image. Pixels below 0.5 opacity will be considered fully transparent,
	// and all others will be considered fully opaque.
	PixbufAlphaModeBilevel PixbufAlphaMode = iota
	// Full: for now falls back to K_PIXBUF_ALPHA_BILEVEL. In the future it will
	// do full alpha compositing.
	PixbufAlphaModeFull
)

func marshalPixbufAlphaMode(p uintptr) (interface{}, error) {
	return PixbufAlphaMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PixbufError: error code in the `GDK_PIXBUF_ERROR` domain.
//
// Many gdk-pixbuf operations can cause errors in this domain, or in the
// `G_FILE_ERROR` domain.
type PixbufError int

const (
	// CorruptImage: image file was broken somehow.
	PixbufErrorCorruptImage PixbufError = iota
	// InsufficientMemory: not enough memory.
	PixbufErrorInsufficientMemory
	// BadOption: bad option was passed to a pixbuf save module.
	PixbufErrorBadOption
	// UnknownType: unknown image type.
	PixbufErrorUnknownType
	// UnsupportedOperation: don't know how to perform the given operation on
	// the type of image at hand.
	PixbufErrorUnsupportedOperation
	// Failed: generic failure code, something went wrong.
	PixbufErrorFailed
	// IncompleteAnimation: only part of the animation was loaded.
	PixbufErrorIncompleteAnimation
)

func marshalPixbufError(p uintptr) (interface{}, error) {
	return PixbufError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PixbufSaveFunc: save functions used by
// [method@GdkPixbuf.Pixbuf.save_to_callback].
//
// This function is called once for each block of bytes that is "written" by
// `gdk_pixbuf_save_to_callback()`.
//
// If successful it should return `TRUE`; if an error occurs it should set
// `error` and return `FALSE`, in which case `gdk_pixbuf_save_to_callback()`
// will fail with the same error.
type PixbufSaveFunc func(buf []byte, data cgo.Handle) (err error, ok bool)

//export gotk4_PixbufSaveFunc
func gotk4_PixbufSaveFunc(arg0 *C.gchar, arg1 C.gsize, arg2 **C.GError, arg3 C.gpointer) (cret C.gboolean) {
	v := gbox.Get(uintptr(arg3))
	if v == nil {
		panic(`callback not found`)
	}

	var buf []byte
	var data cgo.Handle // out

	defer C.free(unsafe.Pointer(arg0))
	buf = make([]byte, arg1)
	copy(buf, unsafe.Slice((*byte)(unsafe.Pointer(arg0)), arg1))
	data = (cgo.Handle)(unsafe.Pointer(arg3))

	fn := v.(PixbufSaveFunc)
	err, ok := fn(buf, data)

	*arg2 = (*C.GError)(gerror.New(err))
	if ok {
		cret = C.TRUE
	}

	return cret
}

// PixbufCalculateRowstride calculates the rowstride that an image created with
// those values would have.
//
// This function is useful for front-ends and backends that want to check image
// values without needing to create a `GdkPixbuf`.
func PixbufCalculateRowstride(colorspace Colorspace, hasAlpha bool, bitsPerSample int, width int, height int) int {
	var _arg1 C.GdkColorspace // out
	var _arg2 C.gboolean      // out
	var _arg3 C.int           // out
	var _arg4 C.int           // out
	var _arg5 C.int           // out
	var _cret C.gint          // in

	_arg1 = C.GdkColorspace(colorspace)
	if hasAlpha {
		_arg2 = C.TRUE
	}
	_arg3 = C.int(bitsPerSample)
	_arg4 = C.int(width)
	_arg5 = C.int(height)

	_cret = C.gdk_pixbuf_calculate_rowstride(_arg1, _arg2, _arg3, _arg4, _arg5)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// PixbufSaveToStreamFinish finishes an asynchronous pixbuf save operation
// started with gdk_pixbuf_save_to_stream_async().
func PixbufSaveToStreamFinish(asyncResult gio.AsyncResulter) error {
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer((asyncResult).(gextras.Nativer).Native()))

	C.gdk_pixbuf_save_to_stream_finish(_arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}
