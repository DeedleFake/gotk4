// Code generated by girgen. DO NOT EDIT.

package gdkpixbuf

import (
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gdk-pixbuf-2.0 glib-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gdk-pixbuf/gdk-pixbuf.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gdk_colorspace_get_type()), F: marshalColorspace},
		{T: externglib.Type(C.gdk_interp_type_get_type()), F: marshalInterpType},
		{T: externglib.Type(C.gdk_pixbuf_alpha_mode_get_type()), F: marshalPixbufAlphaMode},
		{T: externglib.Type(C.gdk_pixbuf_error_get_type()), F: marshalPixbufError},
		{T: externglib.Type(C.gdk_pixbuf_rotation_get_type()), F: marshalPixbufRotation},
		{T: externglib.Type(C.gdk_pixbuf_get_type()), F: marshalPixbuf},
		{T: externglib.Type(C.gdk_pixbuf_non_anim_get_type()), F: marshalPixbufNonAnim},
		{T: externglib.Type(C.gdk_pixbuf_simple_anim_iter_get_type()), F: marshalPixbufSimpleAnimIter},
	})
}

// Colorspace: this enumeration defines the color spaces that are supported by
// the gdk-pixbuf library.
//
// Currently only RGB is supported.
type Colorspace int

const (
	// ColorspaceRGB indicates a red/green/blue additive color space.
	ColorspaceRGB Colorspace = 0
)

func marshalColorspace(p uintptr) (interface{}, error) {
	return Colorspace(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// InterpType: interpolation modes for scaling functions.
//
// The `GDK_INTERP_NEAREST` mode is the fastest scaling method, but has horrible
// quality when scaling down; `GDK_INTERP_BILINEAR` is the best choice if you
// aren't sure what to choose, it has a good speed/quality balance.
//
// **Note**: Cubic filtering is missing from the list; hyperbolic interpolation
// is just as fast and results in higher quality.
type InterpType int

const (
	// InterpTypeNearest: nearest neighbor sampling; this is the fastest and
	// lowest quality mode. Quality is normally unacceptable when scaling down,
	// but may be OK when scaling up.
	InterpTypeNearest InterpType = 0
	// InterpTypeTiles: this is an accurate simulation of the PostScript image
	// operator without any interpolation enabled. Each pixel is rendered as a
	// tiny parallelogram of solid color, the edges of which are implemented
	// with antialiasing. It resembles nearest neighbor for enlargement, and
	// bilinear for reduction.
	InterpTypeTiles InterpType = 1
	// InterpTypeBilinear: best quality/speed balance; use this mode by default.
	// Bilinear interpolation. For enlargement, it is equivalent to
	// point-sampling the ideal bilinear-interpolated image. For reduction, it
	// is equivalent to laying down small tiles and integrating over the
	// coverage area.
	InterpTypeBilinear InterpType = 2
	// InterpTypeHyper: this is the slowest and highest quality reconstruction
	// function. It is derived from the hyperbolic filters in Wolberg's "Digital
	// Image Warping", and is formally defined as the hyperbolic-filter sampling
	// the ideal hyperbolic-filter interpolated image (the filter is designed to
	// be idempotent for 1:1 pixel mapping). **Deprecated**: this interpolation
	// filter is deprecated, as in reality it has a lower quality than the
	// @GDK_INTERP_BILINEAR filter (Since: 2.38)
	InterpTypeHyper InterpType = 3
)

func marshalInterpType(p uintptr) (interface{}, error) {
	return InterpType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PixbufAlphaMode: control the alpha channel for drawables.
//
// These values can be passed to gdk_pixbuf_xlib_render_to_drawable_alpha() in
// gdk-pixbuf-xlib to control how the alpha channel of an image should be
// handled.
//
// This function can create a bilevel clipping mask (black and white) and use it
// while painting the image.
//
// In the future, when the X Window System gets an alpha channel extension, it
// will be possible to do full alpha compositing onto arbitrary drawables. For
// now both cases fall back to a bilevel clipping mask.
type PixbufAlphaMode int

const (
	// PixbufAlphaModeBilevel: a bilevel clipping mask (black and white) will be
	// created and used to draw the image. Pixels below 0.5 opacity will be
	// considered fully transparent, and all others will be considered fully
	// opaque.
	PixbufAlphaModeBilevel PixbufAlphaMode = 0
	// PixbufAlphaModeFull: for now falls back to K_PIXBUF_ALPHA_BILEVEL. In the
	// future it will do full alpha compositing.
	PixbufAlphaModeFull PixbufAlphaMode = 1
)

func marshalPixbufAlphaMode(p uintptr) (interface{}, error) {
	return PixbufAlphaMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PixbufError: an error code in the `GDK_PIXBUF_ERROR` domain.
//
// Many gdk-pixbuf operations can cause errors in this domain, or in the
// `G_FILE_ERROR` domain.
type PixbufError int

const (
	// PixbufErrorCorruptImage: an image file was broken somehow.
	PixbufErrorCorruptImage PixbufError = 0
	// PixbufErrorInsufficientMemory: not enough memory.
	PixbufErrorInsufficientMemory PixbufError = 1
	// PixbufErrorBadOption: a bad option was passed to a pixbuf save module.
	PixbufErrorBadOption PixbufError = 2
	// PixbufErrorUnknownType: unknown image type.
	PixbufErrorUnknownType PixbufError = 3
	// PixbufErrorUnsupportedOperation: don't know how to perform the given
	// operation on the type of image at hand.
	PixbufErrorUnsupportedOperation PixbufError = 4
	// PixbufErrorFailed: generic failure code, something went wrong.
	PixbufErrorFailed PixbufError = 5
	// PixbufErrorIncompleteAnimation: only part of the animation was loaded.
	PixbufErrorIncompleteAnimation PixbufError = 6
)

func marshalPixbufError(p uintptr) (interface{}, error) {
	return PixbufError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PixbufRotation: the possible rotations which can be passed to
// gdk_pixbuf_rotate_simple().
//
// To make them easier to use, their numerical values are the actual degrees.
type PixbufRotation int

const (
	// PixbufRotationNone: no rotation.
	PixbufRotationNone PixbufRotation = 0
	// PixbufRotationCounterclockwise: rotate by 90 degrees.
	PixbufRotationCounterclockwise PixbufRotation = 90
	// PixbufRotationUpsidedown: rotate by 180 degrees.
	PixbufRotationUpsidedown PixbufRotation = 180
	// PixbufRotationClockwise: rotate by 270 degrees.
	PixbufRotationClockwise PixbufRotation = 270
)

func marshalPixbufRotation(p uintptr) (interface{}, error) {
	return PixbufRotation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Pixbuf: a pixel buffer.
//
// `GdkPixbuf` contains information about an image's pixel data, its color
// space, bits per sample, width and height, and the rowstride (the number of
// bytes between the start of one row and the start of the next).
//
// Creating new `GdkPixbuf`
//
// The most basic way to create a pixbuf is to wrap an existing pixel buffer
// with a [class@GdkPixbuf.Pixbuf] instance. You can use the
// [`ctor@GdkPixbuf.Pixbuf.new_from_data`] function to do this.
//
// Every time you create a new `GdkPixbuf` instance for some data, you will need
// to specify the destroy notification function that will be called when the
// data buffer needs to be freed; this will happen when a `GdkPixbuf` is
// finalized by the reference counting functions. If you have a chunk of static
// data compiled into your application, you can pass in `NULL` as the destroy
// notification function so that the data will not be freed.
//
// The [`ctor@GdkPixbuf.Pixbuf.new`] constructor function can be used as a
// convenience to create a pixbuf with an empty buffer; this is equivalent to
// allocating a data buffer using `malloc()` and then wrapping it with
// `gdk_pixbuf_new_from_data()`. The `gdk_pixbuf_new()` function will compute an
// optimal rowstride so that rendering can be performed with an efficient
// algorithm.
//
// As a special case, you can use the
// [`ctor@GdkPixbuf.Pixbuf.new_from_xpm_data`] function to create a pixbuf from
// inline XPM image data.
//
// You can also copy an existing pixbuf with the [method@Pixbuf.copy] function.
// This is not the same as just acquiring a reference to the old pixbuf
// instance: the copy function will actually duplicate the pixel data in memory
// and create a new [class@Pixbuf] instance for it.
//
//
// Reference counting
//
// `GdkPixbuf` structures are reference counted. This means that an application
// can share a single pixbuf among many parts of the code. When a piece of the
// program needs to use a pixbuf, it should acquire a reference to it by calling
// `g_object_ref()`; when it no longer needs the pixbuf, it should release the
// reference it acquired by calling `g_object_unref()`. The resources associated
// with a `GdkPixbuf` will be freed when its reference count drops to zero.
// Newly-created `GdkPixbuf` instances start with a reference count of one.
//
//
// Image Data
//
// Image data in a pixbuf is stored in memory in an uncompressed, packed format.
// Rows in the image are stored top to bottom, and in each row pixels are stored
// from left to right.
//
// There may be padding at the end of a row.
//
// The "rowstride" value of a pixbuf, as returned by
// [`method@GdkPixbuf.Pixbuf.get_rowstride`], indicates the number of bytes
// between rows.
//
// **NOTE**: If you are copying raw pixbuf data with `memcpy()` note that the
// last row in the pixbuf may not be as wide as the full rowstride, but rather
// just as wide as the pixel data needs to be; that is: it is unsafe to do
// `memcpy (dest, pixels, rowstride * height)` to copy a whole pixbuf. Use
// [method@GdkPixbuf.Pixbuf.copy] instead, or compute the width in bytes of the
// last row as:
//
// “`c last_row = width * ((n_channels * bits_per_sample + 7) / 8); “`
//
// The same rule applies when iterating over each row of a `GdkPixbuf` pixels
// array.
//
// The following code illustrates a simple `put_pixel()` function for RGB
// pixbufs with 8 bits per channel with an alpha channel.
//
// “`c static void put_pixel (GdkPixbuf *pixbuf, int x, int y, guchar red,
// guchar green, guchar blue, guchar alpha) { int n_channels =
// gdk_pixbuf_get_n_channels (pixbuf);
//
//    // Ensure that the pixbuf is valid
//    g_assert (gdk_pixbuf_get_colorspace (pixbuf) == GDK_COLORSPACE_RGB);
//    g_assert (gdk_pixbuf_get_bits_per_sample (pixbuf) == 8);
//    g_assert (gdk_pixbuf_get_has_alpha (pixbuf));
//    g_assert (n_channels == 4);
//
//    int width = gdk_pixbuf_get_width (pixbuf);
//    int height = gdk_pixbuf_get_height (pixbuf);
//
//    // Ensure that the coordinates are in a valid range
//    g_assert (x >= 0 && x < width);
//    g_assert (y >= 0 && y < height);
//
//    int rowstride = gdk_pixbuf_get_rowstride (pixbuf);
//
//    // The pixel buffer in the GdkPixbuf instance
//    guchar *pixels = gdk_pixbuf_get_pixels (pixbuf);
//
//    // The pixel we wish to modify
//    guchar *p = pixels + y * rowstride + x * n_channels;
//    p[0] = red;
//    p[1] = green;
//    p[2] = blue;
//    p[3] = alpha;
//
// } “`
//
//
// Loading images
//
// The `GdkPixBuf` class provides a simple mechanism for loading an image from a
// file in synchronous and asynchronous fashion.
//
// For GUI applications, it is recommended to use the asynchronous stream API to
// avoid blocking the control flow of the application.
//
// Additionally, `GdkPixbuf` provides the [class@GdkPixbuf.PixbufLoader`] API
// for progressive image loading.
//
//
// Saving images
//
// The `GdkPixbuf` class provides methods for saving image data in a number of
// file formats. The formatted data can be written to a file or to a memory
// buffer. `GdkPixbuf` can also call a user-defined callback on the data, which
// allows to e.g. write the image to a socket or store it in a database.
type Pixbuf interface {
	gextras.Objector
	gio.Icon

	// Composite creates a transformation of the source image @src by scaling by
	// @scale_x and @scale_y then translating by @offset_x and @offset_y.
	//
	// This gives an image in the coordinates of the destination pixbuf. The
	// rectangle (@dest_x, @dest_y, @dest_width, @dest_height) is then alpha
	// blended onto the corresponding rectangle of the original destination
	// image.
	//
	// When the destination rectangle contains parts not in the source image,
	// the data at the edges of the source image is replicated to infinity.
	//
	// ! (composite.png)
	Composite(dest Pixbuf, destX int, destY int, destWidth int, destHeight int, offsetX float64, offsetY float64, scaleX float64, scaleY float64, interpType InterpType, overallAlpha int)
	// CompositeColor creates a transformation of the source image @src by
	// scaling by @scale_x and @scale_y then translating by @offset_x and
	// @offset_y, then alpha blends the rectangle (@dest_x ,@dest_y,
	// @dest_width, @dest_height) of the resulting image with a checkboard of
	// the colors @color1 and @color2 and renders it onto the destination image.
	//
	// If the source image has no alpha channel, and @overall_alpha is 255, a
	// fast path is used which omits the alpha blending and just performs the
	// scaling.
	//
	// See gdk_pixbuf_composite_color_simple() for a simpler variant of this
	// function suitable for many tasks.
	CompositeColor(dest Pixbuf, destX int, destY int, destWidth int, destHeight int, offsetX float64, offsetY float64, scaleX float64, scaleY float64, interpType InterpType, overallAlpha int, checkX int, checkY int, checkSize int, color1 uint32, color2 uint32)
	// CopyArea copies a rectangular area from `src_pixbuf` to `dest_pixbuf`.
	//
	// Conversion of pixbuf formats is done automatically.
	//
	// If the source rectangle overlaps the destination rectangle on the same
	// pixbuf, it will be overwritten during the copy operation. Therefore, you
	// can not use this function to scroll a pixbuf.
	CopyArea(srcX int, srcY int, width int, height int, destPixbuf Pixbuf, destX int, destY int)
	// CopyOptions copies the key/value pair options attached to a `GdkPixbuf`
	// to another `GdkPixbuf`.
	//
	// This is useful to keep original metadata after having manipulated a file.
	// However be careful to remove metadata which you've already applied, such
	// as the "orientation" option after rotating the image.
	CopyOptions(destPixbuf Pixbuf) bool
	// Fill clears a pixbuf to the given RGBA value, converting the RGBA value
	// into the pixbuf's pixel format.
	//
	// The alpha component will be ignored if the pixbuf doesn't have an alpha
	// channel.
	Fill(pixel uint32)
	// BitsPerSample queries the number of bits per color sample in a pixbuf.
	BitsPerSample() int
	// ByteLength returns the length of the pixel data, in bytes.
	ByteLength() uint
	// HasAlpha queries whether a pixbuf has an alpha channel (opacity
	// information).
	HasAlpha() bool
	// Height queries the height of a pixbuf.
	Height() int
	// NChannels queries the number of channels of a pixbuf.
	NChannels() int
	// Option looks up @key in the list of options that may have been attached
	// to the @pixbuf when it was loaded, or that may have been attached by
	// another function using gdk_pixbuf_set_option().
	//
	// For instance, the ANI loader provides "Title" and "Artist" options. The
	// ICO, XBM, and XPM loaders provide "x_hot" and "y_hot" hot-spot options
	// for cursor definitions. The PNG loader provides the tEXt ancillary chunk
	// key/value pairs as options. Since 2.12, the TIFF and JPEG loaders return
	// an "orientation" option string that corresponds to the embedded TIFF/Exif
	// orientation tag (if present). Since 2.32, the TIFF loader sets the
	// "multipage" option string to "yes" when a multi-page TIFF is loaded.
	// Since 2.32 the JPEG and PNG loaders set "x-dpi" and "y-dpi" if the file
	// contains image density information in dots per inch. Since 2.36.6, the
	// JPEG loader sets the "comment" option with the comment EXIF tag.
	Option(key string) string
	// PixelsWithLength queries a pointer to the pixel data of a pixbuf.
	//
	// This function will cause an implicit copy of the pixbuf data if the
	// pixbuf was created from read-only data.
	//
	// Please see the section on image data (#image-data) for information about
	// how the pixel data is stored in memory.
	PixelsWithLength() []byte
	// Rowstride queries the rowstride of a pixbuf, which is the number of bytes
	// between the start of a row and the start of the next row.
	Rowstride() int
	// Width queries the width of a pixbuf.
	Width() int
	// ReadPixels provides a read-only pointer to the raw pixel data.
	//
	// This function allows skipping the implicit copy that must be made if
	// gdk_pixbuf_get_pixels() is called on a read-only pixbuf.
	ReadPixels() *byte
	// RemoveOption removes the key/value pair option attached to a `GdkPixbuf`.
	RemoveOption(key string) bool
	// SaturateAndPixelate modifies saturation and optionally pixelates `src`,
	// placing the result in `dest`.
	//
	// The `src` and `dest` pixbufs must have the same image format, size, and
	// rowstride.
	//
	// The `src` and `dest` arguments may be the same pixbuf with no ill
	// effects.
	//
	// If `saturation` is 1.0 then saturation is not changed. If it's less than
	// 1.0, saturation is reduced (the image turns toward grayscale); if greater
	// than 1.0, saturation is increased (the image gets more vivid colors).
	//
	// If `pixelate` is `TRUE`, then pixels are faded in a checkerboard pattern
	// to create a pixelated image.
	SaturateAndPixelate(dest Pixbuf, saturation float32, pixelate bool)
	// SaveToBufferv: vector version of `gdk_pixbuf_save_to_buffer()`.
	//
	// Saves pixbuf to a new buffer in format @type, which is currently "jpeg",
	// "tiff", "png", "ico" or "bmp".
	//
	// See [method@GdkPixbuf.Pixbuf.save_to_buffer] for more details.
	SaveToBufferv(typ string, optionKeys []string, optionValues []string) ([]byte, error)
	// SaveToCallbackv: vector version of `gdk_pixbuf_save_to_callback()`.
	//
	// Saves pixbuf to a callback in format @type, which is currently "jpeg",
	// "png", "tiff", "ico" or "bmp".
	//
	// If @error is set, `FALSE` will be returned.
	//
	// See [method@GdkPixbuf.Pixbuf.save_to_callback] for more details.
	SaveToCallbackv(saveFunc PixbufSaveFunc, typ string, optionKeys []string, optionValues []string) error
	// SaveToStreamv saves `pixbuf` to an output stream.
	//
	// Supported file formats are currently "jpeg", "tiff", "png", "ico" or
	// "bmp".
	//
	// See [method@GdkPixbuf.Pixbuf.save_to_stream] for more details.
	SaveToStreamv(stream gio.OutputStream, typ string, optionKeys []string, optionValues []string, cancellable gio.Cancellable) error
	// SaveToStreamvAsync saves `pixbuf` to an output stream asynchronously.
	//
	// For more details see gdk_pixbuf_save_to_streamv(), which is the
	// synchronous version of this function.
	//
	// When the operation is finished, `callback` will be called in the main
	// thread.
	//
	// You can then call gdk_pixbuf_save_to_stream_finish() to get the result of
	// the operation.
	SaveToStreamvAsync(stream gio.OutputStream, typ string, optionKeys []string, optionValues []string, cancellable gio.Cancellable, callback gio.AsyncReadyCallback)
	// Savev: vector version of `gdk_pixbuf_save()`.
	//
	// Saves pixbuf to a file in `type`, which is currently "jpeg", "png",
	// "tiff", "ico" or "bmp".
	//
	// If @error is set, `FALSE` will be returned.
	//
	// See [method@GdkPixbuf.Pixbuf.save] for more details.
	Savev(filename *string, typ string, optionKeys []string, optionValues []string) error
	// Scale creates a transformation of the source image @src by scaling by
	// @scale_x and @scale_y then translating by @offset_x and @offset_y, then
	// renders the rectangle (@dest_x, @dest_y, @dest_width, @dest_height) of
	// the resulting image onto the destination image replacing the previous
	// contents.
	//
	// Try to use gdk_pixbuf_scale_simple() first; this function is the
	// industrial-strength power tool you can fall back to, if
	// gdk_pixbuf_scale_simple() isn't powerful enough.
	//
	// If the source rectangle overlaps the destination rectangle on the same
	// pixbuf, it will be overwritten during the scaling which results in
	// rendering artifacts.
	Scale(dest Pixbuf, destX int, destY int, destWidth int, destHeight int, offsetX float64, offsetY float64, scaleX float64, scaleY float64, interpType InterpType)
	// SetOption attaches a key/value pair as an option to a `GdkPixbuf`.
	//
	// If `key` already exists in the list of options attached to the `pixbuf`,
	// the new value is ignored and `FALSE` is returned.
	SetOption(key string, value string) bool
	// Unref removes a reference from a pixbuf.
	Unref()
}

// pixbuf implements the Pixbuf interface.
type pixbuf struct {
	gextras.Objector
	gio.Icon
}

var _ Pixbuf = (*pixbuf)(nil)

// WrapPixbuf wraps a GObject to the right type. It is
// primarily used internally.
func WrapPixbuf(obj *externglib.Object) Pixbuf {
	return Pixbuf{
		Objector: obj,
		gio.Icon: gio.WrapIcon(obj),
	}
}

func marshalPixbuf(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPixbuf(obj), nil
}

// Composite creates a transformation of the source image @src by scaling by
// @scale_x and @scale_y then translating by @offset_x and @offset_y.
//
// This gives an image in the coordinates of the destination pixbuf. The
// rectangle (@dest_x, @dest_y, @dest_width, @dest_height) is then alpha
// blended onto the corresponding rectangle of the original destination
// image.
//
// When the destination rectangle contains parts not in the source image,
// the data at the edges of the source image is replicated to infinity.
//
// ! (composite.png)
func (s pixbuf) Composite(dest Pixbuf, destX int, destY int, destWidth int, destHeight int, offsetX float64, offsetY float64, scaleX float64, scaleY float64, interpType InterpType, overallAlpha int) {
	var _arg0 *C.GdkPixbuf     // out
	var _arg1 *C.GdkPixbuf     // out
	var _arg2 C.int            // out
	var _arg3 C.int            // out
	var _arg4 C.int            // out
	var _arg5 C.int            // out
	var _arg6 C.double         // out
	var _arg7 C.double         // out
	var _arg8 C.double         // out
	var _arg9 C.double         // out
	var _arg10 C.GdkInterpType // out
	var _arg11 C.int           // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(dest.Native()))
	_arg2 = C.int(destX)
	_arg3 = C.int(destY)
	_arg4 = C.int(destWidth)
	_arg5 = C.int(destHeight)
	_arg6 = C.double(offsetX)
	_arg7 = C.double(offsetY)
	_arg8 = C.double(scaleX)
	_arg9 = C.double(scaleY)
	_arg10 = (C.GdkInterpType)(interpType)
	_arg11 = C.int(overallAlpha)

	C.gdk_pixbuf_composite(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11)
}

// CompositeColor creates a transformation of the source image @src by
// scaling by @scale_x and @scale_y then translating by @offset_x and
// @offset_y, then alpha blends the rectangle (@dest_x ,@dest_y,
// @dest_width, @dest_height) of the resulting image with a checkboard of
// the colors @color1 and @color2 and renders it onto the destination image.
//
// If the source image has no alpha channel, and @overall_alpha is 255, a
// fast path is used which omits the alpha blending and just performs the
// scaling.
//
// See gdk_pixbuf_composite_color_simple() for a simpler variant of this
// function suitable for many tasks.
func (s pixbuf) CompositeColor(dest Pixbuf, destX int, destY int, destWidth int, destHeight int, offsetX float64, offsetY float64, scaleX float64, scaleY float64, interpType InterpType, overallAlpha int, checkX int, checkY int, checkSize int, color1 uint32, color2 uint32) {
	var _arg0 *C.GdkPixbuf     // out
	var _arg1 *C.GdkPixbuf     // out
	var _arg2 C.int            // out
	var _arg3 C.int            // out
	var _arg4 C.int            // out
	var _arg5 C.int            // out
	var _arg6 C.double         // out
	var _arg7 C.double         // out
	var _arg8 C.double         // out
	var _arg9 C.double         // out
	var _arg10 C.GdkInterpType // out
	var _arg11 C.int           // out
	var _arg12 C.int           // out
	var _arg13 C.int           // out
	var _arg14 C.int           // out
	var _arg15 C.guint32       // out
	var _arg16 C.guint32       // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(dest.Native()))
	_arg2 = C.int(destX)
	_arg3 = C.int(destY)
	_arg4 = C.int(destWidth)
	_arg5 = C.int(destHeight)
	_arg6 = C.double(offsetX)
	_arg7 = C.double(offsetY)
	_arg8 = C.double(scaleX)
	_arg9 = C.double(scaleY)
	_arg10 = (C.GdkInterpType)(interpType)
	_arg11 = C.int(overallAlpha)
	_arg12 = C.int(checkX)
	_arg13 = C.int(checkY)
	_arg14 = C.int(checkSize)
	_arg15 = C.guint32(color1)
	_arg16 = C.guint32(color2)

	C.gdk_pixbuf_composite_color(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11, _arg12, _arg13, _arg14, _arg15, _arg16)
}

// CopyArea copies a rectangular area from `src_pixbuf` to `dest_pixbuf`.
//
// Conversion of pixbuf formats is done automatically.
//
// If the source rectangle overlaps the destination rectangle on the same
// pixbuf, it will be overwritten during the copy operation. Therefore, you
// can not use this function to scroll a pixbuf.
func (s pixbuf) CopyArea(srcX int, srcY int, width int, height int, destPixbuf Pixbuf, destX int, destY int) {
	var _arg0 *C.GdkPixbuf // out
	var _arg1 C.int        // out
	var _arg2 C.int        // out
	var _arg3 C.int        // out
	var _arg4 C.int        // out
	var _arg5 *C.GdkPixbuf // out
	var _arg6 C.int        // out
	var _arg7 C.int        // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	_arg1 = C.int(srcX)
	_arg2 = C.int(srcY)
	_arg3 = C.int(width)
	_arg4 = C.int(height)
	_arg5 = (*C.GdkPixbuf)(unsafe.Pointer(destPixbuf.Native()))
	_arg6 = C.int(destX)
	_arg7 = C.int(destY)

	C.gdk_pixbuf_copy_area(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
}

// CopyOptions copies the key/value pair options attached to a `GdkPixbuf`
// to another `GdkPixbuf`.
//
// This is useful to keep original metadata after having manipulated a file.
// However be careful to remove metadata which you've already applied, such
// as the "orientation" option after rotating the image.
func (s pixbuf) CopyOptions(destPixbuf Pixbuf) bool {
	var _arg0 *C.GdkPixbuf // out
	var _arg1 *C.GdkPixbuf // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(destPixbuf.Native()))

	var _cret C.gboolean // in

	_cret = C.gdk_pixbuf_copy_options(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Fill clears a pixbuf to the given RGBA value, converting the RGBA value
// into the pixbuf's pixel format.
//
// The alpha component will be ignored if the pixbuf doesn't have an alpha
// channel.
func (p pixbuf) Fill(pixel uint32) {
	var _arg0 *C.GdkPixbuf // out
	var _arg1 C.guint32    // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))
	_arg1 = C.guint32(pixel)

	C.gdk_pixbuf_fill(_arg0, _arg1)
}

// BitsPerSample queries the number of bits per color sample in a pixbuf.
func (p pixbuf) BitsPerSample() int {
	var _arg0 *C.GdkPixbuf // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var _cret C.int // in

	_cret = C.gdk_pixbuf_get_bits_per_sample(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// ByteLength returns the length of the pixel data, in bytes.
func (p pixbuf) ByteLength() uint {
	var _arg0 *C.GdkPixbuf // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var _cret C.gsize // in

	_cret = C.gdk_pixbuf_get_byte_length(_arg0)

	var _gsize uint // out

	_gsize = (uint)(_cret)

	return _gsize
}

// HasAlpha queries whether a pixbuf has an alpha channel (opacity
// information).
func (p pixbuf) HasAlpha() bool {
	var _arg0 *C.GdkPixbuf // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var _cret C.gboolean // in

	_cret = C.gdk_pixbuf_get_has_alpha(_arg0)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Height queries the height of a pixbuf.
func (p pixbuf) Height() int {
	var _arg0 *C.GdkPixbuf // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var _cret C.int // in

	_cret = C.gdk_pixbuf_get_height(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// NChannels queries the number of channels of a pixbuf.
func (p pixbuf) NChannels() int {
	var _arg0 *C.GdkPixbuf // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var _cret C.int // in

	_cret = C.gdk_pixbuf_get_n_channels(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Option looks up @key in the list of options that may have been attached
// to the @pixbuf when it was loaded, or that may have been attached by
// another function using gdk_pixbuf_set_option().
//
// For instance, the ANI loader provides "Title" and "Artist" options. The
// ICO, XBM, and XPM loaders provide "x_hot" and "y_hot" hot-spot options
// for cursor definitions. The PNG loader provides the tEXt ancillary chunk
// key/value pairs as options. Since 2.12, the TIFF and JPEG loaders return
// an "orientation" option string that corresponds to the embedded TIFF/Exif
// orientation tag (if present). Since 2.32, the TIFF loader sets the
// "multipage" option string to "yes" when a multi-page TIFF is loaded.
// Since 2.32 the JPEG and PNG loaders set "x-dpi" and "y-dpi" if the file
// contains image density information in dots per inch. Since 2.36.6, the
// JPEG loader sets the "comment" option with the comment EXIF tag.
func (p pixbuf) Option(key string) string {
	var _arg0 *C.GdkPixbuf // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret *C.gchar // in

	_cret = C.gdk_pixbuf_get_option(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// PixelsWithLength queries a pointer to the pixel data of a pixbuf.
//
// This function will cause an implicit copy of the pixbuf data if the
// pixbuf was created from read-only data.
//
// Please see the section on image data (#image-data) for information about
// how the pixel data is stored in memory.
func (p pixbuf) PixelsWithLength() []byte {
	var _arg0 *C.GdkPixbuf // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var _cret *C.guchar
	var _arg1 C.guint // in

	_cret = C.gdk_pixbuf_get_pixels_with_length(_arg0, &_arg1)

	var _guint8s []byte

	{
		var src []C.guchar
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(_cret), int(_arg1))

		_guint8s = make([]byte, _arg1)
		for i := 0; i < uintptr(_arg1); i++ {
			_guint8s = (byte)(_cret)
		}
	}

	return _guint8s
}

// Rowstride queries the rowstride of a pixbuf, which is the number of bytes
// between the start of a row and the start of the next row.
func (p pixbuf) Rowstride() int {
	var _arg0 *C.GdkPixbuf // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var _cret C.int // in

	_cret = C.gdk_pixbuf_get_rowstride(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Width queries the width of a pixbuf.
func (p pixbuf) Width() int {
	var _arg0 *C.GdkPixbuf // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var _cret C.int // in

	_cret = C.gdk_pixbuf_get_width(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// ReadPixels provides a read-only pointer to the raw pixel data.
//
// This function allows skipping the implicit copy that must be made if
// gdk_pixbuf_get_pixels() is called on a read-only pixbuf.
func (p pixbuf) ReadPixels() *byte {
	var _arg0 *C.GdkPixbuf // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var _cret *C.guint8 // in

	_cret = C.gdk_pixbuf_read_pixels(_arg0)

	var _guint8 *byte // out

	_guint8 = (*byte)(_cret)

	return _guint8
}

// RemoveOption removes the key/value pair option attached to a `GdkPixbuf`.
func (p pixbuf) RemoveOption(key string) bool {
	var _arg0 *C.GdkPixbuf // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret C.gboolean // in

	_cret = C.gdk_pixbuf_remove_option(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// SaturateAndPixelate modifies saturation and optionally pixelates `src`,
// placing the result in `dest`.
//
// The `src` and `dest` pixbufs must have the same image format, size, and
// rowstride.
//
// The `src` and `dest` arguments may be the same pixbuf with no ill
// effects.
//
// If `saturation` is 1.0 then saturation is not changed. If it's less than
// 1.0, saturation is reduced (the image turns toward grayscale); if greater
// than 1.0, saturation is increased (the image gets more vivid colors).
//
// If `pixelate` is `TRUE`, then pixels are faded in a checkerboard pattern
// to create a pixelated image.
func (s pixbuf) SaturateAndPixelate(dest Pixbuf, saturation float32, pixelate bool) {
	var _arg0 *C.GdkPixbuf // out
	var _arg1 *C.GdkPixbuf // out
	var _arg2 C.gfloat     // out
	var _arg3 C.gboolean   // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(dest.Native()))
	_arg2 = C.gfloat(saturation)
	if pixelate {
		_arg3 = C.gboolean(1)
	}

	C.gdk_pixbuf_saturate_and_pixelate(_arg0, _arg1, _arg2, _arg3)
}

// SaveToBufferv: vector version of `gdk_pixbuf_save_to_buffer()`.
//
// Saves pixbuf to a new buffer in format @type, which is currently "jpeg",
// "tiff", "png", "ico" or "bmp".
//
// See [method@GdkPixbuf.Pixbuf.save_to_buffer] for more details.
func (p pixbuf) SaveToBufferv(typ string, optionKeys []string, optionValues []string) ([]byte, error) {
	var _arg0 *C.GdkPixbuf // out
	var _arg3 *C.char      // out
	var _arg4 **C.char
	var _arg5 **C.char

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))
	_arg3 = (*C.char)(C.CString(typ))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (**C.char)(C.malloc((len(optionKeys) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(_arg4))

	{
		var out []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(_arg4), int(len(optionKeys)))

		for i := range optionKeys {
			_arg4 = (*C.gchar)(C.CString(optionKeys))
			defer C.free(unsafe.Pointer(_arg4))
		}
	}
	_arg5 = (**C.char)(C.malloc((len(optionValues) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(_arg5))

	{
		var out []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(_arg5), int(len(optionValues)))

		for i := range optionValues {
			_arg5 = (*C.gchar)(C.CString(optionValues))
			defer C.free(unsafe.Pointer(_arg5))
		}
	}

	var _arg1 *C.gchar
	var _arg2 C.gsize   // in
	var _cerr *C.GError // in

	C.gdk_pixbuf_save_to_bufferv(_arg0, _arg3, _arg4, _arg5, &_arg1, &_arg2, &_cerr)

	var _buffer []byte
	var _goerr error // out

	ptr.SetSlice(unsafe.Pointer(&_buffer), unsafe.Pointer(_arg1), int(_arg2))
	runtime.SetFinalizer(&_buffer, func(v *[]byte) {
		C.free(ptr.Slice(unsafe.Pointer(v)))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _buffer, _goerr
}

// SaveToCallbackv: vector version of `gdk_pixbuf_save_to_callback()`.
//
// Saves pixbuf to a callback in format @type, which is currently "jpeg",
// "png", "tiff", "ico" or "bmp".
//
// If @error is set, `FALSE` will be returned.
//
// See [method@GdkPixbuf.Pixbuf.save_to_callback] for more details.
func (p pixbuf) SaveToCallbackv(saveFunc PixbufSaveFunc, typ string, optionKeys []string, optionValues []string) error {
	var _arg0 *C.GdkPixbuf        // out
	var _arg1 C.GdkPixbufSaveFunc // out
	var _arg2 C.gpointer
	var _arg3 *C.char // out
	var _arg4 **C.char
	var _arg5 **C.char

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))
	_arg1 = (*[0]byte)(C.gotk4_PixbufSaveFunc)
	_arg2 = C.gpointer(box.Assign(saveFunc))
	_arg3 = (*C.char)(C.CString(typ))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (**C.char)(C.malloc((len(optionKeys) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(_arg4))

	{
		var out []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(_arg4), int(len(optionKeys)))

		for i := range optionKeys {
			_arg4 = (*C.gchar)(C.CString(optionKeys))
			defer C.free(unsafe.Pointer(_arg4))
		}
	}
	_arg5 = (**C.char)(C.malloc((len(optionValues) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(_arg5))

	{
		var out []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(_arg5), int(len(optionValues)))

		for i := range optionValues {
			_arg5 = (*C.gchar)(C.CString(optionValues))
			defer C.free(unsafe.Pointer(_arg5))
		}
	}

	var _cerr *C.GError // in

	C.gdk_pixbuf_save_to_callbackv(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// SaveToStreamv saves `pixbuf` to an output stream.
//
// Supported file formats are currently "jpeg", "tiff", "png", "ico" or
// "bmp".
//
// See [method@GdkPixbuf.Pixbuf.save_to_stream] for more details.
func (p pixbuf) SaveToStreamv(stream gio.OutputStream, typ string, optionKeys []string, optionValues []string, cancellable gio.Cancellable) error {
	var _arg0 *C.GdkPixbuf     // out
	var _arg1 *C.GOutputStream // out
	var _arg2 *C.char          // out
	var _arg3 **C.char
	var _arg4 **C.char
	var _arg5 *C.GCancellable // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GOutputStream)(unsafe.Pointer(stream.Native()))
	_arg2 = (*C.char)(C.CString(typ))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (**C.char)(C.malloc((len(optionKeys) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(_arg3))

	{
		var out []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(_arg3), int(len(optionKeys)))

		for i := range optionKeys {
			_arg3 = (*C.gchar)(C.CString(optionKeys))
			defer C.free(unsafe.Pointer(_arg3))
		}
	}
	_arg4 = (**C.char)(C.malloc((len(optionValues) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(_arg4))

	{
		var out []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(_arg4), int(len(optionValues)))

		for i := range optionValues {
			_arg4 = (*C.gchar)(C.CString(optionValues))
			defer C.free(unsafe.Pointer(_arg4))
		}
	}
	_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var _cerr *C.GError // in

	C.gdk_pixbuf_save_to_streamv(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// SaveToStreamvAsync saves `pixbuf` to an output stream asynchronously.
//
// For more details see gdk_pixbuf_save_to_streamv(), which is the
// synchronous version of this function.
//
// When the operation is finished, `callback` will be called in the main
// thread.
//
// You can then call gdk_pixbuf_save_to_stream_finish() to get the result of
// the operation.
func (p pixbuf) SaveToStreamvAsync(stream gio.OutputStream, typ string, optionKeys []string, optionValues []string, cancellable gio.Cancellable, callback gio.AsyncReadyCallback) {
	var _arg0 *C.GdkPixbuf     // out
	var _arg1 *C.GOutputStream // out
	var _arg2 *C.gchar         // out
	var _arg3 **C.gchar
	var _arg4 **C.gchar
	var _arg5 *C.GCancellable       // out
	var _arg6 C.GAsyncReadyCallback // out
	var _arg7 C.gpointer

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GOutputStream)(unsafe.Pointer(stream.Native()))
	_arg2 = (*C.gchar)(C.CString(typ))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (**C.gchar)(C.malloc((len(optionKeys) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(_arg3))

	{
		var out []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(_arg3), int(len(optionKeys)))

		for i := range optionKeys {
			_arg3 = (*C.gchar)(C.CString(optionKeys))
			defer C.free(unsafe.Pointer(_arg3))
		}
	}
	_arg4 = (**C.gchar)(C.malloc((len(optionValues) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(_arg4))

	{
		var out []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(_arg4), int(len(optionValues)))

		for i := range optionValues {
			_arg4 = (*C.gchar)(C.CString(optionValues))
			defer C.free(unsafe.Pointer(_arg4))
		}
	}
	_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	_arg6 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	_arg7 = C.gpointer(box.Assign(callback))

	C.gdk_pixbuf_save_to_streamv_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
}

// Savev: vector version of `gdk_pixbuf_save()`.
//
// Saves pixbuf to a file in `type`, which is currently "jpeg", "png",
// "tiff", "ico" or "bmp".
//
// If @error is set, `FALSE` will be returned.
//
// See [method@GdkPixbuf.Pixbuf.save] for more details.
func (p pixbuf) Savev(filename *string, typ string, optionKeys []string, optionValues []string) error {
	var _arg0 *C.GdkPixbuf // out
	var _arg1 *C.char      // out
	var _arg2 *C.char      // out
	var _arg3 **C.char
	var _arg4 **C.char

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(C.CString(typ))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (**C.char)(C.malloc((len(optionKeys) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(_arg3))

	{
		var out []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(_arg3), int(len(optionKeys)))

		for i := range optionKeys {
			_arg3 = (*C.gchar)(C.CString(optionKeys))
			defer C.free(unsafe.Pointer(_arg3))
		}
	}
	_arg4 = (**C.char)(C.malloc((len(optionValues) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(_arg4))

	{
		var out []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(_arg4), int(len(optionValues)))

		for i := range optionValues {
			_arg4 = (*C.gchar)(C.CString(optionValues))
			defer C.free(unsafe.Pointer(_arg4))
		}
	}

	var _cerr *C.GError // in

	C.gdk_pixbuf_savev(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// Scale creates a transformation of the source image @src by scaling by
// @scale_x and @scale_y then translating by @offset_x and @offset_y, then
// renders the rectangle (@dest_x, @dest_y, @dest_width, @dest_height) of
// the resulting image onto the destination image replacing the previous
// contents.
//
// Try to use gdk_pixbuf_scale_simple() first; this function is the
// industrial-strength power tool you can fall back to, if
// gdk_pixbuf_scale_simple() isn't powerful enough.
//
// If the source rectangle overlaps the destination rectangle on the same
// pixbuf, it will be overwritten during the scaling which results in
// rendering artifacts.
func (s pixbuf) Scale(dest Pixbuf, destX int, destY int, destWidth int, destHeight int, offsetX float64, offsetY float64, scaleX float64, scaleY float64, interpType InterpType) {
	var _arg0 *C.GdkPixbuf     // out
	var _arg1 *C.GdkPixbuf     // out
	var _arg2 C.int            // out
	var _arg3 C.int            // out
	var _arg4 C.int            // out
	var _arg5 C.int            // out
	var _arg6 C.double         // out
	var _arg7 C.double         // out
	var _arg8 C.double         // out
	var _arg9 C.double         // out
	var _arg10 C.GdkInterpType // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(dest.Native()))
	_arg2 = C.int(destX)
	_arg3 = C.int(destY)
	_arg4 = C.int(destWidth)
	_arg5 = C.int(destHeight)
	_arg6 = C.double(offsetX)
	_arg7 = C.double(offsetY)
	_arg8 = C.double(scaleX)
	_arg9 = C.double(scaleY)
	_arg10 = (C.GdkInterpType)(interpType)

	C.gdk_pixbuf_scale(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10)
}

// SetOption attaches a key/value pair as an option to a `GdkPixbuf`.
//
// If `key` already exists in the list of options attached to the `pixbuf`,
// the new value is ignored and `FALSE` is returned.
func (p pixbuf) SetOption(key string, value string) bool {
	var _arg0 *C.GdkPixbuf // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.gchar     // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg2))

	var _cret C.gboolean // in

	_cret = C.gdk_pixbuf_set_option(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Unref removes a reference from a pixbuf.
func (p pixbuf) Unref() {
	var _arg0 *C.GdkPixbuf // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	C.gdk_pixbuf_unref(_arg0)
}

type PixbufNonAnim interface {
	PixbufAnimation
}

// pixbufNonAnim implements the PixbufNonAnim interface.
type pixbufNonAnim struct {
	PixbufAnimation
}

var _ PixbufNonAnim = (*pixbufNonAnim)(nil)

// WrapPixbufNonAnim wraps a GObject to the right type. It is
// primarily used internally.
func WrapPixbufNonAnim(obj *externglib.Object) PixbufNonAnim {
	return PixbufNonAnim{
		PixbufAnimation: WrapPixbufAnimation(obj),
	}
}

func marshalPixbufNonAnim(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPixbufNonAnim(obj), nil
}

type PixbufSimpleAnimIter interface {
	PixbufAnimationIter
}

// pixbufSimpleAnimIter implements the PixbufSimpleAnimIter interface.
type pixbufSimpleAnimIter struct {
	PixbufAnimationIter
}

var _ PixbufSimpleAnimIter = (*pixbufSimpleAnimIter)(nil)

// WrapPixbufSimpleAnimIter wraps a GObject to the right type. It is
// primarily used internally.
func WrapPixbufSimpleAnimIter(obj *externglib.Object) PixbufSimpleAnimIter {
	return PixbufSimpleAnimIter{
		PixbufAnimationIter: WrapPixbufAnimationIter(obj),
	}
}

func marshalPixbufSimpleAnimIter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPixbufSimpleAnimIter(obj), nil
}
