// Code generated by girgen. DO NOT EDIT.

package gdkpixbuf

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gdk-pixbuf-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <gdk-pixbuf/gdk-pixbuf.h>
//
// extern gboolean gotk4_PixbufSaveFunc(const gchar* _0, gsize _1, GError** _2, gpointer _3);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gdk_colorspace_get_type()), F: marshalColorspace},
		{T: externglib.Type(C.gdk_interp_type_get_type()), F: marshalInterpType},
		{T: externglib.Type(C.gdk_pixbuf_alpha_mode_get_type()), F: marshalPixbufAlphaMode},
		{T: externglib.Type(C.gdk_pixbuf_error_get_type()), F: marshalPixbufError},
		{T: externglib.Type(C.gdk_pixbuf_rotation_get_type()), F: marshalPixbufRotation},
		{T: externglib.Type(C.gdk_pixbuf_format_get_type()), F: marshalPixbufFormat},
		{T: externglib.Type(C.gdk_pixbuf_animation_get_type()), F: marshalPixbufAnimation},
		{T: externglib.Type(C.gdk_pixbuf_animation_iter_get_type()), F: marshalPixbufAnimationIter},
		{T: externglib.Type(C.gdk_pixbuf_loader_get_type()), F: marshalPixbufLoader},
		{T: externglib.Type(C.gdk_pixbuf_simple_anim_get_type()), F: marshalPixbufSimpleAnim},
		{T: externglib.Type(C.gdk_pixbuf_simple_anim_iter_get_type()), F: marshalPixbufSimpleAnimIter},
	})
}

// Colorspace: this enumeration defines the color spaces that are supported by
// the gdk-pixbuf library. Currently only RGB is supported.
type Colorspace int

const (
	// ColorspaceRGB indicates a red/green/blue additive color space.
	ColorspaceRGB Colorspace = 0
)

func marshalColorspace(p uintptr) (interface{}, error) {
	return Colorspace(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// InterpType: this enumeration describes the different interpolation modes that
// can be used with the scaling functions. @GDK_INTERP_NEAREST is the fastest
// scaling method, but has horrible quality when scaling down.
// @GDK_INTERP_BILINEAR is the best choice if you aren't sure what to choose, it
// has a good speed/quality balance.
//
// **Note**: Cubic filtering is missing from the list; hyperbolic interpolation
// is just as fast and results in higher quality.
type InterpType int

const (
	// InterpTypeNearest: nearest neighbor sampling; this is the fastest and
	// lowest quality mode. Quality is normally unacceptable when scaling down,
	// but may be OK when scaling up.
	InterpTypeNearest InterpType = 0
	// InterpTypeTiles: this is an accurate simulation of the PostScript image
	// operator without any interpolation enabled. Each pixel is rendered as a
	// tiny parallelogram of solid color, the edges of which are implemented
	// with antialiasing. It resembles nearest neighbor for enlargement, and
	// bilinear for reduction.
	InterpTypeTiles InterpType = 1
	// InterpTypeBilinear: best quality/speed balance; use this mode by default.
	// Bilinear interpolation. For enlargement, it is equivalent to
	// point-sampling the ideal bilinear-interpolated image. For reduction, it
	// is equivalent to laying down small tiles and integrating over the
	// coverage area.
	InterpTypeBilinear InterpType = 2
	// InterpTypeHyper: this is the slowest and highest quality reconstruction
	// function. It is derived from the hyperbolic filters in Wolberg's "Digital
	// Image Warping", and is formally defined as the hyperbolic-filter sampling
	// the ideal hyperbolic-filter interpolated image (the filter is designed to
	// be idempotent for 1:1 pixel mapping). **Deprecated**: this interpolation
	// filter is deprecated, as in reality it has a lower quality than the
	// @GDK_INTERP_BILINEAR filter (Since: 2.38)
	InterpTypeHyper InterpType = 3
)

func marshalInterpType(p uintptr) (interface{}, error) {
	return InterpType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PixbufAlphaMode: these values can be passed to
// gdk_pixbuf_xlib_render_to_drawable_alpha() to control how the alpha channel
// of an image should be handled. This function can create a bilevel clipping
// mask (black and white) and use it while painting the image. In the future,
// when the X Window System gets an alpha channel extension, it will be possible
// to do full alpha compositing onto arbitrary drawables. For now both cases
// fall back to a bilevel clipping mask.
type PixbufAlphaMode int

const (
	// PixbufAlphaModeBilevel: a bilevel clipping mask (black and white) will be
	// created and used to draw the image. Pixels below 0.5 opacity will be
	// considered fully transparent, and all others will be considered fully
	// opaque.
	PixbufAlphaModeBilevel PixbufAlphaMode = 0
	// PixbufAlphaModeFull: for now falls back to K_PIXBUF_ALPHA_BILEVEL. In the
	// future it will do full alpha compositing.
	PixbufAlphaModeFull PixbufAlphaMode = 1
)

func marshalPixbufAlphaMode(p uintptr) (interface{}, error) {
	return PixbufAlphaMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PixbufError: an error code in the K_PIXBUF_ERROR domain. Many gdk-pixbuf
// operations can cause errors in this domain, or in the FILE_ERROR domain.
type PixbufError int

const (
	// PixbufErrorCorruptImage: an image file was broken somehow.
	PixbufErrorCorruptImage PixbufError = 0
	// PixbufErrorInsufficientMemory: not enough memory.
	PixbufErrorInsufficientMemory PixbufError = 1
	// PixbufErrorBadOption: a bad option was passed to a pixbuf save module.
	PixbufErrorBadOption PixbufError = 2
	// PixbufErrorUnknownType: unknown image type.
	PixbufErrorUnknownType PixbufError = 3
	// PixbufErrorUnsupportedOperation: don't know how to perform the given
	// operation on the type of image at hand.
	PixbufErrorUnsupportedOperation PixbufError = 4
	// PixbufErrorFailed: generic failure code, something went wrong.
	PixbufErrorFailed PixbufError = 5
	// PixbufErrorIncompleteAnimation: only part of the animation was loaded.
	PixbufErrorIncompleteAnimation PixbufError = 6
)

func marshalPixbufError(p uintptr) (interface{}, error) {
	return PixbufError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PixbufRotation: the possible rotations which can be passed to
// gdk_pixbuf_rotate_simple(). To make them easier to use, their numerical
// values are the actual degrees.
type PixbufRotation int

const (
	// PixbufRotationNone: no rotation.
	PixbufRotationNone PixbufRotation = 0
	// PixbufRotationCounterclockwise: rotate by 90 degrees.
	PixbufRotationCounterclockwise PixbufRotation = 90
	// PixbufRotationUpsidedown: rotate by 180 degrees.
	PixbufRotationUpsidedown PixbufRotation = 180
	// PixbufRotationClockwise: rotate by 270 degrees.
	PixbufRotationClockwise PixbufRotation = 270
)

func marshalPixbufRotation(p uintptr) (interface{}, error) {
	return PixbufRotation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PixbufSaveFunc specifies the type of the function passed to
// gdk_pixbuf_save_to_callback(). It is called once for each block of bytes that
// is "written" by gdk_pixbuf_save_to_callback(). If successful it should return
// true. If an error occurs it should set @error and return false, in which case
// gdk_pixbuf_save_to_callback() will fail with the same error.
type PixbufSaveFunc func(buf []byte) (err *glib.Error, ok bool)

//export gotk4_PixbufSaveFunc
func gotk4_PixbufSaveFunc(arg0 *C.gchar, arg1 C.gsize, arg2 **C.GError, arg3 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg3))
	if v == nil {
		panic(`callback not found`)
	}

	var buf []byte

	{
		buf = make([]byte, arg1)
		for i := 0; i < uintptr(arg1); i++ {
			src := (C.guint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			buf[i] = byte(src)
		}
	}

	err, ok := v.(PixbufSaveFunc)(buf)
}

func PixbufErrorQuark() glib.Quark {

	ret := C.gdk_pixbuf_error_quark()

	var ret0 glib.Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

type PixbufFormat struct {
	native C.GdkPixbufFormat
}

// WrapPixbufFormat wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPixbufFormat(ptr unsafe.Pointer) *PixbufFormat {
	if ptr == nil {
		return nil
	}

	return (*PixbufFormat)(ptr)
}

func marshalPixbufFormat(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapPixbufFormat(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (p *PixbufFormat) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

// Copy creates a copy of @format
func (format *PixbufFormat) Copy() *PixbufFormat {
	var arg0 *C.GdkPixbufFormat

	arg0 = (*C.GdkPixbufFormat)(format.Native())

	ret := C.gdk_pixbuf_format_copy(arg0)

	var ret0 *PixbufFormat

	{
		ret0 = WrapPixbufFormat(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *PixbufFormat) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Free frees the resources allocated when copying a PixbufFormat using
// gdk_pixbuf_format_copy()
func (format *PixbufFormat) Free() {
	var arg0 *C.GdkPixbufFormat

	arg0 = (*C.GdkPixbufFormat)(format.Native())

	C.gdk_pixbuf_format_free(arg0)
}

// Description returns a description of the format.
func (format *PixbufFormat) Description() string {
	var arg0 *C.GdkPixbufFormat

	arg0 = (*C.GdkPixbufFormat)(format.Native())

	ret := C.gdk_pixbuf_format_get_description(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Extensions returns the filename extensions typically used for files in the
// given format.
func (format *PixbufFormat) Extensions() []string {
	var arg0 *C.GdkPixbufFormat

	arg0 = (*C.GdkPixbufFormat)(format.Native())

	ret := C.gdk_pixbuf_format_get_extensions(arg0)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// License returns information about the license of the image loader for the
// format. The returned string should be a shorthand for a wellknown license,
// e.g. "LGPL", "GPL", "QPL", "GPL/QPL", or "other" to indicate some other
// license. This string should be freed with g_free() when it's no longer
// needed.
func (format *PixbufFormat) License() string {
	var arg0 *C.GdkPixbufFormat

	arg0 = (*C.GdkPixbufFormat)(format.Native())

	ret := C.gdk_pixbuf_format_get_license(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// MIMETypes returns the mime types supported by the format.
func (format *PixbufFormat) MIMETypes() []string {
	var arg0 *C.GdkPixbufFormat

	arg0 = (*C.GdkPixbufFormat)(format.Native())

	ret := C.gdk_pixbuf_format_get_mime_types(arg0)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// Name returns the name of the format.
func (format *PixbufFormat) Name() string {
	var arg0 *C.GdkPixbufFormat

	arg0 = (*C.GdkPixbufFormat)(format.Native())

	ret := C.gdk_pixbuf_format_get_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// IsDisabled returns whether this image format is disabled. See
// gdk_pixbuf_format_set_disabled().
func (format *PixbufFormat) IsDisabled() bool {
	var arg0 *C.GdkPixbufFormat

	arg0 = (*C.GdkPixbufFormat)(format.Native())

	ret := C.gdk_pixbuf_format_is_disabled(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IsSaveOptionSupported returns true if the save option specified by
// @option_key is supported when saving a pixbuf using the module implementing
// @format. See gdk_pixbuf_save() for more information about option keys.
func (format *PixbufFormat) IsSaveOptionSupported(optionKey string) bool {
	var arg0 *C.GdkPixbufFormat
	var arg1 *C.gchar

	arg0 = (*C.GdkPixbufFormat)(format.Native())
	arg1 = (*C.gchar)(C.CString(optionKey))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gdk_pixbuf_format_is_save_option_supported(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IsScalable returns whether this image format is scalable. If a file is in a
// scalable format, it is preferable to load it at the desired size, rather than
// loading it at the default size and scaling the resulting pixbuf to the
// desired size.
func (format *PixbufFormat) IsScalable() bool {
	var arg0 *C.GdkPixbufFormat

	arg0 = (*C.GdkPixbufFormat)(format.Native())

	ret := C.gdk_pixbuf_format_is_scalable(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IsWritable returns whether pixbufs can be saved in the given format.
func (format *PixbufFormat) IsWritable() bool {
	var arg0 *C.GdkPixbufFormat

	arg0 = (*C.GdkPixbufFormat)(format.Native())

	ret := C.gdk_pixbuf_format_is_writable(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SetDisabled disables or enables an image format. If a format is disabled,
// gdk-pixbuf won't use the image loader for this format to load images.
// Applications can use this to avoid using image loaders with an inappropriate
// license, see gdk_pixbuf_format_get_license().
func (format *PixbufFormat) SetDisabled(disabled bool) {
	var arg0 *C.GdkPixbufFormat
	var arg1 C.gboolean

	arg0 = (*C.GdkPixbufFormat)(format.Native())
	if disabled {
		arg1 = C.TRUE
	}

	C.gdk_pixbuf_format_set_disabled(arg0, arg1)
}

// PixbufAnimation: an opaque struct representing an animation.
type PixbufAnimation interface {
	gextras.Objector

	// Height queries the height of the bounding box of a pixbuf animation.
	Height() int
	// Iter: get an iterator for displaying an animation. The iterator provides
	// the frames that should be displayed at a given time. It should be freed
	// after use with g_object_unref().
	//
	// @start_time would normally come from g_get_current_time(), and marks the
	// beginning of animation playback. After creating an iterator, you should
	// immediately display the pixbuf returned by
	// gdk_pixbuf_animation_iter_get_pixbuf(). Then, you should install a
	// timeout (with g_timeout_add()) or by some other mechanism ensure that
	// you'll update the image after gdk_pixbuf_animation_iter_get_delay_time()
	// milliseconds. Each time the image is updated, you should reinstall the
	// timeout with the new, possibly-changed delay time.
	//
	// As a shortcut, if @start_time is nil, the result of g_get_current_time()
	// will be used automatically.
	//
	// To update the image (i.e. possibly change the result of
	// gdk_pixbuf_animation_iter_get_pixbuf() to a new frame of the animation),
	// call gdk_pixbuf_animation_iter_advance().
	//
	// If you're using PixbufLoader, in addition to updating the image after the
	// delay time, you should also update it whenever you receive the
	// area_updated signal and
	// gdk_pixbuf_animation_iter_on_currently_loading_frame() returns true. In
	// this case, the frame currently being fed into the loader has received new
	// data, so needs to be refreshed. The delay time for a frame may also be
	// modified after an area_updated signal, for example if the delay time for
	// a frame is encoded in the data after the frame itself. So your timeout
	// should be reinstalled after any area_updated signal.
	//
	// A delay time of -1 is possible, indicating "infinite."
	Iter(startTime *glib.TimeVal) PixbufAnimationIter
	// StaticImage: if an animation is really just a plain image (has only one
	// frame), this function returns that image. If the animation is an
	// animation, this function returns a reasonable thing to display as a
	// static unanimated image, which might be the first frame, or something
	// more sophisticated. If an animation hasn't loaded any frames yet, this
	// function will return nil.
	StaticImage() Pixbuf
	// Width queries the width of the bounding box of a pixbuf animation.
	Width() int
	// IsStaticImage: if you load a file with
	// gdk_pixbuf_animation_new_from_file() and it turns out to be a plain,
	// unanimated image, then this function will return true. Use
	// gdk_pixbuf_animation_get_static_image() to retrieve the image.
	IsStaticImage() bool
	// Ref adds a reference to an animation.
	Ref() PixbufAnimation
	// Unref removes a reference from an animation.
	Unref()
}

// pixbufAnimation implements the PixbufAnimation interface.
type pixbufAnimation struct {
	gextras.Objector
}

var _ PixbufAnimation = (*pixbufAnimation)(nil)

// WrapPixbufAnimation wraps a GObject to the right type. It is
// primarily used internally.
func WrapPixbufAnimation(obj *externglib.Object) PixbufAnimation {
	return PixbufAnimation{
		Objector: obj,
	}
}

func marshalPixbufAnimation(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPixbufAnimation(obj), nil
}

// NewPixbufAnimationFromFile constructs a class PixbufAnimation.
func NewPixbufAnimationFromFile(filename string) (pixbufAnimation PixbufAnimation, err error) {
	var arg1 *C.char
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gdk_pixbuf_animation_new_from_file(arg1, &gError)

	var ret0 PixbufAnimation
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(PixbufAnimation)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// NewPixbufAnimationFromResource constructs a class PixbufAnimation.
func NewPixbufAnimationFromResource(resourcePath string) (pixbufAnimation PixbufAnimation, err error) {
	var arg1 *C.char
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gdk_pixbuf_animation_new_from_resource(arg1, &gError)

	var ret0 PixbufAnimation
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(PixbufAnimation)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// NewPixbufAnimationFromStream constructs a class PixbufAnimation.
func NewPixbufAnimationFromStream(stream gio.InputStream, cancellable gio.Cancellable) (pixbufAnimation PixbufAnimation, err error) {
	var arg1 *C.GInputStream
	var arg2 *C.GCancellable
	var gError *C.GError

	arg1 = (*C.GInputStream)(stream.Native())
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.gdk_pixbuf_animation_new_from_stream(arg1, arg2, &gError)

	var ret0 PixbufAnimation
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(PixbufAnimation)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// NewPixbufAnimationFromStreamFinish constructs a class PixbufAnimation.
func NewPixbufAnimationFromStreamFinish(asyncResult gio.AsyncResult) (pixbufAnimation PixbufAnimation, err error) {
	var arg1 *C.GAsyncResult
	var gError *C.GError

	arg1 = (*C.GAsyncResult)(asyncResult.Native())

	ret := C.gdk_pixbuf_animation_new_from_stream_finish(arg1, &gError)

	var ret0 PixbufAnimation
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(PixbufAnimation)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Height queries the height of the bounding box of a pixbuf animation.
func (animation pixbufAnimation) Height() int {
	var arg0 *C.GdkPixbufAnimation

	arg0 = (*C.GdkPixbufAnimation)(animation.Native())

	ret := C.gdk_pixbuf_animation_get_height(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Iter: get an iterator for displaying an animation. The iterator provides
// the frames that should be displayed at a given time. It should be freed
// after use with g_object_unref().
//
// @start_time would normally come from g_get_current_time(), and marks the
// beginning of animation playback. After creating an iterator, you should
// immediately display the pixbuf returned by
// gdk_pixbuf_animation_iter_get_pixbuf(). Then, you should install a
// timeout (with g_timeout_add()) or by some other mechanism ensure that
// you'll update the image after gdk_pixbuf_animation_iter_get_delay_time()
// milliseconds. Each time the image is updated, you should reinstall the
// timeout with the new, possibly-changed delay time.
//
// As a shortcut, if @start_time is nil, the result of g_get_current_time()
// will be used automatically.
//
// To update the image (i.e. possibly change the result of
// gdk_pixbuf_animation_iter_get_pixbuf() to a new frame of the animation),
// call gdk_pixbuf_animation_iter_advance().
//
// If you're using PixbufLoader, in addition to updating the image after the
// delay time, you should also update it whenever you receive the
// area_updated signal and
// gdk_pixbuf_animation_iter_on_currently_loading_frame() returns true. In
// this case, the frame currently being fed into the loader has received new
// data, so needs to be refreshed. The delay time for a frame may also be
// modified after an area_updated signal, for example if the delay time for
// a frame is encoded in the data after the frame itself. So your timeout
// should be reinstalled after any area_updated signal.
//
// A delay time of -1 is possible, indicating "infinite."
func (animation pixbufAnimation) Iter(startTime *glib.TimeVal) PixbufAnimationIter {
	var arg0 *C.GdkPixbufAnimation
	var arg1 *C.GTimeVal

	arg0 = (*C.GdkPixbufAnimation)(animation.Native())
	arg1 = (*C.GTimeVal)(startTime.Native())

	ret := C.gdk_pixbuf_animation_get_iter(arg0, arg1)

	var ret0 PixbufAnimationIter

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(PixbufAnimationIter)

	return ret0
}

// StaticImage: if an animation is really just a plain image (has only one
// frame), this function returns that image. If the animation is an
// animation, this function returns a reasonable thing to display as a
// static unanimated image, which might be the first frame, or something
// more sophisticated. If an animation hasn't loaded any frames yet, this
// function will return nil.
func (animation pixbufAnimation) StaticImage() Pixbuf {
	var arg0 *C.GdkPixbufAnimation

	arg0 = (*C.GdkPixbufAnimation)(animation.Native())

	ret := C.gdk_pixbuf_animation_get_static_image(arg0)

	var ret0 Pixbuf

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Pixbuf)

	return ret0
}

// Width queries the width of the bounding box of a pixbuf animation.
func (animation pixbufAnimation) Width() int {
	var arg0 *C.GdkPixbufAnimation

	arg0 = (*C.GdkPixbufAnimation)(animation.Native())

	ret := C.gdk_pixbuf_animation_get_width(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// IsStaticImage: if you load a file with
// gdk_pixbuf_animation_new_from_file() and it turns out to be a plain,
// unanimated image, then this function will return true. Use
// gdk_pixbuf_animation_get_static_image() to retrieve the image.
func (animation pixbufAnimation) IsStaticImage() bool {
	var arg0 *C.GdkPixbufAnimation

	arg0 = (*C.GdkPixbufAnimation)(animation.Native())

	ret := C.gdk_pixbuf_animation_is_static_image(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Ref adds a reference to an animation.
func (animation pixbufAnimation) Ref() PixbufAnimation {
	var arg0 *C.GdkPixbufAnimation

	arg0 = (*C.GdkPixbufAnimation)(animation.Native())

	ret := C.gdk_pixbuf_animation_ref(arg0)

	var ret0 PixbufAnimation

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(PixbufAnimation)

	return ret0
}

// Unref removes a reference from an animation.
func (animation pixbufAnimation) Unref() {
	var arg0 *C.GdkPixbufAnimation

	arg0 = (*C.GdkPixbufAnimation)(animation.Native())

	C.gdk_pixbuf_animation_unref(arg0)
}

// PixbufAnimationIter: an opaque struct representing an iterator which points
// to a certain position in an animation.
type PixbufAnimationIter interface {
	gextras.Objector

	// Advance: possibly advances an animation to a new frame. Chooses the frame
	// based on the start time passed to gdk_pixbuf_animation_get_iter().
	//
	// @current_time would normally come from g_get_current_time(), and must be
	// greater than or equal to the time passed to
	// gdk_pixbuf_animation_get_iter(), and must increase or remain unchanged
	// each time gdk_pixbuf_animation_iter_get_pixbuf() is called. That is, you
	// can't go backward in time; animations only play forward.
	//
	// As a shortcut, pass nil for the current time and g_get_current_time()
	// will be invoked on your behalf. So you only need to explicitly pass
	// @current_time if you're doing something odd like playing the animation at
	// double speed.
	//
	// If this function returns false, there's no need to update the animation
	// display, assuming the display had been rendered prior to advancing; if
	// true, you need to call gdk_pixbuf_animation_iter_get_pixbuf() and update
	// the display with the new pixbuf.
	Advance(currentTime *glib.TimeVal) bool
	// DelayTime gets the number of milliseconds the current pixbuf should be
	// displayed, or -1 if the current pixbuf should be displayed forever.
	// g_timeout_add() conveniently takes a timeout in milliseconds, so you can
	// use a timeout to schedule the next update.
	//
	// Note that some formats, like GIF, might clamp the timeout values in the
	// image file to avoid updates that are just too quick. The minimum timeout
	// for GIF images is currently 20 milliseconds.
	DelayTime() int
	// Pixbuf gets the current pixbuf which should be displayed; the pixbuf
	// might not be the same size as the animation itself
	// (gdk_pixbuf_animation_get_width(), gdk_pixbuf_animation_get_height()).
	// This pixbuf should be displayed for
	// gdk_pixbuf_animation_iter_get_delay_time() milliseconds. The caller of
	// this function does not own a reference to the returned pixbuf; the
	// returned pixbuf will become invalid when the iterator advances to the
	// next frame, which may happen anytime you call
	// gdk_pixbuf_animation_iter_advance(). Copy the pixbuf to keep it (don't
	// just add a reference), as it may get recycled as you advance the
	// iterator.
	Pixbuf() Pixbuf
	// OnCurrentlyLoadingFrame: used to determine how to respond to the
	// area_updated signal on PixbufLoader when loading an animation.
	// area_updated is emitted for an area of the frame currently streaming in
	// to the loader. So if you're on the currently loading frame, you need to
	// redraw the screen for the updated area.
	OnCurrentlyLoadingFrame() bool
}

// pixbufAnimationIter implements the PixbufAnimationIter interface.
type pixbufAnimationIter struct {
	gextras.Objector
}

var _ PixbufAnimationIter = (*pixbufAnimationIter)(nil)

// WrapPixbufAnimationIter wraps a GObject to the right type. It is
// primarily used internally.
func WrapPixbufAnimationIter(obj *externglib.Object) PixbufAnimationIter {
	return PixbufAnimationIter{
		Objector: obj,
	}
}

func marshalPixbufAnimationIter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPixbufAnimationIter(obj), nil
}

// Advance: possibly advances an animation to a new frame. Chooses the frame
// based on the start time passed to gdk_pixbuf_animation_get_iter().
//
// @current_time would normally come from g_get_current_time(), and must be
// greater than or equal to the time passed to
// gdk_pixbuf_animation_get_iter(), and must increase or remain unchanged
// each time gdk_pixbuf_animation_iter_get_pixbuf() is called. That is, you
// can't go backward in time; animations only play forward.
//
// As a shortcut, pass nil for the current time and g_get_current_time()
// will be invoked on your behalf. So you only need to explicitly pass
// @current_time if you're doing something odd like playing the animation at
// double speed.
//
// If this function returns false, there's no need to update the animation
// display, assuming the display had been rendered prior to advancing; if
// true, you need to call gdk_pixbuf_animation_iter_get_pixbuf() and update
// the display with the new pixbuf.
func (iter pixbufAnimationIter) Advance(currentTime *glib.TimeVal) bool {
	var arg0 *C.GdkPixbufAnimationIter
	var arg1 *C.GTimeVal

	arg0 = (*C.GdkPixbufAnimationIter)(iter.Native())
	arg1 = (*C.GTimeVal)(currentTime.Native())

	ret := C.gdk_pixbuf_animation_iter_advance(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// DelayTime gets the number of milliseconds the current pixbuf should be
// displayed, or -1 if the current pixbuf should be displayed forever.
// g_timeout_add() conveniently takes a timeout in milliseconds, so you can
// use a timeout to schedule the next update.
//
// Note that some formats, like GIF, might clamp the timeout values in the
// image file to avoid updates that are just too quick. The minimum timeout
// for GIF images is currently 20 milliseconds.
func (iter pixbufAnimationIter) DelayTime() int {
	var arg0 *C.GdkPixbufAnimationIter

	arg0 = (*C.GdkPixbufAnimationIter)(iter.Native())

	ret := C.gdk_pixbuf_animation_iter_get_delay_time(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Pixbuf gets the current pixbuf which should be displayed; the pixbuf
// might not be the same size as the animation itself
// (gdk_pixbuf_animation_get_width(), gdk_pixbuf_animation_get_height()).
// This pixbuf should be displayed for
// gdk_pixbuf_animation_iter_get_delay_time() milliseconds. The caller of
// this function does not own a reference to the returned pixbuf; the
// returned pixbuf will become invalid when the iterator advances to the
// next frame, which may happen anytime you call
// gdk_pixbuf_animation_iter_advance(). Copy the pixbuf to keep it (don't
// just add a reference), as it may get recycled as you advance the
// iterator.
func (iter pixbufAnimationIter) Pixbuf() Pixbuf {
	var arg0 *C.GdkPixbufAnimationIter

	arg0 = (*C.GdkPixbufAnimationIter)(iter.Native())

	ret := C.gdk_pixbuf_animation_iter_get_pixbuf(arg0)

	var ret0 Pixbuf

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Pixbuf)

	return ret0
}

// OnCurrentlyLoadingFrame: used to determine how to respond to the
// area_updated signal on PixbufLoader when loading an animation.
// area_updated is emitted for an area of the frame currently streaming in
// to the loader. So if you're on the currently loading frame, you need to
// redraw the screen for the updated area.
func (iter pixbufAnimationIter) OnCurrentlyLoadingFrame() bool {
	var arg0 *C.GdkPixbufAnimationIter

	arg0 = (*C.GdkPixbufAnimationIter)(iter.Native())

	ret := C.gdk_pixbuf_animation_iter_on_currently_loading_frame(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// PixbufLoader: the GdkPixbufLoader struct contains only private fields.
type PixbufLoader interface {
	gextras.Objector

	// Close informs a pixbuf loader that no further writes with
	// gdk_pixbuf_loader_write() will occur, so that it can free its internal
	// loading structures. Also, tries to parse any data that hasn't yet been
	// parsed; if the remaining data is partial or corrupt, an error will be
	// returned. If false is returned, @error will be set to an error from the
	// K_PIXBUF_ERROR or FILE_ERROR domains. If you're just cancelling a load
	// rather than expecting it to be finished, passing nil for @error to ignore
	// it is reasonable.
	//
	// Remember that this does not unref the loader, so if you plan not to use
	// it anymore, please g_object_unref() it.
	Close() error
	// Animation queries the PixbufAnimation that a pixbuf loader is currently
	// creating. In general it only makes sense to call this function after the
	// "area-prepared" signal has been emitted by the loader. If the loader
	// doesn't have enough bytes yet (hasn't emitted the "area-prepared" signal)
	// this function will return nil.
	Animation() PixbufAnimation
	// Format obtains the available information about the format of the
	// currently loading image file.
	Format() *PixbufFormat
	// Pixbuf queries the Pixbuf that a pixbuf loader is currently creating. In
	// general it only makes sense to call this function after the
	// "area-prepared" signal has been emitted by the loader; this means that
	// enough data has been read to know the size of the image that will be
	// allocated. If the loader has not received enough data via
	// gdk_pixbuf_loader_write(), then this function returns nil. The returned
	// pixbuf will be the same in all future calls to the loader, so simply
	// calling g_object_ref() should be sufficient to continue using it.
	// Additionally, if the loader is an animation, it will return the "static
	// image" of the animation (see gdk_pixbuf_animation_get_static_image()).
	Pixbuf() Pixbuf
	// SetSize causes the image to be scaled while it is loaded. The desired
	// image size can be determined relative to the original size of the image
	// by calling gdk_pixbuf_loader_set_size() from a signal handler for the
	// ::size-prepared signal.
	//
	// Attempts to set the desired image size are ignored after the emission of
	// the ::size-prepared signal.
	SetSize(width int, height int)
	// Write: this will cause a pixbuf loader to parse the next @count bytes of
	// an image. It will return true if the data was loaded successfully, and
	// false if an error occurred. In the latter case, the loader will be
	// closed, and will not accept further writes. If false is returned, @error
	// will be set to an error from the K_PIXBUF_ERROR or FILE_ERROR domains.
	Write(buf []byte) error
	// WriteBytes: this will cause a pixbuf loader to parse a buffer inside a
	// #GBytes for an image. It will return true if the data was loaded
	// successfully, and false if an error occurred. In the latter case, the
	// loader will be closed, and will not accept further writes. If false is
	// returned, @error will be set to an error from the K_PIXBUF_ERROR or
	// FILE_ERROR domains.
	//
	// See also: gdk_pixbuf_loader_write()
	WriteBytes(buffer *glib.Bytes) error
}

// pixbufLoader implements the PixbufLoader interface.
type pixbufLoader struct {
	gextras.Objector
}

var _ PixbufLoader = (*pixbufLoader)(nil)

// WrapPixbufLoader wraps a GObject to the right type. It is
// primarily used internally.
func WrapPixbufLoader(obj *externglib.Object) PixbufLoader {
	return PixbufLoader{
		Objector: obj,
	}
}

func marshalPixbufLoader(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPixbufLoader(obj), nil
}

// NewPixbufLoader constructs a class PixbufLoader.
func NewPixbufLoader() PixbufLoader {

	ret := C.gdk_pixbuf_loader_new()

	var ret0 PixbufLoader

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(PixbufLoader)

	return ret0
}

// NewPixbufLoaderWithMIMEType constructs a class PixbufLoader.
func NewPixbufLoaderWithMIMEType(mimeType string) (pixbufLoader PixbufLoader, err error) {
	var arg1 *C.char
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(mimeType))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gdk_pixbuf_loader_new_with_mime_type(arg1, &gError)

	var ret0 PixbufLoader
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(PixbufLoader)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// NewPixbufLoaderWithType constructs a class PixbufLoader.
func NewPixbufLoaderWithType(imageType string) (pixbufLoader PixbufLoader, err error) {
	var arg1 *C.char
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(imageType))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gdk_pixbuf_loader_new_with_type(arg1, &gError)

	var ret0 PixbufLoader
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(PixbufLoader)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Close informs a pixbuf loader that no further writes with
// gdk_pixbuf_loader_write() will occur, so that it can free its internal
// loading structures. Also, tries to parse any data that hasn't yet been
// parsed; if the remaining data is partial or corrupt, an error will be
// returned. If false is returned, @error will be set to an error from the
// K_PIXBUF_ERROR or FILE_ERROR domains. If you're just cancelling a load
// rather than expecting it to be finished, passing nil for @error to ignore
// it is reasonable.
//
// Remember that this does not unref the loader, so if you plan not to use
// it anymore, please g_object_unref() it.
func (loader pixbufLoader) Close() error {
	var arg0 *C.GdkPixbufLoader
	var gError *C.GError

	arg0 = (*C.GdkPixbufLoader)(loader.Native())

	ret := C.gdk_pixbuf_loader_close(arg0, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// Animation queries the PixbufAnimation that a pixbuf loader is currently
// creating. In general it only makes sense to call this function after the
// "area-prepared" signal has been emitted by the loader. If the loader
// doesn't have enough bytes yet (hasn't emitted the "area-prepared" signal)
// this function will return nil.
func (loader pixbufLoader) Animation() PixbufAnimation {
	var arg0 *C.GdkPixbufLoader

	arg0 = (*C.GdkPixbufLoader)(loader.Native())

	ret := C.gdk_pixbuf_loader_get_animation(arg0)

	var ret0 PixbufAnimation

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(PixbufAnimation)

	return ret0
}

// Format obtains the available information about the format of the
// currently loading image file.
func (loader pixbufLoader) Format() *PixbufFormat {
	var arg0 *C.GdkPixbufLoader

	arg0 = (*C.GdkPixbufLoader)(loader.Native())

	ret := C.gdk_pixbuf_loader_get_format(arg0)

	var ret0 *PixbufFormat

	{
		ret0 = WrapPixbufFormat(unsafe.Pointer(ret))
	}

	return ret0
}

// Pixbuf queries the Pixbuf that a pixbuf loader is currently creating. In
// general it only makes sense to call this function after the
// "area-prepared" signal has been emitted by the loader; this means that
// enough data has been read to know the size of the image that will be
// allocated. If the loader has not received enough data via
// gdk_pixbuf_loader_write(), then this function returns nil. The returned
// pixbuf will be the same in all future calls to the loader, so simply
// calling g_object_ref() should be sufficient to continue using it.
// Additionally, if the loader is an animation, it will return the "static
// image" of the animation (see gdk_pixbuf_animation_get_static_image()).
func (loader pixbufLoader) Pixbuf() Pixbuf {
	var arg0 *C.GdkPixbufLoader

	arg0 = (*C.GdkPixbufLoader)(loader.Native())

	ret := C.gdk_pixbuf_loader_get_pixbuf(arg0)

	var ret0 Pixbuf

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Pixbuf)

	return ret0
}

// SetSize causes the image to be scaled while it is loaded. The desired
// image size can be determined relative to the original size of the image
// by calling gdk_pixbuf_loader_set_size() from a signal handler for the
// ::size-prepared signal.
//
// Attempts to set the desired image size are ignored after the emission of
// the ::size-prepared signal.
func (loader pixbufLoader) SetSize(width int, height int) {
	var arg0 *C.GdkPixbufLoader
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GdkPixbufLoader)(loader.Native())
	arg1 = C.int(width)
	arg2 = C.int(height)

	C.gdk_pixbuf_loader_set_size(arg0, arg1, arg2)
}

// Write: this will cause a pixbuf loader to parse the next @count bytes of
// an image. It will return true if the data was loaded successfully, and
// false if an error occurred. In the latter case, the loader will be
// closed, and will not accept further writes. If false is returned, @error
// will be set to an error from the K_PIXBUF_ERROR or FILE_ERROR domains.
func (loader pixbufLoader) Write(buf []byte) error {
	var arg0 *C.GdkPixbufLoader
	var arg1 *C.guchar
	var arg2 C.gsize
	var gError *C.GError

	arg0 = (*C.GdkPixbufLoader)(loader.Native())
	arg1 = (*C.guchar)(unsafe.Pointer(&buf[0]))
	arg2 = len(buf)
	defer runtime.KeepAlive(buf)

	ret := C.gdk_pixbuf_loader_write(arg0, arg1, arg2, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// WriteBytes: this will cause a pixbuf loader to parse a buffer inside a
// #GBytes for an image. It will return true if the data was loaded
// successfully, and false if an error occurred. In the latter case, the
// loader will be closed, and will not accept further writes. If false is
// returned, @error will be set to an error from the K_PIXBUF_ERROR or
// FILE_ERROR domains.
//
// See also: gdk_pixbuf_loader_write()
func (loader pixbufLoader) WriteBytes(buffer *glib.Bytes) error {
	var arg0 *C.GdkPixbufLoader
	var arg1 *C.GBytes
	var gError *C.GError

	arg0 = (*C.GdkPixbufLoader)(loader.Native())
	arg1 = (*C.GBytes)(buffer.Native())

	ret := C.gdk_pixbuf_loader_write_bytes(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// PixbufSimpleAnim: an opaque struct representing a simple animation.
type PixbufSimpleAnim interface {
	PixbufAnimation

	// AddFrame adds a new frame to @animation. The @pixbuf must have the
	// dimensions specified when the animation was constructed.
	AddFrame(pixbuf Pixbuf)
	// Loop gets whether @animation should loop indefinitely when it reaches the
	// end.
	Loop() bool
	// SetLoop sets whether @animation should loop indefinitely when it reaches
	// the end.
	SetLoop(loop bool)
}

// pixbufSimpleAnim implements the PixbufSimpleAnim interface.
type pixbufSimpleAnim struct {
	PixbufAnimation
}

var _ PixbufSimpleAnim = (*pixbufSimpleAnim)(nil)

// WrapPixbufSimpleAnim wraps a GObject to the right type. It is
// primarily used internally.
func WrapPixbufSimpleAnim(obj *externglib.Object) PixbufSimpleAnim {
	return PixbufSimpleAnim{
		PixbufAnimation: WrapPixbufAnimation(obj),
	}
}

func marshalPixbufSimpleAnim(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPixbufSimpleAnim(obj), nil
}

// NewPixbufSimpleAnim constructs a class PixbufSimpleAnim.
func NewPixbufSimpleAnim(width int, height int, rate float32) PixbufSimpleAnim {
	var arg1 C.gint
	var arg2 C.gint
	var arg3 C.gfloat

	arg1 = C.gint(width)
	arg2 = C.gint(height)
	arg3 = C.gfloat(rate)

	ret := C.gdk_pixbuf_simple_anim_new(arg1, arg2, arg3)

	var ret0 PixbufSimpleAnim

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(PixbufSimpleAnim)

	return ret0
}

// AddFrame adds a new frame to @animation. The @pixbuf must have the
// dimensions specified when the animation was constructed.
func (animation pixbufSimpleAnim) AddFrame(pixbuf Pixbuf) {
	var arg0 *C.GdkPixbufSimpleAnim
	var arg1 *C.GdkPixbuf

	arg0 = (*C.GdkPixbufSimpleAnim)(animation.Native())
	arg1 = (*C.GdkPixbuf)(pixbuf.Native())

	C.gdk_pixbuf_simple_anim_add_frame(arg0, arg1)
}

// Loop gets whether @animation should loop indefinitely when it reaches the
// end.
func (animation pixbufSimpleAnim) Loop() bool {
	var arg0 *C.GdkPixbufSimpleAnim

	arg0 = (*C.GdkPixbufSimpleAnim)(animation.Native())

	ret := C.gdk_pixbuf_simple_anim_get_loop(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SetLoop sets whether @animation should loop indefinitely when it reaches
// the end.
func (animation pixbufSimpleAnim) SetLoop(loop bool) {
	var arg0 *C.GdkPixbufSimpleAnim
	var arg1 C.gboolean

	arg0 = (*C.GdkPixbufSimpleAnim)(animation.Native())
	if loop {
		arg1 = C.TRUE
	}

	C.gdk_pixbuf_simple_anim_set_loop(arg0, arg1)
}

type PixbufSimpleAnimIter interface {
	PixbufAnimationIter
}

// pixbufSimpleAnimIter implements the PixbufSimpleAnimIter interface.
type pixbufSimpleAnimIter struct {
	PixbufAnimationIter
}

var _ PixbufSimpleAnimIter = (*pixbufSimpleAnimIter)(nil)

// WrapPixbufSimpleAnimIter wraps a GObject to the right type. It is
// primarily used internally.
func WrapPixbufSimpleAnimIter(obj *externglib.Object) PixbufSimpleAnimIter {
	return PixbufSimpleAnimIter{
		PixbufAnimationIter: WrapPixbufAnimationIter(obj),
	}
}

func marshalPixbufSimpleAnimIter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPixbufSimpleAnimIter(obj), nil
}
