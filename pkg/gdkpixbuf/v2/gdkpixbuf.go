// Code generated by girgen. DO NOT EDIT.

package gdkpixbuf

import (
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gdk-pixbuf/gdk-pixbuf.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gdk_colorspace_get_type()), F: marshalColorspace},
		{T: externglib.Type(C.gdk_interp_type_get_type()), F: marshalInterpType},
		{T: externglib.Type(C.gdk_pixbuf_alpha_mode_get_type()), F: marshalPixbufAlphaMode},
		{T: externglib.Type(C.gdk_pixbuf_error_get_type()), F: marshalPixbufError},
		{T: externglib.Type(C.gdk_pixbuf_rotation_get_type()), F: marshalPixbufRotation},
		{T: externglib.Type(C.gdk_pixbuf_get_type()), F: marshalPixbuf},
		{T: externglib.Type(C.gdk_pixbuf_non_anim_get_type()), F: marshalPixbufNonAnim},
		{T: externglib.Type(C.gdk_pixbuf_simple_anim_iter_get_type()), F: marshalPixbufSimpleAnimIter},
	})
}

// Colorspace: this enumeration defines the color spaces that are supported by
// the gdk-pixbuf library.
//
// Currently only RGB is supported.
type Colorspace int

const (
	// ColorspaceRGB indicates a red/green/blue additive color space.
	ColorspaceRGB Colorspace = 0
)

func marshalColorspace(p uintptr) (interface{}, error) {
	return Colorspace(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// InterpType: interpolation modes for scaling functions.
//
// The `GDK_INTERP_NEAREST` mode is the fastest scaling method, but has horrible
// quality when scaling down; `GDK_INTERP_BILINEAR` is the best choice if you
// aren't sure what to choose, it has a good speed/quality balance.
//
// **Note**: Cubic filtering is missing from the list; hyperbolic interpolation
// is just as fast and results in higher quality.
type InterpType int

const (
	// InterpTypeNearest: nearest neighbor sampling; this is the fastest and
	// lowest quality mode. Quality is normally unacceptable when scaling down,
	// but may be OK when scaling up.
	InterpTypeNearest InterpType = 0
	// InterpTypeTiles: this is an accurate simulation of the PostScript image
	// operator without any interpolation enabled. Each pixel is rendered as a
	// tiny parallelogram of solid color, the edges of which are implemented
	// with antialiasing. It resembles nearest neighbor for enlargement, and
	// bilinear for reduction.
	InterpTypeTiles InterpType = 1
	// InterpTypeBilinear: best quality/speed balance; use this mode by default.
	// Bilinear interpolation. For enlargement, it is equivalent to
	// point-sampling the ideal bilinear-interpolated image. For reduction, it
	// is equivalent to laying down small tiles and integrating over the
	// coverage area.
	InterpTypeBilinear InterpType = 2
	// InterpTypeHyper: this is the slowest and highest quality reconstruction
	// function. It is derived from the hyperbolic filters in Wolberg's "Digital
	// Image Warping", and is formally defined as the hyperbolic-filter sampling
	// the ideal hyperbolic-filter interpolated image (the filter is designed to
	// be idempotent for 1:1 pixel mapping). **Deprecated**: this interpolation
	// filter is deprecated, as in reality it has a lower quality than the
	// @GDK_INTERP_BILINEAR filter (Since: 2.38)
	InterpTypeHyper InterpType = 3
)

func marshalInterpType(p uintptr) (interface{}, error) {
	return InterpType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PixbufAlphaMode: control the alpha channel for drawables.
//
// These values can be passed to gdk_pixbuf_xlib_render_to_drawable_alpha() in
// gdk-pixbuf-xlib to control how the alpha channel of an image should be
// handled.
//
// This function can create a bilevel clipping mask (black and white) and use it
// while painting the image.
//
// In the future, when the X Window System gets an alpha channel extension, it
// will be possible to do full alpha compositing onto arbitrary drawables. For
// now both cases fall back to a bilevel clipping mask.
type PixbufAlphaMode int

const (
	// PixbufAlphaModeBilevel: a bilevel clipping mask (black and white) will be
	// created and used to draw the image. Pixels below 0.5 opacity will be
	// considered fully transparent, and all others will be considered fully
	// opaque.
	PixbufAlphaModeBilevel PixbufAlphaMode = 0
	// PixbufAlphaModeFull: for now falls back to K_PIXBUF_ALPHA_BILEVEL. In the
	// future it will do full alpha compositing.
	PixbufAlphaModeFull PixbufAlphaMode = 1
)

func marshalPixbufAlphaMode(p uintptr) (interface{}, error) {
	return PixbufAlphaMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PixbufError: an error code in the `GDK_PIXBUF_ERROR` domain.
//
// Many gdk-pixbuf operations can cause errors in this domain, or in the
// `G_FILE_ERROR` domain.
type PixbufError int

const (
	// PixbufErrorCorruptImage: an image file was broken somehow.
	PixbufErrorCorruptImage PixbufError = 0
	// PixbufErrorInsufficientMemory: not enough memory.
	PixbufErrorInsufficientMemory PixbufError = 1
	// PixbufErrorBadOption: a bad option was passed to a pixbuf save module.
	PixbufErrorBadOption PixbufError = 2
	// PixbufErrorUnknownType: unknown image type.
	PixbufErrorUnknownType PixbufError = 3
	// PixbufErrorUnsupportedOperation: don't know how to perform the given
	// operation on the type of image at hand.
	PixbufErrorUnsupportedOperation PixbufError = 4
	// PixbufErrorFailed: generic failure code, something went wrong.
	PixbufErrorFailed PixbufError = 5
	// PixbufErrorIncompleteAnimation: only part of the animation was loaded.
	PixbufErrorIncompleteAnimation PixbufError = 6
)

func marshalPixbufError(p uintptr) (interface{}, error) {
	return PixbufError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PixbufRotation: the possible rotations which can be passed to
// gdk_pixbuf_rotate_simple().
//
// To make them easier to use, their numerical values are the actual degrees.
type PixbufRotation int

const (
	// PixbufRotationNone: no rotation.
	PixbufRotationNone PixbufRotation = 0
	// PixbufRotationCounterclockwise: rotate by 90 degrees.
	PixbufRotationCounterclockwise PixbufRotation = 90
	// PixbufRotationUpsidedown: rotate by 180 degrees.
	PixbufRotationUpsidedown PixbufRotation = 180
	// PixbufRotationClockwise: rotate by 270 degrees.
	PixbufRotationClockwise PixbufRotation = 270
)

func marshalPixbufRotation(p uintptr) (interface{}, error) {
	return PixbufRotation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Pixbuf: a pixel buffer.
//
// `GdkPixbuf` contains information about an image's pixel data, its color
// space, bits per sample, width and height, and the rowstride (the number of
// bytes between the start of one row and the start of the next).
//
// Creating new `GdkPixbuf`
//
// The most basic way to create a pixbuf is to wrap an existing pixel buffer
// with a [class@GdkPixbuf.Pixbuf] instance. You can use the
// [`ctor@GdkPixbuf.Pixbuf.new_from_data`] function to do this.
//
// Every time you create a new `GdkPixbuf` instance for some data, you will need
// to specify the destroy notification function that will be called when the
// data buffer needs to be freed; this will happen when a `GdkPixbuf` is
// finalized by the reference counting functions. If you have a chunk of static
// data compiled into your application, you can pass in `NULL` as the destroy
// notification function so that the data will not be freed.
//
// The [`ctor@GdkPixbuf.Pixbuf.new`] constructor function can be used as a
// convenience to create a pixbuf with an empty buffer; this is equivalent to
// allocating a data buffer using `malloc()` and then wrapping it with
// `gdk_pixbuf_new_from_data()`. The `gdk_pixbuf_new()` function will compute an
// optimal rowstride so that rendering can be performed with an efficient
// algorithm.
//
// As a special case, you can use the
// [`ctor@GdkPixbuf.Pixbuf.new_from_xpm_data`] function to create a pixbuf from
// inline XPM image data.
//
// You can also copy an existing pixbuf with the [method@Pixbuf.copy] function.
// This is not the same as just acquiring a reference to the old pixbuf
// instance: the copy function will actually duplicate the pixel data in memory
// and create a new [class@Pixbuf] instance for it.
//
//
// Reference counting
//
// `GdkPixbuf` structures are reference counted. This means that an application
// can share a single pixbuf among many parts of the code. When a piece of the
// program needs to use a pixbuf, it should acquire a reference to it by calling
// `g_object_ref()`; when it no longer needs the pixbuf, it should release the
// reference it acquired by calling `g_object_unref()`. The resources associated
// with a `GdkPixbuf` will be freed when its reference count drops to zero.
// Newly-created `GdkPixbuf` instances start with a reference count of one.
//
//
// Image Data
//
// Image data in a pixbuf is stored in memory in an uncompressed, packed format.
// Rows in the image are stored top to bottom, and in each row pixels are stored
// from left to right.
//
// There may be padding at the end of a row.
//
// The "rowstride" value of a pixbuf, as returned by
// [`method@GdkPixbuf.Pixbuf.get_rowstride`], indicates the number of bytes
// between rows.
//
// **NOTE**: If you are copying raw pixbuf data with `memcpy()` note that the
// last row in the pixbuf may not be as wide as the full rowstride, but rather
// just as wide as the pixel data needs to be; that is: it is unsafe to do
// `memcpy (dest, pixels, rowstride * height)` to copy a whole pixbuf. Use
// [method@GdkPixbuf.Pixbuf.copy] instead, or compute the width in bytes of the
// last row as:
//
// “`c last_row = width * ((n_channels * bits_per_sample + 7) / 8); “`
//
// The same rule applies when iterating over each row of a `GdkPixbuf` pixels
// array.
//
// The following code illustrates a simple `put_pixel()` function for RGB
// pixbufs with 8 bits per channel with an alpha channel.
//
// “`c static void put_pixel (GdkPixbuf *pixbuf, int x, int y, guchar red,
// guchar green, guchar blue, guchar alpha) { int n_channels =
// gdk_pixbuf_get_n_channels (pixbuf);
//
//    // Ensure that the pixbuf is valid
//    g_assert (gdk_pixbuf_get_colorspace (pixbuf) == GDK_COLORSPACE_RGB);
//    g_assert (gdk_pixbuf_get_bits_per_sample (pixbuf) == 8);
//    g_assert (gdk_pixbuf_get_has_alpha (pixbuf));
//    g_assert (n_channels == 4);
//
//    int width = gdk_pixbuf_get_width (pixbuf);
//    int height = gdk_pixbuf_get_height (pixbuf);
//
//    // Ensure that the coordinates are in a valid range
//    g_assert (x >= 0 && x < width);
//    g_assert (y >= 0 && y < height);
//
//    int rowstride = gdk_pixbuf_get_rowstride (pixbuf);
//
//    // The pixel buffer in the GdkPixbuf instance
//    guchar *pixels = gdk_pixbuf_get_pixels (pixbuf);
//
//    // The pixel we wish to modify
//    guchar *p = pixels + y * rowstride + x * n_channels;
//    p[0] = red;
//    p[1] = green;
//    p[2] = blue;
//    p[3] = alpha;
//
// } “`
//
//
// Loading images
//
// The `GdkPixBuf` class provides a simple mechanism for loading an image from a
// file in synchronous and asynchronous fashion.
//
// For GUI applications, it is recommended to use the asynchronous stream API to
// avoid blocking the control flow of the application.
//
// Additionally, `GdkPixbuf` provides the [class@GdkPixbuf.PixbufLoader`] API
// for progressive image loading.
//
//
// Saving images
//
// The `GdkPixbuf` class provides methods for saving image data in a number of
// file formats. The formatted data can be written to a file or to a memory
// buffer. `GdkPixbuf` can also call a user-defined callback on the data, which
// allows to e.g. write the image to a socket or store it in a database.
type Pixbuf interface {
	gextras.Objector
	gio.Icon

	// AddAlpha takes an existing pixbuf and adds an alpha channel to it.
	//
	// If the existing pixbuf already had an alpha channel, the channel values
	// are copied from the original; otherwise, the alpha channel is initialized
	// to 255 (full opacity).
	//
	// If `substitute_color` is `TRUE`, then the color specified by the (`r`,
	// `g`, `b`) arguments will be assigned zero opacity. That is, if you pass
	// `(255, 255, 255)` for the substitute color, all white pixels will become
	// fully transparent.
	//
	// If `substitute_color` is `FALSE`, then the (`r`, `g`, `b`) arguments will
	// be ignored.
	AddAlpha(substituteColor bool, r byte, g byte, b byte) Pixbuf
	// ApplyEmbeddedOrientation takes an existing pixbuf and checks for the
	// presence of an associated "orientation" option.
	//
	// The orientation option may be provided by the JPEG loader (which reads
	// the exif orientation tag) or the TIFF loader (which reads the TIFF
	// orientation tag, and compensates it for the partial transforms performed
	// by libtiff).
	//
	// If an orientation option/tag is present, the appropriate transform will
	// be performed so that the pixbuf is oriented correctly.
	ApplyEmbeddedOrientation() Pixbuf
	// Composite creates a transformation of the source image @src by scaling by
	// @scale_x and @scale_y then translating by @offset_x and @offset_y.
	//
	// This gives an image in the coordinates of the destination pixbuf. The
	// rectangle (@dest_x, @dest_y, @dest_width, @dest_height) is then alpha
	// blended onto the corresponding rectangle of the original destination
	// image.
	//
	// When the destination rectangle contains parts not in the source image,
	// the data at the edges of the source image is replicated to infinity.
	//
	// ! (composite.png)
	Composite(dest Pixbuf, destX int, destY int, destWidth int, destHeight int, offsetX float64, offsetY float64, scaleX float64, scaleY float64, interpType InterpType, overallAlpha int)
	// CompositeColor creates a transformation of the source image @src by
	// scaling by @scale_x and @scale_y then translating by @offset_x and
	// @offset_y, then alpha blends the rectangle (@dest_x ,@dest_y,
	// @dest_width, @dest_height) of the resulting image with a checkboard of
	// the colors @color1 and @color2 and renders it onto the destination image.
	//
	// If the source image has no alpha channel, and @overall_alpha is 255, a
	// fast path is used which omits the alpha blending and just performs the
	// scaling.
	//
	// See gdk_pixbuf_composite_color_simple() for a simpler variant of this
	// function suitable for many tasks.
	CompositeColor(dest Pixbuf, destX int, destY int, destWidth int, destHeight int, offsetX float64, offsetY float64, scaleX float64, scaleY float64, interpType InterpType, overallAlpha int, checkX int, checkY int, checkSize int, color1 uint32, color2 uint32)
	// CompositeColorSimple creates a new pixbuf by scaling `src` to
	// `dest_width` x `dest_height` and alpha blending the result with a
	// checkboard of colors `color1` and `color2`.
	CompositeColorSimple(destWidth int, destHeight int, interpType InterpType, overallAlpha int, checkSize int, color1 uint32, color2 uint32) Pixbuf
	// Copy creates a new `GdkPixbuf` with a copy of the information in the
	// specified `pixbuf`.
	//
	// Note that this does not copy the options set on the original `GdkPixbuf`,
	// use gdk_pixbuf_copy_options() for this.
	Copy() Pixbuf
	// CopyArea copies a rectangular area from `src_pixbuf` to `dest_pixbuf`.
	//
	// Conversion of pixbuf formats is done automatically.
	//
	// If the source rectangle overlaps the destination rectangle on the same
	// pixbuf, it will be overwritten during the copy operation. Therefore, you
	// can not use this function to scroll a pixbuf.
	CopyArea(srcX int, srcY int, width int, height int, destPixbuf Pixbuf, destX int, destY int)
	// CopyOptions copies the key/value pair options attached to a `GdkPixbuf`
	// to another `GdkPixbuf`.
	//
	// This is useful to keep original metadata after having manipulated a file.
	// However be careful to remove metadata which you've already applied, such
	// as the "orientation" option after rotating the image.
	CopyOptions(destPixbuf Pixbuf) bool
	// Fill clears a pixbuf to the given RGBA value, converting the RGBA value
	// into the pixbuf's pixel format.
	//
	// The alpha component will be ignored if the pixbuf doesn't have an alpha
	// channel.
	Fill(pixel uint32)
	// Flip flips a pixbuf horizontally or vertically and returns the result in
	// a new pixbuf.
	Flip(horizontal bool) Pixbuf
	// BitsPerSample queries the number of bits per color sample in a pixbuf.
	BitsPerSample() int
	// ByteLength returns the length of the pixel data, in bytes.
	ByteLength() uint
	// Colorspace queries the color space of a pixbuf.
	Colorspace() Colorspace
	// HasAlpha queries whether a pixbuf has an alpha channel (opacity
	// information).
	HasAlpha() bool
	// Height queries the height of a pixbuf.
	Height() int
	// NChannels queries the number of channels of a pixbuf.
	NChannels() int
	// Option looks up @key in the list of options that may have been attached
	// to the @pixbuf when it was loaded, or that may have been attached by
	// another function using gdk_pixbuf_set_option().
	//
	// For instance, the ANI loader provides "Title" and "Artist" options. The
	// ICO, XBM, and XPM loaders provide "x_hot" and "y_hot" hot-spot options
	// for cursor definitions. The PNG loader provides the tEXt ancillary chunk
	// key/value pairs as options. Since 2.12, the TIFF and JPEG loaders return
	// an "orientation" option string that corresponds to the embedded TIFF/Exif
	// orientation tag (if present). Since 2.32, the TIFF loader sets the
	// "multipage" option string to "yes" when a multi-page TIFF is loaded.
	// Since 2.32 the JPEG and PNG loaders set "x-dpi" and "y-dpi" if the file
	// contains image density information in dots per inch. Since 2.36.6, the
	// JPEG loader sets the "comment" option with the comment EXIF tag.
	Option(key string) string
	// Options returns a `GHashTable` with a list of all the options that may
	// have been attached to the `pixbuf` when it was loaded, or that may have
	// been attached by another function using
	// [method@GdkPixbuf.Pixbuf.set_option].
	Options() *glib.HashTable
	// PixelsWithLength queries a pointer to the pixel data of a pixbuf.
	//
	// This function will cause an implicit copy of the pixbuf data if the
	// pixbuf was created from read-only data.
	//
	// Please see the section on image data (#image-data) for information about
	// how the pixel data is stored in memory.
	PixelsWithLength() []byte
	// Rowstride queries the rowstride of a pixbuf, which is the number of bytes
	// between the start of a row and the start of the next row.
	Rowstride() int
	// Width queries the width of a pixbuf.
	Width() int
	// NewSubpixbuf creates a new pixbuf which represents a sub-region of
	// `src_pixbuf`.
	//
	// The new pixbuf shares its pixels with the original pixbuf, so writing to
	// one affects both. The new pixbuf holds a reference to `src_pixbuf`, so
	// `src_pixbuf` will not be finalized until the new pixbuf is finalized.
	//
	// Note that if `src_pixbuf` is read-only, this function will force it to be
	// mutable.
	NewSubpixbuf(srcX int, srcY int, width int, height int) Pixbuf
	// ReadPixelBytes provides a #GBytes buffer containing the raw pixel data;
	// the data must not be modified.
	//
	// This function allows skipping the implicit copy that must be made if
	// gdk_pixbuf_get_pixels() is called on a read-only pixbuf.
	ReadPixelBytes() *glib.Bytes
	// ReadPixels provides a read-only pointer to the raw pixel data.
	//
	// This function allows skipping the implicit copy that must be made if
	// gdk_pixbuf_get_pixels() is called on a read-only pixbuf.
	ReadPixels() byte
	// Ref adds a reference to a pixbuf.
	Ref() Pixbuf
	// RemoveOption removes the key/value pair option attached to a `GdkPixbuf`.
	RemoveOption(key string) bool
	// RotateSimple rotates a pixbuf by a multiple of 90 degrees, and returns
	// the result in a new pixbuf.
	//
	// If `angle` is 0, this function will return a copy of `src`.
	RotateSimple(angle PixbufRotation) Pixbuf
	// SaturateAndPixelate modifies saturation and optionally pixelates `src`,
	// placing the result in `dest`.
	//
	// The `src` and `dest` pixbufs must have the same image format, size, and
	// rowstride.
	//
	// The `src` and `dest` arguments may be the same pixbuf with no ill
	// effects.
	//
	// If `saturation` is 1.0 then saturation is not changed. If it's less than
	// 1.0, saturation is reduced (the image turns toward grayscale); if greater
	// than 1.0, saturation is increased (the image gets more vivid colors).
	//
	// If `pixelate` is `TRUE`, then pixels are faded in a checkerboard pattern
	// to create a pixelated image.
	SaturateAndPixelate(dest Pixbuf, saturation float32, pixelate bool)
	// SaveToStreamv saves `pixbuf` to an output stream.
	//
	// Supported file formats are currently "jpeg", "tiff", "png", "ico" or
	// "bmp".
	//
	// See [method@GdkPixbuf.Pixbuf.save_to_stream] for more details.
	SaveToStreamv(stream gio.OutputStream, typ string, optionKeys []string, optionValues []string, cancellable gio.Cancellable) error
	// SaveToStreamvAsync saves `pixbuf` to an output stream asynchronously.
	//
	// For more details see gdk_pixbuf_save_to_streamv(), which is the
	// synchronous version of this function.
	//
	// When the operation is finished, `callback` will be called in the main
	// thread.
	//
	// You can then call gdk_pixbuf_save_to_stream_finish() to get the result of
	// the operation.
	SaveToStreamvAsync()
	// Savev: vector version of `gdk_pixbuf_save()`.
	//
	// Saves pixbuf to a file in `type`, which is currently "jpeg", "png",
	// "tiff", "ico" or "bmp".
	//
	// If @error is set, `FALSE` will be returned.
	//
	// See [method@GdkPixbuf.Pixbuf.save] for more details.
	Savev(filename string, typ string, optionKeys []string, optionValues []string) error
	// Scale creates a transformation of the source image @src by scaling by
	// @scale_x and @scale_y then translating by @offset_x and @offset_y, then
	// renders the rectangle (@dest_x, @dest_y, @dest_width, @dest_height) of
	// the resulting image onto the destination image replacing the previous
	// contents.
	//
	// Try to use gdk_pixbuf_scale_simple() first; this function is the
	// industrial-strength power tool you can fall back to, if
	// gdk_pixbuf_scale_simple() isn't powerful enough.
	//
	// If the source rectangle overlaps the destination rectangle on the same
	// pixbuf, it will be overwritten during the scaling which results in
	// rendering artifacts.
	Scale(dest Pixbuf, destX int, destY int, destWidth int, destHeight int, offsetX float64, offsetY float64, scaleX float64, scaleY float64, interpType InterpType)
	// ScaleSimple: create a new pixbuf containing a copy of `src` scaled to
	// `dest_width` x `dest_height`.
	//
	// This function leaves `src` unaffected.
	//
	// The `interp_type` should be `GDK_INTERP_NEAREST` if you want maximum
	// speed (but when scaling down `GDK_INTERP_NEAREST` is usually unusably
	// ugly). The default `interp_type` should be `GDK_INTERP_BILINEAR` which
	// offers reasonable quality and speed.
	//
	// You can scale a sub-portion of `src` by creating a sub-pixbuf pointing
	// into `src`; see [method@GdkPixbuf.Pixbuf.new_subpixbuf].
	//
	// If `dest_width` and `dest_height` are equal to the width and height of
	// `src`, this function will return an unscaled copy of `src`.
	//
	// For more complicated scaling/alpha blending see
	// [method@GdkPixbuf.Pixbuf.scale] and [method@GdkPixbuf.Pixbuf.composite].
	ScaleSimple(destWidth int, destHeight int, interpType InterpType) Pixbuf
	// SetOption attaches a key/value pair as an option to a `GdkPixbuf`.
	//
	// If `key` already exists in the list of options attached to the `pixbuf`,
	// the new value is ignored and `FALSE` is returned.
	SetOption(key string, value string) bool
	// Unref removes a reference from a pixbuf.
	Unref()
}

// pixbuf implements the Pixbuf interface.
type pixbuf struct {
	gextras.Objector
	gio.Icon
}

var _ Pixbuf = (*pixbuf)(nil)

// WrapPixbuf wraps a GObject to the right type. It is
// primarily used internally.
func WrapPixbuf(obj *externglib.Object) Pixbuf {
	return Pixbuf{
		Objector: obj,
		gio.Icon: gio.WrapIcon(obj),
	}
}

func marshalPixbuf(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPixbuf(obj), nil
}

// NewPixbuf constructs a class Pixbuf.
func NewPixbuf(colorspace Colorspace, hasAlpha bool, bitsPerSample int, width int, height int) Pixbuf {
	var arg1 C.GdkColorspace
	var arg2 C.gboolean
	var arg3 C.int
	var arg4 C.int
	var arg5 C.int

	arg1 = (C.GdkColorspace)(colorspace)
	if hasAlpha {
		arg2 = C.gboolean(1)
	}
	arg3 = C.int(bitsPerSample)
	arg4 = C.int(width)
	arg5 = C.int(height)

	cret := new(C.GdkPixbuf)
	var goret Pixbuf

	cret = C.gdk_pixbuf_new(arg1, arg2, arg3, arg4, arg5)

	goret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Pixbuf)

	return goret
}

// NewPixbufFromBytes constructs a class Pixbuf.
func NewPixbufFromBytes(data *glib.Bytes, colorspace Colorspace, hasAlpha bool, bitsPerSample int, width int, height int, rowstride int) Pixbuf {
	var arg1 *C.GBytes
	var arg2 C.GdkColorspace
	var arg3 C.gboolean
	var arg4 C.int
	var arg5 C.int
	var arg6 C.int
	var arg7 C.int

	arg1 = (*C.GBytes)(unsafe.Pointer(data.Native()))
	arg2 = (C.GdkColorspace)(colorspace)
	if hasAlpha {
		arg3 = C.gboolean(1)
	}
	arg4 = C.int(bitsPerSample)
	arg5 = C.int(width)
	arg6 = C.int(height)
	arg7 = C.int(rowstride)

	cret := new(C.GdkPixbuf)
	var goret Pixbuf

	cret = C.gdk_pixbuf_new_from_bytes(arg1, arg2, arg3, arg4, arg5, arg6, arg7)

	goret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Pixbuf)

	return goret
}

// NewPixbufFromData constructs a class Pixbuf.
func NewPixbufFromData() Pixbuf {
	cret := new(C.GdkPixbuf)
	var goret Pixbuf

	cret = C.gdk_pixbuf_new_from_data(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)

	goret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Pixbuf)

	return goret
}

// NewPixbufFromFile constructs a class Pixbuf.
func NewPixbufFromFile(filename string) (pixbuf Pixbuf, err error) {
	var arg1 *C.char

	arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	cret := new(C.GdkPixbuf)
	var goret Pixbuf
	var cerr *C.GError
	var goerr error

	cret = C.gdk_pixbuf_new_from_file(arg1, &cerr)

	goret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Pixbuf)
	goerr = gerror.Take(unsafe.Pointer(cerr))

	return goret, goerr
}

// NewPixbufFromFileAtScale constructs a class Pixbuf.
func NewPixbufFromFileAtScale(filename string, width int, height int, preserveAspectRatio bool) (pixbuf Pixbuf, err error) {
	var arg1 *C.char
	var arg2 C.int
	var arg3 C.int
	var arg4 C.gboolean

	arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(width)
	arg3 = C.int(height)
	if preserveAspectRatio {
		arg4 = C.gboolean(1)
	}

	cret := new(C.GdkPixbuf)
	var goret Pixbuf
	var cerr *C.GError
	var goerr error

	cret = C.gdk_pixbuf_new_from_file_at_scale(arg1, arg2, arg3, arg4, &cerr)

	goret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Pixbuf)
	goerr = gerror.Take(unsafe.Pointer(cerr))

	return goret, goerr
}

// NewPixbufFromFileAtSize constructs a class Pixbuf.
func NewPixbufFromFileAtSize(filename string, width int, height int) (pixbuf Pixbuf, err error) {
	var arg1 *C.char
	var arg2 C.int
	var arg3 C.int

	arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(width)
	arg3 = C.int(height)

	cret := new(C.GdkPixbuf)
	var goret Pixbuf
	var cerr *C.GError
	var goerr error

	cret = C.gdk_pixbuf_new_from_file_at_size(arg1, arg2, arg3, &cerr)

	goret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Pixbuf)
	goerr = gerror.Take(unsafe.Pointer(cerr))

	return goret, goerr
}

// NewPixbufFromResource constructs a class Pixbuf.
func NewPixbufFromResource(resourcePath string) (pixbuf Pixbuf, err error) {
	var arg1 *C.char

	arg1 = (*C.char)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(arg1))

	cret := new(C.GdkPixbuf)
	var goret Pixbuf
	var cerr *C.GError
	var goerr error

	cret = C.gdk_pixbuf_new_from_resource(arg1, &cerr)

	goret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Pixbuf)
	goerr = gerror.Take(unsafe.Pointer(cerr))

	return goret, goerr
}

// NewPixbufFromResourceAtScale constructs a class Pixbuf.
func NewPixbufFromResourceAtScale(resourcePath string, width int, height int, preserveAspectRatio bool) (pixbuf Pixbuf, err error) {
	var arg1 *C.char
	var arg2 C.int
	var arg3 C.int
	var arg4 C.gboolean

	arg1 = (*C.char)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(width)
	arg3 = C.int(height)
	if preserveAspectRatio {
		arg4 = C.gboolean(1)
	}

	cret := new(C.GdkPixbuf)
	var goret Pixbuf
	var cerr *C.GError
	var goerr error

	cret = C.gdk_pixbuf_new_from_resource_at_scale(arg1, arg2, arg3, arg4, &cerr)

	goret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Pixbuf)
	goerr = gerror.Take(unsafe.Pointer(cerr))

	return goret, goerr
}

// NewPixbufFromStream constructs a class Pixbuf.
func NewPixbufFromStream(stream gio.InputStream, cancellable gio.Cancellable) (pixbuf Pixbuf, err error) {
	var arg1 *C.GInputStream
	var arg2 *C.GCancellable

	arg1 = (*C.GInputStream)(unsafe.Pointer(stream.Native()))
	arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	cret := new(C.GdkPixbuf)
	var goret Pixbuf
	var cerr *C.GError
	var goerr error

	cret = C.gdk_pixbuf_new_from_stream(arg1, arg2, &cerr)

	goret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Pixbuf)
	goerr = gerror.Take(unsafe.Pointer(cerr))

	return goret, goerr
}

// NewPixbufFromStreamAtScale constructs a class Pixbuf.
func NewPixbufFromStreamAtScale(stream gio.InputStream, width int, height int, preserveAspectRatio bool, cancellable gio.Cancellable) (pixbuf Pixbuf, err error) {
	var arg1 *C.GInputStream
	var arg2 C.gint
	var arg3 C.gint
	var arg4 C.gboolean
	var arg5 *C.GCancellable

	arg1 = (*C.GInputStream)(unsafe.Pointer(stream.Native()))
	arg2 = C.gint(width)
	arg3 = C.gint(height)
	if preserveAspectRatio {
		arg4 = C.gboolean(1)
	}
	arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	cret := new(C.GdkPixbuf)
	var goret Pixbuf
	var cerr *C.GError
	var goerr error

	cret = C.gdk_pixbuf_new_from_stream_at_scale(arg1, arg2, arg3, arg4, arg5, &cerr)

	goret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Pixbuf)
	goerr = gerror.Take(unsafe.Pointer(cerr))

	return goret, goerr
}

// NewPixbufFromStreamFinish constructs a class Pixbuf.
func NewPixbufFromStreamFinish(asyncResult gio.AsyncResult) (pixbuf Pixbuf, err error) {
	var arg1 *C.GAsyncResult

	arg1 = (*C.GAsyncResult)(unsafe.Pointer(asyncResult.Native()))

	cret := new(C.GdkPixbuf)
	var goret Pixbuf
	var cerr *C.GError
	var goerr error

	cret = C.gdk_pixbuf_new_from_stream_finish(arg1, &cerr)

	goret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Pixbuf)
	goerr = gerror.Take(unsafe.Pointer(cerr))

	return goret, goerr
}

// NewPixbufFromXpmData constructs a class Pixbuf.
func NewPixbufFromXpmData(data []string) Pixbuf {
	var arg1 **C.char

	arg1 = (**C.char)(C.malloc((len(data) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(arg1))

	{
		var out []*C.char
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg1), int(len(data)))

		for i := range data {
			out[i] = (*C.char)(C.CString(data[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	cret := new(C.GdkPixbuf)
	var goret Pixbuf

	cret = C.gdk_pixbuf_new_from_xpm_data(arg1)

	goret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Pixbuf)

	return goret
}

// AddAlpha takes an existing pixbuf and adds an alpha channel to it.
//
// If the existing pixbuf already had an alpha channel, the channel values
// are copied from the original; otherwise, the alpha channel is initialized
// to 255 (full opacity).
//
// If `substitute_color` is `TRUE`, then the color specified by the (`r`,
// `g`, `b`) arguments will be assigned zero opacity. That is, if you pass
// `(255, 255, 255)` for the substitute color, all white pixels will become
// fully transparent.
//
// If `substitute_color` is `FALSE`, then the (`r`, `g`, `b`) arguments will
// be ignored.
func (p pixbuf) AddAlpha(substituteColor bool, r byte, g byte, b byte) Pixbuf {
	var arg0 *C.GdkPixbuf
	var arg1 C.gboolean
	var arg2 C.guchar
	var arg3 C.guchar
	var arg4 C.guchar

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))
	if substituteColor {
		arg1 = C.gboolean(1)
	}
	arg2 = C.guchar(r)
	arg3 = C.guchar(g)
	arg4 = C.guchar(b)

	cret := new(C.GdkPixbuf)
	var goret Pixbuf

	cret = C.gdk_pixbuf_add_alpha(arg0, arg1, arg2, arg3, arg4)

	goret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Pixbuf)

	return goret
}

// ApplyEmbeddedOrientation takes an existing pixbuf and checks for the
// presence of an associated "orientation" option.
//
// The orientation option may be provided by the JPEG loader (which reads
// the exif orientation tag) or the TIFF loader (which reads the TIFF
// orientation tag, and compensates it for the partial transforms performed
// by libtiff).
//
// If an orientation option/tag is present, the appropriate transform will
// be performed so that the pixbuf is oriented correctly.
func (s pixbuf) ApplyEmbeddedOrientation() Pixbuf {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))

	cret := new(C.GdkPixbuf)
	var goret Pixbuf

	cret = C.gdk_pixbuf_apply_embedded_orientation(arg0)

	goret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Pixbuf)

	return goret
}

// Composite creates a transformation of the source image @src by scaling by
// @scale_x and @scale_y then translating by @offset_x and @offset_y.
//
// This gives an image in the coordinates of the destination pixbuf. The
// rectangle (@dest_x, @dest_y, @dest_width, @dest_height) is then alpha
// blended onto the corresponding rectangle of the original destination
// image.
//
// When the destination rectangle contains parts not in the source image,
// the data at the edges of the source image is replicated to infinity.
//
// ! (composite.png)
func (s pixbuf) Composite(dest Pixbuf, destX int, destY int, destWidth int, destHeight int, offsetX float64, offsetY float64, scaleX float64, scaleY float64, interpType InterpType, overallAlpha int) {
	var arg0 *C.GdkPixbuf
	var arg1 *C.GdkPixbuf
	var arg2 C.int
	var arg3 C.int
	var arg4 C.int
	var arg5 C.int
	var arg6 C.double
	var arg7 C.double
	var arg8 C.double
	var arg9 C.double
	var arg10 C.GdkInterpType
	var arg11 C.int

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GdkPixbuf)(unsafe.Pointer(dest.Native()))
	arg2 = C.int(destX)
	arg3 = C.int(destY)
	arg4 = C.int(destWidth)
	arg5 = C.int(destHeight)
	arg6 = C.double(offsetX)
	arg7 = C.double(offsetY)
	arg8 = C.double(scaleX)
	arg9 = C.double(scaleY)
	arg10 = (C.GdkInterpType)(interpType)
	arg11 = C.int(overallAlpha)

	C.gdk_pixbuf_composite(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11)
}

// CompositeColor creates a transformation of the source image @src by
// scaling by @scale_x and @scale_y then translating by @offset_x and
// @offset_y, then alpha blends the rectangle (@dest_x ,@dest_y,
// @dest_width, @dest_height) of the resulting image with a checkboard of
// the colors @color1 and @color2 and renders it onto the destination image.
//
// If the source image has no alpha channel, and @overall_alpha is 255, a
// fast path is used which omits the alpha blending and just performs the
// scaling.
//
// See gdk_pixbuf_composite_color_simple() for a simpler variant of this
// function suitable for many tasks.
func (s pixbuf) CompositeColor(dest Pixbuf, destX int, destY int, destWidth int, destHeight int, offsetX float64, offsetY float64, scaleX float64, scaleY float64, interpType InterpType, overallAlpha int, checkX int, checkY int, checkSize int, color1 uint32, color2 uint32) {
	var arg0 *C.GdkPixbuf
	var arg1 *C.GdkPixbuf
	var arg2 C.int
	var arg3 C.int
	var arg4 C.int
	var arg5 C.int
	var arg6 C.double
	var arg7 C.double
	var arg8 C.double
	var arg9 C.double
	var arg10 C.GdkInterpType
	var arg11 C.int
	var arg12 C.int
	var arg13 C.int
	var arg14 C.int
	var arg15 C.guint32
	var arg16 C.guint32

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GdkPixbuf)(unsafe.Pointer(dest.Native()))
	arg2 = C.int(destX)
	arg3 = C.int(destY)
	arg4 = C.int(destWidth)
	arg5 = C.int(destHeight)
	arg6 = C.double(offsetX)
	arg7 = C.double(offsetY)
	arg8 = C.double(scaleX)
	arg9 = C.double(scaleY)
	arg10 = (C.GdkInterpType)(interpType)
	arg11 = C.int(overallAlpha)
	arg12 = C.int(checkX)
	arg13 = C.int(checkY)
	arg14 = C.int(checkSize)
	arg15 = C.guint32(color1)
	arg16 = C.guint32(color2)

	C.gdk_pixbuf_composite_color(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16)
}

// CompositeColorSimple creates a new pixbuf by scaling `src` to
// `dest_width` x `dest_height` and alpha blending the result with a
// checkboard of colors `color1` and `color2`.
func (s pixbuf) CompositeColorSimple(destWidth int, destHeight int, interpType InterpType, overallAlpha int, checkSize int, color1 uint32, color2 uint32) Pixbuf {
	var arg0 *C.GdkPixbuf
	var arg1 C.int
	var arg2 C.int
	var arg3 C.GdkInterpType
	var arg4 C.int
	var arg5 C.int
	var arg6 C.guint32
	var arg7 C.guint32

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	arg1 = C.int(destWidth)
	arg2 = C.int(destHeight)
	arg3 = (C.GdkInterpType)(interpType)
	arg4 = C.int(overallAlpha)
	arg5 = C.int(checkSize)
	arg6 = C.guint32(color1)
	arg7 = C.guint32(color2)

	cret := new(C.GdkPixbuf)
	var goret Pixbuf

	cret = C.gdk_pixbuf_composite_color_simple(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)

	goret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Pixbuf)

	return goret
}

// Copy creates a new `GdkPixbuf` with a copy of the information in the
// specified `pixbuf`.
//
// Note that this does not copy the options set on the original `GdkPixbuf`,
// use gdk_pixbuf_copy_options() for this.
func (p pixbuf) Copy() Pixbuf {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	cret := new(C.GdkPixbuf)
	var goret Pixbuf

	cret = C.gdk_pixbuf_copy(arg0)

	goret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Pixbuf)

	return goret
}

// CopyArea copies a rectangular area from `src_pixbuf` to `dest_pixbuf`.
//
// Conversion of pixbuf formats is done automatically.
//
// If the source rectangle overlaps the destination rectangle on the same
// pixbuf, it will be overwritten during the copy operation. Therefore, you
// can not use this function to scroll a pixbuf.
func (s pixbuf) CopyArea(srcX int, srcY int, width int, height int, destPixbuf Pixbuf, destX int, destY int) {
	var arg0 *C.GdkPixbuf
	var arg1 C.int
	var arg2 C.int
	var arg3 C.int
	var arg4 C.int
	var arg5 *C.GdkPixbuf
	var arg6 C.int
	var arg7 C.int

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	arg1 = C.int(srcX)
	arg2 = C.int(srcY)
	arg3 = C.int(width)
	arg4 = C.int(height)
	arg5 = (*C.GdkPixbuf)(unsafe.Pointer(destPixbuf.Native()))
	arg6 = C.int(destX)
	arg7 = C.int(destY)

	C.gdk_pixbuf_copy_area(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
}

// CopyOptions copies the key/value pair options attached to a `GdkPixbuf`
// to another `GdkPixbuf`.
//
// This is useful to keep original metadata after having manipulated a file.
// However be careful to remove metadata which you've already applied, such
// as the "orientation" option after rotating the image.
func (s pixbuf) CopyOptions(destPixbuf Pixbuf) bool {
	var arg0 *C.GdkPixbuf
	var arg1 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GdkPixbuf)(unsafe.Pointer(destPixbuf.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gdk_pixbuf_copy_options(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// Fill clears a pixbuf to the given RGBA value, converting the RGBA value
// into the pixbuf's pixel format.
//
// The alpha component will be ignored if the pixbuf doesn't have an alpha
// channel.
func (p pixbuf) Fill(pixel uint32) {
	var arg0 *C.GdkPixbuf
	var arg1 C.guint32

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))
	arg1 = C.guint32(pixel)

	C.gdk_pixbuf_fill(arg0, arg1)
}

// Flip flips a pixbuf horizontally or vertically and returns the result in
// a new pixbuf.
func (s pixbuf) Flip(horizontal bool) Pixbuf {
	var arg0 *C.GdkPixbuf
	var arg1 C.gboolean

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	if horizontal {
		arg1 = C.gboolean(1)
	}

	cret := new(C.GdkPixbuf)
	var goret Pixbuf

	cret = C.gdk_pixbuf_flip(arg0, arg1)

	goret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Pixbuf)

	return goret
}

// BitsPerSample queries the number of bits per color sample in a pixbuf.
func (p pixbuf) BitsPerSample() int {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var cret C.int
	var goret int

	cret = C.gdk_pixbuf_get_bits_per_sample(arg0)

	goret = int(cret)

	return goret
}

// ByteLength returns the length of the pixel data, in bytes.
func (p pixbuf) ByteLength() uint {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var cret C.gsize
	var goret uint

	cret = C.gdk_pixbuf_get_byte_length(arg0)

	goret = uint(cret)

	return goret
}

// Colorspace queries the color space of a pixbuf.
func (p pixbuf) Colorspace() Colorspace {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var cret C.GdkColorspace
	var goret Colorspace

	cret = C.gdk_pixbuf_get_colorspace(arg0)

	goret = Colorspace(cret)

	return goret
}

// HasAlpha queries whether a pixbuf has an alpha channel (opacity
// information).
func (p pixbuf) HasAlpha() bool {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gdk_pixbuf_get_has_alpha(arg0)

	if cret {
		goret = true
	}

	return goret
}

// Height queries the height of a pixbuf.
func (p pixbuf) Height() int {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var cret C.int
	var goret int

	cret = C.gdk_pixbuf_get_height(arg0)

	goret = int(cret)

	return goret
}

// NChannels queries the number of channels of a pixbuf.
func (p pixbuf) NChannels() int {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var cret C.int
	var goret int

	cret = C.gdk_pixbuf_get_n_channels(arg0)

	goret = int(cret)

	return goret
}

// Option looks up @key in the list of options that may have been attached
// to the @pixbuf when it was loaded, or that may have been attached by
// another function using gdk_pixbuf_set_option().
//
// For instance, the ANI loader provides "Title" and "Artist" options. The
// ICO, XBM, and XPM loaders provide "x_hot" and "y_hot" hot-spot options
// for cursor definitions. The PNG loader provides the tEXt ancillary chunk
// key/value pairs as options. Since 2.12, the TIFF and JPEG loaders return
// an "orientation" option string that corresponds to the embedded TIFF/Exif
// orientation tag (if present). Since 2.32, the TIFF loader sets the
// "multipage" option string to "yes" when a multi-page TIFF is loaded.
// Since 2.32 the JPEG and PNG loaders set "x-dpi" and "y-dpi" if the file
// contains image density information in dots per inch. Since 2.36.6, the
// JPEG loader sets the "comment" option with the comment EXIF tag.
func (p pixbuf) Option(key string) string {
	var arg0 *C.GdkPixbuf
	var arg1 *C.gchar

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.gchar
	var goret string

	cret = C.gdk_pixbuf_get_option(arg0, arg1)

	goret = C.GoString(cret)

	return goret
}

// Options returns a `GHashTable` with a list of all the options that may
// have been attached to the `pixbuf` when it was loaded, or that may have
// been attached by another function using
// [method@GdkPixbuf.Pixbuf.set_option].
func (p pixbuf) Options() *glib.HashTable {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	cret := new(C.GHashTable)
	var goret *glib.HashTable

	cret = C.gdk_pixbuf_get_options(arg0)

	goret = glib.WrapHashTable(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *glib.HashTable) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// PixelsWithLength queries a pointer to the pixel data of a pixbuf.
//
// This function will cause an implicit copy of the pixbuf data if the
// pixbuf was created from read-only data.
//
// Please see the section on image data (#image-data) for information about
// how the pixel data is stored in memory.
func (p pixbuf) PixelsWithLength() []byte {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var cret *C.guchar
	var arg1 *C.guint
	var goret []byte

	cret = C.gdk_pixbuf_get_pixels_with_length(arg0, arg1)

	goret = make([]byte, arg1)
	for i := 0; i < uintptr(arg1); i++ {
		src := (C.guchar)(ptr.Add(unsafe.Pointer(cret), i))
		goret[i] = byte(src)
	}

	return ret1, goret
}

// Rowstride queries the rowstride of a pixbuf, which is the number of bytes
// between the start of a row and the start of the next row.
func (p pixbuf) Rowstride() int {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var cret C.int
	var goret int

	cret = C.gdk_pixbuf_get_rowstride(arg0)

	goret = int(cret)

	return goret
}

// Width queries the width of a pixbuf.
func (p pixbuf) Width() int {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var cret C.int
	var goret int

	cret = C.gdk_pixbuf_get_width(arg0)

	goret = int(cret)

	return goret
}

// NewSubpixbuf creates a new pixbuf which represents a sub-region of
// `src_pixbuf`.
//
// The new pixbuf shares its pixels with the original pixbuf, so writing to
// one affects both. The new pixbuf holds a reference to `src_pixbuf`, so
// `src_pixbuf` will not be finalized until the new pixbuf is finalized.
//
// Note that if `src_pixbuf` is read-only, this function will force it to be
// mutable.
func (s pixbuf) NewSubpixbuf(srcX int, srcY int, width int, height int) Pixbuf {
	var arg0 *C.GdkPixbuf
	var arg1 C.int
	var arg2 C.int
	var arg3 C.int
	var arg4 C.int

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	arg1 = C.int(srcX)
	arg2 = C.int(srcY)
	arg3 = C.int(width)
	arg4 = C.int(height)

	cret := new(C.GdkPixbuf)
	var goret Pixbuf

	cret = C.gdk_pixbuf_new_subpixbuf(arg0, arg1, arg2, arg3, arg4)

	goret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Pixbuf)

	return goret
}

// ReadPixelBytes provides a #GBytes buffer containing the raw pixel data;
// the data must not be modified.
//
// This function allows skipping the implicit copy that must be made if
// gdk_pixbuf_get_pixels() is called on a read-only pixbuf.
func (p pixbuf) ReadPixelBytes() *glib.Bytes {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	cret := new(C.GBytes)
	var goret *glib.Bytes

	cret = C.gdk_pixbuf_read_pixel_bytes(arg0)

	goret = glib.WrapBytes(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *glib.Bytes) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// ReadPixels provides a read-only pointer to the raw pixel data.
//
// This function allows skipping the implicit copy that must be made if
// gdk_pixbuf_get_pixels() is called on a read-only pixbuf.
func (p pixbuf) ReadPixels() byte {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var cret *C.guint8
	var goret byte

	cret = C.gdk_pixbuf_read_pixels(arg0)

	goret = byte(cret)

	return goret
}

// Ref adds a reference to a pixbuf.
func (p pixbuf) Ref() Pixbuf {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var cret *C.GdkPixbuf
	var goret Pixbuf

	cret = C.gdk_pixbuf_ref(arg0)

	goret = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Pixbuf)

	return goret
}

// RemoveOption removes the key/value pair option attached to a `GdkPixbuf`.
func (p pixbuf) RemoveOption(key string) bool {
	var arg0 *C.GdkPixbuf
	var arg1 *C.gchar

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.gboolean
	var goret bool

	cret = C.gdk_pixbuf_remove_option(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// RotateSimple rotates a pixbuf by a multiple of 90 degrees, and returns
// the result in a new pixbuf.
//
// If `angle` is 0, this function will return a copy of `src`.
func (s pixbuf) RotateSimple(angle PixbufRotation) Pixbuf {
	var arg0 *C.GdkPixbuf
	var arg1 C.GdkPixbufRotation

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	arg1 = (C.GdkPixbufRotation)(angle)

	cret := new(C.GdkPixbuf)
	var goret Pixbuf

	cret = C.gdk_pixbuf_rotate_simple(arg0, arg1)

	goret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Pixbuf)

	return goret
}

// SaturateAndPixelate modifies saturation and optionally pixelates `src`,
// placing the result in `dest`.
//
// The `src` and `dest` pixbufs must have the same image format, size, and
// rowstride.
//
// The `src` and `dest` arguments may be the same pixbuf with no ill
// effects.
//
// If `saturation` is 1.0 then saturation is not changed. If it's less than
// 1.0, saturation is reduced (the image turns toward grayscale); if greater
// than 1.0, saturation is increased (the image gets more vivid colors).
//
// If `pixelate` is `TRUE`, then pixels are faded in a checkerboard pattern
// to create a pixelated image.
func (s pixbuf) SaturateAndPixelate(dest Pixbuf, saturation float32, pixelate bool) {
	var arg0 *C.GdkPixbuf
	var arg1 *C.GdkPixbuf
	var arg2 C.gfloat
	var arg3 C.gboolean

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GdkPixbuf)(unsafe.Pointer(dest.Native()))
	arg2 = C.gfloat(saturation)
	if pixelate {
		arg3 = C.gboolean(1)
	}

	C.gdk_pixbuf_saturate_and_pixelate(arg0, arg1, arg2, arg3)
}

// SaveToStreamv saves `pixbuf` to an output stream.
//
// Supported file formats are currently "jpeg", "tiff", "png", "ico" or
// "bmp".
//
// See [method@GdkPixbuf.Pixbuf.save_to_stream] for more details.
func (p pixbuf) SaveToStreamv(stream gio.OutputStream, typ string, optionKeys []string, optionValues []string, cancellable gio.Cancellable) error {
	var arg0 *C.GdkPixbuf
	var arg1 *C.GOutputStream
	var arg2 *C.char
	var arg3 **C.char
	var arg4 **C.char
	var arg5 *C.GCancellable

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))
	arg1 = (*C.GOutputStream)(unsafe.Pointer(stream.Native()))
	arg2 = (*C.char)(C.CString(typ))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (**C.char)(C.malloc((len(optionKeys) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(arg3))

	{
		var out []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg3), int(len(optionKeys)))

		for i := range optionKeys {
			out[i] = (*C.gchar)(C.CString(optionKeys[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}
	arg4 = (**C.char)(C.malloc((len(optionValues) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(arg4))

	{
		var out []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg4), int(len(optionValues)))

		for i := range optionValues {
			out[i] = (*C.gchar)(C.CString(optionValues[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}
	arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var cerr *C.GError
	var goerr error

	C.gdk_pixbuf_save_to_streamv(arg0, arg1, arg2, arg3, arg4, arg5, &cerr)

	goerr = gerror.Take(unsafe.Pointer(cerr))

	return goerr
}

// SaveToStreamvAsync saves `pixbuf` to an output stream asynchronously.
//
// For more details see gdk_pixbuf_save_to_streamv(), which is the
// synchronous version of this function.
//
// When the operation is finished, `callback` will be called in the main
// thread.
//
// You can then call gdk_pixbuf_save_to_stream_finish() to get the result of
// the operation.
func (p pixbuf) SaveToStreamvAsync() {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	C.gdk_pixbuf_save_to_streamv_async(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
}

// Savev: vector version of `gdk_pixbuf_save()`.
//
// Saves pixbuf to a file in `type`, which is currently "jpeg", "png",
// "tiff", "ico" or "bmp".
//
// If @error is set, `FALSE` will be returned.
//
// See [method@GdkPixbuf.Pixbuf.save] for more details.
func (p pixbuf) Savev(filename string, typ string, optionKeys []string, optionValues []string) error {
	var arg0 *C.GdkPixbuf
	var arg1 *C.char
	var arg2 *C.char
	var arg3 **C.char
	var arg4 **C.char

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))
	arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.char)(C.CString(typ))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (**C.char)(C.malloc((len(optionKeys) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(arg3))

	{
		var out []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg3), int(len(optionKeys)))

		for i := range optionKeys {
			out[i] = (*C.gchar)(C.CString(optionKeys[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}
	arg4 = (**C.char)(C.malloc((len(optionValues) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(arg4))

	{
		var out []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg4), int(len(optionValues)))

		for i := range optionValues {
			out[i] = (*C.gchar)(C.CString(optionValues[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	var cerr *C.GError
	var goerr error

	C.gdk_pixbuf_savev(arg0, arg1, arg2, arg3, arg4, &cerr)

	goerr = gerror.Take(unsafe.Pointer(cerr))

	return goerr
}

// Scale creates a transformation of the source image @src by scaling by
// @scale_x and @scale_y then translating by @offset_x and @offset_y, then
// renders the rectangle (@dest_x, @dest_y, @dest_width, @dest_height) of
// the resulting image onto the destination image replacing the previous
// contents.
//
// Try to use gdk_pixbuf_scale_simple() first; this function is the
// industrial-strength power tool you can fall back to, if
// gdk_pixbuf_scale_simple() isn't powerful enough.
//
// If the source rectangle overlaps the destination rectangle on the same
// pixbuf, it will be overwritten during the scaling which results in
// rendering artifacts.
func (s pixbuf) Scale(dest Pixbuf, destX int, destY int, destWidth int, destHeight int, offsetX float64, offsetY float64, scaleX float64, scaleY float64, interpType InterpType) {
	var arg0 *C.GdkPixbuf
	var arg1 *C.GdkPixbuf
	var arg2 C.int
	var arg3 C.int
	var arg4 C.int
	var arg5 C.int
	var arg6 C.double
	var arg7 C.double
	var arg8 C.double
	var arg9 C.double
	var arg10 C.GdkInterpType

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GdkPixbuf)(unsafe.Pointer(dest.Native()))
	arg2 = C.int(destX)
	arg3 = C.int(destY)
	arg4 = C.int(destWidth)
	arg5 = C.int(destHeight)
	arg6 = C.double(offsetX)
	arg7 = C.double(offsetY)
	arg8 = C.double(scaleX)
	arg9 = C.double(scaleY)
	arg10 = (C.GdkInterpType)(interpType)

	C.gdk_pixbuf_scale(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)
}

// ScaleSimple: create a new pixbuf containing a copy of `src` scaled to
// `dest_width` x `dest_height`.
//
// This function leaves `src` unaffected.
//
// The `interp_type` should be `GDK_INTERP_NEAREST` if you want maximum
// speed (but when scaling down `GDK_INTERP_NEAREST` is usually unusably
// ugly). The default `interp_type` should be `GDK_INTERP_BILINEAR` which
// offers reasonable quality and speed.
//
// You can scale a sub-portion of `src` by creating a sub-pixbuf pointing
// into `src`; see [method@GdkPixbuf.Pixbuf.new_subpixbuf].
//
// If `dest_width` and `dest_height` are equal to the width and height of
// `src`, this function will return an unscaled copy of `src`.
//
// For more complicated scaling/alpha blending see
// [method@GdkPixbuf.Pixbuf.scale] and [method@GdkPixbuf.Pixbuf.composite].
func (s pixbuf) ScaleSimple(destWidth int, destHeight int, interpType InterpType) Pixbuf {
	var arg0 *C.GdkPixbuf
	var arg1 C.int
	var arg2 C.int
	var arg3 C.GdkInterpType

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	arg1 = C.int(destWidth)
	arg2 = C.int(destHeight)
	arg3 = (C.GdkInterpType)(interpType)

	cret := new(C.GdkPixbuf)
	var goret Pixbuf

	cret = C.gdk_pixbuf_scale_simple(arg0, arg1, arg2, arg3)

	goret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Pixbuf)

	return goret
}

// SetOption attaches a key/value pair as an option to a `GdkPixbuf`.
//
// If `key` already exists in the list of options attached to the `pixbuf`,
// the new value is ignored and `FALSE` is returned.
func (p pixbuf) SetOption(key string, value string) bool {
	var arg0 *C.GdkPixbuf
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(arg2))

	var cret C.gboolean
	var goret bool

	cret = C.gdk_pixbuf_set_option(arg0, arg1, arg2)

	if cret {
		goret = true
	}

	return goret
}

// Unref removes a reference from a pixbuf.
func (p pixbuf) Unref() {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	C.gdk_pixbuf_unref(arg0)
}

type PixbufNonAnim interface {
	PixbufAnimation
}

// pixbufNonAnim implements the PixbufNonAnim interface.
type pixbufNonAnim struct {
	PixbufAnimation
}

var _ PixbufNonAnim = (*pixbufNonAnim)(nil)

// WrapPixbufNonAnim wraps a GObject to the right type. It is
// primarily used internally.
func WrapPixbufNonAnim(obj *externglib.Object) PixbufNonAnim {
	return PixbufNonAnim{
		PixbufAnimation: WrapPixbufAnimation(obj),
	}
}

func marshalPixbufNonAnim(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPixbufNonAnim(obj), nil
}

// NewPixbufNonAnim constructs a class PixbufNonAnim.
func NewPixbufNonAnim(pixbuf Pixbuf) PixbufNonAnim {
	var arg1 *C.GdkPixbuf

	arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	cret := new(C.GdkPixbufNonAnim)
	var goret PixbufNonAnim

	cret = C.gdk_pixbuf_non_anim_new(arg1)

	goret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(PixbufNonAnim)

	return goret
}

type PixbufSimpleAnimIter interface {
	PixbufAnimationIter
}

// pixbufSimpleAnimIter implements the PixbufSimpleAnimIter interface.
type pixbufSimpleAnimIter struct {
	PixbufAnimationIter
}

var _ PixbufSimpleAnimIter = (*pixbufSimpleAnimIter)(nil)

// WrapPixbufSimpleAnimIter wraps a GObject to the right type. It is
// primarily used internally.
func WrapPixbufSimpleAnimIter(obj *externglib.Object) PixbufSimpleAnimIter {
	return PixbufSimpleAnimIter{
		PixbufAnimationIter: WrapPixbufAnimationIter(obj),
	}
}

func marshalPixbufSimpleAnimIter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPixbufSimpleAnimIter(obj), nil
}
