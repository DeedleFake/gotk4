// Code generated by girgen. DO NOT EDIT.

package gdkpixbuf

import (
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gdk-pixbuf/gdk-pixbuf.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gdk_colorspace_get_type()), F: marshalColorspace},
		{T: externglib.Type(C.gdk_interp_type_get_type()), F: marshalInterpType},
		{T: externglib.Type(C.gdk_pixbuf_alpha_mode_get_type()), F: marshalPixbufAlphaMode},
		{T: externglib.Type(C.gdk_pixbuf_error_get_type()), F: marshalPixbufError},
		{T: externglib.Type(C.gdk_pixbuf_rotation_get_type()), F: marshalPixbufRotation},
		{T: externglib.Type(C.gdk_pixbuf_animation_get_type()), F: marshalPixbufAnimation},
		{T: externglib.Type(C.gdk_pixbuf_animation_iter_get_type()), F: marshalPixbufAnimationIter},
		{T: externglib.Type(C.gdk_pixbuf_simple_anim_iter_get_type()), F: marshalPixbufSimpleAnimIter},
	})
}

// Colorspace: this enumeration defines the color spaces that are supported by
// the gdk-pixbuf library. Currently only RGB is supported.
type Colorspace int

const (
	// ColorspaceRGB indicates a red/green/blue additive color space.
	ColorspaceRGB Colorspace = 0
)

func marshalColorspace(p uintptr) (interface{}, error) {
	return Colorspace(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// InterpType: this enumeration describes the different interpolation modes that
// can be used with the scaling functions. @GDK_INTERP_NEAREST is the fastest
// scaling method, but has horrible quality when scaling down.
// @GDK_INTERP_BILINEAR is the best choice if you aren't sure what to choose, it
// has a good speed/quality balance.
//
// **Note**: Cubic filtering is missing from the list; hyperbolic interpolation
// is just as fast and results in higher quality.
type InterpType int

const (
	// InterpTypeNearest: nearest neighbor sampling; this is the fastest and
	// lowest quality mode. Quality is normally unacceptable when scaling down,
	// but may be OK when scaling up.
	InterpTypeNearest InterpType = 0
	// InterpTypeTiles: this is an accurate simulation of the PostScript image
	// operator without any interpolation enabled. Each pixel is rendered as a
	// tiny parallelogram of solid color, the edges of which are implemented
	// with antialiasing. It resembles nearest neighbor for enlargement, and
	// bilinear for reduction.
	InterpTypeTiles InterpType = 1
	// InterpTypeBilinear: best quality/speed balance; use this mode by default.
	// Bilinear interpolation. For enlargement, it is equivalent to
	// point-sampling the ideal bilinear-interpolated image. For reduction, it
	// is equivalent to laying down small tiles and integrating over the
	// coverage area.
	InterpTypeBilinear InterpType = 2
	// InterpTypeHyper: this is the slowest and highest quality reconstruction
	// function. It is derived from the hyperbolic filters in Wolberg's "Digital
	// Image Warping", and is formally defined as the hyperbolic-filter sampling
	// the ideal hyperbolic-filter interpolated image (the filter is designed to
	// be idempotent for 1:1 pixel mapping). **Deprecated**: this interpolation
	// filter is deprecated, as in reality it has a lower quality than the
	// @GDK_INTERP_BILINEAR filter (Since: 2.38)
	InterpTypeHyper InterpType = 3
)

func marshalInterpType(p uintptr) (interface{}, error) {
	return InterpType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PixbufAlphaMode: these values can be passed to
// gdk_pixbuf_xlib_render_to_drawable_alpha() to control how the alpha channel
// of an image should be handled. This function can create a bilevel clipping
// mask (black and white) and use it while painting the image. In the future,
// when the X Window System gets an alpha channel extension, it will be possible
// to do full alpha compositing onto arbitrary drawables. For now both cases
// fall back to a bilevel clipping mask.
type PixbufAlphaMode int

const (
	// PixbufAlphaModeBilevel: a bilevel clipping mask (black and white) will be
	// created and used to draw the image. Pixels below 0.5 opacity will be
	// considered fully transparent, and all others will be considered fully
	// opaque.
	PixbufAlphaModeBilevel PixbufAlphaMode = 0
	// PixbufAlphaModeFull: for now falls back to K_PIXBUF_ALPHA_BILEVEL. In the
	// future it will do full alpha compositing.
	PixbufAlphaModeFull PixbufAlphaMode = 1
)

func marshalPixbufAlphaMode(p uintptr) (interface{}, error) {
	return PixbufAlphaMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PixbufError: an error code in the K_PIXBUF_ERROR domain. Many gdk-pixbuf
// operations can cause errors in this domain, or in the FILE_ERROR domain.
type PixbufError int

const (
	// PixbufErrorCorruptImage: an image file was broken somehow.
	PixbufErrorCorruptImage PixbufError = 0
	// PixbufErrorInsufficientMemory: not enough memory.
	PixbufErrorInsufficientMemory PixbufError = 1
	// PixbufErrorBadOption: a bad option was passed to a pixbuf save module.
	PixbufErrorBadOption PixbufError = 2
	// PixbufErrorUnknownType: unknown image type.
	PixbufErrorUnknownType PixbufError = 3
	// PixbufErrorUnsupportedOperation: don't know how to perform the given
	// operation on the type of image at hand.
	PixbufErrorUnsupportedOperation PixbufError = 4
	// PixbufErrorFailed: generic failure code, something went wrong.
	PixbufErrorFailed PixbufError = 5
	// PixbufErrorIncompleteAnimation: only part of the animation was loaded.
	PixbufErrorIncompleteAnimation PixbufError = 6
)

func marshalPixbufError(p uintptr) (interface{}, error) {
	return PixbufError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PixbufRotation: the possible rotations which can be passed to
// gdk_pixbuf_rotate_simple(). To make them easier to use, their numerical
// values are the actual degrees.
type PixbufRotation int

const (
	// PixbufRotationNone: no rotation.
	PixbufRotationNone PixbufRotation = 0
	// PixbufRotationCounterclockwise: rotate by 90 degrees.
	PixbufRotationCounterclockwise PixbufRotation = 90
	// PixbufRotationUpsidedown: rotate by 180 degrees.
	PixbufRotationUpsidedown PixbufRotation = 180
	// PixbufRotationClockwise: rotate by 270 degrees.
	PixbufRotationClockwise PixbufRotation = 270
)

func marshalPixbufRotation(p uintptr) (interface{}, error) {
	return PixbufRotation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Pixbuf: this is the main structure in the gdk-pixbuf library. It is used to
// represent images. It contains information about the image's pixel data, its
// color space, bits per sample, width and height, and the rowstride (the number
// of bytes between the start of one row and the start of the next).
type Pixbuf interface {
	gextras.Objector
	gio.Icon

	// AddAlpha takes an existing pixbuf and adds an alpha channel to it. If the
	// existing pixbuf already had an alpha channel, the channel values are
	// copied from the original; otherwise, the alpha channel is initialized to
	// 255 (full opacity).
	//
	// If @substitute_color is true, then the color specified by (@r, @g, @b)
	// will be assigned zero opacity. That is, if you pass (255, 255, 255) for
	// the substitute color, all white pixels will become fully transparent.
	AddAlpha(substituteColor bool, r byte, g byte, b byte) Pixbuf
	// ApplyEmbeddedOrientation takes an existing pixbuf and checks for the
	// presence of an associated "orientation" option, which may be provided by
	// the jpeg loader (which reads the exif orientation tag) or the tiff loader
	// (which reads the tiff orientation tag, and compensates it for the partial
	// transforms performed by libtiff). If an orientation option/tag is
	// present, the appropriate transform will be performed so that the pixbuf
	// is oriented correctly.
	ApplyEmbeddedOrientation() Pixbuf
	// Composite creates a transformation of the source image @src by scaling by
	// @scale_x and @scale_y then translating by @offset_x and @offset_y. This
	// gives an image in the coordinates of the destination pixbuf. The
	// rectangle (@dest_x, @dest_y, @dest_width, @dest_height) is then alpha
	// blended onto the corresponding rectangle of the original destination
	// image.
	//
	// When the destination rectangle contains parts not in the source image,
	// the data at the edges of the source image is replicated to infinity.
	//
	// ! (composite.png)
	Composite(dest Pixbuf, destX int, destY int, destWidth int, destHeight int, offsetX float64, offsetY float64, scaleX float64, scaleY float64, interpType InterpType, overallAlpha int)
	// CompositeColor creates a transformation of the source image @src by
	// scaling by @scale_x and @scale_y then translating by @offset_x and
	// @offset_y, then alpha blends the rectangle (@dest_x ,@dest_y,
	// @dest_width, @dest_height) of the resulting image with a checkboard of
	// the colors @color1 and @color2 and renders it onto the destination image.
	//
	// If the source image has no alpha channel, and @overall_alpha is 255, a
	// fast path is used which omits the alpha blending and just performs the
	// scaling.
	//
	// See gdk_pixbuf_composite_color_simple() for a simpler variant of this
	// function suitable for many tasks.
	CompositeColor(dest Pixbuf, destX int, destY int, destWidth int, destHeight int, offsetX float64, offsetY float64, scaleX float64, scaleY float64, interpType InterpType, overallAlpha int, checkX int, checkY int, checkSize int, color1 uint32, color2 uint32)
	// CompositeColorSimple creates a new Pixbuf by scaling @src to @dest_width
	// x @dest_height and alpha blending the result with a checkboard of colors
	// @color1 and @color2.
	CompositeColorSimple(destWidth int, destHeight int, interpType InterpType, overallAlpha int, checkSize int, color1 uint32, color2 uint32) Pixbuf
	// Copy creates a new Pixbuf with a copy of the information in the specified
	// @pixbuf. Note that this does not copy the options set on the original
	// Pixbuf, use gdk_pixbuf_copy_options() for this.
	Copy() Pixbuf
	// CopyArea copies a rectangular area from @src_pixbuf to @dest_pixbuf.
	// Conversion of pixbuf formats is done automatically.
	//
	// If the source rectangle overlaps the destination rectangle on the same
	// pixbuf, it will be overwritten during the copy operation. Therefore, you
	// can not use this function to scroll a pixbuf.
	CopyArea(srcX int, srcY int, width int, height int, destPixbuf Pixbuf, destX int, destY int)
	// CopyOptions: copy the key/value pair options attached to a Pixbuf to
	// another. This is useful to keep original metadata after having
	// manipulated a file. However be careful to remove metadata which you've
	// already applied, such as the "orientation" option after rotating the
	// image.
	CopyOptions(destPixbuf Pixbuf) bool
	// Fill clears a pixbuf to the given RGBA value, converting the RGBA value
	// into the pixbuf's pixel format. The alpha will be ignored if the pixbuf
	// doesn't have an alpha channel.
	Fill(pixel uint32)
	// Flip flips a pixbuf horizontally or vertically and returns the result in
	// a new pixbuf.
	Flip(horizontal bool) Pixbuf
	// BitsPerSample queries the number of bits per color sample in a pixbuf.
	BitsPerSample() int
	// ByteLength returns the length of the pixel data, in bytes.
	ByteLength() uint
	// Colorspace queries the color space of a pixbuf.
	Colorspace() Colorspace
	// HasAlpha queries whether a pixbuf has an alpha channel (opacity
	// information).
	HasAlpha() bool
	// Height queries the height of a pixbuf.
	Height() int
	// NChannels queries the number of channels of a pixbuf.
	NChannels() int
	// Option looks up @key in the list of options that may have been attached
	// to the @pixbuf when it was loaded, or that may have been attached by
	// another function using gdk_pixbuf_set_option().
	//
	// For instance, the ANI loader provides "Title" and "Artist" options. The
	// ICO, XBM, and XPM loaders provide "x_hot" and "y_hot" hot-spot options
	// for cursor definitions. The PNG loader provides the tEXt ancillary chunk
	// key/value pairs as options. Since 2.12, the TIFF and JPEG loaders return
	// an "orientation" option string that corresponds to the embedded TIFF/Exif
	// orientation tag (if present). Since 2.32, the TIFF loader sets the
	// "multipage" option string to "yes" when a multi-page TIFF is loaded.
	// Since 2.32 the JPEG and PNG loaders set "x-dpi" and "y-dpi" if the file
	// contains image density information in dots per inch. Since 2.36.6, the
	// JPEG loader sets the "comment" option with the comment EXIF tag.
	Option(key string) string
	// Options returns a Table with a list of all the options that may have been
	// attached to the @pixbuf when it was loaded, or that may have been
	// attached by another function using gdk_pixbuf_set_option().
	//
	// See gdk_pixbuf_get_option() for more details.
	Options() *glib.HashTable
	// PixelsWithLength queries a pointer to the pixel data of a pixbuf.
	PixelsWithLength() []byte
	// Rowstride queries the rowstride of a pixbuf, which is the number of bytes
	// between the start of a row and the start of the next row.
	Rowstride() int
	// Width queries the width of a pixbuf.
	Width() int
	// NewSubpixbuf creates a new pixbuf which represents a sub-region of
	// @src_pixbuf. The new pixbuf shares its pixels with the original pixbuf,
	// so writing to one affects both. The new pixbuf holds a reference to
	// @src_pixbuf, so @src_pixbuf will not be finalized until the new pixbuf is
	// finalized.
	//
	// Note that if @src_pixbuf is read-only, this function will force it to be
	// mutable.
	NewSubpixbuf(srcX int, srcY int, width int, height int) Pixbuf
	// ReadPixels provides a read-only pointer to the raw pixel data; must not
	// be modified. This function allows skipping the implicit copy that must be
	// made if gdk_pixbuf_get_pixels() is called on a read-only pixbuf.
	ReadPixels() *byte
	// Ref adds a reference to a pixbuf.
	Ref() Pixbuf
	// RemoveOption: remove the key/value pair option attached to a Pixbuf.
	RemoveOption(key string) bool
	// RotateSimple rotates a pixbuf by a multiple of 90 degrees, and returns
	// the result in a new pixbuf.
	//
	// If @angle is 0, a copy of @src is returned, avoiding any rotation.
	RotateSimple(angle PixbufRotation) Pixbuf
	// SaturateAndPixelate modifies saturation and optionally pixelates @src,
	// placing the result in @dest. @src and @dest may be the same pixbuf with
	// no ill effects. If @saturation is 1.0 then saturation is not changed. If
	// it's less than 1.0, saturation is reduced (the image turns toward
	// grayscale); if greater than 1.0, saturation is increased (the image gets
	// more vivid colors). If @pixelate is true, then pixels are faded in a
	// checkerboard pattern to create a pixelated image. @src and @dest must
	// have the same image format, size, and rowstride.
	SaturateAndPixelate(dest Pixbuf, saturation float32, pixelate bool)
	// SaveToStreamv saves @pixbuf to an output stream.
	//
	// Supported file formats are currently "jpeg", "tiff", "png", "ico" or
	// "bmp". See gdk_pixbuf_save_to_stream() for more details.
	SaveToStreamv(stream gio.OutputStream, typ string, optionKeys []string, optionValues []string, cancellable gio.Cancellable) error
	// SaveToStreamvAsync saves @pixbuf to an output stream asynchronously.
	//
	// For more details see gdk_pixbuf_save_to_streamv(), which is the
	// synchronous version of this function.
	//
	// When the operation is finished, @callback will be called in the main
	// thread. You can then call gdk_pixbuf_save_to_stream_finish() to get the
	// result of the operation.
	SaveToStreamvAsync()
	// Savev saves pixbuf to a file in @type, which is currently "jpeg", "png",
	// "tiff", "ico" or "bmp". If @error is set, false will be returned. See
	// gdk_pixbuf_save () for more details.
	Savev(filename *string, typ string, optionKeys []string, optionValues []string) error
	// Scale creates a transformation of the source image @src by scaling by
	// @scale_x and @scale_y then translating by @offset_x and @offset_y, then
	// renders the rectangle (@dest_x, @dest_y, @dest_width, @dest_height) of
	// the resulting image onto the destination image replacing the previous
	// contents.
	//
	// Try to use gdk_pixbuf_scale_simple() first, this function is the
	// industrial-strength power tool you can fall back to if
	// gdk_pixbuf_scale_simple() isn't powerful enough.
	//
	// If the source rectangle overlaps the destination rectangle on the same
	// pixbuf, it will be overwritten during the scaling which results in
	// rendering artifacts.
	Scale(dest Pixbuf, destX int, destY int, destWidth int, destHeight int, offsetX float64, offsetY float64, scaleX float64, scaleY float64, interpType InterpType)
	// ScaleSimple: create a new Pixbuf containing a copy of @src scaled to
	// @dest_width x @dest_height. Leaves @src unaffected. @interp_type should
	// be K_INTERP_NEAREST if you want maximum speed (but when scaling down
	// K_INTERP_NEAREST is usually unusably ugly). The default @interp_type
	// should be K_INTERP_BILINEAR which offers reasonable quality and speed.
	//
	// You can scale a sub-portion of @src by creating a sub-pixbuf pointing
	// into @src; see gdk_pixbuf_new_subpixbuf().
	//
	// If @dest_width and @dest_height are equal to the @src width and height, a
	// copy of @src is returned, avoiding any scaling.
	//
	// For more complicated scaling/alpha blending see gdk_pixbuf_scale() and
	// gdk_pixbuf_composite().
	ScaleSimple(destWidth int, destHeight int, interpType InterpType) Pixbuf
	// SetOption attaches a key/value pair as an option to a Pixbuf. If @key
	// already exists in the list of options attached to @pixbuf, the new value
	// is ignored and false is returned.
	SetOption(key string, value string) bool
	// Unref removes a reference from a pixbuf.
	Unref()
}

// pixbuf implements the Pixbuf interface.
type pixbuf struct {
	gextras.Objector
	gio.Icon
}

var _ Pixbuf = (*pixbuf)(nil)

// WrapPixbuf wraps a GObject to the right type. It is
// primarily used internally.
func WrapPixbuf(obj *externglib.Object) Pixbuf {
	return Pixbuf{
		Objector: obj,
		gio.Icon: gio.WrapIcon(obj),
	}
}

func marshalPixbuf(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPixbuf(obj), nil
}

// NewPixbuf constructs a class Pixbuf.
func NewPixbuf(colorspace Colorspace, hasAlpha bool, bitsPerSample int, width int, height int) Pixbuf {
	var _arg1 C.GdkColorspace
	var _arg2 C.gboolean
	var _arg3 C.int
	var _arg4 C.int
	var _arg5 C.int

	_arg1 = (C.GdkColorspace)(colorspace)
	if hasAlpha {
		_arg2 = C.gboolean(1)
	}
	_arg3 = C.int(bitsPerSample)
	_arg4 = C.int(width)
	_arg5 = C.int(height)

	var _cret C.GdkPixbuf

	cret = C.gdk_pixbuf_new(_arg1, _arg2, _arg3, _arg4, _arg5)

	var _pixbuf Pixbuf

	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(Pixbuf)

	return _pixbuf
}

// NewPixbufFromData constructs a class Pixbuf.
func NewPixbufFromData() Pixbuf {
	var _cret C.GdkPixbuf

	cret = C.gdk_pixbuf_new_from_data()

	var _pixbuf Pixbuf

	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(Pixbuf)

	return _pixbuf
}

// NewPixbufFromFile constructs a class Pixbuf.
func NewPixbufFromFile(filename *string) (Pixbuf, error) {
	var _arg1 *C.char

	_arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret C.GdkPixbuf
	var _cerr *C.GError

	cret = C.gdk_pixbuf_new_from_file(_arg1, _cerr)

	var _pixbuf Pixbuf
	var _goerr error

	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(Pixbuf)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _pixbuf, _goerr
}

// NewPixbufFromFileAtScale constructs a class Pixbuf.
func NewPixbufFromFileAtScale(filename *string, width int, height int, preserveAspectRatio bool) (Pixbuf, error) {
	var _arg1 *C.char
	var _arg2 C.int
	var _arg3 C.int
	var _arg4 C.gboolean

	_arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(width)
	_arg3 = C.int(height)
	if preserveAspectRatio {
		_arg4 = C.gboolean(1)
	}

	var _cret C.GdkPixbuf
	var _cerr *C.GError

	cret = C.gdk_pixbuf_new_from_file_at_scale(_arg1, _arg2, _arg3, _arg4, _cerr)

	var _pixbuf Pixbuf
	var _goerr error

	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(Pixbuf)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _pixbuf, _goerr
}

// NewPixbufFromFileAtSize constructs a class Pixbuf.
func NewPixbufFromFileAtSize(filename *string, width int, height int) (Pixbuf, error) {
	var _arg1 *C.char
	var _arg2 C.int
	var _arg3 C.int

	_arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(width)
	_arg3 = C.int(height)

	var _cret C.GdkPixbuf
	var _cerr *C.GError

	cret = C.gdk_pixbuf_new_from_file_at_size(_arg1, _arg2, _arg3, _cerr)

	var _pixbuf Pixbuf
	var _goerr error

	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(Pixbuf)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _pixbuf, _goerr
}

// NewPixbufFromResource constructs a class Pixbuf.
func NewPixbufFromResource(resourcePath string) (Pixbuf, error) {
	var _arg1 *C.char

	_arg1 = (*C.char)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret C.GdkPixbuf
	var _cerr *C.GError

	cret = C.gdk_pixbuf_new_from_resource(_arg1, _cerr)

	var _pixbuf Pixbuf
	var _goerr error

	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(Pixbuf)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _pixbuf, _goerr
}

// NewPixbufFromResourceAtScale constructs a class Pixbuf.
func NewPixbufFromResourceAtScale(resourcePath string, width int, height int, preserveAspectRatio bool) (Pixbuf, error) {
	var _arg1 *C.char
	var _arg2 C.int
	var _arg3 C.int
	var _arg4 C.gboolean

	_arg1 = (*C.char)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(width)
	_arg3 = C.int(height)
	if preserveAspectRatio {
		_arg4 = C.gboolean(1)
	}

	var _cret C.GdkPixbuf
	var _cerr *C.GError

	cret = C.gdk_pixbuf_new_from_resource_at_scale(_arg1, _arg2, _arg3, _arg4, _cerr)

	var _pixbuf Pixbuf
	var _goerr error

	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(Pixbuf)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _pixbuf, _goerr
}

// NewPixbufFromStream constructs a class Pixbuf.
func NewPixbufFromStream(stream gio.InputStream, cancellable gio.Cancellable) (Pixbuf, error) {
	var _arg1 *C.GInputStream
	var _arg2 *C.GCancellable

	_arg1 = (*C.GInputStream)(unsafe.Pointer(stream.Native()))
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var _cret C.GdkPixbuf
	var _cerr *C.GError

	cret = C.gdk_pixbuf_new_from_stream(_arg1, _arg2, _cerr)

	var _pixbuf Pixbuf
	var _goerr error

	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(Pixbuf)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _pixbuf, _goerr
}

// NewPixbufFromStreamAtScale constructs a class Pixbuf.
func NewPixbufFromStreamAtScale(stream gio.InputStream, width int, height int, preserveAspectRatio bool, cancellable gio.Cancellable) (Pixbuf, error) {
	var _arg1 *C.GInputStream
	var _arg2 C.gint
	var _arg3 C.gint
	var _arg4 C.gboolean
	var _arg5 *C.GCancellable

	_arg1 = (*C.GInputStream)(unsafe.Pointer(stream.Native()))
	_arg2 = C.gint(width)
	_arg3 = C.gint(height)
	if preserveAspectRatio {
		_arg4 = C.gboolean(1)
	}
	_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var _cret C.GdkPixbuf
	var _cerr *C.GError

	cret = C.gdk_pixbuf_new_from_stream_at_scale(_arg1, _arg2, _arg3, _arg4, _arg5, _cerr)

	var _pixbuf Pixbuf
	var _goerr error

	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(Pixbuf)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _pixbuf, _goerr
}

// NewPixbufFromStreamFinish constructs a class Pixbuf.
func NewPixbufFromStreamFinish(asyncResult gio.AsyncResult) (Pixbuf, error) {
	var _arg1 *C.GAsyncResult

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(asyncResult.Native()))

	var _cret C.GdkPixbuf
	var _cerr *C.GError

	cret = C.gdk_pixbuf_new_from_stream_finish(_arg1, _cerr)

	var _pixbuf Pixbuf
	var _goerr error

	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(Pixbuf)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _pixbuf, _goerr
}

// NewPixbufFromXpmData constructs a class Pixbuf.
func NewPixbufFromXpmData(data []string) Pixbuf {
	var _arg1 **C.char

	_arg1 = (**C.char)(C.malloc((len(data) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(_arg1))

	{
		var out []*C.char
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(_arg1), int(len(data)))

		for i := range data {
			_arg1 = (*C.char)(C.CString(data))
			defer C.free(unsafe.Pointer(_arg1))
		}
	}

	var _cret C.GdkPixbuf

	cret = C.gdk_pixbuf_new_from_xpm_data(_arg1)

	var _pixbuf Pixbuf

	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(Pixbuf)

	return _pixbuf
}

// AddAlpha takes an existing pixbuf and adds an alpha channel to it. If the
// existing pixbuf already had an alpha channel, the channel values are
// copied from the original; otherwise, the alpha channel is initialized to
// 255 (full opacity).
//
// If @substitute_color is true, then the color specified by (@r, @g, @b)
// will be assigned zero opacity. That is, if you pass (255, 255, 255) for
// the substitute color, all white pixels will become fully transparent.
func (p pixbuf) AddAlpha(substituteColor bool, r byte, g byte, b byte) Pixbuf {
	var _arg0 *C.GdkPixbuf
	var _arg1 C.gboolean
	var _arg2 C.guchar
	var _arg3 C.guchar
	var _arg4 C.guchar

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))
	if substituteColor {
		_arg1 = C.gboolean(1)
	}
	_arg2 = C.guchar(r)
	_arg3 = C.guchar(g)
	_arg4 = C.guchar(b)

	var _cret *C.GdkPixbuf

	cret = C.gdk_pixbuf_add_alpha(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _ret Pixbuf

	_ret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(Pixbuf)

	return _ret
}

// ApplyEmbeddedOrientation takes an existing pixbuf and checks for the
// presence of an associated "orientation" option, which may be provided by
// the jpeg loader (which reads the exif orientation tag) or the tiff loader
// (which reads the tiff orientation tag, and compensates it for the partial
// transforms performed by libtiff). If an orientation option/tag is
// present, the appropriate transform will be performed so that the pixbuf
// is oriented correctly.
func (s pixbuf) ApplyEmbeddedOrientation() Pixbuf {
	var _arg0 *C.GdkPixbuf

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))

	var _cret *C.GdkPixbuf

	cret = C.gdk_pixbuf_apply_embedded_orientation(_arg0)

	var _pixbuf Pixbuf

	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(Pixbuf)

	return _pixbuf
}

// Composite creates a transformation of the source image @src by scaling by
// @scale_x and @scale_y then translating by @offset_x and @offset_y. This
// gives an image in the coordinates of the destination pixbuf. The
// rectangle (@dest_x, @dest_y, @dest_width, @dest_height) is then alpha
// blended onto the corresponding rectangle of the original destination
// image.
//
// When the destination rectangle contains parts not in the source image,
// the data at the edges of the source image is replicated to infinity.
//
// ! (composite.png)
func (s pixbuf) Composite(dest Pixbuf, destX int, destY int, destWidth int, destHeight int, offsetX float64, offsetY float64, scaleX float64, scaleY float64, interpType InterpType, overallAlpha int) {
	var _arg0 *C.GdkPixbuf
	var _arg1 *C.GdkPixbuf
	var _arg2 C.int
	var _arg3 C.int
	var _arg4 C.int
	var _arg5 C.int
	var _arg6 C.double
	var _arg7 C.double
	var _arg8 C.double
	var _arg9 C.double
	var _arg10 C.GdkInterpType
	var _arg11 C.int

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(dest.Native()))
	_arg2 = C.int(destX)
	_arg3 = C.int(destY)
	_arg4 = C.int(destWidth)
	_arg5 = C.int(destHeight)
	_arg6 = C.double(offsetX)
	_arg7 = C.double(offsetY)
	_arg8 = C.double(scaleX)
	_arg9 = C.double(scaleY)
	_arg10 = (C.GdkInterpType)(interpType)
	_arg11 = C.int(overallAlpha)

	C.gdk_pixbuf_composite(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11)
}

// CompositeColor creates a transformation of the source image @src by
// scaling by @scale_x and @scale_y then translating by @offset_x and
// @offset_y, then alpha blends the rectangle (@dest_x ,@dest_y,
// @dest_width, @dest_height) of the resulting image with a checkboard of
// the colors @color1 and @color2 and renders it onto the destination image.
//
// If the source image has no alpha channel, and @overall_alpha is 255, a
// fast path is used which omits the alpha blending and just performs the
// scaling.
//
// See gdk_pixbuf_composite_color_simple() for a simpler variant of this
// function suitable for many tasks.
func (s pixbuf) CompositeColor(dest Pixbuf, destX int, destY int, destWidth int, destHeight int, offsetX float64, offsetY float64, scaleX float64, scaleY float64, interpType InterpType, overallAlpha int, checkX int, checkY int, checkSize int, color1 uint32, color2 uint32) {
	var _arg0 *C.GdkPixbuf
	var _arg1 *C.GdkPixbuf
	var _arg2 C.int
	var _arg3 C.int
	var _arg4 C.int
	var _arg5 C.int
	var _arg6 C.double
	var _arg7 C.double
	var _arg8 C.double
	var _arg9 C.double
	var _arg10 C.GdkInterpType
	var _arg11 C.int
	var _arg12 C.int
	var _arg13 C.int
	var _arg14 C.int
	var _arg15 C.guint32
	var _arg16 C.guint32

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(dest.Native()))
	_arg2 = C.int(destX)
	_arg3 = C.int(destY)
	_arg4 = C.int(destWidth)
	_arg5 = C.int(destHeight)
	_arg6 = C.double(offsetX)
	_arg7 = C.double(offsetY)
	_arg8 = C.double(scaleX)
	_arg9 = C.double(scaleY)
	_arg10 = (C.GdkInterpType)(interpType)
	_arg11 = C.int(overallAlpha)
	_arg12 = C.int(checkX)
	_arg13 = C.int(checkY)
	_arg14 = C.int(checkSize)
	_arg15 = C.guint32(color1)
	_arg16 = C.guint32(color2)

	C.gdk_pixbuf_composite_color(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11, _arg12, _arg13, _arg14, _arg15, _arg16)
}

// CompositeColorSimple creates a new Pixbuf by scaling @src to @dest_width
// x @dest_height and alpha blending the result with a checkboard of colors
// @color1 and @color2.
func (s pixbuf) CompositeColorSimple(destWidth int, destHeight int, interpType InterpType, overallAlpha int, checkSize int, color1 uint32, color2 uint32) Pixbuf {
	var _arg0 *C.GdkPixbuf
	var _arg1 C.int
	var _arg2 C.int
	var _arg3 C.GdkInterpType
	var _arg4 C.int
	var _arg5 C.int
	var _arg6 C.guint32
	var _arg7 C.guint32

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	_arg1 = C.int(destWidth)
	_arg2 = C.int(destHeight)
	_arg3 = (C.GdkInterpType)(interpType)
	_arg4 = C.int(overallAlpha)
	_arg5 = C.int(checkSize)
	_arg6 = C.guint32(color1)
	_arg7 = C.guint32(color2)

	var _cret *C.GdkPixbuf

	cret = C.gdk_pixbuf_composite_color_simple(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)

	var _pixbuf Pixbuf

	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(Pixbuf)

	return _pixbuf
}

// Copy creates a new Pixbuf with a copy of the information in the specified
// @pixbuf. Note that this does not copy the options set on the original
// Pixbuf, use gdk_pixbuf_copy_options() for this.
func (p pixbuf) Copy() Pixbuf {
	var _arg0 *C.GdkPixbuf

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var _cret *C.GdkPixbuf

	cret = C.gdk_pixbuf_copy(_arg0)

	var _ret Pixbuf

	_ret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(Pixbuf)

	return _ret
}

// CopyArea copies a rectangular area from @src_pixbuf to @dest_pixbuf.
// Conversion of pixbuf formats is done automatically.
//
// If the source rectangle overlaps the destination rectangle on the same
// pixbuf, it will be overwritten during the copy operation. Therefore, you
// can not use this function to scroll a pixbuf.
func (s pixbuf) CopyArea(srcX int, srcY int, width int, height int, destPixbuf Pixbuf, destX int, destY int) {
	var _arg0 *C.GdkPixbuf
	var _arg1 C.int
	var _arg2 C.int
	var _arg3 C.int
	var _arg4 C.int
	var _arg5 *C.GdkPixbuf
	var _arg6 C.int
	var _arg7 C.int

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	_arg1 = C.int(srcX)
	_arg2 = C.int(srcY)
	_arg3 = C.int(width)
	_arg4 = C.int(height)
	_arg5 = (*C.GdkPixbuf)(unsafe.Pointer(destPixbuf.Native()))
	_arg6 = C.int(destX)
	_arg7 = C.int(destY)

	C.gdk_pixbuf_copy_area(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
}

// CopyOptions: copy the key/value pair options attached to a Pixbuf to
// another. This is useful to keep original metadata after having
// manipulated a file. However be careful to remove metadata which you've
// already applied, such as the "orientation" option after rotating the
// image.
func (s pixbuf) CopyOptions(destPixbuf Pixbuf) bool {
	var _arg0 *C.GdkPixbuf
	var _arg1 *C.GdkPixbuf

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(destPixbuf.Native()))

	var _cret C.gboolean

	cret = C.gdk_pixbuf_copy_options(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Fill clears a pixbuf to the given RGBA value, converting the RGBA value
// into the pixbuf's pixel format. The alpha will be ignored if the pixbuf
// doesn't have an alpha channel.
func (p pixbuf) Fill(pixel uint32) {
	var _arg0 *C.GdkPixbuf
	var _arg1 C.guint32

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))
	_arg1 = C.guint32(pixel)

	C.gdk_pixbuf_fill(_arg0, _arg1)
}

// Flip flips a pixbuf horizontally or vertically and returns the result in
// a new pixbuf.
func (s pixbuf) Flip(horizontal bool) Pixbuf {
	var _arg0 *C.GdkPixbuf
	var _arg1 C.gboolean

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	if horizontal {
		_arg1 = C.gboolean(1)
	}

	var _cret *C.GdkPixbuf

	cret = C.gdk_pixbuf_flip(_arg0, _arg1)

	var _pixbuf Pixbuf

	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(Pixbuf)

	return _pixbuf
}

// BitsPerSample queries the number of bits per color sample in a pixbuf.
func (p pixbuf) BitsPerSample() int {
	var _arg0 *C.GdkPixbuf

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var _cret C.int

	cret = C.gdk_pixbuf_get_bits_per_sample(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// ByteLength returns the length of the pixel data, in bytes.
func (p pixbuf) ByteLength() uint {
	var _arg0 *C.GdkPixbuf

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var _cret C.gsize

	cret = C.gdk_pixbuf_get_byte_length(_arg0)

	var _gsize uint

	_gsize = (uint)(_cret)

	return _gsize
}

// Colorspace queries the color space of a pixbuf.
func (p pixbuf) Colorspace() Colorspace {
	var _arg0 *C.GdkPixbuf

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var _cret C.GdkColorspace

	cret = C.gdk_pixbuf_get_colorspace(_arg0)

	var _colorspace Colorspace

	_colorspace = Colorspace(_cret)

	return _colorspace
}

// HasAlpha queries whether a pixbuf has an alpha channel (opacity
// information).
func (p pixbuf) HasAlpha() bool {
	var _arg0 *C.GdkPixbuf

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var _cret C.gboolean

	cret = C.gdk_pixbuf_get_has_alpha(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Height queries the height of a pixbuf.
func (p pixbuf) Height() int {
	var _arg0 *C.GdkPixbuf

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var _cret C.int

	cret = C.gdk_pixbuf_get_height(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// NChannels queries the number of channels of a pixbuf.
func (p pixbuf) NChannels() int {
	var _arg0 *C.GdkPixbuf

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var _cret C.int

	cret = C.gdk_pixbuf_get_n_channels(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// Option looks up @key in the list of options that may have been attached
// to the @pixbuf when it was loaded, or that may have been attached by
// another function using gdk_pixbuf_set_option().
//
// For instance, the ANI loader provides "Title" and "Artist" options. The
// ICO, XBM, and XPM loaders provide "x_hot" and "y_hot" hot-spot options
// for cursor definitions. The PNG loader provides the tEXt ancillary chunk
// key/value pairs as options. Since 2.12, the TIFF and JPEG loaders return
// an "orientation" option string that corresponds to the embedded TIFF/Exif
// orientation tag (if present). Since 2.32, the TIFF loader sets the
// "multipage" option string to "yes" when a multi-page TIFF is loaded.
// Since 2.32 the JPEG and PNG loaders set "x-dpi" and "y-dpi" if the file
// contains image density information in dots per inch. Since 2.36.6, the
// JPEG loader sets the "comment" option with the comment EXIF tag.
func (p pixbuf) Option(key string) string {
	var _arg0 *C.GdkPixbuf
	var _arg1 *C.gchar

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret *C.gchar

	cret = C.gdk_pixbuf_get_option(_arg0, _arg1)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Options returns a Table with a list of all the options that may have been
// attached to the @pixbuf when it was loaded, or that may have been
// attached by another function using gdk_pixbuf_set_option().
//
// See gdk_pixbuf_get_option() for more details.
func (p pixbuf) Options() *glib.HashTable {
	var _arg0 *C.GdkPixbuf

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var _cret *C.GHashTable

	cret = C.gdk_pixbuf_get_options(_arg0)

	var _hashTable *glib.HashTable

	_hashTable = glib.WrapHashTable(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_hashTable, func(v *glib.HashTable) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _hashTable
}

// PixelsWithLength queries a pointer to the pixel data of a pixbuf.
func (p pixbuf) PixelsWithLength() []byte {
	var _arg0 *C.GdkPixbuf

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var _cret *C.guchar
	var _arg1 *C.guint

	cret = C.gdk_pixbuf_get_pixels_with_length(_arg0)

	var _guint8s []byte

	{
		var src []C.guchar
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(_cret), int(_arg1))

		_guint8s = make([]byte, _arg1)
		for i := 0; i < uintptr(_arg1); i++ {
			_guint8s = (byte)(_cret)
		}
	}

	return _guint8s
}

// Rowstride queries the rowstride of a pixbuf, which is the number of bytes
// between the start of a row and the start of the next row.
func (p pixbuf) Rowstride() int {
	var _arg0 *C.GdkPixbuf

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var _cret C.int

	cret = C.gdk_pixbuf_get_rowstride(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// Width queries the width of a pixbuf.
func (p pixbuf) Width() int {
	var _arg0 *C.GdkPixbuf

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var _cret C.int

	cret = C.gdk_pixbuf_get_width(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// NewSubpixbuf creates a new pixbuf which represents a sub-region of
// @src_pixbuf. The new pixbuf shares its pixels with the original pixbuf,
// so writing to one affects both. The new pixbuf holds a reference to
// @src_pixbuf, so @src_pixbuf will not be finalized until the new pixbuf is
// finalized.
//
// Note that if @src_pixbuf is read-only, this function will force it to be
// mutable.
func (s pixbuf) NewSubpixbuf(srcX int, srcY int, width int, height int) Pixbuf {
	var _arg0 *C.GdkPixbuf
	var _arg1 C.int
	var _arg2 C.int
	var _arg3 C.int
	var _arg4 C.int

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	_arg1 = C.int(srcX)
	_arg2 = C.int(srcY)
	_arg3 = C.int(width)
	_arg4 = C.int(height)

	var _cret *C.GdkPixbuf

	cret = C.gdk_pixbuf_new_subpixbuf(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _pixbuf Pixbuf

	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(Pixbuf)

	return _pixbuf
}

// ReadPixels provides a read-only pointer to the raw pixel data; must not
// be modified. This function allows skipping the implicit copy that must be
// made if gdk_pixbuf_get_pixels() is called on a read-only pixbuf.
func (p pixbuf) ReadPixels() *byte {
	var _arg0 *C.GdkPixbuf

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var _cret *C.guint8

	cret = C.gdk_pixbuf_read_pixels(_arg0)

	var _guint8 *byte

	_guint8 = (*byte)(_cret)

	return _guint8
}

// Ref adds a reference to a pixbuf.
func (p pixbuf) Ref() Pixbuf {
	var _arg0 *C.GdkPixbuf

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var _cret *C.GdkPixbuf

	cret = C.gdk_pixbuf_ref(_arg0)

	var _ret Pixbuf

	_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret.Native()))).(Pixbuf)

	return _ret
}

// RemoveOption: remove the key/value pair option attached to a Pixbuf.
func (p pixbuf) RemoveOption(key string) bool {
	var _arg0 *C.GdkPixbuf
	var _arg1 *C.gchar

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret C.gboolean

	cret = C.gdk_pixbuf_remove_option(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// RotateSimple rotates a pixbuf by a multiple of 90 degrees, and returns
// the result in a new pixbuf.
//
// If @angle is 0, a copy of @src is returned, avoiding any rotation.
func (s pixbuf) RotateSimple(angle PixbufRotation) Pixbuf {
	var _arg0 *C.GdkPixbuf
	var _arg1 C.GdkPixbufRotation

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GdkPixbufRotation)(angle)

	var _cret *C.GdkPixbuf

	cret = C.gdk_pixbuf_rotate_simple(_arg0, _arg1)

	var _pixbuf Pixbuf

	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(Pixbuf)

	return _pixbuf
}

// SaturateAndPixelate modifies saturation and optionally pixelates @src,
// placing the result in @dest. @src and @dest may be the same pixbuf with
// no ill effects. If @saturation is 1.0 then saturation is not changed. If
// it's less than 1.0, saturation is reduced (the image turns toward
// grayscale); if greater than 1.0, saturation is increased (the image gets
// more vivid colors). If @pixelate is true, then pixels are faded in a
// checkerboard pattern to create a pixelated image. @src and @dest must
// have the same image format, size, and rowstride.
func (s pixbuf) SaturateAndPixelate(dest Pixbuf, saturation float32, pixelate bool) {
	var _arg0 *C.GdkPixbuf
	var _arg1 *C.GdkPixbuf
	var _arg2 C.gfloat
	var _arg3 C.gboolean

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(dest.Native()))
	_arg2 = C.gfloat(saturation)
	if pixelate {
		_arg3 = C.gboolean(1)
	}

	C.gdk_pixbuf_saturate_and_pixelate(_arg0, _arg1, _arg2, _arg3)
}

// SaveToStreamv saves @pixbuf to an output stream.
//
// Supported file formats are currently "jpeg", "tiff", "png", "ico" or
// "bmp". See gdk_pixbuf_save_to_stream() for more details.
func (p pixbuf) SaveToStreamv(stream gio.OutputStream, typ string, optionKeys []string, optionValues []string, cancellable gio.Cancellable) error {
	var _arg0 *C.GdkPixbuf
	var _arg1 *C.GOutputStream
	var _arg2 *C.char
	var _arg3 **C.char
	var _arg4 **C.char
	var _arg5 *C.GCancellable

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GOutputStream)(unsafe.Pointer(stream.Native()))
	_arg2 = (*C.char)(C.CString(typ))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (**C.char)(C.malloc((len(optionKeys) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(_arg3))

	{
		var out []*C.char
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(_arg3), int(len(optionKeys)))

		for i := range optionKeys {
			_arg3 = (*C.char)(C.CString(optionKeys))
			defer C.free(unsafe.Pointer(_arg3))
		}
	}
	_arg4 = (**C.char)(C.malloc((len(optionValues) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(_arg4))

	{
		var out []*C.char
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(_arg4), int(len(optionValues)))

		for i := range optionValues {
			_arg4 = (*C.char)(C.CString(optionValues))
			defer C.free(unsafe.Pointer(_arg4))
		}
	}
	_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var _cerr *C.GError

	C.gdk_pixbuf_save_to_streamv(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _cerr)

	var _goerr error

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// SaveToStreamvAsync saves @pixbuf to an output stream asynchronously.
//
// For more details see gdk_pixbuf_save_to_streamv(), which is the
// synchronous version of this function.
//
// When the operation is finished, @callback will be called in the main
// thread. You can then call gdk_pixbuf_save_to_stream_finish() to get the
// result of the operation.
func (p pixbuf) SaveToStreamvAsync() {
	var _arg0 *C.GdkPixbuf

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	C.gdk_pixbuf_save_to_streamv_async(_arg0)
}

// Savev saves pixbuf to a file in @type, which is currently "jpeg", "png",
// "tiff", "ico" or "bmp". If @error is set, false will be returned. See
// gdk_pixbuf_save () for more details.
func (p pixbuf) Savev(filename *string, typ string, optionKeys []string, optionValues []string) error {
	var _arg0 *C.GdkPixbuf
	var _arg1 *C.char
	var _arg2 *C.char
	var _arg3 **C.char
	var _arg4 **C.char

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(C.CString(typ))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (**C.char)(C.malloc((len(optionKeys) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(_arg3))

	{
		var out []*C.char
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(_arg3), int(len(optionKeys)))

		for i := range optionKeys {
			_arg3 = (*C.char)(C.CString(optionKeys))
			defer C.free(unsafe.Pointer(_arg3))
		}
	}
	_arg4 = (**C.char)(C.malloc((len(optionValues) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(_arg4))

	{
		var out []*C.char
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(_arg4), int(len(optionValues)))

		for i := range optionValues {
			_arg4 = (*C.char)(C.CString(optionValues))
			defer C.free(unsafe.Pointer(_arg4))
		}
	}

	var _cerr *C.GError

	C.gdk_pixbuf_savev(_arg0, _arg1, _arg2, _arg3, _arg4, _cerr)

	var _goerr error

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// Scale creates a transformation of the source image @src by scaling by
// @scale_x and @scale_y then translating by @offset_x and @offset_y, then
// renders the rectangle (@dest_x, @dest_y, @dest_width, @dest_height) of
// the resulting image onto the destination image replacing the previous
// contents.
//
// Try to use gdk_pixbuf_scale_simple() first, this function is the
// industrial-strength power tool you can fall back to if
// gdk_pixbuf_scale_simple() isn't powerful enough.
//
// If the source rectangle overlaps the destination rectangle on the same
// pixbuf, it will be overwritten during the scaling which results in
// rendering artifacts.
func (s pixbuf) Scale(dest Pixbuf, destX int, destY int, destWidth int, destHeight int, offsetX float64, offsetY float64, scaleX float64, scaleY float64, interpType InterpType) {
	var _arg0 *C.GdkPixbuf
	var _arg1 *C.GdkPixbuf
	var _arg2 C.int
	var _arg3 C.int
	var _arg4 C.int
	var _arg5 C.int
	var _arg6 C.double
	var _arg7 C.double
	var _arg8 C.double
	var _arg9 C.double
	var _arg10 C.GdkInterpType

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(dest.Native()))
	_arg2 = C.int(destX)
	_arg3 = C.int(destY)
	_arg4 = C.int(destWidth)
	_arg5 = C.int(destHeight)
	_arg6 = C.double(offsetX)
	_arg7 = C.double(offsetY)
	_arg8 = C.double(scaleX)
	_arg9 = C.double(scaleY)
	_arg10 = (C.GdkInterpType)(interpType)

	C.gdk_pixbuf_scale(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10)
}

// ScaleSimple: create a new Pixbuf containing a copy of @src scaled to
// @dest_width x @dest_height. Leaves @src unaffected. @interp_type should
// be K_INTERP_NEAREST if you want maximum speed (but when scaling down
// K_INTERP_NEAREST is usually unusably ugly). The default @interp_type
// should be K_INTERP_BILINEAR which offers reasonable quality and speed.
//
// You can scale a sub-portion of @src by creating a sub-pixbuf pointing
// into @src; see gdk_pixbuf_new_subpixbuf().
//
// If @dest_width and @dest_height are equal to the @src width and height, a
// copy of @src is returned, avoiding any scaling.
//
// For more complicated scaling/alpha blending see gdk_pixbuf_scale() and
// gdk_pixbuf_composite().
func (s pixbuf) ScaleSimple(destWidth int, destHeight int, interpType InterpType) Pixbuf {
	var _arg0 *C.GdkPixbuf
	var _arg1 C.int
	var _arg2 C.int
	var _arg3 C.GdkInterpType

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	_arg1 = C.int(destWidth)
	_arg2 = C.int(destHeight)
	_arg3 = (C.GdkInterpType)(interpType)

	var _cret *C.GdkPixbuf

	cret = C.gdk_pixbuf_scale_simple(_arg0, _arg1, _arg2, _arg3)

	var _pixbuf Pixbuf

	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(Pixbuf)

	return _pixbuf
}

// SetOption attaches a key/value pair as an option to a Pixbuf. If @key
// already exists in the list of options attached to @pixbuf, the new value
// is ignored and false is returned.
func (p pixbuf) SetOption(key string, value string) bool {
	var _arg0 *C.GdkPixbuf
	var _arg1 *C.gchar
	var _arg2 *C.gchar

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg2))

	var _cret C.gboolean

	cret = C.gdk_pixbuf_set_option(_arg0, _arg1, _arg2)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Unref removes a reference from a pixbuf.
func (p pixbuf) Unref() {
	var _arg0 *C.GdkPixbuf

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	C.gdk_pixbuf_unref(_arg0)
}

// PixbufAnimation: an opaque struct representing an animation.
type PixbufAnimation interface {
	gextras.Objector

	// Height queries the height of the bounding box of a pixbuf animation.
	Height() int
	// Iter: get an iterator for displaying an animation. The iterator provides
	// the frames that should be displayed at a given time. It should be freed
	// after use with g_object_unref().
	//
	// @start_time would normally come from g_get_current_time(), and marks the
	// beginning of animation playback. After creating an iterator, you should
	// immediately display the pixbuf returned by
	// gdk_pixbuf_animation_iter_get_pixbuf(). Then, you should install a
	// timeout (with g_timeout_add()) or by some other mechanism ensure that
	// you'll update the image after gdk_pixbuf_animation_iter_get_delay_time()
	// milliseconds. Each time the image is updated, you should reinstall the
	// timeout with the new, possibly-changed delay time.
	//
	// As a shortcut, if @start_time is nil, the result of g_get_current_time()
	// will be used automatically.
	//
	// To update the image (i.e. possibly change the result of
	// gdk_pixbuf_animation_iter_get_pixbuf() to a new frame of the animation),
	// call gdk_pixbuf_animation_iter_advance().
	//
	// If you're using PixbufLoader, in addition to updating the image after the
	// delay time, you should also update it whenever you receive the
	// area_updated signal and
	// gdk_pixbuf_animation_iter_on_currently_loading_frame() returns true. In
	// this case, the frame currently being fed into the loader has received new
	// data, so needs to be refreshed. The delay time for a frame may also be
	// modified after an area_updated signal, for example if the delay time for
	// a frame is encoded in the data after the frame itself. So your timeout
	// should be reinstalled after any area_updated signal.
	//
	// A delay time of -1 is possible, indicating "infinite."
	Iter(startTime *glib.TimeVal) PixbufAnimationIter
	// StaticImage: if an animation is really just a plain image (has only one
	// frame), this function returns that image. If the animation is an
	// animation, this function returns a reasonable thing to display as a
	// static unanimated image, which might be the first frame, or something
	// more sophisticated. If an animation hasn't loaded any frames yet, this
	// function will return nil.
	StaticImage() Pixbuf
	// Width queries the width of the bounding box of a pixbuf animation.
	Width() int
	// IsStaticImage: if you load a file with
	// gdk_pixbuf_animation_new_from_file() and it turns out to be a plain,
	// unanimated image, then this function will return true. Use
	// gdk_pixbuf_animation_get_static_image() to retrieve the image.
	IsStaticImage() bool
	// Ref adds a reference to an animation.
	Ref() PixbufAnimation
	// Unref removes a reference from an animation.
	Unref()
}

// pixbufAnimation implements the PixbufAnimation interface.
type pixbufAnimation struct {
	gextras.Objector
}

var _ PixbufAnimation = (*pixbufAnimation)(nil)

// WrapPixbufAnimation wraps a GObject to the right type. It is
// primarily used internally.
func WrapPixbufAnimation(obj *externglib.Object) PixbufAnimation {
	return PixbufAnimation{
		Objector: obj,
	}
}

func marshalPixbufAnimation(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPixbufAnimation(obj), nil
}

// NewPixbufAnimationFromFile constructs a class PixbufAnimation.
func NewPixbufAnimationFromFile(filename *string) (PixbufAnimation, error) {
	var _arg1 *C.char

	_arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret C.GdkPixbufAnimation
	var _cerr *C.GError

	cret = C.gdk_pixbuf_animation_new_from_file(_arg1, _cerr)

	var _pixbufAnimation PixbufAnimation
	var _goerr error

	_pixbufAnimation = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(PixbufAnimation)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _pixbufAnimation, _goerr
}

// NewPixbufAnimationFromResource constructs a class PixbufAnimation.
func NewPixbufAnimationFromResource(resourcePath string) (PixbufAnimation, error) {
	var _arg1 *C.char

	_arg1 = (*C.char)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret C.GdkPixbufAnimation
	var _cerr *C.GError

	cret = C.gdk_pixbuf_animation_new_from_resource(_arg1, _cerr)

	var _pixbufAnimation PixbufAnimation
	var _goerr error

	_pixbufAnimation = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(PixbufAnimation)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _pixbufAnimation, _goerr
}

// NewPixbufAnimationFromStream constructs a class PixbufAnimation.
func NewPixbufAnimationFromStream(stream gio.InputStream, cancellable gio.Cancellable) (PixbufAnimation, error) {
	var _arg1 *C.GInputStream
	var _arg2 *C.GCancellable

	_arg1 = (*C.GInputStream)(unsafe.Pointer(stream.Native()))
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var _cret C.GdkPixbufAnimation
	var _cerr *C.GError

	cret = C.gdk_pixbuf_animation_new_from_stream(_arg1, _arg2, _cerr)

	var _pixbufAnimation PixbufAnimation
	var _goerr error

	_pixbufAnimation = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(PixbufAnimation)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _pixbufAnimation, _goerr
}

// NewPixbufAnimationFromStreamFinish constructs a class PixbufAnimation.
func NewPixbufAnimationFromStreamFinish(asyncResult gio.AsyncResult) (PixbufAnimation, error) {
	var _arg1 *C.GAsyncResult

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(asyncResult.Native()))

	var _cret C.GdkPixbufAnimation
	var _cerr *C.GError

	cret = C.gdk_pixbuf_animation_new_from_stream_finish(_arg1, _cerr)

	var _pixbufAnimation PixbufAnimation
	var _goerr error

	_pixbufAnimation = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(PixbufAnimation)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _pixbufAnimation, _goerr
}

// Height queries the height of the bounding box of a pixbuf animation.
func (a pixbufAnimation) Height() int {
	var _arg0 *C.GdkPixbufAnimation

	_arg0 = (*C.GdkPixbufAnimation)(unsafe.Pointer(a.Native()))

	var _cret C.int

	cret = C.gdk_pixbuf_animation_get_height(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// Iter: get an iterator for displaying an animation. The iterator provides
// the frames that should be displayed at a given time. It should be freed
// after use with g_object_unref().
//
// @start_time would normally come from g_get_current_time(), and marks the
// beginning of animation playback. After creating an iterator, you should
// immediately display the pixbuf returned by
// gdk_pixbuf_animation_iter_get_pixbuf(). Then, you should install a
// timeout (with g_timeout_add()) or by some other mechanism ensure that
// you'll update the image after gdk_pixbuf_animation_iter_get_delay_time()
// milliseconds. Each time the image is updated, you should reinstall the
// timeout with the new, possibly-changed delay time.
//
// As a shortcut, if @start_time is nil, the result of g_get_current_time()
// will be used automatically.
//
// To update the image (i.e. possibly change the result of
// gdk_pixbuf_animation_iter_get_pixbuf() to a new frame of the animation),
// call gdk_pixbuf_animation_iter_advance().
//
// If you're using PixbufLoader, in addition to updating the image after the
// delay time, you should also update it whenever you receive the
// area_updated signal and
// gdk_pixbuf_animation_iter_on_currently_loading_frame() returns true. In
// this case, the frame currently being fed into the loader has received new
// data, so needs to be refreshed. The delay time for a frame may also be
// modified after an area_updated signal, for example if the delay time for
// a frame is encoded in the data after the frame itself. So your timeout
// should be reinstalled after any area_updated signal.
//
// A delay time of -1 is possible, indicating "infinite."
func (a pixbufAnimation) Iter(startTime *glib.TimeVal) PixbufAnimationIter {
	var _arg0 *C.GdkPixbufAnimation
	var _arg1 *C.GTimeVal

	_arg0 = (*C.GdkPixbufAnimation)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GTimeVal)(unsafe.Pointer(startTime.Native()))

	var _cret *C.GdkPixbufAnimationIter

	cret = C.gdk_pixbuf_animation_get_iter(_arg0, _arg1)

	var _pixbufAnimationIter PixbufAnimationIter

	_pixbufAnimationIter = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(PixbufAnimationIter)

	return _pixbufAnimationIter
}

// StaticImage: if an animation is really just a plain image (has only one
// frame), this function returns that image. If the animation is an
// animation, this function returns a reasonable thing to display as a
// static unanimated image, which might be the first frame, or something
// more sophisticated. If an animation hasn't loaded any frames yet, this
// function will return nil.
func (a pixbufAnimation) StaticImage() Pixbuf {
	var _arg0 *C.GdkPixbufAnimation

	_arg0 = (*C.GdkPixbufAnimation)(unsafe.Pointer(a.Native()))

	var _cret *C.GdkPixbuf

	cret = C.gdk_pixbuf_animation_get_static_image(_arg0)

	var _pixbuf Pixbuf

	_pixbuf = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret.Native()))).(Pixbuf)

	return _pixbuf
}

// Width queries the width of the bounding box of a pixbuf animation.
func (a pixbufAnimation) Width() int {
	var _arg0 *C.GdkPixbufAnimation

	_arg0 = (*C.GdkPixbufAnimation)(unsafe.Pointer(a.Native()))

	var _cret C.int

	cret = C.gdk_pixbuf_animation_get_width(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// IsStaticImage: if you load a file with
// gdk_pixbuf_animation_new_from_file() and it turns out to be a plain,
// unanimated image, then this function will return true. Use
// gdk_pixbuf_animation_get_static_image() to retrieve the image.
func (a pixbufAnimation) IsStaticImage() bool {
	var _arg0 *C.GdkPixbufAnimation

	_arg0 = (*C.GdkPixbufAnimation)(unsafe.Pointer(a.Native()))

	var _cret C.gboolean

	cret = C.gdk_pixbuf_animation_is_static_image(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Ref adds a reference to an animation.
func (a pixbufAnimation) Ref() PixbufAnimation {
	var _arg0 *C.GdkPixbufAnimation

	_arg0 = (*C.GdkPixbufAnimation)(unsafe.Pointer(a.Native()))

	var _cret *C.GdkPixbufAnimation

	cret = C.gdk_pixbuf_animation_ref(_arg0)

	var _pixbufAnimation PixbufAnimation

	_pixbufAnimation = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret.Native()))).(PixbufAnimation)

	return _pixbufAnimation
}

// Unref removes a reference from an animation.
func (a pixbufAnimation) Unref() {
	var _arg0 *C.GdkPixbufAnimation

	_arg0 = (*C.GdkPixbufAnimation)(unsafe.Pointer(a.Native()))

	C.gdk_pixbuf_animation_unref(_arg0)
}

// PixbufAnimationIter: an opaque struct representing an iterator which points
// to a certain position in an animation.
type PixbufAnimationIter interface {
	gextras.Objector

	// Advance: possibly advances an animation to a new frame. Chooses the frame
	// based on the start time passed to gdk_pixbuf_animation_get_iter().
	//
	// @current_time would normally come from g_get_current_time(), and must be
	// greater than or equal to the time passed to
	// gdk_pixbuf_animation_get_iter(), and must increase or remain unchanged
	// each time gdk_pixbuf_animation_iter_get_pixbuf() is called. That is, you
	// can't go backward in time; animations only play forward.
	//
	// As a shortcut, pass nil for the current time and g_get_current_time()
	// will be invoked on your behalf. So you only need to explicitly pass
	// @current_time if you're doing something odd like playing the animation at
	// double speed.
	//
	// If this function returns false, there's no need to update the animation
	// display, assuming the display had been rendered prior to advancing; if
	// true, you need to call gdk_pixbuf_animation_iter_get_pixbuf() and update
	// the display with the new pixbuf.
	Advance(currentTime *glib.TimeVal) bool
	// DelayTime gets the number of milliseconds the current pixbuf should be
	// displayed, or -1 if the current pixbuf should be displayed forever.
	// g_timeout_add() conveniently takes a timeout in milliseconds, so you can
	// use a timeout to schedule the next update.
	//
	// Note that some formats, like GIF, might clamp the timeout values in the
	// image file to avoid updates that are just too quick. The minimum timeout
	// for GIF images is currently 20 milliseconds.
	DelayTime() int
	// Pixbuf gets the current pixbuf which should be displayed; the pixbuf
	// might not be the same size as the animation itself
	// (gdk_pixbuf_animation_get_width(), gdk_pixbuf_animation_get_height()).
	// This pixbuf should be displayed for
	// gdk_pixbuf_animation_iter_get_delay_time() milliseconds. The caller of
	// this function does not own a reference to the returned pixbuf; the
	// returned pixbuf will become invalid when the iterator advances to the
	// next frame, which may happen anytime you call
	// gdk_pixbuf_animation_iter_advance(). Copy the pixbuf to keep it (don't
	// just add a reference), as it may get recycled as you advance the
	// iterator.
	Pixbuf() Pixbuf
	// OnCurrentlyLoadingFrame: used to determine how to respond to the
	// area_updated signal on PixbufLoader when loading an animation.
	// area_updated is emitted for an area of the frame currently streaming in
	// to the loader. So if you're on the currently loading frame, you need to
	// redraw the screen for the updated area.
	OnCurrentlyLoadingFrame() bool
}

// pixbufAnimationIter implements the PixbufAnimationIter interface.
type pixbufAnimationIter struct {
	gextras.Objector
}

var _ PixbufAnimationIter = (*pixbufAnimationIter)(nil)

// WrapPixbufAnimationIter wraps a GObject to the right type. It is
// primarily used internally.
func WrapPixbufAnimationIter(obj *externglib.Object) PixbufAnimationIter {
	return PixbufAnimationIter{
		Objector: obj,
	}
}

func marshalPixbufAnimationIter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPixbufAnimationIter(obj), nil
}

// Advance: possibly advances an animation to a new frame. Chooses the frame
// based on the start time passed to gdk_pixbuf_animation_get_iter().
//
// @current_time would normally come from g_get_current_time(), and must be
// greater than or equal to the time passed to
// gdk_pixbuf_animation_get_iter(), and must increase or remain unchanged
// each time gdk_pixbuf_animation_iter_get_pixbuf() is called. That is, you
// can't go backward in time; animations only play forward.
//
// As a shortcut, pass nil for the current time and g_get_current_time()
// will be invoked on your behalf. So you only need to explicitly pass
// @current_time if you're doing something odd like playing the animation at
// double speed.
//
// If this function returns false, there's no need to update the animation
// display, assuming the display had been rendered prior to advancing; if
// true, you need to call gdk_pixbuf_animation_iter_get_pixbuf() and update
// the display with the new pixbuf.
func (i pixbufAnimationIter) Advance(currentTime *glib.TimeVal) bool {
	var _arg0 *C.GdkPixbufAnimationIter
	var _arg1 *C.GTimeVal

	_arg0 = (*C.GdkPixbufAnimationIter)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GTimeVal)(unsafe.Pointer(currentTime.Native()))

	var _cret C.gboolean

	cret = C.gdk_pixbuf_animation_iter_advance(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// DelayTime gets the number of milliseconds the current pixbuf should be
// displayed, or -1 if the current pixbuf should be displayed forever.
// g_timeout_add() conveniently takes a timeout in milliseconds, so you can
// use a timeout to schedule the next update.
//
// Note that some formats, like GIF, might clamp the timeout values in the
// image file to avoid updates that are just too quick. The minimum timeout
// for GIF images is currently 20 milliseconds.
func (i pixbufAnimationIter) DelayTime() int {
	var _arg0 *C.GdkPixbufAnimationIter

	_arg0 = (*C.GdkPixbufAnimationIter)(unsafe.Pointer(i.Native()))

	var _cret C.int

	cret = C.gdk_pixbuf_animation_iter_get_delay_time(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// Pixbuf gets the current pixbuf which should be displayed; the pixbuf
// might not be the same size as the animation itself
// (gdk_pixbuf_animation_get_width(), gdk_pixbuf_animation_get_height()).
// This pixbuf should be displayed for
// gdk_pixbuf_animation_iter_get_delay_time() milliseconds. The caller of
// this function does not own a reference to the returned pixbuf; the
// returned pixbuf will become invalid when the iterator advances to the
// next frame, which may happen anytime you call
// gdk_pixbuf_animation_iter_advance(). Copy the pixbuf to keep it (don't
// just add a reference), as it may get recycled as you advance the
// iterator.
func (i pixbufAnimationIter) Pixbuf() Pixbuf {
	var _arg0 *C.GdkPixbufAnimationIter

	_arg0 = (*C.GdkPixbufAnimationIter)(unsafe.Pointer(i.Native()))

	var _cret *C.GdkPixbuf

	cret = C.gdk_pixbuf_animation_iter_get_pixbuf(_arg0)

	var _pixbuf Pixbuf

	_pixbuf = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret.Native()))).(Pixbuf)

	return _pixbuf
}

// OnCurrentlyLoadingFrame: used to determine how to respond to the
// area_updated signal on PixbufLoader when loading an animation.
// area_updated is emitted for an area of the frame currently streaming in
// to the loader. So if you're on the currently loading frame, you need to
// redraw the screen for the updated area.
func (i pixbufAnimationIter) OnCurrentlyLoadingFrame() bool {
	var _arg0 *C.GdkPixbufAnimationIter

	_arg0 = (*C.GdkPixbufAnimationIter)(unsafe.Pointer(i.Native()))

	var _cret C.gboolean

	cret = C.gdk_pixbuf_animation_iter_on_currently_loading_frame(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

type PixbufSimpleAnimIter interface {
	PixbufAnimationIter
}

// pixbufSimpleAnimIter implements the PixbufSimpleAnimIter interface.
type pixbufSimpleAnimIter struct {
	PixbufAnimationIter
}

var _ PixbufSimpleAnimIter = (*pixbufSimpleAnimIter)(nil)

// WrapPixbufSimpleAnimIter wraps a GObject to the right type. It is
// primarily used internally.
func WrapPixbufSimpleAnimIter(obj *externglib.Object) PixbufSimpleAnimIter {
	return PixbufSimpleAnimIter{
		PixbufAnimationIter: WrapPixbufAnimationIter(obj),
	}
}

func marshalPixbufSimpleAnimIter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPixbufSimpleAnimIter(obj), nil
}
