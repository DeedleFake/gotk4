// Code generated by girgen. DO NOT EDIT.

package gdkpixbuf

import (
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gdk-pixbuf/gdk-pixbuf.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gdk_colorspace_get_type()), F: marshalColorspace},
		{T: externglib.Type(C.gdk_interp_type_get_type()), F: marshalInterpType},
		{T: externglib.Type(C.gdk_pixbuf_alpha_mode_get_type()), F: marshalPixbufAlphaMode},
		{T: externglib.Type(C.gdk_pixbuf_error_get_type()), F: marshalPixbufError},
		{T: externglib.Type(C.gdk_pixbuf_rotation_get_type()), F: marshalPixbufRotation},
		{T: externglib.Type(C.gdk_pixbuf_animation_get_type()), F: marshalPixbufAnimation},
		{T: externglib.Type(C.gdk_pixbuf_animation_iter_get_type()), F: marshalPixbufAnimationIter},
		{T: externglib.Type(C.gdk_pixbuf_simple_anim_iter_get_type()), F: marshalPixbufSimpleAnimIter},
	})
}

// Colorspace: this enumeration defines the color spaces that are supported by
// the gdk-pixbuf library. Currently only RGB is supported.
type Colorspace int

const (
	// ColorspaceRGB indicates a red/green/blue additive color space.
	ColorspaceRGB Colorspace = 0
)

func marshalColorspace(p uintptr) (interface{}, error) {
	return Colorspace(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// InterpType: this enumeration describes the different interpolation modes that
// can be used with the scaling functions. @GDK_INTERP_NEAREST is the fastest
// scaling method, but has horrible quality when scaling down.
// @GDK_INTERP_BILINEAR is the best choice if you aren't sure what to choose, it
// has a good speed/quality balance.
//
// **Note**: Cubic filtering is missing from the list; hyperbolic interpolation
// is just as fast and results in higher quality.
type InterpType int

const (
	// InterpTypeNearest: nearest neighbor sampling; this is the fastest and
	// lowest quality mode. Quality is normally unacceptable when scaling down,
	// but may be OK when scaling up.
	InterpTypeNearest InterpType = 0
	// InterpTypeTiles: this is an accurate simulation of the PostScript image
	// operator without any interpolation enabled. Each pixel is rendered as a
	// tiny parallelogram of solid color, the edges of which are implemented
	// with antialiasing. It resembles nearest neighbor for enlargement, and
	// bilinear for reduction.
	InterpTypeTiles InterpType = 1
	// InterpTypeBilinear: best quality/speed balance; use this mode by default.
	// Bilinear interpolation. For enlargement, it is equivalent to
	// point-sampling the ideal bilinear-interpolated image. For reduction, it
	// is equivalent to laying down small tiles and integrating over the
	// coverage area.
	InterpTypeBilinear InterpType = 2
	// InterpTypeHyper: this is the slowest and highest quality reconstruction
	// function. It is derived from the hyperbolic filters in Wolberg's "Digital
	// Image Warping", and is formally defined as the hyperbolic-filter sampling
	// the ideal hyperbolic-filter interpolated image (the filter is designed to
	// be idempotent for 1:1 pixel mapping). **Deprecated**: this interpolation
	// filter is deprecated, as in reality it has a lower quality than the
	// @GDK_INTERP_BILINEAR filter (Since: 2.38)
	InterpTypeHyper InterpType = 3
)

func marshalInterpType(p uintptr) (interface{}, error) {
	return InterpType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PixbufAlphaMode: these values can be passed to
// gdk_pixbuf_xlib_render_to_drawable_alpha() to control how the alpha channel
// of an image should be handled. This function can create a bilevel clipping
// mask (black and white) and use it while painting the image. In the future,
// when the X Window System gets an alpha channel extension, it will be possible
// to do full alpha compositing onto arbitrary drawables. For now both cases
// fall back to a bilevel clipping mask.
type PixbufAlphaMode int

const (
	// PixbufAlphaModeBilevel: a bilevel clipping mask (black and white) will be
	// created and used to draw the image. Pixels below 0.5 opacity will be
	// considered fully transparent, and all others will be considered fully
	// opaque.
	PixbufAlphaModeBilevel PixbufAlphaMode = 0
	// PixbufAlphaModeFull: for now falls back to K_PIXBUF_ALPHA_BILEVEL. In the
	// future it will do full alpha compositing.
	PixbufAlphaModeFull PixbufAlphaMode = 1
)

func marshalPixbufAlphaMode(p uintptr) (interface{}, error) {
	return PixbufAlphaMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PixbufError: an error code in the K_PIXBUF_ERROR domain. Many gdk-pixbuf
// operations can cause errors in this domain, or in the FILE_ERROR domain.
type PixbufError int

const (
	// PixbufErrorCorruptImage: an image file was broken somehow.
	PixbufErrorCorruptImage PixbufError = 0
	// PixbufErrorInsufficientMemory: not enough memory.
	PixbufErrorInsufficientMemory PixbufError = 1
	// PixbufErrorBadOption: a bad option was passed to a pixbuf save module.
	PixbufErrorBadOption PixbufError = 2
	// PixbufErrorUnknownType: unknown image type.
	PixbufErrorUnknownType PixbufError = 3
	// PixbufErrorUnsupportedOperation: don't know how to perform the given
	// operation on the type of image at hand.
	PixbufErrorUnsupportedOperation PixbufError = 4
	// PixbufErrorFailed: generic failure code, something went wrong.
	PixbufErrorFailed PixbufError = 5
	// PixbufErrorIncompleteAnimation: only part of the animation was loaded.
	PixbufErrorIncompleteAnimation PixbufError = 6
)

func marshalPixbufError(p uintptr) (interface{}, error) {
	return PixbufError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PixbufRotation: the possible rotations which can be passed to
// gdk_pixbuf_rotate_simple(). To make them easier to use, their numerical
// values are the actual degrees.
type PixbufRotation int

const (
	// PixbufRotationNone: no rotation.
	PixbufRotationNone PixbufRotation = 0
	// PixbufRotationCounterclockwise: rotate by 90 degrees.
	PixbufRotationCounterclockwise PixbufRotation = 90
	// PixbufRotationUpsidedown: rotate by 180 degrees.
	PixbufRotationUpsidedown PixbufRotation = 180
	// PixbufRotationClockwise: rotate by 270 degrees.
	PixbufRotationClockwise PixbufRotation = 270
)

func marshalPixbufRotation(p uintptr) (interface{}, error) {
	return PixbufRotation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

func PixbufErrorQuark() {
	C.gdk_pixbuf_error_quark()
}

// Pixbuf: this is the main structure in the gdk-pixbuf library. It is used to
// represent images. It contains information about the image's pixel data, its
// color space, bits per sample, width and height, and the rowstride (the number
// of bytes between the start of one row and the start of the next).
type Pixbuf interface {
	gextras.Objector
	gio.Icon

	// AddAlpha takes an existing pixbuf and adds an alpha channel to it. If the
	// existing pixbuf already had an alpha channel, the channel values are
	// copied from the original; otherwise, the alpha channel is initialized to
	// 255 (full opacity).
	//
	// If @substitute_color is true, then the color specified by (@r, @g, @b)
	// will be assigned zero opacity. That is, if you pass (255, 255, 255) for
	// the substitute color, all white pixels will become fully transparent.
	AddAlpha(p Pixbuf, substituteColor bool, r byte, g byte, b byte)
	// ApplyEmbeddedOrientation takes an existing pixbuf and checks for the
	// presence of an associated "orientation" option, which may be provided by
	// the jpeg loader (which reads the exif orientation tag) or the tiff loader
	// (which reads the tiff orientation tag, and compensates it for the partial
	// transforms performed by libtiff). If an orientation option/tag is
	// present, the appropriate transform will be performed so that the pixbuf
	// is oriented correctly.
	ApplyEmbeddedOrientation(s Pixbuf)
	// Composite creates a transformation of the source image @src by scaling by
	// @scale_x and @scale_y then translating by @offset_x and @offset_y. This
	// gives an image in the coordinates of the destination pixbuf. The
	// rectangle (@dest_x, @dest_y, @dest_width, @dest_height) is then alpha
	// blended onto the corresponding rectangle of the original destination
	// image.
	//
	// When the destination rectangle contains parts not in the source image,
	// the data at the edges of the source image is replicated to infinity.
	//
	// ! (composite.png)
	Composite(s Pixbuf, dest Pixbuf, destX int, destY int, destWidth int, destHeight int, offsetX float64, offsetY float64, scaleX float64, scaleY float64, interpType InterpType, overallAlpha int)
	// CompositeColor creates a transformation of the source image @src by
	// scaling by @scale_x and @scale_y then translating by @offset_x and
	// @offset_y, then alpha blends the rectangle (@dest_x ,@dest_y,
	// @dest_width, @dest_height) of the resulting image with a checkboard of
	// the colors @color1 and @color2 and renders it onto the destination image.
	//
	// If the source image has no alpha channel, and @overall_alpha is 255, a
	// fast path is used which omits the alpha blending and just performs the
	// scaling.
	//
	// See gdk_pixbuf_composite_color_simple() for a simpler variant of this
	// function suitable for many tasks.
	CompositeColor(s Pixbuf, dest Pixbuf, destX int, destY int, destWidth int, destHeight int, offsetX float64, offsetY float64, scaleX float64, scaleY float64, interpType InterpType, overallAlpha int, checkX int, checkY int, checkSize int, color1 uint32, color2 uint32)
	// CompositeColorSimple creates a new Pixbuf by scaling @src to @dest_width
	// x @dest_height and alpha blending the result with a checkboard of colors
	// @color1 and @color2.
	CompositeColorSimple(s Pixbuf, destWidth int, destHeight int, interpType InterpType, overallAlpha int, checkSize int, color1 uint32, color2 uint32)
	// Copy creates a new Pixbuf with a copy of the information in the specified
	// @pixbuf. Note that this does not copy the options set on the original
	// Pixbuf, use gdk_pixbuf_copy_options() for this.
	Copy(p Pixbuf)
	// CopyArea copies a rectangular area from @src_pixbuf to @dest_pixbuf.
	// Conversion of pixbuf formats is done automatically.
	//
	// If the source rectangle overlaps the destination rectangle on the same
	// pixbuf, it will be overwritten during the copy operation. Therefore, you
	// can not use this function to scroll a pixbuf.
	CopyArea(s Pixbuf, srcX int, srcY int, width int, height int, destPixbuf Pixbuf, destX int, destY int)
	// CopyOptions: copy the key/value pair options attached to a Pixbuf to
	// another. This is useful to keep original metadata after having
	// manipulated a file. However be careful to remove metadata which you've
	// already applied, such as the "orientation" option after rotating the
	// image.
	CopyOptions(s Pixbuf, destPixbuf Pixbuf) bool
	// Fill clears a pixbuf to the given RGBA value, converting the RGBA value
	// into the pixbuf's pixel format. The alpha will be ignored if the pixbuf
	// doesn't have an alpha channel.
	Fill(p Pixbuf, pixel uint32)
	// Flip flips a pixbuf horizontally or vertically and returns the result in
	// a new pixbuf.
	Flip(s Pixbuf, horizontal bool)
	// BitsPerSample queries the number of bits per color sample in a pixbuf.
	BitsPerSample(p Pixbuf)
	// ByteLength returns the length of the pixel data, in bytes.
	ByteLength(p Pixbuf)
	// Colorspace queries the color space of a pixbuf.
	Colorspace(p Pixbuf)
	// HasAlpha queries whether a pixbuf has an alpha channel (opacity
	// information).
	HasAlpha(p Pixbuf) bool
	// Height queries the height of a pixbuf.
	Height(p Pixbuf)
	// NChannels queries the number of channels of a pixbuf.
	NChannels(p Pixbuf)
	// Option looks up @key in the list of options that may have been attached
	// to the @pixbuf when it was loaded, or that may have been attached by
	// another function using gdk_pixbuf_set_option().
	//
	// For instance, the ANI loader provides "Title" and "Artist" options. The
	// ICO, XBM, and XPM loaders provide "x_hot" and "y_hot" hot-spot options
	// for cursor definitions. The PNG loader provides the tEXt ancillary chunk
	// key/value pairs as options. Since 2.12, the TIFF and JPEG loaders return
	// an "orientation" option string that corresponds to the embedded TIFF/Exif
	// orientation tag (if present). Since 2.32, the TIFF loader sets the
	// "multipage" option string to "yes" when a multi-page TIFF is loaded.
	// Since 2.32 the JPEG and PNG loaders set "x-dpi" and "y-dpi" if the file
	// contains image density information in dots per inch. Since 2.36.6, the
	// JPEG loader sets the "comment" option with the comment EXIF tag.
	Option(p Pixbuf, key string)
	// Options returns a Table with a list of all the options that may have been
	// attached to the @pixbuf when it was loaded, or that may have been
	// attached by another function using gdk_pixbuf_set_option().
	//
	// See gdk_pixbuf_get_option() for more details.
	Options(p Pixbuf)
	// PixelsWithLength queries a pointer to the pixel data of a pixbuf.
	PixelsWithLength(p Pixbuf) uint
	// Rowstride queries the rowstride of a pixbuf, which is the number of bytes
	// between the start of a row and the start of the next row.
	Rowstride(p Pixbuf)
	// Width queries the width of a pixbuf.
	Width(p Pixbuf)
	// NewSubpixbuf creates a new pixbuf which represents a sub-region of
	// @src_pixbuf. The new pixbuf shares its pixels with the original pixbuf,
	// so writing to one affects both. The new pixbuf holds a reference to
	// @src_pixbuf, so @src_pixbuf will not be finalized until the new pixbuf is
	// finalized.
	//
	// Note that if @src_pixbuf is read-only, this function will force it to be
	// mutable.
	NewSubpixbuf(s Pixbuf, srcX int, srcY int, width int, height int)
	// ReadPixelBytes provides a #GBytes buffer containing the raw pixel data;
	// the data must not be modified. This function allows skipping the implicit
	// copy that must be made if gdk_pixbuf_get_pixels() is called on a
	// read-only pixbuf.
	ReadPixelBytes(p Pixbuf)
	// ReadPixels provides a read-only pointer to the raw pixel data; must not
	// be modified. This function allows skipping the implicit copy that must be
	// made if gdk_pixbuf_get_pixels() is called on a read-only pixbuf.
	ReadPixels(p Pixbuf)
	// Ref adds a reference to a pixbuf.
	Ref(p Pixbuf)
	// RemoveOption: remove the key/value pair option attached to a Pixbuf.
	RemoveOption(p Pixbuf, key string) bool
	// RotateSimple rotates a pixbuf by a multiple of 90 degrees, and returns
	// the result in a new pixbuf.
	//
	// If @angle is 0, a copy of @src is returned, avoiding any rotation.
	RotateSimple(s Pixbuf, angle PixbufRotation)
	// SaturateAndPixelate modifies saturation and optionally pixelates @src,
	// placing the result in @dest. @src and @dest may be the same pixbuf with
	// no ill effects. If @saturation is 1.0 then saturation is not changed. If
	// it's less than 1.0, saturation is reduced (the image turns toward
	// grayscale); if greater than 1.0, saturation is increased (the image gets
	// more vivid colors). If @pixelate is true, then pixels are faded in a
	// checkerboard pattern to create a pixelated image. @src and @dest must
	// have the same image format, size, and rowstride.
	SaturateAndPixelate(s Pixbuf, dest Pixbuf, saturation float32, pixelate bool)
	// SaveToStreamv saves @pixbuf to an output stream.
	//
	// Supported file formats are currently "jpeg", "tiff", "png", "ico" or
	// "bmp". See gdk_pixbuf_save_to_stream() for more details.
	SaveToStreamv(p Pixbuf, stream gio.OutputStream, typ string, optionKeys []string, optionValues []string, cancellable gio.Cancellable) error
	// SaveToStreamvAsync saves @pixbuf to an output stream asynchronously.
	//
	// For more details see gdk_pixbuf_save_to_streamv(), which is the
	// synchronous version of this function.
	//
	// When the operation is finished, @callback will be called in the main
	// thread. You can then call gdk_pixbuf_save_to_stream_finish() to get the
	// result of the operation.
	SaveToStreamvAsync(p Pixbuf)
	// Savev saves pixbuf to a file in @type, which is currently "jpeg", "png",
	// "tiff", "ico" or "bmp". If @error is set, false will be returned. See
	// gdk_pixbuf_save () for more details.
	Savev(p Pixbuf, filename string, typ string, optionKeys []string, optionValues []string) error
	// Scale creates a transformation of the source image @src by scaling by
	// @scale_x and @scale_y then translating by @offset_x and @offset_y, then
	// renders the rectangle (@dest_x, @dest_y, @dest_width, @dest_height) of
	// the resulting image onto the destination image replacing the previous
	// contents.
	//
	// Try to use gdk_pixbuf_scale_simple() first, this function is the
	// industrial-strength power tool you can fall back to if
	// gdk_pixbuf_scale_simple() isn't powerful enough.
	//
	// If the source rectangle overlaps the destination rectangle on the same
	// pixbuf, it will be overwritten during the scaling which results in
	// rendering artifacts.
	Scale(s Pixbuf, dest Pixbuf, destX int, destY int, destWidth int, destHeight int, offsetX float64, offsetY float64, scaleX float64, scaleY float64, interpType InterpType)
	// ScaleSimple: create a new Pixbuf containing a copy of @src scaled to
	// @dest_width x @dest_height. Leaves @src unaffected. @interp_type should
	// be K_INTERP_NEAREST if you want maximum speed (but when scaling down
	// K_INTERP_NEAREST is usually unusably ugly). The default @interp_type
	// should be K_INTERP_BILINEAR which offers reasonable quality and speed.
	//
	// You can scale a sub-portion of @src by creating a sub-pixbuf pointing
	// into @src; see gdk_pixbuf_new_subpixbuf().
	//
	// If @dest_width and @dest_height are equal to the @src width and height, a
	// copy of @src is returned, avoiding any scaling.
	//
	// For more complicated scaling/alpha blending see gdk_pixbuf_scale() and
	// gdk_pixbuf_composite().
	ScaleSimple(s Pixbuf, destWidth int, destHeight int, interpType InterpType)
	// SetOption attaches a key/value pair as an option to a Pixbuf. If @key
	// already exists in the list of options attached to @pixbuf, the new value
	// is ignored and false is returned.
	SetOption(p Pixbuf, key string, value string) bool
	// Unref removes a reference from a pixbuf.
	Unref(p Pixbuf)
}

// pixbuf implements the Pixbuf interface.
type pixbuf struct {
	gextras.Objector
	gio.Icon
}

var _ Pixbuf = (*pixbuf)(nil)

// WrapPixbuf wraps a GObject to the right type. It is
// primarily used internally.
func WrapPixbuf(obj *externglib.Object) Pixbuf {
	return Pixbuf{
		Objector: obj,
		gio.Icon: gio.WrapIcon(obj),
	}
}

func marshalPixbuf(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPixbuf(obj), nil
}

// NewPixbuf constructs a class Pixbuf.
func NewPixbuf(colorspace Colorspace, hasAlpha bool, bitsPerSample int, width int, height int) {
	var arg1 C.GdkColorspace
	var arg2 C.gboolean
	var arg3 C.int
	var arg4 C.int
	var arg5 C.int

	arg1 = (C.GdkColorspace)(colorspace)
	if hasAlpha {
		arg2 = C.gboolean(1)
	}
	arg3 = C.int(bitsPerSample)
	arg4 = C.int(width)
	arg5 = C.int(height)

	C.gdk_pixbuf_new(arg1, arg2, arg3, arg4, arg5)
}

// NewPixbufFromBytes constructs a class Pixbuf.
func NewPixbufFromBytes(data *glib.Bytes, colorspace Colorspace, hasAlpha bool, bitsPerSample int, width int, height int, rowstride int) {
	var arg1 *C.GBytes
	var arg2 C.GdkColorspace
	var arg3 C.gboolean
	var arg4 C.int
	var arg5 C.int
	var arg6 C.int
	var arg7 C.int

	arg1 = (*C.GBytes)(unsafe.Pointer(data.Native()))
	arg2 = (C.GdkColorspace)(colorspace)
	if hasAlpha {
		arg3 = C.gboolean(1)
	}
	arg4 = C.int(bitsPerSample)
	arg5 = C.int(width)
	arg6 = C.int(height)
	arg7 = C.int(rowstride)

	C.gdk_pixbuf_new_from_bytes(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
}

// NewPixbufFromData constructs a class Pixbuf.
func NewPixbufFromData() {
	C.gdk_pixbuf_new_from_data(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
}

// NewPixbufFromFile constructs a class Pixbuf.
func NewPixbufFromFile(filename string) error {
	var arg1 *C.char

	arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	var errout *C.GError
	var err error

	C.gdk_pixbuf_new_from_file(arg1, &errout)

	err = gerror.Take(unsafe.Pointer(errout))

	return err
}

// NewPixbufFromFileAtScale constructs a class Pixbuf.
func NewPixbufFromFileAtScale(filename string, width int, height int, preserveAspectRatio bool) error {
	var arg1 *C.char
	var arg2 C.int
	var arg3 C.int
	var arg4 C.gboolean

	arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(width)
	arg3 = C.int(height)
	if preserveAspectRatio {
		arg4 = C.gboolean(1)
	}

	var errout *C.GError
	var err error

	C.gdk_pixbuf_new_from_file_at_scale(arg1, arg2, arg3, arg4, &errout)

	err = gerror.Take(unsafe.Pointer(errout))

	return err
}

// NewPixbufFromFileAtSize constructs a class Pixbuf.
func NewPixbufFromFileAtSize(filename string, width int, height int) error {
	var arg1 *C.char
	var arg2 C.int
	var arg3 C.int

	arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(width)
	arg3 = C.int(height)

	var errout *C.GError
	var err error

	C.gdk_pixbuf_new_from_file_at_size(arg1, arg2, arg3, &errout)

	err = gerror.Take(unsafe.Pointer(errout))

	return err
}

// NewPixbufFromResource constructs a class Pixbuf.
func NewPixbufFromResource(resourcePath string) error {
	var arg1 *C.char

	arg1 = (*C.char)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(arg1))

	var errout *C.GError
	var err error

	C.gdk_pixbuf_new_from_resource(arg1, &errout)

	err = gerror.Take(unsafe.Pointer(errout))

	return err
}

// NewPixbufFromResourceAtScale constructs a class Pixbuf.
func NewPixbufFromResourceAtScale(resourcePath string, width int, height int, preserveAspectRatio bool) error {
	var arg1 *C.char
	var arg2 C.int
	var arg3 C.int
	var arg4 C.gboolean

	arg1 = (*C.char)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(width)
	arg3 = C.int(height)
	if preserveAspectRatio {
		arg4 = C.gboolean(1)
	}

	var errout *C.GError
	var err error

	C.gdk_pixbuf_new_from_resource_at_scale(arg1, arg2, arg3, arg4, &errout)

	err = gerror.Take(unsafe.Pointer(errout))

	return err
}

// NewPixbufFromStream constructs a class Pixbuf.
func NewPixbufFromStream(stream gio.InputStream, cancellable gio.Cancellable) error {
	var arg1 *C.GInputStream
	var arg2 *C.GCancellable

	arg1 = (*C.GInputStream)(unsafe.Pointer(stream.Native()))
	arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var errout *C.GError
	var err error

	C.gdk_pixbuf_new_from_stream(arg1, arg2, &errout)

	err = gerror.Take(unsafe.Pointer(errout))

	return err
}

// NewPixbufFromStreamAtScale constructs a class Pixbuf.
func NewPixbufFromStreamAtScale(stream gio.InputStream, width int, height int, preserveAspectRatio bool, cancellable gio.Cancellable) error {
	var arg1 *C.GInputStream
	var arg2 C.gint
	var arg3 C.gint
	var arg4 C.gboolean
	var arg5 *C.GCancellable

	arg1 = (*C.GInputStream)(unsafe.Pointer(stream.Native()))
	arg2 = C.gint(width)
	arg3 = C.gint(height)
	if preserveAspectRatio {
		arg4 = C.gboolean(1)
	}
	arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var errout *C.GError
	var err error

	C.gdk_pixbuf_new_from_stream_at_scale(arg1, arg2, arg3, arg4, arg5, &errout)

	err = gerror.Take(unsafe.Pointer(errout))

	return err
}

// NewPixbufFromStreamFinish constructs a class Pixbuf.
func NewPixbufFromStreamFinish(asyncResult gio.AsyncResult) error {
	var arg1 *C.GAsyncResult

	arg1 = (*C.GAsyncResult)(unsafe.Pointer(asyncResult.Native()))

	var errout *C.GError
	var err error

	C.gdk_pixbuf_new_from_stream_finish(arg1, &errout)

	err = gerror.Take(unsafe.Pointer(errout))

	return err
}

// NewPixbufFromXpmData constructs a class Pixbuf.
func NewPixbufFromXpmData(data []string) {
	var arg1 **C.char

	arg1 = C.malloc(len(data) * (unsafe.Sizeof(int(0)) + 1))
	defer C.free(unsafe.Pointer(arg1))

	{
		var out []*C.char
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg1), int(len(data)))

		for i := range data {
			out[i] = (*C.char)(C.CString(data[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.gdk_pixbuf_new_from_xpm_data(arg1)
}

// AddAlpha takes an existing pixbuf and adds an alpha channel to it. If the
// existing pixbuf already had an alpha channel, the channel values are
// copied from the original; otherwise, the alpha channel is initialized to
// 255 (full opacity).
//
// If @substitute_color is true, then the color specified by (@r, @g, @b)
// will be assigned zero opacity. That is, if you pass (255, 255, 255) for
// the substitute color, all white pixels will become fully transparent.
func (p pixbuf) AddAlpha(p Pixbuf, substituteColor bool, r byte, g byte, b byte) {
	var arg0 *C.GdkPixbuf
	var arg1 C.gboolean
	var arg2 C.guchar
	var arg3 C.guchar
	var arg4 C.guchar

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))
	if substituteColor {
		arg1 = C.gboolean(1)
	}
	arg2 = C.guchar(r)
	arg3 = C.guchar(g)
	arg4 = C.guchar(b)

	C.gdk_pixbuf_add_alpha(arg0, arg1, arg2, arg3, arg4)
}

// ApplyEmbeddedOrientation takes an existing pixbuf and checks for the
// presence of an associated "orientation" option, which may be provided by
// the jpeg loader (which reads the exif orientation tag) or the tiff loader
// (which reads the tiff orientation tag, and compensates it for the partial
// transforms performed by libtiff). If an orientation option/tag is
// present, the appropriate transform will be performed so that the pixbuf
// is oriented correctly.
func (s pixbuf) ApplyEmbeddedOrientation(s Pixbuf) {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))

	C.gdk_pixbuf_apply_embedded_orientation(arg0)
}

// Composite creates a transformation of the source image @src by scaling by
// @scale_x and @scale_y then translating by @offset_x and @offset_y. This
// gives an image in the coordinates of the destination pixbuf. The
// rectangle (@dest_x, @dest_y, @dest_width, @dest_height) is then alpha
// blended onto the corresponding rectangle of the original destination
// image.
//
// When the destination rectangle contains parts not in the source image,
// the data at the edges of the source image is replicated to infinity.
//
// ! (composite.png)
func (s pixbuf) Composite(s Pixbuf, dest Pixbuf, destX int, destY int, destWidth int, destHeight int, offsetX float64, offsetY float64, scaleX float64, scaleY float64, interpType InterpType, overallAlpha int) {
	var arg0 *C.GdkPixbuf
	var arg1 *C.GdkPixbuf
	var arg2 C.int
	var arg3 C.int
	var arg4 C.int
	var arg5 C.int
	var arg6 C.double
	var arg7 C.double
	var arg8 C.double
	var arg9 C.double
	var arg10 C.GdkInterpType
	var arg11 C.int

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GdkPixbuf)(unsafe.Pointer(dest.Native()))
	arg2 = C.int(destX)
	arg3 = C.int(destY)
	arg4 = C.int(destWidth)
	arg5 = C.int(destHeight)
	arg6 = C.double(offsetX)
	arg7 = C.double(offsetY)
	arg8 = C.double(scaleX)
	arg9 = C.double(scaleY)
	arg10 = (C.GdkInterpType)(interpType)
	arg11 = C.int(overallAlpha)

	C.gdk_pixbuf_composite(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11)
}

// CompositeColor creates a transformation of the source image @src by
// scaling by @scale_x and @scale_y then translating by @offset_x and
// @offset_y, then alpha blends the rectangle (@dest_x ,@dest_y,
// @dest_width, @dest_height) of the resulting image with a checkboard of
// the colors @color1 and @color2 and renders it onto the destination image.
//
// If the source image has no alpha channel, and @overall_alpha is 255, a
// fast path is used which omits the alpha blending and just performs the
// scaling.
//
// See gdk_pixbuf_composite_color_simple() for a simpler variant of this
// function suitable for many tasks.
func (s pixbuf) CompositeColor(s Pixbuf, dest Pixbuf, destX int, destY int, destWidth int, destHeight int, offsetX float64, offsetY float64, scaleX float64, scaleY float64, interpType InterpType, overallAlpha int, checkX int, checkY int, checkSize int, color1 uint32, color2 uint32) {
	var arg0 *C.GdkPixbuf
	var arg1 *C.GdkPixbuf
	var arg2 C.int
	var arg3 C.int
	var arg4 C.int
	var arg5 C.int
	var arg6 C.double
	var arg7 C.double
	var arg8 C.double
	var arg9 C.double
	var arg10 C.GdkInterpType
	var arg11 C.int
	var arg12 C.int
	var arg13 C.int
	var arg14 C.int
	var arg15 C.guint32
	var arg16 C.guint32

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GdkPixbuf)(unsafe.Pointer(dest.Native()))
	arg2 = C.int(destX)
	arg3 = C.int(destY)
	arg4 = C.int(destWidth)
	arg5 = C.int(destHeight)
	arg6 = C.double(offsetX)
	arg7 = C.double(offsetY)
	arg8 = C.double(scaleX)
	arg9 = C.double(scaleY)
	arg10 = (C.GdkInterpType)(interpType)
	arg11 = C.int(overallAlpha)
	arg12 = C.int(checkX)
	arg13 = C.int(checkY)
	arg14 = C.int(checkSize)
	arg15 = C.guint32(color1)
	arg16 = C.guint32(color2)

	C.gdk_pixbuf_composite_color(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16)
}

// CompositeColorSimple creates a new Pixbuf by scaling @src to @dest_width
// x @dest_height and alpha blending the result with a checkboard of colors
// @color1 and @color2.
func (s pixbuf) CompositeColorSimple(s Pixbuf, destWidth int, destHeight int, interpType InterpType, overallAlpha int, checkSize int, color1 uint32, color2 uint32) {
	var arg0 *C.GdkPixbuf
	var arg1 C.int
	var arg2 C.int
	var arg3 C.GdkInterpType
	var arg4 C.int
	var arg5 C.int
	var arg6 C.guint32
	var arg7 C.guint32

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	arg1 = C.int(destWidth)
	arg2 = C.int(destHeight)
	arg3 = (C.GdkInterpType)(interpType)
	arg4 = C.int(overallAlpha)
	arg5 = C.int(checkSize)
	arg6 = C.guint32(color1)
	arg7 = C.guint32(color2)

	C.gdk_pixbuf_composite_color_simple(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
}

// Copy creates a new Pixbuf with a copy of the information in the specified
// @pixbuf. Note that this does not copy the options set on the original
// Pixbuf, use gdk_pixbuf_copy_options() for this.
func (p pixbuf) Copy(p Pixbuf) {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	C.gdk_pixbuf_copy(arg0)
}

// CopyArea copies a rectangular area from @src_pixbuf to @dest_pixbuf.
// Conversion of pixbuf formats is done automatically.
//
// If the source rectangle overlaps the destination rectangle on the same
// pixbuf, it will be overwritten during the copy operation. Therefore, you
// can not use this function to scroll a pixbuf.
func (s pixbuf) CopyArea(s Pixbuf, srcX int, srcY int, width int, height int, destPixbuf Pixbuf, destX int, destY int) {
	var arg0 *C.GdkPixbuf
	var arg1 C.int
	var arg2 C.int
	var arg3 C.int
	var arg4 C.int
	var arg5 *C.GdkPixbuf
	var arg6 C.int
	var arg7 C.int

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	arg1 = C.int(srcX)
	arg2 = C.int(srcY)
	arg3 = C.int(width)
	arg4 = C.int(height)
	arg5 = (*C.GdkPixbuf)(unsafe.Pointer(destPixbuf.Native()))
	arg6 = C.int(destX)
	arg7 = C.int(destY)

	C.gdk_pixbuf_copy_area(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
}

// CopyOptions: copy the key/value pair options attached to a Pixbuf to
// another. This is useful to keep original metadata after having
// manipulated a file. However be careful to remove metadata which you've
// already applied, such as the "orientation" option after rotating the
// image.
func (s pixbuf) CopyOptions(s Pixbuf, destPixbuf Pixbuf) bool {
	var arg0 *C.GdkPixbuf
	var arg1 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GdkPixbuf)(unsafe.Pointer(destPixbuf.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gdk_pixbuf_copy_options(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// Fill clears a pixbuf to the given RGBA value, converting the RGBA value
// into the pixbuf's pixel format. The alpha will be ignored if the pixbuf
// doesn't have an alpha channel.
func (p pixbuf) Fill(p Pixbuf, pixel uint32) {
	var arg0 *C.GdkPixbuf
	var arg1 C.guint32

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))
	arg1 = C.guint32(pixel)

	C.gdk_pixbuf_fill(arg0, arg1)
}

// Flip flips a pixbuf horizontally or vertically and returns the result in
// a new pixbuf.
func (s pixbuf) Flip(s Pixbuf, horizontal bool) {
	var arg0 *C.GdkPixbuf
	var arg1 C.gboolean

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	if horizontal {
		arg1 = C.gboolean(1)
	}

	C.gdk_pixbuf_flip(arg0, arg1)
}

// BitsPerSample queries the number of bits per color sample in a pixbuf.
func (p pixbuf) BitsPerSample(p Pixbuf) {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	C.gdk_pixbuf_get_bits_per_sample(arg0)
}

// ByteLength returns the length of the pixel data, in bytes.
func (p pixbuf) ByteLength(p Pixbuf) {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	C.gdk_pixbuf_get_byte_length(arg0)
}

// Colorspace queries the color space of a pixbuf.
func (p pixbuf) Colorspace(p Pixbuf) {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	C.gdk_pixbuf_get_colorspace(arg0)
}

// HasAlpha queries whether a pixbuf has an alpha channel (opacity
// information).
func (p pixbuf) HasAlpha(p Pixbuf) bool {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gdk_pixbuf_get_has_alpha(arg0)

	if cret {
		ok = true
	}

	return ok
}

// Height queries the height of a pixbuf.
func (p pixbuf) Height(p Pixbuf) {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	C.gdk_pixbuf_get_height(arg0)
}

// NChannels queries the number of channels of a pixbuf.
func (p pixbuf) NChannels(p Pixbuf) {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	C.gdk_pixbuf_get_n_channels(arg0)
}

// Option looks up @key in the list of options that may have been attached
// to the @pixbuf when it was loaded, or that may have been attached by
// another function using gdk_pixbuf_set_option().
//
// For instance, the ANI loader provides "Title" and "Artist" options. The
// ICO, XBM, and XPM loaders provide "x_hot" and "y_hot" hot-spot options
// for cursor definitions. The PNG loader provides the tEXt ancillary chunk
// key/value pairs as options. Since 2.12, the TIFF and JPEG loaders return
// an "orientation" option string that corresponds to the embedded TIFF/Exif
// orientation tag (if present). Since 2.32, the TIFF loader sets the
// "multipage" option string to "yes" when a multi-page TIFF is loaded.
// Since 2.32 the JPEG and PNG loaders set "x-dpi" and "y-dpi" if the file
// contains image density information in dots per inch. Since 2.36.6, the
// JPEG loader sets the "comment" option with the comment EXIF tag.
func (p pixbuf) Option(p Pixbuf, key string) {
	var arg0 *C.GdkPixbuf
	var arg1 *C.gchar

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	C.gdk_pixbuf_get_option(arg0, arg1)
}

// Options returns a Table with a list of all the options that may have been
// attached to the @pixbuf when it was loaded, or that may have been
// attached by another function using gdk_pixbuf_set_option().
//
// See gdk_pixbuf_get_option() for more details.
func (p pixbuf) Options(p Pixbuf) {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	C.gdk_pixbuf_get_options(arg0)
}

// PixelsWithLength queries a pointer to the pixel data of a pixbuf.
func (p pixbuf) PixelsWithLength(p Pixbuf) uint {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	var arg1 C.guint
	var length uint

	C.gdk_pixbuf_get_pixels_with_length(arg0, &arg1)

	length = uint(&arg1)

	return length
}

// Rowstride queries the rowstride of a pixbuf, which is the number of bytes
// between the start of a row and the start of the next row.
func (p pixbuf) Rowstride(p Pixbuf) {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	C.gdk_pixbuf_get_rowstride(arg0)
}

// Width queries the width of a pixbuf.
func (p pixbuf) Width(p Pixbuf) {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	C.gdk_pixbuf_get_width(arg0)
}

// NewSubpixbuf creates a new pixbuf which represents a sub-region of
// @src_pixbuf. The new pixbuf shares its pixels with the original pixbuf,
// so writing to one affects both. The new pixbuf holds a reference to
// @src_pixbuf, so @src_pixbuf will not be finalized until the new pixbuf is
// finalized.
//
// Note that if @src_pixbuf is read-only, this function will force it to be
// mutable.
func (s pixbuf) NewSubpixbuf(s Pixbuf, srcX int, srcY int, width int, height int) {
	var arg0 *C.GdkPixbuf
	var arg1 C.int
	var arg2 C.int
	var arg3 C.int
	var arg4 C.int

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	arg1 = C.int(srcX)
	arg2 = C.int(srcY)
	arg3 = C.int(width)
	arg4 = C.int(height)

	C.gdk_pixbuf_new_subpixbuf(arg0, arg1, arg2, arg3, arg4)
}

// ReadPixelBytes provides a #GBytes buffer containing the raw pixel data;
// the data must not be modified. This function allows skipping the implicit
// copy that must be made if gdk_pixbuf_get_pixels() is called on a
// read-only pixbuf.
func (p pixbuf) ReadPixelBytes(p Pixbuf) {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	C.gdk_pixbuf_read_pixel_bytes(arg0)
}

// ReadPixels provides a read-only pointer to the raw pixel data; must not
// be modified. This function allows skipping the implicit copy that must be
// made if gdk_pixbuf_get_pixels() is called on a read-only pixbuf.
func (p pixbuf) ReadPixels(p Pixbuf) {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	C.gdk_pixbuf_read_pixels(arg0)
}

// Ref adds a reference to a pixbuf.
func (p pixbuf) Ref(p Pixbuf) {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	C.gdk_pixbuf_ref(arg0)
}

// RemoveOption: remove the key/value pair option attached to a Pixbuf.
func (p pixbuf) RemoveOption(p Pixbuf, key string) bool {
	var arg0 *C.GdkPixbuf
	var arg1 *C.gchar

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.gboolean
	var ok bool

	cret = C.gdk_pixbuf_remove_option(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// RotateSimple rotates a pixbuf by a multiple of 90 degrees, and returns
// the result in a new pixbuf.
//
// If @angle is 0, a copy of @src is returned, avoiding any rotation.
func (s pixbuf) RotateSimple(s Pixbuf, angle PixbufRotation) {
	var arg0 *C.GdkPixbuf
	var arg1 C.GdkPixbufRotation

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	arg1 = (C.GdkPixbufRotation)(angle)

	C.gdk_pixbuf_rotate_simple(arg0, arg1)
}

// SaturateAndPixelate modifies saturation and optionally pixelates @src,
// placing the result in @dest. @src and @dest may be the same pixbuf with
// no ill effects. If @saturation is 1.0 then saturation is not changed. If
// it's less than 1.0, saturation is reduced (the image turns toward
// grayscale); if greater than 1.0, saturation is increased (the image gets
// more vivid colors). If @pixelate is true, then pixels are faded in a
// checkerboard pattern to create a pixelated image. @src and @dest must
// have the same image format, size, and rowstride.
func (s pixbuf) SaturateAndPixelate(s Pixbuf, dest Pixbuf, saturation float32, pixelate bool) {
	var arg0 *C.GdkPixbuf
	var arg1 *C.GdkPixbuf
	var arg2 C.gfloat
	var arg3 C.gboolean

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GdkPixbuf)(unsafe.Pointer(dest.Native()))
	arg2 = C.gfloat(saturation)
	if pixelate {
		arg3 = C.gboolean(1)
	}

	C.gdk_pixbuf_saturate_and_pixelate(arg0, arg1, arg2, arg3)
}

// SaveToStreamv saves @pixbuf to an output stream.
//
// Supported file formats are currently "jpeg", "tiff", "png", "ico" or
// "bmp". See gdk_pixbuf_save_to_stream() for more details.
func (p pixbuf) SaveToStreamv(p Pixbuf, stream gio.OutputStream, typ string, optionKeys []string, optionValues []string, cancellable gio.Cancellable) error {
	var arg0 *C.GdkPixbuf
	var arg1 *C.GOutputStream
	var arg2 *C.char
	var arg3 **C.char
	var arg4 **C.char
	var arg5 *C.GCancellable

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))
	arg1 = (*C.GOutputStream)(unsafe.Pointer(stream.Native()))
	arg2 = (*C.char)(C.CString(typ))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.malloc(len(optionKeys) * (unsafe.Sizeof(int(0)) + 1))
	defer C.free(unsafe.Pointer(arg3))

	{
		var out []*C.char
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg3), int(len(optionKeys)))

		for i := range optionKeys {
			out[i] = (*C.char)(C.CString(optionKeys[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}
	arg4 = C.malloc(len(optionValues) * (unsafe.Sizeof(int(0)) + 1))
	defer C.free(unsafe.Pointer(arg4))

	{
		var out []*C.char
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg4), int(len(optionValues)))

		for i := range optionValues {
			out[i] = (*C.char)(C.CString(optionValues[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}
	arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var errout *C.GError
	var err error

	C.gdk_pixbuf_save_to_streamv(arg0, arg1, arg2, arg3, arg4, arg5, &errout)

	err = gerror.Take(unsafe.Pointer(errout))

	return err
}

// SaveToStreamvAsync saves @pixbuf to an output stream asynchronously.
//
// For more details see gdk_pixbuf_save_to_streamv(), which is the
// synchronous version of this function.
//
// When the operation is finished, @callback will be called in the main
// thread. You can then call gdk_pixbuf_save_to_stream_finish() to get the
// result of the operation.
func (p pixbuf) SaveToStreamvAsync(p Pixbuf) {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	C.gdk_pixbuf_save_to_streamv_async(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
}

// Savev saves pixbuf to a file in @type, which is currently "jpeg", "png",
// "tiff", "ico" or "bmp". If @error is set, false will be returned. See
// gdk_pixbuf_save () for more details.
func (p pixbuf) Savev(p Pixbuf, filename string, typ string, optionKeys []string, optionValues []string) error {
	var arg0 *C.GdkPixbuf
	var arg1 *C.char
	var arg2 *C.char
	var arg3 **C.char
	var arg4 **C.char

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))
	arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.char)(C.CString(typ))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.malloc(len(optionKeys) * (unsafe.Sizeof(int(0)) + 1))
	defer C.free(unsafe.Pointer(arg3))

	{
		var out []*C.char
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg3), int(len(optionKeys)))

		for i := range optionKeys {
			out[i] = (*C.char)(C.CString(optionKeys[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}
	arg4 = C.malloc(len(optionValues) * (unsafe.Sizeof(int(0)) + 1))
	defer C.free(unsafe.Pointer(arg4))

	{
		var out []*C.char
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg4), int(len(optionValues)))

		for i := range optionValues {
			out[i] = (*C.char)(C.CString(optionValues[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	var errout *C.GError
	var err error

	C.gdk_pixbuf_savev(arg0, arg1, arg2, arg3, arg4, &errout)

	err = gerror.Take(unsafe.Pointer(errout))

	return err
}

// Scale creates a transformation of the source image @src by scaling by
// @scale_x and @scale_y then translating by @offset_x and @offset_y, then
// renders the rectangle (@dest_x, @dest_y, @dest_width, @dest_height) of
// the resulting image onto the destination image replacing the previous
// contents.
//
// Try to use gdk_pixbuf_scale_simple() first, this function is the
// industrial-strength power tool you can fall back to if
// gdk_pixbuf_scale_simple() isn't powerful enough.
//
// If the source rectangle overlaps the destination rectangle on the same
// pixbuf, it will be overwritten during the scaling which results in
// rendering artifacts.
func (s pixbuf) Scale(s Pixbuf, dest Pixbuf, destX int, destY int, destWidth int, destHeight int, offsetX float64, offsetY float64, scaleX float64, scaleY float64, interpType InterpType) {
	var arg0 *C.GdkPixbuf
	var arg1 *C.GdkPixbuf
	var arg2 C.int
	var arg3 C.int
	var arg4 C.int
	var arg5 C.int
	var arg6 C.double
	var arg7 C.double
	var arg8 C.double
	var arg9 C.double
	var arg10 C.GdkInterpType

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GdkPixbuf)(unsafe.Pointer(dest.Native()))
	arg2 = C.int(destX)
	arg3 = C.int(destY)
	arg4 = C.int(destWidth)
	arg5 = C.int(destHeight)
	arg6 = C.double(offsetX)
	arg7 = C.double(offsetY)
	arg8 = C.double(scaleX)
	arg9 = C.double(scaleY)
	arg10 = (C.GdkInterpType)(interpType)

	C.gdk_pixbuf_scale(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)
}

// ScaleSimple: create a new Pixbuf containing a copy of @src scaled to
// @dest_width x @dest_height. Leaves @src unaffected. @interp_type should
// be K_INTERP_NEAREST if you want maximum speed (but when scaling down
// K_INTERP_NEAREST is usually unusably ugly). The default @interp_type
// should be K_INTERP_BILINEAR which offers reasonable quality and speed.
//
// You can scale a sub-portion of @src by creating a sub-pixbuf pointing
// into @src; see gdk_pixbuf_new_subpixbuf().
//
// If @dest_width and @dest_height are equal to the @src width and height, a
// copy of @src is returned, avoiding any scaling.
//
// For more complicated scaling/alpha blending see gdk_pixbuf_scale() and
// gdk_pixbuf_composite().
func (s pixbuf) ScaleSimple(s Pixbuf, destWidth int, destHeight int, interpType InterpType) {
	var arg0 *C.GdkPixbuf
	var arg1 C.int
	var arg2 C.int
	var arg3 C.GdkInterpType

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(s.Native()))
	arg1 = C.int(destWidth)
	arg2 = C.int(destHeight)
	arg3 = (C.GdkInterpType)(interpType)

	C.gdk_pixbuf_scale_simple(arg0, arg1, arg2, arg3)
}

// SetOption attaches a key/value pair as an option to a Pixbuf. If @key
// already exists in the list of options attached to @pixbuf, the new value
// is ignored and false is returned.
func (p pixbuf) SetOption(p Pixbuf, key string, value string) bool {
	var arg0 *C.GdkPixbuf
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(arg2))

	var cret C.gboolean
	var ok bool

	cret = C.gdk_pixbuf_set_option(arg0, arg1, arg2)

	if cret {
		ok = true
	}

	return ok
}

// Unref removes a reference from a pixbuf.
func (p pixbuf) Unref(p Pixbuf) {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(unsafe.Pointer(p.Native()))

	C.gdk_pixbuf_unref(arg0)
}

// PixbufAnimation: an opaque struct representing an animation.
type PixbufAnimation interface {
	gextras.Objector

	// Height queries the height of the bounding box of a pixbuf animation.
	Height(a PixbufAnimation)
	// Iter: get an iterator for displaying an animation. The iterator provides
	// the frames that should be displayed at a given time. It should be freed
	// after use with g_object_unref().
	//
	// @start_time would normally come from g_get_current_time(), and marks the
	// beginning of animation playback. After creating an iterator, you should
	// immediately display the pixbuf returned by
	// gdk_pixbuf_animation_iter_get_pixbuf(). Then, you should install a
	// timeout (with g_timeout_add()) or by some other mechanism ensure that
	// you'll update the image after gdk_pixbuf_animation_iter_get_delay_time()
	// milliseconds. Each time the image is updated, you should reinstall the
	// timeout with the new, possibly-changed delay time.
	//
	// As a shortcut, if @start_time is nil, the result of g_get_current_time()
	// will be used automatically.
	//
	// To update the image (i.e. possibly change the result of
	// gdk_pixbuf_animation_iter_get_pixbuf() to a new frame of the animation),
	// call gdk_pixbuf_animation_iter_advance().
	//
	// If you're using PixbufLoader, in addition to updating the image after the
	// delay time, you should also update it whenever you receive the
	// area_updated signal and
	// gdk_pixbuf_animation_iter_on_currently_loading_frame() returns true. In
	// this case, the frame currently being fed into the loader has received new
	// data, so needs to be refreshed. The delay time for a frame may also be
	// modified after an area_updated signal, for example if the delay time for
	// a frame is encoded in the data after the frame itself. So your timeout
	// should be reinstalled after any area_updated signal.
	//
	// A delay time of -1 is possible, indicating "infinite."
	Iter(a PixbufAnimation, startTime *glib.TimeVal)
	// StaticImage: if an animation is really just a plain image (has only one
	// frame), this function returns that image. If the animation is an
	// animation, this function returns a reasonable thing to display as a
	// static unanimated image, which might be the first frame, or something
	// more sophisticated. If an animation hasn't loaded any frames yet, this
	// function will return nil.
	StaticImage(a PixbufAnimation)
	// Width queries the width of the bounding box of a pixbuf animation.
	Width(a PixbufAnimation)
	// IsStaticImage: if you load a file with
	// gdk_pixbuf_animation_new_from_file() and it turns out to be a plain,
	// unanimated image, then this function will return true. Use
	// gdk_pixbuf_animation_get_static_image() to retrieve the image.
	IsStaticImage(a PixbufAnimation) bool
	// Ref adds a reference to an animation.
	Ref(a PixbufAnimation)
	// Unref removes a reference from an animation.
	Unref(a PixbufAnimation)
}

// pixbufAnimation implements the PixbufAnimation interface.
type pixbufAnimation struct {
	gextras.Objector
}

var _ PixbufAnimation = (*pixbufAnimation)(nil)

// WrapPixbufAnimation wraps a GObject to the right type. It is
// primarily used internally.
func WrapPixbufAnimation(obj *externglib.Object) PixbufAnimation {
	return PixbufAnimation{
		Objector: obj,
	}
}

func marshalPixbufAnimation(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPixbufAnimation(obj), nil
}

// NewPixbufAnimationFromFile constructs a class PixbufAnimation.
func NewPixbufAnimationFromFile(filename string) error {
	var arg1 *C.char

	arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	var errout *C.GError
	var err error

	C.gdk_pixbuf_animation_new_from_file(arg1, &errout)

	err = gerror.Take(unsafe.Pointer(errout))

	return err
}

// NewPixbufAnimationFromResource constructs a class PixbufAnimation.
func NewPixbufAnimationFromResource(resourcePath string) error {
	var arg1 *C.char

	arg1 = (*C.char)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(arg1))

	var errout *C.GError
	var err error

	C.gdk_pixbuf_animation_new_from_resource(arg1, &errout)

	err = gerror.Take(unsafe.Pointer(errout))

	return err
}

// NewPixbufAnimationFromStream constructs a class PixbufAnimation.
func NewPixbufAnimationFromStream(stream gio.InputStream, cancellable gio.Cancellable) error {
	var arg1 *C.GInputStream
	var arg2 *C.GCancellable

	arg1 = (*C.GInputStream)(unsafe.Pointer(stream.Native()))
	arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var errout *C.GError
	var err error

	C.gdk_pixbuf_animation_new_from_stream(arg1, arg2, &errout)

	err = gerror.Take(unsafe.Pointer(errout))

	return err
}

// NewPixbufAnimationFromStreamFinish constructs a class PixbufAnimation.
func NewPixbufAnimationFromStreamFinish(asyncResult gio.AsyncResult) error {
	var arg1 *C.GAsyncResult

	arg1 = (*C.GAsyncResult)(unsafe.Pointer(asyncResult.Native()))

	var errout *C.GError
	var err error

	C.gdk_pixbuf_animation_new_from_stream_finish(arg1, &errout)

	err = gerror.Take(unsafe.Pointer(errout))

	return err
}

// Height queries the height of the bounding box of a pixbuf animation.
func (a pixbufAnimation) Height(a PixbufAnimation) {
	var arg0 *C.GdkPixbufAnimation

	arg0 = (*C.GdkPixbufAnimation)(unsafe.Pointer(a.Native()))

	C.gdk_pixbuf_animation_get_height(arg0)
}

// Iter: get an iterator for displaying an animation. The iterator provides
// the frames that should be displayed at a given time. It should be freed
// after use with g_object_unref().
//
// @start_time would normally come from g_get_current_time(), and marks the
// beginning of animation playback. After creating an iterator, you should
// immediately display the pixbuf returned by
// gdk_pixbuf_animation_iter_get_pixbuf(). Then, you should install a
// timeout (with g_timeout_add()) or by some other mechanism ensure that
// you'll update the image after gdk_pixbuf_animation_iter_get_delay_time()
// milliseconds. Each time the image is updated, you should reinstall the
// timeout with the new, possibly-changed delay time.
//
// As a shortcut, if @start_time is nil, the result of g_get_current_time()
// will be used automatically.
//
// To update the image (i.e. possibly change the result of
// gdk_pixbuf_animation_iter_get_pixbuf() to a new frame of the animation),
// call gdk_pixbuf_animation_iter_advance().
//
// If you're using PixbufLoader, in addition to updating the image after the
// delay time, you should also update it whenever you receive the
// area_updated signal and
// gdk_pixbuf_animation_iter_on_currently_loading_frame() returns true. In
// this case, the frame currently being fed into the loader has received new
// data, so needs to be refreshed. The delay time for a frame may also be
// modified after an area_updated signal, for example if the delay time for
// a frame is encoded in the data after the frame itself. So your timeout
// should be reinstalled after any area_updated signal.
//
// A delay time of -1 is possible, indicating "infinite."
func (a pixbufAnimation) Iter(a PixbufAnimation, startTime *glib.TimeVal) {
	var arg0 *C.GdkPixbufAnimation
	var arg1 *C.GTimeVal

	arg0 = (*C.GdkPixbufAnimation)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GTimeVal)(unsafe.Pointer(startTime.Native()))

	C.gdk_pixbuf_animation_get_iter(arg0, arg1)
}

// StaticImage: if an animation is really just a plain image (has only one
// frame), this function returns that image. If the animation is an
// animation, this function returns a reasonable thing to display as a
// static unanimated image, which might be the first frame, or something
// more sophisticated. If an animation hasn't loaded any frames yet, this
// function will return nil.
func (a pixbufAnimation) StaticImage(a PixbufAnimation) {
	var arg0 *C.GdkPixbufAnimation

	arg0 = (*C.GdkPixbufAnimation)(unsafe.Pointer(a.Native()))

	C.gdk_pixbuf_animation_get_static_image(arg0)
}

// Width queries the width of the bounding box of a pixbuf animation.
func (a pixbufAnimation) Width(a PixbufAnimation) {
	var arg0 *C.GdkPixbufAnimation

	arg0 = (*C.GdkPixbufAnimation)(unsafe.Pointer(a.Native()))

	C.gdk_pixbuf_animation_get_width(arg0)
}

// IsStaticImage: if you load a file with
// gdk_pixbuf_animation_new_from_file() and it turns out to be a plain,
// unanimated image, then this function will return true. Use
// gdk_pixbuf_animation_get_static_image() to retrieve the image.
func (a pixbufAnimation) IsStaticImage(a PixbufAnimation) bool {
	var arg0 *C.GdkPixbufAnimation

	arg0 = (*C.GdkPixbufAnimation)(unsafe.Pointer(a.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gdk_pixbuf_animation_is_static_image(arg0)

	if cret {
		ok = true
	}

	return ok
}

// Ref adds a reference to an animation.
func (a pixbufAnimation) Ref(a PixbufAnimation) {
	var arg0 *C.GdkPixbufAnimation

	arg0 = (*C.GdkPixbufAnimation)(unsafe.Pointer(a.Native()))

	C.gdk_pixbuf_animation_ref(arg0)
}

// Unref removes a reference from an animation.
func (a pixbufAnimation) Unref(a PixbufAnimation) {
	var arg0 *C.GdkPixbufAnimation

	arg0 = (*C.GdkPixbufAnimation)(unsafe.Pointer(a.Native()))

	C.gdk_pixbuf_animation_unref(arg0)
}

// PixbufAnimationIter: an opaque struct representing an iterator which points
// to a certain position in an animation.
type PixbufAnimationIter interface {
	gextras.Objector

	// Advance: possibly advances an animation to a new frame. Chooses the frame
	// based on the start time passed to gdk_pixbuf_animation_get_iter().
	//
	// @current_time would normally come from g_get_current_time(), and must be
	// greater than or equal to the time passed to
	// gdk_pixbuf_animation_get_iter(), and must increase or remain unchanged
	// each time gdk_pixbuf_animation_iter_get_pixbuf() is called. That is, you
	// can't go backward in time; animations only play forward.
	//
	// As a shortcut, pass nil for the current time and g_get_current_time()
	// will be invoked on your behalf. So you only need to explicitly pass
	// @current_time if you're doing something odd like playing the animation at
	// double speed.
	//
	// If this function returns false, there's no need to update the animation
	// display, assuming the display had been rendered prior to advancing; if
	// true, you need to call gdk_pixbuf_animation_iter_get_pixbuf() and update
	// the display with the new pixbuf.
	Advance(i PixbufAnimationIter, currentTime *glib.TimeVal) bool
	// DelayTime gets the number of milliseconds the current pixbuf should be
	// displayed, or -1 if the current pixbuf should be displayed forever.
	// g_timeout_add() conveniently takes a timeout in milliseconds, so you can
	// use a timeout to schedule the next update.
	//
	// Note that some formats, like GIF, might clamp the timeout values in the
	// image file to avoid updates that are just too quick. The minimum timeout
	// for GIF images is currently 20 milliseconds.
	DelayTime(i PixbufAnimationIter)
	// Pixbuf gets the current pixbuf which should be displayed; the pixbuf
	// might not be the same size as the animation itself
	// (gdk_pixbuf_animation_get_width(), gdk_pixbuf_animation_get_height()).
	// This pixbuf should be displayed for
	// gdk_pixbuf_animation_iter_get_delay_time() milliseconds. The caller of
	// this function does not own a reference to the returned pixbuf; the
	// returned pixbuf will become invalid when the iterator advances to the
	// next frame, which may happen anytime you call
	// gdk_pixbuf_animation_iter_advance(). Copy the pixbuf to keep it (don't
	// just add a reference), as it may get recycled as you advance the
	// iterator.
	Pixbuf(i PixbufAnimationIter)
	// OnCurrentlyLoadingFrame: used to determine how to respond to the
	// area_updated signal on PixbufLoader when loading an animation.
	// area_updated is emitted for an area of the frame currently streaming in
	// to the loader. So if you're on the currently loading frame, you need to
	// redraw the screen for the updated area.
	OnCurrentlyLoadingFrame(i PixbufAnimationIter) bool
}

// pixbufAnimationIter implements the PixbufAnimationIter interface.
type pixbufAnimationIter struct {
	gextras.Objector
}

var _ PixbufAnimationIter = (*pixbufAnimationIter)(nil)

// WrapPixbufAnimationIter wraps a GObject to the right type. It is
// primarily used internally.
func WrapPixbufAnimationIter(obj *externglib.Object) PixbufAnimationIter {
	return PixbufAnimationIter{
		Objector: obj,
	}
}

func marshalPixbufAnimationIter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPixbufAnimationIter(obj), nil
}

// Advance: possibly advances an animation to a new frame. Chooses the frame
// based on the start time passed to gdk_pixbuf_animation_get_iter().
//
// @current_time would normally come from g_get_current_time(), and must be
// greater than or equal to the time passed to
// gdk_pixbuf_animation_get_iter(), and must increase or remain unchanged
// each time gdk_pixbuf_animation_iter_get_pixbuf() is called. That is, you
// can't go backward in time; animations only play forward.
//
// As a shortcut, pass nil for the current time and g_get_current_time()
// will be invoked on your behalf. So you only need to explicitly pass
// @current_time if you're doing something odd like playing the animation at
// double speed.
//
// If this function returns false, there's no need to update the animation
// display, assuming the display had been rendered prior to advancing; if
// true, you need to call gdk_pixbuf_animation_iter_get_pixbuf() and update
// the display with the new pixbuf.
func (i pixbufAnimationIter) Advance(i PixbufAnimationIter, currentTime *glib.TimeVal) bool {
	var arg0 *C.GdkPixbufAnimationIter
	var arg1 *C.GTimeVal

	arg0 = (*C.GdkPixbufAnimationIter)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GTimeVal)(unsafe.Pointer(currentTime.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gdk_pixbuf_animation_iter_advance(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// DelayTime gets the number of milliseconds the current pixbuf should be
// displayed, or -1 if the current pixbuf should be displayed forever.
// g_timeout_add() conveniently takes a timeout in milliseconds, so you can
// use a timeout to schedule the next update.
//
// Note that some formats, like GIF, might clamp the timeout values in the
// image file to avoid updates that are just too quick. The minimum timeout
// for GIF images is currently 20 milliseconds.
func (i pixbufAnimationIter) DelayTime(i PixbufAnimationIter) {
	var arg0 *C.GdkPixbufAnimationIter

	arg0 = (*C.GdkPixbufAnimationIter)(unsafe.Pointer(i.Native()))

	C.gdk_pixbuf_animation_iter_get_delay_time(arg0)
}

// Pixbuf gets the current pixbuf which should be displayed; the pixbuf
// might not be the same size as the animation itself
// (gdk_pixbuf_animation_get_width(), gdk_pixbuf_animation_get_height()).
// This pixbuf should be displayed for
// gdk_pixbuf_animation_iter_get_delay_time() milliseconds. The caller of
// this function does not own a reference to the returned pixbuf; the
// returned pixbuf will become invalid when the iterator advances to the
// next frame, which may happen anytime you call
// gdk_pixbuf_animation_iter_advance(). Copy the pixbuf to keep it (don't
// just add a reference), as it may get recycled as you advance the
// iterator.
func (i pixbufAnimationIter) Pixbuf(i PixbufAnimationIter) {
	var arg0 *C.GdkPixbufAnimationIter

	arg0 = (*C.GdkPixbufAnimationIter)(unsafe.Pointer(i.Native()))

	C.gdk_pixbuf_animation_iter_get_pixbuf(arg0)
}

// OnCurrentlyLoadingFrame: used to determine how to respond to the
// area_updated signal on PixbufLoader when loading an animation.
// area_updated is emitted for an area of the frame currently streaming in
// to the loader. So if you're on the currently loading frame, you need to
// redraw the screen for the updated area.
func (i pixbufAnimationIter) OnCurrentlyLoadingFrame(i PixbufAnimationIter) bool {
	var arg0 *C.GdkPixbufAnimationIter

	arg0 = (*C.GdkPixbufAnimationIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gdk_pixbuf_animation_iter_on_currently_loading_frame(arg0)

	if cret {
		ok = true
	}

	return ok
}

type PixbufSimpleAnimIter interface {
	PixbufAnimationIter
}

// pixbufSimpleAnimIter implements the PixbufSimpleAnimIter interface.
type pixbufSimpleAnimIter struct {
	PixbufAnimationIter
}

var _ PixbufSimpleAnimIter = (*pixbufSimpleAnimIter)(nil)

// WrapPixbufSimpleAnimIter wraps a GObject to the right type. It is
// primarily used internally.
func WrapPixbufSimpleAnimIter(obj *externglib.Object) PixbufSimpleAnimIter {
	return PixbufSimpleAnimIter{
		PixbufAnimationIter: WrapPixbufAnimationIter(obj),
	}
}

func marshalPixbufSimpleAnimIter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPixbufSimpleAnimIter(obj), nil
}
