// Code generated by girgen. DO NOT EDIT.

package gdkpixbuf

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/gio"
	"github.com/diamondburned/gotk4/pkg/glib"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gdk-pixbuf-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <gdk-pixbuf/gdk-pixbuf.h>
//
// extern gboolean gotk4_PixbufSaveFunc(const gchar*, gsize, GError**, gpointer)
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		// Enums
		{T: externglib.Type(C.gdk_colorspace_get_type()), F: marshalColorspace},
		{T: externglib.Type(C.gdk_interp_type_get_type()), F: marshalInterpType},
		{T: externglib.Type(C.gdk_pixbuf_alpha_mode_get_type()), F: marshalPixbufAlphaMode},
		{T: externglib.Type(C.gdk_pixbuf_error_get_type()), F: marshalPixbufError},
		{T: externglib.Type(C.gdk_pixbuf_rotation_get_type()), F: marshalPixbufRotation},

		// Records
		{T: externglib.Type(C.gdk_pixbuf_format_get_type()), F: marshalPixbufFormat},
		// Skipped PixbufLoaderClass.
		// Skipped PixbufSimpleAnimClass.

		// Classes
		{T: externglib.Type(C.gdk_pixbuf_get_type()), F: marshalPixbuf},
		{T: externglib.Type(C.gdk_pixbuf_animation_get_type()), F: marshalPixbufAnimation},
		{T: externglib.Type(C.gdk_pixbuf_animation_iter_get_type()), F: marshalPixbufAnimationIter},
		{T: externglib.Type(C.gdk_pixbuf_loader_get_type()), F: marshalPixbufLoader},
		{T: externglib.Type(C.gdk_pixbuf_simple_anim_get_type()), F: marshalPixbufSimpleAnim},
		{T: externglib.Type(C.gdk_pixbuf_simple_anim_iter_get_type()), F: marshalPixbufSimpleAnimIter},
	})
}

// Colorspace: this enumeration defines the color spaces that are supported by
// the gdk-pixbuf library. Currently only RGB is supported.
type Colorspace int

const (
	// ColorspaceRGB indicates a red/green/blue additive color space.
	ColorspaceRGB Colorspace = 0
)

func marshalColorspace(p uintptr) (interface{}, error) {
	return Colorspace(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// InterpType: this enumeration describes the different interpolation modes that
// can be used with the scaling functions. @GDK_INTERP_NEAREST is the fastest
// scaling method, but has horrible quality when scaling down.
// @GDK_INTERP_BILINEAR is the best choice if you aren't sure what to choose, it
// has a good speed/quality balance.
//
// **Note**: Cubic filtering is missing from the list; hyperbolic interpolation
// is just as fast and results in higher quality.
type InterpType int

const (
	// InterpTypeNearest: nearest neighbor sampling; this is the fastest and
	// lowest quality mode. Quality is normally unacceptable when scaling down,
	// but may be OK when scaling up.
	InterpTypeNearest InterpType = 0
	// InterpTypeTiles: this is an accurate simulation of the PostScript image
	// operator without any interpolation enabled. Each pixel is rendered as a
	// tiny parallelogram of solid color, the edges of which are implemented
	// with antialiasing. It resembles nearest neighbor for enlargement, and
	// bilinear for reduction.
	InterpTypeTiles InterpType = 1
	// InterpTypeBilinear: best quality/speed balance; use this mode by default.
	// Bilinear interpolation. For enlargement, it is equivalent to
	// point-sampling the ideal bilinear-interpolated image. For reduction, it
	// is equivalent to laying down small tiles and integrating over the
	// coverage area.
	InterpTypeBilinear InterpType = 2
	// InterpTypeHyper: this is the slowest and highest quality reconstruction
	// function. It is derived from the hyperbolic filters in Wolberg's "Digital
	// Image Warping", and is formally defined as the hyperbolic-filter sampling
	// the ideal hyperbolic-filter interpolated image (the filter is designed to
	// be idempotent for 1:1 pixel mapping). **Deprecated**: this interpolation
	// filter is deprecated, as in reality it has a lower quality than the
	// @GDK_INTERP_BILINEAR filter (Since: 2.38)
	InterpTypeHyper InterpType = 3
)

func marshalInterpType(p uintptr) (interface{}, error) {
	return InterpType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PixbufAlphaMode: these values can be passed to
// gdk_pixbuf_xlib_render_to_drawable_alpha() to control how the alpha channel
// of an image should be handled. This function can create a bilevel clipping
// mask (black and white) and use it while painting the image. In the future,
// when the X Window System gets an alpha channel extension, it will be possible
// to do full alpha compositing onto arbitrary drawables. For now both cases
// fall back to a bilevel clipping mask.
type PixbufAlphaMode int

const (
	// PixbufAlphaModeBilevel: a bilevel clipping mask (black and white) will be
	// created and used to draw the image. Pixels below 0.5 opacity will be
	// considered fully transparent, and all others will be considered fully
	// opaque.
	PixbufAlphaModeBilevel PixbufAlphaMode = 0
	// PixbufAlphaModeFull: for now falls back to K_PIXBUF_ALPHA_BILEVEL. In the
	// future it will do full alpha compositing.
	PixbufAlphaModeFull PixbufAlphaMode = 1
)

func marshalPixbufAlphaMode(p uintptr) (interface{}, error) {
	return PixbufAlphaMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PixbufError: an error code in the K_PIXBUF_ERROR domain. Many gdk-pixbuf
// operations can cause errors in this domain, or in the FILE_ERROR domain.
type PixbufError int

const (
	// PixbufErrorCorruptImage: an image file was broken somehow.
	PixbufErrorCorruptImage PixbufError = 0
	// PixbufErrorInsufficientMemory: not enough memory.
	PixbufErrorInsufficientMemory PixbufError = 1
	// PixbufErrorBadOption: a bad option was passed to a pixbuf save module.
	PixbufErrorBadOption PixbufError = 2
	// PixbufErrorUnknownType: unknown image type.
	PixbufErrorUnknownType PixbufError = 3
	// PixbufErrorUnsupportedOperation: don't know how to perform the given
	// operation on the type of image at hand.
	PixbufErrorUnsupportedOperation PixbufError = 4
	// PixbufErrorFailed: generic failure code, something went wrong.
	PixbufErrorFailed PixbufError = 5
	// PixbufErrorIncompleteAnimation: only part of the animation was loaded.
	PixbufErrorIncompleteAnimation PixbufError = 6
)

func marshalPixbufError(p uintptr) (interface{}, error) {
	return PixbufError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PixbufRotation: the possible rotations which can be passed to
// gdk_pixbuf_rotate_simple(). To make them easier to use, their numerical
// values are the actual degrees.
type PixbufRotation int

const (
	// PixbufRotationNone: no rotation.
	PixbufRotationNone PixbufRotation = 0
	// PixbufRotationCounterclockwise: rotate by 90 degrees.
	PixbufRotationCounterclockwise PixbufRotation = 90
	// PixbufRotationUpsidedown: rotate by 180 degrees.
	PixbufRotationUpsidedown PixbufRotation = 180
	// PixbufRotationClockwise: rotate by 270 degrees.
	PixbufRotationClockwise PixbufRotation = 270
)

func marshalPixbufRotation(p uintptr) (interface{}, error) {
	return PixbufRotation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PixbufSaveFunc specifies the type of the function passed to
// gdk_pixbuf_save_to_callback(). It is called once for each block of bytes that
// is "written" by gdk_pixbuf_save_to_callback(). If successful it should return
// true. If an error occurs it should set @error and return false, in which case
// gdk_pixbuf_save_to_callback() will fail with the same error.
type PixbufSaveFunc func(buf []byte) (err *glib.Error, ok bool)

//export gotk4_PixbufSaveFunc
func gotk4_PixbufSaveFunc(arg0 *C.gchar, arg1 C.gsize, arg2 **C.GError, arg3 C.gpointer) C.gboolean {
	v := box.Get(box.Callback, uintptr(arg3))
	if v == nil {
		panic(`callback not found`)
	}

	var buf []byte

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&buf))
		sliceHeader.Data = uintptr(unsafe.Pointer(arg0))
		sliceHeader.Len = arg1
		sliceHeader.Cap = arg1
		runtime.SetFinalizer(&arg0, func() {
			C.free(unsafe.Pointer(arg0))
		})
		defer runtime.KeepAlive(arg0)
	}

	err, ok := v.(PixbufSaveFunc)(buf)
}

func PixbufErrorQuark() glib.Quark {

	ret := C.gdk_pixbuf_error_quark()

	var ret0 glib.Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

type PixbufFormat struct {
	native C.GdkPixbufFormat
}

// WrapPixbufFormat wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPixbufFormat(ptr unsafe.Pointer) *PixbufFormat {
	if ptr == nil {
		return nil
	}

	return (*PixbufFormat)(ptr)
}

func marshalPixbufFormat(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapPixbufFormat(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (p *PixbufFormat) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

// Pixbuf: this is the main structure in the gdk-pixbuf library. It is used to
// represent images. It contains information about the image's pixel data, its
// color space, bits per sample, width and height, and the rowstride (the number
// of bytes between the start of one row and the start of the next).
type Pixbuf interface {
	gextras.Objector

	// AddAlpha takes an existing pixbuf and adds an alpha channel to it. If the
	// existing pixbuf already had an alpha channel, the channel values are
	// copied from the original; otherwise, the alpha channel is initialized to
	// 255 (full opacity).
	//
	// If @substitute_color is true, then the color specified by (@r, @g, @b)
	// will be assigned zero opacity. That is, if you pass (255, 255, 255) for
	// the substitute color, all white pixels will become fully transparent.
	AddAlpha(substituteColor bool, r byte, g byte, b byte) Pixbuf
	// ApplyEmbeddedOrientation takes an existing pixbuf and checks for the
	// presence of an associated "orientation" option, which may be provided by
	// the jpeg loader (which reads the exif orientation tag) or the tiff loader
	// (which reads the tiff orientation tag, and compensates it for the partial
	// transforms performed by libtiff). If an orientation option/tag is
	// present, the appropriate transform will be performed so that the pixbuf
	// is oriented correctly.
	ApplyEmbeddedOrientation() Pixbuf
	// Composite creates a transformation of the source image @src by scaling by
	// @scale_x and @scale_y then translating by @offset_x and @offset_y. This
	// gives an image in the coordinates of the destination pixbuf. The
	// rectangle (@dest_x, @dest_y, @dest_width, @dest_height) is then alpha
	// blended onto the corresponding rectangle of the original destination
	// image.
	//
	// When the destination rectangle contains parts not in the source image,
	// the data at the edges of the source image is replicated to infinity.
	//
	// ! (composite.png)
	Composite(dest Pixbuf, destX int, destY int, destWidth int, destHeight int, offsetX float64, offsetY float64, scaleX float64, scaleY float64, interpType InterpType, overallAlpha int)
	// CompositeColor creates a transformation of the source image @src by
	// scaling by @scale_x and @scale_y then translating by @offset_x and
	// @offset_y, then alpha blends the rectangle (@dest_x ,@dest_y,
	// @dest_width, @dest_height) of the resulting image with a checkboard of
	// the colors @color1 and @color2 and renders it onto the destination image.
	//
	// If the source image has no alpha channel, and @overall_alpha is 255, a
	// fast path is used which omits the alpha blending and just performs the
	// scaling.
	//
	// See gdk_pixbuf_composite_color_simple() for a simpler variant of this
	// function suitable for many tasks.
	CompositeColor(dest Pixbuf, destX int, destY int, destWidth int, destHeight int, offsetX float64, offsetY float64, scaleX float64, scaleY float64, interpType InterpType, overallAlpha int, checkX int, checkY int, checkSize int, color1 uint32, color2 uint32)
	// CompositeColorSimple creates a new Pixbuf by scaling @src to @dest_width
	// x @dest_height and alpha blending the result with a checkboard of colors
	// @color1 and @color2.
	CompositeColorSimple(destWidth int, destHeight int, interpType InterpType, overallAlpha int, checkSize int, color1 uint32, color2 uint32) Pixbuf
	// Copy creates a new Pixbuf with a copy of the information in the specified
	// @pixbuf. Note that this does not copy the options set on the original
	// Pixbuf, use gdk_pixbuf_copy_options() for this.
	Copy() Pixbuf
	// CopyArea copies a rectangular area from @src_pixbuf to @dest_pixbuf.
	// Conversion of pixbuf formats is done automatically.
	//
	// If the source rectangle overlaps the destination rectangle on the same
	// pixbuf, it will be overwritten during the copy operation. Therefore, you
	// can not use this function to scroll a pixbuf.
	CopyArea(srcX int, srcY int, width int, height int, destPixbuf Pixbuf, destX int, destY int)
	// CopyOptions: copy the key/value pair options attached to a Pixbuf to
	// another. This is useful to keep original metadata after having
	// manipulated a file. However be careful to remove metadata which you've
	// already applied, such as the "orientation" option after rotating the
	// image.
	CopyOptions(destPixbuf Pixbuf) bool
	// Fill clears a pixbuf to the given RGBA value, converting the RGBA value
	// into the pixbuf's pixel format. The alpha will be ignored if the pixbuf
	// doesn't have an alpha channel.
	Fill(pixel uint32)
	// Flip flips a pixbuf horizontally or vertically and returns the result in
	// a new pixbuf.
	Flip(horizontal bool) Pixbuf
	// BitsPerSample queries the number of bits per color sample in a pixbuf.
	BitsPerSample() int
	// ByteLength returns the length of the pixel data, in bytes.
	ByteLength() uint
	// Colorspace queries the color space of a pixbuf.
	Colorspace() Colorspace
	// HasAlpha queries whether a pixbuf has an alpha channel (opacity
	// information).
	HasAlpha() bool
	// Height queries the height of a pixbuf.
	Height() int
	// NChannels queries the number of channels of a pixbuf.
	NChannels() int
	// Option looks up @key in the list of options that may have been attached
	// to the @pixbuf when it was loaded, or that may have been attached by
	// another function using gdk_pixbuf_set_option().
	//
	// For instance, the ANI loader provides "Title" and "Artist" options. The
	// ICO, XBM, and XPM loaders provide "x_hot" and "y_hot" hot-spot options
	// for cursor definitions. The PNG loader provides the tEXt ancillary chunk
	// key/value pairs as options. Since 2.12, the TIFF and JPEG loaders return
	// an "orientation" option string that corresponds to the embedded TIFF/Exif
	// orientation tag (if present). Since 2.32, the TIFF loader sets the
	// "multipage" option string to "yes" when a multi-page TIFF is loaded.
	// Since 2.32 the JPEG and PNG loaders set "x-dpi" and "y-dpi" if the file
	// contains image density information in dots per inch. Since 2.36.6, the
	// JPEG loader sets the "comment" option with the comment EXIF tag.
	Option(key string) string
	// Options returns a Table with a list of all the options that may have been
	// attached to the @pixbuf when it was loaded, or that may have been
	// attached by another function using gdk_pixbuf_set_option().
	//
	// See gdk_pixbuf_get_option() for more details.
	Options() *glib.HashTable
	// Pixels queries a pointer to the pixel data of a pixbuf.
	Pixels() []byte
	// PixelsWithLength queries a pointer to the pixel data of a pixbuf.
	PixelsWithLength() (length uint, guint8s []byte)
	// Rowstride queries the rowstride of a pixbuf, which is the number of bytes
	// between the start of a row and the start of the next row.
	Rowstride() int
	// Width queries the width of a pixbuf.
	Width() int
	// NewSubpixbuf creates a new pixbuf which represents a sub-region of
	// @src_pixbuf. The new pixbuf shares its pixels with the original pixbuf,
	// so writing to one affects both. The new pixbuf holds a reference to
	// @src_pixbuf, so @src_pixbuf will not be finalized until the new pixbuf is
	// finalized.
	//
	// Note that if @src_pixbuf is read-only, this function will force it to be
	// mutable.
	NewSubpixbuf(srcX int, srcY int, width int, height int) Pixbuf
	// ReadPixelBytes provides a #GBytes buffer containing the raw pixel data;
	// the data must not be modified. This function allows skipping the implicit
	// copy that must be made if gdk_pixbuf_get_pixels() is called on a
	// read-only pixbuf.
	ReadPixelBytes() *glib.Bytes
	// ReadPixels provides a read-only pointer to the raw pixel data; must not
	// be modified. This function allows skipping the implicit copy that must be
	// made if gdk_pixbuf_get_pixels() is called on a read-only pixbuf.
	ReadPixels() byte
	// Ref adds a reference to a pixbuf.
	Ref() Pixbuf
	// RemoveOption: remove the key/value pair option attached to a Pixbuf.
	RemoveOption(key string) bool
	// RotateSimple rotates a pixbuf by a multiple of 90 degrees, and returns
	// the result in a new pixbuf.
	//
	// If @angle is 0, a copy of @src is returned, avoiding any rotation.
	RotateSimple(angle PixbufRotation) Pixbuf
	// SaturateAndPixelate modifies saturation and optionally pixelates @src,
	// placing the result in @dest. @src and @dest may be the same pixbuf with
	// no ill effects. If @saturation is 1.0 then saturation is not changed. If
	// it's less than 1.0, saturation is reduced (the image turns toward
	// grayscale); if greater than 1.0, saturation is increased (the image gets
	// more vivid colors). If @pixelate is true, then pixels are faded in a
	// checkerboard pattern to create a pixelated image. @src and @dest must
	// have the same image format, size, and rowstride.
	SaturateAndPixelate(dest Pixbuf, saturation float32, pixelate bool)
	// SaveToBufferv saves pixbuf to a new buffer in format @type, which is
	// currently "jpeg", "tiff", "png", "ico" or "bmp". See
	// gdk_pixbuf_save_to_buffer() for more details.
	SaveToBufferv(_type string, optionKeys []string, optionValues []string) (buffer []byte, bufferSize uint, ok bool)
	// SaveToCallbackv saves pixbuf to a callback in format @type, which is
	// currently "jpeg", "png", "tiff", "ico" or "bmp". If @error is set, false
	// will be returned. See gdk_pixbuf_save_to_callback () for more details.
	SaveToCallbackv(saveFunc PixbufSaveFunc, _type string, optionKeys []string, optionValues []string) bool
	// SaveToStreamv saves @pixbuf to an output stream.
	//
	// Supported file formats are currently "jpeg", "tiff", "png", "ico" or
	// "bmp". See gdk_pixbuf_save_to_stream() for more details.
	SaveToStreamv(stream gio.OutputStream, _type string, optionKeys []string, optionValues []string, cancellable gio.Cancellable) bool
	// SaveToStreamvAsync saves @pixbuf to an output stream asynchronously.
	//
	// For more details see gdk_pixbuf_save_to_streamv(), which is the
	// synchronous version of this function.
	//
	// When the operation is finished, @callback will be called in the main
	// thread. You can then call gdk_pixbuf_save_to_stream_finish() to get the
	// result of the operation.
	SaveToStreamvAsync(stream gio.OutputStream, _type string, optionKeys []string, optionValues []string, cancellable gio.Cancellable, callback gio.AsyncReadyCallback)
	// Savev saves pixbuf to a file in @type, which is currently "jpeg", "png",
	// "tiff", "ico" or "bmp". If @error is set, false will be returned. See
	// gdk_pixbuf_save () for more details.
	Savev(filename string, _type string, optionKeys []string, optionValues []string) bool
	// Scale creates a transformation of the source image @src by scaling by
	// @scale_x and @scale_y then translating by @offset_x and @offset_y, then
	// renders the rectangle (@dest_x, @dest_y, @dest_width, @dest_height) of
	// the resulting image onto the destination image replacing the previous
	// contents.
	//
	// Try to use gdk_pixbuf_scale_simple() first, this function is the
	// industrial-strength power tool you can fall back to if
	// gdk_pixbuf_scale_simple() isn't powerful enough.
	//
	// If the source rectangle overlaps the destination rectangle on the same
	// pixbuf, it will be overwritten during the scaling which results in
	// rendering artifacts.
	Scale(dest Pixbuf, destX int, destY int, destWidth int, destHeight int, offsetX float64, offsetY float64, scaleX float64, scaleY float64, interpType InterpType)
	// ScaleSimple: create a new Pixbuf containing a copy of @src scaled to
	// @dest_width x @dest_height. Leaves @src unaffected. @interp_type should
	// be K_INTERP_NEAREST if you want maximum speed (but when scaling down
	// K_INTERP_NEAREST is usually unusably ugly). The default @interp_type
	// should be K_INTERP_BILINEAR which offers reasonable quality and speed.
	//
	// You can scale a sub-portion of @src by creating a sub-pixbuf pointing
	// into @src; see gdk_pixbuf_new_subpixbuf().
	//
	// If @dest_width and @dest_height are equal to the @src width and height, a
	// copy of @src is returned, avoiding any scaling.
	//
	// For more complicated scaling/alpha blending see gdk_pixbuf_scale() and
	// gdk_pixbuf_composite().
	ScaleSimple(destWidth int, destHeight int, interpType InterpType) Pixbuf
	// SetOption attaches a key/value pair as an option to a Pixbuf. If @key
	// already exists in the list of options attached to @pixbuf, the new value
	// is ignored and false is returned.
	SetOption(key string, value string) bool
	// Unref removes a reference from a pixbuf.
	Unref()
}

type pixbuf struct {
	*externglib.Object
}

// WrapPixbuf wraps a GObject to the right type. It is
// primarily used internally.
func WrapPixbuf(obj *externglib.Object) Pixbuf {
	return pixbuf{*externglib.Object{obj}}
}

func marshalPixbuf(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPixbuf(obj), nil
}

// New_ constructs a class Pixbuf.
func New_(colorspace Colorspace, hasAlpha bool, bitsPerSample int, width int, height int) Pixbuf {
	var arg1 C.GdkColorspace
	var arg2 C.gboolean
	var arg3 C.int
	var arg4 C.int
	var arg5 C.int

	arg1 = (C.GdkColorspace)(colorspace)
	arg2 = gextras.Cbool(hasAlpha)
	arg3 = C.int(bitsPerSample)
	arg4 = C.int(width)
	arg5 = C.int(height)

	ret := C.gdk_pixbuf_new(arg1, arg2, arg3, arg4, arg5)

	var ret0 Pixbuf

	ret0 = WrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// New_FromBytes constructs a class Pixbuf.
func New_FromBytes(data *glib.Bytes, colorspace Colorspace, hasAlpha bool, bitsPerSample int, width int, height int, rowstride int) Pixbuf {
	var arg1 *C.GBytes
	var arg2 C.GdkColorspace
	var arg3 C.gboolean
	var arg4 C.int
	var arg5 C.int
	var arg6 C.int
	var arg7 C.int

	arg1 = (*C.GBytes)(data.Native())
	arg2 = (C.GdkColorspace)(colorspace)
	arg3 = gextras.Cbool(hasAlpha)
	arg4 = C.int(bitsPerSample)
	arg5 = C.int(width)
	arg6 = C.int(height)
	arg7 = C.int(rowstride)

	ret := C.gdk_pixbuf_new_from_bytes(arg1, arg2, arg3, arg4, arg5, arg6, arg7)

	var ret0 Pixbuf

	ret0 = WrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// New_FromData constructs a class Pixbuf.
func New_FromData(data []byte, colorspace Colorspace, hasAlpha bool, bitsPerSample int, width int, height int, rowstride int) Pixbuf {
	var arg1 *C.guchar
	var arg2 C.GdkColorspace
	var arg3 C.gboolean
	var arg4 C.int
	var arg5 C.int
	var arg6 C.int
	var arg7 C.int
	arg9 := C.gpointer(box.Assign(destroyFnData))

	{

	}
	arg2 = (C.GdkColorspace)(colorspace)
	arg3 = gextras.Cbool(hasAlpha)
	arg4 = C.int(bitsPerSample)
	arg5 = C.int(width)
	arg6 = C.int(height)
	arg7 = C.int(rowstride)

	ret := C.gdk_pixbuf_new_from_data(arg1, arg2, arg3, arg4, arg5, arg6, arg7, (*[0]byte)(C.free))

	var ret0 Pixbuf

	ret0 = WrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// New_FromFile constructs a class Pixbuf.
func New_FromFile(filename string) Pixbuf {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gdk_pixbuf_new_from_file(arg1)

	var ret0 Pixbuf

	ret0 = WrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// New_FromFileAtScale constructs a class Pixbuf.
func New_FromFileAtScale(filename string, width int, height int, preserveAspectRatio bool) Pixbuf {
	var arg1 *C.char
	var arg2 C.int
	var arg3 C.int
	var arg4 C.gboolean

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(width)
	arg3 = C.int(height)
	arg4 = gextras.Cbool(preserveAspectRatio)

	ret := C.gdk_pixbuf_new_from_file_at_scale(arg1, arg2, arg3, arg4)

	var ret0 Pixbuf

	ret0 = WrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// New_FromFileAtSize constructs a class Pixbuf.
func New_FromFileAtSize(filename string, width int, height int) Pixbuf {
	var arg1 *C.char
	var arg2 C.int
	var arg3 C.int

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(width)
	arg3 = C.int(height)

	ret := C.gdk_pixbuf_new_from_file_at_size(arg1, arg2, arg3)

	var ret0 Pixbuf

	ret0 = WrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// New_FromInline constructs a class Pixbuf.
func New_FromInline(dataLength int, data []byte, copyPixels bool) Pixbuf {
	var arg1 C.gint
	var arg2 *C.guint8
	var arg3 C.gboolean

	{
		arg2 = (*C.guint8)(&data[0])
		arg1 = len(data)
		defer runtime.KeepAlive(data)
	}
	arg3 = gextras.Cbool(copyPixels)

	ret := C.gdk_pixbuf_new_from_inline(arg1, arg2, arg3)

	var ret0 Pixbuf

	ret0 = WrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// New_FromResource constructs a class Pixbuf.
func New_FromResource(resourcePath string) Pixbuf {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gdk_pixbuf_new_from_resource(arg1)

	var ret0 Pixbuf

	ret0 = WrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// New_FromResourceAtScale constructs a class Pixbuf.
func New_FromResourceAtScale(resourcePath string, width int, height int, preserveAspectRatio bool) Pixbuf {
	var arg1 *C.char
	var arg2 C.int
	var arg3 C.int
	var arg4 C.gboolean

	arg1 = (*C.gchar)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(width)
	arg3 = C.int(height)
	arg4 = gextras.Cbool(preserveAspectRatio)

	ret := C.gdk_pixbuf_new_from_resource_at_scale(arg1, arg2, arg3, arg4)

	var ret0 Pixbuf

	ret0 = WrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// New_FromStream constructs a class Pixbuf.
func New_FromStream(stream gio.InputStream, cancellable gio.Cancellable) Pixbuf {
	var arg1 *C.GInputStream
	var arg2 *C.GCancellable

	arg1 = (*C.GInputStream)(stream.Native())
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.gdk_pixbuf_new_from_stream(arg1, arg2)

	var ret0 Pixbuf

	ret0 = WrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// New_FromStreamAtScale constructs a class Pixbuf.
func New_FromStreamAtScale(stream gio.InputStream, width int, height int, preserveAspectRatio bool, cancellable gio.Cancellable) Pixbuf {
	var arg1 *C.GInputStream
	var arg2 C.gint
	var arg3 C.gint
	var arg4 C.gboolean
	var arg5 *C.GCancellable

	arg1 = (*C.GInputStream)(stream.Native())
	arg2 = C.gint(width)
	arg3 = C.gint(height)
	arg4 = gextras.Cbool(preserveAspectRatio)
	arg5 = (*C.GCancellable)(cancellable.Native())

	ret := C.gdk_pixbuf_new_from_stream_at_scale(arg1, arg2, arg3, arg4, arg5)

	var ret0 Pixbuf

	ret0 = WrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// New_FromStreamFinish constructs a class Pixbuf.
func New_FromStreamFinish(asyncResult gio.AsyncResult) Pixbuf {
	var arg1 *C.GAsyncResult

	ret := C.gdk_pixbuf_new_from_stream_finish(arg1)

	var ret0 Pixbuf

	ret0 = WrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// New_FromXpmData constructs a class Pixbuf.
func New_FromXpmData(data []string) Pixbuf {
	var arg1 **C.char

	{

	}

	ret := C.gdk_pixbuf_new_from_xpm_data(arg1)

	var ret0 Pixbuf

	ret0 = WrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// AddAlpha takes an existing pixbuf and adds an alpha channel to it. If the
// existing pixbuf already had an alpha channel, the channel values are
// copied from the original; otherwise, the alpha channel is initialized to
// 255 (full opacity).
//
// If @substitute_color is true, then the color specified by (@r, @g, @b)
// will be assigned zero opacity. That is, if you pass (255, 255, 255) for
// the substitute color, all white pixels will become fully transparent.
func (pixbuf pixbuf) AddAlpha(substituteColor bool, r byte, g byte, b byte) Pixbuf {
	var arg0 *C.GdkPixbuf
	var arg1 C.gboolean
	var arg2 C.guchar
	var arg3 C.guchar
	var arg4 C.guchar

	arg0 = (*C.GdkPixbuf)(pixbuf.Native())
	arg1 = gextras.Cbool(substituteColor)
	arg2 = C.guchar(r)
	arg3 = C.guchar(g)
	arg4 = C.guchar(b)

	ret := C.gdk_pixbuf_add_alpha(arg0, arg1, arg2, arg3, arg4)

	var ret0 Pixbuf

	ret0 = WrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// ApplyEmbeddedOrientation takes an existing pixbuf and checks for the
// presence of an associated "orientation" option, which may be provided by
// the jpeg loader (which reads the exif orientation tag) or the tiff loader
// (which reads the tiff orientation tag, and compensates it for the partial
// transforms performed by libtiff). If an orientation option/tag is
// present, the appropriate transform will be performed so that the pixbuf
// is oriented correctly.
func (src pixbuf) ApplyEmbeddedOrientation() Pixbuf {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(src.Native())

	ret := C.gdk_pixbuf_apply_embedded_orientation(arg0)

	var ret0 Pixbuf

	ret0 = WrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Composite creates a transformation of the source image @src by scaling by
// @scale_x and @scale_y then translating by @offset_x and @offset_y. This
// gives an image in the coordinates of the destination pixbuf. The
// rectangle (@dest_x, @dest_y, @dest_width, @dest_height) is then alpha
// blended onto the corresponding rectangle of the original destination
// image.
//
// When the destination rectangle contains parts not in the source image,
// the data at the edges of the source image is replicated to infinity.
//
// ! (composite.png)
func (src pixbuf) Composite(dest Pixbuf, destX int, destY int, destWidth int, destHeight int, offsetX float64, offsetY float64, scaleX float64, scaleY float64, interpType InterpType, overallAlpha int) {
	var arg0 *C.GdkPixbuf
	var arg1 *C.GdkPixbuf
	var arg2 C.int
	var arg3 C.int
	var arg4 C.int
	var arg5 C.int
	var arg6 C.double
	var arg7 C.double
	var arg8 C.double
	var arg9 C.double
	var arg10 C.GdkInterpType
	var arg11 C.int

	arg0 = (*C.GdkPixbuf)(src.Native())
	arg1 = (*C.GdkPixbuf)(dest.Native())
	arg2 = C.int(destX)
	arg3 = C.int(destY)
	arg4 = C.int(destWidth)
	arg5 = C.int(destHeight)
	arg6 = C.double(offsetX)
	arg7 = C.double(offsetY)
	arg8 = C.double(scaleX)
	arg9 = C.double(scaleY)
	arg10 = (C.GdkInterpType)(interpType)
	arg11 = C.int(overallAlpha)

	C.gdk_pixbuf_composite(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11)
}

// CompositeColor creates a transformation of the source image @src by
// scaling by @scale_x and @scale_y then translating by @offset_x and
// @offset_y, then alpha blends the rectangle (@dest_x ,@dest_y,
// @dest_width, @dest_height) of the resulting image with a checkboard of
// the colors @color1 and @color2 and renders it onto the destination image.
//
// If the source image has no alpha channel, and @overall_alpha is 255, a
// fast path is used which omits the alpha blending and just performs the
// scaling.
//
// See gdk_pixbuf_composite_color_simple() for a simpler variant of this
// function suitable for many tasks.
func (src pixbuf) CompositeColor(dest Pixbuf, destX int, destY int, destWidth int, destHeight int, offsetX float64, offsetY float64, scaleX float64, scaleY float64, interpType InterpType, overallAlpha int, checkX int, checkY int, checkSize int, color1 uint32, color2 uint32) {
	var arg0 *C.GdkPixbuf
	var arg1 *C.GdkPixbuf
	var arg2 C.int
	var arg3 C.int
	var arg4 C.int
	var arg5 C.int
	var arg6 C.double
	var arg7 C.double
	var arg8 C.double
	var arg9 C.double
	var arg10 C.GdkInterpType
	var arg11 C.int
	var arg12 C.int
	var arg13 C.int
	var arg14 C.int
	var arg15 C.guint32
	var arg16 C.guint32

	arg0 = (*C.GdkPixbuf)(src.Native())
	arg1 = (*C.GdkPixbuf)(dest.Native())
	arg2 = C.int(destX)
	arg3 = C.int(destY)
	arg4 = C.int(destWidth)
	arg5 = C.int(destHeight)
	arg6 = C.double(offsetX)
	arg7 = C.double(offsetY)
	arg8 = C.double(scaleX)
	arg9 = C.double(scaleY)
	arg10 = (C.GdkInterpType)(interpType)
	arg11 = C.int(overallAlpha)
	arg12 = C.int(checkX)
	arg13 = C.int(checkY)
	arg14 = C.int(checkSize)
	arg15 = C.guint32(color1)
	arg16 = C.guint32(color2)

	C.gdk_pixbuf_composite_color(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16)
}

// CompositeColorSimple creates a new Pixbuf by scaling @src to @dest_width
// x @dest_height and alpha blending the result with a checkboard of colors
// @color1 and @color2.
func (src pixbuf) CompositeColorSimple(destWidth int, destHeight int, interpType InterpType, overallAlpha int, checkSize int, color1 uint32, color2 uint32) Pixbuf {
	var arg0 *C.GdkPixbuf
	var arg1 C.int
	var arg2 C.int
	var arg3 C.GdkInterpType
	var arg4 C.int
	var arg5 C.int
	var arg6 C.guint32
	var arg7 C.guint32

	arg0 = (*C.GdkPixbuf)(src.Native())
	arg1 = C.int(destWidth)
	arg2 = C.int(destHeight)
	arg3 = (C.GdkInterpType)(interpType)
	arg4 = C.int(overallAlpha)
	arg5 = C.int(checkSize)
	arg6 = C.guint32(color1)
	arg7 = C.guint32(color2)

	ret := C.gdk_pixbuf_composite_color_simple(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)

	var ret0 Pixbuf

	ret0 = WrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Copy creates a new Pixbuf with a copy of the information in the specified
// @pixbuf. Note that this does not copy the options set on the original
// Pixbuf, use gdk_pixbuf_copy_options() for this.
func (pixbuf pixbuf) Copy() Pixbuf {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(pixbuf.Native())

	ret := C.gdk_pixbuf_copy(arg0)

	var ret0 Pixbuf

	ret0 = WrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// CopyArea copies a rectangular area from @src_pixbuf to @dest_pixbuf.
// Conversion of pixbuf formats is done automatically.
//
// If the source rectangle overlaps the destination rectangle on the same
// pixbuf, it will be overwritten during the copy operation. Therefore, you
// can not use this function to scroll a pixbuf.
func (srcPixbuf pixbuf) CopyArea(srcX int, srcY int, width int, height int, destPixbuf Pixbuf, destX int, destY int) {
	var arg0 *C.GdkPixbuf
	var arg1 C.int
	var arg2 C.int
	var arg3 C.int
	var arg4 C.int
	var arg5 *C.GdkPixbuf
	var arg6 C.int
	var arg7 C.int

	arg0 = (*C.GdkPixbuf)(srcPixbuf.Native())
	arg1 = C.int(srcX)
	arg2 = C.int(srcY)
	arg3 = C.int(width)
	arg4 = C.int(height)
	arg5 = (*C.GdkPixbuf)(destPixbuf.Native())
	arg6 = C.int(destX)
	arg7 = C.int(destY)

	C.gdk_pixbuf_copy_area(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
}

// CopyOptions: copy the key/value pair options attached to a Pixbuf to
// another. This is useful to keep original metadata after having
// manipulated a file. However be careful to remove metadata which you've
// already applied, such as the "orientation" option after rotating the
// image.
func (srcPixbuf pixbuf) CopyOptions(destPixbuf Pixbuf) bool {
	var arg0 *C.GdkPixbuf
	var arg1 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(srcPixbuf.Native())
	arg1 = (*C.GdkPixbuf)(destPixbuf.Native())

	ret := C.gdk_pixbuf_copy_options(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Fill clears a pixbuf to the given RGBA value, converting the RGBA value
// into the pixbuf's pixel format. The alpha will be ignored if the pixbuf
// doesn't have an alpha channel.
func (pixbuf pixbuf) Fill(pixel uint32) {
	var arg0 *C.GdkPixbuf
	var arg1 C.guint32

	arg0 = (*C.GdkPixbuf)(pixbuf.Native())
	arg1 = C.guint32(pixel)

	C.gdk_pixbuf_fill(arg0, arg1)
}

// Flip flips a pixbuf horizontally or vertically and returns the result in
// a new pixbuf.
func (src pixbuf) Flip(horizontal bool) Pixbuf {
	var arg0 *C.GdkPixbuf
	var arg1 C.gboolean

	arg0 = (*C.GdkPixbuf)(src.Native())
	arg1 = gextras.Cbool(horizontal)

	ret := C.gdk_pixbuf_flip(arg0, arg1)

	var ret0 Pixbuf

	ret0 = WrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// BitsPerSample queries the number of bits per color sample in a pixbuf.
func (pixbuf pixbuf) BitsPerSample() int {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(pixbuf.Native())

	ret := C.gdk_pixbuf_get_bits_per_sample(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ByteLength returns the length of the pixel data, in bytes.
func (pixbuf pixbuf) ByteLength() uint {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(pixbuf.Native())

	ret := C.gdk_pixbuf_get_byte_length(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Colorspace queries the color space of a pixbuf.
func (pixbuf pixbuf) Colorspace() Colorspace {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(pixbuf.Native())

	ret := C.gdk_pixbuf_get_colorspace(arg0)

	var ret0 Colorspace

	ret0 = Colorspace(ret)

	return ret0
}

// HasAlpha queries whether a pixbuf has an alpha channel (opacity
// information).
func (pixbuf pixbuf) HasAlpha() bool {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(pixbuf.Native())

	ret := C.gdk_pixbuf_get_has_alpha(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Height queries the height of a pixbuf.
func (pixbuf pixbuf) Height() int {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(pixbuf.Native())

	ret := C.gdk_pixbuf_get_height(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// NChannels queries the number of channels of a pixbuf.
func (pixbuf pixbuf) NChannels() int {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(pixbuf.Native())

	ret := C.gdk_pixbuf_get_n_channels(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Option looks up @key in the list of options that may have been attached
// to the @pixbuf when it was loaded, or that may have been attached by
// another function using gdk_pixbuf_set_option().
//
// For instance, the ANI loader provides "Title" and "Artist" options. The
// ICO, XBM, and XPM loaders provide "x_hot" and "y_hot" hot-spot options
// for cursor definitions. The PNG loader provides the tEXt ancillary chunk
// key/value pairs as options. Since 2.12, the TIFF and JPEG loaders return
// an "orientation" option string that corresponds to the embedded TIFF/Exif
// orientation tag (if present). Since 2.32, the TIFF loader sets the
// "multipage" option string to "yes" when a multi-page TIFF is loaded.
// Since 2.32 the JPEG and PNG loaders set "x-dpi" and "y-dpi" if the file
// contains image density information in dots per inch. Since 2.36.6, the
// JPEG loader sets the "comment" option with the comment EXIF tag.
func (pixbuf pixbuf) Option(key string) string {
	var arg0 *C.GdkPixbuf
	var arg1 *C.gchar

	arg0 = (*C.GdkPixbuf)(pixbuf.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gdk_pixbuf_get_option(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Options returns a Table with a list of all the options that may have been
// attached to the @pixbuf when it was loaded, or that may have been
// attached by another function using gdk_pixbuf_set_option().
//
// See gdk_pixbuf_get_option() for more details.
func (pixbuf pixbuf) Options() *glib.HashTable {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(pixbuf.Native())

	ret := C.gdk_pixbuf_get_options(arg0)

	var ret0 *glib.HashTable

	ret0 = glib.WrapHashTable(ret)

	return ret0
}

// Pixels queries a pointer to the pixel data of a pixbuf.
func (pixbuf pixbuf) Pixels() []byte {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(pixbuf.Native())

	ret := C.gdk_pixbuf_get_pixels(arg0)

	var ret0 []byte

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]byte, length)
		for i := 0; i < length; i++ {
			src := (C.guint8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = byte(src)
		}
	}

	return ret0
}

// PixelsWithLength queries a pointer to the pixel data of a pixbuf.
func (pixbuf pixbuf) PixelsWithLength() (length uint, guint8s []byte) {
	var arg0 *C.GdkPixbuf
	var arg1 *C.guint // out

	arg0 = (*C.GdkPixbuf)(pixbuf.Native())

	ret := C.gdk_pixbuf_get_pixels_with_length(arg0, &arg1)

	var ret0 uint
	var ret1 []byte

	ret0 = uint(arg1)

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret1))
		sliceHeader.Data = uintptr(unsafe.Pointer(ret))
		sliceHeader.Len = arg1
		sliceHeader.Cap = arg1
		runtime.SetFinalizer(&ret, func() {
			C.free(unsafe.Pointer(ret))
		})
		defer runtime.KeepAlive(ret)
	}

	return ret0, ret1
}

// Rowstride queries the rowstride of a pixbuf, which is the number of bytes
// between the start of a row and the start of the next row.
func (pixbuf pixbuf) Rowstride() int {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(pixbuf.Native())

	ret := C.gdk_pixbuf_get_rowstride(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Width queries the width of a pixbuf.
func (pixbuf pixbuf) Width() int {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(pixbuf.Native())

	ret := C.gdk_pixbuf_get_width(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// NewSubpixbuf creates a new pixbuf which represents a sub-region of
// @src_pixbuf. The new pixbuf shares its pixels with the original pixbuf,
// so writing to one affects both. The new pixbuf holds a reference to
// @src_pixbuf, so @src_pixbuf will not be finalized until the new pixbuf is
// finalized.
//
// Note that if @src_pixbuf is read-only, this function will force it to be
// mutable.
func (srcPixbuf pixbuf) NewSubpixbuf(srcX int, srcY int, width int, height int) Pixbuf {
	var arg0 *C.GdkPixbuf
	var arg1 C.int
	var arg2 C.int
	var arg3 C.int
	var arg4 C.int

	arg0 = (*C.GdkPixbuf)(srcPixbuf.Native())
	arg1 = C.int(srcX)
	arg2 = C.int(srcY)
	arg3 = C.int(width)
	arg4 = C.int(height)

	ret := C.gdk_pixbuf_new_subpixbuf(arg0, arg1, arg2, arg3, arg4)

	var ret0 Pixbuf

	ret0 = WrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// ReadPixelBytes provides a #GBytes buffer containing the raw pixel data;
// the data must not be modified. This function allows skipping the implicit
// copy that must be made if gdk_pixbuf_get_pixels() is called on a
// read-only pixbuf.
func (pixbuf pixbuf) ReadPixelBytes() *glib.Bytes {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(pixbuf.Native())

	ret := C.gdk_pixbuf_read_pixel_bytes(arg0)

	var ret0 *glib.Bytes

	ret0 = glib.WrapBytes(ret)

	return ret0
}

// ReadPixels provides a read-only pointer to the raw pixel data; must not
// be modified. This function allows skipping the implicit copy that must be
// made if gdk_pixbuf_get_pixels() is called on a read-only pixbuf.
func (pixbuf pixbuf) ReadPixels() byte {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(pixbuf.Native())

	ret := C.gdk_pixbuf_read_pixels(arg0)

	var ret0 byte

	ret0 = byte(ret)

	return ret0
}

// Ref adds a reference to a pixbuf.
func (pixbuf pixbuf) Ref() Pixbuf {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(pixbuf.Native())

	ret := C.gdk_pixbuf_ref(arg0)

	var ret0 Pixbuf

	ret0 = WrapPixbuf(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// RemoveOption: remove the key/value pair option attached to a Pixbuf.
func (pixbuf pixbuf) RemoveOption(key string) bool {
	var arg0 *C.GdkPixbuf
	var arg1 *C.gchar

	arg0 = (*C.GdkPixbuf)(pixbuf.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gdk_pixbuf_remove_option(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// RotateSimple rotates a pixbuf by a multiple of 90 degrees, and returns
// the result in a new pixbuf.
//
// If @angle is 0, a copy of @src is returned, avoiding any rotation.
func (src pixbuf) RotateSimple(angle PixbufRotation) Pixbuf {
	var arg0 *C.GdkPixbuf
	var arg1 C.GdkPixbufRotation

	arg0 = (*C.GdkPixbuf)(src.Native())
	arg1 = (C.GdkPixbufRotation)(angle)

	ret := C.gdk_pixbuf_rotate_simple(arg0, arg1)

	var ret0 Pixbuf

	ret0 = WrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// SaturateAndPixelate modifies saturation and optionally pixelates @src,
// placing the result in @dest. @src and @dest may be the same pixbuf with
// no ill effects. If @saturation is 1.0 then saturation is not changed. If
// it's less than 1.0, saturation is reduced (the image turns toward
// grayscale); if greater than 1.0, saturation is increased (the image gets
// more vivid colors). If @pixelate is true, then pixels are faded in a
// checkerboard pattern to create a pixelated image. @src and @dest must
// have the same image format, size, and rowstride.
func (src pixbuf) SaturateAndPixelate(dest Pixbuf, saturation float32, pixelate bool) {
	var arg0 *C.GdkPixbuf
	var arg1 *C.GdkPixbuf
	var arg2 C.gfloat
	var arg3 C.gboolean

	arg0 = (*C.GdkPixbuf)(src.Native())
	arg1 = (*C.GdkPixbuf)(dest.Native())
	arg2 = C.gfloat(saturation)
	arg3 = gextras.Cbool(pixelate)

	C.gdk_pixbuf_saturate_and_pixelate(arg0, arg1, arg2, arg3)
}

// SaveToBufferv saves pixbuf to a new buffer in format @type, which is
// currently "jpeg", "tiff", "png", "ico" or "bmp". See
// gdk_pixbuf_save_to_buffer() for more details.
func (pixbuf pixbuf) SaveToBufferv(_type string, optionKeys []string, optionValues []string) (buffer []byte, bufferSize uint, ok bool) {
	var arg0 *C.GdkPixbuf
	var arg1 **C.gchar // out
	var arg2 *C.gsize  // out
	var arg3 *C.char
	var arg4 **C.char
	var arg5 **C.char

	arg0 = (*C.GdkPixbuf)(pixbuf.Native())
	arg3 = (*C.gchar)(C.CString(_type))
	defer C.free(unsafe.Pointer(arg3))
	{

	}
	{

	}

	ret := C.gdk_pixbuf_save_to_bufferv(arg0, &arg1, &arg2, arg3, arg4, arg5)

	var ret0 []byte
	var ret1 uint
	var ret2 bool

	{
		ret0 = make([]byte, arg2)
		for i := 0; i < uintptr(arg2); i++ {
			src := (C.guint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret0[i] = byte(src)
		}
	}

	ret1 = uint(arg2)

	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// SaveToCallbackv saves pixbuf to a callback in format @type, which is
// currently "jpeg", "png", "tiff", "ico" or "bmp". If @error is set, false
// will be returned. See gdk_pixbuf_save_to_callback () for more details.
func (pixbuf pixbuf) SaveToCallbackv(saveFunc PixbufSaveFunc, _type string, optionKeys []string, optionValues []string) bool {
	var arg0 *C.GdkPixbuf
	var arg1 C.GdkPixbufSaveFunc
	arg2 := C.gpointer(box.Assign(userData))
	var arg3 *C.char
	var arg4 **C.char
	var arg5 **C.char

	arg0 = (*C.GdkPixbuf)(pixbuf.Native())
	arg1 = (*[0]byte)(C.gotk4_PixbufSaveFunc)
	arg3 = (*C.gchar)(C.CString(_type))
	defer C.free(unsafe.Pointer(arg3))
	{

	}
	{

	}

	ret := C.gdk_pixbuf_save_to_callbackv(arg0, arg1, arg3, arg4, arg5)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SaveToStreamv saves @pixbuf to an output stream.
//
// Supported file formats are currently "jpeg", "tiff", "png", "ico" or
// "bmp". See gdk_pixbuf_save_to_stream() for more details.
func (pixbuf pixbuf) SaveToStreamv(stream gio.OutputStream, _type string, optionKeys []string, optionValues []string, cancellable gio.Cancellable) bool {
	var arg0 *C.GdkPixbuf
	var arg1 *C.GOutputStream
	var arg2 *C.char
	var arg3 **C.char
	var arg4 **C.char
	var arg5 *C.GCancellable

	arg0 = (*C.GdkPixbuf)(pixbuf.Native())
	arg1 = (*C.GOutputStream)(stream.Native())
	arg2 = (*C.gchar)(C.CString(_type))
	defer C.free(unsafe.Pointer(arg2))
	{

	}
	{

	}
	arg5 = (*C.GCancellable)(cancellable.Native())

	ret := C.gdk_pixbuf_save_to_streamv(arg0, arg1, arg2, arg3, arg4, arg5)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SaveToStreamvAsync saves @pixbuf to an output stream asynchronously.
//
// For more details see gdk_pixbuf_save_to_streamv(), which is the
// synchronous version of this function.
//
// When the operation is finished, @callback will be called in the main
// thread. You can then call gdk_pixbuf_save_to_stream_finish() to get the
// result of the operation.
func (pixbuf pixbuf) SaveToStreamvAsync(stream gio.OutputStream, _type string, optionKeys []string, optionValues []string, cancellable gio.Cancellable, callback gio.AsyncReadyCallback) {
	var arg0 *C.GdkPixbuf
	var arg1 *C.GOutputStream
	var arg2 *C.gchar
	var arg3 **C.gchar
	var arg4 **C.gchar
	var arg5 *C.GCancellable
	var arg6 C.GAsyncReadyCallback
	arg7 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GdkPixbuf)(pixbuf.Native())
	arg1 = (*C.GOutputStream)(stream.Native())
	arg2 = (*C.gchar)(C.CString(_type))
	defer C.free(unsafe.Pointer(arg2))
	{

	}
	{

	}
	arg5 = (*C.GCancellable)(cancellable.Native())
	arg6 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.gdk_pixbuf_save_to_streamv_async(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
}

// Savev saves pixbuf to a file in @type, which is currently "jpeg", "png",
// "tiff", "ico" or "bmp". If @error is set, false will be returned. See
// gdk_pixbuf_save () for more details.
func (pixbuf pixbuf) Savev(filename string, _type string, optionKeys []string, optionValues []string) bool {
	var arg0 *C.GdkPixbuf
	var arg1 *C.char
	var arg2 *C.char
	var arg3 **C.char
	var arg4 **C.char

	arg0 = (*C.GdkPixbuf)(pixbuf.Native())
	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(_type))
	defer C.free(unsafe.Pointer(arg2))
	{

	}
	{

	}

	ret := C.gdk_pixbuf_savev(arg0, arg1, arg2, arg3, arg4)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Scale creates a transformation of the source image @src by scaling by
// @scale_x and @scale_y then translating by @offset_x and @offset_y, then
// renders the rectangle (@dest_x, @dest_y, @dest_width, @dest_height) of
// the resulting image onto the destination image replacing the previous
// contents.
//
// Try to use gdk_pixbuf_scale_simple() first, this function is the
// industrial-strength power tool you can fall back to if
// gdk_pixbuf_scale_simple() isn't powerful enough.
//
// If the source rectangle overlaps the destination rectangle on the same
// pixbuf, it will be overwritten during the scaling which results in
// rendering artifacts.
func (src pixbuf) Scale(dest Pixbuf, destX int, destY int, destWidth int, destHeight int, offsetX float64, offsetY float64, scaleX float64, scaleY float64, interpType InterpType) {
	var arg0 *C.GdkPixbuf
	var arg1 *C.GdkPixbuf
	var arg2 C.int
	var arg3 C.int
	var arg4 C.int
	var arg5 C.int
	var arg6 C.double
	var arg7 C.double
	var arg8 C.double
	var arg9 C.double
	var arg10 C.GdkInterpType

	arg0 = (*C.GdkPixbuf)(src.Native())
	arg1 = (*C.GdkPixbuf)(dest.Native())
	arg2 = C.int(destX)
	arg3 = C.int(destY)
	arg4 = C.int(destWidth)
	arg5 = C.int(destHeight)
	arg6 = C.double(offsetX)
	arg7 = C.double(offsetY)
	arg8 = C.double(scaleX)
	arg9 = C.double(scaleY)
	arg10 = (C.GdkInterpType)(interpType)

	C.gdk_pixbuf_scale(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)
}

// ScaleSimple: create a new Pixbuf containing a copy of @src scaled to
// @dest_width x @dest_height. Leaves @src unaffected. @interp_type should
// be K_INTERP_NEAREST if you want maximum speed (but when scaling down
// K_INTERP_NEAREST is usually unusably ugly). The default @interp_type
// should be K_INTERP_BILINEAR which offers reasonable quality and speed.
//
// You can scale a sub-portion of @src by creating a sub-pixbuf pointing
// into @src; see gdk_pixbuf_new_subpixbuf().
//
// If @dest_width and @dest_height are equal to the @src width and height, a
// copy of @src is returned, avoiding any scaling.
//
// For more complicated scaling/alpha blending see gdk_pixbuf_scale() and
// gdk_pixbuf_composite().
func (src pixbuf) ScaleSimple(destWidth int, destHeight int, interpType InterpType) Pixbuf {
	var arg0 *C.GdkPixbuf
	var arg1 C.int
	var arg2 C.int
	var arg3 C.GdkInterpType

	arg0 = (*C.GdkPixbuf)(src.Native())
	arg1 = C.int(destWidth)
	arg2 = C.int(destHeight)
	arg3 = (C.GdkInterpType)(interpType)

	ret := C.gdk_pixbuf_scale_simple(arg0, arg1, arg2, arg3)

	var ret0 Pixbuf

	ret0 = WrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// SetOption attaches a key/value pair as an option to a Pixbuf. If @key
// already exists in the list of options attached to @pixbuf, the new value
// is ignored and false is returned.
func (pixbuf pixbuf) SetOption(key string, value string) bool {
	var arg0 *C.GdkPixbuf
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg0 = (*C.GdkPixbuf)(pixbuf.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gdk_pixbuf_set_option(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Unref removes a reference from a pixbuf.
func (pixbuf pixbuf) Unref() {
	var arg0 *C.GdkPixbuf

	arg0 = (*C.GdkPixbuf)(pixbuf.Native())

	C.gdk_pixbuf_unref(arg0)
}

// PixbufAnimation: an opaque struct representing an animation.
type PixbufAnimation interface {
	gextras.Objector

	// Height queries the height of the bounding box of a pixbuf animation.
	Height() int
	// Iter: get an iterator for displaying an animation. The iterator provides
	// the frames that should be displayed at a given time. It should be freed
	// after use with g_object_unref().
	//
	// @start_time would normally come from g_get_current_time(), and marks the
	// beginning of animation playback. After creating an iterator, you should
	// immediately display the pixbuf returned by
	// gdk_pixbuf_animation_iter_get_pixbuf(). Then, you should install a
	// timeout (with g_timeout_add()) or by some other mechanism ensure that
	// you'll update the image after gdk_pixbuf_animation_iter_get_delay_time()
	// milliseconds. Each time the image is updated, you should reinstall the
	// timeout with the new, possibly-changed delay time.
	//
	// As a shortcut, if @start_time is nil, the result of g_get_current_time()
	// will be used automatically.
	//
	// To update the image (i.e. possibly change the result of
	// gdk_pixbuf_animation_iter_get_pixbuf() to a new frame of the animation),
	// call gdk_pixbuf_animation_iter_advance().
	//
	// If you're using PixbufLoader, in addition to updating the image after the
	// delay time, you should also update it whenever you receive the
	// area_updated signal and
	// gdk_pixbuf_animation_iter_on_currently_loading_frame() returns true. In
	// this case, the frame currently being fed into the loader has received new
	// data, so needs to be refreshed. The delay time for a frame may also be
	// modified after an area_updated signal, for example if the delay time for
	// a frame is encoded in the data after the frame itself. So your timeout
	// should be reinstalled after any area_updated signal.
	//
	// A delay time of -1 is possible, indicating "infinite."
	Iter(startTime *glib.TimeVal) PixbufAnimationIter
	// StaticImage: if an animation is really just a plain image (has only one
	// frame), this function returns that image. If the animation is an
	// animation, this function returns a reasonable thing to display as a
	// static unanimated image, which might be the first frame, or something
	// more sophisticated. If an animation hasn't loaded any frames yet, this
	// function will return nil.
	StaticImage() Pixbuf
	// Width queries the width of the bounding box of a pixbuf animation.
	Width() int
	// IsStaticImage: if you load a file with
	// gdk_pixbuf_animation_new_from_file() and it turns out to be a plain,
	// unanimated image, then this function will return true. Use
	// gdk_pixbuf_animation_get_static_image() to retrieve the image.
	IsStaticImage() bool
	// Ref adds a reference to an animation.
	Ref() PixbufAnimation
	// Unref removes a reference from an animation.
	Unref()
}

type pixbufAnimation struct {
	*externglib.Object
}

// WrapPixbufAnimation wraps a GObject to the right type. It is
// primarily used internally.
func WrapPixbufAnimation(obj *externglib.Object) PixbufAnimation {
	return pixbufAnimation{*externglib.Object{obj}}
}

func marshalPixbufAnimation(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPixbufAnimation(obj), nil
}

// New_FromFile constructs a class PixbufAnimation.
func New_FromFile(filename string) PixbufAnimation {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gdk_pixbuf_animation_new_from_file(arg1)

	var ret0 PixbufAnimation

	ret0 = WrapPixbufAnimation(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// New_FromResource constructs a class PixbufAnimation.
func New_FromResource(resourcePath string) PixbufAnimation {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gdk_pixbuf_animation_new_from_resource(arg1)

	var ret0 PixbufAnimation

	ret0 = WrapPixbufAnimation(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// New_FromStream constructs a class PixbufAnimation.
func New_FromStream(stream gio.InputStream, cancellable gio.Cancellable) PixbufAnimation {
	var arg1 *C.GInputStream
	var arg2 *C.GCancellable

	arg1 = (*C.GInputStream)(stream.Native())
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.gdk_pixbuf_animation_new_from_stream(arg1, arg2)

	var ret0 PixbufAnimation

	ret0 = WrapPixbufAnimation(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// New_FromStreamFinish constructs a class PixbufAnimation.
func New_FromStreamFinish(asyncResult gio.AsyncResult) PixbufAnimation {
	var arg1 *C.GAsyncResult

	ret := C.gdk_pixbuf_animation_new_from_stream_finish(arg1)

	var ret0 PixbufAnimation

	ret0 = WrapPixbufAnimation(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Height queries the height of the bounding box of a pixbuf animation.
func (animation pixbufAnimation) Height() int {
	var arg0 *C.GdkPixbufAnimation

	arg0 = (*C.GdkPixbufAnimation)(animation.Native())

	ret := C.gdk_pixbuf_animation_get_height(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Iter: get an iterator for displaying an animation. The iterator provides
// the frames that should be displayed at a given time. It should be freed
// after use with g_object_unref().
//
// @start_time would normally come from g_get_current_time(), and marks the
// beginning of animation playback. After creating an iterator, you should
// immediately display the pixbuf returned by
// gdk_pixbuf_animation_iter_get_pixbuf(). Then, you should install a
// timeout (with g_timeout_add()) or by some other mechanism ensure that
// you'll update the image after gdk_pixbuf_animation_iter_get_delay_time()
// milliseconds. Each time the image is updated, you should reinstall the
// timeout with the new, possibly-changed delay time.
//
// As a shortcut, if @start_time is nil, the result of g_get_current_time()
// will be used automatically.
//
// To update the image (i.e. possibly change the result of
// gdk_pixbuf_animation_iter_get_pixbuf() to a new frame of the animation),
// call gdk_pixbuf_animation_iter_advance().
//
// If you're using PixbufLoader, in addition to updating the image after the
// delay time, you should also update it whenever you receive the
// area_updated signal and
// gdk_pixbuf_animation_iter_on_currently_loading_frame() returns true. In
// this case, the frame currently being fed into the loader has received new
// data, so needs to be refreshed. The delay time for a frame may also be
// modified after an area_updated signal, for example if the delay time for
// a frame is encoded in the data after the frame itself. So your timeout
// should be reinstalled after any area_updated signal.
//
// A delay time of -1 is possible, indicating "infinite."
func (animation pixbufAnimation) Iter(startTime *glib.TimeVal) PixbufAnimationIter {
	var arg0 *C.GdkPixbufAnimation
	var arg1 *C.GTimeVal

	arg0 = (*C.GdkPixbufAnimation)(animation.Native())
	arg1 = (*C.GTimeVal)(startTime.Native())

	ret := C.gdk_pixbuf_animation_get_iter(arg0, arg1)

	var ret0 PixbufAnimationIter

	ret0 = WrapPixbufAnimationIter(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// StaticImage: if an animation is really just a plain image (has only one
// frame), this function returns that image. If the animation is an
// animation, this function returns a reasonable thing to display as a
// static unanimated image, which might be the first frame, or something
// more sophisticated. If an animation hasn't loaded any frames yet, this
// function will return nil.
func (animation pixbufAnimation) StaticImage() Pixbuf {
	var arg0 *C.GdkPixbufAnimation

	arg0 = (*C.GdkPixbufAnimation)(animation.Native())

	ret := C.gdk_pixbuf_animation_get_static_image(arg0)

	var ret0 Pixbuf

	ret0 = WrapPixbuf(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Width queries the width of the bounding box of a pixbuf animation.
func (animation pixbufAnimation) Width() int {
	var arg0 *C.GdkPixbufAnimation

	arg0 = (*C.GdkPixbufAnimation)(animation.Native())

	ret := C.gdk_pixbuf_animation_get_width(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// IsStaticImage: if you load a file with
// gdk_pixbuf_animation_new_from_file() and it turns out to be a plain,
// unanimated image, then this function will return true. Use
// gdk_pixbuf_animation_get_static_image() to retrieve the image.
func (animation pixbufAnimation) IsStaticImage() bool {
	var arg0 *C.GdkPixbufAnimation

	arg0 = (*C.GdkPixbufAnimation)(animation.Native())

	ret := C.gdk_pixbuf_animation_is_static_image(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Ref adds a reference to an animation.
func (animation pixbufAnimation) Ref() PixbufAnimation {
	var arg0 *C.GdkPixbufAnimation

	arg0 = (*C.GdkPixbufAnimation)(animation.Native())

	ret := C.gdk_pixbuf_animation_ref(arg0)

	var ret0 PixbufAnimation

	ret0 = WrapPixbufAnimation(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Unref removes a reference from an animation.
func (animation pixbufAnimation) Unref() {
	var arg0 *C.GdkPixbufAnimation

	arg0 = (*C.GdkPixbufAnimation)(animation.Native())

	C.gdk_pixbuf_animation_unref(arg0)
}

// PixbufAnimationIter: an opaque struct representing an iterator which points
// to a certain position in an animation.
type PixbufAnimationIter interface {
	gextras.Objector

	// Advance: possibly advances an animation to a new frame. Chooses the frame
	// based on the start time passed to gdk_pixbuf_animation_get_iter().
	//
	// @current_time would normally come from g_get_current_time(), and must be
	// greater than or equal to the time passed to
	// gdk_pixbuf_animation_get_iter(), and must increase or remain unchanged
	// each time gdk_pixbuf_animation_iter_get_pixbuf() is called. That is, you
	// can't go backward in time; animations only play forward.
	//
	// As a shortcut, pass nil for the current time and g_get_current_time()
	// will be invoked on your behalf. So you only need to explicitly pass
	// @current_time if you're doing something odd like playing the animation at
	// double speed.
	//
	// If this function returns false, there's no need to update the animation
	// display, assuming the display had been rendered prior to advancing; if
	// true, you need to call gdk_pixbuf_animation_iter_get_pixbuf() and update
	// the display with the new pixbuf.
	Advance(currentTime *glib.TimeVal) bool
	// DelayTime gets the number of milliseconds the current pixbuf should be
	// displayed, or -1 if the current pixbuf should be displayed forever.
	// g_timeout_add() conveniently takes a timeout in milliseconds, so you can
	// use a timeout to schedule the next update.
	//
	// Note that some formats, like GIF, might clamp the timeout values in the
	// image file to avoid updates that are just too quick. The minimum timeout
	// for GIF images is currently 20 milliseconds.
	DelayTime() int
	// Pixbuf gets the current pixbuf which should be displayed; the pixbuf
	// might not be the same size as the animation itself
	// (gdk_pixbuf_animation_get_width(), gdk_pixbuf_animation_get_height()).
	// This pixbuf should be displayed for
	// gdk_pixbuf_animation_iter_get_delay_time() milliseconds. The caller of
	// this function does not own a reference to the returned pixbuf; the
	// returned pixbuf will become invalid when the iterator advances to the
	// next frame, which may happen anytime you call
	// gdk_pixbuf_animation_iter_advance(). Copy the pixbuf to keep it (don't
	// just add a reference), as it may get recycled as you advance the
	// iterator.
	Pixbuf() Pixbuf
	// OnCurrentlyLoadingFrame: used to determine how to respond to the
	// area_updated signal on PixbufLoader when loading an animation.
	// area_updated is emitted for an area of the frame currently streaming in
	// to the loader. So if you're on the currently loading frame, you need to
	// redraw the screen for the updated area.
	OnCurrentlyLoadingFrame() bool
}

type pixbufAnimationIter struct {
	*externglib.Object
}

// WrapPixbufAnimationIter wraps a GObject to the right type. It is
// primarily used internally.
func WrapPixbufAnimationIter(obj *externglib.Object) PixbufAnimationIter {
	return pixbufAnimationIter{*externglib.Object{obj}}
}

func marshalPixbufAnimationIter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPixbufAnimationIter(obj), nil
}

// Advance: possibly advances an animation to a new frame. Chooses the frame
// based on the start time passed to gdk_pixbuf_animation_get_iter().
//
// @current_time would normally come from g_get_current_time(), and must be
// greater than or equal to the time passed to
// gdk_pixbuf_animation_get_iter(), and must increase or remain unchanged
// each time gdk_pixbuf_animation_iter_get_pixbuf() is called. That is, you
// can't go backward in time; animations only play forward.
//
// As a shortcut, pass nil for the current time and g_get_current_time()
// will be invoked on your behalf. So you only need to explicitly pass
// @current_time if you're doing something odd like playing the animation at
// double speed.
//
// If this function returns false, there's no need to update the animation
// display, assuming the display had been rendered prior to advancing; if
// true, you need to call gdk_pixbuf_animation_iter_get_pixbuf() and update
// the display with the new pixbuf.
func (iter pixbufAnimationIter) Advance(currentTime *glib.TimeVal) bool {
	var arg0 *C.GdkPixbufAnimationIter
	var arg1 *C.GTimeVal

	arg0 = (*C.GdkPixbufAnimationIter)(iter.Native())
	arg1 = (*C.GTimeVal)(currentTime.Native())

	ret := C.gdk_pixbuf_animation_iter_advance(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// DelayTime gets the number of milliseconds the current pixbuf should be
// displayed, or -1 if the current pixbuf should be displayed forever.
// g_timeout_add() conveniently takes a timeout in milliseconds, so you can
// use a timeout to schedule the next update.
//
// Note that some formats, like GIF, might clamp the timeout values in the
// image file to avoid updates that are just too quick. The minimum timeout
// for GIF images is currently 20 milliseconds.
func (iter pixbufAnimationIter) DelayTime() int {
	var arg0 *C.GdkPixbufAnimationIter

	arg0 = (*C.GdkPixbufAnimationIter)(iter.Native())

	ret := C.gdk_pixbuf_animation_iter_get_delay_time(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Pixbuf gets the current pixbuf which should be displayed; the pixbuf
// might not be the same size as the animation itself
// (gdk_pixbuf_animation_get_width(), gdk_pixbuf_animation_get_height()).
// This pixbuf should be displayed for
// gdk_pixbuf_animation_iter_get_delay_time() milliseconds. The caller of
// this function does not own a reference to the returned pixbuf; the
// returned pixbuf will become invalid when the iterator advances to the
// next frame, which may happen anytime you call
// gdk_pixbuf_animation_iter_advance(). Copy the pixbuf to keep it (don't
// just add a reference), as it may get recycled as you advance the
// iterator.
func (iter pixbufAnimationIter) Pixbuf() Pixbuf {
	var arg0 *C.GdkPixbufAnimationIter

	arg0 = (*C.GdkPixbufAnimationIter)(iter.Native())

	ret := C.gdk_pixbuf_animation_iter_get_pixbuf(arg0)

	var ret0 Pixbuf

	ret0 = WrapPixbuf(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// OnCurrentlyLoadingFrame: used to determine how to respond to the
// area_updated signal on PixbufLoader when loading an animation.
// area_updated is emitted for an area of the frame currently streaming in
// to the loader. So if you're on the currently loading frame, you need to
// redraw the screen for the updated area.
func (iter pixbufAnimationIter) OnCurrentlyLoadingFrame() bool {
	var arg0 *C.GdkPixbufAnimationIter

	arg0 = (*C.GdkPixbufAnimationIter)(iter.Native())

	ret := C.gdk_pixbuf_animation_iter_on_currently_loading_frame(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// PixbufLoader: the GdkPixbufLoader struct contains only private fields.
type PixbufLoader interface {
	gextras.Objector

	// Close informs a pixbuf loader that no further writes with
	// gdk_pixbuf_loader_write() will occur, so that it can free its internal
	// loading structures. Also, tries to parse any data that hasn't yet been
	// parsed; if the remaining data is partial or corrupt, an error will be
	// returned. If false is returned, @error will be set to an error from the
	// K_PIXBUF_ERROR or FILE_ERROR domains. If you're just cancelling a load
	// rather than expecting it to be finished, passing nil for @error to ignore
	// it is reasonable.
	//
	// Remember that this does not unref the loader, so if you plan not to use
	// it anymore, please g_object_unref() it.
	Close() bool
	// Animation queries the PixbufAnimation that a pixbuf loader is currently
	// creating. In general it only makes sense to call this function after the
	// "area-prepared" signal has been emitted by the loader. If the loader
	// doesn't have enough bytes yet (hasn't emitted the "area-prepared" signal)
	// this function will return nil.
	Animation() PixbufAnimation
	// Format obtains the available information about the format of the
	// currently loading image file.
	Format() *PixbufFormat
	// Pixbuf queries the Pixbuf that a pixbuf loader is currently creating. In
	// general it only makes sense to call this function after the
	// "area-prepared" signal has been emitted by the loader; this means that
	// enough data has been read to know the size of the image that will be
	// allocated. If the loader has not received enough data via
	// gdk_pixbuf_loader_write(), then this function returns nil. The returned
	// pixbuf will be the same in all future calls to the loader, so simply
	// calling g_object_ref() should be sufficient to continue using it.
	// Additionally, if the loader is an animation, it will return the "static
	// image" of the animation (see gdk_pixbuf_animation_get_static_image()).
	Pixbuf() Pixbuf
	// SetSize causes the image to be scaled while it is loaded. The desired
	// image size can be determined relative to the original size of the image
	// by calling gdk_pixbuf_loader_set_size() from a signal handler for the
	// ::size-prepared signal.
	//
	// Attempts to set the desired image size are ignored after the emission of
	// the ::size-prepared signal.
	SetSize(width int, height int)
	// Write: this will cause a pixbuf loader to parse the next @count bytes of
	// an image. It will return true if the data was loaded successfully, and
	// false if an error occurred. In the latter case, the loader will be
	// closed, and will not accept further writes. If false is returned, @error
	// will be set to an error from the K_PIXBUF_ERROR or FILE_ERROR domains.
	Write(buf []byte) bool
	// WriteBytes: this will cause a pixbuf loader to parse a buffer inside a
	// #GBytes for an image. It will return true if the data was loaded
	// successfully, and false if an error occurred. In the latter case, the
	// loader will be closed, and will not accept further writes. If false is
	// returned, @error will be set to an error from the K_PIXBUF_ERROR or
	// FILE_ERROR domains.
	//
	// See also: gdk_pixbuf_loader_write()
	WriteBytes(buffer *glib.Bytes) bool
}

type pixbufLoader struct {
	*externglib.Object
}

// WrapPixbufLoader wraps a GObject to the right type. It is
// primarily used internally.
func WrapPixbufLoader(obj *externglib.Object) PixbufLoader {
	return pixbufLoader{*externglib.Object{obj}}
}

func marshalPixbufLoader(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPixbufLoader(obj), nil
}

// New_ constructs a class PixbufLoader.
func New_() PixbufLoader {

	ret := C.gdk_pixbuf_loader_new()

	var ret0 PixbufLoader

	ret0 = WrapPixbufLoader(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// New_WithMIMEType constructs a class PixbufLoader.
func New_WithMIMEType(mimeType string) PixbufLoader {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(mimeType))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gdk_pixbuf_loader_new_with_mime_type(arg1)

	var ret0 PixbufLoader

	ret0 = WrapPixbufLoader(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// New_WithType constructs a class PixbufLoader.
func New_WithType(imageType string) PixbufLoader {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(imageType))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gdk_pixbuf_loader_new_with_type(arg1)

	var ret0 PixbufLoader

	ret0 = WrapPixbufLoader(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Close informs a pixbuf loader that no further writes with
// gdk_pixbuf_loader_write() will occur, so that it can free its internal
// loading structures. Also, tries to parse any data that hasn't yet been
// parsed; if the remaining data is partial or corrupt, an error will be
// returned. If false is returned, @error will be set to an error from the
// K_PIXBUF_ERROR or FILE_ERROR domains. If you're just cancelling a load
// rather than expecting it to be finished, passing nil for @error to ignore
// it is reasonable.
//
// Remember that this does not unref the loader, so if you plan not to use
// it anymore, please g_object_unref() it.
func (loader pixbufLoader) Close() bool {
	var arg0 *C.GdkPixbufLoader

	arg0 = (*C.GdkPixbufLoader)(loader.Native())

	ret := C.gdk_pixbuf_loader_close(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Animation queries the PixbufAnimation that a pixbuf loader is currently
// creating. In general it only makes sense to call this function after the
// "area-prepared" signal has been emitted by the loader. If the loader
// doesn't have enough bytes yet (hasn't emitted the "area-prepared" signal)
// this function will return nil.
func (loader pixbufLoader) Animation() PixbufAnimation {
	var arg0 *C.GdkPixbufLoader

	arg0 = (*C.GdkPixbufLoader)(loader.Native())

	ret := C.gdk_pixbuf_loader_get_animation(arg0)

	var ret0 PixbufAnimation

	ret0 = WrapPixbufAnimation(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Format obtains the available information about the format of the
// currently loading image file.
func (loader pixbufLoader) Format() *PixbufFormat {
	var arg0 *C.GdkPixbufLoader

	arg0 = (*C.GdkPixbufLoader)(loader.Native())

	ret := C.gdk_pixbuf_loader_get_format(arg0)

	var ret0 *PixbufFormat

	ret0 = WrapPixbufFormat(ret)

	return ret0
}

// Pixbuf queries the Pixbuf that a pixbuf loader is currently creating. In
// general it only makes sense to call this function after the
// "area-prepared" signal has been emitted by the loader; this means that
// enough data has been read to know the size of the image that will be
// allocated. If the loader has not received enough data via
// gdk_pixbuf_loader_write(), then this function returns nil. The returned
// pixbuf will be the same in all future calls to the loader, so simply
// calling g_object_ref() should be sufficient to continue using it.
// Additionally, if the loader is an animation, it will return the "static
// image" of the animation (see gdk_pixbuf_animation_get_static_image()).
func (loader pixbufLoader) Pixbuf() Pixbuf {
	var arg0 *C.GdkPixbufLoader

	arg0 = (*C.GdkPixbufLoader)(loader.Native())

	ret := C.gdk_pixbuf_loader_get_pixbuf(arg0)

	var ret0 Pixbuf

	ret0 = WrapPixbuf(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// SetSize causes the image to be scaled while it is loaded. The desired
// image size can be determined relative to the original size of the image
// by calling gdk_pixbuf_loader_set_size() from a signal handler for the
// ::size-prepared signal.
//
// Attempts to set the desired image size are ignored after the emission of
// the ::size-prepared signal.
func (loader pixbufLoader) SetSize(width int, height int) {
	var arg0 *C.GdkPixbufLoader
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GdkPixbufLoader)(loader.Native())
	arg1 = C.int(width)
	arg2 = C.int(height)

	C.gdk_pixbuf_loader_set_size(arg0, arg1, arg2)
}

// Write: this will cause a pixbuf loader to parse the next @count bytes of
// an image. It will return true if the data was loaded successfully, and
// false if an error occurred. In the latter case, the loader will be
// closed, and will not accept further writes. If false is returned, @error
// will be set to an error from the K_PIXBUF_ERROR or FILE_ERROR domains.
func (loader pixbufLoader) Write(buf []byte) bool {
	var arg0 *C.GdkPixbufLoader
	var arg1 *C.guchar
	var arg2 C.gsize

	arg0 = (*C.GdkPixbufLoader)(loader.Native())
	{
		arg1 = (*C.guchar)(&buf[0])
		arg2 = len(buf)
		defer runtime.KeepAlive(buf)
	}

	ret := C.gdk_pixbuf_loader_write(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// WriteBytes: this will cause a pixbuf loader to parse a buffer inside a
// #GBytes for an image. It will return true if the data was loaded
// successfully, and false if an error occurred. In the latter case, the
// loader will be closed, and will not accept further writes. If false is
// returned, @error will be set to an error from the K_PIXBUF_ERROR or
// FILE_ERROR domains.
//
// See also: gdk_pixbuf_loader_write()
func (loader pixbufLoader) WriteBytes(buffer *glib.Bytes) bool {
	var arg0 *C.GdkPixbufLoader
	var arg1 *C.GBytes

	arg0 = (*C.GdkPixbufLoader)(loader.Native())
	arg1 = (*C.GBytes)(buffer.Native())

	ret := C.gdk_pixbuf_loader_write_bytes(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// PixbufSimpleAnim: an opaque struct representing a simple animation.
type PixbufSimpleAnim interface {
	PixbufAnimation

	// AddFrame adds a new frame to @animation. The @pixbuf must have the
	// dimensions specified when the animation was constructed.
	AddFrame(pixbuf Pixbuf)
	// Loop gets whether @animation should loop indefinitely when it reaches the
	// end.
	Loop() bool
	// SetLoop sets whether @animation should loop indefinitely when it reaches
	// the end.
	SetLoop(loop bool)
}

type pixbufSimpleAnim struct {
	pixbufAnimation
}

// WrapPixbufSimpleAnim wraps a GObject to the right type. It is
// primarily used internally.
func WrapPixbufSimpleAnim(obj *externglib.Object) PixbufSimpleAnim {
	return pixbufSimpleAnim{pixbufAnimation{*externglib.Object{obj}}}
}

func marshalPixbufSimpleAnim(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPixbufSimpleAnim(obj), nil
}

// New_ constructs a class PixbufSimpleAnim.
func New_(width int, height int, rate float32) PixbufSimpleAnim {
	var arg1 C.gint
	var arg2 C.gint
	var arg3 C.gfloat

	arg1 = C.gint(width)
	arg2 = C.gint(height)
	arg3 = C.gfloat(rate)

	ret := C.gdk_pixbuf_simple_anim_new(arg1, arg2, arg3)

	var ret0 PixbufSimpleAnim

	ret0 = WrapPixbufSimpleAnim(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// AddFrame adds a new frame to @animation. The @pixbuf must have the
// dimensions specified when the animation was constructed.
func (animation pixbufSimpleAnim) AddFrame(pixbuf Pixbuf) {
	var arg0 *C.GdkPixbufSimpleAnim
	var arg1 *C.GdkPixbuf

	arg0 = (*C.GdkPixbufSimpleAnim)(animation.Native())
	arg1 = (*C.GdkPixbuf)(pixbuf.Native())

	C.gdk_pixbuf_simple_anim_add_frame(arg0, arg1)
}

// Loop gets whether @animation should loop indefinitely when it reaches the
// end.
func (animation pixbufSimpleAnim) Loop() bool {
	var arg0 *C.GdkPixbufSimpleAnim

	arg0 = (*C.GdkPixbufSimpleAnim)(animation.Native())

	ret := C.gdk_pixbuf_simple_anim_get_loop(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetLoop sets whether @animation should loop indefinitely when it reaches
// the end.
func (animation pixbufSimpleAnim) SetLoop(loop bool) {
	var arg0 *C.GdkPixbufSimpleAnim
	var arg1 C.gboolean

	arg0 = (*C.GdkPixbufSimpleAnim)(animation.Native())
	arg1 = gextras.Cbool(loop)

	C.gdk_pixbuf_simple_anim_set_loop(arg0, arg1)
}

type PixbufSimpleAnimIter interface {
	PixbufAnimationIter
}

type pixbufSimpleAnimIter struct {
	pixbufAnimationIter
}

// WrapPixbufSimpleAnimIter wraps a GObject to the right type. It is
// primarily used internally.
func WrapPixbufSimpleAnimIter(obj *externglib.Object) PixbufSimpleAnimIter {
	return pixbufSimpleAnimIter{pixbufAnimationIter{*externglib.Object{obj}}}
}

func marshalPixbufSimpleAnimIter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPixbufSimpleAnimIter(obj), nil
}
