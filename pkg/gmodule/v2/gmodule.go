// Code generated by girgen. DO NOT EDIT.

package gmodule

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
)

// #cgo pkg-config: gmodule-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <gmodule.h>
//
import "C"

// ModuleFlags flags passed to g_module_open(). Note that these flags are not
// supported on all platforms.
type ModuleFlags int

const (
	// ModuleFlagsLazy specifies that symbols are only resolved when needed. The
	// default action is to bind all symbols when the module is loaded.
	ModuleFlagsLazy ModuleFlags = 0b1
	// ModuleFlagsLocal specifies that symbols in the module should not be added
	// to the global name space. The default action on most platforms is to
	// place symbols in the module in the global name space, which may cause
	// conflicts with existing symbols.
	ModuleFlagsLocal ModuleFlags = 0b10
	// ModuleFlagsMask: mask for all flags.
	ModuleFlagsMask ModuleFlags = 0b11
)

// ModuleBuildPath: a portable way to build the filename of a module. The
// platform-specific prefix and suffix are added to the filename, if needed, and
// the result is added to the directory, using the correct separator character.
//
// The directory should specify the directory where the module can be found. It
// can be nil or an empty string to indicate that the module is in a standard
// platform-specific directory, though this is not recommended since the wrong
// module may be found.
//
// For example, calling g_module_build_path() on a Linux system with a
// @directory of `/lib` and a @module_name of "mylibrary" will return
// `/lib/libmylibrary.so`. On a Windows system, using `\Windows` as the
// directory it will return `\Windows\mylibrary.dll`.
func ModuleBuildPath(directory string, moduleName string) string {
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg1 = (*C.gchar)(C.CString(directory))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(moduleName))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_module_build_path(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// ModuleError gets a string describing the last module error.
func ModuleError() string {

	ret := C.g_module_error()

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// ModuleSupported checks if modules are supported on the current platform.
func ModuleSupported() bool {

	ret := C.g_module_supported()

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Module: the #GModule struct is an opaque data structure to represent a
// [dynamically-loaded module][glib-Dynamic-Loading-of-Modules]. It should only
// be accessed via the following functions.
type Module struct {
	native C.GModule
}

// WrapModule wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapModule(ptr unsafe.Pointer) *Module {
	if ptr == nil {
		return nil
	}

	return (*Module)(ptr)
}

func marshalModule(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapModule(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (m *Module) Native() unsafe.Pointer {
	return unsafe.Pointer(&m.native)
}

// Close closes a module.
func (module *Module) Close() bool {
	var arg0 *C.GModule

	arg0 = (*C.GModule)(module.Native())

	ret := C.g_module_close(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// MakeResident ensures that a module will never be unloaded. Any future
// g_module_close() calls on the module will be ignored.
func (module *Module) MakeResident() {
	var arg0 *C.GModule

	arg0 = (*C.GModule)(module.Native())

	C.g_module_make_resident(arg0)
}

// Name returns the filename that the module was opened with.
//
// If @module refers to the application itself, "main" is returned.
func (module *Module) Name() string {
	var arg0 *C.GModule

	arg0 = (*C.GModule)(module.Native())

	ret := C.g_module_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Symbol gets a symbol pointer from a module, such as one exported by
// MODULE_EXPORT. Note that a valid symbol can be nil.
func (module *Module) Symbol(symbolName string) (symbol interface{}, ok bool) {
	var arg0 *C.GModule
	var arg1 *C.gchar
	var arg2 *C.gpointer // out

	arg0 = (*C.GModule)(module.Native())
	arg1 = (*C.gchar)(C.CString(symbolName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_module_symbol(arg0, arg1, &arg2)

	var ret0 interface{}
	var ret1 bool

	ret0 = box.Get(uintptr(arg2)).(interface{})

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}
