// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/core/gerror"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <glib.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_io_condition_get_type()), F: marshalIOCondition},
		{T: externglib.Type(C.g_checksum_get_type()), F: marshalChecksum},
		{T: externglib.Type(C.g_hash_table_get_type()), F: marshalHashTable},
		{T: externglib.Type(C.g_key_file_get_type()), F: marshalKeyFile},
		{T: externglib.Type(C.g_main_context_get_type()), F: marshalMainContext},
		{T: externglib.Type(C.g_main_loop_get_type()), F: marshalMainLoop},
		{T: externglib.Type(C.g_mapped_file_get_type()), F: marshalMappedFile},
		{T: externglib.Type(C.g_markup_parse_context_get_type()), F: marshalMarkupParseContext},
		{T: externglib.Type(C.g_match_info_get_type()), F: marshalMatchInfo},
		{T: externglib.Type(C.g_option_group_get_type()), F: marshalOptionGroup},
		{T: externglib.Type(C.g_pollfd_get_type()), F: marshalPollFD},
		{T: externglib.Type(C.g_regex_get_type()), F: marshalRegex},
		{T: externglib.Type(C.g_time_zone_get_type()), F: marshalTimeZone},
		{T: externglib.Type(C.g_tree_get_type()), F: marshalTree},
		{T: externglib.Type(C.g_uri_get_type()), F: marshalURI},
		{T: externglib.Type(C.g_variant_builder_get_type()), F: marshalVariantBuilder},
		{T: externglib.Type(C.g_variant_dict_get_type()), F: marshalVariantDict},
		{T: externglib.Type(C.g_variant_type_get_gtype()), F: marshalVariantType},
	})
}

// Pid: a type which is used to hold a process identification.
//
// On UNIX, processes are identified by a process id (an integer), while Windows
// uses process handles (which are pointers).
//
// GPid is used in GLib only for descendant processes spawned with the g_spawn
// functions.
type Pid = int

// Quark: a GQuark is a non-zero integer which uniquely identifies a particular
// string. A GQuark value of zero is associated to nil.
type Quark = uint32

type Type = uint

// BookmarkFileError: error codes returned by bookmark file parsing.
type BookmarkFileError int

const (
	// BookmarkFileErrorInvalidURI: URI was ill-formed
	BookmarkFileErrorInvalidURI BookmarkFileError = 0
	// BookmarkFileErrorInvalidValue: a requested field was not found
	BookmarkFileErrorInvalidValue BookmarkFileError = 1
	// BookmarkFileErrorAppNotRegistered: a requested application did not
	// register a bookmark
	BookmarkFileErrorAppNotRegistered BookmarkFileError = 2
	// BookmarkFileErrorURINotFound: a requested URI was not found
	BookmarkFileErrorURINotFound BookmarkFileError = 3
	// BookmarkFileErrorRead: document was ill formed
	BookmarkFileErrorRead BookmarkFileError = 4
	// BookmarkFileErrorUnknownEncoding: the text being parsed was in an unknown
	// encoding
	BookmarkFileErrorUnknownEncoding BookmarkFileError = 5
	// BookmarkFileErrorWrite: an error occurred while writing
	BookmarkFileErrorWrite BookmarkFileError = 6
	// BookmarkFileErrorFileNotFound: requested file was not found
	BookmarkFileErrorFileNotFound BookmarkFileError = 7
)

// ChecksumType: the hashing algorithm to be used by #GChecksum when performing
// the digest of some data.
//
// Note that the Type enumeration may be extended at a later date to include new
// hashing algorithm types.
type ChecksumType int

const (
	// ChecksumTypeMD5: use the MD5 hashing algorithm
	ChecksumTypeMD5 ChecksumType = 0
	// ChecksumTypeSHA1: use the SHA-1 hashing algorithm
	ChecksumTypeSHA1 ChecksumType = 1
	// ChecksumTypeSHA256: use the SHA-256 hashing algorithm
	ChecksumTypeSHA256 ChecksumType = 2
	// ChecksumTypeSHA512: use the SHA-512 hashing algorithm (Since: 2.36)
	ChecksumTypeSHA512 ChecksumType = 3
	// ChecksumTypeSHA384: use the SHA-384 hashing algorithm (Since: 2.51)
	ChecksumTypeSHA384 ChecksumType = 4
)

// ConvertError: error codes returned by character set conversion routines.
type ConvertError int

const (
	// ConvertErrorNoConversion: conversion between the requested character sets
	// is not supported.
	ConvertErrorNoConversion ConvertError = 0
	// ConvertErrorIllegalSequence: invalid byte sequence in conversion input;
	// or the character sequence could not be represented in the target
	// character set.
	ConvertErrorIllegalSequence ConvertError = 1
	// ConvertErrorFailed: conversion failed for some reason.
	ConvertErrorFailed ConvertError = 2
	// ConvertErrorPartialInput: partial character sequence at end of input.
	ConvertErrorPartialInput ConvertError = 3
	// ConvertErrorBadURI: URI is invalid.
	ConvertErrorBadURI ConvertError = 4
	// ConvertErrorNotAbsolutePath: pathname is not an absolute path.
	ConvertErrorNotAbsolutePath ConvertError = 5
	// ConvertErrorNoMemory: no memory available. Since: 2.40
	ConvertErrorNoMemory ConvertError = 6
	// ConvertErrorEmbeddedNUL: an embedded NUL character is present in
	// conversion output where a NUL-terminated string is expected. Since: 2.56
	ConvertErrorEmbeddedNUL ConvertError = 7
)

// ErrorType: the possible errors, used in the @v_error field of Value, when the
// token is a G_TOKEN_ERROR.
type ErrorType int

const (
	// ErrorTypeUnknown: unknown error
	ErrorTypeUnknown ErrorType = 0
	// ErrorTypeUnexpEOF: unexpected end of file
	ErrorTypeUnexpEOF ErrorType = 1
	// ErrorTypeUnexpEOFInString: unterminated string constant
	ErrorTypeUnexpEOFInString ErrorType = 2
	// ErrorTypeUnexpEOFInComment: unterminated comment
	ErrorTypeUnexpEOFInComment ErrorType = 3
	// ErrorTypeNonDigitInConst: non-digit character in a number
	ErrorTypeNonDigitInConst ErrorType = 4
	// ErrorTypeDigitRadix: digit beyond radix in a number
	ErrorTypeDigitRadix ErrorType = 5
	// ErrorTypeFloatRadix: non-decimal floating point number
	ErrorTypeFloatRadix ErrorType = 6
	// ErrorTypeFloatMalformed: malformed floating point number
	ErrorTypeFloatMalformed ErrorType = 7
)

// FileError values corresponding to @errno codes returned from file operations
// on UNIX. Unlike @errno codes, GFileError values are available on all systems,
// even Windows. The exact meaning of each code depends on what sort of file
// operation you were performing; the UNIX documentation gives more details. The
// following error code descriptions come from the GNU C Library manual, and are
// under the copyright of that manual.
//
// It's not very portable to make detailed assumptions about exactly which
// errors will be returned from a given operation. Some errors don't occur on
// some systems, etc., sometimes there are subtle differences in when a system
// will report a given error, etc.
type FileError int

const (
	// FileErrorExist: operation not permitted; only the owner of the file (or
	// other resource) or processes with special privileges can perform the
	// operation.
	FileErrorExist FileError = 0
	// FileErrorIsdir: file is a directory; you cannot open a directory for
	// writing, or create or remove hard links to it.
	FileErrorIsdir FileError = 1
	// FileErrorAcces: permission denied; the file permissions do not allow the
	// attempted operation.
	FileErrorAcces FileError = 2
	// FileErrorNametoolong: filename too long.
	FileErrorNametoolong FileError = 3
	// FileErrorNoent: no such file or directory. This is a "file doesn't exist"
	// error for ordinary files that are referenced in contexts where they are
	// expected to already exist.
	FileErrorNoent FileError = 4
	// FileErrorNotdir: a file that isn't a directory was specified when a
	// directory is required.
	FileErrorNotdir FileError = 5
	// FileErrorNxio: no such device or address. The system tried to use the
	// device represented by a file you specified, and it couldn't find the
	// device. This can mean that the device file was installed incorrectly, or
	// that the physical device is missing or not correctly attached to the
	// computer.
	FileErrorNxio FileError = 6
	// FileErrorNodev: the underlying file system of the specified file does not
	// support memory mapping.
	FileErrorNodev FileError = 7
	// FileErrorRofs: the directory containing the new link can't be modified
	// because it's on a read-only file system.
	FileErrorRofs FileError = 8
	// FileErrorTxtbsy: text file busy.
	FileErrorTxtbsy FileError = 9
	// FileErrorFault: you passed in a pointer to bad memory. (GLib won't
	// reliably return this, don't pass in pointers to bad memory.)
	FileErrorFault FileError = 10
	// FileErrorLoop: too many levels of symbolic links were encountered in
	// looking up a file name. This often indicates a cycle of symbolic links.
	FileErrorLoop FileError = 11
	// FileErrorNospc: no space left on device; write operation on a file failed
	// because the disk is full.
	FileErrorNospc FileError = 12
	// FileErrorNOMEM: no memory available. The system cannot allocate more
	// virtual memory because its capacity is full.
	FileErrorNOMEM FileError = 13
	// FileErrorMfile: the current process has too many files open and can't
	// open any more. Duplicate descriptors do count toward this limit.
	FileErrorMfile FileError = 14
	// FileErrorNfile: there are too many distinct file openings in the entire
	// system.
	FileErrorNfile FileError = 15
	// FileErrorBadf: bad file descriptor; for example, I/O on a descriptor that
	// has been closed or reading from a descriptor open only for writing (or
	// vice versa).
	FileErrorBadf FileError = 16
	// FileErrorInval: invalid argument. This is used to indicate various kinds
	// of problems with passing the wrong argument to a library function.
	FileErrorInval FileError = 17
	// FileErrorPipe: broken pipe; there is no process reading from the other
	// end of a pipe. Every library function that returns this error code also
	// generates a 'SIGPIPE' signal; this signal terminates the program if not
	// handled or blocked. Thus, your program will never actually see this code
	// unless it has handled or blocked 'SIGPIPE'.
	FileErrorPipe FileError = 18
	// FileErrorAgain: resource temporarily unavailable; the call might work if
	// you try again later.
	FileErrorAgain FileError = 19
	// FileErrorIntr: interrupted function call; an asynchronous signal occurred
	// and prevented completion of the call. When this happens, you should try
	// the call again.
	FileErrorIntr FileError = 20
	// FileErrorIO: input/output error; usually used for physical read or write
	// errors. i.e. the disk or other physical device hardware is returning
	// errors.
	FileErrorIO FileError = 21
	// FileErrorPerm: operation not permitted; only the owner of the file (or
	// other resource) or processes with special privileges can perform the
	// operation.
	FileErrorPerm FileError = 22
	// FileErrorNosys: function not implemented; this indicates that the system
	// is missing some functionality.
	FileErrorNosys FileError = 23
	// FileErrorFailed does not correspond to a UNIX error code; this is the
	// standard "failed for unspecified reason" error code present in all
	// #GError error code enumerations. Returned if no specific code applies.
	FileErrorFailed FileError = 24
)

// IOChannelError: error codes returned by OChannel operations.
type IOChannelError int

const (
	// IOChannelErrorFbig: file too large.
	IOChannelErrorFbig IOChannelError = 0
	// IOChannelErrorInval: invalid argument.
	IOChannelErrorInval IOChannelError = 1
	// IOChannelErrorIO: IO error.
	IOChannelErrorIO IOChannelError = 2
	// IOChannelErrorIsdir: file is a directory.
	IOChannelErrorIsdir IOChannelError = 3
	// IOChannelErrorNospc: no space left on device.
	IOChannelErrorNospc IOChannelError = 4
	// IOChannelErrorNxio: no such device or address.
	IOChannelErrorNxio IOChannelError = 5
	// IOChannelErrorOverflow: value too large for defined datatype.
	IOChannelErrorOverflow IOChannelError = 6
	// IOChannelErrorPipe: broken pipe.
	IOChannelErrorPipe IOChannelError = 7
	// IOChannelErrorFailed: some other error.
	IOChannelErrorFailed IOChannelError = 8
)

// IOError is only used by the deprecated functions g_io_channel_read(),
// g_io_channel_write(), and g_io_channel_seek().
type IOError int

const (
	// IOErrorNone: no error
	IOErrorNone IOError = 0
	// IOErrorAgain: an EAGAIN error occurred
	IOErrorAgain IOError = 1
	// IOErrorInval: an EINVAL error occurred
	IOErrorInval IOError = 2
	// IOErrorUnknown: another error occurred
	IOErrorUnknown IOError = 3
)

// IOStatus statuses returned by most of the OFuncs functions.
type IOStatus int

const (
	// IOStatusError: an error occurred.
	IOStatusError IOStatus = 0
	// IOStatusNormal: success.
	IOStatusNormal IOStatus = 1
	// IOStatusEOF: end of file.
	IOStatusEOF IOStatus = 2
	// IOStatusAgain: resource temporarily unavailable.
	IOStatusAgain IOStatus = 3
)

// KeyFileError: error codes returned by key file parsing.
type KeyFileError int

const (
	// KeyFileErrorUnknownEncoding: the text being parsed was in an unknown
	// encoding
	KeyFileErrorUnknownEncoding KeyFileError = 0
	// KeyFileErrorParse: document was ill-formed
	KeyFileErrorParse KeyFileError = 1
	// KeyFileErrorNotFound: the file was not found
	KeyFileErrorNotFound KeyFileError = 2
	// KeyFileErrorKeyNotFound: a requested key was not found
	KeyFileErrorKeyNotFound KeyFileError = 3
	// KeyFileErrorGroupNotFound: a requested group was not found
	KeyFileErrorGroupNotFound KeyFileError = 4
	// KeyFileErrorInvalidValue: a value could not be parsed
	KeyFileErrorInvalidValue KeyFileError = 5
)

// LogWriterOutput: return values from WriterFuncs to indicate whether the given
// log entry was successfully handled by the writer, or whether there was an
// error in handling it (and hence a fallback writer should be used).
//
// If a WriterFunc ignores a log entry, it should return G_LOG_WRITER_HANDLED.
type LogWriterOutput int

const (
	// LogWriterOutputHandled: log writer has handled the log entry.
	LogWriterOutputHandled LogWriterOutput = 1
	// LogWriterOutputUnhandled: log writer could not handle the log entry.
	LogWriterOutputUnhandled LogWriterOutput = 0
)

// MarkupError: error codes returned by markup parsing.
type MarkupError int

const (
	// MarkupErrorBadUTF8: text being parsed was not valid UTF-8
	MarkupErrorBadUTF8 MarkupError = 0
	// MarkupErrorEmpty: document contained nothing, or only whitespace
	MarkupErrorEmpty MarkupError = 1
	// MarkupErrorParse: document was ill-formed
	MarkupErrorParse MarkupError = 2
	// MarkupErrorUnknownElement: error should be set by Parser functions;
	// element wasn't known
	MarkupErrorUnknownElement MarkupError = 3
	// MarkupErrorUnknownAttribute: error should be set by Parser functions;
	// attribute wasn't known
	MarkupErrorUnknownAttribute MarkupError = 4
	// MarkupErrorInvalidContent: error should be set by Parser functions;
	// content was invalid
	MarkupErrorInvalidContent MarkupError = 5
	// MarkupErrorMissingAttribute: error should be set by Parser functions; a
	// required attribute was missing
	MarkupErrorMissingAttribute MarkupError = 6
)

// NormalizeMode defines how a Unicode string is transformed in a canonical
// form, standardizing such issues as whether a character with an accent is
// represented as a base character and combining accent or as a single
// precomposed character. Unicode strings should generally be normalized before
// comparing them.
type NormalizeMode int

const (
	// NormalizeModeDefault: standardize differences that do not affect the text
	// content, such as the above-mentioned accent representation
	NormalizeModeDefault NormalizeMode = 0
	// NormalizeModeNFD: another name for G_NORMALIZE_DEFAULT
	NormalizeModeNFD NormalizeMode = 0
	// NormalizeModeDefaultCompose: like G_NORMALIZE_DEFAULT, but with composed
	// forms rather than a maximally decomposed form
	NormalizeModeDefaultCompose NormalizeMode = 1
	// NormalizeModeNFC: another name for G_NORMALIZE_DEFAULT_COMPOSE
	NormalizeModeNFC NormalizeMode = 1
	// NormalizeModeAll: beyond G_NORMALIZE_DEFAULT also standardize the
	// "compatibility" characters in Unicode, such as SUPERSCRIPT THREE to the
	// standard forms (in this case DIGIT THREE). Formatting information may be
	// lost but for most text operations such characters should be considered
	// the same
	NormalizeModeAll NormalizeMode = 2
	// NormalizeModeNFKD: another name for G_NORMALIZE_ALL
	NormalizeModeNFKD NormalizeMode = 2
	// NormalizeModeAllCompose: like G_NORMALIZE_ALL, but with composed forms
	// rather than a maximally decomposed form
	NormalizeModeAllCompose NormalizeMode = 3
	// NormalizeModeNFKC: another name for G_NORMALIZE_ALL_COMPOSE
	NormalizeModeNFKC NormalizeMode = 3
)

// OptionArg: the Arg enum values determine which type of extra argument the
// options expect to find. If an option expects an extra argument, it can be
// specified in several ways; with a short option: `-x arg`, with a long option:
// `--name arg` or combined in a single argument: `--name=arg`.
type OptionArg int

const (
	// OptionArgNone: no extra argument. This is useful for simple flags.
	OptionArgNone OptionArg = 0
	// OptionArgString: the option takes a UTF-8 string argument.
	OptionArgString OptionArg = 1
	// OptionArgInt: the option takes an integer argument.
	OptionArgInt OptionArg = 2
	// OptionArgCallback: the option provides a callback (of type ArgFunc) to
	// parse the extra argument.
	OptionArgCallback OptionArg = 3
	// OptionArgFilename: the option takes a filename as argument, which will be
	// in the GLib filename encoding rather than UTF-8.
	OptionArgFilename OptionArg = 4
	// OptionArgStringArray: the option takes a string argument, multiple uses
	// of the option are collected into an array of strings.
	OptionArgStringArray OptionArg = 5
	// OptionArgFilenameArray: the option takes a filename as argument, multiple
	// uses of the option are collected into an array of strings.
	OptionArgFilenameArray OptionArg = 6
	// OptionArgDouble: the option takes a double argument. The argument can be
	// formatted either for the user's locale or for the "C" locale. Since 2.12
	OptionArgDouble OptionArg = 7
	// OptionArgInt64: the option takes a 64-bit integer. Like G_OPTION_ARG_INT
	// but for larger numbers. The number can be in decimal base, or in
	// hexadecimal (when prefixed with `0x`, for example, `0xffffffff`). Since
	// 2.12
	OptionArgInt64 OptionArg = 8
)

// OptionError: error codes returned by option parsing.
type OptionError int

const (
	// OptionErrorUnknownOption: an option was not known to the parser. This
	// error will only be reported, if the parser hasn't been instructed to
	// ignore unknown options, see
	// g_option_context_set_ignore_unknown_options().
	OptionErrorUnknownOption OptionError = 0
	// OptionErrorBadValue: a value couldn't be parsed.
	OptionErrorBadValue OptionError = 1
	// OptionErrorFailed: a ArgFunc callback failed.
	OptionErrorFailed OptionError = 2
)

// RegexError: error codes returned by regular expressions functions.
type RegexError int

const (
	// RegexErrorCompile: compilation of the regular expression failed.
	RegexErrorCompile RegexError = 0
	// RegexErrorOptimize: optimization of the regular expression failed.
	RegexErrorOptimize RegexError = 1
	// RegexErrorReplace: replacement failed due to an ill-formed replacement
	// string.
	RegexErrorReplace RegexError = 2
	// RegexErrorMatch: the match process failed.
	RegexErrorMatch RegexError = 3
	// RegexErrorInternal: internal error of the regular expression engine.
	// Since 2.16
	RegexErrorInternal RegexError = 4
	// RegexErrorStrayBackslash: "\\" at end of pattern. Since 2.16
	RegexErrorStrayBackslash RegexError = 101
	// RegexErrorMissingControlChar: "\\c" at end of pattern. Since 2.16
	RegexErrorMissingControlChar RegexError = 102
	// RegexErrorUnrecognizedEscape: unrecognized character follows "\\". Since
	// 2.16
	RegexErrorUnrecognizedEscape RegexError = 103
	// RegexErrorQuantifiersOutOfOrder numbers out of order in "{}" quantifier.
	// Since 2.16
	RegexErrorQuantifiersOutOfOrder RegexError = 104
	// RegexErrorQuantifierTooBig: number too big in "{}" quantifier. Since 2.16
	RegexErrorQuantifierTooBig RegexError = 105
	// RegexErrorUnterminatedCharacterClass: missing terminating "]" for
	// character class. Since 2.16
	RegexErrorUnterminatedCharacterClass RegexError = 106
	// RegexErrorInvalidEscapeInCharacterClass: invalid escape sequence in
	// character class. Since 2.16
	RegexErrorInvalidEscapeInCharacterClass RegexError = 107
	// RegexErrorRangeOutOfOrder: range out of order in character class. Since
	// 2.16
	RegexErrorRangeOutOfOrder RegexError = 108
	// RegexErrorNothingToRepeat: nothing to repeat. Since 2.16
	RegexErrorNothingToRepeat RegexError = 109
	// RegexErrorUnrecognizedCharacter: unrecognized character after "(?", "(?<"
	// or "(?P". Since 2.16
	RegexErrorUnrecognizedCharacter RegexError = 112
	// RegexErrorPosixNamedClassOutsideClass: POSIX named classes are supported
	// only within a class. Since 2.16
	RegexErrorPosixNamedClassOutsideClass RegexError = 113
	// RegexErrorUnmatchedParenthesis: missing terminating ")" or ")" without
	// opening "(". Since 2.16
	RegexErrorUnmatchedParenthesis RegexError = 114
	// RegexErrorInexistentSubpatternReference: reference to non-existent
	// subpattern. Since 2.16
	RegexErrorInexistentSubpatternReference RegexError = 115
	// RegexErrorUnterminatedComment: missing terminating ")" after comment.
	// Since 2.16
	RegexErrorUnterminatedComment RegexError = 118
	// RegexErrorExpressionTooLarge: regular expression too large. Since 2.16
	RegexErrorExpressionTooLarge RegexError = 120
	// RegexErrorMemoryError: failed to get memory. Since 2.16
	RegexErrorMemoryError RegexError = 121
	// RegexErrorVariableLengthLookbehind: lookbehind assertion is not fixed
	// length. Since 2.16
	RegexErrorVariableLengthLookbehind RegexError = 125
	// RegexErrorMalformedCondition: malformed number or name after "(?(". Since
	// 2.16
	RegexErrorMalformedCondition RegexError = 126
	// RegexErrorTooManyConditionalBranches: conditional group contains more
	// than two branches. Since 2.16
	RegexErrorTooManyConditionalBranches RegexError = 127
	// RegexErrorAssertionExpected: assertion expected after "(?(". Since 2.16
	RegexErrorAssertionExpected RegexError = 128
	// RegexErrorUnknownPosixClassName: unknown POSIX class name. Since 2.16
	RegexErrorUnknownPosixClassName RegexError = 130
	// RegexErrorPosixCollatingElementsNotSupported: POSIX collating elements
	// are not supported. Since 2.16
	RegexErrorPosixCollatingElementsNotSupported RegexError = 131
	// RegexErrorHexCodeTooLarge: character value in "\\x{...}" sequence is too
	// large. Since 2.16
	RegexErrorHexCodeTooLarge RegexError = 134
	// RegexErrorInvalidCondition: invalid condition "(?(0)". Since 2.16
	RegexErrorInvalidCondition RegexError = 135
	// RegexErrorSingleByteMatchInLookbehind: \\C not allowed in lookbehind
	// assertion. Since 2.16
	RegexErrorSingleByteMatchInLookbehind RegexError = 136
	// RegexErrorInfiniteLoop: recursive call could loop indefinitely. Since
	// 2.16
	RegexErrorInfiniteLoop RegexError = 140
	// RegexErrorMissingSubpatternNameTerminator: missing terminator in
	// subpattern name. Since 2.16
	RegexErrorMissingSubpatternNameTerminator RegexError = 142
	// RegexErrorDuplicateSubpatternName: two named subpatterns have the same
	// name. Since 2.16
	RegexErrorDuplicateSubpatternName RegexError = 143
	// RegexErrorMalformedProperty: malformed "\\P" or "\\p" sequence. Since
	// 2.16
	RegexErrorMalformedProperty RegexError = 146
	// RegexErrorUnknownProperty: unknown property name after "\\P" or "\\p".
	// Since 2.16
	RegexErrorUnknownProperty RegexError = 147
	// RegexErrorSubpatternNameTooLong: subpattern name is too long (maximum 32
	// characters). Since 2.16
	RegexErrorSubpatternNameTooLong RegexError = 148
	// RegexErrorTooManySubpatterns: too many named subpatterns (maximum
	// 10,000). Since 2.16
	RegexErrorTooManySubpatterns RegexError = 149
	// RegexErrorInvalidOctalValue: octal value is greater than "\\377". Since
	// 2.16
	RegexErrorInvalidOctalValue RegexError = 151
	// RegexErrorTooManyBranchesInDefine: "DEFINE" group contains more than one
	// branch. Since 2.16
	RegexErrorTooManyBranchesInDefine RegexError = 154
	// RegexErrorDefineRepetion: repeating a "DEFINE" group is not allowed. This
	// error is never raised. Since: 2.16 Deprecated: 2.34
	RegexErrorDefineRepetion RegexError = 155
	// RegexErrorInconsistentNewlineOptions: inconsistent newline options. Since
	// 2.16
	RegexErrorInconsistentNewlineOptions RegexError = 156
	// RegexErrorMissingBackReference: "\\g" is not followed by a braced,
	// angle-bracketed, or quoted name or number, or by a plain number. Since:
	// 2.16
	RegexErrorMissingBackReference RegexError = 157
	// RegexErrorInvalidRelativeReference: relative reference must not be zero.
	// Since: 2.34
	RegexErrorInvalidRelativeReference RegexError = 158
	// RegexErrorBacktrackingControlVerbArgumentForbidden: the backtracing
	// control verb used does not allow an argument. Since: 2.34
	RegexErrorBacktrackingControlVerbArgumentForbidden RegexError = 159
	// RegexErrorUnknownBacktrackingControlVerb: unknown backtracing control
	// verb. Since: 2.34
	RegexErrorUnknownBacktrackingControlVerb RegexError = 160
	// RegexErrorNumberTooBig: number is too big in escape sequence. Since: 2.34
	RegexErrorNumberTooBig RegexError = 161
	// RegexErrorMissingSubpatternName: missing subpattern name. Since: 2.34
	RegexErrorMissingSubpatternName RegexError = 162
	// RegexErrorMissingDigit: missing digit. Since 2.34
	RegexErrorMissingDigit RegexError = 163
	// RegexErrorInvalidDataCharacter: in JavaScript compatibility mode, "[" is
	// an invalid data character. Since: 2.34
	RegexErrorInvalidDataCharacter RegexError = 164
	// RegexErrorExtraSubpatternName: different names for subpatterns of the
	// same number are not allowed. Since: 2.34
	RegexErrorExtraSubpatternName RegexError = 165
	// RegexErrorBacktrackingControlVerbArgumentRequired: the backtracing
	// control verb requires an argument. Since: 2.34
	RegexErrorBacktrackingControlVerbArgumentRequired RegexError = 166
	// RegexErrorInvalidControlChar: "\\c" must be followed by an ASCII
	// character. Since: 2.34
	RegexErrorInvalidControlChar RegexError = 168
	// RegexErrorMissingName: "\\k" is not followed by a braced,
	// angle-bracketed, or quoted name. Since: 2.34
	RegexErrorMissingName RegexError = 169
	// RegexErrorNotSupportedInClass: "\\N" is not supported in a class. Since:
	// 2.34
	RegexErrorNotSupportedInClass RegexError = 171
	// RegexErrorTooManyForwardReferences: too many forward references. Since:
	// 2.34
	RegexErrorTooManyForwardReferences RegexError = 172
	// RegexErrorNameTooLong: the name is too long in "(*MARK)", "(*PRUNE)",
	// "(*SKIP)", or "(*THEN)". Since: 2.34
	RegexErrorNameTooLong RegexError = 175
	// RegexErrorCharacterValueTooLarge: the character value in the \\u sequence
	// is too large. Since: 2.34
	RegexErrorCharacterValueTooLarge RegexError = 176
)

// SeekType: an enumeration specifying the base position for a
// g_io_channel_seek_position() operation.
type SeekType int

const (
	// SeekTypeCur: the current position in the file.
	SeekTypeCur SeekType = 0
	// SeekTypeSet: the start of the file.
	SeekTypeSet SeekType = 1
	// SeekTypeEnd: the end of the file.
	SeekTypeEnd SeekType = 2
)

// ShellError: error codes returned by shell functions.
type ShellError int

const (
	// ShellErrorBadQuoting: mismatched or otherwise mangled quoting.
	ShellErrorBadQuoting ShellError = 0
	// ShellErrorEmptyString: string to be parsed was empty.
	ShellErrorEmptyString ShellError = 1
	// ShellErrorFailed: some other error.
	ShellErrorFailed ShellError = 2
)

// SpawnError: error codes returned by spawning processes.
type SpawnError int

const (
	// SpawnErrorFork: fork failed due to lack of memory.
	SpawnErrorFork SpawnError = 0
	// SpawnErrorRead: read or select on pipes failed.
	SpawnErrorRead SpawnError = 1
	// SpawnErrorChdir: changing to working directory failed.
	SpawnErrorChdir SpawnError = 2
	// SpawnErrorAcces: execv() returned `EACCES`
	SpawnErrorAcces SpawnError = 3
	// SpawnErrorPerm: execv() returned `EPERM`
	SpawnErrorPerm SpawnError = 4
	// SpawnErrorTooBig: execv() returned `E2BIG`
	SpawnErrorTooBig SpawnError = 5
	// SpawnError2Big: deprecated alias for G_SPAWN_ERROR_TOO_BIG (deprecated
	// since GLib 2.32)
	SpawnError2Big SpawnError = 5
	// SpawnErrorNoexec: execv() returned `ENOEXEC`
	SpawnErrorNoexec SpawnError = 6
	// SpawnErrorNametoolong: execv() returned `ENAMETOOLONG`
	SpawnErrorNametoolong SpawnError = 7
	// SpawnErrorNoent: execv() returned `ENOENT`
	SpawnErrorNoent SpawnError = 8
	// SpawnErrorNOMEM: execv() returned `ENOMEM`
	SpawnErrorNOMEM SpawnError = 9
	// SpawnErrorNotdir: execv() returned `ENOTDIR`
	SpawnErrorNotdir SpawnError = 10
	// SpawnErrorLoop: execv() returned `ELOOP`
	SpawnErrorLoop SpawnError = 11
	// SpawnErrorTxtbusy: execv() returned `ETXTBUSY`
	SpawnErrorTxtbusy SpawnError = 12
	// SpawnErrorIO: execv() returned `EIO`
	SpawnErrorIO SpawnError = 13
	// SpawnErrorNfile: execv() returned `ENFILE`
	SpawnErrorNfile SpawnError = 14
	// SpawnErrorMfile: execv() returned `EMFILE`
	SpawnErrorMfile SpawnError = 15
	// SpawnErrorInval: execv() returned `EINVAL`
	SpawnErrorInval SpawnError = 16
	// SpawnErrorIsdir: execv() returned `EISDIR`
	SpawnErrorIsdir SpawnError = 17
	// SpawnErrorLibbad: execv() returned `ELIBBAD`
	SpawnErrorLibbad SpawnError = 18
	// SpawnErrorFailed: some other fatal failure, `error->message` should
	// explain.
	SpawnErrorFailed SpawnError = 19
)

// TimeType disambiguates a given time in two ways.
//
// First, specifies if the given time is in universal or local time.
//
// Second, if the time is in local time, specifies if it is local standard time
// or local daylight time. This is important for the case where the same local
// time occurs twice (during daylight savings time transitions, for example).
type TimeType int

const (
	// TimeTypeStandard: the time is in local standard time
	TimeTypeStandard TimeType = 0
	// TimeTypeDaylight: the time is in local daylight time
	TimeTypeDaylight TimeType = 1
	// TimeTypeUniversal: the time is in UTC
	TimeTypeUniversal TimeType = 2
)

// TokenType: the possible types of token returned from each
// g_scanner_get_next_token() call.
type TokenType int

const (
	// TokenTypeEOF: the end of the file
	TokenTypeEOF TokenType = 0
	// TokenTypeLeftParen: a '(' character
	TokenTypeLeftParen TokenType = 40
	// TokenTypeRightParen: a ')' character
	TokenTypeRightParen TokenType = 41
	// TokenTypeLeftCurly: a '{' character
	TokenTypeLeftCurly TokenType = 123
	// TokenTypeRightCurly: a '}' character
	TokenTypeRightCurly TokenType = 125
	// TokenTypeLeftBrace: a '[' character
	TokenTypeLeftBrace TokenType = 91
	// TokenTypeRightBrace: a ']' character
	TokenTypeRightBrace TokenType = 93
	// TokenTypeEqualSign: a '=' character
	TokenTypeEqualSign TokenType = 61
	// TokenTypeComma: a ',' character
	TokenTypeComma TokenType = 44
	// TokenTypeNone: not a token
	TokenTypeNone TokenType = 256
	// TokenTypeError: an error occurred
	TokenTypeError TokenType = 257
	// TokenTypeChar: a character
	TokenTypeChar TokenType = 258
	// TokenTypeBinary: a binary integer
	TokenTypeBinary TokenType = 259
	// TokenTypeOctal: an octal integer
	TokenTypeOctal TokenType = 260
	// TokenTypeInt: an integer
	TokenTypeInt TokenType = 261
	// TokenTypeHex: a hex integer
	TokenTypeHex TokenType = 262
	// TokenTypeFloat: a floating point number
	TokenTypeFloat TokenType = 263
	// TokenTypeString: a string
	TokenTypeString TokenType = 264
	// TokenTypeSymbol: a symbol
	TokenTypeSymbol TokenType = 265
	// TokenTypeIdentifier: an identifier
	TokenTypeIdentifier TokenType = 266
	// TokenTypeIdentifierNull: a null identifier
	TokenTypeIdentifierNull TokenType = 267
	// TokenTypeCommentSingle: one line comment
	TokenTypeCommentSingle TokenType = 268
	// TokenTypeCommentMulti: multi line comment
	TokenTypeCommentMulti TokenType = 269
)

// TraverseType specifies the type of traversal performed by g_tree_traverse(),
// g_node_traverse() and g_node_find(). The different orders are illustrated
// here: - In order: A, B, C, D, E, F, G, H, I !
// (Sorted_binary_tree_inorder.svg) - Pre order: F, B, A, D, C, E, G, I, H !
// (Sorted_binary_tree_preorder.svg) - Post order: A, C, E, D, B, H, I, G, F !
// (Sorted_binary_tree_postorder.svg) - Level order: F, B, G, A, D, I, C, E, H !
// (Sorted_binary_tree_breadth-first_traversal.svg)
type TraverseType int

const (
	// TraverseTypeInOrder vists a node's left child first, then the node
	// itself, then its right child. This is the one to use if you want the
	// output sorted according to the compare function.
	TraverseTypeInOrder TraverseType = 0
	// TraverseTypePreOrder visits a node, then its children.
	TraverseTypePreOrder TraverseType = 1
	// TraverseTypePostOrder visits the node's children, then the node itself.
	TraverseTypePostOrder TraverseType = 2
	// TraverseTypeLevelOrder is not implemented for [balanced binary
	// trees][glib-Balanced-Binary-Trees]. For [n-ary trees][glib-N-ary-Trees],
	// it vists the root node first, then its children, then its grandchildren,
	// and so on. Note that this is less efficient than the other orders.
	TraverseTypeLevelOrder TraverseType = 3
)

// UnicodeBreakType: these are the possible line break classifications.
//
// Since new unicode versions may add new types here, applications should be
// ready to handle unknown values. They may be regarded as
// G_UNICODE_BREAK_UNKNOWN.
//
// See Unicode Line Breaking Algorithm
// (http://www.unicode.org/unicode/reports/tr14/).
type UnicodeBreakType int

const (
	// UnicodeBreakTypeMandatory: mandatory Break (BK)
	UnicodeBreakTypeMandatory UnicodeBreakType = 0
	// UnicodeBreakTypeCarriageReturn: carriage Return (CR)
	UnicodeBreakTypeCarriageReturn UnicodeBreakType = 1
	// UnicodeBreakTypeLineFeed: line Feed (LF)
	UnicodeBreakTypeLineFeed UnicodeBreakType = 2
	// UnicodeBreakTypeCombiningMark: attached Characters and Combining Marks
	// (CM)
	UnicodeBreakTypeCombiningMark UnicodeBreakType = 3
	// UnicodeBreakTypeSurrogate surrogates (SG)
	UnicodeBreakTypeSurrogate UnicodeBreakType = 4
	// UnicodeBreakTypeZeroWidthSpace: zero Width Space (ZW)
	UnicodeBreakTypeZeroWidthSpace UnicodeBreakType = 5
	// UnicodeBreakTypeInseparable: inseparable (IN)
	UnicodeBreakTypeInseparable UnicodeBreakType = 6
	// UnicodeBreakTypeNonBreakingGlue: non-breaking ("Glue") (GL)
	UnicodeBreakTypeNonBreakingGlue UnicodeBreakType = 7
	// UnicodeBreakTypeContingent: contingent Break Opportunity (CB)
	UnicodeBreakTypeContingent UnicodeBreakType = 8
	// UnicodeBreakTypeSpace: space (SP)
	UnicodeBreakTypeSpace UnicodeBreakType = 9
	// UnicodeBreakTypeAfter: break Opportunity After (BA)
	UnicodeBreakTypeAfter UnicodeBreakType = 10
	// UnicodeBreakTypeBefore: break Opportunity Before (BB)
	UnicodeBreakTypeBefore UnicodeBreakType = 11
	// UnicodeBreakTypeBeforeAndAfter: break Opportunity Before and After (B2)
	UnicodeBreakTypeBeforeAndAfter UnicodeBreakType = 12
	// UnicodeBreakTypeHyphen: hyphen (HY)
	UnicodeBreakTypeHyphen UnicodeBreakType = 13
	// UnicodeBreakTypeNonStarter: nonstarter (NS)
	UnicodeBreakTypeNonStarter UnicodeBreakType = 14
	// UnicodeBreakTypeOpenPunctuation: opening Punctuation (OP)
	UnicodeBreakTypeOpenPunctuation UnicodeBreakType = 15
	// UnicodeBreakTypeClosePunctuation: closing Punctuation (CL)
	UnicodeBreakTypeClosePunctuation UnicodeBreakType = 16
	// UnicodeBreakTypeQuotation ambiguous Quotation (QU)
	UnicodeBreakTypeQuotation UnicodeBreakType = 17
	// UnicodeBreakTypeExclamation: exclamation/Interrogation (EX)
	UnicodeBreakTypeExclamation UnicodeBreakType = 18
	// UnicodeBreakTypeIdeographic: ideographic (ID)
	UnicodeBreakTypeIdeographic UnicodeBreakType = 19
	// UnicodeBreakTypeNumeric: numeric (NU)
	UnicodeBreakTypeNumeric UnicodeBreakType = 20
	// UnicodeBreakTypeInfixSeparator: infix Separator (Numeric) (IS)
	UnicodeBreakTypeInfixSeparator UnicodeBreakType = 21
	// UnicodeBreakTypeSymbol symbols Allowing Break After (SY)
	UnicodeBreakTypeSymbol UnicodeBreakType = 22
	// UnicodeBreakTypeAlphabetic: ordinary Alphabetic and Symbol Characters
	// (AL)
	UnicodeBreakTypeAlphabetic UnicodeBreakType = 23
	// UnicodeBreakTypePrefix: prefix (Numeric) (PR)
	UnicodeBreakTypePrefix UnicodeBreakType = 24
	// UnicodeBreakTypePostfix: postfix (Numeric) (PO)
	UnicodeBreakTypePostfix UnicodeBreakType = 25
	// UnicodeBreakTypeComplexContext: complex Content Dependent (South East
	// Asian) (SA)
	UnicodeBreakTypeComplexContext UnicodeBreakType = 26
	// UnicodeBreakTypeAmbiguous ambiguous (Alphabetic or Ideographic) (AI)
	UnicodeBreakTypeAmbiguous UnicodeBreakType = 27
	// UnicodeBreakTypeUnknown: unknown (XX)
	UnicodeBreakTypeUnknown UnicodeBreakType = 28
	// UnicodeBreakTypeNextLine: next Line (NL)
	UnicodeBreakTypeNextLine UnicodeBreakType = 29
	// UnicodeBreakTypeWordJoiner: word Joiner (WJ)
	UnicodeBreakTypeWordJoiner UnicodeBreakType = 30
	// UnicodeBreakTypeHangulLJamo: hangul L Jamo (JL)
	UnicodeBreakTypeHangulLJamo UnicodeBreakType = 31
	// UnicodeBreakTypeHangulVJamo: hangul V Jamo (JV)
	UnicodeBreakTypeHangulVJamo UnicodeBreakType = 32
	// UnicodeBreakTypeHangulTJamo: hangul T Jamo (JT)
	UnicodeBreakTypeHangulTJamo UnicodeBreakType = 33
	// UnicodeBreakTypeHangulLvSyllable: hangul LV Syllable (H2)
	UnicodeBreakTypeHangulLvSyllable UnicodeBreakType = 34
	// UnicodeBreakTypeHangulLvtSyllable: hangul LVT Syllable (H3)
	UnicodeBreakTypeHangulLvtSyllable UnicodeBreakType = 35
	// UnicodeBreakTypeCloseParanthesis: closing Parenthesis (CP). Since 2.28
	UnicodeBreakTypeCloseParanthesis UnicodeBreakType = 36
	// UnicodeBreakTypeConditionalJapaneseStarter: conditional Japanese Starter
	// (CJ). Since: 2.32
	UnicodeBreakTypeConditionalJapaneseStarter UnicodeBreakType = 37
	// UnicodeBreakTypeHebrewLetter: hebrew Letter (HL). Since: 2.32
	UnicodeBreakTypeHebrewLetter UnicodeBreakType = 38
	// UnicodeBreakTypeRegionalIndicator: regional Indicator (RI). Since: 2.36
	UnicodeBreakTypeRegionalIndicator UnicodeBreakType = 39
	// UnicodeBreakTypeEmojiBase: emoji Base (EB). Since: 2.50
	UnicodeBreakTypeEmojiBase UnicodeBreakType = 40
	// UnicodeBreakTypeEmojiModifier: emoji Modifier (EM). Since: 2.50
	UnicodeBreakTypeEmojiModifier UnicodeBreakType = 41
	// UnicodeBreakTypeZeroWidthJoiner: zero Width Joiner (ZWJ). Since: 2.50
	UnicodeBreakTypeZeroWidthJoiner UnicodeBreakType = 42
)

// UnicodeScript: the Script enumeration identifies different writing systems.
// The values correspond to the names as defined in the Unicode standard. The
// enumeration has been added in GLib 2.14, and is interchangeable with Script.
//
// Note that new types may be added in the future. Applications should be ready
// to handle unknown values. See Unicode Standard Annex #24: Script names
// (http://www.unicode.org/reports/tr24/).
type UnicodeScript int

const (
	// UnicodeScriptInvalidCode: a value never returned from
	// g_unichar_get_script()
	UnicodeScriptInvalidCode UnicodeScript = -1
	// UnicodeScriptCommon: a character used by multiple different scripts
	UnicodeScriptCommon UnicodeScript = 0
	// UnicodeScriptInherited: a mark glyph that takes its script from the base
	// glyph to which it is attached
	UnicodeScriptInherited UnicodeScript = 1
	// UnicodeScriptArabic: arabic
	UnicodeScriptArabic UnicodeScript = 2
	// UnicodeScriptArmenian: armenian
	UnicodeScriptArmenian UnicodeScript = 3
	// UnicodeScriptBengali: bengali
	UnicodeScriptBengali UnicodeScript = 4
	// UnicodeScriptBopomofo: bopomofo
	UnicodeScriptBopomofo UnicodeScript = 5
	// UnicodeScriptCherokee: cherokee
	UnicodeScriptCherokee UnicodeScript = 6
	// UnicodeScriptCoptic: coptic
	UnicodeScriptCoptic UnicodeScript = 7
	// UnicodeScriptCyrillic: cyrillic
	UnicodeScriptCyrillic UnicodeScript = 8
	// UnicodeScriptDeseret: deseret
	UnicodeScriptDeseret UnicodeScript = 9
	// UnicodeScriptDevanagari: devanagari
	UnicodeScriptDevanagari UnicodeScript = 10
	// UnicodeScriptEthiopic: ethiopic
	UnicodeScriptEthiopic UnicodeScript = 11
	// UnicodeScriptGeorgian: georgian
	UnicodeScriptGeorgian UnicodeScript = 12
	// UnicodeScriptGothic: gothic
	UnicodeScriptGothic UnicodeScript = 13
	// UnicodeScriptGreek: greek
	UnicodeScriptGreek UnicodeScript = 14
	// UnicodeScriptGujarati: gujarati
	UnicodeScriptGujarati UnicodeScript = 15
	// UnicodeScriptGurmukhi: gurmukhi
	UnicodeScriptGurmukhi UnicodeScript = 16
	// UnicodeScriptHan: han
	UnicodeScriptHan UnicodeScript = 17
	// UnicodeScriptHangul: hangul
	UnicodeScriptHangul UnicodeScript = 18
	// UnicodeScriptHebrew: hebrew
	UnicodeScriptHebrew UnicodeScript = 19
	// UnicodeScriptHiragana: hiragana
	UnicodeScriptHiragana UnicodeScript = 20
	// UnicodeScriptKannada: kannada
	UnicodeScriptKannada UnicodeScript = 21
	// UnicodeScriptKatakana: katakana
	UnicodeScriptKatakana UnicodeScript = 22
	// UnicodeScriptKhmer: khmer
	UnicodeScriptKhmer UnicodeScript = 23
	// UnicodeScriptLao: lao
	UnicodeScriptLao UnicodeScript = 24
	// UnicodeScriptLatin: latin
	UnicodeScriptLatin UnicodeScript = 25
	// UnicodeScriptMalayalam: malayalam
	UnicodeScriptMalayalam UnicodeScript = 26
	// UnicodeScriptMongolian: mongolian
	UnicodeScriptMongolian UnicodeScript = 27
	// UnicodeScriptMyanmar: myanmar
	UnicodeScriptMyanmar UnicodeScript = 28
	// UnicodeScriptOgham: ogham
	UnicodeScriptOgham UnicodeScript = 29
	// UnicodeScriptOldItalic: old Italic
	UnicodeScriptOldItalic UnicodeScript = 30
	// UnicodeScriptOriya: oriya
	UnicodeScriptOriya UnicodeScript = 31
	// UnicodeScriptRunic: runic
	UnicodeScriptRunic UnicodeScript = 32
	// UnicodeScriptSinhala: sinhala
	UnicodeScriptSinhala UnicodeScript = 33
	// UnicodeScriptSyriac: syriac
	UnicodeScriptSyriac UnicodeScript = 34
	// UnicodeScriptTamil: tamil
	UnicodeScriptTamil UnicodeScript = 35
	// UnicodeScriptTelugu: telugu
	UnicodeScriptTelugu UnicodeScript = 36
	// UnicodeScriptThaana: thaana
	UnicodeScriptThaana UnicodeScript = 37
	// UnicodeScriptThai: thai
	UnicodeScriptThai UnicodeScript = 38
	// UnicodeScriptTibetan: tibetan
	UnicodeScriptTibetan UnicodeScript = 39
	// UnicodeScriptCanadianAboriginal: canadian Aboriginal
	UnicodeScriptCanadianAboriginal UnicodeScript = 40
	// UnicodeScriptYi: yi
	UnicodeScriptYi UnicodeScript = 41
	// UnicodeScriptTagalog: tagalog
	UnicodeScriptTagalog UnicodeScript = 42
	// UnicodeScriptHanunoo: hanunoo
	UnicodeScriptHanunoo UnicodeScript = 43
	// UnicodeScriptBuhid: buhid
	UnicodeScriptBuhid UnicodeScript = 44
	// UnicodeScriptTagbanwa: tagbanwa
	UnicodeScriptTagbanwa UnicodeScript = 45
	// UnicodeScriptBraille: braille
	UnicodeScriptBraille UnicodeScript = 46
	// UnicodeScriptCypriot: cypriot
	UnicodeScriptCypriot UnicodeScript = 47
	// UnicodeScriptLimbu: limbu
	UnicodeScriptLimbu UnicodeScript = 48
	// UnicodeScriptOsmanya: osmanya
	UnicodeScriptOsmanya UnicodeScript = 49
	// UnicodeScriptShavian: shavian
	UnicodeScriptShavian UnicodeScript = 50
	// UnicodeScriptLinearB: linear B
	UnicodeScriptLinearB UnicodeScript = 51
	// UnicodeScriptTaiLe: tai Le
	UnicodeScriptTaiLe UnicodeScript = 52
	// UnicodeScriptUgaritic: ugaritic
	UnicodeScriptUgaritic UnicodeScript = 53
	// UnicodeScriptNewTaiLue: new Tai Lue
	UnicodeScriptNewTaiLue UnicodeScript = 54
	// UnicodeScriptBuginese: buginese
	UnicodeScriptBuginese UnicodeScript = 55
	// UnicodeScriptGlagolitic: glagolitic
	UnicodeScriptGlagolitic UnicodeScript = 56
	// UnicodeScriptTifinagh: tifinagh
	UnicodeScriptTifinagh UnicodeScript = 57
	// UnicodeScriptSylotiNagri: syloti Nagri
	UnicodeScriptSylotiNagri UnicodeScript = 58
	// UnicodeScriptOldPersian: old Persian
	UnicodeScriptOldPersian UnicodeScript = 59
	// UnicodeScriptKharoshthi: kharoshthi
	UnicodeScriptKharoshthi UnicodeScript = 60
	// UnicodeScriptUnknown: an unassigned code point
	UnicodeScriptUnknown UnicodeScript = 61
	// UnicodeScriptBalinese: balinese
	UnicodeScriptBalinese UnicodeScript = 62
	// UnicodeScriptCuneiform: cuneiform
	UnicodeScriptCuneiform UnicodeScript = 63
	// UnicodeScriptPhoenician: phoenician
	UnicodeScriptPhoenician UnicodeScript = 64
	// UnicodeScriptPhagsPa: phags-pa
	UnicodeScriptPhagsPa UnicodeScript = 65
	// UnicodeScriptNko: n'Ko
	UnicodeScriptNko UnicodeScript = 66
	// UnicodeScriptKayahLi: kayah Li. Since 2.16.3
	UnicodeScriptKayahLi UnicodeScript = 67
	// UnicodeScriptLepcha: lepcha. Since 2.16.3
	UnicodeScriptLepcha UnicodeScript = 68
	// UnicodeScriptRejang: rejang. Since 2.16.3
	UnicodeScriptRejang UnicodeScript = 69
	// UnicodeScriptSundanese: sundanese. Since 2.16.3
	UnicodeScriptSundanese UnicodeScript = 70
	// UnicodeScriptSaurashtra: saurashtra. Since 2.16.3
	UnicodeScriptSaurashtra UnicodeScript = 71
	// UnicodeScriptCham: cham. Since 2.16.3
	UnicodeScriptCham UnicodeScript = 72
	// UnicodeScriptOlChiki: ol Chiki. Since 2.16.3
	UnicodeScriptOlChiki UnicodeScript = 73
	// UnicodeScriptVai: vai. Since 2.16.3
	UnicodeScriptVai UnicodeScript = 74
	// UnicodeScriptCarian: carian. Since 2.16.3
	UnicodeScriptCarian UnicodeScript = 75
	// UnicodeScriptLycian: lycian. Since 2.16.3
	UnicodeScriptLycian UnicodeScript = 76
	// UnicodeScriptLydian: lydian. Since 2.16.3
	UnicodeScriptLydian UnicodeScript = 77
	// UnicodeScriptAvestan: avestan. Since 2.26
	UnicodeScriptAvestan UnicodeScript = 78
	// UnicodeScriptBamum: bamum. Since 2.26
	UnicodeScriptBamum UnicodeScript = 79
	// UnicodeScriptEgyptianHieroglyphs: egyptian Hieroglpyhs. Since 2.26
	UnicodeScriptEgyptianHieroglyphs UnicodeScript = 80
	// UnicodeScriptImperialAramaic: imperial Aramaic. Since 2.26
	UnicodeScriptImperialAramaic UnicodeScript = 81
	// UnicodeScriptInscriptionalPahlavi: inscriptional Pahlavi. Since 2.26
	UnicodeScriptInscriptionalPahlavi UnicodeScript = 82
	// UnicodeScriptInscriptionalParthian: inscriptional Parthian. Since 2.26
	UnicodeScriptInscriptionalParthian UnicodeScript = 83
	// UnicodeScriptJavanese: javanese. Since 2.26
	UnicodeScriptJavanese UnicodeScript = 84
	// UnicodeScriptKaithi: kaithi. Since 2.26
	UnicodeScriptKaithi UnicodeScript = 85
	// UnicodeScriptLisu: lisu. Since 2.26
	UnicodeScriptLisu UnicodeScript = 86
	// UnicodeScriptMeeteiMayek: meetei Mayek. Since 2.26
	UnicodeScriptMeeteiMayek UnicodeScript = 87
	// UnicodeScriptOldSouthArabian: old South Arabian. Since 2.26
	UnicodeScriptOldSouthArabian UnicodeScript = 88
	// UnicodeScriptOldTurkic: old Turkic. Since 2.28
	UnicodeScriptOldTurkic UnicodeScript = 89
	// UnicodeScriptSamaritan: samaritan. Since 2.26
	UnicodeScriptSamaritan UnicodeScript = 90
	// UnicodeScriptTaiTham: tai Tham. Since 2.26
	UnicodeScriptTaiTham UnicodeScript = 91
	// UnicodeScriptTaiViet: tai Viet. Since 2.26
	UnicodeScriptTaiViet UnicodeScript = 92
	// UnicodeScriptBatak: batak. Since 2.28
	UnicodeScriptBatak UnicodeScript = 93
	// UnicodeScriptBrahmi: brahmi. Since 2.28
	UnicodeScriptBrahmi UnicodeScript = 94
	// UnicodeScriptMandaic: mandaic. Since 2.28
	UnicodeScriptMandaic UnicodeScript = 95
	// UnicodeScriptChakma: chakma. Since: 2.32
	UnicodeScriptChakma UnicodeScript = 96
	// UnicodeScriptMeroiticCursive: meroitic Cursive. Since: 2.32
	UnicodeScriptMeroiticCursive UnicodeScript = 97
	// UnicodeScriptMeroiticHieroglyphs: meroitic Hieroglyphs. Since: 2.32
	UnicodeScriptMeroiticHieroglyphs UnicodeScript = 98
	// UnicodeScriptMiao: miao. Since: 2.32
	UnicodeScriptMiao UnicodeScript = 99
	// UnicodeScriptSharada: sharada. Since: 2.32
	UnicodeScriptSharada UnicodeScript = 100
	// UnicodeScriptSoraSompeng: sora Sompeng. Since: 2.32
	UnicodeScriptSoraSompeng UnicodeScript = 101
	// UnicodeScriptTakri: takri. Since: 2.32
	UnicodeScriptTakri UnicodeScript = 102
	// UnicodeScriptBassaVah: bassa. Since: 2.42
	UnicodeScriptBassaVah UnicodeScript = 103
	// UnicodeScriptCaucasianAlbanian: caucasian Albanian. Since: 2.42
	UnicodeScriptCaucasianAlbanian UnicodeScript = 104
	// UnicodeScriptDuployan: duployan. Since: 2.42
	UnicodeScriptDuployan UnicodeScript = 105
	// UnicodeScriptElbasan: elbasan. Since: 2.42
	UnicodeScriptElbasan UnicodeScript = 106
	// UnicodeScriptGrantha: grantha. Since: 2.42
	UnicodeScriptGrantha UnicodeScript = 107
	// UnicodeScriptKhojki: kjohki. Since: 2.42
	UnicodeScriptKhojki UnicodeScript = 108
	// UnicodeScriptKhudawadi: khudawadi, Sindhi. Since: 2.42
	UnicodeScriptKhudawadi UnicodeScript = 109
	// UnicodeScriptLinearA: linear A. Since: 2.42
	UnicodeScriptLinearA UnicodeScript = 110
	// UnicodeScriptMahajani: mahajani. Since: 2.42
	UnicodeScriptMahajani UnicodeScript = 111
	// UnicodeScriptManichaean: manichaean. Since: 2.42
	UnicodeScriptManichaean UnicodeScript = 112
	// UnicodeScriptMendeKikakui: mende Kikakui. Since: 2.42
	UnicodeScriptMendeKikakui UnicodeScript = 113
	// UnicodeScriptModi: modi. Since: 2.42
	UnicodeScriptModi UnicodeScript = 114
	// UnicodeScriptMro: mro. Since: 2.42
	UnicodeScriptMro UnicodeScript = 115
	// UnicodeScriptNabataean: nabataean. Since: 2.42
	UnicodeScriptNabataean UnicodeScript = 116
	// UnicodeScriptOldNorthArabian: old North Arabian. Since: 2.42
	UnicodeScriptOldNorthArabian UnicodeScript = 117
	// UnicodeScriptOldPermic: old Permic. Since: 2.42
	UnicodeScriptOldPermic UnicodeScript = 118
	// UnicodeScriptPahawhHmong: pahawh Hmong. Since: 2.42
	UnicodeScriptPahawhHmong UnicodeScript = 119
	// UnicodeScriptPalmyrene: palmyrene. Since: 2.42
	UnicodeScriptPalmyrene UnicodeScript = 120
	// UnicodeScriptPauCinHau: pau Cin Hau. Since: 2.42
	UnicodeScriptPauCinHau UnicodeScript = 121
	// UnicodeScriptPsalterPahlavi: psalter Pahlavi. Since: 2.42
	UnicodeScriptPsalterPahlavi UnicodeScript = 122
	// UnicodeScriptSiddham: siddham. Since: 2.42
	UnicodeScriptSiddham UnicodeScript = 123
	// UnicodeScriptTirhuta: tirhuta. Since: 2.42
	UnicodeScriptTirhuta UnicodeScript = 124
	// UnicodeScriptWarangCiti: warang Citi. Since: 2.42
	UnicodeScriptWarangCiti UnicodeScript = 125
	// UnicodeScriptAhom: ahom. Since: 2.48
	UnicodeScriptAhom UnicodeScript = 126
	// UnicodeScriptAnatolianHieroglyphs: anatolian Hieroglyphs. Since: 2.48
	UnicodeScriptAnatolianHieroglyphs UnicodeScript = 127
	// UnicodeScriptHatran: hatran. Since: 2.48
	UnicodeScriptHatran UnicodeScript = 128
	// UnicodeScriptMultani: multani. Since: 2.48
	UnicodeScriptMultani UnicodeScript = 129
	// UnicodeScriptOldHungarian: old Hungarian. Since: 2.48
	UnicodeScriptOldHungarian UnicodeScript = 130
	// UnicodeScriptSignwriting: signwriting. Since: 2.48
	UnicodeScriptSignwriting UnicodeScript = 131
	// UnicodeScriptAdlam: adlam. Since: 2.50
	UnicodeScriptAdlam UnicodeScript = 132
	// UnicodeScriptBhaiksuki: bhaiksuki. Since: 2.50
	UnicodeScriptBhaiksuki UnicodeScript = 133
	// UnicodeScriptMarchen: marchen. Since: 2.50
	UnicodeScriptMarchen UnicodeScript = 134
	// UnicodeScriptNewa: newa. Since: 2.50
	UnicodeScriptNewa UnicodeScript = 135
	// UnicodeScriptOsage: osage. Since: 2.50
	UnicodeScriptOsage UnicodeScript = 136
	// UnicodeScriptTangut: tangut. Since: 2.50
	UnicodeScriptTangut UnicodeScript = 137
	// UnicodeScriptMasaramGondi: masaram Gondi. Since: 2.54
	UnicodeScriptMasaramGondi UnicodeScript = 138
	// UnicodeScriptNushu: nushu. Since: 2.54
	UnicodeScriptNushu UnicodeScript = 139
	// UnicodeScriptSoyombo: soyombo. Since: 2.54
	UnicodeScriptSoyombo UnicodeScript = 140
	// UnicodeScriptZanabazarSquare: zanabazar Square. Since: 2.54
	UnicodeScriptZanabazarSquare UnicodeScript = 141
	// UnicodeScriptDogra: dogra. Since: 2.58
	UnicodeScriptDogra UnicodeScript = 142
	// UnicodeScriptGunjalaGondi: gunjala Gondi. Since: 2.58
	UnicodeScriptGunjalaGondi UnicodeScript = 143
	// UnicodeScriptHanifiRohingya: hanifi Rohingya. Since: 2.58
	UnicodeScriptHanifiRohingya UnicodeScript = 144
	// UnicodeScriptMakasar: makasar. Since: 2.58
	UnicodeScriptMakasar UnicodeScript = 145
	// UnicodeScriptMedefaidrin: medefaidrin. Since: 2.58
	UnicodeScriptMedefaidrin UnicodeScript = 146
	// UnicodeScriptOldSogdian: old Sogdian. Since: 2.58
	UnicodeScriptOldSogdian UnicodeScript = 147
	// UnicodeScriptSogdian: sogdian. Since: 2.58
	UnicodeScriptSogdian UnicodeScript = 148
	// UnicodeScriptElymaic: elym. Since: 2.62
	UnicodeScriptElymaic UnicodeScript = 149
	// UnicodeScriptNandinagari: nand. Since: 2.62
	UnicodeScriptNandinagari UnicodeScript = 150
	// UnicodeScriptNyiakengPuachueHmong: rohg. Since: 2.62
	UnicodeScriptNyiakengPuachueHmong UnicodeScript = 151
	// UnicodeScriptWancho: wcho. Since: 2.62
	UnicodeScriptWancho UnicodeScript = 152
	// UnicodeScriptChorasmian: chorasmian. Since: 2.66
	UnicodeScriptChorasmian UnicodeScript = 153
	// UnicodeScriptDivesAkuru dives Akuru. Since: 2.66
	UnicodeScriptDivesAkuru UnicodeScript = 154
	// UnicodeScriptKhitanSmallScript: khitan small script. Since: 2.66
	UnicodeScriptKhitanSmallScript UnicodeScript = 155
	// UnicodeScriptYezidi: yezidi. Since: 2.66
	UnicodeScriptYezidi UnicodeScript = 156
)

// UnicodeType: these are the possible character classifications from the
// Unicode specification. See Unicode Character Database
// (http://www.unicode.org/reports/tr44/Category_Values).
type UnicodeType int

const (
	// UnicodeTypeControl: general category "Other, Control" (Cc)
	UnicodeTypeControl UnicodeType = 0
	// UnicodeTypeFormat: general category "Other, Format" (Cf)
	UnicodeTypeFormat UnicodeType = 1
	// UnicodeTypeUnassigned: general category "Other, Not Assigned" (Cn)
	UnicodeTypeUnassigned UnicodeType = 2
	// UnicodeTypePrivateUse: general category "Other, Private Use" (Co)
	UnicodeTypePrivateUse UnicodeType = 3
	// UnicodeTypeSurrogate: general category "Other, Surrogate" (Cs)
	UnicodeTypeSurrogate UnicodeType = 4
	// UnicodeTypeLowercaseLetter: general category "Letter, Lowercase" (Ll)
	UnicodeTypeLowercaseLetter UnicodeType = 5
	// UnicodeTypeModifierLetter: general category "Letter, Modifier" (Lm)
	UnicodeTypeModifierLetter UnicodeType = 6
	// UnicodeTypeOtherLetter: general category "Letter, Other" (Lo)
	UnicodeTypeOtherLetter UnicodeType = 7
	// UnicodeTypeTitlecaseLetter: general category "Letter, Titlecase" (Lt)
	UnicodeTypeTitlecaseLetter UnicodeType = 8
	// UnicodeTypeUppercaseLetter: general category "Letter, Uppercase" (Lu)
	UnicodeTypeUppercaseLetter UnicodeType = 9
	// UnicodeTypeSpacingMark: general category "Mark, Spacing" (Mc)
	UnicodeTypeSpacingMark UnicodeType = 10
	// UnicodeTypeEnclosingMark: general category "Mark, Enclosing" (Me)
	UnicodeTypeEnclosingMark UnicodeType = 11
	// UnicodeTypeNonSpacingMark: general category "Mark, Nonspacing" (Mn)
	UnicodeTypeNonSpacingMark UnicodeType = 12
	// UnicodeTypeDecimalNumber: general category "Number, Decimal Digit" (Nd)
	UnicodeTypeDecimalNumber UnicodeType = 13
	// UnicodeTypeLetterNumber: general category "Number, Letter" (Nl)
	UnicodeTypeLetterNumber UnicodeType = 14
	// UnicodeTypeOtherNumber: general category "Number, Other" (No)
	UnicodeTypeOtherNumber UnicodeType = 15
	// UnicodeTypeConnectPunctuation: general category "Punctuation, Connector"
	// (Pc)
	UnicodeTypeConnectPunctuation UnicodeType = 16
	// UnicodeTypeDashPunctuation: general category "Punctuation, Dash" (Pd)
	UnicodeTypeDashPunctuation UnicodeType = 17
	// UnicodeTypeClosePunctuation: general category "Punctuation, Close" (Pe)
	UnicodeTypeClosePunctuation UnicodeType = 18
	// UnicodeTypeFinalPunctuation: general category "Punctuation, Final quote"
	// (Pf)
	UnicodeTypeFinalPunctuation UnicodeType = 19
	// UnicodeTypeInitialPunctuation: general category "Punctuation, Initial
	// quote" (Pi)
	UnicodeTypeInitialPunctuation UnicodeType = 20
	// UnicodeTypeOtherPunctuation: general category "Punctuation, Other" (Po)
	UnicodeTypeOtherPunctuation UnicodeType = 21
	// UnicodeTypeOpenPunctuation: general category "Punctuation, Open" (Ps)
	UnicodeTypeOpenPunctuation UnicodeType = 22
	// UnicodeTypeCurrencySymbol: general category "Symbol, Currency" (Sc)
	UnicodeTypeCurrencySymbol UnicodeType = 23
	// UnicodeTypeModifierSymbol: general category "Symbol, Modifier" (Sk)
	UnicodeTypeModifierSymbol UnicodeType = 24
	// UnicodeTypeMathSymbol: general category "Symbol, Math" (Sm)
	UnicodeTypeMathSymbol UnicodeType = 25
	// UnicodeTypeOtherSymbol: general category "Symbol, Other" (So)
	UnicodeTypeOtherSymbol UnicodeType = 26
	// UnicodeTypeLineSeparator: general category "Separator, Line" (Zl)
	UnicodeTypeLineSeparator UnicodeType = 27
	// UnicodeTypeParagraphSeparator: general category "Separator, Paragraph"
	// (Zp)
	UnicodeTypeParagraphSeparator UnicodeType = 28
	// UnicodeTypeSpaceSeparator: general category "Separator, Space" (Zs)
	UnicodeTypeSpaceSeparator UnicodeType = 29
)

// URIError: error codes returned by #GUri methods.
type URIError int

const (
	// URIErrorFailed: generic error if no more specific error is available. See
	// the error message for details.
	URIErrorFailed URIError = 0
	// URIErrorBadScheme: the scheme of a URI could not be parsed.
	URIErrorBadScheme URIError = 1
	// URIErrorBadUser: the user/userinfo of a URI could not be parsed.
	URIErrorBadUser URIError = 2
	// URIErrorBadPassword: the password of a URI could not be parsed.
	URIErrorBadPassword URIError = 3
	// URIErrorBadAuthParams: the authentication parameters of a URI could not
	// be parsed.
	URIErrorBadAuthParams URIError = 4
	// URIErrorBadHost: the host of a URI could not be parsed.
	URIErrorBadHost URIError = 5
	// URIErrorBadPort: the port of a URI could not be parsed.
	URIErrorBadPort URIError = 6
	// URIErrorBadPath: the path of a URI could not be parsed.
	URIErrorBadPath URIError = 7
	// URIErrorBadQuery: the query of a URI could not be parsed.
	URIErrorBadQuery URIError = 8
	// URIErrorBadFragment: the fragment of a URI could not be parsed.
	URIErrorBadFragment URIError = 9
)

// UserDirectory: these are logical ids for special directories which are
// defined depending on the platform used. You should use
// g_get_user_special_dir() to retrieve the full path associated to the logical
// id.
//
// The Directory enumeration can be extended at later date. Not every platform
// has a directory for every logical id in this enumeration.
type UserDirectory int

const (
	// UserDirectoryDirectoryDesktop: the user's Desktop directory
	UserDirectoryDirectoryDesktop UserDirectory = 0
	// UserDirectoryDirectoryDocuments: the user's Documents directory
	UserDirectoryDirectoryDocuments UserDirectory = 1
	// UserDirectoryDirectoryDownload: the user's Downloads directory
	UserDirectoryDirectoryDownload UserDirectory = 2
	// UserDirectoryDirectoryMusic: the user's Music directory
	UserDirectoryDirectoryMusic UserDirectory = 3
	// UserDirectoryDirectoryPictures: the user's Pictures directory
	UserDirectoryDirectoryPictures UserDirectory = 4
	// UserDirectoryDirectoryPublicShare: the user's shared directory
	UserDirectoryDirectoryPublicShare UserDirectory = 5
	// UserDirectoryDirectoryTemplates: the user's Templates directory
	UserDirectoryDirectoryTemplates UserDirectory = 6
	// UserDirectoryDirectoryVideos: the user's Movies directory
	UserDirectoryDirectoryVideos UserDirectory = 7
	// UserDirectoryNDirectories: the number of enum values
	UserDirectoryNDirectories UserDirectory = 8
)

// VariantClass: the range of possible top-level types of #GVariant instances.
type VariantClass int

const (
	// VariantClassBoolean: the #GVariant is a boolean.
	VariantClassBoolean VariantClass = 98
	// VariantClassByte: the #GVariant is a byte.
	VariantClassByte VariantClass = 121
	// VariantClassInt16: the #GVariant is a signed 16 bit integer.
	VariantClassInt16 VariantClass = 110
	// VariantClassUint16: the #GVariant is an unsigned 16 bit integer.
	VariantClassUint16 VariantClass = 113
	// VariantClassInt32: the #GVariant is a signed 32 bit integer.
	VariantClassInt32 VariantClass = 105
	// VariantClassUint32: the #GVariant is an unsigned 32 bit integer.
	VariantClassUint32 VariantClass = 117
	// VariantClassInt64: the #GVariant is a signed 64 bit integer.
	VariantClassInt64 VariantClass = 120
	// VariantClassUint64: the #GVariant is an unsigned 64 bit integer.
	VariantClassUint64 VariantClass = 116
	// VariantClassHandle: the #GVariant is a file handle index.
	VariantClassHandle VariantClass = 104
	// VariantClassDouble: the #GVariant is a double precision floating point
	// value.
	VariantClassDouble VariantClass = 100
	// VariantClassString: the #GVariant is a normal string.
	VariantClassString VariantClass = 115
	// VariantClassObjectPath: the #GVariant is a D-Bus object path string.
	VariantClassObjectPath VariantClass = 111
	// VariantClassSignature: the #GVariant is a D-Bus signature string.
	VariantClassSignature VariantClass = 103
	// VariantClassVariant: the #GVariant is a variant.
	VariantClassVariant VariantClass = 118
	// VariantClassMaybe: the #GVariant is a maybe-typed value.
	VariantClassMaybe VariantClass = 109
	// VariantClassArray: the #GVariant is an array.
	VariantClassArray VariantClass = 97
	// VariantClassTuple: the #GVariant is a tuple.
	VariantClassTuple VariantClass = 40
	// VariantClassDictEntry: the #GVariant is a dictionary entry.
	VariantClassDictEntry VariantClass = 123
)

// VariantParseError: error codes returned by parsing text-format GVariants.
type VariantParseError int

const (
	// VariantParseErrorFailed: generic error (unused)
	VariantParseErrorFailed VariantParseError = 0
	// VariantParseErrorBasicTypeExpected: a non-basic Type was given where a
	// basic type was expected
	VariantParseErrorBasicTypeExpected VariantParseError = 1
	// VariantParseErrorCannotInferType: cannot infer the Type
	VariantParseErrorCannotInferType VariantParseError = 2
	// VariantParseErrorDefiniteTypeExpected: an indefinite Type was given where
	// a definite type was expected
	VariantParseErrorDefiniteTypeExpected VariantParseError = 3
	// VariantParseErrorInputNotAtEnd: extra data after parsing finished
	VariantParseErrorInputNotAtEnd VariantParseError = 4
	// VariantParseErrorInvalidCharacter: invalid character in number or unicode
	// escape
	VariantParseErrorInvalidCharacter VariantParseError = 5
	// VariantParseErrorInvalidFormatString: not a valid #GVariant format string
	VariantParseErrorInvalidFormatString VariantParseError = 6
	// VariantParseErrorInvalidObjectPath: not a valid object path
	VariantParseErrorInvalidObjectPath VariantParseError = 7
	// VariantParseErrorInvalidSignature: not a valid type signature
	VariantParseErrorInvalidSignature VariantParseError = 8
	// VariantParseErrorInvalidTypeString: not a valid #GVariant type string
	VariantParseErrorInvalidTypeString VariantParseError = 9
	// VariantParseErrorNoCommonType: could not find a common type for array
	// entries
	VariantParseErrorNoCommonType VariantParseError = 10
	// VariantParseErrorNumberOutOfRange: the numerical value is out of range of
	// the given type
	VariantParseErrorNumberOutOfRange VariantParseError = 11
	// VariantParseErrorNumberTooBig: the numerical value is out of range for
	// any type
	VariantParseErrorNumberTooBig VariantParseError = 12
	// VariantParseErrorTypeError: cannot parse as variant of the specified type
	VariantParseErrorTypeError VariantParseError = 13
	// VariantParseErrorUnexpectedToken: an unexpected token was encountered
	VariantParseErrorUnexpectedToken VariantParseError = 14
	// VariantParseErrorUnknownKeyword: an unknown keyword was encountered
	VariantParseErrorUnknownKeyword VariantParseError = 15
	// VariantParseErrorUnterminatedStringConstant: unterminated string constant
	VariantParseErrorUnterminatedStringConstant VariantParseError = 16
	// VariantParseErrorValueExpected: no value given
	VariantParseErrorValueExpected VariantParseError = 17
	// VariantParseErrorRecursion: variant was too deeply nested; #GVariant is
	// only guaranteed to handle nesting up to 64 levels (Since: 2.64)
	VariantParseErrorRecursion VariantParseError = 18
)

// FileSetContentsFlags flags to pass to g_file_set_contents_full() to affect
// its safety and performance.
type FileSetContentsFlags int

const (
	// FileSetContentsFlagsNone: no guarantees about file consistency or
	// durability. The most dangerous setting, which is slightly faster than
	// other settings.
	FileSetContentsFlagsNone FileSetContentsFlags = 0
	// FileSetContentsFlagsConsistent: guarantee file consistency: after a
	// crash, either the old version of the file or the new version of the file
	// will be available, but not a mixture. On Unix systems this equates to an
	// `fsync()` on the file and use of an atomic `rename()` of the new version
	// of the file over the old.
	FileSetContentsFlagsConsistent FileSetContentsFlags = 1
	// FileSetContentsFlagsDurable: guarantee file durability: after a crash,
	// the new version of the file will be available. On Unix systems this
	// equates to an `fsync()` on the file (if G_FILE_SET_CONTENTS_CONSISTENT is
	// unset), or the effects of G_FILE_SET_CONTENTS_CONSISTENT plus an
	// `fsync()` on the directory containing the file after calling `rename()`.
	FileSetContentsFlagsDurable FileSetContentsFlags = 2
	// FileSetContentsFlagsOnlyExisting: only apply consistency and durability
	// guarantees if the file already exists. This may speed up file operations
	// if the file doesn’t currently exist, but may result in a corrupted
	// version of the new file if the system crashes while writing it.
	FileSetContentsFlagsOnlyExisting FileSetContentsFlags = 4
)

// FileTest: a test to perform on a file using g_file_test().
type FileTest int

const (
	// FileTestIsRegular: true if the file is a regular file (not a directory).
	// Note that this test will also return true if the tested file is a symlink
	// to a regular file.
	FileTestIsRegular FileTest = 1
	// FileTestIsSymlink: true if the file is a symlink.
	FileTestIsSymlink FileTest = 2
	// FileTestIsDir: true if the file is a directory.
	FileTestIsDir FileTest = 4
	// FileTestIsExecutable: true if the file is executable.
	FileTestIsExecutable FileTest = 8
	// FileTestExists: true if the file exists. It may or may not be a regular
	// file.
	FileTestExists FileTest = 16
)

// FormatSizeFlags flags to modify the format of the string returned by
// g_format_size_full().
type FormatSizeFlags int

const (
	// FormatSizeFlagsDefault: behave the same as g_format_size()
	FormatSizeFlagsDefault FormatSizeFlags = 0
	// FormatSizeFlagsLongFormat: include the exact number of bytes as part of
	// the returned string. For example, "45.6 kB (45,612 bytes)".
	FormatSizeFlagsLongFormat FormatSizeFlags = 1
	// FormatSizeFlagsIecUnits: use IEC (base 1024) units with "KiB"-style
	// suffixes. IEC units should only be used for reporting things with a
	// strong "power of 2" basis, like RAM sizes or RAID stripe sizes. Network
	// and storage sizes should be reported in the normal SI units.
	FormatSizeFlagsIecUnits FormatSizeFlags = 2
	// FormatSizeFlagsBits: set the size as a quantity in bits, rather than
	// bytes, and return units in bits. For example, ‘Mb’ rather than ‘MB’.
	FormatSizeFlagsBits FormatSizeFlags = 4
)

// IOCondition: a bitwise combination representing a condition to watch for on
// an event source.
type IOCondition int

const (
	// IOConditionIn: there is data to read.
	IOConditionIn IOCondition = 1
	// IOConditionOut: data can be written (without blocking).
	IOConditionOut IOCondition = 4
	// IOConditionPri: there is urgent data to read.
	IOConditionPri IOCondition = 2
	// IOConditionErr: error condition.
	IOConditionErr IOCondition = 8
	// IOConditionHup: hung up (the connection has been broken, usually for
	// pipes and sockets).
	IOConditionHup IOCondition = 16
	// IOConditionNval: invalid request. The file descriptor is not open.
	IOConditionNval IOCondition = 32
)

func marshalIOCondition(p uintptr) (interface{}, error) {
	return IOCondition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IOFlags specifies properties of a OChannel. Some of the flags can only be
// read with g_io_channel_get_flags(), but not changed with
// g_io_channel_set_flags().
type IOFlags int

const (
	// IOFlagsAppend turns on append mode, corresponds to O_APPEND (see the
	// documentation of the UNIX open() syscall)
	IOFlagsAppend IOFlags = 1
	// IOFlagsNonblock turns on nonblocking mode, corresponds to
	// O_NONBLOCK/O_NDELAY (see the documentation of the UNIX open() syscall)
	IOFlagsNonblock IOFlags = 2
	// IOFlagsIsReadable indicates that the io channel is readable. This flag
	// cannot be changed.
	IOFlagsIsReadable IOFlags = 4
	// IOFlagsIsWritable indicates that the io channel is writable. This flag
	// cannot be changed.
	IOFlagsIsWritable IOFlags = 8
	// IOFlagsIsWriteable: a misspelled version of @G_IO_FLAG_IS_WRITABLE that
	// existed before the spelling was fixed in GLib 2.30. It is kept here for
	// compatibility reasons. Deprecated since 2.30
	IOFlagsIsWriteable IOFlags = 8
	// IOFlagsIsSeekable indicates that the io channel is seekable, i.e. that
	// g_io_channel_seek_position() can be used on it. This flag cannot be
	// changed.
	IOFlagsIsSeekable IOFlags = 16
	// IOFlagsMask: the mask that specifies all the valid flags.
	IOFlagsMask IOFlags = 31
	// IOFlagsGetMask: the mask of the flags that are returned from
	// g_io_channel_get_flags()
	IOFlagsGetMask IOFlags = 31
	// IOFlagsSetMask: the mask of the flags that the user can modify with
	// g_io_channel_set_flags()
	IOFlagsSetMask IOFlags = 3
)

// KeyFileFlags flags which influence the parsing.
type KeyFileFlags int

const (
	// KeyFileFlagsNone: no flags, default behaviour
	KeyFileFlagsNone KeyFileFlags = 0
	// KeyFileFlagsKeepComments: use this flag if you plan to write the
	// (possibly modified) contents of the key file back to a file; otherwise
	// all comments will be lost when the key file is written back.
	KeyFileFlagsKeepComments KeyFileFlags = 1
	// KeyFileFlagsKeepTranslations: use this flag if you plan to write the
	// (possibly modified) contents of the key file back to a file; otherwise
	// only the translations for the current language will be written back.
	KeyFileFlagsKeepTranslations KeyFileFlags = 2
)

// LogLevelFlags flags specifying the level of log messages.
//
// It is possible to change how GLib treats messages of the various levels using
// g_log_set_handler() and g_log_set_fatal_mask().
type LogLevelFlags int

const (
	// LogLevelFlagsFlagRecursion: internal flag
	LogLevelFlagsFlagRecursion LogLevelFlags = 1
	// LogLevelFlagsFlagFatal: internal flag
	LogLevelFlagsFlagFatal LogLevelFlags = 2
	// LogLevelFlagsLevelError: log level for errors, see g_error(). This level
	// is also used for messages produced by g_assert().
	LogLevelFlagsLevelError LogLevelFlags = 4
	// LogLevelFlagsLevelCritical: log level for critical warning messages, see
	// g_critical(). This level is also used for messages produced by
	// g_return_if_fail() and g_return_val_if_fail().
	LogLevelFlagsLevelCritical LogLevelFlags = 8
	// LogLevelFlagsLevelWarning: log level for warnings, see g_warning()
	LogLevelFlagsLevelWarning LogLevelFlags = 16
	// LogLevelFlagsLevelMessage: log level for messages, see g_message()
	LogLevelFlagsLevelMessage LogLevelFlags = 32
	// LogLevelFlagsLevelInfo: log level for informational messages, see
	// g_info()
	LogLevelFlagsLevelInfo LogLevelFlags = 64
	// LogLevelFlagsLevelDebug: log level for debug messages, see g_debug()
	LogLevelFlagsLevelDebug LogLevelFlags = 128
	// LogLevelFlagsLevelMask: a mask including all log levels
	LogLevelFlagsLevelMask LogLevelFlags = -4
)

// MarkupCollectType: a mixed enumerated type and flags field. You must specify
// one type (string, strdup, boolean, tristate). Additionally, you may
// optionally bitwise OR the type with the flag G_MARKUP_COLLECT_OPTIONAL.
//
// It is likely that this enum will be extended in the future to support other
// types.
type MarkupCollectType int

const (
	// MarkupCollectTypeInvalid: used to terminate the list of attributes to
	// collect
	MarkupCollectTypeInvalid MarkupCollectType = 0
	// MarkupCollectTypeString: collect the string pointer directly from the
	// attribute_values[] array. Expects a parameter of type (const char **). If
	// G_MARKUP_COLLECT_OPTIONAL is specified and the attribute isn't present
	// then the pointer will be set to nil
	MarkupCollectTypeString MarkupCollectType = 1
	// MarkupCollectTypeStrdup as with G_MARKUP_COLLECT_STRING, but expects a
	// parameter of type (char **) and g_strdup()s the returned pointer. The
	// pointer must be freed with g_free()
	MarkupCollectTypeStrdup MarkupCollectType = 2
	// MarkupCollectTypeBoolean expects a parameter of type (gboolean *) and
	// parses the attribute value as a boolean. Sets false if the attribute
	// isn't present. Valid boolean values consist of (case-insensitive)
	// "false", "f", "no", "n", "0" and "true", "t", "yes", "y", "1"
	MarkupCollectTypeBoolean MarkupCollectType = 3
	// MarkupCollectTypeTristate as with G_MARKUP_COLLECT_BOOLEAN, but in the
	// case of a missing attribute a value is set that compares equal to neither
	// false nor true G_MARKUP_COLLECT_OPTIONAL is implied
	MarkupCollectTypeTristate MarkupCollectType = 4
	// MarkupCollectTypeOptional: can be bitwise ORed with the other fields. If
	// present, allows the attribute not to appear. A default value is set
	// depending on what value type is used
	MarkupCollectTypeOptional MarkupCollectType = 65536
)

// MarkupParseFlags flags that affect the behaviour of the parser.
type MarkupParseFlags int

const (
	// MarkupParseFlagsDoNotUseThisUnsupportedFlag: flag you should not use
	MarkupParseFlagsDoNotUseThisUnsupportedFlag MarkupParseFlags = 1
	// MarkupParseFlagsTreatCdataAsText: when this flag is set, CDATA marked
	// sections are not passed literally to the @passthrough function of the
	// parser. Instead, the content of the section (without the `<![CDATA[` and
	// `]]>`) is passed to the @text function. This flag was added in GLib 2.12
	MarkupParseFlagsTreatCdataAsText MarkupParseFlags = 2
	// MarkupParseFlagsPrefixErrorPosition: normally errors caught by GMarkup
	// itself have line/column information prefixed to them to let the caller
	// know the location of the error. When this flag is set the location
	// information is also prefixed to errors generated by the Parser
	// implementation functions
	MarkupParseFlagsPrefixErrorPosition MarkupParseFlags = 4
	// MarkupParseFlagsIgnoreQualified: ignore (don't report) qualified
	// attributes and tags, along with their contents. A qualified attribute or
	// tag is one that contains ':' in its name (ie: is in another namespace).
	// Since: 2.40.
	MarkupParseFlagsIgnoreQualified MarkupParseFlags = 8
)

// OptionFlags flags which modify individual options.
type OptionFlags int

const (
	// OptionFlagsNone: no flags. Since: 2.42.
	OptionFlagsNone OptionFlags = 0
	// OptionFlagsHidden: the option doesn't appear in `--help` output.
	OptionFlagsHidden OptionFlags = 1
	// OptionFlagsInMain: the option appears in the main section of the `--help`
	// output, even if it is defined in a group.
	OptionFlagsInMain OptionFlags = 2
	// OptionFlagsReverse: for options of the G_OPTION_ARG_NONE kind, this flag
	// indicates that the sense of the option is reversed.
	OptionFlagsReverse OptionFlags = 4
	// OptionFlagsNoArg: for options of the G_OPTION_ARG_CALLBACK kind, this
	// flag indicates that the callback does not take any argument (like a
	// G_OPTION_ARG_NONE option). Since 2.8
	OptionFlagsNoArg OptionFlags = 8
	// OptionFlagsFilename: for options of the G_OPTION_ARG_CALLBACK kind, this
	// flag indicates that the argument should be passed to the callback in the
	// GLib filename encoding rather than UTF-8. Since 2.8
	OptionFlagsFilename OptionFlags = 16
	// OptionFlagsOptionalArg: for options of the G_OPTION_ARG_CALLBACK kind,
	// this flag indicates that the argument supply is optional. If no argument
	// is given then data of GOptionParseFunc will be set to NULL. Since 2.8
	OptionFlagsOptionalArg OptionFlags = 32
	// OptionFlagsNoalias: this flag turns off the automatic conflict resolution
	// which prefixes long option names with `groupname-` if there is a
	// conflict. This option should only be used in situations where aliasing is
	// necessary to model some legacy commandline interface. It is not safe to
	// use this option, unless all option groups are under your direct control.
	// Since 2.8.
	OptionFlagsNoalias OptionFlags = 64
)

// RegexCompileFlags flags specifying compile-time options.
type RegexCompileFlags int

const (
	// RegexCompileFlagsCaseless letters in the pattern match both upper- and
	// lowercase letters. This option can be changed within a pattern by a
	// "(?i)" option setting.
	RegexCompileFlagsCaseless RegexCompileFlags = 1
	// RegexCompileFlagsMultiline: by default, GRegex treats the strings as
	// consisting of a single line of characters (even if it actually contains
	// newlines). The "start of line" metacharacter ("^") matches only at the
	// start of the string, while the "end of line" metacharacter ("$") matches
	// only at the end of the string, or before a terminating newline (unless
	// REGEX_DOLLAR_ENDONLY is set). When REGEX_MULTILINE is set, the "start of
	// line" and "end of line" constructs match immediately following or
	// immediately before any newline in the string, respectively, as well as at
	// the very start and end. This can be changed within a pattern by a "(?m)"
	// option setting.
	RegexCompileFlagsMultiline RegexCompileFlags = 2
	// RegexCompileFlagsDotall: a dot metacharacter (".") in the pattern matches
	// all characters, including newlines. Without it, newlines are excluded.
	// This option can be changed within a pattern by a ("?s") option setting.
	RegexCompileFlagsDotall RegexCompileFlags = 4
	// RegexCompileFlagsExtended: whitespace data characters in the pattern are
	// totally ignored except when escaped or inside a character class.
	// Whitespace does not include the VT character (code 11). In addition,
	// characters between an unescaped "#" outside a character class and the
	// next newline character, inclusive, are also ignored. This can be changed
	// within a pattern by a "(?x)" option setting.
	RegexCompileFlagsExtended RegexCompileFlags = 8
	// RegexCompileFlagsAnchored: the pattern is forced to be "anchored", that
	// is, it is constrained to match only at the first matching point in the
	// string that is being searched. This effect can also be achieved by
	// appropriate constructs in the pattern itself such as the "^"
	// metacharacter.
	RegexCompileFlagsAnchored RegexCompileFlags = 16
	// RegexCompileFlagsDollarEndonly: a dollar metacharacter ("$") in the
	// pattern matches only at the end of the string. Without this option, a
	// dollar also matches immediately before the final character if it is a
	// newline (but not before any other newlines). This option is ignored if
	// REGEX_MULTILINE is set.
	RegexCompileFlagsDollarEndonly RegexCompileFlags = 32
	// RegexCompileFlagsUngreedy inverts the "greediness" of the quantifiers so
	// that they are not greedy by default, but become greedy if followed by
	// "?". It can also be set by a "(?U)" option setting within the pattern.
	RegexCompileFlagsUngreedy RegexCompileFlags = 512
	// RegexCompileFlagsRaw: usually strings must be valid UTF-8 strings, using
	// this flag they are considered as a raw sequence of bytes.
	RegexCompileFlagsRaw RegexCompileFlags = 2048
	// RegexCompileFlagsNoAutoCapture disables the use of numbered capturing
	// parentheses in the pattern. Any opening parenthesis that is not followed
	// by "?" behaves as if it were followed by "?:" but named parentheses can
	// still be used for capturing (and they acquire numbers in the usual way).
	RegexCompileFlagsNoAutoCapture RegexCompileFlags = 4096
	// RegexCompileFlagsOptimize: optimize the regular expression. If the
	// pattern will be used many times, then it may be worth the effort to
	// optimize it to improve the speed of matches.
	RegexCompileFlagsOptimize RegexCompileFlags = 8192
	// RegexCompileFlagsFirstline limits an unanchored pattern to match before
	// (or at) the first newline. Since: 2.34
	RegexCompileFlagsFirstline RegexCompileFlags = 262144
	// RegexCompileFlagsDupnames names used to identify capturing subpatterns
	// need not be unique. This can be helpful for certain types of pattern when
	// it is known that only one instance of the named subpattern can ever be
	// matched.
	RegexCompileFlagsDupnames RegexCompileFlags = 524288
	// RegexCompileFlagsNewlineCr: usually any newline character or character
	// sequence is recognized. If this option is set, the only recognized
	// newline character is '\r'.
	RegexCompileFlagsNewlineCr RegexCompileFlags = 1048576
	// RegexCompileFlagsNewlineLf: usually any newline character or character
	// sequence is recognized. If this option is set, the only recognized
	// newline character is '\n'.
	RegexCompileFlagsNewlineLf RegexCompileFlags = 2097152
	// RegexCompileFlagsNewlineCrlf: usually any newline character or character
	// sequence is recognized. If this option is set, the only recognized
	// newline character sequence is '\r\n'.
	RegexCompileFlagsNewlineCrlf RegexCompileFlags = 3145728
	// RegexCompileFlagsNewlineAnycrlf: usually any newline character or
	// character sequence is recognized. If this option is set, the only
	// recognized newline character sequences are '\r', '\n', and '\r\n'. Since:
	// 2.34
	RegexCompileFlagsNewlineAnycrlf RegexCompileFlags = 5242880
	// RegexCompileFlagsBsrAnycrlf: usually any newline character or character
	// sequence is recognised. If this option is set, then "\R" only recognizes
	// the newline characters '\r', '\n' and '\r\n'. Since: 2.34
	RegexCompileFlagsBsrAnycrlf RegexCompileFlags = 8388608
	// RegexCompileFlagsJavascriptCompat changes behaviour so that it is
	// compatible with JavaScript rather than PCRE. Since: 2.34
	RegexCompileFlagsJavascriptCompat RegexCompileFlags = 33554432
)

// RegexMatchFlags flags specifying match-time options.
type RegexMatchFlags int

const (
	// RegexMatchFlagsAnchored: the pattern is forced to be "anchored", that is,
	// it is constrained to match only at the first matching point in the string
	// that is being searched. This effect can also be achieved by appropriate
	// constructs in the pattern itself such as the "^" metacharacter.
	RegexMatchFlagsAnchored RegexMatchFlags = 16
	// RegexMatchFlagsNotbol specifies that first character of the string is not
	// the beginning of a line, so the circumflex metacharacter should not match
	// before it. Setting this without REGEX_MULTILINE (at compile time) causes
	// circumflex never to match. This option affects only the behaviour of the
	// circumflex metacharacter, it does not affect "\A".
	RegexMatchFlagsNotbol RegexMatchFlags = 128
	// RegexMatchFlagsNoteol specifies that the end of the subject string is not
	// the end of a line, so the dollar metacharacter should not match it nor
	// (except in multiline mode) a newline immediately before it. Setting this
	// without REGEX_MULTILINE (at compile time) causes dollar never to match.
	// This option affects only the behaviour of the dollar metacharacter, it
	// does not affect "\Z" or "\z".
	RegexMatchFlagsNoteol RegexMatchFlags = 256
	// RegexMatchFlagsNotempty: an empty string is not considered to be a valid
	// match if this option is set. If there are alternatives in the pattern,
	// they are tried. If all the alternatives match the empty string, the
	// entire match fails. For example, if the pattern "a?b?" is applied to a
	// string not beginning with "a" or "b", it matches the empty string at the
	// start of the string. With this flag set, this match is not valid, so
	// GRegex searches further into the string for occurrences of "a" or "b".
	RegexMatchFlagsNotempty RegexMatchFlags = 1024
	// RegexMatchFlagsPartial turns on the partial matching feature, for more
	// documentation on partial matching see g_match_info_is_partial_match().
	RegexMatchFlagsPartial RegexMatchFlags = 32768
	// RegexMatchFlagsNewlineCr overrides the newline definition set when
	// creating a new #GRegex, setting the '\r' character as line terminator.
	RegexMatchFlagsNewlineCr RegexMatchFlags = 1048576
	// RegexMatchFlagsNewlineLf overrides the newline definition set when
	// creating a new #GRegex, setting the '\n' character as line terminator.
	RegexMatchFlagsNewlineLf RegexMatchFlags = 2097152
	// RegexMatchFlagsNewlineCrlf overrides the newline definition set when
	// creating a new #GRegex, setting the '\r\n' characters sequence as line
	// terminator.
	RegexMatchFlagsNewlineCrlf RegexMatchFlags = 3145728
	// RegexMatchFlagsNewlineAny overrides the newline definition set when
	// creating a new #GRegex, any Unicode newline sequence is recognised as a
	// newline. These are '\r', '\n' and '\rn', and the single characters U+000B
	// LINE TABULATION, U+000C FORM FEED (FF), U+0085 NEXT LINE (NEL), U+2028
	// LINE SEPARATOR and U+2029 PARAGRAPH SEPARATOR.
	RegexMatchFlagsNewlineAny RegexMatchFlags = 4194304
	// RegexMatchFlagsNewlineAnycrlf overrides the newline definition set when
	// creating a new #GRegex; any '\r', '\n', or '\r\n' character sequence is
	// recognized as a newline. Since: 2.34
	RegexMatchFlagsNewlineAnycrlf RegexMatchFlags = 5242880
	// RegexMatchFlagsBsrAnycrlf overrides the newline definition for "\R" set
	// when creating a new #GRegex; only '\r', '\n', or '\r\n' character
	// sequences are recognized as a newline by "\R". Since: 2.34
	RegexMatchFlagsBsrAnycrlf RegexMatchFlags = 8388608
	// RegexMatchFlagsBsrAny overrides the newline definition for "\R" set when
	// creating a new #GRegex; any Unicode newline character or character
	// sequence are recognized as a newline by "\R". These are '\r', '\n' and
	// '\rn', and the single characters U+000B LINE TABULATION, U+000C FORM FEED
	// (FF), U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and U+2029 PARAGRAPH
	// SEPARATOR. Since: 2.34
	RegexMatchFlagsBsrAny RegexMatchFlags = 16777216
	// RegexMatchFlagsPartialSoft: an alias for REGEX_MATCH_PARTIAL. Since: 2.34
	RegexMatchFlagsPartialSoft RegexMatchFlags = 32768
	// RegexMatchFlagsPartialHard turns on the partial matching feature. In
	// contrast to to REGEX_MATCH_PARTIAL_SOFT, this stops matching as soon as a
	// partial match is found, without continuing to search for a possible
	// complete match. See g_match_info_is_partial_match() for more information.
	// Since: 2.34
	RegexMatchFlagsPartialHard RegexMatchFlags = 134217728
	// RegexMatchFlagsNotemptyAtstart: like REGEX_MATCH_NOTEMPTY, but only
	// applied to the start of the matched string. For anchored patterns this
	// can only happen for pattern containing "\K". Since: 2.34
	RegexMatchFlagsNotemptyAtstart RegexMatchFlags = 268435456
)

// SpawnFlags flags passed to g_spawn_sync(), g_spawn_async() and
// g_spawn_async_with_pipes().
type SpawnFlags int

const (
	// SpawnFlagsDefault: no flags, default behaviour
	SpawnFlagsDefault SpawnFlags = 0
	// SpawnFlagsLeaveDescriptorsOpen: the parent's open file descriptors will
	// be inherited by the child; otherwise all descriptors except stdin, stdout
	// and stderr will be closed before calling exec() in the child.
	SpawnFlagsLeaveDescriptorsOpen SpawnFlags = 1
	// SpawnFlagsDoNotReapChild: the child will not be automatically reaped; you
	// must use g_child_watch_add() yourself (or call waitpid() or handle
	// `SIGCHLD` yourself), or the child will become a zombie.
	SpawnFlagsDoNotReapChild SpawnFlags = 2
	// SpawnFlagsSearchPath: `argv[0]` need not be an absolute path, it will be
	// looked for in the user's `PATH`.
	SpawnFlagsSearchPath SpawnFlags = 4
	// SpawnFlagsStdoutToDevNull: the child's standard output will be discarded,
	// instead of going to the same location as the parent's standard output.
	SpawnFlagsStdoutToDevNull SpawnFlags = 8
	// SpawnFlagsStderrToDevNull: the child's standard error will be discarded.
	SpawnFlagsStderrToDevNull SpawnFlags = 16
	// SpawnFlagsChildInheritsStdin: the child will inherit the parent's
	// standard input (by default, the child's standard input is attached to
	// `/dev/null`).
	SpawnFlagsChildInheritsStdin SpawnFlags = 32
	// SpawnFlagsFileAndArgvZero: the first element of `argv` is the file to
	// execute, while the remaining elements are the actual argument vector to
	// pass to the file. Normally g_spawn_async_with_pipes() uses `argv[0]` as
	// the file to execute, and passes all of `argv` to the child.
	SpawnFlagsFileAndArgvZero SpawnFlags = 64
	// SpawnFlagsSearchPathFromEnvp: if `argv[0]` is not an absolute path, it
	// will be looked for in the `PATH` from the passed child environment.
	// Since: 2.34
	SpawnFlagsSearchPathFromEnvp SpawnFlags = 128
	// SpawnFlagsCloexecPipes: create all pipes with the `O_CLOEXEC` flag set.
	// Since: 2.40
	SpawnFlagsCloexecPipes SpawnFlags = 256
)

// TraverseFlags specifies which nodes are visited during several of the tree
// functions, including g_node_traverse() and g_node_find().
type TraverseFlags int

const (
	// TraverseFlagsLeaves: only leaf nodes should be visited. This name has
	// been introduced in 2.6, for older version use G_TRAVERSE_LEAFS.
	TraverseFlagsLeaves TraverseFlags = 1
	// TraverseFlagsNonLeaves: only non-leaf nodes should be visited. This name
	// has been introduced in 2.6, for older version use G_TRAVERSE_NON_LEAFS.
	TraverseFlagsNonLeaves TraverseFlags = 2
	// TraverseFlagsAll: all nodes should be visited.
	TraverseFlagsAll TraverseFlags = 3
	// TraverseFlagsMask: a mask of all traverse flags.
	TraverseFlagsMask TraverseFlags = 3
	// TraverseFlagsLeafs: identical to G_TRAVERSE_LEAVES.
	TraverseFlagsLeafs TraverseFlags = 1
	// TraverseFlagsNonLeafs: identical to G_TRAVERSE_NON_LEAVES.
	TraverseFlagsNonLeafs TraverseFlags = 2
)

// URIFlags flags that describe a URI.
//
// When parsing a URI, if you need to choose different flags based on the type
// of URI, you can use g_uri_peek_scheme() on the URI string to check the scheme
// first, and use that to decide what flags to parse it with.
type URIFlags int

const (
	// URIFlagsNone: no flags set.
	URIFlagsNone URIFlags = 0
	// URIFlagsParseRelaxed: parse the URI more relaxedly than the RFC 3986
	// (https://tools.ietf.org/html/rfc3986) grammar specifies, fixing up or
	// ignoring common mistakes in URIs coming from external sources. This is
	// also needed for some obscure URI schemes where `;` separates the host
	// from the path. Don’t use this flag unless you need to.
	URIFlagsParseRelaxed URIFlags = 1
	// URIFlagsHasPassword: the userinfo field may contain a password, which
	// will be separated from the username by `:`.
	URIFlagsHasPassword URIFlags = 2
	// URIFlagsHasAuthParams: the userinfo may contain additional
	// authentication-related parameters, which will be separated from the
	// username and/or password by `;`.
	URIFlagsHasAuthParams URIFlags = 4
	// URIFlagsEncoded: when parsing a URI, this indicates that `%`-encoded
	// characters in the userinfo, path, query, and fragment fields should not
	// be decoded. (And likewise the host field if G_URI_FLAGS_NON_DNS is also
	// set.) When building a URI, it indicates that you have already `%`-encoded
	// the components, and so #GUri should not do any encoding itself.
	URIFlagsEncoded URIFlags = 8
	// URIFlagsNonDns: the host component should not be assumed to be a DNS
	// hostname or IP address (for example, for `smb` URIs with NetBIOS
	// hostnames).
	URIFlagsNonDns URIFlags = 16
	// URIFlagsEncodedQuery: same as G_URI_FLAGS_ENCODED, for the query field
	// only.
	URIFlagsEncodedQuery URIFlags = 32
	// URIFlagsEncodedPath: same as G_URI_FLAGS_ENCODED, for the path only.
	URIFlagsEncodedPath URIFlags = 64
	// URIFlagsEncodedFragment: same as G_URI_FLAGS_ENCODED, for the fragment
	// only.
	URIFlagsEncodedFragment URIFlags = 128
	// URIFlagsSchemeNormalize: a scheme-based normalization will be applied.
	// For example, when parsing an HTTP URI changing omitted path to `/` and
	// omitted port to `80`; and when building a URI, changing empty path to `/`
	// and default port `80`). This only supports a subset of known schemes.
	// (Since: 2.68)
	URIFlagsSchemeNormalize URIFlags = 256
)

// URIHideFlags flags describing what parts of the URI to hide in
// g_uri_to_string_partial(). Note that G_URI_HIDE_PASSWORD and
// G_URI_HIDE_AUTH_PARAMS will only work if the #GUri was parsed with the
// corresponding flags.
type URIHideFlags int

const (
	// URIHideFlagsNone: no flags set.
	URIHideFlagsNone URIHideFlags = 0
	// URIHideFlagsUserinfo: hide the userinfo.
	URIHideFlagsUserinfo URIHideFlags = 1
	// URIHideFlagsPassword: hide the password.
	URIHideFlagsPassword URIHideFlags = 2
	// URIHideFlagsAuthParams: hide the auth_params.
	URIHideFlagsAuthParams URIHideFlags = 4
	// URIHideFlagsQuery: hide the query.
	URIHideFlagsQuery URIHideFlags = 8
	// URIHideFlagsFragment: hide the fragment.
	URIHideFlagsFragment URIHideFlags = 16
)

// URIParamsFlags flags modifying the way parameters are handled by
// g_uri_parse_params() and ParamsIter.
type URIParamsFlags int

const (
	// URIParamsFlagsNone: no flags set.
	URIParamsFlagsNone URIParamsFlags = 0
	// URIParamsFlagsCaseInsensitive: parameter names are case insensitive.
	URIParamsFlagsCaseInsensitive URIParamsFlags = 1
	// URIParamsFlagsWwwForm: replace `+` with space character. Only useful for
	// URLs on the web, using the `https` or `http` schemas.
	URIParamsFlagsWwwForm URIParamsFlags = 2
	// URIParamsFlagsParseRelaxed: see G_URI_FLAGS_PARSE_RELAXED.
	URIParamsFlagsParseRelaxed URIParamsFlags = 4
)

func AssertWarning(logDomain string, file string, line int, prettyFunction string, expression string) {
	var _arg1 *C.char // out
	var _arg2 *C.char // out
	var _arg3 C.int   // out
	var _arg4 *C.char // out
	var _arg5 *C.char // out

	_arg1 = (*C.char)(C.CString(logDomain))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(C.CString(file))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.int)(line)
	_arg4 = (*C.char)(C.CString(prettyFunction))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.char)(C.CString(expression))
	defer C.free(unsafe.Pointer(_arg5))

	C.g_assert_warning(_arg1, _arg2, _arg3, _arg4, _arg5)
}

// Base64Encode: encode a sequence of binary data into its Base-64 stringified
// representation.
func Base64Encode(data []byte) string {
	var _arg1 *C.guchar
	var _arg2 C.gsize
	var _cret *C.gchar // in

	_arg2 = C.gsize(len(data))
	_arg1 = (*C.guchar)(unsafe.Pointer(&data[0]))

	_cret = C.g_base64_encode(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Basename gets the name of the file without any leading directory components.
// It returns a pointer into the given file name string.
func Basename(fileName string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_basename(_arg1)

	var _filename string // out

	_filename = C.GoString(_cret)

	return _filename
}

// BitNthLsf: find the position of the first bit set in @mask, searching from
// (but not including) @nth_bit upwards. Bits are numbered from 0 (least
// significant) to sizeof(#gulong) * 8 - 1 (31 or 63, usually). To start
// searching from the 0th bit, set @nth_bit to -1.
func BitNthLsf(mask uint32, nthBit int) int {
	var _arg1 C.gulong // out
	var _arg2 C.gint   // out
	var _cret C.gint   // in

	_arg1 = (C.gulong)(mask)
	_arg2 = (C.gint)(nthBit)

	_cret = C.g_bit_nth_lsf(_arg1, _arg2)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// BitNthMsf: find the position of the first bit set in @mask, searching from
// (but not including) @nth_bit downwards. Bits are numbered from 0 (least
// significant) to sizeof(#gulong) * 8 - 1 (31 or 63, usually). To start
// searching from the last bit, set @nth_bit to -1 or GLIB_SIZEOF_LONG * 8.
func BitNthMsf(mask uint32, nthBit int) int {
	var _arg1 C.gulong // out
	var _arg2 C.gint   // out
	var _cret C.gint   // in

	_arg1 = (C.gulong)(mask)
	_arg2 = (C.gint)(nthBit)

	_cret = C.g_bit_nth_msf(_arg1, _arg2)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// BitStorage gets the number of bits used to hold @number, e.g. if @number is
// 4, 3 bits are needed.
func BitStorage(number uint32) uint {
	var _arg1 C.gulong // out
	var _cret C.guint  // in

	_arg1 = (C.gulong)(number)

	_cret = C.g_bit_storage(_arg1)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// BuildFilenamev behaves exactly like g_build_filename(), but takes the path
// elements as a string array, instead of varargs. This function is mainly meant
// for language bindings.
func BuildFilenamev(args []string) string {
	var _arg1 **C.gchar
	var _cret *C.gchar // in

	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(args)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(args))
		for i := range args {
			out[i] = (*C.gchar)(C.CString(args[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.g_build_filenamev(_arg1)

	var _filename string // out

	_filename = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _filename
}

// BuildPathv behaves exactly like g_build_path(), but takes the path elements
// as a string array, instead of varargs. This function is mainly meant for
// language bindings.
func BuildPathv(separator string, args []string) string {
	var _arg1 *C.gchar // out
	var _arg2 **C.gchar
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(separator))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (**C.gchar)(C.malloc(C.ulong(len(args)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice(_arg2, len(args))
		for i := range args {
			out[i] = (*C.gchar)(C.CString(args[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.g_build_pathv(_arg1, _arg2)

	var _filename string // out

	_filename = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _filename
}

// CanonicalizeFilename gets the canonical file name from @filename. All triple
// slashes are turned into single slashes, and all `..` and `.`s resolved
// against @relative_to.
//
// Symlinks are not followed, and the returned path is guaranteed to be
// absolute.
//
// If @filename is an absolute path, @relative_to is ignored. Otherwise,
// @relative_to will be prepended to @filename to make it absolute. @relative_to
// must be an absolute path, or nil. If @relative_to is nil, it'll fallback to
// g_get_current_dir().
//
// This function never fails, and will canonicalize file paths even if they
// don't exist.
//
// No file system I/O is done.
func CanonicalizeFilename(filename string, relativeTo string) string {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(relativeTo))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_canonicalize_filename(_arg1, _arg2)

	var _ret string // out

	_ret = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _ret
}

// CheckVersion checks that the GLib library in use is compatible with the given
// version. Generally you would pass in the constants IB_MAJOR_VERSION,
// IB_MINOR_VERSION, IB_MICRO_VERSION as the three arguments to this function;
// that produces a check that the library in use is compatible with the version
// of GLib the application or module was compiled against.
//
// Compatibility is defined by two things: first the version of the running
// library is newer than the version
// @required_major.required_minor.@required_micro. Second the running library
// must be binary compatible with the version
// @required_major.required_minor.@required_micro (same major version.)
func CheckVersion(requiredMajor uint, requiredMinor uint, requiredMicro uint) string {
	var _arg1 C.guint  // out
	var _arg2 C.guint  // out
	var _arg3 C.guint  // out
	var _cret *C.gchar // in

	_arg1 = (C.guint)(requiredMajor)
	_arg2 = (C.guint)(requiredMinor)
	_arg3 = (C.guint)(requiredMicro)

	_cret = C.glib_check_version(_arg1, _arg2, _arg3)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// ComputeChecksumForData computes the checksum for a binary @data of @length.
// This is a convenience wrapper for g_checksum_new(), g_checksum_get_string()
// and g_checksum_free().
//
// The hexadecimal string returned will be in lower case.
func ComputeChecksumForData(checksumType ChecksumType, data []byte) string {
	var _arg1 C.GChecksumType // out
	var _arg2 *C.guchar
	var _arg3 C.gsize
	var _cret *C.gchar // in

	_arg1 = (C.GChecksumType)(checksumType)
	_arg3 = C.gsize(len(data))
	_arg2 = (*C.guchar)(unsafe.Pointer(&data[0]))

	_cret = C.g_compute_checksum_for_data(_arg1, _arg2, _arg3)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ComputeChecksumForString computes the checksum of a string.
//
// The hexadecimal string returned will be in lower case.
func ComputeChecksumForString(checksumType ChecksumType, str string, length int) string {
	var _arg1 C.GChecksumType // out
	var _arg2 *C.gchar        // out
	var _arg3 C.gssize        // out
	var _cret *C.gchar        // in

	_arg1 = (C.GChecksumType)(checksumType)
	_arg2 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.gssize)(length)

	_cret = C.g_compute_checksum_for_string(_arg1, _arg2, _arg3)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ComputeHMACForData computes the HMAC for a binary @data of @length. This is a
// convenience wrapper for g_hmac_new(), g_hmac_get_string() and g_hmac_unref().
//
// The hexadecimal string returned will be in lower case.
func ComputeHMACForData(digestType ChecksumType, key []byte, data []byte) string {
	var _arg1 C.GChecksumType // out
	var _arg2 *C.guchar
	var _arg3 C.gsize
	var _arg4 *C.guchar
	var _arg5 C.gsize
	var _cret *C.gchar // in

	_arg1 = (C.GChecksumType)(digestType)
	_arg3 = C.gsize(len(key))
	_arg2 = (*C.guchar)(unsafe.Pointer(&key[0]))
	_arg5 = C.gsize(len(data))
	_arg4 = (*C.guchar)(unsafe.Pointer(&data[0]))

	_cret = C.g_compute_hmac_for_data(_arg1, _arg2, _arg3, _arg4, _arg5)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ComputeHMACForString computes the HMAC for a string.
//
// The hexadecimal string returned will be in lower case.
func ComputeHMACForString(digestType ChecksumType, key []byte, str string, length int) string {
	var _arg1 C.GChecksumType // out
	var _arg2 *C.guchar
	var _arg3 C.gsize
	var _arg4 *C.gchar // out
	var _arg5 C.gssize // out
	var _cret *C.gchar // in

	_arg1 = (C.GChecksumType)(digestType)
	_arg3 = C.gsize(len(key))
	_arg2 = (*C.guchar)(unsafe.Pointer(&key[0]))
	_arg4 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (C.gssize)(length)

	_cret = C.g_compute_hmac_for_string(_arg1, _arg2, _arg3, _arg4, _arg5)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Dcgettext: this is a variant of g_dgettext() that allows specifying a locale
// category instead of always using `LC_MESSAGES`. See g_dgettext() for more
// information about how this functions differs from calling dcgettext()
// directly.
func Dcgettext(domain string, msgid string, category int) string {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _arg3 C.gint   // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(msgid))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.gint)(category)

	_cret = C.g_dcgettext(_arg1, _arg2, _arg3)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Dgettext: this function is a wrapper of dgettext() which does not translate
// the message if the default domain as set with textdomain() has no
// translations for the current locale.
//
// The advantage of using this function over dgettext() proper is that libraries
// using this function (like GTK+) will not use translations if the application
// using the library does not have translations for the current locale. This
// results in a consistent English-only interface instead of one having partial
// translations. For this feature to work, the call to textdomain() and
// setlocale() should precede any g_dgettext() invocations. For GTK+, it means
// calling textdomain() before gtk_init or its variants.
//
// This function disables translations if and only if upon its first call all
// the following conditions hold:
//
// - @domain is not nil
//
// - textdomain() has been called to set a default text domain
//
// - there is no translations available for the default text domain and the
// current locale
//
// - current locale is not "C" or any English locales (those starting with
// "en_")
//
// Note that this behavior may not be desired for example if an application has
// its untranslated messages in a language other than English. In those cases
// the application should call textdomain() after initializing GTK+.
//
// Applications should normally not use this function directly, but use the _()
// macro for translations.
func Dgettext(domain string, msgid string) string {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(msgid))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_dgettext(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Dngettext: this function is a wrapper of dngettext() which does not translate
// the message if the default domain as set with textdomain() has no
// translations for the current locale.
//
// See g_dgettext() for details of how this differs from dngettext() proper.
func Dngettext(domain string, msgid string, msgidPlural string, n uint32) string {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _arg3 *C.gchar // out
	var _arg4 C.gulong // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(msgid))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(msgidPlural))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (C.gulong)(n)

	_cret = C.g_dngettext(_arg1, _arg2, _arg3, _arg4)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Dpgettext: this function is a variant of g_dgettext() which supports a
// disambiguating message context. GNU gettext uses the '\004' character to
// separate the message context and message id in @msgctxtid. If 0 is passed as
// @msgidoffset, this function will fall back to trying to use the deprecated
// convention of using "|" as a separation character.
//
// This uses g_dgettext() internally. See that functions for differences with
// dgettext() proper.
//
// Applications should normally not use this function directly, but use the C_()
// macro for translations with context.
func Dpgettext(domain string, msgctxtid string, msgidoffset uint) string {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _arg3 C.gsize  // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(msgctxtid))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.gsize)(msgidoffset)

	_cret = C.g_dpgettext(_arg1, _arg2, _arg3)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Dpgettext2: this function is a variant of g_dgettext() which supports a
// disambiguating message context. GNU gettext uses the '\004' character to
// separate the message context and message id in @msgctxtid.
//
// This uses g_dgettext() internally. See that functions for differences with
// dgettext() proper.
//
// This function differs from C_() in that it is not a macro and thus you may
// use non-string-literals as context and msgid arguments.
func Dpgettext2(domain string, context string, msgid string) string {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _arg3 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(context))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(msgid))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.g_dpgettext2(_arg1, _arg2, _arg3)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// EnvironGetenv returns the value of the environment variable @variable in the
// provided list @envp.
func EnvironGetenv(envp []string, variable string) string {
	var _arg1 **C.gchar
	var _arg2 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(envp)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(envp))
		for i := range envp {
			out[i] = (*C.gchar)(C.CString(envp[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}
	_arg2 = (*C.gchar)(C.CString(variable))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_environ_getenv(_arg1, _arg2)

	var _filename string // out

	_filename = C.GoString(_cret)

	return _filename
}

// EnvironSetenv sets the environment variable @variable in the provided list
// @envp to @value.
func EnvironSetenv(envp []string, variable string, value string, overwrite bool) []string {
	var _arg1 **C.gchar
	var _arg2 *C.gchar   // out
	var _arg3 *C.gchar   // out
	var _arg4 C.gboolean // out
	var _cret **C.gchar

	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(envp)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	{
		out := unsafe.Slice(_arg1, len(envp))
		for i := range envp {
			out[i] = (*C.gchar)(C.CString(envp[i]))
		}
	}
	_arg2 = (*C.gchar)(C.CString(variable))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg3))
	if overwrite {
		_arg4 = C.TRUE
	}

	_cret = C.g_environ_setenv(_arg1, _arg2, _arg3, _arg4)

	var _filenames []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_filenames = make([]string, i)
		for i := range src {
			_filenames[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _filenames
}

// EnvironUnsetenv removes the environment variable @variable from the provided
// environment @envp.
func EnvironUnsetenv(envp []string, variable string) []string {
	var _arg1 **C.gchar
	var _arg2 *C.gchar // out
	var _cret **C.gchar

	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(envp)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	{
		out := unsafe.Slice(_arg1, len(envp))
		for i := range envp {
			out[i] = (*C.gchar)(C.CString(envp[i]))
		}
	}
	_arg2 = (*C.gchar)(C.CString(variable))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_environ_unsetenv(_arg1, _arg2)

	var _filenames []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_filenames = make([]string, i)
		for i := range src {
			_filenames[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _filenames
}

// FileErrorFromErrno gets a Error constant based on the passed-in @err_no. For
// example, if you pass in `EEXIST` this function returns FILE_ERROR_EXIST.
// Unlike `errno` values, you can portably assume that all Error values will
// exist.
//
// Normally a Error value goes into a #GError returned from a function that
// manipulates files. So you would use g_file_error_from_errno() when
// constructing a #GError.
func FileErrorFromErrno(errNo int) FileError {
	var _arg1 C.gint       // out
	var _cret C.GFileError // in

	_arg1 = (C.gint)(errNo)

	_cret = C.g_file_error_from_errno(_arg1)

	var _fileError FileError // out

	_fileError = FileError(_cret)

	return _fileError
}

// FileGetContents reads an entire file into allocated memory, with good error
// checking.
//
// If the call was successful, it returns true and sets @contents to the file
// contents and @length to the length of the file contents in bytes. The string
// stored in @contents will be nul-terminated, so for text files you can pass
// nil for the @length argument. If the call was not successful, it returns
// false and sets @error. The error domain is FILE_ERROR. Possible error codes
// are those in the Error enumeration. In the error case, @contents is set to
// nil and @length is set to zero.
func FileGetContents(filename string) ([]byte, error) {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar
	var _arg3 C.gsize   // in
	var _cerr *C.GError // in

	_arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_file_get_contents(_arg1, &_arg2, &_arg3, &_cerr)

	var _contents []byte
	var _goerr error // out

	_contents = unsafe.Slice((*byte)(unsafe.Pointer(_arg2)), _arg3)
	runtime.SetFinalizer(&_contents, func(v *[]byte) {
		C.free(unsafe.Pointer(&(*v)[0]))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _contents, _goerr
}

// FileOpenTmp opens a file for writing in the preferred directory for temporary
// files (as returned by g_get_tmp_dir()).
//
// @tmpl should be a string in the GLib file name encoding containing a sequence
// of six 'X' characters, as the parameter to g_mkstemp(). However, unlike these
// functions, the template should only be a basename, no directory components
// are allowed. If template is nil, a default template is used.
//
// Note that in contrast to g_mkstemp() (and mkstemp()) @tmpl is not modified,
// and might thus be a read-only literal string.
//
// Upon success, and if @name_used is non-nil, the actual name used is returned
// in @name_used. This string should be freed with g_free() when not needed any
// longer. The returned name is in the GLib file name encoding.
func FileOpenTmp(tmpl string) (string, int, error) {
	var _arg1 *C.gchar  // out
	var _arg2 *C.gchar  // in
	var _cret C.gint    // in
	var _cerr *C.GError // in

	_arg1 = (*C.gchar)(C.CString(tmpl))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_open_tmp(_arg1, &_arg2, &_cerr)

	var _nameUsed string // out
	var _gint int        // out
	var _goerr error     // out

	_nameUsed = C.GoString(_arg2)
	defer C.free(unsafe.Pointer(_arg2))
	_gint = (int)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _nameUsed, _gint, _goerr
}

// FileReadLink reads the contents of the symbolic link @filename like the POSIX
// readlink() function. The returned string is in the encoding used for
// filenames. Use g_filename_to_utf8() to convert it to UTF-8.
func FileReadLink(filename string) (string, error) {
	var _arg1 *C.gchar  // out
	var _cret *C.gchar  // in
	var _cerr *C.GError // in

	_arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_read_link(_arg1, &_cerr)

	var _ret string  // out
	var _goerr error // out

	_ret = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _ret, _goerr
}

// FileSetContents writes all of @contents to a file named @filename. This is a
// convenience wrapper around calling g_file_set_contents_full() with `flags`
// set to `G_FILE_SET_CONTENTS_CONSISTENT | G_FILE_SET_CONTENTS_ONLY_EXISTING`
// and `mode` set to `0666`.
func FileSetContents(filename string, contents []byte) error {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar
	var _arg3 C.gssize
	var _cerr *C.GError // in

	_arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))
	_arg3 = C.gssize(len(contents))
	_arg2 = (*C.gchar)(unsafe.Pointer(&contents[0]))

	C.g_file_set_contents(_arg1, _arg2, _arg3, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// FileSetContentsFull writes all of @contents to a file named @filename, with
// good error checking. If a file called @filename already exists it will be
// overwritten.
//
// @flags control the properties of the write operation: whether it’s atomic,
// and what the tradeoff is between returning quickly or being resilient to
// system crashes.
//
// As this function performs file I/O, it is recommended to not call it anywhere
// where blocking would cause problems, such as in the main loop of a graphical
// application. In particular, if @flags has any value other than
// G_FILE_SET_CONTENTS_NONE then this function may call `fsync()`.
//
// If G_FILE_SET_CONTENTS_CONSISTENT is set in @flags, the operation is atomic
// in the sense that it is first written to a temporary file which is then
// renamed to the final name.
//
// Notes:
//
// - On UNIX, if @filename already exists hard links to @filename will break.
// Also since the file is recreated, existing permissions, access control lists,
// metadata etc. may be lost. If @filename is a symbolic link, the link itself
// will be replaced, not the linked file.
//
// - On UNIX, if @filename already exists and is non-empty, and if the system
// supports it (via a journalling filesystem or equivalent), and if
// G_FILE_SET_CONTENTS_CONSISTENT is set in @flags, the `fsync()` call (or
// equivalent) will be used to ensure atomic replacement: @filename will contain
// either its old contents or @contents, even in the face of system power loss,
// the disk being unsafely removed, etc.
//
// - On UNIX, if @filename does not already exist or is empty, there is a
// possibility that system power loss etc. after calling this function will
// leave @filename empty or full of NUL bytes, depending on the underlying
// filesystem, unless G_FILE_SET_CONTENTS_DURABLE and
// G_FILE_SET_CONTENTS_CONSISTENT are set in @flags.
//
// - On Windows renaming a file will not remove an existing file with the new
// name, so on Windows there is a race condition between the existing file being
// removed and the temporary file being renamed.
//
// - On Windows there is no way to remove a file that is open to some process,
// or mapped into memory. Thus, this function will fail if @filename already
// exists and is open.
//
// If the call was successful, it returns true. If the call was not successful,
// it returns false and sets @error. The error domain is FILE_ERROR. Possible
// error codes are those in the Error enumeration.
//
// Note that the name for the temporary file is constructed by appending up to 7
// characters to @filename.
//
// If the file didn’t exist before and is created, it will be given the
// permissions from @mode. Otherwise, the permissions of the existing file may
// be changed to @mode depending on @flags, or they may remain unchanged.
func FileSetContentsFull(filename string, contents []byte, flags FileSetContentsFlags, mode int) error {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar
	var _arg3 C.gssize
	var _arg4 C.GFileSetContentsFlags // out
	var _arg5 C.int                   // out
	var _cerr *C.GError               // in

	_arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))
	_arg3 = C.gssize(len(contents))
	_arg2 = (*C.gchar)(unsafe.Pointer(&contents[0]))
	_arg4 = (C.GFileSetContentsFlags)(flags)
	_arg5 = (C.int)(mode)

	C.g_file_set_contents_full(_arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// TestFile returns true if any of the tests in the bitfield @test are true. For
// example, `(G_FILE_TEST_EXISTS | G_FILE_TEST_IS_DIR)` will return true if the
// file exists; the check whether it's a directory doesn't matter since the
// existence test is true. With the current set of available tests, there's no
// point passing in more than one test at a time.
//
// Apart from G_FILE_TEST_IS_SYMLINK all tests follow symbolic links, so for a
// symbolic link to a regular file g_file_test() will return true for both
// G_FILE_TEST_IS_SYMLINK and G_FILE_TEST_IS_REGULAR.
//
// Note, that for a dangling symbolic link g_file_test() will return true for
// G_FILE_TEST_IS_SYMLINK and false for all other flags.
//
// You should never use g_file_test() to test whether it is safe to perform an
// operation, because there is always the possibility of the condition changing
// before you actually perform the operation. For example, you might think you
// could use G_FILE_TEST_IS_SYMLINK to know whether it is safe to write to a
// file without being tricked into writing into a different location. It doesn't
// work!
//
//    // DON'T DO THIS
//    if (!g_file_test (filename, G_FILE_TEST_IS_SYMLINK))
//      {
//        fd = g_open (filename, O_WRONLY);
//        // write to fd
//      }
//
// Another thing to note is that G_FILE_TEST_EXISTS and
// G_FILE_TEST_IS_EXECUTABLE are implemented using the access() system call.
// This usually doesn't matter, but if your program is setuid or setgid it means
// that these tests will give you the answer for the real user ID and group ID,
// rather than the effective user ID and group ID.
//
// On Windows, there are no symlinks, so testing for G_FILE_TEST_IS_SYMLINK will
// always return false. Testing for G_FILE_TEST_IS_EXECUTABLE will just check
// that the file exists and its name indicates that it is executable, checking
// for well-known extensions and those listed in the `PATHEXT` environment
// variable.
func TestFile(filename string, test FileTest) bool {
	var _arg1 *C.gchar    // out
	var _arg2 C.GFileTest // out
	var _cret C.gboolean  // in

	_arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GFileTest)(test)

	_cret = C.g_file_test(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FilenameDisplayBasename returns the display basename for the particular
// filename, guaranteed to be valid UTF-8. The display name might not be
// identical to the filename, for instance there might be problems converting it
// to UTF-8, and some files can be translated in the display.
//
// If GLib cannot make sense of the encoding of @filename, as a last resort it
// replaces unknown characters with U+FFFD, the Unicode replacement character.
// You can search the result for the UTF-8 encoding of this character (which is
// "\357\277\275" in octal notation) to find out if @filename was in an invalid
// encoding.
//
// You must pass the whole absolute pathname to this functions so that
// translation of well known locations can be done.
//
// This function is preferred over g_filename_display_name() if you know the
// whole path, as it allows translation.
func FilenameDisplayBasename(filename string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_filename_display_basename(_arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// FilenameDisplayName converts a filename into a valid UTF-8 string. The
// conversion is not necessarily reversible, so you should keep the original
// around and use the return value of this function only for display purposes.
// Unlike g_filename_to_utf8(), the result is guaranteed to be non-nil even if
// the filename actually isn't in the GLib file name encoding.
//
// If GLib cannot make sense of the encoding of @filename, as a last resort it
// replaces unknown characters with U+FFFD, the Unicode replacement character.
// You can search the result for the UTF-8 encoding of this character (which is
// "\357\277\275" in octal notation) to find out if @filename was in an invalid
// encoding.
//
// If you know the whole pathname of the file you should use
// g_filename_display_basename(), since that allows location-based translation
// of filenames.
func FilenameDisplayName(filename string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_filename_display_name(_arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// FilenameFromURI converts an escaped ASCII-encoded URI to a local filename in
// the encoding used for filenames.
func FilenameFromURI(uri string) (hostname string, filename string, goerr error) {
	var _arg1 *C.gchar  // out
	var _arg2 *C.gchar  // in
	var _cret *C.gchar  // in
	var _cerr *C.GError // in

	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_filename_from_uri(_arg1, &_arg2, &_cerr)

	var _hostname string // out
	var _filename string // out
	var _goerr error     // out

	_hostname = C.GoString(_arg2)
	defer C.free(unsafe.Pointer(_arg2))
	_filename = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _hostname, _filename, _goerr
}

// FilenameFromUTF8 converts a string from UTF-8 to the encoding GLib uses for
// filenames. Note that on Windows GLib uses UTF-8 for filenames; on other
// platforms, this function indirectly depends on the [current
// locale][setlocale].
//
// The input string shall not contain nul characters even if the @len argument
// is positive. A nul character found inside the string will result in error
// G_CONVERT_ERROR_ILLEGAL_SEQUENCE. If the filename encoding is not UTF-8 and
// the conversion output contains a nul character, the error
// G_CONVERT_ERROR_EMBEDDED_NUL is set and the function returns nil.
func FilenameFromUTF8(utf8String string, len int) (bytesRead uint, bytesWritten uint, filename string, goerr error) {
	var _arg1 *C.gchar  // out
	var _arg2 C.gssize  // out
	var _arg3 C.gsize   // in
	var _arg4 C.gsize   // in
	var _cret *C.gchar  // in
	var _cerr *C.GError // in

	_arg1 = (*C.gchar)(C.CString(utf8String))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gssize)(len)

	_cret = C.g_filename_from_utf8(_arg1, _arg2, &_arg3, &_arg4, &_cerr)

	var _bytesRead uint    // out
	var _bytesWritten uint // out
	var _filename string   // out
	var _goerr error       // out

	_bytesRead = (uint)(_arg3)
	_bytesWritten = (uint)(_arg4)
	_filename = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _bytesRead, _bytesWritten, _filename, _goerr
}

// FilenameToURI converts an absolute filename to an escaped ASCII-encoded URI,
// with the path component following Section 3.3. of RFC 2396.
func FilenameToURI(filename string, hostname string) (string, error) {
	var _arg1 *C.gchar  // out
	var _arg2 *C.gchar  // out
	var _cret *C.gchar  // in
	var _cerr *C.GError // in

	_arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(hostname))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_filename_to_uri(_arg1, _arg2, &_cerr)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _utf8, _goerr
}

// FilenameToUTF8 converts a string which is in the encoding used by GLib for
// filenames into a UTF-8 string. Note that on Windows GLib uses UTF-8 for
// filenames; on other platforms, this function indirectly depends on the
// [current locale][setlocale].
//
// The input string shall not contain nul characters even if the @len argument
// is positive. A nul character found inside the string will result in error
// G_CONVERT_ERROR_ILLEGAL_SEQUENCE. If the source encoding is not UTF-8 and the
// conversion output contains a nul character, the error
// G_CONVERT_ERROR_EMBEDDED_NUL is set and the function returns nil. Use
// g_convert() to produce output that may contain embedded nul characters.
func FilenameToUTF8(opsysstring string, len int) (bytesRead uint, bytesWritten uint, utf8 string, goerr error) {
	var _arg1 *C.gchar  // out
	var _arg2 C.gssize  // out
	var _arg3 C.gsize   // in
	var _arg4 C.gsize   // in
	var _cret *C.gchar  // in
	var _cerr *C.GError // in

	_arg1 = (*C.gchar)(C.CString(opsysstring))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gssize)(len)

	_cret = C.g_filename_to_utf8(_arg1, _arg2, &_arg3, &_arg4, &_cerr)

	var _bytesRead uint    // out
	var _bytesWritten uint // out
	var _utf8 string       // out
	var _goerr error       // out

	_bytesRead = (uint)(_arg3)
	_bytesWritten = (uint)(_arg4)
	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _bytesRead, _bytesWritten, _utf8, _goerr
}

// FindProgramInPath locates the first executable named @program in the user's
// path, in the same way that execvp() would locate it. Returns an allocated
// string with the absolute path name, or nil if the program is not found in the
// path. If @program is already an absolute path, returns a copy of @program if
// @program exists and is executable, and nil otherwise. On Windows, if @program
// does not have a file type suffix, tries with the suffixes .exe, .cmd, .bat
// and .com, and the suffixes in the `PATHEXT` environment variable.
//
// On Windows, it looks for the file in the same way as CreateProcess() would.
// This means first in the directory where the executing program was loaded
// from, then in the current directory, then in the Windows 32-bit system
// directory, then in the Windows directory, and finally in the directories in
// the `PATH` environment variable. If the program is found, the return value
// contains the full name including the type suffix.
func FindProgramInPath(program string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(program))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_find_program_in_path(_arg1)

	var _filename string // out

	_filename = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _filename
}

// FormatSize formats a size (for example the size of a file) into a human
// readable string. Sizes are rounded to the nearest size prefix (kB, MB, GB)
// and are displayed rounded to the nearest tenth. E.g. the file size 3292528
// bytes will be converted into the string "3.2 MB". The returned string is
// UTF-8, and may use a non-breaking space to separate the number and units, to
// ensure they aren’t separated when line wrapped.
//
// The prefix units base is 1000 (i.e. 1 kB is 1000 bytes).
//
// This string should be freed with g_free() when not needed any longer.
//
// See g_format_size_full() for more options about how the size might be
// formatted.
func FormatSize(size uint64) string {
	var _arg1 C.guint64 // out
	var _cret *C.gchar  // in

	_arg1 = (C.guint64)(size)

	_cret = C.g_format_size(_arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// FormatSizeForDisplay formats a size (for example the size of a file) into a
// human readable string. Sizes are rounded to the nearest size prefix (KB, MB,
// GB) and are displayed rounded to the nearest tenth. E.g. the file size
// 3292528 bytes will be converted into the string "3.1 MB".
//
// The prefix units base is 1024 (i.e. 1 KB is 1024 bytes).
//
// This string should be freed with g_free() when not needed any longer.
func FormatSizeForDisplay(size int64) string {
	var _arg1 C.goffset // out
	var _cret *C.gchar  // in

	_arg1 = (C.goffset)(size)

	_cret = C.g_format_size_for_display(_arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// FormatSizeFull formats a size.
//
// This function is similar to g_format_size() but allows for flags that modify
// the output. See SizeFlags.
func FormatSizeFull(size uint64, flags FormatSizeFlags) string {
	var _arg1 C.guint64          // out
	var _arg2 C.GFormatSizeFlags // out
	var _cret *C.gchar           // in

	_arg1 = (C.guint64)(size)
	_arg2 = (C.GFormatSizeFlags)(flags)

	_cret = C.g_format_size_full(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// GetApplicationName gets a human-readable name for the application, as set by
// g_set_application_name(). This name should be localized if possible, and is
// intended for display to the user. Contrast with g_get_prgname(), which gets a
// non-localized name. If g_set_application_name() has not been called, returns
// the result of g_get_prgname() (which may be nil if g_set_prgname() has also
// not been called).
func GetApplicationName() string {
	var _cret *C.gchar // in

	_cret = C.g_get_application_name()

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// GetCharset obtains the character set for the [current locale][setlocale]; you
// might use this character set as an argument to g_convert(), to convert from
// the current locale's encoding to some other encoding. (Frequently
// g_locale_to_utf8() and g_locale_from_utf8() are nice shortcuts, though.)
//
// On Windows the character set returned by this function is the so-called
// system default ANSI code-page. That is the character set used by the "narrow"
// versions of C library and Win32 functions that handle file names. It might be
// different from the character set used by the C library's current locale.
//
// On Linux, the character set is found by consulting nl_langinfo() if
// available. If not, the environment variables `LC_ALL`, `LC_CTYPE`, `LANG` and
// `CHARSET` are queried in order.
//
// The return value is true if the locale's encoding is UTF-8, in that case you
// can perhaps avoid calling g_convert().
//
// The string returned in @charset is not allocated, and should not be freed.
func GetCharset() (string, bool) {
	var _arg1 *C.char    // in
	var _cret C.gboolean // in

	_cret = C.g_get_charset(&_arg1)

	var _charset string // out
	var _ok bool        // out

	_charset = C.GoString(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _charset, _ok
}

// GetCodeset gets the character set for the current locale.
func GetCodeset() string {
	var _cret *C.gchar // in

	_cret = C.g_get_codeset()

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// GetConsoleCharset obtains the character set used by the console attached to
// the process, which is suitable for printing output to the terminal.
//
// Usually this matches the result returned by g_get_charset(), but in
// environments where the locale's character set does not match the encoding of
// the console this function tries to guess a more suitable value instead.
//
// On Windows the character set returned by this function is the output code
// page used by the console associated with the calling process. If the codepage
// can't be determined (for example because there is no console attached) UTF-8
// is assumed.
//
// The return value is true if the locale's encoding is UTF-8, in that case you
// can perhaps avoid calling g_convert().
//
// The string returned in @charset is not allocated, and should not be freed.
func GetConsoleCharset() (string, bool) {
	var _arg1 *C.char    // in
	var _cret C.gboolean // in

	_cret = C.g_get_console_charset(&_arg1)

	var _charset string // out
	var _ok bool        // out

	_charset = C.GoString(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _charset, _ok
}

// GetCurrentDir gets the current directory.
//
// The returned string should be freed when no longer needed. The encoding of
// the returned string is system defined. On Windows, it is always UTF-8.
//
// Since GLib 2.40, this function will return the value of the "PWD" environment
// variable if it is set and it happens to be the same as the current directory.
// This can make a difference in the case that the current directory is the
// target of a symbolic link.
func GetCurrentDir() string {
	var _cret *C.gchar // in

	_cret = C.g_get_current_dir()

	var _filename string // out

	_filename = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _filename
}

// GetCurrentTime: equivalent to the UNIX gettimeofday() function, but portable.
//
// You may find g_get_real_time() to be more convenient.
func GetCurrentTime(result *TimeVal) {
	var _arg1 *C.GTimeVal // out

	_arg1 = (*C.GTimeVal)(unsafe.Pointer(result.Native()))

	C.g_get_current_time(_arg1)
}

// GetEnviron gets the list of environment variables for the current process.
//
// The list is nil terminated and each item in the list is of the form
// 'NAME=VALUE'.
//
// This is equivalent to direct access to the 'environ' global variable, except
// portable.
//
// The return value is freshly allocated and it should be freed with
// g_strfreev() when it is no longer needed.
func GetEnviron() []string {
	var _cret **C.gchar

	_cret = C.g_get_environ()

	var _filenames []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_filenames = make([]string, i)
		for i := range src {
			_filenames[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _filenames
}

// GetFilenameCharsets determines the preferred character sets used for
// filenames. The first character set from the @charsets is the filename
// encoding, the subsequent character sets are used when trying to generate a
// displayable representation of a filename, see g_filename_display_name().
//
// On Unix, the character sets are determined by consulting the environment
// variables `G_FILENAME_ENCODING` and `G_BROKEN_FILENAMES`. On Windows, the
// character set used in the GLib API is always UTF-8 and said environment
// variables have no effect.
//
// `G_FILENAME_ENCODING` may be set to a comma-separated list of character set
// names. The special token "\@locale" is taken to mean the character set for
// the [current locale][setlocale]. If `G_FILENAME_ENCODING` is not set, but
// `G_BROKEN_FILENAMES` is, the character set of the current locale is taken as
// the filename encoding. If neither environment variable is set, UTF-8 is taken
// as the filename encoding, but the character set of the current locale is also
// put in the list of encodings.
//
// The returned @charsets belong to GLib and must not be freed.
//
// Note that on Unix, regardless of the locale character set or
// `G_FILENAME_ENCODING` value, the actual file names present on a system might
// be in any random encoding or just gibberish.
func GetFilenameCharsets() ([]string, bool) {
	var _arg1 **C.gchar
	var _cret C.gboolean // in

	_cret = C.g_get_filename_charsets(&_arg1)

	var _filenameCharsets []string
	var _ok bool // out

	{
		var i int
		var z *C.gchar
		for p := _arg1; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_arg1, i)
		_filenameCharsets = make([]string, i)
		for i := range src {
			_filenameCharsets[i] = C.GoString(src[i])
		}
	}
	if _cret != 0 {
		_ok = true
	}

	return _filenameCharsets, _ok
}

// GetHomeDir gets the current user's home directory.
//
// As with most UNIX tools, this function will return the value of the `HOME`
// environment variable if it is set to an existing absolute path name, falling
// back to the `passwd` file in the case that it is unset.
//
// If the path given in `HOME` is non-absolute, does not exist, or is not a
// directory, the result is undefined.
//
// Before version 2.36 this function would ignore the `HOME` environment
// variable, taking the value from the `passwd` database instead. This was
// changed to increase the compatibility of GLib with other programs (and the
// XDG basedir specification) and to increase testability of programs based on
// GLib (by making it easier to run them from test frameworks).
//
// If your program has a strong requirement for either the new or the old
// behaviour (and if you don't wish to increase your GLib dependency to ensure
// that the new behaviour is in effect) then you should either directly check
// the `HOME` environment variable yourself or unset it before calling any
// functions in GLib.
func GetHomeDir() string {
	var _cret *C.gchar // in

	_cret = C.g_get_home_dir()

	var _filename string // out

	_filename = C.GoString(_cret)

	return _filename
}

// GetHostName: return a name for the machine.
//
// The returned name is not necessarily a fully-qualified domain name, or even
// present in DNS or some other name service at all. It need not even be unique
// on your local network or site, but usually it is. Callers should not rely on
// the return value having any specific properties like uniqueness for security
// purposes. Even if the name of the machine is changed while an application is
// running, the return value from this function does not change. The returned
// string is owned by GLib and should not be modified or freed. If no name can
// be determined, a default fixed string "localhost" is returned.
//
// The encoding of the returned string is UTF-8.
func GetHostName() string {
	var _cret *C.gchar // in

	_cret = C.g_get_host_name()

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// GetLanguageNames computes a list of applicable locale names, which can be
// used to e.g. construct locale-dependent filenames or search paths. The
// returned list is sorted from most desirable to least desirable and always
// contains the default locale "C".
//
// For example, if LANGUAGE=de:en_US, then the returned list is "de", "en_US",
// "en", "C".
//
// This function consults the environment variables `LANGUAGE`, `LC_ALL`,
// `LC_MESSAGES` and `LANG` to find the list of locales specified by the user.
func GetLanguageNames() []string {
	var _cret **C.gchar

	_cret = C.g_get_language_names()

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
		}
	}

	return _utf8s
}

// GetLanguageNamesWithCategory computes a list of applicable locale names with
// a locale category name, which can be used to construct the fallback
// locale-dependent filenames or search paths. The returned list is sorted from
// most desirable to least desirable and always contains the default locale "C".
//
// This function consults the environment variables `LANGUAGE`, `LC_ALL`,
// @category_name, and `LANG` to find the list of locales specified by the user.
//
// g_get_language_names() returns
// g_get_language_names_with_category("LC_MESSAGES").
func GetLanguageNamesWithCategory(categoryName string) []string {
	var _arg1 *C.gchar // out
	var _cret **C.gchar

	_arg1 = (*C.gchar)(C.CString(categoryName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_get_language_names_with_category(_arg1)

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
		}
	}

	return _utf8s
}

// GetLocaleVariants returns a list of derived variants of @locale, which can be
// used to e.g. construct locale-dependent filenames or search paths. The
// returned list is sorted from most desirable to least desirable. This function
// handles territory, charset and extra locale modifiers. See `setlocale(3)`
// (man:setlocale) for information about locales and their format.
//
// @locale itself is guaranteed to be returned in the output.
//
// For example, if @locale is `fr_BE`, then the returned list is `fr_BE`, `fr`.
// If @locale is `en_GB.UTF-8@euro`, then the returned list is
// `en_GB.UTF-8@euro`, `en_GB.UTF-8`, `en_GB@euro`, `en_GB`, `en.UTF-8@euro`,
// `en.UTF-8`, `en@euro`, `en`.
//
// If you need the list of variants for the current locale, use
// g_get_language_names().
func GetLocaleVariants(locale string) []string {
	var _arg1 *C.gchar // out
	var _cret **C.gchar

	_arg1 = (*C.gchar)(C.CString(locale))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_get_locale_variants(_arg1)

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// GetMonotonicTime queries the system monotonic time.
//
// The monotonic clock will always increase and doesn't suffer discontinuities
// when the user (or NTP) changes the system time. It may or may not continue to
// tick during times where the machine is suspended.
//
// We try to use the clock that corresponds as closely as possible to the
// passage of time as measured by system calls such as poll() but it may not
// always be possible to do this.
func GetMonotonicTime() int64 {
	var _cret C.gint64 // in

	_cret = C.g_get_monotonic_time()

	var _gint64 int64 // out

	_gint64 = (int64)(_cret)

	return _gint64
}

// GetOsInfo: get information about the operating system.
//
// On Linux this comes from the `/etc/os-release` file. On other systems, it may
// come from a variety of sources. You can either use the standard key names
// like G_OS_INFO_KEY_NAME or pass any UTF-8 string key name. For example,
// `/etc/os-release` provides a number of other less commonly used values that
// may be useful. No key is guaranteed to be provided, so the caller should
// always check if the result is nil.
func GetOsInfo(keyName string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(keyName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_get_os_info(_arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// GetPrgname gets the name of the program. This name should not be localized,
// in contrast to g_get_application_name().
//
// If you are using #GApplication the program name is set in
// g_application_run(). In case of GDK or GTK+ it is set in gdk_init(), which is
// called by gtk_init() and the Application::startup handler. The program name
// is found by taking the last component of @argv[0].
func GetPrgname() string {
	var _cret *C.gchar // in

	_cret = C.g_get_prgname()

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// GetRealName gets the real name of the user. This usually comes from the
// user's entry in the `passwd` file. The encoding of the returned string is
// system-defined. (On Windows, it is, however, always UTF-8.) If the real user
// name cannot be determined, the string "Unknown" is returned.
func GetRealName() string {
	var _cret *C.gchar // in

	_cret = C.g_get_real_name()

	var _filename string // out

	_filename = C.GoString(_cret)

	return _filename
}

// GetRealTime queries the system wall-clock time.
//
// This call is functionally equivalent to g_get_current_time() except that the
// return value is often more convenient than dealing with a Val.
//
// You should only use this call if you are actually interested in the real
// wall-clock time. g_get_monotonic_time() is probably more useful for measuring
// intervals.
func GetRealTime() int64 {
	var _cret C.gint64 // in

	_cret = C.g_get_real_time()

	var _gint64 int64 // out

	_gint64 = (int64)(_cret)

	return _gint64
}

// GetSystemConfigDirs returns an ordered list of base directories in which to
// access system-wide configuration information.
//
// On UNIX platforms this is determined using the mechanisms described in the
// XDG Base Directory Specification
// (http://www.freedesktop.org/Standards/basedir-spec). In this case the list of
// directories retrieved will be `XDG_CONFIG_DIRS`.
//
// On Windows it follows XDG Base Directory Specification if `XDG_CONFIG_DIRS`
// is defined. If `XDG_CONFIG_DIRS` is undefined, the directory that contains
// application data for all users is used instead. A typical path is
// `C:\Documents and Settings\All Users\Application Data`. This folder is used
// for application data that is not user specific. For example, an application
// can store a spell-check dictionary, a database of clip art, or a log file in
// the CSIDL_COMMON_APPDATA folder. This information will not roam and is
// available to anyone using the computer.
//
// The return value is cached and modifying it at runtime is not supported, as
// it’s not thread-safe to modify environment variables at runtime.
func GetSystemConfigDirs() []string {
	var _cret **C.gchar

	_cret = C.g_get_system_config_dirs()

	var _filenames []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_filenames = make([]string, i)
		for i := range src {
			_filenames[i] = C.GoString(src[i])
		}
	}

	return _filenames
}

// GetSystemDataDirs returns an ordered list of base directories in which to
// access system-wide application data.
//
// On UNIX platforms this is determined using the mechanisms described in the
// XDG Base Directory Specification
// (http://www.freedesktop.org/Standards/basedir-spec) In this case the list of
// directories retrieved will be `XDG_DATA_DIRS`.
//
// On Windows it follows XDG Base Directory Specification if `XDG_DATA_DIRS` is
// defined. If `XDG_DATA_DIRS` is undefined, the first elements in the list are
// the Application Data and Documents folders for All Users. (These can be
// determined only on Windows 2000 or later and are not present in the list on
// other Windows versions.) See documentation for CSIDL_COMMON_APPDATA and
// CSIDL_COMMON_DOCUMENTS.
//
// Then follows the "share" subfolder in the installation folder for the package
// containing the DLL that calls this function, if it can be determined.
//
// Finally the list contains the "share" subfolder in the installation folder
// for GLib, and in the installation folder for the package the application's
// .exe file belongs to.
//
// The installation folders above are determined by looking up the folder where
// the module (DLL or EXE) in question is located. If the folder's name is
// "bin", its parent is used, otherwise the folder itself.
//
// Note that on Windows the returned list can vary depending on where this
// function is called.
//
// The return value is cached and modifying it at runtime is not supported, as
// it’s not thread-safe to modify environment variables at runtime.
func GetSystemDataDirs() []string {
	var _cret **C.gchar

	_cret = C.g_get_system_data_dirs()

	var _filenames []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_filenames = make([]string, i)
		for i := range src {
			_filenames[i] = C.GoString(src[i])
		}
	}

	return _filenames
}

// GetTmpDir gets the directory to use for temporary files.
//
// On UNIX, this is taken from the `TMPDIR` environment variable. If the
// variable is not set, `P_tmpdir` is used, as defined by the system C library.
// Failing that, a hard-coded default of "/tmp" is returned.
//
// On Windows, the `TEMP` environment variable is used, with the root directory
// of the Windows installation (eg: "C:\") used as a default.
//
// The encoding of the returned string is system-defined. On Windows, it is
// always UTF-8. The return value is never nil or the empty string.
func GetTmpDir() string {
	var _cret *C.gchar // in

	_cret = C.g_get_tmp_dir()

	var _filename string // out

	_filename = C.GoString(_cret)

	return _filename
}

// GetUserCacheDir returns a base directory in which to store non-essential,
// cached data specific to particular user.
//
// On UNIX platforms this is determined using the mechanisms described in the
// XDG Base Directory Specification
// (http://www.freedesktop.org/Standards/basedir-spec). In this case the
// directory retrieved will be `XDG_CACHE_HOME`.
//
// On Windows it follows XDG Base Directory Specification if `XDG_CACHE_HOME` is
// defined. If `XDG_CACHE_HOME` is undefined, the directory that serves as a
// common repository for temporary Internet files is used instead. A typical
// path is `C:\Documents and Settings\username\Local Settings\Temporary Internet
// Files`. See the documentation for `CSIDL_INTERNET_CACHE`
// (https://msdn.microsoft.com/en-us/library/windows/desktop/bb76249428v=vs.8529.aspx#csidl_internet_cache).
//
// The return value is cached and modifying it at runtime is not supported, as
// it’s not thread-safe to modify environment variables at runtime.
func GetUserCacheDir() string {
	var _cret *C.gchar // in

	_cret = C.g_get_user_cache_dir()

	var _filename string // out

	_filename = C.GoString(_cret)

	return _filename
}

// GetUserConfigDir returns a base directory in which to store user-specific
// application configuration information such as user preferences and settings.
//
// On UNIX platforms this is determined using the mechanisms described in the
// XDG Base Directory Specification
// (http://www.freedesktop.org/Standards/basedir-spec). In this case the
// directory retrieved will be `XDG_CONFIG_HOME`.
//
// On Windows it follows XDG Base Directory Specification if `XDG_CONFIG_HOME`
// is defined. If `XDG_CONFIG_HOME` is undefined, the folder to use for local
// (as opposed to roaming) application data is used instead. See the
// documentation for `CSIDL_LOCAL_APPDATA`
// (https://msdn.microsoft.com/en-us/library/windows/desktop/bb76249428v=vs.8529.aspx#csidl_local_appdata).
// Note that in this case on Windows it will be the same as what
// g_get_user_data_dir() returns.
//
// The return value is cached and modifying it at runtime is not supported, as
// it’s not thread-safe to modify environment variables at runtime.
func GetUserConfigDir() string {
	var _cret *C.gchar // in

	_cret = C.g_get_user_config_dir()

	var _filename string // out

	_filename = C.GoString(_cret)

	return _filename
}

// GetUserDataDir returns a base directory in which to access application data
// such as icons that is customized for a particular user.
//
// On UNIX platforms this is determined using the mechanisms described in the
// XDG Base Directory Specification
// (http://www.freedesktop.org/Standards/basedir-spec). In this case the
// directory retrieved will be `XDG_DATA_HOME`.
//
// On Windows it follows XDG Base Directory Specification if `XDG_DATA_HOME` is
// defined. If `XDG_DATA_HOME` is undefined, the folder to use for local (as
// opposed to roaming) application data is used instead. See the documentation
// for `CSIDL_LOCAL_APPDATA`
// (https://msdn.microsoft.com/en-us/library/windows/desktop/bb76249428v=vs.8529.aspx#csidl_local_appdata).
// Note that in this case on Windows it will be the same as what
// g_get_user_config_dir() returns.
//
// The return value is cached and modifying it at runtime is not supported, as
// it’s not thread-safe to modify environment variables at runtime.
func GetUserDataDir() string {
	var _cret *C.gchar // in

	_cret = C.g_get_user_data_dir()

	var _filename string // out

	_filename = C.GoString(_cret)

	return _filename
}

// GetUserName gets the user name of the current user. The encoding of the
// returned string is system-defined. On UNIX, it might be the preferred file
// name encoding, or something else, and there is no guarantee that it is even
// consistent on a machine. On Windows, it is always UTF-8.
func GetUserName() string {
	var _cret *C.gchar // in

	_cret = C.g_get_user_name()

	var _filename string // out

	_filename = C.GoString(_cret)

	return _filename
}

// GetUserRuntimeDir returns a directory that is unique to the current user on
// the local system.
//
// This is determined using the mechanisms described in the XDG Base Directory
// Specification (http://www.freedesktop.org/Standards/basedir-spec). This is
// the directory specified in the `XDG_RUNTIME_DIR` environment variable. In the
// case that this variable is not set, we return the value of
// g_get_user_cache_dir(), after verifying that it exists.
//
// The return value is cached and modifying it at runtime is not supported, as
// it’s not thread-safe to modify environment variables at runtime.
func GetUserRuntimeDir() string {
	var _cret *C.gchar // in

	_cret = C.g_get_user_runtime_dir()

	var _filename string // out

	_filename = C.GoString(_cret)

	return _filename
}

// GetUserSpecialDir returns the full path of a special directory using its
// logical id.
//
// On UNIX this is done using the XDG special user directories. For
// compatibility with existing practise, G_USER_DIRECTORY_DESKTOP falls back to
// `$HOME/Desktop` when XDG special user directories have not been set up.
//
// Depending on the platform, the user might be able to change the path of the
// special directory without requiring the session to restart; GLib will not
// reflect any change once the special directories are loaded.
func GetUserSpecialDir(directory UserDirectory) string {
	var _arg1 C.GUserDirectory // out
	var _cret *C.gchar         // in

	_arg1 = (C.GUserDirectory)(directory)

	_cret = C.g_get_user_special_dir(_arg1)

	var _filename string // out

	_filename = C.GoString(_cret)

	return _filename
}

// Getenv returns the value of an environment variable.
//
// On UNIX, the name and value are byte strings which might or might not be in
// some consistent character set and encoding. On Windows, they are in UTF-8. On
// Windows, in case the environment variable's value contains references to
// other environment variables, they are expanded.
func Getenv(variable string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(variable))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_getenv(_arg1)

	var _filename string // out

	_filename = C.GoString(_cret)

	return _filename
}

// HostnameIsASCIIEncoded tests if @hostname contains segments with an
// ASCII-compatible encoding of an Internationalized Domain Name. If this
// returns true, you should decode the hostname with g_hostname_to_unicode()
// before displaying it to the user.
//
// Note that a hostname might contain a mix of encoded and unencoded segments,
// and so it is possible for g_hostname_is_non_ascii() and
// g_hostname_is_ascii_encoded() to both return true for a name.
func HostnameIsASCIIEncoded(hostname string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(C.CString(hostname))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_hostname_is_ascii_encoded(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HostnameIsIpAddress tests if @hostname is the string form of an IPv4 or IPv6
// address. (Eg, "192.168.0.1".)
//
// Since 2.66, IPv6 addresses with a zone-id are accepted (RFC6874).
func HostnameIsIpAddress(hostname string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(C.CString(hostname))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_hostname_is_ip_address(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HostnameIsNonASCII tests if @hostname contains Unicode characters. If this
// returns true, you need to encode the hostname with g_hostname_to_ascii()
// before using it in non-IDN-aware contexts.
//
// Note that a hostname might contain a mix of encoded and unencoded segments,
// and so it is possible for g_hostname_is_non_ascii() and
// g_hostname_is_ascii_encoded() to both return true for a name.
func HostnameIsNonASCII(hostname string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(C.CString(hostname))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_hostname_is_non_ascii(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HostnameToASCII converts @hostname to its canonical ASCII form; an ASCII-only
// string containing no uppercase letters and not ending with a trailing dot.
func HostnameToASCII(hostname string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(hostname))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_hostname_to_ascii(_arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// HostnameToUnicode converts @hostname to its canonical presentation form; a
// UTF-8 string in Unicode normalization form C, containing no uppercase
// letters, no forbidden characters, and no ASCII-encoded segments, and not
// ending with a trailing dot.
//
// Of course if @hostname is not an internationalized hostname, then the
// canonical presentation form will be entirely ASCII.
func HostnameToUnicode(hostname string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(hostname))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_hostname_to_unicode(_arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// InternStaticString returns a canonical representation for @string. Interned
// strings can be compared for equality by comparing the pointers, instead of
// using strcmp(). g_intern_static_string() does not copy the string, therefore
// @string must not be freed or modified.
//
// This function must not be used before library constructors have finished
// running. In particular, this means it cannot be used to initialize global
// variables in C++.
func InternStaticString(_string string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_intern_static_string(_arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// InternString returns a canonical representation for @string. Interned strings
// can be compared for equality by comparing the pointers, instead of using
// strcmp().
//
// This function must not be used before library constructors have finished
// running. In particular, this means it cannot be used to initialize global
// variables in C++.
func InternString(_string string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_intern_string(_arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Listenv gets the names of all variables set in the environment.
//
// Programs that want to be portable to Windows should typically use this
// function and g_getenv() instead of using the environ array from the C library
// directly. On Windows, the strings in the environ array are in system codepage
// encoding, while in most of the typical use cases for environment variables in
// GLib-using programs you want the UTF-8 encoding that this function and
// g_getenv() provide.
func Listenv() []string {
	var _cret **C.gchar

	_cret = C.g_listenv()

	var _filenames []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_filenames = make([]string, i)
		for i := range src {
			_filenames[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _filenames
}

// LocaleToUTF8 converts a string which is in the encoding used for strings by
// the C runtime (usually the same as that used by the operating system) in the
// [current locale][setlocale] into a UTF-8 string.
//
// If the source encoding is not UTF-8 and the conversion output contains a nul
// character, the error G_CONVERT_ERROR_EMBEDDED_NUL is set and the function
// returns nil. If the source encoding is UTF-8, an embedded nul character is
// treated with the G_CONVERT_ERROR_ILLEGAL_SEQUENCE error for backward
// compatibility with earlier versions of this library. Use g_convert() to
// produce output that may contain embedded nul characters.
func LocaleToUTF8(opsysstring []byte) (bytesRead uint, bytesWritten uint, utf8 string, goerr error) {
	var _arg1 *C.gchar
	var _arg2 C.gssize
	var _arg3 C.gsize   // in
	var _arg4 C.gsize   // in
	var _cret *C.gchar  // in
	var _cerr *C.GError // in

	_arg2 = C.gssize(len(opsysstring))
	_arg1 = (*C.gchar)(unsafe.Pointer(&opsysstring[0]))

	_cret = C.g_locale_to_utf8(_arg1, _arg2, &_arg3, &_arg4, &_cerr)

	var _bytesRead uint    // out
	var _bytesWritten uint // out
	var _utf8 string       // out
	var _goerr error       // out

	_bytesRead = (uint)(_arg3)
	_bytesWritten = (uint)(_arg4)
	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _bytesRead, _bytesWritten, _utf8, _goerr
}

// LogRemoveHandler removes the log handler.
//
// This has no effect if structured logging is enabled; see [Using Structured
// Logging][using-structured-logging].
func LogRemoveHandler(logDomain string, handlerId uint) {
	var _arg1 *C.gchar // out
	var _arg2 C.guint  // out

	_arg1 = (*C.gchar)(C.CString(logDomain))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.guint)(handlerId)

	C.g_log_remove_handler(_arg1, _arg2)
}

// LogSetAlwaysFatal sets the message levels which are always fatal, in any log
// domain. When a message with any of these levels is logged the program
// terminates. You can only set the levels defined by GLib to be fatal.
// G_LOG_LEVEL_ERROR is always fatal.
//
// You can also make some message levels fatal at runtime by setting the
// `G_DEBUG` environment variable (see Running GLib Applications
// (glib-running.html)).
//
// Libraries should not call this function, as it affects all messages logged by
// a process, including those from other libraries.
//
// Structured log messages (using g_log_structured() and
// g_log_structured_array()) are fatal only if the default log writer is used;
// otherwise it is up to the writer function to determine which log messages are
// fatal. See [Using Structured Logging][using-structured-logging].
func LogSetAlwaysFatal(fatalMask LogLevelFlags) LogLevelFlags {
	var _arg1 C.GLogLevelFlags // out
	var _cret C.GLogLevelFlags // in

	_arg1 = (C.GLogLevelFlags)(fatalMask)

	_cret = C.g_log_set_always_fatal(_arg1)

	var _logLevelFlags LogLevelFlags // out

	_logLevelFlags = LogLevelFlags(_cret)

	return _logLevelFlags
}

// LogSetFatalMask sets the log levels which are fatal in the given domain.
// G_LOG_LEVEL_ERROR is always fatal.
//
// This has no effect on structured log messages (using g_log_structured() or
// g_log_structured_array()). To change the fatal behaviour for specific log
// messages, programs must install a custom log writer function using
// g_log_set_writer_func(). See [Using Structured
// Logging][using-structured-logging].
//
// This function is mostly intended to be used with G_LOG_LEVEL_CRITICAL. You
// should typically not set G_LOG_LEVEL_WARNING, G_LOG_LEVEL_MESSAGE,
// G_LOG_LEVEL_INFO or G_LOG_LEVEL_DEBUG as fatal except inside of test
// programs.
func LogSetFatalMask(logDomain string, fatalMask LogLevelFlags) LogLevelFlags {
	var _arg1 *C.gchar         // out
	var _arg2 C.GLogLevelFlags // out
	var _cret C.GLogLevelFlags // in

	_arg1 = (*C.gchar)(C.CString(logDomain))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GLogLevelFlags)(fatalMask)

	_cret = C.g_log_set_fatal_mask(_arg1, _arg2)

	var _logLevelFlags LogLevelFlags // out

	_logLevelFlags = LogLevelFlags(_cret)

	return _logLevelFlags
}

// LogStructuredArray: log a message with structured data. The message will be
// passed through to the log writer set by the application using
// g_log_set_writer_func(). If the message is fatal (i.e. its log level is
// G_LOG_LEVEL_ERROR), the program will be aborted at the end of this function.
//
// See g_log_structured() for more documentation.
//
// This assumes that @log_level is already present in @fields (typically as the
// `PRIORITY` field).
func LogStructuredArray(logLevel LogLevelFlags, fields []LogField) {
	var _arg1 C.GLogLevelFlags // out
	var _arg2 *C.GLogField
	var _arg3 C.gsize

	_arg1 = (C.GLogLevelFlags)(logLevel)
	_arg3 = C.gsize(len(fields))
	_arg2 = (*C.GLogField)(unsafe.Pointer(&fields[0]))

	C.g_log_structured_array(_arg1, _arg2, _arg3)
}

// LogVariant: log a message with structured data, accepting the data within a
// #GVariant. This version is especially useful for use in other languages, via
// introspection.
//
// The only mandatory item in the @fields dictionary is the "MESSAGE" which must
// contain the text shown to the user.
//
// The values in the @fields dictionary are likely to be of type String
// (VARIANT_TYPE_STRING). Array of bytes (VARIANT_TYPE_BYTESTRING) is also
// supported. In this case the message is handled as binary and will be
// forwarded to the log writer as such. The size of the array should not be
// higher than G_MAXSSIZE. Otherwise it will be truncated to this size. For
// other types g_variant_print() will be used to convert the value into a
// string.
//
// For more details on its usage and about the parameters, see
// g_log_structured().
func LogVariant(logDomain string, logLevel LogLevelFlags, fields *Variant) {
	var _arg1 *C.gchar         // out
	var _arg2 C.GLogLevelFlags // out
	var _arg3 *C.GVariant      // out

	_arg1 = (*C.gchar)(C.CString(logDomain))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GLogLevelFlags)(logLevel)
	_arg3 = (*C.GVariant)(unsafe.Pointer(fields.Native()))

	C.g_log_variant(_arg1, _arg2, _arg3)
}

// LogWriterDefaultSetUseStderr: configure whether the built-in log functions
// (g_log_default_handler() for the old-style API, and both
// g_log_writer_default() and g_log_writer_standard_streams() for the structured
// API) will output all log messages to `stderr`.
//
// By default, log messages of levels G_LOG_LEVEL_INFO and G_LOG_LEVEL_DEBUG are
// sent to `stdout`, and other log messages are sent to `stderr`. This is
// problematic for applications that intend to reserve `stdout` for structured
// output such as JSON or XML.
//
// This function sets global state. It is not thread-aware, and should be called
// at the very start of a program, before creating any other threads or creating
// objects that could create worker threads of their own.
func LogWriterDefaultSetUseStderr(useStderr bool) {
	var _arg1 C.gboolean // out

	if useStderr {
		_arg1 = C.TRUE
	}

	C.g_log_writer_default_set_use_stderr(_arg1)
}

// LogWriterDefaultWouldDrop: check whether g_log_writer_default() and
// g_log_default_handler() would ignore a message with the given domain and
// level.
//
// As with g_log_default_handler(), this function drops debug and informational
// messages unless their log domain (or `all`) is listed in the space-separated
// `G_MESSAGES_DEBUG` environment variable.
//
// This can be used when implementing log writers with the same filtering
// behaviour as the default, but a different destination or output format:
//
//      if (!g_log_writer_default_would_drop (G_LOG_LEVEL_DEBUG, G_LOG_DOMAIN))
//        {
//          gchar *result = expensive_computation (my_object);
//
//          g_debug ("my_object result: s", result);
//          g_free (result);
//        }
func LogWriterDefaultWouldDrop(logLevel LogLevelFlags, logDomain string) bool {
	var _arg1 C.GLogLevelFlags // out
	var _arg2 *C.char          // out
	var _cret C.gboolean       // in

	_arg1 = (C.GLogLevelFlags)(logLevel)
	_arg2 = (*C.char)(C.CString(logDomain))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_log_writer_default_would_drop(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LogWriterFormatFields: format a structured log message as a string suitable
// for outputting to the terminal (or elsewhere). This will include the values
// of all fields it knows how to interpret, which includes `MESSAGE` and
// `GLIB_DOMAIN` (see the documentation for g_log_structured()). It does not
// include values from unknown fields.
//
// The returned string does **not** have a trailing new-line character. It is
// encoded in the character set of the current locale, which is not necessarily
// UTF-8.
func LogWriterFormatFields(logLevel LogLevelFlags, fields []LogField, useColor bool) string {
	var _arg1 C.GLogLevelFlags // out
	var _arg2 *C.GLogField
	var _arg3 C.gsize
	var _arg4 C.gboolean // out
	var _cret *C.gchar   // in

	_arg1 = (C.GLogLevelFlags)(logLevel)
	_arg3 = C.gsize(len(fields))
	_arg2 = (*C.GLogField)(unsafe.Pointer(&fields[0]))
	if useColor {
		_arg4 = C.TRUE
	}

	_cret = C.g_log_writer_format_fields(_arg1, _arg2, _arg3, _arg4)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// LogWriterIsJournald: check whether the given @output_fd file descriptor is a
// connection to the systemd journal, or something else (like a log file or
// `stdout` or `stderr`).
//
// Invalid file descriptors are accepted and return false, which allows for the
// following construct without needing any additional error handling:
//
//    is_journald = g_log_writer_is_journald (fileno (stderr));
func LogWriterIsJournald(outputFd int) bool {
	var _arg1 C.gint     // out
	var _cret C.gboolean // in

	_arg1 = (C.gint)(outputFd)

	_cret = C.g_log_writer_is_journald(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LogWriterSupportsColor: check whether the given @output_fd file descriptor
// supports ANSI color escape sequences. If so, they can safely be used when
// formatting log messages.
func LogWriterSupportsColor(outputFd int) bool {
	var _arg1 C.gint     // out
	var _cret C.gboolean // in

	_arg1 = (C.gint)(outputFd)

	_cret = C.g_log_writer_supports_color(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MainDepth returns the depth of the stack of calls to
// g_main_context_dispatch() on any Context in the current thread. That is, when
// called from the toplevel, it gives 0. When called from within a callback from
// g_main_context_iteration() (or g_main_loop_run(), etc.) it returns 1. When
// called from within a callback to a recursive call to
// g_main_context_iteration(), it returns 2. And so forth.
//
// This function is useful in a situation like the following: Imagine an
// extremely simple "garbage collected" system.
//
//    gpointer
//    allocate_memory (gsize size)
//    {
//      FreeListBlock *block = g_new (FreeListBlock, 1);
//      block->mem = g_malloc (size);
//      block->depth = g_main_depth ();
//      free_list = g_list_prepend (free_list, block);
//      return block->mem;
//    }
//
//    void
//    free_allocated_memory (void)
//    {
//      GList *l;
//
//      int depth = g_main_depth ();
//      for (l = free_list; l; );
//        {
//          GList *next = l->next;
//          FreeListBlock *block = l->data;
//          if (block->depth > depth)
//            {
//              g_free (block->mem);
//              g_free (block);
//              free_list = g_list_delete_link (free_list, l);
//            }
//
//          l = next;
//        }
//      }
//
// There is a temptation to use g_main_depth() to solve problems with
// reentrancy. For instance, while waiting for data to be received from the
// network in response to a menu item, the menu item might be selected again. It
// might seem that one could make the menu item's callback return immediately
// and do nothing if g_main_depth() returns a value greater than 1. However,
// this should be avoided since the user then sees selecting the menu item do
// nothing. Furthermore, you'll find yourself adding these checks all over your
// code, since there are doubtless many, many things that the user could do.
// Instead, you can use the following techniques:
//
// 1. Use gtk_widget_set_sensitive() or modal dialogs to prevent the user from
// interacting with elements while the main loop is recursing.
//
// 2. Avoid main loop recursion in situations where you can't handle arbitrary
// callbacks. Instead, structure your code so that you simply return to the main
// loop and then get called again when there is more work to do.
func MainDepth() int {
	var _cret C.gint // in

	_cret = C.g_main_depth()

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// MarkupEscapeText escapes text so that the markup parser will parse it
// verbatim. Less than, greater than, ampersand, etc. are replaced with the
// corresponding entities. This function would typically be used when writing
// out a file to be parsed with the markup parser.
//
// Note that this function doesn't protect whitespace and line endings from
// being processed according to the XML rules for normalization of line endings
// and attribute values.
//
// Note also that this function will produce character references in the range
// of &#x1; ... &#x1f; for all control sequences except for tabstop, newline and
// carriage return. The character references in this range are not valid XML
// 1.0, but they are valid XML 1.1 and will be accepted by the GMarkup parser.
func MarkupEscapeText(text string, length int) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gssize)(length)

	_cret = C.g_markup_escape_text(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// MkdirWithParents: create a directory if it doesn't already exist. Create
// intermediate parent directories as needed, too.
func MkdirWithParents(pathname string, mode int) int {
	var _arg1 *C.gchar // out
	var _arg2 C.gint   // out
	var _cret C.gint   // in

	_arg1 = (*C.gchar)(C.CString(pathname))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gint)(mode)

	_cret = C.g_mkdir_with_parents(_arg1, _arg2)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// ParseDebugString parses a string containing debugging options into a guint
// containing bit flags. This is used within GDK and GTK+ to parse the debug
// options passed on the command line or through environment variables.
//
// If @string is equal to "all", all flags are set. Any flags specified along
// with "all" in @string are inverted; thus, "all,foo,bar" or "foo,bar,all" sets
// all flags except those corresponding to "foo" and "bar".
//
// If @string is equal to "help", all the available keys in @keys are printed
// out to standard error.
func ParseDebugString(_string string, keys []DebugKey) uint {
	var _arg1 *C.gchar // out
	var _arg2 *C.GDebugKey
	var _arg3 C.guint
	var _cret C.guint // in

	_arg1 = (*C.gchar)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg1))
	_arg3 = C.guint(len(keys))
	_arg2 = (*C.GDebugKey)(unsafe.Pointer(&keys[0]))

	_cret = C.g_parse_debug_string(_arg1, _arg2, _arg3)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// PathGetBasename gets the last component of the filename.
//
// If @file_name ends with a directory separator it gets the component before
// the last slash. If @file_name consists only of directory separators (and on
// Windows, possibly a drive letter), a single separator is returned. If
// @file_name is empty, it gets ".".
func PathGetBasename(fileName string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_path_get_basename(_arg1)

	var _filename string // out

	_filename = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _filename
}

// PathGetDirname gets the directory components of a file name. For example, the
// directory component of `/usr/bin/test` is `/usr/bin`. The directory component
// of `/` is `/`.
//
// If the file name has no directory components "." is returned. The returned
// string should be freed when no longer needed.
func PathGetDirname(fileName string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_path_get_dirname(_arg1)

	var _filename string // out

	_filename = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _filename
}

// PathIsAbsolute returns true if the given @file_name is an absolute file name.
// Note that this is a somewhat vague concept on Windows.
//
// On POSIX systems, an absolute file name is well-defined. It always starts
// from the single root directory. For example "/usr/local".
//
// On Windows, the concepts of current drive and drive-specific current
// directory introduce vagueness. This function interprets as an absolute file
// name one that either begins with a directory separator such as "\Users\tml"
// or begins with the root on a drive, for example "C:\Windows". The first case
// also includes UNC paths such as "\\\\myserver\docs\foo". In all cases, either
// slashes or backslashes are accepted.
//
// Note that a file name relative to the current drive root does not truly
// specify a file uniquely over time and across processes, as the current drive
// is a per-process value and can be changed.
//
// File names relative the current directory on some specific drive, such as
// "D:foo/bar", are not interpreted as absolute by this function, but they
// obviously are not relative to the normal current directory as returned by
// getcwd() or g_get_current_dir() either. Such paths should be avoided, or need
// to be handled using Windows-specific code.
func PathIsAbsolute(fileName string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_path_is_absolute(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PathSkipRoot returns a pointer into @file_name after the root component, i.e.
// after the "/" in UNIX or "C:\" under Windows. If @file_name is not an
// absolute path it returns nil.
func PathSkipRoot(fileName string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_path_skip_root(_arg1)

	var _filename string // out

	_filename = C.GoString(_cret)

	return _filename
}

// PatternMatch matches a string against a compiled pattern. Passing the correct
// length of the string given is mandatory. The reversed string can be omitted
// by passing nil, this is more efficient if the reversed version of the string
// to be matched is not at hand, as g_pattern_match() will only construct it if
// the compiled pattern requires reverse matches.
//
// Note that, if the user code will (possibly) match a string against a
// multitude of patterns containing wildcards, chances are high that some
// patterns will require a reversed string. In this case, it's more efficient to
// provide the reversed string to avoid multiple constructions thereof in the
// various calls to g_pattern_match().
//
// Note also that the reverse of a UTF-8 encoded string can in general not be
// obtained by g_strreverse(). This works only if the string does not contain
// any multibyte characters. GLib offers the g_utf8_strreverse() function to
// reverse UTF-8 encoded strings.
func PatternMatch(pspec *PatternSpec, stringLength uint, _string string, stringReversed string) bool {
	var _arg1 *C.GPatternSpec // out
	var _arg2 C.guint         // out
	var _arg3 *C.gchar        // out
	var _arg4 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg1 = (*C.GPatternSpec)(unsafe.Pointer(pspec.Native()))
	_arg2 = (C.guint)(stringLength)
	_arg3 = (*C.gchar)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(C.CString(stringReversed))
	defer C.free(unsafe.Pointer(_arg4))

	_cret = C.g_pattern_match(_arg1, _arg2, _arg3, _arg4)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PatternMatchSimple matches a string against a pattern given as a string. If
// this function is to be called in a loop, it's more efficient to compile the
// pattern once with g_pattern_spec_new() and call g_pattern_match_string()
// repeatedly.
func PatternMatchSimple(pattern string, _string string) bool {
	var _arg1 *C.gchar   // out
	var _arg2 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(C.CString(pattern))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_pattern_match_simple(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PatternMatchString matches a string against a compiled pattern. If the string
// is to be matched against more than one pattern, consider using
// g_pattern_match() instead while supplying the reversed string.
func PatternMatchString(pspec *PatternSpec, _string string) bool {
	var _arg1 *C.GPatternSpec // out
	var _arg2 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg1 = (*C.GPatternSpec)(unsafe.Pointer(pspec.Native()))
	_arg2 = (*C.gchar)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_pattern_match_string(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Poll polls @fds, as with the poll() system call, but portably. (On systems
// that don't have poll(), it is emulated using select().) This is used
// internally by Context, but it can be called directly if you need to block
// until a file descriptor is ready, but don't want to run the full main loop.
//
// Each element of @fds is a FD describing a single file descriptor to poll. The
// @fd field indicates the file descriptor, and the @events field indicates the
// events to poll for. On return, the @revents fields will be filled with the
// events that actually occurred.
//
// On POSIX systems, the file descriptors in @fds can be any sort of file
// descriptor, but the situation is much more complicated on Windows. If you
// need to use g_poll() in code that has to run on Windows, the easiest solution
// is to construct all of your FDs with g_io_channel_win32_make_pollfd().
func Poll(fds *PollFD, nfds uint, timeout int) int {
	var _arg1 *C.GPollFD // out
	var _arg2 C.guint    // out
	var _arg3 C.gint     // out
	var _cret C.gint     // in

	_arg1 = (*C.GPollFD)(unsafe.Pointer(fds.Native()))
	_arg2 = (C.guint)(nfds)
	_arg3 = (C.gint)(timeout)

	_cret = C.g_poll(_arg1, _arg2, _arg3)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// RandomDouble returns a random #gdouble equally distributed over the range
// [0..1).
func RandomDouble() float64 {
	var _cret C.gdouble // in

	_cret = C.g_random_double()

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// RandomDoubleRange returns a random #gdouble equally distributed over the
// range [@begin..@end).
func RandomDoubleRange(begin float64, end float64) float64 {
	var _arg1 C.gdouble // out
	var _arg2 C.gdouble // out
	var _cret C.gdouble // in

	_arg1 = (C.gdouble)(begin)
	_arg2 = (C.gdouble)(end)

	_cret = C.g_random_double_range(_arg1, _arg2)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// RandomInt: return a random #guint32 equally distributed over the range
// [0..2^32-1].
func RandomInt() uint32 {
	var _cret C.guint32 // in

	_cret = C.g_random_int()

	var _guint32 uint32 // out

	_guint32 = (uint32)(_cret)

	return _guint32
}

// RandomIntRange returns a random #gint32 equally distributed over the range
// [@begin..@end-1].
func RandomIntRange(begin int32, end int32) int32 {
	var _arg1 C.gint32 // out
	var _arg2 C.gint32 // out
	var _cret C.gint32 // in

	_arg1 = (C.gint32)(begin)
	_arg2 = (C.gint32)(end)

	_cret = C.g_random_int_range(_arg1, _arg2)

	var _gint32 int32 // out

	_gint32 = (int32)(_cret)

	return _gint32
}

// RandomSetSeed sets the seed for the global random number generator, which is
// used by the g_random_* functions, to @seed.
func RandomSetSeed(seed uint32) {
	var _arg1 C.guint32 // out

	_arg1 = (C.guint32)(seed)

	C.g_random_set_seed(_arg1)
}

// ReloadUserSpecialDirsCache resets the cache used for
// g_get_user_special_dir(), so that the latest on-disk version is used. Call
// this only if you just changed the data on disk yourself.
//
// Due to thread safety issues this may cause leaking of strings that were
// previously returned from g_get_user_special_dir() that can't be freed. We
// ensure to only leak the data for the directories that actually changed value
// though.
func ReloadUserSpecialDirsCache() {
	C.g_reload_user_special_dirs_cache()
}

// SetApplicationName sets a human-readable name for the application. This name
// should be localized if possible, and is intended for display to the user.
// Contrast with g_set_prgname(), which sets a non-localized name.
// g_set_prgname() will be called automatically by gtk_init(), but
// g_set_application_name() will not.
//
// Note that for thread safety reasons, this function can only be called once.
//
// The application name will be used in contexts such as error messages, or when
// displaying an application's name in the task list.
func SetApplicationName(applicationName string) {
	var _arg1 *C.gchar // out

	_arg1 = (*C.gchar)(C.CString(applicationName))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_set_application_name(_arg1)
}

// SetPrgname sets the name of the program. This name should not be localized,
// in contrast to g_set_application_name().
//
// If you are using #GApplication the program name is set in
// g_application_run(). In case of GDK or GTK+ it is set in gdk_init(), which is
// called by gtk_init() and the Application::startup handler. The program name
// is found by taking the last component of @argv[0].
//
// Note that for thread-safety reasons this function can only be called once.
func SetPrgname(prgname string) {
	var _arg1 *C.gchar // out

	_arg1 = (*C.gchar)(C.CString(prgname))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_set_prgname(_arg1)
}

// Setenv sets an environment variable. On UNIX, both the variable's name and
// value can be arbitrary byte strings, except that the variable's name cannot
// contain '='. On Windows, they should be in UTF-8.
//
// Note that on some systems, when variables are overwritten, the memory used
// for the previous variables and its value isn't reclaimed.
//
// You should be mindful of the fact that environment variable handling in UNIX
// is not thread-safe, and your program may crash if one thread calls g_setenv()
// while another thread is calling getenv(). (And note that many functions, such
// as gettext(), call getenv() internally.) This function is only safe to use at
// the very start of your program, before creating any other threads (or
// creating objects that create worker threads of their own).
//
// If you need to set up the environment for a child process, you can use
// g_get_environ() to get an environment array, modify that with
// g_environ_setenv() and g_environ_unsetenv(), and then pass that array
// directly to execvpe(), g_spawn_async(), or the like.
func Setenv(variable string, value string, overwrite bool) bool {
	var _arg1 *C.gchar   // out
	var _arg2 *C.gchar   // out
	var _arg3 C.gboolean // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(C.CString(variable))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg2))
	if overwrite {
		_arg3 = C.TRUE
	}

	_cret = C.g_setenv(_arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShellParseArgv parses a command line into an argument vector, in much the
// same way the shell would, but without many of the expansions the shell would
// perform (variable expansion, globs, operators, filename expansion, etc. are
// not supported). The results are defined to be the same as those you would get
// from a UNIX98 /bin/sh, as long as the input contains none of the unsupported
// shell expansions. If the input does contain such expansions, they are passed
// through literally. Possible errors are those from the SHELL_ERROR domain.
// Free the returned vector with g_strfreev().
func ShellParseArgv(commandLine string) ([]string, error) {
	var _arg1 *C.gchar // out
	var _arg3 **C.gchar
	var _arg2 C.gint    // in
	var _cerr *C.GError // in

	_arg1 = (*C.gchar)(C.CString(commandLine))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_shell_parse_argv(_arg1, &_arg2, &_arg3, &_cerr)

	var _argvp []string
	var _goerr error // out

	defer C.free(unsafe.Pointer(_arg3))
	{
		src := unsafe.Slice(_arg3, _arg2)
		_argvp = make([]string, _arg2)
		for i := 0; i < int(_arg2); i++ {
			_argvp[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _argvp, _goerr
}

// ShellQuote quotes a string so that the shell (/bin/sh) will interpret the
// quoted string to mean @unquoted_string. If you pass a filename to the shell,
// for example, you should first quote it with this function. The return value
// must be freed with g_free(). The quoting style used is undefined (single or
// double quotes may be used).
func ShellQuote(unquotedString string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(unquotedString))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_shell_quote(_arg1)

	var _filename string // out

	_filename = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _filename
}

// ShellUnquote unquotes a string as the shell (/bin/sh) would. Only handles
// quotes; if a string contains file globs, arithmetic operators, variables,
// backticks, redirections, or other special-to-the-shell features, the result
// will be different from the result a real shell would produce (the variables,
// backticks, etc. will be passed through literally instead of being expanded).
// This function is guaranteed to succeed if applied to the result of
// g_shell_quote(). If it fails, it returns nil and sets the error. The
// @quoted_string need not actually contain quoted or escaped text;
// g_shell_unquote() simply goes through the string and unquotes/unescapes
// anything that the shell would. Both single and double quotes are handled, as
// are escapes including escaped newlines. The return value must be freed with
// g_free(). Possible errors are in the SHELL_ERROR domain.
//
// Shell quoting rules are a bit strange. Single quotes preserve the literal
// string exactly. escape sequences are not allowed; not even \' - if you want a
// ' in the quoted text, you have to do something like 'foo'\”bar'. Double
// quotes allow $, `, ", \, and newline to be escaped with backslash. Otherwise
// double quotes preserve things literally.
func ShellUnquote(quotedString string) (string, error) {
	var _arg1 *C.gchar  // out
	var _cret *C.gchar  // in
	var _cerr *C.GError // in

	_arg1 = (*C.gchar)(C.CString(quotedString))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_shell_unquote(_arg1, &_cerr)

	var _filename string // out
	var _goerr error     // out

	_filename = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _filename, _goerr
}

// SpacedPrimesClosest gets the smallest prime number from a built-in array of
// primes which is larger than @num. This is used within GLib to calculate the
// optimum size of a Table.
//
// The built-in array of primes ranges from 11 to 13845163 such that each prime
// is approximately 1.5-2 times the previous prime.
func SpacedPrimesClosest(num uint) uint {
	var _arg1 C.guint // out
	var _cret C.guint // in

	_arg1 = (C.guint)(num)

	_cret = C.g_spaced_primes_closest(_arg1)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// SpawnCheckExitStatus: set @error if @exit_status indicates the child exited
// abnormally (e.g. with a nonzero exit code, or via a fatal signal).
//
// The g_spawn_sync() and g_child_watch_add() family of APIs return an exit
// status for subprocesses encoded in a platform-specific way. On Unix, this is
// guaranteed to be in the same format waitpid() returns, and on Windows it is
// guaranteed to be the result of GetExitCodeProcess().
//
// Prior to the introduction of this function in GLib 2.34, interpreting
// @exit_status required use of platform-specific APIs, which is problematic for
// software using GLib as a cross-platform layer.
//
// Additionally, many programs simply want to determine whether or not the child
// exited successfully, and either propagate a #GError or print a message to
// standard error. In that common case, this function can be used. Note that the
// error message in @error will contain human-readable information about the
// exit status.
//
// The @domain and @code of @error have special semantics in the case where the
// process has an "exit code", as opposed to being killed by a signal. On Unix,
// this happens if WIFEXITED() would be true of @exit_status. On Windows, it is
// always the case.
//
// The special semantics are that the actual exit code will be the code set in
// @error, and the domain will be G_SPAWN_EXIT_ERROR. This allows you to
// differentiate between different exit codes.
//
// If the process was terminated by some means other than an exit status, the
// domain will be G_SPAWN_ERROR, and the code will be G_SPAWN_ERROR_FAILED.
//
// This function just offers convenience; you can of course also check the
// available platform via a macro such as G_OS_UNIX, and use WIFEXITED() and
// WEXITSTATUS() on @exit_status directly. Do not attempt to scan or parse the
// error message string; it may be translated and/or change in future versions
// of GLib.
func SpawnCheckExitStatus(exitStatus int) error {
	var _arg1 C.gint    // out
	var _cerr *C.GError // in

	_arg1 = (C.gint)(exitStatus)

	C.g_spawn_check_exit_status(_arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// SpawnCommandLineAsync: a simple version of g_spawn_async() that parses a
// command line with g_shell_parse_argv() and passes it to g_spawn_async(). Runs
// a command line in the background. Unlike g_spawn_async(), the
// G_SPAWN_SEARCH_PATH flag is enabled, other flags are not. Note that
// G_SPAWN_SEARCH_PATH can have security implications, so consider using
// g_spawn_async() directly if appropriate. Possible errors are those from
// g_shell_parse_argv() and g_spawn_async().
//
// The same concerns on Windows apply as for g_spawn_command_line_sync().
func SpawnCommandLineAsync(commandLine string) error {
	var _arg1 *C.gchar  // out
	var _cerr *C.GError // in

	_arg1 = (*C.gchar)(C.CString(commandLine))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_spawn_command_line_async(_arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// SpawnCommandLineSync: a simple version of g_spawn_sync() with little-used
// parameters removed, taking a command line instead of an argument vector. See
// g_spawn_sync() for full details. @command_line will be parsed by
// g_shell_parse_argv(). Unlike g_spawn_sync(), the G_SPAWN_SEARCH_PATH flag is
// enabled. Note that G_SPAWN_SEARCH_PATH can have security implications, so
// consider using g_spawn_sync() directly if appropriate. Possible errors are
// those from g_spawn_sync() and those from g_shell_parse_argv().
//
// If @exit_status is non-nil, the platform-specific exit status of the child is
// stored there; see the documentation of g_spawn_check_exit_status() for how to
// use and interpret this.
//
// On Windows, please note the implications of g_shell_parse_argv() parsing
// @command_line. Parsing is done according to Unix shell rules, not Windows
// command interpreter rules. Space is a separator, and backslashes are special.
// Thus you cannot simply pass a @command_line containing canonical Windows
// paths, like "c:\\program files\\app\\app.exe", as the backslashes will be
// eaten, and the space will act as a separator. You need to enclose such paths
// with single quotes, like "'c:\\program files\\app\\app.exe'
// 'e:\\folder\\argument.txt'".
func SpawnCommandLineSync(commandLine string) (standardOutput []byte, standardError []byte, exitStatus int, goerr error) {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar
	var _arg3 *C.gchar
	var _arg4 C.gint    // in
	var _cerr *C.GError // in

	_arg1 = (*C.gchar)(C.CString(commandLine))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_spawn_command_line_sync(_arg1, &_arg2, &_arg3, &_arg4, &_cerr)

	var _standardOutput []byte
	var _standardError []byte
	var _exitStatus int // out
	var _goerr error    // out

	{
		var i int
		var z C.gchar
		for p := _arg2; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_arg2, i)
		_standardOutput = make([]byte, i)
		for i := range src {
			_standardOutput[i] = (byte)(src[i])
		}
	}
	{
		var i int
		var z C.gchar
		for p := _arg3; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_arg3, i)
		_standardError = make([]byte, i)
		for i := range src {
			_standardError[i] = (byte)(src[i])
		}
	}
	_exitStatus = (int)(_arg4)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _standardOutput, _standardError, _exitStatus, _goerr
}

// StripContext: an auxiliary function for gettext() support (see Q_()).
func StripContext(msgid string, msgval string) string {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(msgid))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(msgval))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_strip_context(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func StrvGetType() externglib.Type {
	var _cret C.GType // in

	_cret = C.g_strv_get_type()

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

// Ucs4ToUTF16: convert a string from UCS-4 to UTF-16. A 0 character will be
// added to the result after the converted text.
func Ucs4ToUTF16(str *uint32, len int32) (itemsRead int32, itemsWritten int32, guint16 *uint16, goerr error) {
	var _arg1 *C.gunichar  // out
	var _arg2 C.glong      // out
	var _arg3 C.glong      // in
	var _arg4 C.glong      // in
	var _cret *C.gunichar2 // in
	var _cerr *C.GError    // in

	_arg1 = (*C.gunichar)(unsafe.Pointer(str))
	_arg2 = (C.glong)(len)

	_cret = C.g_ucs4_to_utf16(_arg1, _arg2, &_arg3, &_arg4, &_cerr)

	var _itemsRead int32    // out
	var _itemsWritten int32 // out
	var _guint16 *uint16    // out
	var _goerr error        // out

	_itemsRead = (int32)(_arg3)
	_itemsWritten = (int32)(_arg4)
	_guint16 = (*uint16)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _itemsRead, _itemsWritten, _guint16, _goerr
}

// Ucs4ToUTF8: convert a string from a 32-bit fixed width representation as
// UCS-4. to UTF-8. The result will be terminated with a 0 byte.
func Ucs4ToUTF8(str *uint32, len int32) (itemsRead int32, itemsWritten int32, utf8 string, goerr error) {
	var _arg1 *C.gunichar // out
	var _arg2 C.glong     // out
	var _arg3 C.glong     // in
	var _arg4 C.glong     // in
	var _cret *C.gchar    // in
	var _cerr *C.GError   // in

	_arg1 = (*C.gunichar)(unsafe.Pointer(str))
	_arg2 = (C.glong)(len)

	_cret = C.g_ucs4_to_utf8(_arg1, _arg2, &_arg3, &_arg4, &_cerr)

	var _itemsRead int32    // out
	var _itemsWritten int32 // out
	var _utf8 string        // out
	var _goerr error        // out

	_itemsRead = (int32)(_arg3)
	_itemsWritten = (int32)(_arg4)
	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _itemsRead, _itemsWritten, _utf8, _goerr
}

// UnicharBreakType determines the break type of @c. @c should be a Unicode
// character (to derive a character from UTF-8 encoded text, use
// g_utf8_get_char()). The break type is used to find word and line breaks
// ("text boundaries"), Pango implements the Unicode boundary resolution
// algorithms and normally you would use a function such as pango_break()
// instead of caring about break types yourself.
func UnicharBreakType(c uint32) UnicodeBreakType {
	var _arg1 C.gunichar          // out
	var _cret C.GUnicodeBreakType // in

	_arg1 = (C.gunichar)(c)

	_cret = C.g_unichar_break_type(_arg1)

	var _unicodeBreakType UnicodeBreakType // out

	_unicodeBreakType = UnicodeBreakType(_cret)

	return _unicodeBreakType
}

// UnicharCombiningClass determines the canonical combining class of a Unicode
// character.
func UnicharCombiningClass(uc uint32) int {
	var _arg1 C.gunichar // out
	var _cret C.gint     // in

	_arg1 = (C.gunichar)(uc)

	_cret = C.g_unichar_combining_class(_arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// UnicharCompose performs a single composition step of the Unicode canonical
// composition algorithm.
//
// This function includes algorithmic Hangul Jamo composition, but it is not
// exactly the inverse of g_unichar_decompose(). No composition can have either
// of @a or @b equal to zero. To be precise, this function composes if and only
// if there exists a Primary Composite P which is canonically equivalent to the
// sequence <@a,@b>. See the Unicode Standard for the definition of Primary
// Composite.
//
// If @a and @b do not compose a new character, @ch is set to zero.
//
// See UAX#15 (http://unicode.org/reports/tr15/) for details.
func UnicharCompose(a uint32, b uint32) (uint32, bool) {
	var _arg1 C.gunichar // out
	var _arg2 C.gunichar // out
	var _arg3 C.gunichar // in
	var _cret C.gboolean // in

	_arg1 = (C.gunichar)(a)
	_arg2 = (C.gunichar)(b)

	_cret = C.g_unichar_compose(_arg1, _arg2, &_arg3)

	var _ch uint32 // out
	var _ok bool   // out

	_ch = (uint32)(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _ch, _ok
}

// UnicharDecompose performs a single decomposition step of the Unicode
// canonical decomposition algorithm.
//
// This function does not include compatibility decompositions. It does,
// however, include algorithmic Hangul Jamo decomposition, as well as
// 'singleton' decompositions which replace a character by a single other
// character. In the case of singletons *@b will be set to zero.
//
// If @ch is not decomposable, *@a is set to @ch and *@b is set to zero.
//
// Note that the way Unicode decomposition pairs are defined, it is guaranteed
// that @b would not decompose further, but @a may itself decompose. To get the
// full canonical decomposition for @ch, one would need to recursively call this
// function on @a. Or use g_unichar_fully_decompose().
//
// See UAX#15 (http://unicode.org/reports/tr15/) for details.
func UnicharDecompose(ch uint32) (a uint32, b uint32, ok bool) {
	var _arg1 C.gunichar // out
	var _arg2 C.gunichar // in
	var _arg3 C.gunichar // in
	var _cret C.gboolean // in

	_arg1 = (C.gunichar)(ch)

	_cret = C.g_unichar_decompose(_arg1, &_arg2, &_arg3)

	var _a uint32 // out
	var _b uint32 // out
	var _ok bool  // out

	_a = (uint32)(_arg2)
	_b = (uint32)(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _a, _b, _ok
}

// UnicharDigitValue determines the numeric value of a character as a decimal
// digit.
func UnicharDigitValue(c uint32) int {
	var _arg1 C.gunichar // out
	var _cret C.gint     // in

	_arg1 = (C.gunichar)(c)

	_cret = C.g_unichar_digit_value(_arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// UnicharFullyDecompose computes the canonical or compatibility decomposition
// of a Unicode character. For compatibility decomposition, pass true for
// @compat; for canonical decomposition pass false for @compat.
//
// The decomposed sequence is placed in @result. Only up to @result_len
// characters are written into @result. The length of the full decomposition
// (irrespective of @result_len) is returned by the function. For canonical
// decomposition, currently all decompositions are of length at most 4, but this
// may change in the future (very unlikely though). At any rate, Unicode does
// guarantee that a buffer of length 18 is always enough for both compatibility
// and canonical decompositions, so that is the size recommended. This is
// provided as G_UNICHAR_MAX_DECOMPOSITION_LENGTH.
//
// See UAX#15 (http://unicode.org/reports/tr15/) for details.
func UnicharFullyDecompose(ch uint32, compat bool, resultLen uint) (uint32, uint) {
	var _arg1 C.gunichar // out
	var _arg2 C.gboolean // out
	var _arg3 C.gunichar // in
	var _arg4 C.gsize    // out
	var _cret C.gsize    // in

	_arg1 = (C.gunichar)(ch)
	if compat {
		_arg2 = C.TRUE
	}
	_arg4 = (C.gsize)(resultLen)

	_cret = C.g_unichar_fully_decompose(_arg1, _arg2, &_arg3, _arg4)

	var _result uint32 // out
	var _gsize uint    // out

	_result = (uint32)(_arg3)
	_gsize = (uint)(_cret)

	return _result, _gsize
}

// UnicharGetMirrorChar: in Unicode, some characters are "mirrored". This means
// that their images are mirrored horizontally in text that is laid out from
// right to left. For instance, "(" would become its mirror image, ")", in
// right-to-left text.
//
// If @ch has the Unicode mirrored property and there is another unicode
// character that typically has a glyph that is the mirror image of @ch's glyph
// and @mirrored_ch is set, it puts that character in the address pointed to by
// @mirrored_ch. Otherwise the original character is put.
func UnicharGetMirrorChar(ch uint32, mirroredCh *uint32) bool {
	var _arg1 C.gunichar  // out
	var _arg2 *C.gunichar // out
	var _cret C.gboolean  // in

	_arg1 = (C.gunichar)(ch)
	_arg2 = (*C.gunichar)(unsafe.Pointer(mirroredCh))

	_cret = C.g_unichar_get_mirror_char(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharGetScript looks up the Script for a particular character (as defined
// by Unicode Standard Annex \#24). No check is made for @ch being a valid
// Unicode character; if you pass in invalid character, the result is undefined.
//
// This function is equivalent to pango_script_for_unichar() and the two are
// interchangeable.
func UnicharGetScript(ch uint32) UnicodeScript {
	var _arg1 C.gunichar       // out
	var _cret C.GUnicodeScript // in

	_arg1 = (C.gunichar)(ch)

	_cret = C.g_unichar_get_script(_arg1)

	var _unicodeScript UnicodeScript // out

	_unicodeScript = UnicodeScript(_cret)

	return _unicodeScript
}

// UnicharIsalnum determines whether a character is alphanumeric. Given some
// UTF-8 text, obtain a character value with g_utf8_get_char().
func UnicharIsalnum(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = (C.gunichar)(c)

	_cret = C.g_unichar_isalnum(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsalpha determines whether a character is alphabetic (i.e. a letter).
// Given some UTF-8 text, obtain a character value with g_utf8_get_char().
func UnicharIsalpha(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = (C.gunichar)(c)

	_cret = C.g_unichar_isalpha(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIscntrl determines whether a character is a control character. Given
// some UTF-8 text, obtain a character value with g_utf8_get_char().
func UnicharIscntrl(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = (C.gunichar)(c)

	_cret = C.g_unichar_iscntrl(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsdefined determines if a given character is assigned in the Unicode
// standard.
func UnicharIsdefined(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = (C.gunichar)(c)

	_cret = C.g_unichar_isdefined(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsdigit determines whether a character is numeric (i.e. a digit). This
// covers ASCII 0-9 and also digits in other languages/scripts. Given some UTF-8
// text, obtain a character value with g_utf8_get_char().
func UnicharIsdigit(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = (C.gunichar)(c)

	_cret = C.g_unichar_isdigit(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsgraph determines whether a character is printable and not a space
// (returns false for control characters, format characters, and spaces).
// g_unichar_isprint() is similar, but returns true for spaces. Given some UTF-8
// text, obtain a character value with g_utf8_get_char().
func UnicharIsgraph(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = (C.gunichar)(c)

	_cret = C.g_unichar_isgraph(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIslower determines whether a character is a lowercase letter. Given
// some UTF-8 text, obtain a character value with g_utf8_get_char().
func UnicharIslower(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = (C.gunichar)(c)

	_cret = C.g_unichar_islower(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsmark determines whether a character is a mark (non-spacing mark,
// combining mark, or enclosing mark in Unicode speak). Given some UTF-8 text,
// obtain a character value with g_utf8_get_char().
//
// Note: in most cases where isalpha characters are allowed, ismark characters
// should be allowed to as they are essential for writing most European
// languages as well as many non-Latin scripts.
func UnicharIsmark(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = (C.gunichar)(c)

	_cret = C.g_unichar_ismark(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsprint determines whether a character is printable. Unlike
// g_unichar_isgraph(), returns true for spaces. Given some UTF-8 text, obtain a
// character value with g_utf8_get_char().
func UnicharIsprint(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = (C.gunichar)(c)

	_cret = C.g_unichar_isprint(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIspunct determines whether a character is punctuation or a symbol.
// Given some UTF-8 text, obtain a character value with g_utf8_get_char().
func UnicharIspunct(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = (C.gunichar)(c)

	_cret = C.g_unichar_ispunct(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsspace determines whether a character is a space, tab, or line
// separator (newline, carriage return, etc.). Given some UTF-8 text, obtain a
// character value with g_utf8_get_char().
//
// (Note: don't use this to do word breaking; you have to use Pango or
// equivalent to get word breaking right, the algorithm is fairly complex.)
func UnicharIsspace(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = (C.gunichar)(c)

	_cret = C.g_unichar_isspace(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIstitle determines if a character is titlecase. Some characters in
// Unicode which are composites, such as the DZ digraph have three case variants
// instead of just two. The titlecase form is used at the beginning of a word
// where only the first letter is capitalized. The titlecase form of the DZ
// digraph is U+01F2 LATIN CAPITAL LETTTER D WITH SMALL LETTER Z.
func UnicharIstitle(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = (C.gunichar)(c)

	_cret = C.g_unichar_istitle(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsupper determines if a character is uppercase.
func UnicharIsupper(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = (C.gunichar)(c)

	_cret = C.g_unichar_isupper(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIswide determines if a character is typically rendered in a
// double-width cell.
func UnicharIswide(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = (C.gunichar)(c)

	_cret = C.g_unichar_iswide(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIswideCjk determines if a character is typically rendered in a
// double-width cell under legacy East Asian locales. If a character is wide
// according to g_unichar_iswide(), then it is also reported wide with this
// function, but the converse is not necessarily true. See the Unicode Standard
// Annex #11 (http://www.unicode.org/reports/tr11/) for details.
//
// If a character passes the g_unichar_iswide() test then it will also pass this
// test, but not the other way around. Note that some characters may pass both
// this test and g_unichar_iszerowidth().
func UnicharIswideCjk(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = (C.gunichar)(c)

	_cret = C.g_unichar_iswide_cjk(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsxdigit determines if a character is a hexadecimal digit.
func UnicharIsxdigit(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = (C.gunichar)(c)

	_cret = C.g_unichar_isxdigit(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIszerowidth determines if a given character typically takes zero width
// when rendered. The return value is true for all non-spacing and enclosing
// marks (e.g., combining accents), format characters, zero-width space, but not
// U+00AD SOFT HYPHEN.
//
// A typical use of this function is with one of g_unichar_iswide() or
// g_unichar_iswide_cjk() to determine the number of cells a string occupies
// when displayed on a grid display (terminals). However, note that not all
// terminals support zero-width rendering of zero-width marks.
func UnicharIszerowidth(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = (C.gunichar)(c)

	_cret = C.g_unichar_iszerowidth(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharToLower converts a character to lower case.
func UnicharToLower(c uint32) uint32 {
	var _arg1 C.gunichar // out
	var _cret C.gunichar // in

	_arg1 = (C.gunichar)(c)

	_cret = C.g_unichar_tolower(_arg1)

	var _gunichar uint32 // out

	_gunichar = (uint32)(_cret)

	return _gunichar
}

// UnicharToTitle converts a character to the titlecase.
func UnicharToTitle(c uint32) uint32 {
	var _arg1 C.gunichar // out
	var _cret C.gunichar // in

	_arg1 = (C.gunichar)(c)

	_cret = C.g_unichar_totitle(_arg1)

	var _gunichar uint32 // out

	_gunichar = (uint32)(_cret)

	return _gunichar
}

// UnicharToUpper converts a character to uppercase.
func UnicharToUpper(c uint32) uint32 {
	var _arg1 C.gunichar // out
	var _cret C.gunichar // in

	_arg1 = (C.gunichar)(c)

	_cret = C.g_unichar_toupper(_arg1)

	var _gunichar uint32 // out

	_gunichar = (uint32)(_cret)

	return _gunichar
}

// UnicharType classifies a Unicode character by type.
func UnicharType(c uint32) UnicodeType {
	var _arg1 C.gunichar     // out
	var _cret C.GUnicodeType // in

	_arg1 = (C.gunichar)(c)

	_cret = C.g_unichar_type(_arg1)

	var _unicodeType UnicodeType // out

	_unicodeType = UnicodeType(_cret)

	return _unicodeType
}

// UnicharValidate checks whether @ch is a valid Unicode character. Some
// possible integer values of @ch will not be valid. 0 is considered a valid
// character, though it's normally a string terminator.
func UnicharValidate(ch uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = (C.gunichar)(ch)

	_cret = C.g_unichar_validate(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharXDigitValue determines the numeric value of a character as a
// hexadecimal digit.
func UnicharXDigitValue(c uint32) int {
	var _arg1 C.gunichar // out
	var _cret C.gint     // in

	_arg1 = (C.gunichar)(c)

	_cret = C.g_unichar_xdigit_value(_arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// UnicodeCanonicalDecomposition computes the canonical decomposition of a
// Unicode character.
func UnicodeCanonicalDecomposition(ch uint32, resultLen *uint) *uint32 {
	var _arg1 C.gunichar  // out
	var _arg2 *C.gsize    // out
	var _cret *C.gunichar // in

	_arg1 = (C.gunichar)(ch)
	_arg2 = (*C.gsize)(unsafe.Pointer(resultLen))

	_cret = C.g_unicode_canonical_decomposition(_arg1, _arg2)

	var _gunichar *uint32 // out

	_gunichar = (*uint32)(_cret)

	return _gunichar
}

// UnicodeCanonicalOrdering computes the canonical ordering of a string
// in-place. This rearranges decomposed characters in the string according to
// their combining classes. See the Unicode manual for more information.
func UnicodeCanonicalOrdering(_string *uint32, len uint) {
	var _arg1 *C.gunichar // out
	var _arg2 C.gsize     // out

	_arg1 = (*C.gunichar)(unsafe.Pointer(_string))
	_arg2 = (C.gsize)(len)

	C.g_unicode_canonical_ordering(_arg1, _arg2)
}

// UnicodeScriptFromISO15924 looks up the Unicode script for @iso15924. ISO
// 15924 assigns four-letter codes to scripts. For example, the code for Arabic
// is 'Arab'. This function accepts four letter codes encoded as a @guint32 in a
// big-endian fashion. That is, the code expected for Arabic is 0x41726162 (0x41
// is ASCII code for 'A', 0x72 is ASCII code for 'r', etc).
//
// See Codes for the representation of names of scripts
// (http://unicode.org/iso15924/codelists.html) for details.
func UnicodeScriptFromISO15924(iso15924 uint32) UnicodeScript {
	var _arg1 C.guint32        // out
	var _cret C.GUnicodeScript // in

	_arg1 = (C.guint32)(iso15924)

	_cret = C.g_unicode_script_from_iso15924(_arg1)

	var _unicodeScript UnicodeScript // out

	_unicodeScript = UnicodeScript(_cret)

	return _unicodeScript
}

// UnicodeScriptToISO15924 looks up the ISO 15924 code for @script. ISO 15924
// assigns four-letter codes to scripts. For example, the code for Arabic is
// 'Arab'. The four letter codes are encoded as a @guint32 by this function in a
// big-endian fashion. That is, the code returned for Arabic is 0x41726162 (0x41
// is ASCII code for 'A', 0x72 is ASCII code for 'r', etc).
//
// See Codes for the representation of names of scripts
// (http://unicode.org/iso15924/codelists.html) for details.
func UnicodeScriptToISO15924(script UnicodeScript) uint32 {
	var _arg1 C.GUnicodeScript // out
	var _cret C.guint32        // in

	_arg1 = (C.GUnicodeScript)(script)

	_cret = C.g_unicode_script_to_iso15924(_arg1)

	var _guint32 uint32 // out

	_guint32 = (uint32)(_cret)

	return _guint32
}

// Unsetenv removes an environment variable from the environment.
//
// Note that on some systems, when variables are overwritten, the memory used
// for the previous variables and its value isn't reclaimed.
//
// You should be mindful of the fact that environment variable handling in UNIX
// is not thread-safe, and your program may crash if one thread calls
// g_unsetenv() while another thread is calling getenv(). (And note that many
// functions, such as gettext(), call getenv() internally.) This function is
// only safe to use at the very start of your program, before creating any other
// threads (or creating objects that create worker threads of their own).
//
// If you need to set up the environment for a child process, you can use
// g_get_environ() to get an environment array, modify that with
// g_environ_setenv() and g_environ_unsetenv(), and then pass that array
// directly to execvpe(), g_spawn_async(), or the like.
func Unsetenv(variable string) {
	var _arg1 *C.gchar // out

	_arg1 = (*C.gchar)(C.CString(variable))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_unsetenv(_arg1)
}

// Usleep pauses the current thread for the given number of microseconds.
//
// There are 1 million microseconds per second (represented by the USEC_PER_SEC
// macro). g_usleep() may have limited precision, depending on hardware and
// operating system; don't rely on the exact length of the sleep.
func Usleep(microseconds uint32) {
	var _arg1 C.gulong // out

	_arg1 = (C.gulong)(microseconds)

	C.g_usleep(_arg1)
}

// UTF16ToUcs4: convert a string from UTF-16 to UCS-4. The result will be
// nul-terminated.
func UTF16ToUcs4(str *uint16, len int32) (itemsRead int32, itemsWritten int32, gunichar *uint32, goerr error) {
	var _arg1 *C.gunichar2 // out
	var _arg2 C.glong      // out
	var _arg3 C.glong      // in
	var _arg4 C.glong      // in
	var _cret *C.gunichar  // in
	var _cerr *C.GError    // in

	_arg1 = (*C.gunichar2)(unsafe.Pointer(str))
	_arg2 = (C.glong)(len)

	_cret = C.g_utf16_to_ucs4(_arg1, _arg2, &_arg3, &_arg4, &_cerr)

	var _itemsRead int32    // out
	var _itemsWritten int32 // out
	var _gunichar *uint32   // out
	var _goerr error        // out

	_itemsRead = (int32)(_arg3)
	_itemsWritten = (int32)(_arg4)
	_gunichar = (*uint32)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _itemsRead, _itemsWritten, _gunichar, _goerr
}

// UTF16ToUTF8: convert a string from UTF-16 to UTF-8. The result will be
// terminated with a 0 byte.
//
// Note that the input is expected to be already in native endianness, an
// initial byte-order-mark character is not handled specially. g_convert() can
// be used to convert a byte buffer of UTF-16 data of ambiguous endianness.
//
// Further note that this function does not validate the result string; it may
// e.g. include embedded NUL characters. The only validation done by this
// function is to ensure that the input can be correctly interpreted as UTF-16,
// i.e. it doesn't contain unpaired surrogates or partial character sequences.
func UTF16ToUTF8(str *uint16, len int32) (itemsRead int32, itemsWritten int32, utf8 string, goerr error) {
	var _arg1 *C.gunichar2 // out
	var _arg2 C.glong      // out
	var _arg3 C.glong      // in
	var _arg4 C.glong      // in
	var _cret *C.gchar     // in
	var _cerr *C.GError    // in

	_arg1 = (*C.gunichar2)(unsafe.Pointer(str))
	_arg2 = (C.glong)(len)

	_cret = C.g_utf16_to_utf8(_arg1, _arg2, &_arg3, &_arg4, &_cerr)

	var _itemsRead int32    // out
	var _itemsWritten int32 // out
	var _utf8 string        // out
	var _goerr error        // out

	_itemsRead = (int32)(_arg3)
	_itemsWritten = (int32)(_arg4)
	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _itemsRead, _itemsWritten, _utf8, _goerr
}

// UTF8Casefold converts a string into a form that is independent of case. The
// result will not correspond to any particular case, but can be compared for
// equality or ordered with the results of calling g_utf8_casefold() on other
// strings.
//
// Note that calling g_utf8_casefold() followed by g_utf8_collate() is only an
// approximation to the correct linguistic case insensitive ordering, though it
// is a fairly good one. Getting this exactly right would require a more
// sophisticated collation function that takes case sensitivity into account.
// GLib does not currently provide such a function.
func UTF8Casefold(str string, len int) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gssize)(len)

	_cret = C.g_utf8_casefold(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8Collate compares two strings for ordering using the linguistically
// correct rules for the [current locale][setlocale]. When sorting a large
// number of strings, it will be significantly faster to obtain collation keys
// with g_utf8_collate_key() and compare the keys with strcmp() when sorting
// instead of sorting the original strings.
func UTF8Collate(str1 string, str2 string) int {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _cret C.gint   // in

	_arg1 = (*C.gchar)(C.CString(str1))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(str2))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_utf8_collate(_arg1, _arg2)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// UTF8CollateKey converts a string into a collation key that can be compared
// with other collation keys produced by the same function using strcmp().
//
// The results of comparing the collation keys of two strings with strcmp() will
// always be the same as comparing the two original keys with g_utf8_collate().
//
// Note that this function depends on the [current locale][setlocale].
func UTF8CollateKey(str string, len int) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gssize)(len)

	_cret = C.g_utf8_collate_key(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8CollateKeyForFilename converts a string into a collation key that can be
// compared with other collation keys produced by the same function using
// strcmp().
//
// In order to sort filenames correctly, this function treats the dot '.' as a
// special case. Most dictionary orderings seem to consider it insignificant,
// thus producing the ordering "event.c" "eventgenerator.c" "event.h" instead of
// "event.c" "event.h" "eventgenerator.c". Also, we would like to treat numbers
// intelligently so that "file1" "file10" "file5" is sorted as "file1" "file5"
// "file10".
//
// Note that this function depends on the [current locale][setlocale].
func UTF8CollateKeyForFilename(str string, len int) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gssize)(len)

	_cret = C.g_utf8_collate_key_for_filename(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8FindNextChar finds the start of the next UTF-8 character in the string
// after @p.
//
// @p does not have to be at the beginning of a UTF-8 character. No check is
// made to see if the character found is actually valid other than it starts
// with an appropriate byte.
//
// If @end is nil, the return value will never be nil: if the end of the string
// is reached, a pointer to the terminating nul byte is returned. If @end is
// non-nil, the return value will be nil if the end of the string is reached.
func UTF8FindNextChar(p string, end string) string {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(p))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(end))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_utf8_find_next_char(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// UTF8FindPrevChar: given a position @p with a UTF-8 encoded string @str, find
// the start of the previous UTF-8 character starting before @p. Returns nil if
// no UTF-8 characters are present in @str before @p.
//
// @p does not have to be at the beginning of a UTF-8 character. No check is
// made to see if the character found is actually valid other than it starts
// with an appropriate byte.
func UTF8FindPrevChar(str string, p string) string {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(p))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_utf8_find_prev_char(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// UTF8GetChar converts a sequence of bytes encoded as UTF-8 to a Unicode
// character.
//
// If @p does not point to a valid UTF-8 encoded character, results are
// undefined. If you are not sure that the bytes are complete valid Unicode
// characters, you should use g_utf8_get_char_validated() instead.
func UTF8GetChar(p string) uint32 {
	var _arg1 *C.gchar   // out
	var _cret C.gunichar // in

	_arg1 = (*C.gchar)(C.CString(p))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_utf8_get_char(_arg1)

	var _gunichar uint32 // out

	_gunichar = (uint32)(_cret)

	return _gunichar
}

// UTF8GetCharValidated: convert a sequence of bytes encoded as UTF-8 to a
// Unicode character. This function checks for incomplete characters, for
// invalid characters such as characters that are out of the range of Unicode,
// and for overlong encodings of valid characters.
//
// Note that g_utf8_get_char_validated() returns (gunichar)-2 if @max_len is
// positive and any of the bytes in the first UTF-8 character sequence are nul.
func UTF8GetCharValidated(p string, maxLen int) uint32 {
	var _arg1 *C.gchar   // out
	var _arg2 C.gssize   // out
	var _cret C.gunichar // in

	_arg1 = (*C.gchar)(C.CString(p))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gssize)(maxLen)

	_cret = C.g_utf8_get_char_validated(_arg1, _arg2)

	var _gunichar uint32 // out

	_gunichar = (uint32)(_cret)

	return _gunichar
}

// UTF8MakeValid: if the provided string is valid UTF-8, return a copy of it. If
// not, return a copy in which bytes that could not be interpreted as valid
// Unicode are replaced with the Unicode replacement character (U+FFFD).
//
// For example, this is an appropriate function to use if you have received a
// string that was incorrectly declared to be UTF-8, and you need a valid UTF-8
// version of it that can be logged or displayed to the user, with the
// assumption that it is close enough to ASCII or UTF-8 to be mostly readable
// as-is.
func UTF8MakeValid(str string, len int) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gssize)(len)

	_cret = C.g_utf8_make_valid(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8Normalize converts a string into canonical form, standardizing such
// issues as whether a character with an accent is represented as a base
// character and combining accent or as a single precomposed character. The
// string has to be valid UTF-8, otherwise nil is returned. You should generally
// call g_utf8_normalize() before comparing two Unicode strings.
//
// The normalization mode G_NORMALIZE_DEFAULT only standardizes differences that
// do not affect the text content, such as the above-mentioned accent
// representation. G_NORMALIZE_ALL also standardizes the "compatibility"
// characters in Unicode, such as SUPERSCRIPT THREE to the standard forms (in
// this case DIGIT THREE). Formatting information may be lost but for most text
// operations such characters should be considered the same.
//
// G_NORMALIZE_DEFAULT_COMPOSE and G_NORMALIZE_ALL_COMPOSE are like
// G_NORMALIZE_DEFAULT and G_NORMALIZE_ALL, but returned a result with composed
// forms rather than a maximally decomposed form. This is often useful if you
// intend to convert the string to a legacy encoding or pass it to a system with
// less capable Unicode handling.
func UTF8Normalize(str string, len int, mode NormalizeMode) string {
	var _arg1 *C.gchar         // out
	var _arg2 C.gssize         // out
	var _arg3 C.GNormalizeMode // out
	var _cret *C.gchar         // in

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gssize)(len)
	_arg3 = (C.GNormalizeMode)(mode)

	_cret = C.g_utf8_normalize(_arg1, _arg2, _arg3)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8OffsetToPointer converts from an integer character offset to a pointer to
// a position within the string.
//
// Since 2.10, this function allows to pass a negative @offset to step
// backwards. It is usually worth stepping backwards from the end instead of
// forwards if @offset is in the last fourth of the string, since moving forward
// is about 3 times faster than moving backward.
//
// Note that this function doesn't abort when reaching the end of @str.
// Therefore you should be sure that @offset is within string boundaries before
// calling that function. Call g_utf8_strlen() when unsure. This limitation
// exists as this function is called frequently during text rendering and
// therefore has to be as fast as possible.
func UTF8OffsetToPointer(str string, offset int32) string {
	var _arg1 *C.gchar // out
	var _arg2 C.glong  // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.glong)(offset)

	_cret = C.g_utf8_offset_to_pointer(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// UTF8PointerToOffset converts from a pointer to position within a string to an
// integer character offset.
//
// Since 2.10, this function allows @pos to be before @str, and returns a
// negative offset in this case.
func UTF8PointerToOffset(str string, pos string) int32 {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _cret C.glong  // in

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(pos))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_utf8_pointer_to_offset(_arg1, _arg2)

	var _glong int32 // out

	_glong = (int32)(_cret)

	return _glong
}

// UTF8PrevChar finds the previous UTF-8 character in the string before @p.
//
// @p does not have to be at the beginning of a UTF-8 character. No check is
// made to see if the character found is actually valid other than it starts
// with an appropriate byte. If @p might be the first character of the string,
// you must use g_utf8_find_prev_char() instead.
func UTF8PrevChar(p string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(p))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_utf8_prev_char(_arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// UTF8Strchr finds the leftmost occurrence of the given Unicode character in a
// UTF-8 encoded string, while limiting the search to @len bytes. If @len is -1,
// allow unbounded search.
func UTF8Strchr(p string, len int, c uint32) string {
	var _arg1 *C.gchar   // out
	var _arg2 C.gssize   // out
	var _arg3 C.gunichar // out
	var _cret *C.gchar   // in

	_arg1 = (*C.gchar)(C.CString(p))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gssize)(len)
	_arg3 = (C.gunichar)(c)

	_cret = C.g_utf8_strchr(_arg1, _arg2, _arg3)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// UTF8Strdown converts all Unicode characters in the string that have a case to
// lowercase. The exact manner that this is done depends on the current locale,
// and may result in the number of characters in the string changing.
func UTF8Strdown(str string, len int) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gssize)(len)

	_cret = C.g_utf8_strdown(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8Strlen computes the length of the string in characters, not including the
// terminating nul character. If the @max'th byte falls in the middle of a
// character, the last (partial) character is not counted.
func UTF8Strlen(p string, max int) int32 {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize // out
	var _cret C.glong  // in

	_arg1 = (*C.gchar)(C.CString(p))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gssize)(max)

	_cret = C.g_utf8_strlen(_arg1, _arg2)

	var _glong int32 // out

	_glong = (int32)(_cret)

	return _glong
}

// UTF8Strncpy: like the standard C strncpy() function, but copies a given
// number of characters instead of a given number of bytes. The @src string must
// be valid UTF-8 encoded text. (Use g_utf8_validate() on all text before trying
// to use UTF-8 utility functions with it.)
//
// Note you must ensure @dest is at least 4 * @n to fit the largest possible
// UTF-8 characters
func UTF8Strncpy(dest string, src string, n uint) string {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _arg3 C.gsize  // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(dest))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(src))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.gsize)(n)

	_cret = C.g_utf8_strncpy(_arg1, _arg2, _arg3)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// UTF8Strrchr: find the rightmost occurrence of the given Unicode character in
// a UTF-8 encoded string, while limiting the search to @len bytes. If @len is
// -1, allow unbounded search.
func UTF8Strrchr(p string, len int, c uint32) string {
	var _arg1 *C.gchar   // out
	var _arg2 C.gssize   // out
	var _arg3 C.gunichar // out
	var _cret *C.gchar   // in

	_arg1 = (*C.gchar)(C.CString(p))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gssize)(len)
	_arg3 = (C.gunichar)(c)

	_cret = C.g_utf8_strrchr(_arg1, _arg2, _arg3)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// UTF8Strreverse reverses a UTF-8 string. @str must be valid UTF-8 encoded
// text. (Use g_utf8_validate() on all text before trying to use UTF-8 utility
// functions with it.)
//
// This function is intended for programmatic uses of reversed strings. It pays
// no attention to decomposed characters, combining marks, byte order marks,
// directional indicators (LRM, LRO, etc) and similar characters which might
// need special handling when reversing a string for display purposes.
//
// Note that unlike g_strreverse(), this function returns newly-allocated
// memory, which should be freed with g_free() when no longer needed.
func UTF8Strreverse(str string, len int) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gssize)(len)

	_cret = C.g_utf8_strreverse(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8Strup converts all Unicode characters in the string that have a case to
// uppercase. The exact manner that this is done depends on the current locale,
// and may result in the number of characters in the string increasing. (For
// instance, the German ess-zet will be changed to SS.)
func UTF8Strup(str string, len int) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gssize)(len)

	_cret = C.g_utf8_strup(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8Substring copies a substring out of a UTF-8 encoded string. The substring
// will contain @end_pos - @start_pos characters.
func UTF8Substring(str string, startPos int32, endPos int32) string {
	var _arg1 *C.gchar // out
	var _arg2 C.glong  // out
	var _arg3 C.glong  // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.glong)(startPos)
	_arg3 = (C.glong)(endPos)

	_cret = C.g_utf8_substring(_arg1, _arg2, _arg3)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8ToUcs4: convert a string from UTF-8 to a 32-bit fixed width
// representation as UCS-4. A trailing 0 character will be added to the string
// after the converted text.
func UTF8ToUcs4(str string, len int32) (itemsRead int32, itemsWritten int32, gunichar *uint32, goerr error) {
	var _arg1 *C.gchar    // out
	var _arg2 C.glong     // out
	var _arg3 C.glong     // in
	var _arg4 C.glong     // in
	var _cret *C.gunichar // in
	var _cerr *C.GError   // in

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.glong)(len)

	_cret = C.g_utf8_to_ucs4(_arg1, _arg2, &_arg3, &_arg4, &_cerr)

	var _itemsRead int32    // out
	var _itemsWritten int32 // out
	var _gunichar *uint32   // out
	var _goerr error        // out

	_itemsRead = (int32)(_arg3)
	_itemsWritten = (int32)(_arg4)
	_gunichar = (*uint32)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _itemsRead, _itemsWritten, _gunichar, _goerr
}

// UTF8ToUcs4Fast: convert a string from UTF-8 to a 32-bit fixed width
// representation as UCS-4, assuming valid UTF-8 input. This function is roughly
// twice as fast as g_utf8_to_ucs4() but does no error checking on the input. A
// trailing 0 character will be added to the string after the converted text.
func UTF8ToUcs4Fast(str string, len int32) (int32, *uint32) {
	var _arg1 *C.gchar    // out
	var _arg2 C.glong     // out
	var _arg3 C.glong     // in
	var _cret *C.gunichar // in

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.glong)(len)

	_cret = C.g_utf8_to_ucs4_fast(_arg1, _arg2, &_arg3)

	var _itemsWritten int32 // out
	var _gunichar *uint32   // out

	_itemsWritten = (int32)(_arg3)
	_gunichar = (*uint32)(_cret)

	return _itemsWritten, _gunichar
}

// UTF8ToUTF16: convert a string from UTF-8 to UTF-16. A 0 character will be
// added to the result after the converted text.
func UTF8ToUTF16(str string, len int32) (itemsRead int32, itemsWritten int32, guint16 *uint16, goerr error) {
	var _arg1 *C.gchar     // out
	var _arg2 C.glong      // out
	var _arg3 C.glong      // in
	var _arg4 C.glong      // in
	var _cret *C.gunichar2 // in
	var _cerr *C.GError    // in

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.glong)(len)

	_cret = C.g_utf8_to_utf16(_arg1, _arg2, &_arg3, &_arg4, &_cerr)

	var _itemsRead int32    // out
	var _itemsWritten int32 // out
	var _guint16 *uint16    // out
	var _goerr error        // out

	_itemsRead = (int32)(_arg3)
	_itemsWritten = (int32)(_arg4)
	_guint16 = (*uint16)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _itemsRead, _itemsWritten, _guint16, _goerr
}

// UTF8Validate validates UTF-8 encoded text. @str is the text to validate; if
// @str is nul-terminated, then @max_len can be -1, otherwise @max_len should be
// the number of bytes to validate. If @end is non-nil, then the end of the
// valid range will be stored there (i.e. the start of the first invalid
// character if some bytes were invalid, or the end of the text being validated
// otherwise).
//
// Note that g_utf8_validate() returns false if @max_len is positive and any of
// the @max_len bytes are nul.
//
// Returns true if all of @str was valid. Many GLib and GTK+ routines require
// valid UTF-8 as input; so data read from a file or the network should be
// checked with g_utf8_validate() before doing anything else with it.
func UTF8Validate(str []byte) (string, bool) {
	var _arg1 *C.gchar
	var _arg2 C.gssize
	var _arg3 *C.gchar   // in
	var _cret C.gboolean // in

	_arg2 = C.gssize(len(str))
	_arg1 = (*C.gchar)(unsafe.Pointer(&str[0]))

	_cret = C.g_utf8_validate(_arg1, _arg2, &_arg3)

	var _end string // out
	var _ok bool    // out

	_end = C.GoString(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _end, _ok
}

// UTF8ValidateLen validates UTF-8 encoded text.
//
// As with g_utf8_validate(), but @max_len must be set, and hence this function
// will always return false if any of the bytes of @str are nul.
func UTF8ValidateLen(str []byte) (string, bool) {
	var _arg1 *C.gchar
	var _arg2 C.gsize
	var _arg3 *C.gchar   // in
	var _cret C.gboolean // in

	_arg2 = C.gsize(len(str))
	_arg1 = (*C.gchar)(unsafe.Pointer(&str[0]))

	_cret = C.g_utf8_validate_len(_arg1, _arg2, &_arg3)

	var _end string // out
	var _ok bool    // out

	_end = C.GoString(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _end, _ok
}

// UUIDStringIsValid parses the string @str and verify if it is a UUID.
//
// The function accepts the following syntax:
//
// - simple forms (e.g. `f81d4fae-7dec-11d0-a765-00a0c91e6bf6`)
//
// Note that hyphens are required within the UUID string itself, as per the
// aforementioned RFC.
func UUIDStringIsValid(str string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_uuid_string_is_valid(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UUIDStringRandom generates a random UUID (RFC 4122 version 4) as a string. It
// has the same randomness guarantees as #GRand, so must not be used for
// cryptographic purposes such as key generation, nonces, salts or one-time
// pads.
func UUIDStringRandom() string {
	var _cret *C.gchar // in

	_cret = C.g_uuid_string_random()

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func VariantGetGType() externglib.Type {
	var _cret C.GType // in

	_cret = C.g_variant_get_gtype()

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

// BookmarkFile: the `GBookmarkFile` structure contains only private data and
// should not be directly accessed.
type BookmarkFile C.GBookmarkFile

// WrapBookmarkFile wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapBookmarkFile(ptr unsafe.Pointer) *BookmarkFile {
	return (*BookmarkFile)(ptr)
}

// Native returns the underlying C source pointer.
func (b *BookmarkFile) Native() unsafe.Pointer {
	return unsafe.Pointer(b)
}

// AddApplication adds the application with @name and @exec to the list of
// applications that have registered a bookmark for @uri into @bookmark.
//
// Every bookmark inside a File must have at least an application registered.
// Each application must provide a name, a command line useful for launching the
// bookmark, the number of times the bookmark has been registered by the
// application and the last time the application registered this bookmark.
//
// If @name is nil, the name of the application will be the same returned by
// g_get_application_name(); if @exec is nil, the command line will be a
// composition of the program name as returned by g_get_prgname() and the "\u"
// modifier, which will be expanded to the bookmark's URI.
//
// This function will automatically take care of updating the registrations
// count and timestamping in case an application with the same @name had already
// registered a bookmark for @uri inside @bookmark.
//
// If no bookmark for @uri is found, one is created.
func (b *BookmarkFile) AddApplication(uri string, name string, exec string) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out
	var _arg3 *C.gchar         // out

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(exec))
	defer C.free(unsafe.Pointer(_arg3))

	C.g_bookmark_file_add_application(_arg0, _arg1, _arg2, _arg3)
}

// AddGroup adds @group to the list of groups to which the bookmark for @uri
// belongs to.
//
// If no bookmark for @uri is found then it is created.
func (b *BookmarkFile) AddGroup(uri string, group string) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(group))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_bookmark_file_add_group(_arg0, _arg1, _arg2)
}

// Free frees a File.
func (b *BookmarkFile) Free() {
	var _arg0 *C.GBookmarkFile // out

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))

	C.g_bookmark_file_free(_arg0)
}

// Added gets the time the bookmark for @uri was added to @bookmark
//
// In the event the URI cannot be found, -1 is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (b *BookmarkFile) Added(uri string) (int32, error) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _cret C.time_t         // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_bookmark_file_get_added(_arg0, _arg1, &_cerr)

	var _glong int32 // out
	var _goerr error // out

	_glong = (int32)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _glong, _goerr
}

// AppInfo gets the registration information of @app_name for the bookmark for
// @uri. See g_bookmark_file_set_application_info() for more information about
// the returned data.
//
// The string returned in @app_exec must be freed.
//
// In the event the URI cannot be found, false is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND. In the event that no application with name
// @app_name has registered a bookmark for @uri, false is returned and error is
// set to BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED. In the event that unquoting
// the command line fails, an error of the SHELL_ERROR domain is set and false
// is returned.
func (b *BookmarkFile) AppInfo(uri string, name string) (string, uint, int32, error) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out
	var _arg3 *C.gchar         // in
	var _arg4 C.guint          // in
	var _arg5 C.time_t         // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_bookmark_file_get_app_info(_arg0, _arg1, _arg2, &_arg3, &_arg4, &_arg5, &_cerr)

	var _exec string // out
	var _count uint  // out
	var _stamp int32 // out
	var _goerr error // out

	_exec = C.GoString(_arg3)
	defer C.free(unsafe.Pointer(_arg3))
	_count = (uint)(_arg4)
	_stamp = (int32)(_arg5)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _exec, _count, _stamp, _goerr
}

// Description retrieves the description of the bookmark for @uri.
//
// In the event the URI cannot be found, nil is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (b *BookmarkFile) Description(uri string) (string, error) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _cret *C.gchar         // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_bookmark_file_get_description(_arg0, _arg1, &_cerr)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _utf8, _goerr
}

// Icon gets the icon of the bookmark for @uri.
//
// In the event the URI cannot be found, false is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (b *BookmarkFile) Icon(uri string) (href string, mimeType string, goerr error) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // in
	var _arg3 *C.gchar         // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_bookmark_file_get_icon(_arg0, _arg1, &_arg2, &_arg3, &_cerr)

	var _href string     // out
	var _mimeType string // out
	var _goerr error     // out

	_href = C.GoString(_arg2)
	defer C.free(unsafe.Pointer(_arg2))
	_mimeType = C.GoString(_arg3)
	defer C.free(unsafe.Pointer(_arg3))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _href, _mimeType, _goerr
}

// IsPrivate gets whether the private flag of the bookmark for @uri is set.
//
// In the event the URI cannot be found, false is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND. In the event that the private flag cannot
// be found, false is returned and @error is set to
// BOOKMARK_FILE_ERROR_INVALID_VALUE.
func (b *BookmarkFile) IsPrivate(uri string) error {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_bookmark_file_get_is_private(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// MIMEType retrieves the MIME type of the resource pointed by @uri.
//
// In the event the URI cannot be found, nil is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND. In the event that the MIME type cannot be
// found, nil is returned and @error is set to
// BOOKMARK_FILE_ERROR_INVALID_VALUE.
func (b *BookmarkFile) MIMEType(uri string) (string, error) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _cret *C.gchar         // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_bookmark_file_get_mime_type(_arg0, _arg1, &_cerr)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _utf8, _goerr
}

// Modified gets the time when the bookmark for @uri was last modified.
//
// In the event the URI cannot be found, -1 is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (b *BookmarkFile) Modified(uri string) (int32, error) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _cret C.time_t         // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_bookmark_file_get_modified(_arg0, _arg1, &_cerr)

	var _glong int32 // out
	var _goerr error // out

	_glong = (int32)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _glong, _goerr
}

// Size gets the number of bookmarks inside @bookmark.
func (b *BookmarkFile) Size() int {
	var _arg0 *C.GBookmarkFile // out
	var _cret C.gint           // in

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))

	_cret = C.g_bookmark_file_get_size(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Title returns the title of the bookmark for @uri.
//
// If @uri is nil, the title of @bookmark is returned.
//
// In the event the URI cannot be found, nil is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (b *BookmarkFile) Title(uri string) (string, error) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _cret *C.gchar         // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_bookmark_file_get_title(_arg0, _arg1, &_cerr)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _utf8, _goerr
}

// Visited gets the time the bookmark for @uri was last visited.
//
// In the event the URI cannot be found, -1 is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (b *BookmarkFile) Visited(uri string) (int32, error) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _cret C.time_t         // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_bookmark_file_get_visited(_arg0, _arg1, &_cerr)

	var _glong int32 // out
	var _goerr error // out

	_glong = (int32)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _glong, _goerr
}

// HasApplication checks whether the bookmark for @uri inside @bookmark has been
// registered by application @name.
//
// In the event the URI cannot be found, false is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (b *BookmarkFile) HasApplication(uri string, name string) error {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_bookmark_file_has_application(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// HasGroup checks whether @group appears in the list of groups to which the
// bookmark for @uri belongs to.
//
// In the event the URI cannot be found, false is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (b *BookmarkFile) HasGroup(uri string, group string) error {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(group))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_bookmark_file_has_group(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// HasItem looks whether the desktop bookmark has an item with its URI set to
// @uri.
func (b *BookmarkFile) HasItem(uri string) bool {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_bookmark_file_has_item(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LoadFromData loads a bookmark file from memory into an empty File structure.
// If the object cannot be created then @error is set to a FileError.
func (b *BookmarkFile) LoadFromData(data []byte) error {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar
	var _arg2 C.gsize
	var _cerr *C.GError // in

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg2 = C.gsize(len(data))
	_arg1 = (*C.gchar)(unsafe.Pointer(&data[0]))

	C.g_bookmark_file_load_from_data(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// LoadFromDataDirs: this function looks for a desktop bookmark file named @file
// in the paths returned from g_get_user_data_dir() and
// g_get_system_data_dirs(), loads the file into @bookmark and returns the
// file's full path in @full_path. If the file could not be loaded then @error
// is set to either a Error or FileError.
func (b *BookmarkFile) LoadFromDataDirs(file string) (string, error) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(file))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_bookmark_file_load_from_data_dirs(_arg0, _arg1, &_arg2, &_cerr)

	var _fullPath string // out
	var _goerr error     // out

	_fullPath = C.GoString(_arg2)
	defer C.free(unsafe.Pointer(_arg2))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _fullPath, _goerr
}

// LoadFromFile loads a desktop bookmark file into an empty File structure. If
// the file could not be loaded then @error is set to either a Error or
// FileError.
func (b *BookmarkFile) LoadFromFile(filename string) error {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_bookmark_file_load_from_file(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// MoveItem changes the URI of a bookmark item from @old_uri to @new_uri. Any
// existing bookmark for @new_uri will be overwritten. If @new_uri is nil, then
// the bookmark is removed.
//
// In the event the URI cannot be found, false is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (b *BookmarkFile) MoveItem(oldUri string, newUri string) error {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(oldUri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(newUri))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_bookmark_file_move_item(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// RemoveApplication removes application registered with @name from the list of
// applications that have registered a bookmark for @uri inside @bookmark.
//
// In the event the URI cannot be found, false is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND. In the event that no application with name
// @app_name has registered a bookmark for @uri, false is returned and error is
// set to BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED.
func (b *BookmarkFile) RemoveApplication(uri string, name string) error {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_bookmark_file_remove_application(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// RemoveGroup removes @group from the list of groups to which the bookmark for
// @uri belongs to.
//
// In the event the URI cannot be found, false is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND. In the event no group was defined, false
// is returned and @error is set to BOOKMARK_FILE_ERROR_INVALID_VALUE.
func (b *BookmarkFile) RemoveGroup(uri string, group string) error {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(group))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_bookmark_file_remove_group(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// RemoveItem removes the bookmark for @uri from the bookmark file @bookmark.
func (b *BookmarkFile) RemoveItem(uri string) error {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_bookmark_file_remove_item(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// SetAdded sets the time the bookmark for @uri was added into @bookmark.
//
// If no bookmark for @uri is found then it is created.
func (b *BookmarkFile) SetAdded(uri string, added int32) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 C.time_t         // out

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.time_t)(added)

	C.g_bookmark_file_set_added(_arg0, _arg1, _arg2)
}

// SetAppInfo sets the meta-data of application @name inside the list of
// applications that have registered a bookmark for @uri inside @bookmark.
//
// You should rarely use this function; use g_bookmark_file_add_application()
// and g_bookmark_file_remove_application() instead.
//
// @name can be any UTF-8 encoded string used to identify an application. @exec
// can have one of these two modifiers: "\f", which will be expanded as the
// local file name retrieved from the bookmark's URI; "\u", which will be
// expanded as the bookmark's URI. The expansion is done automatically when
// retrieving the stored command line using the
// g_bookmark_file_get_application_info() function. @count is the number of
// times the application has registered the bookmark; if is < 0, the current
// registration count will be increased by one, if is 0, the application with
// @name will be removed from the list of registered applications. @stamp is the
// Unix time of the last registration; if it is -1, the current time will be
// used.
//
// If you try to remove an application by setting its registration count to
// zero, and no bookmark for @uri is found, false is returned and @error is set
// to BOOKMARK_FILE_ERROR_URI_NOT_FOUND; similarly, in the event that no
// application @name has registered a bookmark for @uri, false is returned and
// error is set to BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED. Otherwise, if no
// bookmark for @uri is found, one is created.
func (b *BookmarkFile) SetAppInfo(uri string, name string, exec string, count int, stamp int32) error {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out
	var _arg3 *C.gchar         // out
	var _arg4 C.gint           // out
	var _arg5 C.time_t         // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(exec))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (C.gint)(count)
	_arg5 = (C.time_t)(stamp)

	C.g_bookmark_file_set_app_info(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// SetDescription sets @description as the description of the bookmark for @uri.
//
// If @uri is nil, the description of @bookmark is set.
//
// If a bookmark for @uri cannot be found then it is created.
func (b *BookmarkFile) SetDescription(uri string, description string) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(description))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_bookmark_file_set_description(_arg0, _arg1, _arg2)
}

// SetGroups sets a list of group names for the item with URI @uri. Each
// previously set group name list is removed.
//
// If @uri cannot be found then an item for it is created.
func (b *BookmarkFile) SetGroups(uri string, groups []string) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 **C.gchar
	var _arg3 C.gsize

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg3 = C.gsize(len(groups))
	_arg2 = (**C.gchar)(C.malloc(C.ulong(len(groups)) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice(_arg2, len(groups))
		for i := range groups {
			out[i] = (*C.gchar)(C.CString(groups[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.g_bookmark_file_set_groups(_arg0, _arg1, _arg2, _arg3)
}

// SetIcon sets the icon for the bookmark for @uri. If @href is nil, unsets the
// currently set icon. @href can either be a full URL for the icon file or the
// icon name following the Icon Naming specification.
//
// If no bookmark for @uri is found one is created.
func (b *BookmarkFile) SetIcon(uri string, href string, mimeType string) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out
	var _arg3 *C.gchar         // out

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(href))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(mimeType))
	defer C.free(unsafe.Pointer(_arg3))

	C.g_bookmark_file_set_icon(_arg0, _arg1, _arg2, _arg3)
}

// SetIsPrivate sets the private flag of the bookmark for @uri.
//
// If a bookmark for @uri cannot be found then it is created.
func (b *BookmarkFile) SetIsPrivate(uri string, isPrivate bool) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 C.gboolean       // out

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	if isPrivate {
		_arg2 = C.TRUE
	}

	C.g_bookmark_file_set_is_private(_arg0, _arg1, _arg2)
}

// SetMIMEType sets @mime_type as the MIME type of the bookmark for @uri.
//
// If a bookmark for @uri cannot be found then it is created.
func (b *BookmarkFile) SetMIMEType(uri string, mimeType string) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(mimeType))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_bookmark_file_set_mime_type(_arg0, _arg1, _arg2)
}

// SetModified sets the last time the bookmark for @uri was last modified.
//
// If no bookmark for @uri is found then it is created.
//
// The "modified" time should only be set when the bookmark's meta-data was
// actually changed. Every function of File that modifies a bookmark also
// changes the modification time, except for
// g_bookmark_file_set_visited_date_time().
func (b *BookmarkFile) SetModified(uri string, modified int32) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 C.time_t         // out

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.time_t)(modified)

	C.g_bookmark_file_set_modified(_arg0, _arg1, _arg2)
}

// SetTitle sets @title as the title of the bookmark for @uri inside the
// bookmark file @bookmark.
//
// If @uri is nil, the title of @bookmark is set.
//
// If a bookmark for @uri cannot be found then it is created.
func (b *BookmarkFile) SetTitle(uri string, title string) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_bookmark_file_set_title(_arg0, _arg1, _arg2)
}

// SetVisited sets the time the bookmark for @uri was last visited.
//
// If no bookmark for @uri is found then it is created.
//
// The "visited" time should only be set if the bookmark was launched, either
// using the command line retrieved by g_bookmark_file_get_application_info() or
// by the default application for the bookmark's MIME type, retrieved using
// g_bookmark_file_get_mime_type(). Changing the "visited" time does not affect
// the "modified" time.
func (b *BookmarkFile) SetVisited(uri string, visited int32) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 C.time_t         // out

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.time_t)(visited)

	C.g_bookmark_file_set_visited(_arg0, _arg1, _arg2)
}

// ToFile: this function outputs @bookmark into a file. The write process is
// guaranteed to be atomic by using g_file_set_contents() internally.
func (b *BookmarkFile) ToFile(filename string) error {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_bookmark_file_to_file(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// Checksum: an opaque structure representing a checksumming operation. To
// create a new GChecksum, use g_checksum_new(). To free a GChecksum, use
// g_checksum_free().
type Checksum C.GChecksum

// WrapChecksum wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapChecksum(ptr unsafe.Pointer) *Checksum {
	return (*Checksum)(ptr)
}

func marshalChecksum(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*Checksum)(unsafe.Pointer(b)), nil
}

// NewChecksum constructs a struct Checksum.
func NewChecksum(checksumType ChecksumType) *Checksum {
	var _arg1 C.GChecksumType // out
	var _cret *C.GChecksum    // in

	_arg1 = (C.GChecksumType)(checksumType)

	_cret = C.g_checksum_new(_arg1)

	var _checksum *Checksum // out

	_checksum = WrapChecksum(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_checksum, func(v *Checksum) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _checksum
}

// Native returns the underlying C source pointer.
func (c *Checksum) Native() unsafe.Pointer {
	return unsafe.Pointer(c)
}

// Copy copies a #GChecksum. If @checksum has been closed, by calling
// g_checksum_get_string() or g_checksum_get_digest(), the copied checksum will
// be closed as well.
func (c *Checksum) Copy() *Checksum {
	var _arg0 *C.GChecksum // out
	var _cret *C.GChecksum // in

	_arg0 = (*C.GChecksum)(unsafe.Pointer(c.Native()))

	_cret = C.g_checksum_copy(_arg0)

	var _ret *Checksum // out

	_ret = WrapChecksum(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_ret, func(v *Checksum) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _ret
}

// Free frees the memory allocated for @checksum.
func (c *Checksum) Free() {
	var _arg0 *C.GChecksum // out

	_arg0 = (*C.GChecksum)(unsafe.Pointer(c.Native()))

	C.g_checksum_free(_arg0)
}

// String gets the digest as a hexadecimal string.
//
// Once this function has been called the #GChecksum can no longer be updated
// with g_checksum_update().
//
// The hexadecimal characters will be lower case.
func (c *Checksum) String() string {
	var _arg0 *C.GChecksum // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GChecksum)(unsafe.Pointer(c.Native()))

	_cret = C.g_checksum_get_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Reset resets the state of the @checksum back to its initial state.
func (c *Checksum) Reset() {
	var _arg0 *C.GChecksum // out

	_arg0 = (*C.GChecksum)(unsafe.Pointer(c.Native()))

	C.g_checksum_reset(_arg0)
}

// Update feeds @data into an existing #GChecksum. The checksum must still be
// open, that is g_checksum_get_string() or g_checksum_get_digest() must not
// have been called on @checksum.
func (c *Checksum) Update(data []byte) {
	var _arg0 *C.GChecksum // out
	var _arg1 *C.guchar
	var _arg2 C.gssize

	_arg0 = (*C.GChecksum)(unsafe.Pointer(c.Native()))
	_arg2 = C.gssize(len(data))
	_arg1 = (*C.guchar)(unsafe.Pointer(&data[0]))

	C.g_checksum_update(_arg0, _arg1, _arg2)
}

// DebugKey associates a string with a bit flag. Used in g_parse_debug_string().
type DebugKey C.GDebugKey

// WrapDebugKey wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDebugKey(ptr unsafe.Pointer) *DebugKey {
	return (*DebugKey)(ptr)
}

// Native returns the underlying C source pointer.
func (d *DebugKey) Native() unsafe.Pointer {
	return unsafe.Pointer(d)
}

// Dir: an opaque structure representing an opened directory.
type Dir C.GDir

// WrapDir wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDir(ptr unsafe.Pointer) *Dir {
	return (*Dir)(ptr)
}

// Native returns the underlying C source pointer.
func (d *Dir) Native() unsafe.Pointer {
	return unsafe.Pointer(d)
}

// Close closes the directory and deallocates all related resources.
func (d *Dir) Close() {
	var _arg0 *C.GDir // out

	_arg0 = (*C.GDir)(unsafe.Pointer(d.Native()))

	C.g_dir_close(_arg0)
}

// ReadName retrieves the name of another entry in the directory, or nil. The
// order of entries returned from this function is not defined, and may vary by
// file system or other operating-system dependent factors.
//
// nil may also be returned in case of errors. On Unix, you can check `errno` to
// find out if nil was returned because of an error.
//
// On Unix, the '.' and '..' entries are omitted, and the returned name is in
// the on-disk encoding.
//
// On Windows, as is true of all GLib functions which operate on filenames, the
// returned name is in UTF-8.
func (d *Dir) ReadName() string {
	var _arg0 *C.GDir  // out
	var _cret *C.gchar // in

	_arg0 = (*C.GDir)(unsafe.Pointer(d.Native()))

	_cret = C.g_dir_read_name(_arg0)

	var _filename string // out

	_filename = C.GoString(_cret)

	return _filename
}

// Rewind resets the given directory. The next call to g_dir_read_name() will
// return the first entry again.
func (d *Dir) Rewind() {
	var _arg0 *C.GDir // out

	_arg0 = (*C.GDir)(unsafe.Pointer(d.Native()))

	C.g_dir_rewind(_arg0)
}

// HashTable: the Table struct is an opaque data structure to represent a [Hash
// Table][glib-Hash-Tables]. It should only be accessed via the following
// functions.
type HashTable C.GHashTable

// WrapHashTable wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapHashTable(ptr unsafe.Pointer) *HashTable {
	return (*HashTable)(ptr)
}

func marshalHashTable(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*HashTable)(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (h *HashTable) Native() unsafe.Pointer {
	return unsafe.Pointer(h)
}

// HashTableIter: a GHashTableIter structure represents an iterator that can be
// used to iterate over the elements of a Table. GHashTableIter structures are
// typically allocated on the stack and then initialized with
// g_hash_table_iter_init().
//
// The iteration order of a TableIter over the keys/values in a hash table is
// not defined.
type HashTableIter C.GHashTableIter

// WrapHashTableIter wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapHashTableIter(ptr unsafe.Pointer) *HashTableIter {
	return (*HashTableIter)(ptr)
}

// Native returns the underlying C source pointer.
func (h *HashTableIter) Native() unsafe.Pointer {
	return unsafe.Pointer(h)
}

// Init initializes a key/value pair iterator and associates it with
// @hash_table. Modifying the hash table after calling this function invalidates
// the returned iterator.
//
// The iteration order of a TableIter over the keys/values in a hash table is
// not defined.
//
//    GHashTableIter iter;
//    gpointer key, value;
//
//    g_hash_table_iter_init (&iter, hash_table);
//    while (g_hash_table_iter_next (&iter, &key, &value))
//      {
//        // do something with key and value
//      }
func (i *HashTableIter) Init(hashTable *HashTable) {
	var _arg0 *C.GHashTableIter // out
	var _arg1 *C.GHashTable     // out

	_arg0 = (*C.GHashTableIter)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GHashTable)(unsafe.Pointer(hashTable.Native()))

	C.g_hash_table_iter_init(_arg0, _arg1)
}

// Remove removes the key/value pair currently pointed to by the iterator from
// its associated Table. Can only be called after g_hash_table_iter_next()
// returned true, and cannot be called more than once for the same key/value
// pair.
//
// If the Table was created using g_hash_table_new_full(), the key and value are
// freed using the supplied destroy functions, otherwise you have to make sure
// that any dynamically allocated values are freed yourself.
//
// It is safe to continue iterating the Table afterward:
//
//    while (g_hash_table_iter_next (&iter, &key, &value))
//      {
//        if (condition)
//          g_hash_table_iter_remove (&iter);
//      }
func (i *HashTableIter) Remove() {
	var _arg0 *C.GHashTableIter // out

	_arg0 = (*C.GHashTableIter)(unsafe.Pointer(i.Native()))

	C.g_hash_table_iter_remove(_arg0)
}

// Steal removes the key/value pair currently pointed to by the iterator from
// its associated Table, without calling the key and value destroy functions.
// Can only be called after g_hash_table_iter_next() returned true, and cannot
// be called more than once for the same key/value pair.
func (i *HashTableIter) Steal() {
	var _arg0 *C.GHashTableIter // out

	_arg0 = (*C.GHashTableIter)(unsafe.Pointer(i.Native()))

	C.g_hash_table_iter_steal(_arg0)
}

// HMAC: an opaque structure representing a HMAC operation. To create a new
// GHmac, use g_hmac_new(). To free a GHmac, use g_hmac_unref().
type HMAC C.GHmac

// WrapHMAC wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapHMAC(ptr unsafe.Pointer) *HMAC {
	return (*HMAC)(ptr)
}

// Native returns the underlying C source pointer.
func (h *HMAC) Native() unsafe.Pointer {
	return unsafe.Pointer(h)
}

// String gets the HMAC as a hexadecimal string.
//
// Once this function has been called the #GHmac can no longer be updated with
// g_hmac_update().
//
// The hexadecimal characters will be lower case.
func (h *HMAC) String() string {
	var _arg0 *C.GHmac // out
	var _cret *C.gchar // in

	_arg0 = (*C.GHmac)(unsafe.Pointer(h.Native()))

	_cret = C.g_hmac_get_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Unref: atomically decrements the reference count of @hmac by one.
//
// If the reference count drops to 0, all keys and values will be destroyed, and
// all memory allocated by the hash table is released. This function is MT-safe
// and may be called from any thread. Frees the memory allocated for @hmac.
func (h *HMAC) Unref() {
	var _arg0 *C.GHmac // out

	_arg0 = (*C.GHmac)(unsafe.Pointer(h.Native()))

	C.g_hmac_unref(_arg0)
}

// Update feeds @data into an existing #GHmac.
//
// The HMAC must still be open, that is g_hmac_get_string() or
// g_hmac_get_digest() must not have been called on @hmac.
func (h *HMAC) Update(data []byte) {
	var _arg0 *C.GHmac // out
	var _arg1 *C.guchar
	var _arg2 C.gssize

	_arg0 = (*C.GHmac)(unsafe.Pointer(h.Native()))
	_arg2 = C.gssize(len(data))
	_arg1 = (*C.guchar)(unsafe.Pointer(&data[0]))

	C.g_hmac_update(_arg0, _arg1, _arg2)
}

// KeyFile: the GKeyFile struct contains only private data and should not be
// accessed directly.
type KeyFile C.GKeyFile

// WrapKeyFile wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapKeyFile(ptr unsafe.Pointer) *KeyFile {
	return (*KeyFile)(ptr)
}

func marshalKeyFile(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*KeyFile)(unsafe.Pointer(b)), nil
}

// NewKeyFile constructs a struct KeyFile.
func NewKeyFile() *KeyFile {
	var _cret *C.GKeyFile // in

	_cret = C.g_key_file_new()

	var _keyFile *KeyFile // out

	_keyFile = WrapKeyFile(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_keyFile, func(v *KeyFile) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _keyFile
}

// Native returns the underlying C source pointer.
func (k *KeyFile) Native() unsafe.Pointer {
	return unsafe.Pointer(k)
}

// Boolean returns the value associated with @key under @group_name as a
// boolean.
//
// If @key cannot be found then false is returned and @error is set to
// KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the value associated with @key
// cannot be interpreted as a boolean then false is returned and @error is set
// to KEY_FILE_ERROR_INVALID_VALUE.
func (k *KeyFile) Boolean(groupName string, key string) error {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))
	_arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_key_file_get_boolean(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// Comment retrieves a comment above @key from @group_name. If @key is nil then
// @comment will be read from above @group_name. If both @key and @group_name
// are nil, then @comment will be read from above the first group in the file.
//
// Note that the returned string does not include the '#' comment markers, but
// does include any whitespace after them (on each line). It includes the line
// breaks between lines, but does not include the final line break.
func (k *KeyFile) Comment(groupName string, key string) (string, error) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _cret *C.gchar    // in
	var _cerr *C.GError   // in

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))
	_arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_key_file_get_comment(_arg0, _arg1, _arg2, &_cerr)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _utf8, _goerr
}

// Double returns the value associated with @key under @group_name as a double.
// If @group_name is nil, the start_group is used.
//
// If @key cannot be found then 0.0 is returned and @error is set to
// KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the value associated with @key
// cannot be interpreted as a double then 0.0 is returned and @error is set to
// KEY_FILE_ERROR_INVALID_VALUE.
func (k *KeyFile) Double(groupName string, key string) (float64, error) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _cret C.gdouble   // in
	var _cerr *C.GError   // in

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))
	_arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_key_file_get_double(_arg0, _arg1, _arg2, &_cerr)

	var _gdouble float64 // out
	var _goerr error     // out

	_gdouble = (float64)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gdouble, _goerr
}

// Groups returns all groups in the key file loaded with @key_file. The array of
// returned groups will be nil-terminated, so @length may optionally be nil.
func (k *KeyFile) Groups() (uint, []string) {
	var _arg0 *C.GKeyFile // out
	var _arg1 C.gsize     // in
	var _cret **C.gchar

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))

	_cret = C.g_key_file_get_groups(_arg0, &_arg1)

	var _length uint // out
	var _utf8s []string

	_length = (uint)(_arg1)
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _length, _utf8s
}

// Int64 returns the value associated with @key under @group_name as a signed
// 64-bit integer. This is similar to g_key_file_get_integer() but can return
// 64-bit results without truncation.
func (k *KeyFile) Int64(groupName string, key string) (int64, error) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _cret C.gint64    // in
	var _cerr *C.GError   // in

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))
	_arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_key_file_get_int64(_arg0, _arg1, _arg2, &_cerr)

	var _gint64 int64 // out
	var _goerr error  // out

	_gint64 = (int64)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gint64, _goerr
}

// Integer returns the value associated with @key under @group_name as an
// integer.
//
// If @key cannot be found then 0 is returned and @error is set to
// KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the value associated with @key
// cannot be interpreted as an integer, or is out of range for a #gint, then 0
// is returned and @error is set to KEY_FILE_ERROR_INVALID_VALUE.
func (k *KeyFile) Integer(groupName string, key string) (int, error) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _cret C.gint      // in
	var _cerr *C.GError   // in

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))
	_arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_key_file_get_integer(_arg0, _arg1, _arg2, &_cerr)

	var _gint int    // out
	var _goerr error // out

	_gint = (int)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gint, _goerr
}

// Keys returns all keys for the group name @group_name. The array of returned
// keys will be nil-terminated, so @length may optionally be nil. In the event
// that the @group_name cannot be found, nil is returned and @error is set to
// KEY_FILE_ERROR_GROUP_NOT_FOUND.
func (k *KeyFile) Keys(groupName string) (uint, []string, error) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 C.gsize     // in
	var _cret **C.gchar
	var _cerr *C.GError // in

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))
	_arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_key_file_get_keys(_arg0, _arg1, &_arg2, &_cerr)

	var _length uint // out
	var _utf8s []string
	var _goerr error // out

	_length = (uint)(_arg2)
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _length, _utf8s, _goerr
}

// LocaleForKey returns the actual locale which the result of
// g_key_file_get_locale_string() or g_key_file_get_locale_string_list() came
// from.
//
// If calling g_key_file_get_locale_string() or
// g_key_file_get_locale_string_list() with exactly the same @key_file,
// @group_name, @key and @locale, the result of those functions will have
// originally been tagged with the locale that is the result of this function.
func (k *KeyFile) LocaleForKey(groupName string, key string, locale string) string {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _arg3 *C.gchar    // out
	var _cret *C.gchar    // in

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))
	_arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(locale))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.g_key_file_get_locale_for_key(_arg0, _arg1, _arg2, _arg3)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// LocaleString returns the value associated with @key under @group_name
// translated in the given @locale if available. If @locale is nil then the
// current locale is assumed.
//
// If @locale is to be non-nil, or if the current locale will change over the
// lifetime of the File, it must be loaded with G_KEY_FILE_KEEP_TRANSLATIONS in
// order to load strings for all locales.
//
// If @key cannot be found then nil is returned and @error is set to
// KEY_FILE_ERROR_KEY_NOT_FOUND. If the value associated with @key cannot be
// interpreted or no suitable translation can be found then the untranslated
// value is returned.
func (k *KeyFile) LocaleString(groupName string, key string, locale string) (string, error) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _arg3 *C.gchar    // out
	var _cret *C.gchar    // in
	var _cerr *C.GError   // in

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))
	_arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(locale))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.g_key_file_get_locale_string(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _utf8, _goerr
}

// StartGroup returns the name of the start group of the file.
func (k *KeyFile) StartGroup() string {
	var _arg0 *C.GKeyFile // out
	var _cret *C.gchar    // in

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))

	_cret = C.g_key_file_get_start_group(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// String returns the string value associated with @key under @group_name.
// Unlike g_key_file_get_value(), this function handles escape sequences like
// \s.
//
// In the event the key cannot be found, nil is returned and @error is set to
// KEY_FILE_ERROR_KEY_NOT_FOUND. In the event that the @group_name cannot be
// found, nil is returned and @error is set to KEY_FILE_ERROR_GROUP_NOT_FOUND.
func (k *KeyFile) String(groupName string, key string) (string, error) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _cret *C.gchar    // in
	var _cerr *C.GError   // in

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))
	_arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_key_file_get_string(_arg0, _arg1, _arg2, &_cerr)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _utf8, _goerr
}

// Uint64 returns the value associated with @key under @group_name as an
// unsigned 64-bit integer. This is similar to g_key_file_get_integer() but can
// return large positive results without truncation.
func (k *KeyFile) Uint64(groupName string, key string) (uint64, error) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _cret C.guint64   // in
	var _cerr *C.GError   // in

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))
	_arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_key_file_get_uint64(_arg0, _arg1, _arg2, &_cerr)

	var _guint64 uint64 // out
	var _goerr error    // out

	_guint64 = (uint64)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _guint64, _goerr
}

// Value returns the raw value associated with @key under @group_name. Use
// g_key_file_get_string() to retrieve an unescaped UTF-8 string.
//
// In the event the key cannot be found, nil is returned and @error is set to
// KEY_FILE_ERROR_KEY_NOT_FOUND. In the event that the @group_name cannot be
// found, nil is returned and @error is set to KEY_FILE_ERROR_GROUP_NOT_FOUND.
func (k *KeyFile) Value(groupName string, key string) (string, error) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _cret *C.gchar    // in
	var _cerr *C.GError   // in

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))
	_arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_key_file_get_value(_arg0, _arg1, _arg2, &_cerr)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _utf8, _goerr
}

// HasGroup looks whether the key file has the group @group_name.
func (k *KeyFile) HasGroup(groupName string) bool {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))
	_arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_key_file_has_group(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LoadFromData loads a key file from memory into an empty File structure. If
// the object cannot be created then error is set to a FileError.
func (k *KeyFile) LoadFromData(data string, length uint, flags KeyFileFlags) error {
	var _arg0 *C.GKeyFile     // out
	var _arg1 *C.gchar        // out
	var _arg2 C.gsize         // out
	var _arg3 C.GKeyFileFlags // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))
	_arg1 = (*C.gchar)(C.CString(data))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gsize)(length)
	_arg3 = (C.GKeyFileFlags)(flags)

	C.g_key_file_load_from_data(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// LoadFromDataDirs: this function looks for a key file named @file in the paths
// returned from g_get_user_data_dir() and g_get_system_data_dirs(), loads the
// file into @key_file and returns the file's full path in @full_path. If the
// file could not be loaded then an error is set to either a Error or FileError.
func (k *KeyFile) LoadFromDataDirs(file string, flags KeyFileFlags) (string, error) {
	var _arg0 *C.GKeyFile     // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.gchar        // in
	var _arg3 C.GKeyFileFlags // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))
	_arg1 = (*C.gchar)(C.CString(file))
	defer C.free(unsafe.Pointer(_arg1))
	_arg3 = (C.GKeyFileFlags)(flags)

	C.g_key_file_load_from_data_dirs(_arg0, _arg1, &_arg2, _arg3, &_cerr)

	var _fullPath string // out
	var _goerr error     // out

	_fullPath = C.GoString(_arg2)
	defer C.free(unsafe.Pointer(_arg2))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _fullPath, _goerr
}

// LoadFromDirs: this function looks for a key file named @file in the paths
// specified in @search_dirs, loads the file into @key_file and returns the
// file's full path in @full_path.
//
// If the file could not be found in any of the @search_dirs,
// G_KEY_FILE_ERROR_NOT_FOUND is returned. If the file is found but the OS
// returns an error when opening or reading the file, a G_FILE_ERROR is
// returned. If there is a problem parsing the file, a G_KEY_FILE_ERROR is
// returned.
func (k *KeyFile) LoadFromDirs(file string, searchDirs []string, flags KeyFileFlags) (string, error) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 **C.gchar
	var _arg3 *C.gchar        // in
	var _arg4 C.GKeyFileFlags // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))
	_arg1 = (*C.gchar)(C.CString(file))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (**C.gchar)(C.malloc(C.ulong(len(searchDirs)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice(_arg2, len(searchDirs))
		for i := range searchDirs {
			out[i] = (*C.gchar)(C.CString(searchDirs[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}
	_arg4 = (C.GKeyFileFlags)(flags)

	C.g_key_file_load_from_dirs(_arg0, _arg1, _arg2, &_arg3, _arg4, &_cerr)

	var _fullPath string // out
	var _goerr error     // out

	_fullPath = C.GoString(_arg3)
	defer C.free(unsafe.Pointer(_arg3))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _fullPath, _goerr
}

// LoadFromFile loads a key file into an empty File structure.
//
// If the OS returns an error when opening or reading the file, a G_FILE_ERROR
// is returned. If there is a problem parsing the file, a G_KEY_FILE_ERROR is
// returned.
//
// This function will never return a G_KEY_FILE_ERROR_NOT_FOUND error. If the
// @file is not found, G_FILE_ERROR_NOENT is returned.
func (k *KeyFile) LoadFromFile(file string, flags KeyFileFlags) error {
	var _arg0 *C.GKeyFile     // out
	var _arg1 *C.gchar        // out
	var _arg2 C.GKeyFileFlags // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))
	_arg1 = (*C.gchar)(C.CString(file))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GKeyFileFlags)(flags)

	C.g_key_file_load_from_file(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// RemoveComment removes a comment above @key from @group_name. If @key is nil
// then @comment will be removed above @group_name. If both @key and @group_name
// are nil, then @comment will be removed above the first group in the file.
func (k *KeyFile) RemoveComment(groupName string, key string) error {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))
	_arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_key_file_remove_comment(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// RemoveGroup removes the specified group, @group_name, from the key file.
func (k *KeyFile) RemoveGroup(groupName string) error {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))
	_arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_key_file_remove_group(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// RemoveKey removes @key in @group_name from the key file.
func (k *KeyFile) RemoveKey(groupName string, key string) error {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))
	_arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_key_file_remove_key(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// SaveToFile writes the contents of @key_file to @filename using
// g_file_set_contents(). If you need stricter guarantees about durability of
// the written file than are provided by g_file_set_contents(), use
// g_file_set_contents_full() with the return value of g_key_file_to_data().
//
// This function can fail for any of the reasons that g_file_set_contents() may
// fail.
func (k *KeyFile) SaveToFile(filename string) error {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))
	_arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_key_file_save_to_file(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// SetBoolean associates a new boolean value with @key under @group_name. If
// @key cannot be found then it is created.
func (k *KeyFile) SetBoolean(groupName string, key string, value bool) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _arg3 C.gboolean  // out

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))
	_arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg2))
	if value {
		_arg3 = C.TRUE
	}

	C.g_key_file_set_boolean(_arg0, _arg1, _arg2, _arg3)
}

// SetBooleanList associates a list of boolean values with @key under
// @group_name. If @key cannot be found then it is created. If @group_name is
// nil, the start_group is used.
func (k *KeyFile) SetBooleanList(groupName string, key string, list []bool) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _arg3 *C.gboolean
	var _arg4 C.gsize

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))
	_arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg2))
	_arg4 = C.gsize(len(list))
	_arg3 = (*C.gboolean)(unsafe.Pointer(&list[0]))

	C.g_key_file_set_boolean_list(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// SetComment places a comment above @key from @group_name.
//
// If @key is nil then @comment will be written above @group_name. If both @key
// and @group_name are nil, then @comment will be written above the first group
// in the file.
//
// Note that this function prepends a '#' comment marker to each line of
// @comment.
func (k *KeyFile) SetComment(groupName string, key string, comment string) error {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _arg3 *C.gchar    // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))
	_arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(comment))
	defer C.free(unsafe.Pointer(_arg3))

	C.g_key_file_set_comment(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// SetDouble associates a new double value with @key under @group_name. If @key
// cannot be found then it is created.
func (k *KeyFile) SetDouble(groupName string, key string, value float64) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _arg3 C.gdouble   // out

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))
	_arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.gdouble)(value)

	C.g_key_file_set_double(_arg0, _arg1, _arg2, _arg3)
}

// SetDoubleList associates a list of double values with @key under @group_name.
// If @key cannot be found then it is created.
func (k *KeyFile) SetDoubleList(groupName string, key string, list []float64) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _arg3 *C.gdouble
	var _arg4 C.gsize

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))
	_arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg2))
	_arg4 = C.gsize(len(list))
	_arg3 = (*C.gdouble)(unsafe.Pointer(&list[0]))

	C.g_key_file_set_double_list(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// SetInt64 associates a new integer value with @key under @group_name. If @key
// cannot be found then it is created.
func (k *KeyFile) SetInt64(groupName string, key string, value int64) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _arg3 C.gint64    // out

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))
	_arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.gint64)(value)

	C.g_key_file_set_int64(_arg0, _arg1, _arg2, _arg3)
}

// SetInteger associates a new integer value with @key under @group_name. If
// @key cannot be found then it is created.
func (k *KeyFile) SetInteger(groupName string, key string, value int) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _arg3 C.gint      // out

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))
	_arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.gint)(value)

	C.g_key_file_set_integer(_arg0, _arg1, _arg2, _arg3)
}

// SetIntegerList associates a list of integer values with @key under
// @group_name. If @key cannot be found then it is created.
func (k *KeyFile) SetIntegerList(groupName string, key string, list []int) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _arg3 *C.gint
	var _arg4 C.gsize

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))
	_arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg2))
	_arg4 = C.gsize(len(list))
	_arg3 = (*C.gint)(unsafe.Pointer(&list[0]))

	C.g_key_file_set_integer_list(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// SetListSeparator sets the character which is used to separate values in
// lists. Typically ';' or ',' are used as separators. The default list
// separator is ';'.
func (k *KeyFile) SetListSeparator(separator byte) {
	var _arg0 *C.GKeyFile // out
	var _arg1 C.gchar     // out

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))
	_arg1 = (C.gchar)(separator)

	C.g_key_file_set_list_separator(_arg0, _arg1)
}

// SetLocaleString associates a string value for @key and @locale under
// @group_name. If the translation for @key cannot be found then it is created.
func (k *KeyFile) SetLocaleString(groupName string, key string, locale string, _string string) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _arg3 *C.gchar    // out
	var _arg4 *C.gchar    // out

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))
	_arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(locale))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg4))

	C.g_key_file_set_locale_string(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// SetLocaleStringList associates a list of string values for @key and @locale
// under @group_name. If the translation for @key cannot be found then it is
// created.
func (k *KeyFile) SetLocaleStringList(groupName string, key string, locale string, list []string) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _arg3 *C.gchar    // out
	var _arg4 **C.gchar
	var _arg5 C.gsize

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))
	_arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(locale))
	defer C.free(unsafe.Pointer(_arg3))
	_arg5 = C.gsize(len(list))
	_arg4 = (**C.gchar)(C.malloc(C.ulong(len(list)) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg4))
	{
		out := unsafe.Slice(_arg4, len(list))
		for i := range list {
			out[i] = (*C.gchar)(C.CString(list[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.g_key_file_set_locale_string_list(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}

// SetString associates a new string value with @key under @group_name. If @key
// cannot be found then it is created. If @group_name cannot be found then it is
// created. Unlike g_key_file_set_value(), this function handles characters that
// need escaping, such as newlines.
func (k *KeyFile) SetString(groupName string, key string, _string string) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _arg3 *C.gchar    // out

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))
	_arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg3))

	C.g_key_file_set_string(_arg0, _arg1, _arg2, _arg3)
}

// SetStringList associates a list of string values for @key under @group_name.
// If @key cannot be found then it is created. If @group_name cannot be found
// then it is created.
func (k *KeyFile) SetStringList(groupName string, key string, list []string) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _arg3 **C.gchar
	var _arg4 C.gsize

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))
	_arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg2))
	_arg4 = C.gsize(len(list))
	_arg3 = (**C.gchar)(C.malloc(C.ulong(len(list)) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice(_arg3, len(list))
		for i := range list {
			out[i] = (*C.gchar)(C.CString(list[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.g_key_file_set_string_list(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// SetUint64 associates a new integer value with @key under @group_name. If @key
// cannot be found then it is created.
func (k *KeyFile) SetUint64(groupName string, key string, value uint64) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _arg3 C.guint64   // out

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))
	_arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.guint64)(value)

	C.g_key_file_set_uint64(_arg0, _arg1, _arg2, _arg3)
}

// SetValue associates a new value with @key under @group_name.
//
// If @key cannot be found then it is created. If @group_name cannot be found
// then it is created. To set an UTF-8 string which may contain characters that
// need escaping (such as newlines or spaces), use g_key_file_set_string().
func (k *KeyFile) SetValue(groupName string, key string, value string) {
	var _arg0 *C.GKeyFile // out
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _arg3 *C.gchar    // out

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))
	_arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg3))

	C.g_key_file_set_value(_arg0, _arg1, _arg2, _arg3)
}

// ToData: this function outputs @key_file as a string.
//
// Note that this function never reports an error, so it is safe to pass nil as
// @error.
func (k *KeyFile) ToData() (uint, string, error) {
	var _arg0 *C.GKeyFile // out
	var _arg1 C.gsize     // in
	var _cret *C.gchar    // in
	var _cerr *C.GError   // in

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))

	_cret = C.g_key_file_to_data(_arg0, &_arg1, &_cerr)

	var _length uint // out
	var _utf8 string // out
	var _goerr error // out

	_length = (uint)(_arg1)
	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _length, _utf8, _goerr
}

// Unref decreases the reference count of @key_file by 1. If the reference count
// reaches zero, frees the key file and all its allocated memory.
func (k *KeyFile) Unref() {
	var _arg0 *C.GKeyFile // out

	_arg0 = (*C.GKeyFile)(unsafe.Pointer(k.Native()))

	C.g_key_file_unref(_arg0)
}

// LogField: structure representing a single field in a structured log entry.
// See g_log_structured() for details.
//
// Log fields may contain arbitrary values, including binary with embedded nul
// bytes. If the field contains a string, the string must be UTF-8 encoded and
// have a trailing nul byte. Otherwise, @length must be set to a non-negative
// value.
type LogField C.GLogField

// WrapLogField wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapLogField(ptr unsafe.Pointer) *LogField {
	return (*LogField)(ptr)
}

// Native returns the underlying C source pointer.
func (l *LogField) Native() unsafe.Pointer {
	return unsafe.Pointer(l)
}

// MainContext: the `GMainContext` struct is an opaque data type representing a
// set of sources to be handled in a main loop.
type MainContext C.GMainContext

// WrapMainContext wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMainContext(ptr unsafe.Pointer) *MainContext {
	return (*MainContext)(ptr)
}

func marshalMainContext(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*MainContext)(unsafe.Pointer(b)), nil
}

// NewMainContext constructs a struct MainContext.
func NewMainContext() *MainContext {
	var _cret *C.GMainContext // in

	_cret = C.g_main_context_new()

	var _mainContext *MainContext // out

	_mainContext = WrapMainContext(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_mainContext, func(v *MainContext) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _mainContext
}

// Native returns the underlying C source pointer.
func (m *MainContext) Native() unsafe.Pointer {
	return unsafe.Pointer(m)
}

// Acquire tries to become the owner of the specified context. If some other
// thread is the owner of the context, returns false immediately. Ownership is
// properly recursive: the owner can require ownership again and will release
// ownership when g_main_context_release() is called as many times as
// g_main_context_acquire().
//
// You must be the owner of a context before you can call
// g_main_context_prepare(), g_main_context_query(), g_main_context_check(),
// g_main_context_dispatch().
func (c *MainContext) Acquire() bool {
	var _arg0 *C.GMainContext // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))

	_cret = C.g_main_context_acquire(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AddPoll adds a file descriptor to the set of file descriptors polled for this
// context. This will very seldom be used directly. Instead a typical event
// source will use g_source_add_unix_fd() instead.
func (c *MainContext) AddPoll(fd *PollFD, priority int) {
	var _arg0 *C.GMainContext // out
	var _arg1 *C.GPollFD      // out
	var _arg2 C.gint          // out

	_arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GPollFD)(unsafe.Pointer(fd.Native()))
	_arg2 = (C.gint)(priority)

	C.g_main_context_add_poll(_arg0, _arg1, _arg2)
}

// Check passes the results of polling back to the main loop. You should be
// careful to pass @fds and its length @n_fds as received from
// g_main_context_query(), as this functions relies on assumptions on how @fds
// is filled.
//
// You must have successfully acquired the context with g_main_context_acquire()
// before you may call this function.
func (c *MainContext) Check(maxPriority int, fds []PollFD) bool {
	var _arg0 *C.GMainContext // out
	var _arg1 C.gint          // out
	var _arg2 *C.GPollFD
	var _arg3 C.gint
	var _cret C.gboolean // in

	_arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))
	_arg1 = (C.gint)(maxPriority)
	_arg3 = C.gint(len(fds))
	_arg2 = (*C.GPollFD)(unsafe.Pointer(&fds[0]))

	_cret = C.g_main_context_check(_arg0, _arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Dispatch dispatches all pending sources.
//
// You must have successfully acquired the context with g_main_context_acquire()
// before you may call this function.
func (c *MainContext) Dispatch() {
	var _arg0 *C.GMainContext // out

	_arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))

	C.g_main_context_dispatch(_arg0)
}

// IsOwner determines whether this thread holds the (recursive) ownership of
// this Context. This is useful to know before waiting on another thread that
// may be blocking to get ownership of @context.
func (c *MainContext) IsOwner() bool {
	var _arg0 *C.GMainContext // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))

	_cret = C.g_main_context_is_owner(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Iteration runs a single iteration for the given main loop. This involves
// checking to see if any event sources are ready to be processed, then if no
// events sources are ready and @may_block is true, waiting for a source to
// become ready, then dispatching the highest priority events sources that are
// ready. Otherwise, if @may_block is false sources are not waited to become
// ready, only those highest priority events sources will be dispatched (if
// any), that are ready at this given moment without further waiting.
//
// Note that even when @may_block is true, it is still possible for
// g_main_context_iteration() to return false, since the wait may be interrupted
// for other reasons than an event source becoming ready.
func (c *MainContext) Iteration(mayBlock bool) bool {
	var _arg0 *C.GMainContext // out
	var _arg1 C.gboolean      // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))
	if mayBlock {
		_arg1 = C.TRUE
	}

	_cret = C.g_main_context_iteration(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Pending checks if any sources have pending events for the given context.
func (c *MainContext) Pending() bool {
	var _arg0 *C.GMainContext // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))

	_cret = C.g_main_context_pending(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PopThreadDefault pops @context off the thread-default context stack
// (verifying that it was on the top of the stack).
func (c *MainContext) PopThreadDefault() {
	var _arg0 *C.GMainContext // out

	_arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))

	C.g_main_context_pop_thread_default(_arg0)
}

// Prepare prepares to poll sources within a main loop. The resulting
// information for polling is determined by calling g_main_context_query ().
//
// You must have successfully acquired the context with g_main_context_acquire()
// before you may call this function.
func (c *MainContext) Prepare() (int, bool) {
	var _arg0 *C.GMainContext // out
	var _arg1 C.gint          // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))

	_cret = C.g_main_context_prepare(_arg0, &_arg1)

	var _priority int // out
	var _ok bool      // out

	_priority = (int)(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _priority, _ok
}

// PushThreadDefault acquires @context and sets it as the thread-default context
// for the current thread. This will cause certain asynchronous operations (such
// as most [gio][gio]-based I/O) which are started in this thread to run under
// @context and deliver their results to its main loop, rather than running
// under the global default context in the main thread. Note that calling this
// function changes the context returned by g_main_context_get_thread_default(),
// not the one returned by g_main_context_default(), so it does not affect the
// context used by functions like g_idle_add().
//
// Normally you would call this function shortly after creating a new thread,
// passing it a Context which will be run by a Loop in that thread, to set a new
// default context for all async operations in that thread. In this case you may
// not need to ever call g_main_context_pop_thread_default(), assuming you want
// the new Context to be the default for the whole lifecycle of the thread.
//
// If you don't have control over how the new thread was created (e.g. in the
// new thread isn't newly created, or if the thread life cycle is managed by a
// Pool), it is always suggested to wrap the logic that needs to use the new
// Context inside a g_main_context_push_thread_default() /
// g_main_context_pop_thread_default() pair, otherwise threads that are re-used
// will end up never explicitly releasing the Context reference they hold.
//
// In some cases you may want to schedule a single operation in a non-default
// context, or temporarily use a non-default context in the main thread. In that
// case, you can wrap the call to the asynchronous operation inside a
// g_main_context_push_thread_default() / g_main_context_pop_thread_default()
// pair, but it is up to you to ensure that no other asynchronous operations
// accidentally get started while the non-default context is active.
//
// Beware that libraries that predate this function may not correctly handle
// being used from a thread with a thread-default context. Eg, see
// g_file_supports_thread_contexts().
func (c *MainContext) PushThreadDefault() {
	var _arg0 *C.GMainContext // out

	_arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))

	C.g_main_context_push_thread_default(_arg0)
}

// Ref increases the reference count on a Context object by one.
func (c *MainContext) Ref() *MainContext {
	var _arg0 *C.GMainContext // out
	var _cret *C.GMainContext // in

	_arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))

	_cret = C.g_main_context_ref(_arg0)

	var _mainContext *MainContext // out

	_mainContext = WrapMainContext(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_mainContext, func(v *MainContext) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _mainContext
}

// Release releases ownership of a context previously acquired by this thread
// with g_main_context_acquire(). If the context was acquired multiple times,
// the ownership will be released only when g_main_context_release() is called
// as many times as it was acquired.
func (c *MainContext) Release() {
	var _arg0 *C.GMainContext // out

	_arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))

	C.g_main_context_release(_arg0)
}

// RemovePoll removes file descriptor from the set of file descriptors to be
// polled for a particular context.
func (c *MainContext) RemovePoll(fd *PollFD) {
	var _arg0 *C.GMainContext // out
	var _arg1 *C.GPollFD      // out

	_arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GPollFD)(unsafe.Pointer(fd.Native()))

	C.g_main_context_remove_poll(_arg0, _arg1)
}

// Unref decreases the reference count on a Context object by one. If the result
// is zero, free the context and free all associated memory.
func (c *MainContext) Unref() {
	var _arg0 *C.GMainContext // out

	_arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))

	C.g_main_context_unref(_arg0)
}

// Wakeup: if @context is currently blocking in g_main_context_iteration()
// waiting for a source to become ready, cause it to stop blocking and return.
// Otherwise, cause the next invocation of g_main_context_iteration() to return
// without blocking.
//
// This API is useful for low-level control over Context; for example,
// integrating it with main loop implementations such as Loop.
//
// Another related use for this function is when implementing a main loop with a
// termination condition, computed from multiple threads:
//
//      perform_work();
//
//      if (g_atomic_int_dec_and_test (&tasks_remaining))
//        g_main_context_wakeup (NULL);
func (c *MainContext) Wakeup() {
	var _arg0 *C.GMainContext // out

	_arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))

	C.g_main_context_wakeup(_arg0)
}

// MainLoop: the `GMainLoop` struct is an opaque data type representing the main
// event loop of a GLib or GTK+ application.
type MainLoop C.GMainLoop

// WrapMainLoop wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMainLoop(ptr unsafe.Pointer) *MainLoop {
	return (*MainLoop)(ptr)
}

func marshalMainLoop(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*MainLoop)(unsafe.Pointer(b)), nil
}

// NewMainLoop constructs a struct MainLoop.
func NewMainLoop(context *MainContext, isRunning bool) *MainLoop {
	var _arg1 *C.GMainContext // out
	var _arg2 C.gboolean      // out
	var _cret *C.GMainLoop    // in

	_arg1 = (*C.GMainContext)(unsafe.Pointer(context.Native()))
	if isRunning {
		_arg2 = C.TRUE
	}

	_cret = C.g_main_loop_new(_arg1, _arg2)

	var _mainLoop *MainLoop // out

	_mainLoop = WrapMainLoop(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_mainLoop, func(v *MainLoop) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _mainLoop
}

// Native returns the underlying C source pointer.
func (m *MainLoop) Native() unsafe.Pointer {
	return unsafe.Pointer(m)
}

// Context returns the Context of @loop.
func (l *MainLoop) Context() *MainContext {
	var _arg0 *C.GMainLoop    // out
	var _cret *C.GMainContext // in

	_arg0 = (*C.GMainLoop)(unsafe.Pointer(l.Native()))

	_cret = C.g_main_loop_get_context(_arg0)

	var _mainContext *MainContext // out

	_mainContext = WrapMainContext(unsafe.Pointer(_cret))

	return _mainContext
}

// IsRunning checks to see if the main loop is currently being run via
// g_main_loop_run().
func (l *MainLoop) IsRunning() bool {
	var _arg0 *C.GMainLoop // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GMainLoop)(unsafe.Pointer(l.Native()))

	_cret = C.g_main_loop_is_running(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Quit stops a Loop from running. Any calls to g_main_loop_run() for the loop
// will return.
//
// Note that sources that have already been dispatched when g_main_loop_quit()
// is called will still be executed.
func (l *MainLoop) Quit() {
	var _arg0 *C.GMainLoop // out

	_arg0 = (*C.GMainLoop)(unsafe.Pointer(l.Native()))

	C.g_main_loop_quit(_arg0)
}

// Ref increases the reference count on a Loop object by one.
func (l *MainLoop) Ref() *MainLoop {
	var _arg0 *C.GMainLoop // out
	var _cret *C.GMainLoop // in

	_arg0 = (*C.GMainLoop)(unsafe.Pointer(l.Native()))

	_cret = C.g_main_loop_ref(_arg0)

	var _mainLoop *MainLoop // out

	_mainLoop = WrapMainLoop(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_mainLoop, func(v *MainLoop) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _mainLoop
}

// Run runs a main loop until g_main_loop_quit() is called on the loop. If this
// is called for the thread of the loop's Context, it will process events from
// the loop, otherwise it will simply wait.
func (l *MainLoop) Run() {
	var _arg0 *C.GMainLoop // out

	_arg0 = (*C.GMainLoop)(unsafe.Pointer(l.Native()))

	C.g_main_loop_run(_arg0)
}

// Unref decreases the reference count on a Loop object by one. If the result is
// zero, free the loop and free all associated memory.
func (l *MainLoop) Unref() {
	var _arg0 *C.GMainLoop // out

	_arg0 = (*C.GMainLoop)(unsafe.Pointer(l.Native()))

	C.g_main_loop_unref(_arg0)
}

// MappedFile: the File represents a file mapping created with
// g_mapped_file_new(). It has only private members and should not be accessed
// directly.
type MappedFile C.GMappedFile

// WrapMappedFile wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMappedFile(ptr unsafe.Pointer) *MappedFile {
	return (*MappedFile)(ptr)
}

func marshalMappedFile(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*MappedFile)(unsafe.Pointer(b)), nil
}

// NewMappedFile constructs a struct MappedFile.
func NewMappedFile(filename string, writable bool) (*MappedFile, error) {
	var _arg1 *C.gchar       // out
	var _arg2 C.gboolean     // out
	var _cret *C.GMappedFile // in
	var _cerr *C.GError      // in

	_arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))
	if writable {
		_arg2 = C.TRUE
	}

	_cret = C.g_mapped_file_new(_arg1, _arg2, &_cerr)

	var _mappedFile *MappedFile // out
	var _goerr error            // out

	_mappedFile = WrapMappedFile(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_mappedFile, func(v *MappedFile) {
		C.free(unsafe.Pointer(v.Native()))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _mappedFile, _goerr
}

// NewMappedFileFromFd constructs a struct MappedFile.
func NewMappedFileFromFd(fd int, writable bool) (*MappedFile, error) {
	var _arg1 C.gint         // out
	var _arg2 C.gboolean     // out
	var _cret *C.GMappedFile // in
	var _cerr *C.GError      // in

	_arg1 = (C.gint)(fd)
	if writable {
		_arg2 = C.TRUE
	}

	_cret = C.g_mapped_file_new_from_fd(_arg1, _arg2, &_cerr)

	var _mappedFile *MappedFile // out
	var _goerr error            // out

	_mappedFile = WrapMappedFile(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_mappedFile, func(v *MappedFile) {
		C.free(unsafe.Pointer(v.Native()))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _mappedFile, _goerr
}

// Native returns the underlying C source pointer.
func (m *MappedFile) Native() unsafe.Pointer {
	return unsafe.Pointer(m)
}

// Free: this call existed before File had refcounting and is currently exactly
// the same as g_mapped_file_unref().
func (f *MappedFile) Free() {
	var _arg0 *C.GMappedFile // out

	_arg0 = (*C.GMappedFile)(unsafe.Pointer(f.Native()))

	C.g_mapped_file_free(_arg0)
}

// Contents returns the contents of a File.
//
// Note that the contents may not be zero-terminated, even if the File is backed
// by a text file.
//
// If the file is empty then nil is returned.
func (f *MappedFile) Contents() string {
	var _arg0 *C.GMappedFile // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GMappedFile)(unsafe.Pointer(f.Native()))

	_cret = C.g_mapped_file_get_contents(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Length returns the length of the contents of a File.
func (f *MappedFile) Length() uint {
	var _arg0 *C.GMappedFile // out
	var _cret C.gsize        // in

	_arg0 = (*C.GMappedFile)(unsafe.Pointer(f.Native()))

	_cret = C.g_mapped_file_get_length(_arg0)

	var _gsize uint // out

	_gsize = (uint)(_cret)

	return _gsize
}

// Ref increments the reference count of @file by one. It is safe to call this
// function from any thread.
func (f *MappedFile) Ref() *MappedFile {
	var _arg0 *C.GMappedFile // out
	var _cret *C.GMappedFile // in

	_arg0 = (*C.GMappedFile)(unsafe.Pointer(f.Native()))

	_cret = C.g_mapped_file_ref(_arg0)

	var _mappedFile *MappedFile // out

	_mappedFile = WrapMappedFile(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_mappedFile, func(v *MappedFile) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _mappedFile
}

// Unref decrements the reference count of @file by one. If the reference count
// drops to 0, unmaps the buffer of @file and frees it.
//
// It is safe to call this function from any thread.
//
// Since 2.22
func (f *MappedFile) Unref() {
	var _arg0 *C.GMappedFile // out

	_arg0 = (*C.GMappedFile)(unsafe.Pointer(f.Native()))

	C.g_mapped_file_unref(_arg0)
}

// MarkupParseContext: a parse context is used to parse a stream of bytes that
// you expect to contain marked-up text.
//
// See g_markup_parse_context_new(), Parser, and so on for more details.
type MarkupParseContext C.GMarkupParseContext

// WrapMarkupParseContext wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMarkupParseContext(ptr unsafe.Pointer) *MarkupParseContext {
	return (*MarkupParseContext)(ptr)
}

func marshalMarkupParseContext(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*MarkupParseContext)(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (m *MarkupParseContext) Native() unsafe.Pointer {
	return unsafe.Pointer(m)
}

// EndParse signals to the ParseContext that all data has been fed into the
// parse context with g_markup_parse_context_parse().
//
// This function reports an error if the document isn't complete, for example if
// elements are still open.
func (c *MarkupParseContext) EndParse() error {
	var _arg0 *C.GMarkupParseContext // out
	var _cerr *C.GError              // in

	_arg0 = (*C.GMarkupParseContext)(unsafe.Pointer(c.Native()))

	C.g_markup_parse_context_end_parse(_arg0, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// Free frees a ParseContext.
//
// This function can't be called from inside one of the Parser functions or
// while a subparser is pushed.
func (c *MarkupParseContext) Free() {
	var _arg0 *C.GMarkupParseContext // out

	_arg0 = (*C.GMarkupParseContext)(unsafe.Pointer(c.Native()))

	C.g_markup_parse_context_free(_arg0)
}

// Element retrieves the name of the currently open element.
//
// If called from the start_element or end_element handlers this will give the
// element_name as passed to those functions. For the parent elements, see
// g_markup_parse_context_get_element_stack().
func (c *MarkupParseContext) Element() string {
	var _arg0 *C.GMarkupParseContext // out
	var _cret *C.gchar               // in

	_arg0 = (*C.GMarkupParseContext)(unsafe.Pointer(c.Native()))

	_cret = C.g_markup_parse_context_get_element(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Position retrieves the current line number and the number of the character on
// that line. Intended for use in error messages; there are no strict semantics
// for what constitutes the "current" line number other than "the best number we
// could come up with for error messages."
func (c *MarkupParseContext) Position() (lineNumber int, charNumber int) {
	var _arg0 *C.GMarkupParseContext // out
	var _arg1 C.gint                 // in
	var _arg2 C.gint                 // in

	_arg0 = (*C.GMarkupParseContext)(unsafe.Pointer(c.Native()))

	C.g_markup_parse_context_get_position(_arg0, &_arg1, &_arg2)

	var _lineNumber int // out
	var _charNumber int // out

	_lineNumber = (int)(_arg1)
	_charNumber = (int)(_arg2)

	return _lineNumber, _charNumber
}

// Parse: feed some data to the ParseContext.
//
// The data need not be valid UTF-8; an error will be signaled if it's invalid.
// The data need not be an entire document; you can feed a document into the
// parser incrementally, via multiple calls to this function. Typically, as you
// receive data from a network connection or file, you feed each received chunk
// of data into this function, aborting the process if an error occurs. Once an
// error is reported, no further data may be fed to the ParseContext; all errors
// are fatal.
func (c *MarkupParseContext) Parse(text string, textLen int) error {
	var _arg0 *C.GMarkupParseContext // out
	var _arg1 *C.gchar               // out
	var _arg2 C.gssize               // out
	var _cerr *C.GError              // in

	_arg0 = (*C.GMarkupParseContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gssize)(textLen)

	C.g_markup_parse_context_parse(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// Ref increases the reference count of @context.
func (c *MarkupParseContext) Ref() *MarkupParseContext {
	var _arg0 *C.GMarkupParseContext // out
	var _cret *C.GMarkupParseContext // in

	_arg0 = (*C.GMarkupParseContext)(unsafe.Pointer(c.Native()))

	_cret = C.g_markup_parse_context_ref(_arg0)

	var _markupParseContext *MarkupParseContext // out

	_markupParseContext = WrapMarkupParseContext(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_markupParseContext, func(v *MarkupParseContext) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _markupParseContext
}

// Unref decreases the reference count of @context. When its reference count
// drops to 0, it is freed.
func (c *MarkupParseContext) Unref() {
	var _arg0 *C.GMarkupParseContext // out

	_arg0 = (*C.GMarkupParseContext)(unsafe.Pointer(c.Native()))

	C.g_markup_parse_context_unref(_arg0)
}

// MatchInfo: a GMatchInfo is an opaque struct used to return information about
// matches.
type MatchInfo C.GMatchInfo

// WrapMatchInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMatchInfo(ptr unsafe.Pointer) *MatchInfo {
	return (*MatchInfo)(ptr)
}

func marshalMatchInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*MatchInfo)(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (m *MatchInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(m)
}

// ExpandReferences returns a new string containing the text in
// @string_to_expand with references and escape sequences expanded. References
// refer to the last match done with @string against @regex and have the same
// syntax used by g_regex_replace().
//
// The @string_to_expand must be UTF-8 encoded even if REGEX_RAW was passed to
// g_regex_new().
//
// The backreferences are extracted from the string passed to the match
// function, so you cannot call this function after freeing the string.
//
// @match_info may be nil in which case @string_to_expand must not contain
// references. For instance "foo\n" does not refer to an actual pattern and '\n'
// merely will be replaced with \n character, while to expand "\0" (whole match)
// one needs the result of a match. Use g_regex_check_replacement() to find out
// whether @string_to_expand contains references.
func (m *MatchInfo) ExpandReferences(stringToExpand string) (string, error) {
	var _arg0 *C.GMatchInfo // out
	var _arg1 *C.gchar      // out
	var _cret *C.gchar      // in
	var _cerr *C.GError     // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(stringToExpand))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_match_info_expand_references(_arg0, _arg1, &_cerr)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _utf8, _goerr
}

// Fetch retrieves the text matching the @match_num'th capturing parentheses. 0
// is the full text of the match, 1 is the first paren set, 2 the second, and so
// on.
//
// If @match_num is a valid sub pattern but it didn't match anything (e.g. sub
// pattern 1, matching "b" against "(a)?b") then an empty string is returned.
//
// If the match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved string is not
// that of a set of parentheses but that of a matched substring. Substrings are
// matched in reverse order of length, so 0 is the longest match.
//
// The string is fetched from the string passed to the match function, so you
// cannot call this function after freeing the string.
func (m *MatchInfo) Fetch(matchNum int) string {
	var _arg0 *C.GMatchInfo // out
	var _arg1 C.gint        // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))
	_arg1 = (C.gint)(matchNum)

	_cret = C.g_match_info_fetch(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// FetchAll bundles up pointers to each of the matching substrings from a match
// and stores them in an array of gchar pointers. The first element in the
// returned array is the match number 0, i.e. the entire matched text.
//
// If a sub pattern didn't match anything (e.g. sub pattern 1, matching "b"
// against "(a)?b") then an empty string is inserted.
//
// If the last match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved strings are
// not that matched by sets of parentheses but that of the matched substring.
// Substrings are matched in reverse order of length, so the first one is the
// longest match.
//
// The strings are fetched from the string passed to the match function, so you
// cannot call this function after freeing the string.
func (m *MatchInfo) FetchAll() []string {
	var _arg0 *C.GMatchInfo // out
	var _cret **C.gchar

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))

	_cret = C.g_match_info_fetch_all(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// FetchNamed retrieves the text matching the capturing parentheses named @name.
//
// If @name is a valid sub pattern name but it didn't match anything (e.g. sub
// pattern "X", matching "b" against "(?P<X>a)?b") then an empty string is
// returned.
//
// The string is fetched from the string passed to the match function, so you
// cannot call this function after freeing the string.
func (m *MatchInfo) FetchNamed(name string) string {
	var _arg0 *C.GMatchInfo // out
	var _arg1 *C.gchar      // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_match_info_fetch_named(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// FetchNamedPos retrieves the position in bytes of the capturing parentheses
// named @name.
//
// If @name is a valid sub pattern name but it didn't match anything (e.g. sub
// pattern "X", matching "b" against "(?P<X>a)?b") then @start_pos and @end_pos
// are set to -1 and true is returned.
func (m *MatchInfo) FetchNamedPos(name string) (startPos int, endPos int, ok bool) {
	var _arg0 *C.GMatchInfo // out
	var _arg1 *C.gchar      // out
	var _arg2 C.gint        // in
	var _arg3 C.gint        // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_match_info_fetch_named_pos(_arg0, _arg1, &_arg2, &_arg3)

	var _startPos int // out
	var _endPos int   // out
	var _ok bool      // out

	_startPos = (int)(_arg2)
	_endPos = (int)(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _startPos, _endPos, _ok
}

// FetchPos retrieves the position in bytes of the @match_num'th capturing
// parentheses. 0 is the full text of the match, 1 is the first paren set, 2 the
// second, and so on.
//
// If @match_num is a valid sub pattern but it didn't match anything (e.g. sub
// pattern 1, matching "b" against "(a)?b") then @start_pos and @end_pos are set
// to -1 and true is returned.
//
// If the match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved position is
// not that of a set of parentheses but that of a matched substring. Substrings
// are matched in reverse order of length, so 0 is the longest match.
func (m *MatchInfo) FetchPos(matchNum int) (startPos int, endPos int, ok bool) {
	var _arg0 *C.GMatchInfo // out
	var _arg1 C.gint        // out
	var _arg2 C.gint        // in
	var _arg3 C.gint        // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))
	_arg1 = (C.gint)(matchNum)

	_cret = C.g_match_info_fetch_pos(_arg0, _arg1, &_arg2, &_arg3)

	var _startPos int // out
	var _endPos int   // out
	var _ok bool      // out

	_startPos = (int)(_arg2)
	_endPos = (int)(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _startPos, _endPos, _ok
}

// Free: if @match_info is not nil, calls g_match_info_unref(); otherwise does
// nothing.
func (m *MatchInfo) Free() {
	var _arg0 *C.GMatchInfo // out

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))

	C.g_match_info_free(_arg0)
}

// MatchCount retrieves the number of matched substrings (including substring 0,
// that is the whole matched text), so 1 is returned if the pattern has no
// substrings in it and 0 is returned if the match failed.
//
// If the last match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved count is not
// that of the number of capturing parentheses but that of the number of matched
// substrings.
func (m *MatchInfo) MatchCount() int {
	var _arg0 *C.GMatchInfo // out
	var _cret C.gint        // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))

	_cret = C.g_match_info_get_match_count(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Regex returns #GRegex object used in @match_info. It belongs to Glib and must
// not be freed. Use g_regex_ref() if you need to keep it after you free
// @match_info object.
func (m *MatchInfo) Regex() *Regex {
	var _arg0 *C.GMatchInfo // out
	var _cret *C.GRegex     // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))

	_cret = C.g_match_info_get_regex(_arg0)

	var _regex *Regex // out

	_regex = WrapRegex(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_regex, func(v *Regex) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _regex
}

// String returns the string searched with @match_info. This is the string
// passed to g_regex_match() or g_regex_replace() so you may not free it before
// calling this function.
func (m *MatchInfo) String() string {
	var _arg0 *C.GMatchInfo // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))

	_cret = C.g_match_info_get_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// IsPartialMatch: usually if the string passed to g_regex_match*() matches as
// far as it goes, but is too short to match the entire pattern, false is
// returned. There are circumstances where it might be helpful to distinguish
// this case from other cases in which there is no match.
//
// Consider, for example, an application where a human is required to type in
// data for a field with specific formatting requirements. An example might be a
// date in the form ddmmmyy, defined by the pattern
// "^\d?\d(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\d\d$". If the
// application sees the user’s keystrokes one by one, and can check that what
// has been typed so far is potentially valid, it is able to raise an error as
// soon as a mistake is made.
//
// GRegex supports the concept of partial matching by means of the
// REGEX_MATCH_PARTIAL_SOFT and REGEX_MATCH_PARTIAL_HARD flags. When they are
// used, the return code for g_regex_match() or g_regex_match_full() is, as
// usual, true for a complete match, false otherwise. But, when these functions
// return false, you can check if the match was partial calling
// g_match_info_is_partial_match().
//
// The difference between REGEX_MATCH_PARTIAL_SOFT and REGEX_MATCH_PARTIAL_HARD
// is that when a partial match is encountered with REGEX_MATCH_PARTIAL_SOFT,
// matching continues to search for a possible complete match, while with
// REGEX_MATCH_PARTIAL_HARD matching stops at the partial match. When both
// REGEX_MATCH_PARTIAL_SOFT and REGEX_MATCH_PARTIAL_HARD are set, the latter
// takes precedence.
//
// There were formerly some restrictions on the pattern for partial matching.
// The restrictions no longer apply.
//
// See pcrepartial(3) for more information on partial matching.
func (m *MatchInfo) IsPartialMatch() bool {
	var _arg0 *C.GMatchInfo // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))

	_cret = C.g_match_info_is_partial_match(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Matches returns whether the previous match operation succeeded.
func (m *MatchInfo) Matches() bool {
	var _arg0 *C.GMatchInfo // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))

	_cret = C.g_match_info_matches(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Next scans for the next match using the same parameters of the previous call
// to g_regex_match_full() or g_regex_match() that returned @match_info.
//
// The match is done on the string passed to the match function, so you cannot
// free it before calling this function.
func (m *MatchInfo) Next() error {
	var _arg0 *C.GMatchInfo // out
	var _cerr *C.GError     // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))

	C.g_match_info_next(_arg0, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// Ref increases reference count of @match_info by 1.
func (m *MatchInfo) Ref() *MatchInfo {
	var _arg0 *C.GMatchInfo // out
	var _cret *C.GMatchInfo // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))

	_cret = C.g_match_info_ref(_arg0)

	var _matchInfo *MatchInfo // out

	_matchInfo = WrapMatchInfo(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_matchInfo, func(v *MatchInfo) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _matchInfo
}

// Unref decreases reference count of @match_info by 1. When reference count
// drops to zero, it frees all the memory associated with the match_info
// structure.
func (m *MatchInfo) Unref() {
	var _arg0 *C.GMatchInfo // out

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))

	C.g_match_info_unref(_arg0)
}

// Node: the #GNode struct represents one node in a [n-ary
// tree][glib-N-ary-Trees].
type Node C.GNode

// WrapNode wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapNode(ptr unsafe.Pointer) *Node {
	return (*Node)(ptr)
}

// Native returns the underlying C source pointer.
func (n *Node) Native() unsafe.Pointer {
	return unsafe.Pointer(n)
}

// ChildPosition gets the position of a #GNode with respect to its siblings.
// @child must be a child of @node. The first child is numbered 0, the second 1,
// and so on.
func (n *Node) ChildPosition(child *Node) int {
	var _arg0 *C.GNode // out
	var _arg1 *C.GNode // out
	var _cret C.gint   // in

	_arg0 = (*C.GNode)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GNode)(unsafe.Pointer(child.Native()))

	_cret = C.g_node_child_position(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Depth gets the depth of a #GNode.
//
// If @node is nil the depth is 0. The root node has a depth of 1. For the
// children of the root node the depth is 2. And so on.
func (n *Node) Depth() uint {
	var _arg0 *C.GNode // out
	var _cret C.guint  // in

	_arg0 = (*C.GNode)(unsafe.Pointer(n.Native()))

	_cret = C.g_node_depth(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// Destroy removes @root and its children from the tree, freeing any memory
// allocated.
func (r *Node) Destroy() {
	var _arg0 *C.GNode // out

	_arg0 = (*C.GNode)(unsafe.Pointer(r.Native()))

	C.g_node_destroy(_arg0)
}

// IsAncestor returns true if @node is an ancestor of @descendant. This is true
// if node is the parent of @descendant, or if node is the grandparent of
// @descendant etc.
func (n *Node) IsAncestor(descendant *Node) bool {
	var _arg0 *C.GNode   // out
	var _arg1 *C.GNode   // out
	var _cret C.gboolean // in

	_arg0 = (*C.GNode)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GNode)(unsafe.Pointer(descendant.Native()))

	_cret = C.g_node_is_ancestor(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MaxHeight gets the maximum height of all branches beneath a #GNode. This is
// the maximum distance from the #GNode to all leaf nodes.
//
// If @root is nil, 0 is returned. If @root has no children, 1 is returned. If
// @root has children, 2 is returned. And so on.
func (r *Node) MaxHeight() uint {
	var _arg0 *C.GNode // out
	var _cret C.guint  // in

	_arg0 = (*C.GNode)(unsafe.Pointer(r.Native()))

	_cret = C.g_node_max_height(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// NChildren gets the number of children of a #GNode.
func (n *Node) NChildren() uint {
	var _arg0 *C.GNode // out
	var _cret C.guint  // in

	_arg0 = (*C.GNode)(unsafe.Pointer(n.Native()))

	_cret = C.g_node_n_children(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// NNodes gets the number of nodes in a tree.
func (r *Node) NNodes(flags TraverseFlags) uint {
	var _arg0 *C.GNode         // out
	var _arg1 C.GTraverseFlags // out
	var _cret C.guint          // in

	_arg0 = (*C.GNode)(unsafe.Pointer(r.Native()))
	_arg1 = (C.GTraverseFlags)(flags)

	_cret = C.g_node_n_nodes(_arg0, _arg1)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// ReverseChildren reverses the order of the children of a #GNode. (It doesn't
// change the order of the grandchildren.)
func (n *Node) ReverseChildren() {
	var _arg0 *C.GNode // out

	_arg0 = (*C.GNode)(unsafe.Pointer(n.Native()))

	C.g_node_reverse_children(_arg0)
}

// Unlink unlinks a #GNode from a tree, resulting in two separate trees.
func (n *Node) Unlink() {
	var _arg0 *C.GNode // out

	_arg0 = (*C.GNode)(unsafe.Pointer(n.Native()))

	C.g_node_unlink(_arg0)
}

// OptionContext: a `GOptionContext` struct defines which options are accepted
// by the commandline option parser. The struct has only private fields and
// should not be directly accessed.
type OptionContext C.GOptionContext

// WrapOptionContext wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapOptionContext(ptr unsafe.Pointer) *OptionContext {
	return (*OptionContext)(ptr)
}

// Native returns the underlying C source pointer.
func (o *OptionContext) Native() unsafe.Pointer {
	return unsafe.Pointer(o)
}

// AddGroup adds a Group to the @context, so that parsing with @context will
// recognize the options in the group. Note that this will take ownership of the
// @group and thus the @group should not be freed.
func (c *OptionContext) AddGroup(group *OptionGroup) {
	var _arg0 *C.GOptionContext // out
	var _arg1 *C.GOptionGroup   // out

	_arg0 = (*C.GOptionContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GOptionGroup)(unsafe.Pointer(group.Native()))

	C.g_option_context_add_group(_arg0, _arg1)
}

// AddMainEntries: a convenience function which creates a main group if it
// doesn't exist, adds the @entries to it and sets the translation domain.
func (c *OptionContext) AddMainEntries(entries []OptionEntry, translationDomain string) {
	var _arg0 *C.GOptionContext // out
	var _arg1 *C.GOptionEntry
	var _arg2 *C.gchar // out

	_arg0 = (*C.GOptionContext)(unsafe.Pointer(c.Native()))
	{
		var zero OptionEntry
		entries = append(entries, zero)
	}
	_arg1 = (*C.GOptionEntry)(unsafe.Pointer(&entries[0]))
	_arg2 = (*C.gchar)(C.CString(translationDomain))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_option_context_add_main_entries(_arg0, _arg1, _arg2)
}

// Free frees context and all the groups which have been added to it.
//
// Please note that parsed arguments need to be freed separately (see Entry).
func (c *OptionContext) Free() {
	var _arg0 *C.GOptionContext // out

	_arg0 = (*C.GOptionContext)(unsafe.Pointer(c.Native()))

	C.g_option_context_free(_arg0)
}

// Description returns the description. See g_option_context_set_description().
func (c *OptionContext) Description() string {
	var _arg0 *C.GOptionContext // out
	var _cret *C.gchar          // in

	_arg0 = (*C.GOptionContext)(unsafe.Pointer(c.Native()))

	_cret = C.g_option_context_get_description(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Help returns a formatted, translated help text for the given context. To
// obtain the text produced by `--help`, call `g_option_context_get_help
// (context, TRUE, NULL)`. To obtain the text produced by `--help-all`, call
// `g_option_context_get_help (context, FALSE, NULL)`. To obtain the help text
// for an option group, call `g_option_context_get_help (context, FALSE,
// group)`.
func (c *OptionContext) Help(mainHelp bool, group *OptionGroup) string {
	var _arg0 *C.GOptionContext // out
	var _arg1 C.gboolean        // out
	var _arg2 *C.GOptionGroup   // out
	var _cret *C.gchar          // in

	_arg0 = (*C.GOptionContext)(unsafe.Pointer(c.Native()))
	if mainHelp {
		_arg1 = C.TRUE
	}
	_arg2 = (*C.GOptionGroup)(unsafe.Pointer(group.Native()))

	_cret = C.g_option_context_get_help(_arg0, _arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// HelpEnabled returns whether automatic `--help` generation is turned on for
// @context. See g_option_context_set_help_enabled().
func (c *OptionContext) HelpEnabled() bool {
	var _arg0 *C.GOptionContext // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GOptionContext)(unsafe.Pointer(c.Native()))

	_cret = C.g_option_context_get_help_enabled(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IgnoreUnknownOptions returns whether unknown options are ignored or not. See
// g_option_context_set_ignore_unknown_options().
func (c *OptionContext) IgnoreUnknownOptions() bool {
	var _arg0 *C.GOptionContext // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GOptionContext)(unsafe.Pointer(c.Native()))

	_cret = C.g_option_context_get_ignore_unknown_options(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MainGroup returns a pointer to the main group of @context.
func (c *OptionContext) MainGroup() *OptionGroup {
	var _arg0 *C.GOptionContext // out
	var _cret *C.GOptionGroup   // in

	_arg0 = (*C.GOptionContext)(unsafe.Pointer(c.Native()))

	_cret = C.g_option_context_get_main_group(_arg0)

	var _optionGroup *OptionGroup // out

	_optionGroup = WrapOptionGroup(unsafe.Pointer(_cret))

	return _optionGroup
}

// StrictPosix returns whether strict POSIX code is enabled.
//
// See g_option_context_set_strict_posix() for more information.
func (c *OptionContext) StrictPosix() bool {
	var _arg0 *C.GOptionContext // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GOptionContext)(unsafe.Pointer(c.Native()))

	_cret = C.g_option_context_get_strict_posix(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Summary returns the summary. See g_option_context_set_summary().
func (c *OptionContext) Summary() string {
	var _arg0 *C.GOptionContext // out
	var _cret *C.gchar          // in

	_arg0 = (*C.GOptionContext)(unsafe.Pointer(c.Native()))

	_cret = C.g_option_context_get_summary(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// SetDescription adds a string to be displayed in `--help` output after the
// list of options. This text often includes a bug reporting address.
//
// Note that the summary is translated (see
// g_option_context_set_translate_func()).
func (c *OptionContext) SetDescription(description string) {
	var _arg0 *C.GOptionContext // out
	var _arg1 *C.gchar          // out

	_arg0 = (*C.GOptionContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(description))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_option_context_set_description(_arg0, _arg1)
}

// SetHelpEnabled enables or disables automatic generation of `--help` output.
// By default, g_option_context_parse() recognizes `--help`, `-h`, `-?`,
// `--help-all` and `--help-groupname` and creates suitable output to stdout.
func (c *OptionContext) SetHelpEnabled(helpEnabled bool) {
	var _arg0 *C.GOptionContext // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GOptionContext)(unsafe.Pointer(c.Native()))
	if helpEnabled {
		_arg1 = C.TRUE
	}

	C.g_option_context_set_help_enabled(_arg0, _arg1)
}

// SetIgnoreUnknownOptions sets whether to ignore unknown options or not. If an
// argument is ignored, it is left in the @argv array after parsing. By default,
// g_option_context_parse() treats unknown options as error.
//
// This setting does not affect non-option arguments (i.e. arguments which don't
// start with a dash). But note that GOption cannot reliably determine whether a
// non-option belongs to a preceding unknown option.
func (c *OptionContext) SetIgnoreUnknownOptions(ignoreUnknown bool) {
	var _arg0 *C.GOptionContext // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GOptionContext)(unsafe.Pointer(c.Native()))
	if ignoreUnknown {
		_arg1 = C.TRUE
	}

	C.g_option_context_set_ignore_unknown_options(_arg0, _arg1)
}

// SetMainGroup sets a Group as main group of the @context. This has the same
// effect as calling g_option_context_add_group(), the only difference is that
// the options in the main group are treated differently when generating
// `--help` output.
func (c *OptionContext) SetMainGroup(group *OptionGroup) {
	var _arg0 *C.GOptionContext // out
	var _arg1 *C.GOptionGroup   // out

	_arg0 = (*C.GOptionContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GOptionGroup)(unsafe.Pointer(group.Native()))

	C.g_option_context_set_main_group(_arg0, _arg1)
}

// SetStrictPosix sets strict POSIX mode.
//
// By default, this mode is disabled.
//
// In strict POSIX mode, the first non-argument parameter encountered (eg:
// filename) terminates argument processing. Remaining arguments are treated as
// non-options and are not attempted to be parsed.
//
// If strict POSIX mode is disabled then parsing is done in the GNU way where
// option arguments can be freely mixed with non-options.
//
// As an example, consider "ls foo -l". With GNU style parsing, this will list
// "foo" in long mode. In strict POSIX style, this will list the files named
// "foo" and "-l".
//
// It may be useful to force strict POSIX mode when creating "verb style"
// command line tools. For example, the "gsettings" command line tool supports
// the global option "--schemadir" as well as many subcommands ("get", "set",
// etc.) which each have their own set of arguments. Using strict POSIX mode
// will allow parsing the global options up to the verb name while leaving the
// remaining options to be parsed by the relevant subcommand (which can be
// determined by examining the verb name, which should be present in argv[1]
// after parsing).
func (c *OptionContext) SetStrictPosix(strictPosix bool) {
	var _arg0 *C.GOptionContext // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GOptionContext)(unsafe.Pointer(c.Native()))
	if strictPosix {
		_arg1 = C.TRUE
	}

	C.g_option_context_set_strict_posix(_arg0, _arg1)
}

// SetSummary adds a string to be displayed in `--help` output before the list
// of options. This is typically a summary of the program functionality.
//
// Note that the summary is translated (see
// g_option_context_set_translate_func() and
// g_option_context_set_translation_domain()).
func (c *OptionContext) SetSummary(summary string) {
	var _arg0 *C.GOptionContext // out
	var _arg1 *C.gchar          // out

	_arg0 = (*C.GOptionContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(summary))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_option_context_set_summary(_arg0, _arg1)
}

// SetTranslationDomain: a convenience function to use gettext() for translating
// user-visible strings.
func (c *OptionContext) SetTranslationDomain(domain string) {
	var _arg0 *C.GOptionContext // out
	var _arg1 *C.gchar          // out

	_arg0 = (*C.GOptionContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_option_context_set_translation_domain(_arg0, _arg1)
}

// OptionEntry: a GOptionEntry struct defines a single option. To have an
// effect, they must be added to a Group with
// g_option_context_add_main_entries() or g_option_group_add_entries().
type OptionEntry C.GOptionEntry

// WrapOptionEntry wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapOptionEntry(ptr unsafe.Pointer) *OptionEntry {
	return (*OptionEntry)(ptr)
}

// Native returns the underlying C source pointer.
func (o *OptionEntry) Native() unsafe.Pointer {
	return unsafe.Pointer(o)
}

// OptionGroup: a `GOptionGroup` struct defines the options in a single group.
// The struct has only private fields and should not be directly accessed.
//
// All options in a group share the same translation function. Libraries which
// need to parse commandline options are expected to provide a function for
// getting a `GOptionGroup` holding their options, which the application can
// then add to its Context.
type OptionGroup C.GOptionGroup

// WrapOptionGroup wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapOptionGroup(ptr unsafe.Pointer) *OptionGroup {
	return (*OptionGroup)(ptr)
}

func marshalOptionGroup(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*OptionGroup)(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (o *OptionGroup) Native() unsafe.Pointer {
	return unsafe.Pointer(o)
}

// AddEntries adds the options specified in @entries to @group.
func (g *OptionGroup) AddEntries(entries []OptionEntry) {
	var _arg0 *C.GOptionGroup // out
	var _arg1 *C.GOptionEntry

	_arg0 = (*C.GOptionGroup)(unsafe.Pointer(g.Native()))
	{
		var zero OptionEntry
		entries = append(entries, zero)
	}
	_arg1 = (*C.GOptionEntry)(unsafe.Pointer(&entries[0]))

	C.g_option_group_add_entries(_arg0, _arg1)
}

// Free frees a Group. Note that you must not free groups which have been added
// to a Context.
func (g *OptionGroup) Free() {
	var _arg0 *C.GOptionGroup // out

	_arg0 = (*C.GOptionGroup)(unsafe.Pointer(g.Native()))

	C.g_option_group_free(_arg0)
}

// Ref increments the reference count of @group by one.
func (g *OptionGroup) Ref() *OptionGroup {
	var _arg0 *C.GOptionGroup // out
	var _cret *C.GOptionGroup // in

	_arg0 = (*C.GOptionGroup)(unsafe.Pointer(g.Native()))

	_cret = C.g_option_group_ref(_arg0)

	var _optionGroup *OptionGroup // out

	_optionGroup = WrapOptionGroup(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_optionGroup, func(v *OptionGroup) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _optionGroup
}

// SetTranslationDomain: a convenience function to use gettext() for translating
// user-visible strings.
func (g *OptionGroup) SetTranslationDomain(domain string) {
	var _arg0 *C.GOptionGroup // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GOptionGroup)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_option_group_set_translation_domain(_arg0, _arg1)
}

// Unref decrements the reference count of @group by one. If the reference count
// drops to 0, the @group will be freed. and all memory allocated by the @group
// is released.
func (g *OptionGroup) Unref() {
	var _arg0 *C.GOptionGroup // out

	_arg0 = (*C.GOptionGroup)(unsafe.Pointer(g.Native()))

	C.g_option_group_unref(_arg0)
}

// PatternSpec: a GPatternSpec struct is the 'compiled' form of a pattern. This
// structure is opaque and its fields cannot be accessed directly.
type PatternSpec C.GPatternSpec

// WrapPatternSpec wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPatternSpec(ptr unsafe.Pointer) *PatternSpec {
	return (*PatternSpec)(ptr)
}

// Native returns the underlying C source pointer.
func (p *PatternSpec) Native() unsafe.Pointer {
	return unsafe.Pointer(p)
}

// Equal compares two compiled pattern specs and returns whether they will match
// the same set of strings.
func (p *PatternSpec) Equal(pspec2 *PatternSpec) bool {
	var _arg0 *C.GPatternSpec // out
	var _arg1 *C.GPatternSpec // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GPatternSpec)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GPatternSpec)(unsafe.Pointer(pspec2.Native()))

	_cret = C.g_pattern_spec_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Free frees the memory allocated for the Spec.
func (p *PatternSpec) Free() {
	var _arg0 *C.GPatternSpec // out

	_arg0 = (*C.GPatternSpec)(unsafe.Pointer(p.Native()))

	C.g_pattern_spec_free(_arg0)
}

// PollFD represents a file descriptor, which events to poll for, and which
// events occurred.
type PollFD C.GPollFD

// WrapPollFD wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPollFD(ptr unsafe.Pointer) *PollFD {
	return (*PollFD)(ptr)
}

func marshalPollFD(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*PollFD)(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (p *PollFD) Native() unsafe.Pointer {
	return unsafe.Pointer(p)
}

// Rand: the GRand struct is an opaque data structure. It should only be
// accessed through the g_rand_* functions.
type Rand C.GRand

// WrapRand wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRand(ptr unsafe.Pointer) *Rand {
	return (*Rand)(ptr)
}

// Native returns the underlying C source pointer.
func (r *Rand) Native() unsafe.Pointer {
	return unsafe.Pointer(r)
}

// Double returns the next random #gdouble from @rand_ equally distributed over
// the range [0..1).
func (r *Rand) Double() float64 {
	var _arg0 *C.GRand  // out
	var _cret C.gdouble // in

	_arg0 = (*C.GRand)(unsafe.Pointer(r.Native()))

	_cret = C.g_rand_double(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// DoubleRange returns the next random #gdouble from @rand_ equally distributed
// over the range [@begin..@end).
func (r *Rand) DoubleRange(begin float64, end float64) float64 {
	var _arg0 *C.GRand  // out
	var _arg1 C.gdouble // out
	var _arg2 C.gdouble // out
	var _cret C.gdouble // in

	_arg0 = (*C.GRand)(unsafe.Pointer(r.Native()))
	_arg1 = (C.gdouble)(begin)
	_arg2 = (C.gdouble)(end)

	_cret = C.g_rand_double_range(_arg0, _arg1, _arg2)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// Free frees the memory allocated for the #GRand.
func (r *Rand) Free() {
	var _arg0 *C.GRand // out

	_arg0 = (*C.GRand)(unsafe.Pointer(r.Native()))

	C.g_rand_free(_arg0)
}

// Int returns the next random #guint32 from @rand_ equally distributed over the
// range [0..2^32-1].
func (r *Rand) Int() uint32 {
	var _arg0 *C.GRand  // out
	var _cret C.guint32 // in

	_arg0 = (*C.GRand)(unsafe.Pointer(r.Native()))

	_cret = C.g_rand_int(_arg0)

	var _guint32 uint32 // out

	_guint32 = (uint32)(_cret)

	return _guint32
}

// IntRange returns the next random #gint32 from @rand_ equally distributed over
// the range [@begin..@end-1].
func (r *Rand) IntRange(begin int32, end int32) int32 {
	var _arg0 *C.GRand // out
	var _arg1 C.gint32 // out
	var _arg2 C.gint32 // out
	var _cret C.gint32 // in

	_arg0 = (*C.GRand)(unsafe.Pointer(r.Native()))
	_arg1 = (C.gint32)(begin)
	_arg2 = (C.gint32)(end)

	_cret = C.g_rand_int_range(_arg0, _arg1, _arg2)

	var _gint32 int32 // out

	_gint32 = (int32)(_cret)

	return _gint32
}

// SetSeed sets the seed for the random number generator #GRand to @seed.
func (r *Rand) SetSeed(seed uint32) {
	var _arg0 *C.GRand  // out
	var _arg1 C.guint32 // out

	_arg0 = (*C.GRand)(unsafe.Pointer(r.Native()))
	_arg1 = (C.guint32)(seed)

	C.g_rand_set_seed(_arg0, _arg1)
}

// SetSeedArray initializes the random number generator by an array of longs.
// Array can be of arbitrary size, though only the first 624 values are taken.
// This function is useful if you have many low entropy seeds, or if you require
// more then 32 bits of actual entropy for your application.
func (r *Rand) SetSeedArray(seed *uint32, seedLength uint) {
	var _arg0 *C.GRand   // out
	var _arg1 *C.guint32 // out
	var _arg2 C.guint    // out

	_arg0 = (*C.GRand)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.guint32)(unsafe.Pointer(seed))
	_arg2 = (C.guint)(seedLength)

	C.g_rand_set_seed_array(_arg0, _arg1, _arg2)
}

// Regex: the g_regex_*() functions implement regular expression pattern
// matching using syntax and semantics similar to Perl regular expression.
//
// Some functions accept a @start_position argument, setting it differs from
// just passing over a shortened string and setting REGEX_MATCH_NOTBOL in the
// case of a pattern that begins with any kind of lookbehind assertion. For
// example, consider the pattern "\Biss\B" which finds occurrences of "iss" in
// the middle of words. ("\B" matches only if the current position in the
// subject is not a word boundary.) When applied to the string "Mississipi" from
// the fourth byte, namely "issipi", it does not match, because "\B" is always
// false at the start of the subject, which is deemed to be a word boundary.
// However, if the entire string is passed , but with @start_position set to 4,
// it finds the second occurrence of "iss" because it is able to look behind the
// starting point to discover that it is preceded by a letter.
//
// Note that, unless you set the REGEX_RAW flag, all the strings passed to these
// functions must be encoded in UTF-8. The lengths and the positions inside the
// strings are in bytes and not in characters, so, for instance, "\xc3\xa0"
// (i.e. "à") is two bytes long but it is treated as a single character. If you
// set REGEX_RAW the strings can be non-valid UTF-8 strings and a byte is
// treated as a character, so "\xc3\xa0" is two bytes and two characters long.
//
// When matching a pattern, "\n" matches only against a "\n" character in the
// string, and "\r" matches only a "\r" character. To match any newline sequence
// use "\R". This particular group matches either the two-character sequence CR
// + LF ("\r\n"), or one of the single characters LF (linefeed, U+000A, "\n"),
// VT vertical tab, U+000B, "\v"), FF (formfeed, U+000C, "\f"), CR (carriage
// return, U+000D, "\r"), NEL (next line, U+0085), LS (line separator, U+2028),
// or PS (paragraph separator, U+2029).
//
// The behaviour of the dot, circumflex, and dollar metacharacters are affected
// by newline characters, the default is to recognize any newline character (the
// same characters recognized by "\R"). This can be changed with
// REGEX_NEWLINE_CR, REGEX_NEWLINE_LF and REGEX_NEWLINE_CRLF compile options,
// and with REGEX_MATCH_NEWLINE_ANY, REGEX_MATCH_NEWLINE_CR,
// REGEX_MATCH_NEWLINE_LF and REGEX_MATCH_NEWLINE_CRLF match options. These
// settings are also relevant when compiling a pattern if REGEX_EXTENDED is set,
// and an unescaped "#" outside a character class is encountered. This indicates
// a comment that lasts until after the next newline.
//
// When setting the G_REGEX_JAVASCRIPT_COMPAT flag, pattern syntax and pattern
// matching is changed to be compatible with the way that regular expressions
// work in JavaScript. More precisely, a lonely ']' character in the pattern is
// a syntax error; the '\x' escape only allows 0 to 2 hexadecimal digits, and
// you must use the '\u' escape sequence with 4 hex digits to specify a unicode
// codepoint instead of '\x' or 'x{....}'. If '\x' or '\u' are not followed by
// the specified number of hex digits, they match 'x' and 'u' literally; also
// '\U' always matches 'U' instead of being an error in the pattern. Finally,
// pattern matching is modified so that back references to an unset subpattern
// group produces a match with the empty string instead of an error. See
// pcreapi(3) for more information.
//
// Creating and manipulating the same #GRegex structure from different threads
// is not a problem as #GRegex does not modify its internal state between
// creation and destruction, on the other hand Info is not threadsafe.
//
// The regular expressions low-level functionalities are obtained through the
// excellent PCRE (http://www.pcre.org/) library written by Philip Hazel.
type Regex C.GRegex

// WrapRegex wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRegex(ptr unsafe.Pointer) *Regex {
	return (*Regex)(ptr)
}

func marshalRegex(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*Regex)(unsafe.Pointer(b)), nil
}

// NewRegex constructs a struct Regex.
func NewRegex(pattern string, compileOptions RegexCompileFlags, matchOptions RegexMatchFlags) (*Regex, error) {
	var _arg1 *C.gchar             // out
	var _arg2 C.GRegexCompileFlags // out
	var _arg3 C.GRegexMatchFlags   // out
	var _cret *C.GRegex            // in
	var _cerr *C.GError            // in

	_arg1 = (*C.gchar)(C.CString(pattern))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GRegexCompileFlags)(compileOptions)
	_arg3 = (C.GRegexMatchFlags)(matchOptions)

	_cret = C.g_regex_new(_arg1, _arg2, _arg3, &_cerr)

	var _regex *Regex // out
	var _goerr error  // out

	_regex = WrapRegex(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_regex, func(v *Regex) {
		C.free(unsafe.Pointer(v.Native()))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _regex, _goerr
}

// Native returns the underlying C source pointer.
func (r *Regex) Native() unsafe.Pointer {
	return unsafe.Pointer(r)
}

// CaptureCount returns the number of capturing subpatterns in the pattern.
func (r *Regex) CaptureCount() int {
	var _arg0 *C.GRegex // out
	var _cret C.gint    // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))

	_cret = C.g_regex_get_capture_count(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// CompileFlags returns the compile options that @regex was created with.
//
// Depending on the version of PCRE that is used, this may or may not include
// flags set by option expressions such as `(?i)` found at the top-level within
// the compiled pattern.
func (r *Regex) CompileFlags() RegexCompileFlags {
	var _arg0 *C.GRegex            // out
	var _cret C.GRegexCompileFlags // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))

	_cret = C.g_regex_get_compile_flags(_arg0)

	var _regexCompileFlags RegexCompileFlags // out

	_regexCompileFlags = RegexCompileFlags(_cret)

	return _regexCompileFlags
}

// HasCrOrLf checks whether the pattern contains explicit CR or LF references.
func (r *Regex) HasCrOrLf() bool {
	var _arg0 *C.GRegex  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))

	_cret = C.g_regex_get_has_cr_or_lf(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MatchFlags returns the match options that @regex was created with.
func (r *Regex) MatchFlags() RegexMatchFlags {
	var _arg0 *C.GRegex          // out
	var _cret C.GRegexMatchFlags // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))

	_cret = C.g_regex_get_match_flags(_arg0)

	var _regexMatchFlags RegexMatchFlags // out

	_regexMatchFlags = RegexMatchFlags(_cret)

	return _regexMatchFlags
}

// MaxBackref returns the number of the highest back reference in the pattern,
// or 0 if the pattern does not contain back references.
func (r *Regex) MaxBackref() int {
	var _arg0 *C.GRegex // out
	var _cret C.gint    // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))

	_cret = C.g_regex_get_max_backref(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// MaxLookbehind gets the number of characters in the longest lookbehind
// assertion in the pattern. This information is useful when doing multi-segment
// matching using the partial matching facilities.
func (r *Regex) MaxLookbehind() int {
	var _arg0 *C.GRegex // out
	var _cret C.gint    // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))

	_cret = C.g_regex_get_max_lookbehind(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Pattern gets the pattern string associated with @regex, i.e. a copy of the
// string passed to g_regex_new().
func (r *Regex) Pattern() string {
	var _arg0 *C.GRegex // out
	var _cret *C.gchar  // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))

	_cret = C.g_regex_get_pattern(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// StringNumber retrieves the number of the subexpression named @name.
func (r *Regex) StringNumber(name string) int {
	var _arg0 *C.GRegex // out
	var _arg1 *C.gchar  // out
	var _cret C.gint    // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_regex_get_string_number(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Match scans for a match in @string for the pattern in @regex. The
// @match_options are combined with the match options specified when the @regex
// structure was created, letting you have more flexibility in reusing #GRegex
// structures.
//
// Unless G_REGEX_RAW is specified in the options, @string must be valid UTF-8.
//
// A Info structure, used to get information on the match, is stored in
// @match_info if not nil. Note that if @match_info is not nil then it is
// created even if the function returns false, i.e. you must free it regardless
// if regular expression actually matched.
//
// To retrieve all the non-overlapping matches of the pattern in string you can
// use g_match_info_next().
//
//    static void
//    print_uppercase_words (const gchar *string)
//    {
//      // Print all uppercase-only words.
//      GRegex *regex;
//      GMatchInfo *match_info;
//
//      regex = g_regex_new ("[A-Z]+", 0, 0, NULL);
//      g_regex_match (regex, string, 0, &match_info);
//      while (g_match_info_matches (match_info))
//        {
//          gchar *word = g_match_info_fetch (match_info, 0);
//          g_print ("Found: s\n", word);
//          g_free (word);
//          g_match_info_next (match_info, NULL);
//        }
//      g_match_info_free (match_info);
//      g_regex_unref (regex);
//    }
//
// @string is not copied and is used in Info internally. If you use any Info
// method (except g_match_info_free()) after freeing or modifying @string then
// the behaviour is undefined.
func (r *Regex) Match(_string string, matchOptions RegexMatchFlags) (*MatchInfo, bool) {
	var _arg0 *C.GRegex          // out
	var _arg1 *C.gchar           // out
	var _arg2 C.GRegexMatchFlags // out
	var _matchInfo *MatchInfo
	var _cret C.gboolean // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.gchar)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GRegexMatchFlags)(matchOptions)

	_cret = C.g_regex_match(_arg0, _arg1, _arg2, (**C.GMatchInfo)(unsafe.Pointer(&_matchInfo)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _matchInfo, _ok
}

// MatchAll: using the standard algorithm for regular expression matching only
// the longest match in the string is retrieved. This function uses a different
// algorithm so it can retrieve all the possible matches. For more documentation
// see g_regex_match_all_full().
//
// A Info structure, used to get information on the match, is stored in
// @match_info if not nil. Note that if @match_info is not nil then it is
// created even if the function returns false, i.e. you must free it regardless
// if regular expression actually matched.
//
// @string is not copied and is used in Info internally. If you use any Info
// method (except g_match_info_free()) after freeing or modifying @string then
// the behaviour is undefined.
func (r *Regex) MatchAll(_string string, matchOptions RegexMatchFlags) (*MatchInfo, bool) {
	var _arg0 *C.GRegex          // out
	var _arg1 *C.gchar           // out
	var _arg2 C.GRegexMatchFlags // out
	var _matchInfo *MatchInfo
	var _cret C.gboolean // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.gchar)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GRegexMatchFlags)(matchOptions)

	_cret = C.g_regex_match_all(_arg0, _arg1, _arg2, (**C.GMatchInfo)(unsafe.Pointer(&_matchInfo)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _matchInfo, _ok
}

// MatchAllFull: using the standard algorithm for regular expression matching
// only the longest match in the @string is retrieved, it is not possible to
// obtain all the available matches. For instance matching "<a> <b> <c>" against
// the pattern "<.*>" you get "<a> <b> <c>".
//
// This function uses a different algorithm (called DFA, i.e. deterministic
// finite automaton), so it can retrieve all the possible matches, all starting
// at the same point in the string. For instance matching "<a> <b> <c>" against
// the pattern "<.*>;" you would obtain three matches: "<a> <b> <c>", "<a> <b>"
// and "<a>".
//
// The number of matched strings is retrieved using
// g_match_info_get_match_count(). To obtain the matched strings and their
// position you can use, respectively, g_match_info_fetch() and
// g_match_info_fetch_pos(). Note that the strings are returned in reverse order
// of length; that is, the longest matching string is given first.
//
// Note that the DFA algorithm is slower than the standard one and it is not
// able to capture substrings, so backreferences do not work.
//
// Setting @start_position differs from just passing over a shortened string and
// setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind
// of lookbehind assertion, such as "\b".
//
// Unless G_REGEX_RAW is specified in the options, @string must be valid UTF-8.
//
// A Info structure, used to get information on the match, is stored in
// @match_info if not nil. Note that if @match_info is not nil then it is
// created even if the function returns false, i.e. you must free it regardless
// if regular expression actually matched.
//
// @string is not copied and is used in Info internally. If you use any Info
// method (except g_match_info_free()) after freeing or modifying @string then
// the behaviour is undefined.
func (r *Regex) MatchAllFull(_string []byte, startPosition int, matchOptions RegexMatchFlags) (*MatchInfo, error) {
	var _arg0 *C.GRegex // out
	var _arg1 *C.gchar
	var _arg2 C.gssize
	var _arg3 C.gint             // out
	var _arg4 C.GRegexMatchFlags // out
	var _matchInfo *MatchInfo
	var _cerr *C.GError // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))
	_arg2 = C.gssize(len(_string))
	_arg1 = (*C.gchar)(unsafe.Pointer(&_string[0]))
	_arg3 = (C.gint)(startPosition)
	_arg4 = (C.GRegexMatchFlags)(matchOptions)

	C.g_regex_match_all_full(_arg0, _arg1, _arg2, _arg3, _arg4, (**C.GMatchInfo)(unsafe.Pointer(&_matchInfo)), &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _matchInfo, _goerr
}

// MatchFull scans for a match in @string for the pattern in @regex. The
// @match_options are combined with the match options specified when the @regex
// structure was created, letting you have more flexibility in reusing #GRegex
// structures.
//
// Setting @start_position differs from just passing over a shortened string and
// setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind
// of lookbehind assertion, such as "\b".
//
// Unless G_REGEX_RAW is specified in the options, @string must be valid UTF-8.
//
// A Info structure, used to get information on the match, is stored in
// @match_info if not nil. Note that if @match_info is not nil then it is
// created even if the function returns false, i.e. you must free it regardless
// if regular expression actually matched.
//
// @string is not copied and is used in Info internally. If you use any Info
// method (except g_match_info_free()) after freeing or modifying @string then
// the behaviour is undefined.
//
// To retrieve all the non-overlapping matches of the pattern in string you can
// use g_match_info_next().
//
//    static void
//    print_uppercase_words (const gchar *string)
//    {
//      // Print all uppercase-only words.
//      GRegex *regex;
//      GMatchInfo *match_info;
//      GError *error = NULL;
//
//      regex = g_regex_new ("[A-Z]+", 0, 0, NULL);
//      g_regex_match_full (regex, string, -1, 0, 0, &match_info, &error);
//      while (g_match_info_matches (match_info))
//        {
//          gchar *word = g_match_info_fetch (match_info, 0);
//          g_print ("Found: s\n", word);
//          g_free (word);
//          g_match_info_next (match_info, &error);
//        }
//      g_match_info_free (match_info);
//      g_regex_unref (regex);
//      if (error != NULL)
//        {
//          g_printerr ("Error while matching: s\n", error->message);
//          g_error_free (error);
//        }
//    }
func (r *Regex) MatchFull(_string []byte, startPosition int, matchOptions RegexMatchFlags) (*MatchInfo, error) {
	var _arg0 *C.GRegex // out
	var _arg1 *C.gchar
	var _arg2 C.gssize
	var _arg3 C.gint             // out
	var _arg4 C.GRegexMatchFlags // out
	var _matchInfo *MatchInfo
	var _cerr *C.GError // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))
	_arg2 = C.gssize(len(_string))
	_arg1 = (*C.gchar)(unsafe.Pointer(&_string[0]))
	_arg3 = (C.gint)(startPosition)
	_arg4 = (C.GRegexMatchFlags)(matchOptions)

	C.g_regex_match_full(_arg0, _arg1, _arg2, _arg3, _arg4, (**C.GMatchInfo)(unsafe.Pointer(&_matchInfo)), &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _matchInfo, _goerr
}

// Ref increases reference count of @regex by 1.
func (r *Regex) Ref() *Regex {
	var _arg0 *C.GRegex // out
	var _cret *C.GRegex // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))

	_cret = C.g_regex_ref(_arg0)

	var _ret *Regex // out

	_ret = WrapRegex(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_ret, func(v *Regex) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _ret
}

// Replace replaces all occurrences of the pattern in @regex with the
// replacement text. Backreferences of the form '\number' or '\g<number>' in the
// replacement text are interpolated by the number-th captured subexpression of
// the match, '\g<name>' refers to the captured subexpression with the given
// name. '\0' refers to the complete match, but '\0' followed by a number is the
// octal representation of a character. To include a literal '\' in the
// replacement, write '\\\\'.
//
// There are also escapes that changes the case of the following text:
//
// - \l: Convert to lower case the next character - \u: Convert to upper case
// the next character - \L: Convert to lower case till \E - \U: Convert to upper
// case till \E - \E: End case modification
//
// If you do not need to use backreferences use g_regex_replace_literal().
//
// The @replacement string must be UTF-8 encoded even if REGEX_RAW was passed to
// g_regex_new(). If you want to use not UTF-8 encoded strings you can use
// g_regex_replace_literal().
//
// Setting @start_position differs from just passing over a shortened string and
// setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind
// of lookbehind assertion, such as "\b".
func (r *Regex) Replace(_string []byte, startPosition int, replacement string, matchOptions RegexMatchFlags) (string, error) {
	var _arg0 *C.GRegex // out
	var _arg1 *C.gchar
	var _arg2 C.gssize
	var _arg3 C.gint             // out
	var _arg4 *C.gchar           // out
	var _arg5 C.GRegexMatchFlags // out
	var _cret *C.gchar           // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))
	_arg2 = C.gssize(len(_string))
	_arg1 = (*C.gchar)(unsafe.Pointer(&_string[0]))
	_arg3 = (C.gint)(startPosition)
	_arg4 = (*C.gchar)(C.CString(replacement))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (C.GRegexMatchFlags)(matchOptions)

	_cret = C.g_regex_replace(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _utf8, _goerr
}

// ReplaceLiteral replaces all occurrences of the pattern in @regex with the
// replacement text. @replacement is replaced literally, to include
// backreferences use g_regex_replace().
//
// Setting @start_position differs from just passing over a shortened string and
// setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind
// of lookbehind assertion, such as "\b".
func (r *Regex) ReplaceLiteral(_string []byte, startPosition int, replacement string, matchOptions RegexMatchFlags) (string, error) {
	var _arg0 *C.GRegex // out
	var _arg1 *C.gchar
	var _arg2 C.gssize
	var _arg3 C.gint             // out
	var _arg4 *C.gchar           // out
	var _arg5 C.GRegexMatchFlags // out
	var _cret *C.gchar           // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))
	_arg2 = C.gssize(len(_string))
	_arg1 = (*C.gchar)(unsafe.Pointer(&_string[0]))
	_arg3 = (C.gint)(startPosition)
	_arg4 = (*C.gchar)(C.CString(replacement))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (C.GRegexMatchFlags)(matchOptions)

	_cret = C.g_regex_replace_literal(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _utf8, _goerr
}

// Split breaks the string on the pattern, and returns an array of the tokens.
// If the pattern contains capturing parentheses, then the text for each of the
// substrings will also be returned. If the pattern does not match anywhere in
// the string, then the whole string is returned as the first token.
//
// As a special case, the result of splitting the empty string "" is an empty
// vector, not a vector containing a single string. The reason for this special
// case is that being able to represent an empty vector is typically more useful
// than consistent handling of empty elements. If you do need to represent empty
// elements, you'll need to check for the empty string before calling this
// function.
//
// A pattern that can match empty strings splits @string into separate
// characters wherever it matches the empty string between characters. For
// example splitting "ab c" using as a separator "\s*", you will get "a", "b"
// and "c".
func (r *Regex) Split(_string string, matchOptions RegexMatchFlags) []string {
	var _arg0 *C.GRegex          // out
	var _arg1 *C.gchar           // out
	var _arg2 C.GRegexMatchFlags // out
	var _cret **C.gchar

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.gchar)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GRegexMatchFlags)(matchOptions)

	_cret = C.g_regex_split(_arg0, _arg1, _arg2)

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// SplitFull breaks the string on the pattern, and returns an array of the
// tokens. If the pattern contains capturing parentheses, then the text for each
// of the substrings will also be returned. If the pattern does not match
// anywhere in the string, then the whole string is returned as the first token.
//
// As a special case, the result of splitting the empty string "" is an empty
// vector, not a vector containing a single string. The reason for this special
// case is that being able to represent an empty vector is typically more useful
// than consistent handling of empty elements. If you do need to represent empty
// elements, you'll need to check for the empty string before calling this
// function.
//
// A pattern that can match empty strings splits @string into separate
// characters wherever it matches the empty string between characters. For
// example splitting "ab c" using as a separator "\s*", you will get "a", "b"
// and "c".
//
// Setting @start_position differs from just passing over a shortened string and
// setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind
// of lookbehind assertion, such as "\b".
func (r *Regex) SplitFull(_string []byte, startPosition int, matchOptions RegexMatchFlags, maxTokens int) ([]string, error) {
	var _arg0 *C.GRegex // out
	var _arg1 *C.gchar
	var _arg2 C.gssize
	var _arg3 C.gint             // out
	var _arg4 C.GRegexMatchFlags // out
	var _arg5 C.gint             // out
	var _cret **C.gchar
	var _cerr *C.GError // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))
	_arg2 = C.gssize(len(_string))
	_arg1 = (*C.gchar)(unsafe.Pointer(&_string[0]))
	_arg3 = (C.gint)(startPosition)
	_arg4 = (C.GRegexMatchFlags)(matchOptions)
	_arg5 = (C.gint)(maxTokens)

	_cret = C.g_regex_split_full(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _utf8s []string
	var _goerr error // out

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _utf8s, _goerr
}

// Unref decreases reference count of @regex by 1. When reference count drops to
// zero, it frees all the memory associated with the regex structure.
func (r *Regex) Unref() {
	var _arg0 *C.GRegex // out

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))

	C.g_regex_unref(_arg0)
}

// ScannerConfig specifies the #GScanner parser configuration. Most settings can
// be changed during the parsing phase and will affect the lexical parsing of
// the next unpeeked token.
type ScannerConfig C.GScannerConfig

// WrapScannerConfig wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapScannerConfig(ptr unsafe.Pointer) *ScannerConfig {
	return (*ScannerConfig)(ptr)
}

// Native returns the underlying C source pointer.
func (s *ScannerConfig) Native() unsafe.Pointer {
	return unsafe.Pointer(s)
}

// Sequence: the #GSequence struct is an opaque data type representing a
// [sequence][glib-Sequences] data type.
type Sequence C.GSequence

// WrapSequence wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSequence(ptr unsafe.Pointer) *Sequence {
	return (*Sequence)(ptr)
}

// Native returns the underlying C source pointer.
func (s *Sequence) Native() unsafe.Pointer {
	return unsafe.Pointer(s)
}

// Free frees the memory allocated for @seq. If @seq has a data destroy function
// associated with it, that function is called on all items in @seq.
func (s *Sequence) Free() {
	var _arg0 *C.GSequence // out

	_arg0 = (*C.GSequence)(unsafe.Pointer(s.Native()))

	C.g_sequence_free(_arg0)
}

// BeginIter returns the begin iterator for @seq.
func (s *Sequence) BeginIter() *SequenceIter {
	var _arg0 *C.GSequence     // out
	var _cret *C.GSequenceIter // in

	_arg0 = (*C.GSequence)(unsafe.Pointer(s.Native()))

	_cret = C.g_sequence_get_begin_iter(_arg0)

	var _sequenceIter *SequenceIter // out

	_sequenceIter = WrapSequenceIter(unsafe.Pointer(_cret))

	return _sequenceIter
}

// EndIter returns the end iterator for @seg
func (s *Sequence) EndIter() *SequenceIter {
	var _arg0 *C.GSequence     // out
	var _cret *C.GSequenceIter // in

	_arg0 = (*C.GSequence)(unsafe.Pointer(s.Native()))

	_cret = C.g_sequence_get_end_iter(_arg0)

	var _sequenceIter *SequenceIter // out

	_sequenceIter = WrapSequenceIter(unsafe.Pointer(_cret))

	return _sequenceIter
}

// IterAtPos returns the iterator at position @pos. If @pos is negative or
// larger than the number of items in @seq, the end iterator is returned.
func (s *Sequence) IterAtPos(pos int) *SequenceIter {
	var _arg0 *C.GSequence     // out
	var _arg1 C.gint           // out
	var _cret *C.GSequenceIter // in

	_arg0 = (*C.GSequence)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gint)(pos)

	_cret = C.g_sequence_get_iter_at_pos(_arg0, _arg1)

	var _sequenceIter *SequenceIter // out

	_sequenceIter = WrapSequenceIter(unsafe.Pointer(_cret))

	return _sequenceIter
}

// Length returns the positive length (>= 0) of @seq. Note that this method is
// O(h) where `h' is the height of the tree. It is thus more efficient to use
// g_sequence_is_empty() when comparing the length to zero.
func (s *Sequence) Length() int {
	var _arg0 *C.GSequence // out
	var _cret C.gint       // in

	_arg0 = (*C.GSequence)(unsafe.Pointer(s.Native()))

	_cret = C.g_sequence_get_length(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// IsEmpty returns true if the sequence contains zero items.
//
// This function is functionally identical to checking the result of
// g_sequence_get_length() being equal to zero. However this function is
// implemented in O(1) running time.
func (s *Sequence) IsEmpty() bool {
	var _arg0 *C.GSequence // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSequence)(unsafe.Pointer(s.Native()))

	_cret = C.g_sequence_is_empty(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SequenceIter: the Iter struct is an opaque data type representing an iterator
// pointing into a #GSequence.
type SequenceIter C.GSequenceIter

// WrapSequenceIter wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSequenceIter(ptr unsafe.Pointer) *SequenceIter {
	return (*SequenceIter)(ptr)
}

// Native returns the underlying C source pointer.
func (s *SequenceIter) Native() unsafe.Pointer {
	return unsafe.Pointer(s)
}

// Compare returns a negative number if @a comes before @b, 0 if they are equal,
// and a positive number if @a comes after @b.
//
// The @a and @b iterators must point into the same sequence.
func (a *SequenceIter) Compare(b *SequenceIter) int {
	var _arg0 *C.GSequenceIter // out
	var _arg1 *C.GSequenceIter // out
	var _cret C.gint           // in

	_arg0 = (*C.GSequenceIter)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GSequenceIter)(unsafe.Pointer(b.Native()))

	_cret = C.g_sequence_iter_compare(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Position returns the position of @iter
func (i *SequenceIter) Position() int {
	var _arg0 *C.GSequenceIter // out
	var _cret C.gint           // in

	_arg0 = (*C.GSequenceIter)(unsafe.Pointer(i.Native()))

	_cret = C.g_sequence_iter_get_position(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Sequence returns the #GSequence that @iter points into.
func (i *SequenceIter) Sequence() *Sequence {
	var _arg0 *C.GSequenceIter // out
	var _cret *C.GSequence     // in

	_arg0 = (*C.GSequenceIter)(unsafe.Pointer(i.Native()))

	_cret = C.g_sequence_iter_get_sequence(_arg0)

	var _sequence *Sequence // out

	_sequence = WrapSequence(unsafe.Pointer(_cret))

	return _sequence
}

// IsBegin returns whether @iter is the begin iterator
func (i *SequenceIter) IsBegin() bool {
	var _arg0 *C.GSequenceIter // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GSequenceIter)(unsafe.Pointer(i.Native()))

	_cret = C.g_sequence_iter_is_begin(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsEnd returns whether @iter is the end iterator
func (i *SequenceIter) IsEnd() bool {
	var _arg0 *C.GSequenceIter // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GSequenceIter)(unsafe.Pointer(i.Native()))

	_cret = C.g_sequence_iter_is_end(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Move returns the Iter which is @delta positions away from @iter. If @iter is
// closer than -@delta positions to the beginning of the sequence, the begin
// iterator is returned. If @iter is closer than @delta positions to the end of
// the sequence, the end iterator is returned.
func (i *SequenceIter) Move(delta int) *SequenceIter {
	var _arg0 *C.GSequenceIter // out
	var _arg1 C.gint           // out
	var _cret *C.GSequenceIter // in

	_arg0 = (*C.GSequenceIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(delta)

	_cret = C.g_sequence_iter_move(_arg0, _arg1)

	var _sequenceIter *SequenceIter // out

	_sequenceIter = WrapSequenceIter(unsafe.Pointer(_cret))

	return _sequenceIter
}

// Next returns an iterator pointing to the next position after @iter. If @iter
// is the end iterator, the end iterator is returned.
func (i *SequenceIter) Next() *SequenceIter {
	var _arg0 *C.GSequenceIter // out
	var _cret *C.GSequenceIter // in

	_arg0 = (*C.GSequenceIter)(unsafe.Pointer(i.Native()))

	_cret = C.g_sequence_iter_next(_arg0)

	var _sequenceIter *SequenceIter // out

	_sequenceIter = WrapSequenceIter(unsafe.Pointer(_cret))

	return _sequenceIter
}

// Prev returns an iterator pointing to the previous position before @iter. If
// @iter is the begin iterator, the begin iterator is returned.
func (i *SequenceIter) Prev() *SequenceIter {
	var _arg0 *C.GSequenceIter // out
	var _cret *C.GSequenceIter // in

	_arg0 = (*C.GSequenceIter)(unsafe.Pointer(i.Native()))

	_cret = C.g_sequence_iter_prev(_arg0)

	var _sequenceIter *SequenceIter // out

	_sequenceIter = WrapSequenceIter(unsafe.Pointer(_cret))

	return _sequenceIter
}

// TimeVal represents a precise time, with seconds and microseconds. Similar to
// the struct timeval returned by the gettimeofday() UNIX system call.
//
// GLib is attempting to unify around the use of 64-bit integers to represent
// microsecond-precision time. As such, this type will be removed from a future
// version of GLib. A consequence of using `glong` for `tv_sec` is that on
// 32-bit systems `GTimeVal` is subject to the year 2038 problem.
type TimeVal C.GTimeVal

// WrapTimeVal wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTimeVal(ptr unsafe.Pointer) *TimeVal {
	return (*TimeVal)(ptr)
}

// Native returns the underlying C source pointer.
func (t *TimeVal) Native() unsafe.Pointer {
	return unsafe.Pointer(t)
}

// Add adds the given number of microseconds to @time_. @microseconds can also
// be negative to decrease the value of @time_.
func (t *TimeVal) Add(microseconds int32) {
	var _arg0 *C.GTimeVal // out
	var _arg1 C.glong     // out

	_arg0 = (*C.GTimeVal)(unsafe.Pointer(t.Native()))
	_arg1 = (C.glong)(microseconds)

	C.g_time_val_add(_arg0, _arg1)
}

// ToISO8601 converts @time_ into an RFC 3339 encoded string, relative to the
// Coordinated Universal Time (UTC). This is one of the many formats allowed by
// ISO 8601.
//
// ISO 8601 allows a large number of date/time formats, with or without
// punctuation and optional elements. The format returned by this function is a
// complete date and time, with optional punctuation included, the UTC time zone
// represented as "Z", and the @tv_usec part included if and only if it is
// nonzero, i.e. either "YYYY-MM-DDTHH:MM:SSZ" or "YYYY-MM-DDTHH:MM:SS.fffffZ".
//
// This corresponds to the Internet date/time format defined by RFC 3339
// (https://www.ietf.org/rfc/rfc3339.txt), and to either of the two most-precise
// formats defined by the W3C Note Date and Time Formats
// (http://www.w3.org/TR/NOTE-datetime-19980827). Both of these documents are
// profiles of ISO 8601.
//
// Use g_date_time_format() or g_strdup_printf() if a different variation of ISO
// 8601 format is required.
//
// If @time_ represents a date which is too large to fit into a `struct tm`, nil
// will be returned. This is platform dependent. Note also that since `GTimeVal`
// stores the number of seconds as a `glong`, on 32-bit systems it is subject to
// the year 2038 problem. Accordingly, since GLib 2.62, this function has been
// deprecated. Equivalent functionality is available using:
//
//    GDateTime *dt = g_date_time_new_from_unix_utc (time_val);
//    iso8601_string = g_date_time_format_iso8601 (dt);
//    g_date_time_unref (dt);
//
// The return value of g_time_val_to_iso8601() has been nullable since GLib
// 2.54; before then, GLib would crash under the same conditions.
func (t *TimeVal) ToISO8601() string {
	var _arg0 *C.GTimeVal // out
	var _cret *C.gchar    // in

	_arg0 = (*C.GTimeVal)(unsafe.Pointer(t.Native()))

	_cret = C.g_time_val_to_iso8601(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// TimeZone is an opaque structure whose members cannot be accessed directly.
type TimeZone C.GTimeZone

// WrapTimeZone wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTimeZone(ptr unsafe.Pointer) *TimeZone {
	return (*TimeZone)(ptr)
}

func marshalTimeZone(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*TimeZone)(unsafe.Pointer(b)), nil
}

// NewTimeZone constructs a struct TimeZone.
func NewTimeZone(identifier string) *TimeZone {
	var _arg1 *C.gchar     // out
	var _cret *C.GTimeZone // in

	_arg1 = (*C.gchar)(C.CString(identifier))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_time_zone_new(_arg1)

	var _timeZone *TimeZone // out

	_timeZone = WrapTimeZone(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_timeZone, func(v *TimeZone) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _timeZone
}

// NewTimeZoneIdentifier constructs a struct TimeZone.
func NewTimeZoneIdentifier(identifier string) *TimeZone {
	var _arg1 *C.gchar     // out
	var _cret *C.GTimeZone // in

	_arg1 = (*C.gchar)(C.CString(identifier))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_time_zone_new_identifier(_arg1)

	var _timeZone *TimeZone // out

	_timeZone = WrapTimeZone(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_timeZone, func(v *TimeZone) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _timeZone
}

// NewTimeZoneLocal constructs a struct TimeZone.
func NewTimeZoneLocal() *TimeZone {
	var _cret *C.GTimeZone // in

	_cret = C.g_time_zone_new_local()

	var _timeZone *TimeZone // out

	_timeZone = WrapTimeZone(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_timeZone, func(v *TimeZone) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _timeZone
}

// NewTimeZoneOffset constructs a struct TimeZone.
func NewTimeZoneOffset(seconds int32) *TimeZone {
	var _arg1 C.gint32     // out
	var _cret *C.GTimeZone // in

	_arg1 = (C.gint32)(seconds)

	_cret = C.g_time_zone_new_offset(_arg1)

	var _timeZone *TimeZone // out

	_timeZone = WrapTimeZone(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_timeZone, func(v *TimeZone) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _timeZone
}

// NewTimeZoneUtc constructs a struct TimeZone.
func NewTimeZoneUtc() *TimeZone {
	var _cret *C.GTimeZone // in

	_cret = C.g_time_zone_new_utc()

	var _timeZone *TimeZone // out

	_timeZone = WrapTimeZone(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_timeZone, func(v *TimeZone) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _timeZone
}

// Native returns the underlying C source pointer.
func (t *TimeZone) Native() unsafe.Pointer {
	return unsafe.Pointer(t)
}

// AdjustTime finds an interval within @tz that corresponds to the given @time_,
// possibly adjusting @time_ if required to fit into an interval. The meaning of
// @time_ depends on @type.
//
// This function is similar to g_time_zone_find_interval(), with the difference
// that it always succeeds (by making the adjustments described below).
//
// In any of the cases where g_time_zone_find_interval() succeeds then this
// function returns the same value, without modifying @time_.
//
// This function may, however, modify @time_ in order to deal with non-existent
// times. If the non-existent local @time_ of 02:30 were requested on March 14th
// 2010 in Toronto then this function would adjust @time_ to be 03:00 and return
// the interval containing the adjusted time.
func (t *TimeZone) AdjustTime(typ TimeType, time_ *int64) int {
	var _arg0 *C.GTimeZone // out
	var _arg1 C.GTimeType  // out
	var _arg2 *C.gint64    // out
	var _cret C.gint       // in

	_arg0 = (*C.GTimeZone)(unsafe.Pointer(t.Native()))
	_arg1 = (C.GTimeType)(typ)
	_arg2 = (*C.gint64)(unsafe.Pointer(time_))

	_cret = C.g_time_zone_adjust_time(_arg0, _arg1, _arg2)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// FindInterval finds an interval within @tz that corresponds to the given
// @time_. The meaning of @time_ depends on @type.
//
// If @type is G_TIME_TYPE_UNIVERSAL then this function will always succeed
// (since universal time is monotonic and continuous).
//
// Otherwise @time_ is treated as local time. The distinction between
// G_TIME_TYPE_STANDARD and G_TIME_TYPE_DAYLIGHT is ignored except in the case
// that the given @time_ is ambiguous. In Toronto, for example, 01:30 on
// November 7th 2010 occurred twice (once inside of daylight savings time and
// the next, an hour later, outside of daylight savings time). In this case, the
// different value of @type would result in a different interval being returned.
//
// It is still possible for this function to fail. In Toronto, for example,
// 02:00 on March 14th 2010 does not exist (due to the leap forward to begin
// daylight savings time). -1 is returned in that case.
func (t *TimeZone) FindInterval(typ TimeType, time_ int64) int {
	var _arg0 *C.GTimeZone // out
	var _arg1 C.GTimeType  // out
	var _arg2 C.gint64     // out
	var _cret C.gint       // in

	_arg0 = (*C.GTimeZone)(unsafe.Pointer(t.Native()))
	_arg1 = (C.GTimeType)(typ)
	_arg2 = (C.gint64)(time_)

	_cret = C.g_time_zone_find_interval(_arg0, _arg1, _arg2)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Abbreviation determines the time zone abbreviation to be used during a
// particular @interval of time in the time zone @tz.
//
// For example, in Toronto this is currently "EST" during the winter months and
// "EDT" during the summer months when daylight savings time is in effect.
func (t *TimeZone) Abbreviation(interval int) string {
	var _arg0 *C.GTimeZone // out
	var _arg1 C.gint       // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GTimeZone)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(interval)

	_cret = C.g_time_zone_get_abbreviation(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Identifier: get the identifier of this Zone, as passed to g_time_zone_new().
// If the identifier passed at construction time was not recognised, `UTC` will
// be returned. If it was nil, the identifier of the local timezone at
// construction time will be returned.
//
// The identifier will be returned in the same format as provided at
// construction time: if provided as a time offset, that will be returned by
// this function.
func (t *TimeZone) Identifier() string {
	var _arg0 *C.GTimeZone // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GTimeZone)(unsafe.Pointer(t.Native()))

	_cret = C.g_time_zone_get_identifier(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Offset determines the offset to UTC in effect during a particular @interval
// of time in the time zone @tz.
//
// The offset is the number of seconds that you add to UTC time to arrive at
// local time for @tz (ie: negative numbers for time zones west of GMT, positive
// numbers for east).
func (t *TimeZone) Offset(interval int) int32 {
	var _arg0 *C.GTimeZone // out
	var _arg1 C.gint       // out
	var _cret C.gint32     // in

	_arg0 = (*C.GTimeZone)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(interval)

	_cret = C.g_time_zone_get_offset(_arg0, _arg1)

	var _gint32 int32 // out

	_gint32 = (int32)(_cret)

	return _gint32
}

// IsDst determines if daylight savings time is in effect during a particular
// @interval of time in the time zone @tz.
func (t *TimeZone) IsDst(interval int) bool {
	var _arg0 *C.GTimeZone // out
	var _arg1 C.gint       // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GTimeZone)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(interval)

	_cret = C.g_time_zone_is_dst(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Ref increases the reference count on @tz.
func (t *TimeZone) Ref() *TimeZone {
	var _arg0 *C.GTimeZone // out
	var _cret *C.GTimeZone // in

	_arg0 = (*C.GTimeZone)(unsafe.Pointer(t.Native()))

	_cret = C.g_time_zone_ref(_arg0)

	var _timeZone *TimeZone // out

	_timeZone = WrapTimeZone(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_timeZone, func(v *TimeZone) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _timeZone
}

// Unref decreases the reference count on @tz.
func (t *TimeZone) Unref() {
	var _arg0 *C.GTimeZone // out

	_arg0 = (*C.GTimeZone)(unsafe.Pointer(t.Native()))

	C.g_time_zone_unref(_arg0)
}

// Timer: opaque datatype that records a start time.
type Timer C.GTimer

// WrapTimer wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTimer(ptr unsafe.Pointer) *Timer {
	return (*Timer)(ptr)
}

// Native returns the underlying C source pointer.
func (t *Timer) Native() unsafe.Pointer {
	return unsafe.Pointer(t)
}

// Continue resumes a timer that has previously been stopped with
// g_timer_stop(). g_timer_stop() must be called before using this function.
func (t *Timer) Continue() {
	var _arg0 *C.GTimer // out

	_arg0 = (*C.GTimer)(unsafe.Pointer(t.Native()))

	C.g_timer_continue(_arg0)
}

// Destroy destroys a timer, freeing associated resources.
func (t *Timer) Destroy() {
	var _arg0 *C.GTimer // out

	_arg0 = (*C.GTimer)(unsafe.Pointer(t.Native()))

	C.g_timer_destroy(_arg0)
}

// Elapsed: if @timer has been started but not stopped, obtains the time since
// the timer was started. If @timer has been stopped, obtains the elapsed time
// between the time it was started and the time it was stopped. The return value
// is the number of seconds elapsed, including any fractional part. The
// @microseconds out parameter is essentially useless.
func (t *Timer) Elapsed(microseconds *uint32) float64 {
	var _arg0 *C.GTimer // out
	var _arg1 *C.gulong // out
	var _cret C.gdouble // in

	_arg0 = (*C.GTimer)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.gulong)(unsafe.Pointer(microseconds))

	_cret = C.g_timer_elapsed(_arg0, _arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// IsActive exposes whether the timer is currently active.
func (t *Timer) IsActive() bool {
	var _arg0 *C.GTimer  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GTimer)(unsafe.Pointer(t.Native()))

	_cret = C.g_timer_is_active(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Reset: this function is useless; it's fine to call g_timer_start() on an
// already-started timer to reset the start time, so g_timer_reset() serves no
// purpose.
func (t *Timer) Reset() {
	var _arg0 *C.GTimer // out

	_arg0 = (*C.GTimer)(unsafe.Pointer(t.Native()))

	C.g_timer_reset(_arg0)
}

// Start marks a start time, so that future calls to g_timer_elapsed() will
// report the time since g_timer_start() was called. g_timer_new() automatically
// marks the start time, so no need to call g_timer_start() immediately after
// creating the timer.
func (t *Timer) Start() {
	var _arg0 *C.GTimer // out

	_arg0 = (*C.GTimer)(unsafe.Pointer(t.Native()))

	C.g_timer_start(_arg0)
}

// Stop marks an end time, so calls to g_timer_elapsed() will return the
// difference between this end time and the start time.
func (t *Timer) Stop() {
	var _arg0 *C.GTimer // out

	_arg0 = (*C.GTimer)(unsafe.Pointer(t.Native()))

	C.g_timer_stop(_arg0)
}

// Tree: the GTree struct is an opaque data structure representing a [balanced
// binary tree][glib-Balanced-Binary-Trees]. It should be accessed only by using
// the following functions.
type Tree C.GTree

// WrapTree wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTree(ptr unsafe.Pointer) *Tree {
	return (*Tree)(ptr)
}

func marshalTree(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*Tree)(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *Tree) Native() unsafe.Pointer {
	return unsafe.Pointer(t)
}

// Destroy removes all keys and values from the #GTree and decreases its
// reference count by one. If keys and/or values are dynamically allocated, you
// should either free them first or create the #GTree using g_tree_new_full().
// In the latter case the destroy functions you supplied will be called on all
// keys and values before destroying the #GTree.
func (t *Tree) Destroy() {
	var _arg0 *C.GTree // out

	_arg0 = (*C.GTree)(unsafe.Pointer(t.Native()))

	C.g_tree_destroy(_arg0)
}

// Height gets the height of a #GTree.
//
// If the #GTree contains no nodes, the height is 0. If the #GTree contains only
// one root node the height is 1. If the root node has children the height is 2,
// etc.
func (t *Tree) Height() int {
	var _arg0 *C.GTree // out
	var _cret C.gint   // in

	_arg0 = (*C.GTree)(unsafe.Pointer(t.Native()))

	_cret = C.g_tree_height(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Nnodes gets the number of nodes in a #GTree.
func (t *Tree) Nnodes() int {
	var _arg0 *C.GTree // out
	var _cret C.gint   // in

	_arg0 = (*C.GTree)(unsafe.Pointer(t.Native()))

	_cret = C.g_tree_nnodes(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// NodeFirst returns the first in-order node of the tree, or nil for an empty
// tree.
func (t *Tree) NodeFirst() *TreeNode {
	var _arg0 *C.GTree     // out
	var _cret *C.GTreeNode // in

	_arg0 = (*C.GTree)(unsafe.Pointer(t.Native()))

	_cret = C.g_tree_node_first(_arg0)

	var _treeNode *TreeNode // out

	_treeNode = WrapTreeNode(unsafe.Pointer(_cret))

	return _treeNode
}

// NodeLast returns the last in-order node of the tree, or nil for an empty
// tree.
func (t *Tree) NodeLast() *TreeNode {
	var _arg0 *C.GTree     // out
	var _cret *C.GTreeNode // in

	_arg0 = (*C.GTree)(unsafe.Pointer(t.Native()))

	_cret = C.g_tree_node_last(_arg0)

	var _treeNode *TreeNode // out

	_treeNode = WrapTreeNode(unsafe.Pointer(_cret))

	return _treeNode
}

// Ref increments the reference count of @tree by one.
//
// It is safe to call this function from any thread.
func (t *Tree) Ref() *Tree {
	var _arg0 *C.GTree // out
	var _cret *C.GTree // in

	_arg0 = (*C.GTree)(unsafe.Pointer(t.Native()))

	_cret = C.g_tree_ref(_arg0)

	var _ret *Tree // out

	_ret = WrapTree(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_ret, func(v *Tree) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _ret
}

// Unref decrements the reference count of @tree by one. If the reference count
// drops to 0, all keys and values will be destroyed (if destroy functions were
// specified) and all memory allocated by @tree will be released.
//
// It is safe to call this function from any thread.
func (t *Tree) Unref() {
	var _arg0 *C.GTree // out

	_arg0 = (*C.GTree)(unsafe.Pointer(t.Native()))

	C.g_tree_unref(_arg0)
}

// TreeNode: an opaque type which identifies a specific node in a #GTree.
type TreeNode C.GTreeNode

// WrapTreeNode wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTreeNode(ptr unsafe.Pointer) *TreeNode {
	return (*TreeNode)(ptr)
}

// Native returns the underlying C source pointer.
func (t *TreeNode) Native() unsafe.Pointer {
	return unsafe.Pointer(t)
}

// Next returns the next in-order node of the tree, or nil if the passed node
// was already the last one.
func (n *TreeNode) Next() *TreeNode {
	var _arg0 *C.GTreeNode // out
	var _cret *C.GTreeNode // in

	_arg0 = (*C.GTreeNode)(unsafe.Pointer(n.Native()))

	_cret = C.g_tree_node_next(_arg0)

	var _treeNode *TreeNode // out

	_treeNode = WrapTreeNode(unsafe.Pointer(_cret))

	return _treeNode
}

// Previous returns the previous in-order node of the tree, or nil if the passed
// node was already the first one.
func (n *TreeNode) Previous() *TreeNode {
	var _arg0 *C.GTreeNode // out
	var _cret *C.GTreeNode // in

	_arg0 = (*C.GTreeNode)(unsafe.Pointer(n.Native()))

	_cret = C.g_tree_node_previous(_arg0)

	var _treeNode *TreeNode // out

	_treeNode = WrapTreeNode(unsafe.Pointer(_cret))

	return _treeNode
}

// URI: the #GUri type and related functions can be used to parse URIs into
// their components, and build valid URIs from individual components.
//
// Note that #GUri scope is to help manipulate URIs in various applications,
// following RFC 3986 (https://tools.ietf.org/html/rfc3986). In particular, it
// doesn't intend to cover web browser needs, and doesn't implement the WHATWG
// URL (https://url.spec.whatwg.org/) standard. No APIs are provided to help
// prevent homograph attacks
// (https://en.wikipedia.org/wiki/IDN_homograph_attack), so #GUri is not
// suitable for formatting URIs for display to the user for making
// security-sensitive decisions.
//
//
// Relative and absolute URIs
//
// As defined in RFC 3986 (https://tools.ietf.org/html/rfc3986#section-4), the
// hierarchical nature of URIs means that they can either be ‘relative
// references’ (sometimes referred to as ‘relative URIs’) or ‘URIs’ (for
// clarity, ‘URIs’ are referred to in this documentation as ‘absolute URIs’ —
// although in constrast to RFC 3986
// (https://tools.ietf.org/html/rfc3986#section-4.3), fragment identifiers are
// always allowed).
//
// Relative references have one or more components of the URI missing. In
// particular, they have no scheme. Any other component, such as hostname,
// query, etc. may be missing, apart from a path, which has to be specified (but
// may be empty). The path may be relative, starting with `./` rather than `/`.
//
// For example, a valid relative reference is `./path?query`, `/?query#fragment`
// or `//example.com`.
//
// Absolute URIs have a scheme specified. Any other components of the URI which
// are missing are specified as explicitly unset in the URI, rather than being
// resolved relative to a base URI using g_uri_parse_relative().
//
// For example, a valid absolute URI is `file:///home/bob` or
// `https://search.com?query=string`.
//
// A #GUri instance is always an absolute URI. A string may be an absolute URI
// or a relative reference; see the documentation for individual functions as to
// what forms they accept.
//
//
// Parsing URIs
//
// The most minimalist APIs for parsing URIs are g_uri_split() and
// g_uri_split_with_user(). These split a URI into its component parts, and
// return the parts; the difference between the two is that g_uri_split() treats
// the ‘userinfo’ component of the URI as a single element, while
// g_uri_split_with_user() can (depending on the Flags you pass) treat it as
// containing a username, password, and authentication parameters.
// Alternatively, g_uri_split_network() can be used when you are only interested
// in the components that are needed to initiate a network connection to the
// service (scheme, host, and port).
//
// g_uri_parse() is similar to g_uri_split(), but instead of returning
// individual strings, it returns a #GUri structure (and it requires that the
// URI be an absolute URI).
//
// g_uri_resolve_relative() and g_uri_parse_relative() allow you to resolve a
// relative URI relative to a base URI. g_uri_resolve_relative() takes two
// strings and returns a string, and g_uri_parse_relative() takes a #GUri and a
// string and returns a #GUri.
//
// All of the parsing functions take a Flags argument describing exactly how to
// parse the URI; see the documentation for that type for more details on the
// specific flags that you can pass. If you need to choose different flags based
// on the type of URI, you can use g_uri_peek_scheme() on the URI string to
// check the scheme first, and use that to decide what flags to parse it with.
//
// For example, you might want to use G_URI_PARAMS_WWW_FORM when parsing the
// params for a web URI, so compare the result of g_uri_peek_scheme() against
// `http` and `https`.
//
//
// Building URIs
//
// g_uri_join() and g_uri_join_with_user() can be used to construct valid URI
// strings from a set of component strings. They are the inverse of
// g_uri_split() and g_uri_split_with_user().
//
// Similarly, g_uri_build() and g_uri_build_with_user() can be used to construct
// a #GUri from a set of component strings.
//
// As with the parsing functions, the building functions take a Flags argument.
// In particular, it is important to keep in mind whether the URI components you
// are using are already `%`-encoded. If so, you must pass the
// G_URI_FLAGS_ENCODED flag.
//
// `file://` URIs
//
// Note that Windows and Unix both define special rules for parsing `file://`
// URIs (involving non-UTF-8 character sets on Unix, and the interpretation of
// path separators on Windows). #GUri does not implement these rules. Use
// g_filename_from_uri() and g_filename_to_uri() if you want to properly convert
// between `file://` URIs and local filenames.
//
//
// URI Equality
//
// Note that there is no `g_uri_equal ()` function, because comparing URIs
// usefully requires scheme-specific knowledge that #GUri does not have. #GUri
// can help with normalization if you use the various encoded Flags as well as
// G_URI_FLAGS_SCHEME_NORMALIZE however it is not comprehensive. For example,
// `data:,foo` and `data:;base64,Zm9v` resolve to the same thing according to
// the `data:` URI specification which GLib does not handle.
type URI C.GUri

// WrapURI wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapURI(ptr unsafe.Pointer) *URI {
	return (*URI)(ptr)
}

func marshalURI(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*URI)(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (u *URI) Native() unsafe.Pointer {
	return unsafe.Pointer(u)
}

// AuthParams gets @uri's authentication parameters, which may contain
// `%`-encoding, depending on the flags with which @uri was created. (If @uri
// was not created with G_URI_FLAGS_HAS_AUTH_PARAMS then this will be nil.)
//
// Depending on the URI scheme, g_uri_parse_params() may be useful for further
// parsing this information.
func (u *URI) AuthParams() string {
	var _arg0 *C.GUri  // out
	var _cret *C.gchar // in

	_arg0 = (*C.GUri)(unsafe.Pointer(u.Native()))

	_cret = C.g_uri_get_auth_params(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Flags gets @uri's flags set upon construction.
func (u *URI) Flags() URIFlags {
	var _arg0 *C.GUri     // out
	var _cret C.GUriFlags // in

	_arg0 = (*C.GUri)(unsafe.Pointer(u.Native()))

	_cret = C.g_uri_get_flags(_arg0)

	var _uriFlags URIFlags // out

	_uriFlags = URIFlags(_cret)

	return _uriFlags
}

// Fragment gets @uri's fragment, which may contain `%`-encoding, depending on
// the flags with which @uri was created.
func (u *URI) Fragment() string {
	var _arg0 *C.GUri  // out
	var _cret *C.gchar // in

	_arg0 = (*C.GUri)(unsafe.Pointer(u.Native()))

	_cret = C.g_uri_get_fragment(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Host gets @uri's host. This will never have `%`-encoded characters, unless it
// is non-UTF-8 (which can only be the case if @uri was created with
// G_URI_FLAGS_NON_DNS).
//
// If @uri contained an IPv6 address literal, this value will be just that
// address, without the brackets around it that are necessary in the string form
// of the URI. Note that in this case there may also be a scope ID attached to
// the address. Eg, `fe80::1234%“em1` (or `fe80::1234%“25em1` if the string is
// still encoded).
func (u *URI) Host() string {
	var _arg0 *C.GUri  // out
	var _cret *C.gchar // in

	_arg0 = (*C.GUri)(unsafe.Pointer(u.Native()))

	_cret = C.g_uri_get_host(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Password gets @uri's password, which may contain `%`-encoding, depending on
// the flags with which @uri was created. (If @uri was not created with
// G_URI_FLAGS_HAS_PASSWORD then this will be nil.)
func (u *URI) Password() string {
	var _arg0 *C.GUri  // out
	var _cret *C.gchar // in

	_arg0 = (*C.GUri)(unsafe.Pointer(u.Native()))

	_cret = C.g_uri_get_password(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Path gets @uri's path, which may contain `%`-encoding, depending on the flags
// with which @uri was created.
func (u *URI) Path() string {
	var _arg0 *C.GUri  // out
	var _cret *C.gchar // in

	_arg0 = (*C.GUri)(unsafe.Pointer(u.Native()))

	_cret = C.g_uri_get_path(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Port gets @uri's port.
func (u *URI) Port() int {
	var _arg0 *C.GUri // out
	var _cret C.gint  // in

	_arg0 = (*C.GUri)(unsafe.Pointer(u.Native()))

	_cret = C.g_uri_get_port(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Query gets @uri's query, which may contain `%`-encoding, depending on the
// flags with which @uri was created.
//
// For queries consisting of a series of `name=value` parameters, ParamsIter or
// g_uri_parse_params() may be useful.
func (u *URI) Query() string {
	var _arg0 *C.GUri  // out
	var _cret *C.gchar // in

	_arg0 = (*C.GUri)(unsafe.Pointer(u.Native()))

	_cret = C.g_uri_get_query(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Scheme gets @uri's scheme. Note that this will always be all-lowercase,
// regardless of the string or strings that @uri was created from.
func (u *URI) Scheme() string {
	var _arg0 *C.GUri  // out
	var _cret *C.gchar // in

	_arg0 = (*C.GUri)(unsafe.Pointer(u.Native()))

	_cret = C.g_uri_get_scheme(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// User gets the ‘username’ component of @uri's userinfo, which may contain
// `%`-encoding, depending on the flags with which @uri was created. If @uri was
// not created with G_URI_FLAGS_HAS_PASSWORD or G_URI_FLAGS_HAS_AUTH_PARAMS,
// this is the same as g_uri_get_userinfo().
func (u *URI) User() string {
	var _arg0 *C.GUri  // out
	var _cret *C.gchar // in

	_arg0 = (*C.GUri)(unsafe.Pointer(u.Native()))

	_cret = C.g_uri_get_user(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Userinfo gets @uri's userinfo, which may contain `%`-encoding, depending on
// the flags with which @uri was created.
func (u *URI) Userinfo() string {
	var _arg0 *C.GUri  // out
	var _cret *C.gchar // in

	_arg0 = (*C.GUri)(unsafe.Pointer(u.Native()))

	_cret = C.g_uri_get_userinfo(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// ParseRelative parses @uri_ref according to @flags and, if it is a [relative
// URI][relative-absolute-uris], resolves it relative to @base_uri. If the
// result is not a valid absolute URI, it will be discarded, and an error
// returned.
func (b *URI) ParseRelative(uriRef string, flags URIFlags) (*URI, error) {
	var _arg0 *C.GUri     // out
	var _arg1 *C.gchar    // out
	var _arg2 C.GUriFlags // out
	var _cret *C.GUri     // in
	var _cerr *C.GError   // in

	_arg0 = (*C.GUri)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uriRef))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GUriFlags)(flags)

	_cret = C.g_uri_parse_relative(_arg0, _arg1, _arg2, &_cerr)

	var _uri *URI    // out
	var _goerr error // out

	_uri = WrapURI(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_uri, func(v *URI) {
		C.free(unsafe.Pointer(v.Native()))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _uri, _goerr
}

// String returns a string representing @uri.
//
// This is not guaranteed to return a string which is identical to the string
// that @uri was parsed from. However, if the source URI was syntactically
// correct (according to RFC 3986), and it was parsed with G_URI_FLAGS_ENCODED,
// then g_uri_to_string() is guaranteed to return a string which is at least
// semantically equivalent to the source URI (according to RFC 3986).
//
// If @uri might contain sensitive details, such as authentication parameters,
// or private data in its query string, and the returned string is going to be
// logged, then consider using g_uri_to_string_partial() to redact parts.
func (u *URI) String() string {
	var _arg0 *C.GUri // out
	var _cret *C.char // in

	_arg0 = (*C.GUri)(unsafe.Pointer(u.Native()))

	_cret = C.g_uri_to_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ToStringPartial returns a string representing @uri, subject to the options in
// @flags. See g_uri_to_string() and HideFlags for more details.
func (u *URI) ToStringPartial(flags URIHideFlags) string {
	var _arg0 *C.GUri         // out
	var _arg1 C.GUriHideFlags // out
	var _cret *C.char         // in

	_arg0 = (*C.GUri)(unsafe.Pointer(u.Native()))
	_arg1 = (C.GUriHideFlags)(flags)

	_cret = C.g_uri_to_string_partial(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// URIParamsIter: many URI schemes include one or more attribute/value pairs as
// part of the URI value. For example
// `scheme://server/path?query=string&is=there` has two attributes –
// `query=string` and `is=there` – in its query part.
//
// A ParamsIter structure represents an iterator that can be used to iterate
// over the attribute/value pairs of a URI query string. ParamsIter structures
// are typically allocated on the stack and then initialized with
// g_uri_params_iter_init(). See the documentation for g_uri_params_iter_init()
// for a usage example.
type URIParamsIter C.GUriParamsIter

// WrapURIParamsIter wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapURIParamsIter(ptr unsafe.Pointer) *URIParamsIter {
	return (*URIParamsIter)(ptr)
}

// Native returns the underlying C source pointer.
func (u *URIParamsIter) Native() unsafe.Pointer {
	return unsafe.Pointer(u)
}

// Init initializes an attribute/value pair iterator.
//
// The iterator keeps pointers to the @params and @separators arguments, those
// variables must thus outlive the iterator and not be modified during the
// iteration.
//
// If G_URI_PARAMS_WWW_FORM is passed in @flags, `+` characters in the param
// string will be replaced with spaces in the output. For example, `foo=bar+baz`
// will give attribute `foo` with value `bar baz`. This is commonly used on the
// web (the `https` and `http` schemes only), but is deprecated in favour of the
// equivalent of encoding spaces as `20`.
//
// Unlike with g_uri_parse_params(), G_URI_PARAMS_CASE_INSENSITIVE has no effect
// if passed to @flags for g_uri_params_iter_init(). The caller is responsible
// for doing their own case-insensitive comparisons.
//
//    GUriParamsIter iter;
//    GError *error = NULL;
//    gchar *unowned_attr, *unowned_value;
//
//    g_uri_params_iter_init (&iter, "foo=bar&baz=bar&Foo=frob&baz=bar2", -1, "&", G_URI_PARAMS_NONE);
//    while (g_uri_params_iter_next (&iter, &unowned_attr, &unowned_value, &error))
//      {
//        g_autofree gchar *attr = g_steal_pointer (&unowned_attr);
//        g_autofree gchar *value = g_steal_pointer (&unowned_value);
//        // do something with attr and value; this code will be called 4 times
//        // for the params string in this example: once with attr=foo and value=bar,
//        // then with baz/bar, then Foo/frob, then baz/bar2.
//      }
//    if (error)
//      // handle parsing error
func (i *URIParamsIter) Init(params string, length int, separators string, flags URIParamsFlags) {
	var _arg0 *C.GUriParamsIter // out
	var _arg1 *C.gchar          // out
	var _arg2 C.gssize          // out
	var _arg3 *C.gchar          // out
	var _arg4 C.GUriParamsFlags // out

	_arg0 = (*C.GUriParamsIter)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(params))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gssize)(length)
	_arg3 = (*C.gchar)(C.CString(separators))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (C.GUriParamsFlags)(flags)

	C.g_uri_params_iter_init(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// Next advances @iter and retrieves the next attribute/value. false is returned
// if an error has occurred (in which case @error is set), or if the end of the
// iteration is reached (in which case @attribute and @value are set to nil and
// the iterator becomes invalid). If true is returned, g_uri_params_iter_next()
// may be called again to receive another attribute/value pair.
//
// Note that the same @attribute may be returned multiple times, since URIs
// allow repeated attributes.
func (i *URIParamsIter) Next() (attribute string, value string, goerr error) {
	var _arg0 *C.GUriParamsIter // out
	var _arg1 *C.gchar          // in
	var _arg2 *C.gchar          // in
	var _cerr *C.GError         // in

	_arg0 = (*C.GUriParamsIter)(unsafe.Pointer(i.Native()))

	C.g_uri_params_iter_next(_arg0, &_arg1, &_arg2, &_cerr)

	var _attribute string // out
	var _value string     // out
	var _goerr error      // out

	_attribute = C.GoString(_arg1)
	defer C.free(unsafe.Pointer(_arg1))
	_value = C.GoString(_arg2)
	defer C.free(unsafe.Pointer(_arg2))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _attribute, _value, _goerr
}

// Variant is a variant datatype; it can contain one or more values along with
// information about the type of the values.
//
// A #GVariant may contain simple types, like an integer, or a boolean value; or
// complex types, like an array of two strings, or a dictionary of key value
// pairs. A #GVariant is also immutable: once it's been created neither its type
// nor its content can be modified further.
//
// GVariant is useful whenever data needs to be serialized, for example when
// sending method parameters in D-Bus, or when saving settings using GSettings.
//
// When creating a new #GVariant, you pass the data you want to store in it
// along with a string representing the type of data you wish to pass to it.
//
// For instance, if you want to create a #GVariant holding an integer value you
// can use:
//
//    GVariant *v = g_variant_new ("u", 40);
//
// The string "u" in the first argument tells #GVariant that the data passed to
// the constructor (40) is going to be an unsigned integer.
//
// More advanced examples of #GVariant in use can be found in documentation for
// [GVariant format strings][gvariant-format-strings-pointers].
//
// The range of possible values is determined by the type.
//
// The type system used by #GVariant is Type.
//
// #GVariant instances always have a type and a value (which are given at
// construction time). The type and value of a #GVariant instance can never
// change other than by the #GVariant itself being destroyed. A #GVariant cannot
// contain a pointer.
//
// #GVariant is reference counted using g_variant_ref() and g_variant_unref().
// #GVariant also has floating reference counts -- see g_variant_ref_sink().
//
// #GVariant is completely threadsafe. A #GVariant instance can be concurrently
// accessed in any way from any number of threads without problems.
//
// #GVariant is heavily optimised for dealing with data in serialised form. It
// works particularly well with data located in memory-mapped files. It can
// perform nearly all deserialisation operations in a small constant time,
// usually touching only a single memory page. Serialised #GVariant data can
// also be sent over the network.
//
// #GVariant is largely compatible with D-Bus. Almost all types of #GVariant
// instances can be sent over D-Bus. See Type for exceptions. (However,
// #GVariant's serialisation format is not the same as the serialisation format
// of a D-Bus message body: use BusMessage, in the gio library, for those.)
//
// For space-efficiency, the #GVariant serialisation format does not
// automatically include the variant's length, type or endianness, which must
// either be implied from context (such as knowledge that a particular file
// format always contains a little-endian G_VARIANT_TYPE_VARIANT which occupies
// the whole length of the file) or supplied out-of-band (for instance, a
// length, type and/or endianness indicator could be placed at the beginning of
// a file, network message or network stream).
//
// A #GVariant's size is limited mainly by any lower level operating system
// constraints, such as the number of bits in #gsize. For example, it is
// reasonable to have a 2GB file mapped into memory with File, and call
// g_variant_new_from_data() on it.
//
// For convenience to C programmers, #GVariant features powerful varargs-based
// value construction and destruction. This feature is designed to be embedded
// in other libraries.
//
// There is a Python-inspired text language for describing #GVariant values.
// #GVariant includes a printer for this language and a parser with type
// inferencing.
//
//
// Memory Use
//
// #GVariant tries to be quite efficient with respect to memory use. This
// section gives a rough idea of how much memory is used by the current
// implementation. The information here is subject to change in the future.
//
// The memory allocated by #GVariant can be grouped into 4 broad purposes:
// memory for serialised data, memory for the type information cache, buffer
// management memory and memory for the #GVariant structure itself.
//
//
// Serialised Data Memory
//
// This is the memory that is used for storing GVariant data in serialised form.
// This is what would be sent over the network or what would end up on disk, not
// counting any indicator of the endianness, or of the length or type of the
// top-level variant.
//
// The amount of memory required to store a boolean is 1 byte. 16, 32 and 64 bit
// integers and double precision floating point numbers use their "natural"
// size. Strings (including object path and signature strings) are stored with a
// nul terminator, and as such use the length of the string plus 1 byte.
//
// Maybe types use no space at all to represent the null value and use the same
// amount of space (sometimes plus one byte) as the equivalent non-maybe-typed
// value to represent the non-null case.
//
// Arrays use the amount of space required to store each of their members,
// concatenated. Additionally, if the items stored in an array are not of a
// fixed-size (ie: strings, other arrays, etc) then an additional framing offset
// is stored for each item. The size of this offset is either 1, 2 or 4 bytes
// depending on the overall size of the container. Additionally, extra padding
// bytes are added as required for alignment of child values.
//
// Tuples (including dictionary entries) use the amount of space required to
// store each of their members, concatenated, plus one framing offset (as per
// arrays) for each non-fixed-sized item in the tuple, except for the last one.
// Additionally, extra padding bytes are added as required for alignment of
// child values.
//
// Variants use the same amount of space as the item inside of the variant, plus
// 1 byte, plus the length of the type string for the item inside the variant.
//
// As an example, consider a dictionary mapping strings to variants. In the case
// that the dictionary is empty, 0 bytes are required for the serialisation.
//
// If we add an item "width" that maps to the int32 value of 500 then we will
// use 4 byte to store the int32 (so 6 for the variant containing it) and 6
// bytes for the string. The variant must be aligned to 8 after the 6 bytes of
// the string, so that's 2 extra bytes. 6 (string) + 2 (padding) + 6 (variant)
// is 14 bytes used for the dictionary entry. An additional 1 byte is added to
// the array as a framing offset making a total of 15 bytes.
//
// If we add another entry, "title" that maps to a nullable string that happens
// to have a value of null, then we use 0 bytes for the null value (and 3 bytes
// for the variant to contain it along with its type string) plus 6 bytes for
// the string. Again, we need 2 padding bytes. That makes a total of 6 + 2 + 3 =
// 11 bytes.
//
// We now require extra padding between the two items in the array. After the 14
// bytes of the first item, that's 2 bytes required. We now require 2 framing
// offsets for an extra two bytes. 14 + 2 + 11 + 2 = 29 bytes to encode the
// entire two-item dictionary.
//
//
// Type Information Cache
//
// For each GVariant type that currently exists in the program a type
// information structure is kept in the type information cache. The type
// information structure is required for rapid deserialisation.
//
// Continuing with the above example, if a #GVariant exists with the type
// "a{sv}" then a type information struct will exist for "a{sv}", "{sv}", "s",
// and "v". Multiple uses of the same type will share the same type information.
// Additionally, all single-digit types are stored in read-only static memory
// and do not contribute to the writable memory footprint of a program using
// #GVariant.
//
// Aside from the type information structures stored in read-only memory, there
// are two forms of type information. One is used for container types where
// there is a single element type: arrays and maybe types. The other is used for
// container types where there are multiple element types: tuples and dictionary
// entries.
//
// Array type info structures are 6 * sizeof (void *), plus the memory required
// to store the type string itself. This means that on 32-bit systems, the cache
// entry for "a{sv}" would require 30 bytes of memory (plus malloc overhead).
//
// Tuple type info structures are 6 * sizeof (void *), plus 4 * sizeof (void *)
// for each item in the tuple, plus the memory required to store the type string
// itself. A 2-item tuple, for example, would have a type information structure
// that consumed writable memory in the size of 14 * sizeof (void *) (plus type
// string) This means that on 32-bit systems, the cache entry for "{sv}" would
// require 61 bytes of memory (plus malloc overhead).
//
// This means that in total, for our "a{sv}" example, 91 bytes of type
// information would be allocated.
//
// The type information cache, additionally, uses a Table to store and look up
// the cached items and stores a pointer to this hash table in static storage.
// The hash table is freed when there are zero items in the type cache.
//
// Although these sizes may seem large it is important to remember that a
// program will probably only have a very small number of different types of
// values in it and that only one type information structure is required for
// many different values of the same type.
//
//
// Buffer Management Memory
//
// #GVariant uses an internal buffer management structure to deal with the
// various different possible sources of serialised data that it uses. The
// buffer is responsible for ensuring that the correct call is made when the
// data is no longer in use by #GVariant. This may involve a g_free() or a
// g_slice_free() or even g_mapped_file_unref().
//
// One buffer management structure is used for each chunk of serialised data.
// The size of the buffer management structure is 4 * (void *). On 32-bit
// systems, that's 16 bytes.
//
//
// GVariant structure
//
// The size of a #GVariant structure is 6 * (void *). On 32-bit systems, that's
// 24 bytes.
//
// #GVariant structures only exist if they are explicitly created with API
// calls. For example, if a #GVariant is constructed out of serialised data for
// the example given above (with the dictionary) then although there are 9
// individual values that comprise the entire dictionary (two keys, two values,
// two variants containing the values, two dictionary entries, plus the
// dictionary itself), only 1 #GVariant instance exists -- the one referring to
// the dictionary.
//
// If calls are made to start accessing the other values then #GVariant
// instances will exist for those values only for as long as they are in use
// (ie: until you call g_variant_unref()). The type information is shared. The
// serialised data and the buffer management structure for that serialised data
// is shared by the child.
//
//
// Summary
//
// To put the entire example together, for our dictionary mapping strings to
// variants (with two entries, as given above), we are using 91 bytes of memory
// for type information, 29 bytes of memory for the serialised data, 16 bytes
// for buffer management and 24 bytes for the #GVariant instance, or a total of
// 160 bytes, plus malloc overhead. If we were to use
// g_variant_get_child_value() to access the two dictionary entries, we would
// use an additional 48 bytes. If we were to have other dictionaries of the same
// type, we would use more memory for the serialised data and buffer management
// for those dictionaries, but the type information would be shared.
type Variant C.GVariant

// WrapVariant wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapVariant(ptr unsafe.Pointer) *Variant {
	return (*Variant)(ptr)
}

func marshalVariant(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*Variant)(unsafe.Pointer(b)), nil
}

// NewVariantArray constructs a struct Variant.
func NewVariantArray(childType *VariantType, children []*Variant) *Variant {
	var _arg1 *C.GVariantType // out
	var _arg2 **C.GVariant
	var _arg3 C.gsize
	var _cret *C.GVariant // in

	_arg1 = (*C.GVariantType)(unsafe.Pointer(childType.Native()))
	_arg3 = C.gsize(len(children))
	_arg2 = (**C.GVariant)(unsafe.Pointer(&children[0]))

	_cret = C.g_variant_new_array(_arg1, _arg2, _arg3)

	var _variant *Variant // out

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantBoolean constructs a struct Variant.
func NewVariantBoolean(value bool) *Variant {
	var _arg1 C.gboolean  // out
	var _cret *C.GVariant // in

	if value {
		_arg1 = C.TRUE
	}

	_cret = C.g_variant_new_boolean(_arg1)

	var _variant *Variant // out

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantByte constructs a struct Variant.
func NewVariantByte(value byte) *Variant {
	var _arg1 C.guint8    // out
	var _cret *C.GVariant // in

	_arg1 = (C.guint8)(value)

	_cret = C.g_variant_new_byte(_arg1)

	var _variant *Variant // out

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantBytestring constructs a struct Variant.
func NewVariantBytestring(_string []byte) *Variant {
	var _arg1 *C.gchar
	var _cret *C.GVariant // in

	_arg1 = (*C.gchar)(unsafe.Pointer(&_string[0]))

	_cret = C.g_variant_new_bytestring(_arg1)

	var _variant *Variant // out

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantBytestringArray constructs a struct Variant.
func NewVariantBytestringArray(strv []string) *Variant {
	var _arg1 **C.gchar
	var _arg2 C.gssize
	var _cret *C.GVariant // in

	_arg2 = C.gssize(len(strv))
	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(strv)) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(strv))
		for i := range strv {
			out[i] = (*C.gchar)(C.CString(strv[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.g_variant_new_bytestring_array(_arg1, _arg2)

	var _variant *Variant // out

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantDictEntry constructs a struct Variant.
func NewVariantDictEntry(key *Variant, value *Variant) *Variant {
	var _arg1 *C.GVariant // out
	var _arg2 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg1 = (*C.GVariant)(unsafe.Pointer(key.Native()))
	_arg2 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	_cret = C.g_variant_new_dict_entry(_arg1, _arg2)

	var _variant *Variant // out

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantDouble constructs a struct Variant.
func NewVariantDouble(value float64) *Variant {
	var _arg1 C.gdouble   // out
	var _cret *C.GVariant // in

	_arg1 = (C.gdouble)(value)

	_cret = C.g_variant_new_double(_arg1)

	var _variant *Variant // out

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantHandle constructs a struct Variant.
func NewVariantHandle(value int32) *Variant {
	var _arg1 C.gint32    // out
	var _cret *C.GVariant // in

	_arg1 = (C.gint32)(value)

	_cret = C.g_variant_new_handle(_arg1)

	var _variant *Variant // out

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantInt16 constructs a struct Variant.
func NewVariantInt16(value int16) *Variant {
	var _arg1 C.gint16    // out
	var _cret *C.GVariant // in

	_arg1 = (C.gint16)(value)

	_cret = C.g_variant_new_int16(_arg1)

	var _variant *Variant // out

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantInt32 constructs a struct Variant.
func NewVariantInt32(value int32) *Variant {
	var _arg1 C.gint32    // out
	var _cret *C.GVariant // in

	_arg1 = (C.gint32)(value)

	_cret = C.g_variant_new_int32(_arg1)

	var _variant *Variant // out

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantInt64 constructs a struct Variant.
func NewVariantInt64(value int64) *Variant {
	var _arg1 C.gint64    // out
	var _cret *C.GVariant // in

	_arg1 = (C.gint64)(value)

	_cret = C.g_variant_new_int64(_arg1)

	var _variant *Variant // out

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantMaybe constructs a struct Variant.
func NewVariantMaybe(childType *VariantType, child *Variant) *Variant {
	var _arg1 *C.GVariantType // out
	var _arg2 *C.GVariant     // out
	var _cret *C.GVariant     // in

	_arg1 = (*C.GVariantType)(unsafe.Pointer(childType.Native()))
	_arg2 = (*C.GVariant)(unsafe.Pointer(child.Native()))

	_cret = C.g_variant_new_maybe(_arg1, _arg2)

	var _variant *Variant // out

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantObjectPath constructs a struct Variant.
func NewVariantObjectPath(objectPath string) *Variant {
	var _arg1 *C.gchar    // out
	var _cret *C.GVariant // in

	_arg1 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_variant_new_object_path(_arg1)

	var _variant *Variant // out

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantObjv constructs a struct Variant.
func NewVariantObjv(strv []string) *Variant {
	var _arg1 **C.gchar
	var _arg2 C.gssize
	var _cret *C.GVariant // in

	_arg2 = C.gssize(len(strv))
	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(strv)) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(strv))
		for i := range strv {
			out[i] = (*C.gchar)(C.CString(strv[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.g_variant_new_objv(_arg1, _arg2)

	var _variant *Variant // out

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantSignature constructs a struct Variant.
func NewVariantSignature(signature string) *Variant {
	var _arg1 *C.gchar    // out
	var _cret *C.GVariant // in

	_arg1 = (*C.gchar)(C.CString(signature))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_variant_new_signature(_arg1)

	var _variant *Variant // out

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantString constructs a struct Variant.
func NewVariantString(_string string) *Variant {
	var _arg1 *C.gchar    // out
	var _cret *C.GVariant // in

	_arg1 = (*C.gchar)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_variant_new_string(_arg1)

	var _variant *Variant // out

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantStrv constructs a struct Variant.
func NewVariantStrv(strv []string) *Variant {
	var _arg1 **C.gchar
	var _arg2 C.gssize
	var _cret *C.GVariant // in

	_arg2 = C.gssize(len(strv))
	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(strv)) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(strv))
		for i := range strv {
			out[i] = (*C.gchar)(C.CString(strv[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.g_variant_new_strv(_arg1, _arg2)

	var _variant *Variant // out

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantTuple constructs a struct Variant.
func NewVariantTuple(children []*Variant) *Variant {
	var _arg1 **C.GVariant
	var _arg2 C.gsize
	var _cret *C.GVariant // in

	_arg2 = C.gsize(len(children))
	_arg1 = (**C.GVariant)(unsafe.Pointer(&children[0]))

	_cret = C.g_variant_new_tuple(_arg1, _arg2)

	var _variant *Variant // out

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantUint16 constructs a struct Variant.
func NewVariantUint16(value uint16) *Variant {
	var _arg1 C.guint16   // out
	var _cret *C.GVariant // in

	_arg1 = (C.guint16)(value)

	_cret = C.g_variant_new_uint16(_arg1)

	var _variant *Variant // out

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantUint32 constructs a struct Variant.
func NewVariantUint32(value uint32) *Variant {
	var _arg1 C.guint32   // out
	var _cret *C.GVariant // in

	_arg1 = (C.guint32)(value)

	_cret = C.g_variant_new_uint32(_arg1)

	var _variant *Variant // out

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantUint64 constructs a struct Variant.
func NewVariantUint64(value uint64) *Variant {
	var _arg1 C.guint64   // out
	var _cret *C.GVariant // in

	_arg1 = (C.guint64)(value)

	_cret = C.g_variant_new_uint64(_arg1)

	var _variant *Variant // out

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantVariant constructs a struct Variant.
func NewVariantVariant(value *Variant) *Variant {
	var _arg1 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg1 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	_cret = C.g_variant_new_variant(_arg1)

	var _variant *Variant // out

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// Native returns the underlying C source pointer.
func (v *Variant) Native() unsafe.Pointer {
	return unsafe.Pointer(v)
}

// Byteswap performs a byteswapping operation on the contents of @value. The
// result is that all multi-byte numeric data contained in @value is
// byteswapped. That includes 16, 32, and 64bit signed and unsigned integers as
// well as file handles and double precision floating point values.
//
// This function is an identity mapping on any value that does not contain
// multi-byte numeric data. That include strings, booleans, bytes and containers
// containing only these things (recursively).
//
// The returned value is always in normal form and is marked as trusted.
func (v *Variant) Byteswap() *Variant {
	var _arg0 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_byteswap(_arg0)

	var _variant *Variant // out

	_variant = WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

// CheckFormatString checks if calling g_variant_get() with @format_string on
// @value would be valid from a type-compatibility standpoint. @format_string is
// assumed to be a valid format string (from a syntactic standpoint).
//
// If @copy_only is true then this function additionally checks that it would be
// safe to call g_variant_unref() on @value immediately after the call to
// g_variant_get() without invalidating the result. This is only possible if
// deep copies are made (ie: there are no pointers to the data inside of the
// soon-to-be-freed #GVariant instance). If this check fails then a g_critical()
// is printed and false is returned.
//
// This function is meant to be used by functions that wish to provide varargs
// accessors to #GVariant values of uncertain values (eg: g_variant_lookup() or
// g_menu_model_get_item_attribute()).
func (v *Variant) CheckFormatString(formatString string, copyOnly bool) bool {
	var _arg0 *C.GVariant // out
	var _arg1 *C.gchar    // out
	var _arg2 C.gboolean  // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.gchar)(C.CString(formatString))
	defer C.free(unsafe.Pointer(_arg1))
	if copyOnly {
		_arg2 = C.TRUE
	}

	_cret = C.g_variant_check_format_string(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Classify classifies @value according to its top-level type.
func (v *Variant) Classify() VariantClass {
	var _arg0 *C.GVariant     // out
	var _cret C.GVariantClass // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_classify(_arg0)

	var _variantClass VariantClass // out

	_variantClass = VariantClass(_cret)

	return _variantClass
}

// Compare compares @one and @two.
//
// The types of @one and @two are #gconstpointer only to allow use of this
// function with #GTree, Array, etc. They must each be a #GVariant.
//
// Comparison is only defined for basic types (ie: booleans, numbers, strings).
// For booleans, false is less than true. Numbers are ordered in the usual way.
// Strings are in ASCII lexographical order.
//
// It is a programmer error to attempt to compare container values or two values
// that have types that are not exactly equal. For example, you cannot compare a
// 32-bit signed integer with a 32-bit unsigned integer. Also note that this
// function is not particularly well-behaved when it comes to comparison of
// doubles; in particular, the handling of incomparable values (ie: NaN) is
// undefined.
//
// If you only require an equality comparison, g_variant_equal() is more
// general.
func (o *Variant) Compare(two *Variant) int {
	var _arg0 C.gconstpointer // out
	var _arg1 C.gconstpointer // out
	var _cret C.gint          // in

	_arg0 = (C.gconstpointer)(unsafe.Pointer(o.Native()))
	_arg1 = (C.gconstpointer)(unsafe.Pointer(two.Native()))

	_cret = C.g_variant_compare(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// DupString: similar to g_variant_get_string() except that instead of returning
// a constant string, the string is duplicated.
//
// The string will always be UTF-8 encoded.
//
// The return value must be freed using g_free().
func (v *Variant) DupString() (uint, string) {
	var _arg0 *C.GVariant // out
	var _arg1 C.gsize     // in
	var _cret *C.gchar    // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_dup_string(_arg0, &_arg1)

	var _length uint // out
	var _utf8 string // out

	_length = (uint)(_arg1)
	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _length, _utf8
}

// Equal checks if @one and @two have the same type and value.
//
// The types of @one and @two are #gconstpointer only to allow use of this
// function with Table. They must each be a #GVariant.
func (o *Variant) Equal(two *Variant) bool {
	var _arg0 C.gconstpointer // out
	var _arg1 C.gconstpointer // out
	var _cret C.gboolean      // in

	_arg0 = (C.gconstpointer)(unsafe.Pointer(o.Native()))
	_arg1 = (C.gconstpointer)(unsafe.Pointer(two.Native()))

	_cret = C.g_variant_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Boolean returns the boolean value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_BOOLEAN.
func (v *Variant) Boolean() bool {
	var _arg0 *C.GVariant // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_get_boolean(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Byte returns the byte value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_BYTE.
func (v *Variant) Byte() byte {
	var _arg0 *C.GVariant // out
	var _cret C.guint8    // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_get_byte(_arg0)

	var _guint8 byte // out

	_guint8 = (byte)(_cret)

	return _guint8
}

// Bytestring returns the string value of a #GVariant instance with an
// array-of-bytes type. The string has no particular encoding.
//
// If the array does not end with a nul terminator character, the empty string
// is returned. For this reason, you can always trust that a non-nil
// nul-terminated string will be returned by this function.
//
// If the array contains a nul terminator character somewhere other than the
// last byte then the returned string is the string, up to the first such nul
// character.
//
// g_variant_get_fixed_array() should be used instead if the array contains
// arbitrary data that could not be nul-terminated or could contain nul bytes.
//
// It is an error to call this function with a @value that is not an array of
// bytes.
//
// The return value remains valid as long as @value exists.
func (v *Variant) Bytestring() []byte {
	var _arg0 *C.GVariant // out
	var _cret *C.gchar

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_get_bytestring(_arg0)

	var _guint8s []byte

	{
		var i int
		var z C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_guint8s = make([]byte, i)
		for i := range src {
			_guint8s[i] = (byte)(src[i])
		}
	}

	return _guint8s
}

// ChildValue reads a child item out of a container #GVariant instance. This
// includes variants, maybes, arrays, tuples and dictionary entries. It is an
// error to call this function on any other type of #GVariant.
//
// It is an error if @index_ is greater than the number of child items in the
// container. See g_variant_n_children().
//
// The returned value is never floating. You should free it with
// g_variant_unref() when you're done with it.
//
// Note that values borrowed from the returned child are not guaranteed to still
// be valid after the child is freed even if you still hold a reference to
// @value, if @value has not been serialised at the time this function is
// called. To avoid this, you can serialize @value by calling
// g_variant_get_data() and optionally ignoring the return value.
//
// There may be implementation specific restrictions on deeply nested values,
// which would result in the unit tuple being returned as the child value,
// instead of further nested children. #GVariant is guaranteed to handle nesting
// up to at least 64 levels.
//
// This function is O(1).
func (v *Variant) ChildValue(index_ uint) *Variant {
	var _arg0 *C.GVariant // out
	var _arg1 C.gsize     // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))
	_arg1 = (C.gsize)(index_)

	_cret = C.g_variant_get_child_value(_arg0, _arg1)

	var _variant *Variant // out

	_variant = WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

// Double returns the double precision floating point value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_DOUBLE.
func (v *Variant) Double() float64 {
	var _arg0 *C.GVariant // out
	var _cret C.gdouble   // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_get_double(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// Handle returns the 32-bit signed integer value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_HANDLE.
//
// By convention, handles are indexes into an array of file descriptors that are
// sent alongside a D-Bus message. If you're not interacting with D-Bus, you
// probably don't need them.
func (v *Variant) Handle() int32 {
	var _arg0 *C.GVariant // out
	var _cret C.gint32    // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_get_handle(_arg0)

	var _gint32 int32 // out

	_gint32 = (int32)(_cret)

	return _gint32
}

// Int16 returns the 16-bit signed integer value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_INT16.
func (v *Variant) Int16() int16 {
	var _arg0 *C.GVariant // out
	var _cret C.gint16    // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_get_int16(_arg0)

	var _gint16 int16 // out

	_gint16 = (int16)(_cret)

	return _gint16
}

// Int32 returns the 32-bit signed integer value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_INT32.
func (v *Variant) Int32() int32 {
	var _arg0 *C.GVariant // out
	var _cret C.gint32    // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_get_int32(_arg0)

	var _gint32 int32 // out

	_gint32 = (int32)(_cret)

	return _gint32
}

// Int64 returns the 64-bit signed integer value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_INT64.
func (v *Variant) Int64() int64 {
	var _arg0 *C.GVariant // out
	var _cret C.gint64    // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_get_int64(_arg0)

	var _gint64 int64 // out

	_gint64 = (int64)(_cret)

	return _gint64
}

// Maybe: given a maybe-typed #GVariant instance, extract its value. If the
// value is Nothing, then this function returns nil.
func (v *Variant) Maybe() *Variant {
	var _arg0 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_get_maybe(_arg0)

	var _variant *Variant // out

	_variant = WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

// NormalForm gets a #GVariant instance that has the same value as @value and is
// trusted to be in normal form.
//
// If @value is already trusted to be in normal form then a new reference to
// @value is returned.
//
// If @value is not already trusted, then it is scanned to check if it is in
// normal form. If it is found to be in normal form then it is marked as trusted
// and a new reference to it is returned.
//
// If @value is found not to be in normal form then a new trusted #GVariant is
// created with the same value as @value.
//
// It makes sense to call this function if you've received #GVariant data from
// untrusted sources and you want to ensure your serialised output is definitely
// in normal form.
//
// If @value is already in normal form, a new reference will be returned (which
// will be floating if @value is floating). If it is not in normal form, the
// newly created #GVariant will be returned with a single non-floating
// reference. Typically, g_variant_take_ref() should be called on the return
// value from this function to guarantee ownership of a single non-floating
// reference to it.
func (v *Variant) NormalForm() *Variant {
	var _arg0 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_get_normal_form(_arg0)

	var _variant *Variant // out

	_variant = WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

// Size determines the number of bytes that would be required to store @value
// with g_variant_store().
//
// If @value has a fixed-sized type then this function always returned that
// fixed size.
//
// In the case that @value is already in serialised form or the size has already
// been calculated (ie: this function has been called before) then this function
// is O(1). Otherwise, the size is calculated, an operation which is
// approximately O(n) in the number of values involved.
func (v *Variant) Size() uint {
	var _arg0 *C.GVariant // out
	var _cret C.gsize     // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_get_size(_arg0)

	var _gsize uint // out

	_gsize = (uint)(_cret)

	return _gsize
}

// String returns the string value of a #GVariant instance with a string type.
// This includes the types G_VARIANT_TYPE_STRING, G_VARIANT_TYPE_OBJECT_PATH and
// G_VARIANT_TYPE_SIGNATURE.
//
// The string will always be UTF-8 encoded, will never be nil, and will never
// contain nul bytes.
//
// If @length is non-nil then the length of the string (in bytes) is returned
// there. For trusted values, this information is already known. Untrusted
// values will be validated and, if valid, a strlen() will be performed. If
// invalid, a default value will be returned — for G_VARIANT_TYPE_OBJECT_PATH,
// this is `"/"`, and for other types it is the empty string.
//
// It is an error to call this function with a @value of any type other than
// those three.
//
// The return value remains valid as long as @value exists.
func (v *Variant) String() (uint, string) {
	var _arg0 *C.GVariant // out
	var _arg1 C.gsize     // in
	var _cret *C.gchar    // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_get_string(_arg0, &_arg1)

	var _length uint // out
	var _utf8 string // out

	_length = (uint)(_arg1)
	_utf8 = C.GoString(_cret)

	return _length, _utf8
}

// Type determines the type of @value.
//
// The return value is valid for the lifetime of @value and must not be freed.
func (v *Variant) Type() *VariantType {
	var _arg0 *C.GVariant     // out
	var _cret *C.GVariantType // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_get_type(_arg0)

	var _variantType *VariantType // out

	_variantType = WrapVariantType(unsafe.Pointer(_cret))

	return _variantType
}

// TypeString returns the type string of @value. Unlike the result of calling
// g_variant_type_peek_string(), this string is nul-terminated. This string
// belongs to #GVariant and must not be freed.
func (v *Variant) TypeString() string {
	var _arg0 *C.GVariant // out
	var _cret *C.gchar    // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_get_type_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Uint16 returns the 16-bit unsigned integer value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_UINT16.
func (v *Variant) Uint16() uint16 {
	var _arg0 *C.GVariant // out
	var _cret C.guint16   // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_get_uint16(_arg0)

	var _guint16 uint16 // out

	_guint16 = (uint16)(_cret)

	return _guint16
}

// Uint32 returns the 32-bit unsigned integer value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_UINT32.
func (v *Variant) Uint32() uint32 {
	var _arg0 *C.GVariant // out
	var _cret C.guint32   // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_get_uint32(_arg0)

	var _guint32 uint32 // out

	_guint32 = (uint32)(_cret)

	return _guint32
}

// Uint64 returns the 64-bit unsigned integer value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_UINT64.
func (v *Variant) Uint64() uint64 {
	var _arg0 *C.GVariant // out
	var _cret C.guint64   // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_get_uint64(_arg0)

	var _guint64 uint64 // out

	_guint64 = (uint64)(_cret)

	return _guint64
}

// Variant unboxes @value. The result is the #GVariant instance that was
// contained in @value.
func (v *Variant) Variant() *Variant {
	var _arg0 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_get_variant(_arg0)

	var _variant *Variant // out

	_variant = WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

// Hash generates a hash value for a #GVariant instance.
//
// The output of this function is guaranteed to be the same for a given value
// only per-process. It may change between different processor architectures or
// even different versions of GLib. Do not use this function as a basis for
// building protocols or file formats.
//
// The type of @value is #gconstpointer only to allow use of this function with
// Table. @value must be a #GVariant.
func (v *Variant) Hash() uint {
	var _arg0 C.gconstpointer // out
	var _cret C.guint         // in

	_arg0 = (C.gconstpointer)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_hash(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// IsContainer checks if @value is a container.
func (v *Variant) IsContainer() bool {
	var _arg0 *C.GVariant // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_is_container(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsFloating checks whether @value has a floating reference count.
//
// This function should only ever be used to assert that a given variant is or
// is not floating, or for debug purposes. To acquire a reference to a variant
// that might be floating, always use g_variant_ref_sink() or
// g_variant_take_ref().
//
// See g_variant_ref_sink() for more information about floating reference
// counts.
func (v *Variant) IsFloating() bool {
	var _arg0 *C.GVariant // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_is_floating(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsNormalForm checks if @value is in normal form.
//
// The main reason to do this is to detect if a given chunk of serialised data
// is in normal form: load the data into a #GVariant using
// g_variant_new_from_data() and then use this function to check.
//
// If @value is found to be in normal form then it will be marked as being
// trusted. If the value was already marked as being trusted then this function
// will immediately return true.
//
// There may be implementation specific restrictions on deeply nested values.
// GVariant is guaranteed to handle nesting up to at least 64 levels.
func (v *Variant) IsNormalForm() bool {
	var _arg0 *C.GVariant // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_is_normal_form(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsOfType checks if a value has a type matching the provided type.
func (v *Variant) IsOfType(typ *VariantType) bool {
	var _arg0 *C.GVariant     // out
	var _arg1 *C.GVariantType // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.GVariantType)(unsafe.Pointer(typ.Native()))

	_cret = C.g_variant_is_of_type(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LookupValue looks up a value in a dictionary #GVariant.
//
// This function works with dictionaries of the type a{s*} (and equally well
// with type a{o*}, but we only further discuss the string case for sake of
// clarity).
//
// In the event that @dictionary has the type a{sv}, the @expected_type string
// specifies what type of value is expected to be inside of the variant. If the
// value inside the variant has a different type then nil is returned. In the
// event that @dictionary has a value type other than v then @expected_type must
// directly match the value type and it is used to unpack the value directly or
// an error occurs.
//
// In either case, if @key is not found in @dictionary, nil is returned.
//
// If the key is found and the value has the correct type, it is returned. If
// @expected_type was specified then any non-nil return value will have this
// type.
//
// This function is currently implemented with a linear scan. If you plan to do
// many lookups then Dict may be more efficient.
func (d *Variant) LookupValue(key string, expectedType *VariantType) *Variant {
	var _arg0 *C.GVariant     // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GVariantType // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariantType)(unsafe.Pointer(expectedType.Native()))

	_cret = C.g_variant_lookup_value(_arg0, _arg1, _arg2)

	var _variant *Variant // out

	_variant = WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

// NChildren determines the number of children in a container #GVariant
// instance. This includes variants, maybes, arrays, tuples and dictionary
// entries. It is an error to call this function on any other type of #GVariant.
//
// For variants, the return value is always 1. For values with maybe types, it
// is always zero or one. For arrays, it is the length of the array. For tuples
// it is the number of tuple items (which depends only on the type). For
// dictionary entries, it is always 2
//
// This function is O(1).
func (v *Variant) NChildren() uint {
	var _arg0 *C.GVariant // out
	var _cret C.gsize     // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_n_children(_arg0)

	var _gsize uint // out

	_gsize = (uint)(_cret)

	return _gsize
}

// Print pretty-prints @value in the format understood by g_variant_parse().
//
// The format is described [here][gvariant-text].
//
// If @type_annotate is true, then type information is included in the output.
func (v *Variant) Print(typeAnnotate bool) string {
	var _arg0 *C.GVariant // out
	var _arg1 C.gboolean  // out
	var _cret *C.gchar    // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))
	if typeAnnotate {
		_arg1 = C.TRUE
	}

	_cret = C.g_variant_print(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Ref increases the reference count of @value.
func (v *Variant) Ref() *Variant {
	var _arg0 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_ref(_arg0)

	var _variant *Variant // out

	_variant = WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

// RefSink uses a floating reference count system. All functions with names
// starting with `g_variant_new_` return floating references.
//
// Calling g_variant_ref_sink() on a #GVariant with a floating reference will
// convert the floating reference into a full reference. Calling
// g_variant_ref_sink() on a non-floating #GVariant results in an additional
// normal reference being added.
//
// In other words, if the @value is floating, then this call "assumes ownership"
// of the floating reference, converting it to a normal reference. If the @value
// is not floating, then this call adds a new normal reference increasing the
// reference count by one.
//
// All calls that result in a #GVariant instance being inserted into a container
// will call g_variant_ref_sink() on the instance. This means that if the value
// was just created (and has only its floating reference) then the container
// will assume sole ownership of the value at that point and the caller will not
// need to unreference it. This makes certain common styles of programming much
// easier while still maintaining normal refcounting semantics in situations
// where values are not floating.
func (v *Variant) RefSink() *Variant {
	var _arg0 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_ref_sink(_arg0)

	var _variant *Variant // out

	_variant = WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

// TakeRef: if @value is floating, sink it. Otherwise, do nothing.
//
// Typically you want to use g_variant_ref_sink() in order to automatically do
// the correct thing with respect to floating or non-floating references, but
// there is one specific scenario where this function is helpful.
//
// The situation where this function is helpful is when creating an API that
// allows the user to provide a callback function that returns a #GVariant. We
// certainly want to allow the user the flexibility to return a non-floating
// reference from this callback (for the case where the value that is being
// returned already exists).
//
// At the same time, the style of the #GVariant API makes it likely that for
// newly-created #GVariant instances, the user can be saved some typing if they
// are allowed to return a #GVariant with a floating reference.
//
// Using this function on the return value of the user's callback allows the
// user to do whichever is more convenient for them. The caller will always
// receives exactly one full reference to the value: either the one that was
// returned in the first place, or a floating reference that has been converted
// to a full reference.
//
// This function has an odd interaction when combined with g_variant_ref_sink()
// running at the same time in another thread on the same #GVariant instance. If
// g_variant_ref_sink() runs first then the result will be that the floating
// reference is converted to a hard reference. If g_variant_take_ref() runs
// first then the result will be that the floating reference is converted to a
// hard reference and an additional reference on top of that one is added. It is
// best to avoid this situation.
func (v *Variant) TakeRef() *Variant {
	var _arg0 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_take_ref(_arg0)

	var _variant *Variant // out

	_variant = WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

// Unref decreases the reference count of @value. When its reference count drops
// to 0, the memory used by the variant is freed.
func (v *Variant) Unref() {
	var _arg0 *C.GVariant // out

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	C.g_variant_unref(_arg0)
}

// VariantBuilder: a utility type for constructing container-type #GVariant
// instances.
//
// This is an opaque structure and may only be accessed using the following
// functions.
//
// Builder is not threadsafe in any way. Do not attempt to access it from more
// than one thread.
type VariantBuilder C.GVariantBuilder

// WrapVariantBuilder wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapVariantBuilder(ptr unsafe.Pointer) *VariantBuilder {
	return (*VariantBuilder)(ptr)
}

func marshalVariantBuilder(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*VariantBuilder)(unsafe.Pointer(b)), nil
}

// NewVariantBuilder constructs a struct VariantBuilder.
func NewVariantBuilder(typ *VariantType) *VariantBuilder {
	var _arg1 *C.GVariantType    // out
	var _cret *C.GVariantBuilder // in

	_arg1 = (*C.GVariantType)(unsafe.Pointer(typ.Native()))

	_cret = C.g_variant_builder_new(_arg1)

	var _variantBuilder *VariantBuilder // out

	_variantBuilder = WrapVariantBuilder(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variantBuilder, func(v *VariantBuilder) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variantBuilder
}

// Native returns the underlying C source pointer.
func (v *VariantBuilder) Native() unsafe.Pointer {
	return unsafe.Pointer(v)
}

// AddValue adds @value to @builder.
//
// It is an error to call this function in any way that would create an
// inconsistent value to be constructed. Some examples of this are putting
// different types of items into an array, putting the wrong types or number of
// items in a tuple, putting more than one value into a variant, etc.
//
// If @value is a floating reference (see g_variant_ref_sink()), the @builder
// instance takes ownership of @value.
func (b *VariantBuilder) AddValue(value *Variant) {
	var _arg0 *C.GVariantBuilder // out
	var _arg1 *C.GVariant        // out

	_arg0 = (*C.GVariantBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	C.g_variant_builder_add_value(_arg0, _arg1)
}

// Close closes the subcontainer inside the given @builder that was opened by
// the most recent call to g_variant_builder_open().
//
// It is an error to call this function in any way that would create an
// inconsistent value to be constructed (ie: too few values added to the
// subcontainer).
func (b *VariantBuilder) Close() {
	var _arg0 *C.GVariantBuilder // out

	_arg0 = (*C.GVariantBuilder)(unsafe.Pointer(b.Native()))

	C.g_variant_builder_close(_arg0)
}

// End ends the builder process and returns the constructed value.
//
// It is not permissible to use @builder in any way after this call except for
// reference counting operations (in the case of a heap-allocated Builder) or by
// reinitialising it with g_variant_builder_init() (in the case of
// stack-allocated). This means that for the stack-allocated builders there is
// no need to call g_variant_builder_clear() after the call to
// g_variant_builder_end().
//
// It is an error to call this function in any way that would create an
// inconsistent value to be constructed (ie: insufficient number of items added
// to a container with a specific number of children required). It is also an
// error to call this function if the builder was created with an indefinite
// array or maybe type and no children have been added; in this case it is
// impossible to infer the type of the empty array.
func (b *VariantBuilder) End() *Variant {
	var _arg0 *C.GVariantBuilder // out
	var _cret *C.GVariant        // in

	_arg0 = (*C.GVariantBuilder)(unsafe.Pointer(b.Native()))

	_cret = C.g_variant_builder_end(_arg0)

	var _variant *Variant // out

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// Open opens a subcontainer inside the given @builder. When done adding items
// to the subcontainer, g_variant_builder_close() must be called. @type is the
// type of the container: so to build a tuple of several values, @type must
// include the tuple itself.
//
// It is an error to call this function in any way that would cause an
// inconsistent value to be constructed (ie: adding too many values or a value
// of an incorrect type).
//
// Example of building a nested variant:
//
//    GVariantBuilder builder;
//    guint32 some_number = get_number ();
//    g_autoptr (GHashTable) some_dict = get_dict ();
//    GHashTableIter iter;
//    const gchar *key;
//    const GVariant *value;
//    g_autoptr (GVariant) output = NULL;
//
//    g_variant_builder_init (&builder, G_VARIANT_TYPE ("(ua{sv})"));
//    g_variant_builder_add (&builder, "u", some_number);
//    g_variant_builder_open (&builder, G_VARIANT_TYPE ("a{sv}"));
//
//    g_hash_table_iter_init (&iter, some_dict);
//    while (g_hash_table_iter_next (&iter, (gpointer *) &key, (gpointer *) &value))
//      {
//        g_variant_builder_open (&builder, G_VARIANT_TYPE ("{sv}"));
//        g_variant_builder_add (&builder, "s", key);
//        g_variant_builder_add (&builder, "v", value);
//        g_variant_builder_close (&builder);
//      }
//
//    g_variant_builder_close (&builder);
//
//    output = g_variant_builder_end (&builder);
func (b *VariantBuilder) Open(typ *VariantType) {
	var _arg0 *C.GVariantBuilder // out
	var _arg1 *C.GVariantType    // out

	_arg0 = (*C.GVariantBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GVariantType)(unsafe.Pointer(typ.Native()))

	C.g_variant_builder_open(_arg0, _arg1)
}

// Ref increases the reference count on @builder.
//
// Don't call this on stack-allocated Builder instances or bad things will
// happen.
func (b *VariantBuilder) Ref() *VariantBuilder {
	var _arg0 *C.GVariantBuilder // out
	var _cret *C.GVariantBuilder // in

	_arg0 = (*C.GVariantBuilder)(unsafe.Pointer(b.Native()))

	_cret = C.g_variant_builder_ref(_arg0)

	var _variantBuilder *VariantBuilder // out

	_variantBuilder = WrapVariantBuilder(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variantBuilder, func(v *VariantBuilder) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variantBuilder
}

// Unref decreases the reference count on @builder.
//
// In the event that there are no more references, releases all memory
// associated with the Builder.
//
// Don't call this on stack-allocated Builder instances or bad things will
// happen.
func (b *VariantBuilder) Unref() {
	var _arg0 *C.GVariantBuilder // out

	_arg0 = (*C.GVariantBuilder)(unsafe.Pointer(b.Native()))

	C.g_variant_builder_unref(_arg0)
}

// VariantDict is a mutable interface to #GVariant dictionaries.
//
// It can be used for doing a sequence of dictionary lookups in an efficient way
// on an existing #GVariant dictionary or it can be used to construct new
// dictionaries with a hashtable-like interface. It can also be used for taking
// existing dictionaries and modifying them in order to create new ones.
//
// Dict can only be used with G_VARIANT_TYPE_VARDICT dictionaries.
//
// It is possible to use Dict allocated on the stack or on the heap. When using
// a stack-allocated Dict, you begin with a call to g_variant_dict_init() and
// free the resources with a call to g_variant_dict_clear().
//
// Heap-allocated Dict follows normal refcounting rules: you allocate it with
// g_variant_dict_new() and use g_variant_dict_ref() and g_variant_dict_unref().
//
// g_variant_dict_end() is used to convert the Dict back into a dictionary-type
// #GVariant. When used with stack-allocated instances, this also implicitly
// frees all associated memory, but for heap-allocated instances, you must still
// call g_variant_dict_unref() afterwards.
//
// You will typically want to use a heap-allocated Dict when you expose it as
// part of an API. For most other uses, the stack-allocated form will be more
// convenient.
//
// Consider the following two examples that do the same thing in each style:
// take an existing dictionary and look up the "count" uint32 key, adding 1 to
// it if it is found, or returning an error if the key is not found. Each
// returns the new dictionary as a floating #GVariant.
//
// Using a stack-allocated GVariantDict
//
//      GVariant *
//      add_to_count (GVariant  *orig,
//                    GError   **error)
//      {
//        GVariantDict *dict;
//        GVariant *result;
//        guint32 count;
//
//        dict = g_variant_dict_new (orig);
//
//        if (g_variant_dict_lookup (dict, "count", "u", &count))
//          {
//            g_variant_dict_insert (dict, "count", "u", count + 1);
//            result = g_variant_dict_end (dict);
//          }
//        else
//          {
//            g_set_error (...);
//            result = NULL;
//          }
//
//        g_variant_dict_unref (dict);
//
//        return result;
//      }
type VariantDict C.GVariantDict

// WrapVariantDict wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapVariantDict(ptr unsafe.Pointer) *VariantDict {
	return (*VariantDict)(ptr)
}

func marshalVariantDict(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*VariantDict)(unsafe.Pointer(b)), nil
}

// NewVariantDict constructs a struct VariantDict.
func NewVariantDict(fromAsv *Variant) *VariantDict {
	var _arg1 *C.GVariant     // out
	var _cret *C.GVariantDict // in

	_arg1 = (*C.GVariant)(unsafe.Pointer(fromAsv.Native()))

	_cret = C.g_variant_dict_new(_arg1)

	var _variantDict *VariantDict // out

	_variantDict = WrapVariantDict(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variantDict, func(v *VariantDict) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variantDict
}

// Native returns the underlying C source pointer.
func (v *VariantDict) Native() unsafe.Pointer {
	return unsafe.Pointer(v)
}

// Clear releases all memory associated with a Dict without freeing the Dict
// structure itself.
//
// It typically only makes sense to do this on a stack-allocated Dict if you
// want to abort building the value part-way through. This function need not be
// called if you call g_variant_dict_end() and it also doesn't need to be called
// on dicts allocated with g_variant_dict_new (see g_variant_dict_unref() for
// that).
//
// It is valid to call this function on either an initialised Dict or one that
// was previously cleared by an earlier call to g_variant_dict_clear() but it is
// not valid to call this function on uninitialised memory.
func (d *VariantDict) Clear() {
	var _arg0 *C.GVariantDict // out

	_arg0 = (*C.GVariantDict)(unsafe.Pointer(d.Native()))

	C.g_variant_dict_clear(_arg0)
}

// Contains checks if @key exists in @dict.
func (d *VariantDict) Contains(key string) bool {
	var _arg0 *C.GVariantDict // out
	var _arg1 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GVariantDict)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_variant_dict_contains(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// End returns the current value of @dict as a #GVariant of type
// G_VARIANT_TYPE_VARDICT, clearing it in the process.
//
// It is not permissible to use @dict in any way after this call except for
// reference counting operations (in the case of a heap-allocated Dict) or by
// reinitialising it with g_variant_dict_init() (in the case of
// stack-allocated).
func (d *VariantDict) End() *Variant {
	var _arg0 *C.GVariantDict // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GVariantDict)(unsafe.Pointer(d.Native()))

	_cret = C.g_variant_dict_end(_arg0)

	var _variant *Variant // out

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// InsertValue inserts (or replaces) a key in a Dict.
//
// @value is consumed if it is floating.
func (d *VariantDict) InsertValue(key string, value *Variant) {
	var _arg0 *C.GVariantDict // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GVariant     // out

	_arg0 = (*C.GVariantDict)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	C.g_variant_dict_insert_value(_arg0, _arg1, _arg2)
}

// LookupValue looks up a value in a Dict.
//
// If @key is not found in @dictionary, nil is returned.
//
// The @expected_type string specifies what type of value is expected. If the
// value associated with @key has a different type then nil is returned.
//
// If the key is found and the value has the correct type, it is returned. If
// @expected_type was specified then any non-nil return value will have this
// type.
func (d *VariantDict) LookupValue(key string, expectedType *VariantType) *Variant {
	var _arg0 *C.GVariantDict // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GVariantType // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GVariantDict)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariantType)(unsafe.Pointer(expectedType.Native()))

	_cret = C.g_variant_dict_lookup_value(_arg0, _arg1, _arg2)

	var _variant *Variant // out

	_variant = WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

// Ref increases the reference count on @dict.
//
// Don't call this on stack-allocated Dict instances or bad things will happen.
func (d *VariantDict) Ref() *VariantDict {
	var _arg0 *C.GVariantDict // out
	var _cret *C.GVariantDict // in

	_arg0 = (*C.GVariantDict)(unsafe.Pointer(d.Native()))

	_cret = C.g_variant_dict_ref(_arg0)

	var _variantDict *VariantDict // out

	_variantDict = WrapVariantDict(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variantDict, func(v *VariantDict) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variantDict
}

// Remove removes a key and its associated value from a Dict.
func (d *VariantDict) Remove(key string) bool {
	var _arg0 *C.GVariantDict // out
	var _arg1 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GVariantDict)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_variant_dict_remove(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Unref decreases the reference count on @dict.
//
// In the event that there are no more references, releases all memory
// associated with the Dict.
//
// Don't call this on stack-allocated Dict instances or bad things will happen.
func (d *VariantDict) Unref() {
	var _arg0 *C.GVariantDict // out

	_arg0 = (*C.GVariantDict)(unsafe.Pointer(d.Native()))

	C.g_variant_dict_unref(_arg0)
}

// VariantType: this section introduces the GVariant type system. It is based,
// in large part, on the D-Bus type system, with two major changes and some
// minor lifting of restrictions. The D-Bus specification
// (http://dbus.freedesktop.org/doc/dbus-specification.html), therefore,
// provides a significant amount of information that is useful when working with
// GVariant.
//
// The first major change with respect to the D-Bus type system is the
// introduction of maybe (or "nullable") types. Any type in GVariant can be
// converted to a maybe type, in which case, "nothing" (or "null") becomes a
// valid value. Maybe types have been added by introducing the character "m" to
// type strings.
//
// The second major change is that the GVariant type system supports the concept
// of "indefinite types" -- types that are less specific than the normal types
// found in D-Bus. For example, it is possible to speak of "an array of any
// type" in GVariant, where the D-Bus type system would require you to speak of
// "an array of integers" or "an array of strings". Indefinite types have been
// added by introducing the characters "*", "?" and "r" to type strings.
//
// Finally, all arbitrary restrictions relating to the complexity of types are
// lifted along with the restriction that dictionary entries may only appear
// nested inside of arrays.
//
// Just as in D-Bus, GVariant types are described with strings ("type strings").
// Subject to the differences mentioned above, these strings are of the same
// form as those found in D-Bus. Note, however: D-Bus always works in terms of
// messages and therefore individual type strings appear nowhere in its
// interface. Instead, "signatures" are a concatenation of the strings of the
// type of each argument in a message. GVariant deals with single values
// directly so GVariant type strings always describe the type of exactly one
// value. This means that a D-Bus signature string is generally not a valid
// GVariant type string -- except in the case that it is the signature of a
// message containing exactly one argument.
//
// An indefinite type is similar in spirit to what may be called an abstract
// type in other type systems. No value can exist that has an indefinite type as
// its type, but values can exist that have types that are subtypes of
// indefinite types. That is to say, g_variant_get_type() will never return an
// indefinite type, but calling g_variant_is_of_type() with an indefinite type
// may return true. For example, you cannot have a value that represents "an
// array of no particular type", but you can have an "array of integers" which
// certainly matches the type of "an array of no particular type", since "array
// of integers" is a subtype of "array of no particular type".
//
// This is similar to how instances of abstract classes may not directly exist
// in other type systems, but instances of their non-abstract subtypes may. For
// example, in GTK, no object that has the type of Bin can exist (since Bin is
// an abstract class), but a Window can certainly be instantiated, and you would
// say that the Window is a Bin (since Window is a subclass of Bin).
//
//
// GVariant Type Strings
//
// A GVariant type string can be any of the following:
//
// - any basic type string (listed below)
//
// - "v", "r" or "*"
//
// - one of the characters 'a' or 'm', followed by another type string
//
// - the character '(', followed by a concatenation of zero or more other type
// strings, followed by the character ')'
//
// - the character '{', followed by a basic type string (see below), followed by
// another type string, followed by the character '}'
//
// A basic type string describes a basic type (as per g_variant_type_is_basic())
// and is always a single character in length. The valid basic type strings are
// "b", "y", "n", "q", "i", "u", "x", "t", "h", "d", "s", "o", "g" and "?".
//
// The above definition is recursive to arbitrary depth. "aaaaai" and
// "(ui(nq((y)))s)" are both valid type strings, as is "a(aa(ui)(qna{ya(yd)}))".
// In order to not hit memory limits, #GVariant imposes a limit on recursion
// depth of 65 nested containers. This is the limit in the D-Bus specification
// (64) plus one to allow a BusMessage to be nested in a top-level tuple.
//
// The meaning of each of the characters is as follows: - `b`: the type string
// of G_VARIANT_TYPE_BOOLEAN; a boolean value. - `y`: the type string of
// G_VARIANT_TYPE_BYTE; a byte. - `n`: the type string of G_VARIANT_TYPE_INT16;
// a signed 16 bit integer. - `q`: the type string of G_VARIANT_TYPE_UINT16; an
// unsigned 16 bit integer. - `i`: the type string of G_VARIANT_TYPE_INT32; a
// signed 32 bit integer. - `u`: the type string of G_VARIANT_TYPE_UINT32; an
// unsigned 32 bit integer. - `x`: the type string of G_VARIANT_TYPE_INT64; a
// signed 64 bit integer. - `t`: the type string of G_VARIANT_TYPE_UINT64; an
// unsigned 64 bit integer. - `h`: the type string of G_VARIANT_TYPE_HANDLE; a
// signed 32 bit value that, by convention, is used as an index into an array of
// file descriptors that are sent alongside a D-Bus message. - `d`: the type
// string of G_VARIANT_TYPE_DOUBLE; a double precision floating point value. -
// `s`: the type string of G_VARIANT_TYPE_STRING; a string. - `o`: the type
// string of G_VARIANT_TYPE_OBJECT_PATH; a string in the form of a D-Bus object
// path. - `g`: the type string of G_VARIANT_TYPE_SIGNATURE; a string in the
// form of a D-Bus type signature. - `?`: the type string of
// G_VARIANT_TYPE_BASIC; an indefinite type that is a supertype of any of the
// basic types. - `v`: the type string of G_VARIANT_TYPE_VARIANT; a container
// type that contain any other type of value. - `a`: used as a prefix on another
// type string to mean an array of that type; the type string "ai", for example,
// is the type of an array of signed 32-bit integers. - `m`: used as a prefix on
// another type string to mean a "maybe", or "nullable", version of that type;
// the type string "ms", for example, is the type of a value that maybe contains
// a string, or maybe contains nothing. - `()`: used to enclose zero or more
// other concatenated type strings to create a tuple type; the type string
// "(is)", for example, is the type of a pair of an integer and a string. - `r`:
// the type string of G_VARIANT_TYPE_TUPLE; an indefinite type that is a
// supertype of any tuple type, regardless of the number of items. - `{}`: used
// to enclose a basic type string concatenated with another type string to
// create a dictionary entry type, which usually appears inside of an array to
// form a dictionary; the type string "a{sd}", for example, is the type of a
// dictionary that maps strings to double precision floating point values.
//
//    The first type (the basic type) is the key type and the second type is
//    the value type. The reason that the first type is restricted to being a
//    basic type is so that it can easily be hashed.
//
// - `*`: the type string of G_VARIANT_TYPE_ANY; the indefinite type that is
//
//    a supertype of all types.  Note that, as with all type strings, this
//    character represents exactly one type. It cannot be used inside of tuples
//    to mean "any number of items".
//
// Any type string of a container that contains an indefinite type is, itself,
// an indefinite type. For example, the type string "a*" (corresponding to
// G_VARIANT_TYPE_ARRAY) is an indefinite type that is a supertype of every
// array type. "(*s)" is a supertype of all tuples that contain exactly two
// items where the second item is a string.
//
// "a{?*}" is an indefinite type that is a supertype of all arrays containing
// dictionary entries where the key is any basic type and the value is any type
// at all. This is, by definition, a dictionary, so this type string corresponds
// to G_VARIANT_TYPE_DICTIONARY. Note that, due to the restriction that the key
// of a dictionary entry must be a basic type, "{**}" is not a valid type
// string.
type VariantType C.GVariantType

// WrapVariantType wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapVariantType(ptr unsafe.Pointer) *VariantType {
	return (*VariantType)(ptr)
}

func marshalVariantType(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*VariantType)(unsafe.Pointer(b)), nil
}

// NewVariantType constructs a struct VariantType.
func NewVariantType(typeString string) *VariantType {
	var _arg1 *C.gchar        // out
	var _cret *C.GVariantType // in

	_arg1 = (*C.gchar)(C.CString(typeString))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_variant_type_new(_arg1)

	var _variantType *VariantType // out

	_variantType = WrapVariantType(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variantType, func(v *VariantType) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variantType
}

// NewVariantTypeArray constructs a struct VariantType.
func NewVariantTypeArray(element *VariantType) *VariantType {
	var _arg1 *C.GVariantType // out
	var _cret *C.GVariantType // in

	_arg1 = (*C.GVariantType)(unsafe.Pointer(element.Native()))

	_cret = C.g_variant_type_new_array(_arg1)

	var _variantType *VariantType // out

	_variantType = WrapVariantType(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variantType, func(v *VariantType) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variantType
}

// NewVariantTypeDictEntry constructs a struct VariantType.
func NewVariantTypeDictEntry(key *VariantType, value *VariantType) *VariantType {
	var _arg1 *C.GVariantType // out
	var _arg2 *C.GVariantType // out
	var _cret *C.GVariantType // in

	_arg1 = (*C.GVariantType)(unsafe.Pointer(key.Native()))
	_arg2 = (*C.GVariantType)(unsafe.Pointer(value.Native()))

	_cret = C.g_variant_type_new_dict_entry(_arg1, _arg2)

	var _variantType *VariantType // out

	_variantType = WrapVariantType(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variantType, func(v *VariantType) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variantType
}

// NewVariantTypeMaybe constructs a struct VariantType.
func NewVariantTypeMaybe(element *VariantType) *VariantType {
	var _arg1 *C.GVariantType // out
	var _cret *C.GVariantType // in

	_arg1 = (*C.GVariantType)(unsafe.Pointer(element.Native()))

	_cret = C.g_variant_type_new_maybe(_arg1)

	var _variantType *VariantType // out

	_variantType = WrapVariantType(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variantType, func(v *VariantType) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variantType
}

// NewVariantTypeTuple constructs a struct VariantType.
func NewVariantTypeTuple(items []*VariantType) *VariantType {
	var _arg1 **C.GVariantType
	var _arg2 C.gint
	var _cret *C.GVariantType // in

	_arg2 = C.gint(len(items))
	_arg1 = (**C.GVariantType)(unsafe.Pointer(&items[0]))

	_cret = C.g_variant_type_new_tuple(_arg1, _arg2)

	var _variantType *VariantType // out

	_variantType = WrapVariantType(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variantType, func(v *VariantType) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variantType
}

// Native returns the underlying C source pointer.
func (v *VariantType) Native() unsafe.Pointer {
	return unsafe.Pointer(v)
}

// Copy makes a copy of a Type. It is appropriate to call g_variant_type_free()
// on the return value. @type may not be nil.
func (t *VariantType) Copy() *VariantType {
	var _arg0 *C.GVariantType // out
	var _cret *C.GVariantType // in

	_arg0 = (*C.GVariantType)(unsafe.Pointer(t.Native()))

	_cret = C.g_variant_type_copy(_arg0)

	var _variantType *VariantType // out

	_variantType = WrapVariantType(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variantType, func(v *VariantType) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variantType
}

// DupString returns a newly-allocated copy of the type string corresponding to
// @type. The returned string is nul-terminated. It is appropriate to call
// g_free() on the return value.
func (t *VariantType) DupString() string {
	var _arg0 *C.GVariantType // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GVariantType)(unsafe.Pointer(t.Native()))

	_cret = C.g_variant_type_dup_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Element determines the element type of an array or maybe type.
//
// This function may only be used with array or maybe types.
func (t *VariantType) Element() *VariantType {
	var _arg0 *C.GVariantType // out
	var _cret *C.GVariantType // in

	_arg0 = (*C.GVariantType)(unsafe.Pointer(t.Native()))

	_cret = C.g_variant_type_element(_arg0)

	var _variantType *VariantType // out

	_variantType = WrapVariantType(unsafe.Pointer(_cret))

	return _variantType
}

// Equal compares @type1 and @type2 for equality.
//
// Only returns true if the types are exactly equal. Even if one type is an
// indefinite type and the other is a subtype of it, false will be returned if
// they are not exactly equal. If you want to check for subtypes, use
// g_variant_type_is_subtype_of().
//
// The argument types of @type1 and @type2 are only #gconstpointer to allow use
// with Table without function pointer casting. For both arguments, a valid Type
// must be provided.
func (t *VariantType) Equal(type2 *VariantType) bool {
	var _arg0 C.gconstpointer // out
	var _arg1 C.gconstpointer // out
	var _cret C.gboolean      // in

	_arg0 = (C.gconstpointer)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gconstpointer)(unsafe.Pointer(type2.Native()))

	_cret = C.g_variant_type_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// First determines the first item type of a tuple or dictionary entry type.
//
// This function may only be used with tuple or dictionary entry types, but must
// not be used with the generic tuple type G_VARIANT_TYPE_TUPLE.
//
// In the case of a dictionary entry type, this returns the type of the key.
//
// nil is returned in case of @type being G_VARIANT_TYPE_UNIT.
//
// This call, together with g_variant_type_next() provides an iterator interface
// over tuple and dictionary entry types.
func (t *VariantType) First() *VariantType {
	var _arg0 *C.GVariantType // out
	var _cret *C.GVariantType // in

	_arg0 = (*C.GVariantType)(unsafe.Pointer(t.Native()))

	_cret = C.g_variant_type_first(_arg0)

	var _variantType *VariantType // out

	_variantType = WrapVariantType(unsafe.Pointer(_cret))

	return _variantType
}

// Free frees a Type that was allocated with g_variant_type_copy(),
// g_variant_type_new() or one of the container type constructor functions.
//
// In the case that @type is nil, this function does nothing.
//
// Since 2.24
func (t *VariantType) Free() {
	var _arg0 *C.GVariantType // out

	_arg0 = (*C.GVariantType)(unsafe.Pointer(t.Native()))

	C.g_variant_type_free(_arg0)
}

// StringLength returns the length of the type string corresponding to the given
// @type. This function must be used to determine the valid extent of the memory
// region returned by g_variant_type_peek_string().
func (t *VariantType) StringLength() uint {
	var _arg0 *C.GVariantType // out
	var _cret C.gsize         // in

	_arg0 = (*C.GVariantType)(unsafe.Pointer(t.Native()))

	_cret = C.g_variant_type_get_string_length(_arg0)

	var _gsize uint // out

	_gsize = (uint)(_cret)

	return _gsize
}

// Hash hashes @type.
//
// The argument type of @type is only #gconstpointer to allow use with Table
// without function pointer casting. A valid Type must be provided.
func (t *VariantType) Hash() uint {
	var _arg0 C.gconstpointer // out
	var _cret C.guint         // in

	_arg0 = (C.gconstpointer)(unsafe.Pointer(t.Native()))

	_cret = C.g_variant_type_hash(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// IsArray determines if the given @type is an array type. This is true if the
// type string for @type starts with an 'a'.
//
// This function returns true for any indefinite type for which every definite
// subtype is an array type -- G_VARIANT_TYPE_ARRAY, for example.
func (t *VariantType) IsArray() bool {
	var _arg0 *C.GVariantType // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GVariantType)(unsafe.Pointer(t.Native()))

	_cret = C.g_variant_type_is_array(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsBasic determines if the given @type is a basic type.
//
// Basic types are booleans, bytes, integers, doubles, strings, object paths and
// signatures.
//
// Only a basic type may be used as the key of a dictionary entry.
//
// This function returns false for all indefinite types except
// G_VARIANT_TYPE_BASIC.
func (t *VariantType) IsBasic() bool {
	var _arg0 *C.GVariantType // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GVariantType)(unsafe.Pointer(t.Native()))

	_cret = C.g_variant_type_is_basic(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsContainer determines if the given @type is a container type.
//
// Container types are any array, maybe, tuple, or dictionary entry types plus
// the variant type.
//
// This function returns true for any indefinite type for which every definite
// subtype is a container -- G_VARIANT_TYPE_ARRAY, for example.
func (t *VariantType) IsContainer() bool {
	var _arg0 *C.GVariantType // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GVariantType)(unsafe.Pointer(t.Native()))

	_cret = C.g_variant_type_is_container(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsDefinite determines if the given @type is definite (ie: not indefinite).
//
// A type is definite if its type string does not contain any indefinite type
// characters ('*', '?', or 'r').
//
// A #GVariant instance may not have an indefinite type, so calling this
// function on the result of g_variant_get_type() will always result in true
// being returned. Calling this function on an indefinite type like
// G_VARIANT_TYPE_ARRAY, however, will result in false being returned.
func (t *VariantType) IsDefinite() bool {
	var _arg0 *C.GVariantType // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GVariantType)(unsafe.Pointer(t.Native()))

	_cret = C.g_variant_type_is_definite(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsDictEntry determines if the given @type is a dictionary entry type. This is
// true if the type string for @type starts with a '{'.
//
// This function returns true for any indefinite type for which every definite
// subtype is a dictionary entry type -- G_VARIANT_TYPE_DICT_ENTRY, for example.
func (t *VariantType) IsDictEntry() bool {
	var _arg0 *C.GVariantType // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GVariantType)(unsafe.Pointer(t.Native()))

	_cret = C.g_variant_type_is_dict_entry(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsMaybe determines if the given @type is a maybe type. This is true if the
// type string for @type starts with an 'm'.
//
// This function returns true for any indefinite type for which every definite
// subtype is a maybe type -- G_VARIANT_TYPE_MAYBE, for example.
func (t *VariantType) IsMaybe() bool {
	var _arg0 *C.GVariantType // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GVariantType)(unsafe.Pointer(t.Native()))

	_cret = C.g_variant_type_is_maybe(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsSubtypeOf checks if @type is a subtype of @supertype.
//
// This function returns true if @type is a subtype of @supertype. All types are
// considered to be subtypes of themselves. Aside from that, only indefinite
// types can have subtypes.
func (t *VariantType) IsSubtypeOf(supertype *VariantType) bool {
	var _arg0 *C.GVariantType // out
	var _arg1 *C.GVariantType // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GVariantType)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GVariantType)(unsafe.Pointer(supertype.Native()))

	_cret = C.g_variant_type_is_subtype_of(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsTuple determines if the given @type is a tuple type. This is true if the
// type string for @type starts with a '(' or if @type is G_VARIANT_TYPE_TUPLE.
//
// This function returns true for any indefinite type for which every definite
// subtype is a tuple type -- G_VARIANT_TYPE_TUPLE, for example.
func (t *VariantType) IsTuple() bool {
	var _arg0 *C.GVariantType // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GVariantType)(unsafe.Pointer(t.Native()))

	_cret = C.g_variant_type_is_tuple(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsVariant determines if the given @type is the variant type.
func (t *VariantType) IsVariant() bool {
	var _arg0 *C.GVariantType // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GVariantType)(unsafe.Pointer(t.Native()))

	_cret = C.g_variant_type_is_variant(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Key determines the key type of a dictionary entry type.
//
// This function may only be used with a dictionary entry type. Other than the
// additional restriction, this call is equivalent to g_variant_type_first().
func (t *VariantType) Key() *VariantType {
	var _arg0 *C.GVariantType // out
	var _cret *C.GVariantType // in

	_arg0 = (*C.GVariantType)(unsafe.Pointer(t.Native()))

	_cret = C.g_variant_type_key(_arg0)

	var _variantType *VariantType // out

	_variantType = WrapVariantType(unsafe.Pointer(_cret))

	return _variantType
}

// NItems determines the number of items contained in a tuple or dictionary
// entry type.
//
// This function may only be used with tuple or dictionary entry types, but must
// not be used with the generic tuple type G_VARIANT_TYPE_TUPLE.
//
// In the case of a dictionary entry type, this function will always return 2.
func (t *VariantType) NItems() uint {
	var _arg0 *C.GVariantType // out
	var _cret C.gsize         // in

	_arg0 = (*C.GVariantType)(unsafe.Pointer(t.Native()))

	_cret = C.g_variant_type_n_items(_arg0)

	var _gsize uint // out

	_gsize = (uint)(_cret)

	return _gsize
}

// Next determines the next item type of a tuple or dictionary entry type.
//
// @type must be the result of a previous call to g_variant_type_first() or
// g_variant_type_next().
//
// If called on the key type of a dictionary entry then this call returns the
// value type. If called on the value type of a dictionary entry then this call
// returns nil.
//
// For tuples, nil is returned when @type is the last item in a tuple.
func (t *VariantType) Next() *VariantType {
	var _arg0 *C.GVariantType // out
	var _cret *C.GVariantType // in

	_arg0 = (*C.GVariantType)(unsafe.Pointer(t.Native()))

	_cret = C.g_variant_type_next(_arg0)

	var _variantType *VariantType // out

	_variantType = WrapVariantType(unsafe.Pointer(_cret))

	return _variantType
}

// Value determines the value type of a dictionary entry type.
//
// This function may only be used with a dictionary entry type.
func (t *VariantType) Value() *VariantType {
	var _arg0 *C.GVariantType // out
	var _cret *C.GVariantType // in

	_arg0 = (*C.GVariantType)(unsafe.Pointer(t.Native()))

	_cret = C.g_variant_type_value(_arg0)

	var _variantType *VariantType // out

	_variantType = WrapVariantType(unsafe.Pointer(_cret))

	return _variantType
}
