// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: glib-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib.h>
//
// extern void gotk4_ChildWatchFunc(GPid _0, gint _1, gpointer _2);
// extern gint gotk4_CompareDataFunc(gconstpointer _0, gconstpointer _1, gpointer _2);
// extern void gotk4_DataForeachFunc(GQuark _0, gpointer _1, gpointer _2);
// extern gpointer gotk4_DuplicateFunc(gpointer _0, gpointer _1);
// extern void gotk4_Func(gpointer _0, gpointer _1);
// extern void gotk4_HFunc(gpointer _0, gpointer _1, gpointer _2);
// extern gboolean gotk4_HRFunc(gpointer _0, gpointer _1, gpointer _2);
// extern void gotk4_LogFunc(const gchar* _0, GLogLevelFlags _1, const gchar* _2, gpointer _3);
// extern GLogWriterOutput gotk4_LogWriterFunc(GLogLevelFlags _0, const GLogField* _1, gsize _2, gpointer _3);
// extern gboolean gotk4_RegexEvalCallback(const GMatchInfo* _0, GString* _1, gpointer _2);
// extern gboolean gotk4_SourceFunc(gpointer _0);
// extern void gotk4_SpawnChildSetupFunc(gpointer _0);
// extern void gotk4_TestDataFunc(gconstpointer _0);
// extern void gotk4_TestFixtureFunc(gpointer _0, gconstpointer _1);
// extern gboolean gotk4_TestLogFatalFunc(const gchar* _0, GLogLevelFlags _1, const gchar* _2, gpointer _3);
// extern gboolean gotk4_UnixFDSourceFunc(gint _0, GIOCondition _1, gpointer _2);
// // extern void callbackDelete(gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_io_condition_get_type()), F: marshalIOCondition},
		{T: externglib.Type(C.g_array_get_type()), F: marshalArray},
		{T: externglib.Type(C.g_byte_array_get_type()), F: marshalByteArray},
		{T: externglib.Type(C.g_bytes_get_type()), F: marshalBytes},
		{T: externglib.Type(C.g_checksum_get_type()), F: marshalChecksum},
		{T: externglib.Type(C.g_date_get_type()), F: marshalDate},
		{T: externglib.Type(C.g_date_time_get_type()), F: marshalDateTime},
		{T: externglib.Type(C.g_error_get_type()), F: marshalError},
		{T: externglib.Type(C.g_hash_table_get_type()), F: marshalHashTable},
		{T: externglib.Type(C.g_io_channel_get_type()), F: marshalIOChannel},
		{T: externglib.Type(C.g_key_file_get_type()), F: marshalKeyFile},
		{T: externglib.Type(C.g_main_context_get_type()), F: marshalMainContext},
		{T: externglib.Type(C.g_main_loop_get_type()), F: marshalMainLoop},
		{T: externglib.Type(C.g_mapped_file_get_type()), F: marshalMappedFile},
		{T: externglib.Type(C.g_markup_parse_context_get_type()), F: marshalMarkupParseContext},
		{T: externglib.Type(C.g_match_info_get_type()), F: marshalMatchInfo},
		{T: externglib.Type(C.g_option_group_get_type()), F: marshalOptionGroup},
		{T: externglib.Type(C.g_pollfd_get_type()), F: marshalPollFD},
		{T: externglib.Type(C.g_ptr_array_get_type()), F: marshalPtrArray},
		{T: externglib.Type(C.g_regex_get_type()), F: marshalRegex},
		{T: externglib.Type(C.g_source_get_type()), F: marshalSource},
		{T: externglib.Type(C.g_gstring_get_type()), F: marshalString},
		{T: externglib.Type(C.g_thread_get_type()), F: marshalThread},
		{T: externglib.Type(C.g_time_zone_get_type()), F: marshalTimeZone},
		{T: externglib.Type(C.g_uri_get_type()), F: marshalURI},
		{T: externglib.Type(C.intern()), F: marshalVariant},
		{T: externglib.Type(C.g_variant_builder_get_type()), F: marshalVariantBuilder},
		{T: externglib.Type(C.g_variant_dict_get_type()), F: marshalVariantDict},
		{T: externglib.Type(C.g_variant_type_get_gtype()), F: marshalVariantType},
	})
}

//export callbackDelete
func callbackDelete(ptr C.gpointer) {
	box.Delete(box.Callback, uintptr(ptr))
}

// DateDay: integer representing a day of the month; between 1 and 31.
// DATE_BAD_DAY represents an invalid day of the month.
type DateDay byte

// DateYear: integer representing a year; DATE_BAD_YEAR is the invalid value.
// The year must be 1 or higher; negative (BC) years are not allowed. The year
// is represented with four digits.
type DateYear uint16

// Pid: a type which is used to hold a process identification.
//
// On UNIX, processes are identified by a process id (an integer), while Windows
// uses process handles (which are pointers).
//
// GPid is used in GLib only for descendant processes spawned with the g_spawn
// functions.
type Pid int

// Quark: a GQuark is a non-zero integer which uniquely identifies a particular
// string. A GQuark value of zero is associated to nil.
type Quark uint32

// RefString: a typedef for a reference-counted string. A pointer to a String
// can be treated like a standard `char*` array by all code, but can
// additionally have `g_ref_string_*()` methods called on it. `g_ref_string_*()`
// methods cannot be called on `char*` arrays not allocated using
// g_ref_string_new().
//
// If using String with autocleanups, g_autoptr() must be used rather than
// g_autofree(), so that the reference counting metadata is also freed.
type RefString byte

// Strv: a typedef alias for gchar**. This is mostly useful when used together
// with g_auto().
type Strv string

// Time: simply a replacement for `time_t`. It has been deprecated since it is
// not equivalent to `time_t` on 64-bit platforms with a 64-bit `time_t`.
// Unrelated to #GTimer.
//
// Note that #GTime is defined to always be a 32-bit integer, unlike `time_t`
// which may be 64-bit on some systems. Therefore, #GTime will overflow in the
// year 2038, and you cannot use the address of a #GTime variable as argument to
// the UNIX time() function.
//
// Instead, do the following:
//
//    time_t ttime;
//    GTime gtime;
//
//    time (&ttime);
//    gtime = (GTime)ttime;
type Time int32

// TimeSpan: a value representing an interval of time, in microseconds.
type TimeSpan int64

type Type uint

// BookmarkFileError: error codes returned by bookmark file parsing.
type BookmarkFileError int

const (
	// BookmarkFileErrorInvalidURI: URI was ill-formed
	BookmarkFileErrorInvalidURI BookmarkFileError = 0
	// BookmarkFileErrorInvalidValue: a requested field was not found
	BookmarkFileErrorInvalidValue BookmarkFileError = 1
	// BookmarkFileErrorAppNotRegistered: a requested application did not
	// register a bookmark
	BookmarkFileErrorAppNotRegistered BookmarkFileError = 2
	// BookmarkFileErrorURINotFound: a requested URI was not found
	BookmarkFileErrorURINotFound BookmarkFileError = 3
	// BookmarkFileErrorRead: document was ill formed
	BookmarkFileErrorRead BookmarkFileError = 4
	// BookmarkFileErrorUnknownEncoding: the text being parsed was in an unknown
	// encoding
	BookmarkFileErrorUnknownEncoding BookmarkFileError = 5
	// BookmarkFileErrorWrite: an error occurred while writing
	BookmarkFileErrorWrite BookmarkFileError = 6
	// BookmarkFileErrorFileNotFound: requested file was not found
	BookmarkFileErrorFileNotFound BookmarkFileError = 7
)

// ChecksumType: the hashing algorithm to be used by #GChecksum when performing
// the digest of some data.
//
// Note that the Type enumeration may be extended at a later date to include new
// hashing algorithm types.
type ChecksumType int

const (
	// ChecksumTypeMD5: use the MD5 hashing algorithm
	ChecksumTypeMD5 ChecksumType = 0
	// ChecksumTypeSHA1: use the SHA-1 hashing algorithm
	ChecksumTypeSHA1 ChecksumType = 1
	// ChecksumTypeSHA256: use the SHA-256 hashing algorithm
	ChecksumTypeSHA256 ChecksumType = 2
	// ChecksumTypeSHA512: use the SHA-512 hashing algorithm (Since: 2.36)
	ChecksumTypeSHA512 ChecksumType = 3
	// ChecksumTypeSHA384: use the SHA-384 hashing algorithm (Since: 2.51)
	ChecksumTypeSHA384 ChecksumType = 4
)

// ConvertError: error codes returned by character set conversion routines.
type ConvertError int

const (
	// ConvertErrorNoConversion: conversion between the requested character sets
	// is not supported.
	ConvertErrorNoConversion ConvertError = 0
	// ConvertErrorIllegalSequence: invalid byte sequence in conversion input;
	// or the character sequence could not be represented in the target
	// character set.
	ConvertErrorIllegalSequence ConvertError = 1
	// ConvertErrorFailed: conversion failed for some reason.
	ConvertErrorFailed ConvertError = 2
	// ConvertErrorPartialInput: partial character sequence at end of input.
	ConvertErrorPartialInput ConvertError = 3
	// ConvertErrorBadURI: URI is invalid.
	ConvertErrorBadURI ConvertError = 4
	// ConvertErrorNotAbsolutePath: pathname is not an absolute path.
	ConvertErrorNotAbsolutePath ConvertError = 5
	// ConvertErrorNoMemory: no memory available. Since: 2.40
	ConvertErrorNoMemory ConvertError = 6
	// ConvertErrorEmbeddedNUL: an embedded NUL character is present in
	// conversion output where a NUL-terminated string is expected. Since: 2.56
	ConvertErrorEmbeddedNUL ConvertError = 7
)

// DateDMY: this enumeration isn't used in the API, but may be useful if you
// need to mark a number as a day, month, or year.
type DateDMY int

const (
	// DateDMYDay: a day
	DateDMYDay DateDMY = 0
	// DateDMYMonth: a month
	DateDMYMonth DateDMY = 1
	// DateDMYYear: a year
	DateDMYYear DateDMY = 2
)

// DateMonth: enumeration representing a month; values are DATE_JANUARY,
// DATE_FEBRUARY, etc. DATE_BAD_MONTH is the invalid value.
type DateMonth int

const (
	// DateMonthBadMonth: invalid value
	DateMonthBadMonth DateMonth = 0
	// DateMonthJanuary: january
	DateMonthJanuary DateMonth = 1
	// DateMonthFebruary: february
	DateMonthFebruary DateMonth = 2
	// DateMonthMarch: march
	DateMonthMarch DateMonth = 3
	// DateMonthApril: april
	DateMonthApril DateMonth = 4
	// DateMonthMay: may
	DateMonthMay DateMonth = 5
	// DateMonthJune: june
	DateMonthJune DateMonth = 6
	// DateMonthJuly: july
	DateMonthJuly DateMonth = 7
	// DateMonthAugust: august
	DateMonthAugust DateMonth = 8
	// DateMonthSeptember: september
	DateMonthSeptember DateMonth = 9
	// DateMonthOctober: october
	DateMonthOctober DateMonth = 10
	// DateMonthNovember: november
	DateMonthNovember DateMonth = 11
	// DateMonthDecember: december
	DateMonthDecember DateMonth = 12
)

// DateWeekday: enumeration representing a day of the week; DATE_MONDAY,
// DATE_TUESDAY, etc. DATE_BAD_WEEKDAY is an invalid weekday.
type DateWeekday int

const (
	// DateWeekdayBadWeekday: invalid value
	DateWeekdayBadWeekday DateWeekday = 0
	// DateWeekdayMonday: monday
	DateWeekdayMonday DateWeekday = 1
	// DateWeekdayTuesday: tuesday
	DateWeekdayTuesday DateWeekday = 2
	// DateWeekdayWednesday: wednesday
	DateWeekdayWednesday DateWeekday = 3
	// DateWeekdayThursday: thursday
	DateWeekdayThursday DateWeekday = 4
	// DateWeekdayFriday: friday
	DateWeekdayFriday DateWeekday = 5
	// DateWeekdaySaturday: saturday
	DateWeekdaySaturday DateWeekday = 6
	// DateWeekdaySunday: sunday
	DateWeekdaySunday DateWeekday = 7
)

// ErrorType: the possible errors, used in the @v_error field of Value, when the
// token is a G_TOKEN_ERROR.
type ErrorType int

const (
	// ErrorTypeUnknown: unknown error
	ErrorTypeUnknown ErrorType = 0
	// ErrorTypeUnexpEOF: unexpected end of file
	ErrorTypeUnexpEOF ErrorType = 1
	// ErrorTypeUnexpEOFInString: unterminated string constant
	ErrorTypeUnexpEOFInString ErrorType = 2
	// ErrorTypeUnexpEOFInComment: unterminated comment
	ErrorTypeUnexpEOFInComment ErrorType = 3
	// ErrorTypeNonDigitInConst: non-digit character in a number
	ErrorTypeNonDigitInConst ErrorType = 4
	// ErrorTypeDigitRadix: digit beyond radix in a number
	ErrorTypeDigitRadix ErrorType = 5
	// ErrorTypeFloatRadix: non-decimal floating point number
	ErrorTypeFloatRadix ErrorType = 6
	// ErrorTypeFloatMalformed: malformed floating point number
	ErrorTypeFloatMalformed ErrorType = 7
)

// FileError values corresponding to @errno codes returned from file operations
// on UNIX. Unlike @errno codes, GFileError values are available on all systems,
// even Windows. The exact meaning of each code depends on what sort of file
// operation you were performing; the UNIX documentation gives more details. The
// following error code descriptions come from the GNU C Library manual, and are
// under the copyright of that manual.
//
// It's not very portable to make detailed assumptions about exactly which
// errors will be returned from a given operation. Some errors don't occur on
// some systems, etc., sometimes there are subtle differences in when a system
// will report a given error, etc.
type FileError int

const (
	// FileErrorExist: operation not permitted; only the owner of the file (or
	// other resource) or processes with special privileges can perform the
	// operation.
	FileErrorExist FileError = 0
	// FileErrorIsdir: file is a directory; you cannot open a directory for
	// writing, or create or remove hard links to it.
	FileErrorIsdir FileError = 1
	// FileErrorAcces: permission denied; the file permissions do not allow the
	// attempted operation.
	FileErrorAcces FileError = 2
	// FileErrorNametoolong: filename too long.
	FileErrorNametoolong FileError = 3
	// FileErrorNoent: no such file or directory. This is a "file doesn't exist"
	// error for ordinary files that are referenced in contexts where they are
	// expected to already exist.
	FileErrorNoent FileError = 4
	// FileErrorNotdir: a file that isn't a directory was specified when a
	// directory is required.
	FileErrorNotdir FileError = 5
	// FileErrorNxio: no such device or address. The system tried to use the
	// device represented by a file you specified, and it couldn't find the
	// device. This can mean that the device file was installed incorrectly, or
	// that the physical device is missing or not correctly attached to the
	// computer.
	FileErrorNxio FileError = 6
	// FileErrorNodev: the underlying file system of the specified file does not
	// support memory mapping.
	FileErrorNodev FileError = 7
	// FileErrorRofs: the directory containing the new link can't be modified
	// because it's on a read-only file system.
	FileErrorRofs FileError = 8
	// FileErrorTxtbsy: text file busy.
	FileErrorTxtbsy FileError = 9
	// FileErrorFault: you passed in a pointer to bad memory. (GLib won't
	// reliably return this, don't pass in pointers to bad memory.)
	FileErrorFault FileError = 10
	// FileErrorLoop: too many levels of symbolic links were encountered in
	// looking up a file name. This often indicates a cycle of symbolic links.
	FileErrorLoop FileError = 11
	// FileErrorNospc: no space left on device; write operation on a file failed
	// because the disk is full.
	FileErrorNospc FileError = 12
	// FileErrorNomem: no memory available. The system cannot allocate more
	// virtual memory because its capacity is full.
	FileErrorNomem FileError = 13
	// FileErrorMfile: the current process has too many files open and can't
	// open any more. Duplicate descriptors do count toward this limit.
	FileErrorMfile FileError = 14
	// FileErrorNfile: there are too many distinct file openings in the entire
	// system.
	FileErrorNfile FileError = 15
	// FileErrorBadf: bad file descriptor; for example, I/O on a descriptor that
	// has been closed or reading from a descriptor open only for writing (or
	// vice versa).
	FileErrorBadf FileError = 16
	// FileErrorInval: invalid argument. This is used to indicate various kinds
	// of problems with passing the wrong argument to a library function.
	FileErrorInval FileError = 17
	// FileErrorPipe: broken pipe; there is no process reading from the other
	// end of a pipe. Every library function that returns this error code also
	// generates a 'SIGPIPE' signal; this signal terminates the program if not
	// handled or blocked. Thus, your program will never actually see this code
	// unless it has handled or blocked 'SIGPIPE'.
	FileErrorPipe FileError = 18
	// FileErrorAgain: resource temporarily unavailable; the call might work if
	// you try again later.
	FileErrorAgain FileError = 19
	// FileErrorIntr: interrupted function call; an asynchronous signal occurred
	// and prevented completion of the call. When this happens, you should try
	// the call again.
	FileErrorIntr FileError = 20
	// FileErrorIO: input/output error; usually used for physical read or write
	// errors. i.e. the disk or other physical device hardware is returning
	// errors.
	FileErrorIO FileError = 21
	// FileErrorPerm: operation not permitted; only the owner of the file (or
	// other resource) or processes with special privileges can perform the
	// operation.
	FileErrorPerm FileError = 22
	// FileErrorNosys: function not implemented; this indicates that the system
	// is missing some functionality.
	FileErrorNosys FileError = 23
	// FileErrorFailed does not correspond to a UNIX error code; this is the
	// standard "failed for unspecified reason" error code present in all
	// #GError error code enumerations. Returned if no specific code applies.
	FileErrorFailed FileError = 24
)

// IOChannelError: error codes returned by OChannel operations.
type IOChannelError int

const (
	// IOChannelErrorFbig: file too large.
	IOChannelErrorFbig IOChannelError = 0
	// IOChannelErrorInval: invalid argument.
	IOChannelErrorInval IOChannelError = 1
	// IOChannelErrorIO: IO error.
	IOChannelErrorIO IOChannelError = 2
	// IOChannelErrorIsdir: file is a directory.
	IOChannelErrorIsdir IOChannelError = 3
	// IOChannelErrorNospc: no space left on device.
	IOChannelErrorNospc IOChannelError = 4
	// IOChannelErrorNxio: no such device or address.
	IOChannelErrorNxio IOChannelError = 5
	// IOChannelErrorOverflow: value too large for defined datatype.
	IOChannelErrorOverflow IOChannelError = 6
	// IOChannelErrorPipe: broken pipe.
	IOChannelErrorPipe IOChannelError = 7
	// IOChannelErrorFailed: some other error.
	IOChannelErrorFailed IOChannelError = 8
)

// IOError is only used by the deprecated functions g_io_channel_read(),
// g_io_channel_write(), and g_io_channel_seek().
type IOError int

const (
	// IOErrorNone: no error
	IOErrorNone IOError = 0
	// IOErrorAgain: an EAGAIN error occurred
	IOErrorAgain IOError = 1
	// IOErrorInval: an EINVAL error occurred
	IOErrorInval IOError = 2
	// IOErrorUnknown: another error occurred
	IOErrorUnknown IOError = 3
)

// IOStatus statuses returned by most of the OFuncs functions.
type IOStatus int

const (
	// IOStatusError: an error occurred.
	IOStatusError IOStatus = 0
	// IOStatusNormal: success.
	IOStatusNormal IOStatus = 1
	// IOStatusEOF: end of file.
	IOStatusEOF IOStatus = 2
	// IOStatusAgain: resource temporarily unavailable.
	IOStatusAgain IOStatus = 3
)

// KeyFileError: error codes returned by key file parsing.
type KeyFileError int

const (
	// KeyFileErrorUnknownEncoding: the text being parsed was in an unknown
	// encoding
	KeyFileErrorUnknownEncoding KeyFileError = 0
	// KeyFileErrorParse: document was ill-formed
	KeyFileErrorParse KeyFileError = 1
	// KeyFileErrorNotFound: the file was not found
	KeyFileErrorNotFound KeyFileError = 2
	// KeyFileErrorKeyNotFound: a requested key was not found
	KeyFileErrorKeyNotFound KeyFileError = 3
	// KeyFileErrorGroupNotFound: a requested group was not found
	KeyFileErrorGroupNotFound KeyFileError = 4
	// KeyFileErrorInvalidValue: a value could not be parsed
	KeyFileErrorInvalidValue KeyFileError = 5
)

// LogWriterOutput: return values from WriterFuncs to indicate whether the given
// log entry was successfully handled by the writer, or whether there was an
// error in handling it (and hence a fallback writer should be used).
//
// If a WriterFunc ignores a log entry, it should return G_LOG_WRITER_HANDLED.
type LogWriterOutput int

const (
	// LogWriterOutputHandled: log writer has handled the log entry.
	LogWriterOutputHandled LogWriterOutput = 1
	// LogWriterOutputUnhandled: log writer could not handle the log entry.
	LogWriterOutputUnhandled LogWriterOutput = 0
)

// MarkupError: error codes returned by markup parsing.
type MarkupError int

const (
	// MarkupErrorBadUTF8: text being parsed was not valid UTF-8
	MarkupErrorBadUTF8 MarkupError = 0
	// MarkupErrorEmpty: document contained nothing, or only whitespace
	MarkupErrorEmpty MarkupError = 1
	// MarkupErrorParse: document was ill-formed
	MarkupErrorParse MarkupError = 2
	// MarkupErrorUnknownElement: error should be set by Parser functions;
	// element wasn't known
	MarkupErrorUnknownElement MarkupError = 3
	// MarkupErrorUnknownAttribute: error should be set by Parser functions;
	// attribute wasn't known
	MarkupErrorUnknownAttribute MarkupError = 4
	// MarkupErrorInvalidContent: error should be set by Parser functions;
	// content was invalid
	MarkupErrorInvalidContent MarkupError = 5
	// MarkupErrorMissingAttribute: error should be set by Parser functions; a
	// required attribute was missing
	MarkupErrorMissingAttribute MarkupError = 6
)

// NormalizeMode defines how a Unicode string is transformed in a canonical
// form, standardizing such issues as whether a character with an accent is
// represented as a base character and combining accent or as a single
// precomposed character. Unicode strings should generally be normalized before
// comparing them.
type NormalizeMode int

const (
	// NormalizeModeDefault: standardize differences that do not affect the text
	// content, such as the above-mentioned accent representation
	NormalizeModeDefault NormalizeMode = 0
	// NormalizeModeNFD: another name for G_NORMALIZE_DEFAULT
	NormalizeModeNFD NormalizeMode = 0
	// NormalizeModeDefaultCompose: like G_NORMALIZE_DEFAULT, but with composed
	// forms rather than a maximally decomposed form
	NormalizeModeDefaultCompose NormalizeMode = 1
	// NormalizeModeNFC: another name for G_NORMALIZE_DEFAULT_COMPOSE
	NormalizeModeNFC NormalizeMode = 1
	// NormalizeModeAll: beyond G_NORMALIZE_DEFAULT also standardize the
	// "compatibility" characters in Unicode, such as SUPERSCRIPT THREE to the
	// standard forms (in this case DIGIT THREE). Formatting information may be
	// lost but for most text operations such characters should be considered
	// the same
	NormalizeModeAll NormalizeMode = 2
	// NormalizeModeNFKD: another name for G_NORMALIZE_ALL
	NormalizeModeNFKD NormalizeMode = 2
	// NormalizeModeAllCompose: like G_NORMALIZE_ALL, but with composed forms
	// rather than a maximally decomposed form
	NormalizeModeAllCompose NormalizeMode = 3
	// NormalizeModeNFKC: another name for G_NORMALIZE_ALL_COMPOSE
	NormalizeModeNFKC NormalizeMode = 3
)

// NumberParserError: error codes returned by functions converting a string to a
// number.
type NumberParserError int

const (
	// NumberParserErrorInvalid: string was not a valid number.
	NumberParserErrorInvalid NumberParserError = 0
	// NumberParserErrorOutOfBounds: string was a number, but out of bounds.
	NumberParserErrorOutOfBounds NumberParserError = 1
)

// OnceStatus: the possible statuses of a one-time initialization function
// controlled by a #GOnce struct.
type OnceStatus int

const (
	// OnceStatusNotcalled: the function has not been called yet.
	OnceStatusNotcalled OnceStatus = 0
	// OnceStatusProgress: the function call is currently in progress.
	OnceStatusProgress OnceStatus = 1
	// OnceStatusReady: the function has been called.
	OnceStatusReady OnceStatus = 2
)

// OptionArg: the Arg enum values determine which type of extra argument the
// options expect to find. If an option expects an extra argument, it can be
// specified in several ways; with a short option: `-x arg`, with a long option:
// `--name arg` or combined in a single argument: `--name=arg`.
type OptionArg int

const (
	// OptionArgNone: no extra argument. This is useful for simple flags.
	OptionArgNone OptionArg = 0
	// OptionArgString: the option takes a UTF-8 string argument.
	OptionArgString OptionArg = 1
	// OptionArgInt: the option takes an integer argument.
	OptionArgInt OptionArg = 2
	// OptionArgCallback: the option provides a callback (of type ArgFunc) to
	// parse the extra argument.
	OptionArgCallback OptionArg = 3
	// OptionArgFilename: the option takes a filename as argument, which will be
	// in the GLib filename encoding rather than UTF-8.
	OptionArgFilename OptionArg = 4
	// OptionArgStringArray: the option takes a string argument, multiple uses
	// of the option are collected into an array of strings.
	OptionArgStringArray OptionArg = 5
	// OptionArgFilenameArray: the option takes a filename as argument, multiple
	// uses of the option are collected into an array of strings.
	OptionArgFilenameArray OptionArg = 6
	// OptionArgDouble: the option takes a double argument. The argument can be
	// formatted either for the user's locale or for the "C" locale. Since 2.12
	OptionArgDouble OptionArg = 7
	// OptionArgInt64: the option takes a 64-bit integer. Like G_OPTION_ARG_INT
	// but for larger numbers. The number can be in decimal base, or in
	// hexadecimal (when prefixed with `0x`, for example, `0xffffffff`). Since
	// 2.12
	OptionArgInt64 OptionArg = 8
)

// OptionError: error codes returned by option parsing.
type OptionError int

const (
	// OptionErrorUnknownOption: an option was not known to the parser. This
	// error will only be reported, if the parser hasn't been instructed to
	// ignore unknown options, see
	// g_option_context_set_ignore_unknown_options().
	OptionErrorUnknownOption OptionError = 0
	// OptionErrorBadValue: a value couldn't be parsed.
	OptionErrorBadValue OptionError = 1
	// OptionErrorFailed: a ArgFunc callback failed.
	OptionErrorFailed OptionError = 2
)

// RegexError: error codes returned by regular expressions functions.
type RegexError int

const (
	// RegexErrorCompile: compilation of the regular expression failed.
	RegexErrorCompile RegexError = 0
	// RegexErrorOptimize: optimization of the regular expression failed.
	RegexErrorOptimize RegexError = 1
	// RegexErrorReplace: replacement failed due to an ill-formed replacement
	// string.
	RegexErrorReplace RegexError = 2
	// RegexErrorMatch: the match process failed.
	RegexErrorMatch RegexError = 3
	// RegexErrorInternal: internal error of the regular expression engine.
	// Since 2.16
	RegexErrorInternal RegexError = 4
	// RegexErrorStrayBackslash: "\\" at end of pattern. Since 2.16
	RegexErrorStrayBackslash RegexError = 101
	// RegexErrorMissingControlChar: "\\c" at end of pattern. Since 2.16
	RegexErrorMissingControlChar RegexError = 102
	// RegexErrorUnrecognizedEscape: unrecognized character follows "\\". Since
	// 2.16
	RegexErrorUnrecognizedEscape RegexError = 103
	// RegexErrorQuantifiersOutOfOrder numbers out of order in "{}" quantifier.
	// Since 2.16
	RegexErrorQuantifiersOutOfOrder RegexError = 104
	// RegexErrorQuantifierTooBig: number too big in "{}" quantifier. Since 2.16
	RegexErrorQuantifierTooBig RegexError = 105
	// RegexErrorUnterminatedCharacterClass: missing terminating "]" for
	// character class. Since 2.16
	RegexErrorUnterminatedCharacterClass RegexError = 106
	// RegexErrorInvalidEscapeInCharacterClass: invalid escape sequence in
	// character class. Since 2.16
	RegexErrorInvalidEscapeInCharacterClass RegexError = 107
	// RegexErrorRangeOutOfOrder: range out of order in character class. Since
	// 2.16
	RegexErrorRangeOutOfOrder RegexError = 108
	// RegexErrorNothingToRepeat: nothing to repeat. Since 2.16
	RegexErrorNothingToRepeat RegexError = 109
	// RegexErrorUnrecognizedCharacter: unrecognized character after "(?", "(?<"
	// or "(?P". Since 2.16
	RegexErrorUnrecognizedCharacter RegexError = 112
	// RegexErrorPosixNamedClassOutsideClass: POSIX named classes are supported
	// only within a class. Since 2.16
	RegexErrorPosixNamedClassOutsideClass RegexError = 113
	// RegexErrorUnmatchedParenthesis: missing terminating ")" or ")" without
	// opening "(". Since 2.16
	RegexErrorUnmatchedParenthesis RegexError = 114
	// RegexErrorInexistentSubpatternReference: reference to non-existent
	// subpattern. Since 2.16
	RegexErrorInexistentSubpatternReference RegexError = 115
	// RegexErrorUnterminatedComment: missing terminating ")" after comment.
	// Since 2.16
	RegexErrorUnterminatedComment RegexError = 118
	// RegexErrorExpressionTooLarge: regular expression too large. Since 2.16
	RegexErrorExpressionTooLarge RegexError = 120
	// RegexErrorMemoryError: failed to get memory. Since 2.16
	RegexErrorMemoryError RegexError = 121
	// RegexErrorVariableLengthLookbehind: lookbehind assertion is not fixed
	// length. Since 2.16
	RegexErrorVariableLengthLookbehind RegexError = 125
	// RegexErrorMalformedCondition: malformed number or name after "(?(". Since
	// 2.16
	RegexErrorMalformedCondition RegexError = 126
	// RegexErrorTooManyConditionalBranches: conditional group contains more
	// than two branches. Since 2.16
	RegexErrorTooManyConditionalBranches RegexError = 127
	// RegexErrorAssertionExpected: assertion expected after "(?(". Since 2.16
	RegexErrorAssertionExpected RegexError = 128
	// RegexErrorUnknownPosixClassName: unknown POSIX class name. Since 2.16
	RegexErrorUnknownPosixClassName RegexError = 130
	// RegexErrorPosixCollatingElementsNotSupported: POSIX collating elements
	// are not supported. Since 2.16
	RegexErrorPosixCollatingElementsNotSupported RegexError = 131
	// RegexErrorHexCodeTooLarge: character value in "\\x{...}" sequence is too
	// large. Since 2.16
	RegexErrorHexCodeTooLarge RegexError = 134
	// RegexErrorInvalidCondition: invalid condition "(?(0)". Since 2.16
	RegexErrorInvalidCondition RegexError = 135
	// RegexErrorSingleByteMatchInLookbehind: \\C not allowed in lookbehind
	// assertion. Since 2.16
	RegexErrorSingleByteMatchInLookbehind RegexError = 136
	// RegexErrorInfiniteLoop: recursive call could loop indefinitely. Since
	// 2.16
	RegexErrorInfiniteLoop RegexError = 140
	// RegexErrorMissingSubpatternNameTerminator: missing terminator in
	// subpattern name. Since 2.16
	RegexErrorMissingSubpatternNameTerminator RegexError = 142
	// RegexErrorDuplicateSubpatternName: two named subpatterns have the same
	// name. Since 2.16
	RegexErrorDuplicateSubpatternName RegexError = 143
	// RegexErrorMalformedProperty: malformed "\\P" or "\\p" sequence. Since
	// 2.16
	RegexErrorMalformedProperty RegexError = 146
	// RegexErrorUnknownProperty: unknown property name after "\\P" or "\\p".
	// Since 2.16
	RegexErrorUnknownProperty RegexError = 147
	// RegexErrorSubpatternNameTooLong: subpattern name is too long (maximum 32
	// characters). Since 2.16
	RegexErrorSubpatternNameTooLong RegexError = 148
	// RegexErrorTooManySubpatterns: too many named subpatterns (maximum
	// 10,000). Since 2.16
	RegexErrorTooManySubpatterns RegexError = 149
	// RegexErrorInvalidOctalValue: octal value is greater than "\\377". Since
	// 2.16
	RegexErrorInvalidOctalValue RegexError = 151
	// RegexErrorTooManyBranchesInDefine: "DEFINE" group contains more than one
	// branch. Since 2.16
	RegexErrorTooManyBranchesInDefine RegexError = 154
	// RegexErrorDefineRepetion: repeating a "DEFINE" group is not allowed. This
	// error is never raised. Since: 2.16 Deprecated: 2.34
	RegexErrorDefineRepetion RegexError = 155
	// RegexErrorInconsistentNewlineOptions: inconsistent newline options. Since
	// 2.16
	RegexErrorInconsistentNewlineOptions RegexError = 156
	// RegexErrorMissingBackReference: "\\g" is not followed by a braced,
	// angle-bracketed, or quoted name or number, or by a plain number. Since:
	// 2.16
	RegexErrorMissingBackReference RegexError = 157
	// RegexErrorInvalidRelativeReference: relative reference must not be zero.
	// Since: 2.34
	RegexErrorInvalidRelativeReference RegexError = 158
	// RegexErrorBacktrackingControlVerbArgumentForbidden: the backtracing
	// control verb used does not allow an argument. Since: 2.34
	RegexErrorBacktrackingControlVerbArgumentForbidden RegexError = 159
	// RegexErrorUnknownBacktrackingControlVerb: unknown backtracing control
	// verb. Since: 2.34
	RegexErrorUnknownBacktrackingControlVerb RegexError = 160
	// RegexErrorNumberTooBig: number is too big in escape sequence. Since: 2.34
	RegexErrorNumberTooBig RegexError = 161
	// RegexErrorMissingSubpatternName: missing subpattern name. Since: 2.34
	RegexErrorMissingSubpatternName RegexError = 162
	// RegexErrorMissingDigit: missing digit. Since 2.34
	RegexErrorMissingDigit RegexError = 163
	// RegexErrorInvalidDataCharacter: in JavaScript compatibility mode, "[" is
	// an invalid data character. Since: 2.34
	RegexErrorInvalidDataCharacter RegexError = 164
	// RegexErrorExtraSubpatternName: different names for subpatterns of the
	// same number are not allowed. Since: 2.34
	RegexErrorExtraSubpatternName RegexError = 165
	// RegexErrorBacktrackingControlVerbArgumentRequired: the backtracing
	// control verb requires an argument. Since: 2.34
	RegexErrorBacktrackingControlVerbArgumentRequired RegexError = 166
	// RegexErrorInvalidControlChar: "\\c" must be followed by an ASCII
	// character. Since: 2.34
	RegexErrorInvalidControlChar RegexError = 168
	// RegexErrorMissingName: "\\k" is not followed by a braced,
	// angle-bracketed, or quoted name. Since: 2.34
	RegexErrorMissingName RegexError = 169
	// RegexErrorNotSupportedInClass: "\\N" is not supported in a class. Since:
	// 2.34
	RegexErrorNotSupportedInClass RegexError = 171
	// RegexErrorTooManyForwardReferences: too many forward references. Since:
	// 2.34
	RegexErrorTooManyForwardReferences RegexError = 172
	// RegexErrorNameTooLong: the name is too long in "(*MARK)", "(*PRUNE)",
	// "(*SKIP)", or "(*THEN)". Since: 2.34
	RegexErrorNameTooLong RegexError = 175
	// RegexErrorCharacterValueTooLarge: the character value in the \\u sequence
	// is too large. Since: 2.34
	RegexErrorCharacterValueTooLarge RegexError = 176
)

// SeekType: an enumeration specifying the base position for a
// g_io_channel_seek_position() operation.
type SeekType int

const (
	// SeekTypeCur: the current position in the file.
	SeekTypeCur SeekType = 0
	// SeekTypeSet: the start of the file.
	SeekTypeSet SeekType = 1
	// SeekTypeEnd: the end of the file.
	SeekTypeEnd SeekType = 2
)

// ShellError: error codes returned by shell functions.
type ShellError int

const (
	// ShellErrorBadQuoting: mismatched or otherwise mangled quoting.
	ShellErrorBadQuoting ShellError = 0
	// ShellErrorEmptyString: string to be parsed was empty.
	ShellErrorEmptyString ShellError = 1
	// ShellErrorFailed: some other error.
	ShellErrorFailed ShellError = 2
)

type SliceConfig int

const (
	SliceConfigAlwaysMalloc SliceConfig = 1

	SliceConfigBypassMagazines SliceConfig = 2

	SliceConfigWorkingSetMsecs SliceConfig = 3

	SliceConfigColorIncrement SliceConfig = 4

	SliceConfigChunkSizes SliceConfig = 5

	SliceConfigContentionCounter SliceConfig = 6
)

// SpawnError: error codes returned by spawning processes.
type SpawnError int

const (
	// SpawnErrorFork: fork failed due to lack of memory.
	SpawnErrorFork SpawnError = 0
	// SpawnErrorRead: read or select on pipes failed.
	SpawnErrorRead SpawnError = 1
	// SpawnErrorChdir: changing to working directory failed.
	SpawnErrorChdir SpawnError = 2
	// SpawnErrorAcces: execv() returned `EACCES`
	SpawnErrorAcces SpawnError = 3
	// SpawnErrorPerm: execv() returned `EPERM`
	SpawnErrorPerm SpawnError = 4
	// SpawnErrorTooBig: execv() returned `E2BIG`
	SpawnErrorTooBig SpawnError = 5
	// SpawnError2Big: deprecated alias for G_SPAWN_ERROR_TOO_BIG (deprecated
	// since GLib 2.32)
	SpawnError2Big SpawnError = 5
	// SpawnErrorNoexec: execv() returned `ENOEXEC`
	SpawnErrorNoexec SpawnError = 6
	// SpawnErrorNametoolong: execv() returned `ENAMETOOLONG`
	SpawnErrorNametoolong SpawnError = 7
	// SpawnErrorNoent: execv() returned `ENOENT`
	SpawnErrorNoent SpawnError = 8
	// SpawnErrorNomem: execv() returned `ENOMEM`
	SpawnErrorNomem SpawnError = 9
	// SpawnErrorNotdir: execv() returned `ENOTDIR`
	SpawnErrorNotdir SpawnError = 10
	// SpawnErrorLoop: execv() returned `ELOOP`
	SpawnErrorLoop SpawnError = 11
	// SpawnErrorTxtbusy: execv() returned `ETXTBUSY`
	SpawnErrorTxtbusy SpawnError = 12
	// SpawnErrorIO: execv() returned `EIO`
	SpawnErrorIO SpawnError = 13
	// SpawnErrorNfile: execv() returned `ENFILE`
	SpawnErrorNfile SpawnError = 14
	// SpawnErrorMfile: execv() returned `EMFILE`
	SpawnErrorMfile SpawnError = 15
	// SpawnErrorInval: execv() returned `EINVAL`
	SpawnErrorInval SpawnError = 16
	// SpawnErrorIsdir: execv() returned `EISDIR`
	SpawnErrorIsdir SpawnError = 17
	// SpawnErrorLibbad: execv() returned `ELIBBAD`
	SpawnErrorLibbad SpawnError = 18
	// SpawnErrorFailed: some other fatal failure, `error->message` should
	// explain.
	SpawnErrorFailed SpawnError = 19
)

// TestFileType: the type of file to return the filename for, when used with
// g_test_build_filename().
//
// These two options correspond rather directly to the 'dist' and 'built'
// terminology that automake uses and are explicitly used to distinguish between
// the 'srcdir' and 'builddir' being separate. All files in your project should
// either be dist (in the `EXTRA_DIST` or `dist_schema_DATA` sense, in which
// case they will always be in the srcdir) or built (in the `BUILT_SOURCES`
// sense, in which case they will always be in the builddir).
//
// Note: as a general rule of automake, files that are generated only as part of
// the build-from-git process (but then are distributed with the tarball) always
// go in srcdir (even if doing a srcdir != builddir build from git) and are
// considered as distributed files.
type TestFileType int

const (
	// TestFileTypeDist: a file that was included in the distribution tarball
	TestFileTypeDist TestFileType = 0
	// TestFileTypeBuilt: a file that was built on the compiling machine
	TestFileTypeBuilt TestFileType = 1
)

type TestLogType int

const (
	TestLogTypeNone TestLogType = 0

	TestLogTypeError TestLogType = 1

	TestLogTypeStartBinary TestLogType = 2

	TestLogTypeListCase TestLogType = 3

	TestLogTypeSkipCase TestLogType = 4

	TestLogTypeStartCase TestLogType = 5

	TestLogTypeStopCase TestLogType = 6

	TestLogTypeMinResult TestLogType = 7

	TestLogTypeMaxResult TestLogType = 8

	TestLogTypeMessage TestLogType = 9

	TestLogTypeStartSuite TestLogType = 10

	TestLogTypeStopSuite TestLogType = 11
)

type TestResult int

const (
	TestResultSuccess TestResult = 0

	TestResultSkipped TestResult = 1

	TestResultFailure TestResult = 2

	TestResultIncomplete TestResult = 3
)

// ThreadError: possible errors of thread related functions.
type ThreadError int

const (
	// ThreadErrorThreadErrorAgain: a thread couldn't be created due to resource
	// shortage. Try again later.
	ThreadErrorThreadErrorAgain ThreadError = 0
)

// TimeType disambiguates a given time in two ways.
//
// First, specifies if the given time is in universal or local time.
//
// Second, if the time is in local time, specifies if it is local standard time
// or local daylight time. This is important for the case where the same local
// time occurs twice (during daylight savings time transitions, for example).
type TimeType int

const (
	// TimeTypeStandard: the time is in local standard time
	TimeTypeStandard TimeType = 0
	// TimeTypeDaylight: the time is in local daylight time
	TimeTypeDaylight TimeType = 1
	// TimeTypeUniversal: the time is in UTC
	TimeTypeUniversal TimeType = 2
)

// TokenType: the possible types of token returned from each
// g_scanner_get_next_token() call.
type TokenType int

const (
	// TokenTypeEOF: the end of the file
	TokenTypeEOF TokenType = 0
	// TokenTypeLeftParen: a '(' character
	TokenTypeLeftParen TokenType = 40
	// TokenTypeRightParen: a ')' character
	TokenTypeRightParen TokenType = 41
	// TokenTypeLeftCurly: a '{' character
	TokenTypeLeftCurly TokenType = 123
	// TokenTypeRightCurly: a '}' character
	TokenTypeRightCurly TokenType = 125
	// TokenTypeLeftBrace: a '[' character
	TokenTypeLeftBrace TokenType = 91
	// TokenTypeRightBrace: a ']' character
	TokenTypeRightBrace TokenType = 93
	// TokenTypeEqualSign: a '=' character
	TokenTypeEqualSign TokenType = 61
	// TokenTypeComma: a ',' character
	TokenTypeComma TokenType = 44
	// TokenTypeNone: not a token
	TokenTypeNone TokenType = 256
	// TokenTypeError: an error occurred
	TokenTypeError TokenType = 257
	// TokenTypeChar: a character
	TokenTypeChar TokenType = 258
	// TokenTypeBinary: a binary integer
	TokenTypeBinary TokenType = 259
	// TokenTypeOctal: an octal integer
	TokenTypeOctal TokenType = 260
	// TokenTypeInt: an integer
	TokenTypeInt TokenType = 261
	// TokenTypeHex: a hex integer
	TokenTypeHex TokenType = 262
	// TokenTypeFloat: a floating point number
	TokenTypeFloat TokenType = 263
	// TokenTypeString: a string
	TokenTypeString TokenType = 264
	// TokenTypeSymbol: a symbol
	TokenTypeSymbol TokenType = 265
	// TokenTypeIdentifier: an identifier
	TokenTypeIdentifier TokenType = 266
	// TokenTypeIdentifierNull: a null identifier
	TokenTypeIdentifierNull TokenType = 267
	// TokenTypeCommentSingle: one line comment
	TokenTypeCommentSingle TokenType = 268
	// TokenTypeCommentMulti: multi line comment
	TokenTypeCommentMulti TokenType = 269
)

// TraverseType specifies the type of traversal performed by g_tree_traverse(),
// g_node_traverse() and g_node_find(). The different orders are illustrated
// here: - In order: A, B, C, D, E, F, G, H, I !
// (Sorted_binary_tree_inorder.svg) - Pre order: F, B, A, D, C, E, G, I, H !
// (Sorted_binary_tree_preorder.svg) - Post order: A, C, E, D, B, H, I, G, F !
// (Sorted_binary_tree_postorder.svg) - Level order: F, B, G, A, D, I, C, E, H !
// (Sorted_binary_tree_breadth-first_traversal.svg)
type TraverseType int

const (
	// TraverseTypeInOrder vists a node's left child first, then the node
	// itself, then its right child. This is the one to use if you want the
	// output sorted according to the compare function.
	TraverseTypeInOrder TraverseType = 0
	// TraverseTypePreOrder visits a node, then its children.
	TraverseTypePreOrder TraverseType = 1
	// TraverseTypePostOrder visits the node's children, then the node itself.
	TraverseTypePostOrder TraverseType = 2
	// TraverseTypeLevelOrder is not implemented for [balanced binary
	// trees][glib-Balanced-Binary-Trees]. For [n-ary trees][glib-N-ary-Trees],
	// it vists the root node first, then its children, then its grandchildren,
	// and so on. Note that this is less efficient than the other orders.
	TraverseTypeLevelOrder TraverseType = 3
)

// UnicodeBreakType: these are the possible line break classifications.
//
// Since new unicode versions may add new types here, applications should be
// ready to handle unknown values. They may be regarded as
// G_UNICODE_BREAK_UNKNOWN.
//
// See Unicode Line Breaking Algorithm
// (http://www.unicode.org/unicode/reports/tr14/).
type UnicodeBreakType int

const (
	// UnicodeBreakTypeMandatory: mandatory Break (BK)
	UnicodeBreakTypeMandatory UnicodeBreakType = 0
	// UnicodeBreakTypeCarriageReturn: carriage Return (CR)
	UnicodeBreakTypeCarriageReturn UnicodeBreakType = 1
	// UnicodeBreakTypeLineFeed: line Feed (LF)
	UnicodeBreakTypeLineFeed UnicodeBreakType = 2
	// UnicodeBreakTypeCombiningMark: attached Characters and Combining Marks
	// (CM)
	UnicodeBreakTypeCombiningMark UnicodeBreakType = 3
	// UnicodeBreakTypeSurrogate surrogates (SG)
	UnicodeBreakTypeSurrogate UnicodeBreakType = 4
	// UnicodeBreakTypeZeroWidthSpace: zero Width Space (ZW)
	UnicodeBreakTypeZeroWidthSpace UnicodeBreakType = 5
	// UnicodeBreakTypeInseparable: inseparable (IN)
	UnicodeBreakTypeInseparable UnicodeBreakType = 6
	// UnicodeBreakTypeNonBreakingGlue: non-breaking ("Glue") (GL)
	UnicodeBreakTypeNonBreakingGlue UnicodeBreakType = 7
	// UnicodeBreakTypeContingent: contingent Break Opportunity (CB)
	UnicodeBreakTypeContingent UnicodeBreakType = 8
	// UnicodeBreakTypeSpace: space (SP)
	UnicodeBreakTypeSpace UnicodeBreakType = 9
	// UnicodeBreakTypeAfter: break Opportunity After (BA)
	UnicodeBreakTypeAfter UnicodeBreakType = 10
	// UnicodeBreakTypeBefore: break Opportunity Before (BB)
	UnicodeBreakTypeBefore UnicodeBreakType = 11
	// UnicodeBreakTypeBeforeAndAfter: break Opportunity Before and After (B2)
	UnicodeBreakTypeBeforeAndAfter UnicodeBreakType = 12
	// UnicodeBreakTypeHyphen: hyphen (HY)
	UnicodeBreakTypeHyphen UnicodeBreakType = 13
	// UnicodeBreakTypeNonStarter: nonstarter (NS)
	UnicodeBreakTypeNonStarter UnicodeBreakType = 14
	// UnicodeBreakTypeOpenPunctuation: opening Punctuation (OP)
	UnicodeBreakTypeOpenPunctuation UnicodeBreakType = 15
	// UnicodeBreakTypeClosePunctuation: closing Punctuation (CL)
	UnicodeBreakTypeClosePunctuation UnicodeBreakType = 16
	// UnicodeBreakTypeQuotation ambiguous Quotation (QU)
	UnicodeBreakTypeQuotation UnicodeBreakType = 17
	// UnicodeBreakTypeExclamation: exclamation/Interrogation (EX)
	UnicodeBreakTypeExclamation UnicodeBreakType = 18
	// UnicodeBreakTypeIdeographic: ideographic (ID)
	UnicodeBreakTypeIdeographic UnicodeBreakType = 19
	// UnicodeBreakTypeNumeric: numeric (NU)
	UnicodeBreakTypeNumeric UnicodeBreakType = 20
	// UnicodeBreakTypeInfixSeparator: infix Separator (Numeric) (IS)
	UnicodeBreakTypeInfixSeparator UnicodeBreakType = 21
	// UnicodeBreakTypeSymbol symbols Allowing Break After (SY)
	UnicodeBreakTypeSymbol UnicodeBreakType = 22
	// UnicodeBreakTypeAlphabetic: ordinary Alphabetic and Symbol Characters
	// (AL)
	UnicodeBreakTypeAlphabetic UnicodeBreakType = 23
	// UnicodeBreakTypePrefix: prefix (Numeric) (PR)
	UnicodeBreakTypePrefix UnicodeBreakType = 24
	// UnicodeBreakTypePostfix: postfix (Numeric) (PO)
	UnicodeBreakTypePostfix UnicodeBreakType = 25
	// UnicodeBreakTypeComplexContext: complex Content Dependent (South East
	// Asian) (SA)
	UnicodeBreakTypeComplexContext UnicodeBreakType = 26
	// UnicodeBreakTypeAmbiguous ambiguous (Alphabetic or Ideographic) (AI)
	UnicodeBreakTypeAmbiguous UnicodeBreakType = 27
	// UnicodeBreakTypeUnknown: unknown (XX)
	UnicodeBreakTypeUnknown UnicodeBreakType = 28
	// UnicodeBreakTypeNextLine: next Line (NL)
	UnicodeBreakTypeNextLine UnicodeBreakType = 29
	// UnicodeBreakTypeWordJoiner: word Joiner (WJ)
	UnicodeBreakTypeWordJoiner UnicodeBreakType = 30
	// UnicodeBreakTypeHangulLJamo: hangul L Jamo (JL)
	UnicodeBreakTypeHangulLJamo UnicodeBreakType = 31
	// UnicodeBreakTypeHangulVJamo: hangul V Jamo (JV)
	UnicodeBreakTypeHangulVJamo UnicodeBreakType = 32
	// UnicodeBreakTypeHangulTJamo: hangul T Jamo (JT)
	UnicodeBreakTypeHangulTJamo UnicodeBreakType = 33
	// UnicodeBreakTypeHangulLvSyllable: hangul LV Syllable (H2)
	UnicodeBreakTypeHangulLvSyllable UnicodeBreakType = 34
	// UnicodeBreakTypeHangulLvtSyllable: hangul LVT Syllable (H3)
	UnicodeBreakTypeHangulLvtSyllable UnicodeBreakType = 35
	// UnicodeBreakTypeCloseParanthesis: closing Parenthesis (CP). Since 2.28
	UnicodeBreakTypeCloseParanthesis UnicodeBreakType = 36
	// UnicodeBreakTypeConditionalJapaneseStarter: conditional Japanese Starter
	// (CJ). Since: 2.32
	UnicodeBreakTypeConditionalJapaneseStarter UnicodeBreakType = 37
	// UnicodeBreakTypeHebrewLetter: hebrew Letter (HL). Since: 2.32
	UnicodeBreakTypeHebrewLetter UnicodeBreakType = 38
	// UnicodeBreakTypeRegionalIndicator: regional Indicator (RI). Since: 2.36
	UnicodeBreakTypeRegionalIndicator UnicodeBreakType = 39
	// UnicodeBreakTypeEmojiBase: emoji Base (EB). Since: 2.50
	UnicodeBreakTypeEmojiBase UnicodeBreakType = 40
	// UnicodeBreakTypeEmojiModifier: emoji Modifier (EM). Since: 2.50
	UnicodeBreakTypeEmojiModifier UnicodeBreakType = 41
	// UnicodeBreakTypeZeroWidthJoiner: zero Width Joiner (ZWJ). Since: 2.50
	UnicodeBreakTypeZeroWidthJoiner UnicodeBreakType = 42
)

// UnicodeScript: the Script enumeration identifies different writing systems.
// The values correspond to the names as defined in the Unicode standard. The
// enumeration has been added in GLib 2.14, and is interchangeable with Script.
//
// Note that new types may be added in the future. Applications should be ready
// to handle unknown values. See Unicode Standard Annex #24: Script names
// (http://www.unicode.org/reports/tr24/).
type UnicodeScript int

const (
	// UnicodeScriptInvalidCode: a value never returned from
	// g_unichar_get_script()
	UnicodeScriptInvalidCode UnicodeScript = -1
	// UnicodeScriptCommon: a character used by multiple different scripts
	UnicodeScriptCommon UnicodeScript = 0
	// UnicodeScriptInherited: a mark glyph that takes its script from the base
	// glyph to which it is attached
	UnicodeScriptInherited UnicodeScript = 1
	// UnicodeScriptArabic: arabic
	UnicodeScriptArabic UnicodeScript = 2
	// UnicodeScriptArmenian: armenian
	UnicodeScriptArmenian UnicodeScript = 3
	// UnicodeScriptBengali: bengali
	UnicodeScriptBengali UnicodeScript = 4
	// UnicodeScriptBopomofo: bopomofo
	UnicodeScriptBopomofo UnicodeScript = 5
	// UnicodeScriptCherokee: cherokee
	UnicodeScriptCherokee UnicodeScript = 6
	// UnicodeScriptCoptic: coptic
	UnicodeScriptCoptic UnicodeScript = 7
	// UnicodeScriptCyrillic: cyrillic
	UnicodeScriptCyrillic UnicodeScript = 8
	// UnicodeScriptDeseret: deseret
	UnicodeScriptDeseret UnicodeScript = 9
	// UnicodeScriptDevanagari: devanagari
	UnicodeScriptDevanagari UnicodeScript = 10
	// UnicodeScriptEthiopic: ethiopic
	UnicodeScriptEthiopic UnicodeScript = 11
	// UnicodeScriptGeorgian: georgian
	UnicodeScriptGeorgian UnicodeScript = 12
	// UnicodeScriptGothic: gothic
	UnicodeScriptGothic UnicodeScript = 13
	// UnicodeScriptGreek: greek
	UnicodeScriptGreek UnicodeScript = 14
	// UnicodeScriptGujarati: gujarati
	UnicodeScriptGujarati UnicodeScript = 15
	// UnicodeScriptGurmukhi: gurmukhi
	UnicodeScriptGurmukhi UnicodeScript = 16
	// UnicodeScriptHan: han
	UnicodeScriptHan UnicodeScript = 17
	// UnicodeScriptHangul: hangul
	UnicodeScriptHangul UnicodeScript = 18
	// UnicodeScriptHebrew: hebrew
	UnicodeScriptHebrew UnicodeScript = 19
	// UnicodeScriptHiragana: hiragana
	UnicodeScriptHiragana UnicodeScript = 20
	// UnicodeScriptKannada: kannada
	UnicodeScriptKannada UnicodeScript = 21
	// UnicodeScriptKatakana: katakana
	UnicodeScriptKatakana UnicodeScript = 22
	// UnicodeScriptKhmer: khmer
	UnicodeScriptKhmer UnicodeScript = 23
	// UnicodeScriptLao: lao
	UnicodeScriptLao UnicodeScript = 24
	// UnicodeScriptLatin: latin
	UnicodeScriptLatin UnicodeScript = 25
	// UnicodeScriptMalayalam: malayalam
	UnicodeScriptMalayalam UnicodeScript = 26
	// UnicodeScriptMongolian: mongolian
	UnicodeScriptMongolian UnicodeScript = 27
	// UnicodeScriptMyanmar: myanmar
	UnicodeScriptMyanmar UnicodeScript = 28
	// UnicodeScriptOgham: ogham
	UnicodeScriptOgham UnicodeScript = 29
	// UnicodeScriptOldItalic: old Italic
	UnicodeScriptOldItalic UnicodeScript = 30
	// UnicodeScriptOriya: oriya
	UnicodeScriptOriya UnicodeScript = 31
	// UnicodeScriptRunic: runic
	UnicodeScriptRunic UnicodeScript = 32
	// UnicodeScriptSinhala: sinhala
	UnicodeScriptSinhala UnicodeScript = 33
	// UnicodeScriptSyriac: syriac
	UnicodeScriptSyriac UnicodeScript = 34
	// UnicodeScriptTamil: tamil
	UnicodeScriptTamil UnicodeScript = 35
	// UnicodeScriptTelugu: telugu
	UnicodeScriptTelugu UnicodeScript = 36
	// UnicodeScriptThaana: thaana
	UnicodeScriptThaana UnicodeScript = 37
	// UnicodeScriptThai: thai
	UnicodeScriptThai UnicodeScript = 38
	// UnicodeScriptTibetan: tibetan
	UnicodeScriptTibetan UnicodeScript = 39
	// UnicodeScriptCanadianAboriginal: canadian Aboriginal
	UnicodeScriptCanadianAboriginal UnicodeScript = 40
	// UnicodeScriptYi: yi
	UnicodeScriptYi UnicodeScript = 41
	// UnicodeScriptTagalog: tagalog
	UnicodeScriptTagalog UnicodeScript = 42
	// UnicodeScriptHanunoo: hanunoo
	UnicodeScriptHanunoo UnicodeScript = 43
	// UnicodeScriptBuhid: buhid
	UnicodeScriptBuhid UnicodeScript = 44
	// UnicodeScriptTagbanwa: tagbanwa
	UnicodeScriptTagbanwa UnicodeScript = 45
	// UnicodeScriptBraille: braille
	UnicodeScriptBraille UnicodeScript = 46
	// UnicodeScriptCypriot: cypriot
	UnicodeScriptCypriot UnicodeScript = 47
	// UnicodeScriptLimbu: limbu
	UnicodeScriptLimbu UnicodeScript = 48
	// UnicodeScriptOsmanya: osmanya
	UnicodeScriptOsmanya UnicodeScript = 49
	// UnicodeScriptShavian: shavian
	UnicodeScriptShavian UnicodeScript = 50
	// UnicodeScriptLinearB: linear B
	UnicodeScriptLinearB UnicodeScript = 51
	// UnicodeScriptTaiLe: tai Le
	UnicodeScriptTaiLe UnicodeScript = 52
	// UnicodeScriptUgaritic: ugaritic
	UnicodeScriptUgaritic UnicodeScript = 53
	// UnicodeScriptNewTaiLue: new Tai Lue
	UnicodeScriptNewTaiLue UnicodeScript = 54
	// UnicodeScriptBuginese: buginese
	UnicodeScriptBuginese UnicodeScript = 55
	// UnicodeScriptGlagolitic: glagolitic
	UnicodeScriptGlagolitic UnicodeScript = 56
	// UnicodeScriptTifinagh: tifinagh
	UnicodeScriptTifinagh UnicodeScript = 57
	// UnicodeScriptSylotiNagri: syloti Nagri
	UnicodeScriptSylotiNagri UnicodeScript = 58
	// UnicodeScriptOldPersian: old Persian
	UnicodeScriptOldPersian UnicodeScript = 59
	// UnicodeScriptKharoshthi: kharoshthi
	UnicodeScriptKharoshthi UnicodeScript = 60
	// UnicodeScriptUnknown: an unassigned code point
	UnicodeScriptUnknown UnicodeScript = 61
	// UnicodeScriptBalinese: balinese
	UnicodeScriptBalinese UnicodeScript = 62
	// UnicodeScriptCuneiform: cuneiform
	UnicodeScriptCuneiform UnicodeScript = 63
	// UnicodeScriptPhoenician: phoenician
	UnicodeScriptPhoenician UnicodeScript = 64
	// UnicodeScriptPhagsPa: phags-pa
	UnicodeScriptPhagsPa UnicodeScript = 65
	// UnicodeScriptNko: n'Ko
	UnicodeScriptNko UnicodeScript = 66
	// UnicodeScriptKayahLi: kayah Li. Since 2.16.3
	UnicodeScriptKayahLi UnicodeScript = 67
	// UnicodeScriptLepcha: lepcha. Since 2.16.3
	UnicodeScriptLepcha UnicodeScript = 68
	// UnicodeScriptRejang: rejang. Since 2.16.3
	UnicodeScriptRejang UnicodeScript = 69
	// UnicodeScriptSundanese: sundanese. Since 2.16.3
	UnicodeScriptSundanese UnicodeScript = 70
	// UnicodeScriptSaurashtra: saurashtra. Since 2.16.3
	UnicodeScriptSaurashtra UnicodeScript = 71
	// UnicodeScriptCham: cham. Since 2.16.3
	UnicodeScriptCham UnicodeScript = 72
	// UnicodeScriptOlChiki: ol Chiki. Since 2.16.3
	UnicodeScriptOlChiki UnicodeScript = 73
	// UnicodeScriptVai: vai. Since 2.16.3
	UnicodeScriptVai UnicodeScript = 74
	// UnicodeScriptCarian: carian. Since 2.16.3
	UnicodeScriptCarian UnicodeScript = 75
	// UnicodeScriptLycian: lycian. Since 2.16.3
	UnicodeScriptLycian UnicodeScript = 76
	// UnicodeScriptLydian: lydian. Since 2.16.3
	UnicodeScriptLydian UnicodeScript = 77
	// UnicodeScriptAvestan: avestan. Since 2.26
	UnicodeScriptAvestan UnicodeScript = 78
	// UnicodeScriptBamum: bamum. Since 2.26
	UnicodeScriptBamum UnicodeScript = 79
	// UnicodeScriptEgyptianHieroglyphs: egyptian Hieroglpyhs. Since 2.26
	UnicodeScriptEgyptianHieroglyphs UnicodeScript = 80
	// UnicodeScriptImperialAramaic: imperial Aramaic. Since 2.26
	UnicodeScriptImperialAramaic UnicodeScript = 81
	// UnicodeScriptInscriptionalPahlavi: inscriptional Pahlavi. Since 2.26
	UnicodeScriptInscriptionalPahlavi UnicodeScript = 82
	// UnicodeScriptInscriptionalParthian: inscriptional Parthian. Since 2.26
	UnicodeScriptInscriptionalParthian UnicodeScript = 83
	// UnicodeScriptJavanese: javanese. Since 2.26
	UnicodeScriptJavanese UnicodeScript = 84
	// UnicodeScriptKaithi: kaithi. Since 2.26
	UnicodeScriptKaithi UnicodeScript = 85
	// UnicodeScriptLisu: lisu. Since 2.26
	UnicodeScriptLisu UnicodeScript = 86
	// UnicodeScriptMeeteiMayek: meetei Mayek. Since 2.26
	UnicodeScriptMeeteiMayek UnicodeScript = 87
	// UnicodeScriptOldSouthArabian: old South Arabian. Since 2.26
	UnicodeScriptOldSouthArabian UnicodeScript = 88
	// UnicodeScriptOldTurkic: old Turkic. Since 2.28
	UnicodeScriptOldTurkic UnicodeScript = 89
	// UnicodeScriptSamaritan: samaritan. Since 2.26
	UnicodeScriptSamaritan UnicodeScript = 90
	// UnicodeScriptTaiTham: tai Tham. Since 2.26
	UnicodeScriptTaiTham UnicodeScript = 91
	// UnicodeScriptTaiViet: tai Viet. Since 2.26
	UnicodeScriptTaiViet UnicodeScript = 92
	// UnicodeScriptBatak: batak. Since 2.28
	UnicodeScriptBatak UnicodeScript = 93
	// UnicodeScriptBrahmi: brahmi. Since 2.28
	UnicodeScriptBrahmi UnicodeScript = 94
	// UnicodeScriptMandaic: mandaic. Since 2.28
	UnicodeScriptMandaic UnicodeScript = 95
	// UnicodeScriptChakma: chakma. Since: 2.32
	UnicodeScriptChakma UnicodeScript = 96
	// UnicodeScriptMeroiticCursive: meroitic Cursive. Since: 2.32
	UnicodeScriptMeroiticCursive UnicodeScript = 97
	// UnicodeScriptMeroiticHieroglyphs: meroitic Hieroglyphs. Since: 2.32
	UnicodeScriptMeroiticHieroglyphs UnicodeScript = 98
	// UnicodeScriptMiao: miao. Since: 2.32
	UnicodeScriptMiao UnicodeScript = 99
	// UnicodeScriptSharada: sharada. Since: 2.32
	UnicodeScriptSharada UnicodeScript = 100
	// UnicodeScriptSoraSompeng: sora Sompeng. Since: 2.32
	UnicodeScriptSoraSompeng UnicodeScript = 101
	// UnicodeScriptTakri: takri. Since: 2.32
	UnicodeScriptTakri UnicodeScript = 102
	// UnicodeScriptBassaVah: bassa. Since: 2.42
	UnicodeScriptBassaVah UnicodeScript = 103
	// UnicodeScriptCaucasianAlbanian: caucasian Albanian. Since: 2.42
	UnicodeScriptCaucasianAlbanian UnicodeScript = 104
	// UnicodeScriptDuployan: duployan. Since: 2.42
	UnicodeScriptDuployan UnicodeScript = 105
	// UnicodeScriptElbasan: elbasan. Since: 2.42
	UnicodeScriptElbasan UnicodeScript = 106
	// UnicodeScriptGrantha: grantha. Since: 2.42
	UnicodeScriptGrantha UnicodeScript = 107
	// UnicodeScriptKhojki: kjohki. Since: 2.42
	UnicodeScriptKhojki UnicodeScript = 108
	// UnicodeScriptKhudawadi: khudawadi, Sindhi. Since: 2.42
	UnicodeScriptKhudawadi UnicodeScript = 109
	// UnicodeScriptLinearA: linear A. Since: 2.42
	UnicodeScriptLinearA UnicodeScript = 110
	// UnicodeScriptMahajani: mahajani. Since: 2.42
	UnicodeScriptMahajani UnicodeScript = 111
	// UnicodeScriptManichaean: manichaean. Since: 2.42
	UnicodeScriptManichaean UnicodeScript = 112
	// UnicodeScriptMendeKikakui: mende Kikakui. Since: 2.42
	UnicodeScriptMendeKikakui UnicodeScript = 113
	// UnicodeScriptModi: modi. Since: 2.42
	UnicodeScriptModi UnicodeScript = 114
	// UnicodeScriptMro: mro. Since: 2.42
	UnicodeScriptMro UnicodeScript = 115
	// UnicodeScriptNabataean: nabataean. Since: 2.42
	UnicodeScriptNabataean UnicodeScript = 116
	// UnicodeScriptOldNorthArabian: old North Arabian. Since: 2.42
	UnicodeScriptOldNorthArabian UnicodeScript = 117
	// UnicodeScriptOldPermic: old Permic. Since: 2.42
	UnicodeScriptOldPermic UnicodeScript = 118
	// UnicodeScriptPahawhHmong: pahawh Hmong. Since: 2.42
	UnicodeScriptPahawhHmong UnicodeScript = 119
	// UnicodeScriptPalmyrene: palmyrene. Since: 2.42
	UnicodeScriptPalmyrene UnicodeScript = 120
	// UnicodeScriptPauCinHau: pau Cin Hau. Since: 2.42
	UnicodeScriptPauCinHau UnicodeScript = 121
	// UnicodeScriptPsalterPahlavi: psalter Pahlavi. Since: 2.42
	UnicodeScriptPsalterPahlavi UnicodeScript = 122
	// UnicodeScriptSiddham: siddham. Since: 2.42
	UnicodeScriptSiddham UnicodeScript = 123
	// UnicodeScriptTirhuta: tirhuta. Since: 2.42
	UnicodeScriptTirhuta UnicodeScript = 124
	// UnicodeScriptWarangCiti: warang Citi. Since: 2.42
	UnicodeScriptWarangCiti UnicodeScript = 125
	// UnicodeScriptAhom: ahom. Since: 2.48
	UnicodeScriptAhom UnicodeScript = 126
	// UnicodeScriptAnatolianHieroglyphs: anatolian Hieroglyphs. Since: 2.48
	UnicodeScriptAnatolianHieroglyphs UnicodeScript = 127
	// UnicodeScriptHatran: hatran. Since: 2.48
	UnicodeScriptHatran UnicodeScript = 128
	// UnicodeScriptMultani: multani. Since: 2.48
	UnicodeScriptMultani UnicodeScript = 129
	// UnicodeScriptOldHungarian: old Hungarian. Since: 2.48
	UnicodeScriptOldHungarian UnicodeScript = 130
	// UnicodeScriptSignwriting: signwriting. Since: 2.48
	UnicodeScriptSignwriting UnicodeScript = 131
	// UnicodeScriptAdlam: adlam. Since: 2.50
	UnicodeScriptAdlam UnicodeScript = 132
	// UnicodeScriptBhaiksuki: bhaiksuki. Since: 2.50
	UnicodeScriptBhaiksuki UnicodeScript = 133
	// UnicodeScriptMarchen: marchen. Since: 2.50
	UnicodeScriptMarchen UnicodeScript = 134
	// UnicodeScriptNewa: newa. Since: 2.50
	UnicodeScriptNewa UnicodeScript = 135
	// UnicodeScriptOsage: osage. Since: 2.50
	UnicodeScriptOsage UnicodeScript = 136
	// UnicodeScriptTangut: tangut. Since: 2.50
	UnicodeScriptTangut UnicodeScript = 137
	// UnicodeScriptMasaramGondi: masaram Gondi. Since: 2.54
	UnicodeScriptMasaramGondi UnicodeScript = 138
	// UnicodeScriptNushu: nushu. Since: 2.54
	UnicodeScriptNushu UnicodeScript = 139
	// UnicodeScriptSoyombo: soyombo. Since: 2.54
	UnicodeScriptSoyombo UnicodeScript = 140
	// UnicodeScriptZanabazarSquare: zanabazar Square. Since: 2.54
	UnicodeScriptZanabazarSquare UnicodeScript = 141
	// UnicodeScriptDogra: dogra. Since: 2.58
	UnicodeScriptDogra UnicodeScript = 142
	// UnicodeScriptGunjalaGondi: gunjala Gondi. Since: 2.58
	UnicodeScriptGunjalaGondi UnicodeScript = 143
	// UnicodeScriptHanifiRohingya: hanifi Rohingya. Since: 2.58
	UnicodeScriptHanifiRohingya UnicodeScript = 144
	// UnicodeScriptMakasar: makasar. Since: 2.58
	UnicodeScriptMakasar UnicodeScript = 145
	// UnicodeScriptMedefaidrin: medefaidrin. Since: 2.58
	UnicodeScriptMedefaidrin UnicodeScript = 146
	// UnicodeScriptOldSogdian: old Sogdian. Since: 2.58
	UnicodeScriptOldSogdian UnicodeScript = 147
	// UnicodeScriptSogdian: sogdian. Since: 2.58
	UnicodeScriptSogdian UnicodeScript = 148
	// UnicodeScriptElymaic: elym. Since: 2.62
	UnicodeScriptElymaic UnicodeScript = 149
	// UnicodeScriptNandinagari: nand. Since: 2.62
	UnicodeScriptNandinagari UnicodeScript = 150
	// UnicodeScriptNyiakengPuachueHmong: rohg. Since: 2.62
	UnicodeScriptNyiakengPuachueHmong UnicodeScript = 151
	// UnicodeScriptWancho: wcho. Since: 2.62
	UnicodeScriptWancho UnicodeScript = 152
	// UnicodeScriptChorasmian: chorasmian. Since: 2.66
	UnicodeScriptChorasmian UnicodeScript = 153
	// UnicodeScriptDivesAkuru dives Akuru. Since: 2.66
	UnicodeScriptDivesAkuru UnicodeScript = 154
	// UnicodeScriptKhitanSmallScript: khitan small script. Since: 2.66
	UnicodeScriptKhitanSmallScript UnicodeScript = 155
	// UnicodeScriptYezidi: yezidi. Since: 2.66
	UnicodeScriptYezidi UnicodeScript = 156
)

// UnicodeType: these are the possible character classifications from the
// Unicode specification. See Unicode Character Database
// (http://www.unicode.org/reports/tr44/Category_Values).
type UnicodeType int

const (
	// UnicodeTypeControl: general category "Other, Control" (Cc)
	UnicodeTypeControl UnicodeType = 0
	// UnicodeTypeFormat: general category "Other, Format" (Cf)
	UnicodeTypeFormat UnicodeType = 1
	// UnicodeTypeUnassigned: general category "Other, Not Assigned" (Cn)
	UnicodeTypeUnassigned UnicodeType = 2
	// UnicodeTypePrivateUse: general category "Other, Private Use" (Co)
	UnicodeTypePrivateUse UnicodeType = 3
	// UnicodeTypeSurrogate: general category "Other, Surrogate" (Cs)
	UnicodeTypeSurrogate UnicodeType = 4
	// UnicodeTypeLowercaseLetter: general category "Letter, Lowercase" (Ll)
	UnicodeTypeLowercaseLetter UnicodeType = 5
	// UnicodeTypeModifierLetter: general category "Letter, Modifier" (Lm)
	UnicodeTypeModifierLetter UnicodeType = 6
	// UnicodeTypeOtherLetter: general category "Letter, Other" (Lo)
	UnicodeTypeOtherLetter UnicodeType = 7
	// UnicodeTypeTitlecaseLetter: general category "Letter, Titlecase" (Lt)
	UnicodeTypeTitlecaseLetter UnicodeType = 8
	// UnicodeTypeUppercaseLetter: general category "Letter, Uppercase" (Lu)
	UnicodeTypeUppercaseLetter UnicodeType = 9
	// UnicodeTypeSpacingMark: general category "Mark, Spacing" (Mc)
	UnicodeTypeSpacingMark UnicodeType = 10
	// UnicodeTypeEnclosingMark: general category "Mark, Enclosing" (Me)
	UnicodeTypeEnclosingMark UnicodeType = 11
	// UnicodeTypeNonSpacingMark: general category "Mark, Nonspacing" (Mn)
	UnicodeTypeNonSpacingMark UnicodeType = 12
	// UnicodeTypeDecimalNumber: general category "Number, Decimal Digit" (Nd)
	UnicodeTypeDecimalNumber UnicodeType = 13
	// UnicodeTypeLetterNumber: general category "Number, Letter" (Nl)
	UnicodeTypeLetterNumber UnicodeType = 14
	// UnicodeTypeOtherNumber: general category "Number, Other" (No)
	UnicodeTypeOtherNumber UnicodeType = 15
	// UnicodeTypeConnectPunctuation: general category "Punctuation, Connector"
	// (Pc)
	UnicodeTypeConnectPunctuation UnicodeType = 16
	// UnicodeTypeDashPunctuation: general category "Punctuation, Dash" (Pd)
	UnicodeTypeDashPunctuation UnicodeType = 17
	// UnicodeTypeClosePunctuation: general category "Punctuation, Close" (Pe)
	UnicodeTypeClosePunctuation UnicodeType = 18
	// UnicodeTypeFinalPunctuation: general category "Punctuation, Final quote"
	// (Pf)
	UnicodeTypeFinalPunctuation UnicodeType = 19
	// UnicodeTypeInitialPunctuation: general category "Punctuation, Initial
	// quote" (Pi)
	UnicodeTypeInitialPunctuation UnicodeType = 20
	// UnicodeTypeOtherPunctuation: general category "Punctuation, Other" (Po)
	UnicodeTypeOtherPunctuation UnicodeType = 21
	// UnicodeTypeOpenPunctuation: general category "Punctuation, Open" (Ps)
	UnicodeTypeOpenPunctuation UnicodeType = 22
	// UnicodeTypeCurrencySymbol: general category "Symbol, Currency" (Sc)
	UnicodeTypeCurrencySymbol UnicodeType = 23
	// UnicodeTypeModifierSymbol: general category "Symbol, Modifier" (Sk)
	UnicodeTypeModifierSymbol UnicodeType = 24
	// UnicodeTypeMathSymbol: general category "Symbol, Math" (Sm)
	UnicodeTypeMathSymbol UnicodeType = 25
	// UnicodeTypeOtherSymbol: general category "Symbol, Other" (So)
	UnicodeTypeOtherSymbol UnicodeType = 26
	// UnicodeTypeLineSeparator: general category "Separator, Line" (Zl)
	UnicodeTypeLineSeparator UnicodeType = 27
	// UnicodeTypeParagraphSeparator: general category "Separator, Paragraph"
	// (Zp)
	UnicodeTypeParagraphSeparator UnicodeType = 28
	// UnicodeTypeSpaceSeparator: general category "Separator, Space" (Zs)
	UnicodeTypeSpaceSeparator UnicodeType = 29
)

// URIError: error codes returned by #GUri methods.
type URIError int

const (
	// URIErrorFailed: generic error if no more specific error is available. See
	// the error message for details.
	URIErrorFailed URIError = 0
	// URIErrorBadScheme: the scheme of a URI could not be parsed.
	URIErrorBadScheme URIError = 1
	// URIErrorBadUser: the user/userinfo of a URI could not be parsed.
	URIErrorBadUser URIError = 2
	// URIErrorBadPassword: the password of a URI could not be parsed.
	URIErrorBadPassword URIError = 3
	// URIErrorBadAuthParams: the authentication parameters of a URI could not
	// be parsed.
	URIErrorBadAuthParams URIError = 4
	// URIErrorBadHost: the host of a URI could not be parsed.
	URIErrorBadHost URIError = 5
	// URIErrorBadPort: the port of a URI could not be parsed.
	URIErrorBadPort URIError = 6
	// URIErrorBadPath: the path of a URI could not be parsed.
	URIErrorBadPath URIError = 7
	// URIErrorBadQuery: the query of a URI could not be parsed.
	URIErrorBadQuery URIError = 8
	// URIErrorBadFragment: the fragment of a URI could not be parsed.
	URIErrorBadFragment URIError = 9
)

// UserDirectory: these are logical ids for special directories which are
// defined depending on the platform used. You should use
// g_get_user_special_dir() to retrieve the full path associated to the logical
// id.
//
// The Directory enumeration can be extended at later date. Not every platform
// has a directory for every logical id in this enumeration.
type UserDirectory int

const (
	// UserDirectoryDirectoryDesktop: the user's Desktop directory
	UserDirectoryDirectoryDesktop UserDirectory = 0
	// UserDirectoryDirectoryDocuments: the user's Documents directory
	UserDirectoryDirectoryDocuments UserDirectory = 1
	// UserDirectoryDirectoryDownload: the user's Downloads directory
	UserDirectoryDirectoryDownload UserDirectory = 2
	// UserDirectoryDirectoryMusic: the user's Music directory
	UserDirectoryDirectoryMusic UserDirectory = 3
	// UserDirectoryDirectoryPictures: the user's Pictures directory
	UserDirectoryDirectoryPictures UserDirectory = 4
	// UserDirectoryDirectoryPublicShare: the user's shared directory
	UserDirectoryDirectoryPublicShare UserDirectory = 5
	// UserDirectoryDirectoryTemplates: the user's Templates directory
	UserDirectoryDirectoryTemplates UserDirectory = 6
	// UserDirectoryDirectoryVideos: the user's Movies directory
	UserDirectoryDirectoryVideos UserDirectory = 7
	// UserDirectoryNDirectories: the number of enum values
	UserDirectoryNDirectories UserDirectory = 8
)

// VariantClass: the range of possible top-level types of #GVariant instances.
type VariantClass int

const (
	// VariantClassBoolean: the #GVariant is a boolean.
	VariantClassBoolean VariantClass = 98
	// VariantClassByte: the #GVariant is a byte.
	VariantClassByte VariantClass = 121
	// VariantClassInt16: the #GVariant is a signed 16 bit integer.
	VariantClassInt16 VariantClass = 110
	// VariantClassUint16: the #GVariant is an unsigned 16 bit integer.
	VariantClassUint16 VariantClass = 113
	// VariantClassInt32: the #GVariant is a signed 32 bit integer.
	VariantClassInt32 VariantClass = 105
	// VariantClassUint32: the #GVariant is an unsigned 32 bit integer.
	VariantClassUint32 VariantClass = 117
	// VariantClassInt64: the #GVariant is a signed 64 bit integer.
	VariantClassInt64 VariantClass = 120
	// VariantClassUint64: the #GVariant is an unsigned 64 bit integer.
	VariantClassUint64 VariantClass = 116
	// VariantClassHandle: the #GVariant is a file handle index.
	VariantClassHandle VariantClass = 104
	// VariantClassDouble: the #GVariant is a double precision floating point
	// value.
	VariantClassDouble VariantClass = 100
	// VariantClassString: the #GVariant is a normal string.
	VariantClassString VariantClass = 115
	// VariantClassObjectPath: the #GVariant is a D-Bus object path string.
	VariantClassObjectPath VariantClass = 111
	// VariantClassSignature: the #GVariant is a D-Bus signature string.
	VariantClassSignature VariantClass = 103
	// VariantClassVariant: the #GVariant is a variant.
	VariantClassVariant VariantClass = 118
	// VariantClassMaybe: the #GVariant is a maybe-typed value.
	VariantClassMaybe VariantClass = 109
	// VariantClassArray: the #GVariant is an array.
	VariantClassArray VariantClass = 97
	// VariantClassTuple: the #GVariant is a tuple.
	VariantClassTuple VariantClass = 40
	// VariantClassDictEntry: the #GVariant is a dictionary entry.
	VariantClassDictEntry VariantClass = 123
)

// VariantParseError: error codes returned by parsing text-format GVariants.
type VariantParseError int

const (
	// VariantParseErrorFailed: generic error (unused)
	VariantParseErrorFailed VariantParseError = 0
	// VariantParseErrorBasicTypeExpected: a non-basic Type was given where a
	// basic type was expected
	VariantParseErrorBasicTypeExpected VariantParseError = 1
	// VariantParseErrorCannotInferType: cannot infer the Type
	VariantParseErrorCannotInferType VariantParseError = 2
	// VariantParseErrorDefiniteTypeExpected: an indefinite Type was given where
	// a definite type was expected
	VariantParseErrorDefiniteTypeExpected VariantParseError = 3
	// VariantParseErrorInputNotAtEnd: extra data after parsing finished
	VariantParseErrorInputNotAtEnd VariantParseError = 4
	// VariantParseErrorInvalidCharacter: invalid character in number or unicode
	// escape
	VariantParseErrorInvalidCharacter VariantParseError = 5
	// VariantParseErrorInvalidFormatString: not a valid #GVariant format string
	VariantParseErrorInvalidFormatString VariantParseError = 6
	// VariantParseErrorInvalidObjectPath: not a valid object path
	VariantParseErrorInvalidObjectPath VariantParseError = 7
	// VariantParseErrorInvalidSignature: not a valid type signature
	VariantParseErrorInvalidSignature VariantParseError = 8
	// VariantParseErrorInvalidTypeString: not a valid #GVariant type string
	VariantParseErrorInvalidTypeString VariantParseError = 9
	// VariantParseErrorNoCommonType: could not find a common type for array
	// entries
	VariantParseErrorNoCommonType VariantParseError = 10
	// VariantParseErrorNumberOutOfRange: the numerical value is out of range of
	// the given type
	VariantParseErrorNumberOutOfRange VariantParseError = 11
	// VariantParseErrorNumberTooBig: the numerical value is out of range for
	// any type
	VariantParseErrorNumberTooBig VariantParseError = 12
	// VariantParseErrorTypeError: cannot parse as variant of the specified type
	VariantParseErrorTypeError VariantParseError = 13
	// VariantParseErrorUnexpectedToken: an unexpected token was encountered
	VariantParseErrorUnexpectedToken VariantParseError = 14
	// VariantParseErrorUnknownKeyword: an unknown keyword was encountered
	VariantParseErrorUnknownKeyword VariantParseError = 15
	// VariantParseErrorUnterminatedStringConstant: unterminated string constant
	VariantParseErrorUnterminatedStringConstant VariantParseError = 16
	// VariantParseErrorValueExpected: no value given
	VariantParseErrorValueExpected VariantParseError = 17
	// VariantParseErrorRecursion: variant was too deeply nested; #GVariant is
	// only guaranteed to handle nesting up to 64 levels (Since: 2.64)
	VariantParseErrorRecursion VariantParseError = 18
)

type ASCIIType int

const (
	ASCIITypeAlnum ASCIIType = 0b1

	ASCIITypeAlpha ASCIIType = 0b10

	ASCIITypeCntrl ASCIIType = 0b100

	ASCIITypeDigit ASCIIType = 0b1000

	ASCIITypeGraph ASCIIType = 0b10000

	ASCIITypeLower ASCIIType = 0b100000

	ASCIITypePrint ASCIIType = 0b1000000

	ASCIITypePunct ASCIIType = 0b10000000

	ASCIITypeSpace ASCIIType = 0b100000000

	ASCIITypeUpper ASCIIType = 0b1000000000

	ASCIITypeXDigit ASCIIType = 0b10000000000
)

// FileSetContentsFlags flags to pass to g_file_set_contents_full() to affect
// its safety and performance.
type FileSetContentsFlags int

const (
	// FileSetContentsFlagsNone: no guarantees about file consistency or
	// durability. The most dangerous setting, which is slightly faster than
	// other settings.
	FileSetContentsFlagsNone FileSetContentsFlags = 0b0
	// FileSetContentsFlagsConsistent: guarantee file consistency: after a
	// crash, either the old version of the file or the new version of the file
	// will be available, but not a mixture. On Unix systems this equates to an
	// `fsync()` on the file and use of an atomic `rename()` of the new version
	// of the file over the old.
	FileSetContentsFlagsConsistent FileSetContentsFlags = 0b1
	// FileSetContentsFlagsDurable: guarantee file durability: after a crash,
	// the new version of the file will be available. On Unix systems this
	// equates to an `fsync()` on the file (if G_FILE_SET_CONTENTS_CONSISTENT is
	// unset), or the effects of G_FILE_SET_CONTENTS_CONSISTENT plus an
	// `fsync()` on the directory containing the file after calling `rename()`.
	FileSetContentsFlagsDurable FileSetContentsFlags = 0b10
	// FileSetContentsFlagsOnlyExisting: only apply consistency and durability
	// guarantees if the file already exists. This may speed up file operations
	// if the file doesn’t currently exist, but may result in a corrupted
	// version of the new file if the system crashes while writing it.
	FileSetContentsFlagsOnlyExisting FileSetContentsFlags = 0b100
)

// FileTest: a test to perform on a file using g_file_test().
type FileTest int

const (
	// FileTestIsRegular: true if the file is a regular file (not a directory).
	// Note that this test will also return true if the tested file is a symlink
	// to a regular file.
	FileTestIsRegular FileTest = 0b1
	// FileTestIsSymlink: true if the file is a symlink.
	FileTestIsSymlink FileTest = 0b10
	// FileTestIsDir: true if the file is a directory.
	FileTestIsDir FileTest = 0b100
	// FileTestIsExecutable: true if the file is executable.
	FileTestIsExecutable FileTest = 0b1000
	// FileTestExists: true if the file exists. It may or may not be a regular
	// file.
	FileTestExists FileTest = 0b10000
)

// FormatSizeFlags flags to modify the format of the string returned by
// g_format_size_full().
type FormatSizeFlags int

const (
	// FormatSizeFlagsDefault: behave the same as g_format_size()
	FormatSizeFlagsDefault FormatSizeFlags = 0b0
	// FormatSizeFlagsLongFormat: include the exact number of bytes as part of
	// the returned string. For example, "45.6 kB (45,612 bytes)".
	FormatSizeFlagsLongFormat FormatSizeFlags = 0b1
	// FormatSizeFlagsIecUnits: use IEC (base 1024) units with "KiB"-style
	// suffixes. IEC units should only be used for reporting things with a
	// strong "power of 2" basis, like RAM sizes or RAID stripe sizes. Network
	// and storage sizes should be reported in the normal SI units.
	FormatSizeFlagsIecUnits FormatSizeFlags = 0b10
	// FormatSizeFlagsBits: set the size as a quantity in bits, rather than
	// bytes, and return units in bits. For example, ‘Mb’ rather than ‘MB’.
	FormatSizeFlagsBits FormatSizeFlags = 0b100
)

// HookFlagMask flags used internally in the #GHook implementation.
type HookFlagMask int

const (
	// HookFlagMaskActive: set if the hook has not been destroyed
	HookFlagMaskActive HookFlagMask = 0b1
	// HookFlagMaskInCall: set if the hook is currently being run
	HookFlagMaskInCall HookFlagMask = 0b10
	// HookFlagMaskMask: a mask covering all bits reserved for hook flags; see
	// G_HOOK_FLAG_USER_SHIFT
	HookFlagMaskMask HookFlagMask = 0b1111
)

// IOCondition: a bitwise combination representing a condition to watch for on
// an event source.
type IOCondition int

const (
	// IOConditionIn: there is data to read.
	IOConditionIn IOCondition = 0b1
	// IOConditionOut: data can be written (without blocking).
	IOConditionOut IOCondition = 0b100
	// IOConditionPri: there is urgent data to read.
	IOConditionPri IOCondition = 0b10
	// IOConditionErr: error condition.
	IOConditionErr IOCondition = 0b1000
	// IOConditionHup: hung up (the connection has been broken, usually for
	// pipes and sockets).
	IOConditionHup IOCondition = 0b10000
	// IOConditionNval: invalid request. The file descriptor is not open.
	IOConditionNval IOCondition = 0b100000
)

func marshalIOCondition(p uintptr) (interface{}, error) {
	return IOCondition(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IOFlags specifies properties of a OChannel. Some of the flags can only be
// read with g_io_channel_get_flags(), but not changed with
// g_io_channel_set_flags().
type IOFlags int

const (
	// IOFlagsAppend turns on append mode, corresponds to O_APPEND (see the
	// documentation of the UNIX open() syscall)
	IOFlagsAppend IOFlags = 0b1
	// IOFlagsNonblock turns on nonblocking mode, corresponds to
	// O_NONBLOCK/O_NDELAY (see the documentation of the UNIX open() syscall)
	IOFlagsNonblock IOFlags = 0b10
	// IOFlagsIsReadable indicates that the io channel is readable. This flag
	// cannot be changed.
	IOFlagsIsReadable IOFlags = 0b100
	// IOFlagsIsWritable indicates that the io channel is writable. This flag
	// cannot be changed.
	IOFlagsIsWritable IOFlags = 0b1000
	// IOFlagsIsWriteable: a misspelled version of @G_IO_FLAG_IS_WRITABLE that
	// existed before the spelling was fixed in GLib 2.30. It is kept here for
	// compatibility reasons. Deprecated since 2.30
	IOFlagsIsWriteable IOFlags = 0b1000
	// IOFlagsIsSeekable indicates that the io channel is seekable, i.e. that
	// g_io_channel_seek_position() can be used on it. This flag cannot be
	// changed.
	IOFlagsIsSeekable IOFlags = 0b10000
	// IOFlagsMask: the mask that specifies all the valid flags.
	IOFlagsMask IOFlags = 0b11111
	// IOFlagsGetMask: the mask of the flags that are returned from
	// g_io_channel_get_flags()
	IOFlagsGetMask IOFlags = 0b11111
	// IOFlagsSetMask: the mask of the flags that the user can modify with
	// g_io_channel_set_flags()
	IOFlagsSetMask IOFlags = 0b11
)

// KeyFileFlags flags which influence the parsing.
type KeyFileFlags int

const (
	// KeyFileFlagsNone: no flags, default behaviour
	KeyFileFlagsNone KeyFileFlags = 0b0
	// KeyFileFlagsKeepComments: use this flag if you plan to write the
	// (possibly modified) contents of the key file back to a file; otherwise
	// all comments will be lost when the key file is written back.
	KeyFileFlagsKeepComments KeyFileFlags = 0b1
	// KeyFileFlagsKeepTranslations: use this flag if you plan to write the
	// (possibly modified) contents of the key file back to a file; otherwise
	// only the translations for the current language will be written back.
	KeyFileFlagsKeepTranslations KeyFileFlags = 0b10
)

// LogLevelFlags flags specifying the level of log messages.
//
// It is possible to change how GLib treats messages of the various levels using
// g_log_set_handler() and g_log_set_fatal_mask().
type LogLevelFlags int

const (
	// LogLevelFlagsFlagRecursion: internal flag
	LogLevelFlagsFlagRecursion LogLevelFlags = 0b1
	// LogLevelFlagsFlagFatal: internal flag
	LogLevelFlagsFlagFatal LogLevelFlags = 0b10
	// LogLevelFlagsLevelError: log level for errors, see g_error(). This level
	// is also used for messages produced by g_assert().
	LogLevelFlagsLevelError LogLevelFlags = 0b100
	// LogLevelFlagsLevelCritical: log level for critical warning messages, see
	// g_critical(). This level is also used for messages produced by
	// g_return_if_fail() and g_return_val_if_fail().
	LogLevelFlagsLevelCritical LogLevelFlags = 0b1000
	// LogLevelFlagsLevelWarning: log level for warnings, see g_warning()
	LogLevelFlagsLevelWarning LogLevelFlags = 0b10000
	// LogLevelFlagsLevelMessage: log level for messages, see g_message()
	LogLevelFlagsLevelMessage LogLevelFlags = 0b100000
	// LogLevelFlagsLevelInfo: log level for informational messages, see
	// g_info()
	LogLevelFlagsLevelInfo LogLevelFlags = 0b1000000
	// LogLevelFlagsLevelDebug: log level for debug messages, see g_debug()
	LogLevelFlagsLevelDebug LogLevelFlags = 0b10000000
	// LogLevelFlagsLevelMask: a mask including all log levels
	LogLevelFlagsLevelMask LogLevelFlags = -4
)

// MarkupCollectType: a mixed enumerated type and flags field. You must specify
// one type (string, strdup, boolean, tristate). Additionally, you may
// optionally bitwise OR the type with the flag G_MARKUP_COLLECT_OPTIONAL.
//
// It is likely that this enum will be extended in the future to support other
// types.
type MarkupCollectType int

const (
	// MarkupCollectTypeInvalid: used to terminate the list of attributes to
	// collect
	MarkupCollectTypeInvalid MarkupCollectType = 0b0
	// MarkupCollectTypeString: collect the string pointer directly from the
	// attribute_values[] array. Expects a parameter of type (const char **). If
	// G_MARKUP_COLLECT_OPTIONAL is specified and the attribute isn't present
	// then the pointer will be set to nil
	MarkupCollectTypeString MarkupCollectType = 0b1
	// MarkupCollectTypeStrdup as with G_MARKUP_COLLECT_STRING, but expects a
	// parameter of type (char **) and g_strdup()s the returned pointer. The
	// pointer must be freed with g_free()
	MarkupCollectTypeStrdup MarkupCollectType = 0b10
	// MarkupCollectTypeBoolean expects a parameter of type (gboolean *) and
	// parses the attribute value as a boolean. Sets false if the attribute
	// isn't present. Valid boolean values consist of (case-insensitive)
	// "false", "f", "no", "n", "0" and "true", "t", "yes", "y", "1"
	MarkupCollectTypeBoolean MarkupCollectType = 0b11
	// MarkupCollectTypeTristate as with G_MARKUP_COLLECT_BOOLEAN, but in the
	// case of a missing attribute a value is set that compares equal to neither
	// false nor true G_MARKUP_COLLECT_OPTIONAL is implied
	MarkupCollectTypeTristate MarkupCollectType = 0b100
	// MarkupCollectTypeOptional: can be bitwise ORed with the other fields. If
	// present, allows the attribute not to appear. A default value is set
	// depending on what value type is used
	MarkupCollectTypeOptional MarkupCollectType = 0b10000000000000000
)

// MarkupParseFlags flags that affect the behaviour of the parser.
type MarkupParseFlags int

const (
	// MarkupParseFlagsDoNotUseThisUnsupportedFlag: flag you should not use
	MarkupParseFlagsDoNotUseThisUnsupportedFlag MarkupParseFlags = 0b1
	// MarkupParseFlagsTreatCdataAsText: when this flag is set, CDATA marked
	// sections are not passed literally to the @passthrough function of the
	// parser. Instead, the content of the section (without the `<![CDATA[` and
	// `]]>`) is passed to the @text function. This flag was added in GLib 2.12
	MarkupParseFlagsTreatCdataAsText MarkupParseFlags = 0b10
	// MarkupParseFlagsPrefixErrorPosition: normally errors caught by GMarkup
	// itself have line/column information prefixed to them to let the caller
	// know the location of the error. When this flag is set the location
	// information is also prefixed to errors generated by the Parser
	// implementation functions
	MarkupParseFlagsPrefixErrorPosition MarkupParseFlags = 0b100
	// MarkupParseFlagsIgnoreQualified: ignore (don't report) qualified
	// attributes and tags, along with their contents. A qualified attribute or
	// tag is one that contains ':' in its name (ie: is in another namespace).
	// Since: 2.40.
	MarkupParseFlagsIgnoreQualified MarkupParseFlags = 0b1000
)

// OptionFlags flags which modify individual options.
type OptionFlags int

const (
	// OptionFlagsNone: no flags. Since: 2.42.
	OptionFlagsNone OptionFlags = 0b0
	// OptionFlagsHidden: the option doesn't appear in `--help` output.
	OptionFlagsHidden OptionFlags = 0b1
	// OptionFlagsInMain: the option appears in the main section of the `--help`
	// output, even if it is defined in a group.
	OptionFlagsInMain OptionFlags = 0b10
	// OptionFlagsReverse: for options of the G_OPTION_ARG_NONE kind, this flag
	// indicates that the sense of the option is reversed.
	OptionFlagsReverse OptionFlags = 0b100
	// OptionFlagsNoArg: for options of the G_OPTION_ARG_CALLBACK kind, this
	// flag indicates that the callback does not take any argument (like a
	// G_OPTION_ARG_NONE option). Since 2.8
	OptionFlagsNoArg OptionFlags = 0b1000
	// OptionFlagsFilename: for options of the G_OPTION_ARG_CALLBACK kind, this
	// flag indicates that the argument should be passed to the callback in the
	// GLib filename encoding rather than UTF-8. Since 2.8
	OptionFlagsFilename OptionFlags = 0b10000
	// OptionFlagsOptionalArg: for options of the G_OPTION_ARG_CALLBACK kind,
	// this flag indicates that the argument supply is optional. If no argument
	// is given then data of GOptionParseFunc will be set to NULL. Since 2.8
	OptionFlagsOptionalArg OptionFlags = 0b100000
	// OptionFlagsNoalias: this flag turns off the automatic conflict resolution
	// which prefixes long option names with `groupname-` if there is a
	// conflict. This option should only be used in situations where aliasing is
	// necessary to model some legacy commandline interface. It is not safe to
	// use this option, unless all option groups are under your direct control.
	// Since 2.8.
	OptionFlagsNoalias OptionFlags = 0b1000000
)

// RegexCompileFlags flags specifying compile-time options.
type RegexCompileFlags int

const (
	// RegexCompileFlagsCaseless letters in the pattern match both upper- and
	// lowercase letters. This option can be changed within a pattern by a
	// "(?i)" option setting.
	RegexCompileFlagsCaseless RegexCompileFlags = 0b1
	// RegexCompileFlagsMultiline: by default, GRegex treats the strings as
	// consisting of a single line of characters (even if it actually contains
	// newlines). The "start of line" metacharacter ("^") matches only at the
	// start of the string, while the "end of line" metacharacter ("$") matches
	// only at the end of the string, or before a terminating newline (unless
	// REGEX_DOLLAR_ENDONLY is set). When REGEX_MULTILINE is set, the "start of
	// line" and "end of line" constructs match immediately following or
	// immediately before any newline in the string, respectively, as well as at
	// the very start and end. This can be changed within a pattern by a "(?m)"
	// option setting.
	RegexCompileFlagsMultiline RegexCompileFlags = 0b10
	// RegexCompileFlagsDotall: a dot metacharacter (".") in the pattern matches
	// all characters, including newlines. Without it, newlines are excluded.
	// This option can be changed within a pattern by a ("?s") option setting.
	RegexCompileFlagsDotall RegexCompileFlags = 0b100
	// RegexCompileFlagsExtended: whitespace data characters in the pattern are
	// totally ignored except when escaped or inside a character class.
	// Whitespace does not include the VT character (code 11). In addition,
	// characters between an unescaped "#" outside a character class and the
	// next newline character, inclusive, are also ignored. This can be changed
	// within a pattern by a "(?x)" option setting.
	RegexCompileFlagsExtended RegexCompileFlags = 0b1000
	// RegexCompileFlagsAnchored: the pattern is forced to be "anchored", that
	// is, it is constrained to match only at the first matching point in the
	// string that is being searched. This effect can also be achieved by
	// appropriate constructs in the pattern itself such as the "^"
	// metacharacter.
	RegexCompileFlagsAnchored RegexCompileFlags = 0b10000
	// RegexCompileFlagsDollarEndonly: a dollar metacharacter ("$") in the
	// pattern matches only at the end of the string. Without this option, a
	// dollar also matches immediately before the final character if it is a
	// newline (but not before any other newlines). This option is ignored if
	// REGEX_MULTILINE is set.
	RegexCompileFlagsDollarEndonly RegexCompileFlags = 0b100000
	// RegexCompileFlagsUngreedy inverts the "greediness" of the quantifiers so
	// that they are not greedy by default, but become greedy if followed by
	// "?". It can also be set by a "(?U)" option setting within the pattern.
	RegexCompileFlagsUngreedy RegexCompileFlags = 0b1000000000
	// RegexCompileFlagsRaw: usually strings must be valid UTF-8 strings, using
	// this flag they are considered as a raw sequence of bytes.
	RegexCompileFlagsRaw RegexCompileFlags = 0b100000000000
	// RegexCompileFlagsNoAutoCapture disables the use of numbered capturing
	// parentheses in the pattern. Any opening parenthesis that is not followed
	// by "?" behaves as if it were followed by "?:" but named parentheses can
	// still be used for capturing (and they acquire numbers in the usual way).
	RegexCompileFlagsNoAutoCapture RegexCompileFlags = 0b1000000000000
	// RegexCompileFlagsOptimize: optimize the regular expression. If the
	// pattern will be used many times, then it may be worth the effort to
	// optimize it to improve the speed of matches.
	RegexCompileFlagsOptimize RegexCompileFlags = 0b10000000000000
	// RegexCompileFlagsFirstline limits an unanchored pattern to match before
	// (or at) the first newline. Since: 2.34
	RegexCompileFlagsFirstline RegexCompileFlags = 0b1000000000000000000
	// RegexCompileFlagsDupnames names used to identify capturing subpatterns
	// need not be unique. This can be helpful for certain types of pattern when
	// it is known that only one instance of the named subpattern can ever be
	// matched.
	RegexCompileFlagsDupnames RegexCompileFlags = 0b10000000000000000000
	// RegexCompileFlagsNewlineCr: usually any newline character or character
	// sequence is recognized. If this option is set, the only recognized
	// newline character is '\r'.
	RegexCompileFlagsNewlineCr RegexCompileFlags = 0b100000000000000000000
	// RegexCompileFlagsNewlineLf: usually any newline character or character
	// sequence is recognized. If this option is set, the only recognized
	// newline character is '\n'.
	RegexCompileFlagsNewlineLf RegexCompileFlags = 0b1000000000000000000000
	// RegexCompileFlagsNewlineCrlf: usually any newline character or character
	// sequence is recognized. If this option is set, the only recognized
	// newline character sequence is '\r\n'.
	RegexCompileFlagsNewlineCrlf RegexCompileFlags = 0b1100000000000000000000
	// RegexCompileFlagsNewlineAnycrlf: usually any newline character or
	// character sequence is recognized. If this option is set, the only
	// recognized newline character sequences are '\r', '\n', and '\r\n'. Since:
	// 2.34
	RegexCompileFlagsNewlineAnycrlf RegexCompileFlags = 0b10100000000000000000000
	// RegexCompileFlagsBsrAnycrlf: usually any newline character or character
	// sequence is recognised. If this option is set, then "\R" only recognizes
	// the newline characters '\r', '\n' and '\r\n'. Since: 2.34
	RegexCompileFlagsBsrAnycrlf RegexCompileFlags = 0b100000000000000000000000
	// RegexCompileFlagsJavascriptCompat changes behaviour so that it is
	// compatible with JavaScript rather than PCRE. Since: 2.34
	RegexCompileFlagsJavascriptCompat RegexCompileFlags = 0b10000000000000000000000000
)

// RegexMatchFlags flags specifying match-time options.
type RegexMatchFlags int

const (
	// RegexMatchFlagsAnchored: the pattern is forced to be "anchored", that is,
	// it is constrained to match only at the first matching point in the string
	// that is being searched. This effect can also be achieved by appropriate
	// constructs in the pattern itself such as the "^" metacharacter.
	RegexMatchFlagsAnchored RegexMatchFlags = 0b10000
	// RegexMatchFlagsNotbol specifies that first character of the string is not
	// the beginning of a line, so the circumflex metacharacter should not match
	// before it. Setting this without REGEX_MULTILINE (at compile time) causes
	// circumflex never to match. This option affects only the behaviour of the
	// circumflex metacharacter, it does not affect "\A".
	RegexMatchFlagsNotbol RegexMatchFlags = 0b10000000
	// RegexMatchFlagsNoteol specifies that the end of the subject string is not
	// the end of a line, so the dollar metacharacter should not match it nor
	// (except in multiline mode) a newline immediately before it. Setting this
	// without REGEX_MULTILINE (at compile time) causes dollar never to match.
	// This option affects only the behaviour of the dollar metacharacter, it
	// does not affect "\Z" or "\z".
	RegexMatchFlagsNoteol RegexMatchFlags = 0b100000000
	// RegexMatchFlagsNotempty: an empty string is not considered to be a valid
	// match if this option is set. If there are alternatives in the pattern,
	// they are tried. If all the alternatives match the empty string, the
	// entire match fails. For example, if the pattern "a?b?" is applied to a
	// string not beginning with "a" or "b", it matches the empty string at the
	// start of the string. With this flag set, this match is not valid, so
	// GRegex searches further into the string for occurrences of "a" or "b".
	RegexMatchFlagsNotempty RegexMatchFlags = 0b10000000000
	// RegexMatchFlagsPartial turns on the partial matching feature, for more
	// documentation on partial matching see g_match_info_is_partial_match().
	RegexMatchFlagsPartial RegexMatchFlags = 0b1000000000000000
	// RegexMatchFlagsNewlineCr overrides the newline definition set when
	// creating a new #GRegex, setting the '\r' character as line terminator.
	RegexMatchFlagsNewlineCr RegexMatchFlags = 0b100000000000000000000
	// RegexMatchFlagsNewlineLf overrides the newline definition set when
	// creating a new #GRegex, setting the '\n' character as line terminator.
	RegexMatchFlagsNewlineLf RegexMatchFlags = 0b1000000000000000000000
	// RegexMatchFlagsNewlineCrlf overrides the newline definition set when
	// creating a new #GRegex, setting the '\r\n' characters sequence as line
	// terminator.
	RegexMatchFlagsNewlineCrlf RegexMatchFlags = 0b1100000000000000000000
	// RegexMatchFlagsNewlineAny overrides the newline definition set when
	// creating a new #GRegex, any Unicode newline sequence is recognised as a
	// newline. These are '\r', '\n' and '\rn', and the single characters U+000B
	// LINE TABULATION, U+000C FORM FEED (FF), U+0085 NEXT LINE (NEL), U+2028
	// LINE SEPARATOR and U+2029 PARAGRAPH SEPARATOR.
	RegexMatchFlagsNewlineAny RegexMatchFlags = 0b10000000000000000000000
	// RegexMatchFlagsNewlineAnycrlf overrides the newline definition set when
	// creating a new #GRegex; any '\r', '\n', or '\r\n' character sequence is
	// recognized as a newline. Since: 2.34
	RegexMatchFlagsNewlineAnycrlf RegexMatchFlags = 0b10100000000000000000000
	// RegexMatchFlagsBsrAnycrlf overrides the newline definition for "\R" set
	// when creating a new #GRegex; only '\r', '\n', or '\r\n' character
	// sequences are recognized as a newline by "\R". Since: 2.34
	RegexMatchFlagsBsrAnycrlf RegexMatchFlags = 0b100000000000000000000000
	// RegexMatchFlagsBsrAny overrides the newline definition for "\R" set when
	// creating a new #GRegex; any Unicode newline character or character
	// sequence are recognized as a newline by "\R". These are '\r', '\n' and
	// '\rn', and the single characters U+000B LINE TABULATION, U+000C FORM FEED
	// (FF), U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and U+2029 PARAGRAPH
	// SEPARATOR. Since: 2.34
	RegexMatchFlagsBsrAny RegexMatchFlags = 0b1000000000000000000000000
	// RegexMatchFlagsPartialSoft: an alias for REGEX_MATCH_PARTIAL. Since: 2.34
	RegexMatchFlagsPartialSoft RegexMatchFlags = 0b1000000000000000
	// RegexMatchFlagsPartialHard turns on the partial matching feature. In
	// contrast to to REGEX_MATCH_PARTIAL_SOFT, this stops matching as soon as a
	// partial match is found, without continuing to search for a possible
	// complete match. See g_match_info_is_partial_match() for more information.
	// Since: 2.34
	RegexMatchFlagsPartialHard RegexMatchFlags = 0b1000000000000000000000000000
	// RegexMatchFlagsNotemptyAtstart: like REGEX_MATCH_NOTEMPTY, but only
	// applied to the start of the matched string. For anchored patterns this
	// can only happen for pattern containing "\K". Since: 2.34
	RegexMatchFlagsNotemptyAtstart RegexMatchFlags = 0b10000000000000000000000000000
)

// SpawnFlags flags passed to g_spawn_sync(), g_spawn_async() and
// g_spawn_async_with_pipes().
type SpawnFlags int

const (
	// SpawnFlagsDefault: no flags, default behaviour
	SpawnFlagsDefault SpawnFlags = 0b0
	// SpawnFlagsLeaveDescriptorsOpen: the parent's open file descriptors will
	// be inherited by the child; otherwise all descriptors except stdin, stdout
	// and stderr will be closed before calling exec() in the child.
	SpawnFlagsLeaveDescriptorsOpen SpawnFlags = 0b1
	// SpawnFlagsDoNotReapChild: the child will not be automatically reaped; you
	// must use g_child_watch_add() yourself (or call waitpid() or handle
	// `SIGCHLD` yourself), or the child will become a zombie.
	SpawnFlagsDoNotReapChild SpawnFlags = 0b10
	// SpawnFlagsSearchPath: `argv[0]` need not be an absolute path, it will be
	// looked for in the user's `PATH`.
	SpawnFlagsSearchPath SpawnFlags = 0b100
	// SpawnFlagsStdoutToDevNull: the child's standard output will be discarded,
	// instead of going to the same location as the parent's standard output.
	SpawnFlagsStdoutToDevNull SpawnFlags = 0b1000
	// SpawnFlagsStderrToDevNull: the child's standard error will be discarded.
	SpawnFlagsStderrToDevNull SpawnFlags = 0b10000
	// SpawnFlagsChildInheritsStdin: the child will inherit the parent's
	// standard input (by default, the child's standard input is attached to
	// `/dev/null`).
	SpawnFlagsChildInheritsStdin SpawnFlags = 0b100000
	// SpawnFlagsFileAndArgvZero: the first element of `argv` is the file to
	// execute, while the remaining elements are the actual argument vector to
	// pass to the file. Normally g_spawn_async_with_pipes() uses `argv[0]` as
	// the file to execute, and passes all of `argv` to the child.
	SpawnFlagsFileAndArgvZero SpawnFlags = 0b1000000
	// SpawnFlagsSearchPathFromEnvp: if `argv[0]` is not an absolute path, it
	// will be looked for in the `PATH` from the passed child environment.
	// Since: 2.34
	SpawnFlagsSearchPathFromEnvp SpawnFlags = 0b10000000
	// SpawnFlagsCloexecPipes: create all pipes with the `O_CLOEXEC` flag set.
	// Since: 2.40
	SpawnFlagsCloexecPipes SpawnFlags = 0b100000000
)

// TestSubprocessFlags flags to pass to g_test_trap_subprocess() to control
// input and output.
//
// Note that in contrast with g_test_trap_fork(), the default is to not show
// stdout and stderr.
type TestSubprocessFlags int

const (
	// TestSubprocessFlagsStdin: if this flag is given, the child process will
	// inherit the parent's stdin. Otherwise, the child's stdin is redirected to
	// `/dev/null`.
	TestSubprocessFlagsStdin TestSubprocessFlags = 0b1
	// TestSubprocessFlagsStdout: if this flag is given, the child process will
	// inherit the parent's stdout. Otherwise, the child's stdout will not be
	// visible, but it will be captured to allow later tests with
	// g_test_trap_assert_stdout().
	TestSubprocessFlagsStdout TestSubprocessFlags = 0b10
	// TestSubprocessFlagsStderr: if this flag is given, the child process will
	// inherit the parent's stderr. Otherwise, the child's stderr will not be
	// visible, but it will be captured to allow later tests with
	// g_test_trap_assert_stderr().
	TestSubprocessFlagsStderr TestSubprocessFlags = 0b100
)

// TestTrapFlags: test traps are guards around forked tests. These flags
// determine what traps to set.
type TestTrapFlags int

const (
	// TestTrapFlagsSilenceStdout: redirect stdout of the test child to
	// `/dev/null` so it cannot be observed on the console during test runs. The
	// actual output is still captured though to allow later tests with
	// g_test_trap_assert_stdout().
	TestTrapFlagsSilenceStdout TestTrapFlags = 0b10000000
	// TestTrapFlagsSilenceStderr: redirect stderr of the test child to
	// `/dev/null` so it cannot be observed on the console during test runs. The
	// actual output is still captured though to allow later tests with
	// g_test_trap_assert_stderr().
	TestTrapFlagsSilenceStderr TestTrapFlags = 0b100000000
	// TestTrapFlagsInheritStdin: if this flag is given, stdin of the child
	// process is shared with stdin of its parent process. It is redirected to
	// `/dev/null` otherwise.
	TestTrapFlagsInheritStdin TestTrapFlags = 0b1000000000
)

// TraverseFlags specifies which nodes are visited during several of the tree
// functions, including g_node_traverse() and g_node_find().
type TraverseFlags int

const (
	// TraverseFlagsLeaves: only leaf nodes should be visited. This name has
	// been introduced in 2.6, for older version use G_TRAVERSE_LEAFS.
	TraverseFlagsLeaves TraverseFlags = 0b1
	// TraverseFlagsNonLeaves: only non-leaf nodes should be visited. This name
	// has been introduced in 2.6, for older version use G_TRAVERSE_NON_LEAFS.
	TraverseFlagsNonLeaves TraverseFlags = 0b10
	// TraverseFlagsAll: all nodes should be visited.
	TraverseFlagsAll TraverseFlags = 0b11
	// TraverseFlagsMask: a mask of all traverse flags.
	TraverseFlagsMask TraverseFlags = 0b11
	// TraverseFlagsLeafs: identical to G_TRAVERSE_LEAVES.
	TraverseFlagsLeafs TraverseFlags = 0b1
	// TraverseFlagsNonLeafs: identical to G_TRAVERSE_NON_LEAVES.
	TraverseFlagsNonLeafs TraverseFlags = 0b10
)

// URIFlags flags that describe a URI.
//
// When parsing a URI, if you need to choose different flags based on the type
// of URI, you can use g_uri_peek_scheme() on the URI string to check the scheme
// first, and use that to decide what flags to parse it with.
type URIFlags int

const (
	// URIFlagsNone: no flags set.
	URIFlagsNone URIFlags = 0b0
	// URIFlagsParseRelaxed: parse the URI more relaxedly than the RFC 3986
	// (https://tools.ietf.org/html/rfc3986) grammar specifies, fixing up or
	// ignoring common mistakes in URIs coming from external sources. This is
	// also needed for some obscure URI schemes where `;` separates the host
	// from the path. Don’t use this flag unless you need to.
	URIFlagsParseRelaxed URIFlags = 0b1
	// URIFlagsHasPassword: the userinfo field may contain a password, which
	// will be separated from the username by `:`.
	URIFlagsHasPassword URIFlags = 0b10
	// URIFlagsHasAuthParams: the userinfo may contain additional
	// authentication-related parameters, which will be separated from the
	// username and/or password by `;`.
	URIFlagsHasAuthParams URIFlags = 0b100
	// URIFlagsEncoded: when parsing a URI, this indicates that `%`-encoded
	// characters in the userinfo, path, query, and fragment fields should not
	// be decoded. (And likewise the host field if G_URI_FLAGS_NON_DNS is also
	// set.) When building a URI, it indicates that you have already `%`-encoded
	// the components, and so #GUri should not do any encoding itself.
	URIFlagsEncoded URIFlags = 0b1000
	// URIFlagsNonDns: the host component should not be assumed to be a DNS
	// hostname or IP address (for example, for `smb` URIs with NetBIOS
	// hostnames).
	URIFlagsNonDns URIFlags = 0b10000
	// URIFlagsEncodedQuery: same as G_URI_FLAGS_ENCODED, for the query field
	// only.
	URIFlagsEncodedQuery URIFlags = 0b100000
	// URIFlagsEncodedPath: same as G_URI_FLAGS_ENCODED, for the path only.
	URIFlagsEncodedPath URIFlags = 0b1000000
	// URIFlagsEncodedFragment: same as G_URI_FLAGS_ENCODED, for the fragment
	// only.
	URIFlagsEncodedFragment URIFlags = 0b10000000
)

// URIHideFlags flags describing what parts of the URI to hide in
// g_uri_to_string_partial(). Note that G_URI_HIDE_PASSWORD and
// G_URI_HIDE_AUTH_PARAMS will only work if the #GUri was parsed with the
// corresponding flags.
type URIHideFlags int

const (
	// URIHideFlagsNone: no flags set.
	URIHideFlagsNone URIHideFlags = 0b0
	// URIHideFlagsUserinfo: hide the userinfo.
	URIHideFlagsUserinfo URIHideFlags = 0b1
	// URIHideFlagsPassword: hide the password.
	URIHideFlagsPassword URIHideFlags = 0b10
	// URIHideFlagsAuthParams: hide the auth_params.
	URIHideFlagsAuthParams URIHideFlags = 0b100
	// URIHideFlagsQuery: hide the query.
	URIHideFlagsQuery URIHideFlags = 0b1000
	// URIHideFlagsFragment: hide the fragment.
	URIHideFlagsFragment URIHideFlags = 0b10000
)

// URIParamsFlags flags modifying the way parameters are handled by
// g_uri_parse_params() and ParamsIter.
type URIParamsFlags int

const (
	// URIParamsFlagsNone: no flags set.
	URIParamsFlagsNone URIParamsFlags = 0b0
	// URIParamsFlagsCaseInsensitive: parameter names are case insensitive.
	URIParamsFlagsCaseInsensitive URIParamsFlags = 0b1
	// URIParamsFlagsWwwForm: replace `+` with space character. Only useful for
	// URLs on the web, using the `https` or `http` schemas.
	URIParamsFlagsWwwForm URIParamsFlags = 0b10
	// URIParamsFlagsParseRelaxed: see G_URI_FLAGS_PARSE_RELAXED.
	URIParamsFlagsParseRelaxed URIParamsFlags = 0b100
)

// ChildWatchFunc: prototype of a WatchSource callback, called when a child
// process has exited. To interpret @status, see the documentation for
// g_spawn_check_exit_status().
type ChildWatchFunc func(pid Pid, status int)

//export gotk4_ChildWatchFunc
func gotk4_ChildWatchFunc(arg0 C.GPid, arg1 C.gint, arg2 C.gpointer) {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var pid Pid
	var status int

	{
		var tmp int
		tmp = int(arg0)
		pid = Pid(tmp)
	}

	status = int(arg1)

	v.(ChildWatchFunc)(pid, status)
}

// CompareDataFunc specifies the type of a comparison function used to compare
// two values. The function should return a negative integer if the first value
// comes before the second, 0 if they are equal, or a positive integer if the
// first value comes after the second.
type CompareDataFunc func(a interface{}, b interface{}) int

//export gotk4_CompareDataFunc
func gotk4_CompareDataFunc(arg0 C.gpointer, arg1 C.gpointer, arg2 C.gpointer) C.gint {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var a interface{}
	var b interface{}

	a = box.Get(uintptr(arg0))

	b = box.Get(uintptr(arg1))

	gint := v.(CompareDataFunc)(a, b)
}

// DataForeachFunc specifies the type of function passed to g_dataset_foreach().
// It is called with each #GQuark id and associated data element, together with
// the @user_data parameter supplied to g_dataset_foreach().
type DataForeachFunc func(keyID Quark, data interface{})

//export gotk4_DataForeachFunc
func gotk4_DataForeachFunc(arg0 C.GQuark, arg1 C.gpointer, arg2 C.gpointer) {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var keyID Quark
	var data interface{}

	{
		var tmp uint32
		tmp = uint32(arg0)
		keyID = Quark(tmp)
	}

	data = box.Get(uintptr(arg1))

	v.(DataForeachFunc)(keyID, data)
}

// DuplicateFunc: the type of functions that are used to 'duplicate' an object.
// What this means depends on the context, it could just be incrementing the
// reference count, if @data is a ref-counted object.
type DuplicateFunc func(data interface{}) interface{}

//export gotk4_DuplicateFunc
func gotk4_DuplicateFunc(arg0 C.gpointer, arg1 C.gpointer) C.gpointer {
	v := box.Get(uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var data interface{}

	data = box.Get(uintptr(arg0))

	gpointer := v.(DuplicateFunc)(data)
}

// Func specifies the type of functions passed to g_list_foreach() and
// g_slist_foreach().
type Func func(data interface{})

//export gotk4_Func
func gotk4_Func(arg0 C.gpointer, arg1 C.gpointer) {
	v := box.Get(uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var data interface{}

	data = box.Get(uintptr(arg0))

	v.(Func)(data)
}

// HFunc specifies the type of the function passed to g_hash_table_foreach(). It
// is called with each key/value pair, together with the @user_data parameter
// which is passed to g_hash_table_foreach().
type HFunc func(key interface{}, value interface{})

//export gotk4_HFunc
func gotk4_HFunc(arg0 C.gpointer, arg1 C.gpointer, arg2 C.gpointer) {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var key interface{}
	var value interface{}

	key = box.Get(uintptr(arg0))

	value = box.Get(uintptr(arg1))

	v.(HFunc)(key, value)
}

// HRFunc specifies the type of the function passed to
// g_hash_table_foreach_remove(). It is called with each key/value pair,
// together with the @user_data parameter passed to
// g_hash_table_foreach_remove(). It should return true if the key/value pair
// should be removed from the Table.
type HRFunc func(key interface{}, value interface{}) bool

//export gotk4_HRFunc
func gotk4_HRFunc(arg0 C.gpointer, arg1 C.gpointer, arg2 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var key interface{}
	var value interface{}

	key = box.Get(uintptr(arg0))

	value = box.Get(uintptr(arg1))

	ok := v.(HRFunc)(key, value)
}

// LogFunc specifies the prototype of log handler functions.
//
// The default log handler, g_log_default_handler(), automatically appends a
// new-line character to @message when printing it. It is advised that any
// custom log handler functions behave similarly, so that logging calls in user
// code do not need modifying to add a new-line character to the message if the
// log handler is changed.
//
// This is not used if structured logging is enabled; see [Using Structured
// Logging][using-structured-logging].
type LogFunc func(logDomain string, logLevel LogLevelFlags, message string)

//export gotk4_LogFunc
func gotk4_LogFunc(arg0 *C.gchar, arg1 C.GLogLevelFlags, arg2 *C.gchar, arg3 C.gpointer) {
	v := box.Get(uintptr(arg3))
	if v == nil {
		panic(`callback not found`)
	}

	var logDomain string
	var logLevel LogLevelFlags
	var message string

	logDomain = C.GoString(arg0)

	logLevel = LogLevelFlags(arg1)

	message = C.GoString(arg2)

	v.(LogFunc)(logDomain, logLevel, message)
}

// LogWriterFunc: writer function for log entries. A log entry is a collection
// of one or more Fields, using the standard [field names from journal
// specification](https://www.freedesktop.org/software/systemd/man/systemd.journal-fields.html).
// See g_log_structured() for more information.
//
// Writer functions must ignore fields which they do not recognise, unless they
// can write arbitrary binary output, as field values may be arbitrary binary.
//
// @log_level is guaranteed to be included in @fields as the `PRIORITY` field,
// but is provided separately for convenience of deciding whether or where to
// output the log entry.
//
// Writer functions should return G_LOG_WRITER_HANDLED if they handled the log
// message successfully or if they deliberately ignored it. If there was an
// error handling the message (for example, if the writer function is meant to
// send messages to a remote logging server and there is a network error), it
// should return G_LOG_WRITER_UNHANDLED. This allows writer functions to be
// chained and fall back to simpler handlers in case of failure.
type LogWriterFunc func(logLevel LogLevelFlags, fields []LogField) LogWriterOutput

//export gotk4_LogWriterFunc
func gotk4_LogWriterFunc(arg0 C.GLogLevelFlags, arg1 *C.GLogField, arg2 C.gsize, arg3 C.gpointer) C.GLogWriterOutput {
	v := box.Get(uintptr(arg3))
	if v == nil {
		panic(`callback not found`)
	}

	var logLevel LogLevelFlags
	var fields []LogField

	logLevel = LogLevelFlags(arg0)

	{
		fields = make([]LogField, arg2)
		for i := 0; i < uintptr(arg2); i++ {
			src := (C.GLogField)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			{
				fields[i] = WrapLogField(unsafe.Pointer(src))
			}
		}
	}

	logWriterOutput := v.(LogWriterFunc)(logLevel, fields)
}

// RegexEvalCallback specifies the type of the function passed to
// g_regex_replace_eval(). It is called for each occurrence of the pattern in
// the string passed to g_regex_replace_eval(), and it should append the
// replacement to @result.
type RegexEvalCallback func(matchInfo *MatchInfo, result *String) bool

//export gotk4_RegexEvalCallback
func gotk4_RegexEvalCallback(arg0 *C.GMatchInfo, arg1 *C.GString, arg2 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var matchInfo *MatchInfo
	var result *String

	{
		matchInfo = WrapMatchInfo(unsafe.Pointer(arg0))
	}

	{
		result = WrapString(unsafe.Pointer(arg1))
	}

	ok := v.(RegexEvalCallback)(matchInfo, result)
}

// SourceFunc specifies the type of function passed to g_timeout_add(),
// g_timeout_add_full(), g_idle_add(), and g_idle_add_full().
//
// When calling g_source_set_callback(), you may need to cast a function of a
// different type to this type. Use G_SOURCE_FUNC() to avoid warnings about
// incompatible function types.
type SourceFunc func() bool

//export gotk4_SourceFunc
func gotk4_SourceFunc(arg0 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg0))
	if v == nil {
		panic(`callback not found`)
	}

	ok := v.(SourceFunc)()
}

// SpawnChildSetupFunc specifies the type of the setup function passed to
// g_spawn_async(), g_spawn_sync() and g_spawn_async_with_pipes(), which can, in
// very limited ways, be used to affect the child's execution.
//
// On POSIX platforms, the function is called in the child after GLib has
// performed all the setup it plans to perform, but before calling exec().
// Actions taken in this function will only affect the child, not the parent.
//
// On Windows, the function is called in the parent. Its usefulness on Windows
// is thus questionable. In many cases executing the child setup function in the
// parent can have ill effects, and you should be very careful when porting
// software to Windows that uses child setup functions.
//
// However, even on POSIX, you are extremely limited in what you can safely do
// from a ChildSetupFunc, because any mutexes that were held by other threads in
// the parent process at the time of the fork() will still be locked in the
// child process, and they will never be unlocked (since the threads that held
// them don't exist in the child). POSIX allows only async-signal-safe functions
// (see signal(7)) to be called in the child between fork() and exec(), which
// drastically limits the usefulness of child setup functions.
//
// In particular, it is not safe to call any function which may call malloc(),
// which includes POSIX functions such as setenv(). If you need to set up the
// child environment differently from the parent, you should use
// g_get_environ(), g_environ_setenv(), and g_environ_unsetenv(), and then pass
// the complete environment list to the `g_spawn...` function.
type SpawnChildSetupFunc func()

//export gotk4_SpawnChildSetupFunc
func gotk4_SpawnChildSetupFunc(arg0 C.gpointer) {
	v := box.Get(uintptr(arg0))
	if v == nil {
		panic(`callback not found`)
	}

	v.(SpawnChildSetupFunc)()
}

// TestDataFunc: the type used for test case functions that take an extra
// pointer argument.
type TestDataFunc func()

//export gotk4_TestDataFunc
func gotk4_TestDataFunc(arg0 C.gpointer) {
	v := box.Get(uintptr(arg0))
	if v == nil {
		panic(`callback not found`)
	}

	v.(TestDataFunc)()
}

// TestFixtureFunc: the type used for functions that operate on test fixtures.
// This is used for the fixture setup and teardown functions as well as for the
// testcases themselves.
//
// @user_data is a pointer to the data that was given when registering the test
// case.
//
// @fixture will be a pointer to the area of memory allocated by the test
// framework, of the size requested. If the requested size was zero then
// @fixture will be equal to @user_data.
type TestFixtureFunc func(fixture interface{})

//export gotk4_TestFixtureFunc
func gotk4_TestFixtureFunc(arg0 C.gpointer, arg1 C.gpointer) {
	v := box.Get(uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var fixture interface{}

	fixture = box.Get(uintptr(arg0))

	v.(TestFixtureFunc)(fixture)
}

// TestLogFatalFunc specifies the prototype of fatal log handler functions.
type TestLogFatalFunc func(logDomain string, logLevel LogLevelFlags, message string) bool

//export gotk4_TestLogFatalFunc
func gotk4_TestLogFatalFunc(arg0 *C.gchar, arg1 C.GLogLevelFlags, arg2 *C.gchar, arg3 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg3))
	if v == nil {
		panic(`callback not found`)
	}

	var logDomain string
	var logLevel LogLevelFlags
	var message string

	logDomain = C.GoString(arg0)

	logLevel = LogLevelFlags(arg1)

	message = C.GoString(arg2)

	ok := v.(TestLogFatalFunc)(logDomain, logLevel, message)
}

// UnixFDSourceFunc: the type of functions to be called when a UNIX fd watch
// source triggers.
type UnixFDSourceFunc func(fd int, condition IOCondition) bool

//export gotk4_UnixFDSourceFunc
func gotk4_UnixFDSourceFunc(arg0 C.gint, arg1 C.GIOCondition, arg2 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var fd int
	var condition IOCondition

	fd = int(arg0)

	condition = IOCondition(arg1)

	ok := v.(UnixFDSourceFunc)(fd, condition)
}

// Access: a wrapper for the POSIX access() function. This function is used to
// test a pathname for one or several of read, write or execute permissions, or
// just existence.
//
// On Windows, the file protection mechanism is not at all POSIX-like, and the
// underlying function in the C library only checks the FAT-style READONLY
// attribute, and does not look at the ACL of a file at all. This function is
// this in practise almost useless on Windows. Software that needs to handle
// file permissions on Windows more exactly should use the Win32 API.
//
// See your C library manual for more details about access().
func Access(filename string, mode int) int {
	var arg1 *C.gchar
	var arg2 C.int

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(mode)

	ret := C.g_access(arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ASCIIDigitValue determines the numeric value of a character as a decimal
// digit. Differs from g_unichar_digit_value() because it takes a char, so
// there's no worry about sign extension if characters are signed.
func ASCIIDigitValue(c byte) int {
	var arg1 C.gchar

	arg1 = C.gchar(c)

	ret := C.g_ascii_digit_value(arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ASCIIDtostr converts a #gdouble to a string, using the '.' as decimal point.
//
// This function generates enough precision that converting the string back
// using g_ascii_strtod() gives the same machine-number (on machines with IEEE
// compatible 64bit doubles). It is guaranteed that the size of the resulting
// string will never be larger than @G_ASCII_DTOSTR_BUF_SIZE bytes, including
// the terminating nul character, which is always added.
func ASCIIDtostr(buffer string, bufLen int, d float64) string {
	var arg1 *C.gchar
	var arg2 C.gint
	var arg3 C.gdouble

	arg1 = (*C.gchar)(C.CString(buffer))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(bufLen)
	arg3 = C.gdouble(d)

	ret := C.g_ascii_dtostr(arg1, arg2, arg3)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// ASCIIFormatd converts a #gdouble to a string, using the '.' as decimal point.
// To format the number you pass in a printf()-style format string. Allowed
// conversion specifiers are 'e', 'E', 'f', 'F', 'g' and 'G'.
//
// The returned buffer is guaranteed to be nul-terminated.
//
// If you just want to want to serialize the value into a string, use
// g_ascii_dtostr().
func ASCIIFormatd(buffer string, bufLen int, format string, d float64) string {
	var arg1 *C.gchar
	var arg2 C.gint
	var arg3 *C.gchar
	var arg4 C.gdouble

	arg1 = (*C.gchar)(C.CString(buffer))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(bufLen)
	arg3 = (*C.gchar)(C.CString(format))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = C.gdouble(d)

	ret := C.g_ascii_formatd(arg1, arg2, arg3, arg4)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// ASCIIStrcasecmp: compare two strings, ignoring the case of ASCII characters.
//
// Unlike the BSD strcasecmp() function, this only recognizes standard ASCII
// letters and ignores the locale, treating all non-ASCII bytes as if they are
// not letters.
//
// This function should be used only on strings that are known to be in
// encodings where the bytes corresponding to ASCII letters always represent
// themselves. This includes UTF-8 and the ISO-8859-* charsets, but not for
// instance double-byte encodings like the Windows Codepage 932, where the
// trailing bytes of double-byte characters include all ASCII letters. If you
// compare two CP932 strings using this function, you will get false matches.
//
// Both @s1 and @s2 must be non-nil.
func ASCIIStrcasecmp(s1 string, s2 string) int {
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg1 = (*C.gchar)(C.CString(s1))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(s2))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_ascii_strcasecmp(arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ASCIIStrdown converts all upper case ASCII letters to lower case ASCII
// letters.
func ASCIIStrdown(str string, len int) string {
	var arg1 *C.gchar
	var arg2 C.gssize

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(len)

	ret := C.g_ascii_strdown(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// ASCIIStringToSigned: a convenience function for converting a string to a
// signed number.
//
// This function assumes that @str contains only a number of the given @base
// that is within inclusive bounds limited by @min and @max. If this is true,
// then the converted number is stored in @out_num. An empty string is not a
// valid input. A string with leading or trailing whitespace is also an invalid
// input.
//
// @base can be between 2 and 36 inclusive. Hexadecimal numbers must not be
// prefixed with "0x" or "0X". Such a problem does not exist for octal numbers,
// since they were usually prefixed with a zero which does not change the value
// of the parsed number.
//
// Parsing failures result in an error with the G_NUMBER_PARSER_ERROR domain. If
// the input is invalid, the error code will be G_NUMBER_PARSER_ERROR_INVALID.
// If the parsed number is out of bounds - G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS.
//
// See g_ascii_strtoll() if you have more complex needs such as parsing a string
// which starts with a number, but then has other characters.
func ASCIIStringToSigned(str string, base uint, min int64, max int64) (outNum int64, err error) {
	var arg1 *C.gchar
	var arg2 C.guint
	var arg3 C.gint64
	var arg4 C.gint64
	var arg5 *C.gint64 // out
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.guint(base)
	arg3 = C.gint64(min)
	arg4 = C.gint64(max)

	ret := C.g_ascii_string_to_signed(arg1, arg2, arg3, arg4, &arg5, &gError)

	var ret0 int64
	var goError error

	ret0 = int64(arg5)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// ASCIIStringToUnsigned: a convenience function for converting a string to an
// unsigned number.
//
// This function assumes that @str contains only a number of the given @base
// that is within inclusive bounds limited by @min and @max. If this is true,
// then the converted number is stored in @out_num. An empty string is not a
// valid input. A string with leading or trailing whitespace is also an invalid
// input. A string with a leading sign (`-` or `+`) is not a valid input for the
// unsigned parser.
//
// @base can be between 2 and 36 inclusive. Hexadecimal numbers must not be
// prefixed with "0x" or "0X". Such a problem does not exist for octal numbers,
// since they were usually prefixed with a zero which does not change the value
// of the parsed number.
//
// Parsing failures result in an error with the G_NUMBER_PARSER_ERROR domain. If
// the input is invalid, the error code will be G_NUMBER_PARSER_ERROR_INVALID.
// If the parsed number is out of bounds - G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS.
//
// See g_ascii_strtoull() if you have more complex needs such as parsing a
// string which starts with a number, but then has other characters.
func ASCIIStringToUnsigned(str string, base uint, min uint64, max uint64) (outNum uint64, err error) {
	var arg1 *C.gchar
	var arg2 C.guint
	var arg3 C.guint64
	var arg4 C.guint64
	var arg5 *C.guint64 // out
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.guint(base)
	arg3 = C.guint64(min)
	arg4 = C.guint64(max)

	ret := C.g_ascii_string_to_unsigned(arg1, arg2, arg3, arg4, &arg5, &gError)

	var ret0 uint64
	var goError error

	ret0 = uint64(arg5)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// ASCIIStrncasecmp: compare @s1 and @s2, ignoring the case of ASCII characters
// and any characters after the first @n in each string.
//
// Unlike the BSD strcasecmp() function, this only recognizes standard ASCII
// letters and ignores the locale, treating all non-ASCII characters as if they
// are not letters.
//
// The same warning as in g_ascii_strcasecmp() applies: Use this function only
// on strings known to be in encodings where bytes corresponding to ASCII
// letters always represent themselves.
func ASCIIStrncasecmp(s1 string, s2 string, n uint) int {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 C.gsize

	arg1 = (*C.gchar)(C.CString(s1))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(s2))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.gsize(n)

	ret := C.g_ascii_strncasecmp(arg1, arg2, arg3)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ASCIIStrtod converts a string to a #gdouble value.
//
// This function behaves like the standard strtod() function does in the C
// locale. It does this without actually changing the current locale, since that
// would not be thread-safe. A limitation of the implementation is that this
// function will still accept localized versions of infinities and NANs.
//
// This function is typically used when reading configuration files or other
// non-user input that should be locale independent. To handle input from the
// user you should normally use the locale-sensitive system strtod() function.
//
// To convert from a #gdouble to a string in a locale-insensitive way, use
// g_ascii_dtostr().
//
// If the correct value would cause overflow, plus or minus HUGE_VAL is returned
// (according to the sign of the value), and ERANGE is stored in errno. If the
// correct value would cause underflow, zero is returned and ERANGE is stored in
// errno.
//
// This function resets errno before calling strtod() so that you can reliably
// detect overflow and underflow.
func ASCIIStrtod(nptr string) (endptr string, gdouble float64) {
	var arg1 *C.gchar
	var arg2 **C.gchar // out

	arg1 = (*C.gchar)(C.CString(nptr))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_ascii_strtod(arg1, &arg2)

	var ret0 string
	var ret1 float64

	ret0 = C.GoString(arg2)

	ret1 = float64(ret)

	return ret0, ret1
}

// ASCIIStrtoll converts a string to a #gint64 value. This function behaves like
// the standard strtoll() function does in the C locale. It does this without
// actually changing the current locale, since that would not be thread-safe.
//
// This function is typically used when reading configuration files or other
// non-user input that should be locale independent. To handle input from the
// user you should normally use the locale-sensitive system strtoll() function.
//
// If the correct value would cause overflow, G_MAXINT64 or G_MININT64 is
// returned, and `ERANGE` is stored in `errno`. If the base is outside the valid
// range, zero is returned, and `EINVAL` is stored in `errno`. If the string
// conversion fails, zero is returned, and @endptr returns @nptr (if @endptr is
// non-nil).
func ASCIIStrtoll(nptr string, base uint) (endptr string, gint64 int64) {
	var arg1 *C.gchar
	var arg2 **C.gchar // out
	var arg3 C.guint

	arg1 = (*C.gchar)(C.CString(nptr))
	defer C.free(unsafe.Pointer(arg1))
	arg3 = C.guint(base)

	ret := C.g_ascii_strtoll(arg1, &arg2, arg3)

	var ret0 string
	var ret1 int64

	ret0 = C.GoString(arg2)

	ret1 = int64(ret)

	return ret0, ret1
}

// ASCIIStrtoull converts a string to a #guint64 value. This function behaves
// like the standard strtoull() function does in the C locale. It does this
// without actually changing the current locale, since that would not be
// thread-safe.
//
// Note that input with a leading minus sign (`-`) is accepted, and will return
// the negation of the parsed number, unless that would overflow a #guint64.
// Critically, this means you cannot assume that a short fixed length input will
// never result in a low return value, as the input could have a leading `-`.
//
// This function is typically used when reading configuration files or other
// non-user input that should be locale independent. To handle input from the
// user you should normally use the locale-sensitive system strtoull() function.
//
// If the correct value would cause overflow, G_MAXUINT64 is returned, and
// `ERANGE` is stored in `errno`. If the base is outside the valid range, zero
// is returned, and `EINVAL` is stored in `errno`. If the string conversion
// fails, zero is returned, and @endptr returns @nptr (if @endptr is non-nil).
func ASCIIStrtoull(nptr string, base uint) (endptr string, guint64 uint64) {
	var arg1 *C.gchar
	var arg2 **C.gchar // out
	var arg3 C.guint

	arg1 = (*C.gchar)(C.CString(nptr))
	defer C.free(unsafe.Pointer(arg1))
	arg3 = C.guint(base)

	ret := C.g_ascii_strtoull(arg1, &arg2, arg3)

	var ret0 string
	var ret1 uint64

	ret0 = C.GoString(arg2)

	ret1 = uint64(ret)

	return ret0, ret1
}

// ASCIIStrup converts all lower case ASCII letters to upper case ASCII letters.
func ASCIIStrup(str string, len int) string {
	var arg1 *C.gchar
	var arg2 C.gssize

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(len)

	ret := C.g_ascii_strup(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// ASCIIToLower: convert a character to ASCII lower case.
//
// Unlike the standard C library tolower() function, this only recognizes
// standard ASCII letters and ignores the locale, returning all non-ASCII
// characters unchanged, even if they are lower case letters in a particular
// character set. Also unlike the standard library function, this takes and
// returns a char, not an int, so don't call it on EOF but no need to worry
// about casting to #guchar before passing a possibly non-ASCII character in.
func ASCIIToLower(c byte) byte {
	var arg1 C.gchar

	arg1 = C.gchar(c)

	ret := C.g_ascii_tolower(arg1)

	var ret0 byte

	ret0 = byte(ret)

	return ret0
}

// ASCIIToUpper: convert a character to ASCII upper case.
//
// Unlike the standard C library toupper() function, this only recognizes
// standard ASCII letters and ignores the locale, returning all non-ASCII
// characters unchanged, even if they are upper case letters in a particular
// character set. Also unlike the standard library function, this takes and
// returns a char, not an int, so don't call it on EOF but no need to worry
// about casting to #guchar before passing a possibly non-ASCII character in.
func ASCIIToUpper(c byte) byte {
	var arg1 C.gchar

	arg1 = C.gchar(c)

	ret := C.g_ascii_toupper(arg1)

	var ret0 byte

	ret0 = byte(ret)

	return ret0
}

// ASCIIXDigitValue determines the numeric value of a character as a hexadecimal
// digit. Differs from g_unichar_xdigit_value() because it takes a char, so
// there's no worry about sign extension if characters are signed.
func ASCIIXDigitValue(c byte) int {
	var arg1 C.gchar

	arg1 = C.gchar(c)

	ret := C.g_ascii_xdigit_value(arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

func AssertWarning(logDomain string, file string, line int, prettyFunction string, expression string) {
	var arg1 *C.char
	var arg2 *C.char
	var arg3 C.int
	var arg4 *C.char
	var arg5 *C.char

	arg1 = (*C.gchar)(C.CString(logDomain))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(file))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.int(line)
	arg4 = (*C.gchar)(C.CString(prettyFunction))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.gchar)(C.CString(expression))
	defer C.free(unsafe.Pointer(arg5))

	C.g_assert_warning(arg1, arg2, arg3, arg4, arg5)
}

func AssertionMessage(domain string, file string, line int, fn string, message string) {
	var arg1 *C.char
	var arg2 *C.char
	var arg3 C.int
	var arg4 *C.char
	var arg5 *C.char

	arg1 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(file))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.int(line)
	arg4 = (*C.gchar)(C.CString(fn))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.gchar)(C.CString(message))
	defer C.free(unsafe.Pointer(arg5))

	C.g_assertion_message(arg1, arg2, arg3, arg4, arg5)
}

func AssertionMessageCmpnum(domain string, file string, line int, fn string, expr string, arg1 float64, cmp string, arg2 float64, numtype byte) {
	var arg1 *C.char
	var arg2 *C.char
	var arg3 C.int
	var arg4 *C.char
	var arg5 *C.char
	var arg6 C.longdouble
	var arg7 *C.char
	var arg8 C.longdouble
	var arg9 C.char

	arg1 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(file))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.int(line)
	arg4 = (*C.gchar)(C.CString(fn))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.gchar)(C.CString(expr))
	defer C.free(unsafe.Pointer(arg5))
	arg6 = C.longdouble(arg1)
	arg7 = (*C.gchar)(C.CString(cmp))
	defer C.free(unsafe.Pointer(arg7))
	arg8 = C.longdouble(arg2)
	arg9 = C.char(numtype)

	C.g_assertion_message_cmpnum(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
}

func AssertionMessageCmpstr(domain string, file string, line int, fn string, expr string, arg1 string, cmp string, arg2 string) {
	var arg1 *C.char
	var arg2 *C.char
	var arg3 C.int
	var arg4 *C.char
	var arg5 *C.char
	var arg6 *C.char
	var arg7 *C.char
	var arg8 *C.char

	arg1 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(file))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.int(line)
	arg4 = (*C.gchar)(C.CString(fn))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.gchar)(C.CString(expr))
	defer C.free(unsafe.Pointer(arg5))
	arg6 = (*C.gchar)(C.CString(arg1))
	defer C.free(unsafe.Pointer(arg6))
	arg7 = (*C.gchar)(C.CString(cmp))
	defer C.free(unsafe.Pointer(arg7))
	arg8 = (*C.gchar)(C.CString(arg2))
	defer C.free(unsafe.Pointer(arg8))

	C.g_assertion_message_cmpstr(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
}

// AssertionMessageExpr: internal function used to print messages from the
// public g_assert() and g_assert_not_reached() macros.
func AssertionMessageExpr(domain string, file string, line int, fn string, expr string) {
	var arg1 *C.char
	var arg2 *C.char
	var arg3 C.int
	var arg4 *C.char
	var arg5 *C.char

	arg1 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(file))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.int(line)
	arg4 = (*C.gchar)(C.CString(fn))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.gchar)(C.CString(expr))
	defer C.free(unsafe.Pointer(arg5))

	C.g_assertion_message_expr(arg1, arg2, arg3, arg4, arg5)
}

// AtomicIntAdd: atomically adds @val to the value of @atomic.
//
// Think of this operation as an atomic version of `{ tmp = *atomic; *atomic +=
// val; return tmp; }`.
//
// This call acts as a full compiler and hardware memory barrier.
//
// Before version 2.30, this function did not return a value (but
// g_atomic_int_exchange_and_add() did, and had the same meaning).
func AtomicIntAdd(atomic int, val int) int {
	var arg1 *C.gint
	var arg2 C.gint

	arg1 = (*C.gint)(atomic)
	arg2 = C.gint(val)

	ret := C.g_atomic_int_add(arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// AtomicIntAnd performs an atomic bitwise 'and' of the value of @atomic and
// @val, storing the result back in @atomic.
//
// This call acts as a full compiler and hardware memory barrier.
//
// Think of this operation as an atomic version of `{ tmp = *atomic; *atomic &=
// val; return tmp; }`.
func AtomicIntAnd(atomic uint, val uint) uint {
	var arg1 *C.guint
	var arg2 C.guint

	arg1 = (*C.guint)(atomic)
	arg2 = C.guint(val)

	ret := C.g_atomic_int_and(arg1, arg2)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// AtomicIntCompareAndExchange compares @atomic to @oldval and, if equal, sets
// it to @newval. If @atomic was not equal to @oldval then no change occurs.
//
// This compare and exchange is done atomically.
//
// Think of this operation as an atomic version of `{ if (*atomic == oldval) {
// *atomic = newval; return TRUE; } else return FALSE; }`.
//
// This call acts as a full compiler and hardware memory barrier.
func AtomicIntCompareAndExchange(atomic int, oldval int, newval int) bool {
	var arg1 *C.gint
	var arg2 C.gint
	var arg3 C.gint

	arg1 = (*C.gint)(atomic)
	arg2 = C.gint(oldval)
	arg3 = C.gint(newval)

	ret := C.g_atomic_int_compare_and_exchange(arg1, arg2, arg3)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// AtomicIntDecAndTest decrements the value of @atomic by 1.
//
// Think of this operation as an atomic version of `{ *atomic -= 1; return
// (*atomic == 0); }`.
//
// This call acts as a full compiler and hardware memory barrier.
func AtomicIntDecAndTest(atomic int) bool {
	var arg1 *C.gint

	arg1 = (*C.gint)(atomic)

	ret := C.g_atomic_int_dec_and_test(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// AtomicIntExchangeAndAdd: this function existed before g_atomic_int_add()
// returned the prior value of the integer (which it now does). It is retained
// only for compatibility reasons. Don't use this function in new code.
func AtomicIntExchangeAndAdd(atomic int, val int) int {
	var arg1 *C.gint
	var arg2 C.gint

	arg1 = (*C.gint)(atomic)
	arg2 = C.gint(val)

	ret := C.g_atomic_int_exchange_and_add(arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// AtomicIntGet gets the current value of @atomic.
//
// This call acts as a full compiler and hardware memory barrier (before the
// get).
func AtomicIntGet(atomic int) int {
	var arg1 *C.gint

	arg1 = (*C.gint)(atomic)

	ret := C.g_atomic_int_get(arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// AtomicIntInc increments the value of @atomic by 1.
//
// Think of this operation as an atomic version of `{ *atomic += 1; }`.
//
// This call acts as a full compiler and hardware memory barrier.
func AtomicIntInc(atomic int) {
	var arg1 *C.gint

	arg1 = (*C.gint)(atomic)

	C.g_atomic_int_inc(arg1)
}

// AtomicIntOr performs an atomic bitwise 'or' of the value of @atomic and @val,
// storing the result back in @atomic.
//
// Think of this operation as an atomic version of `{ tmp = *atomic; *atomic |=
// val; return tmp; }`.
//
// This call acts as a full compiler and hardware memory barrier.
func AtomicIntOr(atomic uint, val uint) uint {
	var arg1 *C.guint
	var arg2 C.guint

	arg1 = (*C.guint)(atomic)
	arg2 = C.guint(val)

	ret := C.g_atomic_int_or(arg1, arg2)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// AtomicIntSet sets the value of @atomic to @newval.
//
// This call acts as a full compiler and hardware memory barrier (after the
// set).
func AtomicIntSet(atomic int, newval int) {
	var arg1 *C.gint
	var arg2 C.gint

	arg1 = (*C.gint)(atomic)
	arg2 = C.gint(newval)

	C.g_atomic_int_set(arg1, arg2)
}

// AtomicIntXor performs an atomic bitwise 'xor' of the value of @atomic and
// @val, storing the result back in @atomic.
//
// Think of this operation as an atomic version of `{ tmp = *atomic; *atomic ^=
// val; return tmp; }`.
//
// This call acts as a full compiler and hardware memory barrier.
func AtomicIntXor(atomic uint, val uint) uint {
	var arg1 *C.guint
	var arg2 C.guint

	arg1 = (*C.guint)(atomic)
	arg2 = C.guint(val)

	ret := C.g_atomic_int_xor(arg1, arg2)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// AtomicPointerAdd: atomically adds @val to the value of @atomic.
//
// Think of this operation as an atomic version of `{ tmp = *atomic; *atomic +=
// val; return tmp; }`.
//
// This call acts as a full compiler and hardware memory barrier.
func AtomicPointerAdd(atomic interface{}, val int) int {
	var arg1 *C.void
	var arg2 C.gssize

	arg1 = C.gpointer(box.Assign(atomic))
	arg2 = C.gssize(val)

	ret := C.g_atomic_pointer_add(arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// AtomicPointerAnd performs an atomic bitwise 'and' of the value of @atomic and
// @val, storing the result back in @atomic.
//
// Think of this operation as an atomic version of `{ tmp = *atomic; *atomic &=
// val; return tmp; }`.
//
// This call acts as a full compiler and hardware memory barrier.
func AtomicPointerAnd(atomic interface{}, val uint) uint {
	var arg1 *C.void
	var arg2 C.gsize

	arg1 = C.gpointer(box.Assign(atomic))
	arg2 = C.gsize(val)

	ret := C.g_atomic_pointer_and(arg1, arg2)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// AtomicPointerCompareAndExchange compares @atomic to @oldval and, if equal,
// sets it to @newval. If @atomic was not equal to @oldval then no change
// occurs.
//
// This compare and exchange is done atomically.
//
// Think of this operation as an atomic version of `{ if (*atomic == oldval) {
// *atomic = newval; return TRUE; } else return FALSE; }`.
//
// This call acts as a full compiler and hardware memory barrier.
func AtomicPointerCompareAndExchange(atomic interface{}, oldval interface{}, newval interface{}) bool {
	var arg1 *C.void
	var arg2 C.gpointer
	var arg3 C.gpointer

	arg1 = C.gpointer(box.Assign(atomic))
	arg2 = C.gpointer(box.Assign(oldval))
	arg3 = C.gpointer(box.Assign(newval))

	ret := C.g_atomic_pointer_compare_and_exchange(arg1, arg2, arg3)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// AtomicPointerGet gets the current value of @atomic.
//
// This call acts as a full compiler and hardware memory barrier (before the
// get).
func AtomicPointerGet(atomic interface{}) interface{} {
	var arg1 *C.void

	arg1 = C.gpointer(box.Assign(atomic))

	ret := C.g_atomic_pointer_get(arg1)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// AtomicPointerOr performs an atomic bitwise 'or' of the value of @atomic and
// @val, storing the result back in @atomic.
//
// Think of this operation as an atomic version of `{ tmp = *atomic; *atomic |=
// val; return tmp; }`.
//
// This call acts as a full compiler and hardware memory barrier.
func AtomicPointerOr(atomic interface{}, val uint) uint {
	var arg1 *C.void
	var arg2 C.gsize

	arg1 = C.gpointer(box.Assign(atomic))
	arg2 = C.gsize(val)

	ret := C.g_atomic_pointer_or(arg1, arg2)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// AtomicPointerSet sets the value of @atomic to @newval.
//
// This call acts as a full compiler and hardware memory barrier (after the
// set).
func AtomicPointerSet(atomic interface{}, newval interface{}) {
	var arg1 *C.void
	var arg2 C.gpointer

	arg1 = C.gpointer(box.Assign(atomic))
	arg2 = C.gpointer(box.Assign(newval))

	C.g_atomic_pointer_set(arg1, arg2)
}

// AtomicPointerXor performs an atomic bitwise 'xor' of the value of @atomic and
// @val, storing the result back in @atomic.
//
// Think of this operation as an atomic version of `{ tmp = *atomic; *atomic ^=
// val; return tmp; }`.
//
// This call acts as a full compiler and hardware memory barrier.
func AtomicPointerXor(atomic interface{}, val uint) uint {
	var arg1 *C.void
	var arg2 C.gsize

	arg1 = C.gpointer(box.Assign(atomic))
	arg2 = C.gsize(val)

	ret := C.g_atomic_pointer_xor(arg1, arg2)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// AtomicRCBoxAcquire: atomically acquires a reference on the data pointed by
// @mem_block.
func AtomicRCBoxAcquire(memBlock interface{}) interface{} {
	var arg1 C.gpointer

	arg1 = C.gpointer(box.Assign(memBlock))

	ret := C.g_atomic_rc_box_acquire(arg1)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// AtomicRCBoxAlloc allocates @block_size bytes of memory, and adds atomic
// reference counting semantics to it.
//
// The data will be freed when its reference count drops to zero.
//
// The allocated data is guaranteed to be suitably aligned for any built-in
// type.
func AtomicRCBoxAlloc(blockSize uint) interface{} {
	var arg1 C.gsize

	arg1 = C.gsize(blockSize)

	ret := C.g_atomic_rc_box_alloc(arg1)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// AtomicRCBoxAlloc0 allocates @block_size bytes of memory, and adds atomic
// reference counting semantics to it.
//
// The contents of the returned data is set to zero.
//
// The data will be freed when its reference count drops to zero.
//
// The allocated data is guaranteed to be suitably aligned for any built-in
// type.
func AtomicRCBoxAlloc0(blockSize uint) interface{} {
	var arg1 C.gsize

	arg1 = C.gsize(blockSize)

	ret := C.g_atomic_rc_box_alloc0(arg1)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// AtomicRCBoxDup allocates a new block of data with atomic reference counting
// semantics, and copies @block_size bytes of @mem_block into it.
func AtomicRCBoxDup(blockSize uint, memBlock interface{}) interface{} {
	var arg1 C.gsize
	var arg2 C.gpointer

	arg1 = C.gsize(blockSize)
	arg2 = C.gpointer(box.Assign(memBlock))

	ret := C.g_atomic_rc_box_dup(arg1, arg2)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// AtomicRCBoxGetSize retrieves the size of the reference counted data pointed
// by @mem_block.
func AtomicRCBoxGetSize(memBlock interface{}) uint {
	var arg1 C.gpointer

	arg1 = C.gpointer(box.Assign(memBlock))

	ret := C.g_atomic_rc_box_get_size(arg1)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// AtomicRCBoxRelease: atomically releases a reference on the data pointed by
// @mem_block.
//
// If the reference was the last one, it will free the resources allocated for
// @mem_block.
func AtomicRCBoxRelease(memBlock interface{}) {
	var arg1 C.gpointer

	arg1 = C.gpointer(box.Assign(memBlock))

	C.g_atomic_rc_box_release(arg1)
}

// AtomicRefCountCompare: atomically compares the current value of @arc with
// @val.
func AtomicRefCountCompare(arc int, val int) bool {
	var arg1 *C.gatomicrefcount
	var arg2 C.gint

	arg1 = (*C.gatomicrefcount)(arc)
	arg2 = C.gint(val)

	ret := C.g_atomic_ref_count_compare(arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// AtomicRefCountDec: atomically decreases the reference count.
func AtomicRefCountDec(arc int) bool {
	var arg1 *C.gatomicrefcount

	arg1 = (*C.gatomicrefcount)(arc)

	ret := C.g_atomic_ref_count_dec(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// AtomicRefCountInc: atomically increases the reference count.
func AtomicRefCountInc(arc int) {
	var arg1 *C.gatomicrefcount

	arg1 = (*C.gatomicrefcount)(arc)

	C.g_atomic_ref_count_inc(arg1)
}

// AtomicRefCountInit initializes a reference count variable.
func AtomicRefCountInit(arc int) {
	var arg1 *C.gatomicrefcount

	arg1 = (*C.gatomicrefcount)(arc)

	C.g_atomic_ref_count_init(arg1)
}

// Base64Decode: decode a sequence of Base-64 encoded text into binary data.
// Note that the returned binary data is not necessarily zero-terminated, so it
// should not be used as a character string.
func Base64Decode(text string) (outLen uint, guint8s []byte) {
	var arg1 *C.gchar
	var arg2 *C.gsize // out

	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_base64_decode(arg1, &arg2)

	var ret0 uint
	var ret1 []byte

	ret0 = uint(arg2)

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret1))
		sliceHeader.Data = uintptr(unsafe.Pointer(ret))
		sliceHeader.Len = arg2
		sliceHeader.Cap = arg2
		runtime.SetFinalizer(&ret, func() {
			C.free(unsafe.Pointer(ret))
		})
		defer runtime.KeepAlive(ret)
	}

	return ret0, ret1
}

// Base64DecodeInplace: decode a sequence of Base-64 encoded text into binary
// data by overwriting the input data.
func Base64DecodeInplace(text []byte) byte {
	var arg1 *C.gchar
	var arg2 *C.gsize

	{
		var dst []C.guint8
		ptr := C.malloc(C.sizeof_guint8 * len(text))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(text)
		sliceHeader.Cap = len(text)

		for i := 0; i < len(text); i++ {
			src := text[i]
			dst[i] = C.guint8(src)
		}

		arg1 = (*C.gchar)(unsafe.Pointer(ptr))
		arg2 = len(text)
	}

	ret := C.g_base64_decode_inplace(arg1, arg2)

	var ret0 byte

	ret0 = byte(ret)

	return ret0
}

// Base64Encode: encode a sequence of binary data into its Base-64 stringified
// representation.
func Base64Encode(data []byte) string {
	var arg1 *C.guchar
	var arg2 C.gsize

	arg1 = (*C.guchar)(unsafe.Pointer(&data[0]))
	arg2 = len(data)
	defer runtime.KeepAlive(data)

	ret := C.g_base64_encode(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Basename gets the name of the file without any leading directory components.
// It returns a pointer into the given file name string.
func Basename(fileName string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_basename(arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// BitLock sets the indicated @lock_bit in @address. If the bit is already set,
// this call will block until g_bit_unlock() unsets the corresponding bit.
//
// Attempting to lock on two different bits within the same integer is not
// supported and will very probably cause deadlocks.
//
// The value of the bit that is set is (1u << @bit). If @bit is not between 0
// and 31 then the result is undefined.
//
// This function accesses @address atomically. All other accesses to @address
// must be atomic in order for this function to work reliably.
func BitLock(address int, lockBit int) {
	var arg1 *C.gint
	var arg2 C.gint

	arg1 = (*C.gint)(address)
	arg2 = C.gint(lockBit)

	C.g_bit_lock(arg1, arg2)
}

// BitNthLsf: find the position of the first bit set in @mask, searching from
// (but not including) @nth_bit upwards. Bits are numbered from 0 (least
// significant) to sizeof(#gulong) * 8 - 1 (31 or 63, usually). To start
// searching from the 0th bit, set @nth_bit to -1.
func BitNthLsf(mask uint32, nthBit int) int {
	var arg1 C.gulong
	var arg2 C.gint

	arg1 = C.gulong(mask)
	arg2 = C.gint(nthBit)

	ret := C.g_bit_nth_lsf(arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// BitNthMsf: find the position of the first bit set in @mask, searching from
// (but not including) @nth_bit downwards. Bits are numbered from 0 (least
// significant) to sizeof(#gulong) * 8 - 1 (31 or 63, usually). To start
// searching from the last bit, set @nth_bit to -1 or GLIB_SIZEOF_LONG * 8.
func BitNthMsf(mask uint32, nthBit int) int {
	var arg1 C.gulong
	var arg2 C.gint

	arg1 = C.gulong(mask)
	arg2 = C.gint(nthBit)

	ret := C.g_bit_nth_msf(arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// BitStorage gets the number of bits used to hold @number, e.g. if @number is
// 4, 3 bits are needed.
func BitStorage(number uint32) uint {
	var arg1 C.gulong

	arg1 = C.gulong(number)

	ret := C.g_bit_storage(arg1)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// BitTrylock sets the indicated @lock_bit in @address, returning true if
// successful. If the bit is already set, returns false immediately.
//
// Attempting to lock on two different bits within the same integer is not
// supported.
//
// The value of the bit that is set is (1u << @bit). If @bit is not between 0
// and 31 then the result is undefined.
//
// This function accesses @address atomically. All other accesses to @address
// must be atomic in order for this function to work reliably.
func BitTrylock(address int, lockBit int) bool {
	var arg1 *C.gint
	var arg2 C.gint

	arg1 = (*C.gint)(address)
	arg2 = C.gint(lockBit)

	ret := C.g_bit_trylock(arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// BitUnlock clears the indicated @lock_bit in @address. If another thread is
// currently blocked in g_bit_lock() on this same bit then it will be woken up.
//
// This function accesses @address atomically. All other accesses to @address
// must be atomic in order for this function to work reliably.
func BitUnlock(address int, lockBit int) {
	var arg1 *C.gint
	var arg2 C.gint

	arg1 = (*C.gint)(address)
	arg2 = C.gint(lockBit)

	C.g_bit_unlock(arg1, arg2)
}

func BookmarkFileErrorQuark() Quark {

	ret := C.g_bookmark_file_error_quark()

	var ret0 Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = Quark(tmp)
	}

	return ret0
}

// BuildFilenamev behaves exactly like g_build_filename(), but takes the path
// elements as a string array, instead of varargs. This function is mainly meant
// for language bindings.
func BuildFilenamev(args []string) string {
	var arg1 **C.gchar

	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(args) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(args)
		sliceHeader.Cap = len(args)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(args); i++ {
			src := args[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg1 = (**C.gchar)(unsafe.Pointer(ptr))
	}

	ret := C.g_build_filenamev(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// BuildPathv behaves exactly like g_build_path(), but takes the path elements
// as a string array, instead of varargs. This function is mainly meant for
// language bindings.
func BuildPathv(separator string, args []string) string {
	var arg1 *C.gchar
	var arg2 **C.gchar

	arg1 = (*C.gchar)(C.CString(separator))
	defer C.free(unsafe.Pointer(arg1))
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(args) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(args)
		sliceHeader.Cap = len(args)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(args); i++ {
			src := args[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg2 = (**C.gchar)(unsafe.Pointer(ptr))
	}

	ret := C.g_build_pathv(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// ByteArrayFree frees the memory allocated by the Array. If @free_segment is
// true it frees the actual byte data. If the reference count of @array is
// greater than one, the Array wrapper is preserved but the size of @array will
// be set to zero.
func ByteArrayFree(array []byte, freeSegment bool) byte {
	var arg1 *C.GByteArray
	var arg2 C.gboolean

	{
		var dst []C.guint8
		ptr := C.malloc(C.sizeof_guint8 * (len(array) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(array)
		sliceHeader.Cap = len(array)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(array); i++ {
			src := array[i]
			dst[i] = C.guint8(src)
		}

		arg1 = (*C.GByteArray)(unsafe.Pointer(ptr))
	}
	if freeSegment {
		arg2 = C.TRUE
	}

	ret := C.g_byte_array_free(arg1, arg2)

	var ret0 byte

	ret0 = byte(ret)

	return ret0
}

// ByteArrayFreeToBytes transfers the data from the Array into a new immutable
// #GBytes.
//
// The Array is freed unless the reference count of @array is greater than one,
// the Array wrapper is preserved but the size of @array will be set to zero.
//
// This is identical to using g_bytes_new_take() and g_byte_array_free()
// together.
func ByteArrayFreeToBytes(array []byte) *Bytes {
	var arg1 *C.GByteArray

	{
		var dst []C.guint8
		ptr := C.malloc(C.sizeof_guint8 * (len(array) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(array)
		sliceHeader.Cap = len(array)

		for i := 0; i < len(array); i++ {
			src := array[i]
			dst[i] = C.guint8(src)
		}

		arg1 = (*C.GByteArray)(unsafe.Pointer(ptr))
	}

	ret := C.g_byte_array_free_to_bytes(arg1)

	var ret0 *Bytes

	{
		ret0 = WrapBytes(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Bytes) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewByteArray creates a new Array with a reference count of 1.
func NewByteArray() []byte {

	ret := C.g_byte_array_new()

	var ret0 []byte

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]byte, length)
		for i := 0; i < length; i++ {
			src := (C.guint8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = byte(src)
		}
	}

	return ret0
}

// ByteArrayNewTake: create byte array containing the data. The data will be
// owned by the array and will be freed with g_free(), i.e. it could be
// allocated using g_strdup().
func ByteArrayNewTake(data []byte) []byte {
	var arg1 *C.guint8
	var arg2 C.gsize

	{
		var dst []C.guint8
		ptr := C.malloc(C.sizeof_guint8 * len(data))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(data)
		sliceHeader.Cap = len(data)

		for i := 0; i < len(data); i++ {
			src := data[i]
			dst[i] = C.guint8(src)
		}

		arg1 = (*C.guint8)(unsafe.Pointer(ptr))
		arg2 = len(data)
	}

	ret := C.g_byte_array_new_take(arg1, arg2)

	var ret0 []byte

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]byte, length)
		for i := 0; i < length; i++ {
			src := (C.guint8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = byte(src)
		}
	}

	return ret0
}

// ByteArraySteal frees the data in the array and resets the size to zero, while
// the underlying array is preserved for use elsewhere and returned to the
// caller.
func ByteArraySteal(array []byte) (len uint, guint8 byte) {
	var arg1 *C.GByteArray
	var arg2 *C.gsize // out

	{
		var dst []C.guint8
		ptr := C.malloc(C.sizeof_guint8 * (len(array) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(array)
		sliceHeader.Cap = len(array)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(array); i++ {
			src := array[i]
			dst[i] = C.guint8(src)
		}

		arg1 = (*C.GByteArray)(unsafe.Pointer(ptr))
	}

	ret := C.g_byte_array_steal(arg1, &arg2)

	var ret0 uint
	var ret1 byte

	ret0 = uint(arg2)

	ret1 = byte(ret)

	return ret0, ret1
}

// ByteArrayUnref: atomically decrements the reference count of @array by one.
// If the reference count drops to 0, all memory allocated by the array is
// released. This function is thread-safe and may be called from any thread.
func ByteArrayUnref(array []byte) {
	var arg1 *C.GByteArray

	{
		var dst []C.guint8
		ptr := C.malloc(C.sizeof_guint8 * (len(array) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(array)
		sliceHeader.Cap = len(array)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(array); i++ {
			src := array[i]
			dst[i] = C.guint8(src)
		}

		arg1 = (*C.GByteArray)(unsafe.Pointer(ptr))
	}

	C.g_byte_array_unref(arg1)
}

// CanonicalizeFilename gets the canonical file name from @filename. All triple
// slashes are turned into single slashes, and all `..` and `.`s resolved
// against @relative_to.
//
// Symlinks are not followed, and the returned path is guaranteed to be
// absolute.
//
// If @filename is an absolute path, @relative_to is ignored. Otherwise,
// @relative_to will be prepended to @filename to make it absolute. @relative_to
// must be an absolute path, or nil. If @relative_to is nil, it'll fallback to
// g_get_current_dir().
//
// This function never fails, and will canonicalize file paths even if they
// don't exist.
//
// No file system I/O is done.
func CanonicalizeFilename(filename string, relativeTo string) string {
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(relativeTo))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_canonicalize_filename(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Chdir: a wrapper for the POSIX chdir() function. The function changes the
// current directory of the process to @path.
//
// See your C library manual for more details about chdir().
func Chdir(path string) int {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_chdir(arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// CheckVersion checks that the GLib library in use is compatible with the given
// version. Generally you would pass in the constants IB_MAJOR_VERSION,
// IB_MINOR_VERSION, IB_MICRO_VERSION as the three arguments to this function;
// that produces a check that the library in use is compatible with the version
// of GLib the application or module was compiled against.
//
// Compatibility is defined by two things: first the version of the running
// library is newer than the version
// @required_major.required_minor.@required_micro. Second the running library
// must be binary compatible with the version
// @required_major.required_minor.@required_micro (same major version.)
func CheckVersion(requiredMajor uint, requiredMinor uint, requiredMicro uint) string {
	var arg1 C.guint
	var arg2 C.guint
	var arg3 C.guint

	arg1 = C.guint(requiredMajor)
	arg2 = C.guint(requiredMinor)
	arg3 = C.guint(requiredMicro)

	ret := C.glib_check_version(arg1, arg2, arg3)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// ChecksumTypeGetLength gets the length in bytes of digests of type
// @checksum_type
func ChecksumTypeGetLength(checksumType ChecksumType) int {
	var arg1 C.GChecksumType

	arg1 = (C.GChecksumType)(checksumType)

	ret := C.g_checksum_type_get_length(arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ClearError: if @err or *@err is nil, does nothing. Otherwise, calls
// g_error_free() on *@err and sets *@err to nil.
func ClearError() error {
	var gError *C.GError

	C.g_clear_error(&gError)
}

// ClearList clears a pointer to a #GList, freeing it and, optionally, freeing
// its elements using @destroy.
//
// @list_ptr must be a valid pointer. If @list_ptr points to a null #GList, this
// does nothing.
func ClearList(listPtr **List) {
	var arg1 **C.GList
	var arg2 C.GDestroyNotify

	arg1 = (**C.GList)(listPtr.Native())

	C.g_clear_list(arg1, arg2)
}

// ClearSlist clears a pointer to a List, freeing it and, optionally, freeing
// its elements using @destroy.
//
// @slist_ptr must be a valid pointer. If @slist_ptr points to a null List, this
// does nothing.
func ClearSlist(slistPtr **SList) {
	var arg1 **C.GSList
	var arg2 C.GDestroyNotify

	arg1 = (**C.GSList)(slistPtr.Native())

	C.g_clear_slist(arg1, arg2)
}

// Close: this wraps the close() call; in case of error, errno will be
// preserved, but the error will also be stored as a #GError in @error.
//
// Besides using #GError, there is another major reason to prefer this function
// over the call provided by the system; on Unix, it will attempt to correctly
// handle EINTR, which has platform-specific semantics.
func Close(fd int) error {
	var arg1 C.gint
	var gError *C.GError

	arg1 = C.gint(fd)

	ret := C.g_close(arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// ComputeChecksumForBytes computes the checksum for a binary @data. This is a
// convenience wrapper for g_checksum_new(), g_checksum_get_string() and
// g_checksum_free().
//
// The hexadecimal string returned will be in lower case.
func ComputeChecksumForBytes(checksumType ChecksumType, data *Bytes) string {
	var arg1 C.GChecksumType
	var arg2 *C.GBytes

	arg1 = (C.GChecksumType)(checksumType)
	arg2 = (*C.GBytes)(data.Native())

	ret := C.g_compute_checksum_for_bytes(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// ComputeChecksumForData computes the checksum for a binary @data of @length.
// This is a convenience wrapper for g_checksum_new(), g_checksum_get_string()
// and g_checksum_free().
//
// The hexadecimal string returned will be in lower case.
func ComputeChecksumForData(checksumType ChecksumType, data []byte) string {
	var arg1 C.GChecksumType
	var arg2 *C.guchar
	var arg3 C.gsize

	arg1 = (C.GChecksumType)(checksumType)
	arg2 = (*C.guchar)(unsafe.Pointer(&data[0]))
	arg3 = len(data)
	defer runtime.KeepAlive(data)

	ret := C.g_compute_checksum_for_data(arg1, arg2, arg3)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// ComputeChecksumForString computes the checksum of a string.
//
// The hexadecimal string returned will be in lower case.
func ComputeChecksumForString(checksumType ChecksumType, str string, length int) string {
	var arg1 C.GChecksumType
	var arg2 *C.gchar
	var arg3 C.gssize

	arg1 = (C.GChecksumType)(checksumType)
	arg2 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.gssize(length)

	ret := C.g_compute_checksum_for_string(arg1, arg2, arg3)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// ComputeHMACForBytes computes the HMAC for a binary @data. This is a
// convenience wrapper for g_hmac_new(), g_hmac_get_string() and g_hmac_unref().
//
// The hexadecimal string returned will be in lower case.
func ComputeHMACForBytes(digestType ChecksumType, key *Bytes, data *Bytes) string {
	var arg1 C.GChecksumType
	var arg2 *C.GBytes
	var arg3 *C.GBytes

	arg1 = (C.GChecksumType)(digestType)
	arg2 = (*C.GBytes)(key.Native())
	arg3 = (*C.GBytes)(data.Native())

	ret := C.g_compute_hmac_for_bytes(arg1, arg2, arg3)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// ComputeHMACForData computes the HMAC for a binary @data of @length. This is a
// convenience wrapper for g_hmac_new(), g_hmac_get_string() and g_hmac_unref().
//
// The hexadecimal string returned will be in lower case.
func ComputeHMACForData(digestType ChecksumType, key []byte, data []byte) string {
	var arg1 C.GChecksumType
	var arg2 *C.guchar
	var arg3 C.gsize
	var arg4 *C.guchar
	var arg5 C.gsize

	arg1 = (C.GChecksumType)(digestType)
	arg2 = (*C.guchar)(unsafe.Pointer(&key[0]))
	arg3 = len(key)
	defer runtime.KeepAlive(key)
	arg4 = (*C.guchar)(unsafe.Pointer(&data[0]))
	arg5 = len(data)
	defer runtime.KeepAlive(data)

	ret := C.g_compute_hmac_for_data(arg1, arg2, arg3, arg4, arg5)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// ComputeHMACForString computes the HMAC for a string.
//
// The hexadecimal string returned will be in lower case.
func ComputeHMACForString(digestType ChecksumType, key []byte, str string, length int) string {
	var arg1 C.GChecksumType
	var arg2 *C.guchar
	var arg3 C.gsize
	var arg4 *C.gchar
	var arg5 C.gssize

	arg1 = (C.GChecksumType)(digestType)
	arg2 = (*C.guchar)(unsafe.Pointer(&key[0]))
	arg3 = len(key)
	defer runtime.KeepAlive(key)
	arg4 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = C.gssize(length)

	ret := C.g_compute_hmac_for_string(arg1, arg2, arg3, arg4, arg5)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Convert converts a string from one character set to another.
//
// Note that you should use g_iconv() for streaming conversions. Despite the
// fact that @bytes_read can return information about partial characters, the
// g_convert_... functions are not generally suitable for streaming. If the
// underlying converter maintains internal state, then this won't be preserved
// across successive calls to g_convert(), g_convert_with_iconv() or
// g_convert_with_fallback(). (An example of this is the GNU C converter for
// CP1255 which does not emit a base character until it knows that the next
// character is not a mark that could combine with the base character.)
//
// Using extensions such as "//TRANSLIT" may not work (or may not work well) on
// many platforms. Consider using g_str_to_ascii() instead.
func Convert(str []byte, toCodeset string, fromCodeset string) (bytesRead uint, bytesWritten uint, guint8s []byte, err error) {
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 *C.gchar
	var arg4 *C.gchar
	var arg5 *C.gsize // out
	var arg6 *C.gsize // out
	var gError *C.GError

	arg1 = (*C.gchar)(unsafe.Pointer(&str[0]))
	arg2 = len(str)
	defer runtime.KeepAlive(str)
	arg3 = (*C.gchar)(C.CString(toCodeset))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gchar)(C.CString(fromCodeset))
	defer C.free(unsafe.Pointer(arg4))

	ret := C.g_convert(arg1, arg2, arg3, arg4, &arg5, &arg6, &gError)

	var ret0 uint
	var ret1 uint
	var ret2 []byte
	var goError error

	ret0 = uint(arg5)

	ret1 = uint(arg6)

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret2))
		sliceHeader.Data = uintptr(unsafe.Pointer(ret))
		sliceHeader.Len = arg6
		sliceHeader.Cap = arg6
		runtime.SetFinalizer(&ret, func() {
			C.free(unsafe.Pointer(ret))
		})
		defer runtime.KeepAlive(ret)
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}

func ConvertErrorQuark() Quark {

	ret := C.g_convert_error_quark()

	var ret0 Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = Quark(tmp)
	}

	return ret0
}

// ConvertWithFallback converts a string from one character set to another,
// possibly including fallback sequences for characters not representable in the
// output. Note that it is not guaranteed that the specification for the
// fallback sequences in @fallback will be honored. Some systems may do an
// approximate conversion from @from_codeset to @to_codeset in their iconv()
// functions, in which case GLib will simply return that approximate conversion.
//
// Note that you should use g_iconv() for streaming conversions. Despite the
// fact that @bytes_read can return information about partial characters, the
// g_convert_... functions are not generally suitable for streaming. If the
// underlying converter maintains internal state, then this won't be preserved
// across successive calls to g_convert(), g_convert_with_iconv() or
// g_convert_with_fallback(). (An example of this is the GNU C converter for
// CP1255 which does not emit a base character until it knows that the next
// character is not a mark that could combine with the base character.)
func ConvertWithFallback(str []byte, toCodeset string, fromCodeset string, fallback string) (bytesRead uint, bytesWritten uint, guint8s []byte, err error) {
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 *C.gchar
	var arg4 *C.gchar
	var arg5 *C.gchar
	var arg6 *C.gsize // out
	var arg7 *C.gsize // out
	var gError *C.GError

	arg1 = (*C.gchar)(unsafe.Pointer(&str[0]))
	arg2 = len(str)
	defer runtime.KeepAlive(str)
	arg3 = (*C.gchar)(C.CString(toCodeset))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gchar)(C.CString(fromCodeset))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.gchar)(C.CString(fallback))
	defer C.free(unsafe.Pointer(arg5))

	ret := C.g_convert_with_fallback(arg1, arg2, arg3, arg4, arg5, &arg6, &arg7, &gError)

	var ret0 uint
	var ret1 uint
	var ret2 []byte
	var goError error

	ret0 = uint(arg6)

	ret1 = uint(arg7)

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret2))
		sliceHeader.Data = uintptr(unsafe.Pointer(ret))
		sliceHeader.Len = arg7
		sliceHeader.Cap = arg7
		runtime.SetFinalizer(&ret, func() {
			C.free(unsafe.Pointer(ret))
		})
		defer runtime.KeepAlive(ret)
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}

// ConvertWithIconv converts a string from one character set to another.
//
// Note that you should use g_iconv() for streaming conversions. Despite the
// fact that @bytes_read can return information about partial characters, the
// g_convert_... functions are not generally suitable for streaming. If the
// underlying converter maintains internal state, then this won't be preserved
// across successive calls to g_convert(), g_convert_with_iconv() or
// g_convert_with_fallback(). (An example of this is the GNU C converter for
// CP1255 which does not emit a base character until it knows that the next
// character is not a mark that could combine with the base character.)
//
// Characters which are valid in the input character set, but which have no
// representation in the output character set will result in a
// G_CONVERT_ERROR_ILLEGAL_SEQUENCE error. This is in contrast to the iconv()
// specification, which leaves this behaviour implementation defined. Note that
// this is the same error code as is returned for an invalid byte sequence in
// the input character set. To get defined behaviour for conversion of
// unrepresentable characters, use g_convert_with_fallback().
func ConvertWithIconv(str []byte, converter IConv) (bytesRead uint, bytesWritten uint, guint8s []byte, err error) {
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 C.GIConv
	var arg4 *C.gsize // out
	var arg5 *C.gsize // out
	var gError *C.GError

	arg1 = (*C.gchar)(unsafe.Pointer(&str[0]))
	arg2 = len(str)
	defer runtime.KeepAlive(str)
	arg3 = (C.GIConv)(converter.Native())

	ret := C.g_convert_with_iconv(arg1, arg2, arg3, &arg4, &arg5, &gError)

	var ret0 uint
	var ret1 uint
	var ret2 []byte
	var goError error

	ret0 = uint(arg4)

	ret1 = uint(arg5)

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret2))
		sliceHeader.Data = uintptr(unsafe.Pointer(ret))
		sliceHeader.Len = arg5
		sliceHeader.Cap = arg5
		runtime.SetFinalizer(&ret, func() {
			C.free(unsafe.Pointer(ret))
		})
		defer runtime.KeepAlive(ret)
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}

// DatalistClear frees all the data elements of the datalist. The data elements'
// destroy functions are called if they have been set.
func DatalistClear(datalist **Data) {
	var arg1 **C.GData

	arg1 = (**C.GData)(datalist.Native())

	C.g_datalist_clear(arg1)
}

// DatalistForeach calls the given function for each data element of the
// datalist. The function is called with each data element's #GQuark id and
// data, together with the given @user_data parameter. Note that this function
// is NOT thread-safe. So unless @datalist can be protected from any
// modifications during invocation of this function, it should not be called.
//
// @func can make changes to @datalist, but the iteration will not reflect
// changes made during the g_datalist_foreach() call, other than skipping over
// elements that are removed.
func DatalistForeach(datalist **Data, fn DataForeachFunc) {
	var arg1 **C.GData
	var arg2 C.GDataForeachFunc
	var arg3 C.gpointer

	arg1 = (**C.GData)(datalist.Native())
	arg2 = (*[0]byte)(C.gotk4_DataForeachFunc)
	arg3 = C.gpointer(box.Assign(fn))

	C.g_datalist_foreach(arg1, arg2, arg3)
}

// DatalistGetData gets a data element, using its string identifier. This is
// slower than g_datalist_id_get_data() because it compares strings.
func DatalistGetData(datalist **Data, key string) interface{} {
	var arg1 **C.GData
	var arg2 *C.gchar

	arg1 = (**C.GData)(datalist.Native())
	arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_datalist_get_data(arg1, arg2)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// DatalistGetFlags gets flags values packed in together with the datalist. See
// g_datalist_set_flags().
func DatalistGetFlags(datalist **Data) uint {
	var arg1 **C.GData

	arg1 = (**C.GData)(datalist.Native())

	ret := C.g_datalist_get_flags(arg1)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// DatalistInit resets the datalist to nil. It does not free any memory or call
// any destroy functions.
func DatalistInit(datalist **Data) {
	var arg1 **C.GData

	arg1 = (**C.GData)(datalist.Native())

	C.g_datalist_init(arg1)
}

// DatalistSetFlags turns on flag values for a data list. This function is used
// to keep a small number of boolean flags in an object with a data list without
// using any additional space. It is not generally useful except in
// circumstances where space is very tight. (It is used in the base #GObject
// type, for example.)
func DatalistSetFlags(datalist **Data, flags uint) {
	var arg1 **C.GData
	var arg2 C.guint

	arg1 = (**C.GData)(datalist.Native())
	arg2 = C.guint(flags)

	C.g_datalist_set_flags(arg1, arg2)
}

// DatalistUnsetFlags turns off flag values for a data list. See
// g_datalist_unset_flags()
func DatalistUnsetFlags(datalist **Data, flags uint) {
	var arg1 **C.GData
	var arg2 C.guint

	arg1 = (**C.GData)(datalist.Native())
	arg2 = C.guint(flags)

	C.g_datalist_unset_flags(arg1, arg2)
}

// DatasetDestroy destroys the dataset, freeing all memory allocated, and
// calling any destroy functions set for data elements.
func DatasetDestroy(datasetLocation interface{}) {
	var arg1 C.gpointer

	arg1 = C.gpointer(box.Assign(datasetLocation))

	C.g_dataset_destroy(arg1)
}

// DatasetForeach calls the given function for each data element which is
// associated with the given location. Note that this function is NOT
// thread-safe. So unless @dataset_location can be protected from any
// modifications during invocation of this function, it should not be called.
//
// @func can make changes to the dataset, but the iteration will not reflect
// changes made during the g_dataset_foreach() call, other than skipping over
// elements that are removed.
func DatasetForeach(datasetLocation interface{}, fn DataForeachFunc) {
	var arg1 C.gpointer
	var arg2 C.GDataForeachFunc
	var arg3 C.gpointer

	arg1 = C.gpointer(box.Assign(datasetLocation))
	arg2 = (*[0]byte)(C.gotk4_DataForeachFunc)
	arg3 = C.gpointer(box.Assign(fn))

	C.g_dataset_foreach(arg1, arg2, arg3)
}

// DateStrftime generates a printed representation of the date, in a
// [locale][setlocale]-specific way. Works just like the platform's C library
// strftime() function, but only accepts date-related formats; time-related
// formats give undefined results. Date must be valid. Unlike strftime() (which
// uses the locale encoding), works on a UTF-8 format string and stores a UTF-8
// result.
//
// This function does not provide any conversion specifiers in addition to those
// implemented by the platform's C library. For example, don't expect that using
// g_date_strftime() would make the \F provided by the C99 strftime() work on
// Windows where the C library only complies to C89.
func DateStrftime(s string, slen uint, format string, date *Date) uint {
	var arg1 *C.gchar
	var arg2 C.gsize
	var arg3 *C.gchar
	var arg4 *C.GDate

	arg1 = (*C.gchar)(C.CString(s))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gsize(slen)
	arg3 = (*C.gchar)(C.CString(format))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.GDate)(date.Native())

	ret := C.g_date_strftime(arg1, arg2, arg3, arg4)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// DateTimeCompare: a comparison function for Times that is suitable as a Func.
// Both Times must be non-nil.
func DateTimeCompare(dt1 interface{}, dt2 interface{}) int {
	var arg1 C.gpointer
	var arg2 C.gpointer

	arg1 = C.gpointer(box.Assign(dt1))
	arg2 = C.gpointer(box.Assign(dt2))

	ret := C.g_date_time_compare(arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// DateTimeEqual checks to see if @dt1 and @dt2 are equal.
//
// Equal here means that they represent the same moment after converting them to
// the same time zone.
func DateTimeEqual(dt1 interface{}, dt2 interface{}) bool {
	var arg1 C.gpointer
	var arg2 C.gpointer

	arg1 = C.gpointer(box.Assign(dt1))
	arg2 = C.gpointer(box.Assign(dt2))

	ret := C.g_date_time_equal(arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// DateTimeHash hashes @datetime into a #guint, suitable for use within Table.
func DateTimeHash(datetime interface{}) uint {
	var arg1 C.gpointer

	arg1 = C.gpointer(box.Assign(datetime))

	ret := C.g_date_time_hash(arg1)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// DateValidJulian returns true if the Julian day is valid. Anything greater
// than zero is basically a valid Julian, though there is a 32-bit limit.
func DateValidJulian(julianDate uint32) bool {
	var arg1 C.guint32

	arg1 = C.guint32(julianDate)

	ret := C.g_date_valid_julian(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// DateValidMonth returns true if the month value is valid. The 12 Month
// enumeration values are the only valid months.
func DateValidMonth(month DateMonth) bool {
	var arg1 C.GDateMonth

	arg1 = (C.GDateMonth)(month)

	ret := C.g_date_valid_month(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// DateValidWeekday returns true if the weekday is valid. The seven Weekday
// enumeration values are the only valid weekdays.
func DateValidWeekday(weekday DateWeekday) bool {
	var arg1 C.GDateWeekday

	arg1 = (C.GDateWeekday)(weekday)

	ret := C.g_date_valid_weekday(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Dcgettext: this is a variant of g_dgettext() that allows specifying a locale
// category instead of always using `LC_MESSAGES`. See g_dgettext() for more
// information about how this functions differs from calling dcgettext()
// directly.
func Dcgettext(domain string, msgid string, category int) string {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 C.gint

	arg1 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(msgid))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.gint(category)

	ret := C.g_dcgettext(arg1, arg2, arg3)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Dgettext: this function is a wrapper of dgettext() which does not translate
// the message if the default domain as set with textdomain() has no
// translations for the current locale.
//
// The advantage of using this function over dgettext() proper is that libraries
// using this function (like GTK+) will not use translations if the application
// using the library does not have translations for the current locale. This
// results in a consistent English-only interface instead of one having partial
// translations. For this feature to work, the call to textdomain() and
// setlocale() should precede any g_dgettext() invocations. For GTK+, it means
// calling textdomain() before gtk_init or its variants.
//
// This function disables translations if and only if upon its first call all
// the following conditions hold:
//
// - @domain is not nil
//
// - textdomain() has been called to set a default text domain
//
// - there is no translations available for the default text domain and the
// current locale
//
// - current locale is not "C" or any English locales (those starting with
// "en_")
//
// Note that this behavior may not be desired for example if an application has
// its untranslated messages in a language other than English. In those cases
// the application should call textdomain() after initializing GTK+.
//
// Applications should normally not use this function directly, but use the _()
// macro for translations.
func Dgettext(domain string, msgid string) string {
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg1 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(msgid))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_dgettext(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// DirMakeTmp creates a subdirectory in the preferred directory for temporary
// files (as returned by g_get_tmp_dir()).
//
// @tmpl should be a string in the GLib file name encoding containing a sequence
// of six 'X' characters, as the parameter to g_mkstemp(). However, unlike these
// functions, the template should only be a basename, no directory components
// are allowed. If template is nil, a default template is used.
//
// Note that in contrast to g_mkdtemp() (and mkdtemp()) @tmpl is not modified,
// and might thus be a read-only literal string.
func DirMakeTmp(tmpl string) (filename string, err error) {
	var arg1 *C.gchar
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(tmpl))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_dir_make_tmp(arg1, &gError)

	var ret0 string
	var goError error

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// DirectEqual compares two #gpointer arguments and returns true if they are
// equal. It can be passed to g_hash_table_new() as the @key_equal_func
// parameter, when using opaque pointers compared by pointer value as keys in a
// Table.
//
// This equality function is also appropriate for keys that are integers stored
// in pointers, such as `GINT_TO_POINTER (n)`.
func DirectEqual(v1 interface{}, v2 interface{}) bool {
	var arg1 C.gpointer
	var arg2 C.gpointer

	arg1 = C.gpointer(box.Assign(v1))
	arg2 = C.gpointer(box.Assign(v2))

	ret := C.g_direct_equal(arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// DirectHash converts a gpointer to a hash value. It can be passed to
// g_hash_table_new() as the @hash_func parameter, when using opaque pointers
// compared by pointer value as keys in a Table.
//
// This hash function is also appropriate for keys that are integers stored in
// pointers, such as `GINT_TO_POINTER (n)`.
func DirectHash(v interface{}) uint {
	var arg1 C.gpointer

	arg1 = C.gpointer(box.Assign(v))

	ret := C.g_direct_hash(arg1)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Dngettext: this function is a wrapper of dngettext() which does not translate
// the message if the default domain as set with textdomain() has no
// translations for the current locale.
//
// See g_dgettext() for details of how this differs from dngettext() proper.
func Dngettext(domain string, msgid string, msgidPlural string, n uint32) string {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 C.gulong

	arg1 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(msgid))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(msgidPlural))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = C.gulong(n)

	ret := C.g_dngettext(arg1, arg2, arg3, arg4)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// DoubleEqual compares the two #gdouble values being pointed to and returns
// true if they are equal. It can be passed to g_hash_table_new() as the
// @key_equal_func parameter, when using non-nil pointers to doubles as keys in
// a Table.
func DoubleEqual(v1 interface{}, v2 interface{}) bool {
	var arg1 C.gpointer
	var arg2 C.gpointer

	arg1 = C.gpointer(box.Assign(v1))
	arg2 = C.gpointer(box.Assign(v2))

	ret := C.g_double_equal(arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// DoubleHash converts a pointer to a #gdouble to a hash value. It can be passed
// to g_hash_table_new() as the @hash_func parameter, It can be passed to
// g_hash_table_new() as the @hash_func parameter, when using non-nil pointers
// to doubles as keys in a Table.
func DoubleHash(v interface{}) uint {
	var arg1 C.gpointer

	arg1 = C.gpointer(box.Assign(v))

	ret := C.g_double_hash(arg1)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Dpgettext: this function is a variant of g_dgettext() which supports a
// disambiguating message context. GNU gettext uses the '\004' character to
// separate the message context and message id in @msgctxtid. If 0 is passed as
// @msgidoffset, this function will fall back to trying to use the deprecated
// convention of using "|" as a separation character.
//
// This uses g_dgettext() internally. See that functions for differences with
// dgettext() proper.
//
// Applications should normally not use this function directly, but use the C_()
// macro for translations with context.
func Dpgettext(domain string, msgctxtid string, msgidoffset uint) string {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 C.gsize

	arg1 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(msgctxtid))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.gsize(msgidoffset)

	ret := C.g_dpgettext(arg1, arg2, arg3)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Dpgettext2: this function is a variant of g_dgettext() which supports a
// disambiguating message context. GNU gettext uses the '\004' character to
// separate the message context and message id in @msgctxtid.
//
// This uses g_dgettext() internally. See that functions for differences with
// dgettext() proper.
//
// This function differs from C_() in that it is not a macro and thus you may
// use non-string-literals as context and msgid arguments.
func Dpgettext2(domain string, context string, msgid string) string {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar

	arg1 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(context))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(msgid))
	defer C.free(unsafe.Pointer(arg3))

	ret := C.g_dpgettext2(arg1, arg2, arg3)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// EnvironGetenv returns the value of the environment variable @variable in the
// provided list @envp.
func EnvironGetenv(envp []string, variable string) string {
	var arg1 **C.gchar
	var arg2 *C.gchar

	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(envp) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(envp)
		sliceHeader.Cap = len(envp)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(envp); i++ {
			src := envp[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg1 = (**C.gchar)(unsafe.Pointer(ptr))
	}
	arg2 = (*C.gchar)(C.CString(variable))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_environ_getenv(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// EnvironSetenv sets the environment variable @variable in the provided list
// @envp to @value.
func EnvironSetenv(envp []string, variable string, value string, overwrite bool) []string {
	var arg1 **C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 C.gboolean

	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(envp) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(envp)
		sliceHeader.Cap = len(envp)

		for i := 0; i < len(envp); i++ {
			src := envp[i]
			dst[i] = (*C.gchar)(C.CString(src))
		}

		arg1 = (**C.gchar)(unsafe.Pointer(ptr))
	}
	arg2 = (*C.gchar)(C.CString(variable))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(arg3))
	if overwrite {
		arg4 = C.TRUE
	}

	ret := C.g_environ_setenv(arg1, arg2, arg3, arg4)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// EnvironUnsetenv removes the environment variable @variable from the provided
// environment @envp.
func EnvironUnsetenv(envp []string, variable string) []string {
	var arg1 **C.gchar
	var arg2 *C.gchar

	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(envp) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(envp)
		sliceHeader.Cap = len(envp)

		for i := 0; i < len(envp); i++ {
			src := envp[i]
			dst[i] = (*C.gchar)(C.CString(src))
		}

		arg1 = (**C.gchar)(unsafe.Pointer(ptr))
	}
	arg2 = (*C.gchar)(C.CString(variable))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_environ_unsetenv(arg1, arg2)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// FileErrorFromErrno gets a Error constant based on the passed-in @err_no. For
// example, if you pass in `EEXIST` this function returns FILE_ERROR_EXIST.
// Unlike `errno` values, you can portably assume that all Error values will
// exist.
//
// Normally a Error value goes into a #GError returned from a function that
// manipulates files. So you would use g_file_error_from_errno() when
// constructing a #GError.
func FileErrorFromErrno(errNo int) FileError {
	var arg1 C.gint

	arg1 = C.gint(errNo)

	ret := C.g_file_error_from_errno(arg1)

	var ret0 FileError

	ret0 = FileError(ret)

	return ret0
}

func FileErrorQuark() Quark {

	ret := C.g_file_error_quark()

	var ret0 Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = Quark(tmp)
	}

	return ret0
}

// FileGetContents reads an entire file into allocated memory, with good error
// checking.
//
// If the call was successful, it returns true and sets @contents to the file
// contents and @length to the length of the file contents in bytes. The string
// stored in @contents will be nul-terminated, so for text files you can pass
// nil for the @length argument. If the call was not successful, it returns
// false and sets @error. The error domain is FILE_ERROR. Possible error codes
// are those in the Error enumeration. In the error case, @contents is set to
// nil and @length is set to zero.
func FileGetContents(filename string) (contents []byte, length uint, err error) {
	var arg1 *C.gchar
	var arg2 **C.gchar // out
	var arg3 *C.gsize  // out
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_file_get_contents(arg1, &arg2, &arg3, &gError)

	var ret0 []byte
	var ret1 uint
	var goError error

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret0))
		sliceHeader.Data = uintptr(unsafe.Pointer(arg2))
		sliceHeader.Len = arg3
		sliceHeader.Cap = arg3
		runtime.SetFinalizer(&arg2, func() {
			C.free(unsafe.Pointer(arg2))
		})
		defer runtime.KeepAlive(arg2)
	}

	ret1 = uint(arg3)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// FileOpenTmp opens a file for writing in the preferred directory for temporary
// files (as returned by g_get_tmp_dir()).
//
// @tmpl should be a string in the GLib file name encoding containing a sequence
// of six 'X' characters, as the parameter to g_mkstemp(). However, unlike these
// functions, the template should only be a basename, no directory components
// are allowed. If template is nil, a default template is used.
//
// Note that in contrast to g_mkstemp() (and mkstemp()) @tmpl is not modified,
// and might thus be a read-only literal string.
//
// Upon success, and if @name_used is non-nil, the actual name used is returned
// in @name_used. This string should be freed with g_free() when not needed any
// longer. The returned name is in the GLib file name encoding.
func FileOpenTmp(tmpl string) (nameUsed string, gint int, err error) {
	var arg1 *C.gchar
	var arg2 **C.gchar // out
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(tmpl))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_file_open_tmp(arg1, &arg2, &gError)

	var ret0 string
	var ret1 int
	var goError error

	ret0 = C.GoString(arg2)
	C.free(unsafe.Pointer(arg2))

	ret1 = int(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// FileReadLink reads the contents of the symbolic link @filename like the POSIX
// readlink() function. The returned string is in the encoding used for
// filenames. Use g_filename_to_utf8() to convert it to UTF-8.
func FileReadLink(filename string) (filename string, err error) {
	var arg1 *C.gchar
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_file_read_link(arg1, &gError)

	var ret0 string
	var goError error

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// FileSetContents writes all of @contents to a file named @filename. This is a
// convenience wrapper around calling g_file_set_contents() with `flags` set to
// `G_FILE_SET_CONTENTS_CONSISTENT | G_FILE_SET_CONTENTS_ONLY_EXISTING` and
// `mode` set to `0666`.
func FileSetContents(filename string, contents []byte) error {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 C.gssize
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(unsafe.Pointer(&contents[0]))
	arg3 = len(contents)
	defer runtime.KeepAlive(contents)

	ret := C.g_file_set_contents(arg1, arg2, arg3, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// FileSetContentsFull writes all of @contents to a file named @filename, with
// good error checking. If a file called @filename already exists it will be
// overwritten.
//
// @flags control the properties of the write operation: whether it’s atomic,
// and what the tradeoff is between returning quickly or being resilient to
// system crashes.
//
// As this function performs file I/O, it is recommended to not call it anywhere
// where blocking would cause problems, such as in the main loop of a graphical
// application. In particular, if @flags has any value other than
// G_FILE_SET_CONTENTS_NONE then this function may call `fsync()`.
//
// If G_FILE_SET_CONTENTS_CONSISTENT is set in @flags, the operation is atomic
// in the sense that it is first written to a temporary file which is then
// renamed to the final name.
//
// Notes:
//
// - On UNIX, if @filename already exists hard links to @filename will break.
// Also since the file is recreated, existing permissions, access control lists,
// metadata etc. may be lost. If @filename is a symbolic link, the link itself
// will be replaced, not the linked file.
//
// - On UNIX, if @filename already exists and is non-empty, and if the system
// supports it (via a journalling filesystem or equivalent), and if
// G_FILE_SET_CONTENTS_CONSISTENT is set in @flags, the `fsync()` call (or
// equivalent) will be used to ensure atomic replacement: @filename will contain
// either its old contents or @contents, even in the face of system power loss,
// the disk being unsafely removed, etc.
//
// - On UNIX, if @filename does not already exist or is empty, there is a
// possibility that system power loss etc. after calling this function will
// leave @filename empty or full of NUL bytes, depending on the underlying
// filesystem, unless G_FILE_SET_CONTENTS_DURABLE and
// G_FILE_SET_CONTENTS_CONSISTENT are set in @flags.
//
// - On Windows renaming a file will not remove an existing file with the new
// name, so on Windows there is a race condition between the existing file being
// removed and the temporary file being renamed.
//
// - On Windows there is no way to remove a file that is open to some process,
// or mapped into memory. Thus, this function will fail if @filename already
// exists and is open.
//
// If the call was successful, it returns true. If the call was not successful,
// it returns false and sets @error. The error domain is FILE_ERROR. Possible
// error codes are those in the Error enumeration.
//
// Note that the name for the temporary file is constructed by appending up to 7
// characters to @filename.
//
// If the file didn’t exist before and is created, it will be given the
// permissions from @mode. Otherwise, the permissions of the existing file may
// be changed to @mode depending on @flags, or they may remain unchanged.
func FileSetContentsFull(filename string, contents []byte, flags FileSetContentsFlags, mode int) error {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 C.gssize
	var arg4 C.GFileSetContentsFlags
	var arg5 C.int
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(unsafe.Pointer(&contents[0]))
	arg3 = len(contents)
	defer runtime.KeepAlive(contents)
	arg4 = (C.GFileSetContentsFlags)(flags)
	arg5 = C.int(mode)

	ret := C.g_file_set_contents_full(arg1, arg2, arg3, arg4, arg5, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// FileTest returns true if any of the tests in the bitfield @test are true. For
// example, `(G_FILE_TEST_EXISTS | G_FILE_TEST_IS_DIR)` will return true if the
// file exists; the check whether it's a directory doesn't matter since the
// existence test is true. With the current set of available tests, there's no
// point passing in more than one test at a time.
//
// Apart from G_FILE_TEST_IS_SYMLINK all tests follow symbolic links, so for a
// symbolic link to a regular file g_file_test() will return true for both
// G_FILE_TEST_IS_SYMLINK and G_FILE_TEST_IS_REGULAR.
//
// Note, that for a dangling symbolic link g_file_test() will return true for
// G_FILE_TEST_IS_SYMLINK and false for all other flags.
//
// You should never use g_file_test() to test whether it is safe to perform an
// operation, because there is always the possibility of the condition changing
// before you actually perform the operation. For example, you might think you
// could use G_FILE_TEST_IS_SYMLINK to know whether it is safe to write to a
// file without being tricked into writing into a different location. It doesn't
// work!
//
//    // DON'T DO THIS
//    if (!g_file_test (filename, G_FILE_TEST_IS_SYMLINK))
//      {
//        fd = g_open (filename, O_WRONLY);
//        // write to fd
//      }
//
// Another thing to note is that G_FILE_TEST_EXISTS and
// G_FILE_TEST_IS_EXECUTABLE are implemented using the access() system call.
// This usually doesn't matter, but if your program is setuid or setgid it means
// that these tests will give you the answer for the real user ID and group ID,
// rather than the effective user ID and group ID.
//
// On Windows, there are no symlinks, so testing for G_FILE_TEST_IS_SYMLINK will
// always return false. Testing for G_FILE_TEST_IS_EXECUTABLE will just check
// that the file exists and its name indicates that it is executable, checking
// for well-known extensions and those listed in the `PATHEXT` environment
// variable.
func FileTest(filename string, test FileTest) bool {
	var arg1 *C.gchar
	var arg2 C.GFileTest

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GFileTest)(test)

	ret := C.g_file_test(arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// FilenameDisplayBasename returns the display basename for the particular
// filename, guaranteed to be valid UTF-8. The display name might not be
// identical to the filename, for instance there might be problems converting it
// to UTF-8, and some files can be translated in the display.
//
// If GLib cannot make sense of the encoding of @filename, as a last resort it
// replaces unknown characters with U+FFFD, the Unicode replacement character.
// You can search the result for the UTF-8 encoding of this character (which is
// "\357\277\275" in octal notation) to find out if @filename was in an invalid
// encoding.
//
// You must pass the whole absolute pathname to this functions so that
// translation of well known locations can be done.
//
// This function is preferred over g_filename_display_name() if you know the
// whole path, as it allows translation.
func FilenameDisplayBasename(filename string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_filename_display_basename(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// FilenameDisplayName converts a filename into a valid UTF-8 string. The
// conversion is not necessarily reversible, so you should keep the original
// around and use the return value of this function only for display purposes.
// Unlike g_filename_to_utf8(), the result is guaranteed to be non-nil even if
// the filename actually isn't in the GLib file name encoding.
//
// If GLib cannot make sense of the encoding of @filename, as a last resort it
// replaces unknown characters with U+FFFD, the Unicode replacement character.
// You can search the result for the UTF-8 encoding of this character (which is
// "\357\277\275" in octal notation) to find out if @filename was in an invalid
// encoding.
//
// If you know the whole pathname of the file you should use
// g_filename_display_basename(), since that allows location-based translation
// of filenames.
func FilenameDisplayName(filename string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_filename_display_name(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// FilenameFromURI converts an escaped ASCII-encoded URI to a local filename in
// the encoding used for filenames.
func FilenameFromURI(uri string) (hostname string, filename string, err error) {
	var arg1 *C.gchar
	var arg2 **C.gchar // out
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_filename_from_uri(arg1, &arg2, &gError)

	var ret0 string
	var ret1 string
	var goError error

	ret0 = C.GoString(arg2)
	C.free(unsafe.Pointer(arg2))

	ret1 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// FilenameFromUTF8 converts a string from UTF-8 to the encoding GLib uses for
// filenames. Note that on Windows GLib uses UTF-8 for filenames; on other
// platforms, this function indirectly depends on the [current
// locale][setlocale].
//
// The input string shall not contain nul characters even if the @len argument
// is positive. A nul character found inside the string will result in error
// G_CONVERT_ERROR_ILLEGAL_SEQUENCE. If the filename encoding is not UTF-8 and
// the conversion output contains a nul character, the error
// G_CONVERT_ERROR_EMBEDDED_NUL is set and the function returns nil.
func FilenameFromUTF8(utf8String string, len int) (bytesRead uint, bytesWritten uint, filename string, err error) {
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 *C.gsize // out
	var arg4 *C.gsize // out
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(utf8String))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(len)

	ret := C.g_filename_from_utf8(arg1, arg2, &arg3, &arg4, &gError)

	var ret0 uint
	var ret1 uint
	var ret2 string
	var goError error

	ret0 = uint(arg3)

	ret1 = uint(arg4)

	ret2 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}

// FilenameToURI converts an absolute filename to an escaped ASCII-encoded URI,
// with the path component following Section 3.3. of RFC 2396.
func FilenameToURI(filename string, hostname string) (utf8 string, err error) {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(hostname))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_filename_to_uri(arg1, arg2, &gError)

	var ret0 string
	var goError error

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// FilenameToUTF8 converts a string which is in the encoding used by GLib for
// filenames into a UTF-8 string. Note that on Windows GLib uses UTF-8 for
// filenames; on other platforms, this function indirectly depends on the
// [current locale][setlocale].
//
// The input string shall not contain nul characters even if the @len argument
// is positive. A nul character found inside the string will result in error
// G_CONVERT_ERROR_ILLEGAL_SEQUENCE. If the source encoding is not UTF-8 and the
// conversion output contains a nul character, the error
// G_CONVERT_ERROR_EMBEDDED_NUL is set and the function returns nil. Use
// g_convert() to produce output that may contain embedded nul characters.
func FilenameToUTF8(opsysstring string, len int) (bytesRead uint, bytesWritten uint, utf8 string, err error) {
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 *C.gsize // out
	var arg4 *C.gsize // out
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(opsysstring))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(len)

	ret := C.g_filename_to_utf8(arg1, arg2, &arg3, &arg4, &gError)

	var ret0 uint
	var ret1 uint
	var ret2 string
	var goError error

	ret0 = uint(arg3)

	ret1 = uint(arg4)

	ret2 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}

// FindProgramInPath locates the first executable named @program in the user's
// path, in the same way that execvp() would locate it. Returns an allocated
// string with the absolute path name, or nil if the program is not found in the
// path. If @program is already an absolute path, returns a copy of @program if
// @program exists and is executable, and nil otherwise. On Windows, if @program
// does not have a file type suffix, tries with the suffixes .exe, .cmd, .bat
// and .com, and the suffixes in the `PATHEXT` environment variable.
//
// On Windows, it looks for the file in the same way as CreateProcess() would.
// This means first in the directory where the executing program was loaded
// from, then in the current directory, then in the Windows 32-bit system
// directory, then in the Windows directory, and finally in the directories in
// the `PATH` environment variable. If the program is found, the return value
// contains the full name including the type suffix.
func FindProgramInPath(program string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(program))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_find_program_in_path(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// FormatSize formats a size (for example the size of a file) into a human
// readable string. Sizes are rounded to the nearest size prefix (kB, MB, GB)
// and are displayed rounded to the nearest tenth. E.g. the file size 3292528
// bytes will be converted into the string "3.2 MB". The returned string is
// UTF-8, and may use a non-breaking space to separate the number and units, to
// ensure they aren’t separated when line wrapped.
//
// The prefix units base is 1000 (i.e. 1 kB is 1000 bytes).
//
// This string should be freed with g_free() when not needed any longer.
//
// See g_format_size_full() for more options about how the size might be
// formatted.
func FormatSize(size uint64) string {
	var arg1 C.guint64

	arg1 = C.guint64(size)

	ret := C.g_format_size(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// FormatSizeForDisplay formats a size (for example the size of a file) into a
// human readable string. Sizes are rounded to the nearest size prefix (KB, MB,
// GB) and are displayed rounded to the nearest tenth. E.g. the file size
// 3292528 bytes will be converted into the string "3.1 MB".
//
// The prefix units base is 1024 (i.e. 1 KB is 1024 bytes).
//
// This string should be freed with g_free() when not needed any longer.
func FormatSizeForDisplay(size int64) string {
	var arg1 C.goffset

	arg1 = C.goffset(size)

	ret := C.g_format_size_for_display(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// FormatSizeFull formats a size.
//
// This function is similar to g_format_size() but allows for flags that modify
// the output. See SizeFlags.
func FormatSizeFull(size uint64, flags FormatSizeFlags) string {
	var arg1 C.guint64
	var arg2 C.GFormatSizeFlags

	arg1 = C.guint64(size)
	arg2 = (C.GFormatSizeFlags)(flags)

	ret := C.g_format_size_full(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Free frees the memory pointed to by @mem.
//
// If @mem is nil it simply returns, so there is no need to check @mem against
// nil before calling this function.
func Free(mem interface{}) {
	var arg1 C.gpointer

	arg1 = C.gpointer(box.Assign(mem))

	C.g_free(arg1)
}

// GetApplicationName gets a human-readable name for the application, as set by
// g_set_application_name(). This name should be localized if possible, and is
// intended for display to the user. Contrast with g_get_prgname(), which gets a
// non-localized name. If g_set_application_name() has not been called, returns
// the result of g_get_prgname() (which may be nil if g_set_prgname() has also
// not been called).
func GetApplicationName() string {

	ret := C.g_get_application_name()

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// GetCharset obtains the character set for the [current locale][setlocale]; you
// might use this character set as an argument to g_convert(), to convert from
// the current locale's encoding to some other encoding. (Frequently
// g_locale_to_utf8() and g_locale_from_utf8() are nice shortcuts, though.)
//
// On Windows the character set returned by this function is the so-called
// system default ANSI code-page. That is the character set used by the "narrow"
// versions of C library and Win32 functions that handle file names. It might be
// different from the character set used by the C library's current locale.
//
// On Linux, the character set is found by consulting nl_langinfo() if
// available. If not, the environment variables `LC_ALL`, `LC_CTYPE`, `LANG` and
// `CHARSET` are queried in order.
//
// The return value is true if the locale's encoding is UTF-8, in that case you
// can perhaps avoid calling g_convert().
//
// The string returned in @charset is not allocated, and should not be freed.
func GetCharset() (charset string, ok bool) {
	var arg1 **C.char // out

	ret := C.g_get_charset(&arg1)

	var ret0 string
	var ret1 bool

	ret0 = C.GoString(arg1)

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// GetCodeset gets the character set for the current locale.
func GetCodeset() string {

	ret := C.g_get_codeset()

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// GetConsoleCharset obtains the character set used by the console attached to
// the process, which is suitable for printing output to the terminal.
//
// Usually this matches the result returned by g_get_charset(), but in
// environments where the locale's character set does not match the encoding of
// the console this function tries to guess a more suitable value instead.
//
// On Windows the character set returned by this function is the output code
// page used by the console associated with the calling process. If the codepage
// can't be determined (for example because there is no console attached) UTF-8
// is assumed.
//
// The return value is true if the locale's encoding is UTF-8, in that case you
// can perhaps avoid calling g_convert().
//
// The string returned in @charset is not allocated, and should not be freed.
func GetConsoleCharset() (charset string, ok bool) {
	var arg1 **C.char // out

	ret := C.g_get_console_charset(&arg1)

	var ret0 string
	var ret1 bool

	ret0 = C.GoString(arg1)

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// GetCurrentDir gets the current directory.
//
// The returned string should be freed when no longer needed. The encoding of
// the returned string is system defined. On Windows, it is always UTF-8.
//
// Since GLib 2.40, this function will return the value of the "PWD" environment
// variable if it is set and it happens to be the same as the current directory.
// This can make a difference in the case that the current directory is the
// target of a symbolic link.
func GetCurrentDir() string {

	ret := C.g_get_current_dir()

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// GetCurrentTime: equivalent to the UNIX gettimeofday() function, but portable.
//
// You may find g_get_real_time() to be more convenient.
func GetCurrentTime(result *TimeVal) {
	var arg1 *C.GTimeVal

	arg1 = (*C.GTimeVal)(result.Native())

	C.g_get_current_time(arg1)
}

// GetEnviron gets the list of environment variables for the current process.
//
// The list is nil terminated and each item in the list is of the form
// 'NAME=VALUE'.
//
// This is equivalent to direct access to the 'environ' global variable, except
// portable.
//
// The return value is freshly allocated and it should be freed with
// g_strfreev() when it is no longer needed.
func GetEnviron() []string {

	ret := C.g_get_environ()

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// GetFilenameCharsets determines the preferred character sets used for
// filenames. The first character set from the @charsets is the filename
// encoding, the subsequent character sets are used when trying to generate a
// displayable representation of a filename, see g_filename_display_name().
//
// On Unix, the character sets are determined by consulting the environment
// variables `G_FILENAME_ENCODING` and `G_BROKEN_FILENAMES`. On Windows, the
// character set used in the GLib API is always UTF-8 and said environment
// variables have no effect.
//
// `G_FILENAME_ENCODING` may be set to a comma-separated list of character set
// names. The special token "\@locale" is taken to mean the character set for
// the [current locale][setlocale]. If `G_FILENAME_ENCODING` is not set, but
// `G_BROKEN_FILENAMES` is, the character set of the current locale is taken as
// the filename encoding. If neither environment variable is set, UTF-8 is taken
// as the filename encoding, but the character set of the current locale is also
// put in the list of encodings.
//
// The returned @charsets belong to GLib and must not be freed.
//
// Note that on Unix, regardless of the locale character set or
// `G_FILENAME_ENCODING` value, the actual file names present on a system might
// be in any random encoding or just gibberish.
func GetFilenameCharsets() (filenameCharsets []string, ok bool) {
	var arg1 ***C.gchar // out

	ret := C.g_get_filename_charsets(&arg1)

	var ret0 []string
	var ret1 bool

	{
		var length uint
		for p := unsafe.Pointer(arg1); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (**C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(arg1)) + i))
			ret0[i] = C.GoString(src)
		}
	}

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// GetHomeDir gets the current user's home directory.
//
// As with most UNIX tools, this function will return the value of the `HOME`
// environment variable if it is set to an existing absolute path name, falling
// back to the `passwd` file in the case that it is unset.
//
// If the path given in `HOME` is non-absolute, does not exist, or is not a
// directory, the result is undefined.
//
// Before version 2.36 this function would ignore the `HOME` environment
// variable, taking the value from the `passwd` database instead. This was
// changed to increase the compatibility of GLib with other programs (and the
// XDG basedir specification) and to increase testability of programs based on
// GLib (by making it easier to run them from test frameworks).
//
// If your program has a strong requirement for either the new or the old
// behaviour (and if you don't wish to increase your GLib dependency to ensure
// that the new behaviour is in effect) then you should either directly check
// the `HOME` environment variable yourself or unset it before calling any
// functions in GLib.
func GetHomeDir() string {

	ret := C.g_get_home_dir()

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// GetHostName: return a name for the machine.
//
// The returned name is not necessarily a fully-qualified domain name, or even
// present in DNS or some other name service at all. It need not even be unique
// on your local network or site, but usually it is. Callers should not rely on
// the return value having any specific properties like uniqueness for security
// purposes. Even if the name of the machine is changed while an application is
// running, the return value from this function does not change. The returned
// string is owned by GLib and should not be modified or freed. If no name can
// be determined, a default fixed string "localhost" is returned.
//
// The encoding of the returned string is UTF-8.
func GetHostName() string {

	ret := C.g_get_host_name()

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// GetLanguageNames computes a list of applicable locale names, which can be
// used to e.g. construct locale-dependent filenames or search paths. The
// returned list is sorted from most desirable to least desirable and always
// contains the default locale "C".
//
// For example, if LANGUAGE=de:en_US, then the returned list is "de", "en_US",
// "en", "C".
//
// This function consults the environment variables `LANGUAGE`, `LC_ALL`,
// `LC_MESSAGES` and `LANG` to find the list of locales specified by the user.
func GetLanguageNames() []string {

	ret := C.g_get_language_names()

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
		}
	}

	return ret0
}

// GetLanguageNamesWithCategory computes a list of applicable locale names with
// a locale category name, which can be used to construct the fallback
// locale-dependent filenames or search paths. The returned list is sorted from
// most desirable to least desirable and always contains the default locale "C".
//
// This function consults the environment variables `LANGUAGE`, `LC_ALL`,
// @category_name, and `LANG` to find the list of locales specified by the user.
//
// g_get_language_names() returns
// g_get_language_names_with_category("LC_MESSAGES").
func GetLanguageNamesWithCategory(categoryName string) []string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(categoryName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_get_language_names_with_category(arg1)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
		}
	}

	return ret0
}

// GetLocaleVariants returns a list of derived variants of @locale, which can be
// used to e.g. construct locale-dependent filenames or search paths. The
// returned list is sorted from most desirable to least desirable. This function
// handles territory, charset and extra locale modifiers. See `setlocale(3)`
// (man:setlocale) for information about locales and their format.
//
// @locale itself is guaranteed to be returned in the output.
//
// For example, if @locale is `fr_BE`, then the returned list is `fr_BE`, `fr`.
// If @locale is `en_GB.UTF-8@euro`, then the returned list is
// `en_GB.UTF-8@euro`, `en_GB.UTF-8`, `en_GB@euro`, `en_GB`, `en.UTF-8@euro`,
// `en.UTF-8`, `en@euro`, `en`.
//
// If you need the list of variants for the current locale, use
// g_get_language_names().
func GetLocaleVariants(locale string) []string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(locale))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_get_locale_variants(arg1)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// GetMonotonicTime queries the system monotonic time.
//
// The monotonic clock will always increase and doesn't suffer discontinuities
// when the user (or NTP) changes the system time. It may or may not continue to
// tick during times where the machine is suspended.
//
// We try to use the clock that corresponds as closely as possible to the
// passage of time as measured by system calls such as poll() but it may not
// always be possible to do this.
func GetMonotonicTime() int64 {

	ret := C.g_get_monotonic_time()

	var ret0 int64

	ret0 = int64(ret)

	return ret0
}

// GetNumProcessors: determine the approximate number of threads that the system
// will schedule simultaneously for this process. This is intended to be used as
// a parameter to g_thread_pool_new() for CPU bound tasks and similar cases.
func GetNumProcessors() uint {

	ret := C.g_get_num_processors()

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// GetOsInfo: get information about the operating system.
//
// On Linux this comes from the `/etc/os-release` file. On other systems, it may
// come from a variety of sources. You can either use the standard key names
// like G_OS_INFO_KEY_NAME or pass any UTF-8 string key name. For example,
// `/etc/os-release` provides a number of other less commonly used values that
// may be useful. No key is guaranteed to be provided, so the caller should
// always check if the result is nil.
func GetOsInfo(keyName string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(keyName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_get_os_info(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// GetPrgname gets the name of the program. This name should not be localized,
// in contrast to g_get_application_name().
//
// If you are using #GApplication the program name is set in
// g_application_run(). In case of GDK or GTK+ it is set in gdk_init(), which is
// called by gtk_init() and the Application::startup handler. The program name
// is found by taking the last component of @argv[0].
func GetPrgname() string {

	ret := C.g_get_prgname()

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// GetRealName gets the real name of the user. This usually comes from the
// user's entry in the `passwd` file. The encoding of the returned string is
// system-defined. (On Windows, it is, however, always UTF-8.) If the real user
// name cannot be determined, the string "Unknown" is returned.
func GetRealName() string {

	ret := C.g_get_real_name()

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// GetRealTime queries the system wall-clock time.
//
// This call is functionally equivalent to g_get_current_time() except that the
// return value is often more convenient than dealing with a Val.
//
// You should only use this call if you are actually interested in the real
// wall-clock time. g_get_monotonic_time() is probably more useful for measuring
// intervals.
func GetRealTime() int64 {

	ret := C.g_get_real_time()

	var ret0 int64

	ret0 = int64(ret)

	return ret0
}

// GetSystemConfigDirs returns an ordered list of base directories in which to
// access system-wide configuration information.
//
// On UNIX platforms this is determined using the mechanisms described in the
// XDG Base Directory Specification
// (http://www.freedesktop.org/Standards/basedir-spec). In this case the list of
// directories retrieved will be `XDG_CONFIG_DIRS`.
//
// On Windows it follows XDG Base Directory Specification if `XDG_CONFIG_DIRS`
// is defined. If `XDG_CONFIG_DIRS` is undefined, the directory that contains
// application data for all users is used instead. A typical path is
// `C:\Documents and Settings\All Users\Application Data`. This folder is used
// for application data that is not user specific. For example, an application
// can store a spell-check dictionary, a database of clip art, or a log file in
// the CSIDL_COMMON_APPDATA folder. This information will not roam and is
// available to anyone using the computer.
func GetSystemConfigDirs() []string {

	ret := C.g_get_system_config_dirs()

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
		}
	}

	return ret0
}

// GetSystemDataDirs returns an ordered list of base directories in which to
// access system-wide application data.
//
// On UNIX platforms this is determined using the mechanisms described in the
// XDG Base Directory Specification
// (http://www.freedesktop.org/Standards/basedir-spec) In this case the list of
// directories retrieved will be `XDG_DATA_DIRS`.
//
// On Windows it follows XDG Base Directory Specification if `XDG_DATA_DIRS` is
// defined. If `XDG_DATA_DIRS` is undefined, the first elements in the list are
// the Application Data and Documents folders for All Users. (These can be
// determined only on Windows 2000 or later and are not present in the list on
// other Windows versions.) See documentation for CSIDL_COMMON_APPDATA and
// CSIDL_COMMON_DOCUMENTS.
//
// Then follows the "share" subfolder in the installation folder for the package
// containing the DLL that calls this function, if it can be determined.
//
// Finally the list contains the "share" subfolder in the installation folder
// for GLib, and in the installation folder for the package the application's
// .exe file belongs to.
//
// The installation folders above are determined by looking up the folder where
// the module (DLL or EXE) in question is located. If the folder's name is
// "bin", its parent is used, otherwise the folder itself.
//
// Note that on Windows the returned list can vary depending on where this
// function is called.
func GetSystemDataDirs() []string {

	ret := C.g_get_system_data_dirs()

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
		}
	}

	return ret0
}

// GetTmpDir gets the directory to use for temporary files.
//
// On UNIX, this is taken from the `TMPDIR` environment variable. If the
// variable is not set, `P_tmpdir` is used, as defined by the system C library.
// Failing that, a hard-coded default of "/tmp" is returned.
//
// On Windows, the `TEMP` environment variable is used, with the root directory
// of the Windows installation (eg: "C:\") used as a default.
//
// The encoding of the returned string is system-defined. On Windows, it is
// always UTF-8. The return value is never nil or the empty string.
func GetTmpDir() string {

	ret := C.g_get_tmp_dir()

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// GetUserCacheDir returns a base directory in which to store non-essential,
// cached data specific to particular user.
//
// On UNIX platforms this is determined using the mechanisms described in the
// XDG Base Directory Specification
// (http://www.freedesktop.org/Standards/basedir-spec). In this case the
// directory retrieved will be `XDG_CACHE_HOME`.
//
// On Windows it follows XDG Base Directory Specification if `XDG_CACHE_HOME` is
// defined. If `XDG_CACHE_HOME` is undefined, the directory that serves as a
// common repository for temporary Internet files is used instead. A typical
// path is `C:\Documents and Settings\username\Local Settings\Temporary Internet
// Files`. See the documentation for `CSIDL_INTERNET_CACHE`
// (https://msdn.microsoft.com/en-us/library/windows/desktop/bb76249428v=vs.8529.aspx#csidl_internet_cache).
func GetUserCacheDir() string {

	ret := C.g_get_user_cache_dir()

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// GetUserConfigDir returns a base directory in which to store user-specific
// application configuration information such as user preferences and settings.
//
// On UNIX platforms this is determined using the mechanisms described in the
// XDG Base Directory Specification
// (http://www.freedesktop.org/Standards/basedir-spec). In this case the
// directory retrieved will be `XDG_CONFIG_HOME`.
//
// On Windows it follows XDG Base Directory Specification if `XDG_CONFIG_HOME`
// is defined. If `XDG_CONFIG_HOME` is undefined, the folder to use for local
// (as opposed to roaming) application data is used instead. See the
// documentation for `CSIDL_LOCAL_APPDATA`
// (https://msdn.microsoft.com/en-us/library/windows/desktop/bb76249428v=vs.8529.aspx#csidl_local_appdata).
// Note that in this case on Windows it will be the same as what
// g_get_user_data_dir() returns.
func GetUserConfigDir() string {

	ret := C.g_get_user_config_dir()

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// GetUserDataDir returns a base directory in which to access application data
// such as icons that is customized for a particular user.
//
// On UNIX platforms this is determined using the mechanisms described in the
// XDG Base Directory Specification
// (http://www.freedesktop.org/Standards/basedir-spec). In this case the
// directory retrieved will be `XDG_DATA_HOME`.
//
// On Windows it follows XDG Base Directory Specification if `XDG_DATA_HOME` is
// defined. If `XDG_DATA_HOME` is undefined, the folder to use for local (as
// opposed to roaming) application data is used instead. See the documentation
// for `CSIDL_LOCAL_APPDATA`
// (https://msdn.microsoft.com/en-us/library/windows/desktop/bb76249428v=vs.8529.aspx#csidl_local_appdata).
// Note that in this case on Windows it will be the same as what
// g_get_user_config_dir() returns.
func GetUserDataDir() string {

	ret := C.g_get_user_data_dir()

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// GetUserName gets the user name of the current user. The encoding of the
// returned string is system-defined. On UNIX, it might be the preferred file
// name encoding, or something else, and there is no guarantee that it is even
// consistent on a machine. On Windows, it is always UTF-8.
func GetUserName() string {

	ret := C.g_get_user_name()

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// GetUserRuntimeDir returns a directory that is unique to the current user on
// the local system.
//
// This is determined using the mechanisms described in the XDG Base Directory
// Specification (http://www.freedesktop.org/Standards/basedir-spec). This is
// the directory specified in the `XDG_RUNTIME_DIR` environment variable. In the
// case that this variable is not set, we return the value of
// g_get_user_cache_dir(), after verifying that it exists.
func GetUserRuntimeDir() string {

	ret := C.g_get_user_runtime_dir()

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// GetUserSpecialDir returns the full path of a special directory using its
// logical id.
//
// On UNIX this is done using the XDG special user directories. For
// compatibility with existing practise, G_USER_DIRECTORY_DESKTOP falls back to
// `$HOME/Desktop` when XDG special user directories have not been set up.
//
// Depending on the platform, the user might be able to change the path of the
// special directory without requiring the session to restart; GLib will not
// reflect any change once the special directories are loaded.
func GetUserSpecialDir(directory UserDirectory) string {
	var arg1 C.GUserDirectory

	arg1 = (C.GUserDirectory)(directory)

	ret := C.g_get_user_special_dir(arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Getenv returns the value of an environment variable.
//
// On UNIX, the name and value are byte strings which might or might not be in
// some consistent character set and encoding. On Windows, they are in UTF-8. On
// Windows, in case the environment variable's value contains references to
// other environment variables, they are expanded.
func Getenv(variable string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(variable))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_getenv(arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// HashTableAdd: this is a convenience function for using a Table as a set. It
// is equivalent to calling g_hash_table_replace() with @key as both the key and
// the value.
//
// In particular, this means that if @key already exists in the hash table, then
// the old copy of @key in the hash table is freed and @key replaces it in the
// table.
//
// When a hash table only ever contains keys that have themselves as the
// corresponding value it is able to be stored more efficiently. See the
// discussion in the section description.
//
// Starting from GLib 2.40, this function returns a boolean value to indicate
// whether the newly added value was already in the hash table or not.
func HashTableAdd(hashTable *HashTable, key interface{}) bool {
	var arg1 *C.GHashTable
	var arg2 C.gpointer

	arg1 = (*C.GHashTable)(hashTable.Native())
	arg2 = C.gpointer(box.Assign(key))

	ret := C.g_hash_table_add(arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// HashTableContains checks if @key is in @hash_table.
func HashTableContains(hashTable *HashTable, key interface{}) bool {
	var arg1 *C.GHashTable
	var arg2 C.gpointer

	arg1 = (*C.GHashTable)(hashTable.Native())
	arg2 = C.gpointer(box.Assign(key))

	ret := C.g_hash_table_contains(arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// HashTableDestroy destroys all keys and values in the Table and decrements its
// reference count by 1. If keys and/or values are dynamically allocated, you
// should either free them first or create the Table with destroy notifiers
// using g_hash_table_new_full(). In the latter case the destroy functions you
// supplied will be called on all keys and values during the destruction phase.
func HashTableDestroy(hashTable *HashTable) {
	var arg1 *C.GHashTable

	arg1 = (*C.GHashTable)(hashTable.Native())

	C.g_hash_table_destroy(arg1)
}

// HashTableInsert inserts a new key and value into a Table.
//
// If the key already exists in the Table its current value is replaced with the
// new value. If you supplied a @value_destroy_func when creating the Table, the
// old value is freed using that function. If you supplied a @key_destroy_func
// when creating the Table, the passed key is freed using that function.
//
// Starting from GLib 2.40, this function returns a boolean value to indicate
// whether the newly added value was already in the hash table or not.
func HashTableInsert(hashTable *HashTable, key interface{}, value interface{}) bool {
	var arg1 *C.GHashTable
	var arg2 C.gpointer
	var arg3 C.gpointer

	arg1 = (*C.GHashTable)(hashTable.Native())
	arg2 = C.gpointer(box.Assign(key))
	arg3 = C.gpointer(box.Assign(value))

	ret := C.g_hash_table_insert(arg1, arg2, arg3)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// HashTableLookup looks up a key in a Table. Note that this function cannot
// distinguish between a key that is not present and one which is present and
// has the value nil. If you need this distinction, use
// g_hash_table_lookup_extended().
func HashTableLookup(hashTable *HashTable, key interface{}) interface{} {
	var arg1 *C.GHashTable
	var arg2 C.gpointer

	arg1 = (*C.GHashTable)(hashTable.Native())
	arg2 = C.gpointer(box.Assign(key))

	ret := C.g_hash_table_lookup(arg1, arg2)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// HashTableLookupExtended looks up a key in the Table, returning the original
// key and the associated value and a #gboolean which is true if the key was
// found. This is useful if you need to free the memory allocated for the
// original key, for example before calling g_hash_table_remove().
//
// You can actually pass nil for @lookup_key to test whether the nil key exists,
// provided the hash and equal functions of @hash_table are nil-safe.
func HashTableLookupExtended(hashTable *HashTable, lookupKey interface{}) (origKey interface{}, value interface{}, ok bool) {
	var arg1 *C.GHashTable
	var arg2 C.gpointer
	var arg3 *C.gpointer // out
	var arg4 *C.gpointer // out

	arg1 = (*C.GHashTable)(hashTable.Native())
	arg2 = C.gpointer(box.Assign(lookupKey))

	ret := C.g_hash_table_lookup_extended(arg1, arg2, &arg3, &arg4)

	var ret0 interface{}
	var ret1 interface{}
	var ret2 bool

	ret0 = box.Get(uintptr(arg3)).(interface{})

	ret1 = box.Get(uintptr(arg4)).(interface{})

	ret2 = C.BOOL(ret) != 0

	return ret0, ret1, ret2
}

// HashTableRemove removes a key and its associated value from a Table.
//
// If the Table was created using g_hash_table_new_full(), the key and value are
// freed using the supplied destroy functions, otherwise you have to make sure
// that any dynamically allocated values are freed yourself.
func HashTableRemove(hashTable *HashTable, key interface{}) bool {
	var arg1 *C.GHashTable
	var arg2 C.gpointer

	arg1 = (*C.GHashTable)(hashTable.Native())
	arg2 = C.gpointer(box.Assign(key))

	ret := C.g_hash_table_remove(arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// HashTableRemoveAll removes all keys and their associated values from a Table.
//
// If the Table was created using g_hash_table_new_full(), the keys and values
// are freed using the supplied destroy functions, otherwise you have to make
// sure that any dynamically allocated values are freed yourself.
func HashTableRemoveAll(hashTable *HashTable) {
	var arg1 *C.GHashTable

	arg1 = (*C.GHashTable)(hashTable.Native())

	C.g_hash_table_remove_all(arg1)
}

// HashTableReplace inserts a new key and value into a Table similar to
// g_hash_table_insert(). The difference is that if the key already exists in
// the Table, it gets replaced by the new key. If you supplied a
// @value_destroy_func when creating the Table, the old value is freed using
// that function. If you supplied a @key_destroy_func when creating the Table,
// the old key is freed using that function.
//
// Starting from GLib 2.40, this function returns a boolean value to indicate
// whether the newly added value was already in the hash table or not.
func HashTableReplace(hashTable *HashTable, key interface{}, value interface{}) bool {
	var arg1 *C.GHashTable
	var arg2 C.gpointer
	var arg3 C.gpointer

	arg1 = (*C.GHashTable)(hashTable.Native())
	arg2 = C.gpointer(box.Assign(key))
	arg3 = C.gpointer(box.Assign(value))

	ret := C.g_hash_table_replace(arg1, arg2, arg3)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// HashTableSize returns the number of elements contained in the Table.
func HashTableSize(hashTable *HashTable) uint {
	var arg1 *C.GHashTable

	arg1 = (*C.GHashTable)(hashTable.Native())

	ret := C.g_hash_table_size(arg1)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// HashTableSteal removes a key and its associated value from a Table without
// calling the key and value destroy functions.
func HashTableSteal(hashTable *HashTable, key interface{}) bool {
	var arg1 *C.GHashTable
	var arg2 C.gpointer

	arg1 = (*C.GHashTable)(hashTable.Native())
	arg2 = C.gpointer(box.Assign(key))

	ret := C.g_hash_table_steal(arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// HashTableStealAll removes all keys and their associated values from a Table
// without calling the key and value destroy functions.
func HashTableStealAll(hashTable *HashTable) {
	var arg1 *C.GHashTable

	arg1 = (*C.GHashTable)(hashTable.Native())

	C.g_hash_table_steal_all(arg1)
}

// HashTableStealExtended looks up a key in the Table, stealing the original key
// and the associated value and returning true if the key was found. If the key
// was not found, false is returned.
//
// If found, the stolen key and value are removed from the hash table without
// calling the key and value destroy functions, and ownership is transferred to
// the caller of this method; as with g_hash_table_steal().
//
// You can pass nil for @lookup_key, provided the hash and equal functions of
// @hash_table are nil-safe.
func HashTableStealExtended(hashTable *HashTable, lookupKey interface{}) (stolenKey interface{}, stolenValue interface{}, ok bool) {
	var arg1 *C.GHashTable
	var arg2 C.gpointer
	var arg3 *C.gpointer // out
	var arg4 *C.gpointer // out

	arg1 = (*C.GHashTable)(hashTable.Native())
	arg2 = C.gpointer(box.Assign(lookupKey))

	ret := C.g_hash_table_steal_extended(arg1, arg2, &arg3, &arg4)

	var ret0 interface{}
	var ret1 interface{}
	var ret2 bool

	ret0 = box.Get(uintptr(arg3)).(interface{})

	ret1 = box.Get(uintptr(arg4)).(interface{})

	ret2 = C.BOOL(ret) != 0

	return ret0, ret1, ret2
}

// HashTableUnref: atomically decrements the reference count of @hash_table by
// one. If the reference count drops to 0, all keys and values will be
// destroyed, and all memory allocated by the hash table is released. This
// function is MT-safe and may be called from any thread.
func HashTableUnref(hashTable *HashTable) {
	var arg1 *C.GHashTable

	arg1 = (*C.GHashTable)(hashTable.Native())

	C.g_hash_table_unref(arg1)
}

// HookDestroy destroys a #GHook, given its ID.
func HookDestroy(hookList *HookList, hookID uint32) bool {
	var arg1 *C.GHookList
	var arg2 C.gulong

	arg1 = (*C.GHookList)(hookList.Native())
	arg2 = C.gulong(hookID)

	ret := C.g_hook_destroy(arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// HookDestroyLink removes one #GHook from a List, marking it inactive and
// calling g_hook_unref() on it.
func HookDestroyLink(hookList *HookList, hook *Hook) {
	var arg1 *C.GHookList
	var arg2 *C.GHook

	arg1 = (*C.GHookList)(hookList.Native())
	arg2 = (*C.GHook)(hook.Native())

	C.g_hook_destroy_link(arg1, arg2)
}

// HookFree calls the List @finalize_hook function if it exists, and frees the
// memory allocated for the #GHook.
func HookFree(hookList *HookList, hook *Hook) {
	var arg1 *C.GHookList
	var arg2 *C.GHook

	arg1 = (*C.GHookList)(hookList.Native())
	arg2 = (*C.GHook)(hook.Native())

	C.g_hook_free(arg1, arg2)
}

// HookInsertBefore inserts a #GHook into a List, before a given #GHook.
func HookInsertBefore(hookList *HookList, sibling *Hook, hook *Hook) {
	var arg1 *C.GHookList
	var arg2 *C.GHook
	var arg3 *C.GHook

	arg1 = (*C.GHookList)(hookList.Native())
	arg2 = (*C.GHook)(sibling.Native())
	arg3 = (*C.GHook)(hook.Native())

	C.g_hook_insert_before(arg1, arg2, arg3)
}

// HookPrepend prepends a #GHook on the start of a List.
func HookPrepend(hookList *HookList, hook *Hook) {
	var arg1 *C.GHookList
	var arg2 *C.GHook

	arg1 = (*C.GHookList)(hookList.Native())
	arg2 = (*C.GHook)(hook.Native())

	C.g_hook_prepend(arg1, arg2)
}

// HookUnref decrements the reference count of a #GHook. If the reference count
// falls to 0, the #GHook is removed from the List and g_hook_free() is called
// to free it.
func HookUnref(hookList *HookList, hook *Hook) {
	var arg1 *C.GHookList
	var arg2 *C.GHook

	arg1 = (*C.GHookList)(hookList.Native())
	arg2 = (*C.GHook)(hook.Native())

	C.g_hook_unref(arg1, arg2)
}

// HostnameIsASCIIEncoded tests if @hostname contains segments with an
// ASCII-compatible encoding of an Internationalized Domain Name. If this
// returns true, you should decode the hostname with g_hostname_to_unicode()
// before displaying it to the user.
//
// Note that a hostname might contain a mix of encoded and unencoded segments,
// and so it is possible for g_hostname_is_non_ascii() and
// g_hostname_is_ascii_encoded() to both return true for a name.
func HostnameIsASCIIEncoded(hostname string) bool {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(hostname))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_hostname_is_ascii_encoded(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// HostnameIsIpAddress tests if @hostname is the string form of an IPv4 or IPv6
// address. (Eg, "192.168.0.1".)
//
// Since 2.66, IPv6 addresses with a zone-id are accepted (RFC6874).
func HostnameIsIpAddress(hostname string) bool {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(hostname))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_hostname_is_ip_address(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// HostnameIsNonASCII tests if @hostname contains Unicode characters. If this
// returns true, you need to encode the hostname with g_hostname_to_ascii()
// before using it in non-IDN-aware contexts.
//
// Note that a hostname might contain a mix of encoded and unencoded segments,
// and so it is possible for g_hostname_is_non_ascii() and
// g_hostname_is_ascii_encoded() to both return true for a name.
func HostnameIsNonASCII(hostname string) bool {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(hostname))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_hostname_is_non_ascii(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// HostnameToASCII converts @hostname to its canonical ASCII form; an ASCII-only
// string containing no uppercase letters and not ending with a trailing dot.
func HostnameToASCII(hostname string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(hostname))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_hostname_to_ascii(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// HostnameToUnicode converts @hostname to its canonical presentation form; a
// UTF-8 string in Unicode normalization form C, containing no uppercase
// letters, no forbidden characters, and no ASCII-encoded segments, and not
// ending with a trailing dot.
//
// Of course if @hostname is not an internationalized hostname, then the
// canonical presentation form will be entirely ASCII.
func HostnameToUnicode(hostname string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(hostname))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_hostname_to_unicode(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Iconv: same as the standard UNIX routine iconv(), but may be implemented via
// libiconv on UNIX flavors that lack a native implementation.
//
// GLib provides g_convert() and g_locale_to_utf8() which are likely more
// convenient than the raw iconv wrappers.
//
// Note that the behaviour of iconv() for characters which are valid in the
// input character set, but which have no representation in the output character
// set, is implementation defined. This function may return success (with a
// positive number of non-reversible conversions as replacement characters were
// used), or it may return -1 and set an error such as EILSEQ, in such a
// situation.
func Iconv(converter IConv, inbuf string, inbytesLeft uint, outbuf string, outbytesLeft uint) uint {
	var arg1 C.GIConv
	var arg2 **C.gchar
	var arg3 *C.gsize
	var arg4 **C.gchar
	var arg5 *C.gsize

	arg1 = (C.GIConv)(converter.Native())
	arg2 = (*C.gchar)(C.CString(inbuf))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gsize)(inbytesLeft)
	arg4 = (*C.gchar)(C.CString(outbuf))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.gsize)(outbytesLeft)

	ret := C.g_iconv(arg1, arg2, arg3, arg4, arg5)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// IconvOpen: same as the standard UNIX routine iconv_open(), but may be
// implemented via libiconv on UNIX flavors that lack a native implementation.
//
// GLib provides g_convert() and g_locale_to_utf8() which are likely more
// convenient than the raw iconv wrappers.
func IconvOpen(toCodeset string, fromCodeset string) IConv {
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg1 = (*C.gchar)(C.CString(toCodeset))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(fromCodeset))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_iconv_open(arg1, arg2)

	var ret0 IConv

	{
		ret0 = WrapIConv(unsafe.Pointer(ret))
	}

	return ret0
}

// IdleAddFull adds a function to be called whenever there are no higher
// priority events pending. If the function returns false it is automatically
// removed from the list of event sources and will not be called again.
//
// See [memory management of sources][mainloop-memory-management] for details on
// how to handle the return value and memory management of @data.
//
// This internally creates a main loop source using g_idle_source_new() and
// attaches it to the global Context using g_source_attach(), so the callback
// will be invoked in whichever thread is running that main context. You can do
// these steps manually if you need greater control or to use a custom main
// context.
func IdleAddFull(priority int, function SourceFunc) uint {
	var arg1 C.gint
	var arg2 C.GSourceFunc
	var arg3 C.gpointer
	var arg4 C.GDestroyNotify

	arg1 = C.gint(priority)
	arg2 = (*[0]byte)(C.gotk4_SourceFunc)
	arg3 = C.gpointer(box.Assign(function))
	arg4 = (*[0]byte)(C.callbackDelete)

	ret := C.g_idle_add_full(arg1, arg2, arg3, arg4)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// IdleRemoveByData removes the idle function with the given data.
func IdleRemoveByData(data interface{}) bool {
	var arg1 C.gpointer

	arg1 = C.gpointer(box.Assign(data))

	ret := C.g_idle_remove_by_data(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// NewIdleSource creates a new idle source.
//
// The source will not initially be associated with any Context and must be
// added to one with g_source_attach() before it will be executed. Note that the
// default priority for idle sources is G_PRIORITY_DEFAULT_IDLE, as compared to
// other sources which have a default priority of G_PRIORITY_DEFAULT.
func NewIdleSource() *Source {

	ret := C.g_idle_source_new()

	var ret0 *Source

	{
		ret0 = WrapSource(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Source) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Int64Equal compares the two #gint64 values being pointed to and returns true
// if they are equal. It can be passed to g_hash_table_new() as the
// @key_equal_func parameter, when using non-nil pointers to 64-bit integers as
// keys in a Table.
func Int64Equal(v1 interface{}, v2 interface{}) bool {
	var arg1 C.gpointer
	var arg2 C.gpointer

	arg1 = C.gpointer(box.Assign(v1))
	arg2 = C.gpointer(box.Assign(v2))

	ret := C.g_int64_equal(arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Int64Hash converts a pointer to a #gint64 to a hash value.
//
// It can be passed to g_hash_table_new() as the @hash_func parameter, when
// using non-nil pointers to 64-bit integer values as keys in a Table.
func Int64Hash(v interface{}) uint {
	var arg1 C.gpointer

	arg1 = C.gpointer(box.Assign(v))

	ret := C.g_int64_hash(arg1)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// IntEqual compares the two #gint values being pointed to and returns true if
// they are equal. It can be passed to g_hash_table_new() as the @key_equal_func
// parameter, when using non-nil pointers to integers as keys in a Table.
//
// Note that this function acts on pointers to #gint, not on #gint directly: if
// your hash table's keys are of the form `GINT_TO_POINTER (n)`, use
// g_direct_equal() instead.
func IntEqual(v1 interface{}, v2 interface{}) bool {
	var arg1 C.gpointer
	var arg2 C.gpointer

	arg1 = C.gpointer(box.Assign(v1))
	arg2 = C.gpointer(box.Assign(v2))

	ret := C.g_int_equal(arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IntHash converts a pointer to a #gint to a hash value. It can be passed to
// g_hash_table_new() as the @hash_func parameter, when using non-nil pointers
// to integer values as keys in a Table.
//
// Note that this function acts on pointers to #gint, not on #gint directly: if
// your hash table's keys are of the form `GINT_TO_POINTER (n)`, use
// g_direct_hash() instead.
func IntHash(v interface{}) uint {
	var arg1 C.gpointer

	arg1 = C.gpointer(box.Assign(v))

	ret := C.g_int_hash(arg1)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// InternStaticString returns a canonical representation for @string. Interned
// strings can be compared for equality by comparing the pointers, instead of
// using strcmp(). g_intern_static_string() does not copy the string, therefore
// @string must not be freed or modified.
//
// This function must not be used before library constructors have finished
// running. In particular, this means it cannot be used to initialize global
// variables in C++.
func InternStaticString(string string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_intern_static_string(arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// InternString returns a canonical representation for @string. Interned strings
// can be compared for equality by comparing the pointers, instead of using
// strcmp().
//
// This function must not be used before library constructors have finished
// running. In particular, this means it cannot be used to initialize global
// variables in C++.
func InternString(string string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_intern_string(arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// IOAddWatchFull adds the OChannel into the default main loop context with the
// given priority.
//
// This internally creates a main loop source using g_io_create_watch() and
// attaches it to the main loop context with g_source_attach(). You can do these
// steps manually if you need greater control.
func IOAddWatchFull(channel *IOChannel, priority int, condition IOCondition, fn IOFunc) uint {
	var arg1 *C.GIOChannel
	var arg2 C.gint
	var arg3 C.GIOCondition
	var arg4 C.GIOFunc
	var arg5 C.gpointer
	var arg6 C.GDestroyNotify

	arg1 = (*C.GIOChannel)(channel.Native())
	arg2 = C.gint(priority)
	arg3 = (C.GIOCondition)(condition)
	arg4 = (*[0]byte)(C.gotk4_IOFunc)
	arg5 = C.gpointer(box.Assign(fn))
	arg6 = (*[0]byte)(C.callbackDelete)

	ret := C.g_io_add_watch_full(arg1, arg2, arg3, arg4, arg5, arg6)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// IOChannelErrorFromErrno converts an `errno` error number to a OChannelError.
func IOChannelErrorFromErrno(en int) IOChannelError {
	var arg1 C.gint

	arg1 = C.gint(en)

	ret := C.g_io_channel_error_from_errno(arg1)

	var ret0 IOChannelError

	ret0 = IOChannelError(ret)

	return ret0
}

func IOChannelErrorQuark() Quark {

	ret := C.g_io_channel_error_quark()

	var ret0 Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = Quark(tmp)
	}

	return ret0
}

// IOCreateWatch creates a #GSource that's dispatched when @condition is met for
// the given @channel. For example, if condition is IO_IN, the source will be
// dispatched when there's data available for reading.
//
// The callback function invoked by the #GSource should be added with
// g_source_set_callback(), but it has type OFunc (not Func).
//
// g_io_add_watch() is a simpler interface to this same functionality, for the
// case where you want to add the source to the default main loop context at the
// default priority.
//
// On Windows, polling a #GSource created to watch a channel for a socket puts
// the socket in non-blocking mode. This is a side-effect of the implementation
// and unavoidable.
func IOCreateWatch(channel *IOChannel, condition IOCondition) *Source {
	var arg1 *C.GIOChannel
	var arg2 C.GIOCondition

	arg1 = (*C.GIOChannel)(channel.Native())
	arg2 = (C.GIOCondition)(condition)

	ret := C.g_io_create_watch(arg1, arg2)

	var ret0 *Source

	{
		ret0 = WrapSource(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Source) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

func KeyFileErrorQuark() Quark {

	ret := C.g_key_file_error_quark()

	var ret0 Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = Quark(tmp)
	}

	return ret0
}

// Listenv gets the names of all variables set in the environment.
//
// Programs that want to be portable to Windows should typically use this
// function and g_getenv() instead of using the environ array from the C library
// directly. On Windows, the strings in the environ array are in system codepage
// encoding, while in most of the typical use cases for environment variables in
// GLib-using programs you want the UTF-8 encoding that this function and
// g_getenv() provide.
func Listenv() []string {

	ret := C.g_listenv()

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// LocaleFromUTF8 converts a string from UTF-8 to the encoding used for strings
// by the C runtime (usually the same as that used by the operating system) in
// the [current locale][setlocale]. On Windows this means the system codepage.
//
// The input string shall not contain nul characters even if the @len argument
// is positive. A nul character found inside the string will result in error
// G_CONVERT_ERROR_ILLEGAL_SEQUENCE. Use g_convert() to convert input that may
// contain embedded nul characters.
func LocaleFromUTF8(utf8String string, len int) (bytesRead uint, bytesWritten uint, guint8s []byte, err error) {
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 *C.gsize // out
	var arg4 *C.gsize // out
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(utf8String))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(len)

	ret := C.g_locale_from_utf8(arg1, arg2, &arg3, &arg4, &gError)

	var ret0 uint
	var ret1 uint
	var ret2 []byte
	var goError error

	ret0 = uint(arg3)

	ret1 = uint(arg4)

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret2))
		sliceHeader.Data = uintptr(unsafe.Pointer(ret))
		sliceHeader.Len = arg4
		sliceHeader.Cap = arg4
		runtime.SetFinalizer(&ret, func() {
			C.free(unsafe.Pointer(ret))
		})
		defer runtime.KeepAlive(ret)
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}

// LocaleToUTF8 converts a string which is in the encoding used for strings by
// the C runtime (usually the same as that used by the operating system) in the
// [current locale][setlocale] into a UTF-8 string.
//
// If the source encoding is not UTF-8 and the conversion output contains a nul
// character, the error G_CONVERT_ERROR_EMBEDDED_NUL is set and the function
// returns nil. If the source encoding is UTF-8, an embedded nul character is
// treated with the G_CONVERT_ERROR_ILLEGAL_SEQUENCE error for backward
// compatibility with earlier versions of this library. Use g_convert() to
// produce output that may contain embedded nul characters.
func LocaleToUTF8(opsysstring []byte) (bytesRead uint, bytesWritten uint, utf8 string, err error) {
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 *C.gsize // out
	var arg4 *C.gsize // out
	var gError *C.GError

	arg1 = (*C.gchar)(unsafe.Pointer(&opsysstring[0]))
	arg2 = len(opsysstring)
	defer runtime.KeepAlive(opsysstring)

	ret := C.g_locale_to_utf8(arg1, arg2, &arg3, &arg4, &gError)

	var ret0 uint
	var ret1 uint
	var ret2 string
	var goError error

	ret0 = uint(arg3)

	ret1 = uint(arg4)

	ret2 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}

// LogDefaultHandler: the default log handler set up by GLib;
// g_log_set_default_handler() allows to install an alternate default log
// handler. This is used if no log handler has been set for the particular log
// domain and log level combination. It outputs the message to stderr or stdout
// and if the log level is fatal it calls G_BREAKPOINT(). It automatically
// prints a new-line character after the message, so one does not need to be
// manually included in @message.
//
// The behavior of this log handler can be influenced by a number of environment
// variables:
//
// - `G_MESSAGES_PREFIXED`: A :-separated list of log levels for which messages
// should be prefixed by the program name and PID of the application.
//
// - `G_MESSAGES_DEBUG`: A space-separated list of log domains for which debug
// and informational messages are printed. By default these messages are not
// printed.
//
// stderr is used for levels G_LOG_LEVEL_ERROR, G_LOG_LEVEL_CRITICAL,
// G_LOG_LEVEL_WARNING and G_LOG_LEVEL_MESSAGE. stdout is used for the rest.
//
// This has no effect if structured logging is enabled; see [Using Structured
// Logging][using-structured-logging].
func LogDefaultHandler(logDomain string, logLevel LogLevelFlags, message string, unusedData interface{}) {
	var arg1 *C.gchar
	var arg2 C.GLogLevelFlags
	var arg3 *C.gchar
	var arg4 C.gpointer

	arg1 = (*C.gchar)(C.CString(logDomain))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GLogLevelFlags)(logLevel)
	arg3 = (*C.gchar)(C.CString(message))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = C.gpointer(box.Assign(unusedData))

	C.g_log_default_handler(arg1, arg2, arg3, arg4)
}

// LogRemoveHandler removes the log handler.
//
// This has no effect if structured logging is enabled; see [Using Structured
// Logging][using-structured-logging].
func LogRemoveHandler(logDomain string, handlerID uint) {
	var arg1 *C.gchar
	var arg2 C.guint

	arg1 = (*C.gchar)(C.CString(logDomain))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.guint(handlerID)

	C.g_log_remove_handler(arg1, arg2)
}

// LogSetAlwaysFatal sets the message levels which are always fatal, in any log
// domain. When a message with any of these levels is logged the program
// terminates. You can only set the levels defined by GLib to be fatal.
// G_LOG_LEVEL_ERROR is always fatal.
//
// You can also make some message levels fatal at runtime by setting the
// `G_DEBUG` environment variable (see Running GLib Applications
// (glib-running.html)).
//
// Libraries should not call this function, as it affects all messages logged by
// a process, including those from other libraries.
//
// Structured log messages (using g_log_structured() and
// g_log_structured_array()) are fatal only if the default log writer is used;
// otherwise it is up to the writer function to determine which log messages are
// fatal. See [Using Structured Logging][using-structured-logging].
func LogSetAlwaysFatal(fatalMask LogLevelFlags) LogLevelFlags {
	var arg1 C.GLogLevelFlags

	arg1 = (C.GLogLevelFlags)(fatalMask)

	ret := C.g_log_set_always_fatal(arg1)

	var ret0 LogLevelFlags

	ret0 = LogLevelFlags(ret)

	return ret0
}

// LogSetFatalMask sets the log levels which are fatal in the given domain.
// G_LOG_LEVEL_ERROR is always fatal.
//
// This has no effect on structured log messages (using g_log_structured() or
// g_log_structured_array()). To change the fatal behaviour for specific log
// messages, programs must install a custom log writer function using
// g_log_set_writer_func(). See [Using Structured
// Logging][using-structured-logging].
//
// This function is mostly intended to be used with G_LOG_LEVEL_CRITICAL. You
// should typically not set G_LOG_LEVEL_WARNING, G_LOG_LEVEL_MESSAGE,
// G_LOG_LEVEL_INFO or G_LOG_LEVEL_DEBUG as fatal except inside of test
// programs.
func LogSetFatalMask(logDomain string, fatalMask LogLevelFlags) LogLevelFlags {
	var arg1 *C.gchar
	var arg2 C.GLogLevelFlags

	arg1 = (*C.gchar)(C.CString(logDomain))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GLogLevelFlags)(fatalMask)

	ret := C.g_log_set_fatal_mask(arg1, arg2)

	var ret0 LogLevelFlags

	ret0 = LogLevelFlags(ret)

	return ret0
}

// LogSetHandlerFull: like g_log_set_handler(), but takes a destroy notify for
// the @user_data.
//
// This has no effect if structured logging is enabled; see [Using Structured
// Logging][using-structured-logging].
func LogSetHandlerFull(logDomain string, logLevels LogLevelFlags, logFunc LogFunc) uint {
	var arg1 *C.gchar
	var arg2 C.GLogLevelFlags
	var arg3 C.GLogFunc
	var arg4 C.gpointer
	var arg5 C.GDestroyNotify

	arg1 = (*C.gchar)(C.CString(logDomain))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GLogLevelFlags)(logLevels)
	arg3 = (*[0]byte)(C.gotk4_LogFunc)
	arg4 = C.gpointer(box.Assign(logFunc))
	arg5 = (*[0]byte)(C.callbackDelete)

	ret := C.g_log_set_handler_full(arg1, arg2, arg3, arg4, arg5)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// LogSetWriterFunc: set a writer function which will be called to format and
// write out each log message. Each program should set a writer function, or the
// default writer (g_log_writer_default()) will be used.
//
// Libraries **must not** call this function — only programs are allowed to
// install a writer function, as there must be a single, central point where log
// messages are formatted and outputted.
//
// There can only be one writer function. It is an error to set more than one.
func LogSetWriterFunc(fn LogWriterFunc) {
	var arg1 C.GLogWriterFunc
	var arg2 C.gpointer
	var arg3 C.GDestroyNotify

	C.g_log_set_writer_func(arg1, arg2, arg3)
}

// LogStructuredArray: log a message with structured data. The message will be
// passed through to the log writer set by the application using
// g_log_set_writer_func(). If the message is fatal (i.e. its log level is
// G_LOG_LEVEL_ERROR), the program will be aborted at the end of this function.
//
// See g_log_structured() for more documentation.
//
// This assumes that @log_level is already present in @fields (typically as the
// `PRIORITY` field).
func LogStructuredArray(logLevel LogLevelFlags, fields []LogField) {
	var arg1 C.GLogLevelFlags
	var arg2 *C.GLogField
	var arg3 C.gsize

	arg1 = (C.GLogLevelFlags)(logLevel)
	{
		var dst []C.GLogField
		ptr := C.malloc(C.sizeof_GLogField * len(fields))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(fields)
		sliceHeader.Cap = len(fields)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(fields); i++ {
			src := fields[i]
			dst[i] = (C.GLogField)(src.Native())
		}

		arg2 = (*C.GLogField)(unsafe.Pointer(ptr))
		arg3 = len(fields)
	}

	C.g_log_structured_array(arg1, arg2, arg3)
}

// LogVariant: log a message with structured data, accepting the data within a
// #GVariant. This version is especially useful for use in other languages, via
// introspection.
//
// The only mandatory item in the @fields dictionary is the "MESSAGE" which must
// contain the text shown to the user.
//
// The values in the @fields dictionary are likely to be of type String
// (VARIANT_TYPE_STRING). Array of bytes (VARIANT_TYPE_BYTESTRING) is also
// supported. In this case the message is handled as binary and will be
// forwarded to the log writer as such. The size of the array should not be
// higher than G_MAXSSIZE. Otherwise it will be truncated to this size. For
// other types g_variant_print() will be used to convert the value into a
// string.
//
// For more details on its usage and about the parameters, see
// g_log_structured().
func LogVariant(logDomain string, logLevel LogLevelFlags, fields *Variant) {
	var arg1 *C.gchar
	var arg2 C.GLogLevelFlags
	var arg3 *C.GVariant

	arg1 = (*C.gchar)(C.CString(logDomain))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GLogLevelFlags)(logLevel)
	arg3 = (*C.GVariant)(fields.Native())

	C.g_log_variant(arg1, arg2, arg3)
}

// LogWriterDefault: format a structured log message and output it to the
// default log destination for the platform. On Linux, this is typically the
// systemd journal, falling back to `stdout` or `stderr` if running from the
// terminal or if output is being redirected to a file.
//
// Support for other platform-specific logging mechanisms may be added in
// future. Distributors of GLib may modify this function to impose their own
// (documented) platform-specific log writing policies.
//
// This is suitable for use as a WriterFunc, and is the default writer used if
// no other is set using g_log_set_writer_func().
//
// As with g_log_default_handler(), this function drops debug and informational
// messages unless their log domain (or `all`) is listed in the space-separated
// `G_MESSAGES_DEBUG` environment variable.
func LogWriterDefault(logLevel LogLevelFlags, fields []LogField, userData interface{}) LogWriterOutput {
	var arg1 C.GLogLevelFlags
	var arg2 *C.GLogField
	var arg3 C.gsize
	var arg4 C.gpointer

	arg1 = (C.GLogLevelFlags)(logLevel)
	{
		var dst []C.GLogField
		ptr := C.malloc(C.sizeof_GLogField * len(fields))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(fields)
		sliceHeader.Cap = len(fields)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(fields); i++ {
			src := fields[i]
			dst[i] = (C.GLogField)(src.Native())
		}

		arg2 = (*C.GLogField)(unsafe.Pointer(ptr))
		arg3 = len(fields)
	}
	arg4 = C.gpointer(box.Assign(userData))

	ret := C.g_log_writer_default(arg1, arg2, arg3, arg4)

	var ret0 LogWriterOutput

	ret0 = LogWriterOutput(ret)

	return ret0
}

// LogWriterFormatFields: format a structured log message as a string suitable
// for outputting to the terminal (or elsewhere). This will include the values
// of all fields it knows how to interpret, which includes `MESSAGE` and
// `GLIB_DOMAIN` (see the documentation for g_log_structured()). It does not
// include values from unknown fields.
//
// The returned string does **not** have a trailing new-line character. It is
// encoded in the character set of the current locale, which is not necessarily
// UTF-8.
func LogWriterFormatFields(logLevel LogLevelFlags, fields []LogField, useColor bool) string {
	var arg1 C.GLogLevelFlags
	var arg2 *C.GLogField
	var arg3 C.gsize
	var arg4 C.gboolean

	arg1 = (C.GLogLevelFlags)(logLevel)
	{
		var dst []C.GLogField
		ptr := C.malloc(C.sizeof_GLogField * len(fields))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(fields)
		sliceHeader.Cap = len(fields)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(fields); i++ {
			src := fields[i]
			dst[i] = (C.GLogField)(src.Native())
		}

		arg2 = (*C.GLogField)(unsafe.Pointer(ptr))
		arg3 = len(fields)
	}
	if useColor {
		arg4 = C.TRUE
	}

	ret := C.g_log_writer_format_fields(arg1, arg2, arg3, arg4)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// LogWriterIsJournald: check whether the given @output_fd file descriptor is a
// connection to the systemd journal, or something else (like a log file or
// `stdout` or `stderr`).
//
// Invalid file descriptors are accepted and return false, which allows for the
// following construct without needing any additional error handling:
//
//    is_journald = g_log_writer_is_journald (fileno (stderr));
func LogWriterIsJournald(outputFd int) bool {
	var arg1 C.gint

	arg1 = C.gint(outputFd)

	ret := C.g_log_writer_is_journald(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// LogWriterJournald: format a structured log message and send it to the systemd
// journal as a set of key–value pairs. All fields are sent to the journal, but
// if a field has length zero (indicating program-specific data) then only its
// key will be sent.
//
// This is suitable for use as a WriterFunc.
//
// If GLib has been compiled without systemd support, this function is still
// defined, but will always return G_LOG_WRITER_UNHANDLED.
func LogWriterJournald(logLevel LogLevelFlags, fields []LogField, userData interface{}) LogWriterOutput {
	var arg1 C.GLogLevelFlags
	var arg2 *C.GLogField
	var arg3 C.gsize
	var arg4 C.gpointer

	arg1 = (C.GLogLevelFlags)(logLevel)
	{
		var dst []C.GLogField
		ptr := C.malloc(C.sizeof_GLogField * len(fields))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(fields)
		sliceHeader.Cap = len(fields)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(fields); i++ {
			src := fields[i]
			dst[i] = (C.GLogField)(src.Native())
		}

		arg2 = (*C.GLogField)(unsafe.Pointer(ptr))
		arg3 = len(fields)
	}
	arg4 = C.gpointer(box.Assign(userData))

	ret := C.g_log_writer_journald(arg1, arg2, arg3, arg4)

	var ret0 LogWriterOutput

	ret0 = LogWriterOutput(ret)

	return ret0
}

// LogWriterStandardStreams: format a structured log message and print it to
// either `stdout` or `stderr`, depending on its log level. G_LOG_LEVEL_INFO and
// G_LOG_LEVEL_DEBUG messages are sent to `stdout`; all other log levels are
// sent to `stderr`. Only fields which are understood by this function are
// included in the formatted string which is printed.
//
// If the output stream supports ANSI color escape sequences, they will be used
// in the output.
//
// A trailing new-line character is added to the log message when it is printed.
//
// This is suitable for use as a WriterFunc.
func LogWriterStandardStreams(logLevel LogLevelFlags, fields []LogField, userData interface{}) LogWriterOutput {
	var arg1 C.GLogLevelFlags
	var arg2 *C.GLogField
	var arg3 C.gsize
	var arg4 C.gpointer

	arg1 = (C.GLogLevelFlags)(logLevel)
	{
		var dst []C.GLogField
		ptr := C.malloc(C.sizeof_GLogField * len(fields))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(fields)
		sliceHeader.Cap = len(fields)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(fields); i++ {
			src := fields[i]
			dst[i] = (C.GLogField)(src.Native())
		}

		arg2 = (*C.GLogField)(unsafe.Pointer(ptr))
		arg3 = len(fields)
	}
	arg4 = C.gpointer(box.Assign(userData))

	ret := C.g_log_writer_standard_streams(arg1, arg2, arg3, arg4)

	var ret0 LogWriterOutput

	ret0 = LogWriterOutput(ret)

	return ret0
}

// LogWriterSupportsColor: check whether the given @output_fd file descriptor
// supports ANSI color escape sequences. If so, they can safely be used when
// formatting log messages.
func LogWriterSupportsColor(outputFd int) bool {
	var arg1 C.gint

	arg1 = C.gint(outputFd)

	ret := C.g_log_writer_supports_color(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// MainContextDefault returns the global default main context. This is the main
// context used for main loop functions when a main loop is not explicitly
// specified, and corresponds to the "main" main loop. See also
// g_main_context_get_thread_default().
func MainContextDefault() *MainContext {

	ret := C.g_main_context_default()

	var ret0 *MainContext

	{
		ret0 = WrapMainContext(unsafe.Pointer(ret))
	}

	return ret0
}

// MainContextGetThreadDefault gets the thread-default Context for this thread.
// Asynchronous operations that want to be able to be run in contexts other than
// the default one should call this method or
// g_main_context_ref_thread_default() to get a Context to add their #GSources
// to. (Note that even in single-threaded programs applications may sometimes
// want to temporarily push a non-default context, so it is not safe to assume
// that this will always return nil if you are running in the default thread.)
//
// If you need to hold a reference on the context, use
// g_main_context_ref_thread_default() instead.
func MainContextGetThreadDefault() *MainContext {

	ret := C.g_main_context_get_thread_default()

	var ret0 *MainContext

	{
		ret0 = WrapMainContext(unsafe.Pointer(ret))
	}

	return ret0
}

// MainContextRefThreadDefault gets the thread-default Context for this thread,
// as with g_main_context_get_thread_default(), but also adds a reference to it
// with g_main_context_ref(). In addition, unlike
// g_main_context_get_thread_default(), if the thread-default context is the
// global default context, this will return that Context (with a ref added to
// it) rather than returning nil.
func MainContextRefThreadDefault() *MainContext {

	ret := C.g_main_context_ref_thread_default()

	var ret0 *MainContext

	{
		ret0 = WrapMainContext(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *MainContext) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// MainCurrentSource returns the currently firing source for this thread.
func MainCurrentSource() *Source {

	ret := C.g_main_current_source()

	var ret0 *Source

	{
		ret0 = WrapSource(unsafe.Pointer(ret))
	}

	return ret0
}

// MainDepth returns the depth of the stack of calls to
// g_main_context_dispatch() on any Context in the current thread. That is, when
// called from the toplevel, it gives 0. When called from within a callback from
// g_main_context_iteration() (or g_main_loop_run(), etc.) it returns 1. When
// called from within a callback to a recursive call to
// g_main_context_iteration(), it returns 2. And so forth.
//
// This function is useful in a situation like the following: Imagine an
// extremely simple "garbage collected" system.
//
//    gpointer
//    allocate_memory (gsize size)
//    {
//      FreeListBlock *block = g_new (FreeListBlock, 1);
//      block->mem = g_malloc (size);
//      block->depth = g_main_depth ();
//      free_list = g_list_prepend (free_list, block);
//      return block->mem;
//    }
//
//    void
//    free_allocated_memory (void)
//    {
//      GList *l;
//
//      int depth = g_main_depth ();
//      for (l = free_list; l; );
//        {
//          GList *next = l->next;
//          FreeListBlock *block = l->data;
//          if (block->depth > depth)
//            {
//              g_free (block->mem);
//              g_free (block);
//              free_list = g_list_delete_link (free_list, l);
//            }
//
//          l = next;
//        }
//      }
//
// There is a temptation to use g_main_depth() to solve problems with
// reentrancy. For instance, while waiting for data to be received from the
// network in response to a menu item, the menu item might be selected again. It
// might seem that one could make the menu item's callback return immediately
// and do nothing if g_main_depth() returns a value greater than 1. However,
// this should be avoided since the user then sees selecting the menu item do
// nothing. Furthermore, you'll find yourself adding these checks all over your
// code, since there are doubtless many, many things that the user could do.
// Instead, you can use the following techniques:
//
// 1. Use gtk_widget_set_sensitive() or modal dialogs to prevent the user from
// interacting with elements while the main loop is recursing.
//
// 2. Avoid main loop recursion in situations where you can't handle arbitrary
// callbacks. Instead, structure your code so that you simply return to the main
// loop and then get called again when there is more work to do.
func MainDepth() int {

	ret := C.g_main_depth()

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Malloc allocates @n_bytes bytes of memory. If @n_bytes is 0 it returns nil.
func Malloc(nBytes uint) interface{} {
	var arg1 C.gsize

	arg1 = C.gsize(nBytes)

	ret := C.g_malloc(arg1)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// Malloc0 allocates @n_bytes bytes of memory, initialized to 0's. If @n_bytes
// is 0 it returns nil.
func Malloc0(nBytes uint) interface{} {
	var arg1 C.gsize

	arg1 = C.gsize(nBytes)

	ret := C.g_malloc0(arg1)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// Malloc0N: this function is similar to g_malloc0(), allocating (@n_blocks *
// @n_block_bytes) bytes, but care is taken to detect possible overflow during
// multiplication.
func Malloc0N(nBlocks uint, nBlockBytes uint) interface{} {
	var arg1 C.gsize
	var arg2 C.gsize

	arg1 = C.gsize(nBlocks)
	arg2 = C.gsize(nBlockBytes)

	ret := C.g_malloc0_n(arg1, arg2)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// MallocN: this function is similar to g_malloc(), allocating (@n_blocks *
// @n_block_bytes) bytes, but care is taken to detect possible overflow during
// multiplication.
func MallocN(nBlocks uint, nBlockBytes uint) interface{} {
	var arg1 C.gsize
	var arg2 C.gsize

	arg1 = C.gsize(nBlocks)
	arg2 = C.gsize(nBlockBytes)

	ret := C.g_malloc_n(arg1, arg2)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

func MarkupErrorQuark() Quark {

	ret := C.g_markup_error_quark()

	var ret0 Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = Quark(tmp)
	}

	return ret0
}

// MarkupEscapeText escapes text so that the markup parser will parse it
// verbatim. Less than, greater than, ampersand, etc. are replaced with the
// corresponding entities. This function would typically be used when writing
// out a file to be parsed with the markup parser.
//
// Note that this function doesn't protect whitespace and line endings from
// being processed according to the XML rules for normalization of line endings
// and attribute values.
//
// Note also that this function will produce character references in the range
// of &#x1; ... &#x1f; for all control sequences except for tabstop, newline and
// carriage return. The character references in this range are not valid XML
// 1.0, but they are valid XML 1.1 and will be accepted by the GMarkup parser.
func MarkupEscapeText(text string, length int) string {
	var arg1 *C.gchar
	var arg2 C.gssize

	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(length)

	ret := C.g_markup_escape_text(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// MemIsSystemMalloc checks whether the allocator used by g_malloc() is the
// system's malloc implementation. If it returns true memory allocated with
// malloc() can be used interchangeably with memory allocated using g_malloc().
// This function is useful for avoiding an extra copy of allocated memory
// returned by a non-GLib-based API.
func MemIsSystemMalloc() bool {

	ret := C.g_mem_is_system_malloc()

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// MemProfile: GLib used to support some tools for memory profiling, but this no
// longer works. There are many other useful tools for memory profiling these
// days which can be used instead.
func MemProfile() {

	C.g_mem_profile()
}

// Memdup allocates @byte_size bytes of memory, and copies @byte_size bytes into
// it from @mem. If @mem is nil it returns nil.
func Memdup(mem interface{}, byteSize uint) interface{} {
	var arg1 C.gpointer
	var arg2 C.guint

	arg1 = C.gpointer(box.Assign(mem))
	arg2 = C.guint(byteSize)

	ret := C.g_memdup(arg1, arg2)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// MkdirWithParents: create a directory if it doesn't already exist. Create
// intermediate parent directories as needed, too.
func MkdirWithParents(pathname string, mode int) int {
	var arg1 *C.gchar
	var arg2 C.gint

	arg1 = (*C.gchar)(C.CString(pathname))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(mode)

	ret := C.g_mkdir_with_parents(arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Mkdtemp creates a temporary directory. See the mkdtemp() documentation on
// most UNIX-like systems.
//
// The parameter is a string that should follow the rules for mkdtemp()
// templates, i.e. contain the string "XXXXXX". g_mkdtemp() is slightly more
// flexible than mkdtemp() in that the sequence does not have to occur at the
// very end of the template. The X string will be modified to form the name of a
// directory that didn't exist. The string should be in the GLib file name
// encoding. Most importantly, on Windows it should be in UTF-8.
//
// If you are going to be creating a temporary directory inside the directory
// returned by g_get_tmp_dir(), you might want to use g_dir_make_tmp() instead.
func Mkdtemp(tmpl string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(tmpl))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_mkdtemp(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// MkdtempFull creates a temporary directory. See the mkdtemp() documentation on
// most UNIX-like systems.
//
// The parameter is a string that should follow the rules for mkdtemp()
// templates, i.e. contain the string "XXXXXX". g_mkdtemp_full() is slightly
// more flexible than mkdtemp() in that the sequence does not have to occur at
// the very end of the template and you can pass a @mode. The X string will be
// modified to form the name of a directory that didn't exist. The string should
// be in the GLib file name encoding. Most importantly, on Windows it should be
// in UTF-8.
//
// If you are going to be creating a temporary directory inside the directory
// returned by g_get_tmp_dir(), you might want to use g_dir_make_tmp() instead.
func MkdtempFull(tmpl string, mode int) string {
	var arg1 *C.gchar
	var arg2 C.gint

	arg1 = (*C.gchar)(C.CString(tmpl))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(mode)

	ret := C.g_mkdtemp_full(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Mkstemp opens a temporary file. See the mkstemp() documentation on most
// UNIX-like systems.
//
// The parameter is a string that should follow the rules for mkstemp()
// templates, i.e. contain the string "XXXXXX". g_mkstemp() is slightly more
// flexible than mkstemp() in that the sequence does not have to occur at the
// very end of the template. The X string will be modified to form the name of a
// file that didn't exist. The string should be in the GLib file name encoding.
// Most importantly, on Windows it should be in UTF-8.
func Mkstemp(tmpl string) int {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(tmpl))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_mkstemp(arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// MkstempFull opens a temporary file. See the mkstemp() documentation on most
// UNIX-like systems.
//
// The parameter is a string that should follow the rules for mkstemp()
// templates, i.e. contain the string "XXXXXX". g_mkstemp_full() is slightly
// more flexible than mkstemp() in that the sequence does not have to occur at
// the very end of the template and you can pass a @mode and additional @flags.
// The X string will be modified to form the name of a file that didn't exist.
// The string should be in the GLib file name encoding. Most importantly, on
// Windows it should be in UTF-8.
func MkstempFull(tmpl string, flags int, mode int) int {
	var arg1 *C.gchar
	var arg2 C.gint
	var arg3 C.gint

	arg1 = (*C.gchar)(C.CString(tmpl))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(flags)
	arg3 = C.gint(mode)

	ret := C.g_mkstemp_full(arg1, arg2, arg3)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// NullifyPointer: set the pointer at the specified location to nil.
func NullifyPointer(nullifyLocation interface{}) {
	var arg1 *C.gpointer

	arg1 = C.gpointer(box.Assign(nullifyLocation))

	C.g_nullify_pointer(arg1)
}

func NumberParserErrorQuark() Quark {

	ret := C.g_number_parser_error_quark()

	var ret0 Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = Quark(tmp)
	}

	return ret0
}

// OnErrorQuery prompts the user with `[E]xit, [H]alt, show [S]tack trace or
// [P]roceed`. This function is intended to be used for debugging use only. The
// following example shows how it can be used together with the g_log()
// functions.
//
//    #include <glib.h>
//
//    static void
//    log_handler (const gchar   *log_domain,
//                 GLogLevelFlags log_level,
//                 const gchar   *message,
//                 gpointer       user_data)
//    {
//      g_log_default_handler (log_domain, log_level, message, user_data);
//
//      g_on_error_query (MY_PROGRAM_NAME);
//    }
//
//    int
//    main (int argc, char *argv[])
//    {
//      g_log_set_handler (MY_LOG_DOMAIN,
//                         G_LOG_LEVEL_WARNING |
//                         G_LOG_LEVEL_ERROR |
//                         G_LOG_LEVEL_CRITICAL,
//                         log_handler,
//                         NULL);
//      ...
//
// If "[E]xit" is selected, the application terminates with a call to _exit(0).
//
// If "[S]tack" trace is selected, g_on_error_stack_trace() is called. This
// invokes gdb, which attaches to the current process and shows a stack trace.
// The prompt is then shown again.
//
// If "[P]roceed" is selected, the function returns.
//
// This function may cause different actions on non-UNIX platforms.
//
// On Windows consider using the `G_DEBUGGER` environment variable (see Running
// GLib Applications (glib-running.html)) and calling g_on_error_stack_trace()
// instead.
func OnErrorQuery(prgName string) {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(prgName))
	defer C.free(unsafe.Pointer(arg1))

	C.g_on_error_query(arg1)
}

// OnErrorStackTrace invokes gdb, which attaches to the current process and
// shows a stack trace. Called by g_on_error_query() when the "[S]tack trace"
// option is selected. You can get the current process's program name with
// g_get_prgname(), assuming that you have called gtk_init() or gdk_init().
//
// This function may cause different actions on non-UNIX platforms.
//
// When running on Windows, this function is *not* called by g_on_error_query().
// If called directly, it will raise an exception, which will crash the program.
// If the `G_DEBUGGER` environment variable is set, a debugger will be invoked
// to attach and handle that exception (see Running GLib Applications
// (glib-running.html)).
func OnErrorStackTrace(prgName string) {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(prgName))
	defer C.free(unsafe.Pointer(arg1))

	C.g_on_error_stack_trace(arg1)
}

// OnceInitEnter: function to be called when starting a critical initialization
// section. The argument @location must point to a static 0-initialized variable
// that will be set to a value other than 0 at the end of the initialization
// section. In combination with g_once_init_leave() and the unique address
// @value_location, it can be ensured that an initialization section will be
// executed only once during a program's life time, and that concurrent threads
// are blocked until initialization completed. To be used in constructs like
// this:
//
//      static gsize initialization_value = 0;
//
//      if (g_once_init_enter (&initialization_value))
//        {
//          gsize setup_value = 42; // initialization code here
//
//          g_once_init_leave (&initialization_value, setup_value);
//        }
//
//      // use initialization_value here
func OnceInitEnter(location interface{}) bool {
	var arg1 *C.void

	arg1 = C.gpointer(box.Assign(location))

	ret := C.g_once_init_enter(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// OnceInitLeave: counterpart to g_once_init_enter(). Expects a location of a
// static 0-initialized initialization variable, and an initialization value
// other than 0. Sets the variable to the initialization value, and releases
// concurrent threads blocking in g_once_init_enter() on this initialization
// variable.
func OnceInitLeave(location interface{}, result uint) {
	var arg1 *C.void
	var arg2 C.gsize

	arg1 = C.gpointer(box.Assign(location))
	arg2 = C.gsize(result)

	C.g_once_init_leave(arg1, arg2)
}

func OptionErrorQuark() Quark {

	ret := C.g_option_error_quark()

	var ret0 Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = Quark(tmp)
	}

	return ret0
}

// ParseDebugString parses a string containing debugging options into a guint
// containing bit flags. This is used within GDK and GTK+ to parse the debug
// options passed on the command line or through environment variables.
//
// If @string is equal to "all", all flags are set. Any flags specified along
// with "all" in @string are inverted; thus, "all,foo,bar" or "foo,bar,all" sets
// all flags except those corresponding to "foo" and "bar".
//
// If @string is equal to "help", all the available keys in @keys are printed
// out to standard error.
func ParseDebugString(string string, keys []DebugKey) uint {
	var arg1 *C.gchar
	var arg2 *C.GDebugKey
	var arg3 C.guint

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))
	{
		var dst []C.GDebugKey
		ptr := C.malloc(C.sizeof_GDebugKey * len(keys))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(keys)
		sliceHeader.Cap = len(keys)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(keys); i++ {
			src := keys[i]
			dst[i] = (C.GDebugKey)(src.Native())
		}

		arg2 = (*C.GDebugKey)(unsafe.Pointer(ptr))
		arg3 = len(keys)
	}

	ret := C.g_parse_debug_string(arg1, arg2, arg3)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// PathGetBasename gets the last component of the filename.
//
// If @file_name ends with a directory separator it gets the component before
// the last slash. If @file_name consists only of directory separators (and on
// Windows, possibly a drive letter), a single separator is returned. If
// @file_name is empty, it gets ".".
func PathGetBasename(fileName string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_path_get_basename(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// PathGetDirname gets the directory components of a file name. For example, the
// directory component of `/usr/bin/test` is `/usr/bin`. The directory component
// of `/` is `/`.
//
// If the file name has no directory components "." is returned. The returned
// string should be freed when no longer needed.
func PathGetDirname(fileName string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_path_get_dirname(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// PathIsAbsolute returns true if the given @file_name is an absolute file name.
// Note that this is a somewhat vague concept on Windows.
//
// On POSIX systems, an absolute file name is well-defined. It always starts
// from the single root directory. For example "/usr/local".
//
// On Windows, the concepts of current drive and drive-specific current
// directory introduce vagueness. This function interprets as an absolute file
// name one that either begins with a directory separator such as "\Users\tml"
// or begins with the root on a drive, for example "C:\Windows". The first case
// also includes UNC paths such as "\\\\myserver\docs\foo". In all cases, either
// slashes or backslashes are accepted.
//
// Note that a file name relative to the current drive root does not truly
// specify a file uniquely over time and across processes, as the current drive
// is a per-process value and can be changed.
//
// File names relative the current directory on some specific drive, such as
// "D:foo/bar", are not interpreted as absolute by this function, but they
// obviously are not relative to the normal current directory as returned by
// getcwd() or g_get_current_dir() either. Such paths should be avoided, or need
// to be handled using Windows-specific code.
func PathIsAbsolute(fileName string) bool {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_path_is_absolute(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// PathSkipRoot returns a pointer into @file_name after the root component, i.e.
// after the "/" in UNIX or "C:\" under Windows. If @file_name is not an
// absolute path it returns nil.
func PathSkipRoot(fileName string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_path_skip_root(arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// PatternMatch matches a string against a compiled pattern. Passing the correct
// length of the string given is mandatory. The reversed string can be omitted
// by passing nil, this is more efficient if the reversed version of the string
// to be matched is not at hand, as g_pattern_match() will only construct it if
// the compiled pattern requires reverse matches.
//
// Note that, if the user code will (possibly) match a string against a
// multitude of patterns containing wildcards, chances are high that some
// patterns will require a reversed string. In this case, it's more efficient to
// provide the reversed string to avoid multiple constructions thereof in the
// various calls to g_pattern_match().
//
// Note also that the reverse of a UTF-8 encoded string can in general not be
// obtained by g_strreverse(). This works only if the string does not contain
// any multibyte characters. GLib offers the g_utf8_strreverse() function to
// reverse UTF-8 encoded strings.
func PatternMatch(pspec *PatternSpec, stringLength uint, string string, stringReversed string) bool {
	var arg1 *C.GPatternSpec
	var arg2 C.guint
	var arg3 *C.gchar
	var arg4 *C.gchar

	arg1 = (*C.GPatternSpec)(pspec.Native())
	arg2 = C.guint(stringLength)
	arg3 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gchar)(C.CString(stringReversed))
	defer C.free(unsafe.Pointer(arg4))

	ret := C.g_pattern_match(arg1, arg2, arg3, arg4)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// PatternMatchSimple matches a string against a pattern given as a string. If
// this function is to be called in a loop, it's more efficient to compile the
// pattern once with g_pattern_spec_new() and call g_pattern_match_string()
// repeatedly.
func PatternMatchSimple(pattern string, string string) bool {
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg1 = (*C.gchar)(C.CString(pattern))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_pattern_match_simple(arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// PatternMatchString matches a string against a compiled pattern. If the string
// is to be matched against more than one pattern, consider using
// g_pattern_match() instead while supplying the reversed string.
func PatternMatchString(pspec *PatternSpec, string string) bool {
	var arg1 *C.GPatternSpec
	var arg2 *C.gchar

	arg1 = (*C.GPatternSpec)(pspec.Native())
	arg2 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_pattern_match_string(arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// PointerBitLock: this is equivalent to g_bit_lock, but working on pointers (or
// other pointer-sized values).
//
// For portability reasons, you may only lock on the bottom 32 bits of the
// pointer.
func PointerBitLock(address interface{}, lockBit int) {
	var arg1 *C.void
	var arg2 C.gint

	arg1 = C.gpointer(box.Assign(address))
	arg2 = C.gint(lockBit)

	C.g_pointer_bit_lock(arg1, arg2)
}

// PointerBitTrylock: this is equivalent to g_bit_trylock, but working on
// pointers (or other pointer-sized values).
//
// For portability reasons, you may only lock on the bottom 32 bits of the
// pointer.
func PointerBitTrylock(address interface{}, lockBit int) bool {
	var arg1 *C.void
	var arg2 C.gint

	arg1 = C.gpointer(box.Assign(address))
	arg2 = C.gint(lockBit)

	ret := C.g_pointer_bit_trylock(arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// PointerBitUnlock: this is equivalent to g_bit_unlock, but working on pointers
// (or other pointer-sized values).
//
// For portability reasons, you may only lock on the bottom 32 bits of the
// pointer.
func PointerBitUnlock(address interface{}, lockBit int) {
	var arg1 *C.void
	var arg2 C.gint

	arg1 = C.gpointer(box.Assign(address))
	arg2 = C.gint(lockBit)

	C.g_pointer_bit_unlock(arg1, arg2)
}

// Poll polls @fds, as with the poll() system call, but portably. (On systems
// that don't have poll(), it is emulated using select().) This is used
// internally by Context, but it can be called directly if you need to block
// until a file descriptor is ready, but don't want to run the full main loop.
//
// Each element of @fds is a FD describing a single file descriptor to poll. The
// @fd field indicates the file descriptor, and the @events field indicates the
// events to poll for. On return, the @revents fields will be filled with the
// events that actually occurred.
//
// On POSIX systems, the file descriptors in @fds can be any sort of file
// descriptor, but the situation is much more complicated on Windows. If you
// need to use g_poll() in code that has to run on Windows, the easiest solution
// is to construct all of your FDs with g_io_channel_win32_make_pollfd().
func Poll(fds *PollFD, nfds uint, timeout int) int {
	var arg1 *C.GPollFD
	var arg2 C.guint
	var arg3 C.gint

	arg1 = (*C.GPollFD)(fds.Native())
	arg2 = C.guint(nfds)
	arg3 = C.gint(timeout)

	ret := C.g_poll(arg1, arg2, arg3)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// PropagateError: if @dest is nil, free @src; otherwise, moves @src into
// *@dest. The error variable @dest points to must be nil.
//
// @src must be non-nil.
//
// Note that @src is no longer valid after this call. If you want to keep using
// the same GError*, you need to set it to nil after calling this function on
// it.
func PropagateError(src *Error) *Error {
	var arg1 **C.GError // out
	var arg2 *C.GError

	arg2 = (*C.GError)(src.Native())

	C.g_propagate_error(&arg1, arg2)

	var ret0 **Error

	{
		ret0 = WrapError(unsafe.Pointer(arg1))
		runtime.SetFinalizer(ret0, func(v **Error) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// PtrArrayFind checks whether @needle exists in @haystack. If the element is
// found, true is returned and the element’s index is returned in @index_ (if
// non-nil). Otherwise, false is returned and @index_ is undefined. If @needle
// exists multiple times in @haystack, the index of the first instance is
// returned.
//
// This does pointer comparisons only. If you want to use more complex equality
// checks, such as string comparisons, use g_ptr_array_find_with_equal_func().
func PtrArrayFind(haystack []interface{}, needle interface{}) (index_ uint, ok bool) {
	var arg1 *C.GPtrArray
	var arg2 C.gpointer
	var arg3 *C.guint // out

	{
		var dst []C.gpointer
		ptr := C.malloc(C.sizeof_gpointer * (len(haystack) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(haystack)
		sliceHeader.Cap = len(haystack)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(haystack); i++ {
			src := haystack[i]
			dst[i] = C.gpointer(box.Assign(src))
		}

		arg1 = (*C.GPtrArray)(unsafe.Pointer(ptr))
	}
	arg2 = C.gpointer(box.Assign(needle))

	ret := C.g_ptr_array_find(arg1, arg2, &arg3)

	var ret0 uint
	var ret1 bool

	ret0 = uint(arg3)

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// PtrArrayFindWithEqualFunc checks whether @needle exists in @haystack, using
// the given @equal_func. If the element is found, true is returned and the
// element’s index is returned in @index_ (if non-nil). Otherwise, false is
// returned and @index_ is undefined. If @needle exists multiple times in
// @haystack, the index of the first instance is returned.
//
// @equal_func is called with the element from the array as its first parameter,
// and @needle as its second parameter. If @equal_func is nil, pointer equality
// is used.
func PtrArrayFindWithEqualFunc(haystack []interface{}, needle interface{}, equalFunc EqualFunc) (index_ uint, ok bool) {
	var arg1 *C.GPtrArray
	var arg2 C.gpointer
	var arg3 C.GEqualFunc
	var arg4 *C.guint // out

	{
		var dst []C.gpointer
		ptr := C.malloc(C.sizeof_gpointer * (len(haystack) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(haystack)
		sliceHeader.Cap = len(haystack)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(haystack); i++ {
			src := haystack[i]
			dst[i] = C.gpointer(box.Assign(src))
		}

		arg1 = (*C.GPtrArray)(unsafe.Pointer(ptr))
	}
	arg2 = C.gpointer(box.Assign(needle))

	ret := C.g_ptr_array_find_with_equal_func(arg1, arg2, arg3, &arg4)

	var ret0 uint
	var ret1 bool

	ret0 = uint(arg4)

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// QsortWithData: this is just like the standard C qsort() function, but the
// comparison routine accepts a user data argument.
//
// This is guaranteed to be a stable sort since version 2.32.
func QsortWithData(pbase interface{}, totalElems int, size uint, compareFunc CompareDataFunc) {
	var arg1 C.gpointer
	var arg2 C.gint
	var arg3 C.gsize
	var arg4 C.GCompareDataFunc
	var arg5 C.gpointer

	arg1 = C.gpointer(box.Assign(pbase))
	arg2 = C.gint(totalElems)
	arg3 = C.gsize(size)
	arg4 = (*[0]byte)(C.gotk4_CompareDataFunc)
	arg5 = C.gpointer(box.Assign(compareFunc))

	C.g_qsort_with_data(arg1, arg2, arg3, arg4, arg5)
}

// QuarkFromStaticString gets the #GQuark identifying the given (static) string.
// If the string does not currently have an associated #GQuark, a new #GQuark is
// created, linked to the given string.
//
// Note that this function is identical to g_quark_from_string() except that if
// a new #GQuark is created the string itself is used rather than a copy. This
// saves memory, but can only be used if the string will continue to exist until
// the program terminates. It can be used with statically allocated strings in
// the main program, but not with statically allocated memory in dynamically
// loaded modules, if you expect to ever unload the module again (e.g. do not
// use this function in GTK+ theme engines).
//
// This function must not be used before library constructors have finished
// running. In particular, this means it cannot be used to initialize global
// variables in C++.
func QuarkFromStaticString(string string) Quark {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_quark_from_static_string(arg1)

	var ret0 Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = Quark(tmp)
	}

	return ret0
}

// QuarkFromString gets the #GQuark identifying the given string. If the string
// does not currently have an associated #GQuark, a new #GQuark is created,
// using a copy of the string.
//
// This function must not be used before library constructors have finished
// running. In particular, this means it cannot be used to initialize global
// variables in C++.
func QuarkFromString(string string) Quark {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_quark_from_string(arg1)

	var ret0 Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = Quark(tmp)
	}

	return ret0
}

// QuarkTryString gets the #GQuark associated with the given string, or 0 if
// string is nil or it has no associated #GQuark.
//
// If you want the GQuark to be created if it doesn't already exist, use
// g_quark_from_string() or g_quark_from_static_string().
//
// This function must not be used before library constructors have finished
// running.
func QuarkTryString(string string) Quark {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_quark_try_string(arg1)

	var ret0 Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = Quark(tmp)
	}

	return ret0
}

// RandomDouble returns a random #gdouble equally distributed over the range
// [0..1).
func RandomDouble() float64 {

	ret := C.g_random_double()

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// RandomDoubleRange returns a random #gdouble equally distributed over the
// range [@begin..@end).
func RandomDoubleRange(begin float64, end float64) float64 {
	var arg1 C.gdouble
	var arg2 C.gdouble

	arg1 = C.gdouble(begin)
	arg2 = C.gdouble(end)

	ret := C.g_random_double_range(arg1, arg2)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// RandomInt: return a random #guint32 equally distributed over the range
// [0..2^32-1].
func RandomInt() uint32 {

	ret := C.g_random_int()

	var ret0 uint32

	ret0 = uint32(ret)

	return ret0
}

// RandomIntRange returns a random #gint32 equally distributed over the range
// [@begin..@end-1].
func RandomIntRange(begin int32, end int32) int32 {
	var arg1 C.gint32
	var arg2 C.gint32

	arg1 = C.gint32(begin)
	arg2 = C.gint32(end)

	ret := C.g_random_int_range(arg1, arg2)

	var ret0 int32

	ret0 = int32(ret)

	return ret0
}

// RandomSetSeed sets the seed for the global random number generator, which is
// used by the g_random_* functions, to @seed.
func RandomSetSeed(seed uint32) {
	var arg1 C.guint32

	arg1 = C.guint32(seed)

	C.g_random_set_seed(arg1)
}

// RCBoxAcquire acquires a reference on the data pointed by @mem_block.
func RCBoxAcquire(memBlock interface{}) interface{} {
	var arg1 C.gpointer

	arg1 = C.gpointer(box.Assign(memBlock))

	ret := C.g_rc_box_acquire(arg1)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// RCBoxAlloc allocates @block_size bytes of memory, and adds reference counting
// semantics to it.
//
// The data will be freed when its reference count drops to zero.
//
// The allocated data is guaranteed to be suitably aligned for any built-in
// type.
func RCBoxAlloc(blockSize uint) interface{} {
	var arg1 C.gsize

	arg1 = C.gsize(blockSize)

	ret := C.g_rc_box_alloc(arg1)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// RCBoxAlloc0 allocates @block_size bytes of memory, and adds reference
// counting semantics to it.
//
// The contents of the returned data is set to zero.
//
// The data will be freed when its reference count drops to zero.
//
// The allocated data is guaranteed to be suitably aligned for any built-in
// type.
func RCBoxAlloc0(blockSize uint) interface{} {
	var arg1 C.gsize

	arg1 = C.gsize(blockSize)

	ret := C.g_rc_box_alloc0(arg1)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// RCBoxDup allocates a new block of data with reference counting semantics, and
// copies @block_size bytes of @mem_block into it.
func RCBoxDup(blockSize uint, memBlock interface{}) interface{} {
	var arg1 C.gsize
	var arg2 C.gpointer

	arg1 = C.gsize(blockSize)
	arg2 = C.gpointer(box.Assign(memBlock))

	ret := C.g_rc_box_dup(arg1, arg2)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// RCBoxGetSize retrieves the size of the reference counted data pointed by
// @mem_block.
func RCBoxGetSize(memBlock interface{}) uint {
	var arg1 C.gpointer

	arg1 = C.gpointer(box.Assign(memBlock))

	ret := C.g_rc_box_get_size(arg1)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// RCBoxRelease releases a reference on the data pointed by @mem_block.
//
// If the reference was the last one, it will free the resources allocated for
// @mem_block.
func RCBoxRelease(memBlock interface{}) {
	var arg1 C.gpointer

	arg1 = C.gpointer(box.Assign(memBlock))

	C.g_rc_box_release(arg1)
}

// Realloc reallocates the memory pointed to by @mem, so that it now has space
// for @n_bytes bytes of memory. It returns the new address of the memory, which
// may have been moved. @mem may be nil, in which case it's considered to have
// zero-length. @n_bytes may be 0, in which case nil will be returned and @mem
// will be freed unless it is nil.
func Realloc(mem interface{}, nBytes uint) interface{} {
	var arg1 C.gpointer
	var arg2 C.gsize

	arg1 = C.gpointer(box.Assign(mem))
	arg2 = C.gsize(nBytes)

	ret := C.g_realloc(arg1, arg2)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// ReallocN: this function is similar to g_realloc(), allocating (@n_blocks *
// @n_block_bytes) bytes, but care is taken to detect possible overflow during
// multiplication.
func ReallocN(mem interface{}, nBlocks uint, nBlockBytes uint) interface{} {
	var arg1 C.gpointer
	var arg2 C.gsize
	var arg3 C.gsize

	arg1 = C.gpointer(box.Assign(mem))
	arg2 = C.gsize(nBlocks)
	arg3 = C.gsize(nBlockBytes)

	ret := C.g_realloc_n(arg1, arg2, arg3)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// RefCountCompare compares the current value of @rc with @val.
func RefCountCompare(rc int, val int) bool {
	var arg1 *C.grefcount
	var arg2 C.gint

	arg1 = (*C.grefcount)(rc)
	arg2 = C.gint(val)

	ret := C.g_ref_count_compare(arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// RefCountDec decreases the reference count.
func RefCountDec(rc int) bool {
	var arg1 *C.grefcount

	arg1 = (*C.grefcount)(rc)

	ret := C.g_ref_count_dec(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// RefCountInc increases the reference count.
func RefCountInc(rc int) {
	var arg1 *C.grefcount

	arg1 = (*C.grefcount)(rc)

	C.g_ref_count_inc(arg1)
}

// RefCountInit initializes a reference count variable.
func RefCountInit(rc int) {
	var arg1 *C.grefcount

	arg1 = (*C.grefcount)(rc)

	C.g_ref_count_init(arg1)
}

// RefStringAcquire acquires a reference on a string.
func RefStringAcquire(str string) string {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_ref_string_acquire(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// RefStringLength retrieves the length of @str.
func RefStringLength(str string) uint {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_ref_string_length(arg1)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// NewRefString creates a new reference counted string and copies the contents
// of @str into it.
func NewRefString(str string) string {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_ref_string_new(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// RefStringNewIntern creates a new reference counted string and copies the
// content of @str into it.
//
// If you call this function multiple times with the same @str, or with the same
// contents of @str, it will return a new reference, instead of creating a new
// string.
func RefStringNewIntern(str string) string {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_ref_string_new_intern(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// RefStringNewLen creates a new reference counted string and copies the
// contents of @str into it, up to @len bytes.
//
// Since this function does not stop at nul bytes, it is the caller's
// responsibility to ensure that @str has at least @len addressable bytes.
func RefStringNewLen(str string, len int) string {
	var arg1 *C.char
	var arg2 C.gssize

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(len)

	ret := C.g_ref_string_new_len(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// RefStringRelease releases a reference on a string; if it was the last
// reference, the resources allocated by the string are freed as well.
func RefStringRelease(str string) {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	C.g_ref_string_release(arg1)
}

// RegexCheckReplacement checks whether @replacement is a valid replacement
// string (see g_regex_replace()), i.e. that all escape sequences in it are
// valid.
//
// If @has_references is not nil then @replacement is checked for pattern
// references. For instance, replacement text 'foo\n' does not contain
// references and may be evaluated without information about actual match, but
// '\0\1' (whole match followed by first subpattern) requires valid Info object.
func RegexCheckReplacement(replacement string) (hasReferences bool, err error) {
	var arg1 *C.gchar
	var arg2 *C.gboolean // out
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(replacement))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_regex_check_replacement(arg1, &arg2, &gError)

	var ret0 bool
	var goError error

	ret0 = C.BOOL(arg2) != 0

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

func RegexErrorQuark() Quark {

	ret := C.g_regex_error_quark()

	var ret0 Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = Quark(tmp)
	}

	return ret0
}

// RegexEscapeNUL escapes the nul characters in @string to "\x00". It can be
// used to compile a regex with embedded nul characters.
//
// For completeness, @length can be -1 for a nul-terminated string. In this case
// the output string will be of course equal to @string.
func RegexEscapeNUL(string string, length int) string {
	var arg1 *C.gchar
	var arg2 C.gint

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(length)

	ret := C.g_regex_escape_nul(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// RegexEscapeString escapes the special characters used for regular expressions
// in @string, for instance "a.b*c" becomes "a\.b\*c". This function is useful
// to dynamically generate regular expressions.
//
// @string can contain nul characters that are replaced with "\0", in this case
// remember to specify the correct length of @string in @length.
func RegexEscapeString(string []string) string {
	var arg1 *C.gchar
	var arg2 C.gint

	{
		var dst []C.gchar
		ptr := C.malloc(C.sizeof_gchar * len(string))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(string)
		sliceHeader.Cap = len(string)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(string); i++ {
			src := string[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg1 = (*C.gchar)(unsafe.Pointer(ptr))
		arg2 = len(string)
	}

	ret := C.g_regex_escape_string(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// RegexMatchSimple scans for a match in @string for @pattern.
//
// This function is equivalent to g_regex_match() but it does not require to
// compile the pattern with g_regex_new(), avoiding some lines of code when you
// need just to do a match without extracting substrings, capture counts, and so
// on.
//
// If this function is to be called on the same @pattern more than once, it's
// more efficient to compile the pattern once with g_regex_new() and then use
// g_regex_match().
func RegexMatchSimple(pattern string, string string, compileOptions RegexCompileFlags, matchOptions RegexMatchFlags) bool {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 C.GRegexCompileFlags
	var arg4 C.GRegexMatchFlags

	arg1 = (*C.gchar)(C.CString(pattern))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (C.GRegexCompileFlags)(compileOptions)
	arg4 = (C.GRegexMatchFlags)(matchOptions)

	ret := C.g_regex_match_simple(arg1, arg2, arg3, arg4)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// RegexSplitSimple breaks the string on the pattern, and returns an array of
// the tokens. If the pattern contains capturing parentheses, then the text for
// each of the substrings will also be returned. If the pattern does not match
// anywhere in the string, then the whole string is returned as the first token.
//
// This function is equivalent to g_regex_split() but it does not require to
// compile the pattern with g_regex_new(), avoiding some lines of code when you
// need just to do a split without extracting substrings, capture counts, and so
// on.
//
// If this function is to be called on the same @pattern more than once, it's
// more efficient to compile the pattern once with g_regex_new() and then use
// g_regex_split().
//
// As a special case, the result of splitting the empty string "" is an empty
// vector, not a vector containing a single string. The reason for this special
// case is that being able to represent an empty vector is typically more useful
// than consistent handling of empty elements. If you do need to represent empty
// elements, you'll need to check for the empty string before calling this
// function.
//
// A pattern that can match empty strings splits @string into separate
// characters wherever it matches the empty string between characters. For
// example splitting "ab c" using as a separator "\s*", you will get "a", "b"
// and "c".
func RegexSplitSimple(pattern string, string string, compileOptions RegexCompileFlags, matchOptions RegexMatchFlags) []string {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 C.GRegexCompileFlags
	var arg4 C.GRegexMatchFlags

	arg1 = (*C.gchar)(C.CString(pattern))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (C.GRegexCompileFlags)(compileOptions)
	arg4 = (C.GRegexMatchFlags)(matchOptions)

	ret := C.g_regex_split_simple(arg1, arg2, arg3, arg4)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// ReloadUserSpecialDirsCache resets the cache used for
// g_get_user_special_dir(), so that the latest on-disk version is used. Call
// this only if you just changed the data on disk yourself.
//
// Due to thread safety issues this may cause leaking of strings that were
// previously returned from g_get_user_special_dir() that can't be freed. We
// ensure to only leak the data for the directories that actually changed value
// though.
func ReloadUserSpecialDirsCache() {

	C.g_reload_user_special_dirs_cache()
}

// ReturnIfFailWarning: internal function used to print messages from the public
// g_return_if_fail() and g_return_val_if_fail() macros.
func ReturnIfFailWarning(logDomain string, prettyFunction string, expression string) {
	var arg1 *C.char
	var arg2 *C.char
	var arg3 *C.char

	arg1 = (*C.gchar)(C.CString(logDomain))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(prettyFunction))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(expression))
	defer C.free(unsafe.Pointer(arg3))

	C.g_return_if_fail_warning(arg1, arg2, arg3)
}

// Rmdir: a wrapper for the POSIX rmdir() function. The rmdir() function deletes
// a directory from the filesystem.
//
// See your C library manual for more details about how rmdir() works on your
// system.
func Rmdir(filename string) int {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_rmdir(arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// SequenceGet returns the data that @iter points to.
func SequenceGet(iter *SequenceIter) interface{} {
	var arg1 *C.GSequenceIter

	arg1 = (*C.GSequenceIter)(iter.Native())

	ret := C.g_sequence_get(arg1)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// SequenceInsertBefore inserts a new item just before the item pointed to by
// @iter.
func SequenceInsertBefore(iter *SequenceIter, data interface{}) *SequenceIter {
	var arg1 *C.GSequenceIter
	var arg2 C.gpointer

	arg1 = (*C.GSequenceIter)(iter.Native())
	arg2 = C.gpointer(box.Assign(data))

	ret := C.g_sequence_insert_before(arg1, arg2)

	var ret0 *SequenceIter

	{
		ret0 = WrapSequenceIter(unsafe.Pointer(ret))
	}

	return ret0
}

// SequenceMove moves the item pointed to by @src to the position indicated by
// @dest. After calling this function @dest will point to the position
// immediately after @src. It is allowed for @src and @dest to point into
// different sequences.
func SequenceMove(src *SequenceIter, dest *SequenceIter) {
	var arg1 *C.GSequenceIter
	var arg2 *C.GSequenceIter

	arg1 = (*C.GSequenceIter)(src.Native())
	arg2 = (*C.GSequenceIter)(dest.Native())

	C.g_sequence_move(arg1, arg2)
}

// SequenceMoveRange inserts the (@begin, @end) range at the destination pointed
// to by @dest. The @begin and @end iters must point into the same sequence. It
// is allowed for @dest to point to a different sequence than the one pointed
// into by @begin and @end.
//
// If @dest is nil, the range indicated by @begin and @end is removed from the
// sequence. If @dest points to a place within the (@begin, @end) range, the
// range does not move.
func SequenceMoveRange(dest *SequenceIter, begin *SequenceIter, end *SequenceIter) {
	var arg1 *C.GSequenceIter
	var arg2 *C.GSequenceIter
	var arg3 *C.GSequenceIter

	arg1 = (*C.GSequenceIter)(dest.Native())
	arg2 = (*C.GSequenceIter)(begin.Native())
	arg3 = (*C.GSequenceIter)(end.Native())

	C.g_sequence_move_range(arg1, arg2, arg3)
}

// SequenceRangeGetMidpoint finds an iterator somewhere in the range (@begin,
// @end). This iterator will be close to the middle of the range, but is not
// guaranteed to be exactly in the middle.
//
// The @begin and @end iterators must both point to the same sequence and @begin
// must come before or be equal to @end in the sequence.
func SequenceRangeGetMidpoint(begin *SequenceIter, end *SequenceIter) *SequenceIter {
	var arg1 *C.GSequenceIter
	var arg2 *C.GSequenceIter

	arg1 = (*C.GSequenceIter)(begin.Native())
	arg2 = (*C.GSequenceIter)(end.Native())

	ret := C.g_sequence_range_get_midpoint(arg1, arg2)

	var ret0 *SequenceIter

	{
		ret0 = WrapSequenceIter(unsafe.Pointer(ret))
	}

	return ret0
}

// SequenceRemove removes the item pointed to by @iter. It is an error to pass
// the end iterator to this function.
//
// If the sequence has a data destroy function associated with it, this function
// is called on the data for the removed item.
func SequenceRemove(iter *SequenceIter) {
	var arg1 *C.GSequenceIter

	arg1 = (*C.GSequenceIter)(iter.Native())

	C.g_sequence_remove(arg1)
}

// SequenceRemoveRange removes all items in the (@begin, @end) range.
//
// If the sequence has a data destroy function associated with it, this function
// is called on the data for the removed items.
func SequenceRemoveRange(begin *SequenceIter, end *SequenceIter) {
	var arg1 *C.GSequenceIter
	var arg2 *C.GSequenceIter

	arg1 = (*C.GSequenceIter)(begin.Native())
	arg2 = (*C.GSequenceIter)(end.Native())

	C.g_sequence_remove_range(arg1, arg2)
}

// SequenceSet changes the data for the item pointed to by @iter to be @data. If
// the sequence has a data destroy function associated with it, that function is
// called on the existing data that @iter pointed to.
func SequenceSet(iter *SequenceIter, data interface{}) {
	var arg1 *C.GSequenceIter
	var arg2 C.gpointer

	arg1 = (*C.GSequenceIter)(iter.Native())
	arg2 = C.gpointer(box.Assign(data))

	C.g_sequence_set(arg1, arg2)
}

// SequenceSwap swaps the items pointed to by @a and @b. It is allowed for @a
// and @b to point into difference sequences.
func SequenceSwap(a *SequenceIter, b *SequenceIter) {
	var arg1 *C.GSequenceIter
	var arg2 *C.GSequenceIter

	arg1 = (*C.GSequenceIter)(a.Native())
	arg2 = (*C.GSequenceIter)(b.Native())

	C.g_sequence_swap(arg1, arg2)
}

// SetApplicationName sets a human-readable name for the application. This name
// should be localized if possible, and is intended for display to the user.
// Contrast with g_set_prgname(), which sets a non-localized name.
// g_set_prgname() will be called automatically by gtk_init(), but
// g_set_application_name() will not.
//
// Note that for thread safety reasons, this function can only be called once.
//
// The application name will be used in contexts such as error messages, or when
// displaying an application's name in the task list.
func SetApplicationName(applicationName string) {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(applicationName))
	defer C.free(unsafe.Pointer(arg1))

	C.g_set_application_name(arg1)
}

// SetPrgname sets the name of the program. This name should not be localized,
// in contrast to g_set_application_name().
//
// If you are using #GApplication the program name is set in
// g_application_run(). In case of GDK or GTK+ it is set in gdk_init(), which is
// called by gtk_init() and the Application::startup handler. The program name
// is found by taking the last component of @argv[0].
//
// Note that for thread-safety reasons this function can only be called once.
func SetPrgname(prgname string) {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(prgname))
	defer C.free(unsafe.Pointer(arg1))

	C.g_set_prgname(arg1)
}

// Setenv sets an environment variable. On UNIX, both the variable's name and
// value can be arbitrary byte strings, except that the variable's name cannot
// contain '='. On Windows, they should be in UTF-8.
//
// Note that on some systems, when variables are overwritten, the memory used
// for the previous variables and its value isn't reclaimed.
//
// You should be mindful of the fact that environment variable handling in UNIX
// is not thread-safe, and your program may crash if one thread calls g_setenv()
// while another thread is calling getenv(). (And note that many functions, such
// as gettext(), call getenv() internally.) This function is only safe to use at
// the very start of your program, before creating any other threads (or
// creating objects that create worker threads of their own).
//
// If you need to set up the environment for a child process, you can use
// g_get_environ() to get an environment array, modify that with
// g_environ_setenv() and g_environ_unsetenv(), and then pass that array
// directly to execvpe(), g_spawn_async(), or the like.
func Setenv(variable string, value string, overwrite bool) bool {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 C.gboolean

	arg1 = (*C.gchar)(C.CString(variable))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(arg2))
	if overwrite {
		arg3 = C.TRUE
	}

	ret := C.g_setenv(arg1, arg2, arg3)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

func ShellErrorQuark() Quark {

	ret := C.g_shell_error_quark()

	var ret0 Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = Quark(tmp)
	}

	return ret0
}

// ShellParseArgv parses a command line into an argument vector, in much the
// same way the shell would, but without many of the expansions the shell would
// perform (variable expansion, globs, operators, filename expansion, etc. are
// not supported). The results are defined to be the same as those you would get
// from a UNIX98 /bin/sh, as long as the input contains none of the unsupported
// shell expansions. If the input does contain such expansions, they are passed
// through literally. Possible errors are those from the SHELL_ERROR domain.
// Free the returned vector with g_strfreev().
func ShellParseArgv(commandLine string) (argcp int, argvp []string, err error) {
	var arg1 *C.gchar
	var arg2 *C.gint    // out
	var arg3 ***C.gchar // out
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(commandLine))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_shell_parse_argv(arg1, &arg2, &arg3, &gError)

	var ret0 int
	var ret1 []string
	var goError error

	ret0 = int(arg2)

	{
		ret1 = make([]string, arg2)
		for i := 0; i < uintptr(arg2); i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// ShellQuote quotes a string so that the shell (/bin/sh) will interpret the
// quoted string to mean @unquoted_string. If you pass a filename to the shell,
// for example, you should first quote it with this function. The return value
// must be freed with g_free(). The quoting style used is undefined (single or
// double quotes may be used).
func ShellQuote(unquotedString string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(unquotedString))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_shell_quote(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// ShellUnquote unquotes a string as the shell (/bin/sh) would. Only handles
// quotes; if a string contains file globs, arithmetic operators, variables,
// backticks, redirections, or other special-to-the-shell features, the result
// will be different from the result a real shell would produce (the variables,
// backticks, etc. will be passed through literally instead of being expanded).
// This function is guaranteed to succeed if applied to the result of
// g_shell_quote(). If it fails, it returns nil and sets the error. The
// @quoted_string need not actually contain quoted or escaped text;
// g_shell_unquote() simply goes through the string and unquotes/unescapes
// anything that the shell would. Both single and double quotes are handled, as
// are escapes including escaped newlines. The return value must be freed with
// g_free(). Possible errors are in the SHELL_ERROR domain.
//
// Shell quoting rules are a bit strange. Single quotes preserve the literal
// string exactly. escape sequences are not allowed; not even \' - if you want a
// ' in the quoted text, you have to do something like 'foo'\”bar'. Double
// quotes allow $, `, ", \, and newline to be escaped with backslash. Otherwise
// double quotes preserve things literally.
func ShellUnquote(quotedString string) (filename string, err error) {
	var arg1 *C.gchar
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(quotedString))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_shell_unquote(arg1, &gError)

	var ret0 string
	var goError error

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// SliceAlloc allocates a block of memory from the slice allocator. The block
// address handed out can be expected to be aligned to at least 1 * sizeof
// (void*), though in general slices are 2 * sizeof (void*) bytes aligned, if a
// malloc() fallback implementation is used instead, the alignment may be
// reduced in a libc dependent fashion. Note that the underlying slice
// allocation mechanism can be changed with the
// [`G_SLICE=always-malloc`][G_SLICE] environment variable.
func SliceAlloc(blockSize uint) interface{} {
	var arg1 C.gsize

	arg1 = C.gsize(blockSize)

	ret := C.g_slice_alloc(arg1)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// SliceAlloc0 allocates a block of memory via g_slice_alloc() and initializes
// the returned memory to 0. Note that the underlying slice allocation mechanism
// can be changed with the [`G_SLICE=always-malloc`][G_SLICE] environment
// variable.
func SliceAlloc0(blockSize uint) interface{} {
	var arg1 C.gsize

	arg1 = C.gsize(blockSize)

	ret := C.g_slice_alloc0(arg1)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// SliceCopy allocates a block of memory from the slice allocator and copies
// @block_size bytes into it from @mem_block.
//
// @mem_block must be non-nil if @block_size is non-zero.
func SliceCopy(blockSize uint, memBlock interface{}) interface{} {
	var arg1 C.gsize
	var arg2 C.gpointer

	arg1 = C.gsize(blockSize)
	arg2 = C.gpointer(box.Assign(memBlock))

	ret := C.g_slice_copy(arg1, arg2)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// SliceFree1 frees a block of memory.
//
// The memory must have been allocated via g_slice_alloc() or g_slice_alloc0()
// and the @block_size has to match the size specified upon allocation. Note
// that the exact release behaviour can be changed with the
// [`G_DEBUG=gc-friendly`][G_DEBUG] environment variable, also see
// [`G_SLICE`][G_SLICE] for related debugging options.
//
// If @mem_block is nil, this function does nothing.
func SliceFree1(blockSize uint, memBlock interface{}) {
	var arg1 C.gsize
	var arg2 C.gpointer

	arg1 = C.gsize(blockSize)
	arg2 = C.gpointer(box.Assign(memBlock))

	C.g_slice_free1(arg1, arg2)
}

// SliceFreeChainWithOffset frees a linked list of memory blocks of structure
// type @type.
//
// The memory blocks must be equal-sized, allocated via g_slice_alloc() or
// g_slice_alloc0() and linked together by a @next pointer (similar to List).
// The offset of the @next field in each block is passed as third argument. Note
// that the exact release behaviour can be changed with the
// [`G_DEBUG=gc-friendly`][G_DEBUG] environment variable, also see
// [`G_SLICE`][G_SLICE] for related debugging options.
//
// If @mem_chain is nil, this function does nothing.
func SliceFreeChainWithOffset(blockSize uint, memChain interface{}, nextOffset uint) {
	var arg1 C.gsize
	var arg2 C.gpointer
	var arg3 C.gsize

	arg1 = C.gsize(blockSize)
	arg2 = C.gpointer(box.Assign(memChain))
	arg3 = C.gsize(nextOffset)

	C.g_slice_free_chain_with_offset(arg1, arg2, arg3)
}

func SliceGetConfig(ckey SliceConfig) int64 {
	var arg1 C.GSliceConfig

	arg1 = (C.GSliceConfig)(ckey)

	ret := C.g_slice_get_config(arg1)

	var ret0 int64

	ret0 = int64(ret)

	return ret0
}

func SliceGetConfigState(ckey SliceConfig, address int64, nValues uint) int64 {
	var arg1 C.GSliceConfig
	var arg2 C.gint64
	var arg3 *C.guint

	arg1 = (C.GSliceConfig)(ckey)
	arg2 = C.gint64(address)
	arg3 = (*C.guint)(nValues)

	ret := C.g_slice_get_config_state(arg1, arg2, arg3)

	var ret0 int64

	ret0 = int64(ret)

	return ret0
}

func SliceSetConfig(ckey SliceConfig, value int64) {
	var arg1 C.GSliceConfig
	var arg2 C.gint64

	arg1 = (C.GSliceConfig)(ckey)
	arg2 = C.gint64(value)

	C.g_slice_set_config(arg1, arg2)
}

// SourceRemove removes the source with the given ID from the default main
// context. You must use g_source_destroy() for sources added to a non-default
// main context.
//
// The ID of a #GSource is given by g_source_get_id(), or will be returned by
// the functions g_source_attach(), g_idle_add(), g_idle_add_full(),
// g_timeout_add(), g_timeout_add_full(), g_child_watch_add(),
// g_child_watch_add_full(), g_io_add_watch(), and g_io_add_watch_full().
//
// It is a programmer error to attempt to remove a non-existent source.
//
// More specifically: source IDs can be reissued after a source has been
// destroyed and therefore it is never valid to use this function with a source
// ID which may have already been removed. An example is when scheduling an idle
// to run in another thread with g_idle_add(): the idle may already have run and
// been removed by the time this function is called on its (now invalid) source
// ID. This source ID may have been reissued, leading to the operation being
// performed against the wrong source.
func SourceRemove(tag uint) bool {
	var arg1 C.guint

	arg1 = C.guint(tag)

	ret := C.g_source_remove(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SourceRemoveByUserData removes a source from the default main loop context
// given the user data for the callback. If multiple sources exist with the same
// user data, only one will be destroyed.
func SourceRemoveByUserData(userData interface{}) bool {
	var arg1 C.gpointer

	arg1 = C.gpointer(box.Assign(userData))

	ret := C.g_source_remove_by_user_data(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SourceSetNameByID sets the name of a source using its ID.
//
// This is a convenience utility to set source names from the return value of
// g_idle_add(), g_timeout_add(), etc.
//
// It is a programmer error to attempt to set the name of a non-existent source.
//
// More specifically: source IDs can be reissued after a source has been
// destroyed and therefore it is never valid to use this function with a source
// ID which may have already been removed. An example is when scheduling an idle
// to run in another thread with g_idle_add(): the idle may already have run and
// been removed by the time this function is called on its (now invalid) source
// ID. This source ID may have been reissued, leading to the operation being
// performed against the wrong source.
func SourceSetNameByID(tag uint, name string) {
	var arg1 C.guint
	var arg2 *C.char

	arg1 = C.guint(tag)
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	C.g_source_set_name_by_id(arg1, arg2)
}

// SpacedPrimesClosest gets the smallest prime number from a built-in array of
// primes which is larger than @num. This is used within GLib to calculate the
// optimum size of a Table.
//
// The built-in array of primes ranges from 11 to 13845163 such that each prime
// is approximately 1.5-2 times the previous prime.
func SpacedPrimesClosest(num uint) uint {
	var arg1 C.guint

	arg1 = C.guint(num)

	ret := C.g_spaced_primes_closest(arg1)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// SpawnAsync: see g_spawn_async_with_pipes() for a full description; this
// function simply calls the g_spawn_async_with_pipes() without any pipes.
//
// You should call g_spawn_close_pid() on the returned child process reference
// when you don't need it any more.
//
// If you are writing a GTK+ application, and the program you are spawning is a
// graphical application too, then to ensure that the spawned program opens its
// windows on the right screen, you may want to use AppLaunchContext,
// LaunchContext, or set the DISPLAY environment variable.
//
// Note that the returned @child_pid on Windows is a handle to the child process
// and not its identifier. Process handles and process identifiers are different
// concepts on Windows.
func SpawnAsync(workingDirectory string, argv []string, envp []string, flags SpawnFlags, childSetup SpawnChildSetupFunc) (childPid Pid, err error) {
	var arg1 *C.gchar
	var arg2 **C.gchar
	var arg3 **C.gchar
	var arg4 C.GSpawnFlags
	var arg5 C.GSpawnChildSetupFunc
	var arg6 C.gpointer
	var arg7 *C.GPid // out
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(workingDirectory))
	defer C.free(unsafe.Pointer(arg1))
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(argv) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(argv)
		sliceHeader.Cap = len(argv)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(argv); i++ {
			src := argv[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg2 = (**C.gchar)(unsafe.Pointer(ptr))
	}
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(envp) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(envp)
		sliceHeader.Cap = len(envp)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(envp); i++ {
			src := envp[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg3 = (**C.gchar)(unsafe.Pointer(ptr))
	}
	arg4 = (C.GSpawnFlags)(flags)
	arg5 = (*[0]byte)(C.gotk4_SpawnChildSetupFunc)
	arg6 = C.gpointer(box.Assign(childSetup))

	ret := C.g_spawn_async(arg1, arg2, arg3, arg4, arg5, arg6, &arg7, &gError)

	var ret0 *Pid
	var goError error

	{
		var tmp int
		tmp = int(arg7)
		ret0 = *Pid(tmp)
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// SpawnAsyncWithFds: identical to g_spawn_async_with_pipes() but instead of
// creating pipes for the stdin/stdout/stderr, you can pass existing file
// descriptors into this function through the @stdin_fd, @stdout_fd and
// @stderr_fd parameters. The following @flags also have their behaviour
// slightly tweaked as a result:
//
// G_SPAWN_STDOUT_TO_DEV_NULL means that the child's standard output will be
// discarded, instead of going to the same location as the parent's standard
// output. If you use this flag, @standard_output must be -1.
// G_SPAWN_STDERR_TO_DEV_NULL means that the child's standard error will be
// discarded, instead of going to the same location as the parent's standard
// error. If you use this flag, @standard_error must be -1.
// G_SPAWN_CHILD_INHERITS_STDIN means that the child will inherit the parent's
// standard input (by default, the child's standard input is attached to
// /dev/null). If you use this flag, @standard_input must be -1.
//
// It is valid to pass the same fd in multiple parameters (e.g. you can pass a
// single fd for both stdout and stderr).
func SpawnAsyncWithFds(workingDirectory string, argv []string, envp []string, flags SpawnFlags, childSetup SpawnChildSetupFunc, stdinFd int, stdoutFd int, stderrFd int) (childPid Pid, err error) {
	var arg1 *C.gchar
	var arg2 **C.gchar
	var arg3 **C.gchar
	var arg4 C.GSpawnFlags
	var arg5 C.GSpawnChildSetupFunc
	var arg6 C.gpointer
	var arg7 *C.GPid // out
	var arg8 C.gint
	var arg9 C.gint
	var arg10 C.gint
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(workingDirectory))
	defer C.free(unsafe.Pointer(arg1))
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(argv) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(argv)
		sliceHeader.Cap = len(argv)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(argv); i++ {
			src := argv[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg2 = (**C.gchar)(unsafe.Pointer(ptr))
	}
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(envp) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(envp)
		sliceHeader.Cap = len(envp)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(envp); i++ {
			src := envp[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg3 = (**C.gchar)(unsafe.Pointer(ptr))
	}
	arg4 = (C.GSpawnFlags)(flags)
	arg5 = (*[0]byte)(C.gotk4_SpawnChildSetupFunc)
	arg6 = C.gpointer(box.Assign(childSetup))
	arg8 = C.gint(stdinFd)
	arg9 = C.gint(stdoutFd)
	arg10 = C.gint(stderrFd)

	ret := C.g_spawn_async_with_fds(arg1, arg2, arg3, arg4, arg5, arg6, &arg7, arg8, arg9, arg10, &gError)

	var ret0 *Pid
	var goError error

	{
		var tmp int
		tmp = int(arg7)
		ret0 = *Pid(tmp)
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// SpawnAsyncWithPipes executes a child program asynchronously (your program
// will not block waiting for the child to exit). The child program is specified
// by the only argument that must be provided, @argv. @argv should be a
// nil-terminated array of strings, to be passed as the argument vector for the
// child. The first string in @argv is of course the name of the program to
// execute. By default, the name of the program must be a full path. If @flags
// contains the G_SPAWN_SEARCH_PATH flag, the `PATH` environment variable is
// used to search for the executable. If @flags contains the
// G_SPAWN_SEARCH_PATH_FROM_ENVP flag, the `PATH` variable from @envp is used to
// search for the executable. If both the G_SPAWN_SEARCH_PATH and
// G_SPAWN_SEARCH_PATH_FROM_ENVP flags are set, the `PATH` variable from @envp
// takes precedence over the environment variable.
//
// If the program name is not a full path and G_SPAWN_SEARCH_PATH flag is not
// used, then the program will be run from the current directory (or
// @working_directory, if specified); this might be unexpected or even dangerous
// in some cases when the current directory is world-writable.
//
// On Windows, note that all the string or string vector arguments to this
// function and the other g_spawn*() functions are in UTF-8, the GLib file name
// encoding. Unicode characters that are not part of the system codepage passed
// in these arguments will be correctly available in the spawned program only if
// it uses wide character API to retrieve its command line. For C programs built
// with Microsoft's tools it is enough to make the program have a wmain()
// instead of main(). wmain() has a wide character argument vector as parameter.
//
// At least currently, mingw doesn't support wmain(), so if you use mingw to
// develop the spawned program, it should call g_win32_get_command_line() to get
// arguments in UTF-8.
//
// On Windows the low-level child process creation API CreateProcess() doesn't
// use argument vectors, but a command line. The C runtime library's spawn*()
// family of functions (which g_spawn_async_with_pipes() eventually calls) paste
// the argument vector elements together into a command line, and the C runtime
// startup code does a corresponding reconstruction of an argument vector from
// the command line, to be passed to main(). Complications arise when you have
// argument vector elements that contain spaces or double quotes. The `spawn*()`
// functions don't do any quoting or escaping, but on the other hand the startup
// code does do unquoting and unescaping in order to enable receiving arguments
// with embedded spaces or double quotes. To work around this asymmetry,
// g_spawn_async_with_pipes() will do quoting and escaping on argument vector
// elements that need it before calling the C runtime spawn() function.
//
// The returned @child_pid on Windows is a handle to the child process, not its
// identifier. Process handles and process identifiers are different concepts on
// Windows.
//
// @envp is a nil-terminated array of strings, where each string has the form
// `KEY=VALUE`. This will become the child's environment. If @envp is nil, the
// child inherits its parent's environment.
//
// @flags should be the bitwise OR of any flags you want to affect the
// function's behaviour. The G_SPAWN_DO_NOT_REAP_CHILD means that the child will
// not automatically be reaped; you must use a child watch (g_child_watch_add())
// to be notified about the death of the child process, otherwise it will stay
// around as a zombie process until this process exits. Eventually you must call
// g_spawn_close_pid() on the @child_pid, in order to free resources which may
// be associated with the child process. (On Unix, using a child watch is
// equivalent to calling waitpid() or handling the SIGCHLD signal manually. On
// Windows, calling g_spawn_close_pid() is equivalent to calling CloseHandle()
// on the process handle returned in @child_pid). See g_child_watch_add().
//
// Open UNIX file descriptors marked as `FD_CLOEXEC` will be automatically
// closed in the child process. G_SPAWN_LEAVE_DESCRIPTORS_OPEN means that other
// open file descriptors will be inherited by the child; otherwise all
// descriptors except stdin/stdout/stderr will be closed before calling exec()
// in the child. G_SPAWN_SEARCH_PATH means that @argv[0] need not be an absolute
// path, it will be looked for in the `PATH` environment variable.
// G_SPAWN_SEARCH_PATH_FROM_ENVP means need not be an absolute path, it will be
// looked for in the `PATH` variable from @envp. If both G_SPAWN_SEARCH_PATH and
// G_SPAWN_SEARCH_PATH_FROM_ENVP are used, the value from @envp takes precedence
// over the environment. G_SPAWN_STDOUT_TO_DEV_NULL means that the child's
// standard output will be discarded, instead of going to the same location as
// the parent's standard output. If you use this flag, @standard_output must be
// nil. G_SPAWN_STDERR_TO_DEV_NULL means that the child's standard error will be
// discarded, instead of going to the same location as the parent's standard
// error. If you use this flag, @standard_error must be nil.
// G_SPAWN_CHILD_INHERITS_STDIN means that the child will inherit the parent's
// standard input (by default, the child's standard input is attached to
// `/dev/null`). If you use this flag, @standard_input must be nil.
// G_SPAWN_FILE_AND_ARGV_ZERO means that the first element of @argv is the file
// to execute, while the remaining elements are the actual argument vector to
// pass to the file. Normally g_spawn_async_with_pipes() uses @argv[0] as the
// file to execute, and passes all of @argv to the child.
//
// @child_setup and @user_data are a function and user data. On POSIX platforms,
// the function is called in the child after GLib has performed all the setup it
// plans to perform (including creating pipes, closing file descriptors, etc.)
// but before calling exec(). That is, @child_setup is called just before
// calling exec() in the child. Obviously actions taken in this function will
// only affect the child, not the parent.
//
// On Windows, there is no separate fork() and exec() functionality. Child
// processes are created and run with a single API call, CreateProcess(). There
// is no sensible thing @child_setup could be used for on Windows so it is
// ignored and not called.
//
// If non-nil, @child_pid will on Unix be filled with the child's process ID.
// You can use the process ID to send signals to the child, or to use
// g_child_watch_add() (or waitpid()) if you specified the
// G_SPAWN_DO_NOT_REAP_CHILD flag. On Windows, @child_pid will be filled with a
// handle to the child process only if you specified the
// G_SPAWN_DO_NOT_REAP_CHILD flag. You can then access the child process using
// the Win32 API, for example wait for its termination with the WaitFor*()
// functions, or examine its exit code with GetExitCodeProcess(). You should
// close the handle with CloseHandle() or g_spawn_close_pid() when you no longer
// need it.
//
// If non-nil, the @standard_input, @standard_output, @standard_error locations
// will be filled with file descriptors for writing to the child's standard
// input or reading from its standard output or standard error. The caller of
// g_spawn_async_with_pipes() must close these file descriptors when they are no
// longer in use. If these parameters are nil, the corresponding pipe won't be
// created.
//
// If @standard_input is nil, the child's standard input is attached to
// `/dev/null` unless G_SPAWN_CHILD_INHERITS_STDIN is set.
//
// If @standard_error is NULL, the child's standard error goes to the same
// location as the parent's standard error unless G_SPAWN_STDERR_TO_DEV_NULL is
// set.
//
// If @standard_output is NULL, the child's standard output goes to the same
// location as the parent's standard output unless G_SPAWN_STDOUT_TO_DEV_NULL is
// set.
//
// @error can be nil to ignore errors, or non-nil to report errors. If an error
// is set, the function returns false. Errors are reported even if they occur in
// the child (for example if the executable in @argv[0] is not found). Typically
// the `message` field of returned errors should be displayed to users. Possible
// errors are those from the SPAWN_ERROR domain.
//
// If an error occurs, @child_pid, @standard_input, @standard_output, and
// @standard_error will not be filled with valid values.
//
// If @child_pid is not nil and an error does not occur then the returned
// process reference must be closed using g_spawn_close_pid().
//
// On modern UNIX platforms, GLib can use an efficient process launching
// codepath driven internally by posix_spawn(). This has the advantage of
// avoiding the fork-time performance costs of cloning the parent process
// address space, and avoiding associated memory overcommit checks that are not
// relevant in the context of immediately executing a distinct process. This
// optimized codepath will be used provided that the following conditions are
// met:
//
// 1. G_SPAWN_DO_NOT_REAP_CHILD is set 2. G_SPAWN_LEAVE_DESCRIPTORS_OPEN is set
// 3. G_SPAWN_SEARCH_PATH_FROM_ENVP is not set 4. @working_directory is nil 5.
// @child_setup is nil 6. The program is of a recognised binary format, or has a
// shebang. Otherwise, GLib will have to execute the program through the shell,
// which is not done using the optimized codepath.
//
// If you are writing a GTK+ application, and the program you are spawning is a
// graphical application too, then to ensure that the spawned program opens its
// windows on the right screen, you may want to use AppLaunchContext,
// LaunchContext, or set the DISPLAY environment variable.
func SpawnAsyncWithPipes(workingDirectory string, argv []string, envp []string, flags SpawnFlags, childSetup SpawnChildSetupFunc) (childPid Pid, standardInput int, standardOutput int, standardError int, err error) {
	var arg1 *C.gchar
	var arg2 **C.gchar
	var arg3 **C.gchar
	var arg4 C.GSpawnFlags
	var arg5 C.GSpawnChildSetupFunc
	var arg6 C.gpointer
	var arg7 *C.GPid  // out
	var arg8 *C.gint  // out
	var arg9 *C.gint  // out
	var arg10 *C.gint // out
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(workingDirectory))
	defer C.free(unsafe.Pointer(arg1))
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(argv) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(argv)
		sliceHeader.Cap = len(argv)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(argv); i++ {
			src := argv[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg2 = (**C.gchar)(unsafe.Pointer(ptr))
	}
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(envp) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(envp)
		sliceHeader.Cap = len(envp)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(envp); i++ {
			src := envp[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg3 = (**C.gchar)(unsafe.Pointer(ptr))
	}
	arg4 = (C.GSpawnFlags)(flags)
	arg5 = (*[0]byte)(C.gotk4_SpawnChildSetupFunc)
	arg6 = C.gpointer(box.Assign(childSetup))

	ret := C.g_spawn_async_with_pipes(arg1, arg2, arg3, arg4, arg5, arg6, &arg7, &arg8, &arg9, &arg10, &gError)

	var ret0 *Pid
	var ret1 int
	var ret2 int
	var ret3 int
	var goError error

	{
		var tmp int
		tmp = int(arg7)
		ret0 = *Pid(tmp)
	}

	ret1 = int(arg8)

	ret2 = int(arg9)

	ret3 = int(arg10)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, ret3, goError
}

// SpawnCheckExitStatus: set @error if @exit_status indicates the child exited
// abnormally (e.g. with a nonzero exit code, or via a fatal signal).
//
// The g_spawn_sync() and g_child_watch_add() family of APIs return an exit
// status for subprocesses encoded in a platform-specific way. On Unix, this is
// guaranteed to be in the same format waitpid() returns, and on Windows it is
// guaranteed to be the result of GetExitCodeProcess().
//
// Prior to the introduction of this function in GLib 2.34, interpreting
// @exit_status required use of platform-specific APIs, which is problematic for
// software using GLib as a cross-platform layer.
//
// Additionally, many programs simply want to determine whether or not the child
// exited successfully, and either propagate a #GError or print a message to
// standard error. In that common case, this function can be used. Note that the
// error message in @error will contain human-readable information about the
// exit status.
//
// The @domain and @code of @error have special semantics in the case where the
// process has an "exit code", as opposed to being killed by a signal. On Unix,
// this happens if WIFEXITED() would be true of @exit_status. On Windows, it is
// always the case.
//
// The special semantics are that the actual exit code will be the code set in
// @error, and the domain will be G_SPAWN_EXIT_ERROR. This allows you to
// differentiate between different exit codes.
//
// If the process was terminated by some means other than an exit status, the
// domain will be G_SPAWN_ERROR, and the code will be G_SPAWN_ERROR_FAILED.
//
// This function just offers convenience; you can of course also check the
// available platform via a macro such as G_OS_UNIX, and use WIFEXITED() and
// WEXITSTATUS() on @exit_status directly. Do not attempt to scan or parse the
// error message string; it may be translated and/or change in future versions
// of GLib.
func SpawnCheckExitStatus(exitStatus int) error {
	var arg1 C.gint
	var gError *C.GError

	arg1 = C.gint(exitStatus)

	ret := C.g_spawn_check_exit_status(arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SpawnCommandLineAsync: a simple version of g_spawn_async() that parses a
// command line with g_shell_parse_argv() and passes it to g_spawn_async(). Runs
// a command line in the background. Unlike g_spawn_async(), the
// G_SPAWN_SEARCH_PATH flag is enabled, other flags are not. Note that
// G_SPAWN_SEARCH_PATH can have security implications, so consider using
// g_spawn_async() directly if appropriate. Possible errors are those from
// g_shell_parse_argv() and g_spawn_async().
//
// The same concerns on Windows apply as for g_spawn_command_line_sync().
func SpawnCommandLineAsync(commandLine string) error {
	var arg1 *C.gchar
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(commandLine))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_spawn_command_line_async(arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SpawnCommandLineSync: a simple version of g_spawn_sync() with little-used
// parameters removed, taking a command line instead of an argument vector. See
// g_spawn_sync() for full details. @command_line will be parsed by
// g_shell_parse_argv(). Unlike g_spawn_sync(), the G_SPAWN_SEARCH_PATH flag is
// enabled. Note that G_SPAWN_SEARCH_PATH can have security implications, so
// consider using g_spawn_sync() directly if appropriate. Possible errors are
// those from g_spawn_sync() and those from g_shell_parse_argv().
//
// If @exit_status is non-nil, the platform-specific exit status of the child is
// stored there; see the documentation of g_spawn_check_exit_status() for how to
// use and interpret this.
//
// On Windows, please note the implications of g_shell_parse_argv() parsing
// @command_line. Parsing is done according to Unix shell rules, not Windows
// command interpreter rules. Space is a separator, and backslashes are special.
// Thus you cannot simply pass a @command_line containing canonical Windows
// paths, like "c:\\program files\\app\\app.exe", as the backslashes will be
// eaten, and the space will act as a separator. You need to enclose such paths
// with single quotes, like "'c:\\program files\\app\\app.exe'
// 'e:\\folder\\argument.txt'".
func SpawnCommandLineSync(commandLine string) (standardOutput []byte, standardError []byte, exitStatus int, err error) {
	var arg1 *C.gchar
	var arg2 **C.gchar // out
	var arg3 **C.gchar // out
	var arg4 *C.gint   // out
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(commandLine))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_spawn_command_line_sync(arg1, &arg2, &arg3, &arg4, &gError)

	var ret0 []byte
	var ret1 []byte
	var ret2 int
	var goError error

	{
		var length uint
		for p := unsafe.Pointer(arg2); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]byte, length)
		for i := 0; i < length; i++ {
			src := (C.guint8)(unsafe.Pointer(uintptr(unsafe.Pointer(arg2)) + i))
			ret0[i] = byte(src)
		}
	}

	{
		var length uint
		for p := unsafe.Pointer(arg3); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret1 = make([]byte, length)
		for i := 0; i < length; i++ {
			src := (C.guint8)(unsafe.Pointer(uintptr(unsafe.Pointer(arg3)) + i))
			ret1[i] = byte(src)
		}
	}

	ret2 = int(arg4)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}

func SpawnErrorQuark() Quark {

	ret := C.g_spawn_error_quark()

	var ret0 Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = Quark(tmp)
	}

	return ret0
}

func SpawnExitErrorQuark() Quark {

	ret := C.g_spawn_exit_error_quark()

	var ret0 Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = Quark(tmp)
	}

	return ret0
}

// SpawnSync executes a child synchronously (waits for the child to exit before
// returning). All output from the child is stored in @standard_output and
// @standard_error, if those parameters are non-nil. Note that you must set the
// G_SPAWN_STDOUT_TO_DEV_NULL and G_SPAWN_STDERR_TO_DEV_NULL flags when passing
// nil for @standard_output and @standard_error.
//
// If @exit_status is non-nil, the platform-specific exit status of the child is
// stored there; see the documentation of g_spawn_check_exit_status() for how to
// use and interpret this. Note that it is invalid to pass
// G_SPAWN_DO_NOT_REAP_CHILD in @flags, and on POSIX platforms, the same
// restrictions as for g_child_watch_source_new() apply.
//
// If an error occurs, no data is returned in @standard_output, @standard_error,
// or @exit_status.
//
// This function calls g_spawn_async_with_pipes() internally; see that function
// for full details on the other parameters and details on how these functions
// work on Windows.
func SpawnSync(workingDirectory string, argv []string, envp []string, flags SpawnFlags, childSetup SpawnChildSetupFunc) (standardOutput []byte, standardError []byte, exitStatus int, err error) {
	var arg1 *C.gchar
	var arg2 **C.gchar
	var arg3 **C.gchar
	var arg4 C.GSpawnFlags
	var arg5 C.GSpawnChildSetupFunc
	var arg6 C.gpointer
	var arg7 **C.gchar // out
	var arg8 **C.gchar // out
	var arg9 *C.gint   // out
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(workingDirectory))
	defer C.free(unsafe.Pointer(arg1))
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(argv) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(argv)
		sliceHeader.Cap = len(argv)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(argv); i++ {
			src := argv[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg2 = (**C.gchar)(unsafe.Pointer(ptr))
	}
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(envp) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(envp)
		sliceHeader.Cap = len(envp)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(envp); i++ {
			src := envp[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg3 = (**C.gchar)(unsafe.Pointer(ptr))
	}
	arg4 = (C.GSpawnFlags)(flags)
	arg5 = (*[0]byte)(C.gotk4_SpawnChildSetupFunc)
	arg6 = C.gpointer(box.Assign(childSetup))

	ret := C.g_spawn_sync(arg1, arg2, arg3, arg4, arg5, arg6, &arg7, &arg8, &arg9, &gError)

	var ret0 []byte
	var ret1 []byte
	var ret2 int
	var goError error

	{
		var length uint
		for p := unsafe.Pointer(arg7); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]byte, length)
		for i := 0; i < length; i++ {
			src := (C.guint8)(unsafe.Pointer(uintptr(unsafe.Pointer(arg7)) + i))
			ret0[i] = byte(src)
		}
	}

	{
		var length uint
		for p := unsafe.Pointer(arg8); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret1 = make([]byte, length)
		for i := 0; i < length; i++ {
			src := (C.guint8)(unsafe.Pointer(uintptr(unsafe.Pointer(arg8)) + i))
			ret1[i] = byte(src)
		}
	}

	ret2 = int(arg9)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}

// Stpcpy copies a nul-terminated string into the dest buffer, include the
// trailing nul, and return a pointer to the trailing nul byte. This is useful
// for concatenating multiple strings together without having to repeatedly scan
// for the end.
func Stpcpy(dest string, src string) string {
	var arg1 *C.gchar
	var arg2 *C.char

	arg1 = (*C.gchar)(C.CString(dest))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(src))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_stpcpy(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

func TestAssertExpectedMessagesInternal(domain string, file string, line int, fn string) {
	var arg1 *C.char
	var arg2 *C.char
	var arg3 C.int
	var arg4 *C.char

	arg1 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(file))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.int(line)
	arg4 = (*C.gchar)(C.CString(fn))
	defer C.free(unsafe.Pointer(arg4))

	C.g_test_assert_expected_messages_internal(arg1, arg2, arg3, arg4)
}

// TestBug: this function adds a message to test reports that associates a bug
// URI with a test case. Bug URIs are constructed from a base URI set with
// g_test_bug_base() and @bug_uri_snippet. If g_test_bug_base() has not been
// called, it is assumed to be the empty string, so a full URI can be provided
// to g_test_bug() instead.
func TestBug(bugURISnippet string) {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(bugURISnippet))
	defer C.free(unsafe.Pointer(arg1))

	C.g_test_bug(arg1)
}

// TestBugBase: specify the base URI for bug reports.
//
// The base URI is used to construct bug report messages for g_test_message()
// when g_test_bug() is called. Calling this function outside of a test case
// sets the default base URI for all test cases. Calling it from within a test
// case changes the base URI for the scope of the test case only. Bug URIs are
// constructed by appending a bug specific URI portion to @uri_pattern, or by
// replacing the special string '\s' within @uri_pattern if that is present.
//
// If g_test_bug_base() is not called, bug URIs are formed solely from the value
// provided by g_test_bug().
func TestBugBase(uriPattern string) {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(uriPattern))
	defer C.free(unsafe.Pointer(arg1))

	C.g_test_bug_base(arg1)
}

// TestCreateSuite: create a new test suite with the name @suite_name.
func TestCreateSuite(suiteName string) *TestSuite {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(suiteName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_test_create_suite(arg1)

	var ret0 *TestSuite

	{
		ret0 = WrapTestSuite(unsafe.Pointer(ret))
	}

	return ret0
}

// TestExpectMessage indicates that a message with the given @log_domain and
// @log_level, with text matching @pattern, is expected to be logged. When this
// message is logged, it will not be printed, and the test case will not abort.
//
// This API may only be used with the old logging API (g_log() without
// G_LOG_USE_STRUCTURED defined). It will not work with the structured logging
// API. See [Testing for Messages][testing-for-messages].
//
// Use g_test_assert_expected_messages() to assert that all previously-expected
// messages have been seen and suppressed.
//
// You can call this multiple times in a row, if multiple messages are expected
// as a result of a single call. (The messages must appear in the same order as
// the calls to g_test_expect_message().)
//
// For example:
//
//    // g_main_context_push_thread_default() should fail if the
//    // context is already owned by another thread.
//    g_test_expect_message (G_LOG_DOMAIN,
//                           G_LOG_LEVEL_CRITICAL,
//                           "assertion*acquired_context*failed");
//    g_main_context_push_thread_default (bad_context);
//    g_test_assert_expected_messages ();
//
// Note that you cannot use this to test g_error() messages, since g_error()
// intentionally never returns even if the program doesn't abort; use
// g_test_trap_subprocess() in this case.
//
// If messages at G_LOG_LEVEL_DEBUG are emitted, but not explicitly expected via
// g_test_expect_message() then they will be ignored.
func TestExpectMessage(logDomain string, logLevel LogLevelFlags, pattern string) {
	var arg1 *C.gchar
	var arg2 C.GLogLevelFlags
	var arg3 *C.gchar

	arg1 = (*C.gchar)(C.CString(logDomain))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GLogLevelFlags)(logLevel)
	arg3 = (*C.gchar)(C.CString(pattern))
	defer C.free(unsafe.Pointer(arg3))

	C.g_test_expect_message(arg1, arg2, arg3)
}

// TestFail indicates that a test failed. This function can be called multiple
// times from the same test. You can use this function if your test failed in a
// recoverable way.
//
// Do not use this function if the failure of a test could cause other tests to
// malfunction.
//
// Calling this function will not stop the test from running, you need to return
// from the test function yourself. So you can produce additional diagnostic
// messages or even continue running the test.
//
// If not called from inside a test, this function does nothing.
func TestFail() {

	C.g_test_fail()
}

// TestFailed returns whether a test has already failed. This will be the case
// when g_test_fail(), g_test_incomplete() or g_test_skip() have been called,
// but also if an assertion has failed.
//
// This can be useful to return early from a test if continuing after a failed
// assertion might be harmful.
//
// The return value of this function is only meaningful if it is called from
// inside a test function.
func TestFailed() bool {

	ret := C.g_test_failed()

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// TestGetDir gets the pathname of the directory containing test files of the
// type specified by @file_type.
//
// This is approximately the same as calling g_test_build_filename("."), but you
// don't need to free the return value.
func TestGetDir(fileType TestFileType) string {
	var arg1 C.GTestFileType

	arg1 = (C.GTestFileType)(fileType)

	ret := C.g_test_get_dir(arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// TestGetRoot: get the toplevel test suite for the test path API.
func TestGetRoot() *TestSuite {

	ret := C.g_test_get_root()

	var ret0 *TestSuite

	{
		ret0 = WrapTestSuite(unsafe.Pointer(ret))
	}

	return ret0
}

// TestIncomplete indicates that a test failed because of some incomplete
// functionality. This function can be called multiple times from the same test.
//
// Calling this function will not stop the test from running, you need to return
// from the test function yourself. So you can produce additional diagnostic
// messages or even continue running the test.
//
// If not called from inside a test, this function does nothing.
func TestIncomplete(msg string) {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(msg))
	defer C.free(unsafe.Pointer(arg1))

	C.g_test_incomplete(arg1)
}

// TestLogSetFatalHandler installs a non-error fatal log handler which can be
// used to decide whether log messages which are counted as fatal abort the
// program.
//
// The use case here is that you are running a test case that depends on
// particular libraries or circumstances and cannot prevent certain known
// critical or warning messages. So you install a handler that compares the
// domain and message to precisely not abort in such a case.
//
// Note that the handler is reset at the beginning of any test case, so you have
// to set it inside each test function which needs the special behavior.
//
// This handler has no effect on g_error messages.
//
// This handler also has no effect on structured log messages (using
// g_log_structured() or g_log_structured_array()). To change the fatal
// behaviour for specific log messages, programs must install a custom log
// writer function using g_log_set_writer_func().See [Using Structured
// Logging][using-structured-logging].
func TestLogSetFatalHandler(logFunc TestLogFatalFunc) {
	var arg1 C.GTestLogFatalFunc
	var arg2 C.gpointer

	arg1 = (*[0]byte)(C.gotk4_TestLogFatalFunc)
	arg2 = C.gpointer(box.Assign(logFunc))

	C.g_test_log_set_fatal_handler(arg1, arg2)
}

func TestLogTypeName(logType TestLogType) string {
	var arg1 C.GTestLogType

	arg1 = (C.GTestLogType)(logType)

	ret := C.g_test_log_type_name(arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// TestQueueFree: enqueue a pointer to be released with g_free() during the next
// teardown phase. This is equivalent to calling g_test_queue_destroy() with a
// destroy callback of g_free().
func TestQueueFree(gfreePointer interface{}) {
	var arg1 C.gpointer

	arg1 = C.gpointer(box.Assign(gfreePointer))

	C.g_test_queue_free(arg1)
}

// TestRandDouble: get a reproducible random floating point number, see
// g_test_rand_int() for details on test case random numbers.
func TestRandDouble() float64 {

	ret := C.g_test_rand_double()

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// TestRandDoubleRange: get a reproducible random floating pointer number out of
// a specified range, see g_test_rand_int() for details on test case random
// numbers.
func TestRandDoubleRange(rangeStart float64, rangeEnd float64) float64 {
	var arg1 C.double
	var arg2 C.double

	arg1 = C.double(rangeStart)
	arg2 = C.double(rangeEnd)

	ret := C.g_test_rand_double_range(arg1, arg2)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// TestRandInt: get a reproducible random integer number.
//
// The random numbers generated by the g_test_rand_*() family of functions
// change with every new test program start, unless the --seed option is given
// when starting test programs.
//
// For individual test cases however, the random number generator is reseeded,
// to avoid dependencies between tests and to make --seed effective for all test
// cases.
func TestRandInt() int32 {

	ret := C.g_test_rand_int()

	var ret0 int32

	ret0 = int32(ret)

	return ret0
}

// TestRandIntRange: get a reproducible random integer number out of a specified
// range, see g_test_rand_int() for details on test case random numbers.
func TestRandIntRange(begin int32, end int32) int32 {
	var arg1 C.gint32
	var arg2 C.gint32

	arg1 = C.gint32(begin)
	arg2 = C.gint32(end)

	ret := C.g_test_rand_int_range(arg1, arg2)

	var ret0 int32

	ret0 = int32(ret)

	return ret0
}

// TestRun runs all tests under the toplevel suite which can be retrieved with
// g_test_get_root(). Similar to g_test_run_suite(), the test cases to be run
// are filtered according to test path arguments (`-p testpath` and `-s
// testpath`) as parsed by g_test_init(). g_test_run_suite() or g_test_run() may
// only be called once in a program.
//
// In general, the tests and sub-suites within each suite are run in the order
// in which they are defined. However, note that prior to GLib 2.36, there was a
// bug in the `g_test_add_*` functions which caused them to create multiple
// suites with the same name, meaning that if you created tests "/foo/simple",
// "/bar/simple", and "/foo/using-bar" in that order, they would get run in that
// order (since g_test_run() would run the first "/foo" suite, then the "/bar"
// suite, then the second "/foo" suite). As of 2.36, this bug is fixed, and
// adding the tests in that order would result in a running order of
// "/foo/simple", "/foo/using-bar", "/bar/simple". If this new ordering is
// sub-optimal (because it puts more-complicated tests before simpler ones,
// making it harder to figure out exactly what has failed), you can fix it by
// changing the test paths to group tests by suite in a way that will result in
// the desired running order. Eg, "/simple/foo", "/simple/bar",
// "/complex/foo-using-bar".
//
// However, you should never make the actual result of a test depend on the
// order that tests are run in. If you need to ensure that some particular code
// runs before or after a given test case, use g_test_add(), which lets you
// specify setup and teardown functions.
//
// If all tests are skipped or marked as incomplete (expected failures), this
// function will return 0 if producing TAP output, or 77 (treated as "skip test"
// by Automake) otherwise.
func TestRun() int {

	ret := C.g_test_run()

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// TestRunSuite: execute the tests within @suite and all nested Suites. The test
// suites to be executed are filtered according to test path arguments (`-p
// testpath` and `-s testpath`) as parsed by g_test_init(). See the g_test_run()
// documentation for more information on the order that tests are run in.
//
// g_test_run_suite() or g_test_run() may only be called once in a program.
func TestRunSuite(suite *TestSuite) int {
	var arg1 *C.GTestSuite

	arg1 = (*C.GTestSuite)(suite.Native())

	ret := C.g_test_run_suite(arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// TestSetNonfatalAssertions changes the behaviour of the various `g_assert_*()`
// macros, g_test_assert_expected_messages() and the various
// `g_test_trap_assert_*()` macros to not abort to program, but instead call
// g_test_fail() and continue. (This also changes the behavior of g_test_fail()
// so that it will not cause the test program to abort after completing the
// failed test.)
//
// Note that the g_assert_not_reached() and g_assert() macros are not affected
// by this.
//
// This function can only be called after g_test_init().
func TestSetNonfatalAssertions() {

	C.g_test_set_nonfatal_assertions()
}

// TestSkip indicates that a test was skipped.
//
// Calling this function will not stop the test from running, you need to return
// from the test function yourself. So you can produce additional diagnostic
// messages or even continue running the test.
//
// If not called from inside a test, this function does nothing.
func TestSkip(msg string) {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(msg))
	defer C.free(unsafe.Pointer(arg1))

	C.g_test_skip(arg1)
}

// TestSubprocess returns true (after g_test_init() has been called) if the test
// program is running under g_test_trap_subprocess().
func TestSubprocess() bool {

	ret := C.g_test_subprocess()

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// TestSummary: set the summary for a test, which describes what the test
// checks, and how it goes about checking it. This may be included in test
// report output, and is useful documentation for anyone reading the source code
// or modifying a test in future. It must be a single line.
//
// This should be called at the top of a test function.
//
// For example:
//
//    static void
//    test_array_sort (void)
//    {
//      g_test_summary ("Test my_array_sort() sorts the array correctly and stably, "
//                      "including testing zero length and one-element arrays.");
//
//      …
//    }
func TestSummary(summary string) {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(summary))
	defer C.free(unsafe.Pointer(arg1))

	C.g_test_summary(arg1)
}

// TestTimerElapsed: get the time since the last start of the timer with
// g_test_timer_start().
func TestTimerElapsed() float64 {

	ret := C.g_test_timer_elapsed()

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// TestTimerLast: report the last result of g_test_timer_elapsed().
func TestTimerLast() float64 {

	ret := C.g_test_timer_last()

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// TestTimerStart: start a timing test. Call g_test_timer_elapsed() when the
// task is supposed to be done. Call this function again to restart the timer.
func TestTimerStart() {

	C.g_test_timer_start()
}

func TestTrapAssertions(domain string, file string, line int, fn string, assertionFlags uint64, pattern string) {
	var arg1 *C.char
	var arg2 *C.char
	var arg3 C.int
	var arg4 *C.char
	var arg5 C.guint64
	var arg6 *C.char

	arg1 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(file))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.int(line)
	arg4 = (*C.gchar)(C.CString(fn))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = C.guint64(assertionFlags)
	arg6 = (*C.gchar)(C.CString(pattern))
	defer C.free(unsafe.Pointer(arg6))

	C.g_test_trap_assertions(arg1, arg2, arg3, arg4, arg5, arg6)
}

// TestTrapFork: fork the current test program to execute a test case that might
// not return or that might abort.
//
// If @usec_timeout is non-0, the forked test case is aborted and considered
// failing if its run time exceeds it.
//
// The forking behavior can be configured with the TrapFlags flags.
//
// In the following example, the test code forks, the forked child process
// produces some sample output and exits successfully. The forking parent
// process then asserts successful child program termination and validates child
// program outputs.
//
//    static void
//    test_fork_patterns (void)
//    {
//      if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDOUT | G_TEST_TRAP_SILENCE_STDERR))
//        {
//          g_print ("some stdout text: somagic17\n");
//          g_printerr ("some stderr text: semagic43\n");
//          exit (0); // successful test run
//        }
//      g_test_trap_assert_passed ();
//      g_test_trap_assert_stdout ("*somagic17*");
//      g_test_trap_assert_stderr ("*semagic43*");
//    }
func TestTrapFork(usecTimeout uint64, testTrapFlags TestTrapFlags) bool {
	var arg1 C.guint64
	var arg2 C.GTestTrapFlags

	arg1 = C.guint64(usecTimeout)
	arg2 = (C.GTestTrapFlags)(testTrapFlags)

	ret := C.g_test_trap_fork(arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// TestTrapHasPassed: check the result of the last g_test_trap_subprocess()
// call.
func TestTrapHasPassed() bool {

	ret := C.g_test_trap_has_passed()

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// TestTrapReachedTimeout: check the result of the last g_test_trap_subprocess()
// call.
func TestTrapReachedTimeout() bool {

	ret := C.g_test_trap_reached_timeout()

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// TestTrapSubprocess respawns the test program to run only @test_path in a
// subprocess. This can be used for a test case that might not return, or that
// might abort.
//
// If @test_path is nil then the same test is re-run in a subprocess. You can
// use g_test_subprocess() to determine whether the test is in a subprocess or
// not.
//
// @test_path can also be the name of the parent test, followed by
// "`/subprocess/`" and then a name for the specific subtest (or just ending
// with "`/subprocess`" if the test only has one child test); tests with names
// of this form will automatically be skipped in the parent process.
//
// If @usec_timeout is non-0, the test subprocess is aborted and considered
// failing if its run time exceeds it.
//
// The subprocess behavior can be configured with the SubprocessFlags flags.
//
// You can use methods such as g_test_trap_assert_passed(),
// g_test_trap_assert_failed(), and g_test_trap_assert_stderr() to check the
// results of the subprocess. (But note that g_test_trap_assert_stdout() and
// g_test_trap_assert_stderr() cannot be used if @test_flags specifies that the
// child should inherit the parent stdout/stderr.)
//
// If your `main ()` needs to behave differently in the subprocess, you can call
// g_test_subprocess() (after calling g_test_init()) to see whether you are in a
// subprocess.
//
// The following example tests that calling `my_object_new(1000000)` will abort
// with an error message.
//
//      static void
//      test_create_large_object (void)
//      {
//        if (g_test_subprocess ())
//          {
//            my_object_new (1000000);
//            return;
//          }
//
//        // Reruns this same test in a subprocess
//        g_test_trap_subprocess (NULL, 0, 0);
//        g_test_trap_assert_failed ();
//        g_test_trap_assert_stderr ("*ERROR*too large*");
//      }
//
//      int
//      main (int argc, char **argv)
//      {
//        g_test_init (&argc, &argv, NULL);
//
//        g_test_add_func ("/myobject/create_large_object",
//                         test_create_large_object);
//        return g_test_run ();
//      }
func TestTrapSubprocess(testPath string, usecTimeout uint64, testFlags TestSubprocessFlags) {
	var arg1 *C.char
	var arg2 C.guint64
	var arg3 C.GTestSubprocessFlags

	arg1 = (*C.gchar)(C.CString(testPath))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.guint64(usecTimeout)
	arg3 = (C.GTestSubprocessFlags)(testFlags)

	C.g_test_trap_subprocess(arg1, arg2, arg3)
}

func ThreadErrorQuark() Quark {

	ret := C.g_thread_error_quark()

	var ret0 Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = Quark(tmp)
	}

	return ret0
}

// ThreadExit terminates the current thread.
//
// If another thread is waiting for us using g_thread_join() then the waiting
// thread will be woken up and get @retval as the return value of
// g_thread_join().
//
// Calling g_thread_exit() with a parameter @retval is equivalent to returning
// @retval from the function @func, as given to g_thread_new().
//
// You must only call g_thread_exit() from a thread that you created yourself
// with g_thread_new() or related APIs. You must not call this function from a
// thread created with another threading library or or from within a Pool.
func ThreadExit(retval interface{}) {
	var arg1 C.gpointer

	arg1 = C.gpointer(box.Assign(retval))

	C.g_thread_exit(arg1)
}

// ThreadPoolGetMaxIdleTime: this function will return the maximum @interval
// that a thread will wait in the thread pool for new tasks before being
// stopped.
//
// If this function returns 0, threads waiting in the thread pool for new work
// are not stopped.
func ThreadPoolGetMaxIdleTime() uint {

	ret := C.g_thread_pool_get_max_idle_time()

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// ThreadPoolGetMaxUnusedThreads returns the maximal allowed number of unused
// threads.
func ThreadPoolGetMaxUnusedThreads() int {

	ret := C.g_thread_pool_get_max_unused_threads()

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ThreadPoolGetNumUnusedThreads returns the number of currently unused threads.
func ThreadPoolGetNumUnusedThreads() uint {

	ret := C.g_thread_pool_get_num_unused_threads()

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// ThreadPoolSetMaxIdleTime: this function will set the maximum @interval that a
// thread waiting in the pool for new tasks can be idle for before being
// stopped. This function is similar to calling
// g_thread_pool_stop_unused_threads() on a regular timeout, except this is done
// on a per thread basis.
//
// By setting @interval to 0, idle threads will not be stopped.
//
// The default value is 15000 (15 seconds).
func ThreadPoolSetMaxIdleTime(interval uint) {
	var arg1 C.guint

	arg1 = C.guint(interval)

	C.g_thread_pool_set_max_idle_time(arg1)
}

// ThreadPoolSetMaxUnusedThreads sets the maximal number of unused threads to
// @max_threads. If @max_threads is -1, no limit is imposed on the number of
// unused threads.
//
// The default value is 2.
func ThreadPoolSetMaxUnusedThreads(maxThreads int) {
	var arg1 C.gint

	arg1 = C.gint(maxThreads)

	C.g_thread_pool_set_max_unused_threads(arg1)
}

// ThreadPoolStopUnusedThreads stops all currently unused threads. This does not
// change the maximal number of unused threads. This function can be used to
// regularly stop all unused threads e.g. from g_timeout_add().
func ThreadPoolStopUnusedThreads() {

	C.g_thread_pool_stop_unused_threads()
}

// ThreadSelf: this function returns the #GThread corresponding to the current
// thread. Note that this function does not increase the reference count of the
// returned struct.
//
// This function will return a #GThread even for threads that were not created
// by GLib (i.e. those created by other threading APIs). This may be useful for
// thread identification purposes (i.e. comparisons) but you must not use GLib
// functions (such as g_thread_join()) on these threads.
func ThreadSelf() *Thread {

	ret := C.g_thread_self()

	var ret0 *Thread

	{
		ret0 = WrapThread(unsafe.Pointer(ret))
	}

	return ret0
}

// ThreadYield causes the calling thread to voluntarily relinquish the CPU, so
// that other threads can run.
//
// This function is often used as a method to make busy wait less evil.
func ThreadYield() {

	C.g_thread_yield()
}

// TimeValFromIso8601 converts a string containing an ISO 8601 encoded date and
// time to a Val and puts it into @time_.
//
// @iso_date must include year, month, day, hours, minutes, and seconds. It can
// optionally include fractions of a second and a time zone indicator. (In the
// absence of any time zone indication, the timestamp is assumed to be in local
// time.)
//
// Any leading or trailing space in @iso_date is ignored.
//
// This function was deprecated, along with Val itself, in GLib 2.62. Equivalent
// functionality is available using code like:
//
//    GDateTime *dt = g_date_time_new_from_iso8601 (iso8601_string, NULL);
//    gint64 time_val = g_date_time_to_unix (dt);
//    g_date_time_unref (dt);
func TimeValFromIso8601(isoDate string) (time_ TimeVal, ok bool) {
	var arg1 *C.gchar
	var arg2 *C.GTimeVal // out

	arg1 = (*C.gchar)(C.CString(isoDate))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_time_val_from_iso8601(arg1, &arg2)

	var ret0 *TimeVal
	var ret1 bool

	{
		ret0 = WrapTimeVal(unsafe.Pointer(arg2))
	}

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// TimeoutAddFull sets a function to be called at regular intervals, with the
// given priority. The function is called repeatedly until it returns false, at
// which point the timeout is automatically destroyed and the function will not
// be called again. The @notify function is called when the timeout is
// destroyed. The first call to the function will be at the end of the first
// @interval.
//
// Note that timeout functions may be delayed, due to the processing of other
// event sources. Thus they should not be relied on for precise timing. After
// each call to the timeout function, the time of the next timeout is
// recalculated based on the current time and the given interval (it does not
// try to 'catch up' time lost in delays).
//
// See [memory management of sources][mainloop-memory-management] for details on
// how to handle the return value and memory management of @data.
//
// This internally creates a main loop source using g_timeout_source_new() and
// attaches it to the global Context using g_source_attach(), so the callback
// will be invoked in whichever thread is running that main context. You can do
// these steps manually if you need greater control or to use a custom main
// context.
//
// The interval given is in terms of monotonic time, not wall clock time. See
// g_get_monotonic_time().
func TimeoutAddFull(priority int, interval uint, function SourceFunc) uint {
	var arg1 C.gint
	var arg2 C.guint
	var arg3 C.GSourceFunc
	var arg4 C.gpointer
	var arg5 C.GDestroyNotify

	arg1 = C.gint(priority)
	arg2 = C.guint(interval)
	arg3 = (*[0]byte)(C.gotk4_SourceFunc)
	arg4 = C.gpointer(box.Assign(function))
	arg5 = (*[0]byte)(C.callbackDelete)

	ret := C.g_timeout_add_full(arg1, arg2, arg3, arg4, arg5)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// TimeoutAddSecondsFull sets a function to be called at regular intervals, with
// @priority. The function is called repeatedly until it returns false, at which
// point the timeout is automatically destroyed and the function will not be
// called again.
//
// Unlike g_timeout_add(), this function operates at whole second granularity.
// The initial starting point of the timer is determined by the implementation
// and the implementation is expected to group multiple timers together so that
// they fire all at the same time. To allow this grouping, the @interval to the
// first timer is rounded and can deviate up to one second from the specified
// interval. Subsequent timer iterations will generally run at the specified
// interval.
//
// Note that timeout functions may be delayed, due to the processing of other
// event sources. Thus they should not be relied on for precise timing. After
// each call to the timeout function, the time of the next timeout is
// recalculated based on the current time and the given @interval
//
// See [memory management of sources][mainloop-memory-management] for details on
// how to handle the return value and memory management of @data.
//
// If you want timing more precise than whole seconds, use g_timeout_add()
// instead.
//
// The grouping of timers to fire at the same time results in a more power and
// CPU efficient behavior so if your timer is in multiples of seconds and you
// don't require the first timer exactly one second from now, the use of
// g_timeout_add_seconds() is preferred over g_timeout_add().
//
// This internally creates a main loop source using
// g_timeout_source_new_seconds() and attaches it to the main loop context using
// g_source_attach(). You can do these steps manually if you need greater
// control.
//
// It is safe to call this function from any thread.
//
// The interval given is in terms of monotonic time, not wall clock time. See
// g_get_monotonic_time().
func TimeoutAddSecondsFull(priority int, interval uint, function SourceFunc) uint {
	var arg1 C.gint
	var arg2 C.guint
	var arg3 C.GSourceFunc
	var arg4 C.gpointer
	var arg5 C.GDestroyNotify

	arg1 = C.gint(priority)
	arg2 = C.guint(interval)
	arg3 = (*[0]byte)(C.gotk4_SourceFunc)
	arg4 = C.gpointer(box.Assign(function))
	arg5 = (*[0]byte)(C.callbackDelete)

	ret := C.g_timeout_add_seconds_full(arg1, arg2, arg3, arg4, arg5)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// NewTimeoutSource creates a new timeout source.
//
// The source will not initially be associated with any Context and must be
// added to one with g_source_attach() before it will be executed.
//
// The interval given is in terms of monotonic time, not wall clock time. See
// g_get_monotonic_time().
func NewTimeoutSource(interval uint) *Source {
	var arg1 C.guint

	arg1 = C.guint(interval)

	ret := C.g_timeout_source_new(arg1)

	var ret0 *Source

	{
		ret0 = WrapSource(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Source) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// TimeoutSourceNewSeconds creates a new timeout source.
//
// The source will not initially be associated with any Context and must be
// added to one with g_source_attach() before it will be executed.
//
// The scheduling granularity/accuracy of this timeout source will be in
// seconds.
//
// The interval given is in terms of monotonic time, not wall clock time. See
// g_get_monotonic_time().
func TimeoutSourceNewSeconds(interval uint) *Source {
	var arg1 C.guint

	arg1 = C.guint(interval)

	ret := C.g_timeout_source_new_seconds(arg1)

	var ret0 *Source

	{
		ret0 = WrapSource(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Source) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// TrashStackHeight returns the height of a Stack.
//
// Note that execution of this function is of O(N) complexity where N denotes
// the number of items on the stack.
func TrashStackHeight(stackP **TrashStack) uint {
	var arg1 **C.GTrashStack

	arg1 = (**C.GTrashStack)(stackP.Native())

	ret := C.g_trash_stack_height(arg1)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// TrashStackPeek returns the element at the top of a Stack which may be nil.
func TrashStackPeek(stackP **TrashStack) interface{} {
	var arg1 **C.GTrashStack

	arg1 = (**C.GTrashStack)(stackP.Native())

	ret := C.g_trash_stack_peek(arg1)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// TrashStackPop pops a piece of memory off a Stack.
func TrashStackPop(stackP **TrashStack) interface{} {
	var arg1 **C.GTrashStack

	arg1 = (**C.GTrashStack)(stackP.Native())

	ret := C.g_trash_stack_pop(arg1)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// TrashStackPush pushes a piece of memory onto a Stack.
func TrashStackPush(stackP **TrashStack, dataP interface{}) {
	var arg1 **C.GTrashStack
	var arg2 C.gpointer

	arg1 = (**C.GTrashStack)(stackP.Native())
	arg2 = C.gpointer(box.Assign(dataP))

	C.g_trash_stack_push(arg1, arg2)
}

// TryMalloc attempts to allocate @n_bytes, and returns nil on failure. Contrast
// with g_malloc(), which aborts the program on failure.
func TryMalloc(nBytes uint) interface{} {
	var arg1 C.gsize

	arg1 = C.gsize(nBytes)

	ret := C.g_try_malloc(arg1)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// TryMalloc0 attempts to allocate @n_bytes, initialized to 0's, and returns nil
// on failure. Contrast with g_malloc0(), which aborts the program on failure.
func TryMalloc0(nBytes uint) interface{} {
	var arg1 C.gsize

	arg1 = C.gsize(nBytes)

	ret := C.g_try_malloc0(arg1)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// TryMalloc0N: this function is similar to g_try_malloc0(), allocating
// (@n_blocks * @n_block_bytes) bytes, but care is taken to detect possible
// overflow during multiplication.
func TryMalloc0N(nBlocks uint, nBlockBytes uint) interface{} {
	var arg1 C.gsize
	var arg2 C.gsize

	arg1 = C.gsize(nBlocks)
	arg2 = C.gsize(nBlockBytes)

	ret := C.g_try_malloc0_n(arg1, arg2)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// TryMallocN: this function is similar to g_try_malloc(), allocating (@n_blocks
// * @n_block_bytes) bytes, but care is taken to detect possible overflow during
// multiplication.
func TryMallocN(nBlocks uint, nBlockBytes uint) interface{} {
	var arg1 C.gsize
	var arg2 C.gsize

	arg1 = C.gsize(nBlocks)
	arg2 = C.gsize(nBlockBytes)

	ret := C.g_try_malloc_n(arg1, arg2)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// TryRealloc attempts to realloc @mem to a new size, @n_bytes, and returns nil
// on failure. Contrast with g_realloc(), which aborts the program on failure.
//
// If @mem is nil, behaves the same as g_try_malloc().
func TryRealloc(mem interface{}, nBytes uint) interface{} {
	var arg1 C.gpointer
	var arg2 C.gsize

	arg1 = C.gpointer(box.Assign(mem))
	arg2 = C.gsize(nBytes)

	ret := C.g_try_realloc(arg1, arg2)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// TryReallocN: this function is similar to g_try_realloc(), allocating
// (@n_blocks * @n_block_bytes) bytes, but care is taken to detect possible
// overflow during multiplication.
func TryReallocN(mem interface{}, nBlocks uint, nBlockBytes uint) interface{} {
	var arg1 C.gpointer
	var arg2 C.gsize
	var arg3 C.gsize

	arg1 = C.gpointer(box.Assign(mem))
	arg2 = C.gsize(nBlocks)
	arg3 = C.gsize(nBlockBytes)

	ret := C.g_try_realloc_n(arg1, arg2, arg3)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// Ucs4ToUTF16: convert a string from UCS-4 to UTF-16. A 0 character will be
// added to the result after the converted text.
func Ucs4ToUTF16(str uint32, len int32) (itemsRead int32, itemsWritten int32, guint16 uint16, err error) {
	var arg1 *C.gunichar
	var arg2 C.glong
	var arg3 *C.glong // out
	var arg4 *C.glong // out
	var gError *C.GError

	arg1 = (*C.gunichar)(str)
	arg2 = C.glong(len)

	ret := C.g_ucs4_to_utf16(arg1, arg2, &arg3, &arg4, &gError)

	var ret0 int32
	var ret1 int32
	var ret2 uint16
	var goError error

	ret0 = int32(arg3)

	ret1 = int32(arg4)

	ret2 = uint16(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}

// Ucs4ToUTF8: convert a string from a 32-bit fixed width representation as
// UCS-4. to UTF-8. The result will be terminated with a 0 byte.
func Ucs4ToUTF8(str uint32, len int32) (itemsRead int32, itemsWritten int32, utf8 string, err error) {
	var arg1 *C.gunichar
	var arg2 C.glong
	var arg3 *C.glong // out
	var arg4 *C.glong // out
	var gError *C.GError

	arg1 = (*C.gunichar)(str)
	arg2 = C.glong(len)

	ret := C.g_ucs4_to_utf8(arg1, arg2, &arg3, &arg4, &gError)

	var ret0 int32
	var ret1 int32
	var ret2 string
	var goError error

	ret0 = int32(arg3)

	ret1 = int32(arg4)

	ret2 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}

// UnicharBreakType determines the break type of @c. @c should be a Unicode
// character (to derive a character from UTF-8 encoded text, use
// g_utf8_get_char()). The break type is used to find word and line breaks
// ("text boundaries"), Pango implements the Unicode boundary resolution
// algorithms and normally you would use a function such as pango_break()
// instead of caring about break types yourself.
func UnicharBreakType(c uint32) UnicodeBreakType {
	var arg1 C.gunichar

	arg1 = C.gunichar(c)

	ret := C.g_unichar_break_type(arg1)

	var ret0 UnicodeBreakType

	ret0 = UnicodeBreakType(ret)

	return ret0
}

// UnicharCombiningClass determines the canonical combining class of a Unicode
// character.
func UnicharCombiningClass(uc uint32) int {
	var arg1 C.gunichar

	arg1 = C.gunichar(uc)

	ret := C.g_unichar_combining_class(arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// UnicharCompose performs a single composition step of the Unicode canonical
// composition algorithm.
//
// This function includes algorithmic Hangul Jamo composition, but it is not
// exactly the inverse of g_unichar_decompose(). No composition can have either
// of @a or @b equal to zero. To be precise, this function composes if and only
// if there exists a Primary Composite P which is canonically equivalent to the
// sequence <@a,@b>. See the Unicode Standard for the definition of Primary
// Composite.
//
// If @a and @b do not compose a new character, @ch is set to zero.
//
// See UAX#15 (http://unicode.org/reports/tr15/) for details.
func UnicharCompose(a uint32, b uint32) (ch uint32, ok bool) {
	var arg1 C.gunichar
	var arg2 C.gunichar
	var arg3 *C.gunichar // out

	arg1 = C.gunichar(a)
	arg2 = C.gunichar(b)

	ret := C.g_unichar_compose(arg1, arg2, &arg3)

	var ret0 uint32
	var ret1 bool

	ret0 = uint32(arg3)

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// UnicharDecompose performs a single decomposition step of the Unicode
// canonical decomposition algorithm.
//
// This function does not include compatibility decompositions. It does,
// however, include algorithmic Hangul Jamo decomposition, as well as
// 'singleton' decompositions which replace a character by a single other
// character. In the case of singletons *@b will be set to zero.
//
// If @ch is not decomposable, *@a is set to @ch and *@b is set to zero.
//
// Note that the way Unicode decomposition pairs are defined, it is guaranteed
// that @b would not decompose further, but @a may itself decompose. To get the
// full canonical decomposition for @ch, one would need to recursively call this
// function on @a. Or use g_unichar_fully_decompose().
//
// See UAX#15 (http://unicode.org/reports/tr15/) for details.
func UnicharDecompose(ch uint32) (a uint32, b uint32, ok bool) {
	var arg1 C.gunichar
	var arg2 *C.gunichar // out
	var arg3 *C.gunichar // out

	arg1 = C.gunichar(ch)

	ret := C.g_unichar_decompose(arg1, &arg2, &arg3)

	var ret0 uint32
	var ret1 uint32
	var ret2 bool

	ret0 = uint32(arg2)

	ret1 = uint32(arg3)

	ret2 = C.BOOL(ret) != 0

	return ret0, ret1, ret2
}

// UnicharDigitValue determines the numeric value of a character as a decimal
// digit.
func UnicharDigitValue(c uint32) int {
	var arg1 C.gunichar

	arg1 = C.gunichar(c)

	ret := C.g_unichar_digit_value(arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// UnicharFullyDecompose computes the canonical or compatibility decomposition
// of a Unicode character. For compatibility decomposition, pass true for
// @compat; for canonical decomposition pass false for @compat.
//
// The decomposed sequence is placed in @result. Only up to @result_len
// characters are written into @result. The length of the full decomposition
// (irrespective of @result_len) is returned by the function. For canonical
// decomposition, currently all decompositions are of length at most 4, but this
// may change in the future (very unlikely though). At any rate, Unicode does
// guarantee that a buffer of length 18 is always enough for both compatibility
// and canonical decompositions, so that is the size recommended. This is
// provided as G_UNICHAR_MAX_DECOMPOSITION_LENGTH.
//
// See UAX#15 (http://unicode.org/reports/tr15/) for details.
func UnicharFullyDecompose(ch uint32, compat bool, resultLen uint) (result uint32, gsize uint) {
	var arg1 C.gunichar
	var arg2 C.gboolean
	var arg3 *C.gunichar // out
	var arg4 C.gsize

	arg1 = C.gunichar(ch)
	if compat {
		arg2 = C.TRUE
	}
	arg4 = C.gsize(resultLen)

	ret := C.g_unichar_fully_decompose(arg1, arg2, &arg3, arg4)

	var ret0 uint32
	var ret1 uint

	ret0 = uint32(arg3)

	ret1 = uint(ret)

	return ret0, ret1
}

// UnicharGetMirrorChar: in Unicode, some characters are "mirrored". This means
// that their images are mirrored horizontally in text that is laid out from
// right to left. For instance, "(" would become its mirror image, ")", in
// right-to-left text.
//
// If @ch has the Unicode mirrored property and there is another unicode
// character that typically has a glyph that is the mirror image of @ch's glyph
// and @mirrored_ch is set, it puts that character in the address pointed to by
// @mirrored_ch. Otherwise the original character is put.
func UnicharGetMirrorChar(ch uint32, mirroredCh uint32) bool {
	var arg1 C.gunichar
	var arg2 *C.gunichar

	arg1 = C.gunichar(ch)
	arg2 = (*C.gunichar)(mirroredCh)

	ret := C.g_unichar_get_mirror_char(arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// UnicharGetScript looks up the Script for a particular character (as defined
// by Unicode Standard Annex \#24). No check is made for @ch being a valid
// Unicode character; if you pass in invalid character, the result is undefined.
//
// This function is equivalent to pango_script_for_unichar() and the two are
// interchangeable.
func UnicharGetScript(ch uint32) UnicodeScript {
	var arg1 C.gunichar

	arg1 = C.gunichar(ch)

	ret := C.g_unichar_get_script(arg1)

	var ret0 UnicodeScript

	ret0 = UnicodeScript(ret)

	return ret0
}

// UnicharIsalnum determines whether a character is alphanumeric. Given some
// UTF-8 text, obtain a character value with g_utf8_get_char().
func UnicharIsalnum(c uint32) bool {
	var arg1 C.gunichar

	arg1 = C.gunichar(c)

	ret := C.g_unichar_isalnum(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// UnicharIsalpha determines whether a character is alphabetic (i.e. a letter).
// Given some UTF-8 text, obtain a character value with g_utf8_get_char().
func UnicharIsalpha(c uint32) bool {
	var arg1 C.gunichar

	arg1 = C.gunichar(c)

	ret := C.g_unichar_isalpha(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// UnicharIscntrl determines whether a character is a control character. Given
// some UTF-8 text, obtain a character value with g_utf8_get_char().
func UnicharIscntrl(c uint32) bool {
	var arg1 C.gunichar

	arg1 = C.gunichar(c)

	ret := C.g_unichar_iscntrl(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// UnicharIsdefined determines if a given character is assigned in the Unicode
// standard.
func UnicharIsdefined(c uint32) bool {
	var arg1 C.gunichar

	arg1 = C.gunichar(c)

	ret := C.g_unichar_isdefined(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// UnicharIsdigit determines whether a character is numeric (i.e. a digit). This
// covers ASCII 0-9 and also digits in other languages/scripts. Given some UTF-8
// text, obtain a character value with g_utf8_get_char().
func UnicharIsdigit(c uint32) bool {
	var arg1 C.gunichar

	arg1 = C.gunichar(c)

	ret := C.g_unichar_isdigit(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// UnicharIsgraph determines whether a character is printable and not a space
// (returns false for control characters, format characters, and spaces).
// g_unichar_isprint() is similar, but returns true for spaces. Given some UTF-8
// text, obtain a character value with g_utf8_get_char().
func UnicharIsgraph(c uint32) bool {
	var arg1 C.gunichar

	arg1 = C.gunichar(c)

	ret := C.g_unichar_isgraph(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// UnicharIslower determines whether a character is a lowercase letter. Given
// some UTF-8 text, obtain a character value with g_utf8_get_char().
func UnicharIslower(c uint32) bool {
	var arg1 C.gunichar

	arg1 = C.gunichar(c)

	ret := C.g_unichar_islower(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// UnicharIsmark determines whether a character is a mark (non-spacing mark,
// combining mark, or enclosing mark in Unicode speak). Given some UTF-8 text,
// obtain a character value with g_utf8_get_char().
//
// Note: in most cases where isalpha characters are allowed, ismark characters
// should be allowed to as they are essential for writing most European
// languages as well as many non-Latin scripts.
func UnicharIsmark(c uint32) bool {
	var arg1 C.gunichar

	arg1 = C.gunichar(c)

	ret := C.g_unichar_ismark(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// UnicharIsprint determines whether a character is printable. Unlike
// g_unichar_isgraph(), returns true for spaces. Given some UTF-8 text, obtain a
// character value with g_utf8_get_char().
func UnicharIsprint(c uint32) bool {
	var arg1 C.gunichar

	arg1 = C.gunichar(c)

	ret := C.g_unichar_isprint(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// UnicharIspunct determines whether a character is punctuation or a symbol.
// Given some UTF-8 text, obtain a character value with g_utf8_get_char().
func UnicharIspunct(c uint32) bool {
	var arg1 C.gunichar

	arg1 = C.gunichar(c)

	ret := C.g_unichar_ispunct(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// UnicharIsspace determines whether a character is a space, tab, or line
// separator (newline, carriage return, etc.). Given some UTF-8 text, obtain a
// character value with g_utf8_get_char().
//
// (Note: don't use this to do word breaking; you have to use Pango or
// equivalent to get word breaking right, the algorithm is fairly complex.)
func UnicharIsspace(c uint32) bool {
	var arg1 C.gunichar

	arg1 = C.gunichar(c)

	ret := C.g_unichar_isspace(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// UnicharIstitle determines if a character is titlecase. Some characters in
// Unicode which are composites, such as the DZ digraph have three case variants
// instead of just two. The titlecase form is used at the beginning of a word
// where only the first letter is capitalized. The titlecase form of the DZ
// digraph is U+01F2 LATIN CAPITAL LETTTER D WITH SMALL LETTER Z.
func UnicharIstitle(c uint32) bool {
	var arg1 C.gunichar

	arg1 = C.gunichar(c)

	ret := C.g_unichar_istitle(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// UnicharIsupper determines if a character is uppercase.
func UnicharIsupper(c uint32) bool {
	var arg1 C.gunichar

	arg1 = C.gunichar(c)

	ret := C.g_unichar_isupper(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// UnicharIswide determines if a character is typically rendered in a
// double-width cell.
func UnicharIswide(c uint32) bool {
	var arg1 C.gunichar

	arg1 = C.gunichar(c)

	ret := C.g_unichar_iswide(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// UnicharIswideCjk determines if a character is typically rendered in a
// double-width cell under legacy East Asian locales. If a character is wide
// according to g_unichar_iswide(), then it is also reported wide with this
// function, but the converse is not necessarily true. See the Unicode Standard
// Annex #11 (http://www.unicode.org/reports/tr11/) for details.
//
// If a character passes the g_unichar_iswide() test then it will also pass this
// test, but not the other way around. Note that some characters may pass both
// this test and g_unichar_iszerowidth().
func UnicharIswideCjk(c uint32) bool {
	var arg1 C.gunichar

	arg1 = C.gunichar(c)

	ret := C.g_unichar_iswide_cjk(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// UnicharIsxdigit determines if a character is a hexadecimal digit.
func UnicharIsxdigit(c uint32) bool {
	var arg1 C.gunichar

	arg1 = C.gunichar(c)

	ret := C.g_unichar_isxdigit(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// UnicharIszerowidth determines if a given character typically takes zero width
// when rendered. The return value is true for all non-spacing and enclosing
// marks (e.g., combining accents), format characters, zero-width space, but not
// U+00AD SOFT HYPHEN.
//
// A typical use of this function is with one of g_unichar_iswide() or
// g_unichar_iswide_cjk() to determine the number of cells a string occupies
// when displayed on a grid display (terminals). However, note that not all
// terminals support zero-width rendering of zero-width marks.
func UnicharIszerowidth(c uint32) bool {
	var arg1 C.gunichar

	arg1 = C.gunichar(c)

	ret := C.g_unichar_iszerowidth(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// UnicharToUTF8 converts a single character to UTF-8.
func UnicharToUTF8(c uint32) (outbuf string, gint int) {
	var arg1 C.gunichar
	var arg2 *C.gchar // out

	arg1 = C.gunichar(c)

	ret := C.g_unichar_to_utf8(arg1, &arg2)

	var ret0 string
	var ret1 int

	ret0 = C.GoString(arg2)

	ret1 = int(ret)

	return ret0, ret1
}

// UnicharToLower converts a character to lower case.
func UnicharToLower(c uint32) uint32 {
	var arg1 C.gunichar

	arg1 = C.gunichar(c)

	ret := C.g_unichar_tolower(arg1)

	var ret0 uint32

	ret0 = uint32(ret)

	return ret0
}

// UnicharTotitle converts a character to the titlecase.
func UnicharTotitle(c uint32) uint32 {
	var arg1 C.gunichar

	arg1 = C.gunichar(c)

	ret := C.g_unichar_totitle(arg1)

	var ret0 uint32

	ret0 = uint32(ret)

	return ret0
}

// UnicharToUpper converts a character to uppercase.
func UnicharToUpper(c uint32) uint32 {
	var arg1 C.gunichar

	arg1 = C.gunichar(c)

	ret := C.g_unichar_toupper(arg1)

	var ret0 uint32

	ret0 = uint32(ret)

	return ret0
}

// UnicharType classifies a Unicode character by type.
func UnicharType(c uint32) UnicodeType {
	var arg1 C.gunichar

	arg1 = C.gunichar(c)

	ret := C.g_unichar_type(arg1)

	var ret0 UnicodeType

	ret0 = UnicodeType(ret)

	return ret0
}

// UnicharValidate checks whether @ch is a valid Unicode character. Some
// possible integer values of @ch will not be valid. 0 is considered a valid
// character, though it's normally a string terminator.
func UnicharValidate(ch uint32) bool {
	var arg1 C.gunichar

	arg1 = C.gunichar(ch)

	ret := C.g_unichar_validate(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// UnicharXDigitValue determines the numeric value of a character as a
// hexadecimal digit.
func UnicharXDigitValue(c uint32) int {
	var arg1 C.gunichar

	arg1 = C.gunichar(c)

	ret := C.g_unichar_xdigit_value(arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// UnicodeCanonicalDecomposition computes the canonical decomposition of a
// Unicode character.
func UnicodeCanonicalDecomposition(ch uint32, resultLen uint) uint32 {
	var arg1 C.gunichar
	var arg2 *C.gsize

	arg1 = C.gunichar(ch)
	arg2 = (*C.gsize)(resultLen)

	ret := C.g_unicode_canonical_decomposition(arg1, arg2)

	var ret0 uint32

	ret0 = uint32(ret)

	return ret0
}

// UnicodeCanonicalOrdering computes the canonical ordering of a string
// in-place. This rearranges decomposed characters in the string according to
// their combining classes. See the Unicode manual for more information.
func UnicodeCanonicalOrdering(string uint32, len uint) {
	var arg1 *C.gunichar
	var arg2 C.gsize

	arg1 = (*C.gunichar)(string)
	arg2 = C.gsize(len)

	C.g_unicode_canonical_ordering(arg1, arg2)
}

// UnicodeScriptFromIso15924 looks up the Unicode script for @iso15924. ISO
// 15924 assigns four-letter codes to scripts. For example, the code for Arabic
// is 'Arab'. This function accepts four letter codes encoded as a @guint32 in a
// big-endian fashion. That is, the code expected for Arabic is 0x41726162 (0x41
// is ASCII code for 'A', 0x72 is ASCII code for 'r', etc).
//
// See Codes for the representation of names of scripts
// (http://unicode.org/iso15924/codelists.html) for details.
func UnicodeScriptFromIso15924(iso15924 uint32) UnicodeScript {
	var arg1 C.guint32

	arg1 = C.guint32(iso15924)

	ret := C.g_unicode_script_from_iso15924(arg1)

	var ret0 UnicodeScript

	ret0 = UnicodeScript(ret)

	return ret0
}

// UnicodeScriptToIso15924 looks up the ISO 15924 code for @script. ISO 15924
// assigns four-letter codes to scripts. For example, the code for Arabic is
// 'Arab'. The four letter codes are encoded as a @guint32 by this function in a
// big-endian fashion. That is, the code returned for Arabic is 0x41726162 (0x41
// is ASCII code for 'A', 0x72 is ASCII code for 'r', etc).
//
// See Codes for the representation of names of scripts
// (http://unicode.org/iso15924/codelists.html) for details.
func UnicodeScriptToIso15924(script UnicodeScript) uint32 {
	var arg1 C.GUnicodeScript

	arg1 = (C.GUnicodeScript)(script)

	ret := C.g_unicode_script_to_iso15924(arg1)

	var ret0 uint32

	ret0 = uint32(ret)

	return ret0
}

func UnixErrorQuark() Quark {

	ret := C.g_unix_error_quark()

	var ret0 Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = Quark(tmp)
	}

	return ret0
}

// UnixFdAdd sets a function to be called when the IO condition, as specified by
// @condition becomes true for @fd.
//
// @function will be called when the specified IO condition becomes true. The
// function is expected to clear whatever event caused the IO condition to
// become true and return true in order to be notified when it happens again. If
// @function returns false then the watch will be cancelled.
//
// The return value of this function can be passed to g_source_remove() to
// cancel the watch at any time that it exists.
//
// The source will never close the fd -- you must do it yourself.
func UnixFdAdd(fd int, condition IOCondition, function UnixFDSourceFunc) uint {
	var arg1 C.gint
	var arg2 C.GIOCondition
	var arg3 C.GUnixFDSourceFunc
	var arg4 C.gpointer

	arg1 = C.gint(fd)
	arg2 = (C.GIOCondition)(condition)
	arg3 = (*[0]byte)(C.gotk4_UnixFDSourceFunc)
	arg4 = C.gpointer(box.Assign(function))

	ret := C.g_unix_fd_add(arg1, arg2, arg3, arg4)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// UnixFdAddFull sets a function to be called when the IO condition, as
// specified by @condition becomes true for @fd.
//
// This is the same as g_unix_fd_add(), except that it allows you to specify a
// non-default priority and a provide a Notify for @user_data.
func UnixFdAddFull(priority int, fd int, condition IOCondition, function UnixFDSourceFunc) uint {
	var arg1 C.gint
	var arg2 C.gint
	var arg3 C.GIOCondition
	var arg4 C.GUnixFDSourceFunc
	var arg5 C.gpointer
	var arg6 C.GDestroyNotify

	arg1 = C.gint(priority)
	arg2 = C.gint(fd)
	arg3 = (C.GIOCondition)(condition)
	arg4 = (*[0]byte)(C.gotk4_UnixFDSourceFunc)
	arg5 = C.gpointer(box.Assign(function))
	arg6 = (*[0]byte)(C.callbackDelete)

	ret := C.g_unix_fd_add_full(arg1, arg2, arg3, arg4, arg5, arg6)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// NewUnixFdSource creates a #GSource to watch for a particular IO condition on
// a file descriptor.
//
// The source will never close the fd -- you must do it yourself.
func NewUnixFdSource(fd int, condition IOCondition) *Source {
	var arg1 C.gint
	var arg2 C.GIOCondition

	arg1 = C.gint(fd)
	arg2 = (C.GIOCondition)(condition)

	ret := C.g_unix_fd_source_new(arg1, arg2)

	var ret0 *Source

	{
		ret0 = WrapSource(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Source) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// UnixGetPasswdEntry: get the `passwd` file entry for the given @user_name
// using `getpwnam_r()`. This can fail if the given @user_name doesn’t exist.
//
// The returned `struct passwd` has been allocated using g_malloc() and should
// be freed using g_free(). The strings referenced by the returned struct are
// included in the same allocation, so are valid until the `struct passwd` is
// freed.
//
// This function is safe to call from multiple threads concurrently.
//
// You will need to include `pwd.h` to get the definition of `struct passwd`.
func UnixGetPasswdEntry(userName string) (gpointer interface{}, err error) {
	var arg1 *C.gchar
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(userName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_unix_get_passwd_entry(arg1, &gError)

	var ret0 interface{}
	var goError error

	ret0 = box.Get(uintptr(ret)).(interface{})

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// UnixOpenPipe: similar to the UNIX pipe() call, but on modern systems like
// Linux uses the pipe2() system call, which atomically creates a pipe with the
// configured flags. The only supported flag currently is FD_CLOEXEC. If for
// example you want to configure O_NONBLOCK, that must still be done separately
// with fcntl().
//
// This function does not take O_CLOEXEC, it takes FD_CLOEXEC as if for fcntl();
// these are different on Linux/glibc.
func UnixOpenPipe(fds int, flags int) error {
	var arg1 *C.gint
	var arg2 C.gint
	var gError *C.GError

	arg1 = (*C.gint)(fds)
	arg2 = C.gint(flags)

	ret := C.g_unix_open_pipe(arg1, arg2, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// UnixSetFdNonblocking: control the non-blocking state of the given file
// descriptor, according to @nonblock. On most systems this uses O_NONBLOCK, but
// on some older ones may use O_NDELAY.
func UnixSetFdNonblocking(fd int, nonblock bool) error {
	var arg1 C.gint
	var arg2 C.gboolean
	var gError *C.GError

	arg1 = C.gint(fd)
	if nonblock {
		arg2 = C.TRUE
	}

	ret := C.g_unix_set_fd_nonblocking(arg1, arg2, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// UnixSignalAddFull: a convenience function for g_unix_signal_source_new(),
// which attaches to the default Context. You can remove the watch using
// g_source_remove().
func UnixSignalAddFull(priority int, signum int, handler SourceFunc) uint {
	var arg1 C.gint
	var arg2 C.gint
	var arg3 C.GSourceFunc
	var arg4 C.gpointer
	var arg5 C.GDestroyNotify

	arg1 = C.gint(priority)
	arg2 = C.gint(signum)
	arg3 = (*[0]byte)(C.gotk4_SourceFunc)
	arg4 = C.gpointer(box.Assign(handler))
	arg5 = (*[0]byte)(C.callbackDelete)

	ret := C.g_unix_signal_add_full(arg1, arg2, arg3, arg4, arg5)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// NewUnixSignalSource: create a #GSource that will be dispatched upon delivery
// of the UNIX signal @signum. In GLib versions before 2.36, only `SIGHUP`,
// `SIGINT`, `SIGTERM` can be monitored. In GLib 2.36, `SIGUSR1` and `SIGUSR2`
// were added. In GLib 2.54, `SIGWINCH` was added.
//
// Note that unlike the UNIX default, all sources which have created a watch
// will be dispatched, regardless of which underlying thread invoked
// g_unix_signal_source_new().
//
// For example, an effective use of this function is to handle `SIGTERM`
// cleanly; flushing any outstanding files, and then calling g_main_loop_quit
// (). It is not safe to do any of this a regular UNIX signal handler; your
// handler may be invoked while malloc() or another library function is running,
// causing reentrancy if you attempt to use it from the handler. None of the
// GLib/GObject API is safe against this kind of reentrancy.
//
// The interaction of this source when combined with native UNIX functions like
// sigprocmask() is not defined.
//
// The source will not initially be associated with any Context and must be
// added to one with g_source_attach() before it will be executed.
func NewUnixSignalSource(signum int) *Source {
	var arg1 C.gint

	arg1 = C.gint(signum)

	ret := C.g_unix_signal_source_new(arg1)

	var ret0 *Source

	{
		ret0 = WrapSource(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Source) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Unlink: a wrapper for the POSIX unlink() function. The unlink() function
// deletes a name from the filesystem. If this was the last link to the file and
// no processes have it opened, the diskspace occupied by the file is freed.
//
// See your C library manual for more details about unlink(). Note that on
// Windows, it is in general not possible to delete files that are open to some
// process, or mapped into memory.
func Unlink(filename string) int {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_unlink(arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Unsetenv removes an environment variable from the environment.
//
// Note that on some systems, when variables are overwritten, the memory used
// for the previous variables and its value isn't reclaimed.
//
// You should be mindful of the fact that environment variable handling in UNIX
// is not thread-safe, and your program may crash if one thread calls
// g_unsetenv() while another thread is calling getenv(). (And note that many
// functions, such as gettext(), call getenv() internally.) This function is
// only safe to use at the very start of your program, before creating any other
// threads (or creating objects that create worker threads of their own).
//
// If you need to set up the environment for a child process, you can use
// g_get_environ() to get an environment array, modify that with
// g_environ_setenv() and g_environ_unsetenv(), and then pass that array
// directly to execvpe(), g_spawn_async(), or the like.
func Unsetenv(variable string) {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(variable))
	defer C.free(unsafe.Pointer(arg1))

	C.g_unsetenv(arg1)
}

// URIBuild creates a new #GUri from the given components according to @flags.
//
// See also g_uri_build_with_user(), which allows specifying the components of
// the "userinfo" separately.
func URIBuild(flags URIFlags, scheme string, userinfo string, host string, port int, path string, query string, fragment string) *URI {
	var arg1 C.GUriFlags
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 *C.gchar
	var arg5 C.gint
	var arg6 *C.gchar
	var arg7 *C.gchar
	var arg8 *C.gchar

	arg1 = (C.GUriFlags)(flags)
	arg2 = (*C.gchar)(C.CString(scheme))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(userinfo))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gchar)(C.CString(host))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = C.gint(port)
	arg6 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg6))
	arg7 = (*C.gchar)(C.CString(query))
	defer C.free(unsafe.Pointer(arg7))
	arg8 = (*C.gchar)(C.CString(fragment))
	defer C.free(unsafe.Pointer(arg8))

	ret := C.g_uri_build(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)

	var ret0 *URI

	{
		ret0 = WrapURI(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *URI) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// URIBuildWithUser creates a new #GUri from the given components according to
// @flags (G_URI_FLAGS_HAS_PASSWORD is added unconditionally). The @flags must
// be coherent with the passed values, in particular use `%`-encoded values with
// G_URI_FLAGS_ENCODED.
//
// In contrast to g_uri_build(), this allows specifying the components of the
// ‘userinfo’ field separately. Note that @user must be non-nil if either
// @password or @auth_params is non-nil.
func URIBuildWithUser(flags URIFlags, scheme string, user string, password string, authParams string, host string, port int, path string, query string, fragment string) *URI {
	var arg1 C.GUriFlags
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 *C.gchar
	var arg5 *C.gchar
	var arg6 *C.gchar
	var arg7 C.gint
	var arg8 *C.gchar
	var arg9 *C.gchar
	var arg10 *C.gchar

	arg1 = (C.GUriFlags)(flags)
	arg2 = (*C.gchar)(C.CString(scheme))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(user))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gchar)(C.CString(password))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.gchar)(C.CString(authParams))
	defer C.free(unsafe.Pointer(arg5))
	arg6 = (*C.gchar)(C.CString(host))
	defer C.free(unsafe.Pointer(arg6))
	arg7 = C.gint(port)
	arg8 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg8))
	arg9 = (*C.gchar)(C.CString(query))
	defer C.free(unsafe.Pointer(arg9))
	arg10 = (*C.gchar)(C.CString(fragment))
	defer C.free(unsafe.Pointer(arg10))

	ret := C.g_uri_build_with_user(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)

	var ret0 *URI

	{
		ret0 = WrapURI(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *URI) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

func URIErrorQuark() Quark {

	ret := C.g_uri_error_quark()

	var ret0 Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = Quark(tmp)
	}

	return ret0
}

// URIEscapeBytes escapes arbitrary data for use in a URI.
//
// Normally all characters that are not ‘unreserved’ (i.e. ASCII alphanumerical
// characters plus dash, dot, underscore and tilde) are escaped. But if you
// specify characters in @reserved_chars_allowed they are not escaped. This is
// useful for the ‘reserved’ characters in the URI specification, since those
// are allowed unescaped in some portions of a URI.
//
// Though technically incorrect, this will also allow escaping nul bytes as
// `%“00`.
func URIEscapeBytes(unescaped []byte, reservedCharsAllowed string) string {
	var arg1 *C.guint8
	var arg2 C.gsize
	var arg3 *C.char

	arg1 = (*C.guint8)(unsafe.Pointer(&unescaped[0]))
	arg2 = len(unescaped)
	defer runtime.KeepAlive(unescaped)
	arg3 = (*C.gchar)(C.CString(reservedCharsAllowed))
	defer C.free(unsafe.Pointer(arg3))

	ret := C.g_uri_escape_bytes(arg1, arg2, arg3)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// URIEscapeString escapes a string for use in a URI.
//
// Normally all characters that are not "unreserved" (i.e. ASCII alphanumerical
// characters plus dash, dot, underscore and tilde) are escaped. But if you
// specify characters in @reserved_chars_allowed they are not escaped. This is
// useful for the "reserved" characters in the URI specification, since those
// are allowed unescaped in some portions of a URI.
func URIEscapeString(unescaped string, reservedCharsAllowed string, allowUTF8 bool) string {
	var arg1 *C.char
	var arg2 *C.char
	var arg3 C.gboolean

	arg1 = (*C.gchar)(C.CString(unescaped))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(reservedCharsAllowed))
	defer C.free(unsafe.Pointer(arg2))
	if allowUTF8 {
		arg3 = C.TRUE
	}

	ret := C.g_uri_escape_string(arg1, arg2, arg3)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// URIIsValid parses @uri_string according to @flags, to determine whether it is
// a valid [absolute URI][relative-absolute-uris], i.e. it does not need to be
// resolved relative to another URI using g_uri_parse_relative().
//
// If it’s not a valid URI, an error is returned explaining how it’s invalid.
//
// See g_uri_split(), and the definition of Flags, for more information on the
// effect of @flags.
func URIIsValid(uriString string, flags URIFlags) error {
	var arg1 *C.gchar
	var arg2 C.GUriFlags
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(uriString))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GUriFlags)(flags)

	ret := C.g_uri_is_valid(arg1, arg2, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// URIJoin joins the given components together according to @flags to create an
// absolute URI string. @path may not be nil (though it may be the empty
// string).
//
// When @host is present, @path must either be empty or begin with a slash (`/`)
// character. When @host is not present, @path cannot begin with two slash
// characters (`//`). See RFC 3986, section 3
// (https://tools.ietf.org/html/rfc3986#section-3).
//
// See also g_uri_join_with_user(), which allows specifying the components of
// the ‘userinfo’ separately.
//
// G_URI_FLAGS_HAS_PASSWORD and G_URI_FLAGS_HAS_AUTH_PARAMS are ignored if set
// in @flags.
func URIJoin(flags URIFlags, scheme string, userinfo string, host string, port int, path string, query string, fragment string) string {
	var arg1 C.GUriFlags
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 *C.gchar
	var arg5 C.gint
	var arg6 *C.gchar
	var arg7 *C.gchar
	var arg8 *C.gchar

	arg1 = (C.GUriFlags)(flags)
	arg2 = (*C.gchar)(C.CString(scheme))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(userinfo))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gchar)(C.CString(host))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = C.gint(port)
	arg6 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg6))
	arg7 = (*C.gchar)(C.CString(query))
	defer C.free(unsafe.Pointer(arg7))
	arg8 = (*C.gchar)(C.CString(fragment))
	defer C.free(unsafe.Pointer(arg8))

	ret := C.g_uri_join(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// URIJoinWithUser joins the given components together according to @flags to
// create an absolute URI string. @path may not be nil (though it may be the
// empty string).
//
// In contrast to g_uri_join(), this allows specifying the components of the
// ‘userinfo’ separately. It otherwise behaves the same.
//
// G_URI_FLAGS_HAS_PASSWORD and G_URI_FLAGS_HAS_AUTH_PARAMS are ignored if set
// in @flags.
func URIJoinWithUser(flags URIFlags, scheme string, user string, password string, authParams string, host string, port int, path string, query string, fragment string) string {
	var arg1 C.GUriFlags
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 *C.gchar
	var arg5 *C.gchar
	var arg6 *C.gchar
	var arg7 C.gint
	var arg8 *C.gchar
	var arg9 *C.gchar
	var arg10 *C.gchar

	arg1 = (C.GUriFlags)(flags)
	arg2 = (*C.gchar)(C.CString(scheme))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(user))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gchar)(C.CString(password))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.gchar)(C.CString(authParams))
	defer C.free(unsafe.Pointer(arg5))
	arg6 = (*C.gchar)(C.CString(host))
	defer C.free(unsafe.Pointer(arg6))
	arg7 = C.gint(port)
	arg8 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg8))
	arg9 = (*C.gchar)(C.CString(query))
	defer C.free(unsafe.Pointer(arg9))
	arg10 = (*C.gchar)(C.CString(fragment))
	defer C.free(unsafe.Pointer(arg10))

	ret := C.g_uri_join_with_user(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// URIListExtractUris splits an URI list conforming to the text/uri-list mime
// type defined in RFC 2483 into individual URIs, discarding any comments. The
// URIs are not validated.
func URIListExtractUris(uriList string) []string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(uriList))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_uri_list_extract_uris(arg1)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// URIParse parses @uri_string according to @flags. If the result is not a valid
// [absolute URI][relative-absolute-uris], it will be discarded, and an error
// returned.
func URIParse(uriString string, flags URIFlags) (uri *URI, err error) {
	var arg1 *C.gchar
	var arg2 C.GUriFlags
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(uriString))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GUriFlags)(flags)

	ret := C.g_uri_parse(arg1, arg2, &gError)

	var ret0 *URI
	var goError error

	{
		ret0 = WrapURI(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *URI) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// URIParseParams: many URI schemes include one or more attribute/value pairs as
// part of the URI value. This method can be used to parse them into a hash
// table. When an attribute has multiple occurrences, the last value is the
// final returned value. If you need to handle repeated attributes differently,
// use ParamsIter.
//
// The @params string is assumed to still be `%`-encoded, but the returned
// values will be fully decoded. (Thus it is possible that the returned values
// may contain `=` or @separators, if the value was encoded in the input.)
// Invalid `%`-encoding is treated as with the G_URI_FLAGS_PARSE_RELAXED rules
// for g_uri_parse(). (However, if @params is the path or query string from a
// #GUri that was parsed without G_URI_FLAGS_PARSE_RELAXED and
// G_URI_FLAGS_ENCODED, then you already know that it does not contain any
// invalid encoding.)
//
// G_URI_PARAMS_WWW_FORM is handled as documented for g_uri_params_iter_init().
//
// If G_URI_PARAMS_CASE_INSENSITIVE is passed to @flags, attributes will be
// compared case-insensitively, so a params string `attr=123&Attr=456` will only
// return a single attribute–value pair, `Attr=456`. Case will be preserved in
// the returned attributes.
//
// If @params cannot be parsed (for example, it contains two @separators
// characters in a row), then @error is set and nil is returned.
func URIParseParams(params string, length int, separators string, flags URIParamsFlags) (hashTable *HashTable, err error) {
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 *C.gchar
	var arg4 C.GUriParamsFlags
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(params))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(length)
	arg3 = (*C.gchar)(C.CString(separators))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (C.GUriParamsFlags)(flags)

	ret := C.g_uri_parse_params(arg1, arg2, arg3, arg4, &gError)

	var ret0 *HashTable
	var goError error

	{
		ret0 = WrapHashTable(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *HashTable) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// URIParseScheme gets the scheme portion of a URI string. RFC 3986
// (https://tools.ietf.org/html/rfc3986#section-3) decodes the scheme as:
//
//    URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
//
// Common schemes include `file`, `https`, `svn+ssh`, etc.
func URIParseScheme(uri string) string {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_uri_parse_scheme(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// URIPeekScheme gets the scheme portion of a URI string. RFC 3986
// (https://tools.ietf.org/html/rfc3986#section-3) decodes the scheme as:
//
//    URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
//
// Common schemes include `file`, `https`, `svn+ssh`, etc.
//
// Unlike g_uri_parse_scheme(), the returned scheme is normalized to
// all-lowercase and does not need to be freed.
func URIPeekScheme(uri string) string {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_uri_peek_scheme(arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// URIResolveRelative parses @uri_ref according to @flags and, if it is a
// [relative URI][relative-absolute-uris], resolves it relative to
// @base_uri_string. If the result is not a valid absolute URI, it will be
// discarded, and an error returned.
//
// (If @base_uri_string is nil, this just returns @uri_ref, or nil if @uri_ref
// is invalid or not absolute.)
func URIResolveRelative(baseURIString string, uriRef string, flags URIFlags) (utf8 string, err error) {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 C.GUriFlags
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(baseURIString))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(uriRef))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (C.GUriFlags)(flags)

	ret := C.g_uri_resolve_relative(arg1, arg2, arg3, &gError)

	var ret0 string
	var goError error

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// URISplit parses @uri_ref (which can be an [absolute or relative
// URI][relative-absolute-uris]) according to @flags, and returns the pieces.
// Any component that doesn't appear in @uri_ref will be returned as nil (but
// note that all URIs always have a path component, though it may be the empty
// string).
//
// If @flags contains G_URI_FLAGS_ENCODED, then `%`-encoded characters in
// @uri_ref will remain encoded in the output strings. (If not, then all such
// characters will be decoded.) Note that decoding will only work if the URI
// components are ASCII or UTF-8, so you will need to use G_URI_FLAGS_ENCODED if
// they are not.
//
// Note that the G_URI_FLAGS_HAS_PASSWORD and G_URI_FLAGS_HAS_AUTH_PARAMS @flags
// are ignored by g_uri_split(), since it always returns only the full userinfo;
// use g_uri_split_with_user() if you want it split up.
func URISplit(uriRef string, flags URIFlags) (scheme string, userinfo string, host string, port int, path string, query string, fragment string, err error) {
	var arg1 *C.gchar
	var arg2 C.GUriFlags
	var arg3 **C.gchar // out
	var arg4 **C.gchar // out
	var arg5 **C.gchar // out
	var arg6 *C.gint   // out
	var arg7 **C.gchar // out
	var arg8 **C.gchar // out
	var arg9 **C.gchar // out
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(uriRef))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GUriFlags)(flags)

	ret := C.g_uri_split(arg1, arg2, &arg3, &arg4, &arg5, &arg6, &arg7, &arg8, &arg9, &gError)

	var ret0 string
	var ret1 string
	var ret2 string
	var ret3 int
	var ret4 string
	var ret5 string
	var ret6 string
	var goError error

	ret0 = C.GoString(arg3)
	C.free(unsafe.Pointer(arg3))

	ret1 = C.GoString(arg4)
	C.free(unsafe.Pointer(arg4))

	ret2 = C.GoString(arg5)
	C.free(unsafe.Pointer(arg5))

	ret3 = int(arg6)

	ret4 = C.GoString(arg7)
	C.free(unsafe.Pointer(arg7))

	ret5 = C.GoString(arg8)
	C.free(unsafe.Pointer(arg8))

	ret6 = C.GoString(arg9)
	C.free(unsafe.Pointer(arg9))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, ret3, ret4, ret5, ret6, goError
}

// URISplitNetwork parses @uri_string (which must be an [absolute
// URI][relative-absolute-uris]) according to @flags, and returns the pieces
// relevant to connecting to a host. See the documentation for g_uri_split() for
// more details; this is mostly a wrapper around that function with simpler
// arguments. However, it will return an error if @uri_string is a relative URI,
// or does not contain a hostname component.
func URISplitNetwork(uriString string, flags URIFlags) (scheme string, host string, port int, err error) {
	var arg1 *C.gchar
	var arg2 C.GUriFlags
	var arg3 **C.gchar // out
	var arg4 **C.gchar // out
	var arg5 *C.gint   // out
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(uriString))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GUriFlags)(flags)

	ret := C.g_uri_split_network(arg1, arg2, &arg3, &arg4, &arg5, &gError)

	var ret0 string
	var ret1 string
	var ret2 int
	var goError error

	ret0 = C.GoString(arg3)
	C.free(unsafe.Pointer(arg3))

	ret1 = C.GoString(arg4)
	C.free(unsafe.Pointer(arg4))

	ret2 = int(arg5)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}

// URISplitWithUser parses @uri_ref (which can be an [absolute or relative
// URI][relative-absolute-uris]) according to @flags, and returns the pieces.
// Any component that doesn't appear in @uri_ref will be returned as nil (but
// note that all URIs always have a path component, though it may be the empty
// string).
//
// See g_uri_split(), and the definition of Flags, for more information on the
// effect of @flags. Note that @password will only be parsed out if @flags
// contains G_URI_FLAGS_HAS_PASSWORD, and @auth_params will only be parsed out
// if @flags contains G_URI_FLAGS_HAS_AUTH_PARAMS.
func URISplitWithUser(uriRef string, flags URIFlags) (scheme string, user string, password string, authParams string, host string, port int, path string, query string, fragment string, err error) {
	var arg1 *C.gchar
	var arg2 C.GUriFlags
	var arg3 **C.gchar  // out
	var arg4 **C.gchar  // out
	var arg5 **C.gchar  // out
	var arg6 **C.gchar  // out
	var arg7 **C.gchar  // out
	var arg8 *C.gint    // out
	var arg9 **C.gchar  // out
	var arg10 **C.gchar // out
	var arg11 **C.gchar // out
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(uriRef))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GUriFlags)(flags)

	ret := C.g_uri_split_with_user(arg1, arg2, &arg3, &arg4, &arg5, &arg6, &arg7, &arg8, &arg9, &arg10, &arg11, &gError)

	var ret0 string
	var ret1 string
	var ret2 string
	var ret3 string
	var ret4 string
	var ret5 int
	var ret6 string
	var ret7 string
	var ret8 string
	var goError error

	ret0 = C.GoString(arg3)
	C.free(unsafe.Pointer(arg3))

	ret1 = C.GoString(arg4)
	C.free(unsafe.Pointer(arg4))

	ret2 = C.GoString(arg5)
	C.free(unsafe.Pointer(arg5))

	ret3 = C.GoString(arg6)
	C.free(unsafe.Pointer(arg6))

	ret4 = C.GoString(arg7)
	C.free(unsafe.Pointer(arg7))

	ret5 = int(arg8)

	ret6 = C.GoString(arg9)
	C.free(unsafe.Pointer(arg9))

	ret7 = C.GoString(arg10)
	C.free(unsafe.Pointer(arg10))

	ret8 = C.GoString(arg11)
	C.free(unsafe.Pointer(arg11))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, ret3, ret4, ret5, ret6, ret7, ret8, goError
}

// URIUnescapeBytes unescapes a segment of an escaped string as binary data.
//
// Note that in contrast to g_uri_unescape_string(), this does allow nul bytes
// to appear in the output.
//
// If any of the characters in @illegal_characters appears as an escaped
// character in @escaped_string, then that is an error and nil will be returned.
// This is useful if you want to avoid for instance having a slash being
// expanded in an escaped path element, which might confuse pathname handling.
func URIUnescapeBytes(escapedString string, length int, illegalCharacters string) (bytes *Bytes, err error) {
	var arg1 *C.char
	var arg2 C.gssize
	var arg3 *C.char
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(escapedString))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(length)
	arg3 = (*C.gchar)(C.CString(illegalCharacters))
	defer C.free(unsafe.Pointer(arg3))

	ret := C.g_uri_unescape_bytes(arg1, arg2, arg3, &gError)

	var ret0 *Bytes
	var goError error

	{
		ret0 = WrapBytes(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Bytes) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// URIUnescapeSegment unescapes a segment of an escaped string.
//
// If any of the characters in @illegal_characters or the NUL character appears
// as an escaped character in @escaped_string, then that is an error and nil
// will be returned. This is useful if you want to avoid for instance having a
// slash being expanded in an escaped path element, which might confuse pathname
// handling.
//
// Note: `NUL` byte is not accepted in the output, in contrast to
// g_uri_unescape_bytes().
func URIUnescapeSegment(escapedString string, escapedStringEnd string, illegalCharacters string) string {
	var arg1 *C.char
	var arg2 *C.char
	var arg3 *C.char

	arg1 = (*C.gchar)(C.CString(escapedString))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(escapedStringEnd))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(illegalCharacters))
	defer C.free(unsafe.Pointer(arg3))

	ret := C.g_uri_unescape_segment(arg1, arg2, arg3)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// URIUnescapeString unescapes a whole escaped string.
//
// If any of the characters in @illegal_characters or the NUL character appears
// as an escaped character in @escaped_string, then that is an error and nil
// will be returned. This is useful if you want to avoid for instance having a
// slash being expanded in an escaped path element, which might confuse pathname
// handling.
func URIUnescapeString(escapedString string, illegalCharacters string) string {
	var arg1 *C.char
	var arg2 *C.char

	arg1 = (*C.gchar)(C.CString(escapedString))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(illegalCharacters))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_uri_unescape_string(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Usleep pauses the current thread for the given number of microseconds.
//
// There are 1 million microseconds per second (represented by the USEC_PER_SEC
// macro). g_usleep() may have limited precision, depending on hardware and
// operating system; don't rely on the exact length of the sleep.
func Usleep(microseconds uint32) {
	var arg1 C.gulong

	arg1 = C.gulong(microseconds)

	C.g_usleep(arg1)
}

// UTF16ToUcs4: convert a string from UTF-16 to UCS-4. The result will be
// nul-terminated.
func UTF16ToUcs4(str uint16, len int32) (itemsRead int32, itemsWritten int32, gunichar uint32, err error) {
	var arg1 *C.gunichar2
	var arg2 C.glong
	var arg3 *C.glong // out
	var arg4 *C.glong // out
	var gError *C.GError

	arg1 = (*C.gunichar2)(str)
	arg2 = C.glong(len)

	ret := C.g_utf16_to_ucs4(arg1, arg2, &arg3, &arg4, &gError)

	var ret0 int32
	var ret1 int32
	var ret2 uint32
	var goError error

	ret0 = int32(arg3)

	ret1 = int32(arg4)

	ret2 = uint32(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}

// UTF16ToUTF8: convert a string from UTF-16 to UTF-8. The result will be
// terminated with a 0 byte.
//
// Note that the input is expected to be already in native endianness, an
// initial byte-order-mark character is not handled specially. g_convert() can
// be used to convert a byte buffer of UTF-16 data of ambiguous endianness.
//
// Further note that this function does not validate the result string; it may
// e.g. include embedded NUL characters. The only validation done by this
// function is to ensure that the input can be correctly interpreted as UTF-16,
// i.e. it doesn't contain unpaired surrogates or partial character sequences.
func UTF16ToUTF8(str uint16, len int32) (itemsRead int32, itemsWritten int32, utf8 string, err error) {
	var arg1 *C.gunichar2
	var arg2 C.glong
	var arg3 *C.glong // out
	var arg4 *C.glong // out
	var gError *C.GError

	arg1 = (*C.gunichar2)(str)
	arg2 = C.glong(len)

	ret := C.g_utf16_to_utf8(arg1, arg2, &arg3, &arg4, &gError)

	var ret0 int32
	var ret1 int32
	var ret2 string
	var goError error

	ret0 = int32(arg3)

	ret1 = int32(arg4)

	ret2 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}

// UTF8Casefold converts a string into a form that is independent of case. The
// result will not correspond to any particular case, but can be compared for
// equality or ordered with the results of calling g_utf8_casefold() on other
// strings.
//
// Note that calling g_utf8_casefold() followed by g_utf8_collate() is only an
// approximation to the correct linguistic case insensitive ordering, though it
// is a fairly good one. Getting this exactly right would require a more
// sophisticated collation function that takes case sensitivity into account.
// GLib does not currently provide such a function.
func UTF8Casefold(str string, len int) string {
	var arg1 *C.gchar
	var arg2 C.gssize

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(len)

	ret := C.g_utf8_casefold(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// UTF8Collate compares two strings for ordering using the linguistically
// correct rules for the [current locale][setlocale]. When sorting a large
// number of strings, it will be significantly faster to obtain collation keys
// with g_utf8_collate_key() and compare the keys with strcmp() when sorting
// instead of sorting the original strings.
func UTF8Collate(str1 string, str2 string) int {
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg1 = (*C.gchar)(C.CString(str1))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(str2))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_utf8_collate(arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// UTF8CollateKey converts a string into a collation key that can be compared
// with other collation keys produced by the same function using strcmp().
//
// The results of comparing the collation keys of two strings with strcmp() will
// always be the same as comparing the two original keys with g_utf8_collate().
//
// Note that this function depends on the [current locale][setlocale].
func UTF8CollateKey(str string, len int) string {
	var arg1 *C.gchar
	var arg2 C.gssize

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(len)

	ret := C.g_utf8_collate_key(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// UTF8CollateKeyForFilename converts a string into a collation key that can be
// compared with other collation keys produced by the same function using
// strcmp().
//
// In order to sort filenames correctly, this function treats the dot '.' as a
// special case. Most dictionary orderings seem to consider it insignificant,
// thus producing the ordering "event.c" "eventgenerator.c" "event.h" instead of
// "event.c" "event.h" "eventgenerator.c". Also, we would like to treat numbers
// intelligently so that "file1" "file10" "file5" is sorted as "file1" "file5"
// "file10".
//
// Note that this function depends on the [current locale][setlocale].
func UTF8CollateKeyForFilename(str string, len int) string {
	var arg1 *C.gchar
	var arg2 C.gssize

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(len)

	ret := C.g_utf8_collate_key_for_filename(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// UTF8FindNextChar finds the start of the next UTF-8 character in the string
// after @p.
//
// @p does not have to be at the beginning of a UTF-8 character. No check is
// made to see if the character found is actually valid other than it starts
// with an appropriate byte.
//
// If @end is nil, the return value will never be nil: if the end of the string
// is reached, a pointer to the terminating nul byte is returned. If @end is
// non-nil, the return value will be nil if the end of the string is reached.
func UTF8FindNextChar(p string, end string) string {
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg1 = (*C.gchar)(C.CString(p))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(end))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_utf8_find_next_char(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// UTF8FindPrevChar: given a position @p with a UTF-8 encoded string @str, find
// the start of the previous UTF-8 character starting before @p. Returns nil if
// no UTF-8 characters are present in @str before @p.
//
// @p does not have to be at the beginning of a UTF-8 character. No check is
// made to see if the character found is actually valid other than it starts
// with an appropriate byte.
func UTF8FindPrevChar(str string, p string) string {
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(p))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_utf8_find_prev_char(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// UTF8GetChar converts a sequence of bytes encoded as UTF-8 to a Unicode
// character.
//
// If @p does not point to a valid UTF-8 encoded character, results are
// undefined. If you are not sure that the bytes are complete valid Unicode
// characters, you should use g_utf8_get_char_validated() instead.
func UTF8GetChar(p string) uint32 {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(p))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_utf8_get_char(arg1)

	var ret0 uint32

	ret0 = uint32(ret)

	return ret0
}

// UTF8GetCharValidated: convert a sequence of bytes encoded as UTF-8 to a
// Unicode character. This function checks for incomplete characters, for
// invalid characters such as characters that are out of the range of Unicode,
// and for overlong encodings of valid characters.
//
// Note that g_utf8_get_char_validated() returns (gunichar)-2 if @max_len is
// positive and any of the bytes in the first UTF-8 character sequence are nul.
func UTF8GetCharValidated(p string, maxLen int) uint32 {
	var arg1 *C.gchar
	var arg2 C.gssize

	arg1 = (*C.gchar)(C.CString(p))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(maxLen)

	ret := C.g_utf8_get_char_validated(arg1, arg2)

	var ret0 uint32

	ret0 = uint32(ret)

	return ret0
}

// UTF8MakeValid: if the provided string is valid UTF-8, return a copy of it. If
// not, return a copy in which bytes that could not be interpreted as valid
// Unicode are replaced with the Unicode replacement character (U+FFFD).
//
// For example, this is an appropriate function to use if you have received a
// string that was incorrectly declared to be UTF-8, and you need a valid UTF-8
// version of it that can be logged or displayed to the user, with the
// assumption that it is close enough to ASCII or UTF-8 to be mostly readable
// as-is.
func UTF8MakeValid(str string, len int) string {
	var arg1 *C.gchar
	var arg2 C.gssize

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(len)

	ret := C.g_utf8_make_valid(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// UTF8Normalize converts a string into canonical form, standardizing such
// issues as whether a character with an accent is represented as a base
// character and combining accent or as a single precomposed character. The
// string has to be valid UTF-8, otherwise nil is returned. You should generally
// call g_utf8_normalize() before comparing two Unicode strings.
//
// The normalization mode G_NORMALIZE_DEFAULT only standardizes differences that
// do not affect the text content, such as the above-mentioned accent
// representation. G_NORMALIZE_ALL also standardizes the "compatibility"
// characters in Unicode, such as SUPERSCRIPT THREE to the standard forms (in
// this case DIGIT THREE). Formatting information may be lost but for most text
// operations such characters should be considered the same.
//
// G_NORMALIZE_DEFAULT_COMPOSE and G_NORMALIZE_ALL_COMPOSE are like
// G_NORMALIZE_DEFAULT and G_NORMALIZE_ALL, but returned a result with composed
// forms rather than a maximally decomposed form. This is often useful if you
// intend to convert the string to a legacy encoding or pass it to a system with
// less capable Unicode handling.
func UTF8Normalize(str string, len int, mode NormalizeMode) string {
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 C.GNormalizeMode

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(len)
	arg3 = (C.GNormalizeMode)(mode)

	ret := C.g_utf8_normalize(arg1, arg2, arg3)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// UTF8OffsetToPointer converts from an integer character offset to a pointer to
// a position within the string.
//
// Since 2.10, this function allows to pass a negative @offset to step
// backwards. It is usually worth stepping backwards from the end instead of
// forwards if @offset is in the last fourth of the string, since moving forward
// is about 3 times faster than moving backward.
//
// Note that this function doesn't abort when reaching the end of @str.
// Therefore you should be sure that @offset is within string boundaries before
// calling that function. Call g_utf8_strlen() when unsure. This limitation
// exists as this function is called frequently during text rendering and
// therefore has to be as fast as possible.
func UTF8OffsetToPointer(str string, offset int32) string {
	var arg1 *C.gchar
	var arg2 C.glong

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.glong(offset)

	ret := C.g_utf8_offset_to_pointer(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// UTF8PointerToOffset converts from a pointer to position within a string to an
// integer character offset.
//
// Since 2.10, this function allows @pos to be before @str, and returns a
// negative offset in this case.
func UTF8PointerToOffset(str string, pos string) int32 {
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(pos))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_utf8_pointer_to_offset(arg1, arg2)

	var ret0 int32

	ret0 = int32(ret)

	return ret0
}

// UTF8PrevChar finds the previous UTF-8 character in the string before @p.
//
// @p does not have to be at the beginning of a UTF-8 character. No check is
// made to see if the character found is actually valid other than it starts
// with an appropriate byte. If @p might be the first character of the string,
// you must use g_utf8_find_prev_char() instead.
func UTF8PrevChar(p string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(p))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_utf8_prev_char(arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// UTF8Strchr finds the leftmost occurrence of the given Unicode character in a
// UTF-8 encoded string, while limiting the search to @len bytes. If @len is -1,
// allow unbounded search.
func UTF8Strchr(p string, len int, c uint32) string {
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 C.gunichar

	arg1 = (*C.gchar)(C.CString(p))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(len)
	arg3 = C.gunichar(c)

	ret := C.g_utf8_strchr(arg1, arg2, arg3)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// UTF8Strdown converts all Unicode characters in the string that have a case to
// lowercase. The exact manner that this is done depends on the current locale,
// and may result in the number of characters in the string changing.
func UTF8Strdown(str string, len int) string {
	var arg1 *C.gchar
	var arg2 C.gssize

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(len)

	ret := C.g_utf8_strdown(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// UTF8Strlen computes the length of the string in characters, not including the
// terminating nul character. If the @max'th byte falls in the middle of a
// character, the last (partial) character is not counted.
func UTF8Strlen(p string, max int) int32 {
	var arg1 *C.gchar
	var arg2 C.gssize

	arg1 = (*C.gchar)(C.CString(p))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(max)

	ret := C.g_utf8_strlen(arg1, arg2)

	var ret0 int32

	ret0 = int32(ret)

	return ret0
}

// UTF8Strncpy: like the standard C strncpy() function, but copies a given
// number of characters instead of a given number of bytes. The @src string must
// be valid UTF-8 encoded text. (Use g_utf8_validate() on all text before trying
// to use UTF-8 utility functions with it.)
//
// Note you must ensure @dest is at least 4 * @n to fit the largest possible
// UTF-8 characters
func UTF8Strncpy(dest string, src string, n uint) string {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 C.gsize

	arg1 = (*C.gchar)(C.CString(dest))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(src))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.gsize(n)

	ret := C.g_utf8_strncpy(arg1, arg2, arg3)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// UTF8Strrchr: find the rightmost occurrence of the given Unicode character in
// a UTF-8 encoded string, while limiting the search to @len bytes. If @len is
// -1, allow unbounded search.
func UTF8Strrchr(p string, len int, c uint32) string {
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 C.gunichar

	arg1 = (*C.gchar)(C.CString(p))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(len)
	arg3 = C.gunichar(c)

	ret := C.g_utf8_strrchr(arg1, arg2, arg3)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// UTF8Strreverse reverses a UTF-8 string. @str must be valid UTF-8 encoded
// text. (Use g_utf8_validate() on all text before trying to use UTF-8 utility
// functions with it.)
//
// This function is intended for programmatic uses of reversed strings. It pays
// no attention to decomposed characters, combining marks, byte order marks,
// directional indicators (LRM, LRO, etc) and similar characters which might
// need special handling when reversing a string for display purposes.
//
// Note that unlike g_strreverse(), this function returns newly-allocated
// memory, which should be freed with g_free() when no longer needed.
func UTF8Strreverse(str string, len int) string {
	var arg1 *C.gchar
	var arg2 C.gssize

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(len)

	ret := C.g_utf8_strreverse(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// UTF8Strup converts all Unicode characters in the string that have a case to
// uppercase. The exact manner that this is done depends on the current locale,
// and may result in the number of characters in the string increasing. (For
// instance, the German ess-zet will be changed to SS.)
func UTF8Strup(str string, len int) string {
	var arg1 *C.gchar
	var arg2 C.gssize

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(len)

	ret := C.g_utf8_strup(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// UTF8Substring copies a substring out of a UTF-8 encoded string. The substring
// will contain @end_pos - @start_pos characters.
func UTF8Substring(str string, startPos int32, endPos int32) string {
	var arg1 *C.gchar
	var arg2 C.glong
	var arg3 C.glong

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.glong(startPos)
	arg3 = C.glong(endPos)

	ret := C.g_utf8_substring(arg1, arg2, arg3)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// UTF8ToUcs4: convert a string from UTF-8 to a 32-bit fixed width
// representation as UCS-4. A trailing 0 character will be added to the string
// after the converted text.
func UTF8ToUcs4(str string, len int32) (itemsRead int32, itemsWritten int32, gunichar uint32, err error) {
	var arg1 *C.gchar
	var arg2 C.glong
	var arg3 *C.glong // out
	var arg4 *C.glong // out
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.glong(len)

	ret := C.g_utf8_to_ucs4(arg1, arg2, &arg3, &arg4, &gError)

	var ret0 int32
	var ret1 int32
	var ret2 uint32
	var goError error

	ret0 = int32(arg3)

	ret1 = int32(arg4)

	ret2 = uint32(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}

// UTF8ToUcs4Fast: convert a string from UTF-8 to a 32-bit fixed width
// representation as UCS-4, assuming valid UTF-8 input. This function is roughly
// twice as fast as g_utf8_to_ucs4() but does no error checking on the input. A
// trailing 0 character will be added to the string after the converted text.
func UTF8ToUcs4Fast(str string, len int32) (itemsWritten int32, gunichar uint32) {
	var arg1 *C.gchar
	var arg2 C.glong
	var arg3 *C.glong // out

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.glong(len)

	ret := C.g_utf8_to_ucs4_fast(arg1, arg2, &arg3)

	var ret0 int32
	var ret1 uint32

	ret0 = int32(arg3)

	ret1 = uint32(ret)

	return ret0, ret1
}

// UTF8ToUTF16: convert a string from UTF-8 to UTF-16. A 0 character will be
// added to the result after the converted text.
func UTF8ToUTF16(str string, len int32) (itemsRead int32, itemsWritten int32, guint16 uint16, err error) {
	var arg1 *C.gchar
	var arg2 C.glong
	var arg3 *C.glong // out
	var arg4 *C.glong // out
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.glong(len)

	ret := C.g_utf8_to_utf16(arg1, arg2, &arg3, &arg4, &gError)

	var ret0 int32
	var ret1 int32
	var ret2 uint16
	var goError error

	ret0 = int32(arg3)

	ret1 = int32(arg4)

	ret2 = uint16(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}

// UTF8Validate validates UTF-8 encoded text. @str is the text to validate; if
// @str is nul-terminated, then @max_len can be -1, otherwise @max_len should be
// the number of bytes to validate. If @end is non-nil, then the end of the
// valid range will be stored there (i.e. the start of the first invalid
// character if some bytes were invalid, or the end of the text being validated
// otherwise).
//
// Note that g_utf8_validate() returns false if @max_len is positive and any of
// the @max_len bytes are nul.
//
// Returns true if all of @str was valid. Many GLib and GTK+ routines require
// valid UTF-8 as input; so data read from a file or the network should be
// checked with g_utf8_validate() before doing anything else with it.
func UTF8Validate(str []byte) (end string, ok bool) {
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 **C.gchar // out

	arg1 = (*C.gchar)(unsafe.Pointer(&str[0]))
	arg2 = len(str)
	defer runtime.KeepAlive(str)

	ret := C.g_utf8_validate(arg1, arg2, &arg3)

	var ret0 string
	var ret1 bool

	ret0 = C.GoString(arg3)

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// UTF8ValidateLen validates UTF-8 encoded text.
//
// As with g_utf8_validate(), but @max_len must be set, and hence this function
// will always return false if any of the bytes of @str are nul.
func UTF8ValidateLen(str []byte) (end string, ok bool) {
	var arg1 *C.gchar
	var arg2 C.gsize
	var arg3 **C.gchar // out

	arg1 = (*C.gchar)(unsafe.Pointer(&str[0]))
	arg2 = len(str)
	defer runtime.KeepAlive(str)

	ret := C.g_utf8_validate_len(arg1, arg2, &arg3)

	var ret0 string
	var ret1 bool

	ret0 = C.GoString(arg3)

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// UUIDStringIsValid parses the string @str and verify if it is a UUID.
//
// The function accepts the following syntax:
//
// - simple forms (e.g. `f81d4fae-7dec-11d0-a765-00a0c91e6bf6`)
//
// Note that hyphens are required within the UUID string itself, as per the
// aforementioned RFC.
func UUIDStringIsValid(str string) bool {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_uuid_string_is_valid(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// UUIDStringRandom generates a random UUID (RFC 4122 version 4) as a string. It
// has the same randomness guarantees as #GRand, so must not be used for
// cryptographic purposes such as key generation, nonces, salts or one-time
// pads.
func UUIDStringRandom() string {

	ret := C.g_uuid_string_random()

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

func VariantGetGType() externglib.Type {

	ret := C.g_variant_get_gtype()

	var ret0 externglib.Type

	ret0 = externglib.Type(ret)

	return ret0
}

// VariantIsObjectPath determines if a given string is a valid D-Bus object
// path. You should ensure that a string is a valid D-Bus object path before
// passing it to g_variant_new_object_path().
//
// A valid object path starts with `/` followed by zero or more sequences of
// characters separated by `/` characters. Each sequence must contain only the
// characters `[A-Z][a-z][0-9]_`. No sequence (including the one following the
// final `/` character) may be empty.
func VariantIsObjectPath(string string) bool {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_variant_is_object_path(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// VariantIsSignature determines if a given string is a valid D-Bus type
// signature. You should ensure that a string is a valid D-Bus type signature
// before passing it to g_variant_new_signature().
//
// D-Bus type signatures consist of zero or more definite Type strings in
// sequence.
func VariantIsSignature(string string) bool {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_variant_is_signature(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// VariantParse parses a #GVariant from a text representation.
//
// A single #GVariant is parsed from the content of @text.
//
// The format is described [here][gvariant-text].
//
// The memory at @limit will never be accessed and the parser behaves as if the
// character at @limit is the nul terminator. This has the effect of bounding
// @text.
//
// If @endptr is non-nil then @text is permitted to contain data following the
// value that this function parses and @endptr will be updated to point to the
// first character past the end of the text parsed by this function. If @endptr
// is nil and there is extra data then an error is returned.
//
// If @type is non-nil then the value will be parsed to have that type. This may
// result in additional parse errors (in the case that the parsed value doesn't
// fit the type) but may also result in fewer errors (in the case that the type
// would have been ambiguous, such as with empty arrays).
//
// In the event that the parsing is successful, the resulting #GVariant is
// returned. It is never floating, and must be freed with g_variant_unref().
//
// In case of any error, nil will be returned. If @error is non-nil then it will
// be set to reflect the error that occurred.
//
// Officially, the language understood by the parser is "any string produced by
// g_variant_print()".
//
// There may be implementation specific restrictions on deeply nested values,
// which would result in a G_VARIANT_PARSE_ERROR_RECURSION error. #GVariant is
// guaranteed to handle nesting up to at least 64 levels.
func VariantParse(typ *VariantType, text string, limit string, endptr string) (variant *Variant, err error) {
	var arg1 *C.GVariantType
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 **C.gchar
	var gError *C.GError

	arg1 = (*C.GVariantType)(typ.Native())
	arg2 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(limit))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gchar)(C.CString(endptr))
	defer C.free(unsafe.Pointer(arg4))

	ret := C.g_variant_parse(arg1, arg2, arg3, arg4, &gError)

	var ret0 *Variant
	var goError error

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Variant) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// VariantParseErrorPrintContext pretty-prints a message showing the context of
// a #GVariant parse error within the string for which parsing was attempted.
//
// The resulting string is suitable for output to the console or other monospace
// media where newlines are treated in the usual way.
//
// The message will typically look something like one of the following:
//
//    unterminated string constant:
//      (1, 2, 3, 'abc
//                ^^^^
//
// or
//
//    unable to find a common type:
//      [1, 2, 3, 'str']
//       ^        ^^^^^
//
// The format of the message may change in a future version.
//
// @error must have come from a failed attempt to g_variant_parse() and
// @source_str must be exactly the same string that caused the error. If
// @source_str was not nul-terminated when you passed it to g_variant_parse()
// then you must add nul termination before using this function.
func VariantParseErrorPrintContext(error *Error, sourceStr string) string {
	var arg1 *C.GError
	var arg2 *C.gchar

	arg1 = (*C.GError)(error.Native())
	arg2 = (*C.gchar)(C.CString(sourceStr))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_variant_parse_error_print_context(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

func VariantParseErrorQuark() Quark {

	ret := C.g_variant_parse_error_quark()

	var ret0 Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = Quark(tmp)
	}

	return ret0
}

// VariantParserGetErrorQuark: same as g_variant_error_quark().
func VariantParserGetErrorQuark() Quark {

	ret := C.g_variant_parser_get_error_quark()

	var ret0 Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = Quark(tmp)
	}

	return ret0
}

func VariantTypeChecked_(arg0 string) *VariantType {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(arg0))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_variant_type_checked_(arg1)

	var ret0 *VariantType

	{
		ret0 = WrapVariantType(unsafe.Pointer(ret))
	}

	return ret0
}

func VariantTypeStringGetDepth_(typeString string) uint {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(typeString))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_variant_type_string_get_depth_(arg1)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// VariantTypeStringIsValid checks if @type_string is a valid GVariant type
// string. This call is equivalent to calling g_variant_type_string_scan() and
// confirming that the following character is a nul terminator.
func VariantTypeStringIsValid(typeString string) bool {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(typeString))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_variant_type_string_is_valid(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// VariantTypeStringScan: scan for a single complete and valid GVariant type
// string in @string. The memory pointed to by @limit (or bytes beyond it) is
// never accessed.
//
// If a valid type string is found, @endptr is updated to point to the first
// character past the end of the string that was found and true is returned.
//
// If there is no valid type string starting at @string, or if the type string
// does not end before @limit then false is returned.
//
// For the simple case of checking if a string is a valid type string, see
// g_variant_type_string_is_valid().
func VariantTypeStringScan(string string, limit string) (endptr string, ok bool) {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 **C.gchar // out

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(limit))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_variant_type_string_scan(arg1, arg2, &arg3)

	var ret0 string
	var ret1 bool

	ret0 = C.GoString(arg3)
	C.free(unsafe.Pointer(arg3))

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// WarnMessage: internal function used to print messages from the public
// g_warn_if_reached() and g_warn_if_fail() macros.
func WarnMessage(domain string, file string, line int, fn string, warnexpr string) {
	var arg1 *C.char
	var arg2 *C.char
	var arg3 C.int
	var arg4 *C.char
	var arg5 *C.char

	arg1 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(file))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.int(line)
	arg4 = (*C.gchar)(C.CString(fn))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.gchar)(C.CString(warnexpr))
	defer C.free(unsafe.Pointer(arg5))

	C.g_warn_message(arg1, arg2, arg3, arg4, arg5)
}

// Array contains the public fields of a GArray.
type Array struct {
	native C.GArray
}

// WrapArray wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapArray(ptr unsafe.Pointer) *Array {
	if ptr == nil {
		return nil
	}

	return (*Array)(ptr)
}

func marshalArray(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapArray(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (a *Array) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// Data gets the field inside the struct.
func (a *Array) Data() string {
	var ret string
	ret = C.GoString(a.native.data)
	return ret
}

// Len gets the field inside the struct.
func (a *Array) Len() uint {
	var ret uint
	ret = uint(a.native.len)
	return ret
}

// AsyncQueue: the GAsyncQueue struct is an opaque data structure which
// represents an asynchronous queue. It should only be accessed through the
// g_async_queue_* functions.
type AsyncQueue struct {
	native C.GAsyncQueue
}

// WrapAsyncQueue wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAsyncQueue(ptr unsafe.Pointer) *AsyncQueue {
	if ptr == nil {
		return nil
	}

	return (*AsyncQueue)(ptr)
}

func marshalAsyncQueue(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapAsyncQueue(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (a *AsyncQueue) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// Length returns the length of the queue.
//
// Actually this function returns the number of data items in the queue minus
// the number of waiting threads, so a negative value means waiting threads, and
// a positive value means available entries in the @queue. A return value of 0
// could mean n entries in the queue and n threads waiting. This can happen due
// to locking of the queue or due to scheduling.
func (queue *AsyncQueue) Length() int {
	var arg0 *C.GAsyncQueue

	arg0 = (*C.GAsyncQueue)(queue.Native())

	ret := C.g_async_queue_length(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// LengthUnlocked returns the length of the queue.
//
// Actually this function returns the number of data items in the queue minus
// the number of waiting threads, so a negative value means waiting threads, and
// a positive value means available entries in the @queue. A return value of 0
// could mean n entries in the queue and n threads waiting. This can happen due
// to locking of the queue or due to scheduling.
//
// This function must be called while holding the @queue's lock.
func (queue *AsyncQueue) LengthUnlocked() int {
	var arg0 *C.GAsyncQueue

	arg0 = (*C.GAsyncQueue)(queue.Native())

	ret := C.g_async_queue_length_unlocked(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Lock acquires the @queue's lock. If another thread is already holding the
// lock, this call will block until the lock becomes available.
//
// Call g_async_queue_unlock() to drop the lock again.
//
// While holding the lock, you can only call the g_async_queue_*_unlocked()
// functions on @queue. Otherwise, deadlock may occur.
func (queue *AsyncQueue) Lock() {
	var arg0 *C.GAsyncQueue

	arg0 = (*C.GAsyncQueue)(queue.Native())

	C.g_async_queue_lock(arg0)
}

// Pop pops data from the @queue. If @queue is empty, this function blocks until
// data becomes available.
func (queue *AsyncQueue) Pop() interface{} {
	var arg0 *C.GAsyncQueue

	arg0 = (*C.GAsyncQueue)(queue.Native())

	ret := C.g_async_queue_pop(arg0)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// PopUnlocked pops data from the @queue. If @queue is empty, this function
// blocks until data becomes available.
//
// This function must be called while holding the @queue's lock.
func (queue *AsyncQueue) PopUnlocked() interface{} {
	var arg0 *C.GAsyncQueue

	arg0 = (*C.GAsyncQueue)(queue.Native())

	ret := C.g_async_queue_pop_unlocked(arg0)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// Push pushes the @data into the @queue. @data must not be nil.
func (queue *AsyncQueue) Push(data interface{}) {
	var arg0 *C.GAsyncQueue
	var arg1 C.gpointer

	arg0 = (*C.GAsyncQueue)(queue.Native())
	arg1 = C.gpointer(box.Assign(data))

	C.g_async_queue_push(arg0, arg1)
}

// PushFront pushes the @item into the @queue. @item must not be nil. In
// contrast to g_async_queue_push(), this function pushes the new item ahead of
// the items already in the queue, so that it will be the next one to be popped
// off the queue.
func (queue *AsyncQueue) PushFront(item interface{}) {
	var arg0 *C.GAsyncQueue
	var arg1 C.gpointer

	arg0 = (*C.GAsyncQueue)(queue.Native())
	arg1 = C.gpointer(box.Assign(item))

	C.g_async_queue_push_front(arg0, arg1)
}

// PushFrontUnlocked pushes the @item into the @queue. @item must not be nil. In
// contrast to g_async_queue_push_unlocked(), this function pushes the new item
// ahead of the items already in the queue, so that it will be the next one to
// be popped off the queue.
//
// This function must be called while holding the @queue's lock.
func (queue *AsyncQueue) PushFrontUnlocked(item interface{}) {
	var arg0 *C.GAsyncQueue
	var arg1 C.gpointer

	arg0 = (*C.GAsyncQueue)(queue.Native())
	arg1 = C.gpointer(box.Assign(item))

	C.g_async_queue_push_front_unlocked(arg0, arg1)
}

// PushSorted inserts @data into @queue using @func to determine the new
// position.
//
// This function requires that the @queue is sorted before pushing on new
// elements, see g_async_queue_sort().
//
// This function will lock @queue before it sorts the queue and unlock it when
// it is finished.
//
// For an example of @func see g_async_queue_sort().
func (queue *AsyncQueue) PushSorted(data interface{}, fn CompareDataFunc) {
	var arg0 *C.GAsyncQueue
	var arg1 C.gpointer
	var arg2 C.GCompareDataFunc
	var arg3 C.gpointer

	arg0 = (*C.GAsyncQueue)(queue.Native())
	arg1 = C.gpointer(box.Assign(data))
	arg2 = (*[0]byte)(C.gotk4_CompareDataFunc)
	arg3 = C.gpointer(box.Assign(fn))

	C.g_async_queue_push_sorted(arg0, arg1, arg2, arg3)
}

// PushSortedUnlocked inserts @data into @queue using @func to determine the new
// position.
//
// The sort function @func is passed two elements of the @queue. It should
// return 0 if they are equal, a negative value if the first element should be
// higher in the @queue or a positive value if the first element should be lower
// in the @queue than the second element.
//
// This function requires that the @queue is sorted before pushing on new
// elements, see g_async_queue_sort().
//
// This function must be called while holding the @queue's lock.
//
// For an example of @func see g_async_queue_sort().
func (queue *AsyncQueue) PushSortedUnlocked(data interface{}, fn CompareDataFunc) {
	var arg0 *C.GAsyncQueue
	var arg1 C.gpointer
	var arg2 C.GCompareDataFunc
	var arg3 C.gpointer

	arg0 = (*C.GAsyncQueue)(queue.Native())
	arg1 = C.gpointer(box.Assign(data))
	arg2 = (*[0]byte)(C.gotk4_CompareDataFunc)
	arg3 = C.gpointer(box.Assign(fn))

	C.g_async_queue_push_sorted_unlocked(arg0, arg1, arg2, arg3)
}

// PushUnlocked pushes the @data into the @queue. @data must not be nil.
//
// This function must be called while holding the @queue's lock.
func (queue *AsyncQueue) PushUnlocked(data interface{}) {
	var arg0 *C.GAsyncQueue
	var arg1 C.gpointer

	arg0 = (*C.GAsyncQueue)(queue.Native())
	arg1 = C.gpointer(box.Assign(data))

	C.g_async_queue_push_unlocked(arg0, arg1)
}

// Ref increases the reference count of the asynchronous @queue by 1. You do not
// need to hold the lock to call this function.
func (queue *AsyncQueue) Ref() *AsyncQueue {
	var arg0 *C.GAsyncQueue

	arg0 = (*C.GAsyncQueue)(queue.Native())

	ret := C.g_async_queue_ref(arg0)

	var ret0 *AsyncQueue

	{
		ret0 = WrapAsyncQueue(unsafe.Pointer(ret))
	}

	return ret0
}

// RefUnlocked increases the reference count of the asynchronous @queue by 1.
func (queue *AsyncQueue) RefUnlocked() {
	var arg0 *C.GAsyncQueue

	arg0 = (*C.GAsyncQueue)(queue.Native())

	C.g_async_queue_ref_unlocked(arg0)
}

// Remove: remove an item from the queue.
func (queue *AsyncQueue) Remove(item interface{}) bool {
	var arg0 *C.GAsyncQueue
	var arg1 C.gpointer

	arg0 = (*C.GAsyncQueue)(queue.Native())
	arg1 = C.gpointer(box.Assign(item))

	ret := C.g_async_queue_remove(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// RemoveUnlocked: remove an item from the queue.
//
// This function must be called while holding the @queue's lock.
func (queue *AsyncQueue) RemoveUnlocked(item interface{}) bool {
	var arg0 *C.GAsyncQueue
	var arg1 C.gpointer

	arg0 = (*C.GAsyncQueue)(queue.Native())
	arg1 = C.gpointer(box.Assign(item))

	ret := C.g_async_queue_remove_unlocked(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Sort sorts @queue using @func.
//
// The sort function @func is passed two elements of the @queue. It should
// return 0 if they are equal, a negative value if the first element should be
// higher in the @queue or a positive value if the first element should be lower
// in the @queue than the second element.
//
// This function will lock @queue before it sorts the queue and unlock it when
// it is finished.
//
// If you were sorting a list of priority numbers to make sure the lowest
// priority would be at the top of the queue, you could use:
//
//     gint32 id1;
//     gint32 id2;
//
//     id1 = GPOINTER_TO_INT (element1);
//     id2 = GPOINTER_TO_INT (element2);
//
//     return (id1 > id2 ? +1 : id1 == id2 ? 0 : -1);
func (queue *AsyncQueue) Sort(fn CompareDataFunc) {
	var arg0 *C.GAsyncQueue
	var arg1 C.GCompareDataFunc
	var arg2 C.gpointer

	arg0 = (*C.GAsyncQueue)(queue.Native())
	arg1 = (*[0]byte)(C.gotk4_CompareDataFunc)
	arg2 = C.gpointer(box.Assign(fn))

	C.g_async_queue_sort(arg0, arg1, arg2)
}

// SortUnlocked sorts @queue using @func.
//
// The sort function @func is passed two elements of the @queue. It should
// return 0 if they are equal, a negative value if the first element should be
// higher in the @queue or a positive value if the first element should be lower
// in the @queue than the second element.
//
// This function must be called while holding the @queue's lock.
func (queue *AsyncQueue) SortUnlocked(fn CompareDataFunc) {
	var arg0 *C.GAsyncQueue
	var arg1 C.GCompareDataFunc
	var arg2 C.gpointer

	arg0 = (*C.GAsyncQueue)(queue.Native())
	arg1 = (*[0]byte)(C.gotk4_CompareDataFunc)
	arg2 = C.gpointer(box.Assign(fn))

	C.g_async_queue_sort_unlocked(arg0, arg1, arg2)
}

// TimedPop pops data from the @queue. If the queue is empty, blocks until
// @end_time or until data becomes available.
//
// If no data is received before @end_time, nil is returned.
//
// To easily calculate @end_time, a combination of g_get_real_time() and
// g_time_val_add() can be used.
func (queue *AsyncQueue) TimedPop(endTime *TimeVal) interface{} {
	var arg0 *C.GAsyncQueue
	var arg1 *C.GTimeVal

	arg0 = (*C.GAsyncQueue)(queue.Native())
	arg1 = (*C.GTimeVal)(endTime.Native())

	ret := C.g_async_queue_timed_pop(arg0, arg1)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// TimedPopUnlocked pops data from the @queue. If the queue is empty, blocks
// until @end_time or until data becomes available.
//
// If no data is received before @end_time, nil is returned.
//
// To easily calculate @end_time, a combination of g_get_real_time() and
// g_time_val_add() can be used.
//
// This function must be called while holding the @queue's lock.
func (queue *AsyncQueue) TimedPopUnlocked(endTime *TimeVal) interface{} {
	var arg0 *C.GAsyncQueue
	var arg1 *C.GTimeVal

	arg0 = (*C.GAsyncQueue)(queue.Native())
	arg1 = (*C.GTimeVal)(endTime.Native())

	ret := C.g_async_queue_timed_pop_unlocked(arg0, arg1)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// TimeoutPop pops data from the @queue. If the queue is empty, blocks for
// @timeout microseconds, or until data becomes available.
//
// If no data is received before the timeout, nil is returned.
func (queue *AsyncQueue) TimeoutPop(timeout uint64) interface{} {
	var arg0 *C.GAsyncQueue
	var arg1 C.guint64

	arg0 = (*C.GAsyncQueue)(queue.Native())
	arg1 = C.guint64(timeout)

	ret := C.g_async_queue_timeout_pop(arg0, arg1)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// TimeoutPopUnlocked pops data from the @queue. If the queue is empty, blocks
// for @timeout microseconds, or until data becomes available.
//
// If no data is received before the timeout, nil is returned.
//
// This function must be called while holding the @queue's lock.
func (queue *AsyncQueue) TimeoutPopUnlocked(timeout uint64) interface{} {
	var arg0 *C.GAsyncQueue
	var arg1 C.guint64

	arg0 = (*C.GAsyncQueue)(queue.Native())
	arg1 = C.guint64(timeout)

	ret := C.g_async_queue_timeout_pop_unlocked(arg0, arg1)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// TryPop tries to pop data from the @queue. If no data is available, nil is
// returned.
func (queue *AsyncQueue) TryPop() interface{} {
	var arg0 *C.GAsyncQueue

	arg0 = (*C.GAsyncQueue)(queue.Native())

	ret := C.g_async_queue_try_pop(arg0)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// TryPopUnlocked tries to pop data from the @queue. If no data is available,
// nil is returned.
//
// This function must be called while holding the @queue's lock.
func (queue *AsyncQueue) TryPopUnlocked() interface{} {
	var arg0 *C.GAsyncQueue

	arg0 = (*C.GAsyncQueue)(queue.Native())

	ret := C.g_async_queue_try_pop_unlocked(arg0)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// Unlock releases the queue's lock.
//
// Calling this function when you have not acquired the with
// g_async_queue_lock() leads to undefined behaviour.
func (queue *AsyncQueue) Unlock() {
	var arg0 *C.GAsyncQueue

	arg0 = (*C.GAsyncQueue)(queue.Native())

	C.g_async_queue_unlock(arg0)
}

// Unref decreases the reference count of the asynchronous @queue by 1.
//
// If the reference count went to 0, the @queue will be destroyed and the memory
// allocated will be freed. So you are not allowed to use the @queue afterwards,
// as it might have disappeared. You do not need to hold the lock to call this
// function.
func (queue *AsyncQueue) Unref() {
	var arg0 *C.GAsyncQueue

	arg0 = (*C.GAsyncQueue)(queue.Native())

	C.g_async_queue_unref(arg0)
}

// UnrefAndUnlock decreases the reference count of the asynchronous @queue by 1
// and releases the lock. This function must be called while holding the
// @queue's lock. If the reference count went to 0, the @queue will be destroyed
// and the memory allocated will be freed.
func (queue *AsyncQueue) UnrefAndUnlock() {
	var arg0 *C.GAsyncQueue

	arg0 = (*C.GAsyncQueue)(queue.Native())

	C.g_async_queue_unref_and_unlock(arg0)
}

// BookmarkFile: the `GBookmarkFile` structure contains only private data and
// should not be directly accessed.
type BookmarkFile struct {
	native C.GBookmarkFile
}

// WrapBookmarkFile wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapBookmarkFile(ptr unsafe.Pointer) *BookmarkFile {
	if ptr == nil {
		return nil
	}

	return (*BookmarkFile)(ptr)
}

func marshalBookmarkFile(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapBookmarkFile(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (b *BookmarkFile) Native() unsafe.Pointer {
	return unsafe.Pointer(&b.native)
}

// AddApplication adds the application with @name and @exec to the list of
// applications that have registered a bookmark for @uri into @bookmark.
//
// Every bookmark inside a File must have at least an application registered.
// Each application must provide a name, a command line useful for launching the
// bookmark, the number of times the bookmark has been registered by the
// application and the last time the application registered this bookmark.
//
// If @name is nil, the name of the application will be the same returned by
// g_get_application_name(); if @exec is nil, the command line will be a
// composition of the program name as returned by g_get_prgname() and the "\u"
// modifier, which will be expanded to the bookmark's URI.
//
// This function will automatically take care of updating the registrations
// count and timestamping in case an application with the same @name had already
// registered a bookmark for @uri inside @bookmark.
//
// If no bookmark for @uri is found, one is created.
func (bookmark *BookmarkFile) AddApplication(uri string, name string, exec string) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(exec))
	defer C.free(unsafe.Pointer(arg3))

	C.g_bookmark_file_add_application(arg0, arg1, arg2, arg3)
}

// AddGroup adds @group to the list of groups to which the bookmark for @uri
// belongs to.
//
// If no bookmark for @uri is found then it is created.
func (bookmark *BookmarkFile) AddGroup(uri string, group string) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(group))
	defer C.free(unsafe.Pointer(arg2))

	C.g_bookmark_file_add_group(arg0, arg1, arg2)
}

// Free frees a File.
func (bookmark *BookmarkFile) Free() {
	var arg0 *C.GBookmarkFile

	arg0 = (*C.GBookmarkFile)(bookmark.Native())

	C.g_bookmark_file_free(arg0)
}

// Added gets the time the bookmark for @uri was added to @bookmark
//
// In the event the URI cannot be found, -1 is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (bookmark *BookmarkFile) Added(uri string) (glong int32, err error) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_bookmark_file_get_added(arg0, arg1, &gError)

	var ret0 int32
	var goError error

	ret0 = int32(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// AddedDateTime gets the time the bookmark for @uri was added to @bookmark
//
// In the event the URI cannot be found, nil is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (bookmark *BookmarkFile) AddedDateTime(uri string) (dateTime *DateTime, err error) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.char
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_bookmark_file_get_added_date_time(arg0, arg1, &gError)

	var ret0 *DateTime
	var goError error

	{
		ret0 = WrapDateTime(unsafe.Pointer(ret))
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// AppInfo gets the registration information of @app_name for the bookmark for
// @uri. See g_bookmark_file_set_application_info() for more information about
// the returned data.
//
// The string returned in @app_exec must be freed.
//
// In the event the URI cannot be found, false is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND. In the event that no application with name
// @app_name has registered a bookmark for @uri, false is returned and error is
// set to BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED. In the event that unquoting
// the command line fails, an error of the SHELL_ERROR domain is set and false
// is returned.
func (bookmark *BookmarkFile) AppInfo(uri string, name string) (exec string, count uint, stamp int32, err error) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 **C.gchar // out
	var arg4 *C.guint  // out
	var arg5 *C.time_t // out
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_bookmark_file_get_app_info(arg0, arg1, arg2, &arg3, &arg4, &arg5, &gError)

	var ret0 string
	var ret1 uint
	var ret2 int32
	var goError error

	ret0 = C.GoString(arg3)
	C.free(unsafe.Pointer(arg3))

	ret1 = uint(arg4)

	ret2 = int32(arg5)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}

// ApplicationInfo gets the registration information of @app_name for the
// bookmark for @uri. See g_bookmark_file_set_application_info() for more
// information about the returned data.
//
// The string returned in @app_exec must be freed.
//
// In the event the URI cannot be found, false is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND. In the event that no application with name
// @app_name has registered a bookmark for @uri, false is returned and error is
// set to BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED. In the event that unquoting
// the command line fails, an error of the SHELL_ERROR domain is set and false
// is returned.
func (bookmark *BookmarkFile) ApplicationInfo(uri string, name string) (exec string, count uint, stamp *DateTime, err error) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.char
	var arg2 *C.char
	var arg3 **C.char      // out
	var arg4 *C.uint       // out
	var arg5 **C.GDateTime // out
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_bookmark_file_get_application_info(arg0, arg1, arg2, &arg3, &arg4, &arg5, &gError)

	var ret0 string
	var ret1 uint
	var ret2 **DateTime
	var goError error

	ret0 = C.GoString(arg3)
	C.free(unsafe.Pointer(arg3))

	ret1 = uint(arg4)

	{
		ret2 = WrapDateTime(unsafe.Pointer(arg5))
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}

// Applications retrieves the names of the applications that have registered the
// bookmark for @uri.
//
// In the event the URI cannot be found, nil is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (bookmark *BookmarkFile) Applications(uri string) (length uint, utf8s []string, err error) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 *C.gsize // out
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_bookmark_file_get_applications(arg0, arg1, &arg2, &gError)

	var ret0 uint
	var ret1 []string
	var goError error

	ret0 = uint(arg2)

	{
		ret1 = make([]string, arg2)
		for i := 0; i < uintptr(arg2); i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// Description retrieves the description of the bookmark for @uri.
//
// In the event the URI cannot be found, nil is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (bookmark *BookmarkFile) Description(uri string) (utf8 string, err error) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_bookmark_file_get_description(arg0, arg1, &gError)

	var ret0 string
	var goError error

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Groups retrieves the list of group names of the bookmark for @uri.
//
// In the event the URI cannot be found, nil is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
//
// The returned array is nil terminated, so @length may optionally be nil.
func (bookmark *BookmarkFile) Groups(uri string) (length uint, utf8s []string, err error) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 *C.gsize // out
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_bookmark_file_get_groups(arg0, arg1, &arg2, &gError)

	var ret0 uint
	var ret1 []string
	var goError error

	ret0 = uint(arg2)

	{
		ret1 = make([]string, arg2)
		for i := 0; i < uintptr(arg2); i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// Icon gets the icon of the bookmark for @uri.
//
// In the event the URI cannot be found, false is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (bookmark *BookmarkFile) Icon(uri string) (href string, mimeType string, err error) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 **C.gchar // out
	var arg3 **C.gchar // out
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_bookmark_file_get_icon(arg0, arg1, &arg2, &arg3, &gError)

	var ret0 string
	var ret1 string
	var goError error

	ret0 = C.GoString(arg2)
	C.free(unsafe.Pointer(arg2))

	ret1 = C.GoString(arg3)
	C.free(unsafe.Pointer(arg3))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// IsPrivate gets whether the private flag of the bookmark for @uri is set.
//
// In the event the URI cannot be found, false is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND. In the event that the private flag cannot
// be found, false is returned and @error is set to
// BOOKMARK_FILE_ERROR_INVALID_VALUE.
func (bookmark *BookmarkFile) IsPrivate(uri string) error {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_bookmark_file_get_is_private(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// MIMEType retrieves the MIME type of the resource pointed by @uri.
//
// In the event the URI cannot be found, nil is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND. In the event that the MIME type cannot be
// found, nil is returned and @error is set to
// BOOKMARK_FILE_ERROR_INVALID_VALUE.
func (bookmark *BookmarkFile) MIMEType(uri string) (utf8 string, err error) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_bookmark_file_get_mime_type(arg0, arg1, &gError)

	var ret0 string
	var goError error

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Modified gets the time when the bookmark for @uri was last modified.
//
// In the event the URI cannot be found, -1 is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (bookmark *BookmarkFile) Modified(uri string) (glong int32, err error) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_bookmark_file_get_modified(arg0, arg1, &gError)

	var ret0 int32
	var goError error

	ret0 = int32(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// ModifiedDateTime gets the time when the bookmark for @uri was last modified.
//
// In the event the URI cannot be found, nil is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (bookmark *BookmarkFile) ModifiedDateTime(uri string) (dateTime *DateTime, err error) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.char
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_bookmark_file_get_modified_date_time(arg0, arg1, &gError)

	var ret0 *DateTime
	var goError error

	{
		ret0 = WrapDateTime(unsafe.Pointer(ret))
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Size gets the number of bookmarks inside @bookmark.
func (bookmark *BookmarkFile) Size() int {
	var arg0 *C.GBookmarkFile

	arg0 = (*C.GBookmarkFile)(bookmark.Native())

	ret := C.g_bookmark_file_get_size(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Title returns the title of the bookmark for @uri.
//
// If @uri is nil, the title of @bookmark is returned.
//
// In the event the URI cannot be found, nil is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (bookmark *BookmarkFile) Title(uri string) (utf8 string, err error) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_bookmark_file_get_title(arg0, arg1, &gError)

	var ret0 string
	var goError error

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Uris returns all URIs of the bookmarks in the bookmark file @bookmark. The
// array of returned URIs will be nil-terminated, so @length may optionally be
// nil.
func (bookmark *BookmarkFile) Uris() (length uint, utf8s []string) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gsize // out

	arg0 = (*C.GBookmarkFile)(bookmark.Native())

	ret := C.g_bookmark_file_get_uris(arg0, &arg1)

	var ret0 uint
	var ret1 []string

	ret0 = uint(arg1)

	{
		ret1 = make([]string, arg1)
		for i := 0; i < uintptr(arg1); i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0, ret1
}

// Visited gets the time the bookmark for @uri was last visited.
//
// In the event the URI cannot be found, -1 is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (bookmark *BookmarkFile) Visited(uri string) (glong int32, err error) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_bookmark_file_get_visited(arg0, arg1, &gError)

	var ret0 int32
	var goError error

	ret0 = int32(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// VisitedDateTime gets the time the bookmark for @uri was last visited.
//
// In the event the URI cannot be found, nil is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (bookmark *BookmarkFile) VisitedDateTime(uri string) (dateTime *DateTime, err error) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.char
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_bookmark_file_get_visited_date_time(arg0, arg1, &gError)

	var ret0 *DateTime
	var goError error

	{
		ret0 = WrapDateTime(unsafe.Pointer(ret))
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// HasApplication checks whether the bookmark for @uri inside @bookmark has been
// registered by application @name.
//
// In the event the URI cannot be found, false is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (bookmark *BookmarkFile) HasApplication(uri string, name string) error {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_bookmark_file_has_application(arg0, arg1, arg2, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// HasGroup checks whether @group appears in the list of groups to which the
// bookmark for @uri belongs to.
//
// In the event the URI cannot be found, false is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (bookmark *BookmarkFile) HasGroup(uri string, group string) error {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(group))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_bookmark_file_has_group(arg0, arg1, arg2, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// HasItem looks whether the desktop bookmark has an item with its URI set to
// @uri.
func (bookmark *BookmarkFile) HasItem(uri string) bool {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_bookmark_file_has_item(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// LoadFromData loads a bookmark file from memory into an empty File structure.
// If the object cannot be created then @error is set to a FileError.
func (bookmark *BookmarkFile) LoadFromData(data []byte) error {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 C.gsize
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(unsafe.Pointer(&data[0]))
	arg2 = len(data)
	defer runtime.KeepAlive(data)

	ret := C.g_bookmark_file_load_from_data(arg0, arg1, arg2, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// LoadFromDataDirs: this function looks for a desktop bookmark file named @file
// in the paths returned from g_get_user_data_dir() and
// g_get_system_data_dirs(), loads the file into @bookmark and returns the
// file's full path in @full_path. If the file could not be loaded then @error
// is set to either a Error or FileError.
func (bookmark *BookmarkFile) LoadFromDataDirs(file string) (fullPath string, err error) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 **C.gchar // out
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(file))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_bookmark_file_load_from_data_dirs(arg0, arg1, &arg2, &gError)

	var ret0 string
	var goError error

	ret0 = C.GoString(arg2)
	C.free(unsafe.Pointer(arg2))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// LoadFromFile loads a desktop bookmark file into an empty File structure. If
// the file could not be loaded then @error is set to either a Error or
// FileError.
func (bookmark *BookmarkFile) LoadFromFile(filename string) error {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_bookmark_file_load_from_file(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// MoveItem changes the URI of a bookmark item from @old_uri to @new_uri. Any
// existing bookmark for @new_uri will be overwritten. If @new_uri is nil, then
// the bookmark is removed.
//
// In the event the URI cannot be found, false is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (bookmark *BookmarkFile) MoveItem(oldURI string, newURI string) error {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(oldURI))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(newURI))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_bookmark_file_move_item(arg0, arg1, arg2, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// RemoveApplication removes application registered with @name from the list of
// applications that have registered a bookmark for @uri inside @bookmark.
//
// In the event the URI cannot be found, false is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND. In the event that no application with name
// @app_name has registered a bookmark for @uri, false is returned and error is
// set to BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED.
func (bookmark *BookmarkFile) RemoveApplication(uri string, name string) error {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_bookmark_file_remove_application(arg0, arg1, arg2, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// RemoveGroup removes @group from the list of groups to which the bookmark for
// @uri belongs to.
//
// In the event the URI cannot be found, false is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND. In the event no group was defined, false
// is returned and @error is set to BOOKMARK_FILE_ERROR_INVALID_VALUE.
func (bookmark *BookmarkFile) RemoveGroup(uri string, group string) error {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(group))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_bookmark_file_remove_group(arg0, arg1, arg2, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// RemoveItem removes the bookmark for @uri from the bookmark file @bookmark.
func (bookmark *BookmarkFile) RemoveItem(uri string) error {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_bookmark_file_remove_item(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SetAdded sets the time the bookmark for @uri was added into @bookmark.
//
// If no bookmark for @uri is found then it is created.
func (bookmark *BookmarkFile) SetAdded(uri string, added int32) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 C.time_t

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.time_t(added)

	C.g_bookmark_file_set_added(arg0, arg1, arg2)
}

// SetAddedDateTime sets the time the bookmark for @uri was added into
// @bookmark.
//
// If no bookmark for @uri is found then it is created.
func (bookmark *BookmarkFile) SetAddedDateTime(uri string, added *DateTime) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.char
	var arg2 *C.GDateTime

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GDateTime)(added.Native())

	C.g_bookmark_file_set_added_date_time(arg0, arg1, arg2)
}

// SetAppInfo sets the meta-data of application @name inside the list of
// applications that have registered a bookmark for @uri inside @bookmark.
//
// You should rarely use this function; use g_bookmark_file_add_application()
// and g_bookmark_file_remove_application() instead.
//
// @name can be any UTF-8 encoded string used to identify an application. @exec
// can have one of these two modifiers: "\f", which will be expanded as the
// local file name retrieved from the bookmark's URI; "\u", which will be
// expanded as the bookmark's URI. The expansion is done automatically when
// retrieving the stored command line using the
// g_bookmark_file_get_application_info() function. @count is the number of
// times the application has registered the bookmark; if is < 0, the current
// registration count will be increased by one, if is 0, the application with
// @name will be removed from the list of registered applications. @stamp is the
// Unix time of the last registration; if it is -1, the current time will be
// used.
//
// If you try to remove an application by setting its registration count to
// zero, and no bookmark for @uri is found, false is returned and @error is set
// to BOOKMARK_FILE_ERROR_URI_NOT_FOUND; similarly, in the event that no
// application @name has registered a bookmark for @uri, false is returned and
// error is set to BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED. Otherwise, if no
// bookmark for @uri is found, one is created.
func (bookmark *BookmarkFile) SetAppInfo(uri string, name string, exec string, count int, stamp int32) error {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 C.gint
	var arg5 C.time_t
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(exec))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = C.gint(count)
	arg5 = C.time_t(stamp)

	ret := C.g_bookmark_file_set_app_info(arg0, arg1, arg2, arg3, arg4, arg5, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SetApplicationInfo sets the meta-data of application @name inside the list of
// applications that have registered a bookmark for @uri inside @bookmark.
//
// You should rarely use this function; use g_bookmark_file_add_application()
// and g_bookmark_file_remove_application() instead.
//
// @name can be any UTF-8 encoded string used to identify an application. @exec
// can have one of these two modifiers: "\f", which will be expanded as the
// local file name retrieved from the bookmark's URI; "\u", which will be
// expanded as the bookmark's URI. The expansion is done automatically when
// retrieving the stored command line using the
// g_bookmark_file_get_application_info() function. @count is the number of
// times the application has registered the bookmark; if is < 0, the current
// registration count will be increased by one, if is 0, the application with
// @name will be removed from the list of registered applications. @stamp is the
// Unix time of the last registration.
//
// If you try to remove an application by setting its registration count to
// zero, and no bookmark for @uri is found, false is returned and @error is set
// to BOOKMARK_FILE_ERROR_URI_NOT_FOUND; similarly, in the event that no
// application @name has registered a bookmark for @uri, false is returned and
// error is set to BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED. Otherwise, if no
// bookmark for @uri is found, one is created.
func (bookmark *BookmarkFile) SetApplicationInfo(uri string, name string, exec string, count int, stamp *DateTime) error {
	var arg0 *C.GBookmarkFile
	var arg1 *C.char
	var arg2 *C.char
	var arg3 *C.char
	var arg4 C.int
	var arg5 *C.GDateTime
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(exec))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = C.int(count)
	arg5 = (*C.GDateTime)(stamp.Native())

	ret := C.g_bookmark_file_set_application_info(arg0, arg1, arg2, arg3, arg4, arg5, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SetDescription sets @description as the description of the bookmark for @uri.
//
// If @uri is nil, the description of @bookmark is set.
//
// If a bookmark for @uri cannot be found then it is created.
func (bookmark *BookmarkFile) SetDescription(uri string, description string) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(description))
	defer C.free(unsafe.Pointer(arg2))

	C.g_bookmark_file_set_description(arg0, arg1, arg2)
}

// SetGroups sets a list of group names for the item with URI @uri. Each
// previously set group name list is removed.
//
// If @uri cannot be found then an item for it is created.
func (bookmark *BookmarkFile) SetGroups(uri string, groups []string) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 **C.gchar
	var arg3 C.gsize

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * len(groups))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(groups)
		sliceHeader.Cap = len(groups)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(groups); i++ {
			src := groups[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg2 = (**C.gchar)(unsafe.Pointer(ptr))
		arg3 = len(groups)
	}

	C.g_bookmark_file_set_groups(arg0, arg1, arg2, arg3)
}

// SetIcon sets the icon for the bookmark for @uri. If @href is nil, unsets the
// currently set icon. @href can either be a full URL for the icon file or the
// icon name following the Icon Naming specification.
//
// If no bookmark for @uri is found one is created.
func (bookmark *BookmarkFile) SetIcon(uri string, href string, mimeType string) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(href))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(mimeType))
	defer C.free(unsafe.Pointer(arg3))

	C.g_bookmark_file_set_icon(arg0, arg1, arg2, arg3)
}

// SetIsPrivate sets the private flag of the bookmark for @uri.
//
// If a bookmark for @uri cannot be found then it is created.
func (bookmark *BookmarkFile) SetIsPrivate(uri string, isPrivate bool) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 C.gboolean

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	if isPrivate {
		arg2 = C.TRUE
	}

	C.g_bookmark_file_set_is_private(arg0, arg1, arg2)
}

// SetMIMEType sets @mime_type as the MIME type of the bookmark for @uri.
//
// If a bookmark for @uri cannot be found then it is created.
func (bookmark *BookmarkFile) SetMIMEType(uri string, mimeType string) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(mimeType))
	defer C.free(unsafe.Pointer(arg2))

	C.g_bookmark_file_set_mime_type(arg0, arg1, arg2)
}

// SetModified sets the last time the bookmark for @uri was last modified.
//
// If no bookmark for @uri is found then it is created.
//
// The "modified" time should only be set when the bookmark's meta-data was
// actually changed. Every function of File that modifies a bookmark also
// changes the modification time, except for
// g_bookmark_file_set_visited_date_time().
func (bookmark *BookmarkFile) SetModified(uri string, modified int32) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 C.time_t

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.time_t(modified)

	C.g_bookmark_file_set_modified(arg0, arg1, arg2)
}

// SetModifiedDateTime sets the last time the bookmark for @uri was last
// modified.
//
// If no bookmark for @uri is found then it is created.
//
// The "modified" time should only be set when the bookmark's meta-data was
// actually changed. Every function of File that modifies a bookmark also
// changes the modification time, except for
// g_bookmark_file_set_visited_date_time().
func (bookmark *BookmarkFile) SetModifiedDateTime(uri string, modified *DateTime) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.char
	var arg2 *C.GDateTime

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GDateTime)(modified.Native())

	C.g_bookmark_file_set_modified_date_time(arg0, arg1, arg2)
}

// SetTitle sets @title as the title of the bookmark for @uri inside the
// bookmark file @bookmark.
//
// If @uri is nil, the title of @bookmark is set.
//
// If a bookmark for @uri cannot be found then it is created.
func (bookmark *BookmarkFile) SetTitle(uri string, title string) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(arg2))

	C.g_bookmark_file_set_title(arg0, arg1, arg2)
}

// SetVisited sets the time the bookmark for @uri was last visited.
//
// If no bookmark for @uri is found then it is created.
//
// The "visited" time should only be set if the bookmark was launched, either
// using the command line retrieved by g_bookmark_file_get_application_info() or
// by the default application for the bookmark's MIME type, retrieved using
// g_bookmark_file_get_mime_type(). Changing the "visited" time does not affect
// the "modified" time.
func (bookmark *BookmarkFile) SetVisited(uri string, visited int32) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 C.time_t

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.time_t(visited)

	C.g_bookmark_file_set_visited(arg0, arg1, arg2)
}

// SetVisitedDateTime sets the time the bookmark for @uri was last visited.
//
// If no bookmark for @uri is found then it is created.
//
// The "visited" time should only be set if the bookmark was launched, either
// using the command line retrieved by g_bookmark_file_get_application_info() or
// by the default application for the bookmark's MIME type, retrieved using
// g_bookmark_file_get_mime_type(). Changing the "visited" time does not affect
// the "modified" time.
func (bookmark *BookmarkFile) SetVisitedDateTime(uri string, visited *DateTime) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.char
	var arg2 *C.GDateTime

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GDateTime)(visited.Native())

	C.g_bookmark_file_set_visited_date_time(arg0, arg1, arg2)
}

// ToData: this function outputs @bookmark as a string.
func (bookmark *BookmarkFile) ToData() (length uint, guint8s []byte, err error) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gsize // out
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(bookmark.Native())

	ret := C.g_bookmark_file_to_data(arg0, &arg1, &gError)

	var ret0 uint
	var ret1 []byte
	var goError error

	ret0 = uint(arg1)

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret1))
		sliceHeader.Data = uintptr(unsafe.Pointer(ret))
		sliceHeader.Len = arg1
		sliceHeader.Cap = arg1
		runtime.SetFinalizer(&ret, func() {
			C.free(unsafe.Pointer(ret))
		})
		defer runtime.KeepAlive(ret)
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// ToFile: this function outputs @bookmark into a file. The write process is
// guaranteed to be atomic by using g_file_set_contents() internally.
func (bookmark *BookmarkFile) ToFile(filename string) error {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(bookmark.Native())
	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_bookmark_file_to_file(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// ByteArray contains the public fields of a GByteArray.
type ByteArray struct {
	native C.GByteArray
}

// WrapByteArray wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapByteArray(ptr unsafe.Pointer) *ByteArray {
	if ptr == nil {
		return nil
	}

	return (*ByteArray)(ptr)
}

func marshalByteArray(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapByteArray(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (b *ByteArray) Native() unsafe.Pointer {
	return unsafe.Pointer(&b.native)
}

// Data gets the field inside the struct.
func (b *ByteArray) Data() byte {
	var ret byte
	ret = byte(b.native.data)
	return ret
}

// Len gets the field inside the struct.
func (b *ByteArray) Len() uint {
	var ret uint
	ret = uint(b.native.len)
	return ret
}

// Bytes: a simple refcounted data type representing an immutable sequence of
// zero or more bytes from an unspecified origin.
//
// The purpose of a #GBytes is to keep the memory region that it holds alive for
// as long as anyone holds a reference to the bytes. When the last reference
// count is dropped, the memory is released. Multiple unrelated callers can use
// byte data in the #GBytes without coordinating their activities, resting
// assured that the byte data will not change or move while they hold a
// reference.
//
// A #GBytes can come from many different origins that may have different
// procedures for freeing the memory region. Examples are memory from
// g_malloc(), from memory slices, from a File or memory from other allocators.
//
// #GBytes work well as keys in Table. Use g_bytes_equal() and g_bytes_hash() as
// parameters to g_hash_table_new() or g_hash_table_new_full(). #GBytes can also
// be used as keys in a #GTree by passing the g_bytes_compare() function to
// g_tree_new().
//
// The data pointed to by this bytes must not be modified. For a mutable array
// of bytes see Array. Use g_bytes_unref_to_array() to create a mutable array
// for a #GBytes sequence. To create an immutable #GBytes from a mutable Array,
// use the g_byte_array_free_to_bytes() function.
type Bytes struct {
	native C.GBytes
}

// WrapBytes wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapBytes(ptr unsafe.Pointer) *Bytes {
	if ptr == nil {
		return nil
	}

	return (*Bytes)(ptr)
}

func marshalBytes(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapBytes(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (b *Bytes) Native() unsafe.Pointer {
	return unsafe.Pointer(&b.native)
}

// NewBytes constructs a struct Bytes.
func NewBytes(data []byte) *Bytes {
	var arg1 C.gpointer
	var arg2 C.gsize

	arg1 = (C.gpointer)(unsafe.Pointer(&data[0]))
	arg2 = len(data)
	defer runtime.KeepAlive(data)

	ret := C.g_bytes_new(arg1, arg2)

	var ret0 *Bytes

	{
		ret0 = WrapBytes(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Bytes) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewBytesStatic constructs a struct Bytes.
func NewBytesStatic(data []byte) *Bytes {
	var arg1 C.gpointer
	var arg2 C.gsize

	{
		var dst []C.guint8
		ptr := C.malloc(C.sizeof_guint8 * len(data))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(data)
		sliceHeader.Cap = len(data)

		for i := 0; i < len(data); i++ {
			src := data[i]
			dst[i] = C.guint8(src)
		}

		arg1 = (C.gpointer)(unsafe.Pointer(ptr))
		arg2 = len(data)
	}

	ret := C.g_bytes_new_static(arg1, arg2)

	var ret0 *Bytes

	{
		ret0 = WrapBytes(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Bytes) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewBytesTake constructs a struct Bytes.
func NewBytesTake(data []byte) *Bytes {
	var arg1 C.gpointer
	var arg2 C.gsize

	{
		var dst []C.guint8
		ptr := C.malloc(C.sizeof_guint8 * len(data))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(data)
		sliceHeader.Cap = len(data)

		for i := 0; i < len(data); i++ {
			src := data[i]
			dst[i] = C.guint8(src)
		}

		arg1 = (C.gpointer)(unsafe.Pointer(ptr))
		arg2 = len(data)
	}

	ret := C.g_bytes_new_take(arg1, arg2)

	var ret0 *Bytes

	{
		ret0 = WrapBytes(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Bytes) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Compare compares the two #GBytes values.
//
// This function can be used to sort GBytes instances in lexicographical order.
//
// If @bytes1 and @bytes2 have different length but the shorter one is a prefix
// of the longer one then the shorter one is considered to be less than the
// longer one. Otherwise the first byte where both differ is used for
// comparison. If @bytes1 has a smaller value at that position it is considered
// less, otherwise greater than @bytes2.
func (bytes1 *Bytes) Compare(bytes2 Bytes) int {
	var arg0 C.gpointer
	var arg1 C.gpointer

	arg0 = (C.gpointer)(bytes1.Native())
	arg1 = (C.gpointer)(bytes2.Native())

	ret := C.g_bytes_compare(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Equal compares the two #GBytes values being pointed to and returns true if
// they are equal.
//
// This function can be passed to g_hash_table_new() as the @key_equal_func
// parameter, when using non-nil #GBytes pointers as keys in a Table.
func (bytes1 *Bytes) Equal(bytes2 Bytes) bool {
	var arg0 C.gpointer
	var arg1 C.gpointer

	arg0 = (C.gpointer)(bytes1.Native())
	arg1 = (C.gpointer)(bytes2.Native())

	ret := C.g_bytes_equal(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Data: get the byte data in the #GBytes. This data should not be modified.
//
// This function will always return the same pointer for a given #GBytes.
//
// nil may be returned if @size is 0. This is not guaranteed, as the #GBytes may
// represent an empty string with @data non-nil and @size as 0. nil will not be
// returned if @size is non-zero.
func (bytes *Bytes) Data() (size uint, guint8s []byte) {
	var arg0 *C.GBytes
	var arg1 *C.gsize // out

	arg0 = (*C.GBytes)(bytes.Native())

	ret := C.g_bytes_get_data(arg0, &arg1)

	var ret0 uint
	var ret1 []byte

	ret0 = uint(arg1)

	{
		ret1 = make([]byte, arg1)
		for i := 0; i < uintptr(arg1); i++ {
			src := (C.guint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = byte(src)
		}
	}

	return ret0, ret1
}

// Size: get the size of the byte data in the #GBytes.
//
// This function will always return the same value for a given #GBytes.
func (bytes *Bytes) Size() uint {
	var arg0 *C.GBytes

	arg0 = (*C.GBytes)(bytes.Native())

	ret := C.g_bytes_get_size(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Hash creates an integer hash code for the byte data in the #GBytes.
//
// This function can be passed to g_hash_table_new() as the @key_hash_func
// parameter, when using non-nil #GBytes pointers as keys in a Table.
func (bytes *Bytes) Hash() uint {
	var arg0 C.gpointer

	arg0 = (C.gpointer)(bytes.Native())

	ret := C.g_bytes_hash(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// NewFromBytes creates a #GBytes which is a subsection of another #GBytes. The
// @offset + @length may not be longer than the size of @bytes.
//
// A reference to @bytes will be held by the newly created #GBytes until the
// byte data is no longer needed.
//
// Since 2.56, if @offset is 0 and @length matches the size of @bytes, then
// @bytes will be returned with the reference count incremented by 1. If @bytes
// is a slice of another #GBytes, then the resulting #GBytes will reference the
// same #GBytes instead of @bytes. This allows consumers to simplify the usage
// of #GBytes when asynchronously writing to streams.
func (bytes *Bytes) NewFromBytes(offset uint, length uint) *Bytes {
	var arg0 *C.GBytes
	var arg1 C.gsize
	var arg2 C.gsize

	arg0 = (*C.GBytes)(bytes.Native())
	arg1 = C.gsize(offset)
	arg2 = C.gsize(length)

	ret := C.g_bytes_new_from_bytes(arg0, arg1, arg2)

	var ret0 *Bytes

	{
		ret0 = WrapBytes(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Bytes) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Ref: increase the reference count on @bytes.
func (bytes *Bytes) Ref() *Bytes {
	var arg0 *C.GBytes

	arg0 = (*C.GBytes)(bytes.Native())

	ret := C.g_bytes_ref(arg0)

	var ret0 *Bytes

	{
		ret0 = WrapBytes(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Bytes) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Unref releases a reference on @bytes. This may result in the bytes being
// freed. If @bytes is nil, it will return immediately.
func (bytes *Bytes) Unref() {
	var arg0 *C.GBytes

	arg0 = (*C.GBytes)(bytes.Native())

	C.g_bytes_unref(arg0)
}

// UnrefToArray unreferences the bytes, and returns a new mutable Array
// containing the same byte data.
//
// As an optimization, the byte data is transferred to the array without copying
// if this was the last reference to bytes and bytes was created with
// g_bytes_new(), g_bytes_new_take() or g_byte_array_free_to_bytes(). In all
// other cases the data is copied.
func (bytes *Bytes) UnrefToArray() []byte {
	var arg0 *C.GBytes

	arg0 = (*C.GBytes)(bytes.Native())

	ret := C.g_bytes_unref_to_array(arg0)

	var ret0 []byte

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]byte, length)
		for i := 0; i < length; i++ {
			src := (C.guint8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = byte(src)
		}
	}

	return ret0
}

// UnrefToData unreferences the bytes, and returns a pointer the same byte data
// contents.
//
// As an optimization, the byte data is returned without copying if this was the
// last reference to bytes and bytes was created with g_bytes_new(),
// g_bytes_new_take() or g_byte_array_free_to_bytes(). In all other cases the
// data is copied.
func (bytes *Bytes) UnrefToData() (size uint, guint8s []byte) {
	var arg0 *C.GBytes
	var arg1 *C.gsize // out

	arg0 = (*C.GBytes)(bytes.Native())

	ret := C.g_bytes_unref_to_data(arg0, &arg1)

	var ret0 uint
	var ret1 []byte

	ret0 = uint(arg1)

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret1))
		sliceHeader.Data = uintptr(unsafe.Pointer(ret))
		sliceHeader.Len = arg1
		sliceHeader.Cap = arg1
		runtime.SetFinalizer(&ret, func() {
			C.free(unsafe.Pointer(ret))
		})
		defer runtime.KeepAlive(ret)
	}

	return ret0, ret1
}

// Checksum: an opaque structure representing a checksumming operation. To
// create a new GChecksum, use g_checksum_new(). To free a GChecksum, use
// g_checksum_free().
type Checksum struct {
	native C.GChecksum
}

// WrapChecksum wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapChecksum(ptr unsafe.Pointer) *Checksum {
	if ptr == nil {
		return nil
	}

	return (*Checksum)(ptr)
}

func marshalChecksum(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapChecksum(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *Checksum) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

// NewChecksum constructs a struct Checksum.
func NewChecksum(checksumType ChecksumType) *Checksum {
	var arg1 C.GChecksumType

	arg1 = (C.GChecksumType)(checksumType)

	ret := C.g_checksum_new(arg1)

	var ret0 *Checksum

	{
		ret0 = WrapChecksum(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Checksum) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Copy copies a #GChecksum. If @checksum has been closed, by calling
// g_checksum_get_string() or g_checksum_get_digest(), the copied checksum will
// be closed as well.
func (checksum *Checksum) Copy() *Checksum {
	var arg0 *C.GChecksum

	arg0 = (*C.GChecksum)(checksum.Native())

	ret := C.g_checksum_copy(arg0)

	var ret0 *Checksum

	{
		ret0 = WrapChecksum(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Checksum) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Free frees the memory allocated for @checksum.
func (checksum *Checksum) Free() {
	var arg0 *C.GChecksum

	arg0 = (*C.GChecksum)(checksum.Native())

	C.g_checksum_free(arg0)
}

// Digest gets the digest from @checksum as a raw binary vector and places it
// into @buffer. The size of the digest depends on the type of checksum.
//
// Once this function has been called, the #GChecksum is closed and can no
// longer be updated with g_checksum_update().
func (checksum *Checksum) Digest(buffer []byte) {
	var arg0 *C.GChecksum
	var arg1 *C.guint8
	var arg2 *C.gsize

	arg0 = (*C.GChecksum)(checksum.Native())
	arg1 = (*C.guint8)(unsafe.Pointer(&buffer[0]))
	arg2 = len(buffer)
	defer runtime.KeepAlive(buffer)

	C.g_checksum_get_digest(arg0, arg1, arg2)
}

// String gets the digest as a hexadecimal string.
//
// Once this function has been called the #GChecksum can no longer be updated
// with g_checksum_update().
//
// The hexadecimal characters will be lower case.
func (checksum *Checksum) String() string {
	var arg0 *C.GChecksum

	arg0 = (*C.GChecksum)(checksum.Native())

	ret := C.g_checksum_get_string(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Reset resets the state of the @checksum back to its initial state.
func (checksum *Checksum) Reset() {
	var arg0 *C.GChecksum

	arg0 = (*C.GChecksum)(checksum.Native())

	C.g_checksum_reset(arg0)
}

// Update feeds @data into an existing #GChecksum. The checksum must still be
// open, that is g_checksum_get_string() or g_checksum_get_digest() must not
// have been called on @checksum.
func (checksum *Checksum) Update(data []byte) {
	var arg0 *C.GChecksum
	var arg1 *C.guchar
	var arg2 C.gssize

	arg0 = (*C.GChecksum)(checksum.Native())
	arg1 = (*C.guchar)(unsafe.Pointer(&data[0]))
	arg2 = len(data)
	defer runtime.KeepAlive(data)

	C.g_checksum_update(arg0, arg1, arg2)
}

// Cond: the #GCond struct is an opaque data structure that represents a
// condition. Threads can block on a #GCond if they find a certain condition to
// be false. If other threads change the state of this condition they signal the
// #GCond, and that causes the waiting threads to be woken up.
//
// Consider the following example of a shared variable. One or more threads can
// wait for data to be published to the variable and when another thread
// publishes the data, it can signal one of the waiting threads to wake up to
// collect the data.
//
// Here is an example for using GCond to block a thread until a condition is
// satisfied:
//
//      gpointer current_data = NULL;
//      GMutex data_mutex;
//      GCond data_cond;
//
//      void
//      push_data (gpointer data)
//      {
//        g_mutex_lock (&data_mutex);
//        current_data = data;
//        g_cond_signal (&data_cond);
//        g_mutex_unlock (&data_mutex);
//      }
//
//      gpointer
//      pop_data (void)
//      {
//        gpointer data;
//
//        g_mutex_lock (&data_mutex);
//        while (!current_data)
//          g_cond_wait (&data_cond, &data_mutex);
//        data = current_data;
//        current_data = NULL;
//        g_mutex_unlock (&data_mutex);
//
//        return data;
//      }
//
// Whenever a thread calls pop_data() now, it will wait until current_data is
// non-nil, i.e. until some other thread has called push_data().
//
// The example shows that use of a condition variable must always be paired with
// a mutex. Without the use of a mutex, there would be a race between the check
// of @current_data by the while loop in pop_data() and waiting. Specifically,
// another thread could set @current_data after the check, and signal the cond
// (with nobody waiting on it) before the first thread goes to sleep. #GCond is
// specifically useful for its ability to release the mutex and go to sleep
// atomically.
//
// It is also important to use the g_cond_wait() and g_cond_wait_until()
// functions only inside a loop which checks for the condition to be true. See
// g_cond_wait() for an explanation of why the condition may not be true even
// after it returns.
//
// If a #GCond is allocated in static storage then it can be used without
// initialisation. Otherwise, you should call g_cond_init() on it and
// g_cond_clear() when done.
//
// A #GCond should only be accessed via the g_cond_ functions.
type Cond struct {
	native C.GCond
}

// WrapCond wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapCond(ptr unsafe.Pointer) *Cond {
	if ptr == nil {
		return nil
	}

	return (*Cond)(ptr)
}

func marshalCond(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapCond(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *Cond) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

// Broadcast: if threads are waiting for @cond, all of them are unblocked. If no
// threads are waiting for @cond, this function has no effect. It is good
// practice to lock the same mutex as the waiting threads while calling this
// function, though not required.
func (cond *Cond) Broadcast() {
	var arg0 *C.GCond

	arg0 = (*C.GCond)(cond.Native())

	C.g_cond_broadcast(arg0)
}

// Clear frees the resources allocated to a #GCond with g_cond_init().
//
// This function should not be used with a #GCond that has been statically
// allocated.
//
// Calling g_cond_clear() for a #GCond on which threads are blocking leads to
// undefined behaviour.
func (cond *Cond) Clear() {
	var arg0 *C.GCond

	arg0 = (*C.GCond)(cond.Native())

	C.g_cond_clear(arg0)
}

// Init initialises a #GCond so that it can be used.
//
// This function is useful to initialise a #GCond that has been allocated as
// part of a larger structure. It is not necessary to initialise a #GCond that
// has been statically allocated.
//
// To undo the effect of g_cond_init() when a #GCond is no longer needed, use
// g_cond_clear().
//
// Calling g_cond_init() on an already-initialised #GCond leads to undefined
// behaviour.
func (cond *Cond) Init() {
	var arg0 *C.GCond

	arg0 = (*C.GCond)(cond.Native())

	C.g_cond_init(arg0)
}

// Signal: if threads are waiting for @cond, at least one of them is unblocked.
// If no threads are waiting for @cond, this function has no effect. It is good
// practice to hold the same lock as the waiting thread while calling this
// function, though not required.
func (cond *Cond) Signal() {
	var arg0 *C.GCond

	arg0 = (*C.GCond)(cond.Native())

	C.g_cond_signal(arg0)
}

// Data: the #GData struct is an opaque data structure to represent a [Keyed
// Data List][glib-Keyed-Data-Lists]. It should only be accessed via the
// following functions.
type Data struct {
	native C.GData
}

// WrapData wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapData(ptr unsafe.Pointer) *Data {
	if ptr == nil {
		return nil
	}

	return (*Data)(ptr)
}

func marshalData(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapData(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (d *Data) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}

// Date represents a day between January 1, Year 1 and a few thousand years in
// the future. None of its members should be accessed directly.
//
// If the #GDate-struct is obtained from g_date_new(), it will be safe to mutate
// but invalid and thus not safe for calendrical computations.
//
// If it's declared on the stack, it will contain garbage so must be initialized
// with g_date_clear(). g_date_clear() makes the date invalid but safe. An
// invalid date doesn't represent a day, it's "empty." A date becomes valid
// after you set it to a Julian day or you set a day, month, and year.
type Date struct {
	native C.GDate
}

// WrapDate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDate(ptr unsafe.Pointer) *Date {
	if ptr == nil {
		return nil
	}

	return (*Date)(ptr)
}

func marshalDate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (d *Date) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}

// NewDate constructs a struct Date.
func NewDate() *Date {

	ret := C.g_date_new()

	var ret0 *Date

	{
		ret0 = WrapDate(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Date) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewDateJulian constructs a struct Date.
func NewDateJulian(julianDay uint32) *Date {
	var arg1 C.guint32

	arg1 = C.guint32(julianDay)

	ret := C.g_date_new_julian(arg1)

	var ret0 *Date

	{
		ret0 = WrapDate(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Date) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// AddDays increments a date some number of days. To move forward by weeks, add
// weeks*7 days. The date must be valid.
func (date *Date) AddDays(nDays uint) {
	var arg0 *C.GDate
	var arg1 C.guint

	arg0 = (*C.GDate)(date.Native())
	arg1 = C.guint(nDays)

	C.g_date_add_days(arg0, arg1)
}

// AddMonths increments a date by some number of months. If the day of the month
// is greater than 28, this routine may change the day of the month (because the
// destination month may not have the current day in it). The date must be
// valid.
func (date *Date) AddMonths(nMonths uint) {
	var arg0 *C.GDate
	var arg1 C.guint

	arg0 = (*C.GDate)(date.Native())
	arg1 = C.guint(nMonths)

	C.g_date_add_months(arg0, arg1)
}

// AddYears increments a date by some number of years. If the date is February
// 29, and the destination year is not a leap year, the date will be changed to
// February 28. The date must be valid.
func (date *Date) AddYears(nYears uint) {
	var arg0 *C.GDate
	var arg1 C.guint

	arg0 = (*C.GDate)(date.Native())
	arg1 = C.guint(nYears)

	C.g_date_add_years(arg0, arg1)
}

// Clamp: if @date is prior to @min_date, sets @date equal to @min_date. If
// @date falls after @max_date, sets @date equal to @max_date. Otherwise, @date
// is unchanged. Either of @min_date and @max_date may be nil. All non-nil dates
// must be valid.
func (date *Date) Clamp(minDate *Date, maxDate *Date) {
	var arg0 *C.GDate
	var arg1 *C.GDate
	var arg2 *C.GDate

	arg0 = (*C.GDate)(date.Native())
	arg1 = (*C.GDate)(minDate.Native())
	arg2 = (*C.GDate)(maxDate.Native())

	C.g_date_clamp(arg0, arg1, arg2)
}

// Clear initializes one or more #GDate structs to a safe but invalid state. The
// cleared dates will not represent an existing date, but will not contain
// garbage. Useful to init a date declared on the stack. Validity can be tested
// with g_date_valid().
func (date *Date) Clear(nDates uint) {
	var arg0 *C.GDate
	var arg1 C.guint

	arg0 = (*C.GDate)(date.Native())
	arg1 = C.guint(nDates)

	C.g_date_clear(arg0, arg1)
}

// Compare: qsort()-style comparison function for dates. Both dates must be
// valid.
func (lhs *Date) Compare(rhs *Date) int {
	var arg0 *C.GDate
	var arg1 *C.GDate

	arg0 = (*C.GDate)(lhs.Native())
	arg1 = (*C.GDate)(rhs.Native())

	ret := C.g_date_compare(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Copy copies a GDate to a newly-allocated GDate. If the input was invalid (as
// determined by g_date_valid()), the invalid state will be copied as is into
// the new object.
func (date *Date) Copy() *Date {
	var arg0 *C.GDate

	arg0 = (*C.GDate)(date.Native())

	ret := C.g_date_copy(arg0)

	var ret0 *Date

	{
		ret0 = WrapDate(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Date) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// DaysBetween computes the number of days between two dates. If @date2 is prior
// to @date1, the returned value is negative. Both dates must be valid.
func (date1 *Date) DaysBetween(date2 *Date) int {
	var arg0 *C.GDate
	var arg1 *C.GDate

	arg0 = (*C.GDate)(date1.Native())
	arg1 = (*C.GDate)(date2.Native())

	ret := C.g_date_days_between(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Free frees a #GDate returned from g_date_new().
func (date *Date) Free() {
	var arg0 *C.GDate

	arg0 = (*C.GDate)(date.Native())

	C.g_date_free(arg0)
}

// Day returns the day of the month. The date must be valid.
func (date *Date) Day() DateDay {
	var arg0 *C.GDate

	arg0 = (*C.GDate)(date.Native())

	ret := C.g_date_get_day(arg0)

	var ret0 DateDay

	{
		var tmp byte
		tmp = byte(ret)
		ret0 = DateDay(tmp)
	}

	return ret0
}

// DayOfYear returns the day of the year, where Jan 1 is the first day of the
// year. The date must be valid.
func (date *Date) DayOfYear() uint {
	var arg0 *C.GDate

	arg0 = (*C.GDate)(date.Native())

	ret := C.g_date_get_day_of_year(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Iso8601WeekOfYear returns the week of the year, where weeks are interpreted
// according to ISO 8601.
func (date *Date) Iso8601WeekOfYear() uint {
	var arg0 *C.GDate

	arg0 = (*C.GDate)(date.Native())

	ret := C.g_date_get_iso8601_week_of_year(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Julian returns the Julian day or "serial number" of the #GDate. The Julian
// day is simply the number of days since January 1, Year 1; i.e., January 1,
// Year 1 is Julian day 1; January 2, Year 1 is Julian day 2, etc. The date must
// be valid.
func (date *Date) Julian() uint32 {
	var arg0 *C.GDate

	arg0 = (*C.GDate)(date.Native())

	ret := C.g_date_get_julian(arg0)

	var ret0 uint32

	ret0 = uint32(ret)

	return ret0
}

// MondayWeekOfYear returns the week of the year, where weeks are understood to
// start on Monday. If the date is before the first Monday of the year, return
// 0. The date must be valid.
func (date *Date) MondayWeekOfYear() uint {
	var arg0 *C.GDate

	arg0 = (*C.GDate)(date.Native())

	ret := C.g_date_get_monday_week_of_year(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Month returns the month of the year. The date must be valid.
func (date *Date) Month() DateMonth {
	var arg0 *C.GDate

	arg0 = (*C.GDate)(date.Native())

	ret := C.g_date_get_month(arg0)

	var ret0 DateMonth

	ret0 = DateMonth(ret)

	return ret0
}

// SundayWeekOfYear returns the week of the year during which this date falls,
// if weeks are understood to begin on Sunday. The date must be valid. Can
// return 0 if the day is before the first Sunday of the year.
func (date *Date) SundayWeekOfYear() uint {
	var arg0 *C.GDate

	arg0 = (*C.GDate)(date.Native())

	ret := C.g_date_get_sunday_week_of_year(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Weekday returns the day of the week for a #GDate. The date must be valid.
func (date *Date) Weekday() DateWeekday {
	var arg0 *C.GDate

	arg0 = (*C.GDate)(date.Native())

	ret := C.g_date_get_weekday(arg0)

	var ret0 DateWeekday

	ret0 = DateWeekday(ret)

	return ret0
}

// Year returns the year of a #GDate. The date must be valid.
func (date *Date) Year() DateYear {
	var arg0 *C.GDate

	arg0 = (*C.GDate)(date.Native())

	ret := C.g_date_get_year(arg0)

	var ret0 DateYear

	{
		var tmp uint16
		tmp = uint16(ret)
		ret0 = DateYear(tmp)
	}

	return ret0
}

// IsFirstOfMonth returns true if the date is on the first of a month. The date
// must be valid.
func (date *Date) IsFirstOfMonth() bool {
	var arg0 *C.GDate

	arg0 = (*C.GDate)(date.Native())

	ret := C.g_date_is_first_of_month(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IsLastOfMonth returns true if the date is the last day of the month. The date
// must be valid.
func (date *Date) IsLastOfMonth() bool {
	var arg0 *C.GDate

	arg0 = (*C.GDate)(date.Native())

	ret := C.g_date_is_last_of_month(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Order checks if @date1 is less than or equal to @date2, and swap the values
// if this is not the case.
func (date1 *Date) Order(date2 *Date) {
	var arg0 *C.GDate
	var arg1 *C.GDate

	arg0 = (*C.GDate)(date1.Native())
	arg1 = (*C.GDate)(date2.Native())

	C.g_date_order(arg0, arg1)
}

// SetJulian sets the value of a #GDate from a Julian day number.
func (date *Date) SetJulian(julianDate uint32) {
	var arg0 *C.GDate
	var arg1 C.guint32

	arg0 = (*C.GDate)(date.Native())
	arg1 = C.guint32(julianDate)

	C.g_date_set_julian(arg0, arg1)
}

// SetMonth sets the month of the year for a #GDate. If the resulting
// day-month-year triplet is invalid, the date will be invalid.
func (date *Date) SetMonth(month DateMonth) {
	var arg0 *C.GDate
	var arg1 C.GDateMonth

	arg0 = (*C.GDate)(date.Native())
	arg1 = (C.GDateMonth)(month)

	C.g_date_set_month(arg0, arg1)
}

// SetParse parses a user-inputted string @str, and try to figure out what date
// it represents, taking the [current locale][setlocale] into account. If the
// string is successfully parsed, the date will be valid after the call.
// Otherwise, it will be invalid. You should check using g_date_valid() to see
// whether the parsing succeeded.
//
// This function is not appropriate for file formats and the like; it isn't very
// precise, and its exact behavior varies with the locale. It's intended to be a
// heuristic routine that guesses what the user means by a given string (and it
// does work pretty well in that capacity).
func (date *Date) SetParse(str string) {
	var arg0 *C.GDate
	var arg1 *C.gchar

	arg0 = (*C.GDate)(date.Native())
	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	C.g_date_set_parse(arg0, arg1)
}

// SetTimeT sets the value of a date to the date corresponding to a time
// specified as a time_t. The time to date conversion is done using the user's
// current timezone.
//
// To set the value of a date to the current day, you could write:
//
//    time_t now = time (NULL);
//    if (now == (time_t) -1)
//      // handle the error
//    g_date_set_time_t (date, now);
func (date *Date) SetTimeT(timet int32) {
	var arg0 *C.GDate
	var arg1 C.time_t

	arg0 = (*C.GDate)(date.Native())
	arg1 = C.time_t(timet)

	C.g_date_set_time_t(arg0, arg1)
}

// SetTimeVal sets the value of a date from a Val value. Note that the @tv_usec
// member is ignored, because #GDate can't make use of the additional precision.
//
// The time to date conversion is done using the user's current timezone.
func (date *Date) SetTimeVal(timeval *TimeVal) {
	var arg0 *C.GDate
	var arg1 *C.GTimeVal

	arg0 = (*C.GDate)(date.Native())
	arg1 = (*C.GTimeVal)(timeval.Native())

	C.g_date_set_time_val(arg0, arg1)
}

// SubtractDays moves a date some number of days into the past. To move by
// weeks, just move by weeks*7 days. The date must be valid.
func (date *Date) SubtractDays(nDays uint) {
	var arg0 *C.GDate
	var arg1 C.guint

	arg0 = (*C.GDate)(date.Native())
	arg1 = C.guint(nDays)

	C.g_date_subtract_days(arg0, arg1)
}

// SubtractMonths moves a date some number of months into the past. If the
// current day of the month doesn't exist in the destination month, the day of
// the month may change. The date must be valid.
func (date *Date) SubtractMonths(nMonths uint) {
	var arg0 *C.GDate
	var arg1 C.guint

	arg0 = (*C.GDate)(date.Native())
	arg1 = C.guint(nMonths)

	C.g_date_subtract_months(arg0, arg1)
}

// SubtractYears moves a date some number of years into the past. If the current
// day doesn't exist in the destination year (i.e. it's February 29 and you move
// to a non-leap-year) then the day is changed to February 29. The date must be
// valid.
func (date *Date) SubtractYears(nYears uint) {
	var arg0 *C.GDate
	var arg1 C.guint

	arg0 = (*C.GDate)(date.Native())
	arg1 = C.guint(nYears)

	C.g_date_subtract_years(arg0, arg1)
}

// ToStructTm fills in the date-related bits of a struct tm using the @date
// value. Initializes the non-date parts with something safe but meaningless.
func (date *Date) ToStructTm(tm interface{}) {
	var arg0 *C.GDate
	var arg1 *C.tm

	arg0 = (*C.GDate)(date.Native())
	arg1 = C.gpointer(box.Assign(tm))

	C.g_date_to_struct_tm(arg0, arg1)
}

// Valid returns true if the #GDate represents an existing day. The date must
// not contain garbage; it should have been initialized with g_date_clear() if
// it wasn't allocated by one of the g_date_new() variants.
func (date *Date) Valid() bool {
	var arg0 *C.GDate

	arg0 = (*C.GDate)(date.Native())

	ret := C.g_date_valid(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// DateTime: `GDateTime` is an opaque structure whose members cannot be accessed
// directly.
type DateTime struct {
	native C.GDateTime
}

// WrapDateTime wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDateTime(ptr unsafe.Pointer) *DateTime {
	if ptr == nil {
		return nil
	}

	return (*DateTime)(ptr)
}

func marshalDateTime(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDateTime(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (d *DateTime) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}

// NewDateTime constructs a struct DateTime.
func NewDateTime(tz *TimeZone, year int, month int, day int, hour int, minute int, seconds float64) *DateTime {
	var arg1 *C.GTimeZone
	var arg2 C.gint
	var arg3 C.gint
	var arg4 C.gint
	var arg5 C.gint
	var arg6 C.gint
	var arg7 C.gdouble

	arg1 = (*C.GTimeZone)(tz.Native())
	arg2 = C.gint(year)
	arg3 = C.gint(month)
	arg4 = C.gint(day)
	arg5 = C.gint(hour)
	arg6 = C.gint(minute)
	arg7 = C.gdouble(seconds)

	ret := C.g_date_time_new(arg1, arg2, arg3, arg4, arg5, arg6, arg7)

	var ret0 *DateTime

	{
		ret0 = WrapDateTime(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *DateTime) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewDateTimeFromIso8601 constructs a struct DateTime.
func NewDateTimeFromIso8601(text string, defaultTz *TimeZone) *DateTime {
	var arg1 *C.gchar
	var arg2 *C.GTimeZone

	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GTimeZone)(defaultTz.Native())

	ret := C.g_date_time_new_from_iso8601(arg1, arg2)

	var ret0 *DateTime

	{
		ret0 = WrapDateTime(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *DateTime) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewDateTimeFromTimevalLocal constructs a struct DateTime.
func NewDateTimeFromTimevalLocal(tv *TimeVal) *DateTime {
	var arg1 *C.GTimeVal

	arg1 = (*C.GTimeVal)(tv.Native())

	ret := C.g_date_time_new_from_timeval_local(arg1)

	var ret0 *DateTime

	{
		ret0 = WrapDateTime(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *DateTime) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewDateTimeFromTimevalUtc constructs a struct DateTime.
func NewDateTimeFromTimevalUtc(tv *TimeVal) *DateTime {
	var arg1 *C.GTimeVal

	arg1 = (*C.GTimeVal)(tv.Native())

	ret := C.g_date_time_new_from_timeval_utc(arg1)

	var ret0 *DateTime

	{
		ret0 = WrapDateTime(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *DateTime) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewDateTimeFromUnixLocal constructs a struct DateTime.
func NewDateTimeFromUnixLocal(t int64) *DateTime {
	var arg1 C.gint64

	arg1 = C.gint64(t)

	ret := C.g_date_time_new_from_unix_local(arg1)

	var ret0 *DateTime

	{
		ret0 = WrapDateTime(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *DateTime) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewDateTimeFromUnixUtc constructs a struct DateTime.
func NewDateTimeFromUnixUtc(t int64) *DateTime {
	var arg1 C.gint64

	arg1 = C.gint64(t)

	ret := C.g_date_time_new_from_unix_utc(arg1)

	var ret0 *DateTime

	{
		ret0 = WrapDateTime(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *DateTime) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewDateTimeLocal constructs a struct DateTime.
func NewDateTimeLocal(year int, month int, day int, hour int, minute int, seconds float64) *DateTime {
	var arg1 C.gint
	var arg2 C.gint
	var arg3 C.gint
	var arg4 C.gint
	var arg5 C.gint
	var arg6 C.gdouble

	arg1 = C.gint(year)
	arg2 = C.gint(month)
	arg3 = C.gint(day)
	arg4 = C.gint(hour)
	arg5 = C.gint(minute)
	arg6 = C.gdouble(seconds)

	ret := C.g_date_time_new_local(arg1, arg2, arg3, arg4, arg5, arg6)

	var ret0 *DateTime

	{
		ret0 = WrapDateTime(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *DateTime) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewDateTimeNow constructs a struct DateTime.
func NewDateTimeNow(tz *TimeZone) *DateTime {
	var arg1 *C.GTimeZone

	arg1 = (*C.GTimeZone)(tz.Native())

	ret := C.g_date_time_new_now(arg1)

	var ret0 *DateTime

	{
		ret0 = WrapDateTime(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *DateTime) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewDateTimeNowLocal constructs a struct DateTime.
func NewDateTimeNowLocal() *DateTime {

	ret := C.g_date_time_new_now_local()

	var ret0 *DateTime

	{
		ret0 = WrapDateTime(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *DateTime) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewDateTimeNowUtc constructs a struct DateTime.
func NewDateTimeNowUtc() *DateTime {

	ret := C.g_date_time_new_now_utc()

	var ret0 *DateTime

	{
		ret0 = WrapDateTime(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *DateTime) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewDateTimeUtc constructs a struct DateTime.
func NewDateTimeUtc(year int, month int, day int, hour int, minute int, seconds float64) *DateTime {
	var arg1 C.gint
	var arg2 C.gint
	var arg3 C.gint
	var arg4 C.gint
	var arg5 C.gint
	var arg6 C.gdouble

	arg1 = C.gint(year)
	arg2 = C.gint(month)
	arg3 = C.gint(day)
	arg4 = C.gint(hour)
	arg5 = C.gint(minute)
	arg6 = C.gdouble(seconds)

	ret := C.g_date_time_new_utc(arg1, arg2, arg3, arg4, arg5, arg6)

	var ret0 *DateTime

	{
		ret0 = WrapDateTime(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *DateTime) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// AddDays creates a copy of @datetime and adds the specified number of days to
// the copy. Add negative values to subtract days.
func (datetime *DateTime) AddDays(days int) *DateTime {
	var arg0 *C.GDateTime
	var arg1 C.gint

	arg0 = (*C.GDateTime)(datetime.Native())
	arg1 = C.gint(days)

	ret := C.g_date_time_add_days(arg0, arg1)

	var ret0 *DateTime

	{
		ret0 = WrapDateTime(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *DateTime) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// AddFull creates a new Time adding the specified values to the current date
// and time in @datetime. Add negative values to subtract.
func (datetime *DateTime) AddFull(years int, months int, days int, hours int, minutes int, seconds float64) *DateTime {
	var arg0 *C.GDateTime
	var arg1 C.gint
	var arg2 C.gint
	var arg3 C.gint
	var arg4 C.gint
	var arg5 C.gint
	var arg6 C.gdouble

	arg0 = (*C.GDateTime)(datetime.Native())
	arg1 = C.gint(years)
	arg2 = C.gint(months)
	arg3 = C.gint(days)
	arg4 = C.gint(hours)
	arg5 = C.gint(minutes)
	arg6 = C.gdouble(seconds)

	ret := C.g_date_time_add_full(arg0, arg1, arg2, arg3, arg4, arg5, arg6)

	var ret0 *DateTime

	{
		ret0 = WrapDateTime(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *DateTime) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// AddHours creates a copy of @datetime and adds the specified number of hours.
// Add negative values to subtract hours.
func (datetime *DateTime) AddHours(hours int) *DateTime {
	var arg0 *C.GDateTime
	var arg1 C.gint

	arg0 = (*C.GDateTime)(datetime.Native())
	arg1 = C.gint(hours)

	ret := C.g_date_time_add_hours(arg0, arg1)

	var ret0 *DateTime

	{
		ret0 = WrapDateTime(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *DateTime) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// AddMinutes creates a copy of @datetime adding the specified number of
// minutes. Add negative values to subtract minutes.
func (datetime *DateTime) AddMinutes(minutes int) *DateTime {
	var arg0 *C.GDateTime
	var arg1 C.gint

	arg0 = (*C.GDateTime)(datetime.Native())
	arg1 = C.gint(minutes)

	ret := C.g_date_time_add_minutes(arg0, arg1)

	var ret0 *DateTime

	{
		ret0 = WrapDateTime(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *DateTime) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// AddMonths creates a copy of @datetime and adds the specified number of months
// to the copy. Add negative values to subtract months.
//
// The day of the month of the resulting Time is clamped to the number of days
// in the updated calendar month. For example, if adding 1 month to 31st January
// 2018, the result would be 28th February 2018. In 2020 (a leap year), the
// result would be 29th February.
func (datetime *DateTime) AddMonths(months int) *DateTime {
	var arg0 *C.GDateTime
	var arg1 C.gint

	arg0 = (*C.GDateTime)(datetime.Native())
	arg1 = C.gint(months)

	ret := C.g_date_time_add_months(arg0, arg1)

	var ret0 *DateTime

	{
		ret0 = WrapDateTime(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *DateTime) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// AddSeconds creates a copy of @datetime and adds the specified number of
// seconds. Add negative values to subtract seconds.
func (datetime *DateTime) AddSeconds(seconds float64) *DateTime {
	var arg0 *C.GDateTime
	var arg1 C.gdouble

	arg0 = (*C.GDateTime)(datetime.Native())
	arg1 = C.gdouble(seconds)

	ret := C.g_date_time_add_seconds(arg0, arg1)

	var ret0 *DateTime

	{
		ret0 = WrapDateTime(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *DateTime) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// AddWeeks creates a copy of @datetime and adds the specified number of weeks
// to the copy. Add negative values to subtract weeks.
func (datetime *DateTime) AddWeeks(weeks int) *DateTime {
	var arg0 *C.GDateTime
	var arg1 C.gint

	arg0 = (*C.GDateTime)(datetime.Native())
	arg1 = C.gint(weeks)

	ret := C.g_date_time_add_weeks(arg0, arg1)

	var ret0 *DateTime

	{
		ret0 = WrapDateTime(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *DateTime) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// AddYears creates a copy of @datetime and adds the specified number of years
// to the copy. Add negative values to subtract years.
//
// As with g_date_time_add_months(), if the resulting date would be 29th
// February on a non-leap year, the day will be clamped to 28th February.
func (datetime *DateTime) AddYears(years int) *DateTime {
	var arg0 *C.GDateTime
	var arg1 C.gint

	arg0 = (*C.GDateTime)(datetime.Native())
	arg1 = C.gint(years)

	ret := C.g_date_time_add_years(arg0, arg1)

	var ret0 *DateTime

	{
		ret0 = WrapDateTime(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *DateTime) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Difference calculates the difference in time between @end and @begin. The
// Span that is returned is effectively @end - @begin (ie: positive if the first
// parameter is larger).
func (end *DateTime) Difference(begin *DateTime) TimeSpan {
	var arg0 *C.GDateTime
	var arg1 *C.GDateTime

	arg0 = (*C.GDateTime)(end.Native())
	arg1 = (*C.GDateTime)(begin.Native())

	ret := C.g_date_time_difference(arg0, arg1)

	var ret0 TimeSpan

	{
		var tmp int64
		tmp = int64(ret)
		ret0 = TimeSpan(tmp)
	}

	return ret0
}

// Format creates a newly allocated string representing the requested @format.
//
// The format strings understood by this function are a subset of the strftime()
// format language as specified by C99. The \D, \U and \W conversions are not
// supported, nor is the 'E' modifier. The GNU extensions \k, \l, \s and \P are
// supported, however, as are the '0', '_' and '-' modifiers. The Python
// extension \f is also supported.
//
// In contrast to strftime(), this function always produces a UTF-8 string,
// regardless of the current locale. Note that the rendering of many formats is
// locale-dependent and may not match the strftime() output exactly.
//
// The following format specifiers are supported:
//
// - \a: the abbreviated weekday name according to the current locale - \A: the
// full weekday name according to the current locale - \b: the abbreviated month
// name according to the current locale - \B: the full month name according to
// the current locale - \c: the preferred date and time representation for the
// current locale - \C: the century number (year/100) as a 2-digit integer
// (00-99) - \d: the day of the month as a decimal number (range 01 to 31) - \e:
// the day of the month as a decimal number (range 1 to 31) - \F: equivalent to
// `Y-m-d` (the ISO 8601 date format) - \g: the last two digits of the ISO 8601
// week-based year as a decimal number (00-99). This works well with \V and \u.
// - \G: the ISO 8601 week-based year as a decimal number. This works well with
// \V and \u. - \h: equivalent to \b - \H: the hour as a decimal number using a
// 24-hour clock (range 00 to 23) - \I: the hour as a decimal number using a
// 12-hour clock (range 01 to 12) - \j: the day of the year as a decimal number
// (range 001 to 366) - \k: the hour (24-hour clock) as a decimal number (range
// 0 to 23); single digits are preceded by a blank - \l: the hour (12-hour
// clock) as a decimal number (range 1 to 12); single digits are preceded by a
// blank - \m: the month as a decimal number (range 01 to 12) - \M: the minute
// as a decimal number (range 00 to 59) - \f: the microsecond as a decimal
// number (range 000000 to 999999) - \p: either "AM" or "PM" according to the
// given time value, or the corresponding strings for the current locale. Noon
// is treated as "PM" and midnight as "AM". Use of this format specifier is
// discouraged, as many locales have no concept of AM/PM formatting. Use \c or
// \X instead. - \P: like \p but lowercase: "am" or "pm" or a corresponding
// string for the current locale. Use of this format specifier is discouraged,
// as many locales have no concept of AM/PM formatting. Use \c or \X instead. -
// \r: the time in a.m. or p.m. notation. Use of this format specifier is
// discouraged, as many locales have no concept of AM/PM formatting. Use \c or
// \X instead. - \R: the time in 24-hour notation (\H:\M) - \s: the number of
// seconds since the Epoch, that is, since 1970-01-01 00:00:00 UTC - \S: the
// second as a decimal number (range 00 to 60) - \t: a tab character - \T: the
// time in 24-hour notation with seconds (\H:\M:\S) - \u: the ISO 8601 standard
// day of the week as a decimal, range 1 to 7, Monday being 1. This works well
// with \G and \V. - \V: the ISO 8601 standard week number of the current year
// as a decimal number, range 01 to 53, where week 1 is the first week that has
// at least 4 days in the new year. See g_date_time_get_week_of_year(). This
// works well with \G and \u. - \w: the day of the week as a decimal, range 0 to
// 6, Sunday being 0. This is not the ISO 8601 standard format -- use \u
// instead. - \x: the preferred date representation for the current locale
// without the time - \X: the preferred time representation for the current
// locale without the date - \y: the year as a decimal number without the
// century - \Y: the year as a decimal number including the century - \z: the
// time zone as an offset from UTC (+hhmm) - \%:z: the time zone as an offset
// from UTC (+hh:mm). This is a gnulib strftime() extension. Since: 2.38 -
// \%::z: the time zone as an offset from UTC (+hh:mm:ss). This is a gnulib
// strftime() extension. Since: 2.38 - \%:::z: the time zone as an offset from
// UTC, with : to necessary precision (e.g., -04, +05:30). This is a gnulib
// strftime() extension. Since: 2.38 - \Z: the time zone or name or abbreviation
// - \%\%: a literal \% character
//
// Some conversion specifications can be modified by preceding the conversion
// specifier by one or more modifier characters. The following modifiers are
// supported for many of the numeric conversions:
//
// - O: Use alternative numeric symbols, if the current locale supports those. -
// _: Pad a numeric result with spaces. This overrides the default padding for
// the specifier. - -: Do not pad a numeric result. This overrides the default
// padding for the specifier. - 0: Pad a numeric result with zeros. This
// overrides the default padding for the specifier.
//
// Additionally, when O is used with B, b, or h, it produces the alternative
// form of a month name. The alternative form should be used when the month name
// is used without a day number (e.g., standalone). It is required in some
// languages (Baltic, Slavic, Greek, and more) due to their grammatical rules.
// For other languages there is no difference. \OB is a GNU and BSD strftime()
// extension expected to be added to the future POSIX specification, \Ob and \Oh
// are GNU strftime() extensions. Since: 2.56
func (datetime *DateTime) Format(format string) string {
	var arg0 *C.GDateTime
	var arg1 *C.gchar

	arg0 = (*C.GDateTime)(datetime.Native())
	arg1 = (*C.gchar)(C.CString(format))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_date_time_format(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// FormatIso8601: format @datetime in ISO 8601 format
// (https://en.wikipedia.org/wiki/ISO_8601), including the date, time and time
// zone, and return that as a UTF-8 encoded string.
//
// Since GLib 2.66, this will output to sub-second precision if needed.
func (datetime *DateTime) FormatIso8601() string {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(datetime.Native())

	ret := C.g_date_time_format_iso8601(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// DayOfMonth retrieves the day of the month represented by @datetime in the
// gregorian calendar.
func (datetime *DateTime) DayOfMonth() int {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(datetime.Native())

	ret := C.g_date_time_get_day_of_month(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// DayOfWeek retrieves the ISO 8601 day of the week on which @datetime falls (1
// is Monday, 2 is Tuesday... 7 is Sunday).
func (datetime *DateTime) DayOfWeek() int {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(datetime.Native())

	ret := C.g_date_time_get_day_of_week(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// DayOfYear retrieves the day of the year represented by @datetime in the
// Gregorian calendar.
func (datetime *DateTime) DayOfYear() int {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(datetime.Native())

	ret := C.g_date_time_get_day_of_year(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Hour retrieves the hour of the day represented by @datetime
func (datetime *DateTime) Hour() int {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(datetime.Native())

	ret := C.g_date_time_get_hour(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Microsecond retrieves the microsecond of the date represented by @datetime
func (datetime *DateTime) Microsecond() int {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(datetime.Native())

	ret := C.g_date_time_get_microsecond(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Minute retrieves the minute of the hour represented by @datetime
func (datetime *DateTime) Minute() int {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(datetime.Native())

	ret := C.g_date_time_get_minute(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Month retrieves the month of the year represented by @datetime in the
// Gregorian calendar.
func (datetime *DateTime) Month() int {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(datetime.Native())

	ret := C.g_date_time_get_month(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Second retrieves the second of the minute represented by @datetime
func (datetime *DateTime) Second() int {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(datetime.Native())

	ret := C.g_date_time_get_second(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Seconds retrieves the number of seconds since the start of the last minute,
// including the fractional part.
func (datetime *DateTime) Seconds() float64 {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(datetime.Native())

	ret := C.g_date_time_get_seconds(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// Timezone: get the time zone for this @datetime.
func (datetime *DateTime) Timezone() *TimeZone {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(datetime.Native())

	ret := C.g_date_time_get_timezone(arg0)

	var ret0 *TimeZone

	{
		ret0 = WrapTimeZone(unsafe.Pointer(ret))
	}

	return ret0
}

// TimezoneAbbreviation determines the time zone abbreviation to be used at the
// time and in the time zone of @datetime.
//
// For example, in Toronto this is currently "EST" during the winter months and
// "EDT" during the summer months when daylight savings time is in effect.
func (datetime *DateTime) TimezoneAbbreviation() string {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(datetime.Native())

	ret := C.g_date_time_get_timezone_abbreviation(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// UtcOffset determines the offset to UTC in effect at the time and in the time
// zone of @datetime.
//
// The offset is the number of microseconds that you add to UTC time to arrive
// at local time for the time zone (ie: negative numbers for time zones west of
// GMT, positive numbers for east).
//
// If @datetime represents UTC time, then the offset is always zero.
func (datetime *DateTime) UtcOffset() TimeSpan {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(datetime.Native())

	ret := C.g_date_time_get_utc_offset(arg0)

	var ret0 TimeSpan

	{
		var tmp int64
		tmp = int64(ret)
		ret0 = TimeSpan(tmp)
	}

	return ret0
}

// WeekNumberingYear returns the ISO 8601 week-numbering year in which the week
// containing @datetime falls.
//
// This function, taken together with g_date_time_get_week_of_year() and
// g_date_time_get_day_of_week() can be used to determine the full ISO week date
// on which @datetime falls.
//
// This is usually equal to the normal Gregorian year (as returned by
// g_date_time_get_year()), except as detailed below:
//
// For Thursday, the week-numbering year is always equal to the usual calendar
// year. For other days, the number is such that every day within a complete
// week (Monday to Sunday) is contained within the same week-numbering year.
//
// For Monday, Tuesday and Wednesday occurring near the end of the year, this
// may mean that the week-numbering year is one greater than the calendar year
// (so that these days have the same week-numbering year as the Thursday
// occurring early in the next year).
//
// For Friday, Saturday and Sunday occurring near the start of the year, this
// may mean that the week-numbering year is one less than the calendar year (so
// that these days have the same week-numbering year as the Thursday occurring
// late in the previous year).
//
// An equivalent description is that the week-numbering year is equal to the
// calendar year containing the majority of the days in the current week (Monday
// to Sunday).
//
// Note that January 1 0001 in the proleptic Gregorian calendar is a Monday, so
// this function never returns 0.
func (datetime *DateTime) WeekNumberingYear() int {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(datetime.Native())

	ret := C.g_date_time_get_week_numbering_year(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// WeekOfYear returns the ISO 8601 week number for the week containing
// @datetime. The ISO 8601 week number is the same for every day of the week
// (from Moday through Sunday). That can produce some unusual results (described
// below).
//
// The first week of the year is week 1. This is the week that contains the
// first Thursday of the year. Equivalently, this is the first week that has
// more than 4 of its days falling within the calendar year.
//
// The value 0 is never returned by this function. Days contained within a year
// but occurring before the first ISO 8601 week of that year are considered as
// being contained in the last week of the previous year. Similarly, the final
// days of a calendar year may be considered as being part of the first ISO 8601
// week of the next year if 4 or more days of that week are contained within the
// new year.
func (datetime *DateTime) WeekOfYear() int {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(datetime.Native())

	ret := C.g_date_time_get_week_of_year(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Year retrieves the year represented by @datetime in the Gregorian calendar.
func (datetime *DateTime) Year() int {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(datetime.Native())

	ret := C.g_date_time_get_year(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Ymd retrieves the Gregorian day, month, and year of a given Time.
func (datetime *DateTime) Ymd() (year int, month int, day int) {
	var arg0 *C.GDateTime
	var arg1 *C.gint // out
	var arg2 *C.gint // out
	var arg3 *C.gint // out

	arg0 = (*C.GDateTime)(datetime.Native())

	C.g_date_time_get_ymd(arg0, &arg1, &arg2, &arg3)

	var ret0 int
	var ret1 int
	var ret2 int

	ret0 = int(arg1)

	ret1 = int(arg2)

	ret2 = int(arg3)

	return ret0, ret1, ret2
}

// IsDaylightSavings determines if daylight savings time is in effect at the
// time and in the time zone of @datetime.
func (datetime *DateTime) IsDaylightSavings() bool {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(datetime.Native())

	ret := C.g_date_time_is_daylight_savings(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Ref: atomically increments the reference count of @datetime by one.
func (datetime *DateTime) Ref() *DateTime {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(datetime.Native())

	ret := C.g_date_time_ref(arg0)

	var ret0 *DateTime

	{
		ret0 = WrapDateTime(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *DateTime) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// ToLocal creates a new Time corresponding to the same instant in time as
// @datetime, but in the local time zone.
//
// This call is equivalent to calling g_date_time_to_timezone() with the time
// zone returned by g_time_zone_new_local().
func (datetime *DateTime) ToLocal() *DateTime {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(datetime.Native())

	ret := C.g_date_time_to_local(arg0)

	var ret0 *DateTime

	{
		ret0 = WrapDateTime(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *DateTime) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// ToTimeval stores the instant in time that @datetime represents into @tv.
//
// The time contained in a Val is always stored in the form of seconds elapsed
// since 1970-01-01 00:00:00 UTC, regardless of the time zone associated with
// @datetime.
//
// On systems where 'long' is 32bit (ie: all 32bit systems and all Windows
// systems), a Val is incapable of storing the entire range of values that Time
// is capable of expressing. On those systems, this function returns false to
// indicate that the time is out of range.
//
// On systems where 'long' is 64bit, this function never fails.
func (datetime *DateTime) ToTimeval(tv *TimeVal) bool {
	var arg0 *C.GDateTime
	var arg1 *C.GTimeVal

	arg0 = (*C.GDateTime)(datetime.Native())
	arg1 = (*C.GTimeVal)(tv.Native())

	ret := C.g_date_time_to_timeval(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ToTimezone: create a new Time corresponding to the same instant in time as
// @datetime, but in the time zone @tz.
//
// This call can fail in the case that the time goes out of bounds. For example,
// converting 0001-01-01 00:00:00 UTC to a time zone west of Greenwich will fail
// (due to the year 0 being out of range).
func (datetime *DateTime) ToTimezone(tz *TimeZone) *DateTime {
	var arg0 *C.GDateTime
	var arg1 *C.GTimeZone

	arg0 = (*C.GDateTime)(datetime.Native())
	arg1 = (*C.GTimeZone)(tz.Native())

	ret := C.g_date_time_to_timezone(arg0, arg1)

	var ret0 *DateTime

	{
		ret0 = WrapDateTime(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *DateTime) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// ToUnix gives the Unix time corresponding to @datetime, rounding down to the
// nearest second.
//
// Unix time is the number of seconds that have elapsed since 1970-01-01
// 00:00:00 UTC, regardless of the time zone associated with @datetime.
func (datetime *DateTime) ToUnix() int64 {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(datetime.Native())

	ret := C.g_date_time_to_unix(arg0)

	var ret0 int64

	ret0 = int64(ret)

	return ret0
}

// ToUtc creates a new Time corresponding to the same instant in time as
// @datetime, but in UTC.
//
// This call is equivalent to calling g_date_time_to_timezone() with the time
// zone returned by g_time_zone_new_utc().
func (datetime *DateTime) ToUtc() *DateTime {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(datetime.Native())

	ret := C.g_date_time_to_utc(arg0)

	var ret0 *DateTime

	{
		ret0 = WrapDateTime(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *DateTime) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Unref: atomically decrements the reference count of @datetime by one.
//
// When the reference count reaches zero, the resources allocated by @datetime
// are freed
func (datetime *DateTime) Unref() {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(datetime.Native())

	C.g_date_time_unref(arg0)
}

// DebugKey associates a string with a bit flag. Used in g_parse_debug_string().
type DebugKey struct {
	native C.GDebugKey
}

// WrapDebugKey wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDebugKey(ptr unsafe.Pointer) *DebugKey {
	if ptr == nil {
		return nil
	}

	return (*DebugKey)(ptr)
}

func marshalDebugKey(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDebugKey(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (d *DebugKey) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}

// Key gets the field inside the struct.
func (d *DebugKey) Key() string {
	var ret string
	ret = C.GoString(d.native.key)
	return ret
}

// Value gets the field inside the struct.
func (d *DebugKey) Value() uint {
	var ret uint
	ret = uint(d.native.value)
	return ret
}

// Dir: an opaque structure representing an opened directory.
type Dir struct {
	native C.GDir
}

// WrapDir wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDir(ptr unsafe.Pointer) *Dir {
	if ptr == nil {
		return nil
	}

	return (*Dir)(ptr)
}

func marshalDir(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDir(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (d *Dir) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}

// Close closes the directory and deallocates all related resources.
func (dir *Dir) Close() {
	var arg0 *C.GDir

	arg0 = (*C.GDir)(dir.Native())

	C.g_dir_close(arg0)
}

// ReadName retrieves the name of another entry in the directory, or nil. The
// order of entries returned from this function is not defined, and may vary by
// file system or other operating-system dependent factors.
//
// nil may also be returned in case of errors. On Unix, you can check `errno` to
// find out if nil was returned because of an error.
//
// On Unix, the '.' and '..' entries are omitted, and the returned name is in
// the on-disk encoding.
//
// On Windows, as is true of all GLib functions which operate on filenames, the
// returned name is in UTF-8.
func (dir *Dir) ReadName() string {
	var arg0 *C.GDir

	arg0 = (*C.GDir)(dir.Native())

	ret := C.g_dir_read_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Rewind resets the given directory. The next call to g_dir_read_name() will
// return the first entry again.
func (dir *Dir) Rewind() {
	var arg0 *C.GDir

	arg0 = (*C.GDir)(dir.Native())

	C.g_dir_rewind(arg0)
}

// Error: the `GError` structure contains information about an error that has
// occurred.
type Error struct {
	native C.GError
}

// WrapError wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapError(ptr unsafe.Pointer) *Error {
	if ptr == nil {
		return nil
	}

	return (*Error)(ptr)
}

func marshalError(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapError(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (e *Error) Native() unsafe.Pointer {
	return unsafe.Pointer(&e.native)
}

// Domain gets the field inside the struct.
func (e *Error) Domain() Quark {
	var ret Quark
	{
		var tmp uint32
		tmp = uint32(e.native.domain)
		ret = Quark(tmp)
	}
	return ret
}

// Code gets the field inside the struct.
func (e *Error) Code() int {
	var ret int
	ret = int(e.native.code)
	return ret
}

// Message gets the field inside the struct.
func (e *Error) Message() string {
	var ret string
	ret = C.GoString(e.native.message)
	return ret
}

// Copy makes a copy of @error.
func (error *Error) Copy() *Error {
	var arg0 *C.GError

	arg0 = (*C.GError)(error.Native())

	ret := C.g_error_copy(arg0)

	var ret0 *Error

	{
		ret0 = WrapError(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Error) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Free frees a #GError and associated resources.
func (error *Error) Free() {
	var arg0 *C.GError

	arg0 = (*C.GError)(error.Native())

	C.g_error_free(arg0)
}

// HashTable: the Table struct is an opaque data structure to represent a [Hash
// Table][glib-Hash-Tables]. It should only be accessed via the following
// functions.
type HashTable struct {
	native C.GHashTable
}

// WrapHashTable wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapHashTable(ptr unsafe.Pointer) *HashTable {
	if ptr == nil {
		return nil
	}

	return (*HashTable)(ptr)
}

func marshalHashTable(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapHashTable(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (h *HashTable) Native() unsafe.Pointer {
	return unsafe.Pointer(&h.native)
}

// HashTableIter: a GHashTableIter structure represents an iterator that can be
// used to iterate over the elements of a Table. GHashTableIter structures are
// typically allocated on the stack and then initialized with
// g_hash_table_iter_init().
//
// The iteration order of a TableIter over the keys/values in a hash table is
// not defined.
type HashTableIter struct {
	native C.GHashTableIter
}

// WrapHashTableIter wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapHashTableIter(ptr unsafe.Pointer) *HashTableIter {
	if ptr == nil {
		return nil
	}

	return (*HashTableIter)(ptr)
}

func marshalHashTableIter(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapHashTableIter(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (h *HashTableIter) Native() unsafe.Pointer {
	return unsafe.Pointer(&h.native)
}

// HashTable returns the Table associated with @iter.
func (iter *HashTableIter) HashTable() *HashTable {
	var arg0 *C.GHashTableIter

	arg0 = (*C.GHashTableIter)(iter.Native())

	ret := C.g_hash_table_iter_get_hash_table(arg0)

	var ret0 *HashTable

	{
		ret0 = WrapHashTable(unsafe.Pointer(ret))
	}

	return ret0
}

// Init initializes a key/value pair iterator and associates it with
// @hash_table. Modifying the hash table after calling this function invalidates
// the returned iterator.
//
// The iteration order of a TableIter over the keys/values in a hash table is
// not defined.
//
//    GHashTableIter iter;
//    gpointer key, value;
//
//    g_hash_table_iter_init (&iter, hash_table);
//    while (g_hash_table_iter_next (&iter, &key, &value))
//      {
//        // do something with key and value
//      }
func (iter *HashTableIter) Init(hashTable *HashTable) {
	var arg0 *C.GHashTableIter
	var arg1 *C.GHashTable

	arg0 = (*C.GHashTableIter)(iter.Native())
	arg1 = (*C.GHashTable)(hashTable.Native())

	C.g_hash_table_iter_init(arg0, arg1)
}

// Next advances @iter and retrieves the key and/or value that are now pointed
// to as a result of this advancement. If false is returned, @key and @value are
// not set, and the iterator becomes invalid.
func (iter *HashTableIter) Next() (key interface{}, value interface{}, ok bool) {
	var arg0 *C.GHashTableIter
	var arg1 *C.gpointer // out
	var arg2 *C.gpointer // out

	arg0 = (*C.GHashTableIter)(iter.Native())

	ret := C.g_hash_table_iter_next(arg0, &arg1, &arg2)

	var ret0 interface{}
	var ret1 interface{}
	var ret2 bool

	ret0 = box.Get(uintptr(arg1)).(interface{})

	ret1 = box.Get(uintptr(arg2)).(interface{})

	ret2 = C.BOOL(ret) != 0

	return ret0, ret1, ret2
}

// Remove removes the key/value pair currently pointed to by the iterator from
// its associated Table. Can only be called after g_hash_table_iter_next()
// returned true, and cannot be called more than once for the same key/value
// pair.
//
// If the Table was created using g_hash_table_new_full(), the key and value are
// freed using the supplied destroy functions, otherwise you have to make sure
// that any dynamically allocated values are freed yourself.
//
// It is safe to continue iterating the Table afterward:
//
//    while (g_hash_table_iter_next (&iter, &key, &value))
//      {
//        if (condition)
//          g_hash_table_iter_remove (&iter);
//      }
func (iter *HashTableIter) Remove() {
	var arg0 *C.GHashTableIter

	arg0 = (*C.GHashTableIter)(iter.Native())

	C.g_hash_table_iter_remove(arg0)
}

// Replace replaces the value currently pointed to by the iterator from its
// associated Table. Can only be called after g_hash_table_iter_next() returned
// true.
//
// If you supplied a @value_destroy_func when creating the Table, the old value
// is freed using that function.
func (iter *HashTableIter) Replace(value interface{}) {
	var arg0 *C.GHashTableIter
	var arg1 C.gpointer

	arg0 = (*C.GHashTableIter)(iter.Native())
	arg1 = C.gpointer(box.Assign(value))

	C.g_hash_table_iter_replace(arg0, arg1)
}

// Steal removes the key/value pair currently pointed to by the iterator from
// its associated Table, without calling the key and value destroy functions.
// Can only be called after g_hash_table_iter_next() returned true, and cannot
// be called more than once for the same key/value pair.
func (iter *HashTableIter) Steal() {
	var arg0 *C.GHashTableIter

	arg0 = (*C.GHashTableIter)(iter.Native())

	C.g_hash_table_iter_steal(arg0)
}

// HMAC: an opaque structure representing a HMAC operation. To create a new
// GHmac, use g_hmac_new(). To free a GHmac, use g_hmac_unref().
type HMAC struct {
	native C.GHmac
}

// WrapHMAC wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapHMAC(ptr unsafe.Pointer) *HMAC {
	if ptr == nil {
		return nil
	}

	return (*HMAC)(ptr)
}

func marshalHMAC(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapHMAC(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (h *HMAC) Native() unsafe.Pointer {
	return unsafe.Pointer(&h.native)
}

// Copy copies a #GHmac. If @hmac has been closed, by calling
// g_hmac_get_string() or g_hmac_get_digest(), the copied HMAC will be closed as
// well.
func (hmac *HMAC) Copy() *HMAC {
	var arg0 *C.GHmac

	arg0 = (*C.GHmac)(hmac.Native())

	ret := C.g_hmac_copy(arg0)

	var ret0 *HMAC

	{
		ret0 = WrapHMAC(unsafe.Pointer(ret))
	}

	return ret0
}

// Digest gets the digest from @checksum as a raw binary array and places it
// into @buffer. The size of the digest depends on the type of checksum.
//
// Once this function has been called, the #GHmac is closed and can no longer be
// updated with g_checksum_update().
func (hmac *HMAC) Digest(buffer []byte) {
	var arg0 *C.GHmac
	var arg1 *C.guint8
	var arg2 *C.gsize

	arg0 = (*C.GHmac)(hmac.Native())
	arg1 = (*C.guint8)(unsafe.Pointer(&buffer[0]))
	arg2 = len(buffer)
	defer runtime.KeepAlive(buffer)

	C.g_hmac_get_digest(arg0, arg1, arg2)
}

// String gets the HMAC as a hexadecimal string.
//
// Once this function has been called the #GHmac can no longer be updated with
// g_hmac_update().
//
// The hexadecimal characters will be lower case.
func (hmac *HMAC) String() string {
	var arg0 *C.GHmac

	arg0 = (*C.GHmac)(hmac.Native())

	ret := C.g_hmac_get_string(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Ref: atomically increments the reference count of @hmac by one.
//
// This function is MT-safe and may be called from any thread.
func (hmac *HMAC) Ref() *HMAC {
	var arg0 *C.GHmac

	arg0 = (*C.GHmac)(hmac.Native())

	ret := C.g_hmac_ref(arg0)

	var ret0 *HMAC

	{
		ret0 = WrapHMAC(unsafe.Pointer(ret))
	}

	return ret0
}

// Unref: atomically decrements the reference count of @hmac by one.
//
// If the reference count drops to 0, all keys and values will be destroyed, and
// all memory allocated by the hash table is released. This function is MT-safe
// and may be called from any thread. Frees the memory allocated for @hmac.
func (hmac *HMAC) Unref() {
	var arg0 *C.GHmac

	arg0 = (*C.GHmac)(hmac.Native())

	C.g_hmac_unref(arg0)
}

// Update feeds @data into an existing #GHmac.
//
// The HMAC must still be open, that is g_hmac_get_string() or
// g_hmac_get_digest() must not have been called on @hmac.
func (hmac *HMAC) Update(data []byte) {
	var arg0 *C.GHmac
	var arg1 *C.guchar
	var arg2 C.gssize

	arg0 = (*C.GHmac)(hmac.Native())
	arg1 = (*C.guchar)(unsafe.Pointer(&data[0]))
	arg2 = len(data)
	defer runtime.KeepAlive(data)

	C.g_hmac_update(arg0, arg1, arg2)
}

// Hook: the #GHook struct represents a single hook function in a List.
type Hook struct {
	native C.GHook
}

// WrapHook wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapHook(ptr unsafe.Pointer) *Hook {
	if ptr == nil {
		return nil
	}

	return (*Hook)(ptr)
}

func marshalHook(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapHook(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (h *Hook) Native() unsafe.Pointer {
	return unsafe.Pointer(&h.native)
}

// Data gets the field inside the struct.
func (h *Hook) Data() interface{} {
	var ret interface{}
	ret = box.Get(uintptr(h.native.data))
	return ret
}

// Next gets the field inside the struct.
func (h *Hook) Next() *Hook {
	var ret *Hook
	{
		ret = WrapHook(unsafe.Pointer(h.native.next))
	}
	return ret
}

// Prev gets the field inside the struct.
func (h *Hook) Prev() *Hook {
	var ret *Hook
	{
		ret = WrapHook(unsafe.Pointer(h.native.prev))
	}
	return ret
}

// RefCount gets the field inside the struct.
func (h *Hook) RefCount() uint {
	var ret uint
	ret = uint(h.native.ref_count)
	return ret
}

// HookID gets the field inside the struct.
func (h *Hook) HookID() uint32 {
	var ret uint32
	ret = uint32(h.native.hook_id)
	return ret
}

// Flags gets the field inside the struct.
func (h *Hook) Flags() uint {
	var ret uint
	ret = uint(h.native.flags)
	return ret
}

// Func gets the field inside the struct.
func (h *Hook) Func() interface{} {
	var ret interface{}
	ret = box.Get(uintptr(h.native._func))
	return ret
}

// CompareIds compares the ids of two #GHook elements, returning a negative
// value if the second id is greater than the first.
func (newHook *Hook) CompareIds(sibling *Hook) int {
	var arg0 *C.GHook
	var arg1 *C.GHook

	arg0 = (*C.GHook)(newHook.Native())
	arg1 = (*C.GHook)(sibling.Native())

	ret := C.g_hook_compare_ids(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// HookList: the List struct represents a list of hook functions.
type HookList struct {
	native C.GHookList
}

// WrapHookList wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapHookList(ptr unsafe.Pointer) *HookList {
	if ptr == nil {
		return nil
	}

	return (*HookList)(ptr)
}

func marshalHookList(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapHookList(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (h *HookList) Native() unsafe.Pointer {
	return unsafe.Pointer(&h.native)
}

// SeqID gets the field inside the struct.
func (h *HookList) SeqID() uint32 {
	var ret uint32
	ret = uint32(h.native.seq_id)
	return ret
}

// Hooks gets the field inside the struct.
func (h *HookList) Hooks() *Hook {
	var ret *Hook
	{
		ret = WrapHook(unsafe.Pointer(h.native.hooks))
	}
	return ret
}

// Dummy3 gets the field inside the struct.
func (h *HookList) Dummy3() interface{} {
	var ret interface{}
	ret = box.Get(uintptr(h.native.dummy3))
	return ret
}

// Dummy gets the field inside the struct.
func (h *HookList) Dummy() [2]interface{} {
	var ret [2]interface{}
	{
		cArray := ([2]gpointer)(h.native.dummy)

		for i := 0; i < 2; i++ {
			src := cArray[i]
			ret[i] = box.Get(uintptr(src))
		}
	}
	return ret
}

// Clear removes all the #GHook elements from a List.
func (hookList *HookList) Clear() {
	var arg0 *C.GHookList

	arg0 = (*C.GHookList)(hookList.Native())

	C.g_hook_list_clear(arg0)
}

// Init initializes a List. This must be called before the List is used.
func (hookList *HookList) Init(hookSize uint) {
	var arg0 *C.GHookList
	var arg1 C.guint

	arg0 = (*C.GHookList)(hookList.Native())
	arg1 = C.guint(hookSize)

	C.g_hook_list_init(arg0, arg1)
}

// Invoke calls all of the #GHook functions in a List.
func (hookList *HookList) Invoke(mayRecurse bool) {
	var arg0 *C.GHookList
	var arg1 C.gboolean

	arg0 = (*C.GHookList)(hookList.Native())
	if mayRecurse {
		arg1 = C.TRUE
	}

	C.g_hook_list_invoke(arg0, arg1)
}

// InvokeCheck calls all of the #GHook functions in a List. Any function which
// returns false is removed from the List.
func (hookList *HookList) InvokeCheck(mayRecurse bool) {
	var arg0 *C.GHookList
	var arg1 C.gboolean

	arg0 = (*C.GHookList)(hookList.Native())
	if mayRecurse {
		arg1 = C.TRUE
	}

	C.g_hook_list_invoke_check(arg0, arg1)
}

// Marshal calls a function on each valid #GHook.
func (hookList *HookList) Marshal(mayRecurse bool, marshaller HookMarshaller) {
	var arg0 *C.GHookList
	var arg1 C.gboolean
	var arg2 C.GHookMarshaller
	var arg3 C.gpointer

	arg0 = (*C.GHookList)(hookList.Native())
	if mayRecurse {
		arg1 = C.TRUE
	}
	arg2 = (*[0]byte)(C.gotk4_HookMarshaller)
	arg3 = C.gpointer(box.Assign(marshaller))

	C.g_hook_list_marshal(arg0, arg1, arg2, arg3)
}

// MarshalCheck calls a function on each valid #GHook and destroys it if the
// function returns false.
func (hookList *HookList) MarshalCheck(mayRecurse bool, marshaller HookCheckMarshaller) {
	var arg0 *C.GHookList
	var arg1 C.gboolean
	var arg2 C.GHookCheckMarshaller
	var arg3 C.gpointer

	arg0 = (*C.GHookList)(hookList.Native())
	if mayRecurse {
		arg1 = C.TRUE
	}
	arg2 = (*[0]byte)(C.gotk4_HookCheckMarshaller)
	arg3 = C.gpointer(box.Assign(marshaller))

	C.g_hook_list_marshal_check(arg0, arg1, arg2, arg3)
}

// IConv: the GIConv struct wraps an iconv() conversion descriptor. It contains
// private data and should only be accessed using the following functions.
type IConv struct {
	native C.GIConv
}

// WrapIConv wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapIConv(ptr unsafe.Pointer) *IConv {
	if ptr == nil {
		return nil
	}

	return (*IConv)(ptr)
}

func marshalIConv(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapIConv(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (i *IConv) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

// _: same as the standard UNIX routine iconv(), but may be implemented via
// libiconv on UNIX flavors that lack a native implementation.
//
// GLib provides g_convert() and g_locale_to_utf8() which are likely more
// convenient than the raw iconv wrappers.
//
// Note that the behaviour of iconv() for characters which are valid in the
// input character set, but which have no representation in the output character
// set, is implementation defined. This function may return success (with a
// positive number of non-reversible conversions as replacement characters were
// used), or it may return -1 and set an error such as EILSEQ, in such a
// situation.
func (converter *IConv) _(inbuf string, inbytesLeft uint, outbuf string, outbytesLeft uint) uint {
	var arg0 C.GIConv
	var arg1 **C.gchar
	var arg2 *C.gsize
	var arg3 **C.gchar
	var arg4 *C.gsize

	arg0 = (C.GIConv)(converter.Native())
	arg1 = (*C.gchar)(C.CString(inbuf))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gsize)(inbytesLeft)
	arg3 = (*C.gchar)(C.CString(outbuf))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gsize)(outbytesLeft)

	ret := C.g_iconv(arg0, arg1, arg2, arg3, arg4)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Close: same as the standard UNIX routine iconv_close(), but may be
// implemented via libiconv on UNIX flavors that lack a native implementation.
// Should be called to clean up the conversion descriptor from g_iconv_open()
// when you are done converting things.
//
// GLib provides g_convert() and g_locale_to_utf8() which are likely more
// convenient than the raw iconv wrappers.
func (converter *IConv) Close() int {
	var arg0 C.GIConv

	arg0 = (C.GIConv)(converter.Native())

	ret := C.g_iconv_close(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// IOChannel: a data structure representing an IO Channel. The fields should be
// considered private and should only be accessed with the following functions.
type IOChannel struct {
	native C.GIOChannel
}

// WrapIOChannel wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapIOChannel(ptr unsafe.Pointer) *IOChannel {
	if ptr == nil {
		return nil
	}

	return (*IOChannel)(ptr)
}

func marshalIOChannel(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapIOChannel(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (i *IOChannel) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

// NewIOChannelFile constructs a struct IOChannel.
func NewIOChannelFile(filename string, mode string) (ioChannel *IOChannel, err error) {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(mode))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_io_channel_new_file(arg1, arg2, &gError)

	var ret0 *IOChannel
	var goError error

	{
		ret0 = WrapIOChannel(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *IOChannel) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// NewIOChannelUnix constructs a struct IOChannel.
func NewIOChannelUnix(fd int) *IOChannel {
	var arg1 C.int

	arg1 = C.int(fd)

	ret := C.g_io_channel_unix_new(arg1)

	var ret0 *IOChannel

	{
		ret0 = WrapIOChannel(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *IOChannel) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Close: close an IO channel. Any pending data to be written will be flushed,
// ignoring errors. The channel will not be freed until the last reference is
// dropped using g_io_channel_unref().
func (channel *IOChannel) Close() {
	var arg0 *C.GIOChannel

	arg0 = (*C.GIOChannel)(channel.Native())

	C.g_io_channel_close(arg0)
}

// Flush flushes the write buffer for the GIOChannel.
func (channel *IOChannel) Flush() (ioStatus IOStatus, err error) {
	var arg0 *C.GIOChannel
	var gError *C.GError

	arg0 = (*C.GIOChannel)(channel.Native())

	ret := C.g_io_channel_flush(arg0, &gError)

	var ret0 IOStatus
	var goError error

	ret0 = IOStatus(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// BufferCondition: this function returns a OCondition depending on whether
// there is data to be read/space to write data in the internal buffers in the
// OChannel. Only the flags G_IO_IN and G_IO_OUT may be set.
func (channel *IOChannel) BufferCondition() IOCondition {
	var arg0 *C.GIOChannel

	arg0 = (*C.GIOChannel)(channel.Native())

	ret := C.g_io_channel_get_buffer_condition(arg0)

	var ret0 IOCondition

	ret0 = IOCondition(ret)

	return ret0
}

// BufferSize gets the buffer size.
func (channel *IOChannel) BufferSize() uint {
	var arg0 *C.GIOChannel

	arg0 = (*C.GIOChannel)(channel.Native())

	ret := C.g_io_channel_get_buffer_size(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Buffered returns whether @channel is buffered.
func (channel *IOChannel) Buffered() bool {
	var arg0 *C.GIOChannel

	arg0 = (*C.GIOChannel)(channel.Native())

	ret := C.g_io_channel_get_buffered(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// CloseOnUnref returns whether the file/socket/whatever associated with
// @channel will be closed when @channel receives its final unref and is
// destroyed. The default value of this is true for channels created by
// g_io_channel_new_file (), and false for all other channels.
func (channel *IOChannel) CloseOnUnref() bool {
	var arg0 *C.GIOChannel

	arg0 = (*C.GIOChannel)(channel.Native())

	ret := C.g_io_channel_get_close_on_unref(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Encoding gets the encoding for the input/output of the channel. The internal
// encoding is always UTF-8. The encoding nil makes the channel safe for binary
// data.
func (channel *IOChannel) Encoding() string {
	var arg0 *C.GIOChannel

	arg0 = (*C.GIOChannel)(channel.Native())

	ret := C.g_io_channel_get_encoding(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Flags gets the current flags for a OChannel, including read-only flags such
// as G_IO_FLAG_IS_READABLE.
//
// The values of the flags G_IO_FLAG_IS_READABLE and G_IO_FLAG_IS_WRITABLE are
// cached for internal use by the channel when it is created. If they should
// change at some later point (e.g. partial shutdown of a socket with the UNIX
// shutdown() function), the user should immediately call
// g_io_channel_get_flags() to update the internal values of these flags.
func (channel *IOChannel) Flags() IOFlags {
	var arg0 *C.GIOChannel

	arg0 = (*C.GIOChannel)(channel.Native())

	ret := C.g_io_channel_get_flags(arg0)

	var ret0 IOFlags

	ret0 = IOFlags(ret)

	return ret0
}

// LineTerm: this returns the string that OChannel uses to determine where in
// the file a line break occurs. A value of nil indicates autodetection.
func (channel *IOChannel) LineTerm(length int) string {
	var arg0 *C.GIOChannel
	var arg1 *C.gint

	arg0 = (*C.GIOChannel)(channel.Native())
	arg1 = (*C.gint)(length)

	ret := C.g_io_channel_get_line_term(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Init initializes a OChannel struct.
//
// This is called by each of the above functions when creating a OChannel, and
// so is not often needed by the application programmer (unless you are creating
// a new type of OChannel).
func (channel *IOChannel) Init() {
	var arg0 *C.GIOChannel

	arg0 = (*C.GIOChannel)(channel.Native())

	C.g_io_channel_init(arg0)
}

// Read reads data from a OChannel.
func (channel *IOChannel) Read(buf string, count uint, bytesRead uint) IOError {
	var arg0 *C.GIOChannel
	var arg1 *C.gchar
	var arg2 C.gsize
	var arg3 *C.gsize

	arg0 = (*C.GIOChannel)(channel.Native())
	arg1 = (*C.gchar)(C.CString(buf))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gsize(count)
	arg3 = (*C.gsize)(bytesRead)

	ret := C.g_io_channel_read(arg0, arg1, arg2, arg3)

	var ret0 IOError

	ret0 = IOError(ret)

	return ret0
}

// ReadChars: replacement for g_io_channel_read() with the new API.
func (channel *IOChannel) ReadChars() (buf []byte, bytesRead uint, ioStatus IOStatus, err error) {
	var arg0 *C.GIOChannel
	var arg1 *C.gchar // out
	var arg2 C.gsize
	var arg3 *C.gsize // out
	var gError *C.GError

	arg0 = (*C.GIOChannel)(channel.Native())

	ret := C.g_io_channel_read_chars(arg0, &arg1, arg2, &arg3, &gError)

	var ret0 []byte
	var ret1 uint
	var ret2 IOStatus
	var goError error

	{
		ret0 = make([]byte, arg2)
		for i := 0; i < uintptr(arg2); i++ {
			src := (C.guint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret0[i] = byte(src)
		}
	}

	ret1 = uint(arg3)

	ret2 = IOStatus(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}

// ReadLine reads a line, including the terminating character(s), from a
// OChannel into a newly-allocated string. @str_return will contain allocated
// memory if the return is G_IO_STATUS_NORMAL.
func (channel *IOChannel) ReadLine() (strReturn string, length uint, terminatorPos uint, ioStatus IOStatus, err error) {
	var arg0 *C.GIOChannel
	var arg1 **C.gchar // out
	var arg2 *C.gsize  // out
	var arg3 *C.gsize  // out
	var gError *C.GError

	arg0 = (*C.GIOChannel)(channel.Native())

	ret := C.g_io_channel_read_line(arg0, &arg1, &arg2, &arg3, &gError)

	var ret0 string
	var ret1 uint
	var ret2 uint
	var ret3 IOStatus
	var goError error

	ret0 = C.GoString(arg1)
	C.free(unsafe.Pointer(arg1))

	ret1 = uint(arg2)

	ret2 = uint(arg3)

	ret3 = IOStatus(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, ret3, goError
}

// ReadLineString reads a line from a OChannel, using a #GString as a buffer.
func (channel *IOChannel) ReadLineString(buffer *String, terminatorPos uint) (ioStatus IOStatus, err error) {
	var arg0 *C.GIOChannel
	var arg1 *C.GString
	var arg2 *C.gsize
	var gError *C.GError

	arg0 = (*C.GIOChannel)(channel.Native())
	arg1 = (*C.GString)(buffer.Native())
	arg2 = (*C.gsize)(terminatorPos)

	ret := C.g_io_channel_read_line_string(arg0, arg1, arg2, &gError)

	var ret0 IOStatus
	var goError error

	ret0 = IOStatus(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// ReadToEnd reads all the remaining data from the file.
func (channel *IOChannel) ReadToEnd() (strReturn []byte, length uint, ioStatus IOStatus, err error) {
	var arg0 *C.GIOChannel
	var arg1 **C.gchar // out
	var arg2 *C.gsize  // out
	var gError *C.GError

	arg0 = (*C.GIOChannel)(channel.Native())

	ret := C.g_io_channel_read_to_end(arg0, &arg1, &arg2, &gError)

	var ret0 []byte
	var ret1 uint
	var ret2 IOStatus
	var goError error

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret0))
		sliceHeader.Data = uintptr(unsafe.Pointer(arg1))
		sliceHeader.Len = arg2
		sliceHeader.Cap = arg2
		runtime.SetFinalizer(&arg1, func() {
			C.free(unsafe.Pointer(arg1))
		})
		defer runtime.KeepAlive(arg1)
	}

	ret1 = uint(arg2)

	ret2 = IOStatus(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}

// ReadUnichar reads a Unicode character from @channel. This function cannot be
// called on a channel with nil encoding.
func (channel *IOChannel) ReadUnichar() (thechar uint32, ioStatus IOStatus, err error) {
	var arg0 *C.GIOChannel
	var arg1 *C.gunichar // out
	var gError *C.GError

	arg0 = (*C.GIOChannel)(channel.Native())

	ret := C.g_io_channel_read_unichar(arg0, &arg1, &gError)

	var ret0 uint32
	var ret1 IOStatus
	var goError error

	ret0 = uint32(arg1)

	ret1 = IOStatus(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// Ref increments the reference count of a OChannel.
func (channel *IOChannel) Ref() *IOChannel {
	var arg0 *C.GIOChannel

	arg0 = (*C.GIOChannel)(channel.Native())

	ret := C.g_io_channel_ref(arg0)

	var ret0 *IOChannel

	{
		ret0 = WrapIOChannel(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *IOChannel) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Seek sets the current position in the OChannel, similar to the standard
// library function fseek().
func (channel *IOChannel) Seek(offset int64, typ SeekType) IOError {
	var arg0 *C.GIOChannel
	var arg1 C.gint64
	var arg2 C.GSeekType

	arg0 = (*C.GIOChannel)(channel.Native())
	arg1 = C.gint64(offset)
	arg2 = (C.GSeekType)(typ)

	ret := C.g_io_channel_seek(arg0, arg1, arg2)

	var ret0 IOError

	ret0 = IOError(ret)

	return ret0
}

// SeekPosition: replacement for g_io_channel_seek() with the new API.
func (channel *IOChannel) SeekPosition(offset int64, typ SeekType) (ioStatus IOStatus, err error) {
	var arg0 *C.GIOChannel
	var arg1 C.gint64
	var arg2 C.GSeekType
	var gError *C.GError

	arg0 = (*C.GIOChannel)(channel.Native())
	arg1 = C.gint64(offset)
	arg2 = (C.GSeekType)(typ)

	ret := C.g_io_channel_seek_position(arg0, arg1, arg2, &gError)

	var ret0 IOStatus
	var goError error

	ret0 = IOStatus(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// SetBufferSize sets the buffer size.
func (channel *IOChannel) SetBufferSize(size uint) {
	var arg0 *C.GIOChannel
	var arg1 C.gsize

	arg0 = (*C.GIOChannel)(channel.Native())
	arg1 = C.gsize(size)

	C.g_io_channel_set_buffer_size(arg0, arg1)
}

// SetBuffered: the buffering state can only be set if the channel's encoding is
// nil. For any other encoding, the channel must be buffered.
//
// A buffered channel can only be set unbuffered if the channel's internal
// buffers have been flushed. Newly created channels or channels which have
// returned G_IO_STATUS_EOF not require such a flush. For write-only channels, a
// call to g_io_channel_flush () is sufficient. For all other channels, the
// buffers may be flushed by a call to g_io_channel_seek_position (). This
// includes the possibility of seeking with seek type G_SEEK_CUR and an offset
// of zero. Note that this means that socket-based channels cannot be set
// unbuffered once they have had data read from them.
//
// On unbuffered channels, it is safe to mix read and write calls from the new
// and old APIs, if this is necessary for maintaining old code.
//
// The default state of the channel is buffered.
func (channel *IOChannel) SetBuffered(buffered bool) {
	var arg0 *C.GIOChannel
	var arg1 C.gboolean

	arg0 = (*C.GIOChannel)(channel.Native())
	if buffered {
		arg1 = C.TRUE
	}

	C.g_io_channel_set_buffered(arg0, arg1)
}

// SetCloseOnUnref: whether to close the channel on the final unref of the
// OChannel data structure. The default value of this is true for channels
// created by g_io_channel_new_file (), and false for all other channels.
//
// Setting this flag to true for a channel you have already closed can cause
// problems when the final reference to the OChannel is dropped.
func (channel *IOChannel) SetCloseOnUnref(doClose bool) {
	var arg0 *C.GIOChannel
	var arg1 C.gboolean

	arg0 = (*C.GIOChannel)(channel.Native())
	if doClose {
		arg1 = C.TRUE
	}

	C.g_io_channel_set_close_on_unref(arg0, arg1)
}

// SetEncoding sets the encoding for the input/output of the channel. The
// internal encoding is always UTF-8. The default encoding for the external file
// is UTF-8.
//
// The encoding nil is safe to use with binary data.
//
// The encoding can only be set if one of the following conditions is true:
//
// - The channel was just created, and has not been written to or read from yet.
//
// - The channel is write-only.
//
// - The channel is a file, and the file pointer was just repositioned by a call
// to g_io_channel_seek_position(). (This flushes all the internal buffers.)
//
// - The current encoding is nil or UTF-8.
//
// - One of the (new API) read functions has just returned G_IO_STATUS_EOF (or,
// in the case of g_io_channel_read_to_end(), G_IO_STATUS_NORMAL).
//
// - One of the functions g_io_channel_read_chars() or
// g_io_channel_read_unichar() has returned G_IO_STATUS_AGAIN or
// G_IO_STATUS_ERROR. This may be useful in the case of
// G_CONVERT_ERROR_ILLEGAL_SEQUENCE. Returning one of these statuses from
// g_io_channel_read_line(), g_io_channel_read_line_string(), or
// g_io_channel_read_to_end() does not guarantee that the encoding can be
// changed.
//
// Channels which do not meet one of the above conditions cannot call
// g_io_channel_seek_position() with an offset of G_SEEK_CUR, and, if they are
// "seekable", cannot call g_io_channel_write_chars() after calling one of the
// API "read" functions.
func (channel *IOChannel) SetEncoding(encoding string) (ioStatus IOStatus, err error) {
	var arg0 *C.GIOChannel
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GIOChannel)(channel.Native())
	arg1 = (*C.gchar)(C.CString(encoding))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_io_channel_set_encoding(arg0, arg1, &gError)

	var ret0 IOStatus
	var goError error

	ret0 = IOStatus(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// SetFlags sets the (writeable) flags in @channel to (@flags &
// G_IO_FLAG_SET_MASK).
func (channel *IOChannel) SetFlags(flags IOFlags) (ioStatus IOStatus, err error) {
	var arg0 *C.GIOChannel
	var arg1 C.GIOFlags
	var gError *C.GError

	arg0 = (*C.GIOChannel)(channel.Native())
	arg1 = (C.GIOFlags)(flags)

	ret := C.g_io_channel_set_flags(arg0, arg1, &gError)

	var ret0 IOStatus
	var goError error

	ret0 = IOStatus(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// SetLineTerm: this sets the string that OChannel uses to determine where in
// the file a line break occurs.
func (channel *IOChannel) SetLineTerm(lineTerm string, length int) {
	var arg0 *C.GIOChannel
	var arg1 *C.gchar
	var arg2 C.gint

	arg0 = (*C.GIOChannel)(channel.Native())
	arg1 = (*C.gchar)(C.CString(lineTerm))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(length)

	C.g_io_channel_set_line_term(arg0, arg1, arg2)
}

// Shutdown: close an IO channel. Any pending data to be written will be flushed
// if @flush is true. The channel will not be freed until the last reference is
// dropped using g_io_channel_unref().
func (channel *IOChannel) Shutdown(flush bool) (ioStatus IOStatus, err error) {
	var arg0 *C.GIOChannel
	var arg1 C.gboolean
	var gError *C.GError

	arg0 = (*C.GIOChannel)(channel.Native())
	if flush {
		arg1 = C.TRUE
	}

	ret := C.g_io_channel_shutdown(arg0, arg1, &gError)

	var ret0 IOStatus
	var goError error

	ret0 = IOStatus(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// UnixGetFd returns the file descriptor of the OChannel.
//
// On Windows this function returns the file descriptor or socket of the
// OChannel.
func (channel *IOChannel) UnixGetFd() int {
	var arg0 *C.GIOChannel

	arg0 = (*C.GIOChannel)(channel.Native())

	ret := C.g_io_channel_unix_get_fd(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Unref decrements the reference count of a OChannel.
func (channel *IOChannel) Unref() {
	var arg0 *C.GIOChannel

	arg0 = (*C.GIOChannel)(channel.Native())

	C.g_io_channel_unref(arg0)
}

// Write writes data to a OChannel.
func (channel *IOChannel) Write(buf string, count uint, bytesWritten uint) IOError {
	var arg0 *C.GIOChannel
	var arg1 *C.gchar
	var arg2 C.gsize
	var arg3 *C.gsize

	arg0 = (*C.GIOChannel)(channel.Native())
	arg1 = (*C.gchar)(C.CString(buf))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gsize(count)
	arg3 = (*C.gsize)(bytesWritten)

	ret := C.g_io_channel_write(arg0, arg1, arg2, arg3)

	var ret0 IOError

	ret0 = IOError(ret)

	return ret0
}

// WriteUnichar writes a Unicode character to @channel. This function cannot be
// called on a channel with nil encoding.
func (channel *IOChannel) WriteUnichar(thechar uint32) (ioStatus IOStatus, err error) {
	var arg0 *C.GIOChannel
	var arg1 C.gunichar
	var gError *C.GError

	arg0 = (*C.GIOChannel)(channel.Native())
	arg1 = C.gunichar(thechar)

	ret := C.g_io_channel_write_unichar(arg0, arg1, &gError)

	var ret0 IOStatus
	var goError error

	ret0 = IOStatus(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// KeyFile: the GKeyFile struct contains only private data and should not be
// accessed directly.
type KeyFile struct {
	native C.GKeyFile
}

// WrapKeyFile wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapKeyFile(ptr unsafe.Pointer) *KeyFile {
	if ptr == nil {
		return nil
	}

	return (*KeyFile)(ptr)
}

func marshalKeyFile(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapKeyFile(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (k *KeyFile) Native() unsafe.Pointer {
	return unsafe.Pointer(&k.native)
}

// NewKeyFile constructs a struct KeyFile.
func NewKeyFile() *KeyFile {

	ret := C.g_key_file_new()

	var ret0 *KeyFile

	{
		ret0 = WrapKeyFile(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *KeyFile) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Free clears all keys and groups from @key_file, and decreases the reference
// count by 1. If the reference count reaches zero, frees the key file and all
// its allocated memory.
func (keyFile *KeyFile) Free() {
	var arg0 *C.GKeyFile

	arg0 = (*C.GKeyFile)(keyFile.Native())

	C.g_key_file_free(arg0)
}

// Boolean returns the value associated with @key under @group_name as a
// boolean.
//
// If @key cannot be found then false is returned and @error is set to
// KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the value associated with @key
// cannot be interpreted as a boolean then false is returned and @error is set
// to KEY_FILE_ERROR_INVALID_VALUE.
func (keyFile *KeyFile) Boolean(groupName string, key string) error {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var gError *C.GError

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_key_file_get_boolean(arg0, arg1, arg2, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// BooleanList returns the values associated with @key under @group_name as
// booleans.
//
// If @key cannot be found then nil is returned and @error is set to
// KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the values associated with @key
// cannot be interpreted as booleans then nil is returned and @error is set to
// KEY_FILE_ERROR_INVALID_VALUE.
func (keyFile *KeyFile) BooleanList(groupName string, key string) (length uint, oks []bool, err error) {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gsize // out
	var gError *C.GError

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_key_file_get_boolean_list(arg0, arg1, arg2, &arg3, &gError)

	var ret0 uint
	var ret1 []bool
	var goError error

	ret0 = uint(arg3)

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret1))
		sliceHeader.Data = uintptr(unsafe.Pointer(ret))
		sliceHeader.Len = arg3
		sliceHeader.Cap = arg3
		runtime.SetFinalizer(&ret, func() {
			C.free(unsafe.Pointer(ret))
		})
		defer runtime.KeepAlive(ret)
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// Comment retrieves a comment above @key from @group_name. If @key is nil then
// @comment will be read from above @group_name. If both @key and @group_name
// are nil, then @comment will be read from above the first group in the file.
//
// Note that the returned string does not include the '#' comment markers, but
// does include any whitespace after them (on each line). It includes the line
// breaks between lines, but does not include the final line break.
func (keyFile *KeyFile) Comment(groupName string, key string) (utf8 string, err error) {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var gError *C.GError

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_key_file_get_comment(arg0, arg1, arg2, &gError)

	var ret0 string
	var goError error

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Double returns the value associated with @key under @group_name as a double.
// If @group_name is nil, the start_group is used.
//
// If @key cannot be found then 0.0 is returned and @error is set to
// KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the value associated with @key
// cannot be interpreted as a double then 0.0 is returned and @error is set to
// KEY_FILE_ERROR_INVALID_VALUE.
func (keyFile *KeyFile) Double(groupName string, key string) (gdouble float64, err error) {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var gError *C.GError

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_key_file_get_double(arg0, arg1, arg2, &gError)

	var ret0 float64
	var goError error

	ret0 = float64(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// DoubleList returns the values associated with @key under @group_name as
// doubles.
//
// If @key cannot be found then nil is returned and @error is set to
// KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the values associated with @key
// cannot be interpreted as doubles then nil is returned and @error is set to
// KEY_FILE_ERROR_INVALID_VALUE.
func (keyFile *KeyFile) DoubleList(groupName string, key string) (length uint, gdoubles []float64, err error) {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gsize // out
	var gError *C.GError

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_key_file_get_double_list(arg0, arg1, arg2, &arg3, &gError)

	var ret0 uint
	var ret1 []float64
	var goError error

	ret0 = uint(arg3)

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret1))
		sliceHeader.Data = uintptr(unsafe.Pointer(ret))
		sliceHeader.Len = arg3
		sliceHeader.Cap = arg3
		runtime.SetFinalizer(&ret, func() {
			C.free(unsafe.Pointer(ret))
		})
		defer runtime.KeepAlive(ret)
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// Groups returns all groups in the key file loaded with @key_file. The array of
// returned groups will be nil-terminated, so @length may optionally be nil.
func (keyFile *KeyFile) Groups() (length uint, utf8s []string) {
	var arg0 *C.GKeyFile
	var arg1 *C.gsize // out

	arg0 = (*C.GKeyFile)(keyFile.Native())

	ret := C.g_key_file_get_groups(arg0, &arg1)

	var ret0 uint
	var ret1 []string

	ret0 = uint(arg1)

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret1 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret1[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0, ret1
}

// Int64 returns the value associated with @key under @group_name as a signed
// 64-bit integer. This is similar to g_key_file_get_integer() but can return
// 64-bit results without truncation.
func (keyFile *KeyFile) Int64(groupName string, key string) (gint64 int64, err error) {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var gError *C.GError

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_key_file_get_int64(arg0, arg1, arg2, &gError)

	var ret0 int64
	var goError error

	ret0 = int64(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Integer returns the value associated with @key under @group_name as an
// integer.
//
// If @key cannot be found then 0 is returned and @error is set to
// KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the value associated with @key
// cannot be interpreted as an integer, or is out of range for a #gint, then 0
// is returned and @error is set to KEY_FILE_ERROR_INVALID_VALUE.
func (keyFile *KeyFile) Integer(groupName string, key string) (gint int, err error) {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var gError *C.GError

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_key_file_get_integer(arg0, arg1, arg2, &gError)

	var ret0 int
	var goError error

	ret0 = int(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// IntegerList returns the values associated with @key under @group_name as
// integers.
//
// If @key cannot be found then nil is returned and @error is set to
// KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the values associated with @key
// cannot be interpreted as integers, or are out of range for #gint, then nil is
// returned and @error is set to KEY_FILE_ERROR_INVALID_VALUE.
func (keyFile *KeyFile) IntegerList(groupName string, key string) (length uint, gints []int, err error) {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gsize // out
	var gError *C.GError

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_key_file_get_integer_list(arg0, arg1, arg2, &arg3, &gError)

	var ret0 uint
	var ret1 []int
	var goError error

	ret0 = uint(arg3)

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret1))
		sliceHeader.Data = uintptr(unsafe.Pointer(ret))
		sliceHeader.Len = arg3
		sliceHeader.Cap = arg3
		runtime.SetFinalizer(&ret, func() {
			C.free(unsafe.Pointer(ret))
		})
		defer runtime.KeepAlive(ret)
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// Keys returns all keys for the group name @group_name. The array of returned
// keys will be nil-terminated, so @length may optionally be nil. In the event
// that the @group_name cannot be found, nil is returned and @error is set to
// KEY_FILE_ERROR_GROUP_NOT_FOUND.
func (keyFile *KeyFile) Keys(groupName string) (length uint, utf8s []string, err error) {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var arg2 *C.gsize // out
	var gError *C.GError

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_key_file_get_keys(arg0, arg1, &arg2, &gError)

	var ret0 uint
	var ret1 []string
	var goError error

	ret0 = uint(arg2)

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret1 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret1[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// LocaleForKey returns the actual locale which the result of
// g_key_file_get_locale_string() or g_key_file_get_locale_string_list() came
// from.
//
// If calling g_key_file_get_locale_string() or
// g_key_file_get_locale_string_list() with exactly the same @key_file,
// @group_name, @key and @locale, the result of those functions will have
// originally been tagged with the locale that is the result of this function.
func (keyFile *KeyFile) LocaleForKey(groupName string, key string, locale string) string {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(locale))
	defer C.free(unsafe.Pointer(arg3))

	ret := C.g_key_file_get_locale_for_key(arg0, arg1, arg2, arg3)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// LocaleString returns the value associated with @key under @group_name
// translated in the given @locale if available. If @locale is nil then the
// current locale is assumed.
//
// If @locale is to be non-nil, or if the current locale will change over the
// lifetime of the File, it must be loaded with G_KEY_FILE_KEEP_TRANSLATIONS in
// order to load strings for all locales.
//
// If @key cannot be found then nil is returned and @error is set to
// KEY_FILE_ERROR_KEY_NOT_FOUND. If the value associated with @key cannot be
// interpreted or no suitable translation can be found then the untranslated
// value is returned.
func (keyFile *KeyFile) LocaleString(groupName string, key string, locale string) (utf8 string, err error) {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var gError *C.GError

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(locale))
	defer C.free(unsafe.Pointer(arg3))

	ret := C.g_key_file_get_locale_string(arg0, arg1, arg2, arg3, &gError)

	var ret0 string
	var goError error

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// LocaleStringList returns the values associated with @key under @group_name
// translated in the given @locale if available. If @locale is nil then the
// current locale is assumed.
//
// If @locale is to be non-nil, or if the current locale will change over the
// lifetime of the File, it must be loaded with G_KEY_FILE_KEEP_TRANSLATIONS in
// order to load strings for all locales.
//
// If @key cannot be found then nil is returned and @error is set to
// KEY_FILE_ERROR_KEY_NOT_FOUND. If the values associated with @key cannot be
// interpreted or no suitable translations can be found then the untranslated
// values are returned. The returned array is nil-terminated, so @length may
// optionally be nil.
func (keyFile *KeyFile) LocaleStringList(groupName string, key string, locale string) (length uint, utf8s []string, err error) {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 *C.gsize // out
	var gError *C.GError

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(locale))
	defer C.free(unsafe.Pointer(arg3))

	ret := C.g_key_file_get_locale_string_list(arg0, arg1, arg2, arg3, &arg4, &gError)

	var ret0 uint
	var ret1 []string
	var goError error

	ret0 = uint(arg4)

	{
		ret1 = make([]string, arg4)
		for i := 0; i < uintptr(arg4); i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// StartGroup returns the name of the start group of the file.
func (keyFile *KeyFile) StartGroup() string {
	var arg0 *C.GKeyFile

	arg0 = (*C.GKeyFile)(keyFile.Native())

	ret := C.g_key_file_get_start_group(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// String returns the string value associated with @key under @group_name.
// Unlike g_key_file_get_value(), this function handles escape sequences like
// \s.
//
// In the event the key cannot be found, nil is returned and @error is set to
// KEY_FILE_ERROR_KEY_NOT_FOUND. In the event that the @group_name cannot be
// found, nil is returned and @error is set to KEY_FILE_ERROR_GROUP_NOT_FOUND.
func (keyFile *KeyFile) String(groupName string, key string) (utf8 string, err error) {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var gError *C.GError

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_key_file_get_string(arg0, arg1, arg2, &gError)

	var ret0 string
	var goError error

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// StringList returns the values associated with @key under @group_name.
//
// In the event the key cannot be found, nil is returned and @error is set to
// KEY_FILE_ERROR_KEY_NOT_FOUND. In the event that the @group_name cannot be
// found, nil is returned and @error is set to KEY_FILE_ERROR_GROUP_NOT_FOUND.
func (keyFile *KeyFile) StringList(groupName string, key string) (length uint, utf8s []string, err error) {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gsize // out
	var gError *C.GError

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_key_file_get_string_list(arg0, arg1, arg2, &arg3, &gError)

	var ret0 uint
	var ret1 []string
	var goError error

	ret0 = uint(arg3)

	{
		ret1 = make([]string, arg3)
		for i := 0; i < uintptr(arg3); i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// Uint64 returns the value associated with @key under @group_name as an
// unsigned 64-bit integer. This is similar to g_key_file_get_integer() but can
// return large positive results without truncation.
func (keyFile *KeyFile) Uint64(groupName string, key string) (guint64 uint64, err error) {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var gError *C.GError

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_key_file_get_uint64(arg0, arg1, arg2, &gError)

	var ret0 uint64
	var goError error

	ret0 = uint64(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Value returns the raw value associated with @key under @group_name. Use
// g_key_file_get_string() to retrieve an unescaped UTF-8 string.
//
// In the event the key cannot be found, nil is returned and @error is set to
// KEY_FILE_ERROR_KEY_NOT_FOUND. In the event that the @group_name cannot be
// found, nil is returned and @error is set to KEY_FILE_ERROR_GROUP_NOT_FOUND.
func (keyFile *KeyFile) Value(groupName string, key string) (utf8 string, err error) {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var gError *C.GError

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_key_file_get_value(arg0, arg1, arg2, &gError)

	var ret0 string
	var goError error

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// HasGroup looks whether the key file has the group @group_name.
func (keyFile *KeyFile) HasGroup(groupName string) bool {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_key_file_has_group(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// HasKey looks whether the key file has the key @key in the group @group_name.
//
// Note that this function does not follow the rules for #GError strictly; the
// return value both carries meaning and signals an error. To use this function,
// you must pass a #GError pointer in @error, and check whether it is not nil to
// see if an error occurred.
//
// Language bindings should use g_key_file_get_value() to test whether or not a
// key exists.
func (keyFile *KeyFile) HasKey(groupName string, key string) error {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var gError *C.GError

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_key_file_has_key(arg0, arg1, arg2, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// LoadFromBytes loads a key file from the data in @bytes into an empty File
// structure. If the object cannot be created then error is set to a FileError.
func (keyFile *KeyFile) LoadFromBytes(bytes *Bytes, flags KeyFileFlags) error {
	var arg0 *C.GKeyFile
	var arg1 *C.GBytes
	var arg2 C.GKeyFileFlags
	var gError *C.GError

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.GBytes)(bytes.Native())
	arg2 = (C.GKeyFileFlags)(flags)

	ret := C.g_key_file_load_from_bytes(arg0, arg1, arg2, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// LoadFromData loads a key file from memory into an empty File structure. If
// the object cannot be created then error is set to a FileError.
func (keyFile *KeyFile) LoadFromData(data string, length uint, flags KeyFileFlags) error {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var arg2 C.gsize
	var arg3 C.GKeyFileFlags
	var gError *C.GError

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(data))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gsize(length)
	arg3 = (C.GKeyFileFlags)(flags)

	ret := C.g_key_file_load_from_data(arg0, arg1, arg2, arg3, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// LoadFromDataDirs: this function looks for a key file named @file in the paths
// returned from g_get_user_data_dir() and g_get_system_data_dirs(), loads the
// file into @key_file and returns the file's full path in @full_path. If the
// file could not be loaded then an error is set to either a Error or FileError.
func (keyFile *KeyFile) LoadFromDataDirs(file string, flags KeyFileFlags) (fullPath string, err error) {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var arg2 **C.gchar // out
	var arg3 C.GKeyFileFlags
	var gError *C.GError

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(file))
	defer C.free(unsafe.Pointer(arg1))
	arg3 = (C.GKeyFileFlags)(flags)

	ret := C.g_key_file_load_from_data_dirs(arg0, arg1, &arg2, arg3, &gError)

	var ret0 string
	var goError error

	ret0 = C.GoString(arg2)
	C.free(unsafe.Pointer(arg2))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// LoadFromDirs: this function looks for a key file named @file in the paths
// specified in @search_dirs, loads the file into @key_file and returns the
// file's full path in @full_path.
//
// If the file could not be found in any of the @search_dirs,
// G_KEY_FILE_ERROR_NOT_FOUND is returned. If the file is found but the OS
// returns an error when opening or reading the file, a G_FILE_ERROR is
// returned. If there is a problem parsing the file, a G_KEY_FILE_ERROR is
// returned.
func (keyFile *KeyFile) LoadFromDirs(file string, searchDirs []string, flags KeyFileFlags) (fullPath string, err error) {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var arg2 **C.gchar
	var arg3 **C.gchar // out
	var arg4 C.GKeyFileFlags
	var gError *C.GError

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(file))
	defer C.free(unsafe.Pointer(arg1))
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(searchDirs) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(searchDirs)
		sliceHeader.Cap = len(searchDirs)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(searchDirs); i++ {
			src := searchDirs[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg2 = (**C.gchar)(unsafe.Pointer(ptr))
	}
	arg4 = (C.GKeyFileFlags)(flags)

	ret := C.g_key_file_load_from_dirs(arg0, arg1, arg2, &arg3, arg4, &gError)

	var ret0 string
	var goError error

	ret0 = C.GoString(arg3)
	C.free(unsafe.Pointer(arg3))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// LoadFromFile loads a key file into an empty File structure.
//
// If the OS returns an error when opening or reading the file, a G_FILE_ERROR
// is returned. If there is a problem parsing the file, a G_KEY_FILE_ERROR is
// returned.
//
// This function will never return a G_KEY_FILE_ERROR_NOT_FOUND error. If the
// @file is not found, G_FILE_ERROR_NOENT is returned.
func (keyFile *KeyFile) LoadFromFile(file string, flags KeyFileFlags) error {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var arg2 C.GKeyFileFlags
	var gError *C.GError

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(file))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GKeyFileFlags)(flags)

	ret := C.g_key_file_load_from_file(arg0, arg1, arg2, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// Ref increases the reference count of @key_file.
func (keyFile *KeyFile) Ref() *KeyFile {
	var arg0 *C.GKeyFile

	arg0 = (*C.GKeyFile)(keyFile.Native())

	ret := C.g_key_file_ref(arg0)

	var ret0 *KeyFile

	{
		ret0 = WrapKeyFile(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *KeyFile) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// RemoveComment removes a comment above @key from @group_name. If @key is nil
// then @comment will be removed above @group_name. If both @key and @group_name
// are nil, then @comment will be removed above the first group in the file.
func (keyFile *KeyFile) RemoveComment(groupName string, key string) error {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var gError *C.GError

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_key_file_remove_comment(arg0, arg1, arg2, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// RemoveGroup removes the specified group, @group_name, from the key file.
func (keyFile *KeyFile) RemoveGroup(groupName string) error {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_key_file_remove_group(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// RemoveKey removes @key in @group_name from the key file.
func (keyFile *KeyFile) RemoveKey(groupName string, key string) error {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var gError *C.GError

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_key_file_remove_key(arg0, arg1, arg2, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SaveToFile writes the contents of @key_file to @filename using
// g_file_set_contents(). If you need stricter guarantees about durability of
// the written file than are provided by g_file_set_contents(), use
// g_file_set_contents_full() with the return value of g_key_file_to_data().
//
// This function can fail for any of the reasons that g_file_set_contents() may
// fail.
func (keyFile *KeyFile) SaveToFile(filename string) error {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_key_file_save_to_file(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SetBoolean associates a new boolean value with @key under @group_name. If
// @key cannot be found then it is created.
func (keyFile *KeyFile) SetBoolean(groupName string, key string, value bool) {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 C.gboolean

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg2))
	if value {
		arg3 = C.TRUE
	}

	C.g_key_file_set_boolean(arg0, arg1, arg2, arg3)
}

// SetBooleanList associates a list of boolean values with @key under
// @group_name. If @key cannot be found then it is created. If @group_name is
// nil, the start_group is used.
func (keyFile *KeyFile) SetBooleanList(groupName string, key string, list []bool) {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gboolean
	var arg4 C.gsize

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gboolean)(unsafe.Pointer(&list[0]))
	arg4 = len(list)
	defer runtime.KeepAlive(list)

	C.g_key_file_set_boolean_list(arg0, arg1, arg2, arg3, arg4)
}

// SetComment places a comment above @key from @group_name.
//
// If @key is nil then @comment will be written above @group_name. If both @key
// and @group_name are nil, then @comment will be written above the first group
// in the file.
//
// Note that this function prepends a '#' comment marker to each line of
// @comment.
func (keyFile *KeyFile) SetComment(groupName string, key string, comment string) error {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var gError *C.GError

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(comment))
	defer C.free(unsafe.Pointer(arg3))

	ret := C.g_key_file_set_comment(arg0, arg1, arg2, arg3, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SetDouble associates a new double value with @key under @group_name. If @key
// cannot be found then it is created.
func (keyFile *KeyFile) SetDouble(groupName string, key string, value float64) {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 C.gdouble

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.gdouble(value)

	C.g_key_file_set_double(arg0, arg1, arg2, arg3)
}

// SetDoubleList associates a list of double values with @key under @group_name.
// If @key cannot be found then it is created.
func (keyFile *KeyFile) SetDoubleList(groupName string, key string, list []float64) {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gdouble
	var arg4 C.gsize

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gdouble)(unsafe.Pointer(&list[0]))
	arg4 = len(list)
	defer runtime.KeepAlive(list)

	C.g_key_file_set_double_list(arg0, arg1, arg2, arg3, arg4)
}

// SetInt64 associates a new integer value with @key under @group_name. If @key
// cannot be found then it is created.
func (keyFile *KeyFile) SetInt64(groupName string, key string, value int64) {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 C.gint64

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.gint64(value)

	C.g_key_file_set_int64(arg0, arg1, arg2, arg3)
}

// SetInteger associates a new integer value with @key under @group_name. If
// @key cannot be found then it is created.
func (keyFile *KeyFile) SetInteger(groupName string, key string, value int) {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 C.gint

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.gint(value)

	C.g_key_file_set_integer(arg0, arg1, arg2, arg3)
}

// SetIntegerList associates a list of integer values with @key under
// @group_name. If @key cannot be found then it is created.
func (keyFile *KeyFile) SetIntegerList(groupName string, key string, list []int) {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gint
	var arg4 C.gsize

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gint)(unsafe.Pointer(&list[0]))
	arg4 = len(list)
	defer runtime.KeepAlive(list)

	C.g_key_file_set_integer_list(arg0, arg1, arg2, arg3, arg4)
}

// SetListSeparator sets the character which is used to separate values in
// lists. Typically ';' or ',' are used as separators. The default list
// separator is ';'.
func (keyFile *KeyFile) SetListSeparator(separator byte) {
	var arg0 *C.GKeyFile
	var arg1 C.gchar

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = C.gchar(separator)

	C.g_key_file_set_list_separator(arg0, arg1)
}

// SetLocaleString associates a string value for @key and @locale under
// @group_name. If the translation for @key cannot be found then it is created.
func (keyFile *KeyFile) SetLocaleString(groupName string, key string, locale string, string string) {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 *C.gchar

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(locale))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg4))

	C.g_key_file_set_locale_string(arg0, arg1, arg2, arg3, arg4)
}

// SetLocaleStringList associates a list of string values for @key and @locale
// under @group_name. If the translation for @key cannot be found then it is
// created.
func (keyFile *KeyFile) SetLocaleStringList(groupName string, key string, locale string, list []string) {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 **C.gchar
	var arg5 C.gsize

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(locale))
	defer C.free(unsafe.Pointer(arg3))
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * len(list))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(list)
		sliceHeader.Cap = len(list)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(list); i++ {
			src := list[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg4 = (**C.gchar)(unsafe.Pointer(ptr))
		arg5 = len(list)
	}

	C.g_key_file_set_locale_string_list(arg0, arg1, arg2, arg3, arg4, arg5)
}

// SetString associates a new string value with @key under @group_name. If @key
// cannot be found then it is created. If @group_name cannot be found then it is
// created. Unlike g_key_file_set_value(), this function handles characters that
// need escaping, such as newlines.
func (keyFile *KeyFile) SetString(groupName string, key string, string string) {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg3))

	C.g_key_file_set_string(arg0, arg1, arg2, arg3)
}

// SetStringList associates a list of string values for @key under @group_name.
// If @key cannot be found then it is created. If @group_name cannot be found
// then it is created.
func (keyFile *KeyFile) SetStringList(groupName string, key string, list []string) {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 **C.gchar
	var arg4 C.gsize

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg2))
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * len(list))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(list)
		sliceHeader.Cap = len(list)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(list); i++ {
			src := list[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg3 = (**C.gchar)(unsafe.Pointer(ptr))
		arg4 = len(list)
	}

	C.g_key_file_set_string_list(arg0, arg1, arg2, arg3, arg4)
}

// SetUint64 associates a new integer value with @key under @group_name. If @key
// cannot be found then it is created.
func (keyFile *KeyFile) SetUint64(groupName string, key string, value uint64) {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 C.guint64

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.guint64(value)

	C.g_key_file_set_uint64(arg0, arg1, arg2, arg3)
}

// SetValue associates a new value with @key under @group_name.
//
// If @key cannot be found then it is created. If @group_name cannot be found
// then it is created. To set an UTF-8 string which may contain characters that
// need escaping (such as newlines or spaces), use g_key_file_set_string().
func (keyFile *KeyFile) SetValue(groupName string, key string, value string) {
	var arg0 *C.GKeyFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar

	arg0 = (*C.GKeyFile)(keyFile.Native())
	arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(arg3))

	C.g_key_file_set_value(arg0, arg1, arg2, arg3)
}

// ToData: this function outputs @key_file as a string.
//
// Note that this function never reports an error, so it is safe to pass nil as
// @error.
func (keyFile *KeyFile) ToData() (length uint, utf8 string, err error) {
	var arg0 *C.GKeyFile
	var arg1 *C.gsize // out
	var gError *C.GError

	arg0 = (*C.GKeyFile)(keyFile.Native())

	ret := C.g_key_file_to_data(arg0, &arg1, &gError)

	var ret0 uint
	var ret1 string
	var goError error

	ret0 = uint(arg1)

	ret1 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// Unref decreases the reference count of @key_file by 1. If the reference count
// reaches zero, frees the key file and all its allocated memory.
func (keyFile *KeyFile) Unref() {
	var arg0 *C.GKeyFile

	arg0 = (*C.GKeyFile)(keyFile.Native())

	C.g_key_file_unref(arg0)
}

// List: the #GList struct is used for each element in a doubly-linked list.
type List struct {
	native C.GList
}

// WrapList wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapList(ptr unsafe.Pointer) *List {
	if ptr == nil {
		return nil
	}

	return (*List)(ptr)
}

func marshalList(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapList(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (l *List) Native() unsafe.Pointer {
	return unsafe.Pointer(&l.native)
}

// Data gets the field inside the struct.
func (l *List) Data() interface{} {
	var ret interface{}
	ret = box.Get(uintptr(l.native.data))
	return ret
}

// Next gets the field inside the struct.
func (l *List) Next() *List {
	var ret *List
	{
		ret = WrapList(unsafe.Pointer(l.native.next))
	}
	return ret
}

// Prev gets the field inside the struct.
func (l *List) Prev() *List {
	var ret *List
	{
		ret = WrapList(unsafe.Pointer(l.native.prev))
	}
	return ret
}

// LogField: structure representing a single field in a structured log entry.
// See g_log_structured() for details.
//
// Log fields may contain arbitrary values, including binary with embedded nul
// bytes. If the field contains a string, the string must be UTF-8 encoded and
// have a trailing nul byte. Otherwise, @length must be set to a non-negative
// value.
type LogField struct {
	native C.GLogField
}

// WrapLogField wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapLogField(ptr unsafe.Pointer) *LogField {
	if ptr == nil {
		return nil
	}

	return (*LogField)(ptr)
}

func marshalLogField(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapLogField(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (l *LogField) Native() unsafe.Pointer {
	return unsafe.Pointer(&l.native)
}

// Key gets the field inside the struct.
func (l *LogField) Key() string {
	var ret string
	ret = C.GoString(l.native.key)
	return ret
}

// Value gets the field inside the struct.
func (l *LogField) Value() interface{} {
	var ret interface{}
	ret = box.Get(uintptr(l.native.value))
	return ret
}

// Length gets the field inside the struct.
func (l *LogField) Length() int {
	var ret int
	ret = int(l.native.length)
	return ret
}

// MainContext: the `GMainContext` struct is an opaque data type representing a
// set of sources to be handled in a main loop.
type MainContext struct {
	native C.GMainContext
}

// WrapMainContext wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMainContext(ptr unsafe.Pointer) *MainContext {
	if ptr == nil {
		return nil
	}

	return (*MainContext)(ptr)
}

func marshalMainContext(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapMainContext(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (m *MainContext) Native() unsafe.Pointer {
	return unsafe.Pointer(&m.native)
}

// NewMainContext constructs a struct MainContext.
func NewMainContext() *MainContext {

	ret := C.g_main_context_new()

	var ret0 *MainContext

	{
		ret0 = WrapMainContext(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *MainContext) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Acquire tries to become the owner of the specified context. If some other
// thread is the owner of the context, returns false immediately. Ownership is
// properly recursive: the owner can require ownership again and will release
// ownership when g_main_context_release() is called as many times as
// g_main_context_acquire().
//
// You must be the owner of a context before you can call
// g_main_context_prepare(), g_main_context_query(), g_main_context_check(),
// g_main_context_dispatch().
func (context *MainContext) Acquire() bool {
	var arg0 *C.GMainContext

	arg0 = (*C.GMainContext)(context.Native())

	ret := C.g_main_context_acquire(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// AddPoll adds a file descriptor to the set of file descriptors polled for this
// context. This will very seldom be used directly. Instead a typical event
// source will use g_source_add_unix_fd() instead.
func (context *MainContext) AddPoll(fd *PollFD, priority int) {
	var arg0 *C.GMainContext
	var arg1 *C.GPollFD
	var arg2 C.gint

	arg0 = (*C.GMainContext)(context.Native())
	arg1 = (*C.GPollFD)(fd.Native())
	arg2 = C.gint(priority)

	C.g_main_context_add_poll(arg0, arg1, arg2)
}

// Check passes the results of polling back to the main loop.
//
// You must have successfully acquired the context with g_main_context_acquire()
// before you may call this function.
func (context *MainContext) Check(maxPriority int, fds []PollFD) bool {
	var arg0 *C.GMainContext
	var arg1 C.gint
	var arg2 *C.GPollFD
	var arg3 C.gint

	arg0 = (*C.GMainContext)(context.Native())
	arg1 = C.gint(maxPriority)
	arg2 = (*C.GPollFD)(unsafe.Pointer(&fds[0]))
	arg3 = len(fds)
	defer runtime.KeepAlive(fds)

	ret := C.g_main_context_check(arg0, arg1, arg2, arg3)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Dispatch dispatches all pending sources.
//
// You must have successfully acquired the context with g_main_context_acquire()
// before you may call this function.
func (context *MainContext) Dispatch() {
	var arg0 *C.GMainContext

	arg0 = (*C.GMainContext)(context.Native())

	C.g_main_context_dispatch(arg0)
}

// FindSourceByID finds a #GSource given a pair of context and ID.
//
// It is a programmer error to attempt to look up a non-existent source.
//
// More specifically: source IDs can be reissued after a source has been
// destroyed and therefore it is never valid to use this function with a source
// ID which may have already been removed. An example is when scheduling an idle
// to run in another thread with g_idle_add(): the idle may already have run and
// been removed by the time this function is called on its (now invalid) source
// ID. This source ID may have been reissued, leading to the operation being
// performed against the wrong source.
func (context *MainContext) FindSourceByID(sourceID uint) *Source {
	var arg0 *C.GMainContext
	var arg1 C.guint

	arg0 = (*C.GMainContext)(context.Native())
	arg1 = C.guint(sourceID)

	ret := C.g_main_context_find_source_by_id(arg0, arg1)

	var ret0 *Source

	{
		ret0 = WrapSource(unsafe.Pointer(ret))
	}

	return ret0
}

// FindSourceByUserData finds a source with the given user data for the
// callback. If multiple sources exist with the same user data, the first one
// found will be returned.
func (context *MainContext) FindSourceByUserData(userData interface{}) *Source {
	var arg0 *C.GMainContext
	var arg1 C.gpointer

	arg0 = (*C.GMainContext)(context.Native())
	arg1 = C.gpointer(box.Assign(userData))

	ret := C.g_main_context_find_source_by_user_data(arg0, arg1)

	var ret0 *Source

	{
		ret0 = WrapSource(unsafe.Pointer(ret))
	}

	return ret0
}

// Invoke invokes a function in such a way that @context is owned during the
// invocation of @function.
//
// If @context is nil then the global default main context — as returned by
// g_main_context_default() — is used.
//
// If @context is owned by the current thread, @function is called directly.
// Otherwise, if @context is the thread-default main context of the current
// thread and g_main_context_acquire() succeeds, then @function is called and
// g_main_context_release() is called afterwards.
//
// In any other case, an idle source is created to call @function and that
// source is attached to @context (presumably to be run in another thread). The
// idle source is attached with PRIORITY_DEFAULT priority. If you want a
// different priority, use g_main_context_invoke_full().
//
// Note that, as with normal idle functions, @function should probably return
// false. If it returns true, it will be continuously run in a loop (and may
// prevent this call from returning).
func (context *MainContext) Invoke(function SourceFunc) {
	var arg0 *C.GMainContext
	var arg1 C.GSourceFunc
	var arg2 C.gpointer

	arg0 = (*C.GMainContext)(context.Native())
	arg1 = (*[0]byte)(C.gotk4_SourceFunc)
	arg2 = C.gpointer(box.Assign(function))

	C.g_main_context_invoke(arg0, arg1, arg2)
}

// InvokeFull invokes a function in such a way that @context is owned during the
// invocation of @function.
//
// This function is the same as g_main_context_invoke() except that it lets you
// specify the priority in case @function ends up being scheduled as an idle and
// also lets you give a Notify for @data.
//
// @notify should not assume that it is called from any particular thread or
// with any particular context acquired.
func (context *MainContext) InvokeFull(priority int, function SourceFunc) {
	var arg0 *C.GMainContext
	var arg1 C.gint
	var arg2 C.GSourceFunc
	var arg3 C.gpointer
	var arg4 C.GDestroyNotify

	arg0 = (*C.GMainContext)(context.Native())
	arg1 = C.gint(priority)
	arg2 = (*[0]byte)(C.gotk4_SourceFunc)
	arg3 = C.gpointer(box.Assign(function))
	arg4 = (*[0]byte)(C.callbackDelete)

	C.g_main_context_invoke_full(arg0, arg1, arg2, arg3, arg4)
}

// IsOwner determines whether this thread holds the (recursive) ownership of
// this Context. This is useful to know before waiting on another thread that
// may be blocking to get ownership of @context.
func (context *MainContext) IsOwner() bool {
	var arg0 *C.GMainContext

	arg0 = (*C.GMainContext)(context.Native())

	ret := C.g_main_context_is_owner(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Iteration runs a single iteration for the given main loop. This involves
// checking to see if any event sources are ready to be processed, then if no
// events sources are ready and @may_block is true, waiting for a source to
// become ready, then dispatching the highest priority events sources that are
// ready. Otherwise, if @may_block is false sources are not waited to become
// ready, only those highest priority events sources will be dispatched (if
// any), that are ready at this given moment without further waiting.
//
// Note that even when @may_block is true, it is still possible for
// g_main_context_iteration() to return false, since the wait may be interrupted
// for other reasons than an event source becoming ready.
func (context *MainContext) Iteration(mayBlock bool) bool {
	var arg0 *C.GMainContext
	var arg1 C.gboolean

	arg0 = (*C.GMainContext)(context.Native())
	if mayBlock {
		arg1 = C.TRUE
	}

	ret := C.g_main_context_iteration(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Pending checks if any sources have pending events for the given context.
func (context *MainContext) Pending() bool {
	var arg0 *C.GMainContext

	arg0 = (*C.GMainContext)(context.Native())

	ret := C.g_main_context_pending(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// PopThreadDefault pops @context off the thread-default context stack
// (verifying that it was on the top of the stack).
func (context *MainContext) PopThreadDefault() {
	var arg0 *C.GMainContext

	arg0 = (*C.GMainContext)(context.Native())

	C.g_main_context_pop_thread_default(arg0)
}

// Prepare prepares to poll sources within a main loop. The resulting
// information for polling is determined by calling g_main_context_query ().
//
// You must have successfully acquired the context with g_main_context_acquire()
// before you may call this function.
func (context *MainContext) Prepare() (priority int, ok bool) {
	var arg0 *C.GMainContext
	var arg1 *C.gint // out

	arg0 = (*C.GMainContext)(context.Native())

	ret := C.g_main_context_prepare(arg0, &arg1)

	var ret0 int
	var ret1 bool

	ret0 = int(arg1)

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// PushThreadDefault acquires @context and sets it as the thread-default context
// for the current thread. This will cause certain asynchronous operations (such
// as most [gio][gio]-based I/O) which are started in this thread to run under
// @context and deliver their results to its main loop, rather than running
// under the global default context in the main thread. Note that calling this
// function changes the context returned by g_main_context_get_thread_default(),
// not the one returned by g_main_context_default(), so it does not affect the
// context used by functions like g_idle_add().
//
// Normally you would call this function shortly after creating a new thread,
// passing it a Context which will be run by a Loop in that thread, to set a new
// default context for all async operations in that thread. In this case you may
// not need to ever call g_main_context_pop_thread_default(), assuming you want
// the new Context to be the default for the whole lifecycle of the thread.
//
// If you don't have control over how the new thread was created (e.g. in the
// new thread isn't newly created, or if the thread life cycle is managed by a
// Pool), it is always suggested to wrap the logic that needs to use the new
// Context inside a g_main_context_push_thread_default() /
// g_main_context_pop_thread_default() pair, otherwise threads that are re-used
// will end up never explicitly releasing the Context reference they hold.
//
// In some cases you may want to schedule a single operation in a non-default
// context, or temporarily use a non-default context in the main thread. In that
// case, you can wrap the call to the asynchronous operation inside a
// g_main_context_push_thread_default() / g_main_context_pop_thread_default()
// pair, but it is up to you to ensure that no other asynchronous operations
// accidentally get started while the non-default context is active.
//
// Beware that libraries that predate this function may not correctly handle
// being used from a thread with a thread-default context. Eg, see
// g_file_supports_thread_contexts().
func (context *MainContext) PushThreadDefault() {
	var arg0 *C.GMainContext

	arg0 = (*C.GMainContext)(context.Native())

	C.g_main_context_push_thread_default(arg0)
}

// Query determines information necessary to poll this main loop.
//
// You must have successfully acquired the context with g_main_context_acquire()
// before you may call this function.
func (context *MainContext) Query(maxPriority int) (timeout_ int, fds []PollFD, gint int) {
	var arg0 *C.GMainContext
	var arg1 C.gint
	var arg2 *C.gint    // out
	var arg3 *C.GPollFD // out
	var arg4 C.gint

	arg0 = (*C.GMainContext)(context.Native())
	arg1 = C.gint(maxPriority)

	ret := C.g_main_context_query(arg0, arg1, &arg2, &arg3, arg4)

	var ret0 int
	var ret1 []PollFD
	var ret2 int

	ret0 = int(arg2)

	{
		ret1 = make([]PollFD, arg4)
		for i := 0; i < uintptr(arg4); i++ {
			src := (C.GPollFD)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			{
				ret1[i] = WrapPollFD(unsafe.Pointer(src))
			}
		}
	}

	ret2 = int(ret)

	return ret0, ret1, ret2
}

// Ref increases the reference count on a Context object by one.
func (context *MainContext) Ref() *MainContext {
	var arg0 *C.GMainContext

	arg0 = (*C.GMainContext)(context.Native())

	ret := C.g_main_context_ref(arg0)

	var ret0 *MainContext

	{
		ret0 = WrapMainContext(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *MainContext) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Release releases ownership of a context previously acquired by this thread
// with g_main_context_acquire(). If the context was acquired multiple times,
// the ownership will be released only when g_main_context_release() is called
// as many times as it was acquired.
func (context *MainContext) Release() {
	var arg0 *C.GMainContext

	arg0 = (*C.GMainContext)(context.Native())

	C.g_main_context_release(arg0)
}

// RemovePoll removes file descriptor from the set of file descriptors to be
// polled for a particular context.
func (context *MainContext) RemovePoll(fd *PollFD) {
	var arg0 *C.GMainContext
	var arg1 *C.GPollFD

	arg0 = (*C.GMainContext)(context.Native())
	arg1 = (*C.GPollFD)(fd.Native())

	C.g_main_context_remove_poll(arg0, arg1)
}

// Unref decreases the reference count on a Context object by one. If the result
// is zero, free the context and free all associated memory.
func (context *MainContext) Unref() {
	var arg0 *C.GMainContext

	arg0 = (*C.GMainContext)(context.Native())

	C.g_main_context_unref(arg0)
}

// Wakeup: if @context is currently blocking in g_main_context_iteration()
// waiting for a source to become ready, cause it to stop blocking and return.
// Otherwise, cause the next invocation of g_main_context_iteration() to return
// without blocking.
//
// This API is useful for low-level control over Context; for example,
// integrating it with main loop implementations such as Loop.
//
// Another related use for this function is when implementing a main loop with a
// termination condition, computed from multiple threads:
//
//      perform_work();
//
//      if (g_atomic_int_dec_and_test (&tasks_remaining))
//        g_main_context_wakeup (NULL);
func (context *MainContext) Wakeup() {
	var arg0 *C.GMainContext

	arg0 = (*C.GMainContext)(context.Native())

	C.g_main_context_wakeup(arg0)
}

// MainLoop: the `GMainLoop` struct is an opaque data type representing the main
// event loop of a GLib or GTK+ application.
type MainLoop struct {
	native C.GMainLoop
}

// WrapMainLoop wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMainLoop(ptr unsafe.Pointer) *MainLoop {
	if ptr == nil {
		return nil
	}

	return (*MainLoop)(ptr)
}

func marshalMainLoop(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapMainLoop(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (m *MainLoop) Native() unsafe.Pointer {
	return unsafe.Pointer(&m.native)
}

// NewMainLoop constructs a struct MainLoop.
func NewMainLoop(context *MainContext, isRunning bool) *MainLoop {
	var arg1 *C.GMainContext
	var arg2 C.gboolean

	arg1 = (*C.GMainContext)(context.Native())
	if isRunning {
		arg2 = C.TRUE
	}

	ret := C.g_main_loop_new(arg1, arg2)

	var ret0 *MainLoop

	{
		ret0 = WrapMainLoop(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *MainLoop) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Context returns the Context of @loop.
func (loop *MainLoop) Context() *MainContext {
	var arg0 *C.GMainLoop

	arg0 = (*C.GMainLoop)(loop.Native())

	ret := C.g_main_loop_get_context(arg0)

	var ret0 *MainContext

	{
		ret0 = WrapMainContext(unsafe.Pointer(ret))
	}

	return ret0
}

// IsRunning checks to see if the main loop is currently being run via
// g_main_loop_run().
func (loop *MainLoop) IsRunning() bool {
	var arg0 *C.GMainLoop

	arg0 = (*C.GMainLoop)(loop.Native())

	ret := C.g_main_loop_is_running(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Quit stops a Loop from running. Any calls to g_main_loop_run() for the loop
// will return.
//
// Note that sources that have already been dispatched when g_main_loop_quit()
// is called will still be executed.
func (loop *MainLoop) Quit() {
	var arg0 *C.GMainLoop

	arg0 = (*C.GMainLoop)(loop.Native())

	C.g_main_loop_quit(arg0)
}

// Ref increases the reference count on a Loop object by one.
func (loop *MainLoop) Ref() *MainLoop {
	var arg0 *C.GMainLoop

	arg0 = (*C.GMainLoop)(loop.Native())

	ret := C.g_main_loop_ref(arg0)

	var ret0 *MainLoop

	{
		ret0 = WrapMainLoop(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *MainLoop) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Run runs a main loop until g_main_loop_quit() is called on the loop. If this
// is called for the thread of the loop's Context, it will process events from
// the loop, otherwise it will simply wait.
func (loop *MainLoop) Run() {
	var arg0 *C.GMainLoop

	arg0 = (*C.GMainLoop)(loop.Native())

	C.g_main_loop_run(arg0)
}

// Unref decreases the reference count on a Loop object by one. If the result is
// zero, free the loop and free all associated memory.
func (loop *MainLoop) Unref() {
	var arg0 *C.GMainLoop

	arg0 = (*C.GMainLoop)(loop.Native())

	C.g_main_loop_unref(arg0)
}

// MappedFile: the File represents a file mapping created with
// g_mapped_file_new(). It has only private members and should not be accessed
// directly.
type MappedFile struct {
	native C.GMappedFile
}

// WrapMappedFile wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMappedFile(ptr unsafe.Pointer) *MappedFile {
	if ptr == nil {
		return nil
	}

	return (*MappedFile)(ptr)
}

func marshalMappedFile(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapMappedFile(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (m *MappedFile) Native() unsafe.Pointer {
	return unsafe.Pointer(&m.native)
}

// NewMappedFile constructs a struct MappedFile.
func NewMappedFile(filename string, writable bool) (mappedFile *MappedFile, err error) {
	var arg1 *C.gchar
	var arg2 C.gboolean
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))
	if writable {
		arg2 = C.TRUE
	}

	ret := C.g_mapped_file_new(arg1, arg2, &gError)

	var ret0 *MappedFile
	var goError error

	{
		ret0 = WrapMappedFile(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *MappedFile) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// NewMappedFileFromFd constructs a struct MappedFile.
func NewMappedFileFromFd(fd int, writable bool) (mappedFile *MappedFile, err error) {
	var arg1 C.gint
	var arg2 C.gboolean
	var gError *C.GError

	arg1 = C.gint(fd)
	if writable {
		arg2 = C.TRUE
	}

	ret := C.g_mapped_file_new_from_fd(arg1, arg2, &gError)

	var ret0 *MappedFile
	var goError error

	{
		ret0 = WrapMappedFile(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *MappedFile) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Free: this call existed before File had refcounting and is currently exactly
// the same as g_mapped_file_unref().
func (file *MappedFile) Free() {
	var arg0 *C.GMappedFile

	arg0 = (*C.GMappedFile)(file.Native())

	C.g_mapped_file_free(arg0)
}

// Bytes creates a new #GBytes which references the data mapped from @file. The
// mapped contents of the file must not be modified after creating this bytes
// object, because a #GBytes should be immutable.
func (file *MappedFile) Bytes() *Bytes {
	var arg0 *C.GMappedFile

	arg0 = (*C.GMappedFile)(file.Native())

	ret := C.g_mapped_file_get_bytes(arg0)

	var ret0 *Bytes

	{
		ret0 = WrapBytes(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Bytes) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Contents returns the contents of a File.
//
// Note that the contents may not be zero-terminated, even if the File is backed
// by a text file.
//
// If the file is empty then nil is returned.
func (file *MappedFile) Contents() string {
	var arg0 *C.GMappedFile

	arg0 = (*C.GMappedFile)(file.Native())

	ret := C.g_mapped_file_get_contents(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Length returns the length of the contents of a File.
func (file *MappedFile) Length() uint {
	var arg0 *C.GMappedFile

	arg0 = (*C.GMappedFile)(file.Native())

	ret := C.g_mapped_file_get_length(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Ref increments the reference count of @file by one. It is safe to call this
// function from any thread.
func (file *MappedFile) Ref() *MappedFile {
	var arg0 *C.GMappedFile

	arg0 = (*C.GMappedFile)(file.Native())

	ret := C.g_mapped_file_ref(arg0)

	var ret0 *MappedFile

	{
		ret0 = WrapMappedFile(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *MappedFile) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Unref decrements the reference count of @file by one. If the reference count
// drops to 0, unmaps the buffer of @file and frees it.
//
// It is safe to call this function from any thread.
//
// Since 2.22
func (file *MappedFile) Unref() {
	var arg0 *C.GMappedFile

	arg0 = (*C.GMappedFile)(file.Native())

	C.g_mapped_file_unref(arg0)
}

// MarkupParseContext: a parse context is used to parse a stream of bytes that
// you expect to contain marked-up text.
//
// See g_markup_parse_context_new(), Parser, and so on for more details.
type MarkupParseContext struct {
	native C.GMarkupParseContext
}

// WrapMarkupParseContext wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMarkupParseContext(ptr unsafe.Pointer) *MarkupParseContext {
	if ptr == nil {
		return nil
	}

	return (*MarkupParseContext)(ptr)
}

func marshalMarkupParseContext(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapMarkupParseContext(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (m *MarkupParseContext) Native() unsafe.Pointer {
	return unsafe.Pointer(&m.native)
}

// EndParse signals to the ParseContext that all data has been fed into the
// parse context with g_markup_parse_context_parse().
//
// This function reports an error if the document isn't complete, for example if
// elements are still open.
func (context *MarkupParseContext) EndParse() error {
	var arg0 *C.GMarkupParseContext
	var gError *C.GError

	arg0 = (*C.GMarkupParseContext)(context.Native())

	ret := C.g_markup_parse_context_end_parse(arg0, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// Free frees a ParseContext.
//
// This function can't be called from inside one of the Parser functions or
// while a subparser is pushed.
func (context *MarkupParseContext) Free() {
	var arg0 *C.GMarkupParseContext

	arg0 = (*C.GMarkupParseContext)(context.Native())

	C.g_markup_parse_context_free(arg0)
}

// Element retrieves the name of the currently open element.
//
// If called from the start_element or end_element handlers this will give the
// element_name as passed to those functions. For the parent elements, see
// g_markup_parse_context_get_element_stack().
func (context *MarkupParseContext) Element() string {
	var arg0 *C.GMarkupParseContext

	arg0 = (*C.GMarkupParseContext)(context.Native())

	ret := C.g_markup_parse_context_get_element(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// ElementStack retrieves the element stack from the internal state of the
// parser.
//
// The returned List is a list of strings where the first item is the currently
// open tag (as would be returned by g_markup_parse_context_get_element()) and
// the next item is its immediate parent.
//
// This function is intended to be used in the start_element and end_element
// handlers where g_markup_parse_context_get_element() would merely return the
// name of the element that is being processed.
func (context *MarkupParseContext) ElementStack() *SList {
	var arg0 *C.GMarkupParseContext

	arg0 = (*C.GMarkupParseContext)(context.Native())

	ret := C.g_markup_parse_context_get_element_stack(arg0)

	var ret0 *SList

	{
		ret0 = WrapSList(unsafe.Pointer(ret))
	}

	return ret0
}

// Position retrieves the current line number and the number of the character on
// that line. Intended for use in error messages; there are no strict semantics
// for what constitutes the "current" line number other than "the best number we
// could come up with for error messages."
func (context *MarkupParseContext) Position() (lineNumber int, charNumber int) {
	var arg0 *C.GMarkupParseContext
	var arg1 *C.gint // out
	var arg2 *C.gint // out

	arg0 = (*C.GMarkupParseContext)(context.Native())

	C.g_markup_parse_context_get_position(arg0, &arg1, &arg2)

	var ret0 int
	var ret1 int

	ret0 = int(arg1)

	ret1 = int(arg2)

	return ret0, ret1
}

// UserData returns the user_data associated with @context.
//
// This will either be the user_data that was provided to
// g_markup_parse_context_new() or to the most recent call of
// g_markup_parse_context_push().
func (context *MarkupParseContext) UserData() interface{} {
	var arg0 *C.GMarkupParseContext

	arg0 = (*C.GMarkupParseContext)(context.Native())

	ret := C.g_markup_parse_context_get_user_data(arg0)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// Parse: feed some data to the ParseContext.
//
// The data need not be valid UTF-8; an error will be signaled if it's invalid.
// The data need not be an entire document; you can feed a document into the
// parser incrementally, via multiple calls to this function. Typically, as you
// receive data from a network connection or file, you feed each received chunk
// of data into this function, aborting the process if an error occurs. Once an
// error is reported, no further data may be fed to the ParseContext; all errors
// are fatal.
func (context *MarkupParseContext) Parse(text string, textLen int) error {
	var arg0 *C.GMarkupParseContext
	var arg1 *C.gchar
	var arg2 C.gssize
	var gError *C.GError

	arg0 = (*C.GMarkupParseContext)(context.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(textLen)

	ret := C.g_markup_parse_context_parse(arg0, arg1, arg2, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// Pop completes the process of a temporary sub-parser redirection.
//
// This function exists to collect the user_data allocated by a matching call to
// g_markup_parse_context_push(). It must be called in the end_element handler
// corresponding to the start_element handler during which
// g_markup_parse_context_push() was called. You must not call this function
// from the error callback -- the @user_data is provided directly to the
// callback in that case.
//
// This function is not intended to be directly called by users interested in
// invoking subparsers. Instead, it is intended to be used by the subparsers
// themselves to implement a higher-level interface.
func (context *MarkupParseContext) Pop() interface{} {
	var arg0 *C.GMarkupParseContext

	arg0 = (*C.GMarkupParseContext)(context.Native())

	ret := C.g_markup_parse_context_pop(arg0)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// Ref increases the reference count of @context.
func (context *MarkupParseContext) Ref() *MarkupParseContext {
	var arg0 *C.GMarkupParseContext

	arg0 = (*C.GMarkupParseContext)(context.Native())

	ret := C.g_markup_parse_context_ref(arg0)

	var ret0 *MarkupParseContext

	{
		ret0 = WrapMarkupParseContext(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *MarkupParseContext) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Unref decreases the reference count of @context. When its reference count
// drops to 0, it is freed.
func (context *MarkupParseContext) Unref() {
	var arg0 *C.GMarkupParseContext

	arg0 = (*C.GMarkupParseContext)(context.Native())

	C.g_markup_parse_context_unref(arg0)
}

// MatchInfo: a GMatchInfo is an opaque struct used to return information about
// matches.
type MatchInfo struct {
	native C.GMatchInfo
}

// WrapMatchInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMatchInfo(ptr unsafe.Pointer) *MatchInfo {
	if ptr == nil {
		return nil
	}

	return (*MatchInfo)(ptr)
}

func marshalMatchInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapMatchInfo(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (m *MatchInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&m.native)
}

// ExpandReferences returns a new string containing the text in
// @string_to_expand with references and escape sequences expanded. References
// refer to the last match done with @string against @regex and have the same
// syntax used by g_regex_replace().
//
// The @string_to_expand must be UTF-8 encoded even if REGEX_RAW was passed to
// g_regex_new().
//
// The backreferences are extracted from the string passed to the match
// function, so you cannot call this function after freeing the string.
//
// @match_info may be nil in which case @string_to_expand must not contain
// references. For instance "foo\n" does not refer to an actual pattern and '\n'
// merely will be replaced with \n character, while to expand "\0" (whole match)
// one needs the result of a match. Use g_regex_check_replacement() to find out
// whether @string_to_expand contains references.
func (matchInfo *MatchInfo) ExpandReferences(stringToExpand string) (utf8 string, err error) {
	var arg0 *C.GMatchInfo
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GMatchInfo)(matchInfo.Native())
	arg1 = (*C.gchar)(C.CString(stringToExpand))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_match_info_expand_references(arg0, arg1, &gError)

	var ret0 string
	var goError error

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Fetch retrieves the text matching the @match_num'th capturing parentheses. 0
// is the full text of the match, 1 is the first paren set, 2 the second, and so
// on.
//
// If @match_num is a valid sub pattern but it didn't match anything (e.g. sub
// pattern 1, matching "b" against "(a)?b") then an empty string is returned.
//
// If the match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved string is not
// that of a set of parentheses but that of a matched substring. Substrings are
// matched in reverse order of length, so 0 is the longest match.
//
// The string is fetched from the string passed to the match function, so you
// cannot call this function after freeing the string.
func (matchInfo *MatchInfo) Fetch(matchNum int) string {
	var arg0 *C.GMatchInfo
	var arg1 C.gint

	arg0 = (*C.GMatchInfo)(matchInfo.Native())
	arg1 = C.gint(matchNum)

	ret := C.g_match_info_fetch(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// FetchAll bundles up pointers to each of the matching substrings from a match
// and stores them in an array of gchar pointers. The first element in the
// returned array is the match number 0, i.e. the entire matched text.
//
// If a sub pattern didn't match anything (e.g. sub pattern 1, matching "b"
// against "(a)?b") then an empty string is inserted.
//
// If the last match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved strings are
// not that matched by sets of parentheses but that of the matched substring.
// Substrings are matched in reverse order of length, so the first one is the
// longest match.
//
// The strings are fetched from the string passed to the match function, so you
// cannot call this function after freeing the string.
func (matchInfo *MatchInfo) FetchAll() []string {
	var arg0 *C.GMatchInfo

	arg0 = (*C.GMatchInfo)(matchInfo.Native())

	ret := C.g_match_info_fetch_all(arg0)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// FetchNamed retrieves the text matching the capturing parentheses named @name.
//
// If @name is a valid sub pattern name but it didn't match anything (e.g. sub
// pattern "X", matching "b" against "(?P<X>a)?b") then an empty string is
// returned.
//
// The string is fetched from the string passed to the match function, so you
// cannot call this function after freeing the string.
func (matchInfo *MatchInfo) FetchNamed(name string) string {
	var arg0 *C.GMatchInfo
	var arg1 *C.gchar

	arg0 = (*C.GMatchInfo)(matchInfo.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_match_info_fetch_named(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// FetchNamedPos retrieves the position in bytes of the capturing parentheses
// named @name.
//
// If @name is a valid sub pattern name but it didn't match anything (e.g. sub
// pattern "X", matching "b" against "(?P<X>a)?b") then @start_pos and @end_pos
// are set to -1 and true is returned.
func (matchInfo *MatchInfo) FetchNamedPos(name string) (startPos int, endPos int, ok bool) {
	var arg0 *C.GMatchInfo
	var arg1 *C.gchar
	var arg2 *C.gint // out
	var arg3 *C.gint // out

	arg0 = (*C.GMatchInfo)(matchInfo.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_match_info_fetch_named_pos(arg0, arg1, &arg2, &arg3)

	var ret0 int
	var ret1 int
	var ret2 bool

	ret0 = int(arg2)

	ret1 = int(arg3)

	ret2 = C.BOOL(ret) != 0

	return ret0, ret1, ret2
}

// FetchPos retrieves the position in bytes of the @match_num'th capturing
// parentheses. 0 is the full text of the match, 1 is the first paren set, 2 the
// second, and so on.
//
// If @match_num is a valid sub pattern but it didn't match anything (e.g. sub
// pattern 1, matching "b" against "(a)?b") then @start_pos and @end_pos are set
// to -1 and true is returned.
//
// If the match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved position is
// not that of a set of parentheses but that of a matched substring. Substrings
// are matched in reverse order of length, so 0 is the longest match.
func (matchInfo *MatchInfo) FetchPos(matchNum int) (startPos int, endPos int, ok bool) {
	var arg0 *C.GMatchInfo
	var arg1 C.gint
	var arg2 *C.gint // out
	var arg3 *C.gint // out

	arg0 = (*C.GMatchInfo)(matchInfo.Native())
	arg1 = C.gint(matchNum)

	ret := C.g_match_info_fetch_pos(arg0, arg1, &arg2, &arg3)

	var ret0 int
	var ret1 int
	var ret2 bool

	ret0 = int(arg2)

	ret1 = int(arg3)

	ret2 = C.BOOL(ret) != 0

	return ret0, ret1, ret2
}

// Free: if @match_info is not nil, calls g_match_info_unref(); otherwise does
// nothing.
func (matchInfo *MatchInfo) Free() {
	var arg0 *C.GMatchInfo

	arg0 = (*C.GMatchInfo)(matchInfo.Native())

	C.g_match_info_free(arg0)
}

// MatchCount retrieves the number of matched substrings (including substring 0,
// that is the whole matched text), so 1 is returned if the pattern has no
// substrings in it and 0 is returned if the match failed.
//
// If the last match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved count is not
// that of the number of capturing parentheses but that of the number of matched
// substrings.
func (matchInfo *MatchInfo) MatchCount() int {
	var arg0 *C.GMatchInfo

	arg0 = (*C.GMatchInfo)(matchInfo.Native())

	ret := C.g_match_info_get_match_count(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Regex returns #GRegex object used in @match_info. It belongs to Glib and must
// not be freed. Use g_regex_ref() if you need to keep it after you free
// @match_info object.
func (matchInfo *MatchInfo) Regex() *Regex {
	var arg0 *C.GMatchInfo

	arg0 = (*C.GMatchInfo)(matchInfo.Native())

	ret := C.g_match_info_get_regex(arg0)

	var ret0 *Regex

	{
		ret0 = WrapRegex(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Regex) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// String returns the string searched with @match_info. This is the string
// passed to g_regex_match() or g_regex_replace() so you may not free it before
// calling this function.
func (matchInfo *MatchInfo) String() string {
	var arg0 *C.GMatchInfo

	arg0 = (*C.GMatchInfo)(matchInfo.Native())

	ret := C.g_match_info_get_string(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// IsPartialMatch: usually if the string passed to g_regex_match*() matches as
// far as it goes, but is too short to match the entire pattern, false is
// returned. There are circumstances where it might be helpful to distinguish
// this case from other cases in which there is no match.
//
// Consider, for example, an application where a human is required to type in
// data for a field with specific formatting requirements. An example might be a
// date in the form ddmmmyy, defined by the pattern
// "^\d?\d(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\d\d$". If the
// application sees the user’s keystrokes one by one, and can check that what
// has been typed so far is potentially valid, it is able to raise an error as
// soon as a mistake is made.
//
// GRegex supports the concept of partial matching by means of the
// REGEX_MATCH_PARTIAL_SOFT and REGEX_MATCH_PARTIAL_HARD flags. When they are
// used, the return code for g_regex_match() or g_regex_match_full() is, as
// usual, true for a complete match, false otherwise. But, when these functions
// return false, you can check if the match was partial calling
// g_match_info_is_partial_match().
//
// The difference between REGEX_MATCH_PARTIAL_SOFT and REGEX_MATCH_PARTIAL_HARD
// is that when a partial match is encountered with REGEX_MATCH_PARTIAL_SOFT,
// matching continues to search for a possible complete match, while with
// REGEX_MATCH_PARTIAL_HARD matching stops at the partial match. When both
// REGEX_MATCH_PARTIAL_SOFT and REGEX_MATCH_PARTIAL_HARD are set, the latter
// takes precedence.
//
// There were formerly some restrictions on the pattern for partial matching.
// The restrictions no longer apply.
//
// See pcrepartial(3) for more information on partial matching.
func (matchInfo *MatchInfo) IsPartialMatch() bool {
	var arg0 *C.GMatchInfo

	arg0 = (*C.GMatchInfo)(matchInfo.Native())

	ret := C.g_match_info_is_partial_match(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Matches returns whether the previous match operation succeeded.
func (matchInfo *MatchInfo) Matches() bool {
	var arg0 *C.GMatchInfo

	arg0 = (*C.GMatchInfo)(matchInfo.Native())

	ret := C.g_match_info_matches(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Next scans for the next match using the same parameters of the previous call
// to g_regex_match_full() or g_regex_match() that returned @match_info.
//
// The match is done on the string passed to the match function, so you cannot
// free it before calling this function.
func (matchInfo *MatchInfo) Next() error {
	var arg0 *C.GMatchInfo
	var gError *C.GError

	arg0 = (*C.GMatchInfo)(matchInfo.Native())

	ret := C.g_match_info_next(arg0, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// Ref increases reference count of @match_info by 1.
func (matchInfo *MatchInfo) Ref() *MatchInfo {
	var arg0 *C.GMatchInfo

	arg0 = (*C.GMatchInfo)(matchInfo.Native())

	ret := C.g_match_info_ref(arg0)

	var ret0 *MatchInfo

	{
		ret0 = WrapMatchInfo(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *MatchInfo) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Unref decreases reference count of @match_info by 1. When reference count
// drops to zero, it frees all the memory associated with the match_info
// structure.
func (matchInfo *MatchInfo) Unref() {
	var arg0 *C.GMatchInfo

	arg0 = (*C.GMatchInfo)(matchInfo.Native())

	C.g_match_info_unref(arg0)
}

// Node: the #GNode struct represents one node in a [n-ary
// tree][glib-N-ary-Trees].
type Node struct {
	native C.GNode
}

// WrapNode wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapNode(ptr unsafe.Pointer) *Node {
	if ptr == nil {
		return nil
	}

	return (*Node)(ptr)
}

func marshalNode(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapNode(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (n *Node) Native() unsafe.Pointer {
	return unsafe.Pointer(&n.native)
}

// Data gets the field inside the struct.
func (n *Node) Data() interface{} {
	var ret interface{}
	ret = box.Get(uintptr(n.native.data))
	return ret
}

// Next gets the field inside the struct.
func (n *Node) Next() *Node {
	var ret *Node
	{
		ret = WrapNode(unsafe.Pointer(n.native.next))
	}
	return ret
}

// Prev gets the field inside the struct.
func (n *Node) Prev() *Node {
	var ret *Node
	{
		ret = WrapNode(unsafe.Pointer(n.native.prev))
	}
	return ret
}

// Parent gets the field inside the struct.
func (n *Node) Parent() *Node {
	var ret *Node
	{
		ret = WrapNode(unsafe.Pointer(n.native.parent))
	}
	return ret
}

// Children gets the field inside the struct.
func (n *Node) Children() *Node {
	var ret *Node
	{
		ret = WrapNode(unsafe.Pointer(n.native.children))
	}
	return ret
}

// ChildIndex gets the position of the first child of a #GNode which contains
// the given data.
func (node *Node) ChildIndex(data interface{}) int {
	var arg0 *C.GNode
	var arg1 C.gpointer

	arg0 = (*C.GNode)(node.Native())
	arg1 = C.gpointer(box.Assign(data))

	ret := C.g_node_child_index(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ChildPosition gets the position of a #GNode with respect to its siblings.
// @child must be a child of @node. The first child is numbered 0, the second 1,
// and so on.
func (node *Node) ChildPosition(child *Node) int {
	var arg0 *C.GNode
	var arg1 *C.GNode

	arg0 = (*C.GNode)(node.Native())
	arg1 = (*C.GNode)(child.Native())

	ret := C.g_node_child_position(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ChildrenForeach calls a function for each of the children of a #GNode. Note
// that it doesn't descend beneath the child nodes. @func must not do anything
// that would modify the structure of the tree.
func (node *Node) ChildrenForeach(flags TraverseFlags, fn NodeForeachFunc) {
	var arg0 *C.GNode
	var arg1 C.GTraverseFlags
	var arg2 C.GNodeForeachFunc
	var arg3 C.gpointer

	arg0 = (*C.GNode)(node.Native())
	arg1 = (C.GTraverseFlags)(flags)
	arg2 = (*[0]byte)(C.gotk4_NodeForeachFunc)
	arg3 = C.gpointer(box.Assign(fn))

	C.g_node_children_foreach(arg0, arg1, arg2, arg3)
}

// Copy: recursively copies a #GNode (but does not deep-copy the data inside the
// nodes, see g_node_copy_deep() if you need that).
func (node *Node) Copy() *Node {
	var arg0 *C.GNode

	arg0 = (*C.GNode)(node.Native())

	ret := C.g_node_copy(arg0)

	var ret0 *Node

	{
		ret0 = WrapNode(unsafe.Pointer(ret))
	}

	return ret0
}

// CopyDeep: recursively copies a #GNode and its data.
func (node *Node) CopyDeep(copyFunc CopyFunc) *Node {
	var arg0 *C.GNode
	var arg1 C.GCopyFunc
	var arg2 C.gpointer

	arg0 = (*C.GNode)(node.Native())
	arg1 = (*[0]byte)(C.gotk4_CopyFunc)
	arg2 = C.gpointer(box.Assign(copyFunc))

	ret := C.g_node_copy_deep(arg0, arg1, arg2)

	var ret0 *Node

	{
		ret0 = WrapNode(unsafe.Pointer(ret))
	}

	return ret0
}

// Depth gets the depth of a #GNode.
//
// If @node is nil the depth is 0. The root node has a depth of 1. For the
// children of the root node the depth is 2. And so on.
func (node *Node) Depth() uint {
	var arg0 *C.GNode

	arg0 = (*C.GNode)(node.Native())

	ret := C.g_node_depth(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Destroy removes @root and its children from the tree, freeing any memory
// allocated.
func (root *Node) Destroy() {
	var arg0 *C.GNode

	arg0 = (*C.GNode)(root.Native())

	C.g_node_destroy(arg0)
}

// Find finds a #GNode in a tree.
func (root *Node) Find(order TraverseType, flags TraverseFlags, data interface{}) *Node {
	var arg0 *C.GNode
	var arg1 C.GTraverseType
	var arg2 C.GTraverseFlags
	var arg3 C.gpointer

	arg0 = (*C.GNode)(root.Native())
	arg1 = (C.GTraverseType)(order)
	arg2 = (C.GTraverseFlags)(flags)
	arg3 = C.gpointer(box.Assign(data))

	ret := C.g_node_find(arg0, arg1, arg2, arg3)

	var ret0 *Node

	{
		ret0 = WrapNode(unsafe.Pointer(ret))
	}

	return ret0
}

// FindChild finds the first child of a #GNode with the given data.
func (node *Node) FindChild(flags TraverseFlags, data interface{}) *Node {
	var arg0 *C.GNode
	var arg1 C.GTraverseFlags
	var arg2 C.gpointer

	arg0 = (*C.GNode)(node.Native())
	arg1 = (C.GTraverseFlags)(flags)
	arg2 = C.gpointer(box.Assign(data))

	ret := C.g_node_find_child(arg0, arg1, arg2)

	var ret0 *Node

	{
		ret0 = WrapNode(unsafe.Pointer(ret))
	}

	return ret0
}

// FirstSibling gets the first sibling of a #GNode. This could possibly be the
// node itself.
func (node *Node) FirstSibling() *Node {
	var arg0 *C.GNode

	arg0 = (*C.GNode)(node.Native())

	ret := C.g_node_first_sibling(arg0)

	var ret0 *Node

	{
		ret0 = WrapNode(unsafe.Pointer(ret))
	}

	return ret0
}

// Root gets the root of a tree.
func (node *Node) Root() *Node {
	var arg0 *C.GNode

	arg0 = (*C.GNode)(node.Native())

	ret := C.g_node_get_root(arg0)

	var ret0 *Node

	{
		ret0 = WrapNode(unsafe.Pointer(ret))
	}

	return ret0
}

// Insert inserts a #GNode beneath the parent at the given position.
func (parent *Node) Insert(position int, node *Node) *Node {
	var arg0 *C.GNode
	var arg1 C.gint
	var arg2 *C.GNode

	arg0 = (*C.GNode)(parent.Native())
	arg1 = C.gint(position)
	arg2 = (*C.GNode)(node.Native())

	ret := C.g_node_insert(arg0, arg1, arg2)

	var ret0 *Node

	{
		ret0 = WrapNode(unsafe.Pointer(ret))
	}

	return ret0
}

// InsertAfter inserts a #GNode beneath the parent after the given sibling.
func (parent *Node) InsertAfter(sibling *Node, node *Node) *Node {
	var arg0 *C.GNode
	var arg1 *C.GNode
	var arg2 *C.GNode

	arg0 = (*C.GNode)(parent.Native())
	arg1 = (*C.GNode)(sibling.Native())
	arg2 = (*C.GNode)(node.Native())

	ret := C.g_node_insert_after(arg0, arg1, arg2)

	var ret0 *Node

	{
		ret0 = WrapNode(unsafe.Pointer(ret))
	}

	return ret0
}

// InsertBefore inserts a #GNode beneath the parent before the given sibling.
func (parent *Node) InsertBefore(sibling *Node, node *Node) *Node {
	var arg0 *C.GNode
	var arg1 *C.GNode
	var arg2 *C.GNode

	arg0 = (*C.GNode)(parent.Native())
	arg1 = (*C.GNode)(sibling.Native())
	arg2 = (*C.GNode)(node.Native())

	ret := C.g_node_insert_before(arg0, arg1, arg2)

	var ret0 *Node

	{
		ret0 = WrapNode(unsafe.Pointer(ret))
	}

	return ret0
}

// IsAncestor returns true if @node is an ancestor of @descendant. This is true
// if node is the parent of @descendant, or if node is the grandparent of
// @descendant etc.
func (node *Node) IsAncestor(descendant *Node) bool {
	var arg0 *C.GNode
	var arg1 *C.GNode

	arg0 = (*C.GNode)(node.Native())
	arg1 = (*C.GNode)(descendant.Native())

	ret := C.g_node_is_ancestor(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// LastChild gets the last child of a #GNode.
func (node *Node) LastChild() *Node {
	var arg0 *C.GNode

	arg0 = (*C.GNode)(node.Native())

	ret := C.g_node_last_child(arg0)

	var ret0 *Node

	{
		ret0 = WrapNode(unsafe.Pointer(ret))
	}

	return ret0
}

// LastSibling gets the last sibling of a #GNode. This could possibly be the
// node itself.
func (node *Node) LastSibling() *Node {
	var arg0 *C.GNode

	arg0 = (*C.GNode)(node.Native())

	ret := C.g_node_last_sibling(arg0)

	var ret0 *Node

	{
		ret0 = WrapNode(unsafe.Pointer(ret))
	}

	return ret0
}

// MaxHeight gets the maximum height of all branches beneath a #GNode. This is
// the maximum distance from the #GNode to all leaf nodes.
//
// If @root is nil, 0 is returned. If @root has no children, 1 is returned. If
// @root has children, 2 is returned. And so on.
func (root *Node) MaxHeight() uint {
	var arg0 *C.GNode

	arg0 = (*C.GNode)(root.Native())

	ret := C.g_node_max_height(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// NChildren gets the number of children of a #GNode.
func (node *Node) NChildren() uint {
	var arg0 *C.GNode

	arg0 = (*C.GNode)(node.Native())

	ret := C.g_node_n_children(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// NNodes gets the number of nodes in a tree.
func (root *Node) NNodes(flags TraverseFlags) uint {
	var arg0 *C.GNode
	var arg1 C.GTraverseFlags

	arg0 = (*C.GNode)(root.Native())
	arg1 = (C.GTraverseFlags)(flags)

	ret := C.g_node_n_nodes(arg0, arg1)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// NthChild gets a child of a #GNode, using the given index. The first child is
// at index 0. If the index is too big, nil is returned.
func (node *Node) NthChild(n uint) *Node {
	var arg0 *C.GNode
	var arg1 C.guint

	arg0 = (*C.GNode)(node.Native())
	arg1 = C.guint(n)

	ret := C.g_node_nth_child(arg0, arg1)

	var ret0 *Node

	{
		ret0 = WrapNode(unsafe.Pointer(ret))
	}

	return ret0
}

// Prepend inserts a #GNode as the first child of the given parent.
func (parent *Node) Prepend(node *Node) *Node {
	var arg0 *C.GNode
	var arg1 *C.GNode

	arg0 = (*C.GNode)(parent.Native())
	arg1 = (*C.GNode)(node.Native())

	ret := C.g_node_prepend(arg0, arg1)

	var ret0 *Node

	{
		ret0 = WrapNode(unsafe.Pointer(ret))
	}

	return ret0
}

// ReverseChildren reverses the order of the children of a #GNode. (It doesn't
// change the order of the grandchildren.)
func (node *Node) ReverseChildren() {
	var arg0 *C.GNode

	arg0 = (*C.GNode)(node.Native())

	C.g_node_reverse_children(arg0)
}

// Traverse traverses a tree starting at the given root #GNode. It calls the
// given function for each node visited. The traversal can be halted at any
// point by returning true from @func. @func must not do anything that would
// modify the structure of the tree.
func (root *Node) Traverse(order TraverseType, flags TraverseFlags, maxDepth int, fn NodeTraverseFunc) {
	var arg0 *C.GNode
	var arg1 C.GTraverseType
	var arg2 C.GTraverseFlags
	var arg3 C.gint
	var arg4 C.GNodeTraverseFunc
	var arg5 C.gpointer

	arg0 = (*C.GNode)(root.Native())
	arg1 = (C.GTraverseType)(order)
	arg2 = (C.GTraverseFlags)(flags)
	arg3 = C.gint(maxDepth)
	arg4 = (*[0]byte)(C.gotk4_NodeTraverseFunc)
	arg5 = C.gpointer(box.Assign(fn))

	C.g_node_traverse(arg0, arg1, arg2, arg3, arg4, arg5)
}

// Unlink unlinks a #GNode from a tree, resulting in two separate trees.
func (node *Node) Unlink() {
	var arg0 *C.GNode

	arg0 = (*C.GNode)(node.Native())

	C.g_node_unlink(arg0)
}

// Once: a #GOnce struct controls a one-time initialization function. Any
// one-time initialization function must have its own unique #GOnce struct.
type Once struct {
	native C.GOnce
}

// WrapOnce wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapOnce(ptr unsafe.Pointer) *Once {
	if ptr == nil {
		return nil
	}

	return (*Once)(ptr)
}

func marshalOnce(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapOnce(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (o *Once) Native() unsafe.Pointer {
	return unsafe.Pointer(&o.native)
}

// Status gets the field inside the struct.
func (o *Once) Status() OnceStatus {
	var ret OnceStatus
	ret = OnceStatus(o.native.status)
	return ret
}

// Retval gets the field inside the struct.
func (o *Once) Retval() interface{} {
	var ret interface{}
	ret = box.Get(uintptr(o.native.retval))
	return ret
}

// OptionContext: a `GOptionContext` struct defines which options are accepted
// by the commandline option parser. The struct has only private fields and
// should not be directly accessed.
type OptionContext struct {
	native C.GOptionContext
}

// WrapOptionContext wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapOptionContext(ptr unsafe.Pointer) *OptionContext {
	if ptr == nil {
		return nil
	}

	return (*OptionContext)(ptr)
}

func marshalOptionContext(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapOptionContext(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (o *OptionContext) Native() unsafe.Pointer {
	return unsafe.Pointer(&o.native)
}

// AddGroup adds a Group to the @context, so that parsing with @context will
// recognize the options in the group. Note that this will take ownership of the
// @group and thus the @group should not be freed.
func (context *OptionContext) AddGroup(group *OptionGroup) {
	var arg0 *C.GOptionContext
	var arg1 *C.GOptionGroup

	arg0 = (*C.GOptionContext)(context.Native())
	arg1 = (*C.GOptionGroup)(group.Native())

	C.g_option_context_add_group(arg0, arg1)
}

// AddMainEntries: a convenience function which creates a main group if it
// doesn't exist, adds the @entries to it and sets the translation domain.
func (context *OptionContext) AddMainEntries(entries []OptionEntry, translationDomain string) {
	var arg0 *C.GOptionContext
	var arg1 *C.GOptionEntry
	var arg2 *C.gchar

	arg0 = (*C.GOptionContext)(context.Native())
	{
		var dst []C.GOptionEntry
		ptr := C.malloc(C.sizeof_GOptionEntry * (len(entries) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(entries)
		sliceHeader.Cap = len(entries)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(entries); i++ {
			src := entries[i]
			dst[i] = (C.GOptionEntry)(src.Native())
		}

		arg1 = (*C.GOptionEntry)(unsafe.Pointer(ptr))
	}
	arg2 = (*C.gchar)(C.CString(translationDomain))
	defer C.free(unsafe.Pointer(arg2))

	C.g_option_context_add_main_entries(arg0, arg1, arg2)
}

// Free frees context and all the groups which have been added to it.
//
// Please note that parsed arguments need to be freed separately (see Entry).
func (context *OptionContext) Free() {
	var arg0 *C.GOptionContext

	arg0 = (*C.GOptionContext)(context.Native())

	C.g_option_context_free(arg0)
}

// Description returns the description. See g_option_context_set_description().
func (context *OptionContext) Description() string {
	var arg0 *C.GOptionContext

	arg0 = (*C.GOptionContext)(context.Native())

	ret := C.g_option_context_get_description(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Help returns a formatted, translated help text for the given context. To
// obtain the text produced by `--help`, call `g_option_context_get_help
// (context, TRUE, NULL)`. To obtain the text produced by `--help-all`, call
// `g_option_context_get_help (context, FALSE, NULL)`. To obtain the help text
// for an option group, call `g_option_context_get_help (context, FALSE,
// group)`.
func (context *OptionContext) Help(mainHelp bool, group *OptionGroup) string {
	var arg0 *C.GOptionContext
	var arg1 C.gboolean
	var arg2 *C.GOptionGroup

	arg0 = (*C.GOptionContext)(context.Native())
	if mainHelp {
		arg1 = C.TRUE
	}
	arg2 = (*C.GOptionGroup)(group.Native())

	ret := C.g_option_context_get_help(arg0, arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// HelpEnabled returns whether automatic `--help` generation is turned on for
// @context. See g_option_context_set_help_enabled().
func (context *OptionContext) HelpEnabled() bool {
	var arg0 *C.GOptionContext

	arg0 = (*C.GOptionContext)(context.Native())

	ret := C.g_option_context_get_help_enabled(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IgnoreUnknownOptions returns whether unknown options are ignored or not. See
// g_option_context_set_ignore_unknown_options().
func (context *OptionContext) IgnoreUnknownOptions() bool {
	var arg0 *C.GOptionContext

	arg0 = (*C.GOptionContext)(context.Native())

	ret := C.g_option_context_get_ignore_unknown_options(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// MainGroup returns a pointer to the main group of @context.
func (context *OptionContext) MainGroup() *OptionGroup {
	var arg0 *C.GOptionContext

	arg0 = (*C.GOptionContext)(context.Native())

	ret := C.g_option_context_get_main_group(arg0)

	var ret0 *OptionGroup

	{
		ret0 = WrapOptionGroup(unsafe.Pointer(ret))
	}

	return ret0
}

// StrictPosix returns whether strict POSIX code is enabled.
//
// See g_option_context_set_strict_posix() for more information.
func (context *OptionContext) StrictPosix() bool {
	var arg0 *C.GOptionContext

	arg0 = (*C.GOptionContext)(context.Native())

	ret := C.g_option_context_get_strict_posix(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Summary returns the summary. See g_option_context_set_summary().
func (context *OptionContext) Summary() string {
	var arg0 *C.GOptionContext

	arg0 = (*C.GOptionContext)(context.Native())

	ret := C.g_option_context_get_summary(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Parse parses the command line arguments, recognizing options which have been
// added to @context. A side-effect of calling this function is that
// g_set_prgname() will be called.
//
// If the parsing is successful, any parsed arguments are removed from the array
// and @argc and @argv are updated accordingly. A '--' option is stripped from
// @argv unless there are unparsed options before and after it, or some of the
// options after it start with '-'. In case of an error, @argc and @argv are
// left unmodified.
//
// If automatic `--help` support is enabled (see
// g_option_context_set_help_enabled()), and the @argv array contains one of the
// recognized help options, this function will produce help output to stdout and
// call `exit (0)`.
//
// Note that function depends on the [current locale][setlocale] for automatic
// character set conversion of string and filename arguments.
func (context *OptionContext) Parse(argc int, argv []string) error {
	var arg0 *C.GOptionContext
	var arg1 *C.gint
	var arg2 ***C.gchar
	var gError *C.GError

	arg0 = (*C.GOptionContext)(context.Native())
	{
		var dst []**C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * len(argv))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(argv)
		sliceHeader.Cap = len(argv)

		for i := 0; i < len(argv); i++ {
			src := argv[i]
			dst[i] = (*C.gchar)(C.CString(src))
		}

		arg2 = (***C.gchar)(unsafe.Pointer(ptr))
		arg1 = len(argv)
	}

	ret := C.g_option_context_parse(arg0, arg1, arg2, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SetDescription adds a string to be displayed in `--help` output after the
// list of options. This text often includes a bug reporting address.
//
// Note that the summary is translated (see
// g_option_context_set_translate_func()).
func (context *OptionContext) SetDescription(description string) {
	var arg0 *C.GOptionContext
	var arg1 *C.gchar

	arg0 = (*C.GOptionContext)(context.Native())
	arg1 = (*C.gchar)(C.CString(description))
	defer C.free(unsafe.Pointer(arg1))

	C.g_option_context_set_description(arg0, arg1)
}

// SetHelpEnabled enables or disables automatic generation of `--help` output.
// By default, g_option_context_parse() recognizes `--help`, `-h`, `-?`,
// `--help-all` and `--help-groupname` and creates suitable output to stdout.
func (context *OptionContext) SetHelpEnabled(helpEnabled bool) {
	var arg0 *C.GOptionContext
	var arg1 C.gboolean

	arg0 = (*C.GOptionContext)(context.Native())
	if helpEnabled {
		arg1 = C.TRUE
	}

	C.g_option_context_set_help_enabled(arg0, arg1)
}

// SetIgnoreUnknownOptions sets whether to ignore unknown options or not. If an
// argument is ignored, it is left in the @argv array after parsing. By default,
// g_option_context_parse() treats unknown options as error.
//
// This setting does not affect non-option arguments (i.e. arguments which don't
// start with a dash). But note that GOption cannot reliably determine whether a
// non-option belongs to a preceding unknown option.
func (context *OptionContext) SetIgnoreUnknownOptions(ignoreUnknown bool) {
	var arg0 *C.GOptionContext
	var arg1 C.gboolean

	arg0 = (*C.GOptionContext)(context.Native())
	if ignoreUnknown {
		arg1 = C.TRUE
	}

	C.g_option_context_set_ignore_unknown_options(arg0, arg1)
}

// SetMainGroup sets a Group as main group of the @context. This has the same
// effect as calling g_option_context_add_group(), the only difference is that
// the options in the main group are treated differently when generating
// `--help` output.
func (context *OptionContext) SetMainGroup(group *OptionGroup) {
	var arg0 *C.GOptionContext
	var arg1 *C.GOptionGroup

	arg0 = (*C.GOptionContext)(context.Native())
	arg1 = (*C.GOptionGroup)(group.Native())

	C.g_option_context_set_main_group(arg0, arg1)
}

// SetStrictPosix sets strict POSIX mode.
//
// By default, this mode is disabled.
//
// In strict POSIX mode, the first non-argument parameter encountered (eg:
// filename) terminates argument processing. Remaining arguments are treated as
// non-options and are not attempted to be parsed.
//
// If strict POSIX mode is disabled then parsing is done in the GNU way where
// option arguments can be freely mixed with non-options.
//
// As an example, consider "ls foo -l". With GNU style parsing, this will list
// "foo" in long mode. In strict POSIX style, this will list the files named
// "foo" and "-l".
//
// It may be useful to force strict POSIX mode when creating "verb style"
// command line tools. For example, the "gsettings" command line tool supports
// the global option "--schemadir" as well as many subcommands ("get", "set",
// etc.) which each have their own set of arguments. Using strict POSIX mode
// will allow parsing the global options up to the verb name while leaving the
// remaining options to be parsed by the relevant subcommand (which can be
// determined by examining the verb name, which should be present in argv[1]
// after parsing).
func (context *OptionContext) SetStrictPosix(strictPosix bool) {
	var arg0 *C.GOptionContext
	var arg1 C.gboolean

	arg0 = (*C.GOptionContext)(context.Native())
	if strictPosix {
		arg1 = C.TRUE
	}

	C.g_option_context_set_strict_posix(arg0, arg1)
}

// SetSummary adds a string to be displayed in `--help` output before the list
// of options. This is typically a summary of the program functionality.
//
// Note that the summary is translated (see
// g_option_context_set_translate_func() and
// g_option_context_set_translation_domain()).
func (context *OptionContext) SetSummary(summary string) {
	var arg0 *C.GOptionContext
	var arg1 *C.gchar

	arg0 = (*C.GOptionContext)(context.Native())
	arg1 = (*C.gchar)(C.CString(summary))
	defer C.free(unsafe.Pointer(arg1))

	C.g_option_context_set_summary(arg0, arg1)
}

// SetTranslateFunc sets the function which is used to translate the contexts
// user-visible strings, for `--help` output. If @func is nil, strings are not
// translated.
//
// Note that option groups have their own translation functions, this function
// only affects the @parameter_string (see g_option_context_new()), the summary
// (see g_option_context_set_summary()) and the description (see
// g_option_context_set_description()).
//
// If you are using gettext(), you only need to set the translation domain, see
// g_option_context_set_translation_domain().
func (context *OptionContext) SetTranslateFunc(fn TranslateFunc) {
	var arg0 *C.GOptionContext
	var arg1 C.GTranslateFunc
	var arg2 C.gpointer
	var arg3 C.GDestroyNotify

	arg0 = (*C.GOptionContext)(context.Native())
	arg1 = (*[0]byte)(C.gotk4_TranslateFunc)
	arg2 = C.gpointer(box.Assign(fn))
	arg3 = (*[0]byte)(C.callbackDelete)

	C.g_option_context_set_translate_func(arg0, arg1, arg2, arg3)
}

// SetTranslationDomain: a convenience function to use gettext() for translating
// user-visible strings.
func (context *OptionContext) SetTranslationDomain(domain string) {
	var arg0 *C.GOptionContext
	var arg1 *C.gchar

	arg0 = (*C.GOptionContext)(context.Native())
	arg1 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(arg1))

	C.g_option_context_set_translation_domain(arg0, arg1)
}

// OptionEntry: a GOptionEntry struct defines a single option. To have an
// effect, they must be added to a Group with
// g_option_context_add_main_entries() or g_option_group_add_entries().
type OptionEntry struct {
	native C.GOptionEntry
}

// WrapOptionEntry wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapOptionEntry(ptr unsafe.Pointer) *OptionEntry {
	if ptr == nil {
		return nil
	}

	return (*OptionEntry)(ptr)
}

func marshalOptionEntry(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapOptionEntry(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (o *OptionEntry) Native() unsafe.Pointer {
	return unsafe.Pointer(&o.native)
}

// LongName gets the field inside the struct.
func (o *OptionEntry) LongName() string {
	var ret string
	ret = C.GoString(o.native.long_name)
	return ret
}

// ShortName gets the field inside the struct.
func (o *OptionEntry) ShortName() byte {
	var ret byte
	ret = byte(o.native.short_name)
	return ret
}

// Flags gets the field inside the struct.
func (o *OptionEntry) Flags() int {
	var ret int
	ret = int(o.native.flags)
	return ret
}

// Arg gets the field inside the struct.
func (o *OptionEntry) Arg() OptionArg {
	var ret OptionArg
	ret = OptionArg(o.native.arg)
	return ret
}

// ArgData gets the field inside the struct.
func (o *OptionEntry) ArgData() interface{} {
	var ret interface{}
	ret = box.Get(uintptr(o.native.arg_data))
	return ret
}

// Description gets the field inside the struct.
func (o *OptionEntry) Description() string {
	var ret string
	ret = C.GoString(o.native.description)
	return ret
}

// ArgDescription gets the field inside the struct.
func (o *OptionEntry) ArgDescription() string {
	var ret string
	ret = C.GoString(o.native.arg_description)
	return ret
}

// OptionGroup: a `GOptionGroup` struct defines the options in a single group.
// The struct has only private fields and should not be directly accessed.
//
// All options in a group share the same translation function. Libraries which
// need to parse commandline options are expected to provide a function for
// getting a `GOptionGroup` holding their options, which the application can
// then add to its Context.
type OptionGroup struct {
	native C.GOptionGroup
}

// WrapOptionGroup wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapOptionGroup(ptr unsafe.Pointer) *OptionGroup {
	if ptr == nil {
		return nil
	}

	return (*OptionGroup)(ptr)
}

func marshalOptionGroup(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapOptionGroup(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (o *OptionGroup) Native() unsafe.Pointer {
	return unsafe.Pointer(&o.native)
}

// NewOptionGroup constructs a struct OptionGroup.
func NewOptionGroup(name string, description string, helpDescription string, userData interface{}) *OptionGroup {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 C.gpointer
	var arg5 C.GDestroyNotify

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(description))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(helpDescription))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = C.gpointer(box.Assign(userData))

	ret := C.g_option_group_new(arg1, arg2, arg3, arg4, arg5)

	var ret0 *OptionGroup

	{
		ret0 = WrapOptionGroup(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *OptionGroup) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// AddEntries adds the options specified in @entries to @group.
func (group *OptionGroup) AddEntries(entries []OptionEntry) {
	var arg0 *C.GOptionGroup
	var arg1 *C.GOptionEntry

	arg0 = (*C.GOptionGroup)(group.Native())
	{
		var dst []C.GOptionEntry
		ptr := C.malloc(C.sizeof_GOptionEntry * (len(entries) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(entries)
		sliceHeader.Cap = len(entries)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(entries); i++ {
			src := entries[i]
			dst[i] = (C.GOptionEntry)(src.Native())
		}

		arg1 = (*C.GOptionEntry)(unsafe.Pointer(ptr))
	}

	C.g_option_group_add_entries(arg0, arg1)
}

// Free frees a Group. Note that you must not free groups which have been added
// to a Context.
func (group *OptionGroup) Free() {
	var arg0 *C.GOptionGroup

	arg0 = (*C.GOptionGroup)(group.Native())

	C.g_option_group_free(arg0)
}

// Ref increments the reference count of @group by one.
func (group *OptionGroup) Ref() *OptionGroup {
	var arg0 *C.GOptionGroup

	arg0 = (*C.GOptionGroup)(group.Native())

	ret := C.g_option_group_ref(arg0)

	var ret0 *OptionGroup

	{
		ret0 = WrapOptionGroup(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *OptionGroup) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// SetParseHooks associates two functions with @group which will be called from
// g_option_context_parse() before the first option is parsed and after the last
// option has been parsed, respectively.
//
// Note that the user data to be passed to @pre_parse_func and @post_parse_func
// can be specified when constructing the group with g_option_group_new().
func (group *OptionGroup) SetParseHooks(preParseFunc OptionParseFunc, postParseFunc OptionParseFunc) {
	var arg0 *C.GOptionGroup
	var arg1 C.GOptionParseFunc
	var arg2 C.GOptionParseFunc

	arg0 = (*C.GOptionGroup)(group.Native())

	C.g_option_group_set_parse_hooks(arg0, arg1, arg2)
}

// SetTranslateFunc sets the function which is used to translate user-visible
// strings, for `--help` output. Different groups can use different Funcs. If
// @func is nil, strings are not translated.
//
// If you are using gettext(), you only need to set the translation domain, see
// g_option_group_set_translation_domain().
func (group *OptionGroup) SetTranslateFunc(fn TranslateFunc) {
	var arg0 *C.GOptionGroup
	var arg1 C.GTranslateFunc
	var arg2 C.gpointer
	var arg3 C.GDestroyNotify

	arg0 = (*C.GOptionGroup)(group.Native())
	arg1 = (*[0]byte)(C.gotk4_TranslateFunc)
	arg2 = C.gpointer(box.Assign(fn))
	arg3 = (*[0]byte)(C.callbackDelete)

	C.g_option_group_set_translate_func(arg0, arg1, arg2, arg3)
}

// SetTranslationDomain: a convenience function to use gettext() for translating
// user-visible strings.
func (group *OptionGroup) SetTranslationDomain(domain string) {
	var arg0 *C.GOptionGroup
	var arg1 *C.gchar

	arg0 = (*C.GOptionGroup)(group.Native())
	arg1 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(arg1))

	C.g_option_group_set_translation_domain(arg0, arg1)
}

// Unref decrements the reference count of @group by one. If the reference count
// drops to 0, the @group will be freed. and all memory allocated by the @group
// is released.
func (group *OptionGroup) Unref() {
	var arg0 *C.GOptionGroup

	arg0 = (*C.GOptionGroup)(group.Native())

	C.g_option_group_unref(arg0)
}

// PatternSpec: a GPatternSpec struct is the 'compiled' form of a pattern. This
// structure is opaque and its fields cannot be accessed directly.
type PatternSpec struct {
	native C.GPatternSpec
}

// WrapPatternSpec wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPatternSpec(ptr unsafe.Pointer) *PatternSpec {
	if ptr == nil {
		return nil
	}

	return (*PatternSpec)(ptr)
}

func marshalPatternSpec(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapPatternSpec(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (p *PatternSpec) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

// Equal compares two compiled pattern specs and returns whether they will match
// the same set of strings.
func (pspec1 *PatternSpec) Equal(pspec2 *PatternSpec) bool {
	var arg0 *C.GPatternSpec
	var arg1 *C.GPatternSpec

	arg0 = (*C.GPatternSpec)(pspec1.Native())
	arg1 = (*C.GPatternSpec)(pspec2.Native())

	ret := C.g_pattern_spec_equal(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Free frees the memory allocated for the Spec.
func (pspec *PatternSpec) Free() {
	var arg0 *C.GPatternSpec

	arg0 = (*C.GPatternSpec)(pspec.Native())

	C.g_pattern_spec_free(arg0)
}

// PollFD represents a file descriptor, which events to poll for, and which
// events occurred.
type PollFD struct {
	native C.GPollFD
}

// WrapPollFD wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPollFD(ptr unsafe.Pointer) *PollFD {
	if ptr == nil {
		return nil
	}

	return (*PollFD)(ptr)
}

func marshalPollFD(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapPollFD(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (p *PollFD) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

// Fd gets the field inside the struct.
func (p *PollFD) Fd() int {
	var ret int
	ret = int(p.native.fd)
	return ret
}

// Events gets the field inside the struct.
func (p *PollFD) Events() uint16 {
	var ret uint16
	ret = uint16(p.native.events)
	return ret
}

// Revents gets the field inside the struct.
func (p *PollFD) Revents() uint16 {
	var ret uint16
	ret = uint16(p.native.revents)
	return ret
}

// Private: the #GPrivate struct is an opaque data structure to represent a
// thread-local data key. It is approximately equivalent to the
// pthread_setspecific()/pthread_getspecific() APIs on POSIX and to
// TlsSetValue()/TlsGetValue() on Windows.
//
// If you don't already know why you might want this functionality, then you
// probably don't need it.
//
// #GPrivate is a very limited resource (as far as 128 per program, shared
// between all libraries). It is also not possible to destroy a #GPrivate after
// it has been used. As such, it is only ever acceptable to use #GPrivate in
// static scope, and even then sparingly so.
//
// See G_PRIVATE_INIT() for a couple of examples.
//
// The #GPrivate structure should be considered opaque. It should only be
// accessed via the g_private_ functions.
type Private struct {
	native C.GPrivate
}

// WrapPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPrivate(ptr unsafe.Pointer) *Private {
	if ptr == nil {
		return nil
	}

	return (*Private)(ptr)
}

func marshalPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (p *Private) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

// Get returns the current value of the thread local variable @key.
//
// If the value has not yet been set in this thread, nil is returned. Values are
// never copied between threads (when a new thread is created, for example).
func (key *Private) Get() interface{} {
	var arg0 *C.GPrivate

	arg0 = (*C.GPrivate)(key.Native())

	ret := C.g_private_get(arg0)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// Replace sets the thread local variable @key to have the value @value in the
// current thread.
//
// This function differs from g_private_set() in the following way: if the
// previous value was non-nil then the Notify handler for @key is run on it.
func (key *Private) Replace(value interface{}) {
	var arg0 *C.GPrivate
	var arg1 C.gpointer

	arg0 = (*C.GPrivate)(key.Native())
	arg1 = C.gpointer(box.Assign(value))

	C.g_private_replace(arg0, arg1)
}

// Set sets the thread local variable @key to have the value @value in the
// current thread.
//
// This function differs from g_private_replace() in the following way: the
// Notify for @key is not called on the old value.
func (key *Private) Set(value interface{}) {
	var arg0 *C.GPrivate
	var arg1 C.gpointer

	arg0 = (*C.GPrivate)(key.Native())
	arg1 = C.gpointer(box.Assign(value))

	C.g_private_set(arg0, arg1)
}

// PtrArray contains the public fields of a pointer array.
type PtrArray struct {
	native C.GPtrArray
}

// WrapPtrArray wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPtrArray(ptr unsafe.Pointer) *PtrArray {
	if ptr == nil {
		return nil
	}

	return (*PtrArray)(ptr)
}

func marshalPtrArray(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapPtrArray(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (p *PtrArray) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

// Pdata gets the field inside the struct.
func (p *PtrArray) Pdata() interface{} {
	var ret interface{}
	ret = box.Get(uintptr(p.native.pdata))
	return ret
}

// Len gets the field inside the struct.
func (p *PtrArray) Len() uint {
	var ret uint
	ret = uint(p.native.len)
	return ret
}

// Queue contains the public fields of a [Queue][glib-Double-ended-Queues].
type Queue struct {
	native C.GQueue
}

// WrapQueue wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapQueue(ptr unsafe.Pointer) *Queue {
	if ptr == nil {
		return nil
	}

	return (*Queue)(ptr)
}

func marshalQueue(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapQueue(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (q *Queue) Native() unsafe.Pointer {
	return unsafe.Pointer(&q.native)
}

// Head gets the field inside the struct.
func (q *Queue) Head() *List {
	var ret *List
	{
		ret = WrapList(unsafe.Pointer(q.native.head))
	}
	return ret
}

// Tail gets the field inside the struct.
func (q *Queue) Tail() *List {
	var ret *List
	{
		ret = WrapList(unsafe.Pointer(q.native.tail))
	}
	return ret
}

// Clear removes all the elements in @queue. If queue elements contain
// dynamically-allocated memory, they should be freed first.
func (queue *Queue) Clear() {
	var arg0 *C.GQueue

	arg0 = (*C.GQueue)(queue.Native())

	C.g_queue_clear(arg0)
}

// ClearFull: convenience method, which frees all the memory used by a #GQueue,
// and calls the provided @free_func on each item in the #GQueue.
func (queue *Queue) ClearFull() {
	var arg0 *C.GQueue
	var arg1 C.GDestroyNotify

	arg0 = (*C.GQueue)(queue.Native())

	C.g_queue_clear_full(arg0, arg1)
}

// Copy copies a @queue. Note that is a shallow copy. If the elements in the
// queue consist of pointers to data, the pointers are copied, but the actual
// data is not.
func (queue *Queue) Copy() *Queue {
	var arg0 *C.GQueue

	arg0 = (*C.GQueue)(queue.Native())

	ret := C.g_queue_copy(arg0)

	var ret0 *Queue

	{
		ret0 = WrapQueue(unsafe.Pointer(ret))
	}

	return ret0
}

// DeleteLink removes @link_ from @queue and frees it.
//
// @link_ must be part of @queue.
func (queue *Queue) DeleteLink(link_ *List) {
	var arg0 *C.GQueue
	var arg1 *C.GList

	arg0 = (*C.GQueue)(queue.Native())
	arg1 = (*C.GList)(link_.Native())

	C.g_queue_delete_link(arg0, arg1)
}

// Find finds the first link in @queue which contains @data.
func (queue *Queue) Find(data interface{}) *List {
	var arg0 *C.GQueue
	var arg1 C.gpointer

	arg0 = (*C.GQueue)(queue.Native())
	arg1 = C.gpointer(box.Assign(data))

	ret := C.g_queue_find(arg0, arg1)

	var ret0 *List

	{
		ret0 = WrapList(unsafe.Pointer(ret))
	}

	return ret0
}

// Foreach calls @func for each element in the queue passing @user_data to the
// function.
//
// It is safe for @func to remove the element from @queue, but it must not
// modify any part of the queue after that element.
func (queue *Queue) Foreach(fn Func) {
	var arg0 *C.GQueue
	var arg1 C.GFunc
	var arg2 C.gpointer

	arg0 = (*C.GQueue)(queue.Native())
	arg1 = (*[0]byte)(C.gotk4_Func)
	arg2 = C.gpointer(box.Assign(fn))

	C.g_queue_foreach(arg0, arg1, arg2)
}

// Free frees the memory allocated for the #GQueue. Only call this function if
// @queue was created with g_queue_new(). If queue elements contain
// dynamically-allocated memory, they should be freed first.
//
// If queue elements contain dynamically-allocated memory, you should either use
// g_queue_free_full() or free them manually first.
func (queue *Queue) Free() {
	var arg0 *C.GQueue

	arg0 = (*C.GQueue)(queue.Native())

	C.g_queue_free(arg0)
}

// Length returns the number of items in @queue.
func (queue *Queue) Length() uint {
	var arg0 *C.GQueue

	arg0 = (*C.GQueue)(queue.Native())

	ret := C.g_queue_get_length(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Index returns the position of the first element in @queue which contains
// @data.
func (queue *Queue) Index(data interface{}) int {
	var arg0 *C.GQueue
	var arg1 C.gpointer

	arg0 = (*C.GQueue)(queue.Native())
	arg1 = C.gpointer(box.Assign(data))

	ret := C.g_queue_index(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Init: a statically-allocated #GQueue must be initialized with this function
// before it can be used. Alternatively you can initialize it with QUEUE_INIT.
// It is not necessary to initialize queues created with g_queue_new().
func (queue *Queue) Init() {
	var arg0 *C.GQueue

	arg0 = (*C.GQueue)(queue.Native())

	C.g_queue_init(arg0)
}

// InsertAfter inserts @data into @queue after @sibling.
//
// @sibling must be part of @queue. Since GLib 2.44 a nil sibling pushes the
// data at the head of the queue.
func (queue *Queue) InsertAfter(sibling *List, data interface{}) {
	var arg0 *C.GQueue
	var arg1 *C.GList
	var arg2 C.gpointer

	arg0 = (*C.GQueue)(queue.Native())
	arg1 = (*C.GList)(sibling.Native())
	arg2 = C.gpointer(box.Assign(data))

	C.g_queue_insert_after(arg0, arg1, arg2)
}

// InsertAfterLink inserts @link_ into @queue after @sibling.
//
// @sibling must be part of @queue.
func (queue *Queue) InsertAfterLink(sibling *List, link_ *List) {
	var arg0 *C.GQueue
	var arg1 *C.GList
	var arg2 *C.GList

	arg0 = (*C.GQueue)(queue.Native())
	arg1 = (*C.GList)(sibling.Native())
	arg2 = (*C.GList)(link_.Native())

	C.g_queue_insert_after_link(arg0, arg1, arg2)
}

// InsertBefore inserts @data into @queue before @sibling.
//
// @sibling must be part of @queue. Since GLib 2.44 a nil sibling pushes the
// data at the tail of the queue.
func (queue *Queue) InsertBefore(sibling *List, data interface{}) {
	var arg0 *C.GQueue
	var arg1 *C.GList
	var arg2 C.gpointer

	arg0 = (*C.GQueue)(queue.Native())
	arg1 = (*C.GList)(sibling.Native())
	arg2 = C.gpointer(box.Assign(data))

	C.g_queue_insert_before(arg0, arg1, arg2)
}

// InsertBeforeLink inserts @link_ into @queue before @sibling.
//
// @sibling must be part of @queue.
func (queue *Queue) InsertBeforeLink(sibling *List, link_ *List) {
	var arg0 *C.GQueue
	var arg1 *C.GList
	var arg2 *C.GList

	arg0 = (*C.GQueue)(queue.Native())
	arg1 = (*C.GList)(sibling.Native())
	arg2 = (*C.GList)(link_.Native())

	C.g_queue_insert_before_link(arg0, arg1, arg2)
}

// InsertSorted inserts @data into @queue using @func to determine the new
// position.
func (queue *Queue) InsertSorted(data interface{}, fn CompareDataFunc) {
	var arg0 *C.GQueue
	var arg1 C.gpointer
	var arg2 C.GCompareDataFunc
	var arg3 C.gpointer

	arg0 = (*C.GQueue)(queue.Native())
	arg1 = C.gpointer(box.Assign(data))
	arg2 = (*[0]byte)(C.gotk4_CompareDataFunc)
	arg3 = C.gpointer(box.Assign(fn))

	C.g_queue_insert_sorted(arg0, arg1, arg2, arg3)
}

// IsEmpty returns true if the queue is empty.
func (queue *Queue) IsEmpty() bool {
	var arg0 *C.GQueue

	arg0 = (*C.GQueue)(queue.Native())

	ret := C.g_queue_is_empty(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// LinkIndex returns the position of @link_ in @queue.
func (queue *Queue) LinkIndex(link_ *List) int {
	var arg0 *C.GQueue
	var arg1 *C.GList

	arg0 = (*C.GQueue)(queue.Native())
	arg1 = (*C.GList)(link_.Native())

	ret := C.g_queue_link_index(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// PeekHead returns the first element of the queue.
func (queue *Queue) PeekHead() interface{} {
	var arg0 *C.GQueue

	arg0 = (*C.GQueue)(queue.Native())

	ret := C.g_queue_peek_head(arg0)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// PeekHeadLink returns the first link in @queue.
func (queue *Queue) PeekHeadLink() *List {
	var arg0 *C.GQueue

	arg0 = (*C.GQueue)(queue.Native())

	ret := C.g_queue_peek_head_link(arg0)

	var ret0 *List

	{
		ret0 = WrapList(unsafe.Pointer(ret))
	}

	return ret0
}

// PeekNth returns the @n'th element of @queue.
func (queue *Queue) PeekNth(n uint) interface{} {
	var arg0 *C.GQueue
	var arg1 C.guint

	arg0 = (*C.GQueue)(queue.Native())
	arg1 = C.guint(n)

	ret := C.g_queue_peek_nth(arg0, arg1)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// PeekNthLink returns the link at the given position
func (queue *Queue) PeekNthLink(n uint) *List {
	var arg0 *C.GQueue
	var arg1 C.guint

	arg0 = (*C.GQueue)(queue.Native())
	arg1 = C.guint(n)

	ret := C.g_queue_peek_nth_link(arg0, arg1)

	var ret0 *List

	{
		ret0 = WrapList(unsafe.Pointer(ret))
	}

	return ret0
}

// PeekTail returns the last element of the queue.
func (queue *Queue) PeekTail() interface{} {
	var arg0 *C.GQueue

	arg0 = (*C.GQueue)(queue.Native())

	ret := C.g_queue_peek_tail(arg0)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// PeekTailLink returns the last link in @queue.
func (queue *Queue) PeekTailLink() *List {
	var arg0 *C.GQueue

	arg0 = (*C.GQueue)(queue.Native())

	ret := C.g_queue_peek_tail_link(arg0)

	var ret0 *List

	{
		ret0 = WrapList(unsafe.Pointer(ret))
	}

	return ret0
}

// PopHead removes the first element of the queue and returns its data.
func (queue *Queue) PopHead() interface{} {
	var arg0 *C.GQueue

	arg0 = (*C.GQueue)(queue.Native())

	ret := C.g_queue_pop_head(arg0)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// PopHeadLink removes and returns the first element of the queue.
func (queue *Queue) PopHeadLink() *List {
	var arg0 *C.GQueue

	arg0 = (*C.GQueue)(queue.Native())

	ret := C.g_queue_pop_head_link(arg0)

	var ret0 *List

	{
		ret0 = WrapList(unsafe.Pointer(ret))
	}

	return ret0
}

// PopNth removes the @n'th element of @queue and returns its data.
func (queue *Queue) PopNth(n uint) interface{} {
	var arg0 *C.GQueue
	var arg1 C.guint

	arg0 = (*C.GQueue)(queue.Native())
	arg1 = C.guint(n)

	ret := C.g_queue_pop_nth(arg0, arg1)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// PopNthLink removes and returns the link at the given position.
func (queue *Queue) PopNthLink(n uint) *List {
	var arg0 *C.GQueue
	var arg1 C.guint

	arg0 = (*C.GQueue)(queue.Native())
	arg1 = C.guint(n)

	ret := C.g_queue_pop_nth_link(arg0, arg1)

	var ret0 *List

	{
		ret0 = WrapList(unsafe.Pointer(ret))
	}

	return ret0
}

// PopTail removes the last element of the queue and returns its data.
func (queue *Queue) PopTail() interface{} {
	var arg0 *C.GQueue

	arg0 = (*C.GQueue)(queue.Native())

	ret := C.g_queue_pop_tail(arg0)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// PopTailLink removes and returns the last element of the queue.
func (queue *Queue) PopTailLink() *List {
	var arg0 *C.GQueue

	arg0 = (*C.GQueue)(queue.Native())

	ret := C.g_queue_pop_tail_link(arg0)

	var ret0 *List

	{
		ret0 = WrapList(unsafe.Pointer(ret))
	}

	return ret0
}

// PushHead adds a new element at the head of the queue.
func (queue *Queue) PushHead(data interface{}) {
	var arg0 *C.GQueue
	var arg1 C.gpointer

	arg0 = (*C.GQueue)(queue.Native())
	arg1 = C.gpointer(box.Assign(data))

	C.g_queue_push_head(arg0, arg1)
}

// PushHeadLink adds a new element at the head of the queue.
func (queue *Queue) PushHeadLink(link_ *List) {
	var arg0 *C.GQueue
	var arg1 *C.GList

	arg0 = (*C.GQueue)(queue.Native())
	arg1 = (*C.GList)(link_.Native())

	C.g_queue_push_head_link(arg0, arg1)
}

// PushNth inserts a new element into @queue at the given position.
func (queue *Queue) PushNth(data interface{}, n int) {
	var arg0 *C.GQueue
	var arg1 C.gpointer
	var arg2 C.gint

	arg0 = (*C.GQueue)(queue.Native())
	arg1 = C.gpointer(box.Assign(data))
	arg2 = C.gint(n)

	C.g_queue_push_nth(arg0, arg1, arg2)
}

// PushNthLink inserts @link into @queue at the given position.
func (queue *Queue) PushNthLink(n int, link_ *List) {
	var arg0 *C.GQueue
	var arg1 C.gint
	var arg2 *C.GList

	arg0 = (*C.GQueue)(queue.Native())
	arg1 = C.gint(n)
	arg2 = (*C.GList)(link_.Native())

	C.g_queue_push_nth_link(arg0, arg1, arg2)
}

// PushTail adds a new element at the tail of the queue.
func (queue *Queue) PushTail(data interface{}) {
	var arg0 *C.GQueue
	var arg1 C.gpointer

	arg0 = (*C.GQueue)(queue.Native())
	arg1 = C.gpointer(box.Assign(data))

	C.g_queue_push_tail(arg0, arg1)
}

// PushTailLink adds a new element at the tail of the queue.
func (queue *Queue) PushTailLink(link_ *List) {
	var arg0 *C.GQueue
	var arg1 *C.GList

	arg0 = (*C.GQueue)(queue.Native())
	arg1 = (*C.GList)(link_.Native())

	C.g_queue_push_tail_link(arg0, arg1)
}

// Remove removes the first element in @queue that contains @data.
func (queue *Queue) Remove(data interface{}) bool {
	var arg0 *C.GQueue
	var arg1 C.gpointer

	arg0 = (*C.GQueue)(queue.Native())
	arg1 = C.gpointer(box.Assign(data))

	ret := C.g_queue_remove(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// RemoveAll: remove all elements whose data equals @data from @queue.
func (queue *Queue) RemoveAll(data interface{}) uint {
	var arg0 *C.GQueue
	var arg1 C.gpointer

	arg0 = (*C.GQueue)(queue.Native())
	arg1 = C.gpointer(box.Assign(data))

	ret := C.g_queue_remove_all(arg0, arg1)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Reverse reverses the order of the items in @queue.
func (queue *Queue) Reverse() {
	var arg0 *C.GQueue

	arg0 = (*C.GQueue)(queue.Native())

	C.g_queue_reverse(arg0)
}

// Sort sorts @queue using @compare_func.
func (queue *Queue) Sort(compareFunc CompareDataFunc) {
	var arg0 *C.GQueue
	var arg1 C.GCompareDataFunc
	var arg2 C.gpointer

	arg0 = (*C.GQueue)(queue.Native())
	arg1 = (*[0]byte)(C.gotk4_CompareDataFunc)
	arg2 = C.gpointer(box.Assign(compareFunc))

	C.g_queue_sort(arg0, arg1, arg2)
}

// Unlink unlinks @link_ so that it will no longer be part of @queue. The link
// is not freed.
//
// @link_ must be part of @queue.
func (queue *Queue) Unlink(link_ *List) {
	var arg0 *C.GQueue
	var arg1 *C.GList

	arg0 = (*C.GQueue)(queue.Native())
	arg1 = (*C.GList)(link_.Native())

	C.g_queue_unlink(arg0, arg1)
}

// RWLock: the GRWLock struct is an opaque data structure to represent a
// reader-writer lock. It is similar to a #GMutex in that it allows multiple
// threads to coordinate access to a shared resource.
//
// The difference to a mutex is that a reader-writer lock discriminates between
// read-only ('reader') and full ('writer') access. While only one thread at a
// time is allowed write access (by holding the 'writer' lock via
// g_rw_lock_writer_lock()), multiple threads can gain simultaneous read-only
// access (by holding the 'reader' lock via g_rw_lock_reader_lock()).
//
// It is unspecified whether readers or writers have priority in acquiring the
// lock when a reader already holds the lock and a writer is queued to acquire
// it.
//
// Here is an example for an array with access functions: |[<!-- language="C"
// --> GRWLock lock; GPtrArray *array;
//
//     gpointer
//     my_array_get (guint index)
//     {
//       gpointer retval = NULL;
//
//       if (!array)
//         return NULL;
//
//       g_rw_lock_reader_lock (&lock);
//       if (index < array->len)
//         retval = g_ptr_array_index (array, index);
//       g_rw_lock_reader_unlock (&lock);
//
//       return retval;
//     }
//
//     void
//     my_array_set (guint index, gpointer data)
//     {
//       g_rw_lock_writer_lock (&lock);
//
//       if (!array)
//         array = g_ptr_array_new ();
//
//       if (index >= array->len)
//         g_ptr_array_set_size (array, index+1);
//       g_ptr_array_index (array, index) = data;
//
//       g_rw_lock_writer_unlock (&lock);
//     }
//    ]|
//
// This example shows an array which can be accessed by many readers (the
// my_array_get() function) simultaneously, whereas the writers (the
// my_array_set() function) will only be allowed one at a time and only if no
// readers currently access the array. This is because of the potentially
// dangerous resizing of the array. Using these functions is fully multi-thread
// safe now.
//
// If a WLock is allocated in static storage then it can be used without
// initialisation. Otherwise, you should call g_rw_lock_init() on it and
// g_rw_lock_clear() when done.
//
// A GRWLock should only be accessed with the g_rw_lock_ functions.
type RWLock struct {
	native C.GRWLock
}

// WrapRWLock wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRWLock(ptr unsafe.Pointer) *RWLock {
	if ptr == nil {
		return nil
	}

	return (*RWLock)(ptr)
}

func marshalRWLock(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRWLock(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *RWLock) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// Clear frees the resources allocated to a lock with g_rw_lock_init().
//
// This function should not be used with a WLock that has been statically
// allocated.
//
// Calling g_rw_lock_clear() when any thread holds the lock leads to undefined
// behaviour.
//
// Sine: 2.32
func (rwLock *RWLock) Clear() {
	var arg0 *C.GRWLock

	arg0 = (*C.GRWLock)(rwLock.Native())

	C.g_rw_lock_clear(arg0)
}

// Init initializes a WLock so that it can be used.
//
// This function is useful to initialize a lock that has been allocated on the
// stack, or as part of a larger structure. It is not necessary to initialise a
// reader-writer lock that has been statically allocated.
//
//      typedef struct {
//        GRWLock l;
//        ...
//      } Blob;
//
//    Blob *b;
//
//    b = g_new (Blob, 1);
//    g_rw_lock_init (&b->l);
//
// To undo the effect of g_rw_lock_init() when a lock is no longer needed, use
// g_rw_lock_clear().
//
// Calling g_rw_lock_init() on an already initialized WLock leads to undefined
// behaviour.
func (rwLock *RWLock) Init() {
	var arg0 *C.GRWLock

	arg0 = (*C.GRWLock)(rwLock.Native())

	C.g_rw_lock_init(arg0)
}

// ReaderLock: obtain a read lock on @rw_lock. If another thread currently holds
// the write lock on @rw_lock, the current thread will block. If another thread
// does not hold the write lock, but is waiting for it, it is implementation
// defined whether the reader or writer will block. Read locks can be taken
// recursively.
//
// It is implementation-defined how many threads are allowed to hold read locks
// on the same lock simultaneously. If the limit is hit, or if a deadlock is
// detected, a critical warning will be emitted.
func (rwLock *RWLock) ReaderLock() {
	var arg0 *C.GRWLock

	arg0 = (*C.GRWLock)(rwLock.Native())

	C.g_rw_lock_reader_lock(arg0)
}

// ReaderTrylock tries to obtain a read lock on @rw_lock and returns true if the
// read lock was successfully obtained. Otherwise it returns false.
func (rwLock *RWLock) ReaderTrylock() bool {
	var arg0 *C.GRWLock

	arg0 = (*C.GRWLock)(rwLock.Native())

	ret := C.g_rw_lock_reader_trylock(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ReaderUnlock: release a read lock on @rw_lock.
//
// Calling g_rw_lock_reader_unlock() on a lock that is not held by the current
// thread leads to undefined behaviour.
func (rwLock *RWLock) ReaderUnlock() {
	var arg0 *C.GRWLock

	arg0 = (*C.GRWLock)(rwLock.Native())

	C.g_rw_lock_reader_unlock(arg0)
}

// WriterLock: obtain a write lock on @rw_lock. If any thread already holds a
// read or write lock on @rw_lock, the current thread will block until all other
// threads have dropped their locks on @rw_lock.
func (rwLock *RWLock) WriterLock() {
	var arg0 *C.GRWLock

	arg0 = (*C.GRWLock)(rwLock.Native())

	C.g_rw_lock_writer_lock(arg0)
}

// WriterTrylock tries to obtain a write lock on @rw_lock. If any other thread
// holds a read or write lock on @rw_lock, it immediately returns false.
// Otherwise it locks @rw_lock and returns true.
func (rwLock *RWLock) WriterTrylock() bool {
	var arg0 *C.GRWLock

	arg0 = (*C.GRWLock)(rwLock.Native())

	ret := C.g_rw_lock_writer_trylock(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// WriterUnlock: release a write lock on @rw_lock.
//
// Calling g_rw_lock_writer_unlock() on a lock that is not held by the current
// thread leads to undefined behaviour.
func (rwLock *RWLock) WriterUnlock() {
	var arg0 *C.GRWLock

	arg0 = (*C.GRWLock)(rwLock.Native())

	C.g_rw_lock_writer_unlock(arg0)
}

// Rand: the GRand struct is an opaque data structure. It should only be
// accessed through the g_rand_* functions.
type Rand struct {
	native C.GRand
}

// WrapRand wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRand(ptr unsafe.Pointer) *Rand {
	if ptr == nil {
		return nil
	}

	return (*Rand)(ptr)
}

func marshalRand(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRand(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *Rand) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// Copy copies a #GRand into a new one with the same exact state as before. This
// way you can take a snapshot of the random number generator for replaying
// later.
func (rand_ *Rand) Copy() *Rand {
	var arg0 *C.GRand

	arg0 = (*C.GRand)(rand_.Native())

	ret := C.g_rand_copy(arg0)

	var ret0 *Rand

	{
		ret0 = WrapRand(unsafe.Pointer(ret))
	}

	return ret0
}

// Double returns the next random #gdouble from @rand_ equally distributed over
// the range [0..1).
func (rand_ *Rand) Double() float64 {
	var arg0 *C.GRand

	arg0 = (*C.GRand)(rand_.Native())

	ret := C.g_rand_double(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// DoubleRange returns the next random #gdouble from @rand_ equally distributed
// over the range [@begin..@end).
func (rand_ *Rand) DoubleRange(begin float64, end float64) float64 {
	var arg0 *C.GRand
	var arg1 C.gdouble
	var arg2 C.gdouble

	arg0 = (*C.GRand)(rand_.Native())
	arg1 = C.gdouble(begin)
	arg2 = C.gdouble(end)

	ret := C.g_rand_double_range(arg0, arg1, arg2)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// Free frees the memory allocated for the #GRand.
func (rand_ *Rand) Free() {
	var arg0 *C.GRand

	arg0 = (*C.GRand)(rand_.Native())

	C.g_rand_free(arg0)
}

// Int returns the next random #guint32 from @rand_ equally distributed over the
// range [0..2^32-1].
func (rand_ *Rand) Int() uint32 {
	var arg0 *C.GRand

	arg0 = (*C.GRand)(rand_.Native())

	ret := C.g_rand_int(arg0)

	var ret0 uint32

	ret0 = uint32(ret)

	return ret0
}

// IntRange returns the next random #gint32 from @rand_ equally distributed over
// the range [@begin..@end-1].
func (rand_ *Rand) IntRange(begin int32, end int32) int32 {
	var arg0 *C.GRand
	var arg1 C.gint32
	var arg2 C.gint32

	arg0 = (*C.GRand)(rand_.Native())
	arg1 = C.gint32(begin)
	arg2 = C.gint32(end)

	ret := C.g_rand_int_range(arg0, arg1, arg2)

	var ret0 int32

	ret0 = int32(ret)

	return ret0
}

// SetSeed sets the seed for the random number generator #GRand to @seed.
func (rand_ *Rand) SetSeed(seed uint32) {
	var arg0 *C.GRand
	var arg1 C.guint32

	arg0 = (*C.GRand)(rand_.Native())
	arg1 = C.guint32(seed)

	C.g_rand_set_seed(arg0, arg1)
}

// SetSeedArray initializes the random number generator by an array of longs.
// Array can be of arbitrary size, though only the first 624 values are taken.
// This function is useful if you have many low entropy seeds, or if you require
// more then 32 bits of actual entropy for your application.
func (rand_ *Rand) SetSeedArray(seed uint32, seedLength uint) {
	var arg0 *C.GRand
	var arg1 *C.guint32
	var arg2 C.guint

	arg0 = (*C.GRand)(rand_.Native())
	arg1 = (*C.guint32)(seed)
	arg2 = C.guint(seedLength)

	C.g_rand_set_seed_array(arg0, arg1, arg2)
}

// RecMutex: the GRecMutex struct is an opaque data structure to represent a
// recursive mutex. It is similar to a #GMutex with the difference that it is
// possible to lock a GRecMutex multiple times in the same thread without
// deadlock. When doing so, care has to be taken to unlock the recursive mutex
// as often as it has been locked.
//
// If a Mutex is allocated in static storage then it can be used without
// initialisation. Otherwise, you should call g_rec_mutex_init() on it and
// g_rec_mutex_clear() when done.
//
// A GRecMutex should only be accessed with the g_rec_mutex_ functions.
type RecMutex struct {
	native C.GRecMutex
}

// WrapRecMutex wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRecMutex(ptr unsafe.Pointer) *RecMutex {
	if ptr == nil {
		return nil
	}

	return (*RecMutex)(ptr)
}

func marshalRecMutex(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRecMutex(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *RecMutex) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// Clear frees the resources allocated to a recursive mutex with
// g_rec_mutex_init().
//
// This function should not be used with a Mutex that has been statically
// allocated.
//
// Calling g_rec_mutex_clear() on a locked recursive mutex leads to undefined
// behaviour.
//
// Sine: 2.32
func (recMutex *RecMutex) Clear() {
	var arg0 *C.GRecMutex

	arg0 = (*C.GRecMutex)(recMutex.Native())

	C.g_rec_mutex_clear(arg0)
}

// Init initializes a Mutex so that it can be used.
//
// This function is useful to initialize a recursive mutex that has been
// allocated on the stack, or as part of a larger structure.
//
// It is not necessary to initialise a recursive mutex that has been statically
// allocated.
//
//      typedef struct {
//        GRecMutex m;
//        ...
//      } Blob;
//
//    Blob *b;
//
//    b = g_new (Blob, 1);
//    g_rec_mutex_init (&b->m);
//
// Calling g_rec_mutex_init() on an already initialized Mutex leads to undefined
// behaviour.
//
// To undo the effect of g_rec_mutex_init() when a recursive mutex is no longer
// needed, use g_rec_mutex_clear().
func (recMutex *RecMutex) Init() {
	var arg0 *C.GRecMutex

	arg0 = (*C.GRecMutex)(recMutex.Native())

	C.g_rec_mutex_init(arg0)
}

// Lock locks @rec_mutex. If @rec_mutex is already locked by another thread, the
// current thread will block until @rec_mutex is unlocked by the other thread.
// If @rec_mutex is already locked by the current thread, the 'lock count' of
// @rec_mutex is increased. The mutex will only become available again when it
// is unlocked as many times as it has been locked.
func (recMutex *RecMutex) Lock() {
	var arg0 *C.GRecMutex

	arg0 = (*C.GRecMutex)(recMutex.Native())

	C.g_rec_mutex_lock(arg0)
}

// Trylock tries to lock @rec_mutex. If @rec_mutex is already locked by another
// thread, it immediately returns false. Otherwise it locks @rec_mutex and
// returns true.
func (recMutex *RecMutex) Trylock() bool {
	var arg0 *C.GRecMutex

	arg0 = (*C.GRecMutex)(recMutex.Native())

	ret := C.g_rec_mutex_trylock(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Unlock unlocks @rec_mutex. If another thread is blocked in a
// g_rec_mutex_lock() call for @rec_mutex, it will become unblocked and can lock
// @rec_mutex itself.
//
// Calling g_rec_mutex_unlock() on a recursive mutex that is not locked by the
// current thread leads to undefined behaviour.
func (recMutex *RecMutex) Unlock() {
	var arg0 *C.GRecMutex

	arg0 = (*C.GRecMutex)(recMutex.Native())

	C.g_rec_mutex_unlock(arg0)
}

// Regex: the g_regex_*() functions implement regular expression pattern
// matching using syntax and semantics similar to Perl regular expression.
//
// Some functions accept a @start_position argument, setting it differs from
// just passing over a shortened string and setting REGEX_MATCH_NOTBOL in the
// case of a pattern that begins with any kind of lookbehind assertion. For
// example, consider the pattern "\Biss\B" which finds occurrences of "iss" in
// the middle of words. ("\B" matches only if the current position in the
// subject is not a word boundary.) When applied to the string "Mississipi" from
// the fourth byte, namely "issipi", it does not match, because "\B" is always
// false at the start of the subject, which is deemed to be a word boundary.
// However, if the entire string is passed , but with @start_position set to 4,
// it finds the second occurrence of "iss" because it is able to look behind the
// starting point to discover that it is preceded by a letter.
//
// Note that, unless you set the REGEX_RAW flag, all the strings passed to these
// functions must be encoded in UTF-8. The lengths and the positions inside the
// strings are in bytes and not in characters, so, for instance, "\xc3\xa0"
// (i.e. "à") is two bytes long but it is treated as a single character. If you
// set REGEX_RAW the strings can be non-valid UTF-8 strings and a byte is
// treated as a character, so "\xc3\xa0" is two bytes and two characters long.
//
// When matching a pattern, "\n" matches only against a "\n" character in the
// string, and "\r" matches only a "\r" character. To match any newline sequence
// use "\R". This particular group matches either the two-character sequence CR
// + LF ("\r\n"), or one of the single characters LF (linefeed, U+000A, "\n"),
// VT vertical tab, U+000B, "\v"), FF (formfeed, U+000C, "\f"), CR (carriage
// return, U+000D, "\r"), NEL (next line, U+0085), LS (line separator, U+2028),
// or PS (paragraph separator, U+2029).
//
// The behaviour of the dot, circumflex, and dollar metacharacters are affected
// by newline characters, the default is to recognize any newline character (the
// same characters recognized by "\R"). This can be changed with
// REGEX_NEWLINE_CR, REGEX_NEWLINE_LF and REGEX_NEWLINE_CRLF compile options,
// and with REGEX_MATCH_NEWLINE_ANY, REGEX_MATCH_NEWLINE_CR,
// REGEX_MATCH_NEWLINE_LF and REGEX_MATCH_NEWLINE_CRLF match options. These
// settings are also relevant when compiling a pattern if REGEX_EXTENDED is set,
// and an unescaped "#" outside a character class is encountered. This indicates
// a comment that lasts until after the next newline.
//
// When setting the G_REGEX_JAVASCRIPT_COMPAT flag, pattern syntax and pattern
// matching is changed to be compatible with the way that regular expressions
// work in JavaScript. More precisely, a lonely ']' character in the pattern is
// a syntax error; the '\x' escape only allows 0 to 2 hexadecimal digits, and
// you must use the '\u' escape sequence with 4 hex digits to specify a unicode
// codepoint instead of '\x' or 'x{....}'. If '\x' or '\u' are not followed by
// the specified number of hex digits, they match 'x' and 'u' literally; also
// '\U' always matches 'U' instead of being an error in the pattern. Finally,
// pattern matching is modified so that back references to an unset subpattern
// group produces a match with the empty string instead of an error. See
// pcreapi(3) for more information.
//
// Creating and manipulating the same #GRegex structure from different threads
// is not a problem as #GRegex does not modify its internal state between
// creation and destruction, on the other hand Info is not threadsafe.
//
// The regular expressions low-level functionalities are obtained through the
// excellent PCRE (http://www.pcre.org/) library written by Philip Hazel.
type Regex struct {
	native C.GRegex
}

// WrapRegex wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRegex(ptr unsafe.Pointer) *Regex {
	if ptr == nil {
		return nil
	}

	return (*Regex)(ptr)
}

func marshalRegex(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRegex(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *Regex) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// NewRegex constructs a struct Regex.
func NewRegex(pattern string, compileOptions RegexCompileFlags, matchOptions RegexMatchFlags) (regex *Regex, err error) {
	var arg1 *C.gchar
	var arg2 C.GRegexCompileFlags
	var arg3 C.GRegexMatchFlags
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(pattern))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GRegexCompileFlags)(compileOptions)
	arg3 = (C.GRegexMatchFlags)(matchOptions)

	ret := C.g_regex_new(arg1, arg2, arg3, &gError)

	var ret0 *Regex
	var goError error

	{
		ret0 = WrapRegex(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Regex) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// CaptureCount returns the number of capturing subpatterns in the pattern.
func (regex *Regex) CaptureCount() int {
	var arg0 *C.GRegex

	arg0 = (*C.GRegex)(regex.Native())

	ret := C.g_regex_get_capture_count(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// CompileFlags returns the compile options that @regex was created with.
//
// Depending on the version of PCRE that is used, this may or may not include
// flags set by option expressions such as `(?i)` found at the top-level within
// the compiled pattern.
func (regex *Regex) CompileFlags() RegexCompileFlags {
	var arg0 *C.GRegex

	arg0 = (*C.GRegex)(regex.Native())

	ret := C.g_regex_get_compile_flags(arg0)

	var ret0 RegexCompileFlags

	ret0 = RegexCompileFlags(ret)

	return ret0
}

// HasCrOrLf checks whether the pattern contains explicit CR or LF references.
func (regex *Regex) HasCrOrLf() bool {
	var arg0 *C.GRegex

	arg0 = (*C.GRegex)(regex.Native())

	ret := C.g_regex_get_has_cr_or_lf(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// MatchFlags returns the match options that @regex was created with.
func (regex *Regex) MatchFlags() RegexMatchFlags {
	var arg0 *C.GRegex

	arg0 = (*C.GRegex)(regex.Native())

	ret := C.g_regex_get_match_flags(arg0)

	var ret0 RegexMatchFlags

	ret0 = RegexMatchFlags(ret)

	return ret0
}

// MaxBackref returns the number of the highest back reference in the pattern,
// or 0 if the pattern does not contain back references.
func (regex *Regex) MaxBackref() int {
	var arg0 *C.GRegex

	arg0 = (*C.GRegex)(regex.Native())

	ret := C.g_regex_get_max_backref(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// MaxLookbehind gets the number of characters in the longest lookbehind
// assertion in the pattern. This information is useful when doing multi-segment
// matching using the partial matching facilities.
func (regex *Regex) MaxLookbehind() int {
	var arg0 *C.GRegex

	arg0 = (*C.GRegex)(regex.Native())

	ret := C.g_regex_get_max_lookbehind(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Pattern gets the pattern string associated with @regex, i.e. a copy of the
// string passed to g_regex_new().
func (regex *Regex) Pattern() string {
	var arg0 *C.GRegex

	arg0 = (*C.GRegex)(regex.Native())

	ret := C.g_regex_get_pattern(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// StringNumber retrieves the number of the subexpression named @name.
func (regex *Regex) StringNumber(name string) int {
	var arg0 *C.GRegex
	var arg1 *C.gchar

	arg0 = (*C.GRegex)(regex.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_regex_get_string_number(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Match scans for a match in @string for the pattern in @regex. The
// @match_options are combined with the match options specified when the @regex
// structure was created, letting you have more flexibility in reusing #GRegex
// structures.
//
// Unless G_REGEX_RAW is specified in the options, @string must be valid UTF-8.
//
// A Info structure, used to get information on the match, is stored in
// @match_info if not nil. Note that if @match_info is not nil then it is
// created even if the function returns false, i.e. you must free it regardless
// if regular expression actually matched.
//
// To retrieve all the non-overlapping matches of the pattern in string you can
// use g_match_info_next().
//
//    static void
//    print_uppercase_words (const gchar *string)
//    {
//      // Print all uppercase-only words.
//      GRegex *regex;
//      GMatchInfo *match_info;
//
//      regex = g_regex_new ("[A-Z]+", 0, 0, NULL);
//      g_regex_match (regex, string, 0, &match_info);
//      while (g_match_info_matches (match_info))
//        {
//          gchar *word = g_match_info_fetch (match_info, 0);
//          g_print ("Found: s\n", word);
//          g_free (word);
//          g_match_info_next (match_info, NULL);
//        }
//      g_match_info_free (match_info);
//      g_regex_unref (regex);
//    }
//
// @string is not copied and is used in Info internally. If you use any Info
// method (except g_match_info_free()) after freeing or modifying @string then
// the behaviour is undefined.
func (regex *Regex) Match(string string, matchOptions RegexMatchFlags) (matchInfo *MatchInfo, ok bool) {
	var arg0 *C.GRegex
	var arg1 *C.gchar
	var arg2 C.GRegexMatchFlags
	var arg3 **C.GMatchInfo // out

	arg0 = (*C.GRegex)(regex.Native())
	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GRegexMatchFlags)(matchOptions)

	ret := C.g_regex_match(arg0, arg1, arg2, &arg3)

	var ret0 **MatchInfo
	var ret1 bool

	{
		ret0 = WrapMatchInfo(unsafe.Pointer(arg3))
		runtime.SetFinalizer(ret0, func(v **MatchInfo) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// MatchAll: using the standard algorithm for regular expression matching only
// the longest match in the string is retrieved. This function uses a different
// algorithm so it can retrieve all the possible matches. For more documentation
// see g_regex_match_all_full().
//
// A Info structure, used to get information on the match, is stored in
// @match_info if not nil. Note that if @match_info is not nil then it is
// created even if the function returns false, i.e. you must free it regardless
// if regular expression actually matched.
//
// @string is not copied and is used in Info internally. If you use any Info
// method (except g_match_info_free()) after freeing or modifying @string then
// the behaviour is undefined.
func (regex *Regex) MatchAll(string string, matchOptions RegexMatchFlags) (matchInfo *MatchInfo, ok bool) {
	var arg0 *C.GRegex
	var arg1 *C.gchar
	var arg2 C.GRegexMatchFlags
	var arg3 **C.GMatchInfo // out

	arg0 = (*C.GRegex)(regex.Native())
	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GRegexMatchFlags)(matchOptions)

	ret := C.g_regex_match_all(arg0, arg1, arg2, &arg3)

	var ret0 **MatchInfo
	var ret1 bool

	{
		ret0 = WrapMatchInfo(unsafe.Pointer(arg3))
		runtime.SetFinalizer(ret0, func(v **MatchInfo) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// MatchAllFull: using the standard algorithm for regular expression matching
// only the longest match in the @string is retrieved, it is not possible to
// obtain all the available matches. For instance matching "<a> <b> <c>" against
// the pattern "<.*>" you get "<a> <b> <c>".
//
// This function uses a different algorithm (called DFA, i.e. deterministic
// finite automaton), so it can retrieve all the possible matches, all starting
// at the same point in the string. For instance matching "<a> <b> <c>" against
// the pattern "<.*>;" you would obtain three matches: "<a> <b> <c>", "<a> <b>"
// and "<a>".
//
// The number of matched strings is retrieved using
// g_match_info_get_match_count(). To obtain the matched strings and their
// position you can use, respectively, g_match_info_fetch() and
// g_match_info_fetch_pos(). Note that the strings are returned in reverse order
// of length; that is, the longest matching string is given first.
//
// Note that the DFA algorithm is slower than the standard one and it is not
// able to capture substrings, so backreferences do not work.
//
// Setting @start_position differs from just passing over a shortened string and
// setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind
// of lookbehind assertion, such as "\b".
//
// Unless G_REGEX_RAW is specified in the options, @string must be valid UTF-8.
//
// A Info structure, used to get information on the match, is stored in
// @match_info if not nil. Note that if @match_info is not nil then it is
// created even if the function returns false, i.e. you must free it regardless
// if regular expression actually matched.
//
// @string is not copied and is used in Info internally. If you use any Info
// method (except g_match_info_free()) after freeing or modifying @string then
// the behaviour is undefined.
func (regex *Regex) MatchAllFull(string []string, startPosition int, matchOptions RegexMatchFlags) (matchInfo *MatchInfo, err error) {
	var arg0 *C.GRegex
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 C.gint
	var arg4 C.GRegexMatchFlags
	var arg5 **C.GMatchInfo // out
	var gError *C.GError

	arg0 = (*C.GRegex)(regex.Native())
	{
		var dst []C.gchar
		ptr := C.malloc(C.sizeof_gchar * len(string))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(string)
		sliceHeader.Cap = len(string)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(string); i++ {
			src := string[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg1 = (*C.gchar)(unsafe.Pointer(ptr))
		arg2 = len(string)
	}
	arg3 = C.gint(startPosition)
	arg4 = (C.GRegexMatchFlags)(matchOptions)

	ret := C.g_regex_match_all_full(arg0, arg1, arg2, arg3, arg4, &arg5, &gError)

	var ret0 **MatchInfo
	var goError error

	{
		ret0 = WrapMatchInfo(unsafe.Pointer(arg5))
		runtime.SetFinalizer(ret0, func(v **MatchInfo) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// MatchFull scans for a match in @string for the pattern in @regex. The
// @match_options are combined with the match options specified when the @regex
// structure was created, letting you have more flexibility in reusing #GRegex
// structures.
//
// Setting @start_position differs from just passing over a shortened string and
// setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind
// of lookbehind assertion, such as "\b".
//
// Unless G_REGEX_RAW is specified in the options, @string must be valid UTF-8.
//
// A Info structure, used to get information on the match, is stored in
// @match_info if not nil. Note that if @match_info is not nil then it is
// created even if the function returns false, i.e. you must free it regardless
// if regular expression actually matched.
//
// @string is not copied and is used in Info internally. If you use any Info
// method (except g_match_info_free()) after freeing or modifying @string then
// the behaviour is undefined.
//
// To retrieve all the non-overlapping matches of the pattern in string you can
// use g_match_info_next().
//
//    static void
//    print_uppercase_words (const gchar *string)
//    {
//      // Print all uppercase-only words.
//      GRegex *regex;
//      GMatchInfo *match_info;
//      GError *error = NULL;
//
//      regex = g_regex_new ("[A-Z]+", 0, 0, NULL);
//      g_regex_match_full (regex, string, -1, 0, 0, &match_info, &error);
//      while (g_match_info_matches (match_info))
//        {
//          gchar *word = g_match_info_fetch (match_info, 0);
//          g_print ("Found: s\n", word);
//          g_free (word);
//          g_match_info_next (match_info, &error);
//        }
//      g_match_info_free (match_info);
//      g_regex_unref (regex);
//      if (error != NULL)
//        {
//          g_printerr ("Error while matching: s\n", error->message);
//          g_error_free (error);
//        }
//    }
func (regex *Regex) MatchFull(string []string, startPosition int, matchOptions RegexMatchFlags) (matchInfo *MatchInfo, err error) {
	var arg0 *C.GRegex
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 C.gint
	var arg4 C.GRegexMatchFlags
	var arg5 **C.GMatchInfo // out
	var gError *C.GError

	arg0 = (*C.GRegex)(regex.Native())
	{
		var dst []C.gchar
		ptr := C.malloc(C.sizeof_gchar * len(string))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(string)
		sliceHeader.Cap = len(string)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(string); i++ {
			src := string[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg1 = (*C.gchar)(unsafe.Pointer(ptr))
		arg2 = len(string)
	}
	arg3 = C.gint(startPosition)
	arg4 = (C.GRegexMatchFlags)(matchOptions)

	ret := C.g_regex_match_full(arg0, arg1, arg2, arg3, arg4, &arg5, &gError)

	var ret0 **MatchInfo
	var goError error

	{
		ret0 = WrapMatchInfo(unsafe.Pointer(arg5))
		runtime.SetFinalizer(ret0, func(v **MatchInfo) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Ref increases reference count of @regex by 1.
func (regex *Regex) Ref() *Regex {
	var arg0 *C.GRegex

	arg0 = (*C.GRegex)(regex.Native())

	ret := C.g_regex_ref(arg0)

	var ret0 *Regex

	{
		ret0 = WrapRegex(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Regex) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Replace replaces all occurrences of the pattern in @regex with the
// replacement text. Backreferences of the form '\number' or '\g<number>' in the
// replacement text are interpolated by the number-th captured subexpression of
// the match, '\g<name>' refers to the captured subexpression with the given
// name. '\0' refers to the complete match, but '\0' followed by a number is the
// octal representation of a character. To include a literal '\' in the
// replacement, write '\\\\'.
//
// There are also escapes that changes the case of the following text:
//
// - \l: Convert to lower case the next character - \u: Convert to upper case
// the next character - \L: Convert to lower case till \E - \U: Convert to upper
// case till \E - \E: End case modification
//
// If you do not need to use backreferences use g_regex_replace_literal().
//
// The @replacement string must be UTF-8 encoded even if REGEX_RAW was passed to
// g_regex_new(). If you want to use not UTF-8 encoded strings you can use
// g_regex_replace_literal().
//
// Setting @start_position differs from just passing over a shortened string and
// setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind
// of lookbehind assertion, such as "\b".
func (regex *Regex) Replace(string []string, startPosition int, replacement string, matchOptions RegexMatchFlags) (utf8 string, err error) {
	var arg0 *C.GRegex
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 C.gint
	var arg4 *C.gchar
	var arg5 C.GRegexMatchFlags
	var gError *C.GError

	arg0 = (*C.GRegex)(regex.Native())
	{
		var dst []C.gchar
		ptr := C.malloc(C.sizeof_gchar * len(string))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(string)
		sliceHeader.Cap = len(string)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(string); i++ {
			src := string[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg1 = (*C.gchar)(unsafe.Pointer(ptr))
		arg2 = len(string)
	}
	arg3 = C.gint(startPosition)
	arg4 = (*C.gchar)(C.CString(replacement))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (C.GRegexMatchFlags)(matchOptions)

	ret := C.g_regex_replace(arg0, arg1, arg2, arg3, arg4, arg5, &gError)

	var ret0 string
	var goError error

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// ReplaceEval replaces occurrences of the pattern in regex with the output of
// @eval for that occurrence.
//
// Setting @start_position differs from just passing over a shortened string and
// setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind
// of lookbehind assertion, such as "\b".
//
// The following example uses g_regex_replace_eval() to replace multiple strings
// at once:
//
//    static gboolean
//    eval_cb (const GMatchInfo *info,
//             GString          *res,
//             gpointer          data)
//    {
//      gchar *match;
//      gchar *r;
//
//       match = g_match_info_fetch (info, 0);
//       r = g_hash_table_lookup ((GHashTable *)data, match);
//       g_string_append (res, r);
//       g_free (match);
//
//       return FALSE;
//    }
//
//    ...
//
//    GRegex *reg;
//    GHashTable *h;
//    gchar *res;
//
//    h = g_hash_table_new (g_str_hash, g_str_equal);
//
//    g_hash_table_insert (h, "1", "ONE");
//    g_hash_table_insert (h, "2", "TWO");
//    g_hash_table_insert (h, "3", "THREE");
//    g_hash_table_insert (h, "4", "FOUR");
//
//    reg = g_regex_new ("1|2|3|4", 0, 0, NULL);
//    res = g_regex_replace_eval (reg, text, -1, 0, 0, eval_cb, h, NULL);
//    g_hash_table_destroy (h);
//
//    ...
func (regex *Regex) ReplaceEval(string []string, startPosition int, matchOptions RegexMatchFlags, eval RegexEvalCallback) (utf8 string, err error) {
	var arg0 *C.GRegex
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 C.gint
	var arg4 C.GRegexMatchFlags
	var arg5 C.GRegexEvalCallback
	var arg6 C.gpointer
	var gError *C.GError

	arg0 = (*C.GRegex)(regex.Native())
	{
		var dst []C.gchar
		ptr := C.malloc(C.sizeof_gchar * len(string))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(string)
		sliceHeader.Cap = len(string)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(string); i++ {
			src := string[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg1 = (*C.gchar)(unsafe.Pointer(ptr))
		arg2 = len(string)
	}
	arg3 = C.gint(startPosition)
	arg4 = (C.GRegexMatchFlags)(matchOptions)
	arg5 = (*[0]byte)(C.gotk4_RegexEvalCallback)
	arg6 = C.gpointer(box.Assign(eval))

	ret := C.g_regex_replace_eval(arg0, arg1, arg2, arg3, arg4, arg5, arg6, &gError)

	var ret0 string
	var goError error

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// ReplaceLiteral replaces all occurrences of the pattern in @regex with the
// replacement text. @replacement is replaced literally, to include
// backreferences use g_regex_replace().
//
// Setting @start_position differs from just passing over a shortened string and
// setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind
// of lookbehind assertion, such as "\b".
func (regex *Regex) ReplaceLiteral(string []string, startPosition int, replacement string, matchOptions RegexMatchFlags) (utf8 string, err error) {
	var arg0 *C.GRegex
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 C.gint
	var arg4 *C.gchar
	var arg5 C.GRegexMatchFlags
	var gError *C.GError

	arg0 = (*C.GRegex)(regex.Native())
	{
		var dst []C.gchar
		ptr := C.malloc(C.sizeof_gchar * len(string))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(string)
		sliceHeader.Cap = len(string)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(string); i++ {
			src := string[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg1 = (*C.gchar)(unsafe.Pointer(ptr))
		arg2 = len(string)
	}
	arg3 = C.gint(startPosition)
	arg4 = (*C.gchar)(C.CString(replacement))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (C.GRegexMatchFlags)(matchOptions)

	ret := C.g_regex_replace_literal(arg0, arg1, arg2, arg3, arg4, arg5, &gError)

	var ret0 string
	var goError error

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Split breaks the string on the pattern, and returns an array of the tokens.
// If the pattern contains capturing parentheses, then the text for each of the
// substrings will also be returned. If the pattern does not match anywhere in
// the string, then the whole string is returned as the first token.
//
// As a special case, the result of splitting the empty string "" is an empty
// vector, not a vector containing a single string. The reason for this special
// case is that being able to represent an empty vector is typically more useful
// than consistent handling of empty elements. If you do need to represent empty
// elements, you'll need to check for the empty string before calling this
// function.
//
// A pattern that can match empty strings splits @string into separate
// characters wherever it matches the empty string between characters. For
// example splitting "ab c" using as a separator "\s*", you will get "a", "b"
// and "c".
func (regex *Regex) Split(string string, matchOptions RegexMatchFlags) []string {
	var arg0 *C.GRegex
	var arg1 *C.gchar
	var arg2 C.GRegexMatchFlags

	arg0 = (*C.GRegex)(regex.Native())
	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GRegexMatchFlags)(matchOptions)

	ret := C.g_regex_split(arg0, arg1, arg2)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// SplitFull breaks the string on the pattern, and returns an array of the
// tokens. If the pattern contains capturing parentheses, then the text for each
// of the substrings will also be returned. If the pattern does not match
// anywhere in the string, then the whole string is returned as the first token.
//
// As a special case, the result of splitting the empty string "" is an empty
// vector, not a vector containing a single string. The reason for this special
// case is that being able to represent an empty vector is typically more useful
// than consistent handling of empty elements. If you do need to represent empty
// elements, you'll need to check for the empty string before calling this
// function.
//
// A pattern that can match empty strings splits @string into separate
// characters wherever it matches the empty string between characters. For
// example splitting "ab c" using as a separator "\s*", you will get "a", "b"
// and "c".
//
// Setting @start_position differs from just passing over a shortened string and
// setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind
// of lookbehind assertion, such as "\b".
func (regex *Regex) SplitFull(string []string, startPosition int, matchOptions RegexMatchFlags, maxTokens int) (utf8s []string, err error) {
	var arg0 *C.GRegex
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 C.gint
	var arg4 C.GRegexMatchFlags
	var arg5 C.gint
	var gError *C.GError

	arg0 = (*C.GRegex)(regex.Native())
	{
		var dst []C.gchar
		ptr := C.malloc(C.sizeof_gchar * len(string))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(string)
		sliceHeader.Cap = len(string)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(string); i++ {
			src := string[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg1 = (*C.gchar)(unsafe.Pointer(ptr))
		arg2 = len(string)
	}
	arg3 = C.gint(startPosition)
	arg4 = (C.GRegexMatchFlags)(matchOptions)
	arg5 = C.gint(maxTokens)

	ret := C.g_regex_split_full(arg0, arg1, arg2, arg3, arg4, arg5, &gError)

	var ret0 []string
	var goError error

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Unref decreases reference count of @regex by 1. When reference count drops to
// zero, it frees all the memory associated with the regex structure.
func (regex *Regex) Unref() {
	var arg0 *C.GRegex

	arg0 = (*C.GRegex)(regex.Native())

	C.g_regex_unref(arg0)
}

// SList: the List struct is used for each element in the singly-linked list.
type SList struct {
	native C.GSList
}

// WrapSList wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSList(ptr unsafe.Pointer) *SList {
	if ptr == nil {
		return nil
	}

	return (*SList)(ptr)
}

func marshalSList(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSList(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *SList) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// Data gets the field inside the struct.
func (s *SList) Data() interface{} {
	var ret interface{}
	ret = box.Get(uintptr(s.native.data))
	return ret
}

// Next gets the field inside the struct.
func (s *SList) Next() *SList {
	var ret *SList
	{
		ret = WrapSList(unsafe.Pointer(s.native.next))
	}
	return ret
}

// Scanner: the data structure representing a lexical scanner.
//
// You should set @input_name after creating the scanner, since it is used by
// the default message handler when displaying warnings and errors. If you are
// scanning a file, the filename would be a good choice.
//
// The @user_data and @max_parse_errors fields are not used. If you need to
// associate extra data with the scanner you can place them here.
//
// If you want to use your own message handler you can set the @msg_handler
// field. The type of the message handler function is declared by MsgFunc.
type Scanner struct {
	native C.GScanner
}

// WrapScanner wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapScanner(ptr unsafe.Pointer) *Scanner {
	if ptr == nil {
		return nil
	}

	return (*Scanner)(ptr)
}

func marshalScanner(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapScanner(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *Scanner) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// UserData gets the field inside the struct.
func (s *Scanner) UserData() interface{} {
	var ret interface{}
	ret = box.Get(uintptr(s.native.user_data))
	return ret
}

// MaxParseErrors gets the field inside the struct.
func (s *Scanner) MaxParseErrors() uint {
	var ret uint
	ret = uint(s.native.max_parse_errors)
	return ret
}

// ParseErrors gets the field inside the struct.
func (s *Scanner) ParseErrors() uint {
	var ret uint
	ret = uint(s.native.parse_errors)
	return ret
}

// InputName gets the field inside the struct.
func (s *Scanner) InputName() string {
	var ret string
	ret = C.GoString(s.native.input_name)
	return ret
}

// Qdata gets the field inside the struct.
func (s *Scanner) Qdata() *Data {
	var ret *Data
	{
		ret = WrapData(unsafe.Pointer(s.native.qdata))
	}
	return ret
}

// Config gets the field inside the struct.
func (s *Scanner) Config() *ScannerConfig {
	var ret *ScannerConfig
	{
		ret = WrapScannerConfig(unsafe.Pointer(s.native.config))
	}
	return ret
}

// Token gets the field inside the struct.
func (s *Scanner) Token() TokenType {
	var ret TokenType
	ret = TokenType(s.native.token)
	return ret
}

// Line gets the field inside the struct.
func (s *Scanner) Line() uint {
	var ret uint
	ret = uint(s.native.line)
	return ret
}

// Position gets the field inside the struct.
func (s *Scanner) Position() uint {
	var ret uint
	ret = uint(s.native.position)
	return ret
}

// NextLine gets the field inside the struct.
func (s *Scanner) NextLine() uint {
	var ret uint
	ret = uint(s.native.next_line)
	return ret
}

// NextPosition gets the field inside the struct.
func (s *Scanner) NextPosition() uint {
	var ret uint
	ret = uint(s.native.next_position)
	return ret
}

// CurLine returns the current line in the input stream (counting from 1). This
// is the line of the last token parsed via g_scanner_get_next_token().
func (scanner *Scanner) CurLine() uint {
	var arg0 *C.GScanner

	arg0 = (*C.GScanner)(scanner.Native())

	ret := C.g_scanner_cur_line(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// CurPosition returns the current position in the current line (counting from
// 0). This is the position of the last token parsed via
// g_scanner_get_next_token().
func (scanner *Scanner) CurPosition() uint {
	var arg0 *C.GScanner

	arg0 = (*C.GScanner)(scanner.Native())

	ret := C.g_scanner_cur_position(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// CurToken gets the current token type. This is simply the @token field in the
// #GScanner structure.
func (scanner *Scanner) CurToken() TokenType {
	var arg0 *C.GScanner

	arg0 = (*C.GScanner)(scanner.Native())

	ret := C.g_scanner_cur_token(arg0)

	var ret0 TokenType

	ret0 = TokenType(ret)

	return ret0
}

// Destroy frees all memory used by the #GScanner.
func (scanner *Scanner) Destroy() {
	var arg0 *C.GScanner

	arg0 = (*C.GScanner)(scanner.Native())

	C.g_scanner_destroy(arg0)
}

// EOF returns true if the scanner has reached the end of the file or text
// buffer.
func (scanner *Scanner) EOF() bool {
	var arg0 *C.GScanner

	arg0 = (*C.GScanner)(scanner.Native())

	ret := C.g_scanner_eof(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// NextToken parses the next token just like g_scanner_peek_next_token() and
// also removes it from the input stream. The token data is placed in the
// @token, @value, @line, and @position fields of the #GScanner structure.
func (scanner *Scanner) NextToken() TokenType {
	var arg0 *C.GScanner

	arg0 = (*C.GScanner)(scanner.Native())

	ret := C.g_scanner_get_next_token(arg0)

	var ret0 TokenType

	ret0 = TokenType(ret)

	return ret0
}

// InputFile prepares to scan a file.
func (scanner *Scanner) InputFile(inputFd int) {
	var arg0 *C.GScanner
	var arg1 C.gint

	arg0 = (*C.GScanner)(scanner.Native())
	arg1 = C.gint(inputFd)

	C.g_scanner_input_file(arg0, arg1)
}

// InputText prepares to scan a text buffer.
func (scanner *Scanner) InputText(text string, textLen uint) {
	var arg0 *C.GScanner
	var arg1 *C.gchar
	var arg2 C.guint

	arg0 = (*C.GScanner)(scanner.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.guint(textLen)

	C.g_scanner_input_text(arg0, arg1, arg2)
}

// LookupSymbol looks up a symbol in the current scope and return its value. If
// the symbol is not bound in the current scope, nil is returned.
func (scanner *Scanner) LookupSymbol(symbol string) interface{} {
	var arg0 *C.GScanner
	var arg1 *C.gchar

	arg0 = (*C.GScanner)(scanner.Native())
	arg1 = (*C.gchar)(C.CString(symbol))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_scanner_lookup_symbol(arg0, arg1)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// PeekNextToken parses the next token, without removing it from the input
// stream. The token data is placed in the @next_token, @next_value, @next_line,
// and @next_position fields of the #GScanner structure.
//
// Note that, while the token is not removed from the input stream (i.e. the
// next call to g_scanner_get_next_token() will return the same token), it will
// not be reevaluated. This can lead to surprising results when changing scope
// or the scanner configuration after peeking the next token. Getting the next
// token after switching the scope or configuration will return whatever was
// peeked before, regardless of any symbols that may have been added or removed
// in the new scope.
func (scanner *Scanner) PeekNextToken() TokenType {
	var arg0 *C.GScanner

	arg0 = (*C.GScanner)(scanner.Native())

	ret := C.g_scanner_peek_next_token(arg0)

	var ret0 TokenType

	ret0 = TokenType(ret)

	return ret0
}

// ScopeAddSymbol adds a symbol to the given scope.
func (scanner *Scanner) ScopeAddSymbol(scopeID uint, symbol string, value interface{}) {
	var arg0 *C.GScanner
	var arg1 C.guint
	var arg2 *C.gchar
	var arg3 C.gpointer

	arg0 = (*C.GScanner)(scanner.Native())
	arg1 = C.guint(scopeID)
	arg2 = (*C.gchar)(C.CString(symbol))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.gpointer(box.Assign(value))

	C.g_scanner_scope_add_symbol(arg0, arg1, arg2, arg3)
}

// ScopeForeachSymbol calls the given function for each of the symbol/value
// pairs in the given scope of the #GScanner. The function is passed the symbol
// and value of each pair, and the given @user_data parameter.
func (scanner *Scanner) ScopeForeachSymbol(scopeID uint, fn HFunc) {
	var arg0 *C.GScanner
	var arg1 C.guint
	var arg2 C.GHFunc
	var arg3 C.gpointer

	arg0 = (*C.GScanner)(scanner.Native())
	arg1 = C.guint(scopeID)
	arg2 = (*[0]byte)(C.gotk4_HFunc)
	arg3 = C.gpointer(box.Assign(fn))

	C.g_scanner_scope_foreach_symbol(arg0, arg1, arg2, arg3)
}

// ScopeLookupSymbol looks up a symbol in a scope and return its value. If the
// symbol is not bound in the scope, nil is returned.
func (scanner *Scanner) ScopeLookupSymbol(scopeID uint, symbol string) interface{} {
	var arg0 *C.GScanner
	var arg1 C.guint
	var arg2 *C.gchar

	arg0 = (*C.GScanner)(scanner.Native())
	arg1 = C.guint(scopeID)
	arg2 = (*C.gchar)(C.CString(symbol))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_scanner_scope_lookup_symbol(arg0, arg1, arg2)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// ScopeRemoveSymbol removes a symbol from a scope.
func (scanner *Scanner) ScopeRemoveSymbol(scopeID uint, symbol string) {
	var arg0 *C.GScanner
	var arg1 C.guint
	var arg2 *C.gchar

	arg0 = (*C.GScanner)(scanner.Native())
	arg1 = C.guint(scopeID)
	arg2 = (*C.gchar)(C.CString(symbol))
	defer C.free(unsafe.Pointer(arg2))

	C.g_scanner_scope_remove_symbol(arg0, arg1, arg2)
}

// SetScope sets the current scope.
func (scanner *Scanner) SetScope(scopeID uint) uint {
	var arg0 *C.GScanner
	var arg1 C.guint

	arg0 = (*C.GScanner)(scanner.Native())
	arg1 = C.guint(scopeID)

	ret := C.g_scanner_set_scope(arg0, arg1)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// SyncFileOffset rewinds the filedescriptor to the current buffer position and
// blows the file read ahead buffer. This is useful for third party uses of the
// scanners filedescriptor, which hooks onto the current scanning position.
func (scanner *Scanner) SyncFileOffset() {
	var arg0 *C.GScanner

	arg0 = (*C.GScanner)(scanner.Native())

	C.g_scanner_sync_file_offset(arg0)
}

// UnexpToken outputs a message through the scanner's msg_handler, resulting
// from an unexpected token in the input stream. Note that you should not call
// g_scanner_peek_next_token() followed by g_scanner_unexp_token() without an
// intermediate call to g_scanner_get_next_token(), as g_scanner_unexp_token()
// evaluates the scanner's current token (not the peeked token) to construct
// part of the message.
func (scanner *Scanner) UnexpToken(expectedToken TokenType, identifierSpec string, symbolSpec string, symbolName string, message string, isError int) {
	var arg0 *C.GScanner
	var arg1 C.GTokenType
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 *C.gchar
	var arg5 *C.gchar
	var arg6 C.gint

	arg0 = (*C.GScanner)(scanner.Native())
	arg1 = (C.GTokenType)(expectedToken)
	arg2 = (*C.gchar)(C.CString(identifierSpec))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(symbolSpec))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gchar)(C.CString(symbolName))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.gchar)(C.CString(message))
	defer C.free(unsafe.Pointer(arg5))
	arg6 = C.gint(isError)

	C.g_scanner_unexp_token(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
}

// ScannerConfig specifies the #GScanner parser configuration. Most settings can
// be changed during the parsing phase and will affect the lexical parsing of
// the next unpeeked token.
type ScannerConfig struct {
	native C.GScannerConfig
}

// WrapScannerConfig wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapScannerConfig(ptr unsafe.Pointer) *ScannerConfig {
	if ptr == nil {
		return nil
	}

	return (*ScannerConfig)(ptr)
}

func marshalScannerConfig(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapScannerConfig(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *ScannerConfig) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// CsetSkipCharacters gets the field inside the struct.
func (s *ScannerConfig) CsetSkipCharacters() string {
	var ret string
	ret = C.GoString(s.native.cset_skip_characters)
	return ret
}

// CsetIdentifierFirst gets the field inside the struct.
func (s *ScannerConfig) CsetIdentifierFirst() string {
	var ret string
	ret = C.GoString(s.native.cset_identifier_first)
	return ret
}

// CsetIdentifierNth gets the field inside the struct.
func (s *ScannerConfig) CsetIdentifierNth() string {
	var ret string
	ret = C.GoString(s.native.cset_identifier_nth)
	return ret
}

// CpairCommentSingle gets the field inside the struct.
func (s *ScannerConfig) CpairCommentSingle() string {
	var ret string
	ret = C.GoString(s.native.cpair_comment_single)
	return ret
}

// Sequence: the #GSequence struct is an opaque data type representing a
// [sequence][glib-Sequences] data type.
type Sequence struct {
	native C.GSequence
}

// WrapSequence wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSequence(ptr unsafe.Pointer) *Sequence {
	if ptr == nil {
		return nil
	}

	return (*Sequence)(ptr)
}

func marshalSequence(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSequence(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *Sequence) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// Append adds a new item to the end of @seq.
func (seq *Sequence) Append(data interface{}) *SequenceIter {
	var arg0 *C.GSequence
	var arg1 C.gpointer

	arg0 = (*C.GSequence)(seq.Native())
	arg1 = C.gpointer(box.Assign(data))

	ret := C.g_sequence_append(arg0, arg1)

	var ret0 *SequenceIter

	{
		ret0 = WrapSequenceIter(unsafe.Pointer(ret))
	}

	return ret0
}

// Foreach calls @func for each item in the sequence passing @user_data to the
// function. @func must not modify the sequence itself.
func (seq *Sequence) Foreach(fn Func) {
	var arg0 *C.GSequence
	var arg1 C.GFunc
	var arg2 C.gpointer

	arg0 = (*C.GSequence)(seq.Native())
	arg1 = (*[0]byte)(C.gotk4_Func)
	arg2 = C.gpointer(box.Assign(fn))

	C.g_sequence_foreach(arg0, arg1, arg2)
}

// Free frees the memory allocated for @seq. If @seq has a data destroy function
// associated with it, that function is called on all items in @seq.
func (seq *Sequence) Free() {
	var arg0 *C.GSequence

	arg0 = (*C.GSequence)(seq.Native())

	C.g_sequence_free(arg0)
}

// BeginIter returns the begin iterator for @seq.
func (seq *Sequence) BeginIter() *SequenceIter {
	var arg0 *C.GSequence

	arg0 = (*C.GSequence)(seq.Native())

	ret := C.g_sequence_get_begin_iter(arg0)

	var ret0 *SequenceIter

	{
		ret0 = WrapSequenceIter(unsafe.Pointer(ret))
	}

	return ret0
}

// EndIter returns the end iterator for @seg
func (seq *Sequence) EndIter() *SequenceIter {
	var arg0 *C.GSequence

	arg0 = (*C.GSequence)(seq.Native())

	ret := C.g_sequence_get_end_iter(arg0)

	var ret0 *SequenceIter

	{
		ret0 = WrapSequenceIter(unsafe.Pointer(ret))
	}

	return ret0
}

// IterAtPos returns the iterator at position @pos. If @pos is negative or
// larger than the number of items in @seq, the end iterator is returned.
func (seq *Sequence) IterAtPos(pos int) *SequenceIter {
	var arg0 *C.GSequence
	var arg1 C.gint

	arg0 = (*C.GSequence)(seq.Native())
	arg1 = C.gint(pos)

	ret := C.g_sequence_get_iter_at_pos(arg0, arg1)

	var ret0 *SequenceIter

	{
		ret0 = WrapSequenceIter(unsafe.Pointer(ret))
	}

	return ret0
}

// Length returns the length of @seq. Note that this method is O(h) where `h' is
// the height of the tree. It is thus more efficient to use
// g_sequence_is_empty() when comparing the length to zero.
func (seq *Sequence) Length() int {
	var arg0 *C.GSequence

	arg0 = (*C.GSequence)(seq.Native())

	ret := C.g_sequence_get_length(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// InsertSorted inserts @data into @seq using @cmp_func to determine the new
// position. The sequence must already be sorted according to @cmp_func;
// otherwise the new position of @data is undefined.
//
// @cmp_func is called with two items of the @seq, and @cmp_data. It should
// return 0 if the items are equal, a negative value if the first item comes
// before the second, and a positive value if the second item comes before the
// first.
//
// Note that when adding a large amount of data to a #GSequence, it is more
// efficient to do unsorted insertions and then call g_sequence_sort() or
// g_sequence_sort_iter().
func (seq *Sequence) InsertSorted(data interface{}, cmpFunc CompareDataFunc) *SequenceIter {
	var arg0 *C.GSequence
	var arg1 C.gpointer
	var arg2 C.GCompareDataFunc
	var arg3 C.gpointer

	arg0 = (*C.GSequence)(seq.Native())
	arg1 = C.gpointer(box.Assign(data))
	arg2 = (*[0]byte)(C.gotk4_CompareDataFunc)
	arg3 = C.gpointer(box.Assign(cmpFunc))

	ret := C.g_sequence_insert_sorted(arg0, arg1, arg2, arg3)

	var ret0 *SequenceIter

	{
		ret0 = WrapSequenceIter(unsafe.Pointer(ret))
	}

	return ret0
}

// InsertSortedIter: like g_sequence_insert_sorted(), but uses a IterCompareFunc
// instead of a DataFunc as the compare function.
//
// @iter_cmp is called with two iterators pointing into @seq. It should return 0
// if the iterators are equal, a negative value if the first iterator comes
// before the second, and a positive value if the second iterator comes before
// the first.
//
// Note that when adding a large amount of data to a #GSequence, it is more
// efficient to do unsorted insertions and then call g_sequence_sort() or
// g_sequence_sort_iter().
func (seq *Sequence) InsertSortedIter(data interface{}, iterCmp SequenceIterCompareFunc) *SequenceIter {
	var arg0 *C.GSequence
	var arg1 C.gpointer
	var arg2 C.GSequenceIterCompareFunc
	var arg3 C.gpointer

	arg0 = (*C.GSequence)(seq.Native())
	arg1 = C.gpointer(box.Assign(data))
	arg2 = (*[0]byte)(C.gotk4_SequenceIterCompareFunc)
	arg3 = C.gpointer(box.Assign(iterCmp))

	ret := C.g_sequence_insert_sorted_iter(arg0, arg1, arg2, arg3)

	var ret0 *SequenceIter

	{
		ret0 = WrapSequenceIter(unsafe.Pointer(ret))
	}

	return ret0
}

// IsEmpty returns true if the sequence contains zero items.
//
// This function is functionally identical to checking the result of
// g_sequence_get_length() being equal to zero. However this function is
// implemented in O(1) running time.
func (seq *Sequence) IsEmpty() bool {
	var arg0 *C.GSequence

	arg0 = (*C.GSequence)(seq.Native())

	ret := C.g_sequence_is_empty(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Lookup returns an iterator pointing to the position of the first item found
// equal to @data according to @cmp_func and @cmp_data. If more than one item is
// equal, it is not guaranteed that it is the first which is returned. In that
// case, you can use g_sequence_iter_next() and g_sequence_iter_prev() to get
// others.
//
// @cmp_func is called with two items of the @seq, and @cmp_data. It should
// return 0 if the items are equal, a negative value if the first item comes
// before the second, and a positive value if the second item comes before the
// first.
//
// This function will fail if the data contained in the sequence is unsorted.
func (seq *Sequence) Lookup(data interface{}, cmpFunc CompareDataFunc) *SequenceIter {
	var arg0 *C.GSequence
	var arg1 C.gpointer
	var arg2 C.GCompareDataFunc
	var arg3 C.gpointer

	arg0 = (*C.GSequence)(seq.Native())
	arg1 = C.gpointer(box.Assign(data))
	arg2 = (*[0]byte)(C.gotk4_CompareDataFunc)
	arg3 = C.gpointer(box.Assign(cmpFunc))

	ret := C.g_sequence_lookup(arg0, arg1, arg2, arg3)

	var ret0 *SequenceIter

	{
		ret0 = WrapSequenceIter(unsafe.Pointer(ret))
	}

	return ret0
}

// LookupIter: like g_sequence_lookup(), but uses a IterCompareFunc instead of a
// DataFunc as the compare function.
//
// @iter_cmp is called with two iterators pointing into @seq. It should return 0
// if the iterators are equal, a negative value if the first iterator comes
// before the second, and a positive value if the second iterator comes before
// the first.
//
// This function will fail if the data contained in the sequence is unsorted.
func (seq *Sequence) LookupIter(data interface{}, iterCmp SequenceIterCompareFunc) *SequenceIter {
	var arg0 *C.GSequence
	var arg1 C.gpointer
	var arg2 C.GSequenceIterCompareFunc
	var arg3 C.gpointer

	arg0 = (*C.GSequence)(seq.Native())
	arg1 = C.gpointer(box.Assign(data))
	arg2 = (*[0]byte)(C.gotk4_SequenceIterCompareFunc)
	arg3 = C.gpointer(box.Assign(iterCmp))

	ret := C.g_sequence_lookup_iter(arg0, arg1, arg2, arg3)

	var ret0 *SequenceIter

	{
		ret0 = WrapSequenceIter(unsafe.Pointer(ret))
	}

	return ret0
}

// Prepend adds a new item to the front of @seq
func (seq *Sequence) Prepend(data interface{}) *SequenceIter {
	var arg0 *C.GSequence
	var arg1 C.gpointer

	arg0 = (*C.GSequence)(seq.Native())
	arg1 = C.gpointer(box.Assign(data))

	ret := C.g_sequence_prepend(arg0, arg1)

	var ret0 *SequenceIter

	{
		ret0 = WrapSequenceIter(unsafe.Pointer(ret))
	}

	return ret0
}

// Search returns an iterator pointing to the position where @data would be
// inserted according to @cmp_func and @cmp_data.
//
// @cmp_func is called with two items of the @seq, and @cmp_data. It should
// return 0 if the items are equal, a negative value if the first item comes
// before the second, and a positive value if the second item comes before the
// first.
//
// If you are simply searching for an existing element of the sequence, consider
// using g_sequence_lookup().
//
// This function will fail if the data contained in the sequence is unsorted.
func (seq *Sequence) Search(data interface{}, cmpFunc CompareDataFunc) *SequenceIter {
	var arg0 *C.GSequence
	var arg1 C.gpointer
	var arg2 C.GCompareDataFunc
	var arg3 C.gpointer

	arg0 = (*C.GSequence)(seq.Native())
	arg1 = C.gpointer(box.Assign(data))
	arg2 = (*[0]byte)(C.gotk4_CompareDataFunc)
	arg3 = C.gpointer(box.Assign(cmpFunc))

	ret := C.g_sequence_search(arg0, arg1, arg2, arg3)

	var ret0 *SequenceIter

	{
		ret0 = WrapSequenceIter(unsafe.Pointer(ret))
	}

	return ret0
}

// SearchIter: like g_sequence_search(), but uses a IterCompareFunc instead of a
// DataFunc as the compare function.
//
// @iter_cmp is called with two iterators pointing into @seq. It should return 0
// if the iterators are equal, a negative value if the first iterator comes
// before the second, and a positive value if the second iterator comes before
// the first.
//
// If you are simply searching for an existing element of the sequence, consider
// using g_sequence_lookup_iter().
//
// This function will fail if the data contained in the sequence is unsorted.
func (seq *Sequence) SearchIter(data interface{}, iterCmp SequenceIterCompareFunc) *SequenceIter {
	var arg0 *C.GSequence
	var arg1 C.gpointer
	var arg2 C.GSequenceIterCompareFunc
	var arg3 C.gpointer

	arg0 = (*C.GSequence)(seq.Native())
	arg1 = C.gpointer(box.Assign(data))
	arg2 = (*[0]byte)(C.gotk4_SequenceIterCompareFunc)
	arg3 = C.gpointer(box.Assign(iterCmp))

	ret := C.g_sequence_search_iter(arg0, arg1, arg2, arg3)

	var ret0 *SequenceIter

	{
		ret0 = WrapSequenceIter(unsafe.Pointer(ret))
	}

	return ret0
}

// Sort sorts @seq using @cmp_func.
//
// @cmp_func is passed two items of @seq and should return 0 if they are equal,
// a negative value if the first comes before the second, and a positive value
// if the second comes before the first.
func (seq *Sequence) Sort(cmpFunc CompareDataFunc) {
	var arg0 *C.GSequence
	var arg1 C.GCompareDataFunc
	var arg2 C.gpointer

	arg0 = (*C.GSequence)(seq.Native())
	arg1 = (*[0]byte)(C.gotk4_CompareDataFunc)
	arg2 = C.gpointer(box.Assign(cmpFunc))

	C.g_sequence_sort(arg0, arg1, arg2)
}

// SortIter: like g_sequence_sort(), but uses a IterCompareFunc instead of a
// DataFunc as the compare function
//
// @cmp_func is called with two iterators pointing into @seq. It should return 0
// if the iterators are equal, a negative value if the first iterator comes
// before the second, and a positive value if the second iterator comes before
// the first.
func (seq *Sequence) SortIter(cmpFunc SequenceIterCompareFunc) {
	var arg0 *C.GSequence
	var arg1 C.GSequenceIterCompareFunc
	var arg2 C.gpointer

	arg0 = (*C.GSequence)(seq.Native())
	arg1 = (*[0]byte)(C.gotk4_SequenceIterCompareFunc)
	arg2 = C.gpointer(box.Assign(cmpFunc))

	C.g_sequence_sort_iter(arg0, arg1, arg2)
}

// SequenceIter: the Iter struct is an opaque data type representing an iterator
// pointing into a #GSequence.
type SequenceIter struct {
	native C.GSequenceIter
}

// WrapSequenceIter wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSequenceIter(ptr unsafe.Pointer) *SequenceIter {
	if ptr == nil {
		return nil
	}

	return (*SequenceIter)(ptr)
}

func marshalSequenceIter(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSequenceIter(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *SequenceIter) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// Compare returns a negative number if @a comes before @b, 0 if they are equal,
// and a positive number if @a comes after @b.
//
// The @a and @b iterators must point into the same sequence.
func (a *SequenceIter) Compare(b *SequenceIter) int {
	var arg0 *C.GSequenceIter
	var arg1 *C.GSequenceIter

	arg0 = (*C.GSequenceIter)(a.Native())
	arg1 = (*C.GSequenceIter)(b.Native())

	ret := C.g_sequence_iter_compare(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Position returns the position of @iter
func (iter *SequenceIter) Position() int {
	var arg0 *C.GSequenceIter

	arg0 = (*C.GSequenceIter)(iter.Native())

	ret := C.g_sequence_iter_get_position(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Sequence returns the #GSequence that @iter points into.
func (iter *SequenceIter) Sequence() *Sequence {
	var arg0 *C.GSequenceIter

	arg0 = (*C.GSequenceIter)(iter.Native())

	ret := C.g_sequence_iter_get_sequence(arg0)

	var ret0 *Sequence

	{
		ret0 = WrapSequence(unsafe.Pointer(ret))
	}

	return ret0
}

// IsBegin returns whether @iter is the begin iterator
func (iter *SequenceIter) IsBegin() bool {
	var arg0 *C.GSequenceIter

	arg0 = (*C.GSequenceIter)(iter.Native())

	ret := C.g_sequence_iter_is_begin(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IsEnd returns whether @iter is the end iterator
func (iter *SequenceIter) IsEnd() bool {
	var arg0 *C.GSequenceIter

	arg0 = (*C.GSequenceIter)(iter.Native())

	ret := C.g_sequence_iter_is_end(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Move returns the Iter which is @delta positions away from @iter. If @iter is
// closer than -@delta positions to the beginning of the sequence, the begin
// iterator is returned. If @iter is closer than @delta positions to the end of
// the sequence, the end iterator is returned.
func (iter *SequenceIter) Move(delta int) *SequenceIter {
	var arg0 *C.GSequenceIter
	var arg1 C.gint

	arg0 = (*C.GSequenceIter)(iter.Native())
	arg1 = C.gint(delta)

	ret := C.g_sequence_iter_move(arg0, arg1)

	var ret0 *SequenceIter

	{
		ret0 = WrapSequenceIter(unsafe.Pointer(ret))
	}

	return ret0
}

// Next returns an iterator pointing to the next position after @iter. If @iter
// is the end iterator, the end iterator is returned.
func (iter *SequenceIter) Next() *SequenceIter {
	var arg0 *C.GSequenceIter

	arg0 = (*C.GSequenceIter)(iter.Native())

	ret := C.g_sequence_iter_next(arg0)

	var ret0 *SequenceIter

	{
		ret0 = WrapSequenceIter(unsafe.Pointer(ret))
	}

	return ret0
}

// Prev returns an iterator pointing to the previous position before @iter. If
// @iter is the begin iterator, the begin iterator is returned.
func (iter *SequenceIter) Prev() *SequenceIter {
	var arg0 *C.GSequenceIter

	arg0 = (*C.GSequenceIter)(iter.Native())

	ret := C.g_sequence_iter_prev(arg0)

	var ret0 *SequenceIter

	{
		ret0 = WrapSequenceIter(unsafe.Pointer(ret))
	}

	return ret0
}

// Source: the `GSource` struct is an opaque data type representing an event
// source.
type Source struct {
	native C.GSource
}

// WrapSource wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSource(ptr unsafe.Pointer) *Source {
	if ptr == nil {
		return nil
	}

	return (*Source)(ptr)
}

func marshalSource(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSource(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *Source) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// AddChildSource adds @child_source to @source as a "polled" source; when
// @source is added to a Context, @child_source will be automatically added with
// the same priority, when @child_source is triggered, it will cause @source to
// dispatch (in addition to calling its own callback), and when @source is
// destroyed, it will destroy @child_source as well. (@source will also still be
// dispatched if its own prepare/check functions indicate that it is ready.)
//
// If you don't need @child_source to do anything on its own when it triggers,
// you can call g_source_set_dummy_callback() on it to set a callback that does
// nothing (except return true if appropriate).
//
// @source will hold a reference on @child_source while @child_source is
// attached to it.
//
// This API is only intended to be used by implementations of #GSource. Do not
// call this API on a #GSource that you did not create.
func (source *Source) AddChildSource(childSource *Source) {
	var arg0 *C.GSource
	var arg1 *C.GSource

	arg0 = (*C.GSource)(source.Native())
	arg1 = (*C.GSource)(childSource.Native())

	C.g_source_add_child_source(arg0, arg1)
}

// AddPoll adds a file descriptor to the set of file descriptors polled for this
// source. This is usually combined with g_source_new() to add an event source.
// The event source's check function will typically test the @revents field in
// the FD struct and return true if events need to be processed.
//
// This API is only intended to be used by implementations of #GSource. Do not
// call this API on a #GSource that you did not create.
//
// Using this API forces the linear scanning of event sources on each main loop
// iteration. Newly-written event sources should try to use
// g_source_add_unix_fd() instead of this API.
func (source *Source) AddPoll(fd *PollFD) {
	var arg0 *C.GSource
	var arg1 *C.GPollFD

	arg0 = (*C.GSource)(source.Native())
	arg1 = (*C.GPollFD)(fd.Native())

	C.g_source_add_poll(arg0, arg1)
}

// AddUnixFd monitors @fd for the IO events in @events.
//
// The tag returned by this function can be used to remove or modify the
// monitoring of the fd using g_source_remove_unix_fd() or
// g_source_modify_unix_fd().
//
// It is not necessary to remove the fd before destroying the source; it will be
// cleaned up automatically.
//
// This API is only intended to be used by implementations of #GSource. Do not
// call this API on a #GSource that you did not create.
//
// As the name suggests, this function is not available on Windows.
func (source *Source) AddUnixFd(fd int, events IOCondition) interface{} {
	var arg0 *C.GSource
	var arg1 C.gint
	var arg2 C.GIOCondition

	arg0 = (*C.GSource)(source.Native())
	arg1 = C.gint(fd)
	arg2 = (C.GIOCondition)(events)

	ret := C.g_source_add_unix_fd(arg0, arg1, arg2)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// Attach adds a #GSource to a @context so that it will be executed within that
// context. Remove it by calling g_source_destroy().
//
// This function is safe to call from any thread, regardless of which thread the
// @context is running in.
func (source *Source) Attach(context *MainContext) uint {
	var arg0 *C.GSource
	var arg1 *C.GMainContext

	arg0 = (*C.GSource)(source.Native())
	arg1 = (*C.GMainContext)(context.Native())

	ret := C.g_source_attach(arg0, arg1)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Destroy removes a source from its Context, if any, and mark it as destroyed.
// The source cannot be subsequently added to another context. It is safe to
// call this on sources which have already been removed from their context.
//
// This does not unref the #GSource: if you still hold a reference, use
// g_source_unref() to drop it.
//
// This function is safe to call from any thread, regardless of which thread the
// Context is running in.
func (source *Source) Destroy() {
	var arg0 *C.GSource

	arg0 = (*C.GSource)(source.Native())

	C.g_source_destroy(arg0)
}

// CanRecurse checks whether a source is allowed to be called recursively. see
// g_source_set_can_recurse().
func (source *Source) CanRecurse() bool {
	var arg0 *C.GSource

	arg0 = (*C.GSource)(source.Native())

	ret := C.g_source_get_can_recurse(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Context gets the Context with which the source is associated.
//
// You can call this on a source that has been destroyed, provided that the
// Context it was attached to still exists (in which case it will return that
// Context). In particular, you can always call this function on the source
// returned from g_main_current_source(). But calling this function on a source
// whose Context has been destroyed is an error.
func (source *Source) Context() *MainContext {
	var arg0 *C.GSource

	arg0 = (*C.GSource)(source.Native())

	ret := C.g_source_get_context(arg0)

	var ret0 *MainContext

	{
		ret0 = WrapMainContext(unsafe.Pointer(ret))
	}

	return ret0
}

// CurrentTime: this function ignores @source and is otherwise the same as
// g_get_current_time().
func (source *Source) CurrentTime(timeval *TimeVal) {
	var arg0 *C.GSource
	var arg1 *C.GTimeVal

	arg0 = (*C.GSource)(source.Native())
	arg1 = (*C.GTimeVal)(timeval.Native())

	C.g_source_get_current_time(arg0, arg1)
}

// ID returns the numeric ID for a particular source. The ID of a source is a
// positive integer which is unique within a particular main loop context. The
// reverse mapping from ID to source is done by
// g_main_context_find_source_by_id().
//
// You can only call this function while the source is associated to a Context
// instance; calling this function before g_source_attach() or after
// g_source_destroy() yields undefined behavior. The ID returned is unique
// within the Context instance passed to g_source_attach().
func (source *Source) ID() uint {
	var arg0 *C.GSource

	arg0 = (*C.GSource)(source.Native())

	ret := C.g_source_get_id(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Name gets a name for the source, used in debugging and profiling. The name
// may be LL if it has never been set with g_source_set_name().
func (source *Source) Name() string {
	var arg0 *C.GSource

	arg0 = (*C.GSource)(source.Native())

	ret := C.g_source_get_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Priority gets the priority of a source.
func (source *Source) Priority() int {
	var arg0 *C.GSource

	arg0 = (*C.GSource)(source.Native())

	ret := C.g_source_get_priority(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ReadyTime gets the "ready time" of @source, as set by
// g_source_set_ready_time().
//
// Any time before the current monotonic time (including 0) is an indication
// that the source will fire immediately.
func (source *Source) ReadyTime() int64 {
	var arg0 *C.GSource

	arg0 = (*C.GSource)(source.Native())

	ret := C.g_source_get_ready_time(arg0)

	var ret0 int64

	ret0 = int64(ret)

	return ret0
}

// Time gets the time to be used when checking this source. The advantage of
// calling this function over calling g_get_monotonic_time() directly is that
// when checking multiple sources, GLib can cache a single value instead of
// having to repeatedly get the system monotonic time.
//
// The time here is the system monotonic time, if available, or some other
// reasonable alternative otherwise. See g_get_monotonic_time().
func (source *Source) Time() int64 {
	var arg0 *C.GSource

	arg0 = (*C.GSource)(source.Native())

	ret := C.g_source_get_time(arg0)

	var ret0 int64

	ret0 = int64(ret)

	return ret0
}

// IsDestroyed returns whether @source has been destroyed.
//
// This is important when you operate upon your objects from within idle
// handlers, but may have freed the object before the dispatch of your idle
// handler.
//
//    static gboolean
//    idle_callback (gpointer data)
//    {
//      SomeWidget *self = data;
//
//      GDK_THREADS_ENTER ();
//      if (!g_source_is_destroyed (g_main_current_source ()))
//        {
//          // do stuff with self
//        }
//      GDK_THREADS_LEAVE ();
//
//      return FALSE;
//    }
//
// Calls to this function from a thread other than the one acquired by the
// Context the #GSource is attached to are typically redundant, as the source
// could be destroyed immediately after this function returns. However, once a
// source is destroyed it cannot be un-destroyed, so this function can be used
// for opportunistic checks from any thread.
func (source *Source) IsDestroyed() bool {
	var arg0 *C.GSource

	arg0 = (*C.GSource)(source.Native())

	ret := C.g_source_is_destroyed(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ModifyUnixFd updates the event mask to watch for the fd identified by @tag.
//
// @tag is the tag returned from g_source_add_unix_fd().
//
// If you want to remove a fd, don't set its event mask to zero. Instead, call
// g_source_remove_unix_fd().
//
// This API is only intended to be used by implementations of #GSource. Do not
// call this API on a #GSource that you did not create.
//
// As the name suggests, this function is not available on Windows.
func (source *Source) ModifyUnixFd(tag interface{}, newEvents IOCondition) {
	var arg0 *C.GSource
	var arg1 C.gpointer
	var arg2 C.GIOCondition

	arg0 = (*C.GSource)(source.Native())
	arg1 = C.gpointer(box.Assign(tag))
	arg2 = (C.GIOCondition)(newEvents)

	C.g_source_modify_unix_fd(arg0, arg1, arg2)
}

// QueryUnixFd queries the events reported for the fd corresponding to @tag on
// @source during the last poll.
//
// The return value of this function is only defined when the function is called
// from the check or dispatch functions for @source.
//
// This API is only intended to be used by implementations of #GSource. Do not
// call this API on a #GSource that you did not create.
//
// As the name suggests, this function is not available on Windows.
func (source *Source) QueryUnixFd(tag interface{}) IOCondition {
	var arg0 *C.GSource
	var arg1 C.gpointer

	arg0 = (*C.GSource)(source.Native())
	arg1 = C.gpointer(box.Assign(tag))

	ret := C.g_source_query_unix_fd(arg0, arg1)

	var ret0 IOCondition

	ret0 = IOCondition(ret)

	return ret0
}

// Ref increases the reference count on a source by one.
func (source *Source) Ref() *Source {
	var arg0 *C.GSource

	arg0 = (*C.GSource)(source.Native())

	ret := C.g_source_ref(arg0)

	var ret0 *Source

	{
		ret0 = WrapSource(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Source) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// RemoveChildSource detaches @child_source from @source and destroys it.
//
// This API is only intended to be used by implementations of #GSource. Do not
// call this API on a #GSource that you did not create.
func (source *Source) RemoveChildSource(childSource *Source) {
	var arg0 *C.GSource
	var arg1 *C.GSource

	arg0 = (*C.GSource)(source.Native())
	arg1 = (*C.GSource)(childSource.Native())

	C.g_source_remove_child_source(arg0, arg1)
}

// RemovePoll removes a file descriptor from the set of file descriptors polled
// for this source.
//
// This API is only intended to be used by implementations of #GSource. Do not
// call this API on a #GSource that you did not create.
func (source *Source) RemovePoll(fd *PollFD) {
	var arg0 *C.GSource
	var arg1 *C.GPollFD

	arg0 = (*C.GSource)(source.Native())
	arg1 = (*C.GPollFD)(fd.Native())

	C.g_source_remove_poll(arg0, arg1)
}

// RemoveUnixFd reverses the effect of a previous call to
// g_source_add_unix_fd().
//
// You only need to call this if you want to remove an fd from being watched
// while keeping the same source around. In the normal case you will just want
// to destroy the source.
//
// This API is only intended to be used by implementations of #GSource. Do not
// call this API on a #GSource that you did not create.
//
// As the name suggests, this function is not available on Windows.
func (source *Source) RemoveUnixFd(tag interface{}) {
	var arg0 *C.GSource
	var arg1 C.gpointer

	arg0 = (*C.GSource)(source.Native())
	arg1 = C.gpointer(box.Assign(tag))

	C.g_source_remove_unix_fd(arg0, arg1)
}

// SetCallback sets the callback function for a source. The callback for a
// source is called from the source's dispatch function.
//
// The exact type of @func depends on the type of source; ie. you should not
// count on @func being called with @data as its first parameter. Cast @func
// with G_SOURCE_FUNC() to avoid warnings about incompatible function types.
//
// See [memory management of sources][mainloop-memory-management] for details on
// how to handle memory management of @data.
//
// Typically, you won't use this function. Instead use functions specific to the
// type of source you are using, such as g_idle_add() or g_timeout_add().
//
// It is safe to call this function multiple times on a source which has already
// been attached to a context. The changes will take effect for the next time
// the source is dispatched after this call returns.
func (source *Source) SetCallback(fn SourceFunc) {
	var arg0 *C.GSource
	var arg1 C.GSourceFunc
	var arg2 C.gpointer
	var arg3 C.GDestroyNotify

	arg0 = (*C.GSource)(source.Native())
	arg1 = (*[0]byte)(C.gotk4_SourceFunc)
	arg2 = C.gpointer(box.Assign(fn))
	arg3 = (*[0]byte)(C.callbackDelete)

	C.g_source_set_callback(arg0, arg1, arg2, arg3)
}

// SetCanRecurse sets whether a source can be called recursively. If
// @can_recurse is true, then while the source is being dispatched then this
// source will be processed normally. Otherwise, all processing of this source
// is blocked until the dispatch function returns.
func (source *Source) SetCanRecurse(canRecurse bool) {
	var arg0 *C.GSource
	var arg1 C.gboolean

	arg0 = (*C.GSource)(source.Native())
	if canRecurse {
		arg1 = C.TRUE
	}

	C.g_source_set_can_recurse(arg0, arg1)
}

// SetName sets a name for the source, used in debugging and profiling. The name
// defaults to LL.
//
// The source name should describe in a human-readable way what the source does.
// For example, "X11 event queue" or "GTK+ repaint idle handler" or whatever it
// is.
//
// It is permitted to call this function multiple times, but is not recommended
// due to the potential performance impact. For example, one could change the
// name in the "check" function of a Funcs to include details like the event
// type in the source name.
//
// Use caution if changing the name while another thread may be accessing it
// with g_source_get_name(); that function does not copy the value, and changing
// the value will free it while the other thread may be attempting to use it.
func (source *Source) SetName(name string) {
	var arg0 *C.GSource
	var arg1 *C.char

	arg0 = (*C.GSource)(source.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.g_source_set_name(arg0, arg1)
}

// SetPriority sets the priority of a source. While the main loop is being run,
// a source will be dispatched if it is ready to be dispatched and no sources at
// a higher (numerically smaller) priority are ready to be dispatched.
//
// A child source always has the same priority as its parent. It is not
// permitted to change the priority of a source once it has been added as a
// child of another source.
func (source *Source) SetPriority(priority int) {
	var arg0 *C.GSource
	var arg1 C.gint

	arg0 = (*C.GSource)(source.Native())
	arg1 = C.gint(priority)

	C.g_source_set_priority(arg0, arg1)
}

// SetReadyTime sets a #GSource to be dispatched when the given monotonic time
// is reached (or passed). If the monotonic time is in the past (as it always
// will be if @ready_time is 0) then the source will be dispatched immediately.
//
// If @ready_time is -1 then the source is never woken up on the basis of the
// passage of time.
//
// Dispatching the source does not reset the ready time. You should do so
// yourself, from the source dispatch function.
//
// Note that if you have a pair of sources where the ready time of one suggests
// that it will be delivered first but the priority for the other suggests that
// it would be delivered first, and the ready time for both sources is reached
// during the same main context iteration, then the order of dispatch is
// undefined.
//
// It is a no-op to call this function on a #GSource which has already been
// destroyed with g_source_destroy().
//
// This API is only intended to be used by implementations of #GSource. Do not
// call this API on a #GSource that you did not create.
func (source *Source) SetReadyTime(readyTime int64) {
	var arg0 *C.GSource
	var arg1 C.gint64

	arg0 = (*C.GSource)(source.Native())
	arg1 = C.gint64(readyTime)

	C.g_source_set_ready_time(arg0, arg1)
}

// Unref decreases the reference count of a source by one. If the resulting
// reference count is zero the source and associated memory will be destroyed.
func (source *Source) Unref() {
	var arg0 *C.GSource

	arg0 = (*C.GSource)(source.Native())

	C.g_source_unref(arg0)
}

type SourcePrivate struct {
	native C.GSourcePrivate
}

// WrapSourcePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSourcePrivate(ptr unsafe.Pointer) *SourcePrivate {
	if ptr == nil {
		return nil
	}

	return (*SourcePrivate)(ptr)
}

func marshalSourcePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSourcePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *SourcePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// StatBuf: a type corresponding to the appropriate struct type for the stat()
// system call, depending on the platform and/or compiler being used.
//
// See g_stat() for more information.
type StatBuf struct {
	native C.GStatBuf
}

// WrapStatBuf wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapStatBuf(ptr unsafe.Pointer) *StatBuf {
	if ptr == nil {
		return nil
	}

	return (*StatBuf)(ptr)
}

func marshalStatBuf(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapStatBuf(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *StatBuf) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// String: the GString struct contains the public fields of a GString.
type String struct {
	native C.GString
}

// WrapString wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapString(ptr unsafe.Pointer) *String {
	if ptr == nil {
		return nil
	}

	return (*String)(ptr)
}

func marshalString(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapString(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *String) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// Str gets the field inside the struct.
func (s *String) Str() string {
	var ret string
	ret = C.GoString(s.native.str)
	return ret
}

// Len gets the field inside the struct.
func (s *String) Len() uint {
	var ret uint
	ret = uint(s.native.len)
	return ret
}

// AllocatedLen gets the field inside the struct.
func (s *String) AllocatedLen() uint {
	var ret uint
	ret = uint(s.native.allocated_len)
	return ret
}

// Append adds a string onto the end of a #GString, expanding it if necessary.
func (string *String) Append(val string) *String {
	var arg0 *C.GString
	var arg1 *C.gchar

	arg0 = (*C.GString)(string.Native())
	arg1 = (*C.gchar)(C.CString(val))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_string_append(arg0, arg1)

	var ret0 *String

	{
		ret0 = WrapString(unsafe.Pointer(ret))
	}

	return ret0
}

// AppendC adds a byte onto the end of a #GString, expanding it if necessary.
func (string *String) AppendC(c byte) *String {
	var arg0 *C.GString
	var arg1 C.gchar

	arg0 = (*C.GString)(string.Native())
	arg1 = C.gchar(c)

	ret := C.g_string_append_c(arg0, arg1)

	var ret0 *String

	{
		ret0 = WrapString(unsafe.Pointer(ret))
	}

	return ret0
}

// AppendLen appends @len bytes of @val to @string.
//
// If @len is positive, @val may contain embedded nuls and need not be
// nul-terminated. It is the caller's responsibility to ensure that @val has at
// least @len addressable bytes.
//
// If @len is negative, @val must be nul-terminated and @len is considered to
// request the entire string length. This makes g_string_append_len() equivalent
// to g_string_append().
func (string *String) AppendLen(val string, len int) *String {
	var arg0 *C.GString
	var arg1 *C.gchar
	var arg2 C.gssize

	arg0 = (*C.GString)(string.Native())
	arg1 = (*C.gchar)(C.CString(val))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(len)

	ret := C.g_string_append_len(arg0, arg1, arg2)

	var ret0 *String

	{
		ret0 = WrapString(unsafe.Pointer(ret))
	}

	return ret0
}

// AppendUnichar converts a Unicode character into UTF-8, and appends it to the
// string.
func (string *String) AppendUnichar(wc uint32) *String {
	var arg0 *C.GString
	var arg1 C.gunichar

	arg0 = (*C.GString)(string.Native())
	arg1 = C.gunichar(wc)

	ret := C.g_string_append_unichar(arg0, arg1)

	var ret0 *String

	{
		ret0 = WrapString(unsafe.Pointer(ret))
	}

	return ret0
}

// AppendURIEscaped appends @unescaped to @string, escaping any characters that
// are reserved in URIs using URI-style escape sequences.
func (string *String) AppendURIEscaped(unescaped string, reservedCharsAllowed string, allowUTF8 bool) *String {
	var arg0 *C.GString
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 C.gboolean

	arg0 = (*C.GString)(string.Native())
	arg1 = (*C.gchar)(C.CString(unescaped))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(reservedCharsAllowed))
	defer C.free(unsafe.Pointer(arg2))
	if allowUTF8 {
		arg3 = C.TRUE
	}

	ret := C.g_string_append_uri_escaped(arg0, arg1, arg2, arg3)

	var ret0 *String

	{
		ret0 = WrapString(unsafe.Pointer(ret))
	}

	return ret0
}

// ASCIIDown converts all uppercase ASCII letters to lowercase ASCII letters.
func (string *String) ASCIIDown() *String {
	var arg0 *C.GString

	arg0 = (*C.GString)(string.Native())

	ret := C.g_string_ascii_down(arg0)

	var ret0 *String

	{
		ret0 = WrapString(unsafe.Pointer(ret))
	}

	return ret0
}

// ASCIIUp converts all lowercase ASCII letters to uppercase ASCII letters.
func (string *String) ASCIIUp() *String {
	var arg0 *C.GString

	arg0 = (*C.GString)(string.Native())

	ret := C.g_string_ascii_up(arg0)

	var ret0 *String

	{
		ret0 = WrapString(unsafe.Pointer(ret))
	}

	return ret0
}

// Assign copies the bytes from a string into a #GString, destroying any
// previous contents. It is rather like the standard strcpy() function, except
// that you do not have to worry about having enough space to copy the string.
func (string *String) Assign(rval string) *String {
	var arg0 *C.GString
	var arg1 *C.gchar

	arg0 = (*C.GString)(string.Native())
	arg1 = (*C.gchar)(C.CString(rval))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_string_assign(arg0, arg1)

	var ret0 *String

	{
		ret0 = WrapString(unsafe.Pointer(ret))
	}

	return ret0
}

// Down converts a #GString to lowercase.
func (string *String) Down() *String {
	var arg0 *C.GString

	arg0 = (*C.GString)(string.Native())

	ret := C.g_string_down(arg0)

	var ret0 *String

	{
		ret0 = WrapString(unsafe.Pointer(ret))
	}

	return ret0
}

// Equal compares two strings for equality, returning true if they are equal.
// For use with Table.
func (v *String) Equal(v2 *String) bool {
	var arg0 *C.GString
	var arg1 *C.GString

	arg0 = (*C.GString)(v.Native())
	arg1 = (*C.GString)(v2.Native())

	ret := C.g_string_equal(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Erase removes @len bytes from a #GString, starting at position @pos. The rest
// of the #GString is shifted down to fill the gap.
func (string *String) Erase(pos int, len int) *String {
	var arg0 *C.GString
	var arg1 C.gssize
	var arg2 C.gssize

	arg0 = (*C.GString)(string.Native())
	arg1 = C.gssize(pos)
	arg2 = C.gssize(len)

	ret := C.g_string_erase(arg0, arg1, arg2)

	var ret0 *String

	{
		ret0 = WrapString(unsafe.Pointer(ret))
	}

	return ret0
}

// Free frees the memory allocated for the #GString. If @free_segment is true it
// also frees the character data. If it's false, the caller gains ownership of
// the buffer and must free it after use with g_free().
func (string *String) Free(freeSegment bool) string {
	var arg0 *C.GString
	var arg1 C.gboolean

	arg0 = (*C.GString)(string.Native())
	if freeSegment {
		arg1 = C.TRUE
	}

	ret := C.g_string_free(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// FreeToBytes transfers ownership of the contents of @string to a newly
// allocated #GBytes. The #GString structure itself is deallocated, and it is
// therefore invalid to use @string after invoking this function.
//
// Note that while #GString ensures that its buffer always has a trailing nul
// character (not reflected in its "len"), the returned #GBytes does not include
// this extra nul; i.e. it has length exactly equal to the "len" member.
func (string *String) FreeToBytes() *Bytes {
	var arg0 *C.GString

	arg0 = (*C.GString)(string.Native())

	ret := C.g_string_free_to_bytes(arg0)

	var ret0 *Bytes

	{
		ret0 = WrapBytes(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Bytes) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Hash creates a hash code for @str; for use with Table.
func (str *String) Hash() uint {
	var arg0 *C.GString

	arg0 = (*C.GString)(str.Native())

	ret := C.g_string_hash(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Insert inserts a copy of a string into a #GString, expanding it if necessary.
func (string *String) Insert(pos int, val string) *String {
	var arg0 *C.GString
	var arg1 C.gssize
	var arg2 *C.gchar

	arg0 = (*C.GString)(string.Native())
	arg1 = C.gssize(pos)
	arg2 = (*C.gchar)(C.CString(val))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_string_insert(arg0, arg1, arg2)

	var ret0 *String

	{
		ret0 = WrapString(unsafe.Pointer(ret))
	}

	return ret0
}

// InsertC inserts a byte into a #GString, expanding it if necessary.
func (string *String) InsertC(pos int, c byte) *String {
	var arg0 *C.GString
	var arg1 C.gssize
	var arg2 C.gchar

	arg0 = (*C.GString)(string.Native())
	arg1 = C.gssize(pos)
	arg2 = C.gchar(c)

	ret := C.g_string_insert_c(arg0, arg1, arg2)

	var ret0 *String

	{
		ret0 = WrapString(unsafe.Pointer(ret))
	}

	return ret0
}

// InsertLen inserts @len bytes of @val into @string at @pos.
//
// If @len is positive, @val may contain embedded nuls and need not be
// nul-terminated. It is the caller's responsibility to ensure that @val has at
// least @len addressable bytes.
//
// If @len is negative, @val must be nul-terminated and @len is considered to
// request the entire string length.
//
// If @pos is -1, bytes are inserted at the end of the string.
func (string *String) InsertLen(pos int, val string, len int) *String {
	var arg0 *C.GString
	var arg1 C.gssize
	var arg2 *C.gchar
	var arg3 C.gssize

	arg0 = (*C.GString)(string.Native())
	arg1 = C.gssize(pos)
	arg2 = (*C.gchar)(C.CString(val))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.gssize(len)

	ret := C.g_string_insert_len(arg0, arg1, arg2, arg3)

	var ret0 *String

	{
		ret0 = WrapString(unsafe.Pointer(ret))
	}

	return ret0
}

// InsertUnichar converts a Unicode character into UTF-8, and insert it into the
// string at the given position.
func (string *String) InsertUnichar(pos int, wc uint32) *String {
	var arg0 *C.GString
	var arg1 C.gssize
	var arg2 C.gunichar

	arg0 = (*C.GString)(string.Native())
	arg1 = C.gssize(pos)
	arg2 = C.gunichar(wc)

	ret := C.g_string_insert_unichar(arg0, arg1, arg2)

	var ret0 *String

	{
		ret0 = WrapString(unsafe.Pointer(ret))
	}

	return ret0
}

// Overwrite overwrites part of a string, lengthening it if necessary.
func (string *String) Overwrite(pos uint, val string) *String {
	var arg0 *C.GString
	var arg1 C.gsize
	var arg2 *C.gchar

	arg0 = (*C.GString)(string.Native())
	arg1 = C.gsize(pos)
	arg2 = (*C.gchar)(C.CString(val))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_string_overwrite(arg0, arg1, arg2)

	var ret0 *String

	{
		ret0 = WrapString(unsafe.Pointer(ret))
	}

	return ret0
}

// OverwriteLen overwrites part of a string, lengthening it if necessary. This
// function will work with embedded nuls.
func (string *String) OverwriteLen(pos uint, val string, len int) *String {
	var arg0 *C.GString
	var arg1 C.gsize
	var arg2 *C.gchar
	var arg3 C.gssize

	arg0 = (*C.GString)(string.Native())
	arg1 = C.gsize(pos)
	arg2 = (*C.gchar)(C.CString(val))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.gssize(len)

	ret := C.g_string_overwrite_len(arg0, arg1, arg2, arg3)

	var ret0 *String

	{
		ret0 = WrapString(unsafe.Pointer(ret))
	}

	return ret0
}

// Prepend adds a string on to the start of a #GString, expanding it if
// necessary.
func (string *String) Prepend(val string) *String {
	var arg0 *C.GString
	var arg1 *C.gchar

	arg0 = (*C.GString)(string.Native())
	arg1 = (*C.gchar)(C.CString(val))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_string_prepend(arg0, arg1)

	var ret0 *String

	{
		ret0 = WrapString(unsafe.Pointer(ret))
	}

	return ret0
}

// PrependC adds a byte onto the start of a #GString, expanding it if necessary.
func (string *String) PrependC(c byte) *String {
	var arg0 *C.GString
	var arg1 C.gchar

	arg0 = (*C.GString)(string.Native())
	arg1 = C.gchar(c)

	ret := C.g_string_prepend_c(arg0, arg1)

	var ret0 *String

	{
		ret0 = WrapString(unsafe.Pointer(ret))
	}

	return ret0
}

// PrependLen prepends @len bytes of @val to @string.
//
// If @len is positive, @val may contain embedded nuls and need not be
// nul-terminated. It is the caller's responsibility to ensure that @val has at
// least @len addressable bytes.
//
// If @len is negative, @val must be nul-terminated and @len is considered to
// request the entire string length. This makes g_string_prepend_len()
// equivalent to g_string_prepend().
func (string *String) PrependLen(val string, len int) *String {
	var arg0 *C.GString
	var arg1 *C.gchar
	var arg2 C.gssize

	arg0 = (*C.GString)(string.Native())
	arg1 = (*C.gchar)(C.CString(val))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(len)

	ret := C.g_string_prepend_len(arg0, arg1, arg2)

	var ret0 *String

	{
		ret0 = WrapString(unsafe.Pointer(ret))
	}

	return ret0
}

// PrependUnichar converts a Unicode character into UTF-8, and prepends it to
// the string.
func (string *String) PrependUnichar(wc uint32) *String {
	var arg0 *C.GString
	var arg1 C.gunichar

	arg0 = (*C.GString)(string.Native())
	arg1 = C.gunichar(wc)

	ret := C.g_string_prepend_unichar(arg0, arg1)

	var ret0 *String

	{
		ret0 = WrapString(unsafe.Pointer(ret))
	}

	return ret0
}

// SetSize sets the length of a #GString. If the length is less than the current
// length, the string will be truncated. If the length is greater than the
// current length, the contents of the newly added area are undefined. (However,
// as always, string->str[string->len] will be a nul byte.)
func (string *String) SetSize(len uint) *String {
	var arg0 *C.GString
	var arg1 C.gsize

	arg0 = (*C.GString)(string.Native())
	arg1 = C.gsize(len)

	ret := C.g_string_set_size(arg0, arg1)

	var ret0 *String

	{
		ret0 = WrapString(unsafe.Pointer(ret))
	}

	return ret0
}

// Truncate cuts off the end of the GString, leaving the first @len bytes.
func (string *String) Truncate(len uint) *String {
	var arg0 *C.GString
	var arg1 C.gsize

	arg0 = (*C.GString)(string.Native())
	arg1 = C.gsize(len)

	ret := C.g_string_truncate(arg0, arg1)

	var ret0 *String

	{
		ret0 = WrapString(unsafe.Pointer(ret))
	}

	return ret0
}

// Up converts a #GString to uppercase.
func (string *String) Up() *String {
	var arg0 *C.GString

	arg0 = (*C.GString)(string.Native())

	ret := C.g_string_up(arg0)

	var ret0 *String

	{
		ret0 = WrapString(unsafe.Pointer(ret))
	}

	return ret0
}

// StringChunk: an opaque data structure representing String Chunks. It should
// only be accessed by using the following functions.
type StringChunk struct {
	native C.GStringChunk
}

// WrapStringChunk wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapStringChunk(ptr unsafe.Pointer) *StringChunk {
	if ptr == nil {
		return nil
	}

	return (*StringChunk)(ptr)
}

func marshalStringChunk(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapStringChunk(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *StringChunk) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// Clear frees all strings contained within the Chunk. After calling
// g_string_chunk_clear() it is not safe to access any of the strings which were
// contained within it.
func (chunk *StringChunk) Clear() {
	var arg0 *C.GStringChunk

	arg0 = (*C.GStringChunk)(chunk.Native())

	C.g_string_chunk_clear(arg0)
}

// Free frees all memory allocated by the Chunk. After calling
// g_string_chunk_free() it is not safe to access any of the strings which were
// contained within it.
func (chunk *StringChunk) Free() {
	var arg0 *C.GStringChunk

	arg0 = (*C.GStringChunk)(chunk.Native())

	C.g_string_chunk_free(arg0)
}

// Insert adds a copy of @string to the Chunk. It returns a pointer to the new
// copy of the string in the Chunk. The characters in the string can be changed,
// if necessary, though you should not change anything after the end of the
// string.
//
// Unlike g_string_chunk_insert_const(), this function does not check for
// duplicates. Also strings added with g_string_chunk_insert() will not be
// searched by g_string_chunk_insert_const() when looking for duplicates.
func (chunk *StringChunk) Insert(string string) string {
	var arg0 *C.GStringChunk
	var arg1 *C.gchar

	arg0 = (*C.GStringChunk)(chunk.Native())
	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_string_chunk_insert(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// InsertConst adds a copy of @string to the Chunk, unless the same string has
// already been added to the Chunk with g_string_chunk_insert_const().
//
// This function is useful if you need to copy a large number of strings but do
// not want to waste space storing duplicates. But you must remember that there
// may be several pointers to the same string, and so any changes made to the
// strings should be done very carefully.
//
// Note that g_string_chunk_insert_const() will not return a pointer to a string
// added with g_string_chunk_insert(), even if they do match.
func (chunk *StringChunk) InsertConst(string string) string {
	var arg0 *C.GStringChunk
	var arg1 *C.gchar

	arg0 = (*C.GStringChunk)(chunk.Native())
	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_string_chunk_insert_const(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// InsertLen adds a copy of the first @len bytes of @string to the Chunk. The
// copy is nul-terminated.
//
// Since this function does not stop at nul bytes, it is the caller's
// responsibility to ensure that @string has at least @len addressable bytes.
//
// The characters in the returned string can be changed, if necessary, though
// you should not change anything after the end of the string.
func (chunk *StringChunk) InsertLen(string string, len int) string {
	var arg0 *C.GStringChunk
	var arg1 *C.gchar
	var arg2 C.gssize

	arg0 = (*C.GStringChunk)(chunk.Native())
	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(len)

	ret := C.g_string_chunk_insert_len(arg0, arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// TestCase: an opaque structure representing a test case.
type TestCase struct {
	native C.GTestCase
}

// WrapTestCase wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTestCase(ptr unsafe.Pointer) *TestCase {
	if ptr == nil {
		return nil
	}

	return (*TestCase)(ptr)
}

func marshalTestCase(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTestCase(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TestCase) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

type TestConfig struct {
	native C.GTestConfig
}

// WrapTestConfig wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTestConfig(ptr unsafe.Pointer) *TestConfig {
	if ptr == nil {
		return nil
	}

	return (*TestConfig)(ptr)
}

func marshalTestConfig(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTestConfig(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TestConfig) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// TestInitialized gets the field inside the struct.
func (t *TestConfig) TestInitialized() bool {
	var ret bool
	ret = C.BOOL(t.native.test_initialized) != 0
	return ret
}

// TestQuick gets the field inside the struct.
func (t *TestConfig) TestQuick() bool {
	var ret bool
	ret = C.BOOL(t.native.test_quick) != 0
	return ret
}

// TestPerf gets the field inside the struct.
func (t *TestConfig) TestPerf() bool {
	var ret bool
	ret = C.BOOL(t.native.test_perf) != 0
	return ret
}

// TestVerbose gets the field inside the struct.
func (t *TestConfig) TestVerbose() bool {
	var ret bool
	ret = C.BOOL(t.native.test_verbose) != 0
	return ret
}

// TestQuiet gets the field inside the struct.
func (t *TestConfig) TestQuiet() bool {
	var ret bool
	ret = C.BOOL(t.native.test_quiet) != 0
	return ret
}

// TestUndefined gets the field inside the struct.
func (t *TestConfig) TestUndefined() bool {
	var ret bool
	ret = C.BOOL(t.native.test_undefined) != 0
	return ret
}

type TestLogBuffer struct {
	native C.GTestLogBuffer
}

// WrapTestLogBuffer wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTestLogBuffer(ptr unsafe.Pointer) *TestLogBuffer {
	if ptr == nil {
		return nil
	}

	return (*TestLogBuffer)(ptr)
}

func marshalTestLogBuffer(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTestLogBuffer(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TestLogBuffer) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// Free: internal function for gtester to free test log messages, no ABI
// guarantees provided.
func (tbuffer *TestLogBuffer) Free() {
	var arg0 *C.GTestLogBuffer

	arg0 = (*C.GTestLogBuffer)(tbuffer.Native())

	C.g_test_log_buffer_free(arg0)
}

// Pop: internal function for gtester to retrieve test log messages, no ABI
// guarantees provided.
func (tbuffer *TestLogBuffer) Pop() *TestLogMsg {
	var arg0 *C.GTestLogBuffer

	arg0 = (*C.GTestLogBuffer)(tbuffer.Native())

	ret := C.g_test_log_buffer_pop(arg0)

	var ret0 *TestLogMsg

	{
		ret0 = WrapTestLogMsg(unsafe.Pointer(ret))
	}

	return ret0
}

// Push: internal function for gtester to decode test log messages, no ABI
// guarantees provided.
func (tbuffer *TestLogBuffer) Push(nBytes uint, bytes byte) {
	var arg0 *C.GTestLogBuffer
	var arg1 C.guint
	var arg2 *C.guint8

	arg0 = (*C.GTestLogBuffer)(tbuffer.Native())
	arg1 = C.guint(nBytes)
	arg2 = (*C.guint8)(bytes)

	C.g_test_log_buffer_push(arg0, arg1, arg2)
}

type TestLogMsg struct {
	native C.GTestLogMsg
}

// WrapTestLogMsg wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTestLogMsg(ptr unsafe.Pointer) *TestLogMsg {
	if ptr == nil {
		return nil
	}

	return (*TestLogMsg)(ptr)
}

func marshalTestLogMsg(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTestLogMsg(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TestLogMsg) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// LogType gets the field inside the struct.
func (t *TestLogMsg) LogType() TestLogType {
	var ret TestLogType
	ret = TestLogType(t.native.log_type)
	return ret
}

// NStrings gets the field inside the struct.
func (t *TestLogMsg) NStrings() uint {
	var ret uint
	ret = uint(t.native.n_strings)
	return ret
}

// Strings gets the field inside the struct.
func (t *TestLogMsg) Strings() string {
	var ret string
	ret = C.GoString(t.native.strings)
	return ret
}

// NNums gets the field inside the struct.
func (t *TestLogMsg) NNums() uint {
	var ret uint
	ret = uint(t.native.n_nums)
	return ret
}

// Nums gets the field inside the struct.
func (t *TestLogMsg) Nums() float64 {
	var ret float64
	ret = float64(t.native.nums)
	return ret
}

// Free: internal function for gtester to free test log messages, no ABI
// guarantees provided.
func (tmsg *TestLogMsg) Free() {
	var arg0 *C.GTestLogMsg

	arg0 = (*C.GTestLogMsg)(tmsg.Native())

	C.g_test_log_msg_free(arg0)
}

// TestSuite: an opaque structure representing a test suite.
type TestSuite struct {
	native C.GTestSuite
}

// WrapTestSuite wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTestSuite(ptr unsafe.Pointer) *TestSuite {
	if ptr == nil {
		return nil
	}

	return (*TestSuite)(ptr)
}

func marshalTestSuite(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTestSuite(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TestSuite) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// Add adds @test_case to @suite.
func (suite *TestSuite) Add(testCase *TestCase) {
	var arg0 *C.GTestSuite
	var arg1 *C.GTestCase

	arg0 = (*C.GTestSuite)(suite.Native())
	arg1 = (*C.GTestCase)(testCase.Native())

	C.g_test_suite_add(arg0, arg1)
}

// AddSuite adds @nestedsuite to @suite.
func (suite *TestSuite) AddSuite(nestedsuite *TestSuite) {
	var arg0 *C.GTestSuite
	var arg1 *C.GTestSuite

	arg0 = (*C.GTestSuite)(suite.Native())
	arg1 = (*C.GTestSuite)(nestedsuite.Native())

	C.g_test_suite_add_suite(arg0, arg1)
}

// Thread: the #GThread struct represents a running thread. This struct is
// returned by g_thread_new() or g_thread_try_new(). You can obtain the #GThread
// struct representing the current thread by calling g_thread_self().
//
// GThread is refcounted, see g_thread_ref() and g_thread_unref(). The thread
// represented by it holds a reference while it is running, and g_thread_join()
// consumes the reference that it is given, so it is normally not necessary to
// manage GThread references explicitly.
//
// The structure is opaque -- none of its fields may be directly accessed.
type Thread struct {
	native C.GThread
}

// WrapThread wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapThread(ptr unsafe.Pointer) *Thread {
	if ptr == nil {
		return nil
	}

	return (*Thread)(ptr)
}

func marshalThread(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapThread(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *Thread) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// NewThread constructs a struct Thread.
func NewThread(name string, fn ThreadFunc) *Thread {
	var arg1 *C.gchar
	var arg2 C.GThreadFunc
	var arg3 C.gpointer

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*[0]byte)(C.gotk4_ThreadFunc)
	arg3 = C.gpointer(box.Assign(fn))

	ret := C.g_thread_new(arg1, arg2, arg3)

	var ret0 *Thread

	{
		ret0 = WrapThread(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Thread) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewThreadTry constructs a struct Thread.
func NewThreadTry(name string, fn ThreadFunc) (thread *Thread, err error) {
	var arg1 *C.gchar
	var arg2 C.GThreadFunc
	var arg3 C.gpointer
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*[0]byte)(C.gotk4_ThreadFunc)
	arg3 = C.gpointer(box.Assign(fn))

	ret := C.g_thread_try_new(arg1, arg2, arg3, &gError)

	var ret0 *Thread
	var goError error

	{
		ret0 = WrapThread(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Thread) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Join waits until @thread finishes, i.e. the function @func, as given to
// g_thread_new(), returns or g_thread_exit() is called. If @thread has already
// terminated, then g_thread_join() returns immediately.
//
// Any thread can wait for any other thread by calling g_thread_join(), not just
// its 'creator'. Calling g_thread_join() from multiple threads for the same
// @thread leads to undefined behaviour.
//
// The value returned by @func or given to g_thread_exit() is returned by this
// function.
//
// g_thread_join() consumes the reference to the passed-in @thread. This will
// usually cause the #GThread struct and associated resources to be freed. Use
// g_thread_ref() to obtain an extra reference if you want to keep the GThread
// alive beyond the g_thread_join() call.
func (thread *Thread) Join() interface{} {
	var arg0 *C.GThread

	arg0 = (*C.GThread)(thread.Native())

	ret := C.g_thread_join(arg0)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// Ref: increase the reference count on @thread.
func (thread *Thread) Ref() *Thread {
	var arg0 *C.GThread

	arg0 = (*C.GThread)(thread.Native())

	ret := C.g_thread_ref(arg0)

	var ret0 *Thread

	{
		ret0 = WrapThread(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Thread) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Unref: decrease the reference count on @thread, possibly freeing all
// resources associated with it.
//
// Note that each thread holds a reference to its #GThread while it is running,
// so it is safe to drop your own reference to it if you don't need it anymore.
func (thread *Thread) Unref() {
	var arg0 *C.GThread

	arg0 = (*C.GThread)(thread.Native())

	C.g_thread_unref(arg0)
}

// ThreadPool: the Pool struct represents a thread pool. It has three public
// read-only members, but the underlying struct is bigger, so you must not copy
// this struct.
type ThreadPool struct {
	native C.GThreadPool
}

// WrapThreadPool wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapThreadPool(ptr unsafe.Pointer) *ThreadPool {
	if ptr == nil {
		return nil
	}

	return (*ThreadPool)(ptr)
}

func marshalThreadPool(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapThreadPool(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *ThreadPool) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// UserData gets the field inside the struct.
func (t *ThreadPool) UserData() interface{} {
	var ret interface{}
	ret = box.Get(uintptr(t.native.user_data))
	return ret
}

// Exclusive gets the field inside the struct.
func (t *ThreadPool) Exclusive() bool {
	var ret bool
	ret = C.BOOL(t.native.exclusive) != 0
	return ret
}

// Free frees all resources allocated for @pool.
//
// If @immediate is true, no new task is processed for @pool. Otherwise @pool is
// not freed before the last task is processed. Note however, that no thread of
// this pool is interrupted while processing a task. Instead at least all still
// running threads can finish their tasks before the @pool is freed.
//
// If @wait_ is true, this function does not return before all tasks to be
// processed (dependent on @immediate, whether all or only the currently
// running) are ready. Otherwise this function returns immediately.
//
// After calling this function @pool must not be used anymore.
func (pool *ThreadPool) Free(immediate bool, wait_ bool) {
	var arg0 *C.GThreadPool
	var arg1 C.gboolean
	var arg2 C.gboolean

	arg0 = (*C.GThreadPool)(pool.Native())
	if immediate {
		arg1 = C.TRUE
	}
	if wait_ {
		arg2 = C.TRUE
	}

	C.g_thread_pool_free(arg0, arg1, arg2)
}

// MaxThreads returns the maximal number of threads for @pool.
func (pool *ThreadPool) MaxThreads() int {
	var arg0 *C.GThreadPool

	arg0 = (*C.GThreadPool)(pool.Native())

	ret := C.g_thread_pool_get_max_threads(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// NumThreads returns the number of threads currently running in @pool.
func (pool *ThreadPool) NumThreads() uint {
	var arg0 *C.GThreadPool

	arg0 = (*C.GThreadPool)(pool.Native())

	ret := C.g_thread_pool_get_num_threads(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// MoveToFront moves the item to the front of the queue of unprocessed items, so
// that it will be processed next.
func (pool *ThreadPool) MoveToFront(data interface{}) bool {
	var arg0 *C.GThreadPool
	var arg1 C.gpointer

	arg0 = (*C.GThreadPool)(pool.Native())
	arg1 = C.gpointer(box.Assign(data))

	ret := C.g_thread_pool_move_to_front(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Push inserts @data into the list of tasks to be executed by @pool.
//
// When the number of currently running threads is lower than the maximal
// allowed number of threads, a new thread is started (or reused) with the
// properties given to g_thread_pool_new(). Otherwise, @data stays in the queue
// until a thread in this pool finishes its previous task and processes @data.
//
// @error can be nil to ignore errors, or non-nil to report errors. An error can
// only occur when a new thread couldn't be created. In that case @data is
// simply appended to the queue of work to do.
//
// Before version 2.32, this function did not return a success status.
func (pool *ThreadPool) Push(data interface{}) error {
	var arg0 *C.GThreadPool
	var arg1 C.gpointer
	var gError *C.GError

	arg0 = (*C.GThreadPool)(pool.Native())
	arg1 = C.gpointer(box.Assign(data))

	ret := C.g_thread_pool_push(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SetMaxThreads sets the maximal allowed number of threads for @pool. A value
// of -1 means that the maximal number of threads is unlimited. If @pool is an
// exclusive thread pool, setting the maximal number of threads to -1 is not
// allowed.
//
// Setting @max_threads to 0 means stopping all work for @pool. It is
// effectively frozen until @max_threads is set to a non-zero value again.
//
// A thread is never terminated while calling @func, as supplied by
// g_thread_pool_new(). Instead the maximal number of threads only has effect
// for the allocation of new threads in g_thread_pool_push(). A new thread is
// allocated, whenever the number of currently running threads in @pool is
// smaller than the maximal number.
//
// @error can be nil to ignore errors, or non-nil to report errors. An error can
// only occur when a new thread couldn't be created.
//
// Before version 2.32, this function did not return a success status.
func (pool *ThreadPool) SetMaxThreads(maxThreads int) error {
	var arg0 *C.GThreadPool
	var arg1 C.gint
	var gError *C.GError

	arg0 = (*C.GThreadPool)(pool.Native())
	arg1 = C.gint(maxThreads)

	ret := C.g_thread_pool_set_max_threads(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SetSortFunction sets the function used to sort the list of tasks. This allows
// the tasks to be processed by a priority determined by @func, and not just in
// the order in which they were added to the pool.
//
// Note, if the maximum number of threads is more than 1, the order that threads
// are executed cannot be guaranteed 100%. Threads are scheduled by the
// operating system and are executed at random. It cannot be assumed that
// threads are executed in the order they are created.
func (pool *ThreadPool) SetSortFunction(fn CompareDataFunc) {
	var arg0 *C.GThreadPool
	var arg1 C.GCompareDataFunc
	var arg2 C.gpointer

	arg0 = (*C.GThreadPool)(pool.Native())
	arg1 = (*[0]byte)(C.gotk4_CompareDataFunc)
	arg2 = C.gpointer(box.Assign(fn))

	C.g_thread_pool_set_sort_function(arg0, arg1, arg2)
}

// Unprocessed returns the number of tasks still unprocessed in @pool.
func (pool *ThreadPool) Unprocessed() uint {
	var arg0 *C.GThreadPool

	arg0 = (*C.GThreadPool)(pool.Native())

	ret := C.g_thread_pool_unprocessed(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// TimeVal represents a precise time, with seconds and microseconds. Similar to
// the struct timeval returned by the gettimeofday() UNIX system call.
//
// GLib is attempting to unify around the use of 64-bit integers to represent
// microsecond-precision time. As such, this type will be removed from a future
// version of GLib. A consequence of using `glong` for `tv_sec` is that on
// 32-bit systems `GTimeVal` is subject to the year 2038 problem.
type TimeVal struct {
	native C.GTimeVal
}

// WrapTimeVal wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTimeVal(ptr unsafe.Pointer) *TimeVal {
	if ptr == nil {
		return nil
	}

	return (*TimeVal)(ptr)
}

func marshalTimeVal(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTimeVal(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TimeVal) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// TvSec gets the field inside the struct.
func (t *TimeVal) TvSec() int32 {
	var ret int32
	ret = int32(t.native.tv_sec)
	return ret
}

// TvUsec gets the field inside the struct.
func (t *TimeVal) TvUsec() int32 {
	var ret int32
	ret = int32(t.native.tv_usec)
	return ret
}

// Add adds the given number of microseconds to @time_. @microseconds can also
// be negative to decrease the value of @time_.
func (time_ *TimeVal) Add(microseconds int32) {
	var arg0 *C.GTimeVal
	var arg1 C.glong

	arg0 = (*C.GTimeVal)(time_.Native())
	arg1 = C.glong(microseconds)

	C.g_time_val_add(arg0, arg1)
}

// ToIso8601 converts @time_ into an RFC 3339 encoded string, relative to the
// Coordinated Universal Time (UTC). This is one of the many formats allowed by
// ISO 8601.
//
// ISO 8601 allows a large number of date/time formats, with or without
// punctuation and optional elements. The format returned by this function is a
// complete date and time, with optional punctuation included, the UTC time zone
// represented as "Z", and the @tv_usec part included if and only if it is
// nonzero, i.e. either "YYYY-MM-DDTHH:MM:SSZ" or "YYYY-MM-DDTHH:MM:SS.fffffZ".
//
// This corresponds to the Internet date/time format defined by RFC 3339
// (https://www.ietf.org/rfc/rfc3339.txt), and to either of the two most-precise
// formats defined by the W3C Note Date and Time Formats
// (http://www.w3.org/TR/NOTE-datetime-19980827). Both of these documents are
// profiles of ISO 8601.
//
// Use g_date_time_format() or g_strdup_printf() if a different variation of ISO
// 8601 format is required.
//
// If @time_ represents a date which is too large to fit into a `struct tm`, nil
// will be returned. This is platform dependent. Note also that since `GTimeVal`
// stores the number of seconds as a `glong`, on 32-bit systems it is subject to
// the year 2038 problem. Accordingly, since GLib 2.62, this function has been
// deprecated. Equivalent functionality is available using:
//
//    GDateTime *dt = g_date_time_new_from_unix_utc (time_val);
//    iso8601_string = g_date_time_format_iso8601 (dt);
//    g_date_time_unref (dt);
//
// The return value of g_time_val_to_iso8601() has been nullable since GLib
// 2.54; before then, GLib would crash under the same conditions.
func (time_ *TimeVal) ToIso8601() string {
	var arg0 *C.GTimeVal

	arg0 = (*C.GTimeVal)(time_.Native())

	ret := C.g_time_val_to_iso8601(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// TimeZone is an opaque structure whose members cannot be accessed directly.
type TimeZone struct {
	native C.GTimeZone
}

// WrapTimeZone wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTimeZone(ptr unsafe.Pointer) *TimeZone {
	if ptr == nil {
		return nil
	}

	return (*TimeZone)(ptr)
}

func marshalTimeZone(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTimeZone(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TimeZone) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// NewTimeZone constructs a struct TimeZone.
func NewTimeZone(identifier string) *TimeZone {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(identifier))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_time_zone_new(arg1)

	var ret0 *TimeZone

	{
		ret0 = WrapTimeZone(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *TimeZone) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewTimeZoneLocal constructs a struct TimeZone.
func NewTimeZoneLocal() *TimeZone {

	ret := C.g_time_zone_new_local()

	var ret0 *TimeZone

	{
		ret0 = WrapTimeZone(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *TimeZone) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewTimeZoneOffset constructs a struct TimeZone.
func NewTimeZoneOffset(seconds int32) *TimeZone {
	var arg1 C.gint32

	arg1 = C.gint32(seconds)

	ret := C.g_time_zone_new_offset(arg1)

	var ret0 *TimeZone

	{
		ret0 = WrapTimeZone(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *TimeZone) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewTimeZoneUtc constructs a struct TimeZone.
func NewTimeZoneUtc() *TimeZone {

	ret := C.g_time_zone_new_utc()

	var ret0 *TimeZone

	{
		ret0 = WrapTimeZone(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *TimeZone) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// AdjustTime finds an interval within @tz that corresponds to the given @time_,
// possibly adjusting @time_ if required to fit into an interval. The meaning of
// @time_ depends on @type.
//
// This function is similar to g_time_zone_find_interval(), with the difference
// that it always succeeds (by making the adjustments described below).
//
// In any of the cases where g_time_zone_find_interval() succeeds then this
// function returns the same value, without modifying @time_.
//
// This function may, however, modify @time_ in order to deal with non-existent
// times. If the non-existent local @time_ of 02:30 were requested on March 14th
// 2010 in Toronto then this function would adjust @time_ to be 03:00 and return
// the interval containing the adjusted time.
func (tz *TimeZone) AdjustTime(typ TimeType, time_ int64) int {
	var arg0 *C.GTimeZone
	var arg1 C.GTimeType
	var arg2 *C.gint64

	arg0 = (*C.GTimeZone)(tz.Native())
	arg1 = (C.GTimeType)(typ)
	arg2 = (*C.gint64)(time_)

	ret := C.g_time_zone_adjust_time(arg0, arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// FindInterval finds an interval within @tz that corresponds to the given
// @time_. The meaning of @time_ depends on @type.
//
// If @type is G_TIME_TYPE_UNIVERSAL then this function will always succeed
// (since universal time is monotonic and continuous).
//
// Otherwise @time_ is treated as local time. The distinction between
// G_TIME_TYPE_STANDARD and G_TIME_TYPE_DAYLIGHT is ignored except in the case
// that the given @time_ is ambiguous. In Toronto, for example, 01:30 on
// November 7th 2010 occurred twice (once inside of daylight savings time and
// the next, an hour later, outside of daylight savings time). In this case, the
// different value of @type would result in a different interval being returned.
//
// It is still possible for this function to fail. In Toronto, for example,
// 02:00 on March 14th 2010 does not exist (due to the leap forward to begin
// daylight savings time). -1 is returned in that case.
func (tz *TimeZone) FindInterval(typ TimeType, time_ int64) int {
	var arg0 *C.GTimeZone
	var arg1 C.GTimeType
	var arg2 C.gint64

	arg0 = (*C.GTimeZone)(tz.Native())
	arg1 = (C.GTimeType)(typ)
	arg2 = C.gint64(time_)

	ret := C.g_time_zone_find_interval(arg0, arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Abbreviation determines the time zone abbreviation to be used during a
// particular @interval of time in the time zone @tz.
//
// For example, in Toronto this is currently "EST" during the winter months and
// "EDT" during the summer months when daylight savings time is in effect.
func (tz *TimeZone) Abbreviation(interval int) string {
	var arg0 *C.GTimeZone
	var arg1 C.gint

	arg0 = (*C.GTimeZone)(tz.Native())
	arg1 = C.gint(interval)

	ret := C.g_time_zone_get_abbreviation(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Identifier: get the identifier of this Zone, as passed to g_time_zone_new().
// If the identifier passed at construction time was not recognised, `UTC` will
// be returned. If it was nil, the identifier of the local timezone at
// construction time will be returned.
//
// The identifier will be returned in the same format as provided at
// construction time: if provided as a time offset, that will be returned by
// this function.
func (tz *TimeZone) Identifier() string {
	var arg0 *C.GTimeZone

	arg0 = (*C.GTimeZone)(tz.Native())

	ret := C.g_time_zone_get_identifier(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Offset determines the offset to UTC in effect during a particular @interval
// of time in the time zone @tz.
//
// The offset is the number of seconds that you add to UTC time to arrive at
// local time for @tz (ie: negative numbers for time zones west of GMT, positive
// numbers for east).
func (tz *TimeZone) Offset(interval int) int32 {
	var arg0 *C.GTimeZone
	var arg1 C.gint

	arg0 = (*C.GTimeZone)(tz.Native())
	arg1 = C.gint(interval)

	ret := C.g_time_zone_get_offset(arg0, arg1)

	var ret0 int32

	ret0 = int32(ret)

	return ret0
}

// IsDst determines if daylight savings time is in effect during a particular
// @interval of time in the time zone @tz.
func (tz *TimeZone) IsDst(interval int) bool {
	var arg0 *C.GTimeZone
	var arg1 C.gint

	arg0 = (*C.GTimeZone)(tz.Native())
	arg1 = C.gint(interval)

	ret := C.g_time_zone_is_dst(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Ref increases the reference count on @tz.
func (tz *TimeZone) Ref() *TimeZone {
	var arg0 *C.GTimeZone

	arg0 = (*C.GTimeZone)(tz.Native())

	ret := C.g_time_zone_ref(arg0)

	var ret0 *TimeZone

	{
		ret0 = WrapTimeZone(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *TimeZone) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Unref decreases the reference count on @tz.
func (tz *TimeZone) Unref() {
	var arg0 *C.GTimeZone

	arg0 = (*C.GTimeZone)(tz.Native())

	C.g_time_zone_unref(arg0)
}

// Timer: opaque datatype that records a start time.
type Timer struct {
	native C.GTimer
}

// WrapTimer wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTimer(ptr unsafe.Pointer) *Timer {
	if ptr == nil {
		return nil
	}

	return (*Timer)(ptr)
}

func marshalTimer(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTimer(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *Timer) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// Continue resumes a timer that has previously been stopped with
// g_timer_stop(). g_timer_stop() must be called before using this function.
func (timer *Timer) Continue() {
	var arg0 *C.GTimer

	arg0 = (*C.GTimer)(timer.Native())

	C.g_timer_continue(arg0)
}

// Destroy destroys a timer, freeing associated resources.
func (timer *Timer) Destroy() {
	var arg0 *C.GTimer

	arg0 = (*C.GTimer)(timer.Native())

	C.g_timer_destroy(arg0)
}

// Elapsed: if @timer has been started but not stopped, obtains the time since
// the timer was started. If @timer has been stopped, obtains the elapsed time
// between the time it was started and the time it was stopped. The return value
// is the number of seconds elapsed, including any fractional part. The
// @microseconds out parameter is essentially useless.
func (timer *Timer) Elapsed(microseconds uint32) float64 {
	var arg0 *C.GTimer
	var arg1 *C.gulong

	arg0 = (*C.GTimer)(timer.Native())
	arg1 = (*C.gulong)(microseconds)

	ret := C.g_timer_elapsed(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// IsActive exposes whether the timer is currently active.
func (timer *Timer) IsActive() bool {
	var arg0 *C.GTimer

	arg0 = (*C.GTimer)(timer.Native())

	ret := C.g_timer_is_active(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Reset: this function is useless; it's fine to call g_timer_start() on an
// already-started timer to reset the start time, so g_timer_reset() serves no
// purpose.
func (timer *Timer) Reset() {
	var arg0 *C.GTimer

	arg0 = (*C.GTimer)(timer.Native())

	C.g_timer_reset(arg0)
}

// Start marks a start time, so that future calls to g_timer_elapsed() will
// report the time since g_timer_start() was called. g_timer_new() automatically
// marks the start time, so no need to call g_timer_start() immediately after
// creating the timer.
func (timer *Timer) Start() {
	var arg0 *C.GTimer

	arg0 = (*C.GTimer)(timer.Native())

	C.g_timer_start(arg0)
}

// Stop marks an end time, so calls to g_timer_elapsed() will return the
// difference between this end time and the start time.
func (timer *Timer) Stop() {
	var arg0 *C.GTimer

	arg0 = (*C.GTimer)(timer.Native())

	C.g_timer_stop(arg0)
}

// TrashStack: each piece of memory that is pushed onto the stack is cast to a
// GTrashStack*.
type TrashStack struct {
	native C.GTrashStack
}

// WrapTrashStack wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTrashStack(ptr unsafe.Pointer) *TrashStack {
	if ptr == nil {
		return nil
	}

	return (*TrashStack)(ptr)
}

func marshalTrashStack(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTrashStack(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TrashStack) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// Next gets the field inside the struct.
func (t *TrashStack) Next() *TrashStack {
	var ret *TrashStack
	{
		ret = WrapTrashStack(unsafe.Pointer(t.native.next))
	}
	return ret
}

// Tree: the GTree struct is an opaque data structure representing a [balanced
// binary tree][glib-Balanced-Binary-Trees]. It should be accessed only by using
// the following functions.
type Tree struct {
	native C.GTree
}

// WrapTree wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTree(ptr unsafe.Pointer) *Tree {
	if ptr == nil {
		return nil
	}

	return (*Tree)(ptr)
}

func marshalTree(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTree(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *Tree) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// Destroy removes all keys and values from the #GTree and decreases its
// reference count by one. If keys and/or values are dynamically allocated, you
// should either free them first or create the #GTree using g_tree_new_full().
// In the latter case the destroy functions you supplied will be called on all
// keys and values before destroying the #GTree.
func (tree *Tree) Destroy() {
	var arg0 *C.GTree

	arg0 = (*C.GTree)(tree.Native())

	C.g_tree_destroy(arg0)
}

// Foreach calls the given function for each of the key/value pairs in the
// #GTree. The function is passed the key and value of each pair, and the given
// @data parameter. The tree is traversed in sorted order.
//
// The tree may not be modified while iterating over it (you can't add/remove
// items). To remove all items matching a predicate, you need to add each item
// to a list in your Func as you walk over the tree, then walk the list and
// remove each item.
func (tree *Tree) Foreach(fn TraverseFunc) {
	var arg0 *C.GTree
	var arg1 C.GTraverseFunc
	var arg2 C.gpointer

	arg0 = (*C.GTree)(tree.Native())
	arg1 = (*[0]byte)(C.gotk4_TraverseFunc)
	arg2 = C.gpointer(box.Assign(fn))

	C.g_tree_foreach(arg0, arg1, arg2)
}

// Height gets the height of a #GTree.
//
// If the #GTree contains no nodes, the height is 0. If the #GTree contains only
// one root node the height is 1. If the root node has children the height is 2,
// etc.
func (tree *Tree) Height() int {
	var arg0 *C.GTree

	arg0 = (*C.GTree)(tree.Native())

	ret := C.g_tree_height(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Insert inserts a key/value pair into a #GTree.
//
// If the given key already exists in the #GTree its corresponding value is set
// to the new value. If you supplied a @value_destroy_func when creating the
// #GTree, the old value is freed using that function. If you supplied a
// @key_destroy_func when creating the #GTree, the passed key is freed using
// that function.
//
// The tree is automatically 'balanced' as new key/value pairs are added, so
// that the distance from the root to every leaf is as small as possible. The
// cost of maintaining a balanced tree while inserting new key/value result in a
// O(n log(n)) operation where most of the other operations are O(log(n)).
func (tree *Tree) Insert(key interface{}, value interface{}) {
	var arg0 *C.GTree
	var arg1 C.gpointer
	var arg2 C.gpointer

	arg0 = (*C.GTree)(tree.Native())
	arg1 = C.gpointer(box.Assign(key))
	arg2 = C.gpointer(box.Assign(value))

	C.g_tree_insert(arg0, arg1, arg2)
}

// Lookup gets the value corresponding to the given key. Since a #GTree is
// automatically balanced as key/value pairs are added, key lookup is O(log n)
// (where n is the number of key/value pairs in the tree).
func (tree *Tree) Lookup(key interface{}) interface{} {
	var arg0 *C.GTree
	var arg1 C.gpointer

	arg0 = (*C.GTree)(tree.Native())
	arg1 = C.gpointer(box.Assign(key))

	ret := C.g_tree_lookup(arg0, arg1)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// LookupExtended looks up a key in the #GTree, returning the original key and
// the associated value. This is useful if you need to free the memory allocated
// for the original key, for example before calling g_tree_remove().
func (tree *Tree) LookupExtended(lookupKey interface{}) (origKey interface{}, value interface{}, ok bool) {
	var arg0 *C.GTree
	var arg1 C.gpointer
	var arg2 *C.gpointer // out
	var arg3 *C.gpointer // out

	arg0 = (*C.GTree)(tree.Native())
	arg1 = C.gpointer(box.Assign(lookupKey))

	ret := C.g_tree_lookup_extended(arg0, arg1, &arg2, &arg3)

	var ret0 interface{}
	var ret1 interface{}
	var ret2 bool

	ret0 = box.Get(uintptr(arg2)).(interface{})

	ret1 = box.Get(uintptr(arg3)).(interface{})

	ret2 = C.BOOL(ret) != 0

	return ret0, ret1, ret2
}

// Nnodes gets the number of nodes in a #GTree.
func (tree *Tree) Nnodes() int {
	var arg0 *C.GTree

	arg0 = (*C.GTree)(tree.Native())

	ret := C.g_tree_nnodes(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Ref increments the reference count of @tree by one.
//
// It is safe to call this function from any thread.
func (tree *Tree) Ref() *Tree {
	var arg0 *C.GTree

	arg0 = (*C.GTree)(tree.Native())

	ret := C.g_tree_ref(arg0)

	var ret0 *Tree

	{
		ret0 = WrapTree(unsafe.Pointer(ret))
	}

	return ret0
}

// Remove removes a key/value pair from a #GTree.
//
// If the #GTree was created using g_tree_new_full(), the key and value are
// freed using the supplied destroy functions, otherwise you have to make sure
// that any dynamically allocated values are freed yourself. If the key does not
// exist in the #GTree, the function does nothing.
//
// The cost of maintaining a balanced tree while removing a key/value result in
// a O(n log(n)) operation where most of the other operations are O(log(n)).
func (tree *Tree) Remove(key interface{}) bool {
	var arg0 *C.GTree
	var arg1 C.gpointer

	arg0 = (*C.GTree)(tree.Native())
	arg1 = C.gpointer(box.Assign(key))

	ret := C.g_tree_remove(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Replace inserts a new key and value into a #GTree similar to g_tree_insert().
// The difference is that if the key already exists in the #GTree, it gets
// replaced by the new key. If you supplied a @value_destroy_func when creating
// the #GTree, the old value is freed using that function. If you supplied a
// @key_destroy_func when creating the #GTree, the old key is freed using that
// function.
//
// The tree is automatically 'balanced' as new key/value pairs are added, so
// that the distance from the root to every leaf is as small as possible.
func (tree *Tree) Replace(key interface{}, value interface{}) {
	var arg0 *C.GTree
	var arg1 C.gpointer
	var arg2 C.gpointer

	arg0 = (*C.GTree)(tree.Native())
	arg1 = C.gpointer(box.Assign(key))
	arg2 = C.gpointer(box.Assign(value))

	C.g_tree_replace(arg0, arg1, arg2)
}

// Search searches a #GTree using @search_func.
//
// The @search_func is called with a pointer to the key of a key/value pair in
// the tree, and the passed in @user_data. If @search_func returns 0 for a
// key/value pair, then the corresponding value is returned as the result of
// g_tree_search(). If @search_func returns -1, searching will proceed among the
// key/value pairs that have a smaller key; if @search_func returns 1, searching
// will proceed among the key/value pairs that have a larger key.
func (tree *Tree) Search(searchFunc CompareFunc) interface{} {
	var arg0 *C.GTree
	var arg1 C.GCompareFunc
	var arg2 C.gpointer

	arg0 = (*C.GTree)(tree.Native())
	arg1 = (*[0]byte)(C.gotk4_CompareFunc)
	arg2 = C.gpointer(box.Assign(searchFunc))

	ret := C.g_tree_search(arg0, arg1, arg2)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// Steal removes a key and its associated value from a #GTree without calling
// the key and value destroy functions.
//
// If the key does not exist in the #GTree, the function does nothing.
func (tree *Tree) Steal(key interface{}) bool {
	var arg0 *C.GTree
	var arg1 C.gpointer

	arg0 = (*C.GTree)(tree.Native())
	arg1 = C.gpointer(box.Assign(key))

	ret := C.g_tree_steal(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Traverse calls the given function for each node in the #GTree.
func (tree *Tree) Traverse(traverseFunc TraverseFunc, traverseType TraverseType) {
	var arg0 *C.GTree
	var arg1 C.GTraverseFunc
	var arg2 C.GTraverseType
	var arg3 C.gpointer

	arg0 = (*C.GTree)(tree.Native())
	arg1 = (*[0]byte)(C.gotk4_TraverseFunc)
	arg3 = C.gpointer(box.Assign(traverseFunc))
	arg2 = (C.GTraverseType)(traverseType)

	C.g_tree_traverse(arg0, arg1, arg2, arg3)
}

// Unref decrements the reference count of @tree by one. If the reference count
// drops to 0, all keys and values will be destroyed (if destroy functions were
// specified) and all memory allocated by @tree will be released.
//
// It is safe to call this function from any thread.
func (tree *Tree) Unref() {
	var arg0 *C.GTree

	arg0 = (*C.GTree)(tree.Native())

	C.g_tree_unref(arg0)
}

// URI: the #GUri type and related functions can be used to parse URIs into
// their components, and build valid URIs from individual components.
//
// Note that #GUri scope is to help manipulate URIs in various applications,
// following RFC 3986 (https://tools.ietf.org/html/rfc3986). In particular, it
// doesn't intend to cover web browser needs, and doesn't implement the WHATWG
// URL (https://url.spec.whatwg.org/) standard. No APIs are provided to help
// prevent homograph attacks
// (https://en.wikipedia.org/wiki/IDN_homograph_attack), so #GUri is not
// suitable for formatting URIs for display to the user for making
// security-sensitive decisions.
//
//
// Relative and absolute URIs
//
// As defined in RFC 3986 (https://tools.ietf.org/html/rfc3986#section-4), the
// hierarchical nature of URIs means that they can either be ‘relative
// references’ (sometimes referred to as ‘relative URIs’) or ‘URIs’ (for
// clarity, ‘URIs’ are referred to in this documentation as ‘absolute URIs’ —
// although in constrast to RFC 3986
// (https://tools.ietf.org/html/rfc3986#section-4.3), fragment identifiers are
// always allowed).
//
// Relative references have one or more components of the URI missing. In
// particular, they have no scheme. Any other component, such as hostname,
// query, etc. may be missing, apart from a path, which has to be specified (but
// may be empty). The path may be relative, starting with `./` rather than `/`.
//
// For example, a valid relative reference is `./path?query`, `/?query#fragment`
// or `//example.com`.
//
// Absolute URIs have a scheme specified. Any other components of the URI which
// are missing are specified as explicitly unset in the URI, rather than being
// resolved relative to a base URI using g_uri_parse_relative().
//
// For example, a valid absolute URI is `file:///home/bob` or
// `https://search.com?query=string`.
//
// A #GUri instance is always an absolute URI. A string may be an absolute URI
// or a relative reference; see the documentation for individual functions as to
// what forms they accept.
//
//
// Parsing URIs
//
// The most minimalist APIs for parsing URIs are g_uri_split() and
// g_uri_split_with_user(). These split a URI into its component parts, and
// return the parts; the difference between the two is that g_uri_split() treats
// the ‘userinfo’ component of the URI as a single element, while
// g_uri_split_with_user() can (depending on the Flags you pass) treat it as
// containing a username, password, and authentication parameters.
// Alternatively, g_uri_split_network() can be used when you are only interested
// in the components that are needed to initiate a network connection to the
// service (scheme, host, and port).
//
// g_uri_parse() is similar to g_uri_split(), but instead of returning
// individual strings, it returns a #GUri structure (and it requires that the
// URI be an absolute URI).
//
// g_uri_resolve_relative() and g_uri_parse_relative() allow you to resolve a
// relative URI relative to a base URI. g_uri_resolve_relative() takes two
// strings and returns a string, and g_uri_parse_relative() takes a #GUri and a
// string and returns a #GUri.
//
// All of the parsing functions take a Flags argument describing exactly how to
// parse the URI; see the documentation for that type for more details on the
// specific flags that you can pass. If you need to choose different flags based
// on the type of URI, you can use g_uri_peek_scheme() on the URI string to
// check the scheme first, and use that to decide what flags to parse it with.
//
// For example, you might want to use G_URI_PARAMS_WWW_FORM when parsing the
// params for a web URI, so compare the result of g_uri_peek_scheme() against
// `http` and `https`.
//
//
// Building URIs
//
// g_uri_join() and g_uri_join_with_user() can be used to construct valid URI
// strings from a set of component strings. They are the inverse of
// g_uri_split() and g_uri_split_with_user().
//
// Similarly, g_uri_build() and g_uri_build_with_user() can be used to construct
// a #GUri from a set of component strings.
//
// As with the parsing functions, the building functions take a Flags argument.
// In particular, it is important to keep in mind whether the URI components you
// are using are already `%`-encoded. If so, you must pass the
// G_URI_FLAGS_ENCODED flag.
//
// `file://` URIs
//
// Note that Windows and Unix both define special rules for parsing `file://`
// URIs (involving non-UTF-8 character sets on Unix, and the interpretation of
// path separators on Windows). #GUri does not implement these rules. Use
// g_filename_from_uri() and g_filename_to_uri() if you want to properly convert
// between `file://` URIs and local filenames.
//
//
// URI Equality
//
// Note that there is no `g_uri_equal ()` function, because comparing URIs
// usefully requires scheme-specific knowledge that #GUri does not have. For
// example, `http://example.com/` and `http://EXAMPLE.COM:80` have exactly the
// same meaning according to the HTTP specification, and `data:,foo` and
// `data:;base64,Zm9v` resolve to the same thing according to the `data:` URI
// specification.
type URI struct {
	native C.GUri
}

// WrapURI wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapURI(ptr unsafe.Pointer) *URI {
	if ptr == nil {
		return nil
	}

	return (*URI)(ptr)
}

func marshalURI(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapURI(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (u *URI) Native() unsafe.Pointer {
	return unsafe.Pointer(&u.native)
}

// AuthParams gets @uri's authentication parameters, which may contain
// `%`-encoding, depending on the flags with which @uri was created. (If @uri
// was not created with G_URI_FLAGS_HAS_AUTH_PARAMS then this will be nil.)
//
// Depending on the URI scheme, g_uri_parse_params() may be useful for further
// parsing this information.
func (uri *URI) AuthParams() string {
	var arg0 *C.GUri

	arg0 = (*C.GUri)(uri.Native())

	ret := C.g_uri_get_auth_params(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Flags gets @uri's flags set upon construction.
func (uri *URI) Flags() URIFlags {
	var arg0 *C.GUri

	arg0 = (*C.GUri)(uri.Native())

	ret := C.g_uri_get_flags(arg0)

	var ret0 URIFlags

	ret0 = URIFlags(ret)

	return ret0
}

// Fragment gets @uri's fragment, which may contain `%`-encoding, depending on
// the flags with which @uri was created.
func (uri *URI) Fragment() string {
	var arg0 *C.GUri

	arg0 = (*C.GUri)(uri.Native())

	ret := C.g_uri_get_fragment(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Host gets @uri's host. This will never have `%`-encoded characters, unless it
// is non-UTF-8 (which can only be the case if @uri was created with
// G_URI_FLAGS_NON_DNS).
//
// If @uri contained an IPv6 address literal, this value will be just that
// address, without the brackets around it that are necessary in the string form
// of the URI. Note that in this case there may also be a scope ID attached to
// the address. Eg, `fe80::1234%“em1` (or `fe80::1234%“25em1` if the string is
// still encoded).
func (uri *URI) Host() string {
	var arg0 *C.GUri

	arg0 = (*C.GUri)(uri.Native())

	ret := C.g_uri_get_host(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Password gets @uri's password, which may contain `%`-encoding, depending on
// the flags with which @uri was created. (If @uri was not created with
// G_URI_FLAGS_HAS_PASSWORD then this will be nil.)
func (uri *URI) Password() string {
	var arg0 *C.GUri

	arg0 = (*C.GUri)(uri.Native())

	ret := C.g_uri_get_password(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Path gets @uri's path, which may contain `%`-encoding, depending on the flags
// with which @uri was created.
func (uri *URI) Path() string {
	var arg0 *C.GUri

	arg0 = (*C.GUri)(uri.Native())

	ret := C.g_uri_get_path(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Port gets @uri's port.
func (uri *URI) Port() int {
	var arg0 *C.GUri

	arg0 = (*C.GUri)(uri.Native())

	ret := C.g_uri_get_port(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Query gets @uri's query, which may contain `%`-encoding, depending on the
// flags with which @uri was created.
//
// For queries consisting of a series of `name=value` parameters, ParamsIter or
// g_uri_parse_params() may be useful.
func (uri *URI) Query() string {
	var arg0 *C.GUri

	arg0 = (*C.GUri)(uri.Native())

	ret := C.g_uri_get_query(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Scheme gets @uri's scheme. Note that this will always be all-lowercase,
// regardless of the string or strings that @uri was created from.
func (uri *URI) Scheme() string {
	var arg0 *C.GUri

	arg0 = (*C.GUri)(uri.Native())

	ret := C.g_uri_get_scheme(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// User gets the ‘username’ component of @uri's userinfo, which may contain
// `%`-encoding, depending on the flags with which @uri was created. If @uri was
// not created with G_URI_FLAGS_HAS_PASSWORD or G_URI_FLAGS_HAS_AUTH_PARAMS,
// this is the same as g_uri_get_userinfo().
func (uri *URI) User() string {
	var arg0 *C.GUri

	arg0 = (*C.GUri)(uri.Native())

	ret := C.g_uri_get_user(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Userinfo gets @uri's userinfo, which may contain `%`-encoding, depending on
// the flags with which @uri was created.
func (uri *URI) Userinfo() string {
	var arg0 *C.GUri

	arg0 = (*C.GUri)(uri.Native())

	ret := C.g_uri_get_userinfo(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// ParseRelative parses @uri_ref according to @flags and, if it is a [relative
// URI][relative-absolute-uris], resolves it relative to @base_uri. If the
// result is not a valid absolute URI, it will be discarded, and an error
// returned.
func (baseURI *URI) ParseRelative(uriRef string, flags URIFlags) (uri *URI, err error) {
	var arg0 *C.GUri
	var arg1 *C.gchar
	var arg2 C.GUriFlags
	var gError *C.GError

	arg0 = (*C.GUri)(baseURI.Native())
	arg1 = (*C.gchar)(C.CString(uriRef))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GUriFlags)(flags)

	ret := C.g_uri_parse_relative(arg0, arg1, arg2, &gError)

	var ret0 *URI
	var goError error

	{
		ret0 = WrapURI(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *URI) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Ref increments the reference count of @uri by one.
func (uri *URI) Ref() *URI {
	var arg0 *C.GUri

	arg0 = (*C.GUri)(uri.Native())

	ret := C.g_uri_ref(arg0)

	var ret0 *URI

	{
		ret0 = WrapURI(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *URI) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// String returns a string representing @uri.
//
// This is not guaranteed to return a string which is identical to the string
// that @uri was parsed from. However, if the source URI was syntactically
// correct (according to RFC 3986), and it was parsed with G_URI_FLAGS_ENCODED,
// then g_uri_to_string() is guaranteed to return a string which is at least
// semantically equivalent to the source URI (according to RFC 3986).
//
// If @uri might contain sensitive details, such as authentication parameters,
// or private data in its query string, and the returned string is going to be
// logged, then consider using g_uri_to_string_partial() to redact parts.
func (uri *URI) String() string {
	var arg0 *C.GUri

	arg0 = (*C.GUri)(uri.Native())

	ret := C.g_uri_to_string(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// ToStringPartial returns a string representing @uri, subject to the options in
// @flags. See g_uri_to_string() and HideFlags for more details.
func (uri *URI) ToStringPartial(flags URIHideFlags) string {
	var arg0 *C.GUri
	var arg1 C.GUriHideFlags

	arg0 = (*C.GUri)(uri.Native())
	arg1 = (C.GUriHideFlags)(flags)

	ret := C.g_uri_to_string_partial(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Unref: atomically decrements the reference count of @uri by one.
//
// When the reference count reaches zero, the resources allocated by @uri are
// freed
func (uri *URI) Unref() {
	var arg0 *C.GUri

	arg0 = (*C.GUri)(uri.Native())

	C.g_uri_unref(arg0)
}

// URIParamsIter: many URI schemes include one or more attribute/value pairs as
// part of the URI value. For example
// `scheme://server/path?query=string&is=there` has two attributes –
// `query=string` and `is=there` – in its query part.
//
// A ParamsIter structure represents an iterator that can be used to iterate
// over the attribute/value pairs of a URI query string. ParamsIter structures
// are typically allocated on the stack and then initialized with
// g_uri_params_iter_init(). See the documentation for g_uri_params_iter_init()
// for a usage example.
type URIParamsIter struct {
	native C.GUriParamsIter
}

// WrapURIParamsIter wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapURIParamsIter(ptr unsafe.Pointer) *URIParamsIter {
	if ptr == nil {
		return nil
	}

	return (*URIParamsIter)(ptr)
}

func marshalURIParamsIter(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapURIParamsIter(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (u *URIParamsIter) Native() unsafe.Pointer {
	return unsafe.Pointer(&u.native)
}

// Init initializes an attribute/value pair iterator.
//
// The iterator keeps pointers to the @params and @separators arguments, those
// variables must thus outlive the iterator and not be modified during the
// iteration.
//
// If G_URI_PARAMS_WWW_FORM is passed in @flags, `+` characters in the param
// string will be replaced with spaces in the output. For example, `foo=bar+baz`
// will give attribute `foo` with value `bar baz`. This is commonly used on the
// web (the `https` and `http` schemes only), but is deprecated in favour of the
// equivalent of encoding spaces as `20`.
//
// Unlike with g_uri_parse_params(), G_URI_PARAMS_CASE_INSENSITIVE has no effect
// if passed to @flags for g_uri_params_iter_init(). The caller is responsible
// for doing their own case-insensitive comparisons.
//
//    GUriParamsIter iter;
//    GError *error = NULL;
//    gchar *unowned_attr, *unowned_value;
//
//    g_uri_params_iter_init (&iter, "foo=bar&baz=bar&Foo=frob&baz=bar2", -1, "&", G_URI_PARAMS_NONE);
//    while (g_uri_params_iter_next (&iter, &unowned_attr, &unowned_value, &error))
//      {
//        g_autofree gchar *attr = g_steal_pointer (&unowned_attr);
//        g_autofree gchar *value = g_steal_pointer (&unowned_value);
//        // do something with attr and value; this code will be called 4 times
//        // for the params string in this example: once with attr=foo and value=bar,
//        // then with baz/bar, then Foo/frob, then baz/bar2.
//      }
//    if (error)
//      // handle parsing error
func (iter *URIParamsIter) Init(params string, length int, separators string, flags URIParamsFlags) {
	var arg0 *C.GUriParamsIter
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 *C.gchar
	var arg4 C.GUriParamsFlags

	arg0 = (*C.GUriParamsIter)(iter.Native())
	arg1 = (*C.gchar)(C.CString(params))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(length)
	arg3 = (*C.gchar)(C.CString(separators))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (C.GUriParamsFlags)(flags)

	C.g_uri_params_iter_init(arg0, arg1, arg2, arg3, arg4)
}

// Next advances @iter and retrieves the next attribute/value. false is returned
// if an error has occurred (in which case @error is set), or if the end of the
// iteration is reached (in which case @attribute and @value are set to nil and
// the iterator becomes invalid). If true is returned, g_uri_params_iter_next()
// may be called again to receive another attribute/value pair.
//
// Note that the same @attribute may be returned multiple times, since URIs
// allow repeated attributes.
func (iter *URIParamsIter) Next() (attribute string, value string, err error) {
	var arg0 *C.GUriParamsIter
	var arg1 **C.gchar // out
	var arg2 **C.gchar // out
	var gError *C.GError

	arg0 = (*C.GUriParamsIter)(iter.Native())

	ret := C.g_uri_params_iter_next(arg0, &arg1, &arg2, &gError)

	var ret0 string
	var ret1 string
	var goError error

	ret0 = C.GoString(arg1)
	C.free(unsafe.Pointer(arg1))

	ret1 = C.GoString(arg2)
	C.free(unsafe.Pointer(arg2))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// Variant is a variant datatype; it can contain one or more values along with
// information about the type of the values.
//
// A #GVariant may contain simple types, like an integer, or a boolean value; or
// complex types, like an array of two strings, or a dictionary of key value
// pairs. A #GVariant is also immutable: once it's been created neither its type
// nor its content can be modified further.
//
// GVariant is useful whenever data needs to be serialized, for example when
// sending method parameters in DBus, or when saving settings using GSettings.
//
// When creating a new #GVariant, you pass the data you want to store in it
// along with a string representing the type of data you wish to pass to it.
//
// For instance, if you want to create a #GVariant holding an integer value you
// can use:
//
//    GVariant *v = g_variant_new ("u", 40);
//
// The string "u" in the first argument tells #GVariant that the data passed to
// the constructor (40) is going to be an unsigned integer.
//
// More advanced examples of #GVariant in use can be found in documentation for
// [GVariant format strings][gvariant-format-strings-pointers].
//
// The range of possible values is determined by the type.
//
// The type system used by #GVariant is Type.
//
// #GVariant instances always have a type and a value (which are given at
// construction time). The type and value of a #GVariant instance can never
// change other than by the #GVariant itself being destroyed. A #GVariant cannot
// contain a pointer.
//
// #GVariant is reference counted using g_variant_ref() and g_variant_unref().
// #GVariant also has floating reference counts -- see g_variant_ref_sink().
//
// #GVariant is completely threadsafe. A #GVariant instance can be concurrently
// accessed in any way from any number of threads without problems.
//
// #GVariant is heavily optimised for dealing with data in serialised form. It
// works particularly well with data located in memory-mapped files. It can
// perform nearly all deserialisation operations in a small constant time,
// usually touching only a single memory page. Serialised #GVariant data can
// also be sent over the network.
//
// #GVariant is largely compatible with D-Bus. Almost all types of #GVariant
// instances can be sent over D-Bus. See Type for exceptions. (However,
// #GVariant's serialisation format is not the same as the serialisation format
// of a D-Bus message body: use BusMessage, in the gio library, for those.)
//
// For space-efficiency, the #GVariant serialisation format does not
// automatically include the variant's length, type or endianness, which must
// either be implied from context (such as knowledge that a particular file
// format always contains a little-endian G_VARIANT_TYPE_VARIANT which occupies
// the whole length of the file) or supplied out-of-band (for instance, a
// length, type and/or endianness indicator could be placed at the beginning of
// a file, network message or network stream).
//
// A #GVariant's size is limited mainly by any lower level operating system
// constraints, such as the number of bits in #gsize. For example, it is
// reasonable to have a 2GB file mapped into memory with File, and call
// g_variant_new_from_data() on it.
//
// For convenience to C programmers, #GVariant features powerful varargs-based
// value construction and destruction. This feature is designed to be embedded
// in other libraries.
//
// There is a Python-inspired text language for describing #GVariant values.
// #GVariant includes a printer for this language and a parser with type
// inferencing.
//
//
// Memory Use
//
// #GVariant tries to be quite efficient with respect to memory use. This
// section gives a rough idea of how much memory is used by the current
// implementation. The information here is subject to change in the future.
//
// The memory allocated by #GVariant can be grouped into 4 broad purposes:
// memory for serialised data, memory for the type information cache, buffer
// management memory and memory for the #GVariant structure itself.
//
//
// Serialised Data Memory
//
// This is the memory that is used for storing GVariant data in serialised form.
// This is what would be sent over the network or what would end up on disk, not
// counting any indicator of the endianness, or of the length or type of the
// top-level variant.
//
// The amount of memory required to store a boolean is 1 byte. 16, 32 and 64 bit
// integers and double precision floating point numbers use their "natural"
// size. Strings (including object path and signature strings) are stored with a
// nul terminator, and as such use the length of the string plus 1 byte.
//
// Maybe types use no space at all to represent the null value and use the same
// amount of space (sometimes plus one byte) as the equivalent non-maybe-typed
// value to represent the non-null case.
//
// Arrays use the amount of space required to store each of their members,
// concatenated. Additionally, if the items stored in an array are not of a
// fixed-size (ie: strings, other arrays, etc) then an additional framing offset
// is stored for each item. The size of this offset is either 1, 2 or 4 bytes
// depending on the overall size of the container. Additionally, extra padding
// bytes are added as required for alignment of child values.
//
// Tuples (including dictionary entries) use the amount of space required to
// store each of their members, concatenated, plus one framing offset (as per
// arrays) for each non-fixed-sized item in the tuple, except for the last one.
// Additionally, extra padding bytes are added as required for alignment of
// child values.
//
// Variants use the same amount of space as the item inside of the variant, plus
// 1 byte, plus the length of the type string for the item inside the variant.
//
// As an example, consider a dictionary mapping strings to variants. In the case
// that the dictionary is empty, 0 bytes are required for the serialisation.
//
// If we add an item "width" that maps to the int32 value of 500 then we will
// use 4 byte to store the int32 (so 6 for the variant containing it) and 6
// bytes for the string. The variant must be aligned to 8 after the 6 bytes of
// the string, so that's 2 extra bytes. 6 (string) + 2 (padding) + 6 (variant)
// is 14 bytes used for the dictionary entry. An additional 1 byte is added to
// the array as a framing offset making a total of 15 bytes.
//
// If we add another entry, "title" that maps to a nullable string that happens
// to have a value of null, then we use 0 bytes for the null value (and 3 bytes
// for the variant to contain it along with its type string) plus 6 bytes for
// the string. Again, we need 2 padding bytes. That makes a total of 6 + 2 + 3 =
// 11 bytes.
//
// We now require extra padding between the two items in the array. After the 14
// bytes of the first item, that's 2 bytes required. We now require 2 framing
// offsets for an extra two bytes. 14 + 2 + 11 + 2 = 29 bytes to encode the
// entire two-item dictionary.
//
//
// Type Information Cache
//
// For each GVariant type that currently exists in the program a type
// information structure is kept in the type information cache. The type
// information structure is required for rapid deserialisation.
//
// Continuing with the above example, if a #GVariant exists with the type
// "a{sv}" then a type information struct will exist for "a{sv}", "{sv}", "s",
// and "v". Multiple uses of the same type will share the same type information.
// Additionally, all single-digit types are stored in read-only static memory
// and do not contribute to the writable memory footprint of a program using
// #GVariant.
//
// Aside from the type information structures stored in read-only memory, there
// are two forms of type information. One is used for container types where
// there is a single element type: arrays and maybe types. The other is used for
// container types where there are multiple element types: tuples and dictionary
// entries.
//
// Array type info structures are 6 * sizeof (void *), plus the memory required
// to store the type string itself. This means that on 32-bit systems, the cache
// entry for "a{sv}" would require 30 bytes of memory (plus malloc overhead).
//
// Tuple type info structures are 6 * sizeof (void *), plus 4 * sizeof (void *)
// for each item in the tuple, plus the memory required to store the type string
// itself. A 2-item tuple, for example, would have a type information structure
// that consumed writable memory in the size of 14 * sizeof (void *) (plus type
// string) This means that on 32-bit systems, the cache entry for "{sv}" would
// require 61 bytes of memory (plus malloc overhead).
//
// This means that in total, for our "a{sv}" example, 91 bytes of type
// information would be allocated.
//
// The type information cache, additionally, uses a Table to store and look up
// the cached items and stores a pointer to this hash table in static storage.
// The hash table is freed when there are zero items in the type cache.
//
// Although these sizes may seem large it is important to remember that a
// program will probably only have a very small number of different types of
// values in it and that only one type information structure is required for
// many different values of the same type.
//
//
// Buffer Management Memory
//
// #GVariant uses an internal buffer management structure to deal with the
// various different possible sources of serialised data that it uses. The
// buffer is responsible for ensuring that the correct call is made when the
// data is no longer in use by #GVariant. This may involve a g_free() or a
// g_slice_free() or even g_mapped_file_unref().
//
// One buffer management structure is used for each chunk of serialised data.
// The size of the buffer management structure is 4 * (void *). On 32-bit
// systems, that's 16 bytes.
//
//
// GVariant structure
//
// The size of a #GVariant structure is 6 * (void *). On 32-bit systems, that's
// 24 bytes.
//
// #GVariant structures only exist if they are explicitly created with API
// calls. For example, if a #GVariant is constructed out of serialised data for
// the example given above (with the dictionary) then although there are 9
// individual values that comprise the entire dictionary (two keys, two values,
// two variants containing the values, two dictionary entries, plus the
// dictionary itself), only 1 #GVariant instance exists -- the one referring to
// the dictionary.
//
// If calls are made to start accessing the other values then #GVariant
// instances will exist for those values only for as long as they are in use
// (ie: until you call g_variant_unref()). The type information is shared. The
// serialised data and the buffer management structure for that serialised data
// is shared by the child.
//
//
// Summary
//
// To put the entire example together, for our dictionary mapping strings to
// variants (with two entries, as given above), we are using 91 bytes of memory
// for type information, 29 bytes of memory for the serialised data, 16 bytes
// for buffer management and 24 bytes for the #GVariant instance, or a total of
// 160 bytes, plus malloc overhead. If we were to use
// g_variant_get_child_value() to access the two dictionary entries, we would
// use an additional 48 bytes. If we were to have other dictionaries of the same
// type, we would use more memory for the serialised data and buffer management
// for those dictionaries, but the type information would be shared.
type Variant struct {
	native C.GVariant
}

// WrapVariant wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapVariant(ptr unsafe.Pointer) *Variant {
	if ptr == nil {
		return nil
	}

	return (*Variant)(ptr)
}

func marshalVariant(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapVariant(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (v *Variant) Native() unsafe.Pointer {
	return unsafe.Pointer(&v.native)
}

// NewVariantArray constructs a struct Variant.
func NewVariantArray(childType *VariantType, children []*Variant) *Variant {
	var arg1 *C.GVariantType
	var arg2 **C.GVariant
	var arg3 C.gsize

	arg1 = (*C.GVariantType)(childType.Native())
	arg2 = (**C.GVariant)(unsafe.Pointer(&children[0]))
	arg3 = len(children)
	defer runtime.KeepAlive(children)

	ret := C.g_variant_new_array(arg1, arg2, arg3)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
	}

	return ret0
}

// NewVariantBoolean constructs a struct Variant.
func NewVariantBoolean(value bool) *Variant {
	var arg1 C.gboolean

	if value {
		arg1 = C.TRUE
	}

	ret := C.g_variant_new_boolean(arg1)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
	}

	return ret0
}

// NewVariantByte constructs a struct Variant.
func NewVariantByte(value byte) *Variant {
	var arg1 C.guint8

	arg1 = C.guint8(value)

	ret := C.g_variant_new_byte(arg1)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
	}

	return ret0
}

// NewVariantBytestring constructs a struct Variant.
func NewVariantBytestring(string []byte) *Variant {
	var arg1 *C.gchar

	{
		var dst []C.guint8
		ptr := C.malloc(C.sizeof_guint8 * (len(string) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(string)
		sliceHeader.Cap = len(string)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(string); i++ {
			src := string[i]
			dst[i] = C.guint8(src)
		}

		arg1 = (*C.gchar)(unsafe.Pointer(ptr))
	}

	ret := C.g_variant_new_bytestring(arg1)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
	}

	return ret0
}

// NewVariantBytestringArray constructs a struct Variant.
func NewVariantBytestringArray(strv []string) *Variant {
	var arg1 **C.gchar
	var arg2 C.gssize

	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * len(strv))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(strv)
		sliceHeader.Cap = len(strv)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(strv); i++ {
			src := strv[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg1 = (**C.gchar)(unsafe.Pointer(ptr))
		arg2 = len(strv)
	}

	ret := C.g_variant_new_bytestring_array(arg1, arg2)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
	}

	return ret0
}

// NewVariantDictEntry constructs a struct Variant.
func NewVariantDictEntry(key *Variant, value *Variant) *Variant {
	var arg1 *C.GVariant
	var arg2 *C.GVariant

	arg1 = (*C.GVariant)(key.Native())
	arg2 = (*C.GVariant)(value.Native())

	ret := C.g_variant_new_dict_entry(arg1, arg2)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
	}

	return ret0
}

// NewVariantDouble constructs a struct Variant.
func NewVariantDouble(value float64) *Variant {
	var arg1 C.gdouble

	arg1 = C.gdouble(value)

	ret := C.g_variant_new_double(arg1)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
	}

	return ret0
}

// NewVariantFixedArray constructs a struct Variant.
func NewVariantFixedArray(elementType *VariantType, elements interface{}, nElements uint, elementSize uint) *Variant {
	var arg1 *C.GVariantType
	var arg2 C.gpointer
	var arg3 C.gsize
	var arg4 C.gsize

	arg1 = (*C.GVariantType)(elementType.Native())
	arg2 = C.gpointer(box.Assign(elements))
	arg3 = C.gsize(nElements)
	arg4 = C.gsize(elementSize)

	ret := C.g_variant_new_fixed_array(arg1, arg2, arg3, arg4)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
	}

	return ret0
}

// NewVariantFromBytes constructs a struct Variant.
func NewVariantFromBytes(typ *VariantType, bytes *Bytes, trusted bool) *Variant {
	var arg1 *C.GVariantType
	var arg2 *C.GBytes
	var arg3 C.gboolean

	arg1 = (*C.GVariantType)(typ.Native())
	arg2 = (*C.GBytes)(bytes.Native())
	if trusted {
		arg3 = C.TRUE
	}

	ret := C.g_variant_new_from_bytes(arg1, arg2, arg3)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
	}

	return ret0
}

// NewVariantHandle constructs a struct Variant.
func NewVariantHandle(value int32) *Variant {
	var arg1 C.gint32

	arg1 = C.gint32(value)

	ret := C.g_variant_new_handle(arg1)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
	}

	return ret0
}

// NewVariantInt16 constructs a struct Variant.
func NewVariantInt16(value int16) *Variant {
	var arg1 C.gint16

	arg1 = C.gint16(value)

	ret := C.g_variant_new_int16(arg1)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
	}

	return ret0
}

// NewVariantInt32 constructs a struct Variant.
func NewVariantInt32(value int32) *Variant {
	var arg1 C.gint32

	arg1 = C.gint32(value)

	ret := C.g_variant_new_int32(arg1)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
	}

	return ret0
}

// NewVariantInt64 constructs a struct Variant.
func NewVariantInt64(value int64) *Variant {
	var arg1 C.gint64

	arg1 = C.gint64(value)

	ret := C.g_variant_new_int64(arg1)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
	}

	return ret0
}

// NewVariantMaybe constructs a struct Variant.
func NewVariantMaybe(childType *VariantType, child *Variant) *Variant {
	var arg1 *C.GVariantType
	var arg2 *C.GVariant

	arg1 = (*C.GVariantType)(childType.Native())
	arg2 = (*C.GVariant)(child.Native())

	ret := C.g_variant_new_maybe(arg1, arg2)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
	}

	return ret0
}

// NewVariantObjectPath constructs a struct Variant.
func NewVariantObjectPath(objectPath string) *Variant {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_variant_new_object_path(arg1)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
	}

	return ret0
}

// NewVariantObjv constructs a struct Variant.
func NewVariantObjv(strv []string) *Variant {
	var arg1 **C.gchar
	var arg2 C.gssize

	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * len(strv))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(strv)
		sliceHeader.Cap = len(strv)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(strv); i++ {
			src := strv[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg1 = (**C.gchar)(unsafe.Pointer(ptr))
		arg2 = len(strv)
	}

	ret := C.g_variant_new_objv(arg1, arg2)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
	}

	return ret0
}

// NewVariantSignature constructs a struct Variant.
func NewVariantSignature(signature string) *Variant {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(signature))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_variant_new_signature(arg1)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
	}

	return ret0
}

// NewVariantString constructs a struct Variant.
func NewVariantString(string string) *Variant {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_variant_new_string(arg1)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
	}

	return ret0
}

// NewVariantStrv constructs a struct Variant.
func NewVariantStrv(strv []string) *Variant {
	var arg1 **C.gchar
	var arg2 C.gssize

	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * len(strv))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(strv)
		sliceHeader.Cap = len(strv)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(strv); i++ {
			src := strv[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg1 = (**C.gchar)(unsafe.Pointer(ptr))
		arg2 = len(strv)
	}

	ret := C.g_variant_new_strv(arg1, arg2)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
	}

	return ret0
}

// NewVariantTakeString constructs a struct Variant.
func NewVariantTakeString(string string) *Variant {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_variant_new_take_string(arg1)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
	}

	return ret0
}

// NewVariantTuple constructs a struct Variant.
func NewVariantTuple(children []*Variant) *Variant {
	var arg1 **C.GVariant
	var arg2 C.gsize

	arg1 = (**C.GVariant)(unsafe.Pointer(&children[0]))
	arg2 = len(children)
	defer runtime.KeepAlive(children)

	ret := C.g_variant_new_tuple(arg1, arg2)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
	}

	return ret0
}

// NewVariantUint16 constructs a struct Variant.
func NewVariantUint16(value uint16) *Variant {
	var arg1 C.guint16

	arg1 = C.guint16(value)

	ret := C.g_variant_new_uint16(arg1)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
	}

	return ret0
}

// NewVariantUint32 constructs a struct Variant.
func NewVariantUint32(value uint32) *Variant {
	var arg1 C.guint32

	arg1 = C.guint32(value)

	ret := C.g_variant_new_uint32(arg1)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
	}

	return ret0
}

// NewVariantUint64 constructs a struct Variant.
func NewVariantUint64(value uint64) *Variant {
	var arg1 C.guint64

	arg1 = C.guint64(value)

	ret := C.g_variant_new_uint64(arg1)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
	}

	return ret0
}

// NewVariantVariant constructs a struct Variant.
func NewVariantVariant(value *Variant) *Variant {
	var arg1 *C.GVariant

	arg1 = (*C.GVariant)(value.Native())

	ret := C.g_variant_new_variant(arg1)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
	}

	return ret0
}

// Byteswap performs a byteswapping operation on the contents of @value. The
// result is that all multi-byte numeric data contained in @value is
// byteswapped. That includes 16, 32, and 64bit signed and unsigned integers as
// well as file handles and double precision floating point values.
//
// This function is an identity mapping on any value that does not contain
// multi-byte numeric data. That include strings, booleans, bytes and containers
// containing only these things (recursively).
//
// The returned value is always in normal form and is marked as trusted.
func (value *Variant) Byteswap() *Variant {
	var arg0 *C.GVariant

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_byteswap(arg0)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Variant) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// CheckFormatString checks if calling g_variant_get() with @format_string on
// @value would be valid from a type-compatibility standpoint. @format_string is
// assumed to be a valid format string (from a syntactic standpoint).
//
// If @copy_only is true then this function additionally checks that it would be
// safe to call g_variant_unref() on @value immediately after the call to
// g_variant_get() without invalidating the result. This is only possible if
// deep copies are made (ie: there are no pointers to the data inside of the
// soon-to-be-freed #GVariant instance). If this check fails then a g_critical()
// is printed and false is returned.
//
// This function is meant to be used by functions that wish to provide varargs
// accessors to #GVariant values of uncertain values (eg: g_variant_lookup() or
// g_menu_model_get_item_attribute()).
func (value *Variant) CheckFormatString(formatString string, copyOnly bool) bool {
	var arg0 *C.GVariant
	var arg1 *C.gchar
	var arg2 C.gboolean

	arg0 = (*C.GVariant)(value.Native())
	arg1 = (*C.gchar)(C.CString(formatString))
	defer C.free(unsafe.Pointer(arg1))
	if copyOnly {
		arg2 = C.TRUE
	}

	ret := C.g_variant_check_format_string(arg0, arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Classify classifies @value according to its top-level type.
func (value *Variant) Classify() VariantClass {
	var arg0 *C.GVariant

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_classify(arg0)

	var ret0 VariantClass

	ret0 = VariantClass(ret)

	return ret0
}

// Compare compares @one and @two.
//
// The types of @one and @two are #gconstpointer only to allow use of this
// function with #GTree, Array, etc. They must each be a #GVariant.
//
// Comparison is only defined for basic types (ie: booleans, numbers, strings).
// For booleans, false is less than true. Numbers are ordered in the usual way.
// Strings are in ASCII lexographical order.
//
// It is a programmer error to attempt to compare container values or two values
// that have types that are not exactly equal. For example, you cannot compare a
// 32-bit signed integer with a 32-bit unsigned integer. Also note that this
// function is not particularly well-behaved when it comes to comparison of
// doubles; in particular, the handling of incomparable values (ie: NaN) is
// undefined.
//
// If you only require an equality comparison, g_variant_equal() is more
// general.
func (one *Variant) Compare(two Variant) int {
	var arg0 C.gpointer
	var arg1 C.gpointer

	arg0 = (C.gpointer)(one.Native())
	arg1 = (C.gpointer)(two.Native())

	ret := C.g_variant_compare(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// DupBytestring: similar to g_variant_get_bytestring() except that instead of
// returning a constant string, the string is duplicated.
//
// The return value must be freed using g_free().
func (value *Variant) DupBytestring() (length uint, guint8s []byte) {
	var arg0 *C.GVariant
	var arg1 *C.gsize // out

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_dup_bytestring(arg0, &arg1)

	var ret0 uint
	var ret1 []byte

	ret0 = uint(arg1)

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret1))
		sliceHeader.Data = uintptr(unsafe.Pointer(ret))
		sliceHeader.Len = arg1
		sliceHeader.Cap = arg1
		runtime.SetFinalizer(&ret, func() {
			C.free(unsafe.Pointer(ret))
		})
		defer runtime.KeepAlive(ret)
	}

	return ret0, ret1
}

// DupBytestringArray gets the contents of an array of array of bytes #GVariant.
// This call makes a deep copy; the return result should be released with
// g_strfreev().
//
// If @length is non-nil then the number of elements in the result is stored
// there. In any case, the resulting array will be nil-terminated.
//
// For an empty array, @length will be set to 0 and a pointer to a nil pointer
// will be returned.
func (value *Variant) DupBytestringArray() (length uint, utf8s []string) {
	var arg0 *C.GVariant
	var arg1 *C.gsize // out

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_dup_bytestring_array(arg0, &arg1)

	var ret0 uint
	var ret1 []string

	ret0 = uint(arg1)

	{
		ret1 = make([]string, arg1)
		for i := 0; i < uintptr(arg1); i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0, ret1
}

// DupObjv gets the contents of an array of object paths #GVariant. This call
// makes a deep copy; the return result should be released with g_strfreev().
//
// If @length is non-nil then the number of elements in the result is stored
// there. In any case, the resulting array will be nil-terminated.
//
// For an empty array, @length will be set to 0 and a pointer to a nil pointer
// will be returned.
func (value *Variant) DupObjv() (length uint, utf8s []string) {
	var arg0 *C.GVariant
	var arg1 *C.gsize // out

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_dup_objv(arg0, &arg1)

	var ret0 uint
	var ret1 []string

	ret0 = uint(arg1)

	{
		ret1 = make([]string, arg1)
		for i := 0; i < uintptr(arg1); i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0, ret1
}

// DupString: similar to g_variant_get_string() except that instead of returning
// a constant string, the string is duplicated.
//
// The string will always be UTF-8 encoded.
//
// The return value must be freed using g_free().
func (value *Variant) DupString() (length uint, utf8 string) {
	var arg0 *C.GVariant
	var arg1 *C.gsize // out

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_dup_string(arg0, &arg1)

	var ret0 uint
	var ret1 string

	ret0 = uint(arg1)

	ret1 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0, ret1
}

// DupStrv gets the contents of an array of strings #GVariant. This call makes a
// deep copy; the return result should be released with g_strfreev().
//
// If @length is non-nil then the number of elements in the result is stored
// there. In any case, the resulting array will be nil-terminated.
//
// For an empty array, @length will be set to 0 and a pointer to a nil pointer
// will be returned.
func (value *Variant) DupStrv() (length uint, utf8s []string) {
	var arg0 *C.GVariant
	var arg1 *C.gsize // out

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_dup_strv(arg0, &arg1)

	var ret0 uint
	var ret1 []string

	ret0 = uint(arg1)

	{
		ret1 = make([]string, arg1)
		for i := 0; i < uintptr(arg1); i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0, ret1
}

// Equal checks if @one and @two have the same type and value.
//
// The types of @one and @two are #gconstpointer only to allow use of this
// function with Table. They must each be a #GVariant.
func (one *Variant) Equal(two Variant) bool {
	var arg0 C.gpointer
	var arg1 C.gpointer

	arg0 = (C.gpointer)(one.Native())
	arg1 = (C.gpointer)(two.Native())

	ret := C.g_variant_equal(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Boolean returns the boolean value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_BOOLEAN.
func (value *Variant) Boolean() bool {
	var arg0 *C.GVariant

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_get_boolean(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Byte returns the byte value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_BYTE.
func (value *Variant) Byte() byte {
	var arg0 *C.GVariant

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_get_byte(arg0)

	var ret0 byte

	ret0 = byte(ret)

	return ret0
}

// Bytestring returns the string value of a #GVariant instance with an
// array-of-bytes type. The string has no particular encoding.
//
// If the array does not end with a nul terminator character, the empty string
// is returned. For this reason, you can always trust that a non-nil
// nul-terminated string will be returned by this function.
//
// If the array contains a nul terminator character somewhere other than the
// last byte then the returned string is the string, up to the first such nul
// character.
//
// g_variant_get_fixed_array() should be used instead if the array contains
// arbitrary data that could not be nul-terminated or could contain nul bytes.
//
// It is an error to call this function with a @value that is not an array of
// bytes.
//
// The return value remains valid as long as @value exists.
func (value *Variant) Bytestring() []byte {
	var arg0 *C.GVariant

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_get_bytestring(arg0)

	var ret0 []byte

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]byte, length)
		for i := 0; i < length; i++ {
			src := (C.guint8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = byte(src)
		}
	}

	return ret0
}

// BytestringArray gets the contents of an array of array of bytes #GVariant.
// This call makes a shallow copy; the return result should be released with
// g_free(), but the individual strings must not be modified.
//
// If @length is non-nil then the number of elements in the result is stored
// there. In any case, the resulting array will be nil-terminated.
//
// For an empty array, @length will be set to 0 and a pointer to a nil pointer
// will be returned.
func (value *Variant) BytestringArray() (length uint, utf8s []string) {
	var arg0 *C.GVariant
	var arg1 *C.gsize // out

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_get_bytestring_array(arg0, &arg1)

	var ret0 uint
	var ret1 []string

	ret0 = uint(arg1)

	{
		ret1 = make([]string, arg1)
		for i := 0; i < uintptr(arg1); i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = C.GoString(src)
		}
	}

	return ret0, ret1
}

// ChildValue reads a child item out of a container #GVariant instance. This
// includes variants, maybes, arrays, tuples and dictionary entries. It is an
// error to call this function on any other type of #GVariant.
//
// It is an error if @index_ is greater than the number of child items in the
// container. See g_variant_n_children().
//
// The returned value is never floating. You should free it with
// g_variant_unref() when you're done with it.
//
// Note that values borrowed from the returned child are not guaranteed to still
// be valid after the child is freed even if you still hold a reference to
// @value, if @value has not been serialised at the time this function is
// called. To avoid this, you can serialize @value by calling
// g_variant_get_data() and optionally ignoring the return value.
//
// There may be implementation specific restrictions on deeply nested values,
// which would result in the unit tuple being returned as the child value,
// instead of further nested children. #GVariant is guaranteed to handle nesting
// up to at least 64 levels.
//
// This function is O(1).
func (value *Variant) ChildValue(index_ uint) *Variant {
	var arg0 *C.GVariant
	var arg1 C.gsize

	arg0 = (*C.GVariant)(value.Native())
	arg1 = C.gsize(index_)

	ret := C.g_variant_get_child_value(arg0, arg1)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Variant) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Data returns a pointer to the serialised form of a #GVariant instance. The
// returned data may not be in fully-normalised form if read from an untrusted
// source. The returned data must not be freed; it remains valid for as long as
// @value exists.
//
// If @value is a fixed-sized value that was deserialised from a corrupted
// serialised container then nil may be returned. In this case, the proper thing
// to do is typically to use the appropriate number of nul bytes in place of
// @value. If @value is not fixed-sized then nil is never returned.
//
// In the case that @value is already in serialised form, this function is O(1).
// If the value is not already in serialised form, serialisation occurs
// implicitly and is approximately O(n) in the size of the result.
//
// To deserialise the data returned by this function, in addition to the
// serialised data, you must know the type of the #GVariant, and (if the machine
// might be different) the endianness of the machine that stored it. As a
// result, file formats or network messages that incorporate serialised
// #GVariants must include this information either implicitly (for instance "the
// file always contains a G_VARIANT_TYPE_VARIANT and it is always in
// little-endian order") or explicitly (by storing the type and/or endianness in
// addition to the serialised data).
func (value *Variant) Data() interface{} {
	var arg0 *C.GVariant

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_get_data(arg0)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// DataAsBytes returns a pointer to the serialised form of a #GVariant instance.
// The semantics of this function are exactly the same as g_variant_get_data(),
// except that the returned #GBytes holds a reference to the variant data.
func (value *Variant) DataAsBytes() *Bytes {
	var arg0 *C.GVariant

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_get_data_as_bytes(arg0)

	var ret0 *Bytes

	{
		ret0 = WrapBytes(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Bytes) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Double returns the double precision floating point value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_DOUBLE.
func (value *Variant) Double() float64 {
	var arg0 *C.GVariant

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_get_double(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// FixedArray provides access to the serialised data for an array of fixed-sized
// items.
//
// @value must be an array with fixed-sized elements. Numeric types are
// fixed-size, as are tuples containing only other fixed-sized types.
//
// @element_size must be the size of a single element in the array, as given by
// the section on [serialized data memory][gvariant-serialised-data-memory].
//
// In particular, arrays of these fixed-sized types can be interpreted as an
// array of the given C type, with @element_size set to the size the appropriate
// type: - G_VARIANT_TYPE_INT16 (etc.): #gint16 (etc.) - G_VARIANT_TYPE_BOOLEAN:
// #guchar (not #gboolean!) - G_VARIANT_TYPE_BYTE: #guint8 -
// G_VARIANT_TYPE_HANDLE: #guint32 - G_VARIANT_TYPE_DOUBLE: #gdouble
//
// For example, if calling this function for an array of 32-bit integers, you
// might say `sizeof(gint32)`. This value isn't used except for the purpose of a
// double-check that the form of the serialised data matches the caller's
// expectation.
//
// @n_elements, which must be non-nil, is set equal to the number of items in
// the array.
func (value *Variant) FixedArray(elementSize uint) (nElements uint, gpointers []interface{}) {
	var arg0 *C.GVariant
	var arg1 *C.gsize // out
	var arg2 C.gsize

	arg0 = (*C.GVariant)(value.Native())
	arg2 = C.gsize(elementSize)

	ret := C.g_variant_get_fixed_array(arg0, &arg1, arg2)

	var ret0 uint
	var ret1 []interface{}

	ret0 = uint(arg1)

	{
		ret1 = make([]interface{}, arg1)
		for i := 0; i < uintptr(arg1); i++ {
			src := (C.gpointer)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = box.Get(uintptr(src)).([]interface{})
		}
	}

	return ret0, ret1
}

// Handle returns the 32-bit signed integer value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_HANDLE.
//
// By convention, handles are indexes into an array of file descriptors that are
// sent alongside a D-Bus message. If you're not interacting with D-Bus, you
// probably don't need them.
func (value *Variant) Handle() int32 {
	var arg0 *C.GVariant

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_get_handle(arg0)

	var ret0 int32

	ret0 = int32(ret)

	return ret0
}

// Int16 returns the 16-bit signed integer value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_INT16.
func (value *Variant) Int16() int16 {
	var arg0 *C.GVariant

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_get_int16(arg0)

	var ret0 int16

	ret0 = int16(ret)

	return ret0
}

// Int32 returns the 32-bit signed integer value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_INT32.
func (value *Variant) Int32() int32 {
	var arg0 *C.GVariant

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_get_int32(arg0)

	var ret0 int32

	ret0 = int32(ret)

	return ret0
}

// Int64 returns the 64-bit signed integer value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_INT64.
func (value *Variant) Int64() int64 {
	var arg0 *C.GVariant

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_get_int64(arg0)

	var ret0 int64

	ret0 = int64(ret)

	return ret0
}

// Maybe: given a maybe-typed #GVariant instance, extract its value. If the
// value is Nothing, then this function returns nil.
func (value *Variant) Maybe() *Variant {
	var arg0 *C.GVariant

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_get_maybe(arg0)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Variant) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NormalForm gets a #GVariant instance that has the same value as @value and is
// trusted to be in normal form.
//
// If @value is already trusted to be in normal form then a new reference to
// @value is returned.
//
// If @value is not already trusted, then it is scanned to check if it is in
// normal form. If it is found to be in normal form then it is marked as trusted
// and a new reference to it is returned.
//
// If @value is found not to be in normal form then a new trusted #GVariant is
// created with the same value as @value.
//
// It makes sense to call this function if you've received #GVariant data from
// untrusted sources and you want to ensure your serialised output is definitely
// in normal form.
//
// If @value is already in normal form, a new reference will be returned (which
// will be floating if @value is floating). If it is not in normal form, the
// newly created #GVariant will be returned with a single non-floating
// reference. Typically, g_variant_take_ref() should be called on the return
// value from this function to guarantee ownership of a single non-floating
// reference to it.
func (value *Variant) NormalForm() *Variant {
	var arg0 *C.GVariant

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_get_normal_form(arg0)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Variant) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Objv gets the contents of an array of object paths #GVariant. This call makes
// a shallow copy; the return result should be released with g_free(), but the
// individual strings must not be modified.
//
// If @length is non-nil then the number of elements in the result is stored
// there. In any case, the resulting array will be nil-terminated.
//
// For an empty array, @length will be set to 0 and a pointer to a nil pointer
// will be returned.
func (value *Variant) Objv() (length uint, utf8s []string) {
	var arg0 *C.GVariant
	var arg1 *C.gsize // out

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_get_objv(arg0, &arg1)

	var ret0 uint
	var ret1 []string

	ret0 = uint(arg1)

	{
		ret1 = make([]string, arg1)
		for i := 0; i < uintptr(arg1); i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = C.GoString(src)
		}
	}

	return ret0, ret1
}

// Size determines the number of bytes that would be required to store @value
// with g_variant_store().
//
// If @value has a fixed-sized type then this function always returned that
// fixed size.
//
// In the case that @value is already in serialised form or the size has already
// been calculated (ie: this function has been called before) then this function
// is O(1). Otherwise, the size is calculated, an operation which is
// approximately O(n) in the number of values involved.
func (value *Variant) Size() uint {
	var arg0 *C.GVariant

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_get_size(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// String returns the string value of a #GVariant instance with a string type.
// This includes the types G_VARIANT_TYPE_STRING, G_VARIANT_TYPE_OBJECT_PATH and
// G_VARIANT_TYPE_SIGNATURE.
//
// The string will always be UTF-8 encoded, will never be nil, and will never
// contain nul bytes.
//
// If @length is non-nil then the length of the string (in bytes) is returned
// there. For trusted values, this information is already known. Untrusted
// values will be validated and, if valid, a strlen() will be performed. If
// invalid, a default value will be returned — for G_VARIANT_TYPE_OBJECT_PATH,
// this is `"/"`, and for other types it is the empty string.
//
// It is an error to call this function with a @value of any type other than
// those three.
//
// The return value remains valid as long as @value exists.
func (value *Variant) String() (length uint, utf8 string) {
	var arg0 *C.GVariant
	var arg1 *C.gsize // out

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_get_string(arg0, &arg1)

	var ret0 uint
	var ret1 string

	ret0 = uint(arg1)

	ret1 = C.GoString(ret)

	return ret0, ret1
}

// Strv gets the contents of an array of strings #GVariant. This call makes a
// shallow copy; the return result should be released with g_free(), but the
// individual strings must not be modified.
//
// If @length is non-nil then the number of elements in the result is stored
// there. In any case, the resulting array will be nil-terminated.
//
// For an empty array, @length will be set to 0 and a pointer to a nil pointer
// will be returned.
func (value *Variant) Strv() (length uint, utf8s []string) {
	var arg0 *C.GVariant
	var arg1 *C.gsize // out

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_get_strv(arg0, &arg1)

	var ret0 uint
	var ret1 []string

	ret0 = uint(arg1)

	{
		ret1 = make([]string, arg1)
		for i := 0; i < uintptr(arg1); i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = C.GoString(src)
		}
	}

	return ret0, ret1
}

// Type determines the type of @value.
//
// The return value is valid for the lifetime of @value and must not be freed.
func (value *Variant) Type() *VariantType {
	var arg0 *C.GVariant

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_get_type(arg0)

	var ret0 *VariantType

	{
		ret0 = WrapVariantType(unsafe.Pointer(ret))
	}

	return ret0
}

// TypeString returns the type string of @value. Unlike the result of calling
// g_variant_type_peek_string(), this string is nul-terminated. This string
// belongs to #GVariant and must not be freed.
func (value *Variant) TypeString() string {
	var arg0 *C.GVariant

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_get_type_string(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Uint16 returns the 16-bit unsigned integer value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_UINT16.
func (value *Variant) Uint16() uint16 {
	var arg0 *C.GVariant

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_get_uint16(arg0)

	var ret0 uint16

	ret0 = uint16(ret)

	return ret0
}

// Uint32 returns the 32-bit unsigned integer value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_UINT32.
func (value *Variant) Uint32() uint32 {
	var arg0 *C.GVariant

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_get_uint32(arg0)

	var ret0 uint32

	ret0 = uint32(ret)

	return ret0
}

// Uint64 returns the 64-bit unsigned integer value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_UINT64.
func (value *Variant) Uint64() uint64 {
	var arg0 *C.GVariant

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_get_uint64(arg0)

	var ret0 uint64

	ret0 = uint64(ret)

	return ret0
}

// Variant unboxes @value. The result is the #GVariant instance that was
// contained in @value.
func (value *Variant) Variant() *Variant {
	var arg0 *C.GVariant

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_get_variant(arg0)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Variant) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Hash generates a hash value for a #GVariant instance.
//
// The output of this function is guaranteed to be the same for a given value
// only per-process. It may change between different processor architectures or
// even different versions of GLib. Do not use this function as a basis for
// building protocols or file formats.
//
// The type of @value is #gconstpointer only to allow use of this function with
// Table. @value must be a #GVariant.
func (value *Variant) Hash() uint {
	var arg0 C.gpointer

	arg0 = (C.gpointer)(value.Native())

	ret := C.g_variant_hash(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// IsContainer checks if @value is a container.
func (value *Variant) IsContainer() bool {
	var arg0 *C.GVariant

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_is_container(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IsFloating checks whether @value has a floating reference count.
//
// This function should only ever be used to assert that a given variant is or
// is not floating, or for debug purposes. To acquire a reference to a variant
// that might be floating, always use g_variant_ref_sink() or
// g_variant_take_ref().
//
// See g_variant_ref_sink() for more information about floating reference
// counts.
func (value *Variant) IsFloating() bool {
	var arg0 *C.GVariant

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_is_floating(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IsNormalForm checks if @value is in normal form.
//
// The main reason to do this is to detect if a given chunk of serialised data
// is in normal form: load the data into a #GVariant using
// g_variant_new_from_data() and then use this function to check.
//
// If @value is found to be in normal form then it will be marked as being
// trusted. If the value was already marked as being trusted then this function
// will immediately return true.
//
// There may be implementation specific restrictions on deeply nested values.
// GVariant is guaranteed to handle nesting up to at least 64 levels.
func (value *Variant) IsNormalForm() bool {
	var arg0 *C.GVariant

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_is_normal_form(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IsOfType checks if a value has a type matching the provided type.
func (value *Variant) IsOfType(typ *VariantType) bool {
	var arg0 *C.GVariant
	var arg1 *C.GVariantType

	arg0 = (*C.GVariant)(value.Native())
	arg1 = (*C.GVariantType)(typ.Native())

	ret := C.g_variant_is_of_type(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// NewIter creates a heap-allocated Iter for iterating over the items in @value.
//
// Use g_variant_iter_free() to free the return value when you no longer need
// it.
//
// A reference is taken to @value and will be released only when
// g_variant_iter_free() is called.
func (value *Variant) NewIter() *VariantIter {
	var arg0 *C.GVariant

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_iter_new(arg0)

	var ret0 *VariantIter

	{
		ret0 = WrapVariantIter(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *VariantIter) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// LookupValue looks up a value in a dictionary #GVariant.
//
// This function works with dictionaries of the type a{s*} (and equally well
// with type a{o*}, but we only further discuss the string case for sake of
// clarity).
//
// In the event that @dictionary has the type a{sv}, the @expected_type string
// specifies what type of value is expected to be inside of the variant. If the
// value inside the variant has a different type then nil is returned. In the
// event that @dictionary has a value type other than v then @expected_type must
// directly match the value type and it is used to unpack the value directly or
// an error occurs.
//
// In either case, if @key is not found in @dictionary, nil is returned.
//
// If the key is found and the value has the correct type, it is returned. If
// @expected_type was specified then any non-nil return value will have this
// type.
//
// This function is currently implemented with a linear scan. If you plan to do
// many lookups then Dict may be more efficient.
func (dictionary *Variant) LookupValue(key string, expectedType *VariantType) *Variant {
	var arg0 *C.GVariant
	var arg1 *C.gchar
	var arg2 *C.GVariantType

	arg0 = (*C.GVariant)(dictionary.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GVariantType)(expectedType.Native())

	ret := C.g_variant_lookup_value(arg0, arg1, arg2)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Variant) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NChildren determines the number of children in a container #GVariant
// instance. This includes variants, maybes, arrays, tuples and dictionary
// entries. It is an error to call this function on any other type of #GVariant.
//
// For variants, the return value is always 1. For values with maybe types, it
// is always zero or one. For arrays, it is the length of the array. For tuples
// it is the number of tuple items (which depends only on the type). For
// dictionary entries, it is always 2
//
// This function is O(1).
func (value *Variant) NChildren() uint {
	var arg0 *C.GVariant

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_n_children(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Print pretty-prints @value in the format understood by g_variant_parse().
//
// The format is described [here][gvariant-text].
//
// If @type_annotate is true, then type information is included in the output.
func (value *Variant) Print(typeAnnotate bool) string {
	var arg0 *C.GVariant
	var arg1 C.gboolean

	arg0 = (*C.GVariant)(value.Native())
	if typeAnnotate {
		arg1 = C.TRUE
	}

	ret := C.g_variant_print(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// PrintString behaves as g_variant_print(), but operates on a #GString.
//
// If @string is non-nil then it is appended to and returned. Else, a new empty
// #GString is allocated and it is returned.
func (value *Variant) PrintString(string *String, typeAnnotate bool) *String {
	var arg0 *C.GVariant
	var arg1 *C.GString
	var arg2 C.gboolean

	arg0 = (*C.GVariant)(value.Native())
	arg1 = (*C.GString)(string.Native())
	if typeAnnotate {
		arg2 = C.TRUE
	}

	ret := C.g_variant_print_string(arg0, arg1, arg2)

	var ret0 *String

	{
		ret0 = WrapString(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *String) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Ref increases the reference count of @value.
func (value *Variant) Ref() *Variant {
	var arg0 *C.GVariant

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_ref(arg0)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Variant) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// RefSink uses a floating reference count system. All functions with names
// starting with `g_variant_new_` return floating references.
//
// Calling g_variant_ref_sink() on a #GVariant with a floating reference will
// convert the floating reference into a full reference. Calling
// g_variant_ref_sink() on a non-floating #GVariant results in an additional
// normal reference being added.
//
// In other words, if the @value is floating, then this call "assumes ownership"
// of the floating reference, converting it to a normal reference. If the @value
// is not floating, then this call adds a new normal reference increasing the
// reference count by one.
//
// All calls that result in a #GVariant instance being inserted into a container
// will call g_variant_ref_sink() on the instance. This means that if the value
// was just created (and has only its floating reference) then the container
// will assume sole ownership of the value at that point and the caller will not
// need to unreference it. This makes certain common styles of programming much
// easier while still maintaining normal refcounting semantics in situations
// where values are not floating.
func (value *Variant) RefSink() *Variant {
	var arg0 *C.GVariant

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_ref_sink(arg0)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Variant) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Store stores the serialised form of @value at @data. @data should be large
// enough. See g_variant_get_size().
//
// The stored data is in machine native byte order but may not be in
// fully-normalised form if read from an untrusted source. See
// g_variant_get_normal_form() for a solution.
//
// As with g_variant_get_data(), to be able to deserialise the serialised
// variant successfully, its type and (if the destination machine might be
// different) its endianness must also be available.
//
// This function is approximately O(n) in the size of @data.
func (value *Variant) Store(data interface{}) {
	var arg0 *C.GVariant
	var arg1 C.gpointer

	arg0 = (*C.GVariant)(value.Native())
	arg1 = C.gpointer(box.Assign(data))

	C.g_variant_store(arg0, arg1)
}

// TakeRef: if @value is floating, sink it. Otherwise, do nothing.
//
// Typically you want to use g_variant_ref_sink() in order to automatically do
// the correct thing with respect to floating or non-floating references, but
// there is one specific scenario where this function is helpful.
//
// The situation where this function is helpful is when creating an API that
// allows the user to provide a callback function that returns a #GVariant. We
// certainly want to allow the user the flexibility to return a non-floating
// reference from this callback (for the case where the value that is being
// returned already exists).
//
// At the same time, the style of the #GVariant API makes it likely that for
// newly-created #GVariant instances, the user can be saved some typing if they
// are allowed to return a #GVariant with a floating reference.
//
// Using this function on the return value of the user's callback allows the
// user to do whichever is more convenient for them. The caller will always
// receives exactly one full reference to the value: either the one that was
// returned in the first place, or a floating reference that has been converted
// to a full reference.
//
// This function has an odd interaction when combined with g_variant_ref_sink()
// running at the same time in another thread on the same #GVariant instance. If
// g_variant_ref_sink() runs first then the result will be that the floating
// reference is converted to a hard reference. If g_variant_take_ref() runs
// first then the result will be that the floating reference is converted to a
// hard reference and an additional reference on top of that one is added. It is
// best to avoid this situation.
func (value *Variant) TakeRef() *Variant {
	var arg0 *C.GVariant

	arg0 = (*C.GVariant)(value.Native())

	ret := C.g_variant_take_ref(arg0)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Variant) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Unref decreases the reference count of @value. When its reference count drops
// to 0, the memory used by the variant is freed.
func (value *Variant) Unref() {
	var arg0 *C.GVariant

	arg0 = (*C.GVariant)(value.Native())

	C.g_variant_unref(arg0)
}

// VariantBuilder: a utility type for constructing container-type #GVariant
// instances.
//
// This is an opaque structure and may only be accessed using the following
// functions.
//
// Builder is not threadsafe in any way. Do not attempt to access it from more
// than one thread.
type VariantBuilder struct {
	native C.GVariantBuilder
}

// WrapVariantBuilder wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapVariantBuilder(ptr unsafe.Pointer) *VariantBuilder {
	if ptr == nil {
		return nil
	}

	return (*VariantBuilder)(ptr)
}

func marshalVariantBuilder(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapVariantBuilder(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (v *VariantBuilder) Native() unsafe.Pointer {
	return unsafe.Pointer(&v.native)
}

// NewVariantBuilder constructs a struct VariantBuilder.
func NewVariantBuilder(typ *VariantType) *VariantBuilder {
	var arg1 *C.GVariantType

	arg1 = (*C.GVariantType)(typ.Native())

	ret := C.g_variant_builder_new(arg1)

	var ret0 *VariantBuilder

	{
		ret0 = WrapVariantBuilder(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *VariantBuilder) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// AddValue adds @value to @builder.
//
// It is an error to call this function in any way that would create an
// inconsistent value to be constructed. Some examples of this are putting
// different types of items into an array, putting the wrong types or number of
// items in a tuple, putting more than one value into a variant, etc.
//
// If @value is a floating reference (see g_variant_ref_sink()), the @builder
// instance takes ownership of @value.
func (builder *VariantBuilder) AddValue(value *Variant) {
	var arg0 *C.GVariantBuilder
	var arg1 *C.GVariant

	arg0 = (*C.GVariantBuilder)(builder.Native())
	arg1 = (*C.GVariant)(value.Native())

	C.g_variant_builder_add_value(arg0, arg1)
}

// Clear releases all memory associated with a Builder without freeing the
// Builder structure itself.
//
// It typically only makes sense to do this on a stack-allocated Builder if you
// want to abort building the value part-way through. This function need not be
// called if you call g_variant_builder_end() and it also doesn't need to be
// called on builders allocated with g_variant_builder_new() (see
// g_variant_builder_unref() for that).
//
// This function leaves the Builder structure set to all-zeros. It is valid to
// call this function on either an initialised Builder or one that is set to
// all-zeros but it is not valid to call this function on uninitialised memory.
func (builder *VariantBuilder) Clear() {
	var arg0 *C.GVariantBuilder

	arg0 = (*C.GVariantBuilder)(builder.Native())

	C.g_variant_builder_clear(arg0)
}

// Close closes the subcontainer inside the given @builder that was opened by
// the most recent call to g_variant_builder_open().
//
// It is an error to call this function in any way that would create an
// inconsistent value to be constructed (ie: too few values added to the
// subcontainer).
func (builder *VariantBuilder) Close() {
	var arg0 *C.GVariantBuilder

	arg0 = (*C.GVariantBuilder)(builder.Native())

	C.g_variant_builder_close(arg0)
}

// End ends the builder process and returns the constructed value.
//
// It is not permissible to use @builder in any way after this call except for
// reference counting operations (in the case of a heap-allocated Builder) or by
// reinitialising it with g_variant_builder_init() (in the case of
// stack-allocated). This means that for the stack-allocated builders there is
// no need to call g_variant_builder_clear() after the call to
// g_variant_builder_end().
//
// It is an error to call this function in any way that would create an
// inconsistent value to be constructed (ie: insufficient number of items added
// to a container with a specific number of children required). It is also an
// error to call this function if the builder was created with an indefinite
// array or maybe type and no children have been added; in this case it is
// impossible to infer the type of the empty array.
func (builder *VariantBuilder) End() *Variant {
	var arg0 *C.GVariantBuilder

	arg0 = (*C.GVariantBuilder)(builder.Native())

	ret := C.g_variant_builder_end(arg0)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
	}

	return ret0
}

// Init initialises a Builder structure.
//
// @type must be non-nil. It specifies the type of container to construct. It
// can be an indefinite type such as G_VARIANT_TYPE_ARRAY or a definite type
// such as "as" or "(ii)". Maybe, array, tuple, dictionary entry and
// variant-typed values may be constructed.
//
// After the builder is initialised, values are added using
// g_variant_builder_add_value() or g_variant_builder_add().
//
// After all the child values are added, g_variant_builder_end() frees the
// memory associated with the builder and returns the #GVariant that was
// created.
//
// This function completely ignores the previous contents of @builder. On one
// hand this means that it is valid to pass in completely uninitialised memory.
// On the other hand, this means that if you are initialising over top of an
// existing Builder you need to first call g_variant_builder_clear() in order to
// avoid leaking memory.
//
// You must not call g_variant_builder_ref() or g_variant_builder_unref() on a
// Builder that was initialised with this function. If you ever pass a reference
// to a Builder outside of the control of your own code then you should assume
// that the person receiving that reference may try to use reference counting;
// you should use g_variant_builder_new() instead of this function.
func (builder *VariantBuilder) Init(typ *VariantType) {
	var arg0 *C.GVariantBuilder
	var arg1 *C.GVariantType

	arg0 = (*C.GVariantBuilder)(builder.Native())
	arg1 = (*C.GVariantType)(typ.Native())

	C.g_variant_builder_init(arg0, arg1)
}

// Open opens a subcontainer inside the given @builder. When done adding items
// to the subcontainer, g_variant_builder_close() must be called. @type is the
// type of the container: so to build a tuple of several values, @type must
// include the tuple itself.
//
// It is an error to call this function in any way that would cause an
// inconsistent value to be constructed (ie: adding too many values or a value
// of an incorrect type).
//
// Example of building a nested variant:
//
//    GVariantBuilder builder;
//    guint32 some_number = get_number ();
//    g_autoptr (GHashTable) some_dict = get_dict ();
//    GHashTableIter iter;
//    const gchar *key;
//    const GVariant *value;
//    g_autoptr (GVariant) output = NULL;
//
//    g_variant_builder_init (&builder, G_VARIANT_TYPE ("(ua{sv})"));
//    g_variant_builder_add (&builder, "u", some_number);
//    g_variant_builder_open (&builder, G_VARIANT_TYPE ("a{sv}"));
//
//    g_hash_table_iter_init (&iter, some_dict);
//    while (g_hash_table_iter_next (&iter, (gpointer *) &key, (gpointer *) &value))
//      {
//        g_variant_builder_open (&builder, G_VARIANT_TYPE ("{sv}"));
//        g_variant_builder_add (&builder, "s", key);
//        g_variant_builder_add (&builder, "v", value);
//        g_variant_builder_close (&builder);
//      }
//
//    g_variant_builder_close (&builder);
//
//    output = g_variant_builder_end (&builder);
func (builder *VariantBuilder) Open(typ *VariantType) {
	var arg0 *C.GVariantBuilder
	var arg1 *C.GVariantType

	arg0 = (*C.GVariantBuilder)(builder.Native())
	arg1 = (*C.GVariantType)(typ.Native())

	C.g_variant_builder_open(arg0, arg1)
}

// Ref increases the reference count on @builder.
//
// Don't call this on stack-allocated Builder instances or bad things will
// happen.
func (builder *VariantBuilder) Ref() *VariantBuilder {
	var arg0 *C.GVariantBuilder

	arg0 = (*C.GVariantBuilder)(builder.Native())

	ret := C.g_variant_builder_ref(arg0)

	var ret0 *VariantBuilder

	{
		ret0 = WrapVariantBuilder(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *VariantBuilder) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Unref decreases the reference count on @builder.
//
// In the event that there are no more references, releases all memory
// associated with the Builder.
//
// Don't call this on stack-allocated Builder instances or bad things will
// happen.
func (builder *VariantBuilder) Unref() {
	var arg0 *C.GVariantBuilder

	arg0 = (*C.GVariantBuilder)(builder.Native())

	C.g_variant_builder_unref(arg0)
}

// VariantDict is a mutable interface to #GVariant dictionaries.
//
// It can be used for doing a sequence of dictionary lookups in an efficient way
// on an existing #GVariant dictionary or it can be used to construct new
// dictionaries with a hashtable-like interface. It can also be used for taking
// existing dictionaries and modifying them in order to create new ones.
//
// Dict can only be used with G_VARIANT_TYPE_VARDICT dictionaries.
//
// It is possible to use Dict allocated on the stack or on the heap. When using
// a stack-allocated Dict, you begin with a call to g_variant_dict_init() and
// free the resources with a call to g_variant_dict_clear().
//
// Heap-allocated Dict follows normal refcounting rules: you allocate it with
// g_variant_dict_new() and use g_variant_dict_ref() and g_variant_dict_unref().
//
// g_variant_dict_end() is used to convert the Dict back into a dictionary-type
// #GVariant. When used with stack-allocated instances, this also implicitly
// frees all associated memory, but for heap-allocated instances, you must still
// call g_variant_dict_unref() afterwards.
//
// You will typically want to use a heap-allocated Dict when you expose it as
// part of an API. For most other uses, the stack-allocated form will be more
// convenient.
//
// Consider the following two examples that do the same thing in each style:
// take an existing dictionary and look up the "count" uint32 key, adding 1 to
// it if it is found, or returning an error if the key is not found. Each
// returns the new dictionary as a floating #GVariant.
//
// Using a stack-allocated GVariantDict
//
//      GVariant *
//      add_to_count (GVariant  *orig,
//                    GError   **error)
//      {
//        GVariantDict *dict;
//        GVariant *result;
//        guint32 count;
//
//        dict = g_variant_dict_new (orig);
//
//        if (g_variant_dict_lookup (dict, "count", "u", &count))
//          {
//            g_variant_dict_insert (dict, "count", "u", count + 1);
//            result = g_variant_dict_end (dict);
//          }
//        else
//          {
//            g_set_error (...);
//            result = NULL;
//          }
//
//        g_variant_dict_unref (dict);
//
//        return result;
//      }
type VariantDict struct {
	native C.GVariantDict
}

// WrapVariantDict wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapVariantDict(ptr unsafe.Pointer) *VariantDict {
	if ptr == nil {
		return nil
	}

	return (*VariantDict)(ptr)
}

func marshalVariantDict(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapVariantDict(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (v *VariantDict) Native() unsafe.Pointer {
	return unsafe.Pointer(&v.native)
}

// NewVariantDict constructs a struct VariantDict.
func NewVariantDict(fromAsv *Variant) *VariantDict {
	var arg1 *C.GVariant

	arg1 = (*C.GVariant)(fromAsv.Native())

	ret := C.g_variant_dict_new(arg1)

	var ret0 *VariantDict

	{
		ret0 = WrapVariantDict(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *VariantDict) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Clear releases all memory associated with a Dict without freeing the Dict
// structure itself.
//
// It typically only makes sense to do this on a stack-allocated Dict if you
// want to abort building the value part-way through. This function need not be
// called if you call g_variant_dict_end() and it also doesn't need to be called
// on dicts allocated with g_variant_dict_new (see g_variant_dict_unref() for
// that).
//
// It is valid to call this function on either an initialised Dict or one that
// was previously cleared by an earlier call to g_variant_dict_clear() but it is
// not valid to call this function on uninitialised memory.
func (dict *VariantDict) Clear() {
	var arg0 *C.GVariantDict

	arg0 = (*C.GVariantDict)(dict.Native())

	C.g_variant_dict_clear(arg0)
}

// Contains checks if @key exists in @dict.
func (dict *VariantDict) Contains(key string) bool {
	var arg0 *C.GVariantDict
	var arg1 *C.gchar

	arg0 = (*C.GVariantDict)(dict.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_variant_dict_contains(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// End returns the current value of @dict as a #GVariant of type
// G_VARIANT_TYPE_VARDICT, clearing it in the process.
//
// It is not permissible to use @dict in any way after this call except for
// reference counting operations (in the case of a heap-allocated Dict) or by
// reinitialising it with g_variant_dict_init() (in the case of
// stack-allocated).
func (dict *VariantDict) End() *Variant {
	var arg0 *C.GVariantDict

	arg0 = (*C.GVariantDict)(dict.Native())

	ret := C.g_variant_dict_end(arg0)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
	}

	return ret0
}

// Init initialises a Dict structure.
//
// If @from_asv is given, it is used to initialise the dictionary.
//
// This function completely ignores the previous contents of @dict. On one hand
// this means that it is valid to pass in completely uninitialised memory. On
// the other hand, this means that if you are initialising over top of an
// existing Dict you need to first call g_variant_dict_clear() in order to avoid
// leaking memory.
//
// You must not call g_variant_dict_ref() or g_variant_dict_unref() on a Dict
// that was initialised with this function. If you ever pass a reference to a
// Dict outside of the control of your own code then you should assume that the
// person receiving that reference may try to use reference counting; you should
// use g_variant_dict_new() instead of this function.
func (dict *VariantDict) Init(fromAsv *Variant) {
	var arg0 *C.GVariantDict
	var arg1 *C.GVariant

	arg0 = (*C.GVariantDict)(dict.Native())
	arg1 = (*C.GVariant)(fromAsv.Native())

	C.g_variant_dict_init(arg0, arg1)
}

// InsertValue inserts (or replaces) a key in a Dict.
//
// @value is consumed if it is floating.
func (dict *VariantDict) InsertValue(key string, value *Variant) {
	var arg0 *C.GVariantDict
	var arg1 *C.gchar
	var arg2 *C.GVariant

	arg0 = (*C.GVariantDict)(dict.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GVariant)(value.Native())

	C.g_variant_dict_insert_value(arg0, arg1, arg2)
}

// LookupValue looks up a value in a Dict.
//
// If @key is not found in @dictionary, nil is returned.
//
// The @expected_type string specifies what type of value is expected. If the
// value associated with @key has a different type then nil is returned.
//
// If the key is found and the value has the correct type, it is returned. If
// @expected_type was specified then any non-nil return value will have this
// type.
func (dict *VariantDict) LookupValue(key string, expectedType *VariantType) *Variant {
	var arg0 *C.GVariantDict
	var arg1 *C.gchar
	var arg2 *C.GVariantType

	arg0 = (*C.GVariantDict)(dict.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GVariantType)(expectedType.Native())

	ret := C.g_variant_dict_lookup_value(arg0, arg1, arg2)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Variant) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Ref increases the reference count on @dict.
//
// Don't call this on stack-allocated Dict instances or bad things will happen.
func (dict *VariantDict) Ref() *VariantDict {
	var arg0 *C.GVariantDict

	arg0 = (*C.GVariantDict)(dict.Native())

	ret := C.g_variant_dict_ref(arg0)

	var ret0 *VariantDict

	{
		ret0 = WrapVariantDict(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *VariantDict) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Remove removes a key and its associated value from a Dict.
func (dict *VariantDict) Remove(key string) bool {
	var arg0 *C.GVariantDict
	var arg1 *C.gchar

	arg0 = (*C.GVariantDict)(dict.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_variant_dict_remove(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Unref decreases the reference count on @dict.
//
// In the event that there are no more references, releases all memory
// associated with the Dict.
//
// Don't call this on stack-allocated Dict instances or bad things will happen.
func (dict *VariantDict) Unref() {
	var arg0 *C.GVariantDict

	arg0 = (*C.GVariantDict)(dict.Native())

	C.g_variant_dict_unref(arg0)
}

// VariantIter is an opaque data structure and can only be accessed using the
// following functions.
type VariantIter struct {
	native C.GVariantIter
}

// WrapVariantIter wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapVariantIter(ptr unsafe.Pointer) *VariantIter {
	if ptr == nil {
		return nil
	}

	return (*VariantIter)(ptr)
}

func marshalVariantIter(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapVariantIter(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (v *VariantIter) Native() unsafe.Pointer {
	return unsafe.Pointer(&v.native)
}

// Copy creates a new heap-allocated Iter to iterate over the container that was
// being iterated over by @iter. Iteration begins on the new iterator from the
// current position of the old iterator but the two copies are independent past
// that point.
//
// Use g_variant_iter_free() to free the return value when you no longer need
// it.
//
// A reference is taken to the container that @iter is iterating over and will
// be related only when g_variant_iter_free() is called.
func (iter *VariantIter) Copy() *VariantIter {
	var arg0 *C.GVariantIter

	arg0 = (*C.GVariantIter)(iter.Native())

	ret := C.g_variant_iter_copy(arg0)

	var ret0 *VariantIter

	{
		ret0 = WrapVariantIter(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *VariantIter) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Free frees a heap-allocated Iter. Only call this function on iterators that
// were returned by g_variant_iter_new() or g_variant_iter_copy().
func (iter *VariantIter) Free() {
	var arg0 *C.GVariantIter

	arg0 = (*C.GVariantIter)(iter.Native())

	C.g_variant_iter_free(arg0)
}

// Init initialises (without allocating) a Iter. @iter may be completely
// uninitialised prior to this call; its old value is ignored.
//
// The iterator remains valid for as long as @value exists, and need not be
// freed in any way.
func (iter *VariantIter) Init(value *Variant) uint {
	var arg0 *C.GVariantIter
	var arg1 *C.GVariant

	arg0 = (*C.GVariantIter)(iter.Native())
	arg1 = (*C.GVariant)(value.Native())

	ret := C.g_variant_iter_init(arg0, arg1)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// NChildren queries the number of child items in the container that we are
// iterating over. This is the total number of items -- not the number of items
// remaining.
//
// This function might be useful for preallocation of arrays.
func (iter *VariantIter) NChildren() uint {
	var arg0 *C.GVariantIter

	arg0 = (*C.GVariantIter)(iter.Native())

	ret := C.g_variant_iter_n_children(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// NextValue gets the next item in the container. If no more items remain then
// nil is returned.
//
// Use g_variant_unref() to drop your reference on the return value when you no
// longer need it.
//
// Here is an example for iterating with g_variant_iter_next_value():
//
//      // recursively iterate a container
//      void
//      iterate_container_recursive (GVariant *container)
//      {
//        GVariantIter iter;
//        GVariant *child;
//
//        g_variant_iter_init (&iter, container);
//        while ((child = g_variant_iter_next_value (&iter)))
//          {
//            g_print ("type 's'\n", g_variant_get_type_string (child));
//
//            if (g_variant_is_container (child))
//              iterate_container_recursive (child);
//
//            g_variant_unref (child);
//          }
//      }
func (iter *VariantIter) NextValue() *Variant {
	var arg0 *C.GVariantIter

	arg0 = (*C.GVariantIter)(iter.Native())

	ret := C.g_variant_iter_next_value(arg0)

	var ret0 *Variant

	{
		ret0 = WrapVariant(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Variant) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// VariantType: this section introduces the GVariant type system. It is based,
// in large part, on the D-Bus type system, with two major changes and some
// minor lifting of restrictions. The D-Bus specification
// (http://dbus.freedesktop.org/doc/dbus-specification.html), therefore,
// provides a significant amount of information that is useful when working with
// GVariant.
//
// The first major change with respect to the D-Bus type system is the
// introduction of maybe (or "nullable") types. Any type in GVariant can be
// converted to a maybe type, in which case, "nothing" (or "null") becomes a
// valid value. Maybe types have been added by introducing the character "m" to
// type strings.
//
// The second major change is that the GVariant type system supports the concept
// of "indefinite types" -- types that are less specific than the normal types
// found in D-Bus. For example, it is possible to speak of "an array of any
// type" in GVariant, where the D-Bus type system would require you to speak of
// "an array of integers" or "an array of strings". Indefinite types have been
// added by introducing the characters "*", "?" and "r" to type strings.
//
// Finally, all arbitrary restrictions relating to the complexity of types are
// lifted along with the restriction that dictionary entries may only appear
// nested inside of arrays.
//
// Just as in D-Bus, GVariant types are described with strings ("type strings").
// Subject to the differences mentioned above, these strings are of the same
// form as those found in DBus. Note, however: D-Bus always works in terms of
// messages and therefore individual type strings appear nowhere in its
// interface. Instead, "signatures" are a concatenation of the strings of the
// type of each argument in a message. GVariant deals with single values
// directly so GVariant type strings always describe the type of exactly one
// value. This means that a D-Bus signature string is generally not a valid
// GVariant type string -- except in the case that it is the signature of a
// message containing exactly one argument.
//
// An indefinite type is similar in spirit to what may be called an abstract
// type in other type systems. No value can exist that has an indefinite type as
// its type, but values can exist that have types that are subtypes of
// indefinite types. That is to say, g_variant_get_type() will never return an
// indefinite type, but calling g_variant_is_of_type() with an indefinite type
// may return true. For example, you cannot have a value that represents "an
// array of no particular type", but you can have an "array of integers" which
// certainly matches the type of "an array of no particular type", since "array
// of integers" is a subtype of "array of no particular type".
//
// This is similar to how instances of abstract classes may not directly exist
// in other type systems, but instances of their non-abstract subtypes may. For
// example, in GTK, no object that has the type of Bin can exist (since Bin is
// an abstract class), but a Window can certainly be instantiated, and you would
// say that the Window is a Bin (since Window is a subclass of Bin).
//
//
// GVariant Type Strings
//
// A GVariant type string can be any of the following:
//
// - any basic type string (listed below)
//
// - "v", "r" or "*"
//
// - one of the characters 'a' or 'm', followed by another type string
//
// - the character '(', followed by a concatenation of zero or more other type
// strings, followed by the character ')'
//
// - the character '{', followed by a basic type string (see below), followed by
// another type string, followed by the character '}'
//
// A basic type string describes a basic type (as per g_variant_type_is_basic())
// and is always a single character in length. The valid basic type strings are
// "b", "y", "n", "q", "i", "u", "x", "t", "h", "d", "s", "o", "g" and "?".
//
// The above definition is recursive to arbitrary depth. "aaaaai" and
// "(ui(nq((y)))s)" are both valid type strings, as is "a(aa(ui)(qna{ya(yd)}))".
// In order to not hit memory limits, #GVariant imposes a limit on recursion
// depth of 65 nested containers. This is the limit in the D-Bus specification
// (64) plus one to allow a BusMessage to be nested in a top-level tuple.
//
// The meaning of each of the characters is as follows: - `b`: the type string
// of G_VARIANT_TYPE_BOOLEAN; a boolean value. - `y`: the type string of
// G_VARIANT_TYPE_BYTE; a byte. - `n`: the type string of G_VARIANT_TYPE_INT16;
// a signed 16 bit integer. - `q`: the type string of G_VARIANT_TYPE_UINT16; an
// unsigned 16 bit integer. - `i`: the type string of G_VARIANT_TYPE_INT32; a
// signed 32 bit integer. - `u`: the type string of G_VARIANT_TYPE_UINT32; an
// unsigned 32 bit integer. - `x`: the type string of G_VARIANT_TYPE_INT64; a
// signed 64 bit integer. - `t`: the type string of G_VARIANT_TYPE_UINT64; an
// unsigned 64 bit integer. - `h`: the type string of G_VARIANT_TYPE_HANDLE; a
// signed 32 bit value that, by convention, is used as an index into an array of
// file descriptors that are sent alongside a D-Bus message. - `d`: the type
// string of G_VARIANT_TYPE_DOUBLE; a double precision floating point value. -
// `s`: the type string of G_VARIANT_TYPE_STRING; a string. - `o`: the type
// string of G_VARIANT_TYPE_OBJECT_PATH; a string in the form of a D-Bus object
// path. - `g`: the type string of G_VARIANT_TYPE_SIGNATURE; a string in the
// form of a D-Bus type signature. - `?`: the type string of
// G_VARIANT_TYPE_BASIC; an indefinite type that is a supertype of any of the
// basic types. - `v`: the type string of G_VARIANT_TYPE_VARIANT; a container
// type that contain any other type of value. - `a`: used as a prefix on another
// type string to mean an array of that type; the type string "ai", for example,
// is the type of an array of signed 32-bit integers. - `m`: used as a prefix on
// another type string to mean a "maybe", or "nullable", version of that type;
// the type string "ms", for example, is the type of a value that maybe contains
// a string, or maybe contains nothing. - `()`: used to enclose zero or more
// other concatenated type strings to create a tuple type; the type string
// "(is)", for example, is the type of a pair of an integer and a string. - `r`:
// the type string of G_VARIANT_TYPE_TUPLE; an indefinite type that is a
// supertype of any tuple type, regardless of the number of items. - `{}`: used
// to enclose a basic type string concatenated with another type string to
// create a dictionary entry type, which usually appears inside of an array to
// form a dictionary; the type string "a{sd}", for example, is the type of a
// dictionary that maps strings to double precision floating point values.
//
//    The first type (the basic type) is the key type and the second type is
//    the value type. The reason that the first type is restricted to being a
//    basic type is so that it can easily be hashed.
//
// - `*`: the type string of G_VARIANT_TYPE_ANY; the indefinite type that is
//
//    a supertype of all types.  Note that, as with all type strings, this
//    character represents exactly one type. It cannot be used inside of tuples
//    to mean "any number of items".
//
// Any type string of a container that contains an indefinite type is, itself,
// an indefinite type. For example, the type string "a*" (corresponding to
// G_VARIANT_TYPE_ARRAY) is an indefinite type that is a supertype of every
// array type. "(*s)" is a supertype of all tuples that contain exactly two
// items where the second item is a string.
//
// "a{?*}" is an indefinite type that is a supertype of all arrays containing
// dictionary entries where the key is any basic type and the value is any type
// at all. This is, by definition, a dictionary, so this type string corresponds
// to G_VARIANT_TYPE_DICTIONARY. Note that, due to the restriction that the key
// of a dictionary entry must be a basic type, "{**}" is not a valid type
// string.
type VariantType struct {
	native C.GVariantType
}

// WrapVariantType wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapVariantType(ptr unsafe.Pointer) *VariantType {
	if ptr == nil {
		return nil
	}

	return (*VariantType)(ptr)
}

func marshalVariantType(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapVariantType(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (v *VariantType) Native() unsafe.Pointer {
	return unsafe.Pointer(&v.native)
}

// NewVariantType constructs a struct VariantType.
func NewVariantType(typeString string) *VariantType {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(typeString))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_variant_type_new(arg1)

	var ret0 *VariantType

	{
		ret0 = WrapVariantType(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *VariantType) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewVariantTypeArray constructs a struct VariantType.
func NewVariantTypeArray(element *VariantType) *VariantType {
	var arg1 *C.GVariantType

	arg1 = (*C.GVariantType)(element.Native())

	ret := C.g_variant_type_new_array(arg1)

	var ret0 *VariantType

	{
		ret0 = WrapVariantType(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *VariantType) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewVariantTypeDictEntry constructs a struct VariantType.
func NewVariantTypeDictEntry(key *VariantType, value *VariantType) *VariantType {
	var arg1 *C.GVariantType
	var arg2 *C.GVariantType

	arg1 = (*C.GVariantType)(key.Native())
	arg2 = (*C.GVariantType)(value.Native())

	ret := C.g_variant_type_new_dict_entry(arg1, arg2)

	var ret0 *VariantType

	{
		ret0 = WrapVariantType(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *VariantType) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewVariantTypeMaybe constructs a struct VariantType.
func NewVariantTypeMaybe(element *VariantType) *VariantType {
	var arg1 *C.GVariantType

	arg1 = (*C.GVariantType)(element.Native())

	ret := C.g_variant_type_new_maybe(arg1)

	var ret0 *VariantType

	{
		ret0 = WrapVariantType(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *VariantType) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewVariantTypeTuple constructs a struct VariantType.
func NewVariantTypeTuple(items []*VariantType) *VariantType {
	var arg1 **C.GVariantType
	var arg2 C.gint

	arg1 = (**C.GVariantType)(unsafe.Pointer(&items[0]))
	arg2 = len(items)
	defer runtime.KeepAlive(items)

	ret := C.g_variant_type_new_tuple(arg1, arg2)

	var ret0 *VariantType

	{
		ret0 = WrapVariantType(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *VariantType) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Copy makes a copy of a Type. It is appropriate to call g_variant_type_free()
// on the return value. @type may not be nil.
func (typ *VariantType) Copy() *VariantType {
	var arg0 *C.GVariantType

	arg0 = (*C.GVariantType)(typ.Native())

	ret := C.g_variant_type_copy(arg0)

	var ret0 *VariantType

	{
		ret0 = WrapVariantType(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *VariantType) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// DupString returns a newly-allocated copy of the type string corresponding to
// @type. The returned string is nul-terminated. It is appropriate to call
// g_free() on the return value.
func (typ *VariantType) DupString() string {
	var arg0 *C.GVariantType

	arg0 = (*C.GVariantType)(typ.Native())

	ret := C.g_variant_type_dup_string(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Element determines the element type of an array or maybe type.
//
// This function may only be used with array or maybe types.
func (typ *VariantType) Element() *VariantType {
	var arg0 *C.GVariantType

	arg0 = (*C.GVariantType)(typ.Native())

	ret := C.g_variant_type_element(arg0)

	var ret0 *VariantType

	{
		ret0 = WrapVariantType(unsafe.Pointer(ret))
	}

	return ret0
}

// Equal compares @type1 and @type2 for equality.
//
// Only returns true if the types are exactly equal. Even if one type is an
// indefinite type and the other is a subtype of it, false will be returned if
// they are not exactly equal. If you want to check for subtypes, use
// g_variant_type_is_subtype_of().
//
// The argument types of @type1 and @type2 are only #gconstpointer to allow use
// with Table without function pointer casting. For both arguments, a valid Type
// must be provided.
func (type1 *VariantType) Equal(type2 VariantType) bool {
	var arg0 C.gpointer
	var arg1 C.gpointer

	arg0 = (C.gpointer)(type1.Native())
	arg1 = (C.gpointer)(type2.Native())

	ret := C.g_variant_type_equal(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// First determines the first item type of a tuple or dictionary entry type.
//
// This function may only be used with tuple or dictionary entry types, but must
// not be used with the generic tuple type G_VARIANT_TYPE_TUPLE.
//
// In the case of a dictionary entry type, this returns the type of the key.
//
// nil is returned in case of @type being G_VARIANT_TYPE_UNIT.
//
// This call, together with g_variant_type_next() provides an iterator interface
// over tuple and dictionary entry types.
func (typ *VariantType) First() *VariantType {
	var arg0 *C.GVariantType

	arg0 = (*C.GVariantType)(typ.Native())

	ret := C.g_variant_type_first(arg0)

	var ret0 *VariantType

	{
		ret0 = WrapVariantType(unsafe.Pointer(ret))
	}

	return ret0
}

// Free frees a Type that was allocated with g_variant_type_copy(),
// g_variant_type_new() or one of the container type constructor functions.
//
// In the case that @type is nil, this function does nothing.
//
// Since 2.24
func (typ *VariantType) Free() {
	var arg0 *C.GVariantType

	arg0 = (*C.GVariantType)(typ.Native())

	C.g_variant_type_free(arg0)
}

// StringLength returns the length of the type string corresponding to the given
// @type. This function must be used to determine the valid extent of the memory
// region returned by g_variant_type_peek_string().
func (typ *VariantType) StringLength() uint {
	var arg0 *C.GVariantType

	arg0 = (*C.GVariantType)(typ.Native())

	ret := C.g_variant_type_get_string_length(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Hash hashes @type.
//
// The argument type of @type is only #gconstpointer to allow use with Table
// without function pointer casting. A valid Type must be provided.
func (typ *VariantType) Hash() uint {
	var arg0 C.gpointer

	arg0 = (C.gpointer)(typ.Native())

	ret := C.g_variant_type_hash(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// IsArray determines if the given @type is an array type. This is true if the
// type string for @type starts with an 'a'.
//
// This function returns true for any indefinite type for which every definite
// subtype is an array type -- G_VARIANT_TYPE_ARRAY, for example.
func (typ *VariantType) IsArray() bool {
	var arg0 *C.GVariantType

	arg0 = (*C.GVariantType)(typ.Native())

	ret := C.g_variant_type_is_array(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IsBasic determines if the given @type is a basic type.
//
// Basic types are booleans, bytes, integers, doubles, strings, object paths and
// signatures.
//
// Only a basic type may be used as the key of a dictionary entry.
//
// This function returns false for all indefinite types except
// G_VARIANT_TYPE_BASIC.
func (typ *VariantType) IsBasic() bool {
	var arg0 *C.GVariantType

	arg0 = (*C.GVariantType)(typ.Native())

	ret := C.g_variant_type_is_basic(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IsContainer determines if the given @type is a container type.
//
// Container types are any array, maybe, tuple, or dictionary entry types plus
// the variant type.
//
// This function returns true for any indefinite type for which every definite
// subtype is a container -- G_VARIANT_TYPE_ARRAY, for example.
func (typ *VariantType) IsContainer() bool {
	var arg0 *C.GVariantType

	arg0 = (*C.GVariantType)(typ.Native())

	ret := C.g_variant_type_is_container(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IsDefinite determines if the given @type is definite (ie: not indefinite).
//
// A type is definite if its type string does not contain any indefinite type
// characters ('*', '?', or 'r').
//
// A #GVariant instance may not have an indefinite type, so calling this
// function on the result of g_variant_get_type() will always result in true
// being returned. Calling this function on an indefinite type like
// G_VARIANT_TYPE_ARRAY, however, will result in false being returned.
func (typ *VariantType) IsDefinite() bool {
	var arg0 *C.GVariantType

	arg0 = (*C.GVariantType)(typ.Native())

	ret := C.g_variant_type_is_definite(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IsDictEntry determines if the given @type is a dictionary entry type. This is
// true if the type string for @type starts with a '{'.
//
// This function returns true for any indefinite type for which every definite
// subtype is a dictionary entry type -- G_VARIANT_TYPE_DICT_ENTRY, for example.
func (typ *VariantType) IsDictEntry() bool {
	var arg0 *C.GVariantType

	arg0 = (*C.GVariantType)(typ.Native())

	ret := C.g_variant_type_is_dict_entry(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IsMaybe determines if the given @type is a maybe type. This is true if the
// type string for @type starts with an 'm'.
//
// This function returns true for any indefinite type for which every definite
// subtype is a maybe type -- G_VARIANT_TYPE_MAYBE, for example.
func (typ *VariantType) IsMaybe() bool {
	var arg0 *C.GVariantType

	arg0 = (*C.GVariantType)(typ.Native())

	ret := C.g_variant_type_is_maybe(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IsSubtypeOf checks if @type is a subtype of @supertype.
//
// This function returns true if @type is a subtype of @supertype. All types are
// considered to be subtypes of themselves. Aside from that, only indefinite
// types can have subtypes.
func (typ *VariantType) IsSubtypeOf(supertype *VariantType) bool {
	var arg0 *C.GVariantType
	var arg1 *C.GVariantType

	arg0 = (*C.GVariantType)(typ.Native())
	arg1 = (*C.GVariantType)(supertype.Native())

	ret := C.g_variant_type_is_subtype_of(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IsTuple determines if the given @type is a tuple type. This is true if the
// type string for @type starts with a '(' or if @type is G_VARIANT_TYPE_TUPLE.
//
// This function returns true for any indefinite type for which every definite
// subtype is a tuple type -- G_VARIANT_TYPE_TUPLE, for example.
func (typ *VariantType) IsTuple() bool {
	var arg0 *C.GVariantType

	arg0 = (*C.GVariantType)(typ.Native())

	ret := C.g_variant_type_is_tuple(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IsVariant determines if the given @type is the variant type.
func (typ *VariantType) IsVariant() bool {
	var arg0 *C.GVariantType

	arg0 = (*C.GVariantType)(typ.Native())

	ret := C.g_variant_type_is_variant(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Key determines the key type of a dictionary entry type.
//
// This function may only be used with a dictionary entry type. Other than the
// additional restriction, this call is equivalent to g_variant_type_first().
func (typ *VariantType) Key() *VariantType {
	var arg0 *C.GVariantType

	arg0 = (*C.GVariantType)(typ.Native())

	ret := C.g_variant_type_key(arg0)

	var ret0 *VariantType

	{
		ret0 = WrapVariantType(unsafe.Pointer(ret))
	}

	return ret0
}

// NItems determines the number of items contained in a tuple or dictionary
// entry type.
//
// This function may only be used with tuple or dictionary entry types, but must
// not be used with the generic tuple type G_VARIANT_TYPE_TUPLE.
//
// In the case of a dictionary entry type, this function will always return 2.
func (typ *VariantType) NItems() uint {
	var arg0 *C.GVariantType

	arg0 = (*C.GVariantType)(typ.Native())

	ret := C.g_variant_type_n_items(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Next determines the next item type of a tuple or dictionary entry type.
//
// @type must be the result of a previous call to g_variant_type_first() or
// g_variant_type_next().
//
// If called on the key type of a dictionary entry then this call returns the
// value type. If called on the value type of a dictionary entry then this call
// returns nil.
//
// For tuples, nil is returned when @type is the last item in a tuple.
func (typ *VariantType) Next() *VariantType {
	var arg0 *C.GVariantType

	arg0 = (*C.GVariantType)(typ.Native())

	ret := C.g_variant_type_next(arg0)

	var ret0 *VariantType

	{
		ret0 = WrapVariantType(unsafe.Pointer(ret))
	}

	return ret0
}

// PeekString returns the type string corresponding to the given @type. The
// result is not nul-terminated; in order to determine its length you must call
// g_variant_type_get_string_length().
//
// To get a nul-terminated string, see g_variant_type_dup_string().
func (typ *VariantType) PeekString() string {
	var arg0 *C.GVariantType

	arg0 = (*C.GVariantType)(typ.Native())

	ret := C.g_variant_type_peek_string(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Value determines the value type of a dictionary entry type.
//
// This function may only be used with a dictionary entry type.
func (typ *VariantType) Value() *VariantType {
	var arg0 *C.GVariantType

	arg0 = (*C.GVariantType)(typ.Native())

	ret := C.g_variant_type_value(arg0)

	var ret0 *VariantType

	{
		ret0 = WrapVariantType(unsafe.Pointer(ret))
	}

	return ret0
}
