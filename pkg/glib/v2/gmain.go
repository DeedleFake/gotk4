// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <glib.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_main_context_get_type()), F: marshalMainContext},
		{T: externglib.Type(C.g_main_loop_get_type()), F: marshalMainLoop},
		{T: externglib.Type(C.g_source_get_type()), F: marshalSource},
	})
}

// ChildWatchFunc: prototype of a WatchSource callback, called when a child
// process has exited. To interpret @status, see the documentation for
// g_spawn_check_exit_status().
type ChildWatchFunc func()

//export gotk4_ChildWatchFunc
func gotk4_ChildWatchFunc(arg0 C.GPid, arg1 C.gint, arg2 C.gpointer) {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	fn := v.(ChildWatchFunc)
	fn()
}

// SourceFunc specifies the type of function passed to g_timeout_add(),
// g_timeout_add_full(), g_idle_add(), and g_idle_add_full().
//
// When calling g_source_set_callback(), you may need to cast a function of a
// different type to this type. Use G_SOURCE_FUNC() to avoid warnings about
// incompatible function types.
type SourceFunc func() (ok bool)

//export gotk4_SourceFunc
func gotk4_SourceFunc(arg0 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg0))
	if v == nil {
		panic(`callback not found`)
	}

	fn := v.(SourceFunc)
	fn(ok)

	if ok {
		cret = C.gboolean(1)
	}
}

// ChildWatchAddFull sets a function to be called when the child indicated by
// @pid exits, at the priority @priority.
//
// If you obtain @pid from g_spawn_async() or g_spawn_async_with_pipes() you
// will need to pass SPAWN_DO_NOT_REAP_CHILD as flag to the spawn function for
// the child watching to work.
//
// In many programs, you will want to call g_spawn_check_exit_status() in the
// callback to determine whether or not the child exited successfully.
//
// Also, note that on platforms where #GPid must be explicitly closed (see
// g_spawn_close_pid()) @pid must not be closed while the source is still
// active. Typically, you should invoke g_spawn_close_pid() in the callback
// function for the source.
//
// GLib supports only a single callback per process id. On POSIX platforms, the
// same restrictions mentioned for g_child_watch_source_new() apply to this
// function.
//
// This internally creates a main loop source using g_child_watch_source_new()
// and attaches it to the main loop context using g_source_attach(). You can do
// these steps manually if you need greater control.
func ChildWatchAddFull() uint {
	var cret C.guint
	var goret uint

	cret = C.g_child_watch_add_full(arg1, arg2, arg3, arg4, arg5)

	goret = uint(cret)

	return goret
}

// GetCurrentTime: equivalent to the UNIX gettimeofday() function, but portable.
//
// You may find g_get_real_time() to be more convenient.
func GetCurrentTime(result *TimeVal) {
	var arg1 *C.GTimeVal

	arg1 = (*C.GTimeVal)(unsafe.Pointer(result.Native()))

	C.g_get_current_time(arg1)
}

// GetMonotonicTime queries the system monotonic time.
//
// The monotonic clock will always increase and doesn't suffer discontinuities
// when the user (or NTP) changes the system time. It may or may not continue to
// tick during times where the machine is suspended.
//
// We try to use the clock that corresponds as closely as possible to the
// passage of time as measured by system calls such as poll() but it may not
// always be possible to do this.
func GetMonotonicTime() int64 {
	var cret C.gint64
	var goret int64

	cret = C.g_get_monotonic_time()

	goret = int64(cret)

	return goret
}

// GetRealTime queries the system wall-clock time.
//
// This call is functionally equivalent to g_get_current_time() except that the
// return value is often more convenient than dealing with a Val.
//
// You should only use this call if you are actually interested in the real
// wall-clock time. g_get_monotonic_time() is probably more useful for measuring
// intervals.
func GetRealTime() int64 {
	var cret C.gint64
	var goret int64

	cret = C.g_get_real_time()

	goret = int64(cret)

	return goret
}

// IdleAddFull adds a function to be called whenever there are no higher
// priority events pending. If the function returns false it is automatically
// removed from the list of event sources and will not be called again.
//
// See [memory management of sources][mainloop-memory-management] for details on
// how to handle the return value and memory management of @data.
//
// This internally creates a main loop source using g_idle_source_new() and
// attaches it to the global Context using g_source_attach(), so the callback
// will be invoked in whichever thread is running that main context. You can do
// these steps manually if you need greater control or to use a custom main
// context.
func IdleAddFull() uint {
	var cret C.guint
	var goret uint

	cret = C.g_idle_add_full(arg1, arg2, arg3, arg4)

	goret = uint(cret)

	return goret
}

// IdleRemoveByData removes the idle function with the given data.
func IdleRemoveByData(data interface{}) bool {
	var arg1 C.gpointer

	arg1 = C.gpointer(data)

	var cret C.gboolean
	var goret bool

	cret = C.g_idle_remove_by_data(arg1)

	if cret {
		goret = true
	}

	return goret
}

// NewIdleSource creates a new idle source.
//
// The source will not initially be associated with any Context and must be
// added to one with g_source_attach() before it will be executed. Note that the
// default priority for idle sources is G_PRIORITY_DEFAULT_IDLE, as compared to
// other sources which have a default priority of G_PRIORITY_DEFAULT.
func NewIdleSource() *Source {
	cret := new(C.GSource)
	var goret *Source

	cret = C.g_idle_source_new()

	goret = WrapSource(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *Source) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// MainCurrentSource returns the currently firing source for this thread.
func MainCurrentSource() *Source {
	var cret *C.GSource
	var goret *Source

	cret = C.g_main_current_source()

	goret = WrapSource(unsafe.Pointer(cret))

	return goret
}

// MainDepth returns the depth of the stack of calls to
// g_main_context_dispatch() on any Context in the current thread. That is, when
// called from the toplevel, it gives 0. When called from within a callback from
// g_main_context_iteration() (or g_main_loop_run(), etc.) it returns 1. When
// called from within a callback to a recursive call to
// g_main_context_iteration(), it returns 2. And so forth.
//
// This function is useful in a situation like the following: Imagine an
// extremely simple "garbage collected" system.
//
//    gpointer
//    allocate_memory (gsize size)
//    {
//      FreeListBlock *block = g_new (FreeListBlock, 1);
//      block->mem = g_malloc (size);
//      block->depth = g_main_depth ();
//      free_list = g_list_prepend (free_list, block);
//      return block->mem;
//    }
//
//    void
//    free_allocated_memory (void)
//    {
//      GList *l;
//
//      int depth = g_main_depth ();
//      for (l = free_list; l; );
//        {
//          GList *next = l->next;
//          FreeListBlock *block = l->data;
//          if (block->depth > depth)
//            {
//              g_free (block->mem);
//              g_free (block);
//              free_list = g_list_delete_link (free_list, l);
//            }
//
//          l = next;
//        }
//      }
//
// There is a temptation to use g_main_depth() to solve problems with
// reentrancy. For instance, while waiting for data to be received from the
// network in response to a menu item, the menu item might be selected again. It
// might seem that one could make the menu item's callback return immediately
// and do nothing if g_main_depth() returns a value greater than 1. However,
// this should be avoided since the user then sees selecting the menu item do
// nothing. Furthermore, you'll find yourself adding these checks all over your
// code, since there are doubtless many, many things that the user could do.
// Instead, you can use the following techniques:
//
// 1. Use gtk_widget_set_sensitive() or modal dialogs to prevent the user from
// interacting with elements while the main loop is recursing.
//
// 2. Avoid main loop recursion in situations where you can't handle arbitrary
// callbacks. Instead, structure your code so that you simply return to the main
// loop and then get called again when there is more work to do.
func MainDepth() int {
	var cret C.gint
	var goret int

	cret = C.g_main_depth()

	goret = int(cret)

	return goret
}

// TimeoutAddFull sets a function to be called at regular intervals, with the
// given priority. The function is called repeatedly until it returns false, at
// which point the timeout is automatically destroyed and the function will not
// be called again. The @notify function is called when the timeout is
// destroyed. The first call to the function will be at the end of the first
// @interval.
//
// Note that timeout functions may be delayed, due to the processing of other
// event sources. Thus they should not be relied on for precise timing. After
// each call to the timeout function, the time of the next timeout is
// recalculated based on the current time and the given interval (it does not
// try to 'catch up' time lost in delays).
//
// See [memory management of sources][mainloop-memory-management] for details on
// how to handle the return value and memory management of @data.
//
// This internally creates a main loop source using g_timeout_source_new() and
// attaches it to the global Context using g_source_attach(), so the callback
// will be invoked in whichever thread is running that main context. You can do
// these steps manually if you need greater control or to use a custom main
// context.
//
// The interval given is in terms of monotonic time, not wall clock time. See
// g_get_monotonic_time().
func TimeoutAddFull() uint {
	var cret C.guint
	var goret uint

	cret = C.g_timeout_add_full(arg1, arg2, arg3, arg4, arg5)

	goret = uint(cret)

	return goret
}

// TimeoutAddSecondsFull sets a function to be called at regular intervals, with
// @priority. The function is called repeatedly until it returns false, at which
// point the timeout is automatically destroyed and the function will not be
// called again.
//
// Unlike g_timeout_add(), this function operates at whole second granularity.
// The initial starting point of the timer is determined by the implementation
// and the implementation is expected to group multiple timers together so that
// they fire all at the same time. To allow this grouping, the @interval to the
// first timer is rounded and can deviate up to one second from the specified
// interval. Subsequent timer iterations will generally run at the specified
// interval.
//
// Note that timeout functions may be delayed, due to the processing of other
// event sources. Thus they should not be relied on for precise timing. After
// each call to the timeout function, the time of the next timeout is
// recalculated based on the current time and the given @interval
//
// See [memory management of sources][mainloop-memory-management] for details on
// how to handle the return value and memory management of @data.
//
// If you want timing more precise than whole seconds, use g_timeout_add()
// instead.
//
// The grouping of timers to fire at the same time results in a more power and
// CPU efficient behavior so if your timer is in multiples of seconds and you
// don't require the first timer exactly one second from now, the use of
// g_timeout_add_seconds() is preferred over g_timeout_add().
//
// This internally creates a main loop source using
// g_timeout_source_new_seconds() and attaches it to the main loop context using
// g_source_attach(). You can do these steps manually if you need greater
// control.
//
// It is safe to call this function from any thread.
//
// The interval given is in terms of monotonic time, not wall clock time. See
// g_get_monotonic_time().
func TimeoutAddSecondsFull() uint {
	var cret C.guint
	var goret uint

	cret = C.g_timeout_add_seconds_full(arg1, arg2, arg3, arg4, arg5)

	goret = uint(cret)

	return goret
}

// NewTimeoutSource creates a new timeout source.
//
// The source will not initially be associated with any Context and must be
// added to one with g_source_attach() before it will be executed.
//
// The interval given is in terms of monotonic time, not wall clock time. See
// g_get_monotonic_time().
func NewTimeoutSource(interval uint) *Source {
	var arg1 C.guint

	arg1 = C.guint(interval)

	cret := new(C.GSource)
	var goret *Source

	cret = C.g_timeout_source_new(arg1)

	goret = WrapSource(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *Source) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// TimeoutSourceNewSeconds creates a new timeout source.
//
// The source will not initially be associated with any Context and must be
// added to one with g_source_attach() before it will be executed.
//
// The scheduling granularity/accuracy of this timeout source will be in
// seconds.
//
// The interval given is in terms of monotonic time, not wall clock time. See
// g_get_monotonic_time().
func TimeoutSourceNewSeconds(interval uint) *Source {
	var arg1 C.guint

	arg1 = C.guint(interval)

	cret := new(C.GSource)
	var goret *Source

	cret = C.g_timeout_source_new_seconds(arg1)

	goret = WrapSource(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *Source) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// MainContext: the `GMainContext` struct is an opaque data type representing a
// set of sources to be handled in a main loop.
type MainContext struct {
	native C.GMainContext
}

// WrapMainContext wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMainContext(ptr unsafe.Pointer) *MainContext {
	if ptr == nil {
		return nil
	}

	return (*MainContext)(ptr)
}

func marshalMainContext(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapMainContext(unsafe.Pointer(b)), nil
}

// NewMainContext constructs a struct MainContext.
func NewMainContext() *MainContext {
	cret := new(C.GMainContext)
	var goret *MainContext

	cret = C.g_main_context_new()

	goret = WrapMainContext(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *MainContext) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// Native returns the underlying C source pointer.
func (m *MainContext) Native() unsafe.Pointer {
	return unsafe.Pointer(&m.native)
}

// Acquire tries to become the owner of the specified context. If some other
// thread is the owner of the context, returns false immediately. Ownership is
// properly recursive: the owner can require ownership again and will release
// ownership when g_main_context_release() is called as many times as
// g_main_context_acquire().
//
// You must be the owner of a context before you can call
// g_main_context_prepare(), g_main_context_query(), g_main_context_check(),
// g_main_context_dispatch().
func (c *MainContext) Acquire() bool {
	var arg0 *C.GMainContext

	arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.g_main_context_acquire(arg0)

	if cret {
		goret = true
	}

	return goret
}

// AddPoll adds a file descriptor to the set of file descriptors polled for this
// context. This will very seldom be used directly. Instead a typical event
// source will use g_source_add_unix_fd() instead.
func (c *MainContext) AddPoll(fd *PollFD, priority int) {
	var arg0 *C.GMainContext
	var arg1 *C.GPollFD
	var arg2 C.gint

	arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))
	arg1 = (*C.GPollFD)(unsafe.Pointer(fd.Native()))
	arg2 = C.gint(priority)

	C.g_main_context_add_poll(arg0, arg1, arg2)
}

// Check passes the results of polling back to the main loop. You should be
// careful to pass @fds and its length @n_fds as received from
// g_main_context_query(), as this functions relies on assumptions on how @fds
// is filled.
//
// You must have successfully acquired the context with g_main_context_acquire()
// before you may call this function.
func (c *MainContext) Check() bool {
	var arg0 *C.GMainContext

	arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.g_main_context_check(arg0, arg1, arg2, arg3)

	if cret {
		goret = true
	}

	return goret
}

// Dispatch dispatches all pending sources.
//
// You must have successfully acquired the context with g_main_context_acquire()
// before you may call this function.
func (c *MainContext) Dispatch() {
	var arg0 *C.GMainContext

	arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))

	C.g_main_context_dispatch(arg0)
}

// FindSourceByID finds a #GSource given a pair of context and ID.
//
// It is a programmer error to attempt to look up a non-existent source.
//
// More specifically: source IDs can be reissued after a source has been
// destroyed and therefore it is never valid to use this function with a source
// ID which may have already been removed. An example is when scheduling an idle
// to run in another thread with g_idle_add(): the idle may already have run and
// been removed by the time this function is called on its (now invalid) source
// ID. This source ID may have been reissued, leading to the operation being
// performed against the wrong source.
func (c *MainContext) FindSourceByID(sourceID uint) *Source {
	var arg0 *C.GMainContext
	var arg1 C.guint

	arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))
	arg1 = C.guint(sourceID)

	var cret *C.GSource
	var goret *Source

	cret = C.g_main_context_find_source_by_id(arg0, arg1)

	goret = WrapSource(unsafe.Pointer(cret))

	return goret
}

// FindSourceByUserData finds a source with the given user data for the
// callback. If multiple sources exist with the same user data, the first one
// found will be returned.
func (c *MainContext) FindSourceByUserData(userData interface{}) *Source {
	var arg0 *C.GMainContext
	var arg1 C.gpointer

	arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))
	arg1 = C.gpointer(userData)

	var cret *C.GSource
	var goret *Source

	cret = C.g_main_context_find_source_by_user_data(arg0, arg1)

	goret = WrapSource(unsafe.Pointer(cret))

	return goret
}

// Invoke invokes a function in such a way that @context is owned during the
// invocation of @function.
//
// If @context is nil then the global default main context — as returned by
// g_main_context_default() — is used.
//
// If @context is owned by the current thread, @function is called directly.
// Otherwise, if @context is the thread-default main context of the current
// thread and g_main_context_acquire() succeeds, then @function is called and
// g_main_context_release() is called afterwards.
//
// In any other case, an idle source is created to call @function and that
// source is attached to @context (presumably to be run in another thread). The
// idle source is attached with PRIORITY_DEFAULT priority. If you want a
// different priority, use g_main_context_invoke_full().
//
// Note that, as with normal idle functions, @function should probably return
// false. If it returns true, it will be continuously run in a loop (and may
// prevent this call from returning).
func (c *MainContext) Invoke() {
	var arg0 *C.GMainContext

	arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))

	C.g_main_context_invoke(arg0, arg1, arg2)
}

// InvokeFull invokes a function in such a way that @context is owned during the
// invocation of @function.
//
// This function is the same as g_main_context_invoke() except that it lets you
// specify the priority in case @function ends up being scheduled as an idle and
// also lets you give a Notify for @data.
//
// @notify should not assume that it is called from any particular thread or
// with any particular context acquired.
func (c *MainContext) InvokeFull() {
	var arg0 *C.GMainContext

	arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))

	C.g_main_context_invoke_full(arg0, arg1, arg2, arg3, arg4)
}

// IsOwner determines whether this thread holds the (recursive) ownership of
// this Context. This is useful to know before waiting on another thread that
// may be blocking to get ownership of @context.
func (c *MainContext) IsOwner() bool {
	var arg0 *C.GMainContext

	arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.g_main_context_is_owner(arg0)

	if cret {
		goret = true
	}

	return goret
}

// Iteration runs a single iteration for the given main loop. This involves
// checking to see if any event sources are ready to be processed, then if no
// events sources are ready and @may_block is true, waiting for a source to
// become ready, then dispatching the highest priority events sources that are
// ready. Otherwise, if @may_block is false sources are not waited to become
// ready, only those highest priority events sources will be dispatched (if
// any), that are ready at this given moment without further waiting.
//
// Note that even when @may_block is true, it is still possible for
// g_main_context_iteration() to return false, since the wait may be interrupted
// for other reasons than an event source becoming ready.
func (c *MainContext) Iteration(mayBlock bool) bool {
	var arg0 *C.GMainContext
	var arg1 C.gboolean

	arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))
	if mayBlock {
		arg1 = C.gboolean(1)
	}

	var cret C.gboolean
	var goret bool

	cret = C.g_main_context_iteration(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// Pending checks if any sources have pending events for the given context.
func (c *MainContext) Pending() bool {
	var arg0 *C.GMainContext

	arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.g_main_context_pending(arg0)

	if cret {
		goret = true
	}

	return goret
}

// PopThreadDefault pops @context off the thread-default context stack
// (verifying that it was on the top of the stack).
func (c *MainContext) PopThreadDefault() {
	var arg0 *C.GMainContext

	arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))

	C.g_main_context_pop_thread_default(arg0)
}

// Prepare prepares to poll sources within a main loop. The resulting
// information for polling is determined by calling g_main_context_query ().
//
// You must have successfully acquired the context with g_main_context_acquire()
// before you may call this function.
func (c *MainContext) Prepare() (priority int, ok bool) {
	var arg0 *C.GMainContext

	arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))

	arg1 := new(C.gint)
	var ret1 int
	var cret C.gboolean
	var goret bool

	cret = C.g_main_context_prepare(arg0, arg1)

	ret1 = int(*arg1)
	if cret {
		goret = true
	}

	return ret1, goret
}

// PushThreadDefault acquires @context and sets it as the thread-default context
// for the current thread. This will cause certain asynchronous operations (such
// as most [gio][gio]-based I/O) which are started in this thread to run under
// @context and deliver their results to its main loop, rather than running
// under the global default context in the main thread. Note that calling this
// function changes the context returned by g_main_context_get_thread_default(),
// not the one returned by g_main_context_default(), so it does not affect the
// context used by functions like g_idle_add().
//
// Normally you would call this function shortly after creating a new thread,
// passing it a Context which will be run by a Loop in that thread, to set a new
// default context for all async operations in that thread. In this case you may
// not need to ever call g_main_context_pop_thread_default(), assuming you want
// the new Context to be the default for the whole lifecycle of the thread.
//
// If you don't have control over how the new thread was created (e.g. in the
// new thread isn't newly created, or if the thread life cycle is managed by a
// Pool), it is always suggested to wrap the logic that needs to use the new
// Context inside a g_main_context_push_thread_default() /
// g_main_context_pop_thread_default() pair, otherwise threads that are re-used
// will end up never explicitly releasing the Context reference they hold.
//
// In some cases you may want to schedule a single operation in a non-default
// context, or temporarily use a non-default context in the main thread. In that
// case, you can wrap the call to the asynchronous operation inside a
// g_main_context_push_thread_default() / g_main_context_pop_thread_default()
// pair, but it is up to you to ensure that no other asynchronous operations
// accidentally get started while the non-default context is active.
//
// Beware that libraries that predate this function may not correctly handle
// being used from a thread with a thread-default context. Eg, see
// g_file_supports_thread_contexts().
func (c *MainContext) PushThreadDefault() {
	var arg0 *C.GMainContext

	arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))

	C.g_main_context_push_thread_default(arg0)
}

// Query determines information necessary to poll this main loop. You should be
// careful to pass the resulting @fds array and its length @n_fds as is when
// calling g_main_context_check(), as this function relies on assumptions made
// when the array is filled.
//
// You must have successfully acquired the context with g_main_context_acquire()
// before you may call this function.
func (c *MainContext) Query(maxPriority int, nFds int) int {
	var arg0 *C.GMainContext
	var arg1 C.gint
	var arg4 C.gint

	arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))
	arg1 = C.gint(maxPriority)
	arg4 = C.gint(nFds)

	var cret C.gint
	var goret int

	cret = C.g_main_context_query(arg0, arg1, arg2, arg3, arg4)

	goret = int(cret)

	return ret2, ret3, goret
}

// Ref increases the reference count on a Context object by one.
func (c *MainContext) Ref() *MainContext {
	var arg0 *C.GMainContext

	arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))

	cret := new(C.GMainContext)
	var goret *MainContext

	cret = C.g_main_context_ref(arg0)

	goret = WrapMainContext(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *MainContext) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// Release releases ownership of a context previously acquired by this thread
// with g_main_context_acquire(). If the context was acquired multiple times,
// the ownership will be released only when g_main_context_release() is called
// as many times as it was acquired.
func (c *MainContext) Release() {
	var arg0 *C.GMainContext

	arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))

	C.g_main_context_release(arg0)
}

// RemovePoll removes file descriptor from the set of file descriptors to be
// polled for a particular context.
func (c *MainContext) RemovePoll(fd *PollFD) {
	var arg0 *C.GMainContext
	var arg1 *C.GPollFD

	arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))
	arg1 = (*C.GPollFD)(unsafe.Pointer(fd.Native()))

	C.g_main_context_remove_poll(arg0, arg1)
}

// Unref decreases the reference count on a Context object by one. If the result
// is zero, free the context and free all associated memory.
func (c *MainContext) Unref() {
	var arg0 *C.GMainContext

	arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))

	C.g_main_context_unref(arg0)
}

// Wakeup: if @context is currently blocking in g_main_context_iteration()
// waiting for a source to become ready, cause it to stop blocking and return.
// Otherwise, cause the next invocation of g_main_context_iteration() to return
// without blocking.
//
// This API is useful for low-level control over Context; for example,
// integrating it with main loop implementations such as Loop.
//
// Another related use for this function is when implementing a main loop with a
// termination condition, computed from multiple threads:
//
//      perform_work();
//
//      if (g_atomic_int_dec_and_test (&tasks_remaining))
//        g_main_context_wakeup (NULL);
func (c *MainContext) Wakeup() {
	var arg0 *C.GMainContext

	arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))

	C.g_main_context_wakeup(arg0)
}

// MainLoop: the `GMainLoop` struct is an opaque data type representing the main
// event loop of a GLib or GTK+ application.
type MainLoop struct {
	native C.GMainLoop
}

// WrapMainLoop wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMainLoop(ptr unsafe.Pointer) *MainLoop {
	if ptr == nil {
		return nil
	}

	return (*MainLoop)(ptr)
}

func marshalMainLoop(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapMainLoop(unsafe.Pointer(b)), nil
}

// NewMainLoop constructs a struct MainLoop.
func NewMainLoop(context *MainContext, isRunning bool) *MainLoop {
	var arg1 *C.GMainContext
	var arg2 C.gboolean

	arg1 = (*C.GMainContext)(unsafe.Pointer(context.Native()))
	if isRunning {
		arg2 = C.gboolean(1)
	}

	cret := new(C.GMainLoop)
	var goret *MainLoop

	cret = C.g_main_loop_new(arg1, arg2)

	goret = WrapMainLoop(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *MainLoop) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// Native returns the underlying C source pointer.
func (m *MainLoop) Native() unsafe.Pointer {
	return unsafe.Pointer(&m.native)
}

// Context returns the Context of @loop.
func (l *MainLoop) Context() *MainContext {
	var arg0 *C.GMainLoop

	arg0 = (*C.GMainLoop)(unsafe.Pointer(l.Native()))

	var cret *C.GMainContext
	var goret *MainContext

	cret = C.g_main_loop_get_context(arg0)

	goret = WrapMainContext(unsafe.Pointer(cret))

	return goret
}

// IsRunning checks to see if the main loop is currently being run via
// g_main_loop_run().
func (l *MainLoop) IsRunning() bool {
	var arg0 *C.GMainLoop

	arg0 = (*C.GMainLoop)(unsafe.Pointer(l.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.g_main_loop_is_running(arg0)

	if cret {
		goret = true
	}

	return goret
}

// Quit stops a Loop from running. Any calls to g_main_loop_run() for the loop
// will return.
//
// Note that sources that have already been dispatched when g_main_loop_quit()
// is called will still be executed.
func (l *MainLoop) Quit() {
	var arg0 *C.GMainLoop

	arg0 = (*C.GMainLoop)(unsafe.Pointer(l.Native()))

	C.g_main_loop_quit(arg0)
}

// Ref increases the reference count on a Loop object by one.
func (l *MainLoop) Ref() *MainLoop {
	var arg0 *C.GMainLoop

	arg0 = (*C.GMainLoop)(unsafe.Pointer(l.Native()))

	cret := new(C.GMainLoop)
	var goret *MainLoop

	cret = C.g_main_loop_ref(arg0)

	goret = WrapMainLoop(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *MainLoop) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// Run runs a main loop until g_main_loop_quit() is called on the loop. If this
// is called for the thread of the loop's Context, it will process events from
// the loop, otherwise it will simply wait.
func (l *MainLoop) Run() {
	var arg0 *C.GMainLoop

	arg0 = (*C.GMainLoop)(unsafe.Pointer(l.Native()))

	C.g_main_loop_run(arg0)
}

// Unref decreases the reference count on a Loop object by one. If the result is
// zero, free the loop and free all associated memory.
func (l *MainLoop) Unref() {
	var arg0 *C.GMainLoop

	arg0 = (*C.GMainLoop)(unsafe.Pointer(l.Native()))

	C.g_main_loop_unref(arg0)
}

// Source: the `GSource` struct is an opaque data type representing an event
// source.
type Source struct {
	native C.GSource
}

// WrapSource wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSource(ptr unsafe.Pointer) *Source {
	if ptr == nil {
		return nil
	}

	return (*Source)(ptr)
}

func marshalSource(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSource(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *Source) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// AddChildSource adds @child_source to @source as a "polled" source; when
// @source is added to a Context, @child_source will be automatically added with
// the same priority, when @child_source is triggered, it will cause @source to
// dispatch (in addition to calling its own callback), and when @source is
// destroyed, it will destroy @child_source as well. (@source will also still be
// dispatched if its own prepare/check functions indicate that it is ready.)
//
// If you don't need @child_source to do anything on its own when it triggers,
// you can call g_source_set_dummy_callback() on it to set a callback that does
// nothing (except return true if appropriate).
//
// @source will hold a reference on @child_source while @child_source is
// attached to it.
//
// This API is only intended to be used by implementations of #GSource. Do not
// call this API on a #GSource that you did not create.
func (s *Source) AddChildSource(childSource *Source) {
	var arg0 *C.GSource
	var arg1 *C.GSource

	arg0 = (*C.GSource)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GSource)(unsafe.Pointer(childSource.Native()))

	C.g_source_add_child_source(arg0, arg1)
}

// AddPoll adds a file descriptor to the set of file descriptors polled for this
// source. This is usually combined with g_source_new() to add an event source.
// The event source's check function will typically test the @revents field in
// the FD struct and return true if events need to be processed.
//
// This API is only intended to be used by implementations of #GSource. Do not
// call this API on a #GSource that you did not create.
//
// Using this API forces the linear scanning of event sources on each main loop
// iteration. Newly-written event sources should try to use
// g_source_add_unix_fd() instead of this API.
func (s *Source) AddPoll(fd *PollFD) {
	var arg0 *C.GSource
	var arg1 *C.GPollFD

	arg0 = (*C.GSource)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GPollFD)(unsafe.Pointer(fd.Native()))

	C.g_source_add_poll(arg0, arg1)
}

// AddUnixFd monitors @fd for the IO events in @events.
//
// The tag returned by this function can be used to remove or modify the
// monitoring of the fd using g_source_remove_unix_fd() or
// g_source_modify_unix_fd().
//
// It is not necessary to remove the fd before destroying the source; it will be
// cleaned up automatically.
//
// This API is only intended to be used by implementations of #GSource. Do not
// call this API on a #GSource that you did not create.
//
// As the name suggests, this function is not available on Windows.
func (s *Source) AddUnixFd(fd int, events IOCondition) interface{} {
	var arg0 *C.GSource
	var arg1 C.gint
	var arg2 C.GIOCondition

	arg0 = (*C.GSource)(unsafe.Pointer(s.Native()))
	arg1 = C.gint(fd)
	arg2 = (C.GIOCondition)(events)

	var cret C.gpointer
	var goret interface{}

	cret = C.g_source_add_unix_fd(arg0, arg1, arg2)

	goret = interface{}(cret)

	return goret
}

// Attach adds a #GSource to a @context so that it will be executed within that
// context. Remove it by calling g_source_destroy().
//
// This function is safe to call from any thread, regardless of which thread the
// @context is running in.
func (s *Source) Attach(context *MainContext) uint {
	var arg0 *C.GSource
	var arg1 *C.GMainContext

	arg0 = (*C.GSource)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GMainContext)(unsafe.Pointer(context.Native()))

	var cret C.guint
	var goret uint

	cret = C.g_source_attach(arg0, arg1)

	goret = uint(cret)

	return goret
}

// Destroy removes a source from its Context, if any, and mark it as destroyed.
// The source cannot be subsequently added to another context. It is safe to
// call this on sources which have already been removed from their context.
//
// This does not unref the #GSource: if you still hold a reference, use
// g_source_unref() to drop it.
//
// This function is safe to call from any thread, regardless of which thread the
// Context is running in.
func (s *Source) Destroy() {
	var arg0 *C.GSource

	arg0 = (*C.GSource)(unsafe.Pointer(s.Native()))

	C.g_source_destroy(arg0)
}

// CanRecurse checks whether a source is allowed to be called recursively. see
// g_source_set_can_recurse().
func (s *Source) CanRecurse() bool {
	var arg0 *C.GSource

	arg0 = (*C.GSource)(unsafe.Pointer(s.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.g_source_get_can_recurse(arg0)

	if cret {
		goret = true
	}

	return goret
}

// Context gets the Context with which the source is associated.
//
// You can call this on a source that has been destroyed, provided that the
// Context it was attached to still exists (in which case it will return that
// Context). In particular, you can always call this function on the source
// returned from g_main_current_source(). But calling this function on a source
// whose Context has been destroyed is an error.
func (s *Source) Context() *MainContext {
	var arg0 *C.GSource

	arg0 = (*C.GSource)(unsafe.Pointer(s.Native()))

	var cret *C.GMainContext
	var goret *MainContext

	cret = C.g_source_get_context(arg0)

	goret = WrapMainContext(unsafe.Pointer(cret))

	return goret
}

// CurrentTime: this function ignores @source and is otherwise the same as
// g_get_current_time().
func (s *Source) CurrentTime(timeval *TimeVal) {
	var arg0 *C.GSource
	var arg1 *C.GTimeVal

	arg0 = (*C.GSource)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GTimeVal)(unsafe.Pointer(timeval.Native()))

	C.g_source_get_current_time(arg0, arg1)
}

// ID returns the numeric ID for a particular source. The ID of a source is a
// positive integer which is unique within a particular main loop context. The
// reverse mapping from ID to source is done by
// g_main_context_find_source_by_id().
//
// You can only call this function while the source is associated to a Context
// instance; calling this function before g_source_attach() or after
// g_source_destroy() yields undefined behavior. The ID returned is unique
// within the Context instance passed to g_source_attach().
func (s *Source) ID() uint {
	var arg0 *C.GSource

	arg0 = (*C.GSource)(unsafe.Pointer(s.Native()))

	var cret C.guint
	var goret uint

	cret = C.g_source_get_id(arg0)

	goret = uint(cret)

	return goret
}

// Name gets a name for the source, used in debugging and profiling. The name
// may be LL if it has never been set with g_source_set_name().
func (s *Source) Name() string {
	var arg0 *C.GSource

	arg0 = (*C.GSource)(unsafe.Pointer(s.Native()))

	var cret *C.char
	var goret string

	cret = C.g_source_get_name(arg0)

	goret = C.GoString(cret)

	return goret
}

// Priority gets the priority of a source.
func (s *Source) Priority() int {
	var arg0 *C.GSource

	arg0 = (*C.GSource)(unsafe.Pointer(s.Native()))

	var cret C.gint
	var goret int

	cret = C.g_source_get_priority(arg0)

	goret = int(cret)

	return goret
}

// ReadyTime gets the "ready time" of @source, as set by
// g_source_set_ready_time().
//
// Any time before the current monotonic time (including 0) is an indication
// that the source will fire immediately.
func (s *Source) ReadyTime() int64 {
	var arg0 *C.GSource

	arg0 = (*C.GSource)(unsafe.Pointer(s.Native()))

	var cret C.gint64
	var goret int64

	cret = C.g_source_get_ready_time(arg0)

	goret = int64(cret)

	return goret
}

// Time gets the time to be used when checking this source. The advantage of
// calling this function over calling g_get_monotonic_time() directly is that
// when checking multiple sources, GLib can cache a single value instead of
// having to repeatedly get the system monotonic time.
//
// The time here is the system monotonic time, if available, or some other
// reasonable alternative otherwise. See g_get_monotonic_time().
func (s *Source) Time() int64 {
	var arg0 *C.GSource

	arg0 = (*C.GSource)(unsafe.Pointer(s.Native()))

	var cret C.gint64
	var goret int64

	cret = C.g_source_get_time(arg0)

	goret = int64(cret)

	return goret
}

// IsDestroyed returns whether @source has been destroyed.
//
// This is important when you operate upon your objects from within idle
// handlers, but may have freed the object before the dispatch of your idle
// handler.
//
//    static gboolean
//    idle_callback (gpointer data)
//    {
//      SomeWidget *self = data;
//
//      g_mutex_lock (&self->idle_id_mutex);
//      if (!g_source_is_destroyed (g_main_current_source ()))
//        {
//          // do stuff with self
//        }
//      g_mutex_unlock (&self->idle_id_mutex);
//
//      return FALSE;
//    }
//
// Calls to this function from a thread other than the one acquired by the
// Context the #GSource is attached to are typically redundant, as the source
// could be destroyed immediately after this function returns. However, once a
// source is destroyed it cannot be un-destroyed, so this function can be used
// for opportunistic checks from any thread.
func (s *Source) IsDestroyed() bool {
	var arg0 *C.GSource

	arg0 = (*C.GSource)(unsafe.Pointer(s.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.g_source_is_destroyed(arg0)

	if cret {
		goret = true
	}

	return goret
}

// ModifyUnixFd updates the event mask to watch for the fd identified by @tag.
//
// @tag is the tag returned from g_source_add_unix_fd().
//
// If you want to remove a fd, don't set its event mask to zero. Instead, call
// g_source_remove_unix_fd().
//
// This API is only intended to be used by implementations of #GSource. Do not
// call this API on a #GSource that you did not create.
//
// As the name suggests, this function is not available on Windows.
func (s *Source) ModifyUnixFd(tag interface{}, newEvents IOCondition) {
	var arg0 *C.GSource
	var arg1 C.gpointer
	var arg2 C.GIOCondition

	arg0 = (*C.GSource)(unsafe.Pointer(s.Native()))
	arg1 = C.gpointer(tag)
	arg2 = (C.GIOCondition)(newEvents)

	C.g_source_modify_unix_fd(arg0, arg1, arg2)
}

// QueryUnixFd queries the events reported for the fd corresponding to @tag on
// @source during the last poll.
//
// The return value of this function is only defined when the function is called
// from the check or dispatch functions for @source.
//
// This API is only intended to be used by implementations of #GSource. Do not
// call this API on a #GSource that you did not create.
//
// As the name suggests, this function is not available on Windows.
func (s *Source) QueryUnixFd(tag interface{}) IOCondition {
	var arg0 *C.GSource
	var arg1 C.gpointer

	arg0 = (*C.GSource)(unsafe.Pointer(s.Native()))
	arg1 = C.gpointer(tag)

	var cret C.GIOCondition
	var goret IOCondition

	cret = C.g_source_query_unix_fd(arg0, arg1)

	goret = IOCondition(cret)

	return goret
}

// Ref increases the reference count on a source by one.
func (s *Source) Ref() *Source {
	var arg0 *C.GSource

	arg0 = (*C.GSource)(unsafe.Pointer(s.Native()))

	cret := new(C.GSource)
	var goret *Source

	cret = C.g_source_ref(arg0)

	goret = WrapSource(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *Source) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// RemoveChildSource detaches @child_source from @source and destroys it.
//
// This API is only intended to be used by implementations of #GSource. Do not
// call this API on a #GSource that you did not create.
func (s *Source) RemoveChildSource(childSource *Source) {
	var arg0 *C.GSource
	var arg1 *C.GSource

	arg0 = (*C.GSource)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GSource)(unsafe.Pointer(childSource.Native()))

	C.g_source_remove_child_source(arg0, arg1)
}

// RemovePoll removes a file descriptor from the set of file descriptors polled
// for this source.
//
// This API is only intended to be used by implementations of #GSource. Do not
// call this API on a #GSource that you did not create.
func (s *Source) RemovePoll(fd *PollFD) {
	var arg0 *C.GSource
	var arg1 *C.GPollFD

	arg0 = (*C.GSource)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GPollFD)(unsafe.Pointer(fd.Native()))

	C.g_source_remove_poll(arg0, arg1)
}

// RemoveUnixFd reverses the effect of a previous call to
// g_source_add_unix_fd().
//
// You only need to call this if you want to remove an fd from being watched
// while keeping the same source around. In the normal case you will just want
// to destroy the source.
//
// This API is only intended to be used by implementations of #GSource. Do not
// call this API on a #GSource that you did not create.
//
// As the name suggests, this function is not available on Windows.
func (s *Source) RemoveUnixFd(tag interface{}) {
	var arg0 *C.GSource
	var arg1 C.gpointer

	arg0 = (*C.GSource)(unsafe.Pointer(s.Native()))
	arg1 = C.gpointer(tag)

	C.g_source_remove_unix_fd(arg0, arg1)
}

// SetCallback sets the callback function for a source. The callback for a
// source is called from the source's dispatch function.
//
// The exact type of @func depends on the type of source; ie. you should not
// count on @func being called with @data as its first parameter. Cast @func
// with G_SOURCE_FUNC() to avoid warnings about incompatible function types.
//
// See [memory management of sources][mainloop-memory-management] for details on
// how to handle memory management of @data.
//
// Typically, you won't use this function. Instead use functions specific to the
// type of source you are using, such as g_idle_add() or g_timeout_add().
//
// It is safe to call this function multiple times on a source which has already
// been attached to a context. The changes will take effect for the next time
// the source is dispatched after this call returns.
func (s *Source) SetCallback() {
	var arg0 *C.GSource

	arg0 = (*C.GSource)(unsafe.Pointer(s.Native()))

	C.g_source_set_callback(arg0, arg1, arg2, arg3)
}

// SetCanRecurse sets whether a source can be called recursively. If
// @can_recurse is true, then while the source is being dispatched then this
// source will be processed normally. Otherwise, all processing of this source
// is blocked until the dispatch function returns.
func (s *Source) SetCanRecurse(canRecurse bool) {
	var arg0 *C.GSource
	var arg1 C.gboolean

	arg0 = (*C.GSource)(unsafe.Pointer(s.Native()))
	if canRecurse {
		arg1 = C.gboolean(1)
	}

	C.g_source_set_can_recurse(arg0, arg1)
}

// SetName sets a name for the source, used in debugging and profiling. The name
// defaults to LL.
//
// The source name should describe in a human-readable way what the source does.
// For example, "X11 event queue" or "GTK+ repaint idle handler" or whatever it
// is.
//
// It is permitted to call this function multiple times, but is not recommended
// due to the potential performance impact. For example, one could change the
// name in the "check" function of a Funcs to include details like the event
// type in the source name.
//
// Use caution if changing the name while another thread may be accessing it
// with g_source_get_name(); that function does not copy the value, and changing
// the value will free it while the other thread may be attempting to use it.
func (s *Source) SetName(name string) {
	var arg0 *C.GSource
	var arg1 *C.char

	arg0 = (*C.GSource)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.g_source_set_name(arg0, arg1)
}

// SetPriority sets the priority of a source. While the main loop is being run,
// a source will be dispatched if it is ready to be dispatched and no sources at
// a higher (numerically smaller) priority are ready to be dispatched.
//
// A child source always has the same priority as its parent. It is not
// permitted to change the priority of a source once it has been added as a
// child of another source.
func (s *Source) SetPriority(priority int) {
	var arg0 *C.GSource
	var arg1 C.gint

	arg0 = (*C.GSource)(unsafe.Pointer(s.Native()))
	arg1 = C.gint(priority)

	C.g_source_set_priority(arg0, arg1)
}

// SetReadyTime sets a #GSource to be dispatched when the given monotonic time
// is reached (or passed). If the monotonic time is in the past (as it always
// will be if @ready_time is 0) then the source will be dispatched immediately.
//
// If @ready_time is -1 then the source is never woken up on the basis of the
// passage of time.
//
// Dispatching the source does not reset the ready time. You should do so
// yourself, from the source dispatch function.
//
// Note that if you have a pair of sources where the ready time of one suggests
// that it will be delivered first but the priority for the other suggests that
// it would be delivered first, and the ready time for both sources is reached
// during the same main context iteration, then the order of dispatch is
// undefined.
//
// It is a no-op to call this function on a #GSource which has already been
// destroyed with g_source_destroy().
//
// This API is only intended to be used by implementations of #GSource. Do not
// call this API on a #GSource that you did not create.
func (s *Source) SetReadyTime(readyTime int64) {
	var arg0 *C.GSource
	var arg1 C.gint64

	arg0 = (*C.GSource)(unsafe.Pointer(s.Native()))
	arg1 = C.gint64(readyTime)

	C.g_source_set_ready_time(arg0, arg1)
}

// Unref decreases the reference count of a source by one. If the resulting
// reference count is zero the source and associated memory will be destroyed.
func (s *Source) Unref() {
	var arg0 *C.GSource

	arg0 = (*C.GSource)(unsafe.Pointer(s.Native()))

	C.g_source_unref(arg0)
}
