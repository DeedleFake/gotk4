// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"runtime"
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <glib.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_main_context_get_type()), F: marshalMainContext},
		{T: externglib.Type(C.g_main_loop_get_type()), F: marshalMainLoop},
	})
}

// MainContextPusher: opaque type. See g_main_context_pusher_new() for details.
type MainContextPusher = C.void

// GetCurrentTime: equivalent to the UNIX gettimeofday() function, but portable.
//
// You may find g_get_real_time() to be more convenient.
//
// Deprecated: since version 2.62.
func GetCurrentTime(result *TimeVal) {
	var _arg1 *C.GTimeVal // out

	_arg1 = (*C.GTimeVal)(unsafe.Pointer(result.Native()))

	C.g_get_current_time(_arg1)
}

// GetMonotonicTime queries the system monotonic time.
//
// The monotonic clock will always increase and doesn't suffer discontinuities
// when the user (or NTP) changes the system time. It may or may not continue to
// tick during times where the machine is suspended.
//
// We try to use the clock that corresponds as closely as possible to the
// passage of time as measured by system calls such as poll() but it may not
// always be possible to do this.
func GetMonotonicTime() int64 {
	var _cret C.gint64 // in

	_cret = C.g_get_monotonic_time()

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// GetRealTime queries the system wall-clock time.
//
// This call is functionally equivalent to g_get_current_time() except that the
// return value is often more convenient than dealing with a Val.
//
// You should only use this call if you are actually interested in the real
// wall-clock time. g_get_monotonic_time() is probably more useful for measuring
// intervals.
func GetRealTime() int64 {
	var _cret C.gint64 // in

	_cret = C.g_get_real_time()

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// NewIdleSource creates a new idle source.
//
// The source will not initially be associated with any Context and must be
// added to one with g_source_attach() before it will be executed. Note that the
// default priority for idle sources is G_PRIORITY_DEFAULT_IDLE, as compared to
// other sources which have a default priority of G_PRIORITY_DEFAULT.
func NewIdleSource() *Source {
	var _cret *C.GSource // in

	_cret = C.g_idle_source_new()

	var _source *Source // out

	_source = (*Source)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_source, func(v **Source) {
		C.free(unsafe.Pointer(v))
	})

	return _source
}

// MainCurrentSource returns the currently firing source for this thread.
func MainCurrentSource() *Source {
	var _cret *C.GSource // in

	_cret = C.g_main_current_source()

	var _source *Source // out

	_source = (*Source)(unsafe.Pointer(_cret))

	return _source
}

// MainDepth returns the depth of the stack of calls to
// g_main_context_dispatch() on any Context in the current thread. That is, when
// called from the toplevel, it gives 0. When called from within a callback from
// g_main_context_iteration() (or g_main_loop_run(), etc.) it returns 1. When
// called from within a callback to a recursive call to
// g_main_context_iteration(), it returns 2. And so forth.
//
// This function is useful in a situation like the following: Imagine an
// extremely simple "garbage collected" system.
//
//    gpointer
//    allocate_memory (gsize size)
//    {
//      FreeListBlock *block = g_new (FreeListBlock, 1);
//      block->mem = g_malloc (size);
//      block->depth = g_main_depth ();
//      free_list = g_list_prepend (free_list, block);
//      return block->mem;
//    }
//
//    void
//    free_allocated_memory (void)
//    {
//      GList *l;
//
//      int depth = g_main_depth ();
//      for (l = free_list; l; );
//        {
//          GList *next = l->next;
//          FreeListBlock *block = l->data;
//          if (block->depth > depth)
//            {
//              g_free (block->mem);
//              g_free (block);
//              free_list = g_list_delete_link (free_list, l);
//            }
//
//          l = next;
//        }
//      }
//
// There is a temptation to use g_main_depth() to solve problems with
// reentrancy. For instance, while waiting for data to be received from the
// network in response to a menu item, the menu item might be selected again. It
// might seem that one could make the menu item's callback return immediately
// and do nothing if g_main_depth() returns a value greater than 1. However,
// this should be avoided since the user then sees selecting the menu item do
// nothing. Furthermore, you'll find yourself adding these checks all over your
// code, since there are doubtless many, many things that the user could do.
// Instead, you can use the following techniques:
//
// 1. Use gtk_widget_set_sensitive() or modal dialogs to prevent the user from
// interacting with elements while the main loop is recursing.
//
// 2. Avoid main loop recursion in situations where you can't handle arbitrary
// callbacks. Instead, structure your code so that you simply return to the main
// loop and then get called again when there is more work to do.
func MainDepth() int {
	var _cret C.gint // in

	_cret = C.g_main_depth()

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// NewTimeoutSource creates a new timeout source.
//
// The source will not initially be associated with any Context and must be
// added to one with g_source_attach() before it will be executed.
//
// The interval given is in terms of monotonic time, not wall clock time. See
// g_get_monotonic_time().
func NewTimeoutSource(interval uint) *Source {
	var _arg1 C.guint    // out
	var _cret *C.GSource // in

	_arg1 = C.guint(interval)

	_cret = C.g_timeout_source_new(_arg1)

	var _source *Source // out

	_source = (*Source)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_source, func(v **Source) {
		C.free(unsafe.Pointer(v))
	})

	return _source
}

// TimeoutSourceNewSeconds creates a new timeout source.
//
// The source will not initially be associated with any Context and must be
// added to one with g_source_attach() before it will be executed.
//
// The scheduling granularity/accuracy of this timeout source will be in
// seconds.
//
// The interval given is in terms of monotonic time, not wall clock time. See
// g_get_monotonic_time().
func TimeoutSourceNewSeconds(interval uint) *Source {
	var _arg1 C.guint    // out
	var _cret *C.GSource // in

	_arg1 = C.guint(interval)

	_cret = C.g_timeout_source_new_seconds(_arg1)

	var _source *Source // out

	_source = (*Source)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_source, func(v **Source) {
		C.free(unsafe.Pointer(v))
	})

	return _source
}

// MainContext: the `GMainContext` struct is an opaque data type representing a
// set of sources to be handled in a main loop.
type MainContext C.GMainContext

// WrapMainContext wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMainContext(ptr unsafe.Pointer) *MainContext {
	return (*MainContext)(ptr)
}

func marshalMainContext(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*MainContext)(unsafe.Pointer(b)), nil
}

// NewMainContext constructs a struct MainContext.
func NewMainContext() *MainContext {
	var _cret *C.GMainContext // in

	_cret = C.g_main_context_new()

	var _mainContext *MainContext // out

	_mainContext = (*MainContext)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_mainContext, func(v **MainContext) {
		C.free(unsafe.Pointer(v))
	})

	return _mainContext
}

// Native returns the underlying C source pointer.
func (m *MainContext) Native() unsafe.Pointer {
	return unsafe.Pointer(m)
}

// Acquire: if @context is currently blocking in g_main_context_iteration()
// waiting for a source to become ready, cause it to stop blocking and return.
// Otherwise, cause the next invocation of g_main_context_iteration() to return
// without blocking.
//
// This API is useful for low-level control over Context; for example,
// integrating it with main loop implementations such as Loop.
//
// Another related use for this function is when implementing a main loop with a
// termination condition, computed from multiple threads:
//
//      perform_work();
//
//      if (g_atomic_int_dec_and_test (&tasks_remaining))
//        g_main_context_wakeup (NULL);
func (c *MainContext) Acquire() bool {
	var _arg0 *C.GMainContext // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))

	_cret = C.g_main_context_acquire(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AddPoll: if @context is currently blocking in g_main_context_iteration()
// waiting for a source to become ready, cause it to stop blocking and return.
// Otherwise, cause the next invocation of g_main_context_iteration() to return
// without blocking.
//
// This API is useful for low-level control over Context; for example,
// integrating it with main loop implementations such as Loop.
//
// Another related use for this function is when implementing a main loop with a
// termination condition, computed from multiple threads:
//
//      perform_work();
//
//      if (g_atomic_int_dec_and_test (&tasks_remaining))
//        g_main_context_wakeup (NULL);
func (c *MainContext) AddPoll(fd *PollFD, priority int) {
	var _arg0 *C.GMainContext // out
	var _arg1 *C.GPollFD      // out
	var _arg2 C.gint          // out

	_arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GPollFD)(unsafe.Pointer(fd.Native()))
	_arg2 = C.gint(priority)

	C.g_main_context_add_poll(_arg0, _arg1, _arg2)
}

// Check: if @context is currently blocking in g_main_context_iteration()
// waiting for a source to become ready, cause it to stop blocking and return.
// Otherwise, cause the next invocation of g_main_context_iteration() to return
// without blocking.
//
// This API is useful for low-level control over Context; for example,
// integrating it with main loop implementations such as Loop.
//
// Another related use for this function is when implementing a main loop with a
// termination condition, computed from multiple threads:
//
//      perform_work();
//
//      if (g_atomic_int_dec_and_test (&tasks_remaining))
//        g_main_context_wakeup (NULL);
func (c *MainContext) Check(maxPriority int, fds []PollFD) bool {
	var _arg0 *C.GMainContext // out
	var _arg1 C.gint          // out
	var _arg2 *C.GPollFD
	var _arg3 C.gint
	var _cret C.gboolean // in

	_arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))
	_arg1 = C.gint(maxPriority)
	_arg3 = C.gint(len(fds))
	_arg2 = (*C.GPollFD)(unsafe.Pointer(&fds[0]))

	_cret = C.g_main_context_check(_arg0, _arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Dispatch: if @context is currently blocking in g_main_context_iteration()
// waiting for a source to become ready, cause it to stop blocking and return.
// Otherwise, cause the next invocation of g_main_context_iteration() to return
// without blocking.
//
// This API is useful for low-level control over Context; for example,
// integrating it with main loop implementations such as Loop.
//
// Another related use for this function is when implementing a main loop with a
// termination condition, computed from multiple threads:
//
//      perform_work();
//
//      if (g_atomic_int_dec_and_test (&tasks_remaining))
//        g_main_context_wakeup (NULL);
func (c *MainContext) Dispatch() {
	var _arg0 *C.GMainContext // out

	_arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))

	C.g_main_context_dispatch(_arg0)
}

// FindSourceByID: if @context is currently blocking in
// g_main_context_iteration() waiting for a source to become ready, cause it to
// stop blocking and return. Otherwise, cause the next invocation of
// g_main_context_iteration() to return without blocking.
//
// This API is useful for low-level control over Context; for example,
// integrating it with main loop implementations such as Loop.
//
// Another related use for this function is when implementing a main loop with a
// termination condition, computed from multiple threads:
//
//      perform_work();
//
//      if (g_atomic_int_dec_and_test (&tasks_remaining))
//        g_main_context_wakeup (NULL);
func (c *MainContext) FindSourceByID(sourceId uint) *Source {
	var _arg0 *C.GMainContext // out
	var _arg1 C.guint         // out
	var _cret *C.GSource      // in

	_arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))
	_arg1 = C.guint(sourceId)

	_cret = C.g_main_context_find_source_by_id(_arg0, _arg1)

	var _source *Source // out

	_source = (*Source)(unsafe.Pointer(_cret))

	return _source
}

// IsOwner: if @context is currently blocking in g_main_context_iteration()
// waiting for a source to become ready, cause it to stop blocking and return.
// Otherwise, cause the next invocation of g_main_context_iteration() to return
// without blocking.
//
// This API is useful for low-level control over Context; for example,
// integrating it with main loop implementations such as Loop.
//
// Another related use for this function is when implementing a main loop with a
// termination condition, computed from multiple threads:
//
//      perform_work();
//
//      if (g_atomic_int_dec_and_test (&tasks_remaining))
//        g_main_context_wakeup (NULL);
func (c *MainContext) IsOwner() bool {
	var _arg0 *C.GMainContext // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))

	_cret = C.g_main_context_is_owner(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Iteration: if @context is currently blocking in g_main_context_iteration()
// waiting for a source to become ready, cause it to stop blocking and return.
// Otherwise, cause the next invocation of g_main_context_iteration() to return
// without blocking.
//
// This API is useful for low-level control over Context; for example,
// integrating it with main loop implementations such as Loop.
//
// Another related use for this function is when implementing a main loop with a
// termination condition, computed from multiple threads:
//
//      perform_work();
//
//      if (g_atomic_int_dec_and_test (&tasks_remaining))
//        g_main_context_wakeup (NULL);
func (c *MainContext) Iteration(mayBlock bool) bool {
	var _arg0 *C.GMainContext // out
	var _arg1 C.gboolean      // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))
	if mayBlock {
		_arg1 = C.TRUE
	}

	_cret = C.g_main_context_iteration(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Pending: if @context is currently blocking in g_main_context_iteration()
// waiting for a source to become ready, cause it to stop blocking and return.
// Otherwise, cause the next invocation of g_main_context_iteration() to return
// without blocking.
//
// This API is useful for low-level control over Context; for example,
// integrating it with main loop implementations such as Loop.
//
// Another related use for this function is when implementing a main loop with a
// termination condition, computed from multiple threads:
//
//      perform_work();
//
//      if (g_atomic_int_dec_and_test (&tasks_remaining))
//        g_main_context_wakeup (NULL);
func (c *MainContext) Pending() bool {
	var _arg0 *C.GMainContext // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))

	_cret = C.g_main_context_pending(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PopThreadDefault: if @context is currently blocking in
// g_main_context_iteration() waiting for a source to become ready, cause it to
// stop blocking and return. Otherwise, cause the next invocation of
// g_main_context_iteration() to return without blocking.
//
// This API is useful for low-level control over Context; for example,
// integrating it with main loop implementations such as Loop.
//
// Another related use for this function is when implementing a main loop with a
// termination condition, computed from multiple threads:
//
//      perform_work();
//
//      if (g_atomic_int_dec_and_test (&tasks_remaining))
//        g_main_context_wakeup (NULL);
func (c *MainContext) PopThreadDefault() {
	var _arg0 *C.GMainContext // out

	_arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))

	C.g_main_context_pop_thread_default(_arg0)
}

// Prepare: if @context is currently blocking in g_main_context_iteration()
// waiting for a source to become ready, cause it to stop blocking and return.
// Otherwise, cause the next invocation of g_main_context_iteration() to return
// without blocking.
//
// This API is useful for low-level control over Context; for example,
// integrating it with main loop implementations such as Loop.
//
// Another related use for this function is when implementing a main loop with a
// termination condition, computed from multiple threads:
//
//      perform_work();
//
//      if (g_atomic_int_dec_and_test (&tasks_remaining))
//        g_main_context_wakeup (NULL);
func (c *MainContext) Prepare() (int, bool) {
	var _arg0 *C.GMainContext // out
	var _arg1 C.gint          // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))

	_cret = C.g_main_context_prepare(_arg0, &_arg1)

	var _priority int // out
	var _ok bool      // out

	_priority = int(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _priority, _ok
}

// PushThreadDefault: if @context is currently blocking in
// g_main_context_iteration() waiting for a source to become ready, cause it to
// stop blocking and return. Otherwise, cause the next invocation of
// g_main_context_iteration() to return without blocking.
//
// This API is useful for low-level control over Context; for example,
// integrating it with main loop implementations such as Loop.
//
// Another related use for this function is when implementing a main loop with a
// termination condition, computed from multiple threads:
//
//      perform_work();
//
//      if (g_atomic_int_dec_and_test (&tasks_remaining))
//        g_main_context_wakeup (NULL);
func (c *MainContext) PushThreadDefault() {
	var _arg0 *C.GMainContext // out

	_arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))

	C.g_main_context_push_thread_default(_arg0)
}

// Ref: if @context is currently blocking in g_main_context_iteration() waiting
// for a source to become ready, cause it to stop blocking and return.
// Otherwise, cause the next invocation of g_main_context_iteration() to return
// without blocking.
//
// This API is useful for low-level control over Context; for example,
// integrating it with main loop implementations such as Loop.
//
// Another related use for this function is when implementing a main loop with a
// termination condition, computed from multiple threads:
//
//      perform_work();
//
//      if (g_atomic_int_dec_and_test (&tasks_remaining))
//        g_main_context_wakeup (NULL);
func (c *MainContext) Ref() *MainContext {
	var _arg0 *C.GMainContext // out
	var _cret *C.GMainContext // in

	_arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))

	_cret = C.g_main_context_ref(_arg0)

	var _mainContext *MainContext // out

	_mainContext = (*MainContext)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_mainContext, func(v **MainContext) {
		C.free(unsafe.Pointer(v))
	})

	return _mainContext
}

// Release: if @context is currently blocking in g_main_context_iteration()
// waiting for a source to become ready, cause it to stop blocking and return.
// Otherwise, cause the next invocation of g_main_context_iteration() to return
// without blocking.
//
// This API is useful for low-level control over Context; for example,
// integrating it with main loop implementations such as Loop.
//
// Another related use for this function is when implementing a main loop with a
// termination condition, computed from multiple threads:
//
//      perform_work();
//
//      if (g_atomic_int_dec_and_test (&tasks_remaining))
//        g_main_context_wakeup (NULL);
func (c *MainContext) Release() {
	var _arg0 *C.GMainContext // out

	_arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))

	C.g_main_context_release(_arg0)
}

// RemovePoll: if @context is currently blocking in g_main_context_iteration()
// waiting for a source to become ready, cause it to stop blocking and return.
// Otherwise, cause the next invocation of g_main_context_iteration() to return
// without blocking.
//
// This API is useful for low-level control over Context; for example,
// integrating it with main loop implementations such as Loop.
//
// Another related use for this function is when implementing a main loop with a
// termination condition, computed from multiple threads:
//
//      perform_work();
//
//      if (g_atomic_int_dec_and_test (&tasks_remaining))
//        g_main_context_wakeup (NULL);
func (c *MainContext) RemovePoll(fd *PollFD) {
	var _arg0 *C.GMainContext // out
	var _arg1 *C.GPollFD      // out

	_arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GPollFD)(unsafe.Pointer(fd.Native()))

	C.g_main_context_remove_poll(_arg0, _arg1)
}

// Unref: if @context is currently blocking in g_main_context_iteration()
// waiting for a source to become ready, cause it to stop blocking and return.
// Otherwise, cause the next invocation of g_main_context_iteration() to return
// without blocking.
//
// This API is useful for low-level control over Context; for example,
// integrating it with main loop implementations such as Loop.
//
// Another related use for this function is when implementing a main loop with a
// termination condition, computed from multiple threads:
//
//      perform_work();
//
//      if (g_atomic_int_dec_and_test (&tasks_remaining))
//        g_main_context_wakeup (NULL);
func (c *MainContext) Unref() {
	var _arg0 *C.GMainContext // out

	_arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))

	C.g_main_context_unref(_arg0)
}

// Wakeup: if @context is currently blocking in g_main_context_iteration()
// waiting for a source to become ready, cause it to stop blocking and return.
// Otherwise, cause the next invocation of g_main_context_iteration() to return
// without blocking.
//
// This API is useful for low-level control over Context; for example,
// integrating it with main loop implementations such as Loop.
//
// Another related use for this function is when implementing a main loop with a
// termination condition, computed from multiple threads:
//
//      perform_work();
//
//      if (g_atomic_int_dec_and_test (&tasks_remaining))
//        g_main_context_wakeup (NULL);
func (c *MainContext) Wakeup() {
	var _arg0 *C.GMainContext // out

	_arg0 = (*C.GMainContext)(unsafe.Pointer(c.Native()))

	C.g_main_context_wakeup(_arg0)
}

// MainLoop: the `GMainLoop` struct is an opaque data type representing the main
// event loop of a GLib or GTK+ application.
type MainLoop C.GMainLoop

// WrapMainLoop wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMainLoop(ptr unsafe.Pointer) *MainLoop {
	return (*MainLoop)(ptr)
}

func marshalMainLoop(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*MainLoop)(unsafe.Pointer(b)), nil
}

// NewMainLoop constructs a struct MainLoop.
func NewMainLoop(context *MainContext, isRunning bool) *MainLoop {
	var _arg1 *C.GMainContext // out
	var _arg2 C.gboolean      // out
	var _cret *C.GMainLoop    // in

	_arg1 = (*C.GMainContext)(unsafe.Pointer(context.Native()))
	if isRunning {
		_arg2 = C.TRUE
	}

	_cret = C.g_main_loop_new(_arg1, _arg2)

	var _mainLoop *MainLoop // out

	_mainLoop = (*MainLoop)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_mainLoop, func(v **MainLoop) {
		C.free(unsafe.Pointer(v))
	})

	return _mainLoop
}

// Native returns the underlying C source pointer.
func (m *MainLoop) Native() unsafe.Pointer {
	return unsafe.Pointer(m)
}

// Context decreases the reference count on a Loop object by one. If the result
// is zero, free the loop and free all associated memory.
func (l *MainLoop) Context() *MainContext {
	var _arg0 *C.GMainLoop    // out
	var _cret *C.GMainContext // in

	_arg0 = (*C.GMainLoop)(unsafe.Pointer(l.Native()))

	_cret = C.g_main_loop_get_context(_arg0)

	var _mainContext *MainContext // out

	_mainContext = (*MainContext)(unsafe.Pointer(_cret))

	return _mainContext
}

// IsRunning decreases the reference count on a Loop object by one. If the
// result is zero, free the loop and free all associated memory.
func (l *MainLoop) IsRunning() bool {
	var _arg0 *C.GMainLoop // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GMainLoop)(unsafe.Pointer(l.Native()))

	_cret = C.g_main_loop_is_running(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Quit decreases the reference count on a Loop object by one. If the result is
// zero, free the loop and free all associated memory.
func (l *MainLoop) Quit() {
	var _arg0 *C.GMainLoop // out

	_arg0 = (*C.GMainLoop)(unsafe.Pointer(l.Native()))

	C.g_main_loop_quit(_arg0)
}

// Ref decreases the reference count on a Loop object by one. If the result is
// zero, free the loop and free all associated memory.
func (l *MainLoop) Ref() *MainLoop {
	var _arg0 *C.GMainLoop // out
	var _cret *C.GMainLoop // in

	_arg0 = (*C.GMainLoop)(unsafe.Pointer(l.Native()))

	_cret = C.g_main_loop_ref(_arg0)

	var _mainLoop *MainLoop // out

	_mainLoop = (*MainLoop)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_mainLoop, func(v **MainLoop) {
		C.free(unsafe.Pointer(v))
	})

	return _mainLoop
}

// Run decreases the reference count on a Loop object by one. If the result is
// zero, free the loop and free all associated memory.
func (l *MainLoop) Run() {
	var _arg0 *C.GMainLoop // out

	_arg0 = (*C.GMainLoop)(unsafe.Pointer(l.Native()))

	C.g_main_loop_run(_arg0)
}

// Unref decreases the reference count on a Loop object by one. If the result is
// zero, free the loop and free all associated memory.
func (l *MainLoop) Unref() {
	var _arg0 *C.GMainLoop // out

	_arg0 = (*C.GMainLoop)(unsafe.Pointer(l.Native()))

	C.g_main_loop_unref(_arg0)
}
