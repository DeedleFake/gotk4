// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <glib.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_variant_builder_get_type()), F: marshalVariantBuilder},
		{T: externglib.Type(C.g_variant_dict_get_type()), F: marshalVariantDict},
	})
}

// VariantClass: the range of possible top-level types of #GVariant instances.
type VariantClass int

const (
	// boolean: the #GVariant is a boolean.
	VariantClassBoolean VariantClass = 98
	// byte: the #GVariant is a byte.
	VariantClassByte VariantClass = 121
	// int16: the #GVariant is a signed 16 bit integer.
	VariantClassInt16 VariantClass = 110
	// uint16: the #GVariant is an unsigned 16 bit integer.
	VariantClassUint16 VariantClass = 113
	// int32: the #GVariant is a signed 32 bit integer.
	VariantClassInt32 VariantClass = 105
	// uint32: the #GVariant is an unsigned 32 bit integer.
	VariantClassUint32 VariantClass = 117
	// int64: the #GVariant is a signed 64 bit integer.
	VariantClassInt64 VariantClass = 120
	// uint64: the #GVariant is an unsigned 64 bit integer.
	VariantClassUint64 VariantClass = 116
	// handle: the #GVariant is a file handle index.
	VariantClassHandle VariantClass = 104
	// double: the #GVariant is a double precision floating point value.
	VariantClassDouble VariantClass = 100
	// string: the #GVariant is a normal string.
	VariantClassString VariantClass = 115
	// ObjectPath: the #GVariant is a D-Bus object path string.
	VariantClassObjectPath VariantClass = 111
	// signature: the #GVariant is a D-Bus signature string.
	VariantClassSignature VariantClass = 103
	// variant: the #GVariant is a variant.
	VariantClassVariant VariantClass = 118
	// maybe: the #GVariant is a maybe-typed value.
	VariantClassMaybe VariantClass = 109
	// array: the #GVariant is an array.
	VariantClassArray VariantClass = 97
	// tuple: the #GVariant is a tuple.
	VariantClassTuple VariantClass = 40
	// DictEntry: the #GVariant is a dictionary entry.
	VariantClassDictEntry VariantClass = 123
)

// VariantParseError: error codes returned by parsing text-format GVariants.
type VariantParseError int

const (
	// failed: generic error (unused)
	VariantParseErrorFailed VariantParseError = 0
	// BasicTypeExpected: a non-basic Type was given where a basic type was
	// expected
	VariantParseErrorBasicTypeExpected VariantParseError = 1
	// CannotInferType: cannot infer the Type
	VariantParseErrorCannotInferType VariantParseError = 2
	// DefiniteTypeExpected: an indefinite Type was given where a definite type
	// was expected
	VariantParseErrorDefiniteTypeExpected VariantParseError = 3
	// InputNotAtEnd: extra data after parsing finished
	VariantParseErrorInputNotAtEnd VariantParseError = 4
	// InvalidCharacter: invalid character in number or unicode escape
	VariantParseErrorInvalidCharacter VariantParseError = 5
	// InvalidFormatString: not a valid #GVariant format string
	VariantParseErrorInvalidFormatString VariantParseError = 6
	// InvalidObjectPath: not a valid object path
	VariantParseErrorInvalidObjectPath VariantParseError = 7
	// InvalidSignature: not a valid type signature
	VariantParseErrorInvalidSignature VariantParseError = 8
	// InvalidTypeString: not a valid #GVariant type string
	VariantParseErrorInvalidTypeString VariantParseError = 9
	// NoCommonType: could not find a common type for array entries
	VariantParseErrorNoCommonType VariantParseError = 10
	// NumberOutOfRange: the numerical value is out of range of the given type
	VariantParseErrorNumberOutOfRange VariantParseError = 11
	// NumberTooBig: the numerical value is out of range for any type
	VariantParseErrorNumberTooBig VariantParseError = 12
	// TypeError: cannot parse as variant of the specified type
	VariantParseErrorTypeError VariantParseError = 13
	// UnexpectedToken: an unexpected token was encountered
	VariantParseErrorUnexpectedToken VariantParseError = 14
	// UnknownKeyword: an unknown keyword was encountered
	VariantParseErrorUnknownKeyword VariantParseError = 15
	// UnterminatedStringConstant: unterminated string constant
	VariantParseErrorUnterminatedStringConstant VariantParseError = 16
	// ValueExpected: no value given
	VariantParseErrorValueExpected VariantParseError = 17
	// recursion: variant was too deeply nested; #GVariant is only guaranteed to
	// handle nesting up to 64 levels (Since: 2.64)
	VariantParseErrorRecursion VariantParseError = 18
)

// Variant is a variant datatype; it can contain one or more values along with
// information about the type of the values.
//
// A #GVariant may contain simple types, like an integer, or a boolean value; or
// complex types, like an array of two strings, or a dictionary of key value
// pairs. A #GVariant is also immutable: once it's been created neither its type
// nor its content can be modified further.
//
// GVariant is useful whenever data needs to be serialized, for example when
// sending method parameters in D-Bus, or when saving settings using GSettings.
//
// When creating a new #GVariant, you pass the data you want to store in it
// along with a string representing the type of data you wish to pass to it.
//
// For instance, if you want to create a #GVariant holding an integer value you
// can use:
//
//    GVariant *v = g_variant_new ("u", 40);
//
// The string "u" in the first argument tells #GVariant that the data passed to
// the constructor (40) is going to be an unsigned integer.
//
// More advanced examples of #GVariant in use can be found in documentation for
// [GVariant format strings][gvariant-format-strings-pointers].
//
// The range of possible values is determined by the type.
//
// The type system used by #GVariant is Type.
//
// #GVariant instances always have a type and a value (which are given at
// construction time). The type and value of a #GVariant instance can never
// change other than by the #GVariant itself being destroyed. A #GVariant cannot
// contain a pointer.
//
// #GVariant is reference counted using g_variant_ref() and g_variant_unref().
// #GVariant also has floating reference counts -- see g_variant_ref_sink().
//
// #GVariant is completely threadsafe. A #GVariant instance can be concurrently
// accessed in any way from any number of threads without problems.
//
// #GVariant is heavily optimised for dealing with data in serialised form. It
// works particularly well with data located in memory-mapped files. It can
// perform nearly all deserialisation operations in a small constant time,
// usually touching only a single memory page. Serialised #GVariant data can
// also be sent over the network.
//
// #GVariant is largely compatible with D-Bus. Almost all types of #GVariant
// instances can be sent over D-Bus. See Type for exceptions. (However,
// #GVariant's serialisation format is not the same as the serialisation format
// of a D-Bus message body: use BusMessage, in the gio library, for those.)
//
// For space-efficiency, the #GVariant serialisation format does not
// automatically include the variant's length, type or endianness, which must
// either be implied from context (such as knowledge that a particular file
// format always contains a little-endian G_VARIANT_TYPE_VARIANT which occupies
// the whole length of the file) or supplied out-of-band (for instance, a
// length, type and/or endianness indicator could be placed at the beginning of
// a file, network message or network stream).
//
// A #GVariant's size is limited mainly by any lower level operating system
// constraints, such as the number of bits in #gsize. For example, it is
// reasonable to have a 2GB file mapped into memory with File, and call
// g_variant_new_from_data() on it.
//
// For convenience to C programmers, #GVariant features powerful varargs-based
// value construction and destruction. This feature is designed to be embedded
// in other libraries.
//
// There is a Python-inspired text language for describing #GVariant values.
// #GVariant includes a printer for this language and a parser with type
// inferencing.
//
//
// Memory Use
//
// #GVariant tries to be quite efficient with respect to memory use. This
// section gives a rough idea of how much memory is used by the current
// implementation. The information here is subject to change in the future.
//
// The memory allocated by #GVariant can be grouped into 4 broad purposes:
// memory for serialised data, memory for the type information cache, buffer
// management memory and memory for the #GVariant structure itself.
//
//
// Serialised Data Memory
//
// This is the memory that is used for storing GVariant data in serialised form.
// This is what would be sent over the network or what would end up on disk, not
// counting any indicator of the endianness, or of the length or type of the
// top-level variant.
//
// The amount of memory required to store a boolean is 1 byte. 16, 32 and 64 bit
// integers and double precision floating point numbers use their "natural"
// size. Strings (including object path and signature strings) are stored with a
// nul terminator, and as such use the length of the string plus 1 byte.
//
// Maybe types use no space at all to represent the null value and use the same
// amount of space (sometimes plus one byte) as the equivalent non-maybe-typed
// value to represent the non-null case.
//
// Arrays use the amount of space required to store each of their members,
// concatenated. Additionally, if the items stored in an array are not of a
// fixed-size (ie: strings, other arrays, etc) then an additional framing offset
// is stored for each item. The size of this offset is either 1, 2 or 4 bytes
// depending on the overall size of the container. Additionally, extra padding
// bytes are added as required for alignment of child values.
//
// Tuples (including dictionary entries) use the amount of space required to
// store each of their members, concatenated, plus one framing offset (as per
// arrays) for each non-fixed-sized item in the tuple, except for the last one.
// Additionally, extra padding bytes are added as required for alignment of
// child values.
//
// Variants use the same amount of space as the item inside of the variant, plus
// 1 byte, plus the length of the type string for the item inside the variant.
//
// As an example, consider a dictionary mapping strings to variants. In the case
// that the dictionary is empty, 0 bytes are required for the serialisation.
//
// If we add an item "width" that maps to the int32 value of 500 then we will
// use 4 byte to store the int32 (so 6 for the variant containing it) and 6
// bytes for the string. The variant must be aligned to 8 after the 6 bytes of
// the string, so that's 2 extra bytes. 6 (string) + 2 (padding) + 6 (variant)
// is 14 bytes used for the dictionary entry. An additional 1 byte is added to
// the array as a framing offset making a total of 15 bytes.
//
// If we add another entry, "title" that maps to a nullable string that happens
// to have a value of null, then we use 0 bytes for the null value (and 3 bytes
// for the variant to contain it along with its type string) plus 6 bytes for
// the string. Again, we need 2 padding bytes. That makes a total of 6 + 2 + 3 =
// 11 bytes.
//
// We now require extra padding between the two items in the array. After the 14
// bytes of the first item, that's 2 bytes required. We now require 2 framing
// offsets for an extra two bytes. 14 + 2 + 11 + 2 = 29 bytes to encode the
// entire two-item dictionary.
//
//
// Type Information Cache
//
// For each GVariant type that currently exists in the program a type
// information structure is kept in the type information cache. The type
// information structure is required for rapid deserialisation.
//
// Continuing with the above example, if a #GVariant exists with the type
// "a{sv}" then a type information struct will exist for "a{sv}", "{sv}", "s",
// and "v". Multiple uses of the same type will share the same type information.
// Additionally, all single-digit types are stored in read-only static memory
// and do not contribute to the writable memory footprint of a program using
// #GVariant.
//
// Aside from the type information structures stored in read-only memory, there
// are two forms of type information. One is used for container types where
// there is a single element type: arrays and maybe types. The other is used for
// container types where there are multiple element types: tuples and dictionary
// entries.
//
// Array type info structures are 6 * sizeof (void *), plus the memory required
// to store the type string itself. This means that on 32-bit systems, the cache
// entry for "a{sv}" would require 30 bytes of memory (plus malloc overhead).
//
// Tuple type info structures are 6 * sizeof (void *), plus 4 * sizeof (void *)
// for each item in the tuple, plus the memory required to store the type string
// itself. A 2-item tuple, for example, would have a type information structure
// that consumed writable memory in the size of 14 * sizeof (void *) (plus type
// string) This means that on 32-bit systems, the cache entry for "{sv}" would
// require 61 bytes of memory (plus malloc overhead).
//
// This means that in total, for our "a{sv}" example, 91 bytes of type
// information would be allocated.
//
// The type information cache, additionally, uses a Table to store and look up
// the cached items and stores a pointer to this hash table in static storage.
// The hash table is freed when there are zero items in the type cache.
//
// Although these sizes may seem large it is important to remember that a
// program will probably only have a very small number of different types of
// values in it and that only one type information structure is required for
// many different values of the same type.
//
//
// Buffer Management Memory
//
// #GVariant uses an internal buffer management structure to deal with the
// various different possible sources of serialised data that it uses. The
// buffer is responsible for ensuring that the correct call is made when the
// data is no longer in use by #GVariant. This may involve a g_free() or a
// g_slice_free() or even g_mapped_file_unref().
//
// One buffer management structure is used for each chunk of serialised data.
// The size of the buffer management structure is 4 * (void *). On 32-bit
// systems, that's 16 bytes.
//
//
// GVariant structure
//
// The size of a #GVariant structure is 6 * (void *). On 32-bit systems, that's
// 24 bytes.
//
// #GVariant structures only exist if they are explicitly created with API
// calls. For example, if a #GVariant is constructed out of serialised data for
// the example given above (with the dictionary) then although there are 9
// individual values that comprise the entire dictionary (two keys, two values,
// two variants containing the values, two dictionary entries, plus the
// dictionary itself), only 1 #GVariant instance exists -- the one referring to
// the dictionary.
//
// If calls are made to start accessing the other values then #GVariant
// instances will exist for those values only for as long as they are in use
// (ie: until you call g_variant_unref()). The type information is shared. The
// serialised data and the buffer management structure for that serialised data
// is shared by the child.
//
//
// Summary
//
// To put the entire example together, for our dictionary mapping strings to
// variants (with two entries, as given above), we are using 91 bytes of memory
// for type information, 29 bytes of memory for the serialised data, 16 bytes
// for buffer management and 24 bytes for the #GVariant instance, or a total of
// 160 bytes, plus malloc overhead. If we were to use
// g_variant_get_child_value() to access the two dictionary entries, we would
// use an additional 48 bytes. If we were to have other dictionaries of the same
// type, we would use more memory for the serialised data and buffer management
// for those dictionaries, but the type information would be shared.
type Variant C.GVariant

// WrapVariant wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapVariant(ptr unsafe.Pointer) *Variant {
	return (*Variant)(ptr)
}

func marshalVariant(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*Variant)(unsafe.Pointer(b)), nil
}

// NewVariantArray constructs a struct Variant.
func NewVariantArray(childType *VariantType, children []*Variant) *Variant {
	var _arg1 *C.GVariantType // out
	var _arg2 **C.GVariant
	var _arg3 C.gsize
	var _cret *C.GVariant // in

	_arg1 = (*C.GVariantType)(unsafe.Pointer(childType.Native()))
	_arg3 = C.gsize(len(children))
	_arg2 = (**C.GVariant)(unsafe.Pointer(&children[0]))

	_cret = C.g_variant_new_array(_arg1, _arg2, _arg3)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantBoolean constructs a struct Variant.
func NewVariantBoolean(value bool) *Variant {
	var _arg1 C.gboolean  // out
	var _cret *C.GVariant // in

	if value {
		_arg1 = C.TRUE
	}

	_cret = C.g_variant_new_boolean(_arg1)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantByte constructs a struct Variant.
func NewVariantByte(value byte) *Variant {
	var _arg1 C.guint8    // out
	var _cret *C.GVariant // in

	_arg1 = C.guint8(value)

	_cret = C.g_variant_new_byte(_arg1)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantBytestring constructs a struct Variant.
func NewVariantBytestring(_string []byte) *Variant {
	var _arg1 *C.gchar
	var _cret *C.GVariant // in

	_arg1 = (*C.gchar)(unsafe.Pointer(&_string[0]))

	_cret = C.g_variant_new_bytestring(_arg1)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantBytestringArray constructs a struct Variant.
func NewVariantBytestringArray(strv []string) *Variant {
	var _arg1 **C.gchar
	var _arg2 C.gssize
	var _cret *C.GVariant // in

	_arg2 = C.gssize(len(strv))
	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(strv)) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(strv))
		for i := range strv {
			out[i] = (*C.gchar)(C.CString(strv[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.g_variant_new_bytestring_array(_arg1, _arg2)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantDictEntry constructs a struct Variant.
func NewVariantDictEntry(key *Variant, value *Variant) *Variant {
	var _arg1 *C.GVariant // out
	var _arg2 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg1 = (*C.GVariant)(unsafe.Pointer(key.Native()))
	_arg2 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	_cret = C.g_variant_new_dict_entry(_arg1, _arg2)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantDouble constructs a struct Variant.
func NewVariantDouble(value float64) *Variant {
	var _arg1 C.gdouble   // out
	var _cret *C.GVariant // in

	_arg1 = C.gdouble(value)

	_cret = C.g_variant_new_double(_arg1)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantFixedArray constructs a struct Variant.
func NewVariantFixedArray(elementType *VariantType, elements interface{}, nElements uint, elementSize uint) *Variant {
	var _arg1 *C.GVariantType // out
	var _arg2 C.gconstpointer // out
	var _arg3 C.gsize         // out
	var _arg4 C.gsize         // out
	var _cret *C.GVariant     // in

	_arg1 = (*C.GVariantType)(unsafe.Pointer(elementType.Native()))
	_arg2 = C.gconstpointer(box.Assign(unsafe.Pointer(elements)))
	_arg3 = C.gsize(nElements)
	_arg4 = C.gsize(elementSize)

	_cret = C.g_variant_new_fixed_array(_arg1, _arg2, _arg3, _arg4)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantHandle constructs a struct Variant.
func NewVariantHandle(value int32) *Variant {
	var _arg1 C.gint32    // out
	var _cret *C.GVariant // in

	_arg1 = C.gint32(value)

	_cret = C.g_variant_new_handle(_arg1)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantInt16 constructs a struct Variant.
func NewVariantInt16(value int16) *Variant {
	var _arg1 C.gint16    // out
	var _cret *C.GVariant // in

	_arg1 = C.gint16(value)

	_cret = C.g_variant_new_int16(_arg1)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantInt32 constructs a struct Variant.
func NewVariantInt32(value int32) *Variant {
	var _arg1 C.gint32    // out
	var _cret *C.GVariant // in

	_arg1 = C.gint32(value)

	_cret = C.g_variant_new_int32(_arg1)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantInt64 constructs a struct Variant.
func NewVariantInt64(value int64) *Variant {
	var _arg1 C.gint64    // out
	var _cret *C.GVariant // in

	_arg1 = C.gint64(value)

	_cret = C.g_variant_new_int64(_arg1)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantMaybe constructs a struct Variant.
func NewVariantMaybe(childType *VariantType, child *Variant) *Variant {
	var _arg1 *C.GVariantType // out
	var _arg2 *C.GVariant     // out
	var _cret *C.GVariant     // in

	_arg1 = (*C.GVariantType)(unsafe.Pointer(childType.Native()))
	_arg2 = (*C.GVariant)(unsafe.Pointer(child.Native()))

	_cret = C.g_variant_new_maybe(_arg1, _arg2)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantObjectPath constructs a struct Variant.
func NewVariantObjectPath(objectPath string) *Variant {
	var _arg1 *C.gchar    // out
	var _cret *C.GVariant // in

	_arg1 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_variant_new_object_path(_arg1)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantObjv constructs a struct Variant.
func NewVariantObjv(strv []string) *Variant {
	var _arg1 **C.gchar
	var _arg2 C.gssize
	var _cret *C.GVariant // in

	_arg2 = C.gssize(len(strv))
	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(strv)) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(strv))
		for i := range strv {
			out[i] = (*C.gchar)(C.CString(strv[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.g_variant_new_objv(_arg1, _arg2)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantSignature constructs a struct Variant.
func NewVariantSignature(signature string) *Variant {
	var _arg1 *C.gchar    // out
	var _cret *C.GVariant // in

	_arg1 = (*C.gchar)(C.CString(signature))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_variant_new_signature(_arg1)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantString constructs a struct Variant.
func NewVariantString(_string string) *Variant {
	var _arg1 *C.gchar    // out
	var _cret *C.GVariant // in

	_arg1 = (*C.gchar)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_variant_new_string(_arg1)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantStrv constructs a struct Variant.
func NewVariantStrv(strv []string) *Variant {
	var _arg1 **C.gchar
	var _arg2 C.gssize
	var _cret *C.GVariant // in

	_arg2 = C.gssize(len(strv))
	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(strv)) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(strv))
		for i := range strv {
			out[i] = (*C.gchar)(C.CString(strv[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.g_variant_new_strv(_arg1, _arg2)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantTuple constructs a struct Variant.
func NewVariantTuple(children []*Variant) *Variant {
	var _arg1 **C.GVariant
	var _arg2 C.gsize
	var _cret *C.GVariant // in

	_arg2 = C.gsize(len(children))
	_arg1 = (**C.GVariant)(unsafe.Pointer(&children[0]))

	_cret = C.g_variant_new_tuple(_arg1, _arg2)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantUint16 constructs a struct Variant.
func NewVariantUint16(value uint16) *Variant {
	var _arg1 C.guint16   // out
	var _cret *C.GVariant // in

	_arg1 = C.guint16(value)

	_cret = C.g_variant_new_uint16(_arg1)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantUint32 constructs a struct Variant.
func NewVariantUint32(value uint32) *Variant {
	var _arg1 C.guint32   // out
	var _cret *C.GVariant // in

	_arg1 = C.guint32(value)

	_cret = C.g_variant_new_uint32(_arg1)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantUint64 constructs a struct Variant.
func NewVariantUint64(value uint64) *Variant {
	var _arg1 C.guint64   // out
	var _cret *C.GVariant // in

	_arg1 = C.guint64(value)

	_cret = C.g_variant_new_uint64(_arg1)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantVariant constructs a struct Variant.
func NewVariantVariant(value *Variant) *Variant {
	var _arg1 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg1 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	_cret = C.g_variant_new_variant(_arg1)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))

	return _variant
}

// Native returns the underlying C source pointer.
func (v *Variant) Native() unsafe.Pointer {
	return unsafe.Pointer(v)
}

// Byteswap decreases the reference count of @value. When its reference count
// drops to 0, the memory used by the variant is freed.
func (v *Variant) Byteswap() *Variant {
	var _arg0 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_byteswap(_arg0)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_variant, func(v **Variant) {
		C.free(unsafe.Pointer(v))
	})

	return _variant
}

// CheckFormatString decreases the reference count of @value. When its reference
// count drops to 0, the memory used by the variant is freed.
func (v *Variant) CheckFormatString(formatString string, copyOnly bool) bool {
	var _arg0 *C.GVariant // out
	var _arg1 *C.gchar    // out
	var _arg2 C.gboolean  // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.gchar)(C.CString(formatString))
	defer C.free(unsafe.Pointer(_arg1))
	if copyOnly {
		_arg2 = C.TRUE
	}

	_cret = C.g_variant_check_format_string(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Classify decreases the reference count of @value. When its reference count
// drops to 0, the memory used by the variant is freed.
func (v *Variant) Classify() VariantClass {
	var _arg0 *C.GVariant     // out
	var _cret C.GVariantClass // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_classify(_arg0)

	var _variantClass VariantClass // out

	_variantClass = VariantClass(_cret)

	return _variantClass
}

// Compare decreases the reference count of @value. When its reference count
// drops to 0, the memory used by the variant is freed.
func (v *Variant) Compare(two *Variant) int {
	var _arg0 C.gconstpointer // out
	var _arg1 C.gconstpointer // out
	var _cret C.gint          // in

	_arg0 = (C.gconstpointer)(unsafe.Pointer(o.Native()))
	_arg1 = (C.gconstpointer)(unsafe.Pointer(two.Native()))

	_cret = C.g_variant_compare(_arg0, _arg1)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// DupString decreases the reference count of @value. When its reference count
// drops to 0, the memory used by the variant is freed.
func (v *Variant) DupString() (uint, string) {
	var _arg0 *C.GVariant // out
	var _arg1 C.gsize     // in
	var _cret *C.gchar    // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_dup_string(_arg0, &_arg1)

	var _length uint // out
	var _utf8 string // out

	_length = uint(_arg1)
	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _length, _utf8
}

// Equal decreases the reference count of @value. When its reference count drops
// to 0, the memory used by the variant is freed.
func (v *Variant) Equal(two *Variant) bool {
	var _arg0 C.gconstpointer // out
	var _arg1 C.gconstpointer // out
	var _cret C.gboolean      // in

	_arg0 = (C.gconstpointer)(unsafe.Pointer(o.Native()))
	_arg1 = (C.gconstpointer)(unsafe.Pointer(two.Native()))

	_cret = C.g_variant_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Boolean decreases the reference count of @value. When its reference count
// drops to 0, the memory used by the variant is freed.
func (v *Variant) Boolean() bool {
	var _arg0 *C.GVariant // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_get_boolean(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Byte decreases the reference count of @value. When its reference count drops
// to 0, the memory used by the variant is freed.
func (v *Variant) Byte() byte {
	var _arg0 *C.GVariant // out
	var _cret C.guint8    // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_get_byte(_arg0)

	var _guint8 byte // out

	_guint8 = byte(_cret)

	return _guint8
}

// Bytestring decreases the reference count of @value. When its reference count
// drops to 0, the memory used by the variant is freed.
func (v *Variant) Bytestring() []byte {
	var _arg0 *C.GVariant // out
	var _cret *C.gchar

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_get_bytestring(_arg0)

	var _guint8s []byte

	{
		var i int
		var z C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_guint8s = make([]byte, i)
		for i := range src {
			_guint8s[i] = byte(src[i])
		}
	}

	return _guint8s
}

// ChildValue decreases the reference count of @value. When its reference count
// drops to 0, the memory used by the variant is freed.
func (v *Variant) ChildValue(index_ uint) *Variant {
	var _arg0 *C.GVariant // out
	var _arg1 C.gsize     // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))
	_arg1 = C.gsize(index_)

	_cret = C.g_variant_get_child_value(_arg0, _arg1)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_variant, func(v **Variant) {
		C.free(unsafe.Pointer(v))
	})

	return _variant
}

// Data decreases the reference count of @value. When its reference count drops
// to 0, the memory used by the variant is freed.
func (v *Variant) Data() interface{} {
	var _arg0 *C.GVariant     // out
	var _cret C.gconstpointer // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_get_data(_arg0)

	var _gpointer interface{} // out

	_gpointer = box.Get(uintptr(_cret))

	return _gpointer
}

// Double decreases the reference count of @value. When its reference count
// drops to 0, the memory used by the variant is freed.
func (v *Variant) Double() float64 {
	var _arg0 *C.GVariant // out
	var _cret C.gdouble   // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_get_double(_arg0)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Handle decreases the reference count of @value. When its reference count
// drops to 0, the memory used by the variant is freed.
func (v *Variant) Handle() int32 {
	var _arg0 *C.GVariant // out
	var _cret C.gint32    // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_get_handle(_arg0)

	var _gint32 int32 // out

	_gint32 = int32(_cret)

	return _gint32
}

// Int16 decreases the reference count of @value. When its reference count drops
// to 0, the memory used by the variant is freed.
func (v *Variant) Int16() int16 {
	var _arg0 *C.GVariant // out
	var _cret C.gint16    // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_get_int16(_arg0)

	var _gint16 int16 // out

	_gint16 = int16(_cret)

	return _gint16
}

// Int32 decreases the reference count of @value. When its reference count drops
// to 0, the memory used by the variant is freed.
func (v *Variant) Int32() int32 {
	var _arg0 *C.GVariant // out
	var _cret C.gint32    // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_get_int32(_arg0)

	var _gint32 int32 // out

	_gint32 = int32(_cret)

	return _gint32
}

// Int64 decreases the reference count of @value. When its reference count drops
// to 0, the memory used by the variant is freed.
func (v *Variant) Int64() int64 {
	var _arg0 *C.GVariant // out
	var _cret C.gint64    // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_get_int64(_arg0)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// Maybe decreases the reference count of @value. When its reference count drops
// to 0, the memory used by the variant is freed.
func (v *Variant) Maybe() *Variant {
	var _arg0 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_get_maybe(_arg0)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_variant, func(v **Variant) {
		C.free(unsafe.Pointer(v))
	})

	return _variant
}

// NormalForm decreases the reference count of @value. When its reference count
// drops to 0, the memory used by the variant is freed.
func (v *Variant) NormalForm() *Variant {
	var _arg0 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_get_normal_form(_arg0)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_variant, func(v **Variant) {
		C.free(unsafe.Pointer(v))
	})

	return _variant
}

// Size decreases the reference count of @value. When its reference count drops
// to 0, the memory used by the variant is freed.
func (v *Variant) Size() uint {
	var _arg0 *C.GVariant // out
	var _cret C.gsize     // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_get_size(_arg0)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// String decreases the reference count of @value. When its reference count
// drops to 0, the memory used by the variant is freed.
func (v *Variant) String() (uint, string) {
	var _arg0 *C.GVariant // out
	var _arg1 C.gsize     // in
	var _cret *C.gchar    // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_get_string(_arg0, &_arg1)

	var _length uint // out
	var _utf8 string // out

	_length = uint(_arg1)
	_utf8 = C.GoString(_cret)

	return _length, _utf8
}

// Type decreases the reference count of @value. When its reference count drops
// to 0, the memory used by the variant is freed.
func (v *Variant) Type() *VariantType {
	var _arg0 *C.GVariant     // out
	var _cret *C.GVariantType // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_get_type(_arg0)

	var _variantType *VariantType // out

	_variantType = (*VariantType)(unsafe.Pointer(_cret))

	return _variantType
}

// TypeString decreases the reference count of @value. When its reference count
// drops to 0, the memory used by the variant is freed.
func (v *Variant) TypeString() string {
	var _arg0 *C.GVariant // out
	var _cret *C.gchar    // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_get_type_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Uint16 decreases the reference count of @value. When its reference count
// drops to 0, the memory used by the variant is freed.
func (v *Variant) Uint16() uint16 {
	var _arg0 *C.GVariant // out
	var _cret C.guint16   // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_get_uint16(_arg0)

	var _guint16 uint16 // out

	_guint16 = uint16(_cret)

	return _guint16
}

// Uint32 decreases the reference count of @value. When its reference count
// drops to 0, the memory used by the variant is freed.
func (v *Variant) Uint32() uint32 {
	var _arg0 *C.GVariant // out
	var _cret C.guint32   // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_get_uint32(_arg0)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// Uint64 decreases the reference count of @value. When its reference count
// drops to 0, the memory used by the variant is freed.
func (v *Variant) Uint64() uint64 {
	var _arg0 *C.GVariant // out
	var _cret C.guint64   // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_get_uint64(_arg0)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// Variant decreases the reference count of @value. When its reference count
// drops to 0, the memory used by the variant is freed.
func (v *Variant) Variant() *Variant {
	var _arg0 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_get_variant(_arg0)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_variant, func(v **Variant) {
		C.free(unsafe.Pointer(v))
	})

	return _variant
}

// Hash decreases the reference count of @value. When its reference count drops
// to 0, the memory used by the variant is freed.
func (v *Variant) Hash() uint {
	var _arg0 C.gconstpointer // out
	var _cret C.guint         // in

	_arg0 = (C.gconstpointer)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_hash(_arg0)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// IsContainer decreases the reference count of @value. When its reference count
// drops to 0, the memory used by the variant is freed.
func (v *Variant) IsContainer() bool {
	var _arg0 *C.GVariant // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_is_container(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsFloating decreases the reference count of @value. When its reference count
// drops to 0, the memory used by the variant is freed.
func (v *Variant) IsFloating() bool {
	var _arg0 *C.GVariant // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_is_floating(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsNormalForm decreases the reference count of @value. When its reference
// count drops to 0, the memory used by the variant is freed.
func (v *Variant) IsNormalForm() bool {
	var _arg0 *C.GVariant // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_is_normal_form(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsOfType decreases the reference count of @value. When its reference count
// drops to 0, the memory used by the variant is freed.
func (v *Variant) IsOfType(typ *VariantType) bool {
	var _arg0 *C.GVariant     // out
	var _arg1 *C.GVariantType // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.GVariantType)(unsafe.Pointer(typ.Native()))

	_cret = C.g_variant_is_of_type(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LookupValue decreases the reference count of @value. When its reference count
// drops to 0, the memory used by the variant is freed.
func (v *Variant) LookupValue(key string, expectedType *VariantType) *Variant {
	var _arg0 *C.GVariant     // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GVariantType // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariantType)(unsafe.Pointer(expectedType.Native()))

	_cret = C.g_variant_lookup_value(_arg0, _arg1, _arg2)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_variant, func(v **Variant) {
		C.free(unsafe.Pointer(v))
	})

	return _variant
}

// NChildren decreases the reference count of @value. When its reference count
// drops to 0, the memory used by the variant is freed.
func (v *Variant) NChildren() uint {
	var _arg0 *C.GVariant // out
	var _cret C.gsize     // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_n_children(_arg0)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Print decreases the reference count of @value. When its reference count drops
// to 0, the memory used by the variant is freed.
func (v *Variant) Print(typeAnnotate bool) string {
	var _arg0 *C.GVariant // out
	var _arg1 C.gboolean  // out
	var _cret *C.gchar    // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))
	if typeAnnotate {
		_arg1 = C.TRUE
	}

	_cret = C.g_variant_print(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Ref decreases the reference count of @value. When its reference count drops
// to 0, the memory used by the variant is freed.
func (v *Variant) Ref() *Variant {
	var _arg0 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_ref(_arg0)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_variant, func(v **Variant) {
		C.free(unsafe.Pointer(v))
	})

	return _variant
}

// RefSink decreases the reference count of @value. When its reference count
// drops to 0, the memory used by the variant is freed.
func (v *Variant) RefSink() *Variant {
	var _arg0 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_ref_sink(_arg0)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_variant, func(v **Variant) {
		C.free(unsafe.Pointer(v))
	})

	return _variant
}

// Store decreases the reference count of @value. When its reference count drops
// to 0, the memory used by the variant is freed.
func (v *Variant) Store(data interface{}) {
	var _arg0 *C.GVariant // out
	var _arg1 C.gpointer  // out

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))
	_arg1 = C.gpointer(box.Assign(unsafe.Pointer(data)))

	C.g_variant_store(_arg0, _arg1)
}

// TakeRef decreases the reference count of @value. When its reference count
// drops to 0, the memory used by the variant is freed.
func (v *Variant) TakeRef() *Variant {
	var _arg0 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	_cret = C.g_variant_take_ref(_arg0)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_variant, func(v **Variant) {
		C.free(unsafe.Pointer(v))
	})

	return _variant
}

// Unref decreases the reference count of @value. When its reference count drops
// to 0, the memory used by the variant is freed.
func (v *Variant) Unref() {
	var _arg0 *C.GVariant // out

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	C.g_variant_unref(_arg0)
}

// VariantBuilder: a utility type for constructing container-type #GVariant
// instances.
//
// This is an opaque structure and may only be accessed using the following
// functions.
//
// Builder is not threadsafe in any way. Do not attempt to access it from more
// than one thread.
type VariantBuilder C.GVariantBuilder

// WrapVariantBuilder wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapVariantBuilder(ptr unsafe.Pointer) *VariantBuilder {
	return (*VariantBuilder)(ptr)
}

func marshalVariantBuilder(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*VariantBuilder)(unsafe.Pointer(b)), nil
}

// NewVariantBuilder constructs a struct VariantBuilder.
func NewVariantBuilder(typ *VariantType) *VariantBuilder {
	var _arg1 *C.GVariantType    // out
	var _cret *C.GVariantBuilder // in

	_arg1 = (*C.GVariantType)(unsafe.Pointer(typ.Native()))

	_cret = C.g_variant_builder_new(_arg1)

	var _variantBuilder *VariantBuilder // out

	_variantBuilder = (*VariantBuilder)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_variantBuilder, func(v **VariantBuilder) {
		C.free(unsafe.Pointer(v))
	})

	return _variantBuilder
}

// Native returns the underlying C source pointer.
func (v *VariantBuilder) Native() unsafe.Pointer {
	return unsafe.Pointer(v)
}

// AddValue decreases the reference count on @builder.
//
// In the event that there are no more references, releases all memory
// associated with the Builder.
//
// Don't call this on stack-allocated Builder instances or bad things will
// happen.
func (b *VariantBuilder) AddValue(value *Variant) {
	var _arg0 *C.GVariantBuilder // out
	var _arg1 *C.GVariant        // out

	_arg0 = (*C.GVariantBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	C.g_variant_builder_add_value(_arg0, _arg1)
}

// Close decreases the reference count on @builder.
//
// In the event that there are no more references, releases all memory
// associated with the Builder.
//
// Don't call this on stack-allocated Builder instances or bad things will
// happen.
func (b *VariantBuilder) Close() {
	var _arg0 *C.GVariantBuilder // out

	_arg0 = (*C.GVariantBuilder)(unsafe.Pointer(b.Native()))

	C.g_variant_builder_close(_arg0)
}

// End decreases the reference count on @builder.
//
// In the event that there are no more references, releases all memory
// associated with the Builder.
//
// Don't call this on stack-allocated Builder instances or bad things will
// happen.
func (b *VariantBuilder) End() *Variant {
	var _arg0 *C.GVariantBuilder // out
	var _cret *C.GVariant        // in

	_arg0 = (*C.GVariantBuilder)(unsafe.Pointer(b.Native()))

	_cret = C.g_variant_builder_end(_arg0)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))

	return _variant
}

// Open decreases the reference count on @builder.
//
// In the event that there are no more references, releases all memory
// associated with the Builder.
//
// Don't call this on stack-allocated Builder instances or bad things will
// happen.
func (b *VariantBuilder) Open(typ *VariantType) {
	var _arg0 *C.GVariantBuilder // out
	var _arg1 *C.GVariantType    // out

	_arg0 = (*C.GVariantBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GVariantType)(unsafe.Pointer(typ.Native()))

	C.g_variant_builder_open(_arg0, _arg1)
}

// Ref decreases the reference count on @builder.
//
// In the event that there are no more references, releases all memory
// associated with the Builder.
//
// Don't call this on stack-allocated Builder instances or bad things will
// happen.
func (b *VariantBuilder) Ref() *VariantBuilder {
	var _arg0 *C.GVariantBuilder // out
	var _cret *C.GVariantBuilder // in

	_arg0 = (*C.GVariantBuilder)(unsafe.Pointer(b.Native()))

	_cret = C.g_variant_builder_ref(_arg0)

	var _variantBuilder *VariantBuilder // out

	_variantBuilder = (*VariantBuilder)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_variantBuilder, func(v **VariantBuilder) {
		C.free(unsafe.Pointer(v))
	})

	return _variantBuilder
}

// Unref decreases the reference count on @builder.
//
// In the event that there are no more references, releases all memory
// associated with the Builder.
//
// Don't call this on stack-allocated Builder instances or bad things will
// happen.
func (b *VariantBuilder) Unref() {
	var _arg0 *C.GVariantBuilder // out

	_arg0 = (*C.GVariantBuilder)(unsafe.Pointer(b.Native()))

	C.g_variant_builder_unref(_arg0)
}

// VariantDict is a mutable interface to #GVariant dictionaries.
//
// It can be used for doing a sequence of dictionary lookups in an efficient way
// on an existing #GVariant dictionary or it can be used to construct new
// dictionaries with a hashtable-like interface. It can also be used for taking
// existing dictionaries and modifying them in order to create new ones.
//
// Dict can only be used with G_VARIANT_TYPE_VARDICT dictionaries.
//
// It is possible to use Dict allocated on the stack or on the heap. When using
// a stack-allocated Dict, you begin with a call to g_variant_dict_init() and
// free the resources with a call to g_variant_dict_clear().
//
// Heap-allocated Dict follows normal refcounting rules: you allocate it with
// g_variant_dict_new() and use g_variant_dict_ref() and g_variant_dict_unref().
//
// g_variant_dict_end() is used to convert the Dict back into a dictionary-type
// #GVariant. When used with stack-allocated instances, this also implicitly
// frees all associated memory, but for heap-allocated instances, you must still
// call g_variant_dict_unref() afterwards.
//
// You will typically want to use a heap-allocated Dict when you expose it as
// part of an API. For most other uses, the stack-allocated form will be more
// convenient.
//
// Consider the following two examples that do the same thing in each style:
// take an existing dictionary and look up the "count" uint32 key, adding 1 to
// it if it is found, or returning an error if the key is not found. Each
// returns the new dictionary as a floating #GVariant.
//
// Using a stack-allocated GVariantDict
//
//      GVariant *
//      add_to_count (GVariant  *orig,
//                    GError   **error)
//      {
//        GVariantDict *dict;
//        GVariant *result;
//        guint32 count;
//
//        dict = g_variant_dict_new (orig);
//
//        if (g_variant_dict_lookup (dict, "count", "u", &count))
//          {
//            g_variant_dict_insert (dict, "count", "u", count + 1);
//            result = g_variant_dict_end (dict);
//          }
//        else
//          {
//            g_set_error (...);
//            result = NULL;
//          }
//
//        g_variant_dict_unref (dict);
//
//        return result;
//      }
type VariantDict C.GVariantDict

// WrapVariantDict wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapVariantDict(ptr unsafe.Pointer) *VariantDict {
	return (*VariantDict)(ptr)
}

func marshalVariantDict(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*VariantDict)(unsafe.Pointer(b)), nil
}

// NewVariantDict constructs a struct VariantDict.
func NewVariantDict(fromAsv *Variant) *VariantDict {
	var _arg1 *C.GVariant     // out
	var _cret *C.GVariantDict // in

	_arg1 = (*C.GVariant)(unsafe.Pointer(fromAsv.Native()))

	_cret = C.g_variant_dict_new(_arg1)

	var _variantDict *VariantDict // out

	_variantDict = (*VariantDict)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_variantDict, func(v **VariantDict) {
		C.free(unsafe.Pointer(v))
	})

	return _variantDict
}

// Native returns the underlying C source pointer.
func (v *VariantDict) Native() unsafe.Pointer {
	return unsafe.Pointer(v)
}

// Clear decreases the reference count on @dict.
//
// In the event that there are no more references, releases all memory
// associated with the Dict.
//
// Don't call this on stack-allocated Dict instances or bad things will happen.
func (d *VariantDict) Clear() {
	var _arg0 *C.GVariantDict // out

	_arg0 = (*C.GVariantDict)(unsafe.Pointer(d.Native()))

	C.g_variant_dict_clear(_arg0)
}

// Contains decreases the reference count on @dict.
//
// In the event that there are no more references, releases all memory
// associated with the Dict.
//
// Don't call this on stack-allocated Dict instances or bad things will happen.
func (d *VariantDict) Contains(key string) bool {
	var _arg0 *C.GVariantDict // out
	var _arg1 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GVariantDict)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_variant_dict_contains(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// End decreases the reference count on @dict.
//
// In the event that there are no more references, releases all memory
// associated with the Dict.
//
// Don't call this on stack-allocated Dict instances or bad things will happen.
func (d *VariantDict) End() *Variant {
	var _arg0 *C.GVariantDict // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GVariantDict)(unsafe.Pointer(d.Native()))

	_cret = C.g_variant_dict_end(_arg0)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))

	return _variant
}

// InsertValue decreases the reference count on @dict.
//
// In the event that there are no more references, releases all memory
// associated with the Dict.
//
// Don't call this on stack-allocated Dict instances or bad things will happen.
func (d *VariantDict) InsertValue(key string, value *Variant) {
	var _arg0 *C.GVariantDict // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GVariant     // out

	_arg0 = (*C.GVariantDict)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	C.g_variant_dict_insert_value(_arg0, _arg1, _arg2)
}

// LookupValue decreases the reference count on @dict.
//
// In the event that there are no more references, releases all memory
// associated with the Dict.
//
// Don't call this on stack-allocated Dict instances or bad things will happen.
func (d *VariantDict) LookupValue(key string, expectedType *VariantType) *Variant {
	var _arg0 *C.GVariantDict // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GVariantType // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GVariantDict)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariantType)(unsafe.Pointer(expectedType.Native()))

	_cret = C.g_variant_dict_lookup_value(_arg0, _arg1, _arg2)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_variant, func(v **Variant) {
		C.free(unsafe.Pointer(v))
	})

	return _variant
}

// Ref decreases the reference count on @dict.
//
// In the event that there are no more references, releases all memory
// associated with the Dict.
//
// Don't call this on stack-allocated Dict instances or bad things will happen.
func (d *VariantDict) Ref() *VariantDict {
	var _arg0 *C.GVariantDict // out
	var _cret *C.GVariantDict // in

	_arg0 = (*C.GVariantDict)(unsafe.Pointer(d.Native()))

	_cret = C.g_variant_dict_ref(_arg0)

	var _variantDict *VariantDict // out

	_variantDict = (*VariantDict)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_variantDict, func(v **VariantDict) {
		C.free(unsafe.Pointer(v))
	})

	return _variantDict
}

// Remove decreases the reference count on @dict.
//
// In the event that there are no more references, releases all memory
// associated with the Dict.
//
// Don't call this on stack-allocated Dict instances or bad things will happen.
func (d *VariantDict) Remove(key string) bool {
	var _arg0 *C.GVariantDict // out
	var _arg1 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GVariantDict)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_variant_dict_remove(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Unref decreases the reference count on @dict.
//
// In the event that there are no more references, releases all memory
// associated with the Dict.
//
// Don't call this on stack-allocated Dict instances or bad things will happen.
func (d *VariantDict) Unref() {
	var _arg0 *C.GVariantDict // out

	_arg0 = (*C.GVariantDict)(unsafe.Pointer(d.Native()))

	C.g_variant_dict_unref(_arg0)
}
