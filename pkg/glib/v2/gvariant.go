// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/ptr"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <glib.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_variant_builder_get_type()), F: marshalVariantBuilder},
		{T: externglib.Type(C.g_variant_dict_get_type()), F: marshalVariantDict},
	})
}

// VariantClass: the range of possible top-level types of #GVariant instances.
type VariantClass int

const (
	// VariantClassBoolean: the #GVariant is a boolean.
	VariantClassBoolean VariantClass = 98
	// VariantClassByte: the #GVariant is a byte.
	VariantClassByte VariantClass = 121
	// VariantClassInt16: the #GVariant is a signed 16 bit integer.
	VariantClassInt16 VariantClass = 110
	// VariantClassUint16: the #GVariant is an unsigned 16 bit integer.
	VariantClassUint16 VariantClass = 113
	// VariantClassInt32: the #GVariant is a signed 32 bit integer.
	VariantClassInt32 VariantClass = 105
	// VariantClassUint32: the #GVariant is an unsigned 32 bit integer.
	VariantClassUint32 VariantClass = 117
	// VariantClassInt64: the #GVariant is a signed 64 bit integer.
	VariantClassInt64 VariantClass = 120
	// VariantClassUint64: the #GVariant is an unsigned 64 bit integer.
	VariantClassUint64 VariantClass = 116
	// VariantClassHandle: the #GVariant is a file handle index.
	VariantClassHandle VariantClass = 104
	// VariantClassDouble: the #GVariant is a double precision floating point
	// value.
	VariantClassDouble VariantClass = 100
	// VariantClassString: the #GVariant is a normal string.
	VariantClassString VariantClass = 115
	// VariantClassObjectPath: the #GVariant is a D-Bus object path string.
	VariantClassObjectPath VariantClass = 111
	// VariantClassSignature: the #GVariant is a D-Bus signature string.
	VariantClassSignature VariantClass = 103
	// VariantClassVariant: the #GVariant is a variant.
	VariantClassVariant VariantClass = 118
	// VariantClassMaybe: the #GVariant is a maybe-typed value.
	VariantClassMaybe VariantClass = 109
	// VariantClassArray: the #GVariant is an array.
	VariantClassArray VariantClass = 97
	// VariantClassTuple: the #GVariant is a tuple.
	VariantClassTuple VariantClass = 40
	// VariantClassDictEntry: the #GVariant is a dictionary entry.
	VariantClassDictEntry VariantClass = 123
)

// VariantParseError: error codes returned by parsing text-format GVariants.
type VariantParseError int

const (
	// VariantParseErrorFailed: generic error (unused)
	VariantParseErrorFailed VariantParseError = 0
	// VariantParseErrorBasicTypeExpected: a non-basic Type was given where a
	// basic type was expected
	VariantParseErrorBasicTypeExpected VariantParseError = 1
	// VariantParseErrorCannotInferType: cannot infer the Type
	VariantParseErrorCannotInferType VariantParseError = 2
	// VariantParseErrorDefiniteTypeExpected: an indefinite Type was given where
	// a definite type was expected
	VariantParseErrorDefiniteTypeExpected VariantParseError = 3
	// VariantParseErrorInputNotAtEnd: extra data after parsing finished
	VariantParseErrorInputNotAtEnd VariantParseError = 4
	// VariantParseErrorInvalidCharacter: invalid character in number or unicode
	// escape
	VariantParseErrorInvalidCharacter VariantParseError = 5
	// VariantParseErrorInvalidFormatString: not a valid #GVariant format string
	VariantParseErrorInvalidFormatString VariantParseError = 6
	// VariantParseErrorInvalidObjectPath: not a valid object path
	VariantParseErrorInvalidObjectPath VariantParseError = 7
	// VariantParseErrorInvalidSignature: not a valid type signature
	VariantParseErrorInvalidSignature VariantParseError = 8
	// VariantParseErrorInvalidTypeString: not a valid #GVariant type string
	VariantParseErrorInvalidTypeString VariantParseError = 9
	// VariantParseErrorNoCommonType: could not find a common type for array
	// entries
	VariantParseErrorNoCommonType VariantParseError = 10
	// VariantParseErrorNumberOutOfRange: the numerical value is out of range of
	// the given type
	VariantParseErrorNumberOutOfRange VariantParseError = 11
	// VariantParseErrorNumberTooBig: the numerical value is out of range for
	// any type
	VariantParseErrorNumberTooBig VariantParseError = 12
	// VariantParseErrorTypeError: cannot parse as variant of the specified type
	VariantParseErrorTypeError VariantParseError = 13
	// VariantParseErrorUnexpectedToken: an unexpected token was encountered
	VariantParseErrorUnexpectedToken VariantParseError = 14
	// VariantParseErrorUnknownKeyword: an unknown keyword was encountered
	VariantParseErrorUnknownKeyword VariantParseError = 15
	// VariantParseErrorUnterminatedStringConstant: unterminated string constant
	VariantParseErrorUnterminatedStringConstant VariantParseError = 16
	// VariantParseErrorValueExpected: no value given
	VariantParseErrorValueExpected VariantParseError = 17
	// VariantParseErrorRecursion: variant was too deeply nested; #GVariant is
	// only guaranteed to handle nesting up to 64 levels (Since: 2.64)
	VariantParseErrorRecursion VariantParseError = 18
)

// Variant is a variant datatype; it can contain one or more values along with
// information about the type of the values.
//
// A #GVariant may contain simple types, like an integer, or a boolean value; or
// complex types, like an array of two strings, or a dictionary of key value
// pairs. A #GVariant is also immutable: once it's been created neither its type
// nor its content can be modified further.
//
// GVariant is useful whenever data needs to be serialized, for example when
// sending method parameters in DBus, or when saving settings using GSettings.
//
// When creating a new #GVariant, you pass the data you want to store in it
// along with a string representing the type of data you wish to pass to it.
//
// For instance, if you want to create a #GVariant holding an integer value you
// can use:
//
//    GVariant *v = g_variant_new ("u", 40);
//
// The string "u" in the first argument tells #GVariant that the data passed to
// the constructor (40) is going to be an unsigned integer.
//
// More advanced examples of #GVariant in use can be found in documentation for
// [GVariant format strings][gvariant-format-strings-pointers].
//
// The range of possible values is determined by the type.
//
// The type system used by #GVariant is Type.
//
// #GVariant instances always have a type and a value (which are given at
// construction time). The type and value of a #GVariant instance can never
// change other than by the #GVariant itself being destroyed. A #GVariant cannot
// contain a pointer.
//
// #GVariant is reference counted using g_variant_ref() and g_variant_unref().
// #GVariant also has floating reference counts -- see g_variant_ref_sink().
//
// #GVariant is completely threadsafe. A #GVariant instance can be concurrently
// accessed in any way from any number of threads without problems.
//
// #GVariant is heavily optimised for dealing with data in serialised form. It
// works particularly well with data located in memory-mapped files. It can
// perform nearly all deserialisation operations in a small constant time,
// usually touching only a single memory page. Serialised #GVariant data can
// also be sent over the network.
//
// #GVariant is largely compatible with D-Bus. Almost all types of #GVariant
// instances can be sent over D-Bus. See Type for exceptions. (However,
// #GVariant's serialisation format is not the same as the serialisation format
// of a D-Bus message body: use BusMessage, in the gio library, for those.)
//
// For space-efficiency, the #GVariant serialisation format does not
// automatically include the variant's length, type or endianness, which must
// either be implied from context (such as knowledge that a particular file
// format always contains a little-endian G_VARIANT_TYPE_VARIANT which occupies
// the whole length of the file) or supplied out-of-band (for instance, a
// length, type and/or endianness indicator could be placed at the beginning of
// a file, network message or network stream).
//
// A #GVariant's size is limited mainly by any lower level operating system
// constraints, such as the number of bits in #gsize. For example, it is
// reasonable to have a 2GB file mapped into memory with File, and call
// g_variant_new_from_data() on it.
//
// For convenience to C programmers, #GVariant features powerful varargs-based
// value construction and destruction. This feature is designed to be embedded
// in other libraries.
//
// There is a Python-inspired text language for describing #GVariant values.
// #GVariant includes a printer for this language and a parser with type
// inferencing.
//
//
// Memory Use
//
// #GVariant tries to be quite efficient with respect to memory use. This
// section gives a rough idea of how much memory is used by the current
// implementation. The information here is subject to change in the future.
//
// The memory allocated by #GVariant can be grouped into 4 broad purposes:
// memory for serialised data, memory for the type information cache, buffer
// management memory and memory for the #GVariant structure itself.
//
//
// Serialised Data Memory
//
// This is the memory that is used for storing GVariant data in serialised form.
// This is what would be sent over the network or what would end up on disk, not
// counting any indicator of the endianness, or of the length or type of the
// top-level variant.
//
// The amount of memory required to store a boolean is 1 byte. 16, 32 and 64 bit
// integers and double precision floating point numbers use their "natural"
// size. Strings (including object path and signature strings) are stored with a
// nul terminator, and as such use the length of the string plus 1 byte.
//
// Maybe types use no space at all to represent the null value and use the same
// amount of space (sometimes plus one byte) as the equivalent non-maybe-typed
// value to represent the non-null case.
//
// Arrays use the amount of space required to store each of their members,
// concatenated. Additionally, if the items stored in an array are not of a
// fixed-size (ie: strings, other arrays, etc) then an additional framing offset
// is stored for each item. The size of this offset is either 1, 2 or 4 bytes
// depending on the overall size of the container. Additionally, extra padding
// bytes are added as required for alignment of child values.
//
// Tuples (including dictionary entries) use the amount of space required to
// store each of their members, concatenated, plus one framing offset (as per
// arrays) for each non-fixed-sized item in the tuple, except for the last one.
// Additionally, extra padding bytes are added as required for alignment of
// child values.
//
// Variants use the same amount of space as the item inside of the variant, plus
// 1 byte, plus the length of the type string for the item inside the variant.
//
// As an example, consider a dictionary mapping strings to variants. In the case
// that the dictionary is empty, 0 bytes are required for the serialisation.
//
// If we add an item "width" that maps to the int32 value of 500 then we will
// use 4 byte to store the int32 (so 6 for the variant containing it) and 6
// bytes for the string. The variant must be aligned to 8 after the 6 bytes of
// the string, so that's 2 extra bytes. 6 (string) + 2 (padding) + 6 (variant)
// is 14 bytes used for the dictionary entry. An additional 1 byte is added to
// the array as a framing offset making a total of 15 bytes.
//
// If we add another entry, "title" that maps to a nullable string that happens
// to have a value of null, then we use 0 bytes for the null value (and 3 bytes
// for the variant to contain it along with its type string) plus 6 bytes for
// the string. Again, we need 2 padding bytes. That makes a total of 6 + 2 + 3 =
// 11 bytes.
//
// We now require extra padding between the two items in the array. After the 14
// bytes of the first item, that's 2 bytes required. We now require 2 framing
// offsets for an extra two bytes. 14 + 2 + 11 + 2 = 29 bytes to encode the
// entire two-item dictionary.
//
//
// Type Information Cache
//
// For each GVariant type that currently exists in the program a type
// information structure is kept in the type information cache. The type
// information structure is required for rapid deserialisation.
//
// Continuing with the above example, if a #GVariant exists with the type
// "a{sv}" then a type information struct will exist for "a{sv}", "{sv}", "s",
// and "v". Multiple uses of the same type will share the same type information.
// Additionally, all single-digit types are stored in read-only static memory
// and do not contribute to the writable memory footprint of a program using
// #GVariant.
//
// Aside from the type information structures stored in read-only memory, there
// are two forms of type information. One is used for container types where
// there is a single element type: arrays and maybe types. The other is used for
// container types where there are multiple element types: tuples and dictionary
// entries.
//
// Array type info structures are 6 * sizeof (void *), plus the memory required
// to store the type string itself. This means that on 32-bit systems, the cache
// entry for "a{sv}" would require 30 bytes of memory (plus malloc overhead).
//
// Tuple type info structures are 6 * sizeof (void *), plus 4 * sizeof (void *)
// for each item in the tuple, plus the memory required to store the type string
// itself. A 2-item tuple, for example, would have a type information structure
// that consumed writable memory in the size of 14 * sizeof (void *) (plus type
// string) This means that on 32-bit systems, the cache entry for "{sv}" would
// require 61 bytes of memory (plus malloc overhead).
//
// This means that in total, for our "a{sv}" example, 91 bytes of type
// information would be allocated.
//
// The type information cache, additionally, uses a Table to store and look up
// the cached items and stores a pointer to this hash table in static storage.
// The hash table is freed when there are zero items in the type cache.
//
// Although these sizes may seem large it is important to remember that a
// program will probably only have a very small number of different types of
// values in it and that only one type information structure is required for
// many different values of the same type.
//
//
// Buffer Management Memory
//
// #GVariant uses an internal buffer management structure to deal with the
// various different possible sources of serialised data that it uses. The
// buffer is responsible for ensuring that the correct call is made when the
// data is no longer in use by #GVariant. This may involve a g_free() or a
// g_slice_free() or even g_mapped_file_unref().
//
// One buffer management structure is used for each chunk of serialised data.
// The size of the buffer management structure is 4 * (void *). On 32-bit
// systems, that's 16 bytes.
//
//
// GVariant structure
//
// The size of a #GVariant structure is 6 * (void *). On 32-bit systems, that's
// 24 bytes.
//
// #GVariant structures only exist if they are explicitly created with API
// calls. For example, if a #GVariant is constructed out of serialised data for
// the example given above (with the dictionary) then although there are 9
// individual values that comprise the entire dictionary (two keys, two values,
// two variants containing the values, two dictionary entries, plus the
// dictionary itself), only 1 #GVariant instance exists -- the one referring to
// the dictionary.
//
// If calls are made to start accessing the other values then #GVariant
// instances will exist for those values only for as long as they are in use
// (ie: until you call g_variant_unref()). The type information is shared. The
// serialised data and the buffer management structure for that serialised data
// is shared by the child.
//
//
// Summary
//
// To put the entire example together, for our dictionary mapping strings to
// variants (with two entries, as given above), we are using 91 bytes of memory
// for type information, 29 bytes of memory for the serialised data, 16 bytes
// for buffer management and 24 bytes for the #GVariant instance, or a total of
// 160 bytes, plus malloc overhead. If we were to use
// g_variant_get_child_value() to access the two dictionary entries, we would
// use an additional 48 bytes. If we were to have other dictionaries of the same
// type, we would use more memory for the serialised data and buffer management
// for those dictionaries, but the type information would be shared.
type Variant struct {
	native C.GVariant
}

// WrapVariant wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapVariant(ptr unsafe.Pointer) *Variant {
	if ptr == nil {
		return nil
	}

	return (*Variant)(ptr)
}

func marshalVariant(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapVariant(unsafe.Pointer(b)), nil
}

// NewVariantArray constructs a struct Variant.
func NewVariantArray() *Variant {
	var _cret *C.GVariant

	cret = C.g_variant_new_array()

	var _variant *Variant

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantBoolean constructs a struct Variant.
func NewVariantBoolean(value bool) *Variant {
	var _arg1 C.gboolean

	if value {
		_arg1 = C.gboolean(1)
	}

	var _cret *C.GVariant

	cret = C.g_variant_new_boolean(_arg1)

	var _variant *Variant

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantByte constructs a struct Variant.
func NewVariantByte(value byte) *Variant {
	var _arg1 C.guint8

	_arg1 = C.guint8(value)

	var _cret *C.GVariant

	cret = C.g_variant_new_byte(_arg1)

	var _variant *Variant

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantBytestring constructs a struct Variant.
func NewVariantBytestring(string []byte) *Variant {
	var _arg1 *C.gchar

	_arg1 = (*C.gchar)(C.malloc((len(string) + 1) * C.sizeof_guint8))
	defer C.free(unsafe.Pointer(_arg1))

	{
		var out []C.guint8
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(_arg1), int(len(string)))

		for i := range string {
			_arg1 = C.guint8(string)
		}
	}

	var _cret *C.GVariant

	cret = C.g_variant_new_bytestring(_arg1)

	var _variant *Variant

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantBytestringArray constructs a struct Variant.
func NewVariantBytestringArray() *Variant {
	var _cret *C.GVariant

	cret = C.g_variant_new_bytestring_array()

	var _variant *Variant

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantDictEntry constructs a struct Variant.
func NewVariantDictEntry(key *Variant, value *Variant) *Variant {
	var _arg1 *C.GVariant
	var _arg2 *C.GVariant

	_arg1 = (*C.GVariant)(unsafe.Pointer(key.Native()))
	_arg2 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	var _cret *C.GVariant

	cret = C.g_variant_new_dict_entry(_arg1, _arg2)

	var _variant *Variant

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantDouble constructs a struct Variant.
func NewVariantDouble(value float64) *Variant {
	var _arg1 C.gdouble

	_arg1 = C.gdouble(value)

	var _cret *C.GVariant

	cret = C.g_variant_new_double(_arg1)

	var _variant *Variant

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantFixedArray constructs a struct Variant.
func NewVariantFixedArray(elementType *VariantType, elements interface{}, nElements uint, elementSize uint) *Variant {
	var _arg1 *C.GVariantType
	var _arg2 C.gpointer
	var _arg3 C.gsize
	var _arg4 C.gsize

	_arg1 = (*C.GVariantType)(unsafe.Pointer(elementType.Native()))
	_arg2 = C.gpointer(elements)
	_arg3 = C.gsize(nElements)
	_arg4 = C.gsize(elementSize)

	var _cret *C.GVariant

	cret = C.g_variant_new_fixed_array(_arg1, _arg2, _arg3, _arg4)

	var _variant *Variant

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantHandle constructs a struct Variant.
func NewVariantHandle(value int32) *Variant {
	var _arg1 C.gint32

	_arg1 = C.gint32(value)

	var _cret *C.GVariant

	cret = C.g_variant_new_handle(_arg1)

	var _variant *Variant

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantInt16 constructs a struct Variant.
func NewVariantInt16(value int16) *Variant {
	var _arg1 C.gint16

	_arg1 = C.gint16(value)

	var _cret *C.GVariant

	cret = C.g_variant_new_int16(_arg1)

	var _variant *Variant

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantInt32 constructs a struct Variant.
func NewVariantInt32(value int32) *Variant {
	var _arg1 C.gint32

	_arg1 = C.gint32(value)

	var _cret *C.GVariant

	cret = C.g_variant_new_int32(_arg1)

	var _variant *Variant

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantInt64 constructs a struct Variant.
func NewVariantInt64(value int64) *Variant {
	var _arg1 C.gint64

	_arg1 = C.gint64(value)

	var _cret *C.GVariant

	cret = C.g_variant_new_int64(_arg1)

	var _variant *Variant

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantMaybe constructs a struct Variant.
func NewVariantMaybe(childType *VariantType, child *Variant) *Variant {
	var _arg1 *C.GVariantType
	var _arg2 *C.GVariant

	_arg1 = (*C.GVariantType)(unsafe.Pointer(childType.Native()))
	_arg2 = (*C.GVariant)(unsafe.Pointer(child.Native()))

	var _cret *C.GVariant

	cret = C.g_variant_new_maybe(_arg1, _arg2)

	var _variant *Variant

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantObjectPath constructs a struct Variant.
func NewVariantObjectPath(objectPath string) *Variant {
	var _arg1 *C.gchar

	_arg1 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret *C.GVariant

	cret = C.g_variant_new_object_path(_arg1)

	var _variant *Variant

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantObjv constructs a struct Variant.
func NewVariantObjv() *Variant {
	var _cret *C.GVariant

	cret = C.g_variant_new_objv()

	var _variant *Variant

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantSignature constructs a struct Variant.
func NewVariantSignature(signature string) *Variant {
	var _arg1 *C.gchar

	_arg1 = (*C.gchar)(C.CString(signature))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret *C.GVariant

	cret = C.g_variant_new_signature(_arg1)

	var _variant *Variant

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantString constructs a struct Variant.
func NewVariantString(string string) *Variant {
	var _arg1 *C.gchar

	_arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret *C.GVariant

	cret = C.g_variant_new_string(_arg1)

	var _variant *Variant

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantStrv constructs a struct Variant.
func NewVariantStrv() *Variant {
	var _cret *C.GVariant

	cret = C.g_variant_new_strv()

	var _variant *Variant

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantTakeString constructs a struct Variant.
func NewVariantTakeString(string string) *Variant {
	var _arg1 *C.gchar

	_arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret *C.GVariant

	cret = C.g_variant_new_take_string(_arg1)

	var _variant *Variant

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantTuple constructs a struct Variant.
func NewVariantTuple() *Variant {
	var _cret *C.GVariant

	cret = C.g_variant_new_tuple()

	var _variant *Variant

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantUint16 constructs a struct Variant.
func NewVariantUint16(value uint16) *Variant {
	var _arg1 C.guint16

	_arg1 = C.guint16(value)

	var _cret *C.GVariant

	cret = C.g_variant_new_uint16(_arg1)

	var _variant *Variant

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantUint32 constructs a struct Variant.
func NewVariantUint32(value uint32) *Variant {
	var _arg1 C.guint32

	_arg1 = C.guint32(value)

	var _cret *C.GVariant

	cret = C.g_variant_new_uint32(_arg1)

	var _variant *Variant

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantUint64 constructs a struct Variant.
func NewVariantUint64(value uint64) *Variant {
	var _arg1 C.guint64

	_arg1 = C.guint64(value)

	var _cret *C.GVariant

	cret = C.g_variant_new_uint64(_arg1)

	var _variant *Variant

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// NewVariantVariant constructs a struct Variant.
func NewVariantVariant(value *Variant) *Variant {
	var _arg1 *C.GVariant

	_arg1 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	var _cret *C.GVariant

	cret = C.g_variant_new_variant(_arg1)

	var _variant *Variant

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// Native returns the underlying C source pointer.
func (v *Variant) Native() unsafe.Pointer {
	return unsafe.Pointer(&v.native)
}

// Byteswap performs a byteswapping operation on the contents of @value. The
// result is that all multi-byte numeric data contained in @value is
// byteswapped. That includes 16, 32, and 64bit signed and unsigned integers as
// well as file handles and double precision floating point values.
//
// This function is an identity mapping on any value that does not contain
// multi-byte numeric data. That include strings, booleans, bytes and containers
// containing only these things (recursively).
//
// The returned value is always in normal form and is marked as trusted.
func (v *Variant) Byteswap() *Variant {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	var _cret *C.GVariant

	cret = C.g_variant_byteswap(_arg0)

	var _variant *Variant

	_variant = WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

// CheckFormatString checks if calling g_variant_get() with @format_string on
// @value would be valid from a type-compatibility standpoint. @format_string is
// assumed to be a valid format string (from a syntactic standpoint).
//
// If @copy_only is true then this function additionally checks that it would be
// safe to call g_variant_unref() on @value immediately after the call to
// g_variant_get() without invalidating the result. This is only possible if
// deep copies are made (ie: there are no pointers to the data inside of the
// soon-to-be-freed #GVariant instance). If this check fails then a g_critical()
// is printed and false is returned.
//
// This function is meant to be used by functions that wish to provide varargs
// accessors to #GVariant values of uncertain values (eg: g_variant_lookup() or
// g_menu_model_get_item_attribute()).
func (v *Variant) CheckFormatString(formatString string, copyOnly bool) bool {
	var _arg0 *C.GVariant
	var _arg1 *C.gchar
	var _arg2 C.gboolean

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.gchar)(C.CString(formatString))
	defer C.free(unsafe.Pointer(_arg1))
	if copyOnly {
		_arg2 = C.gboolean(1)
	}

	var _cret C.gboolean

	cret = C.g_variant_check_format_string(_arg0, _arg1, _arg2)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Classify classifies @value according to its top-level type.
func (v *Variant) Classify() VariantClass {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	var _cret C.GVariantClass

	cret = C.g_variant_classify(_arg0)

	var _variantClass VariantClass

	_variantClass = VariantClass(_cret)

	return _variantClass
}

// Compare compares @one and @two.
//
// The types of @one and @two are #gconstpointer only to allow use of this
// function with #GTree, Array, etc. They must each be a #GVariant.
//
// Comparison is only defined for basic types (ie: booleans, numbers, strings).
// For booleans, false is less than true. Numbers are ordered in the usual way.
// Strings are in ASCII lexographical order.
//
// It is a programmer error to attempt to compare container values or two values
// that have types that are not exactly equal. For example, you cannot compare a
// 32-bit signed integer with a 32-bit unsigned integer. Also note that this
// function is not particularly well-behaved when it comes to comparison of
// doubles; in particular, the handling of incomparable values (ie: NaN) is
// undefined.
//
// If you only require an equality comparison, g_variant_equal() is more
// general.
func (o *Variant) Compare(two Variant) int {
	var _arg0 C.gpointer
	var _arg1 C.gpointer

	_arg0 = (C.gpointer)(unsafe.Pointer(o.Native()))
	_arg1 = (C.gpointer)(unsafe.Pointer(two.Native()))

	var _cret C.gint

	cret = C.g_variant_compare(_arg0, _arg1)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// DupBytestring: similar to g_variant_get_bytestring() except that instead of
// returning a constant string, the string is duplicated.
//
// The return value must be freed using g_free().
func (v *Variant) DupBytestring() []byte {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	var _cret *C.gchar
	var _arg1 *C.gsize

	cret = C.g_variant_dup_bytestring(_arg0)

	var _guint8s []byte

	ptr.SetSlice(unsafe.Pointer(&_guint8s), unsafe.Pointer(_cret), int(_arg1))
	runtime.SetFinalizer(&_guint8s, func(v *[]byte) {
		C.free(ptr.Slice(unsafe.Pointer(v)))
	})

	return _guint8s
}

// DupBytestringArray gets the contents of an array of array of bytes #GVariant.
// This call makes a deep copy; the return result should be released with
// g_strfreev().
//
// If @length is non-nil then the number of elements in the result is stored
// there. In any case, the resulting array will be nil-terminated.
//
// For an empty array, @length will be set to 0 and a pointer to a nil pointer
// will be returned.
func (v *Variant) DupBytestringArray() []string {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	var _cret **C.gchar
	var _arg1 *C.gsize

	cret = C.g_variant_dup_bytestring_array(_arg0)

	var _utf8s []string

	{
		var src []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(_cret), int(_arg1))

		_utf8s = make([]string, _arg1)
		for i := 0; i < uintptr(_arg1); i++ {
			_utf8s = C.GoString(_cret)
			defer C.free(unsafe.Pointer(_cret))
		}
	}

	return _utf8s
}

// DupObjv gets the contents of an array of object paths #GVariant. This call
// makes a deep copy; the return result should be released with g_strfreev().
//
// If @length is non-nil then the number of elements in the result is stored
// there. In any case, the resulting array will be nil-terminated.
//
// For an empty array, @length will be set to 0 and a pointer to a nil pointer
// will be returned.
func (v *Variant) DupObjv() []string {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	var _cret **C.gchar
	var _arg1 *C.gsize

	cret = C.g_variant_dup_objv(_arg0)

	var _utf8s []string

	{
		var src []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(_cret), int(_arg1))

		_utf8s = make([]string, _arg1)
		for i := 0; i < uintptr(_arg1); i++ {
			_utf8s = C.GoString(_cret)
			defer C.free(unsafe.Pointer(_cret))
		}
	}

	return _utf8s
}

// DupString: similar to g_variant_get_string() except that instead of returning
// a constant string, the string is duplicated.
//
// The string will always be UTF-8 encoded.
//
// The return value must be freed using g_free().
func (v *Variant) DupString() (uint, string) {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	var _arg1 C.gsize
	var _cret *C.gchar

	cret = C.g_variant_dup_string(_arg0, &_arg1)

	var _length uint
	var _utf8 string

	_length = (uint)(_arg1)
	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _length, _utf8
}

// DupStrv gets the contents of an array of strings #GVariant. This call makes a
// deep copy; the return result should be released with g_strfreev().
//
// If @length is non-nil then the number of elements in the result is stored
// there. In any case, the resulting array will be nil-terminated.
//
// For an empty array, @length will be set to 0 and a pointer to a nil pointer
// will be returned.
func (v *Variant) DupStrv() []string {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	var _cret **C.gchar
	var _arg1 *C.gsize

	cret = C.g_variant_dup_strv(_arg0)

	var _utf8s []string

	{
		var src []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(_cret), int(_arg1))

		_utf8s = make([]string, _arg1)
		for i := 0; i < uintptr(_arg1); i++ {
			_utf8s = C.GoString(_cret)
			defer C.free(unsafe.Pointer(_cret))
		}
	}

	return _utf8s
}

// Equal checks if @one and @two have the same type and value.
//
// The types of @one and @two are #gconstpointer only to allow use of this
// function with Table. They must each be a #GVariant.
func (o *Variant) Equal(two Variant) bool {
	var _arg0 C.gpointer
	var _arg1 C.gpointer

	_arg0 = (C.gpointer)(unsafe.Pointer(o.Native()))
	_arg1 = (C.gpointer)(unsafe.Pointer(two.Native()))

	var _cret C.gboolean

	cret = C.g_variant_equal(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Boolean returns the boolean value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_BOOLEAN.
func (v *Variant) Boolean() bool {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	var _cret C.gboolean

	cret = C.g_variant_get_boolean(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Byte returns the byte value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_BYTE.
func (v *Variant) Byte() byte {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	var _cret C.guint8

	cret = C.g_variant_get_byte(_arg0)

	var _guint8 byte

	_guint8 = (byte)(_cret)

	return _guint8
}

// Bytestring returns the string value of a #GVariant instance with an
// array-of-bytes type. The string has no particular encoding.
//
// If the array does not end with a nul terminator character, the empty string
// is returned. For this reason, you can always trust that a non-nil
// nul-terminated string will be returned by this function.
//
// If the array contains a nul terminator character somewhere other than the
// last byte then the returned string is the string, up to the first such nul
// character.
//
// g_variant_get_fixed_array() should be used instead if the array contains
// arbitrary data that could not be nul-terminated or could contain nul bytes.
//
// It is an error to call this function with a @value that is not an array of
// bytes.
//
// The return value remains valid as long as @value exists.
func (v *Variant) Bytestring() []byte {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	var _cret *C.gchar

	cret = C.g_variant_get_bytestring(_arg0)

	var _guint8s []byte

	{
		var length int
		for p := _cret; *p != 0; p = (*C.gchar)(ptr.Add(unsafe.Pointer(p), C.sizeof_guint8)) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		var src []C.guint8
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(_cret), int(length))

		_guint8s = make([]byte, length)
		for i := uintptr(0); i < uintptr(length); i += C.sizeof_guint8 {
			_guint8s = (byte)(_cret)
		}
	}

	return _guint8s
}

// BytestringArray gets the contents of an array of array of bytes #GVariant.
// This call makes a shallow copy; the return result should be released with
// g_free(), but the individual strings must not be modified.
//
// If @length is non-nil then the number of elements in the result is stored
// there. In any case, the resulting array will be nil-terminated.
//
// For an empty array, @length will be set to 0 and a pointer to a nil pointer
// will be returned.
func (v *Variant) BytestringArray() []string {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	var _cret **C.gchar
	var _arg1 *C.gsize

	cret = C.g_variant_get_bytestring_array(_arg0)

	var _utf8s []string

	{
		var src []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(_cret), int(_arg1))

		_utf8s = make([]string, _arg1)
		for i := 0; i < uintptr(_arg1); i++ {
			_utf8s = C.GoString(_cret)
		}
	}

	return _utf8s
}

// ChildValue reads a child item out of a container #GVariant instance. This
// includes variants, maybes, arrays, tuples and dictionary entries. It is an
// error to call this function on any other type of #GVariant.
//
// It is an error if @index_ is greater than the number of child items in the
// container. See g_variant_n_children().
//
// The returned value is never floating. You should free it with
// g_variant_unref() when you're done with it.
//
// Note that values borrowed from the returned child are not guaranteed to still
// be valid after the child is freed even if you still hold a reference to
// @value, if @value has not been serialised at the time this function is
// called. To avoid this, you can serialize @value by calling
// g_variant_get_data() and optionally ignoring the return value.
//
// There may be implementation specific restrictions on deeply nested values,
// which would result in the unit tuple being returned as the child value,
// instead of further nested children. #GVariant is guaranteed to handle nesting
// up to at least 64 levels.
//
// This function is O(1).
func (v *Variant) ChildValue(index_ uint) *Variant {
	var _arg0 *C.GVariant
	var _arg1 C.gsize

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))
	_arg1 = C.gsize(index_)

	var _cret *C.GVariant

	cret = C.g_variant_get_child_value(_arg0, _arg1)

	var _variant *Variant

	_variant = WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

// Data returns a pointer to the serialised form of a #GVariant instance. The
// returned data may not be in fully-normalised form if read from an untrusted
// source. The returned data must not be freed; it remains valid for as long as
// @value exists.
//
// If @value is a fixed-sized value that was deserialised from a corrupted
// serialised container then nil may be returned. In this case, the proper thing
// to do is typically to use the appropriate number of nul bytes in place of
// @value. If @value is not fixed-sized then nil is never returned.
//
// In the case that @value is already in serialised form, this function is O(1).
// If the value is not already in serialised form, serialisation occurs
// implicitly and is approximately O(n) in the size of the result.
//
// To deserialise the data returned by this function, in addition to the
// serialised data, you must know the type of the #GVariant, and (if the machine
// might be different) the endianness of the machine that stored it. As a
// result, file formats or network messages that incorporate serialised
// #GVariants must include this information either implicitly (for instance "the
// file always contains a G_VARIANT_TYPE_VARIANT and it is always in
// little-endian order") or explicitly (by storing the type and/or endianness in
// addition to the serialised data).
func (v *Variant) Data() interface{} {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	var _cret C.gpointer

	cret = C.g_variant_get_data(_arg0)

	var _gpointer interface{}

	_gpointer = (interface{})(_cret)

	return _gpointer
}

// Double returns the double precision floating point value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_DOUBLE.
func (v *Variant) Double() float64 {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	var _cret C.gdouble

	cret = C.g_variant_get_double(_arg0)

	var _gdouble float64

	_gdouble = (float64)(_cret)

	return _gdouble
}

// Handle returns the 32-bit signed integer value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_HANDLE.
//
// By convention, handles are indexes into an array of file descriptors that are
// sent alongside a D-Bus message. If you're not interacting with D-Bus, you
// probably don't need them.
func (v *Variant) Handle() int32 {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	var _cret C.gint32

	cret = C.g_variant_get_handle(_arg0)

	var _gint32 int32

	_gint32 = (int32)(_cret)

	return _gint32
}

// Int16 returns the 16-bit signed integer value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_INT16.
func (v *Variant) Int16() int16 {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	var _cret C.gint16

	cret = C.g_variant_get_int16(_arg0)

	var _gint16 int16

	_gint16 = (int16)(_cret)

	return _gint16
}

// Int32 returns the 32-bit signed integer value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_INT32.
func (v *Variant) Int32() int32 {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	var _cret C.gint32

	cret = C.g_variant_get_int32(_arg0)

	var _gint32 int32

	_gint32 = (int32)(_cret)

	return _gint32
}

// Int64 returns the 64-bit signed integer value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_INT64.
func (v *Variant) Int64() int64 {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	var _cret C.gint64

	cret = C.g_variant_get_int64(_arg0)

	var _gint64 int64

	_gint64 = (int64)(_cret)

	return _gint64
}

// Maybe: given a maybe-typed #GVariant instance, extract its value. If the
// value is Nothing, then this function returns nil.
func (v *Variant) Maybe() *Variant {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	var _cret *C.GVariant

	cret = C.g_variant_get_maybe(_arg0)

	var _variant *Variant

	_variant = WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

// NormalForm gets a #GVariant instance that has the same value as @value and is
// trusted to be in normal form.
//
// If @value is already trusted to be in normal form then a new reference to
// @value is returned.
//
// If @value is not already trusted, then it is scanned to check if it is in
// normal form. If it is found to be in normal form then it is marked as trusted
// and a new reference to it is returned.
//
// If @value is found not to be in normal form then a new trusted #GVariant is
// created with the same value as @value.
//
// It makes sense to call this function if you've received #GVariant data from
// untrusted sources and you want to ensure your serialised output is definitely
// in normal form.
//
// If @value is already in normal form, a new reference will be returned (which
// will be floating if @value is floating). If it is not in normal form, the
// newly created #GVariant will be returned with a single non-floating
// reference. Typically, g_variant_take_ref() should be called on the return
// value from this function to guarantee ownership of a single non-floating
// reference to it.
func (v *Variant) NormalForm() *Variant {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	var _cret *C.GVariant

	cret = C.g_variant_get_normal_form(_arg0)

	var _variant *Variant

	_variant = WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

// Objv gets the contents of an array of object paths #GVariant. This call makes
// a shallow copy; the return result should be released with g_free(), but the
// individual strings must not be modified.
//
// If @length is non-nil then the number of elements in the result is stored
// there. In any case, the resulting array will be nil-terminated.
//
// For an empty array, @length will be set to 0 and a pointer to a nil pointer
// will be returned.
func (v *Variant) Objv() []string {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	var _cret **C.gchar
	var _arg1 *C.gsize

	cret = C.g_variant_get_objv(_arg0)

	var _utf8s []string

	{
		var src []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(_cret), int(_arg1))

		_utf8s = make([]string, _arg1)
		for i := 0; i < uintptr(_arg1); i++ {
			_utf8s = C.GoString(_cret)
		}
	}

	return _utf8s
}

// Size determines the number of bytes that would be required to store @value
// with g_variant_store().
//
// If @value has a fixed-sized type then this function always returned that
// fixed size.
//
// In the case that @value is already in serialised form or the size has already
// been calculated (ie: this function has been called before) then this function
// is O(1). Otherwise, the size is calculated, an operation which is
// approximately O(n) in the number of values involved.
func (v *Variant) Size() uint {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	var _cret C.gsize

	cret = C.g_variant_get_size(_arg0)

	var _gsize uint

	_gsize = (uint)(_cret)

	return _gsize
}

// String returns the string value of a #GVariant instance with a string type.
// This includes the types G_VARIANT_TYPE_STRING, G_VARIANT_TYPE_OBJECT_PATH and
// G_VARIANT_TYPE_SIGNATURE.
//
// The string will always be UTF-8 encoded, will never be nil, and will never
// contain nul bytes.
//
// If @length is non-nil then the length of the string (in bytes) is returned
// there. For trusted values, this information is already known. Untrusted
// values will be validated and, if valid, a strlen() will be performed. If
// invalid, a default value will be returned — for G_VARIANT_TYPE_OBJECT_PATH,
// this is `"/"`, and for other types it is the empty string.
//
// It is an error to call this function with a @value of any type other than
// those three.
//
// The return value remains valid as long as @value exists.
func (v *Variant) String() (uint, string) {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	var _arg1 C.gsize
	var _cret *C.gchar

	cret = C.g_variant_get_string(_arg0, &_arg1)

	var _length uint
	var _utf8 string

	_length = (uint)(_arg1)
	_utf8 = C.GoString(_cret)

	return _length, _utf8
}

// Strv gets the contents of an array of strings #GVariant. This call makes a
// shallow copy; the return result should be released with g_free(), but the
// individual strings must not be modified.
//
// If @length is non-nil then the number of elements in the result is stored
// there. In any case, the resulting array will be nil-terminated.
//
// For an empty array, @length will be set to 0 and a pointer to a nil pointer
// will be returned.
func (v *Variant) Strv() []string {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	var _cret **C.gchar
	var _arg1 *C.gsize

	cret = C.g_variant_get_strv(_arg0)

	var _utf8s []string

	{
		var src []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(_cret), int(_arg1))

		_utf8s = make([]string, _arg1)
		for i := 0; i < uintptr(_arg1); i++ {
			_utf8s = C.GoString(_cret)
		}
	}

	return _utf8s
}

// Type determines the type of @value.
//
// The return value is valid for the lifetime of @value and must not be freed.
func (v *Variant) Type() *VariantType {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	var _cret *C.GVariantType

	cret = C.g_variant_get_type(_arg0)

	var _variantType *VariantType

	_variantType = WrapVariantType(unsafe.Pointer(_cret))

	return _variantType
}

// TypeString returns the type string of @value. Unlike the result of calling
// g_variant_type_peek_string(), this string is nul-terminated. This string
// belongs to #GVariant and must not be freed.
func (v *Variant) TypeString() string {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	var _cret *C.gchar

	cret = C.g_variant_get_type_string(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Uint16 returns the 16-bit unsigned integer value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_UINT16.
func (v *Variant) Uint16() uint16 {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	var _cret C.guint16

	cret = C.g_variant_get_uint16(_arg0)

	var _guint16 uint16

	_guint16 = (uint16)(_cret)

	return _guint16
}

// Uint32 returns the 32-bit unsigned integer value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_UINT32.
func (v *Variant) Uint32() uint32 {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	var _cret C.guint32

	cret = C.g_variant_get_uint32(_arg0)

	var _guint32 uint32

	_guint32 = (uint32)(_cret)

	return _guint32
}

// Uint64 returns the 64-bit unsigned integer value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_UINT64.
func (v *Variant) Uint64() uint64 {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	var _cret C.guint64

	cret = C.g_variant_get_uint64(_arg0)

	var _guint64 uint64

	_guint64 = (uint64)(_cret)

	return _guint64
}

// Variant unboxes @value. The result is the #GVariant instance that was
// contained in @value.
func (v *Variant) Variant() *Variant {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	var _cret *C.GVariant

	cret = C.g_variant_get_variant(_arg0)

	var _variant *Variant

	_variant = WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

// Hash generates a hash value for a #GVariant instance.
//
// The output of this function is guaranteed to be the same for a given value
// only per-process. It may change between different processor architectures or
// even different versions of GLib. Do not use this function as a basis for
// building protocols or file formats.
//
// The type of @value is #gconstpointer only to allow use of this function with
// Table. @value must be a #GVariant.
func (v *Variant) Hash() uint {
	var _arg0 C.gpointer

	_arg0 = (C.gpointer)(unsafe.Pointer(v.Native()))

	var _cret C.guint

	cret = C.g_variant_hash(_arg0)

	var _guint uint

	_guint = (uint)(_cret)

	return _guint
}

// IsContainer checks if @value is a container.
func (v *Variant) IsContainer() bool {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	var _cret C.gboolean

	cret = C.g_variant_is_container(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// IsFloating checks whether @value has a floating reference count.
//
// This function should only ever be used to assert that a given variant is or
// is not floating, or for debug purposes. To acquire a reference to a variant
// that might be floating, always use g_variant_ref_sink() or
// g_variant_take_ref().
//
// See g_variant_ref_sink() for more information about floating reference
// counts.
func (v *Variant) IsFloating() bool {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	var _cret C.gboolean

	cret = C.g_variant_is_floating(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// IsNormalForm checks if @value is in normal form.
//
// The main reason to do this is to detect if a given chunk of serialised data
// is in normal form: load the data into a #GVariant using
// g_variant_new_from_data() and then use this function to check.
//
// If @value is found to be in normal form then it will be marked as being
// trusted. If the value was already marked as being trusted then this function
// will immediately return true.
//
// There may be implementation specific restrictions on deeply nested values.
// GVariant is guaranteed to handle nesting up to at least 64 levels.
func (v *Variant) IsNormalForm() bool {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	var _cret C.gboolean

	cret = C.g_variant_is_normal_form(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// IsOfType checks if a value has a type matching the provided type.
func (v *Variant) IsOfType(typ *VariantType) bool {
	var _arg0 *C.GVariant
	var _arg1 *C.GVariantType

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.GVariantType)(unsafe.Pointer(typ.Native()))

	var _cret C.gboolean

	cret = C.g_variant_is_of_type(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// NewIter creates a heap-allocated Iter for iterating over the items in @value.
//
// Use g_variant_iter_free() to free the return value when you no longer need
// it.
//
// A reference is taken to @value and will be released only when
// g_variant_iter_free() is called.
func (v *Variant) NewIter() *VariantIter {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	var _cret *C.GVariantIter

	cret = C.g_variant_iter_new(_arg0)

	var _variantIter *VariantIter

	_variantIter = WrapVariantIter(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variantIter, func(v *VariantIter) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variantIter
}

// LookupValue looks up a value in a dictionary #GVariant.
//
// This function works with dictionaries of the type a{s*} (and equally well
// with type a{o*}, but we only further discuss the string case for sake of
// clarity).
//
// In the event that @dictionary has the type a{sv}, the @expected_type string
// specifies what type of value is expected to be inside of the variant. If the
// value inside the variant has a different type then nil is returned. In the
// event that @dictionary has a value type other than v then @expected_type must
// directly match the value type and it is used to unpack the value directly or
// an error occurs.
//
// In either case, if @key is not found in @dictionary, nil is returned.
//
// If the key is found and the value has the correct type, it is returned. If
// @expected_type was specified then any non-nil return value will have this
// type.
//
// This function is currently implemented with a linear scan. If you plan to do
// many lookups then Dict may be more efficient.
func (d *Variant) LookupValue(key string, expectedType *VariantType) *Variant {
	var _arg0 *C.GVariant
	var _arg1 *C.gchar
	var _arg2 *C.GVariantType

	_arg0 = (*C.GVariant)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariantType)(unsafe.Pointer(expectedType.Native()))

	var _cret *C.GVariant

	cret = C.g_variant_lookup_value(_arg0, _arg1, _arg2)

	var _variant *Variant

	_variant = WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

// NChildren determines the number of children in a container #GVariant
// instance. This includes variants, maybes, arrays, tuples and dictionary
// entries. It is an error to call this function on any other type of #GVariant.
//
// For variants, the return value is always 1. For values with maybe types, it
// is always zero or one. For arrays, it is the length of the array. For tuples
// it is the number of tuple items (which depends only on the type). For
// dictionary entries, it is always 2
//
// This function is O(1).
func (v *Variant) NChildren() uint {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	var _cret C.gsize

	cret = C.g_variant_n_children(_arg0)

	var _gsize uint

	_gsize = (uint)(_cret)

	return _gsize
}

// Print pretty-prints @value in the format understood by g_variant_parse().
//
// The format is described [here][gvariant-text].
//
// If @type_annotate is true, then type information is included in the output.
func (v *Variant) Print(typeAnnotate bool) string {
	var _arg0 *C.GVariant
	var _arg1 C.gboolean

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))
	if typeAnnotate {
		_arg1 = C.gboolean(1)
	}

	var _cret *C.gchar

	cret = C.g_variant_print(_arg0, _arg1)

	var _utf8 string

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// PrintString behaves as g_variant_print(), but operates on a #GString.
//
// If @string is non-nil then it is appended to and returned. Else, a new empty
// #GString is allocated and it is returned.
func (v *Variant) PrintString(string *String, typeAnnotate bool) *String {
	var _arg0 *C.GVariant
	var _arg1 *C.GString
	var _arg2 C.gboolean

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.GString)(unsafe.Pointer(string.Native()))
	if typeAnnotate {
		_arg2 = C.gboolean(1)
	}

	var _cret *C.GString

	cret = C.g_variant_print_string(_arg0, _arg1, _arg2)

	var _ret *String

	_ret = WrapString(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_ret, func(v *String) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _ret
}

// Ref increases the reference count of @value.
func (v *Variant) Ref() *Variant {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	var _cret *C.GVariant

	cret = C.g_variant_ref(_arg0)

	var _variant *Variant

	_variant = WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

// RefSink uses a floating reference count system. All functions with names
// starting with `g_variant_new_` return floating references.
//
// Calling g_variant_ref_sink() on a #GVariant with a floating reference will
// convert the floating reference into a full reference. Calling
// g_variant_ref_sink() on a non-floating #GVariant results in an additional
// normal reference being added.
//
// In other words, if the @value is floating, then this call "assumes ownership"
// of the floating reference, converting it to a normal reference. If the @value
// is not floating, then this call adds a new normal reference increasing the
// reference count by one.
//
// All calls that result in a #GVariant instance being inserted into a container
// will call g_variant_ref_sink() on the instance. This means that if the value
// was just created (and has only its floating reference) then the container
// will assume sole ownership of the value at that point and the caller will not
// need to unreference it. This makes certain common styles of programming much
// easier while still maintaining normal refcounting semantics in situations
// where values are not floating.
func (v *Variant) RefSink() *Variant {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	var _cret *C.GVariant

	cret = C.g_variant_ref_sink(_arg0)

	var _variant *Variant

	_variant = WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

// Store stores the serialised form of @value at @data. @data should be large
// enough. See g_variant_get_size().
//
// The stored data is in machine native byte order but may not be in
// fully-normalised form if read from an untrusted source. See
// g_variant_get_normal_form() for a solution.
//
// As with g_variant_get_data(), to be able to deserialise the serialised
// variant successfully, its type and (if the destination machine might be
// different) its endianness must also be available.
//
// This function is approximately O(n) in the size of @data.
func (v *Variant) Store(data interface{}) {
	var _arg0 *C.GVariant
	var _arg1 C.gpointer

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))
	_arg1 = C.gpointer(data)

	C.g_variant_store(_arg0, _arg1)
}

// TakeRef: if @value is floating, sink it. Otherwise, do nothing.
//
// Typically you want to use g_variant_ref_sink() in order to automatically do
// the correct thing with respect to floating or non-floating references, but
// there is one specific scenario where this function is helpful.
//
// The situation where this function is helpful is when creating an API that
// allows the user to provide a callback function that returns a #GVariant. We
// certainly want to allow the user the flexibility to return a non-floating
// reference from this callback (for the case where the value that is being
// returned already exists).
//
// At the same time, the style of the #GVariant API makes it likely that for
// newly-created #GVariant instances, the user can be saved some typing if they
// are allowed to return a #GVariant with a floating reference.
//
// Using this function on the return value of the user's callback allows the
// user to do whichever is more convenient for them. The caller will always
// receives exactly one full reference to the value: either the one that was
// returned in the first place, or a floating reference that has been converted
// to a full reference.
//
// This function has an odd interaction when combined with g_variant_ref_sink()
// running at the same time in another thread on the same #GVariant instance. If
// g_variant_ref_sink() runs first then the result will be that the floating
// reference is converted to a hard reference. If g_variant_take_ref() runs
// first then the result will be that the floating reference is converted to a
// hard reference and an additional reference on top of that one is added. It is
// best to avoid this situation.
func (v *Variant) TakeRef() *Variant {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	var _cret *C.GVariant

	cret = C.g_variant_take_ref(_arg0)

	var _variant *Variant

	_variant = WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

// Unref decreases the reference count of @value. When its reference count drops
// to 0, the memory used by the variant is freed.
func (v *Variant) Unref() {
	var _arg0 *C.GVariant

	_arg0 = (*C.GVariant)(unsafe.Pointer(v.Native()))

	C.g_variant_unref(_arg0)
}

// VariantBuilder: a utility type for constructing container-type #GVariant
// instances.
//
// This is an opaque structure and may only be accessed using the following
// functions.
//
// Builder is not threadsafe in any way. Do not attempt to access it from more
// than one thread.
type VariantBuilder struct {
	native C.GVariantBuilder
}

// WrapVariantBuilder wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapVariantBuilder(ptr unsafe.Pointer) *VariantBuilder {
	if ptr == nil {
		return nil
	}

	return (*VariantBuilder)(ptr)
}

func marshalVariantBuilder(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapVariantBuilder(unsafe.Pointer(b)), nil
}

// NewVariantBuilder constructs a struct VariantBuilder.
func NewVariantBuilder(typ *VariantType) *VariantBuilder {
	var _arg1 *C.GVariantType

	_arg1 = (*C.GVariantType)(unsafe.Pointer(typ.Native()))

	var _cret *C.GVariantBuilder

	cret = C.g_variant_builder_new(_arg1)

	var _variantBuilder *VariantBuilder

	_variantBuilder = WrapVariantBuilder(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variantBuilder, func(v *VariantBuilder) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variantBuilder
}

// Native returns the underlying C source pointer.
func (v *VariantBuilder) Native() unsafe.Pointer {
	return unsafe.Pointer(&v.native)
}

// AddValue adds @value to @builder.
//
// It is an error to call this function in any way that would create an
// inconsistent value to be constructed. Some examples of this are putting
// different types of items into an array, putting the wrong types or number of
// items in a tuple, putting more than one value into a variant, etc.
//
// If @value is a floating reference (see g_variant_ref_sink()), the @builder
// instance takes ownership of @value.
func (b *VariantBuilder) AddValue(value *Variant) {
	var _arg0 *C.GVariantBuilder
	var _arg1 *C.GVariant

	_arg0 = (*C.GVariantBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	C.g_variant_builder_add_value(_arg0, _arg1)
}

// Clear releases all memory associated with a Builder without freeing the
// Builder structure itself.
//
// It typically only makes sense to do this on a stack-allocated Builder if you
// want to abort building the value part-way through. This function need not be
// called if you call g_variant_builder_end() and it also doesn't need to be
// called on builders allocated with g_variant_builder_new() (see
// g_variant_builder_unref() for that).
//
// This function leaves the Builder structure set to all-zeros. It is valid to
// call this function on either an initialised Builder or one that is set to
// all-zeros but it is not valid to call this function on uninitialised memory.
func (b *VariantBuilder) Clear() {
	var _arg0 *C.GVariantBuilder

	_arg0 = (*C.GVariantBuilder)(unsafe.Pointer(b.Native()))

	C.g_variant_builder_clear(_arg0)
}

// Close closes the subcontainer inside the given @builder that was opened by
// the most recent call to g_variant_builder_open().
//
// It is an error to call this function in any way that would create an
// inconsistent value to be constructed (ie: too few values added to the
// subcontainer).
func (b *VariantBuilder) Close() {
	var _arg0 *C.GVariantBuilder

	_arg0 = (*C.GVariantBuilder)(unsafe.Pointer(b.Native()))

	C.g_variant_builder_close(_arg0)
}

// End ends the builder process and returns the constructed value.
//
// It is not permissible to use @builder in any way after this call except for
// reference counting operations (in the case of a heap-allocated Builder) or by
// reinitialising it with g_variant_builder_init() (in the case of
// stack-allocated). This means that for the stack-allocated builders there is
// no need to call g_variant_builder_clear() after the call to
// g_variant_builder_end().
//
// It is an error to call this function in any way that would create an
// inconsistent value to be constructed (ie: insufficient number of items added
// to a container with a specific number of children required). It is also an
// error to call this function if the builder was created with an indefinite
// array or maybe type and no children have been added; in this case it is
// impossible to infer the type of the empty array.
func (b *VariantBuilder) End() *Variant {
	var _arg0 *C.GVariantBuilder

	_arg0 = (*C.GVariantBuilder)(unsafe.Pointer(b.Native()))

	var _cret *C.GVariant

	cret = C.g_variant_builder_end(_arg0)

	var _variant *Variant

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// Init initialises a Builder structure.
//
// @type must be non-nil. It specifies the type of container to construct. It
// can be an indefinite type such as G_VARIANT_TYPE_ARRAY or a definite type
// such as "as" or "(ii)". Maybe, array, tuple, dictionary entry and
// variant-typed values may be constructed.
//
// After the builder is initialised, values are added using
// g_variant_builder_add_value() or g_variant_builder_add().
//
// After all the child values are added, g_variant_builder_end() frees the
// memory associated with the builder and returns the #GVariant that was
// created.
//
// This function completely ignores the previous contents of @builder. On one
// hand this means that it is valid to pass in completely uninitialised memory.
// On the other hand, this means that if you are initialising over top of an
// existing Builder you need to first call g_variant_builder_clear() in order to
// avoid leaking memory.
//
// You must not call g_variant_builder_ref() or g_variant_builder_unref() on a
// Builder that was initialised with this function. If you ever pass a reference
// to a Builder outside of the control of your own code then you should assume
// that the person receiving that reference may try to use reference counting;
// you should use g_variant_builder_new() instead of this function.
func (b *VariantBuilder) Init(typ *VariantType) {
	var _arg0 *C.GVariantBuilder
	var _arg1 *C.GVariantType

	_arg0 = (*C.GVariantBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GVariantType)(unsafe.Pointer(typ.Native()))

	C.g_variant_builder_init(_arg0, _arg1)
}

// Open opens a subcontainer inside the given @builder. When done adding items
// to the subcontainer, g_variant_builder_close() must be called. @type is the
// type of the container: so to build a tuple of several values, @type must
// include the tuple itself.
//
// It is an error to call this function in any way that would cause an
// inconsistent value to be constructed (ie: adding too many values or a value
// of an incorrect type).
//
// Example of building a nested variant:
//
//    GVariantBuilder builder;
//    guint32 some_number = get_number ();
//    g_autoptr (GHashTable) some_dict = get_dict ();
//    GHashTableIter iter;
//    const gchar *key;
//    const GVariant *value;
//    g_autoptr (GVariant) output = NULL;
//
//    g_variant_builder_init (&builder, G_VARIANT_TYPE ("(ua{sv})"));
//    g_variant_builder_add (&builder, "u", some_number);
//    g_variant_builder_open (&builder, G_VARIANT_TYPE ("a{sv}"));
//
//    g_hash_table_iter_init (&iter, some_dict);
//    while (g_hash_table_iter_next (&iter, (gpointer *) &key, (gpointer *) &value))
//      {
//        g_variant_builder_open (&builder, G_VARIANT_TYPE ("{sv}"));
//        g_variant_builder_add (&builder, "s", key);
//        g_variant_builder_add (&builder, "v", value);
//        g_variant_builder_close (&builder);
//      }
//
//    g_variant_builder_close (&builder);
//
//    output = g_variant_builder_end (&builder);
func (b *VariantBuilder) Open(typ *VariantType) {
	var _arg0 *C.GVariantBuilder
	var _arg1 *C.GVariantType

	_arg0 = (*C.GVariantBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GVariantType)(unsafe.Pointer(typ.Native()))

	C.g_variant_builder_open(_arg0, _arg1)
}

// Ref increases the reference count on @builder.
//
// Don't call this on stack-allocated Builder instances or bad things will
// happen.
func (b *VariantBuilder) Ref() *VariantBuilder {
	var _arg0 *C.GVariantBuilder

	_arg0 = (*C.GVariantBuilder)(unsafe.Pointer(b.Native()))

	var _cret *C.GVariantBuilder

	cret = C.g_variant_builder_ref(_arg0)

	var _variantBuilder *VariantBuilder

	_variantBuilder = WrapVariantBuilder(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variantBuilder, func(v *VariantBuilder) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variantBuilder
}

// Unref decreases the reference count on @builder.
//
// In the event that there are no more references, releases all memory
// associated with the Builder.
//
// Don't call this on stack-allocated Builder instances or bad things will
// happen.
func (b *VariantBuilder) Unref() {
	var _arg0 *C.GVariantBuilder

	_arg0 = (*C.GVariantBuilder)(unsafe.Pointer(b.Native()))

	C.g_variant_builder_unref(_arg0)
}

// VariantDict is a mutable interface to #GVariant dictionaries.
//
// It can be used for doing a sequence of dictionary lookups in an efficient way
// on an existing #GVariant dictionary or it can be used to construct new
// dictionaries with a hashtable-like interface. It can also be used for taking
// existing dictionaries and modifying them in order to create new ones.
//
// Dict can only be used with G_VARIANT_TYPE_VARDICT dictionaries.
//
// It is possible to use Dict allocated on the stack or on the heap. When using
// a stack-allocated Dict, you begin with a call to g_variant_dict_init() and
// free the resources with a call to g_variant_dict_clear().
//
// Heap-allocated Dict follows normal refcounting rules: you allocate it with
// g_variant_dict_new() and use g_variant_dict_ref() and g_variant_dict_unref().
//
// g_variant_dict_end() is used to convert the Dict back into a dictionary-type
// #GVariant. When used with stack-allocated instances, this also implicitly
// frees all associated memory, but for heap-allocated instances, you must still
// call g_variant_dict_unref() afterwards.
//
// You will typically want to use a heap-allocated Dict when you expose it as
// part of an API. For most other uses, the stack-allocated form will be more
// convenient.
//
// Consider the following two examples that do the same thing in each style:
// take an existing dictionary and look up the "count" uint32 key, adding 1 to
// it if it is found, or returning an error if the key is not found. Each
// returns the new dictionary as a floating #GVariant.
//
// Using a stack-allocated GVariantDict
//
//      GVariant *
//      add_to_count (GVariant  *orig,
//                    GError   **error)
//      {
//        GVariantDict *dict;
//        GVariant *result;
//        guint32 count;
//
//        dict = g_variant_dict_new (orig);
//
//        if (g_variant_dict_lookup (dict, "count", "u", &count))
//          {
//            g_variant_dict_insert (dict, "count", "u", count + 1);
//            result = g_variant_dict_end (dict);
//          }
//        else
//          {
//            g_set_error (...);
//            result = NULL;
//          }
//
//        g_variant_dict_unref (dict);
//
//        return result;
//      }
type VariantDict struct {
	native C.GVariantDict
}

// WrapVariantDict wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapVariantDict(ptr unsafe.Pointer) *VariantDict {
	if ptr == nil {
		return nil
	}

	return (*VariantDict)(ptr)
}

func marshalVariantDict(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapVariantDict(unsafe.Pointer(b)), nil
}

// NewVariantDict constructs a struct VariantDict.
func NewVariantDict(fromAsv *Variant) *VariantDict {
	var _arg1 *C.GVariant

	_arg1 = (*C.GVariant)(unsafe.Pointer(fromAsv.Native()))

	var _cret *C.GVariantDict

	cret = C.g_variant_dict_new(_arg1)

	var _variantDict *VariantDict

	_variantDict = WrapVariantDict(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variantDict, func(v *VariantDict) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variantDict
}

// Native returns the underlying C source pointer.
func (v *VariantDict) Native() unsafe.Pointer {
	return unsafe.Pointer(&v.native)
}

// Clear releases all memory associated with a Dict without freeing the Dict
// structure itself.
//
// It typically only makes sense to do this on a stack-allocated Dict if you
// want to abort building the value part-way through. This function need not be
// called if you call g_variant_dict_end() and it also doesn't need to be called
// on dicts allocated with g_variant_dict_new (see g_variant_dict_unref() for
// that).
//
// It is valid to call this function on either an initialised Dict or one that
// was previously cleared by an earlier call to g_variant_dict_clear() but it is
// not valid to call this function on uninitialised memory.
func (d *VariantDict) Clear() {
	var _arg0 *C.GVariantDict

	_arg0 = (*C.GVariantDict)(unsafe.Pointer(d.Native()))

	C.g_variant_dict_clear(_arg0)
}

// Contains checks if @key exists in @dict.
func (d *VariantDict) Contains(key string) bool {
	var _arg0 *C.GVariantDict
	var _arg1 *C.gchar

	_arg0 = (*C.GVariantDict)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret C.gboolean

	cret = C.g_variant_dict_contains(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// End returns the current value of @dict as a #GVariant of type
// G_VARIANT_TYPE_VARDICT, clearing it in the process.
//
// It is not permissible to use @dict in any way after this call except for
// reference counting operations (in the case of a heap-allocated Dict) or by
// reinitialising it with g_variant_dict_init() (in the case of
// stack-allocated).
func (d *VariantDict) End() *Variant {
	var _arg0 *C.GVariantDict

	_arg0 = (*C.GVariantDict)(unsafe.Pointer(d.Native()))

	var _cret *C.GVariant

	cret = C.g_variant_dict_end(_arg0)

	var _variant *Variant

	_variant = WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// Init initialises a Dict structure.
//
// If @from_asv is given, it is used to initialise the dictionary.
//
// This function completely ignores the previous contents of @dict. On one hand
// this means that it is valid to pass in completely uninitialised memory. On
// the other hand, this means that if you are initialising over top of an
// existing Dict you need to first call g_variant_dict_clear() in order to avoid
// leaking memory.
//
// You must not call g_variant_dict_ref() or g_variant_dict_unref() on a Dict
// that was initialised with this function. If you ever pass a reference to a
// Dict outside of the control of your own code then you should assume that the
// person receiving that reference may try to use reference counting; you should
// use g_variant_dict_new() instead of this function.
func (d *VariantDict) Init(fromAsv *Variant) {
	var _arg0 *C.GVariantDict
	var _arg1 *C.GVariant

	_arg0 = (*C.GVariantDict)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.GVariant)(unsafe.Pointer(fromAsv.Native()))

	C.g_variant_dict_init(_arg0, _arg1)
}

// InsertValue inserts (or replaces) a key in a Dict.
//
// @value is consumed if it is floating.
func (d *VariantDict) InsertValue(key string, value *Variant) {
	var _arg0 *C.GVariantDict
	var _arg1 *C.gchar
	var _arg2 *C.GVariant

	_arg0 = (*C.GVariantDict)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	C.g_variant_dict_insert_value(_arg0, _arg1, _arg2)
}

// LookupValue looks up a value in a Dict.
//
// If @key is not found in @dictionary, nil is returned.
//
// The @expected_type string specifies what type of value is expected. If the
// value associated with @key has a different type then nil is returned.
//
// If the key is found and the value has the correct type, it is returned. If
// @expected_type was specified then any non-nil return value will have this
// type.
func (d *VariantDict) LookupValue(key string, expectedType *VariantType) *Variant {
	var _arg0 *C.GVariantDict
	var _arg1 *C.gchar
	var _arg2 *C.GVariantType

	_arg0 = (*C.GVariantDict)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariantType)(unsafe.Pointer(expectedType.Native()))

	var _cret *C.GVariant

	cret = C.g_variant_dict_lookup_value(_arg0, _arg1, _arg2)

	var _variant *Variant

	_variant = WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

// Ref increases the reference count on @dict.
//
// Don't call this on stack-allocated Dict instances or bad things will happen.
func (d *VariantDict) Ref() *VariantDict {
	var _arg0 *C.GVariantDict

	_arg0 = (*C.GVariantDict)(unsafe.Pointer(d.Native()))

	var _cret *C.GVariantDict

	cret = C.g_variant_dict_ref(_arg0)

	var _variantDict *VariantDict

	_variantDict = WrapVariantDict(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variantDict, func(v *VariantDict) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variantDict
}

// Remove removes a key and its associated value from a Dict.
func (d *VariantDict) Remove(key string) bool {
	var _arg0 *C.GVariantDict
	var _arg1 *C.gchar

	_arg0 = (*C.GVariantDict)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret C.gboolean

	cret = C.g_variant_dict_remove(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Unref decreases the reference count on @dict.
//
// In the event that there are no more references, releases all memory
// associated with the Dict.
//
// Don't call this on stack-allocated Dict instances or bad things will happen.
func (d *VariantDict) Unref() {
	var _arg0 *C.GVariantDict

	_arg0 = (*C.GVariantDict)(unsafe.Pointer(d.Native()))

	C.g_variant_dict_unref(_arg0)
}

// VariantIter is an opaque data structure and can only be accessed using the
// following functions.
type VariantIter struct {
	native C.GVariantIter
}

// WrapVariantIter wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapVariantIter(ptr unsafe.Pointer) *VariantIter {
	if ptr == nil {
		return nil
	}

	return (*VariantIter)(ptr)
}

func marshalVariantIter(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapVariantIter(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (v *VariantIter) Native() unsafe.Pointer {
	return unsafe.Pointer(&v.native)
}

// Copy creates a new heap-allocated Iter to iterate over the container that was
// being iterated over by @iter. Iteration begins on the new iterator from the
// current position of the old iterator but the two copies are independent past
// that point.
//
// Use g_variant_iter_free() to free the return value when you no longer need
// it.
//
// A reference is taken to the container that @iter is iterating over and will
// be related only when g_variant_iter_free() is called.
func (i *VariantIter) Copy() *VariantIter {
	var _arg0 *C.GVariantIter

	_arg0 = (*C.GVariantIter)(unsafe.Pointer(i.Native()))

	var _cret *C.GVariantIter

	cret = C.g_variant_iter_copy(_arg0)

	var _variantIter *VariantIter

	_variantIter = WrapVariantIter(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variantIter, func(v *VariantIter) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variantIter
}

// Free frees a heap-allocated Iter. Only call this function on iterators that
// were returned by g_variant_iter_new() or g_variant_iter_copy().
func (i *VariantIter) Free() {
	var _arg0 *C.GVariantIter

	_arg0 = (*C.GVariantIter)(unsafe.Pointer(i.Native()))

	C.g_variant_iter_free(_arg0)
}

// Init initialises (without allocating) a Iter. @iter may be completely
// uninitialised prior to this call; its old value is ignored.
//
// The iterator remains valid for as long as @value exists, and need not be
// freed in any way.
func (i *VariantIter) Init(value *Variant) uint {
	var _arg0 *C.GVariantIter
	var _arg1 *C.GVariant

	_arg0 = (*C.GVariantIter)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	var _cret C.gsize

	cret = C.g_variant_iter_init(_arg0, _arg1)

	var _gsize uint

	_gsize = (uint)(_cret)

	return _gsize
}

// NChildren queries the number of child items in the container that we are
// iterating over. This is the total number of items -- not the number of items
// remaining.
//
// This function might be useful for preallocation of arrays.
func (i *VariantIter) NChildren() uint {
	var _arg0 *C.GVariantIter

	_arg0 = (*C.GVariantIter)(unsafe.Pointer(i.Native()))

	var _cret C.gsize

	cret = C.g_variant_iter_n_children(_arg0)

	var _gsize uint

	_gsize = (uint)(_cret)

	return _gsize
}

// NextValue gets the next item in the container. If no more items remain then
// nil is returned.
//
// Use g_variant_unref() to drop your reference on the return value when you no
// longer need it.
//
// Here is an example for iterating with g_variant_iter_next_value():
//
//      // recursively iterate a container
//      void
//      iterate_container_recursive (GVariant *container)
//      {
//        GVariantIter iter;
//        GVariant *child;
//
//        g_variant_iter_init (&iter, container);
//        while ((child = g_variant_iter_next_value (&iter)))
//          {
//            g_print ("type 's'\n", g_variant_get_type_string (child));
//
//            if (g_variant_is_container (child))
//              iterate_container_recursive (child);
//
//            g_variant_unref (child);
//          }
//      }
func (i *VariantIter) NextValue() *Variant {
	var _arg0 *C.GVariantIter

	_arg0 = (*C.GVariantIter)(unsafe.Pointer(i.Native()))

	var _cret *C.GVariant

	cret = C.g_variant_iter_next_value(_arg0)

	var _variant *Variant

	_variant = WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}
