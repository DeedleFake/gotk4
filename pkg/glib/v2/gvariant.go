// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/box"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <glib.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_variant_builder_get_type()), F: marshalVariantBuilder},
		{T: externglib.Type(C.g_variant_dict_get_type()), F: marshalVariantDict},
	})
}

// VariantClass: the range of possible top-level types of #GVariant instances.
type VariantClass int

const (
	// Boolean: the #GVariant is a boolean.
	VariantClassBoolean VariantClass = 98
	// Byte: the #GVariant is a byte.
	VariantClassByte VariantClass = 121
	// Int16: the #GVariant is a signed 16 bit integer.
	VariantClassInt16 VariantClass = 110
	// Uint16: the #GVariant is an unsigned 16 bit integer.
	VariantClassUint16 VariantClass = 113
	// Int32: the #GVariant is a signed 32 bit integer.
	VariantClassInt32 VariantClass = 105
	// Uint32: the #GVariant is an unsigned 32 bit integer.
	VariantClassUint32 VariantClass = 117
	// Int64: the #GVariant is a signed 64 bit integer.
	VariantClassInt64 VariantClass = 120
	// Uint64: the #GVariant is an unsigned 64 bit integer.
	VariantClassUint64 VariantClass = 116
	// Handle: the #GVariant is a file handle index.
	VariantClassHandle VariantClass = 104
	// Double: the #GVariant is a double precision floating point value.
	VariantClassDouble VariantClass = 100
	// String: the #GVariant is a normal string.
	VariantClassString VariantClass = 115
	// ObjectPath: the #GVariant is a D-Bus object path string.
	VariantClassObjectPath VariantClass = 111
	// Signature: the #GVariant is a D-Bus signature string.
	VariantClassSignature VariantClass = 103
	// Variant: the #GVariant is a variant.
	VariantClassVariant VariantClass = 118
	// Maybe: the #GVariant is a maybe-typed value.
	VariantClassMaybe VariantClass = 109
	// Array: the #GVariant is an array.
	VariantClassArray VariantClass = 97
	// Tuple: the #GVariant is a tuple.
	VariantClassTuple VariantClass = 40
	// DictEntry: the #GVariant is a dictionary entry.
	VariantClassDictEntry VariantClass = 123
)

// VariantParseError: error codes returned by parsing text-format GVariants.
type VariantParseError int

const (
	// Failed: generic error (unused)
	VariantParseErrorFailed VariantParseError = iota
	// BasicTypeExpected: non-basic Type was given where a basic type was
	// expected
	VariantParseErrorBasicTypeExpected
	// CannotInferType: cannot infer the Type
	VariantParseErrorCannotInferType
	// DefiniteTypeExpected: indefinite Type was given where a definite type was
	// expected
	VariantParseErrorDefiniteTypeExpected
	// InputNotAtEnd: extra data after parsing finished
	VariantParseErrorInputNotAtEnd
	// InvalidCharacter: invalid character in number or unicode escape
	VariantParseErrorInvalidCharacter
	// InvalidFormatString: not a valid #GVariant format string
	VariantParseErrorInvalidFormatString
	// InvalidObjectPath: not a valid object path
	VariantParseErrorInvalidObjectPath
	// InvalidSignature: not a valid type signature
	VariantParseErrorInvalidSignature
	// InvalidTypeString: not a valid #GVariant type string
	VariantParseErrorInvalidTypeString
	// NoCommonType: could not find a common type for array entries
	VariantParseErrorNoCommonType
	// NumberOutOfRange: the numerical value is out of range of the given type
	VariantParseErrorNumberOutOfRange
	// NumberTooBig: the numerical value is out of range for any type
	VariantParseErrorNumberTooBig
	// TypeError: cannot parse as variant of the specified type
	VariantParseErrorTypeError
	// UnexpectedToken: unexpected token was encountered
	VariantParseErrorUnexpectedToken
	// UnknownKeyword: unknown keyword was encountered
	VariantParseErrorUnknownKeyword
	// UnterminatedStringConstant: unterminated string constant
	VariantParseErrorUnterminatedStringConstant
	// ValueExpected: no value given
	VariantParseErrorValueExpected
	// Recursion: variant was too deeply nested; #GVariant is only guaranteed to
	// handle nesting up to 64 levels (Since: 2.64)
	VariantParseErrorRecursion
)

// Variant is a variant datatype; it can contain one or more values along with
// information about the type of the values.
//
// A #GVariant may contain simple types, like an integer, or a boolean value; or
// complex types, like an array of two strings, or a dictionary of key value
// pairs. A #GVariant is also immutable: once it's been created neither its type
// nor its content can be modified further.
//
// GVariant is useful whenever data needs to be serialized, for example when
// sending method parameters in D-Bus, or when saving settings using GSettings.
//
// When creating a new #GVariant, you pass the data you want to store in it
// along with a string representing the type of data you wish to pass to it.
//
// For instance, if you want to create a #GVariant holding an integer value you
// can use:
//
//    GVariant *v = g_variant_new ("u", 40);
//
// The string "u" in the first argument tells #GVariant that the data passed to
// the constructor (40) is going to be an unsigned integer.
//
// More advanced examples of #GVariant in use can be found in documentation for
// [GVariant format strings][gvariant-format-strings-pointers].
//
// The range of possible values is determined by the type.
//
// The type system used by #GVariant is Type.
//
// #GVariant instances always have a type and a value (which are given at
// construction time). The type and value of a #GVariant instance can never
// change other than by the #GVariant itself being destroyed. A #GVariant cannot
// contain a pointer.
//
// #GVariant is reference counted using g_variant_ref() and g_variant_unref().
// #GVariant also has floating reference counts -- see g_variant_ref_sink().
//
// #GVariant is completely threadsafe. A #GVariant instance can be concurrently
// accessed in any way from any number of threads without problems.
//
// #GVariant is heavily optimised for dealing with data in serialised form. It
// works particularly well with data located in memory-mapped files. It can
// perform nearly all deserialisation operations in a small constant time,
// usually touching only a single memory page. Serialised #GVariant data can
// also be sent over the network.
//
// #GVariant is largely compatible with D-Bus. Almost all types of #GVariant
// instances can be sent over D-Bus. See Type for exceptions. (However,
// #GVariant's serialisation format is not the same as the serialisation format
// of a D-Bus message body: use BusMessage, in the gio library, for those.)
//
// For space-efficiency, the #GVariant serialisation format does not
// automatically include the variant's length, type or endianness, which must
// either be implied from context (such as knowledge that a particular file
// format always contains a little-endian G_VARIANT_TYPE_VARIANT which occupies
// the whole length of the file) or supplied out-of-band (for instance, a
// length, type and/or endianness indicator could be placed at the beginning of
// a file, network message or network stream).
//
// A #GVariant's size is limited mainly by any lower level operating system
// constraints, such as the number of bits in #gsize. For example, it is
// reasonable to have a 2GB file mapped into memory with File, and call
// g_variant_new_from_data() on it.
//
// For convenience to C programmers, #GVariant features powerful varargs-based
// value construction and destruction. This feature is designed to be embedded
// in other libraries.
//
// There is a Python-inspired text language for describing #GVariant values.
// #GVariant includes a printer for this language and a parser with type
// inferencing.
//
//
// Memory Use
//
// #GVariant tries to be quite efficient with respect to memory use. This
// section gives a rough idea of how much memory is used by the current
// implementation. The information here is subject to change in the future.
//
// The memory allocated by #GVariant can be grouped into 4 broad purposes:
// memory for serialised data, memory for the type information cache, buffer
// management memory and memory for the #GVariant structure itself.
//
//
// Serialised Data Memory
//
// This is the memory that is used for storing GVariant data in serialised form.
// This is what would be sent over the network or what would end up on disk, not
// counting any indicator of the endianness, or of the length or type of the
// top-level variant.
//
// The amount of memory required to store a boolean is 1 byte. 16, 32 and 64 bit
// integers and double precision floating point numbers use their "natural"
// size. Strings (including object path and signature strings) are stored with a
// nul terminator, and as such use the length of the string plus 1 byte.
//
// Maybe types use no space at all to represent the null value and use the same
// amount of space (sometimes plus one byte) as the equivalent non-maybe-typed
// value to represent the non-null case.
//
// Arrays use the amount of space required to store each of their members,
// concatenated. Additionally, if the items stored in an array are not of a
// fixed-size (ie: strings, other arrays, etc) then an additional framing offset
// is stored for each item. The size of this offset is either 1, 2 or 4 bytes
// depending on the overall size of the container. Additionally, extra padding
// bytes are added as required for alignment of child values.
//
// Tuples (including dictionary entries) use the amount of space required to
// store each of their members, concatenated, plus one framing offset (as per
// arrays) for each non-fixed-sized item in the tuple, except for the last one.
// Additionally, extra padding bytes are added as required for alignment of
// child values.
//
// Variants use the same amount of space as the item inside of the variant, plus
// 1 byte, plus the length of the type string for the item inside the variant.
//
// As an example, consider a dictionary mapping strings to variants. In the case
// that the dictionary is empty, 0 bytes are required for the serialisation.
//
// If we add an item "width" that maps to the int32 value of 500 then we will
// use 4 byte to store the int32 (so 6 for the variant containing it) and 6
// bytes for the string. The variant must be aligned to 8 after the 6 bytes of
// the string, so that's 2 extra bytes. 6 (string) + 2 (padding) + 6 (variant)
// is 14 bytes used for the dictionary entry. An additional 1 byte is added to
// the array as a framing offset making a total of 15 bytes.
//
// If we add another entry, "title" that maps to a nullable string that happens
// to have a value of null, then we use 0 bytes for the null value (and 3 bytes
// for the variant to contain it along with its type string) plus 6 bytes for
// the string. Again, we need 2 padding bytes. That makes a total of 6 + 2 + 3 =
// 11 bytes.
//
// We now require extra padding between the two items in the array. After the 14
// bytes of the first item, that's 2 bytes required. We now require 2 framing
// offsets for an extra two bytes. 14 + 2 + 11 + 2 = 29 bytes to encode the
// entire two-item dictionary.
//
//
// Type Information Cache
//
// For each GVariant type that currently exists in the program a type
// information structure is kept in the type information cache. The type
// information structure is required for rapid deserialisation.
//
// Continuing with the above example, if a #GVariant exists with the type
// "a{sv}" then a type information struct will exist for "a{sv}", "{sv}", "s",
// and "v". Multiple uses of the same type will share the same type information.
// Additionally, all single-digit types are stored in read-only static memory
// and do not contribute to the writable memory footprint of a program using
// #GVariant.
//
// Aside from the type information structures stored in read-only memory, there
// are two forms of type information. One is used for container types where
// there is a single element type: arrays and maybe types. The other is used for
// container types where there are multiple element types: tuples and dictionary
// entries.
//
// Array type info structures are 6 * sizeof (void *), plus the memory required
// to store the type string itself. This means that on 32-bit systems, the cache
// entry for "a{sv}" would require 30 bytes of memory (plus malloc overhead).
//
// Tuple type info structures are 6 * sizeof (void *), plus 4 * sizeof (void *)
// for each item in the tuple, plus the memory required to store the type string
// itself. A 2-item tuple, for example, would have a type information structure
// that consumed writable memory in the size of 14 * sizeof (void *) (plus type
// string) This means that on 32-bit systems, the cache entry for "{sv}" would
// require 61 bytes of memory (plus malloc overhead).
//
// This means that in total, for our "a{sv}" example, 91 bytes of type
// information would be allocated.
//
// The type information cache, additionally, uses a Table to store and look up
// the cached items and stores a pointer to this hash table in static storage.
// The hash table is freed when there are zero items in the type cache.
//
// Although these sizes may seem large it is important to remember that a
// program will probably only have a very small number of different types of
// values in it and that only one type information structure is required for
// many different values of the same type.
//
//
// Buffer Management Memory
//
// #GVariant uses an internal buffer management structure to deal with the
// various different possible sources of serialised data that it uses. The
// buffer is responsible for ensuring that the correct call is made when the
// data is no longer in use by #GVariant. This may involve a g_free() or a
// g_slice_free() or even g_mapped_file_unref().
//
// One buffer management structure is used for each chunk of serialised data.
// The size of the buffer management structure is 4 * (void *). On 32-bit
// systems, that's 16 bytes.
//
//
// GVariant structure
//
// The size of a #GVariant structure is 6 * (void *). On 32-bit systems, that's
// 24 bytes.
//
// #GVariant structures only exist if they are explicitly created with API
// calls. For example, if a #GVariant is constructed out of serialised data for
// the example given above (with the dictionary) then although there are 9
// individual values that comprise the entire dictionary (two keys, two values,
// two variants containing the values, two dictionary entries, plus the
// dictionary itself), only 1 #GVariant instance exists -- the one referring to
// the dictionary.
//
// If calls are made to start accessing the other values then #GVariant
// instances will exist for those values only for as long as they are in use
// (ie: until you call g_variant_unref()). The type information is shared. The
// serialised data and the buffer management structure for that serialised data
// is shared by the child.
//
//
// Summary
//
// To put the entire example together, for our dictionary mapping strings to
// variants (with two entries, as given above), we are using 91 bytes of memory
// for type information, 29 bytes of memory for the serialised data, 16 bytes
// for buffer management and 24 bytes for the #GVariant instance, or a total of
// 160 bytes, plus malloc overhead. If we were to use
// g_variant_get_child_value() to access the two dictionary entries, we would
// use an additional 48 bytes. If we were to have other dictionaries of the same
// type, we would use more memory for the serialised data and buffer management
// for those dictionaries, but the type information would be shared.
type Variant struct {
	native C.GVariant
}

func marshalVariant(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*Variant)(unsafe.Pointer(b)), nil
}

// NewVariantArray constructs a struct Variant.
func NewVariantArray(childType *VariantType, children []*Variant) *Variant {
	var _arg1 *C.GVariantType // out
	var _arg2 **C.GVariant
	var _arg3 C.gsize
	var _cret *C.GVariant // in

	_arg1 = (*C.GVariantType)(unsafe.Pointer(childType))
	_arg3 = C.gsize(len(children))
	_arg2 = (**C.GVariant)(unsafe.Pointer(&children[0]))

	_cret = C.g_variant_new_array(_arg1, _arg2, _arg3)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// NewVariantBoolean constructs a struct Variant.
func NewVariantBoolean(value bool) *Variant {
	var _arg1 C.gboolean  // out
	var _cret *C.GVariant // in

	if value {
		_arg1 = C.TRUE
	}

	_cret = C.g_variant_new_boolean(_arg1)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// NewVariantByte constructs a struct Variant.
func NewVariantByte(value byte) *Variant {
	var _arg1 C.guint8    // out
	var _cret *C.GVariant // in

	_arg1 = C.guint8(value)

	_cret = C.g_variant_new_byte(_arg1)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// NewVariantBytestring constructs a struct Variant.
func NewVariantBytestring(_string []byte) *Variant {
	var _arg1 *C.gchar
	var _cret *C.GVariant // in

	_arg1 = (*C.gchar)(unsafe.Pointer(&_string[0]))

	_cret = C.g_variant_new_bytestring(_arg1)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// NewVariantBytestringArray constructs a struct Variant.
func NewVariantBytestringArray(strv []string) *Variant {
	var _arg1 **C.gchar
	var _arg2 C.gssize
	var _cret *C.GVariant // in

	_arg2 = C.gssize(len(strv))
	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(strv)) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(strv))
		for i := range strv {
			out[i] = (*C.gchar)(C.CString(strv[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.g_variant_new_bytestring_array(_arg1, _arg2)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// NewVariantDictEntry constructs a struct Variant.
func NewVariantDictEntry(key *Variant, value *Variant) *Variant {
	var _arg1 *C.GVariant // out
	var _arg2 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg1 = (*C.GVariant)(unsafe.Pointer(key))
	_arg2 = (*C.GVariant)(unsafe.Pointer(value))

	_cret = C.g_variant_new_dict_entry(_arg1, _arg2)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// NewVariantDouble constructs a struct Variant.
func NewVariantDouble(value float64) *Variant {
	var _arg1 C.gdouble   // out
	var _cret *C.GVariant // in

	_arg1 = C.gdouble(value)

	_cret = C.g_variant_new_double(_arg1)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// NewVariantFixedArray constructs a struct Variant.
func NewVariantFixedArray(elementType *VariantType, elements interface{}, nElements uint, elementSize uint) *Variant {
	var _arg1 *C.GVariantType // out
	var _arg2 C.gconstpointer // out
	var _arg3 C.gsize         // out
	var _arg4 C.gsize         // out
	var _cret *C.GVariant     // in

	_arg1 = (*C.GVariantType)(unsafe.Pointer(elementType))
	_arg2 = (C.gconstpointer)(box.Assign(elements))
	_arg3 = C.gsize(nElements)
	_arg4 = C.gsize(elementSize)

	_cret = C.g_variant_new_fixed_array(_arg1, _arg2, _arg3, _arg4)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// NewVariantHandle constructs a struct Variant.
func NewVariantHandle(value int32) *Variant {
	var _arg1 C.gint32    // out
	var _cret *C.GVariant // in

	_arg1 = C.gint32(value)

	_cret = C.g_variant_new_handle(_arg1)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// NewVariantInt16 constructs a struct Variant.
func NewVariantInt16(value int16) *Variant {
	var _arg1 C.gint16    // out
	var _cret *C.GVariant // in

	_arg1 = C.gint16(value)

	_cret = C.g_variant_new_int16(_arg1)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// NewVariantInt32 constructs a struct Variant.
func NewVariantInt32(value int32) *Variant {
	var _arg1 C.gint32    // out
	var _cret *C.GVariant // in

	_arg1 = C.gint32(value)

	_cret = C.g_variant_new_int32(_arg1)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// NewVariantInt64 constructs a struct Variant.
func NewVariantInt64(value int64) *Variant {
	var _arg1 C.gint64    // out
	var _cret *C.GVariant // in

	_arg1 = C.gint64(value)

	_cret = C.g_variant_new_int64(_arg1)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// NewVariantMaybe constructs a struct Variant.
func NewVariantMaybe(childType *VariantType, child *Variant) *Variant {
	var _arg1 *C.GVariantType // out
	var _arg2 *C.GVariant     // out
	var _cret *C.GVariant     // in

	_arg1 = (*C.GVariantType)(unsafe.Pointer(childType))
	_arg2 = (*C.GVariant)(unsafe.Pointer(child))

	_cret = C.g_variant_new_maybe(_arg1, _arg2)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// NewVariantObjectPath constructs a struct Variant.
func NewVariantObjectPath(objectPath string) *Variant {
	var _arg1 *C.gchar    // out
	var _cret *C.GVariant // in

	_arg1 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_variant_new_object_path(_arg1)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// NewVariantObjv constructs a struct Variant.
func NewVariantObjv(strv []string) *Variant {
	var _arg1 **C.gchar
	var _arg2 C.gssize
	var _cret *C.GVariant // in

	_arg2 = C.gssize(len(strv))
	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(strv)) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(strv))
		for i := range strv {
			out[i] = (*C.gchar)(C.CString(strv[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.g_variant_new_objv(_arg1, _arg2)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// NewVariantSignature constructs a struct Variant.
func NewVariantSignature(signature string) *Variant {
	var _arg1 *C.gchar    // out
	var _cret *C.GVariant // in

	_arg1 = (*C.gchar)(C.CString(signature))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_variant_new_signature(_arg1)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// NewVariantString constructs a struct Variant.
func NewVariantString(_string string) *Variant {
	var _arg1 *C.gchar    // out
	var _cret *C.GVariant // in

	_arg1 = (*C.gchar)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_variant_new_string(_arg1)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// NewVariantStrv constructs a struct Variant.
func NewVariantStrv(strv []string) *Variant {
	var _arg1 **C.gchar
	var _arg2 C.gssize
	var _cret *C.GVariant // in

	_arg2 = C.gssize(len(strv))
	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(strv)) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(strv))
		for i := range strv {
			out[i] = (*C.gchar)(C.CString(strv[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.g_variant_new_strv(_arg1, _arg2)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// NewVariantTuple constructs a struct Variant.
func NewVariantTuple(children []*Variant) *Variant {
	var _arg1 **C.GVariant
	var _arg2 C.gsize
	var _cret *C.GVariant // in

	_arg2 = C.gsize(len(children))
	_arg1 = (**C.GVariant)(unsafe.Pointer(&children[0]))

	_cret = C.g_variant_new_tuple(_arg1, _arg2)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// NewVariantUint16 constructs a struct Variant.
func NewVariantUint16(value uint16) *Variant {
	var _arg1 C.guint16   // out
	var _cret *C.GVariant // in

	_arg1 = C.guint16(value)

	_cret = C.g_variant_new_uint16(_arg1)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// NewVariantUint32 constructs a struct Variant.
func NewVariantUint32(value uint32) *Variant {
	var _arg1 C.guint32   // out
	var _cret *C.GVariant // in

	_arg1 = C.guint32(value)

	_cret = C.g_variant_new_uint32(_arg1)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// NewVariantUint64 constructs a struct Variant.
func NewVariantUint64(value uint64) *Variant {
	var _arg1 C.guint64   // out
	var _cret *C.GVariant // in

	_arg1 = C.guint64(value)

	_cret = C.g_variant_new_uint64(_arg1)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// NewVariantVariant constructs a struct Variant.
func NewVariantVariant(value *Variant) *Variant {
	var _arg1 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg1 = (*C.GVariant)(unsafe.Pointer(value))

	_cret = C.g_variant_new_variant(_arg1)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// Native returns the underlying C source pointer.
func (v *Variant) Native() unsafe.Pointer {
	return unsafe.Pointer(&v.native)
}

// Byteswap performs a byteswapping operation on the contents of @value. The
// result is that all multi-byte numeric data contained in @value is
// byteswapped. That includes 16, 32, and 64bit signed and unsigned integers as
// well as file handles and double precision floating point values.
//
// This function is an identity mapping on any value that does not contain
// multi-byte numeric data. That include strings, booleans, bytes and containers
// containing only these things (recursively).
//
// The returned value is always in normal form and is marked as trusted.
func (value *Variant) Byteswap() *Variant {
	var _arg0 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(value))

	_cret = C.g_variant_byteswap(_arg0)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// CheckFormatString checks if calling g_variant_get() with @format_string on
// @value would be valid from a type-compatibility standpoint. @format_string is
// assumed to be a valid format string (from a syntactic standpoint).
//
// If @copy_only is true then this function additionally checks that it would be
// safe to call g_variant_unref() on @value immediately after the call to
// g_variant_get() without invalidating the result. This is only possible if
// deep copies are made (ie: there are no pointers to the data inside of the
// soon-to-be-freed #GVariant instance). If this check fails then a g_critical()
// is printed and false is returned.
//
// This function is meant to be used by functions that wish to provide varargs
// accessors to #GVariant values of uncertain values (eg: g_variant_lookup() or
// g_menu_model_get_item_attribute()).
func (value *Variant) CheckFormatString(formatString string, copyOnly bool) bool {
	var _arg0 *C.GVariant // out
	var _arg1 *C.gchar    // out
	var _arg2 C.gboolean  // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(value))
	_arg1 = (*C.gchar)(C.CString(formatString))
	defer C.free(unsafe.Pointer(_arg1))
	if copyOnly {
		_arg2 = C.TRUE
	}

	_cret = C.g_variant_check_format_string(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Classify classifies @value according to its top-level type.
func (value *Variant) Classify() VariantClass {
	var _arg0 *C.GVariant     // out
	var _cret C.GVariantClass // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(value))

	_cret = C.g_variant_classify(_arg0)

	var _variantClass VariantClass // out

	_variantClass = (VariantClass)(_cret)

	return _variantClass
}

// Compare compares @one and @two.
//
// The types of @one and @two are #gconstpointer only to allow use of this
// function with #GTree, Array, etc. They must each be a #GVariant.
//
// Comparison is only defined for basic types (ie: booleans, numbers, strings).
// For booleans, false is less than true. Numbers are ordered in the usual way.
// Strings are in ASCII lexographical order.
//
// It is a programmer error to attempt to compare container values or two values
// that have types that are not exactly equal. For example, you cannot compare a
// 32-bit signed integer with a 32-bit unsigned integer. Also note that this
// function is not particularly well-behaved when it comes to comparison of
// doubles; in particular, the handling of incomparable values (ie: NaN) is
// undefined.
//
// If you only require an equality comparison, g_variant_equal() is more
// general.
func (one *Variant) Compare(two *Variant) int {
	var _arg0 C.gconstpointer // out
	var _arg1 C.gconstpointer // out
	var _cret C.gint          // in

	_arg0 = (C.gconstpointer)(unsafe.Pointer(one))
	_arg1 = (C.gconstpointer)(unsafe.Pointer(two))

	_cret = C.g_variant_compare(_arg0, _arg1)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// DupString: similar to g_variant_get_string() except that instead of returning
// a constant string, the string is duplicated.
//
// The string will always be UTF-8 encoded.
//
// The return value must be freed using g_free().
func (value *Variant) DupString() (uint, string) {
	var _arg0 *C.GVariant // out
	var _arg1 C.gsize     // in
	var _cret *C.gchar    // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(value))

	_cret = C.g_variant_dup_string(_arg0, &_arg1)

	var _length uint // out
	var _utf8 string // out

	_length = uint(_arg1)
	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _length, _utf8
}

// Equal checks if @one and @two have the same type and value.
//
// The types of @one and @two are #gconstpointer only to allow use of this
// function with Table. They must each be a #GVariant.
func (one *Variant) Equal(two *Variant) bool {
	var _arg0 C.gconstpointer // out
	var _arg1 C.gconstpointer // out
	var _cret C.gboolean      // in

	_arg0 = (C.gconstpointer)(unsafe.Pointer(one))
	_arg1 = (C.gconstpointer)(unsafe.Pointer(two))

	_cret = C.g_variant_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Boolean returns the boolean value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_BOOLEAN.
func (value *Variant) Boolean() bool {
	var _arg0 *C.GVariant // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(value))

	_cret = C.g_variant_get_boolean(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Byte returns the byte value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_BYTE.
func (value *Variant) Byte() byte {
	var _arg0 *C.GVariant // out
	var _cret C.guint8    // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(value))

	_cret = C.g_variant_get_byte(_arg0)

	var _guint8 byte // out

	_guint8 = byte(_cret)

	return _guint8
}

// Bytestring returns the string value of a #GVariant instance with an
// array-of-bytes type. The string has no particular encoding.
//
// If the array does not end with a nul terminator character, the empty string
// is returned. For this reason, you can always trust that a non-nil
// nul-terminated string will be returned by this function.
//
// If the array contains a nul terminator character somewhere other than the
// last byte then the returned string is the string, up to the first such nul
// character.
//
// g_variant_get_fixed_array() should be used instead if the array contains
// arbitrary data that could not be nul-terminated or could contain nul bytes.
//
// It is an error to call this function with a @value that is not an array of
// bytes.
//
// The return value remains valid as long as @value exists.
func (value *Variant) Bytestring() []byte {
	var _arg0 *C.GVariant // out
	var _cret *C.gchar

	_arg0 = (*C.GVariant)(unsafe.Pointer(value))

	_cret = C.g_variant_get_bytestring(_arg0)

	var _guint8s []byte

	{
		var i int
		var z C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_guint8s = make([]byte, i)
		for i := range src {
			_guint8s[i] = byte(src[i])
		}
	}

	return _guint8s
}

// ChildValue reads a child item out of a container #GVariant instance. This
// includes variants, maybes, arrays, tuples and dictionary entries. It is an
// error to call this function on any other type of #GVariant.
//
// It is an error if @index_ is greater than the number of child items in the
// container. See g_variant_n_children().
//
// The returned value is never floating. You should free it with
// g_variant_unref() when you're done with it.
//
// Note that values borrowed from the returned child are not guaranteed to still
// be valid after the child is freed even if you still hold a reference to
// @value, if @value has not been serialised at the time this function is
// called. To avoid this, you can serialize @value by calling
// g_variant_get_data() and optionally ignoring the return value.
//
// There may be implementation specific restrictions on deeply nested values,
// which would result in the unit tuple being returned as the child value,
// instead of further nested children. #GVariant is guaranteed to handle nesting
// up to at least 64 levels.
//
// This function is O(1).
func (value *Variant) ChildValue(index_ uint) *Variant {
	var _arg0 *C.GVariant // out
	var _arg1 C.gsize     // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(value))
	_arg1 = C.gsize(index_)

	_cret = C.g_variant_get_child_value(_arg0, _arg1)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// Data returns a pointer to the serialised form of a #GVariant instance. The
// returned data may not be in fully-normalised form if read from an untrusted
// source. The returned data must not be freed; it remains valid for as long as
// @value exists.
//
// If @value is a fixed-sized value that was deserialised from a corrupted
// serialised container then nil may be returned. In this case, the proper thing
// to do is typically to use the appropriate number of nul bytes in place of
// @value. If @value is not fixed-sized then nil is never returned.
//
// In the case that @value is already in serialised form, this function is O(1).
// If the value is not already in serialised form, serialisation occurs
// implicitly and is approximately O(n) in the size of the result.
//
// To deserialise the data returned by this function, in addition to the
// serialised data, you must know the type of the #GVariant, and (if the machine
// might be different) the endianness of the machine that stored it. As a
// result, file formats or network messages that incorporate serialised
// #GVariants must include this information either implicitly (for instance "the
// file always contains a G_VARIANT_TYPE_VARIANT and it is always in
// little-endian order") or explicitly (by storing the type and/or endianness in
// addition to the serialised data).
func (value *Variant) Data() interface{} {
	var _arg0 *C.GVariant     // out
	var _cret C.gconstpointer // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(value))

	_cret = C.g_variant_get_data(_arg0)

	var _gpointer interface{} // out

	_gpointer = box.Get(uintptr(_cret))

	return _gpointer
}

// Double returns the double precision floating point value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_DOUBLE.
func (value *Variant) Double() float64 {
	var _arg0 *C.GVariant // out
	var _cret C.gdouble   // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(value))

	_cret = C.g_variant_get_double(_arg0)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Handle returns the 32-bit signed integer value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_HANDLE.
//
// By convention, handles are indexes into an array of file descriptors that are
// sent alongside a D-Bus message. If you're not interacting with D-Bus, you
// probably don't need them.
func (value *Variant) Handle() int32 {
	var _arg0 *C.GVariant // out
	var _cret C.gint32    // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(value))

	_cret = C.g_variant_get_handle(_arg0)

	var _gint32 int32 // out

	_gint32 = int32(_cret)

	return _gint32
}

// Int16 returns the 16-bit signed integer value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_INT16.
func (value *Variant) Int16() int16 {
	var _arg0 *C.GVariant // out
	var _cret C.gint16    // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(value))

	_cret = C.g_variant_get_int16(_arg0)

	var _gint16 int16 // out

	_gint16 = int16(_cret)

	return _gint16
}

// Int32 returns the 32-bit signed integer value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_INT32.
func (value *Variant) Int32() int32 {
	var _arg0 *C.GVariant // out
	var _cret C.gint32    // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(value))

	_cret = C.g_variant_get_int32(_arg0)

	var _gint32 int32 // out

	_gint32 = int32(_cret)

	return _gint32
}

// Int64 returns the 64-bit signed integer value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_INT64.
func (value *Variant) Int64() int64 {
	var _arg0 *C.GVariant // out
	var _cret C.gint64    // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(value))

	_cret = C.g_variant_get_int64(_arg0)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// Maybe: given a maybe-typed #GVariant instance, extract its value. If the
// value is Nothing, then this function returns nil.
func (value *Variant) Maybe() *Variant {
	var _arg0 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(value))

	_cret = C.g_variant_get_maybe(_arg0)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// NormalForm gets a #GVariant instance that has the same value as @value and is
// trusted to be in normal form.
//
// If @value is already trusted to be in normal form then a new reference to
// @value is returned.
//
// If @value is not already trusted, then it is scanned to check if it is in
// normal form. If it is found to be in normal form then it is marked as trusted
// and a new reference to it is returned.
//
// If @value is found not to be in normal form then a new trusted #GVariant is
// created with the same value as @value.
//
// It makes sense to call this function if you've received #GVariant data from
// untrusted sources and you want to ensure your serialised output is definitely
// in normal form.
//
// If @value is already in normal form, a new reference will be returned (which
// will be floating if @value is floating). If it is not in normal form, the
// newly created #GVariant will be returned with a single non-floating
// reference. Typically, g_variant_take_ref() should be called on the return
// value from this function to guarantee ownership of a single non-floating
// reference to it.
func (value *Variant) NormalForm() *Variant {
	var _arg0 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(value))

	_cret = C.g_variant_get_normal_form(_arg0)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// Size determines the number of bytes that would be required to store @value
// with g_variant_store().
//
// If @value has a fixed-sized type then this function always returned that
// fixed size.
//
// In the case that @value is already in serialised form or the size has already
// been calculated (ie: this function has been called before) then this function
// is O(1). Otherwise, the size is calculated, an operation which is
// approximately O(n) in the number of values involved.
func (value *Variant) Size() uint {
	var _arg0 *C.GVariant // out
	var _cret C.gsize     // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(value))

	_cret = C.g_variant_get_size(_arg0)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// String returns the string value of a #GVariant instance with a string type.
// This includes the types G_VARIANT_TYPE_STRING, G_VARIANT_TYPE_OBJECT_PATH and
// G_VARIANT_TYPE_SIGNATURE.
//
// The string will always be UTF-8 encoded, will never be nil, and will never
// contain nul bytes.
//
// If @length is non-nil then the length of the string (in bytes) is returned
// there. For trusted values, this information is already known. Untrusted
// values will be validated and, if valid, a strlen() will be performed. If
// invalid, a default value will be returned — for G_VARIANT_TYPE_OBJECT_PATH,
// this is `"/"`, and for other types it is the empty string.
//
// It is an error to call this function with a @value of any type other than
// those three.
//
// The return value remains valid as long as @value exists.
func (value *Variant) String() (uint, string) {
	var _arg0 *C.GVariant // out
	var _arg1 C.gsize     // in
	var _cret *C.gchar    // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(value))

	_cret = C.g_variant_get_string(_arg0, &_arg1)

	var _length uint // out
	var _utf8 string // out

	_length = uint(_arg1)
	_utf8 = C.GoString(_cret)

	return _length, _utf8
}

// Type determines the type of @value.
//
// The return value is valid for the lifetime of @value and must not be freed.
func (value *Variant) Type() *VariantType {
	var _arg0 *C.GVariant     // out
	var _cret *C.GVariantType // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(value))

	_cret = C.g_variant_get_type(_arg0)

	var _variantType *VariantType // out

	_variantType = (*VariantType)(unsafe.Pointer(_cret))

	return _variantType
}

// TypeString returns the type string of @value. Unlike the result of calling
// g_variant_type_peek_string(), this string is nul-terminated. This string
// belongs to #GVariant and must not be freed.
func (value *Variant) TypeString() string {
	var _arg0 *C.GVariant // out
	var _cret *C.gchar    // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(value))

	_cret = C.g_variant_get_type_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Uint16 returns the 16-bit unsigned integer value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_UINT16.
func (value *Variant) Uint16() uint16 {
	var _arg0 *C.GVariant // out
	var _cret C.guint16   // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(value))

	_cret = C.g_variant_get_uint16(_arg0)

	var _guint16 uint16 // out

	_guint16 = uint16(_cret)

	return _guint16
}

// Uint32 returns the 32-bit unsigned integer value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_UINT32.
func (value *Variant) Uint32() uint32 {
	var _arg0 *C.GVariant // out
	var _cret C.guint32   // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(value))

	_cret = C.g_variant_get_uint32(_arg0)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// Uint64 returns the 64-bit unsigned integer value of @value.
//
// It is an error to call this function with a @value of any type other than
// G_VARIANT_TYPE_UINT64.
func (value *Variant) Uint64() uint64 {
	var _arg0 *C.GVariant // out
	var _cret C.guint64   // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(value))

	_cret = C.g_variant_get_uint64(_arg0)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// Variant unboxes @value. The result is the #GVariant instance that was
// contained in @value.
func (value *Variant) Variant() *Variant {
	var _arg0 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(value))

	_cret = C.g_variant_get_variant(_arg0)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// Hash generates a hash value for a #GVariant instance.
//
// The output of this function is guaranteed to be the same for a given value
// only per-process. It may change between different processor architectures or
// even different versions of GLib. Do not use this function as a basis for
// building protocols or file formats.
//
// The type of @value is #gconstpointer only to allow use of this function with
// Table. @value must be a #GVariant.
func (value *Variant) Hash() uint {
	var _arg0 C.gconstpointer // out
	var _cret C.guint         // in

	_arg0 = (C.gconstpointer)(unsafe.Pointer(value))

	_cret = C.g_variant_hash(_arg0)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// IsContainer checks if @value is a container.
func (value *Variant) IsContainer() bool {
	var _arg0 *C.GVariant // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(value))

	_cret = C.g_variant_is_container(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsFloating checks whether @value has a floating reference count.
//
// This function should only ever be used to assert that a given variant is or
// is not floating, or for debug purposes. To acquire a reference to a variant
// that might be floating, always use g_variant_ref_sink() or
// g_variant_take_ref().
//
// See g_variant_ref_sink() for more information about floating reference
// counts.
func (value *Variant) IsFloating() bool {
	var _arg0 *C.GVariant // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(value))

	_cret = C.g_variant_is_floating(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsNormalForm checks if @value is in normal form.
//
// The main reason to do this is to detect if a given chunk of serialised data
// is in normal form: load the data into a #GVariant using
// g_variant_new_from_data() and then use this function to check.
//
// If @value is found to be in normal form then it will be marked as being
// trusted. If the value was already marked as being trusted then this function
// will immediately return true.
//
// There may be implementation specific restrictions on deeply nested values.
// GVariant is guaranteed to handle nesting up to at least 64 levels.
func (value *Variant) IsNormalForm() bool {
	var _arg0 *C.GVariant // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(value))

	_cret = C.g_variant_is_normal_form(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsOfType checks if a value has a type matching the provided type.
func (value *Variant) IsOfType(typ *VariantType) bool {
	var _arg0 *C.GVariant     // out
	var _arg1 *C.GVariantType // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(value))
	_arg1 = (*C.GVariantType)(unsafe.Pointer(typ))

	_cret = C.g_variant_is_of_type(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LookupValue looks up a value in a dictionary #GVariant.
//
// This function works with dictionaries of the type a{s*} (and equally well
// with type a{o*}, but we only further discuss the string case for sake of
// clarity).
//
// In the event that @dictionary has the type a{sv}, the @expected_type string
// specifies what type of value is expected to be inside of the variant. If the
// value inside the variant has a different type then nil is returned. In the
// event that @dictionary has a value type other than v then @expected_type must
// directly match the value type and it is used to unpack the value directly or
// an error occurs.
//
// In either case, if @key is not found in @dictionary, nil is returned.
//
// If the key is found and the value has the correct type, it is returned. If
// @expected_type was specified then any non-nil return value will have this
// type.
//
// This function is currently implemented with a linear scan. If you plan to do
// many lookups then Dict may be more efficient.
func (dictionary *Variant) LookupValue(key string, expectedType *VariantType) *Variant {
	var _arg0 *C.GVariant     // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GVariantType // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(dictionary))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariantType)(unsafe.Pointer(expectedType))

	_cret = C.g_variant_lookup_value(_arg0, _arg1, _arg2)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// NChildren determines the number of children in a container #GVariant
// instance. This includes variants, maybes, arrays, tuples and dictionary
// entries. It is an error to call this function on any other type of #GVariant.
//
// For variants, the return value is always 1. For values with maybe types, it
// is always zero or one. For arrays, it is the length of the array. For tuples
// it is the number of tuple items (which depends only on the type). For
// dictionary entries, it is always 2
//
// This function is O(1).
func (value *Variant) NChildren() uint {
	var _arg0 *C.GVariant // out
	var _cret C.gsize     // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(value))

	_cret = C.g_variant_n_children(_arg0)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Print pretty-prints @value in the format understood by g_variant_parse().
//
// The format is described [here][gvariant-text].
//
// If @type_annotate is true, then type information is included in the output.
func (value *Variant) Print(typeAnnotate bool) string {
	var _arg0 *C.GVariant // out
	var _arg1 C.gboolean  // out
	var _cret *C.gchar    // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(value))
	if typeAnnotate {
		_arg1 = C.TRUE
	}

	_cret = C.g_variant_print(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Ref increases the reference count of @value.
func (value *Variant) ref() *Variant {
	var _arg0 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(value))

	_cret = C.g_variant_ref(_arg0)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// RefSink uses a floating reference count system. All functions with names
// starting with `g_variant_new_` return floating references.
//
// Calling g_variant_ref_sink() on a #GVariant with a floating reference will
// convert the floating reference into a full reference. Calling
// g_variant_ref_sink() on a non-floating #GVariant results in an additional
// normal reference being added.
//
// In other words, if the @value is floating, then this call "assumes ownership"
// of the floating reference, converting it to a normal reference. If the @value
// is not floating, then this call adds a new normal reference increasing the
// reference count by one.
//
// All calls that result in a #GVariant instance being inserted into a container
// will call g_variant_ref_sink() on the instance. This means that if the value
// was just created (and has only its floating reference) then the container
// will assume sole ownership of the value at that point and the caller will not
// need to unreference it. This makes certain common styles of programming much
// easier while still maintaining normal refcounting semantics in situations
// where values are not floating.
func (value *Variant) RefSink() *Variant {
	var _arg0 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(value))

	_cret = C.g_variant_ref_sink(_arg0)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// Store stores the serialised form of @value at @data. @data should be large
// enough. See g_variant_get_size().
//
// The stored data is in machine native byte order but may not be in
// fully-normalised form if read from an untrusted source. See
// g_variant_get_normal_form() for a solution.
//
// As with g_variant_get_data(), to be able to deserialise the serialised
// variant successfully, its type and (if the destination machine might be
// different) its endianness must also be available.
//
// This function is approximately O(n) in the size of @data.
func (value *Variant) Store(data interface{}) {
	var _arg0 *C.GVariant // out
	var _arg1 C.gpointer  // out

	_arg0 = (*C.GVariant)(unsafe.Pointer(value))
	_arg1 = (C.gpointer)(box.Assign(data))

	C.g_variant_store(_arg0, _arg1)
}

// TakeRef: if @value is floating, sink it. Otherwise, do nothing.
//
// Typically you want to use g_variant_ref_sink() in order to automatically do
// the correct thing with respect to floating or non-floating references, but
// there is one specific scenario where this function is helpful.
//
// The situation where this function is helpful is when creating an API that
// allows the user to provide a callback function that returns a #GVariant. We
// certainly want to allow the user the flexibility to return a non-floating
// reference from this callback (for the case where the value that is being
// returned already exists).
//
// At the same time, the style of the #GVariant API makes it likely that for
// newly-created #GVariant instances, the user can be saved some typing if they
// are allowed to return a #GVariant with a floating reference.
//
// Using this function on the return value of the user's callback allows the
// user to do whichever is more convenient for them. The caller will always
// receives exactly one full reference to the value: either the one that was
// returned in the first place, or a floating reference that has been converted
// to a full reference.
//
// This function has an odd interaction when combined with g_variant_ref_sink()
// running at the same time in another thread on the same #GVariant instance. If
// g_variant_ref_sink() runs first then the result will be that the floating
// reference is converted to a hard reference. If g_variant_take_ref() runs
// first then the result will be that the floating reference is converted to a
// hard reference and an additional reference on top of that one is added. It is
// best to avoid this situation.
func (value *Variant) TakeRef() *Variant {
	var _arg0 *C.GVariant // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GVariant)(unsafe.Pointer(value))

	_cret = C.g_variant_take_ref(_arg0)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// Unref decreases the reference count of @value. When its reference count drops
// to 0, the memory used by the variant is freed.
func (value *Variant) unref() {
	var _arg0 *C.GVariant // out

	_arg0 = (*C.GVariant)(unsafe.Pointer(value))

	C.g_variant_unref(_arg0)
}

// VariantBuilder: utility type for constructing container-type #GVariant
// instances.
//
// This is an opaque structure and may only be accessed using the following
// functions.
//
// Builder is not threadsafe in any way. Do not attempt to access it from more
// than one thread.
type VariantBuilder struct {
	native C.GVariantBuilder
}

func marshalVariantBuilder(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*VariantBuilder)(unsafe.Pointer(b)), nil
}

// NewVariantBuilder constructs a struct VariantBuilder.
func NewVariantBuilder(typ *VariantType) *VariantBuilder {
	var _arg1 *C.GVariantType    // out
	var _cret *C.GVariantBuilder // in

	_arg1 = (*C.GVariantType)(unsafe.Pointer(typ))

	_cret = C.g_variant_builder_new(_arg1)

	var _variantBuilder *VariantBuilder // out

	_variantBuilder = (*VariantBuilder)(unsafe.Pointer(_cret))
	C.g_variant_builder_ref(_cret)
	runtime.SetFinalizer(_variantBuilder, func(v *VariantBuilder) {
		C.g_variant_builder_unref((*C.GVariantBuilder)(unsafe.Pointer(v)))
	})

	return _variantBuilder
}

// Native returns the underlying C source pointer.
func (v *VariantBuilder) Native() unsafe.Pointer {
	return unsafe.Pointer(&v.native)
}

// AddValue adds @value to @builder.
//
// It is an error to call this function in any way that would create an
// inconsistent value to be constructed. Some examples of this are putting
// different types of items into an array, putting the wrong types or number of
// items in a tuple, putting more than one value into a variant, etc.
//
// If @value is a floating reference (see g_variant_ref_sink()), the @builder
// instance takes ownership of @value.
func (builder *VariantBuilder) AddValue(value *Variant) {
	var _arg0 *C.GVariantBuilder // out
	var _arg1 *C.GVariant        // out

	_arg0 = (*C.GVariantBuilder)(unsafe.Pointer(builder))
	_arg1 = (*C.GVariant)(unsafe.Pointer(value))

	C.g_variant_builder_add_value(_arg0, _arg1)
}

// Close closes the subcontainer inside the given @builder that was opened by
// the most recent call to g_variant_builder_open().
//
// It is an error to call this function in any way that would create an
// inconsistent value to be constructed (ie: too few values added to the
// subcontainer).
func (builder *VariantBuilder) Close() {
	var _arg0 *C.GVariantBuilder // out

	_arg0 = (*C.GVariantBuilder)(unsafe.Pointer(builder))

	C.g_variant_builder_close(_arg0)
}

// End ends the builder process and returns the constructed value.
//
// It is not permissible to use @builder in any way after this call except for
// reference counting operations (in the case of a heap-allocated Builder) or by
// reinitialising it with g_variant_builder_init() (in the case of
// stack-allocated). This means that for the stack-allocated builders there is
// no need to call g_variant_builder_clear() after the call to
// g_variant_builder_end().
//
// It is an error to call this function in any way that would create an
// inconsistent value to be constructed (ie: insufficient number of items added
// to a container with a specific number of children required). It is also an
// error to call this function if the builder was created with an indefinite
// array or maybe type and no children have been added; in this case it is
// impossible to infer the type of the empty array.
func (builder *VariantBuilder) End() *Variant {
	var _arg0 *C.GVariantBuilder // out
	var _cret *C.GVariant        // in

	_arg0 = (*C.GVariantBuilder)(unsafe.Pointer(builder))

	_cret = C.g_variant_builder_end(_arg0)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// Open opens a subcontainer inside the given @builder. When done adding items
// to the subcontainer, g_variant_builder_close() must be called. @type is the
// type of the container: so to build a tuple of several values, @type must
// include the tuple itself.
//
// It is an error to call this function in any way that would cause an
// inconsistent value to be constructed (ie: adding too many values or a value
// of an incorrect type).
//
// Example of building a nested variant:
//
//    GVariantBuilder builder;
//    guint32 some_number = get_number ();
//    g_autoptr (GHashTable) some_dict = get_dict ();
//    GHashTableIter iter;
//    const gchar *key;
//    const GVariant *value;
//    g_autoptr (GVariant) output = NULL;
//
//    g_variant_builder_init (&builder, G_VARIANT_TYPE ("(ua{sv})"));
//    g_variant_builder_add (&builder, "u", some_number);
//    g_variant_builder_open (&builder, G_VARIANT_TYPE ("a{sv}"));
//
//    g_hash_table_iter_init (&iter, some_dict);
//    while (g_hash_table_iter_next (&iter, (gpointer *) &key, (gpointer *) &value))
//      {
//        g_variant_builder_open (&builder, G_VARIANT_TYPE ("{sv}"));
//        g_variant_builder_add (&builder, "s", key);
//        g_variant_builder_add (&builder, "v", value);
//        g_variant_builder_close (&builder);
//      }
//
//    g_variant_builder_close (&builder);
//
//    output = g_variant_builder_end (&builder);
func (builder *VariantBuilder) Open(typ *VariantType) {
	var _arg0 *C.GVariantBuilder // out
	var _arg1 *C.GVariantType    // out

	_arg0 = (*C.GVariantBuilder)(unsafe.Pointer(builder))
	_arg1 = (*C.GVariantType)(unsafe.Pointer(typ))

	C.g_variant_builder_open(_arg0, _arg1)
}

// Ref increases the reference count on @builder.
//
// Don't call this on stack-allocated Builder instances or bad things will
// happen.
func (builder *VariantBuilder) ref() *VariantBuilder {
	var _arg0 *C.GVariantBuilder // out
	var _cret *C.GVariantBuilder // in

	_arg0 = (*C.GVariantBuilder)(unsafe.Pointer(builder))

	_cret = C.g_variant_builder_ref(_arg0)

	var _variantBuilder *VariantBuilder // out

	_variantBuilder = (*VariantBuilder)(unsafe.Pointer(_cret))
	C.g_variant_builder_ref(_cret)
	runtime.SetFinalizer(_variantBuilder, func(v *VariantBuilder) {
		C.g_variant_builder_unref((*C.GVariantBuilder)(unsafe.Pointer(v)))
	})

	return _variantBuilder
}

// Unref decreases the reference count on @builder.
//
// In the event that there are no more references, releases all memory
// associated with the Builder.
//
// Don't call this on stack-allocated Builder instances or bad things will
// happen.
func (builder *VariantBuilder) unref() {
	var _arg0 *C.GVariantBuilder // out

	_arg0 = (*C.GVariantBuilder)(unsafe.Pointer(builder))

	C.g_variant_builder_unref(_arg0)
}

// VariantDict is a mutable interface to #GVariant dictionaries.
//
// It can be used for doing a sequence of dictionary lookups in an efficient way
// on an existing #GVariant dictionary or it can be used to construct new
// dictionaries with a hashtable-like interface. It can also be used for taking
// existing dictionaries and modifying them in order to create new ones.
//
// Dict can only be used with G_VARIANT_TYPE_VARDICT dictionaries.
//
// It is possible to use Dict allocated on the stack or on the heap. When using
// a stack-allocated Dict, you begin with a call to g_variant_dict_init() and
// free the resources with a call to g_variant_dict_clear().
//
// Heap-allocated Dict follows normal refcounting rules: you allocate it with
// g_variant_dict_new() and use g_variant_dict_ref() and g_variant_dict_unref().
//
// g_variant_dict_end() is used to convert the Dict back into a dictionary-type
// #GVariant. When used with stack-allocated instances, this also implicitly
// frees all associated memory, but for heap-allocated instances, you must still
// call g_variant_dict_unref() afterwards.
//
// You will typically want to use a heap-allocated Dict when you expose it as
// part of an API. For most other uses, the stack-allocated form will be more
// convenient.
//
// Consider the following two examples that do the same thing in each style:
// take an existing dictionary and look up the "count" uint32 key, adding 1 to
// it if it is found, or returning an error if the key is not found. Each
// returns the new dictionary as a floating #GVariant.
//
// Using a stack-allocated GVariantDict
//
//      GVariant *
//      add_to_count (GVariant  *orig,
//                    GError   **error)
//      {
//        GVariantDict *dict;
//        GVariant *result;
//        guint32 count;
//
//        dict = g_variant_dict_new (orig);
//
//        if (g_variant_dict_lookup (dict, "count", "u", &count))
//          {
//            g_variant_dict_insert (dict, "count", "u", count + 1);
//            result = g_variant_dict_end (dict);
//          }
//        else
//          {
//            g_set_error (...);
//            result = NULL;
//          }
//
//        g_variant_dict_unref (dict);
//
//        return result;
//      }
type VariantDict struct {
	native C.GVariantDict
}

func marshalVariantDict(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*VariantDict)(unsafe.Pointer(b)), nil
}

// NewVariantDict constructs a struct VariantDict.
func NewVariantDict(fromAsv *Variant) *VariantDict {
	var _arg1 *C.GVariant     // out
	var _cret *C.GVariantDict // in

	_arg1 = (*C.GVariant)(unsafe.Pointer(fromAsv))

	_cret = C.g_variant_dict_new(_arg1)

	var _variantDict *VariantDict // out

	_variantDict = (*VariantDict)(unsafe.Pointer(_cret))
	C.g_variant_dict_ref(_cret)
	runtime.SetFinalizer(_variantDict, func(v *VariantDict) {
		C.g_variant_dict_unref((*C.GVariantDict)(unsafe.Pointer(v)))
	})

	return _variantDict
}

// Native returns the underlying C source pointer.
func (v *VariantDict) Native() unsafe.Pointer {
	return unsafe.Pointer(&v.native)
}

// Clear releases all memory associated with a Dict without freeing the Dict
// structure itself.
//
// It typically only makes sense to do this on a stack-allocated Dict if you
// want to abort building the value part-way through. This function need not be
// called if you call g_variant_dict_end() and it also doesn't need to be called
// on dicts allocated with g_variant_dict_new (see g_variant_dict_unref() for
// that).
//
// It is valid to call this function on either an initialised Dict or one that
// was previously cleared by an earlier call to g_variant_dict_clear() but it is
// not valid to call this function on uninitialised memory.
func (dict *VariantDict) Clear() {
	var _arg0 *C.GVariantDict // out

	_arg0 = (*C.GVariantDict)(unsafe.Pointer(dict))

	C.g_variant_dict_clear(_arg0)
}

// Contains checks if @key exists in @dict.
func (dict *VariantDict) Contains(key string) bool {
	var _arg0 *C.GVariantDict // out
	var _arg1 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GVariantDict)(unsafe.Pointer(dict))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_variant_dict_contains(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// End returns the current value of @dict as a #GVariant of type
// G_VARIANT_TYPE_VARDICT, clearing it in the process.
//
// It is not permissible to use @dict in any way after this call except for
// reference counting operations (in the case of a heap-allocated Dict) or by
// reinitialising it with g_variant_dict_init() (in the case of
// stack-allocated).
func (dict *VariantDict) End() *Variant {
	var _arg0 *C.GVariantDict // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GVariantDict)(unsafe.Pointer(dict))

	_cret = C.g_variant_dict_end(_arg0)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// InsertValue inserts (or replaces) a key in a Dict.
//
// @value is consumed if it is floating.
func (dict *VariantDict) InsertValue(key string, value *Variant) {
	var _arg0 *C.GVariantDict // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GVariant     // out

	_arg0 = (*C.GVariantDict)(unsafe.Pointer(dict))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(unsafe.Pointer(value))

	C.g_variant_dict_insert_value(_arg0, _arg1, _arg2)
}

// LookupValue looks up a value in a Dict.
//
// If @key is not found in @dictionary, nil is returned.
//
// The @expected_type string specifies what type of value is expected. If the
// value associated with @key has a different type then nil is returned.
//
// If the key is found and the value has the correct type, it is returned. If
// @expected_type was specified then any non-nil return value will have this
// type.
func (dict *VariantDict) LookupValue(key string, expectedType *VariantType) *Variant {
	var _arg0 *C.GVariantDict // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GVariantType // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GVariantDict)(unsafe.Pointer(dict))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariantType)(unsafe.Pointer(expectedType))

	_cret = C.g_variant_dict_lookup_value(_arg0, _arg1, _arg2)

	var _variant *Variant // out

	_variant = (*Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

// Ref increases the reference count on @dict.
//
// Don't call this on stack-allocated Dict instances or bad things will happen.
func (dict *VariantDict) ref() *VariantDict {
	var _arg0 *C.GVariantDict // out
	var _cret *C.GVariantDict // in

	_arg0 = (*C.GVariantDict)(unsafe.Pointer(dict))

	_cret = C.g_variant_dict_ref(_arg0)

	var _variantDict *VariantDict // out

	_variantDict = (*VariantDict)(unsafe.Pointer(_cret))
	C.g_variant_dict_ref(_cret)
	runtime.SetFinalizer(_variantDict, func(v *VariantDict) {
		C.g_variant_dict_unref((*C.GVariantDict)(unsafe.Pointer(v)))
	})

	return _variantDict
}

// Remove removes a key and its associated value from a Dict.
func (dict *VariantDict) Remove(key string) bool {
	var _arg0 *C.GVariantDict // out
	var _arg1 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GVariantDict)(unsafe.Pointer(dict))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_variant_dict_remove(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Unref decreases the reference count on @dict.
//
// In the event that there are no more references, releases all memory
// associated with the Dict.
//
// Don't call this on stack-allocated Dict instances or bad things will happen.
func (dict *VariantDict) unref() {
	var _arg0 *C.GVariantDict // out

	_arg0 = (*C.GVariantDict)(unsafe.Pointer(dict))

	C.g_variant_dict_unref(_arg0)
}
