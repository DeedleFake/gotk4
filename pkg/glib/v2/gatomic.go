// Code generated by girgen. DO NOT EDIT.

package glib

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib.h>
import "C"

// AtomicIntAdd: atomically adds @val to the value of @atomic.
//
// Think of this operation as an atomic version of `{ tmp = *atomic; *atomic +=
// val; return tmp; }`.
//
// This call acts as a full compiler and hardware memory barrier.
//
// Before version 2.30, this function did not return a value (but
// g_atomic_int_exchange_and_add() did, and had the same meaning).
func AtomicIntAdd(atomic int, val int) int {
	var arg1 *C.gint
	var arg2 C.gint

	arg1 = *C.gint(atomic)
	arg2 = C.gint(val)

	var cret C.gint
	var ret1 int

	cret = C.g_atomic_int_add(atomic, val)

	ret1 = C.gint(cret)

	return ret1
}

// AtomicIntAnd performs an atomic bitwise 'and' of the value of @atomic and
// @val, storing the result back in @atomic.
//
// This call acts as a full compiler and hardware memory barrier.
//
// Think of this operation as an atomic version of `{ tmp = *atomic; *atomic &=
// val; return tmp; }`.
func AtomicIntAnd(atomic uint, val uint) uint {
	var arg1 *C.guint
	var arg2 C.guint

	arg1 = *C.guint(atomic)
	arg2 = C.guint(val)

	var cret C.guint
	var ret1 uint

	cret = C.g_atomic_int_and(atomic, val)

	ret1 = C.guint(cret)

	return ret1
}

// AtomicIntCompareAndExchange compares @atomic to @oldval and, if equal, sets
// it to @newval. If @atomic was not equal to @oldval then no change occurs.
//
// This compare and exchange is done atomically.
//
// Think of this operation as an atomic version of `{ if (*atomic == oldval) {
// *atomic = newval; return TRUE; } else return FALSE; }`.
//
// This call acts as a full compiler and hardware memory barrier.
func AtomicIntCompareAndExchange(atomic int, oldval int, newval int) bool {
	var arg1 *C.gint
	var arg2 C.gint
	var arg3 C.gint

	arg1 = *C.gint(atomic)
	arg2 = C.gint(oldval)
	arg3 = C.gint(newval)

	var cret C.gboolean
	var ret1 bool

	cret = C.g_atomic_int_compare_and_exchange(atomic, oldval, newval)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// AtomicIntDecAndTest decrements the value of @atomic by 1.
//
// Think of this operation as an atomic version of `{ *atomic -= 1; return
// (*atomic == 0); }`.
//
// This call acts as a full compiler and hardware memory barrier.
func AtomicIntDecAndTest(atomic int) bool {
	var arg1 *C.gint

	arg1 = *C.gint(atomic)

	var cret C.gboolean
	var ret1 bool

	cret = C.g_atomic_int_dec_and_test(atomic)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// AtomicIntExchangeAndAdd: this function existed before g_atomic_int_add()
// returned the prior value of the integer (which it now does). It is retained
// only for compatibility reasons. Don't use this function in new code.
func AtomicIntExchangeAndAdd(atomic int, val int) int {
	var arg1 *C.gint
	var arg2 C.gint

	arg1 = *C.gint(atomic)
	arg2 = C.gint(val)

	var cret C.gint
	var ret1 int

	cret = C.g_atomic_int_exchange_and_add(atomic, val)

	ret1 = C.gint(cret)

	return ret1
}

// AtomicIntGet gets the current value of @atomic.
//
// This call acts as a full compiler and hardware memory barrier (before the
// get).
func AtomicIntGet(atomic int) int {
	var arg1 *C.gint

	arg1 = *C.gint(atomic)

	var cret C.gint
	var ret1 int

	cret = C.g_atomic_int_get(atomic)

	ret1 = C.gint(cret)

	return ret1
}

// AtomicIntInc increments the value of @atomic by 1.
//
// Think of this operation as an atomic version of `{ *atomic += 1; }`.
//
// This call acts as a full compiler and hardware memory barrier.
func AtomicIntInc(atomic int) {
	var arg1 *C.gint

	arg1 = *C.gint(atomic)

	C.g_atomic_int_inc(atomic)
}

// AtomicIntOr performs an atomic bitwise 'or' of the value of @atomic and @val,
// storing the result back in @atomic.
//
// Think of this operation as an atomic version of `{ tmp = *atomic; *atomic |=
// val; return tmp; }`.
//
// This call acts as a full compiler and hardware memory barrier.
func AtomicIntOr(atomic uint, val uint) uint {
	var arg1 *C.guint
	var arg2 C.guint

	arg1 = *C.guint(atomic)
	arg2 = C.guint(val)

	var cret C.guint
	var ret1 uint

	cret = C.g_atomic_int_or(atomic, val)

	ret1 = C.guint(cret)

	return ret1
}

// AtomicIntSet sets the value of @atomic to @newval.
//
// This call acts as a full compiler and hardware memory barrier (after the
// set).
func AtomicIntSet(atomic int, newval int) {
	var arg1 *C.gint
	var arg2 C.gint

	arg1 = *C.gint(atomic)
	arg2 = C.gint(newval)

	C.g_atomic_int_set(atomic, newval)
}

// AtomicIntXor performs an atomic bitwise 'xor' of the value of @atomic and
// @val, storing the result back in @atomic.
//
// Think of this operation as an atomic version of `{ tmp = *atomic; *atomic ^=
// val; return tmp; }`.
//
// This call acts as a full compiler and hardware memory barrier.
func AtomicIntXor(atomic uint, val uint) uint {
	var arg1 *C.guint
	var arg2 C.guint

	arg1 = *C.guint(atomic)
	arg2 = C.guint(val)

	var cret C.guint
	var ret1 uint

	cret = C.g_atomic_int_xor(atomic, val)

	ret1 = C.guint(cret)

	return ret1
}

// AtomicPointerAdd: atomically adds @val to the value of @atomic.
//
// Think of this operation as an atomic version of `{ tmp = *atomic; *atomic +=
// val; return tmp; }`.
//
// This call acts as a full compiler and hardware memory barrier.
func AtomicPointerAdd(atomic interface{}, val int) int {
	var arg1 *C.void
	var arg2 C.gssize

	arg1 = *C.void(atomic)
	arg2 = C.gssize(val)

	var cret C.gssize
	var ret1 int

	cret = C.g_atomic_pointer_add(atomic, val)

	ret1 = C.gssize(cret)

	return ret1
}

// AtomicPointerAnd performs an atomic bitwise 'and' of the value of @atomic and
// @val, storing the result back in @atomic.
//
// Think of this operation as an atomic version of `{ tmp = *atomic; *atomic &=
// val; return tmp; }`.
//
// This call acts as a full compiler and hardware memory barrier.
func AtomicPointerAnd(atomic interface{}, val uint) uint {
	var arg1 *C.void
	var arg2 C.gsize

	arg1 = *C.void(atomic)
	arg2 = C.gsize(val)

	var cret C.gsize
	var ret1 uint

	cret = C.g_atomic_pointer_and(atomic, val)

	ret1 = C.gsize(cret)

	return ret1
}

// AtomicPointerCompareAndExchange compares @atomic to @oldval and, if equal,
// sets it to @newval. If @atomic was not equal to @oldval then no change
// occurs.
//
// This compare and exchange is done atomically.
//
// Think of this operation as an atomic version of `{ if (*atomic == oldval) {
// *atomic = newval; return TRUE; } else return FALSE; }`.
//
// This call acts as a full compiler and hardware memory barrier.
func AtomicPointerCompareAndExchange(atomic interface{}, oldval interface{}, newval interface{}) bool {
	var arg1 *C.void
	var arg2 C.gpointer
	var arg3 C.gpointer

	arg1 = *C.void(atomic)
	arg2 = C.gpointer(oldval)
	arg3 = C.gpointer(newval)

	var cret C.gboolean
	var ret1 bool

	cret = C.g_atomic_pointer_compare_and_exchange(atomic, oldval, newval)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// AtomicPointerGet gets the current value of @atomic.
//
// This call acts as a full compiler and hardware memory barrier (before the
// get).
func AtomicPointerGet(atomic interface{}) interface{} {
	var arg1 *C.void

	arg1 = *C.void(atomic)

	var cret C.gpointer
	var ret1 interface{}

	cret = C.g_atomic_pointer_get(atomic)

	ret1 = C.gpointer(cret)

	return ret1
}

// AtomicPointerOr performs an atomic bitwise 'or' of the value of @atomic and
// @val, storing the result back in @atomic.
//
// Think of this operation as an atomic version of `{ tmp = *atomic; *atomic |=
// val; return tmp; }`.
//
// This call acts as a full compiler and hardware memory barrier.
func AtomicPointerOr(atomic interface{}, val uint) uint {
	var arg1 *C.void
	var arg2 C.gsize

	arg1 = *C.void(atomic)
	arg2 = C.gsize(val)

	var cret C.gsize
	var ret1 uint

	cret = C.g_atomic_pointer_or(atomic, val)

	ret1 = C.gsize(cret)

	return ret1
}

// AtomicPointerSet sets the value of @atomic to @newval.
//
// This call acts as a full compiler and hardware memory barrier (after the
// set).
func AtomicPointerSet(atomic interface{}, newval interface{}) {
	var arg1 *C.void
	var arg2 C.gpointer

	arg1 = *C.void(atomic)
	arg2 = C.gpointer(newval)

	C.g_atomic_pointer_set(atomic, newval)
}

// AtomicPointerXor performs an atomic bitwise 'xor' of the value of @atomic and
// @val, storing the result back in @atomic.
//
// Think of this operation as an atomic version of `{ tmp = *atomic; *atomic ^=
// val; return tmp; }`.
//
// This call acts as a full compiler and hardware memory barrier.
func AtomicPointerXor(atomic interface{}, val uint) uint {
	var arg1 *C.void
	var arg2 C.gsize

	arg1 = *C.void(atomic)
	arg2 = C.gsize(val)

	var cret C.gsize
	var ret1 uint

	cret = C.g_atomic_pointer_xor(atomic, val)

	ret1 = C.gsize(cret)

	return ret1
}
