// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"github.com/diamondburned/gotk4/internal/box"
)

// #cgo pkg-config: glib-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib.h>
import "C"

// AtomicIntAdd: atomically adds @val to the value of @atomic.
//
// Think of this operation as an atomic version of `{ tmp = *atomic; *atomic +=
// val; return tmp; }`.
//
// This call acts as a full compiler and hardware memory barrier.
//
// Before version 2.30, this function did not return a value (but
// g_atomic_int_exchange_and_add() did, and had the same meaning).
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicIntAdd(atomic int, val int) int {
	var arg1 *C.gint
	var arg2 C.gint

	arg1 = (*C.gint)(atomic)
	arg2 = C.gint(val)

	ret := C.g_atomic_int_add(arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// AtomicIntAnd performs an atomic bitwise 'and' of the value of @atomic and
// @val, storing the result back in @atomic.
//
// This call acts as a full compiler and hardware memory barrier.
//
// Think of this operation as an atomic version of `{ tmp = *atomic; *atomic &=
// val; return tmp; }`.
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicIntAnd(atomic uint, val uint) uint {
	var arg1 *C.guint
	var arg2 C.guint

	arg1 = (*C.guint)(atomic)
	arg2 = C.guint(val)

	ret := C.g_atomic_int_and(arg1, arg2)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// AtomicIntCompareAndExchange compares @atomic to @oldval and, if equal, sets
// it to @newval. If @atomic was not equal to @oldval then no change occurs.
//
// This compare and exchange is done atomically.
//
// Think of this operation as an atomic version of `{ if (*atomic == oldval) {
// *atomic = newval; return TRUE; } else return FALSE; }`.
//
// This call acts as a full compiler and hardware memory barrier.
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicIntCompareAndExchange(atomic int, oldval int, newval int) bool {
	var arg1 *C.gint
	var arg2 C.gint
	var arg3 C.gint

	arg1 = (*C.gint)(atomic)
	arg2 = C.gint(oldval)
	arg3 = C.gint(newval)

	ret := C.g_atomic_int_compare_and_exchange(arg1, arg2, arg3)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// AtomicIntDecAndTest decrements the value of @atomic by 1.
//
// Think of this operation as an atomic version of `{ *atomic -= 1; return
// (*atomic == 0); }`.
//
// This call acts as a full compiler and hardware memory barrier.
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicIntDecAndTest(atomic int) bool {
	var arg1 *C.gint

	arg1 = (*C.gint)(atomic)

	ret := C.g_atomic_int_dec_and_test(arg1)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// AtomicIntExchangeAndAdd: this function existed before g_atomic_int_add()
// returned the prior value of the integer (which it now does). It is retained
// only for compatibility reasons. Don't use this function in new code.
func AtomicIntExchangeAndAdd(atomic int, val int) int {
	var arg1 *C.gint
	var arg2 C.gint

	arg1 = (*C.gint)(atomic)
	arg2 = C.gint(val)

	ret := C.g_atomic_int_exchange_and_add(arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// AtomicIntGet gets the current value of @atomic.
//
// This call acts as a full compiler and hardware memory barrier (before the
// get).
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicIntGet(atomic int) int {
	var arg1 *C.gint

	arg1 = (*C.gint)(atomic)

	ret := C.g_atomic_int_get(arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// AtomicIntInc increments the value of @atomic by 1.
//
// Think of this operation as an atomic version of `{ *atomic += 1; }`.
//
// This call acts as a full compiler and hardware memory barrier.
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicIntInc(atomic int) {
	var arg1 *C.gint

	arg1 = (*C.gint)(atomic)

	C.g_atomic_int_inc(arg1)
}

// AtomicIntOr performs an atomic bitwise 'or' of the value of @atomic and @val,
// storing the result back in @atomic.
//
// Think of this operation as an atomic version of `{ tmp = *atomic; *atomic |=
// val; return tmp; }`.
//
// This call acts as a full compiler and hardware memory barrier.
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicIntOr(atomic uint, val uint) uint {
	var arg1 *C.guint
	var arg2 C.guint

	arg1 = (*C.guint)(atomic)
	arg2 = C.guint(val)

	ret := C.g_atomic_int_or(arg1, arg2)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// AtomicIntSet sets the value of @atomic to @newval.
//
// This call acts as a full compiler and hardware memory barrier (after the
// set).
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicIntSet(atomic int, newval int) {
	var arg1 *C.gint
	var arg2 C.gint

	arg1 = (*C.gint)(atomic)
	arg2 = C.gint(newval)

	C.g_atomic_int_set(arg1, arg2)
}

// AtomicIntXor performs an atomic bitwise 'xor' of the value of @atomic and
// @val, storing the result back in @atomic.
//
// Think of this operation as an atomic version of `{ tmp = *atomic; *atomic ^=
// val; return tmp; }`.
//
// This call acts as a full compiler and hardware memory barrier.
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicIntXor(atomic uint, val uint) uint {
	var arg1 *C.guint
	var arg2 C.guint

	arg1 = (*C.guint)(atomic)
	arg2 = C.guint(val)

	ret := C.g_atomic_int_xor(arg1, arg2)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// AtomicPointerAdd: atomically adds @val to the value of @atomic.
//
// Think of this operation as an atomic version of `{ tmp = *atomic; *atomic +=
// val; return tmp; }`.
//
// This call acts as a full compiler and hardware memory barrier.
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicPointerAdd(atomic interface{}, val int) int {
	var arg1 *C.void
	var arg2 C.gssize

	arg1 = C.gpointer(box.Assign(atomic))
	arg2 = C.gssize(val)

	ret := C.g_atomic_pointer_add(arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// AtomicPointerAnd performs an atomic bitwise 'and' of the value of @atomic and
// @val, storing the result back in @atomic.
//
// Think of this operation as an atomic version of `{ tmp = *atomic; *atomic &=
// val; return tmp; }`.
//
// This call acts as a full compiler and hardware memory barrier.
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicPointerAnd(atomic interface{}, val uint) uint {
	var arg1 *C.void
	var arg2 C.gsize

	arg1 = C.gpointer(box.Assign(atomic))
	arg2 = C.gsize(val)

	ret := C.g_atomic_pointer_and(arg1, arg2)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// AtomicPointerCompareAndExchange compares @atomic to @oldval and, if equal,
// sets it to @newval. If @atomic was not equal to @oldval then no change
// occurs.
//
// This compare and exchange is done atomically.
//
// Think of this operation as an atomic version of `{ if (*atomic == oldval) {
// *atomic = newval; return TRUE; } else return FALSE; }`.
//
// This call acts as a full compiler and hardware memory barrier.
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicPointerCompareAndExchange(atomic interface{}, oldval interface{}, newval interface{}) bool {
	var arg1 *C.void
	var arg2 C.gpointer
	var arg3 C.gpointer

	arg1 = C.gpointer(box.Assign(atomic))
	arg2 = C.gpointer(box.Assign(oldval))
	arg3 = C.gpointer(box.Assign(newval))

	ret := C.g_atomic_pointer_compare_and_exchange(arg1, arg2, arg3)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// AtomicPointerGet gets the current value of @atomic.
//
// This call acts as a full compiler and hardware memory barrier (before the
// get).
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicPointerGet(atomic interface{}) interface{} {
	var arg1 *C.void

	arg1 = C.gpointer(box.Assign(atomic))

	ret := C.g_atomic_pointer_get(arg1)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// AtomicPointerOr performs an atomic bitwise 'or' of the value of @atomic and
// @val, storing the result back in @atomic.
//
// Think of this operation as an atomic version of `{ tmp = *atomic; *atomic |=
// val; return tmp; }`.
//
// This call acts as a full compiler and hardware memory barrier.
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicPointerOr(atomic interface{}, val uint) uint {
	var arg1 *C.void
	var arg2 C.gsize

	arg1 = C.gpointer(box.Assign(atomic))
	arg2 = C.gsize(val)

	ret := C.g_atomic_pointer_or(arg1, arg2)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// AtomicPointerSet sets the value of @atomic to @newval.
//
// This call acts as a full compiler and hardware memory barrier (after the
// set).
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicPointerSet(atomic interface{}, newval interface{}) {
	var arg1 *C.void
	var arg2 C.gpointer

	arg1 = C.gpointer(box.Assign(atomic))
	arg2 = C.gpointer(box.Assign(newval))

	C.g_atomic_pointer_set(arg1, arg2)
}

// AtomicPointerXor performs an atomic bitwise 'xor' of the value of @atomic and
// @val, storing the result back in @atomic.
//
// Think of this operation as an atomic version of `{ tmp = *atomic; *atomic ^=
// val; return tmp; }`.
//
// This call acts as a full compiler and hardware memory barrier.
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicPointerXor(atomic interface{}, val uint) uint {
	var arg1 *C.void
	var arg2 C.gsize

	arg1 = C.gpointer(box.Assign(atomic))
	arg2 = C.gsize(val)

	ret := C.g_atomic_pointer_xor(arg1, arg2)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}
