// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"runtime"
	"runtime/cgo"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdlib.h>
// #include <glib.h>
import "C"

// HRFunc specifies the type of the function passed to
// g_hash_table_foreach_remove(). It is called with each key/value pair,
// together with the user_data parameter passed to
// g_hash_table_foreach_remove(). It should return TRUE if the key/value pair
// should be removed from the Table.
type HRFunc func(key, value cgo.Handle) (ok bool)

//export _gotk4_glib2_HRFunc
func _gotk4_glib2_HRFunc(arg0 C.gpointer, arg1 C.gpointer, arg2 C.gpointer) (cret C.gboolean) {
	v := gbox.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var key cgo.Handle   // out
	var value cgo.Handle // out

	key = (cgo.Handle)(unsafe.Pointer(arg0))
	value = (cgo.Handle)(unsafe.Pointer(arg1))

	fn := v.(HRFunc)
	ok := fn(key, value)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// DirectEqual compares two #gpointer arguments and returns TRUE if they are
// equal. It can be passed to g_hash_table_new() as the key_equal_func
// parameter, when using opaque pointers compared by pointer value as keys in a
// Table.
//
// This equality function is also appropriate for keys that are integers stored
// in pointers, such as GINT_TO_POINTER (n).
//
// The function takes the following parameters:
//
//    - v1: key.
//    - v2: key to compare with v1.
//
func DirectEqual(v1, v2 cgo.Handle) bool {
	var _arg1 C.gconstpointer // out
	var _arg2 C.gconstpointer // out
	var _cret C.gboolean      // in

	_arg1 = (C.gconstpointer)(unsafe.Pointer(v1))
	_arg2 = (C.gconstpointer)(unsafe.Pointer(v2))

	_cret = C.g_direct_equal(_arg1, _arg2)
	runtime.KeepAlive(v1)
	runtime.KeepAlive(v2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DirectHash converts a gpointer to a hash value. It can be passed to
// g_hash_table_new() as the hash_func parameter, when using opaque pointers
// compared by pointer value as keys in a Table.
//
// This hash function is also appropriate for keys that are integers stored in
// pointers, such as GINT_TO_POINTER (n).
//
// The function takes the following parameters:
//
//    - v: #gpointer key.
//
func DirectHash(v cgo.Handle) uint {
	var _arg1 C.gconstpointer // out
	var _cret C.guint         // in

	_arg1 = (C.gconstpointer)(unsafe.Pointer(v))

	_cret = C.g_direct_hash(_arg1)
	runtime.KeepAlive(v)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// DoubleEqual compares the two #gdouble values being pointed to and returns
// TRUE if they are equal. It can be passed to g_hash_table_new() as the
// key_equal_func parameter, when using non-NULL pointers to doubles as keys in
// a Table.
//
// The function takes the following parameters:
//
//    - v1: pointer to a #gdouble key.
//    - v2: pointer to a #gdouble key to compare with v1.
//
func DoubleEqual(v1, v2 cgo.Handle) bool {
	var _arg1 C.gconstpointer // out
	var _arg2 C.gconstpointer // out
	var _cret C.gboolean      // in

	_arg1 = (C.gconstpointer)(unsafe.Pointer(v1))
	_arg2 = (C.gconstpointer)(unsafe.Pointer(v2))

	_cret = C.g_double_equal(_arg1, _arg2)
	runtime.KeepAlive(v1)
	runtime.KeepAlive(v2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DoubleHash converts a pointer to a #gdouble to a hash value. It can be passed
// to g_hash_table_new() as the hash_func parameter, It can be passed to
// g_hash_table_new() as the hash_func parameter, when using non-NULL pointers
// to doubles as keys in a Table.
//
// The function takes the following parameters:
//
//    - v: pointer to a #gdouble key.
//
func DoubleHash(v cgo.Handle) uint {
	var _arg1 C.gconstpointer // out
	var _cret C.guint         // in

	_arg1 = (C.gconstpointer)(unsafe.Pointer(v))

	_cret = C.g_double_hash(_arg1)
	runtime.KeepAlive(v)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Int64Equal compares the two #gint64 values being pointed to and returns TRUE
// if they are equal. It can be passed to g_hash_table_new() as the
// key_equal_func parameter, when using non-NULL pointers to 64-bit integers as
// keys in a Table.
//
// The function takes the following parameters:
//
//    - v1: pointer to a #gint64 key.
//    - v2: pointer to a #gint64 key to compare with v1.
//
func Int64Equal(v1, v2 cgo.Handle) bool {
	var _arg1 C.gconstpointer // out
	var _arg2 C.gconstpointer // out
	var _cret C.gboolean      // in

	_arg1 = (C.gconstpointer)(unsafe.Pointer(v1))
	_arg2 = (C.gconstpointer)(unsafe.Pointer(v2))

	_cret = C.g_int64_equal(_arg1, _arg2)
	runtime.KeepAlive(v1)
	runtime.KeepAlive(v2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Int64Hash converts a pointer to a #gint64 to a hash value.
//
// It can be passed to g_hash_table_new() as the hash_func parameter, when using
// non-NULL pointers to 64-bit integer values as keys in a Table.
//
// The function takes the following parameters:
//
//    - v: pointer to a #gint64 key.
//
func Int64Hash(v cgo.Handle) uint {
	var _arg1 C.gconstpointer // out
	var _cret C.guint         // in

	_arg1 = (C.gconstpointer)(unsafe.Pointer(v))

	_cret = C.g_int64_hash(_arg1)
	runtime.KeepAlive(v)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// IntEqual compares the two #gint values being pointed to and returns TRUE if
// they are equal. It can be passed to g_hash_table_new() as the key_equal_func
// parameter, when using non-NULL pointers to integers as keys in a Table.
//
// Note that this function acts on pointers to #gint, not on #gint directly: if
// your hash table's keys are of the form GINT_TO_POINTER (n), use
// g_direct_equal() instead.
//
// The function takes the following parameters:
//
//    - v1: pointer to a #gint key.
//    - v2: pointer to a #gint key to compare with v1.
//
func IntEqual(v1, v2 cgo.Handle) bool {
	var _arg1 C.gconstpointer // out
	var _arg2 C.gconstpointer // out
	var _cret C.gboolean      // in

	_arg1 = (C.gconstpointer)(unsafe.Pointer(v1))
	_arg2 = (C.gconstpointer)(unsafe.Pointer(v2))

	_cret = C.g_int_equal(_arg1, _arg2)
	runtime.KeepAlive(v1)
	runtime.KeepAlive(v2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IntHash converts a pointer to a #gint to a hash value. It can be passed to
// g_hash_table_new() as the hash_func parameter, when using non-NULL pointers
// to integer values as keys in a Table.
//
// Note that this function acts on pointers to #gint, not on #gint directly: if
// your hash table's keys are of the form GINT_TO_POINTER (n), use
// g_direct_hash() instead.
//
// The function takes the following parameters:
//
//    - v: pointer to a #gint key.
//
func IntHash(v cgo.Handle) uint {
	var _arg1 C.gconstpointer // out
	var _cret C.guint         // in

	_arg1 = (C.gconstpointer)(unsafe.Pointer(v))

	_cret = C.g_int_hash(_arg1)
	runtime.KeepAlive(v)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// StrEqual compares two strings for byte-by-byte equality and returns TRUE if
// they are equal. It can be passed to g_hash_table_new() as the key_equal_func
// parameter, when using non-NULL strings as keys in a Table.
//
// This function is typically used for hash table comparisons, but can be used
// for general purpose comparisons of non-NULL strings. For a NULL-safe string
// comparison function, see g_strcmp0().
//
// The function takes the following parameters:
//
//    - v1: key.
//    - v2: key to compare with v1.
//
func StrEqual(v1, v2 cgo.Handle) bool {
	var _arg1 C.gconstpointer // out
	var _arg2 C.gconstpointer // out
	var _cret C.gboolean      // in

	_arg1 = (C.gconstpointer)(unsafe.Pointer(v1))
	_arg2 = (C.gconstpointer)(unsafe.Pointer(v2))

	_cret = C.g_str_equal(_arg1, _arg2)
	runtime.KeepAlive(v1)
	runtime.KeepAlive(v2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// StrHash converts a string to a hash value.
//
// This function implements the widely used "djb" hash apparently posted by
// Daniel Bernstein to comp.lang.c some time ago. The 32 bit unsigned hash value
// starts at 5381 and for each byte 'c' in the string, is updated: hash = hash *
// 33 + c. This function uses the signed value of each byte.
//
// It can be passed to g_hash_table_new() as the hash_func parameter, when using
// non-NULL strings as keys in a Table.
//
// Note that this function may not be a perfect fit for all use cases. For
// example, it produces some hash collisions with strings as short as 2.
//
// The function takes the following parameters:
//
//    - v: string key.
//
func StrHash(v cgo.Handle) uint {
	var _arg1 C.gconstpointer // out
	var _cret C.guint         // in

	_arg1 = (C.gconstpointer)(unsafe.Pointer(v))

	_cret = C.g_str_hash(_arg1)
	runtime.KeepAlive(v)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}
