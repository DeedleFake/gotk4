// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"reflect"
	"runtime"
	"unsafe"
)

// #cgo pkg-config: glib-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <stdbool.h>
// #include <glib.h>
import "C"

// BookmarkFileError: error codes returned by bookmark file parsing.
type BookmarkFileError int

const (
	// BookmarkFileErrorInvalidURI: URI was ill-formed
	BookmarkFileErrorInvalidURI BookmarkFileError = 0
	// BookmarkFileErrorInvalidValue: a requested field was not found
	BookmarkFileErrorInvalidValue BookmarkFileError = 1
	// BookmarkFileErrorAppNotRegistered: a requested application did not
	// register a bookmark
	BookmarkFileErrorAppNotRegistered BookmarkFileError = 2
	// BookmarkFileErrorURINotFound: a requested URI was not found
	BookmarkFileErrorURINotFound BookmarkFileError = 3
	// BookmarkFileErrorRead: document was ill formed
	BookmarkFileErrorRead BookmarkFileError = 4
	// BookmarkFileErrorUnknownEncoding: the text being parsed was in an unknown
	// encoding
	BookmarkFileErrorUnknownEncoding BookmarkFileError = 5
	// BookmarkFileErrorWrite: an error occurred while writing
	BookmarkFileErrorWrite BookmarkFileError = 6
	// BookmarkFileErrorFileNotFound: requested file was not found
	BookmarkFileErrorFileNotFound BookmarkFileError = 7
)

// BookmarkFile: the `GBookmarkFile` structure contains only private data and
// should not be directly accessed.
type BookmarkFile struct {
	native C.GBookmarkFile
}

// WrapBookmarkFile wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapBookmarkFile(ptr unsafe.Pointer) *BookmarkFile {
	if ptr == nil {
		return nil
	}

	return (*BookmarkFile)(ptr)
}

func marshalBookmarkFile(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapBookmarkFile(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (b *BookmarkFile) Native() unsafe.Pointer {
	return unsafe.Pointer(&b.native)
}

// AddApplication adds the application with @name and @exec to the list of
// applications that have registered a bookmark for @uri into @bookmark.
//
// Every bookmark inside a File must have at least an application registered.
// Each application must provide a name, a command line useful for launching the
// bookmark, the number of times the bookmark has been registered by the
// application and the last time the application registered this bookmark.
//
// If @name is nil, the name of the application will be the same returned by
// g_get_application_name(); if @exec is nil, the command line will be a
// composition of the program name as returned by g_get_prgname() and the "\u"
// modifier, which will be expanded to the bookmark's URI.
//
// This function will automatically take care of updating the registrations
// count and timestamping in case an application with the same @name had already
// registered a bookmark for @uri inside @bookmark.
//
// If no bookmark for @uri is found, one is created.
func (b *BookmarkFile) AddApplication(uri string, name string, exec string) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(exec))
	defer C.free(unsafe.Pointer(arg3))

	C.g_bookmark_file_add_application(arg0, arg1, arg2, arg3)
}

// AddGroup adds @group to the list of groups to which the bookmark for @uri
// belongs to.
//
// If no bookmark for @uri is found then it is created.
func (b *BookmarkFile) AddGroup(uri string, group string) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(group))
	defer C.free(unsafe.Pointer(arg2))

	C.g_bookmark_file_add_group(arg0, arg1, arg2)
}

// Free frees a File.
func (b *BookmarkFile) Free() {
	var arg0 *C.GBookmarkFile

	arg0 = (*C.GBookmarkFile)(b.Native())

	C.g_bookmark_file_free(arg0)
}

// Added gets the time the bookmark for @uri was added to @bookmark
//
// In the event the URI cannot be found, -1 is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (b *BookmarkFile) Added(uri string) (glong int32, err error) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_bookmark_file_get_added(arg0, arg1, &gError)

	var ret0 int32
	var goError error

	ret0 = int32(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// AddedDateTime gets the time the bookmark for @uri was added to @bookmark
//
// In the event the URI cannot be found, nil is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (b *BookmarkFile) AddedDateTime(uri string) (dateTime *DateTime, err error) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.char
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_bookmark_file_get_added_date_time(arg0, arg1, &gError)

	var ret0 *DateTime
	var goError error

	{
		ret0 = WrapDateTime(unsafe.Pointer(ret))
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// AppInfo gets the registration information of @app_name for the bookmark for
// @uri. See g_bookmark_file_set_application_info() for more information about
// the returned data.
//
// The string returned in @app_exec must be freed.
//
// In the event the URI cannot be found, false is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND. In the event that no application with name
// @app_name has registered a bookmark for @uri, false is returned and error is
// set to BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED. In the event that unquoting
// the command line fails, an error of the SHELL_ERROR domain is set and false
// is returned.
func (b *BookmarkFile) AppInfo(uri string, name string) (exec string, count uint, stamp int32, err error) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 **C.gchar // out
	var arg4 *C.guint  // out
	var arg5 *C.time_t // out
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_bookmark_file_get_app_info(arg0, arg1, arg2, &arg3, &arg4, &arg5, &gError)

	var ret0 string
	var ret1 uint
	var ret2 int32
	var goError error

	ret0 = C.GoString(arg3)
	C.free(unsafe.Pointer(arg3))

	ret1 = uint(arg4)

	ret2 = int32(arg5)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}

// ApplicationInfo gets the registration information of @app_name for the
// bookmark for @uri. See g_bookmark_file_set_application_info() for more
// information about the returned data.
//
// The string returned in @app_exec must be freed.
//
// In the event the URI cannot be found, false is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND. In the event that no application with name
// @app_name has registered a bookmark for @uri, false is returned and error is
// set to BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED. In the event that unquoting
// the command line fails, an error of the SHELL_ERROR domain is set and false
// is returned.
func (b *BookmarkFile) ApplicationInfo(uri string, name string) (exec string, count uint, stamp *DateTime, err error) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.char
	var arg2 *C.char
	var arg3 **C.char      // out
	var arg4 *C.uint       // out
	var arg5 **C.GDateTime // out
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_bookmark_file_get_application_info(arg0, arg1, arg2, &arg3, &arg4, &arg5, &gError)

	var ret0 string
	var ret1 uint
	var ret2 **DateTime
	var goError error

	ret0 = C.GoString(arg3)
	C.free(unsafe.Pointer(arg3))

	ret1 = uint(arg4)

	{
		ret2 = WrapDateTime(unsafe.Pointer(arg5))
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}

// Applications retrieves the names of the applications that have registered the
// bookmark for @uri.
//
// In the event the URI cannot be found, nil is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (b *BookmarkFile) Applications(uri string) (length uint, utf8s []string, err error) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 *C.gsize // out
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_bookmark_file_get_applications(arg0, arg1, &arg2, &gError)

	var ret0 uint
	var ret1 []string
	var goError error

	ret0 = uint(arg2)

	{
		ret1 = make([]string, arg2)
		for i := 0; i < uintptr(arg2); i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// Description retrieves the description of the bookmark for @uri.
//
// In the event the URI cannot be found, nil is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (b *BookmarkFile) Description(uri string) (utf8 string, err error) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_bookmark_file_get_description(arg0, arg1, &gError)

	var ret0 string
	var goError error

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Groups retrieves the list of group names of the bookmark for @uri.
//
// In the event the URI cannot be found, nil is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
//
// The returned array is nil terminated, so @length may optionally be nil.
func (b *BookmarkFile) Groups(uri string) (length uint, utf8s []string, err error) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 *C.gsize // out
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_bookmark_file_get_groups(arg0, arg1, &arg2, &gError)

	var ret0 uint
	var ret1 []string
	var goError error

	ret0 = uint(arg2)

	{
		ret1 = make([]string, arg2)
		for i := 0; i < uintptr(arg2); i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// Icon gets the icon of the bookmark for @uri.
//
// In the event the URI cannot be found, false is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (b *BookmarkFile) Icon(uri string) (href string, mimeType string, err error) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 **C.gchar // out
	var arg3 **C.gchar // out
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_bookmark_file_get_icon(arg0, arg1, &arg2, &arg3, &gError)

	var ret0 string
	var ret1 string
	var goError error

	ret0 = C.GoString(arg2)
	C.free(unsafe.Pointer(arg2))

	ret1 = C.GoString(arg3)
	C.free(unsafe.Pointer(arg3))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// IsPrivate gets whether the private flag of the bookmark for @uri is set.
//
// In the event the URI cannot be found, false is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND. In the event that the private flag cannot
// be found, false is returned and @error is set to
// BOOKMARK_FILE_ERROR_INVALID_VALUE.
func (b *BookmarkFile) IsPrivate(uri string) error {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_bookmark_file_get_is_private(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// MIMEType retrieves the MIME type of the resource pointed by @uri.
//
// In the event the URI cannot be found, nil is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND. In the event that the MIME type cannot be
// found, nil is returned and @error is set to
// BOOKMARK_FILE_ERROR_INVALID_VALUE.
func (b *BookmarkFile) MIMEType(uri string) (utf8 string, err error) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_bookmark_file_get_mime_type(arg0, arg1, &gError)

	var ret0 string
	var goError error

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Modified gets the time when the bookmark for @uri was last modified.
//
// In the event the URI cannot be found, -1 is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (b *BookmarkFile) Modified(uri string) (glong int32, err error) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_bookmark_file_get_modified(arg0, arg1, &gError)

	var ret0 int32
	var goError error

	ret0 = int32(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// ModifiedDateTime gets the time when the bookmark for @uri was last modified.
//
// In the event the URI cannot be found, nil is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (b *BookmarkFile) ModifiedDateTime(uri string) (dateTime *DateTime, err error) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.char
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_bookmark_file_get_modified_date_time(arg0, arg1, &gError)

	var ret0 *DateTime
	var goError error

	{
		ret0 = WrapDateTime(unsafe.Pointer(ret))
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Size gets the number of bookmarks inside @bookmark.
func (b *BookmarkFile) Size() int {
	var arg0 *C.GBookmarkFile

	arg0 = (*C.GBookmarkFile)(b.Native())

	ret := C.g_bookmark_file_get_size(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Title returns the title of the bookmark for @uri.
//
// If @uri is nil, the title of @bookmark is returned.
//
// In the event the URI cannot be found, nil is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (b *BookmarkFile) Title(uri string) (utf8 string, err error) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_bookmark_file_get_title(arg0, arg1, &gError)

	var ret0 string
	var goError error

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Uris returns all URIs of the bookmarks in the bookmark file @bookmark. The
// array of returned URIs will be nil-terminated, so @length may optionally be
// nil.
func (b *BookmarkFile) Uris() (length uint, utf8s []string) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gsize // out

	arg0 = (*C.GBookmarkFile)(b.Native())

	ret := C.g_bookmark_file_get_uris(arg0, &arg1)

	var ret0 uint
	var ret1 []string

	ret0 = uint(arg1)

	{
		ret1 = make([]string, arg1)
		for i := 0; i < uintptr(arg1); i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0, ret1
}

// Visited gets the time the bookmark for @uri was last visited.
//
// In the event the URI cannot be found, -1 is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (b *BookmarkFile) Visited(uri string) (glong int32, err error) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_bookmark_file_get_visited(arg0, arg1, &gError)

	var ret0 int32
	var goError error

	ret0 = int32(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// VisitedDateTime gets the time the bookmark for @uri was last visited.
//
// In the event the URI cannot be found, nil is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (b *BookmarkFile) VisitedDateTime(uri string) (dateTime *DateTime, err error) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.char
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_bookmark_file_get_visited_date_time(arg0, arg1, &gError)

	var ret0 *DateTime
	var goError error

	{
		ret0 = WrapDateTime(unsafe.Pointer(ret))
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// HasApplication checks whether the bookmark for @uri inside @bookmark has been
// registered by application @name.
//
// In the event the URI cannot be found, false is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (b *BookmarkFile) HasApplication(uri string, name string) error {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_bookmark_file_has_application(arg0, arg1, arg2, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// HasGroup checks whether @group appears in the list of groups to which the
// bookmark for @uri belongs to.
//
// In the event the URI cannot be found, false is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (b *BookmarkFile) HasGroup(uri string, group string) error {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(group))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_bookmark_file_has_group(arg0, arg1, arg2, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// HasItem looks whether the desktop bookmark has an item with its URI set to
// @uri.
func (b *BookmarkFile) HasItem(uri string) bool {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_bookmark_file_has_item(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// LoadFromData loads a bookmark file from memory into an empty File structure.
// If the object cannot be created then @error is set to a FileError.
func (b *BookmarkFile) LoadFromData(data []byte) error {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 C.gsize
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(unsafe.Pointer(&data[0]))
	arg2 = len(data)
	defer runtime.KeepAlive(data)

	ret := C.g_bookmark_file_load_from_data(arg0, arg1, arg2, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// LoadFromDataDirs: this function looks for a desktop bookmark file named @file
// in the paths returned from g_get_user_data_dir() and
// g_get_system_data_dirs(), loads the file into @bookmark and returns the
// file's full path in @full_path. If the file could not be loaded then @error
// is set to either a Error or FileError.
func (b *BookmarkFile) LoadFromDataDirs(file string) (fullPath string, err error) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 **C.gchar // out
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(file))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_bookmark_file_load_from_data_dirs(arg0, arg1, &arg2, &gError)

	var ret0 string
	var goError error

	ret0 = C.GoString(arg2)
	C.free(unsafe.Pointer(arg2))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// LoadFromFile loads a desktop bookmark file into an empty File structure. If
// the file could not be loaded then @error is set to either a Error or
// FileError.
func (b *BookmarkFile) LoadFromFile(filename string) error {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_bookmark_file_load_from_file(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// MoveItem changes the URI of a bookmark item from @old_uri to @new_uri. Any
// existing bookmark for @new_uri will be overwritten. If @new_uri is nil, then
// the bookmark is removed.
//
// In the event the URI cannot be found, false is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (b *BookmarkFile) MoveItem(oldURI string, newURI string) error {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(oldURI))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(newURI))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_bookmark_file_move_item(arg0, arg1, arg2, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// RemoveApplication removes application registered with @name from the list of
// applications that have registered a bookmark for @uri inside @bookmark.
//
// In the event the URI cannot be found, false is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND. In the event that no application with name
// @app_name has registered a bookmark for @uri, false is returned and error is
// set to BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED.
func (b *BookmarkFile) RemoveApplication(uri string, name string) error {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_bookmark_file_remove_application(arg0, arg1, arg2, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// RemoveGroup removes @group from the list of groups to which the bookmark for
// @uri belongs to.
//
// In the event the URI cannot be found, false is returned and @error is set to
// BOOKMARK_FILE_ERROR_URI_NOT_FOUND. In the event no group was defined, false
// is returned and @error is set to BOOKMARK_FILE_ERROR_INVALID_VALUE.
func (b *BookmarkFile) RemoveGroup(uri string, group string) error {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(group))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_bookmark_file_remove_group(arg0, arg1, arg2, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// RemoveItem removes the bookmark for @uri from the bookmark file @bookmark.
func (b *BookmarkFile) RemoveItem(uri string) error {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_bookmark_file_remove_item(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SetAdded sets the time the bookmark for @uri was added into @bookmark.
//
// If no bookmark for @uri is found then it is created.
func (b *BookmarkFile) SetAdded(uri string, added int32) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 C.time_t

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.time_t(added)

	C.g_bookmark_file_set_added(arg0, arg1, arg2)
}

// SetAddedDateTime sets the time the bookmark for @uri was added into
// @bookmark.
//
// If no bookmark for @uri is found then it is created.
func (b *BookmarkFile) SetAddedDateTime(uri string, added *DateTime) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.char
	var arg2 *C.GDateTime

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GDateTime)(added.Native())

	C.g_bookmark_file_set_added_date_time(arg0, arg1, arg2)
}

// SetAppInfo sets the meta-data of application @name inside the list of
// applications that have registered a bookmark for @uri inside @bookmark.
//
// You should rarely use this function; use g_bookmark_file_add_application()
// and g_bookmark_file_remove_application() instead.
//
// @name can be any UTF-8 encoded string used to identify an application. @exec
// can have one of these two modifiers: "\f", which will be expanded as the
// local file name retrieved from the bookmark's URI; "\u", which will be
// expanded as the bookmark's URI. The expansion is done automatically when
// retrieving the stored command line using the
// g_bookmark_file_get_application_info() function. @count is the number of
// times the application has registered the bookmark; if is < 0, the current
// registration count will be increased by one, if is 0, the application with
// @name will be removed from the list of registered applications. @stamp is the
// Unix time of the last registration; if it is -1, the current time will be
// used.
//
// If you try to remove an application by setting its registration count to
// zero, and no bookmark for @uri is found, false is returned and @error is set
// to BOOKMARK_FILE_ERROR_URI_NOT_FOUND; similarly, in the event that no
// application @name has registered a bookmark for @uri, false is returned and
// error is set to BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED. Otherwise, if no
// bookmark for @uri is found, one is created.
func (b *BookmarkFile) SetAppInfo(uri string, name string, exec string, count int, stamp int32) error {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 C.gint
	var arg5 C.time_t
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(exec))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = C.gint(count)
	arg5 = C.time_t(stamp)

	ret := C.g_bookmark_file_set_app_info(arg0, arg1, arg2, arg3, arg4, arg5, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SetApplicationInfo sets the meta-data of application @name inside the list of
// applications that have registered a bookmark for @uri inside @bookmark.
//
// You should rarely use this function; use g_bookmark_file_add_application()
// and g_bookmark_file_remove_application() instead.
//
// @name can be any UTF-8 encoded string used to identify an application. @exec
// can have one of these two modifiers: "\f", which will be expanded as the
// local file name retrieved from the bookmark's URI; "\u", which will be
// expanded as the bookmark's URI. The expansion is done automatically when
// retrieving the stored command line using the
// g_bookmark_file_get_application_info() function. @count is the number of
// times the application has registered the bookmark; if is < 0, the current
// registration count will be increased by one, if is 0, the application with
// @name will be removed from the list of registered applications. @stamp is the
// Unix time of the last registration.
//
// If you try to remove an application by setting its registration count to
// zero, and no bookmark for @uri is found, false is returned and @error is set
// to BOOKMARK_FILE_ERROR_URI_NOT_FOUND; similarly, in the event that no
// application @name has registered a bookmark for @uri, false is returned and
// error is set to BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED. Otherwise, if no
// bookmark for @uri is found, one is created.
func (b *BookmarkFile) SetApplicationInfo(uri string, name string, exec string, count int, stamp *DateTime) error {
	var arg0 *C.GBookmarkFile
	var arg1 *C.char
	var arg2 *C.char
	var arg3 *C.char
	var arg4 C.int
	var arg5 *C.GDateTime
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(exec))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = C.int(count)
	arg5 = (*C.GDateTime)(stamp.Native())

	ret := C.g_bookmark_file_set_application_info(arg0, arg1, arg2, arg3, arg4, arg5, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SetDescription sets @description as the description of the bookmark for @uri.
//
// If @uri is nil, the description of @bookmark is set.
//
// If a bookmark for @uri cannot be found then it is created.
func (b *BookmarkFile) SetDescription(uri string, description string) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(description))
	defer C.free(unsafe.Pointer(arg2))

	C.g_bookmark_file_set_description(arg0, arg1, arg2)
}

// SetGroups sets a list of group names for the item with URI @uri. Each
// previously set group name list is removed.
//
// If @uri cannot be found then an item for it is created.
func (b *BookmarkFile) SetGroups(uri string, groups []string) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 **C.gchar
	var arg3 C.gsize

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * len(groups))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(groups)
		sliceHeader.Cap = len(groups)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(groups); i++ {
			src := groups[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg2 = (**C.gchar)(unsafe.Pointer(ptr))
		arg3 = len(groups)
	}

	C.g_bookmark_file_set_groups(arg0, arg1, arg2, arg3)
}

// SetIcon sets the icon for the bookmark for @uri. If @href is nil, unsets the
// currently set icon. @href can either be a full URL for the icon file or the
// icon name following the Icon Naming specification.
//
// If no bookmark for @uri is found one is created.
func (b *BookmarkFile) SetIcon(uri string, href string, mimeType string) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(href))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(mimeType))
	defer C.free(unsafe.Pointer(arg3))

	C.g_bookmark_file_set_icon(arg0, arg1, arg2, arg3)
}

// SetIsPrivate sets the private flag of the bookmark for @uri.
//
// If a bookmark for @uri cannot be found then it is created.
func (b *BookmarkFile) SetIsPrivate(uri string, isPrivate bool) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 C.gboolean

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	if isPrivate {
		arg2 = C.TRUE
	}

	C.g_bookmark_file_set_is_private(arg0, arg1, arg2)
}

// SetMIMEType sets @mime_type as the MIME type of the bookmark for @uri.
//
// If a bookmark for @uri cannot be found then it is created.
func (b *BookmarkFile) SetMIMEType(uri string, mimeType string) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(mimeType))
	defer C.free(unsafe.Pointer(arg2))

	C.g_bookmark_file_set_mime_type(arg0, arg1, arg2)
}

// SetModified sets the last time the bookmark for @uri was last modified.
//
// If no bookmark for @uri is found then it is created.
//
// The "modified" time should only be set when the bookmark's meta-data was
// actually changed. Every function of File that modifies a bookmark also
// changes the modification time, except for
// g_bookmark_file_set_visited_date_time().
func (b *BookmarkFile) SetModified(uri string, modified int32) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 C.time_t

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.time_t(modified)

	C.g_bookmark_file_set_modified(arg0, arg1, arg2)
}

// SetModifiedDateTime sets the last time the bookmark for @uri was last
// modified.
//
// If no bookmark for @uri is found then it is created.
//
// The "modified" time should only be set when the bookmark's meta-data was
// actually changed. Every function of File that modifies a bookmark also
// changes the modification time, except for
// g_bookmark_file_set_visited_date_time().
func (b *BookmarkFile) SetModifiedDateTime(uri string, modified *DateTime) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.char
	var arg2 *C.GDateTime

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GDateTime)(modified.Native())

	C.g_bookmark_file_set_modified_date_time(arg0, arg1, arg2)
}

// SetTitle sets @title as the title of the bookmark for @uri inside the
// bookmark file @bookmark.
//
// If @uri is nil, the title of @bookmark is set.
//
// If a bookmark for @uri cannot be found then it is created.
func (b *BookmarkFile) SetTitle(uri string, title string) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(arg2))

	C.g_bookmark_file_set_title(arg0, arg1, arg2)
}

// SetVisited sets the time the bookmark for @uri was last visited.
//
// If no bookmark for @uri is found then it is created.
//
// The "visited" time should only be set if the bookmark was launched, either
// using the command line retrieved by g_bookmark_file_get_application_info() or
// by the default application for the bookmark's MIME type, retrieved using
// g_bookmark_file_get_mime_type(). Changing the "visited" time does not affect
// the "modified" time.
func (b *BookmarkFile) SetVisited(uri string, visited int32) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var arg2 C.time_t

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.time_t(visited)

	C.g_bookmark_file_set_visited(arg0, arg1, arg2)
}

// SetVisitedDateTime sets the time the bookmark for @uri was last visited.
//
// If no bookmark for @uri is found then it is created.
//
// The "visited" time should only be set if the bookmark was launched, either
// using the command line retrieved by g_bookmark_file_get_application_info() or
// by the default application for the bookmark's MIME type, retrieved using
// g_bookmark_file_get_mime_type(). Changing the "visited" time does not affect
// the "modified" time.
func (b *BookmarkFile) SetVisitedDateTime(uri string, visited *DateTime) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.char
	var arg2 *C.GDateTime

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GDateTime)(visited.Native())

	C.g_bookmark_file_set_visited_date_time(arg0, arg1, arg2)
}

// ToData: this function outputs @bookmark as a string.
func (b *BookmarkFile) ToData() (length uint, guint8s []byte, err error) {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gsize // out
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(b.Native())

	ret := C.g_bookmark_file_to_data(arg0, &arg1, &gError)

	var ret0 uint
	var ret1 []byte
	var goError error

	ret0 = uint(arg1)

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret1))
		sliceHeader.Data = uintptr(unsafe.Pointer(ret))
		sliceHeader.Len = arg1
		sliceHeader.Cap = arg1
		runtime.SetFinalizer(&ret, func() {
			C.free(unsafe.Pointer(ret))
		})
		defer runtime.KeepAlive(ret)
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// ToFile: this function outputs @bookmark into a file. The write process is
// guaranteed to be atomic by using g_file_set_contents() internally.
func (b *BookmarkFile) ToFile(filename string) error {
	var arg0 *C.GBookmarkFile
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GBookmarkFile)(b.Native())
	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_bookmark_file_to_file(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}
