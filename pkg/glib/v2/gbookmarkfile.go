// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"unsafe"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib.h>
import "C"

// BookmarkFileError: error codes returned by bookmark file parsing.
type BookmarkFileError int

const (
	// BookmarkFileErrorInvalidURI: URI was ill-formed
	BookmarkFileErrorInvalidURI BookmarkFileError = 0
	// BookmarkFileErrorInvalidValue: a requested field was not found
	BookmarkFileErrorInvalidValue BookmarkFileError = 1
	// BookmarkFileErrorAppNotRegistered: a requested application did not
	// register a bookmark
	BookmarkFileErrorAppNotRegistered BookmarkFileError = 2
	// BookmarkFileErrorURINotFound: a requested URI was not found
	BookmarkFileErrorURINotFound BookmarkFileError = 3
	// BookmarkFileErrorRead: document was ill formed
	BookmarkFileErrorRead BookmarkFileError = 4
	// BookmarkFileErrorUnknownEncoding: the text being parsed was in an unknown
	// encoding
	BookmarkFileErrorUnknownEncoding BookmarkFileError = 5
	// BookmarkFileErrorWrite: an error occurred while writing
	BookmarkFileErrorWrite BookmarkFileError = 6
	// BookmarkFileErrorFileNotFound: requested file was not found
	BookmarkFileErrorFileNotFound BookmarkFileError = 7
)

// BookmarkFile: the `GBookmarkFile` structure contains only private data and
// should not be directly accessed.
type BookmarkFile struct {
	native C.GBookmarkFile
}

// WrapBookmarkFile wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapBookmarkFile(ptr unsafe.Pointer) *BookmarkFile {
	if ptr == nil {
		return nil
	}

	return (*BookmarkFile)(ptr)
}

// Native returns the underlying C source pointer.
func (b *BookmarkFile) Native() unsafe.Pointer {
	return unsafe.Pointer(&b.native)
}

// AddApplication adds the application with @name and @exec to the list of
// applications that have registered a bookmark for @uri into @bookmark.
//
// Every bookmark inside a File must have at least an application registered.
// Each application must provide a name, a command line useful for launching the
// bookmark, the number of times the bookmark has been registered by the
// application and the last time the application registered this bookmark.
//
// If @name is nil, the name of the application will be the same returned by
// g_get_application_name(); if @exec is nil, the command line will be a
// composition of the program name as returned by g_get_prgname() and the "\u"
// modifier, which will be expanded to the bookmark's URI.
//
// This function will automatically take care of updating the registrations
// count and timestamping in case an application with the same @name had already
// registered a bookmark for @uri inside @bookmark.
//
// If no bookmark for @uri is found, one is created.
func (b *BookmarkFile) AddApplication(uri string, name string, exec string) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out
	var _arg3 *C.gchar         // out

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(exec))
	defer C.free(unsafe.Pointer(_arg3))

	C.g_bookmark_file_add_application(_arg0, _arg1, _arg2, _arg3)
}

// AddGroup adds @group to the list of groups to which the bookmark for @uri
// belongs to.
//
// If no bookmark for @uri is found then it is created.
func (b *BookmarkFile) AddGroup(uri string, group string) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(group))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_bookmark_file_add_group(_arg0, _arg1, _arg2)
}

// Free frees a File.
func (b *BookmarkFile) Free() {
	var _arg0 *C.GBookmarkFile // out

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))

	C.g_bookmark_file_free(_arg0)
}

// Size gets the number of bookmarks inside @bookmark.
func (b *BookmarkFile) Size() int {
	var _arg0 *C.GBookmarkFile // out

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))

	var _cret C.gint // in

	_cret = C.g_bookmark_file_get_size(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Uris returns all URIs of the bookmarks in the bookmark file @bookmark. The
// array of returned URIs will be nil-terminated, so @length may optionally be
// nil.
func (b *BookmarkFile) Uris() []string {
	var _arg0 *C.GBookmarkFile // out

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))

	var _cret **C.gchar
	var _arg1 C.gsize // in

	_cret = C.g_bookmark_file_get_uris(_arg0, &_arg1)

	var _utf8s []string

	{
		src := unsafe.Slice(_cret, _arg1)
		defer C.free(unsafe.Pointer(_cret))
		_utf8s = make([]string, _arg1)
		for i := 0; i < int(_arg1); i++ {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// HasItem looks whether the desktop bookmark has an item with its URI set to
// @uri.
func (b *BookmarkFile) HasItem(uri string) bool {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret C.gboolean // in

	_cret = C.g_bookmark_file_has_item(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetAdded sets the time the bookmark for @uri was added into @bookmark.
//
// If no bookmark for @uri is found then it is created.
func (b *BookmarkFile) SetAdded(uri string, added int32) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 C.time_t         // out

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.time_t(added)

	C.g_bookmark_file_set_added(_arg0, _arg1, _arg2)
}

// SetDescription sets @description as the description of the bookmark for @uri.
//
// If @uri is nil, the description of @bookmark is set.
//
// If a bookmark for @uri cannot be found then it is created.
func (b *BookmarkFile) SetDescription(uri string, description string) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(description))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_bookmark_file_set_description(_arg0, _arg1, _arg2)
}

// SetGroups sets a list of group names for the item with URI @uri. Each
// previously set group name list is removed.
//
// If @uri cannot be found then an item for it is created.
func (b *BookmarkFile) SetGroups(uri string, groups []string) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 **C.gchar
	var _arg3 C.gsize

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg3 = C.gsize(len(groups))
	_arg2 = (**C.gchar)(C.malloc(C.ulong(len(groups)) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg2))

	{
		out := unsafe.Slice(_arg2, len(groups))
		for i := range groups {
			out[i] = (*C.gchar)(C.CString(groups[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.g_bookmark_file_set_groups(_arg0, _arg1, _arg2, _arg3)
}

// SetIcon sets the icon for the bookmark for @uri. If @href is nil, unsets the
// currently set icon. @href can either be a full URL for the icon file or the
// icon name following the Icon Naming specification.
//
// If no bookmark for @uri is found one is created.
func (b *BookmarkFile) SetIcon(uri string, href string, mimeType string) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out
	var _arg3 *C.gchar         // out

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(href))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(mimeType))
	defer C.free(unsafe.Pointer(_arg3))

	C.g_bookmark_file_set_icon(_arg0, _arg1, _arg2, _arg3)
}

// SetIsPrivate sets the private flag of the bookmark for @uri.
//
// If a bookmark for @uri cannot be found then it is created.
func (b *BookmarkFile) SetIsPrivate(uri string, isPrivate bool) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 C.gboolean       // out

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	if isPrivate {
		_arg2 = C.TRUE
	}

	C.g_bookmark_file_set_is_private(_arg0, _arg1, _arg2)
}

// SetMIMEType sets @mime_type as the MIME type of the bookmark for @uri.
//
// If a bookmark for @uri cannot be found then it is created.
func (b *BookmarkFile) SetMIMEType(uri string, mimeType string) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(mimeType))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_bookmark_file_set_mime_type(_arg0, _arg1, _arg2)
}

// SetModified sets the last time the bookmark for @uri was last modified.
//
// If no bookmark for @uri is found then it is created.
//
// The "modified" time should only be set when the bookmark's meta-data was
// actually changed. Every function of File that modifies a bookmark also
// changes the modification time, except for
// g_bookmark_file_set_visited_date_time().
func (b *BookmarkFile) SetModified(uri string, modified int32) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 C.time_t         // out

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.time_t(modified)

	C.g_bookmark_file_set_modified(_arg0, _arg1, _arg2)
}

// SetTitle sets @title as the title of the bookmark for @uri inside the
// bookmark file @bookmark.
//
// If @uri is nil, the title of @bookmark is set.
//
// If a bookmark for @uri cannot be found then it is created.
func (b *BookmarkFile) SetTitle(uri string, title string) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_bookmark_file_set_title(_arg0, _arg1, _arg2)
}

// SetVisited sets the time the bookmark for @uri was last visited.
//
// If no bookmark for @uri is found then it is created.
//
// The "visited" time should only be set if the bookmark was launched, either
// using the command line retrieved by g_bookmark_file_get_application_info() or
// by the default application for the bookmark's MIME type, retrieved using
// g_bookmark_file_get_mime_type(). Changing the "visited" time does not affect
// the "modified" time.
func (b *BookmarkFile) SetVisited(uri string, visited int32) {
	var _arg0 *C.GBookmarkFile // out
	var _arg1 *C.gchar         // out
	var _arg2 C.time_t         // out

	_arg0 = (*C.GBookmarkFile)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.time_t(visited)

	C.g_bookmark_file_set_visited(_arg0, _arg1, _arg2)
}
