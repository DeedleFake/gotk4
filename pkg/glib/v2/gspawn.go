// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
)

// #cgo pkg-config: glib-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <glib.h>
//
// extern void gotk4_SpawnChildSetupFunc(gpointer _0);
import "C"

// SpawnError: error codes returned by spawning processes.
type SpawnError int

const (
	// SpawnErrorFork: fork failed due to lack of memory.
	SpawnErrorFork SpawnError = 0
	// SpawnErrorRead: read or select on pipes failed.
	SpawnErrorRead SpawnError = 1
	// SpawnErrorChdir: changing to working directory failed.
	SpawnErrorChdir SpawnError = 2
	// SpawnErrorAcces: execv() returned `EACCES`
	SpawnErrorAcces SpawnError = 3
	// SpawnErrorPerm: execv() returned `EPERM`
	SpawnErrorPerm SpawnError = 4
	// SpawnErrorTooBig: execv() returned `E2BIG`
	SpawnErrorTooBig SpawnError = 5
	// SpawnError2Big: deprecated alias for G_SPAWN_ERROR_TOO_BIG (deprecated
	// since GLib 2.32)
	SpawnError2Big SpawnError = 5
	// SpawnErrorNoexec: execv() returned `ENOEXEC`
	SpawnErrorNoexec SpawnError = 6
	// SpawnErrorNametoolong: execv() returned `ENAMETOOLONG`
	SpawnErrorNametoolong SpawnError = 7
	// SpawnErrorNoent: execv() returned `ENOENT`
	SpawnErrorNoent SpawnError = 8
	// SpawnErrorNomem: execv() returned `ENOMEM`
	SpawnErrorNomem SpawnError = 9
	// SpawnErrorNotdir: execv() returned `ENOTDIR`
	SpawnErrorNotdir SpawnError = 10
	// SpawnErrorLoop: execv() returned `ELOOP`
	SpawnErrorLoop SpawnError = 11
	// SpawnErrorTxtbusy: execv() returned `ETXTBUSY`
	SpawnErrorTxtbusy SpawnError = 12
	// SpawnErrorIO: execv() returned `EIO`
	SpawnErrorIO SpawnError = 13
	// SpawnErrorNfile: execv() returned `ENFILE`
	SpawnErrorNfile SpawnError = 14
	// SpawnErrorMfile: execv() returned `EMFILE`
	SpawnErrorMfile SpawnError = 15
	// SpawnErrorInval: execv() returned `EINVAL`
	SpawnErrorInval SpawnError = 16
	// SpawnErrorIsdir: execv() returned `EISDIR`
	SpawnErrorIsdir SpawnError = 17
	// SpawnErrorLibbad: execv() returned `ELIBBAD`
	SpawnErrorLibbad SpawnError = 18
	// SpawnErrorFailed: some other fatal failure, `error->message` should
	// explain.
	SpawnErrorFailed SpawnError = 19
)

// SpawnFlags flags passed to g_spawn_sync(), g_spawn_async() and
// g_spawn_async_with_pipes().
type SpawnFlags int

const (
	// SpawnFlagsDefault: no flags, default behaviour
	SpawnFlagsDefault SpawnFlags = 0b0
	// SpawnFlagsLeaveDescriptorsOpen: the parent's open file descriptors will
	// be inherited by the child; otherwise all descriptors except stdin, stdout
	// and stderr will be closed before calling exec() in the child.
	SpawnFlagsLeaveDescriptorsOpen SpawnFlags = 0b1
	// SpawnFlagsDoNotReapChild: the child will not be automatically reaped; you
	// must use g_child_watch_add() yourself (or call waitpid() or handle
	// `SIGCHLD` yourself), or the child will become a zombie.
	SpawnFlagsDoNotReapChild SpawnFlags = 0b10
	// SpawnFlagsSearchPath: `argv[0]` need not be an absolute path, it will be
	// looked for in the user's `PATH`.
	SpawnFlagsSearchPath SpawnFlags = 0b100
	// SpawnFlagsStdoutToDevNull: the child's standard output will be discarded,
	// instead of going to the same location as the parent's standard output.
	SpawnFlagsStdoutToDevNull SpawnFlags = 0b1000
	// SpawnFlagsStderrToDevNull: the child's standard error will be discarded.
	SpawnFlagsStderrToDevNull SpawnFlags = 0b10000
	// SpawnFlagsChildInheritsStdin: the child will inherit the parent's
	// standard input (by default, the child's standard input is attached to
	// `/dev/null`).
	SpawnFlagsChildInheritsStdin SpawnFlags = 0b100000
	// SpawnFlagsFileAndArgvZero: the first element of `argv` is the file to
	// execute, while the remaining elements are the actual argument vector to
	// pass to the file. Normally g_spawn_async_with_pipes() uses `argv[0]` as
	// the file to execute, and passes all of `argv` to the child.
	SpawnFlagsFileAndArgvZero SpawnFlags = 0b1000000
	// SpawnFlagsSearchPathFromEnvp: if `argv[0]` is not an absolute path, it
	// will be looked for in the `PATH` from the passed child environment.
	// Since: 2.34
	SpawnFlagsSearchPathFromEnvp SpawnFlags = 0b10000000
	// SpawnFlagsCloexecPipes: create all pipes with the `O_CLOEXEC` flag set.
	// Since: 2.40
	SpawnFlagsCloexecPipes SpawnFlags = 0b100000000
)

// SpawnChildSetupFunc specifies the type of the setup function passed to
// g_spawn_async(), g_spawn_sync() and g_spawn_async_with_pipes(), which can, in
// very limited ways, be used to affect the child's execution.
//
// On POSIX platforms, the function is called in the child after GLib has
// performed all the setup it plans to perform, but before calling exec().
// Actions taken in this function will only affect the child, not the parent.
//
// On Windows, the function is called in the parent. Its usefulness on Windows
// is thus questionable. In many cases executing the child setup function in the
// parent can have ill effects, and you should be very careful when porting
// software to Windows that uses child setup functions.
//
// However, even on POSIX, you are extremely limited in what you can safely do
// from a ChildSetupFunc, because any mutexes that were held by other threads in
// the parent process at the time of the fork() will still be locked in the
// child process, and they will never be unlocked (since the threads that held
// them don't exist in the child). POSIX allows only async-signal-safe functions
// (see signal(7)) to be called in the child between fork() and exec(), which
// drastically limits the usefulness of child setup functions.
//
// In particular, it is not safe to call any function which may call malloc(),
// which includes POSIX functions such as setenv(). If you need to set up the
// child environment differently from the parent, you should use
// g_get_environ(), g_environ_setenv(), and g_environ_unsetenv(), and then pass
// the complete environment list to the `g_spawn...` function.
type SpawnChildSetupFunc func()

//export gotk4_SpawnChildSetupFunc
func gotk4_SpawnChildSetupFunc(arg0 C.gpointer) {
	v := box.Get(uintptr(arg0))
	if v == nil {
		panic(`callback not found`)
	}

	v.(SpawnChildSetupFunc)()
}

// SpawnAsync: see g_spawn_async_with_pipes() for a full description; this
// function simply calls the g_spawn_async_with_pipes() without any pipes.
//
// You should call g_spawn_close_pid() on the returned child process reference
// when you don't need it any more.
//
// If you are writing a GTK+ application, and the program you are spawning is a
// graphical application too, then to ensure that the spawned program opens its
// windows on the right screen, you may want to use AppLaunchContext,
// LaunchContext, or set the DISPLAY environment variable.
//
// Note that the returned @child_pid on Windows is a handle to the child process
// and not its identifier. Process handles and process identifiers are different
// concepts on Windows.
func SpawnAsync(workingDirectory string, argv []string, envp []string, flags SpawnFlags, childSetup SpawnChildSetupFunc) (childPid Pid, err error) {
	var arg1 *C.gchar
	var arg2 **C.gchar
	var arg3 **C.gchar
	var arg4 C.GSpawnFlags
	var arg5 C.GSpawnChildSetupFunc
	var arg6 C.gpointer
	var arg7 *C.GPid // out
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(workingDirectory))
	defer C.free(unsafe.Pointer(arg1))
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(argv) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(argv)
		sliceHeader.Cap = len(argv)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(argv); i++ {
			src := argv[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg2 = (**C.gchar)(unsafe.Pointer(ptr))
	}
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(envp) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(envp)
		sliceHeader.Cap = len(envp)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(envp); i++ {
			src := envp[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg3 = (**C.gchar)(unsafe.Pointer(ptr))
	}
	arg4 = (C.GSpawnFlags)(flags)
	arg5 = (*[0]byte)(C.gotk4_SpawnChildSetupFunc)
	arg6 = C.gpointer(box.Assign(childSetup))

	ret := C.g_spawn_async(arg1, arg2, arg3, arg4, arg5, arg6, &arg7, &gError)

	var ret0 *Pid
	var goError error

	{
		var tmp int
		tmp = int(arg7)
		ret0 = *Pid(tmp)
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// SpawnAsyncWithFds: identical to g_spawn_async_with_pipes_and_fds() but with
// `n_fds` set to zero, so no FD assignments are used.
func SpawnAsyncWithFds(workingDirectory string, argv []string, envp []string, flags SpawnFlags, childSetup SpawnChildSetupFunc, stdinFd int, stdoutFd int, stderrFd int) (childPid Pid, err error) {
	var arg1 *C.gchar
	var arg2 **C.gchar
	var arg3 **C.gchar
	var arg4 C.GSpawnFlags
	var arg5 C.GSpawnChildSetupFunc
	var arg6 C.gpointer
	var arg7 *C.GPid // out
	var arg8 C.gint
	var arg9 C.gint
	var arg10 C.gint
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(workingDirectory))
	defer C.free(unsafe.Pointer(arg1))
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(argv) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(argv)
		sliceHeader.Cap = len(argv)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(argv); i++ {
			src := argv[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg2 = (**C.gchar)(unsafe.Pointer(ptr))
	}
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(envp) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(envp)
		sliceHeader.Cap = len(envp)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(envp); i++ {
			src := envp[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg3 = (**C.gchar)(unsafe.Pointer(ptr))
	}
	arg4 = (C.GSpawnFlags)(flags)
	arg5 = (*[0]byte)(C.gotk4_SpawnChildSetupFunc)
	arg6 = C.gpointer(box.Assign(childSetup))
	arg8 = C.gint(stdinFd)
	arg9 = C.gint(stdoutFd)
	arg10 = C.gint(stderrFd)

	ret := C.g_spawn_async_with_fds(arg1, arg2, arg3, arg4, arg5, arg6, &arg7, arg8, arg9, arg10, &gError)

	var ret0 *Pid
	var goError error

	{
		var tmp int
		tmp = int(arg7)
		ret0 = *Pid(tmp)
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// SpawnAsyncWithPipes: identical to g_spawn_async_with_pipes_and_fds() but with
// `n_fds` set to zero, so no FD assignments are used.
func SpawnAsyncWithPipes(workingDirectory string, argv []string, envp []string, flags SpawnFlags, childSetup SpawnChildSetupFunc) (childPid Pid, standardInput int, standardOutput int, standardError int, err error) {
	var arg1 *C.gchar
	var arg2 **C.gchar
	var arg3 **C.gchar
	var arg4 C.GSpawnFlags
	var arg5 C.GSpawnChildSetupFunc
	var arg6 C.gpointer
	var arg7 *C.GPid  // out
	var arg8 *C.gint  // out
	var arg9 *C.gint  // out
	var arg10 *C.gint // out
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(workingDirectory))
	defer C.free(unsafe.Pointer(arg1))
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(argv) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(argv)
		sliceHeader.Cap = len(argv)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(argv); i++ {
			src := argv[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg2 = (**C.gchar)(unsafe.Pointer(ptr))
	}
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(envp) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(envp)
		sliceHeader.Cap = len(envp)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(envp); i++ {
			src := envp[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg3 = (**C.gchar)(unsafe.Pointer(ptr))
	}
	arg4 = (C.GSpawnFlags)(flags)
	arg5 = (*[0]byte)(C.gotk4_SpawnChildSetupFunc)
	arg6 = C.gpointer(box.Assign(childSetup))

	ret := C.g_spawn_async_with_pipes(arg1, arg2, arg3, arg4, arg5, arg6, &arg7, &arg8, &arg9, &arg10, &gError)

	var ret0 *Pid
	var ret1 int
	var ret2 int
	var ret3 int
	var goError error

	{
		var tmp int
		tmp = int(arg7)
		ret0 = *Pid(tmp)
	}

	ret1 = int(arg8)

	ret2 = int(arg9)

	ret3 = int(arg10)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, ret3, goError
}

// SpawnAsyncWithPipesAndFds executes a child program asynchronously (your
// program will not block waiting for the child to exit). The child program is
// specified by the only argument that must be provided, @argv. @argv should be
// a nil-terminated array of strings, to be passed as the argument vector for
// the child. The first string in @argv is of course the name of the program to
// execute. By default, the name of the program must be a full path. If @flags
// contains the G_SPAWN_SEARCH_PATH flag, the `PATH` environment variable is
// used to search for the executable. If @flags contains the
// G_SPAWN_SEARCH_PATH_FROM_ENVP flag, the `PATH` variable from @envp is used to
// search for the executable. If both the G_SPAWN_SEARCH_PATH and
// G_SPAWN_SEARCH_PATH_FROM_ENVP flags are set, the `PATH` variable from @envp
// takes precedence over the environment variable.
//
// If the program name is not a full path and G_SPAWN_SEARCH_PATH flag is not
// used, then the program will be run from the current directory (or
// @working_directory, if specified); this might be unexpected or even dangerous
// in some cases when the current directory is world-writable.
//
// On Windows, note that all the string or string vector arguments to this
// function and the other g_spawn*() functions are in UTF-8, the GLib file name
// encoding. Unicode characters that are not part of the system codepage passed
// in these arguments will be correctly available in the spawned program only if
// it uses wide character API to retrieve its command line. For C programs built
// with Microsoft's tools it is enough to make the program have a wmain()
// instead of main(). wmain() has a wide character argument vector as parameter.
//
// At least currently, mingw doesn't support wmain(), so if you use mingw to
// develop the spawned program, it should call g_win32_get_command_line() to get
// arguments in UTF-8.
//
// On Windows the low-level child process creation API CreateProcess() doesn't
// use argument vectors, but a command line. The C runtime library's spawn*()
// family of functions (which g_spawn_async_with_pipes() eventually calls) paste
// the argument vector elements together into a command line, and the C runtime
// startup code does a corresponding reconstruction of an argument vector from
// the command line, to be passed to main(). Complications arise when you have
// argument vector elements that contain spaces or double quotes. The `spawn*()`
// functions don't do any quoting or escaping, but on the other hand the startup
// code does do unquoting and unescaping in order to enable receiving arguments
// with embedded spaces or double quotes. To work around this asymmetry,
// g_spawn_async_with_pipes() will do quoting and escaping on argument vector
// elements that need it before calling the C runtime spawn() function.
//
// The returned @child_pid on Windows is a handle to the child process, not its
// identifier. Process handles and process identifiers are different concepts on
// Windows.
//
// @envp is a nil-terminated array of strings, where each string has the form
// `KEY=VALUE`. This will become the child's environment. If @envp is nil, the
// child inherits its parent's environment.
//
// @flags should be the bitwise OR of any flags you want to affect the
// function's behaviour. The G_SPAWN_DO_NOT_REAP_CHILD means that the child will
// not automatically be reaped; you must use a child watch (g_child_watch_add())
// to be notified about the death of the child process, otherwise it will stay
// around as a zombie process until this process exits. Eventually you must call
// g_spawn_close_pid() on the @child_pid, in order to free resources which may
// be associated with the child process. (On Unix, using a child watch is
// equivalent to calling waitpid() or handling the `SIGCHLD` signal manually. On
// Windows, calling g_spawn_close_pid() is equivalent to calling CloseHandle()
// on the process handle returned in @child_pid). See g_child_watch_add().
//
// Open UNIX file descriptors marked as `FD_CLOEXEC` will be automatically
// closed in the child process. G_SPAWN_LEAVE_DESCRIPTORS_OPEN means that other
// open file descriptors will be inherited by the child; otherwise all
// descriptors except stdin/stdout/stderr will be closed before calling exec()
// in the child. G_SPAWN_SEARCH_PATH means that @argv[0] need not be an absolute
// path, it will be looked for in the `PATH` environment variable.
// G_SPAWN_SEARCH_PATH_FROM_ENVP means need not be an absolute path, it will be
// looked for in the `PATH` variable from @envp. If both G_SPAWN_SEARCH_PATH and
// G_SPAWN_SEARCH_PATH_FROM_ENVP are used, the value from @envp takes precedence
// over the environment.
//
// G_SPAWN_STDOUT_TO_DEV_NULL means that the child's standard output will be
// discarded, instead of going to the same location as the parent's standard
// output. If you use this flag, @stdout_pipe_out must be nil.
//
// G_SPAWN_STDERR_TO_DEV_NULL means that the child's standard error will be
// discarded, instead of going to the same location as the parent's standard
// error. If you use this flag, @stderr_pipe_out must be nil.
//
// G_SPAWN_CHILD_INHERITS_STDIN means that the child will inherit the parent's
// standard input (by default, the child's standard input is attached to
// `/dev/null`). If you use this flag, @stdin_pipe_out must be nil.
//
// It is valid to pass the same FD in multiple parameters (e.g. you can pass a
// single FD for both @stdout_fd and @stderr_fd, and include it in @source_fds
// too).
//
// @source_fds and @target_fds allow zero or more FDs from this process to be
// remapped to different FDs in the spawned process. If @n_fds is greater than
// zero, @source_fds and @target_fds must both be non-nil and the same length.
// Each FD in @source_fds is remapped to the FD number at the same index in
// @target_fds. The source and target FD may be equal to simply propagate an FD
// to the spawned process. FD remappings are processed after standard FDs, so
// any target FDs which equal @stdin_fd, @stdout_fd or @stderr_fd will overwrite
// them in the spawned process.
//
// G_SPAWN_FILE_AND_ARGV_ZERO means that the first element of @argv is the file
// to execute, while the remaining elements are the actual argument vector to
// pass to the file. Normally g_spawn_async_with_pipes() uses @argv[0] as the
// file to execute, and passes all of @argv to the child.
//
// @child_setup and @user_data are a function and user data. On POSIX platforms,
// the function is called in the child after GLib has performed all the setup it
// plans to perform (including creating pipes, closing file descriptors, etc.)
// but before calling exec(). That is, @child_setup is called just before
// calling exec() in the child. Obviously actions taken in this function will
// only affect the child, not the parent.
//
// On Windows, there is no separate fork() and exec() functionality. Child
// processes are created and run with a single API call, CreateProcess(). There
// is no sensible thing @child_setup could be used for on Windows so it is
// ignored and not called.
//
// If non-nil, @child_pid will on Unix be filled with the child's process ID.
// You can use the process ID to send signals to the child, or to use
// g_child_watch_add() (or waitpid()) if you specified the
// G_SPAWN_DO_NOT_REAP_CHILD flag. On Windows, @child_pid will be filled with a
// handle to the child process only if you specified the
// G_SPAWN_DO_NOT_REAP_CHILD flag. You can then access the child process using
// the Win32 API, for example wait for its termination with the WaitFor*()
// functions, or examine its exit code with GetExitCodeProcess(). You should
// close the handle with CloseHandle() or g_spawn_close_pid() when you no longer
// need it.
//
// If non-nil, the @stdin_pipe_out, @stdout_pipe_out, @stderr_pipe_out locations
// will be filled with file descriptors for writing to the child's standard
// input or reading from its standard output or standard error. The caller of
// g_spawn_async_with_pipes() must close these file descriptors when they are no
// longer in use. If these parameters are nil, the corresponding pipe won't be
// created.
//
// If @stdin_pipe_out is nil, the child's standard input is attached to
// `/dev/null` unless G_SPAWN_CHILD_INHERITS_STDIN is set.
//
// If @stderr_pipe_out is NULL, the child's standard error goes to the same
// location as the parent's standard error unless G_SPAWN_STDERR_TO_DEV_NULL is
// set.
//
// If @stdout_pipe_out is NULL, the child's standard output goes to the same
// location as the parent's standard output unless G_SPAWN_STDOUT_TO_DEV_NULL is
// set.
//
// @error can be nil to ignore errors, or non-nil to report errors. If an error
// is set, the function returns false. Errors are reported even if they occur in
// the child (for example if the executable in @argv[0] is not found). Typically
// the `message` field of returned errors should be displayed to users. Possible
// errors are those from the SPAWN_ERROR domain.
//
// If an error occurs, @child_pid, @stdin_pipe_out, @stdout_pipe_out, and
// @stderr_pipe_out will not be filled with valid values.
//
// If @child_pid is not nil and an error does not occur then the returned
// process reference must be closed using g_spawn_close_pid().
//
// On modern UNIX platforms, GLib can use an efficient process launching
// codepath driven internally by posix_spawn(). This has the advantage of
// avoiding the fork-time performance costs of cloning the parent process
// address space, and avoiding associated memory overcommit checks that are not
// relevant in the context of immediately executing a distinct process. This
// optimized codepath will be used provided that the following conditions are
// met:
//
// 1. G_SPAWN_DO_NOT_REAP_CHILD is set 2. G_SPAWN_LEAVE_DESCRIPTORS_OPEN is set
// 3. G_SPAWN_SEARCH_PATH_FROM_ENVP is not set 4. @working_directory is nil 5.
// @child_setup is nil 6. The program is of a recognised binary format, or has a
// shebang. Otherwise, GLib will have to execute the program through the shell,
// which is not done using the optimized codepath.
//
// If you are writing a GTK+ application, and the program you are spawning is a
// graphical application too, then to ensure that the spawned program opens its
// windows on the right screen, you may want to use AppLaunchContext,
// LaunchContext, or set the `DISPLAY` environment variable.
func SpawnAsyncWithPipesAndFds(workingDirectory string, argv []string, envp []string, flags SpawnFlags, childSetup SpawnChildSetupFunc, stdinFd int, stdoutFd int, stderrFd int, sourceFds []int, targetFds []int) (childPidOut Pid, stdinPipeOut int, stdoutPipeOut int, stderrPipeOut int, err error) {
	var arg1 *C.gchar
	var arg2 **C.gchar
	var arg3 **C.gchar
	var arg4 C.GSpawnFlags
	var arg5 C.GSpawnChildSetupFunc
	var arg6 C.gpointer
	var arg7 C.gint
	var arg8 C.gint
	var arg9 C.gint
	var arg10 *C.gint
	var arg11 *C.gint
	var arg12 C.gsize
	var arg13 *C.GPid // out
	var arg14 *C.gint // out
	var arg15 *C.gint // out
	var arg16 *C.gint // out
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(workingDirectory))
	defer C.free(unsafe.Pointer(arg1))
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(argv) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(argv)
		sliceHeader.Cap = len(argv)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(argv); i++ {
			src := argv[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg2 = (**C.gchar)(unsafe.Pointer(ptr))
	}
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(envp) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(envp)
		sliceHeader.Cap = len(envp)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(envp); i++ {
			src := envp[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg3 = (**C.gchar)(unsafe.Pointer(ptr))
	}
	arg4 = (C.GSpawnFlags)(flags)
	arg5 = (*[0]byte)(C.gotk4_SpawnChildSetupFunc)
	arg6 = C.gpointer(box.Assign(childSetup))
	arg7 = C.gint(stdinFd)
	arg8 = C.gint(stdoutFd)
	arg9 = C.gint(stderrFd)
	arg10 = (*C.gint)(unsafe.Pointer(&sourceFds[0]))
	arg12 = len(sourceFds)
	defer runtime.KeepAlive(sourceFds)
	arg11 = (*C.gint)(unsafe.Pointer(&targetFds[0]))
	arg12 = len(targetFds)
	defer runtime.KeepAlive(targetFds)

	ret := C.g_spawn_async_with_pipes_and_fds(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, &arg13, &arg14, &arg15, &arg16, &gError)

	var ret0 *Pid
	var ret1 int
	var ret2 int
	var ret3 int
	var goError error

	{
		var tmp int
		tmp = int(arg13)
		ret0 = *Pid(tmp)
	}

	ret1 = int(arg14)

	ret2 = int(arg15)

	ret3 = int(arg16)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, ret3, goError
}

// SpawnCheckExitStatus: set @error if @exit_status indicates the child exited
// abnormally (e.g. with a nonzero exit code, or via a fatal signal).
//
// The g_spawn_sync() and g_child_watch_add() family of APIs return an exit
// status for subprocesses encoded in a platform-specific way. On Unix, this is
// guaranteed to be in the same format waitpid() returns, and on Windows it is
// guaranteed to be the result of GetExitCodeProcess().
//
// Prior to the introduction of this function in GLib 2.34, interpreting
// @exit_status required use of platform-specific APIs, which is problematic for
// software using GLib as a cross-platform layer.
//
// Additionally, many programs simply want to determine whether or not the child
// exited successfully, and either propagate a #GError or print a message to
// standard error. In that common case, this function can be used. Note that the
// error message in @error will contain human-readable information about the
// exit status.
//
// The @domain and @code of @error have special semantics in the case where the
// process has an "exit code", as opposed to being killed by a signal. On Unix,
// this happens if WIFEXITED() would be true of @exit_status. On Windows, it is
// always the case.
//
// The special semantics are that the actual exit code will be the code set in
// @error, and the domain will be G_SPAWN_EXIT_ERROR. This allows you to
// differentiate between different exit codes.
//
// If the process was terminated by some means other than an exit status, the
// domain will be G_SPAWN_ERROR, and the code will be G_SPAWN_ERROR_FAILED.
//
// This function just offers convenience; you can of course also check the
// available platform via a macro such as G_OS_UNIX, and use WIFEXITED() and
// WEXITSTATUS() on @exit_status directly. Do not attempt to scan or parse the
// error message string; it may be translated and/or change in future versions
// of GLib.
func SpawnCheckExitStatus(exitStatus int) error {
	var arg1 C.gint
	var gError *C.GError

	arg1 = C.gint(exitStatus)

	ret := C.g_spawn_check_exit_status(arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SpawnCommandLineAsync: a simple version of g_spawn_async() that parses a
// command line with g_shell_parse_argv() and passes it to g_spawn_async(). Runs
// a command line in the background. Unlike g_spawn_async(), the
// G_SPAWN_SEARCH_PATH flag is enabled, other flags are not. Note that
// G_SPAWN_SEARCH_PATH can have security implications, so consider using
// g_spawn_async() directly if appropriate. Possible errors are those from
// g_shell_parse_argv() and g_spawn_async().
//
// The same concerns on Windows apply as for g_spawn_command_line_sync().
func SpawnCommandLineAsync(commandLine string) error {
	var arg1 *C.gchar
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(commandLine))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_spawn_command_line_async(arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SpawnCommandLineSync: a simple version of g_spawn_sync() with little-used
// parameters removed, taking a command line instead of an argument vector. See
// g_spawn_sync() for full details. @command_line will be parsed by
// g_shell_parse_argv(). Unlike g_spawn_sync(), the G_SPAWN_SEARCH_PATH flag is
// enabled. Note that G_SPAWN_SEARCH_PATH can have security implications, so
// consider using g_spawn_sync() directly if appropriate. Possible errors are
// those from g_spawn_sync() and those from g_shell_parse_argv().
//
// If @exit_status is non-nil, the platform-specific exit status of the child is
// stored there; see the documentation of g_spawn_check_exit_status() for how to
// use and interpret this.
//
// On Windows, please note the implications of g_shell_parse_argv() parsing
// @command_line. Parsing is done according to Unix shell rules, not Windows
// command interpreter rules. Space is a separator, and backslashes are special.
// Thus you cannot simply pass a @command_line containing canonical Windows
// paths, like "c:\\program files\\app\\app.exe", as the backslashes will be
// eaten, and the space will act as a separator. You need to enclose such paths
// with single quotes, like "'c:\\program files\\app\\app.exe'
// 'e:\\folder\\argument.txt'".
func SpawnCommandLineSync(commandLine string) (standardOutput []byte, standardError []byte, exitStatus int, err error) {
	var arg1 *C.gchar
	var arg2 **C.gchar // out
	var arg3 **C.gchar // out
	var arg4 *C.gint   // out
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(commandLine))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_spawn_command_line_sync(arg1, &arg2, &arg3, &arg4, &gError)

	var ret0 []byte
	var ret1 []byte
	var ret2 int
	var goError error

	{
		var length uint
		for p := unsafe.Pointer(arg2); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]byte, length)
		for i := 0; i < length; i++ {
			src := (C.guint8)(unsafe.Pointer(uintptr(unsafe.Pointer(arg2)) + i))
			ret0[i] = byte(src)
		}
	}

	{
		var length uint
		for p := unsafe.Pointer(arg3); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret1 = make([]byte, length)
		for i := 0; i < length; i++ {
			src := (C.guint8)(unsafe.Pointer(uintptr(unsafe.Pointer(arg3)) + i))
			ret1[i] = byte(src)
		}
	}

	ret2 = int(arg4)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}

// SpawnSync executes a child synchronously (waits for the child to exit before
// returning). All output from the child is stored in @standard_output and
// @standard_error, if those parameters are non-nil. Note that you must set the
// G_SPAWN_STDOUT_TO_DEV_NULL and G_SPAWN_STDERR_TO_DEV_NULL flags when passing
// nil for @standard_output and @standard_error.
//
// If @exit_status is non-nil, the platform-specific exit status of the child is
// stored there; see the documentation of g_spawn_check_exit_status() for how to
// use and interpret this. Note that it is invalid to pass
// G_SPAWN_DO_NOT_REAP_CHILD in @flags, and on POSIX platforms, the same
// restrictions as for g_child_watch_source_new() apply.
//
// If an error occurs, no data is returned in @standard_output, @standard_error,
// or @exit_status.
//
// This function calls g_spawn_async_with_pipes() internally; see that function
// for full details on the other parameters and details on how these functions
// work on Windows.
func SpawnSync(workingDirectory string, argv []string, envp []string, flags SpawnFlags, childSetup SpawnChildSetupFunc) (standardOutput []byte, standardError []byte, exitStatus int, err error) {
	var arg1 *C.gchar
	var arg2 **C.gchar
	var arg3 **C.gchar
	var arg4 C.GSpawnFlags
	var arg5 C.GSpawnChildSetupFunc
	var arg6 C.gpointer
	var arg7 **C.gchar // out
	var arg8 **C.gchar // out
	var arg9 *C.gint   // out
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(workingDirectory))
	defer C.free(unsafe.Pointer(arg1))
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(argv) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(argv)
		sliceHeader.Cap = len(argv)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(argv); i++ {
			src := argv[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg2 = (**C.gchar)(unsafe.Pointer(ptr))
	}
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(envp) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(envp)
		sliceHeader.Cap = len(envp)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(envp); i++ {
			src := envp[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg3 = (**C.gchar)(unsafe.Pointer(ptr))
	}
	arg4 = (C.GSpawnFlags)(flags)
	arg5 = (*[0]byte)(C.gotk4_SpawnChildSetupFunc)
	arg6 = C.gpointer(box.Assign(childSetup))

	ret := C.g_spawn_sync(arg1, arg2, arg3, arg4, arg5, arg6, &arg7, &arg8, &arg9, &gError)

	var ret0 []byte
	var ret1 []byte
	var ret2 int
	var goError error

	{
		var length uint
		for p := unsafe.Pointer(arg7); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]byte, length)
		for i := 0; i < length; i++ {
			src := (C.guint8)(unsafe.Pointer(uintptr(unsafe.Pointer(arg7)) + i))
			ret0[i] = byte(src)
		}
	}

	{
		var length uint
		for p := unsafe.Pointer(arg8); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret1 = make([]byte, length)
		for i := 0; i < length; i++ {
			src := (C.guint8)(unsafe.Pointer(uintptr(unsafe.Pointer(arg8)) + i))
			ret1[i] = byte(src)
		}
	}

	ret2 = int(arg9)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}
