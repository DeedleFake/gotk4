// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"runtime"
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <glib.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_date_time_get_type()), F: marshalDateTime},
	})
}

// TimeSpan: a value representing an interval of time, in microseconds.
type TimeSpan int64

// DateTime: `GDateTime` is an opaque structure whose members cannot be accessed
// directly.
type DateTime struct {
	native C.GDateTime
}

// WrapDateTime wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDateTime(ptr unsafe.Pointer) *DateTime {
	if ptr == nil {
		return nil
	}

	return (*DateTime)(ptr)
}

func marshalDateTime(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDateTime(unsafe.Pointer(b)), nil
}

// NewDateTime constructs a struct DateTime.
func NewDateTime(tz *TimeZone, year int, month int, day int, hour int, minute int, seconds float64) *DateTime {
	var arg1 *C.GTimeZone
	var arg2 C.gint
	var arg3 C.gint
	var arg4 C.gint
	var arg5 C.gint
	var arg6 C.gint
	var arg7 C.gdouble

	arg1 = (*C.GTimeZone)(unsafe.Pointer(tz.Native()))
	arg2 = C.gint(year)
	arg3 = C.gint(month)
	arg4 = C.gint(day)
	arg5 = C.gint(hour)
	arg6 = C.gint(minute)
	arg7 = C.gdouble(seconds)

	cret := new(C.GDateTime)
	var goret *DateTime

	cret = C.g_date_time_new(arg1, arg2, arg3, arg4, arg5, arg6, arg7)

	goret = WrapDateTime(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *DateTime) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// NewDateTimeFromISO8601 constructs a struct DateTime.
func NewDateTimeFromISO8601(text string, defaultTz *TimeZone) *DateTime {
	var arg1 *C.gchar
	var arg2 *C.GTimeZone

	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GTimeZone)(unsafe.Pointer(defaultTz.Native()))

	cret := new(C.GDateTime)
	var goret *DateTime

	cret = C.g_date_time_new_from_iso8601(arg1, arg2)

	goret = WrapDateTime(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *DateTime) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// NewDateTimeFromTimevalLocal constructs a struct DateTime.
func NewDateTimeFromTimevalLocal(tv *TimeVal) *DateTime {
	var arg1 *C.GTimeVal

	arg1 = (*C.GTimeVal)(unsafe.Pointer(tv.Native()))

	cret := new(C.GDateTime)
	var goret *DateTime

	cret = C.g_date_time_new_from_timeval_local(arg1)

	goret = WrapDateTime(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *DateTime) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// NewDateTimeFromTimevalUtc constructs a struct DateTime.
func NewDateTimeFromTimevalUtc(tv *TimeVal) *DateTime {
	var arg1 *C.GTimeVal

	arg1 = (*C.GTimeVal)(unsafe.Pointer(tv.Native()))

	cret := new(C.GDateTime)
	var goret *DateTime

	cret = C.g_date_time_new_from_timeval_utc(arg1)

	goret = WrapDateTime(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *DateTime) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// NewDateTimeFromUnixLocal constructs a struct DateTime.
func NewDateTimeFromUnixLocal(t int64) *DateTime {
	var arg1 C.gint64

	arg1 = C.gint64(t)

	cret := new(C.GDateTime)
	var goret *DateTime

	cret = C.g_date_time_new_from_unix_local(arg1)

	goret = WrapDateTime(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *DateTime) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// NewDateTimeFromUnixUtc constructs a struct DateTime.
func NewDateTimeFromUnixUtc(t int64) *DateTime {
	var arg1 C.gint64

	arg1 = C.gint64(t)

	cret := new(C.GDateTime)
	var goret *DateTime

	cret = C.g_date_time_new_from_unix_utc(arg1)

	goret = WrapDateTime(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *DateTime) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// NewDateTimeLocal constructs a struct DateTime.
func NewDateTimeLocal(year int, month int, day int, hour int, minute int, seconds float64) *DateTime {
	var arg1 C.gint
	var arg2 C.gint
	var arg3 C.gint
	var arg4 C.gint
	var arg5 C.gint
	var arg6 C.gdouble

	arg1 = C.gint(year)
	arg2 = C.gint(month)
	arg3 = C.gint(day)
	arg4 = C.gint(hour)
	arg5 = C.gint(minute)
	arg6 = C.gdouble(seconds)

	cret := new(C.GDateTime)
	var goret *DateTime

	cret = C.g_date_time_new_local(arg1, arg2, arg3, arg4, arg5, arg6)

	goret = WrapDateTime(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *DateTime) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// NewDateTimeNow constructs a struct DateTime.
func NewDateTimeNow(tz *TimeZone) *DateTime {
	var arg1 *C.GTimeZone

	arg1 = (*C.GTimeZone)(unsafe.Pointer(tz.Native()))

	cret := new(C.GDateTime)
	var goret *DateTime

	cret = C.g_date_time_new_now(arg1)

	goret = WrapDateTime(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *DateTime) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// NewDateTimeNowLocal constructs a struct DateTime.
func NewDateTimeNowLocal() *DateTime {
	cret := new(C.GDateTime)
	var goret *DateTime

	cret = C.g_date_time_new_now_local()

	goret = WrapDateTime(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *DateTime) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// NewDateTimeNowUtc constructs a struct DateTime.
func NewDateTimeNowUtc() *DateTime {
	cret := new(C.GDateTime)
	var goret *DateTime

	cret = C.g_date_time_new_now_utc()

	goret = WrapDateTime(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *DateTime) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// NewDateTimeUtc constructs a struct DateTime.
func NewDateTimeUtc(year int, month int, day int, hour int, minute int, seconds float64) *DateTime {
	var arg1 C.gint
	var arg2 C.gint
	var arg3 C.gint
	var arg4 C.gint
	var arg5 C.gint
	var arg6 C.gdouble

	arg1 = C.gint(year)
	arg2 = C.gint(month)
	arg3 = C.gint(day)
	arg4 = C.gint(hour)
	arg5 = C.gint(minute)
	arg6 = C.gdouble(seconds)

	cret := new(C.GDateTime)
	var goret *DateTime

	cret = C.g_date_time_new_utc(arg1, arg2, arg3, arg4, arg5, arg6)

	goret = WrapDateTime(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *DateTime) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// Native returns the underlying C source pointer.
func (d *DateTime) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}

// AddDays creates a copy of @datetime and adds the specified number of days to
// the copy. Add negative values to subtract days.
func (d *DateTime) AddDays(days int) *DateTime {
	var arg0 *C.GDateTime
	var arg1 C.gint

	arg0 = (*C.GDateTime)(unsafe.Pointer(d.Native()))
	arg1 = C.gint(days)

	cret := new(C.GDateTime)
	var goret *DateTime

	cret = C.g_date_time_add_days(arg0, arg1)

	goret = WrapDateTime(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *DateTime) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// AddFull creates a new Time adding the specified values to the current date
// and time in @datetime. Add negative values to subtract.
func (d *DateTime) AddFull(years int, months int, days int, hours int, minutes int, seconds float64) *DateTime {
	var arg0 *C.GDateTime
	var arg1 C.gint
	var arg2 C.gint
	var arg3 C.gint
	var arg4 C.gint
	var arg5 C.gint
	var arg6 C.gdouble

	arg0 = (*C.GDateTime)(unsafe.Pointer(d.Native()))
	arg1 = C.gint(years)
	arg2 = C.gint(months)
	arg3 = C.gint(days)
	arg4 = C.gint(hours)
	arg5 = C.gint(minutes)
	arg6 = C.gdouble(seconds)

	cret := new(C.GDateTime)
	var goret *DateTime

	cret = C.g_date_time_add_full(arg0, arg1, arg2, arg3, arg4, arg5, arg6)

	goret = WrapDateTime(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *DateTime) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// AddHours creates a copy of @datetime and adds the specified number of hours.
// Add negative values to subtract hours.
func (d *DateTime) AddHours(hours int) *DateTime {
	var arg0 *C.GDateTime
	var arg1 C.gint

	arg0 = (*C.GDateTime)(unsafe.Pointer(d.Native()))
	arg1 = C.gint(hours)

	cret := new(C.GDateTime)
	var goret *DateTime

	cret = C.g_date_time_add_hours(arg0, arg1)

	goret = WrapDateTime(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *DateTime) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// AddMinutes creates a copy of @datetime adding the specified number of
// minutes. Add negative values to subtract minutes.
func (d *DateTime) AddMinutes(minutes int) *DateTime {
	var arg0 *C.GDateTime
	var arg1 C.gint

	arg0 = (*C.GDateTime)(unsafe.Pointer(d.Native()))
	arg1 = C.gint(minutes)

	cret := new(C.GDateTime)
	var goret *DateTime

	cret = C.g_date_time_add_minutes(arg0, arg1)

	goret = WrapDateTime(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *DateTime) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// AddMonths creates a copy of @datetime and adds the specified number of months
// to the copy. Add negative values to subtract months.
//
// The day of the month of the resulting Time is clamped to the number of days
// in the updated calendar month. For example, if adding 1 month to 31st January
// 2018, the result would be 28th February 2018. In 2020 (a leap year), the
// result would be 29th February.
func (d *DateTime) AddMonths(months int) *DateTime {
	var arg0 *C.GDateTime
	var arg1 C.gint

	arg0 = (*C.GDateTime)(unsafe.Pointer(d.Native()))
	arg1 = C.gint(months)

	cret := new(C.GDateTime)
	var goret *DateTime

	cret = C.g_date_time_add_months(arg0, arg1)

	goret = WrapDateTime(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *DateTime) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// AddSeconds creates a copy of @datetime and adds the specified number of
// seconds. Add negative values to subtract seconds.
func (d *DateTime) AddSeconds(seconds float64) *DateTime {
	var arg0 *C.GDateTime
	var arg1 C.gdouble

	arg0 = (*C.GDateTime)(unsafe.Pointer(d.Native()))
	arg1 = C.gdouble(seconds)

	cret := new(C.GDateTime)
	var goret *DateTime

	cret = C.g_date_time_add_seconds(arg0, arg1)

	goret = WrapDateTime(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *DateTime) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// AddWeeks creates a copy of @datetime and adds the specified number of weeks
// to the copy. Add negative values to subtract weeks.
func (d *DateTime) AddWeeks(weeks int) *DateTime {
	var arg0 *C.GDateTime
	var arg1 C.gint

	arg0 = (*C.GDateTime)(unsafe.Pointer(d.Native()))
	arg1 = C.gint(weeks)

	cret := new(C.GDateTime)
	var goret *DateTime

	cret = C.g_date_time_add_weeks(arg0, arg1)

	goret = WrapDateTime(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *DateTime) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// AddYears creates a copy of @datetime and adds the specified number of years
// to the copy. Add negative values to subtract years.
//
// As with g_date_time_add_months(), if the resulting date would be 29th
// February on a non-leap year, the day will be clamped to 28th February.
func (d *DateTime) AddYears(years int) *DateTime {
	var arg0 *C.GDateTime
	var arg1 C.gint

	arg0 = (*C.GDateTime)(unsafe.Pointer(d.Native()))
	arg1 = C.gint(years)

	cret := new(C.GDateTime)
	var goret *DateTime

	cret = C.g_date_time_add_years(arg0, arg1)

	goret = WrapDateTime(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *DateTime) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// Compare: a comparison function for Times that is suitable as a Func. Both
// Times must be non-nil.
func (d *DateTime) Compare(dt2 DateTime) int {
	var arg0 C.gpointer
	var arg1 C.gpointer

	arg0 = (C.gpointer)(unsafe.Pointer(d.Native()))
	arg1 = (C.gpointer)(unsafe.Pointer(dt2.Native()))

	var cret C.gint
	var goret int

	cret = C.g_date_time_compare(arg0, arg1)

	goret = int(cret)

	return goret
}

// Equal checks to see if @dt1 and @dt2 are equal.
//
// Equal here means that they represent the same moment after converting them to
// the same time zone.
func (d *DateTime) Equal(dt2 DateTime) bool {
	var arg0 C.gpointer
	var arg1 C.gpointer

	arg0 = (C.gpointer)(unsafe.Pointer(d.Native()))
	arg1 = (C.gpointer)(unsafe.Pointer(dt2.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.g_date_time_equal(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// Format creates a newly allocated string representing the requested @format.
//
// The format strings understood by this function are a subset of the strftime()
// format language as specified by C99. The \D, \U and \W conversions are not
// supported, nor is the 'E' modifier. The GNU extensions \k, \l, \s and \P are
// supported, however, as are the '0', '_' and '-' modifiers. The Python
// extension \f is also supported.
//
// In contrast to strftime(), this function always produces a UTF-8 string,
// regardless of the current locale. Note that the rendering of many formats is
// locale-dependent and may not match the strftime() output exactly.
//
// The following format specifiers are supported:
//
// - \a: the abbreviated weekday name according to the current locale - \A: the
// full weekday name according to the current locale - \b: the abbreviated month
// name according to the current locale - \B: the full month name according to
// the current locale - \c: the preferred date and time representation for the
// current locale - \C: the century number (year/100) as a 2-digit integer
// (00-99) - \d: the day of the month as a decimal number (range 01 to 31) - \e:
// the day of the month as a decimal number (range 1 to 31) - \F: equivalent to
// `Y-m-d` (the ISO 8601 date format) - \g: the last two digits of the ISO 8601
// week-based year as a decimal number (00-99). This works well with \V and \u.
// - \G: the ISO 8601 week-based year as a decimal number. This works well with
// \V and \u. - \h: equivalent to \b - \H: the hour as a decimal number using a
// 24-hour clock (range 00 to 23) - \I: the hour as a decimal number using a
// 12-hour clock (range 01 to 12) - \j: the day of the year as a decimal number
// (range 001 to 366) - \k: the hour (24-hour clock) as a decimal number (range
// 0 to 23); single digits are preceded by a blank - \l: the hour (12-hour
// clock) as a decimal number (range 1 to 12); single digits are preceded by a
// blank - \m: the month as a decimal number (range 01 to 12) - \M: the minute
// as a decimal number (range 00 to 59) - \f: the microsecond as a decimal
// number (range 000000 to 999999) - \p: either "AM" or "PM" according to the
// given time value, or the corresponding strings for the current locale. Noon
// is treated as "PM" and midnight as "AM". Use of this format specifier is
// discouraged, as many locales have no concept of AM/PM formatting. Use \c or
// \X instead. - \P: like \p but lowercase: "am" or "pm" or a corresponding
// string for the current locale. Use of this format specifier is discouraged,
// as many locales have no concept of AM/PM formatting. Use \c or \X instead. -
// \r: the time in a.m. or p.m. notation. Use of this format specifier is
// discouraged, as many locales have no concept of AM/PM formatting. Use \c or
// \X instead. - \R: the time in 24-hour notation (\H:\M) - \s: the number of
// seconds since the Epoch, that is, since 1970-01-01 00:00:00 UTC - \S: the
// second as a decimal number (range 00 to 60) - \t: a tab character - \T: the
// time in 24-hour notation with seconds (\H:\M:\S) - \u: the ISO 8601 standard
// day of the week as a decimal, range 1 to 7, Monday being 1. This works well
// with \G and \V. - \V: the ISO 8601 standard week number of the current year
// as a decimal number, range 01 to 53, where week 1 is the first week that has
// at least 4 days in the new year. See g_date_time_get_week_of_year(). This
// works well with \G and \u. - \w: the day of the week as a decimal, range 0 to
// 6, Sunday being 0. This is not the ISO 8601 standard format -- use \u
// instead. - \x: the preferred date representation for the current locale
// without the time - \X: the preferred time representation for the current
// locale without the date - \y: the year as a decimal number without the
// century - \Y: the year as a decimal number including the century - \z: the
// time zone as an offset from UTC (+hhmm) - \%:z: the time zone as an offset
// from UTC (+hh:mm). This is a gnulib strftime() extension. Since: 2.38 -
// \%::z: the time zone as an offset from UTC (+hh:mm:ss). This is a gnulib
// strftime() extension. Since: 2.38 - \%:::z: the time zone as an offset from
// UTC, with : to necessary precision (e.g., -04, +05:30). This is a gnulib
// strftime() extension. Since: 2.38 - \Z: the time zone or name or abbreviation
// - \%\%: a literal \% character
//
// Some conversion specifications can be modified by preceding the conversion
// specifier by one or more modifier characters. The following modifiers are
// supported for many of the numeric conversions:
//
// - O: Use alternative numeric symbols, if the current locale supports those. -
// _: Pad a numeric result with spaces. This overrides the default padding for
// the specifier. - -: Do not pad a numeric result. This overrides the default
// padding for the specifier. - 0: Pad a numeric result with zeros. This
// overrides the default padding for the specifier.
//
// Additionally, when O is used with B, b, or h, it produces the alternative
// form of a month name. The alternative form should be used when the month name
// is used without a day number (e.g., standalone). It is required in some
// languages (Baltic, Slavic, Greek, and more) due to their grammatical rules.
// For other languages there is no difference. \OB is a GNU and BSD strftime()
// extension expected to be added to the future POSIX specification, \Ob and \Oh
// are GNU strftime() extensions. Since: 2.56
func (d *DateTime) Format(format string) string {
	var arg0 *C.GDateTime
	var arg1 *C.gchar

	arg0 = (*C.GDateTime)(unsafe.Pointer(d.Native()))
	arg1 = (*C.gchar)(C.CString(format))
	defer C.free(unsafe.Pointer(arg1))

	cret := new(C.gchar)
	var goret string

	cret = C.g_date_time_format(arg0, arg1)

	goret = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// FormatISO8601: format @datetime in ISO 8601 format
// (https://en.wikipedia.org/wiki/ISO_8601), including the date, time and time
// zone, and return that as a UTF-8 encoded string.
//
// Since GLib 2.66, this will output to sub-second precision if needed.
func (d *DateTime) FormatISO8601() string {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(unsafe.Pointer(d.Native()))

	cret := new(C.gchar)
	var goret string

	cret = C.g_date_time_format_iso8601(arg0)

	goret = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// DayOfMonth retrieves the day of the month represented by @datetime in the
// gregorian calendar.
func (d *DateTime) DayOfMonth() int {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(unsafe.Pointer(d.Native()))

	var cret C.gint
	var goret int

	cret = C.g_date_time_get_day_of_month(arg0)

	goret = int(cret)

	return goret
}

// DayOfWeek retrieves the ISO 8601 day of the week on which @datetime falls (1
// is Monday, 2 is Tuesday... 7 is Sunday).
func (d *DateTime) DayOfWeek() int {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(unsafe.Pointer(d.Native()))

	var cret C.gint
	var goret int

	cret = C.g_date_time_get_day_of_week(arg0)

	goret = int(cret)

	return goret
}

// DayOfYear retrieves the day of the year represented by @datetime in the
// Gregorian calendar.
func (d *DateTime) DayOfYear() int {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(unsafe.Pointer(d.Native()))

	var cret C.gint
	var goret int

	cret = C.g_date_time_get_day_of_year(arg0)

	goret = int(cret)

	return goret
}

// Hour retrieves the hour of the day represented by @datetime
func (d *DateTime) Hour() int {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(unsafe.Pointer(d.Native()))

	var cret C.gint
	var goret int

	cret = C.g_date_time_get_hour(arg0)

	goret = int(cret)

	return goret
}

// Microsecond retrieves the microsecond of the date represented by @datetime
func (d *DateTime) Microsecond() int {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(unsafe.Pointer(d.Native()))

	var cret C.gint
	var goret int

	cret = C.g_date_time_get_microsecond(arg0)

	goret = int(cret)

	return goret
}

// Minute retrieves the minute of the hour represented by @datetime
func (d *DateTime) Minute() int {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(unsafe.Pointer(d.Native()))

	var cret C.gint
	var goret int

	cret = C.g_date_time_get_minute(arg0)

	goret = int(cret)

	return goret
}

// Month retrieves the month of the year represented by @datetime in the
// Gregorian calendar.
func (d *DateTime) Month() int {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(unsafe.Pointer(d.Native()))

	var cret C.gint
	var goret int

	cret = C.g_date_time_get_month(arg0)

	goret = int(cret)

	return goret
}

// Second retrieves the second of the minute represented by @datetime
func (d *DateTime) Second() int {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(unsafe.Pointer(d.Native()))

	var cret C.gint
	var goret int

	cret = C.g_date_time_get_second(arg0)

	goret = int(cret)

	return goret
}

// Seconds retrieves the number of seconds since the start of the last minute,
// including the fractional part.
func (d *DateTime) Seconds() float64 {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(unsafe.Pointer(d.Native()))

	var cret C.gdouble
	var goret float64

	cret = C.g_date_time_get_seconds(arg0)

	goret = float64(cret)

	return goret
}

// Timezone: get the time zone for this @datetime.
func (d *DateTime) Timezone() *TimeZone {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(unsafe.Pointer(d.Native()))

	var cret *C.GTimeZone
	var goret *TimeZone

	cret = C.g_date_time_get_timezone(arg0)

	goret = WrapTimeZone(unsafe.Pointer(cret))

	return goret
}

// TimezoneAbbreviation determines the time zone abbreviation to be used at the
// time and in the time zone of @datetime.
//
// For example, in Toronto this is currently "EST" during the winter months and
// "EDT" during the summer months when daylight savings time is in effect.
func (d *DateTime) TimezoneAbbreviation() string {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(unsafe.Pointer(d.Native()))

	var cret *C.gchar
	var goret string

	cret = C.g_date_time_get_timezone_abbreviation(arg0)

	goret = C.GoString(cret)

	return goret
}

// WeekNumberingYear returns the ISO 8601 week-numbering year in which the week
// containing @datetime falls.
//
// This function, taken together with g_date_time_get_week_of_year() and
// g_date_time_get_day_of_week() can be used to determine the full ISO week date
// on which @datetime falls.
//
// This is usually equal to the normal Gregorian year (as returned by
// g_date_time_get_year()), except as detailed below:
//
// For Thursday, the week-numbering year is always equal to the usual calendar
// year. For other days, the number is such that every day within a complete
// week (Monday to Sunday) is contained within the same week-numbering year.
//
// For Monday, Tuesday and Wednesday occurring near the end of the year, this
// may mean that the week-numbering year is one greater than the calendar year
// (so that these days have the same week-numbering year as the Thursday
// occurring early in the next year).
//
// For Friday, Saturday and Sunday occurring near the start of the year, this
// may mean that the week-numbering year is one less than the calendar year (so
// that these days have the same week-numbering year as the Thursday occurring
// late in the previous year).
//
// An equivalent description is that the week-numbering year is equal to the
// calendar year containing the majority of the days in the current week (Monday
// to Sunday).
//
// Note that January 1 0001 in the proleptic Gregorian calendar is a Monday, so
// this function never returns 0.
func (d *DateTime) WeekNumberingYear() int {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(unsafe.Pointer(d.Native()))

	var cret C.gint
	var goret int

	cret = C.g_date_time_get_week_numbering_year(arg0)

	goret = int(cret)

	return goret
}

// WeekOfYear returns the ISO 8601 week number for the week containing
// @datetime. The ISO 8601 week number is the same for every day of the week
// (from Moday through Sunday). That can produce some unusual results (described
// below).
//
// The first week of the year is week 1. This is the week that contains the
// first Thursday of the year. Equivalently, this is the first week that has
// more than 4 of its days falling within the calendar year.
//
// The value 0 is never returned by this function. Days contained within a year
// but occurring before the first ISO 8601 week of that year are considered as
// being contained in the last week of the previous year. Similarly, the final
// days of a calendar year may be considered as being part of the first ISO 8601
// week of the next year if 4 or more days of that week are contained within the
// new year.
func (d *DateTime) WeekOfYear() int {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(unsafe.Pointer(d.Native()))

	var cret C.gint
	var goret int

	cret = C.g_date_time_get_week_of_year(arg0)

	goret = int(cret)

	return goret
}

// Year retrieves the year represented by @datetime in the Gregorian calendar.
func (d *DateTime) Year() int {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(unsafe.Pointer(d.Native()))

	var cret C.gint
	var goret int

	cret = C.g_date_time_get_year(arg0)

	goret = int(cret)

	return goret
}

// Ymd retrieves the Gregorian day, month, and year of a given Time.
func (d *DateTime) Ymd() (year int, month int, day int) {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(unsafe.Pointer(d.Native()))

	arg1 := new(C.gint)
	var ret1 int
	arg2 := new(C.gint)
	var ret2 int
	arg3 := new(C.gint)
	var ret3 int

	C.g_date_time_get_ymd(arg0, arg1, arg2, arg3)

	ret1 = int(*arg1)
	ret2 = int(*arg2)
	ret3 = int(*arg3)

	return ret1, ret2, ret3
}

// Hash hashes @datetime into a #guint, suitable for use within Table.
func (d *DateTime) Hash() uint {
	var arg0 C.gpointer

	arg0 = (C.gpointer)(unsafe.Pointer(d.Native()))

	var cret C.guint
	var goret uint

	cret = C.g_date_time_hash(arg0)

	goret = uint(cret)

	return goret
}

// IsDaylightSavings determines if daylight savings time is in effect at the
// time and in the time zone of @datetime.
func (d *DateTime) IsDaylightSavings() bool {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(unsafe.Pointer(d.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.g_date_time_is_daylight_savings(arg0)

	if cret {
		goret = true
	}

	return goret
}

// Ref: atomically increments the reference count of @datetime by one.
func (d *DateTime) Ref() *DateTime {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(unsafe.Pointer(d.Native()))

	cret := new(C.GDateTime)
	var goret *DateTime

	cret = C.g_date_time_ref(arg0)

	goret = WrapDateTime(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *DateTime) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// ToLocal creates a new Time corresponding to the same instant in time as
// @datetime, but in the local time zone.
//
// This call is equivalent to calling g_date_time_to_timezone() with the time
// zone returned by g_time_zone_new_local().
func (d *DateTime) ToLocal() *DateTime {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(unsafe.Pointer(d.Native()))

	cret := new(C.GDateTime)
	var goret *DateTime

	cret = C.g_date_time_to_local(arg0)

	goret = WrapDateTime(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *DateTime) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// ToTimeval stores the instant in time that @datetime represents into @tv.
//
// The time contained in a Val is always stored in the form of seconds elapsed
// since 1970-01-01 00:00:00 UTC, regardless of the time zone associated with
// @datetime.
//
// On systems where 'long' is 32bit (ie: all 32bit systems and all Windows
// systems), a Val is incapable of storing the entire range of values that Time
// is capable of expressing. On those systems, this function returns false to
// indicate that the time is out of range.
//
// On systems where 'long' is 64bit, this function never fails.
func (d *DateTime) ToTimeval(tv *TimeVal) bool {
	var arg0 *C.GDateTime
	var arg1 *C.GTimeVal

	arg0 = (*C.GDateTime)(unsafe.Pointer(d.Native()))
	arg1 = (*C.GTimeVal)(unsafe.Pointer(tv.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.g_date_time_to_timeval(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// ToTimezone: create a new Time corresponding to the same instant in time as
// @datetime, but in the time zone @tz.
//
// This call can fail in the case that the time goes out of bounds. For example,
// converting 0001-01-01 00:00:00 UTC to a time zone west of Greenwich will fail
// (due to the year 0 being out of range).
func (d *DateTime) ToTimezone(tz *TimeZone) *DateTime {
	var arg0 *C.GDateTime
	var arg1 *C.GTimeZone

	arg0 = (*C.GDateTime)(unsafe.Pointer(d.Native()))
	arg1 = (*C.GTimeZone)(unsafe.Pointer(tz.Native()))

	cret := new(C.GDateTime)
	var goret *DateTime

	cret = C.g_date_time_to_timezone(arg0, arg1)

	goret = WrapDateTime(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *DateTime) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// ToUnix gives the Unix time corresponding to @datetime, rounding down to the
// nearest second.
//
// Unix time is the number of seconds that have elapsed since 1970-01-01
// 00:00:00 UTC, regardless of the time zone associated with @datetime.
func (d *DateTime) ToUnix() int64 {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(unsafe.Pointer(d.Native()))

	var cret C.gint64
	var goret int64

	cret = C.g_date_time_to_unix(arg0)

	goret = int64(cret)

	return goret
}

// ToUtc creates a new Time corresponding to the same instant in time as
// @datetime, but in UTC.
//
// This call is equivalent to calling g_date_time_to_timezone() with the time
// zone returned by g_time_zone_new_utc().
func (d *DateTime) ToUtc() *DateTime {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(unsafe.Pointer(d.Native()))

	cret := new(C.GDateTime)
	var goret *DateTime

	cret = C.g_date_time_to_utc(arg0)

	goret = WrapDateTime(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *DateTime) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// Unref: atomically decrements the reference count of @datetime by one.
//
// When the reference count reaches zero, the resources allocated by @datetime
// are freed
func (d *DateTime) Unref() {
	var arg0 *C.GDateTime

	arg0 = (*C.GDateTime)(unsafe.Pointer(d.Native()))

	C.g_date_time_unref(arg0)
}
