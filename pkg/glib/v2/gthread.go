// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <glib.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_thread_get_type()), F: marshalThread},
	})
}

// Cond: the #GCond struct is an opaque data structure that represents a
// condition. Threads can block on a #GCond if they find a certain condition to
// be false. If other threads change the state of this condition they signal the
// #GCond, and that causes the waiting threads to be woken up.
//
// Consider the following example of a shared variable. One or more threads can
// wait for data to be published to the variable and when another thread
// publishes the data, it can signal one of the waiting threads to wake up to
// collect the data.
//
// Here is an example for using GCond to block a thread until a condition is
// satisfied:
//
//      gpointer current_data = NULL;
//      GMutex data_mutex;
//      GCond data_cond;
//
//      void
//      push_data (gpointer data)
//      {
//        g_mutex_lock (&data_mutex);
//        current_data = data;
//        g_cond_signal (&data_cond);
//        g_mutex_unlock (&data_mutex);
//      }
//
//      gpointer
//      pop_data (void)
//      {
//        gpointer data;
//
//        g_mutex_lock (&data_mutex);
//        while (!current_data)
//          g_cond_wait (&data_cond, &data_mutex);
//        data = current_data;
//        current_data = NULL;
//        g_mutex_unlock (&data_mutex);
//
//        return data;
//      }
//
// Whenever a thread calls pop_data() now, it will wait until current_data is
// non-nil, i.e. until some other thread has called push_data().
//
// The example shows that use of a condition variable must always be paired with
// a mutex. Without the use of a mutex, there would be a race between the check
// of @current_data by the while loop in pop_data() and waiting. Specifically,
// another thread could set @current_data after the check, and signal the cond
// (with nobody waiting on it) before the first thread goes to sleep. #GCond is
// specifically useful for its ability to release the mutex and go to sleep
// atomically.
//
// It is also important to use the g_cond_wait() and g_cond_wait_until()
// functions only inside a loop which checks for the condition to be true. See
// g_cond_wait() for an explanation of why the condition may not be true even
// after it returns.
//
// If a #GCond is allocated in static storage then it can be used without
// initialisation. Otherwise, you should call g_cond_init() on it and
// g_cond_clear() when done.
//
// A #GCond should only be accessed via the g_cond_ functions.
type Cond C.GCond

// WrapCond wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapCond(ptr unsafe.Pointer) *Cond {
	return (*Cond)(ptr)
}

// Native returns the underlying C source pointer.
func (c *Cond) Native() unsafe.Pointer {
	return unsafe.Pointer(c)
}

// RWLock: the GRWLock struct is an opaque data structure to represent a
// reader-writer lock. It is similar to a #GMutex in that it allows multiple
// threads to coordinate access to a shared resource.
//
// The difference to a mutex is that a reader-writer lock discriminates between
// read-only ('reader') and full ('writer') access. While only one thread at a
// time is allowed write access (by holding the 'writer' lock via
// g_rw_lock_writer_lock()), multiple threads can gain simultaneous read-only
// access (by holding the 'reader' lock via g_rw_lock_reader_lock()).
//
// It is unspecified whether readers or writers have priority in acquiring the
// lock when a reader already holds the lock and a writer is queued to acquire
// it.
//
// Here is an example for an array with access functions: |[<!-- language="C"
// --> GRWLock lock; GPtrArray *array;
//
//     gpointer
//     my_array_get (guint index)
//     {
//       gpointer retval = NULL;
//
//       if (!array)
//         return NULL;
//
//       g_rw_lock_reader_lock (&lock);
//       if (index < array->len)
//         retval = g_ptr_array_index (array, index);
//       g_rw_lock_reader_unlock (&lock);
//
//       return retval;
//     }
//
//     void
//     my_array_set (guint index, gpointer data)
//     {
//       g_rw_lock_writer_lock (&lock);
//
//       if (!array)
//         array = g_ptr_array_new ();
//
//       if (index >= array->len)
//         g_ptr_array_set_size (array, index+1);
//       g_ptr_array_index (array, index) = data;
//
//       g_rw_lock_writer_unlock (&lock);
//     }
//    ]|
//
// This example shows an array which can be accessed by many readers (the
// my_array_get() function) simultaneously, whereas the writers (the
// my_array_set() function) will only be allowed one at a time and only if no
// readers currently access the array. This is because of the potentially
// dangerous resizing of the array. Using these functions is fully multi-thread
// safe now.
//
// If a WLock is allocated in static storage then it can be used without
// initialisation. Otherwise, you should call g_rw_lock_init() on it and
// g_rw_lock_clear() when done.
//
// A GRWLock should only be accessed with the g_rw_lock_ functions.
type RWLock C.GRWLock

// WrapRWLock wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRWLock(ptr unsafe.Pointer) *RWLock {
	return (*RWLock)(ptr)
}

// Native returns the underlying C source pointer.
func (r *RWLock) Native() unsafe.Pointer {
	return unsafe.Pointer(r)
}

// RecMutex: the GRecMutex struct is an opaque data structure to represent a
// recursive mutex. It is similar to a #GMutex with the difference that it is
// possible to lock a GRecMutex multiple times in the same thread without
// deadlock. When doing so, care has to be taken to unlock the recursive mutex
// as often as it has been locked.
//
// If a Mutex is allocated in static storage then it can be used without
// initialisation. Otherwise, you should call g_rec_mutex_init() on it and
// g_rec_mutex_clear() when done.
//
// A GRecMutex should only be accessed with the g_rec_mutex_ functions.
type RecMutex C.GRecMutex

// WrapRecMutex wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRecMutex(ptr unsafe.Pointer) *RecMutex {
	return (*RecMutex)(ptr)
}

// Native returns the underlying C source pointer.
func (r *RecMutex) Native() unsafe.Pointer {
	return unsafe.Pointer(r)
}

// Thread: the #GThread struct represents a running thread. This struct is
// returned by g_thread_new() or g_thread_try_new(). You can obtain the #GThread
// struct representing the current thread by calling g_thread_self().
//
// GThread is refcounted, see g_thread_ref() and g_thread_unref(). The thread
// represented by it holds a reference while it is running, and g_thread_join()
// consumes the reference that it is given, so it is normally not necessary to
// manage GThread references explicitly.
//
// The structure is opaque -- none of its fields may be directly accessed.
type Thread C.GThread

// WrapThread wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapThread(ptr unsafe.Pointer) *Thread {
	return (*Thread)(ptr)
}

func marshalThread(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*Thread)(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *Thread) Native() unsafe.Pointer {
	return unsafe.Pointer(t)
}
