// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"unsafe"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib.h>
import "C"

// PatternMatch matches a string against a compiled pattern. Passing the correct
// length of the string given is mandatory. The reversed string can be omitted
// by passing nil, this is more efficient if the reversed version of the string
// to be matched is not at hand, as g_pattern_match() will only construct it if
// the compiled pattern requires reverse matches.
//
// Note that, if the user code will (possibly) match a string against a
// multitude of patterns containing wildcards, chances are high that some
// patterns will require a reversed string. In this case, it's more efficient to
// provide the reversed string to avoid multiple constructions thereof in the
// various calls to g_pattern_match().
//
// Note also that the reverse of a UTF-8 encoded string can in general not be
// obtained by g_strreverse(). This works only if the string does not contain
// any multibyte characters. GLib offers the g_utf8_strreverse() function to
// reverse UTF-8 encoded strings.
func PatternMatch(pspec *PatternSpec, stringLength uint, _string string, stringReversed string) bool {
	var _arg1 *C.GPatternSpec // out
	var _arg2 C.guint         // out
	var _arg3 *C.gchar        // out
	var _arg4 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg1 = (*C.GPatternSpec)(unsafe.Pointer(pspec.Native()))
	_arg2 = C.guint(stringLength)
	_arg3 = (*C.gchar)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(C.CString(stringReversed))
	defer C.free(unsafe.Pointer(_arg4))

	_cret = C.g_pattern_match(_arg1, _arg2, _arg3, _arg4)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PatternMatchSimple matches a string against a pattern given as a string. If
// this function is to be called in a loop, it's more efficient to compile the
// pattern once with g_pattern_spec_new() and call g_pattern_match_string()
// repeatedly.
func PatternMatchSimple(pattern string, _string string) bool {
	var _arg1 *C.gchar   // out
	var _arg2 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(C.CString(pattern))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_pattern_match_simple(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PatternMatchString matches a string against a compiled pattern. If the string
// is to be matched against more than one pattern, consider using
// g_pattern_match() instead while supplying the reversed string.
func PatternMatchString(pspec *PatternSpec, _string string) bool {
	var _arg1 *C.GPatternSpec // out
	var _arg2 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg1 = (*C.GPatternSpec)(unsafe.Pointer(pspec.Native()))
	_arg2 = (*C.gchar)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_pattern_match_string(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PatternSpec: a GPatternSpec struct is the 'compiled' form of a pattern. This
// structure is opaque and its fields cannot be accessed directly.
type PatternSpec C.GPatternSpec

// WrapPatternSpec wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPatternSpec(ptr unsafe.Pointer) *PatternSpec {
	return (*PatternSpec)(ptr)
}

// Native returns the underlying C source pointer.
func (p *PatternSpec) Native() unsafe.Pointer {
	return unsafe.Pointer(p)
}

// Equal frees the memory allocated for the Spec.
func (p *PatternSpec) Equal(pspec2 *PatternSpec) bool {
	var _arg0 *C.GPatternSpec // out
	var _arg1 *C.GPatternSpec // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GPatternSpec)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GPatternSpec)(unsafe.Pointer(pspec2.Native()))

	_cret = C.g_pattern_spec_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Free frees the memory allocated for the Spec.
func (p *PatternSpec) Free() {
	var _arg0 *C.GPatternSpec // out

	_arg0 = (*C.GPatternSpec)(unsafe.Pointer(p.Native()))

	C.g_pattern_spec_free(_arg0)
}
