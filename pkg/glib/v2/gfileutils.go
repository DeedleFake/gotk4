// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"reflect"
	"runtime"
	"unsafe"
)

// #cgo pkg-config: glib-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <stdbool.h>
// #include <glib.h>
import "C"

// FileError values corresponding to @errno codes returned from file operations
// on UNIX. Unlike @errno codes, GFileError values are available on all systems,
// even Windows. The exact meaning of each code depends on what sort of file
// operation you were performing; the UNIX documentation gives more details. The
// following error code descriptions come from the GNU C Library manual, and are
// under the copyright of that manual.
//
// It's not very portable to make detailed assumptions about exactly which
// errors will be returned from a given operation. Some errors don't occur on
// some systems, etc., sometimes there are subtle differences in when a system
// will report a given error, etc.
type FileError int

const (
	// FileErrorExist: operation not permitted; only the owner of the file (or
	// other resource) or processes with special privileges can perform the
	// operation.
	FileErrorExist FileError = 0
	// FileErrorIsdir: file is a directory; you cannot open a directory for
	// writing, or create or remove hard links to it.
	FileErrorIsdir FileError = 1
	// FileErrorAcces: permission denied; the file permissions do not allow the
	// attempted operation.
	FileErrorAcces FileError = 2
	// FileErrorNametoolong: filename too long.
	FileErrorNametoolong FileError = 3
	// FileErrorNoent: no such file or directory. This is a "file doesn't exist"
	// error for ordinary files that are referenced in contexts where they are
	// expected to already exist.
	FileErrorNoent FileError = 4
	// FileErrorNotdir: a file that isn't a directory was specified when a
	// directory is required.
	FileErrorNotdir FileError = 5
	// FileErrorNxio: no such device or address. The system tried to use the
	// device represented by a file you specified, and it couldn't find the
	// device. This can mean that the device file was installed incorrectly, or
	// that the physical device is missing or not correctly attached to the
	// computer.
	FileErrorNxio FileError = 6
	// FileErrorNodev: the underlying file system of the specified file does not
	// support memory mapping.
	FileErrorNodev FileError = 7
	// FileErrorRofs: the directory containing the new link can't be modified
	// because it's on a read-only file system.
	FileErrorRofs FileError = 8
	// FileErrorTxtbsy: text file busy.
	FileErrorTxtbsy FileError = 9
	// FileErrorFault: you passed in a pointer to bad memory. (GLib won't
	// reliably return this, don't pass in pointers to bad memory.)
	FileErrorFault FileError = 10
	// FileErrorLoop: too many levels of symbolic links were encountered in
	// looking up a file name. This often indicates a cycle of symbolic links.
	FileErrorLoop FileError = 11
	// FileErrorNospc: no space left on device; write operation on a file failed
	// because the disk is full.
	FileErrorNospc FileError = 12
	// FileErrorNomem: no memory available. The system cannot allocate more
	// virtual memory because its capacity is full.
	FileErrorNomem FileError = 13
	// FileErrorMfile: the current process has too many files open and can't
	// open any more. Duplicate descriptors do count toward this limit.
	FileErrorMfile FileError = 14
	// FileErrorNfile: there are too many distinct file openings in the entire
	// system.
	FileErrorNfile FileError = 15
	// FileErrorBadf: bad file descriptor; for example, I/O on a descriptor that
	// has been closed or reading from a descriptor open only for writing (or
	// vice versa).
	FileErrorBadf FileError = 16
	// FileErrorInval: invalid argument. This is used to indicate various kinds
	// of problems with passing the wrong argument to a library function.
	FileErrorInval FileError = 17
	// FileErrorPipe: broken pipe; there is no process reading from the other
	// end of a pipe. Every library function that returns this error code also
	// generates a 'SIGPIPE' signal; this signal terminates the program if not
	// handled or blocked. Thus, your program will never actually see this code
	// unless it has handled or blocked 'SIGPIPE'.
	FileErrorPipe FileError = 18
	// FileErrorAgain: resource temporarily unavailable; the call might work if
	// you try again later.
	FileErrorAgain FileError = 19
	// FileErrorIntr: interrupted function call; an asynchronous signal occurred
	// and prevented completion of the call. When this happens, you should try
	// the call again.
	FileErrorIntr FileError = 20
	// FileErrorIO: input/output error; usually used for physical read or write
	// errors. i.e. the disk or other physical device hardware is returning
	// errors.
	FileErrorIO FileError = 21
	// FileErrorPerm: operation not permitted; only the owner of the file (or
	// other resource) or processes with special privileges can perform the
	// operation.
	FileErrorPerm FileError = 22
	// FileErrorNosys: function not implemented; this indicates that the system
	// is missing some functionality.
	FileErrorNosys FileError = 23
	// FileErrorFailed does not correspond to a UNIX error code; this is the
	// standard "failed for unspecified reason" error code present in all
	// #GError error code enumerations. Returned if no specific code applies.
	FileErrorFailed FileError = 24
)

// FileSetContentsFlags flags to pass to g_file_set_contents_full() to affect
// its safety and performance.
type FileSetContentsFlags int

const (
	// FileSetContentsFlagsNone: no guarantees about file consistency or
	// durability. The most dangerous setting, which is slightly faster than
	// other settings.
	FileSetContentsFlagsNone FileSetContentsFlags = 0b0
	// FileSetContentsFlagsConsistent: guarantee file consistency: after a
	// crash, either the old version of the file or the new version of the file
	// will be available, but not a mixture. On Unix systems this equates to an
	// `fsync()` on the file and use of an atomic `rename()` of the new version
	// of the file over the old.
	FileSetContentsFlagsConsistent FileSetContentsFlags = 0b1
	// FileSetContentsFlagsDurable: guarantee file durability: after a crash,
	// the new version of the file will be available. On Unix systems this
	// equates to an `fsync()` on the file (if G_FILE_SET_CONTENTS_CONSISTENT is
	// unset), or the effects of G_FILE_SET_CONTENTS_CONSISTENT plus an
	// `fsync()` on the directory containing the file after calling `rename()`.
	FileSetContentsFlagsDurable FileSetContentsFlags = 0b10
	// FileSetContentsFlagsOnlyExisting: only apply consistency and durability
	// guarantees if the file already exists. This may speed up file operations
	// if the file doesnâ€™t currently exist, but may result in a corrupted
	// version of the new file if the system crashes while writing it.
	FileSetContentsFlagsOnlyExisting FileSetContentsFlags = 0b100
)

// FileTest: a test to perform on a file using g_file_test().
type FileTest int

const (
	// FileTestIsRegular: true if the file is a regular file (not a directory).
	// Note that this test will also return true if the tested file is a symlink
	// to a regular file.
	FileTestIsRegular FileTest = 0b1
	// FileTestIsSymlink: true if the file is a symlink.
	FileTestIsSymlink FileTest = 0b10
	// FileTestIsDir: true if the file is a directory.
	FileTestIsDir FileTest = 0b100
	// FileTestIsExecutable: true if the file is executable.
	FileTestIsExecutable FileTest = 0b1000
	// FileTestExists: true if the file exists. It may or may not be a regular
	// file.
	FileTestExists FileTest = 0b10000
)

// Basename gets the name of the file without any leading directory components.
// It returns a pointer into the given file name string.
func Basename(fileName string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_basename(arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// BuildFilenamev behaves exactly like g_build_filename(), but takes the path
// elements as a string array, instead of varargs. This function is mainly meant
// for language bindings.
func BuildFilenamev(args []string) string {
	var arg1 **C.gchar

	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(args) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(args)
		sliceHeader.Cap = len(args)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(args); i++ {
			src := args[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg1 = (**C.gchar)(unsafe.Pointer(ptr))
	}

	ret := C.g_build_filenamev(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// BuildPathv behaves exactly like g_build_path(), but takes the path elements
// as a string array, instead of varargs. This function is mainly meant for
// language bindings.
func BuildPathv(separator string, args []string) string {
	var arg1 *C.gchar
	var arg2 **C.gchar

	arg1 = (*C.gchar)(C.CString(separator))
	defer C.free(unsafe.Pointer(arg1))
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(args) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(args)
		sliceHeader.Cap = len(args)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(args); i++ {
			src := args[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg2 = (**C.gchar)(unsafe.Pointer(ptr))
	}

	ret := C.g_build_pathv(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// CanonicalizeFilename gets the canonical file name from @filename. All triple
// slashes are turned into single slashes, and all `..` and `.`s resolved
// against @relative_to.
//
// Symlinks are not followed, and the returned path is guaranteed to be
// absolute.
//
// If @filename is an absolute path, @relative_to is ignored. Otherwise,
// @relative_to will be prepended to @filename to make it absolute. @relative_to
// must be an absolute path, or nil. If @relative_to is nil, it'll fallback to
// g_get_current_dir().
//
// This function never fails, and will canonicalize file paths even if they
// don't exist.
//
// No file system I/O is done.
func CanonicalizeFilename(filename string, relativeTo string) string {
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(relativeTo))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_canonicalize_filename(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// DirMakeTmp creates a subdirectory in the preferred directory for temporary
// files (as returned by g_get_tmp_dir()).
//
// @tmpl should be a string in the GLib file name encoding containing a sequence
// of six 'X' characters, as the parameter to g_mkstemp(). However, unlike these
// functions, the template should only be a basename, no directory components
// are allowed. If template is nil, a default template is used.
//
// Note that in contrast to g_mkdtemp() (and mkdtemp()) @tmpl is not modified,
// and might thus be a read-only literal string.
func DirMakeTmp(tmpl string) (filename string, err error) {
	var arg1 *C.gchar
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(tmpl))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_dir_make_tmp(arg1, &gError)

	var ret0 string
	var goError error

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// FileErrorFromErrno gets a Error constant based on the passed-in @err_no. For
// example, if you pass in `EEXIST` this function returns FILE_ERROR_EXIST.
// Unlike `errno` values, you can portably assume that all Error values will
// exist.
//
// Normally a Error value goes into a #GError returned from a function that
// manipulates files. So you would use g_file_error_from_errno() when
// constructing a #GError.
func FileErrorFromErrno(errNo int) FileError {
	var arg1 C.gint

	arg1 = C.gint(errNo)

	ret := C.g_file_error_from_errno(arg1)

	var ret0 FileError

	ret0 = FileError(ret)

	return ret0
}

// FileGetContents reads an entire file into allocated memory, with good error
// checking.
//
// If the call was successful, it returns true and sets @contents to the file
// contents and @length to the length of the file contents in bytes. The string
// stored in @contents will be nul-terminated, so for text files you can pass
// nil for the @length argument. If the call was not successful, it returns
// false and sets @error. The error domain is FILE_ERROR. Possible error codes
// are those in the Error enumeration. In the error case, @contents is set to
// nil and @length is set to zero.
func FileGetContents(filename string) (contents []byte, length uint, err error) {
	var arg1 *C.gchar
	var arg2 **C.gchar // out
	var arg3 *C.gsize  // out
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_file_get_contents(arg1, &arg2, &arg3, &gError)

	var ret0 []byte
	var ret1 uint
	var goError error

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret0))
		sliceHeader.Data = uintptr(unsafe.Pointer(arg2))
		sliceHeader.Len = arg3
		sliceHeader.Cap = arg3
		runtime.SetFinalizer(&arg2, func() {
			C.free(unsafe.Pointer(arg2))
		})
		defer runtime.KeepAlive(arg2)
	}

	ret1 = uint(arg3)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// FileOpenTmp opens a file for writing in the preferred directory for temporary
// files (as returned by g_get_tmp_dir()).
//
// @tmpl should be a string in the GLib file name encoding containing a sequence
// of six 'X' characters, as the parameter to g_mkstemp(). However, unlike these
// functions, the template should only be a basename, no directory components
// are allowed. If template is nil, a default template is used.
//
// Note that in contrast to g_mkstemp() (and mkstemp()) @tmpl is not modified,
// and might thus be a read-only literal string.
//
// Upon success, and if @name_used is non-nil, the actual name used is returned
// in @name_used. This string should be freed with g_free() when not needed any
// longer. The returned name is in the GLib file name encoding.
func FileOpenTmp(tmpl string) (nameUsed string, gint int, err error) {
	var arg1 *C.gchar
	var arg2 **C.gchar // out
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(tmpl))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_file_open_tmp(arg1, &arg2, &gError)

	var ret0 string
	var ret1 int
	var goError error

	ret0 = C.GoString(arg2)
	C.free(unsafe.Pointer(arg2))

	ret1 = int(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// FileReadLink reads the contents of the symbolic link @filename like the POSIX
// readlink() function. The returned string is in the encoding used for
// filenames. Use g_filename_to_utf8() to convert it to UTF-8.
func FileReadLink(filename string) (filename string, err error) {
	var arg1 *C.gchar
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_file_read_link(arg1, &gError)

	var ret0 string
	var goError error

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// FileSetContents writes all of @contents to a file named @filename. This is a
// convenience wrapper around calling g_file_set_contents_full() with `flags`
// set to `G_FILE_SET_CONTENTS_CONSISTENT | G_FILE_SET_CONTENTS_ONLY_EXISTING`
// and `mode` set to `0666`.
func FileSetContents(filename string, contents []byte) error {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 C.gssize
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(unsafe.Pointer(&contents[0]))
	arg3 = len(contents)
	defer runtime.KeepAlive(contents)

	ret := C.g_file_set_contents(arg1, arg2, arg3, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// FileSetContentsFull writes all of @contents to a file named @filename, with
// good error checking. If a file called @filename already exists it will be
// overwritten.
//
// @flags control the properties of the write operation: whether itâ€™s atomic,
// and what the tradeoff is between returning quickly or being resilient to
// system crashes.
//
// As this function performs file I/O, it is recommended to not call it anywhere
// where blocking would cause problems, such as in the main loop of a graphical
// application. In particular, if @flags has any value other than
// G_FILE_SET_CONTENTS_NONE then this function may call `fsync()`.
//
// If G_FILE_SET_CONTENTS_CONSISTENT is set in @flags, the operation is atomic
// in the sense that it is first written to a temporary file which is then
// renamed to the final name.
//
// Notes:
//
// - On UNIX, if @filename already exists hard links to @filename will break.
// Also since the file is recreated, existing permissions, access control lists,
// metadata etc. may be lost. If @filename is a symbolic link, the link itself
// will be replaced, not the linked file.
//
// - On UNIX, if @filename already exists and is non-empty, and if the system
// supports it (via a journalling filesystem or equivalent), and if
// G_FILE_SET_CONTENTS_CONSISTENT is set in @flags, the `fsync()` call (or
// equivalent) will be used to ensure atomic replacement: @filename will contain
// either its old contents or @contents, even in the face of system power loss,
// the disk being unsafely removed, etc.
//
// - On UNIX, if @filename does not already exist or is empty, there is a
// possibility that system power loss etc. after calling this function will
// leave @filename empty or full of NUL bytes, depending on the underlying
// filesystem, unless G_FILE_SET_CONTENTS_DURABLE and
// G_FILE_SET_CONTENTS_CONSISTENT are set in @flags.
//
// - On Windows renaming a file will not remove an existing file with the new
// name, so on Windows there is a race condition between the existing file being
// removed and the temporary file being renamed.
//
// - On Windows there is no way to remove a file that is open to some process,
// or mapped into memory. Thus, this function will fail if @filename already
// exists and is open.
//
// If the call was successful, it returns true. If the call was not successful,
// it returns false and sets @error. The error domain is FILE_ERROR. Possible
// error codes are those in the Error enumeration.
//
// Note that the name for the temporary file is constructed by appending up to 7
// characters to @filename.
//
// If the file didnâ€™t exist before and is created, it will be given the
// permissions from @mode. Otherwise, the permissions of the existing file may
// be changed to @mode depending on @flags, or they may remain unchanged.
func FileSetContentsFull(filename string, contents []byte, flags FileSetContentsFlags, mode int) error {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 C.gssize
	var arg4 C.GFileSetContentsFlags
	var arg5 C.int
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(unsafe.Pointer(&contents[0]))
	arg3 = len(contents)
	defer runtime.KeepAlive(contents)
	arg4 = (C.GFileSetContentsFlags)(flags)
	arg5 = C.int(mode)

	ret := C.g_file_set_contents_full(arg1, arg2, arg3, arg4, arg5, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// FileTest returns true if any of the tests in the bitfield @test are true. For
// example, `(G_FILE_TEST_EXISTS | G_FILE_TEST_IS_DIR)` will return true if the
// file exists; the check whether it's a directory doesn't matter since the
// existence test is true. With the current set of available tests, there's no
// point passing in more than one test at a time.
//
// Apart from G_FILE_TEST_IS_SYMLINK all tests follow symbolic links, so for a
// symbolic link to a regular file g_file_test() will return true for both
// G_FILE_TEST_IS_SYMLINK and G_FILE_TEST_IS_REGULAR.
//
// Note, that for a dangling symbolic link g_file_test() will return true for
// G_FILE_TEST_IS_SYMLINK and false for all other flags.
//
// You should never use g_file_test() to test whether it is safe to perform an
// operation, because there is always the possibility of the condition changing
// before you actually perform the operation. For example, you might think you
// could use G_FILE_TEST_IS_SYMLINK to know whether it is safe to write to a
// file without being tricked into writing into a different location. It doesn't
// work!
//
//    // DON'T DO THIS
//    if (!g_file_test (filename, G_FILE_TEST_IS_SYMLINK))
//      {
//        fd = g_open (filename, O_WRONLY);
//        // write to fd
//      }
//
// Another thing to note is that G_FILE_TEST_EXISTS and
// G_FILE_TEST_IS_EXECUTABLE are implemented using the access() system call.
// This usually doesn't matter, but if your program is setuid or setgid it means
// that these tests will give you the answer for the real user ID and group ID,
// rather than the effective user ID and group ID.
//
// On Windows, there are no symlinks, so testing for G_FILE_TEST_IS_SYMLINK will
// always return false. Testing for G_FILE_TEST_IS_EXECUTABLE will just check
// that the file exists and its name indicates that it is executable, checking
// for well-known extensions and those listed in the `PATHEXT` environment
// variable.
func FileTest(filename string, test FileTest) bool {
	var arg1 *C.gchar
	var arg2 C.GFileTest

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GFileTest)(test)

	ret := C.g_file_test(arg1, arg2)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// GetCurrentDir gets the current directory.
//
// The returned string should be freed when no longer needed. The encoding of
// the returned string is system defined. On Windows, it is always UTF-8.
//
// Since GLib 2.40, this function will return the value of the "PWD" environment
// variable if it is set and it happens to be the same as the current directory.
// This can make a difference in the case that the current directory is the
// target of a symbolic link.
func GetCurrentDir() string {
	ret := C.g_get_current_dir()

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// MkdirWithParents: create a directory if it doesn't already exist. Create
// intermediate parent directories as needed, too.
func MkdirWithParents(pathname string, mode int) int {
	var arg1 *C.gchar
	var arg2 C.gint

	arg1 = (*C.gchar)(C.CString(pathname))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(mode)

	ret := C.g_mkdir_with_parents(arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Mkdtemp creates a temporary directory. See the mkdtemp() documentation on
// most UNIX-like systems.
//
// The parameter is a string that should follow the rules for mkdtemp()
// templates, i.e. contain the string "XXXXXX". g_mkdtemp() is slightly more
// flexible than mkdtemp() in that the sequence does not have to occur at the
// very end of the template. The X string will be modified to form the name of a
// directory that didn't exist. The string should be in the GLib file name
// encoding. Most importantly, on Windows it should be in UTF-8.
//
// If you are going to be creating a temporary directory inside the directory
// returned by g_get_tmp_dir(), you might want to use g_dir_make_tmp() instead.
func Mkdtemp(tmpl string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(tmpl))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_mkdtemp(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// MkdtempFull creates a temporary directory. See the mkdtemp() documentation on
// most UNIX-like systems.
//
// The parameter is a string that should follow the rules for mkdtemp()
// templates, i.e. contain the string "XXXXXX". g_mkdtemp_full() is slightly
// more flexible than mkdtemp() in that the sequence does not have to occur at
// the very end of the template and you can pass a @mode. The X string will be
// modified to form the name of a directory that didn't exist. The string should
// be in the GLib file name encoding. Most importantly, on Windows it should be
// in UTF-8.
//
// If you are going to be creating a temporary directory inside the directory
// returned by g_get_tmp_dir(), you might want to use g_dir_make_tmp() instead.
func MkdtempFull(tmpl string, mode int) string {
	var arg1 *C.gchar
	var arg2 C.gint

	arg1 = (*C.gchar)(C.CString(tmpl))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(mode)

	ret := C.g_mkdtemp_full(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Mkstemp opens a temporary file. See the mkstemp() documentation on most
// UNIX-like systems.
//
// The parameter is a string that should follow the rules for mkstemp()
// templates, i.e. contain the string "XXXXXX". g_mkstemp() is slightly more
// flexible than mkstemp() in that the sequence does not have to occur at the
// very end of the template. The X string will be modified to form the name of a
// file that didn't exist. The string should be in the GLib file name encoding.
// Most importantly, on Windows it should be in UTF-8.
func Mkstemp(tmpl string) int {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(tmpl))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_mkstemp(arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// MkstempFull opens a temporary file. See the mkstemp() documentation on most
// UNIX-like systems.
//
// The parameter is a string that should follow the rules for mkstemp()
// templates, i.e. contain the string "XXXXXX". g_mkstemp_full() is slightly
// more flexible than mkstemp() in that the sequence does not have to occur at
// the very end of the template and you can pass a @mode and additional @flags.
// The X string will be modified to form the name of a file that didn't exist.
// The string should be in the GLib file name encoding. Most importantly, on
// Windows it should be in UTF-8.
func MkstempFull(tmpl string, flags int, mode int) int {
	var arg1 *C.gchar
	var arg2 C.gint
	var arg3 C.gint

	arg1 = (*C.gchar)(C.CString(tmpl))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(flags)
	arg3 = C.gint(mode)

	ret := C.g_mkstemp_full(arg1, arg2, arg3)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// PathGetBasename gets the last component of the filename.
//
// If @file_name ends with a directory separator it gets the component before
// the last slash. If @file_name consists only of directory separators (and on
// Windows, possibly a drive letter), a single separator is returned. If
// @file_name is empty, it gets ".".
func PathGetBasename(fileName string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_path_get_basename(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// PathGetDirname gets the directory components of a file name. For example, the
// directory component of `/usr/bin/test` is `/usr/bin`. The directory component
// of `/` is `/`.
//
// If the file name has no directory components "." is returned. The returned
// string should be freed when no longer needed.
func PathGetDirname(fileName string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_path_get_dirname(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// PathIsAbsolute returns true if the given @file_name is an absolute file name.
// Note that this is a somewhat vague concept on Windows.
//
// On POSIX systems, an absolute file name is well-defined. It always starts
// from the single root directory. For example "/usr/local".
//
// On Windows, the concepts of current drive and drive-specific current
// directory introduce vagueness. This function interprets as an absolute file
// name one that either begins with a directory separator such as "\Users\tml"
// or begins with the root on a drive, for example "C:\Windows". The first case
// also includes UNC paths such as "\\\\myserver\docs\foo". In all cases, either
// slashes or backslashes are accepted.
//
// Note that a file name relative to the current drive root does not truly
// specify a file uniquely over time and across processes, as the current drive
// is a per-process value and can be changed.
//
// File names relative the current directory on some specific drive, such as
// "D:foo/bar", are not interpreted as absolute by this function, but they
// obviously are not relative to the normal current directory as returned by
// getcwd() or g_get_current_dir() either. Such paths should be avoided, or need
// to be handled using Windows-specific code.
func PathIsAbsolute(fileName string) bool {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_path_is_absolute(arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// PathSkipRoot returns a pointer into @file_name after the root component, i.e.
// after the "/" in UNIX or "C:\" under Windows. If @file_name is not an
// absolute path it returns nil.
func PathSkipRoot(fileName string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_path_skip_root(arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}
