// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/ptr"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <stdbool.h>
// #include <glib.h>
import "C"

// FileError values corresponding to @errno codes returned from file operations
// on UNIX. Unlike @errno codes, GFileError values are available on all systems,
// even Windows. The exact meaning of each code depends on what sort of file
// operation you were performing; the UNIX documentation gives more details. The
// following error code descriptions come from the GNU C Library manual, and are
// under the copyright of that manual.
//
// It's not very portable to make detailed assumptions about exactly which
// errors will be returned from a given operation. Some errors don't occur on
// some systems, etc., sometimes there are subtle differences in when a system
// will report a given error, etc.
type FileError int

const (
	// FileErrorExist: operation not permitted; only the owner of the file (or
	// other resource) or processes with special privileges can perform the
	// operation.
	FileErrorExist FileError = 0
	// FileErrorIsdir: file is a directory; you cannot open a directory for
	// writing, or create or remove hard links to it.
	FileErrorIsdir FileError = 1
	// FileErrorAcces: permission denied; the file permissions do not allow the
	// attempted operation.
	FileErrorAcces FileError = 2
	// FileErrorNametoolong: filename too long.
	FileErrorNametoolong FileError = 3
	// FileErrorNoent: no such file or directory. This is a "file doesn't exist"
	// error for ordinary files that are referenced in contexts where they are
	// expected to already exist.
	FileErrorNoent FileError = 4
	// FileErrorNotdir: a file that isn't a directory was specified when a
	// directory is required.
	FileErrorNotdir FileError = 5
	// FileErrorNxio: no such device or address. The system tried to use the
	// device represented by a file you specified, and it couldn't find the
	// device. This can mean that the device file was installed incorrectly, or
	// that the physical device is missing or not correctly attached to the
	// computer.
	FileErrorNxio FileError = 6
	// FileErrorNodev: the underlying file system of the specified file does not
	// support memory mapping.
	FileErrorNodev FileError = 7
	// FileErrorRofs: the directory containing the new link can't be modified
	// because it's on a read-only file system.
	FileErrorRofs FileError = 8
	// FileErrorTxtbsy: text file busy.
	FileErrorTxtbsy FileError = 9
	// FileErrorFault: you passed in a pointer to bad memory. (GLib won't
	// reliably return this, don't pass in pointers to bad memory.)
	FileErrorFault FileError = 10
	// FileErrorLoop: too many levels of symbolic links were encountered in
	// looking up a file name. This often indicates a cycle of symbolic links.
	FileErrorLoop FileError = 11
	// FileErrorNospc: no space left on device; write operation on a file failed
	// because the disk is full.
	FileErrorNospc FileError = 12
	// FileErrorNomem: no memory available. The system cannot allocate more
	// virtual memory because its capacity is full.
	FileErrorNomem FileError = 13
	// FileErrorMfile: the current process has too many files open and can't
	// open any more. Duplicate descriptors do count toward this limit.
	FileErrorMfile FileError = 14
	// FileErrorNfile: there are too many distinct file openings in the entire
	// system.
	FileErrorNfile FileError = 15
	// FileErrorBadf: bad file descriptor; for example, I/O on a descriptor that
	// has been closed or reading from a descriptor open only for writing (or
	// vice versa).
	FileErrorBadf FileError = 16
	// FileErrorInval: invalid argument. This is used to indicate various kinds
	// of problems with passing the wrong argument to a library function.
	FileErrorInval FileError = 17
	// FileErrorPipe: broken pipe; there is no process reading from the other
	// end of a pipe. Every library function that returns this error code also
	// generates a 'SIGPIPE' signal; this signal terminates the program if not
	// handled or blocked. Thus, your program will never actually see this code
	// unless it has handled or blocked 'SIGPIPE'.
	FileErrorPipe FileError = 18
	// FileErrorAgain: resource temporarily unavailable; the call might work if
	// you try again later.
	FileErrorAgain FileError = 19
	// FileErrorIntr: interrupted function call; an asynchronous signal occurred
	// and prevented completion of the call. When this happens, you should try
	// the call again.
	FileErrorIntr FileError = 20
	// FileErrorIO: input/output error; usually used for physical read or write
	// errors. i.e. the disk or other physical device hardware is returning
	// errors.
	FileErrorIO FileError = 21
	// FileErrorPerm: operation not permitted; only the owner of the file (or
	// other resource) or processes with special privileges can perform the
	// operation.
	FileErrorPerm FileError = 22
	// FileErrorNosys: function not implemented; this indicates that the system
	// is missing some functionality.
	FileErrorNosys FileError = 23
	// FileErrorFailed does not correspond to a UNIX error code; this is the
	// standard "failed for unspecified reason" error code present in all
	// #GError error code enumerations. Returned if no specific code applies.
	FileErrorFailed FileError = 24
)

// FileSetContentsFlags flags to pass to g_file_set_contents_full() to affect
// its safety and performance.
type FileSetContentsFlags int

const (
	// FileSetContentsFlagsNone: no guarantees about file consistency or
	// durability. The most dangerous setting, which is slightly faster than
	// other settings.
	FileSetContentsFlagsNone FileSetContentsFlags = 0b0
	// FileSetContentsFlagsConsistent: guarantee file consistency: after a
	// crash, either the old version of the file or the new version of the file
	// will be available, but not a mixture. On Unix systems this equates to an
	// `fsync()` on the file and use of an atomic `rename()` of the new version
	// of the file over the old.
	FileSetContentsFlagsConsistent FileSetContentsFlags = 0b1
	// FileSetContentsFlagsDurable: guarantee file durability: after a crash,
	// the new version of the file will be available. On Unix systems this
	// equates to an `fsync()` on the file (if G_FILE_SET_CONTENTS_CONSISTENT is
	// unset), or the effects of G_FILE_SET_CONTENTS_CONSISTENT plus an
	// `fsync()` on the directory containing the file after calling `rename()`.
	FileSetContentsFlagsDurable FileSetContentsFlags = 0b10
	// FileSetContentsFlagsOnlyExisting: only apply consistency and durability
	// guarantees if the file already exists. This may speed up file operations
	// if the file doesnâ€™t currently exist, but may result in a corrupted
	// version of the new file if the system crashes while writing it.
	FileSetContentsFlagsOnlyExisting FileSetContentsFlags = 0b100
)

// FileTest: a test to perform on a file using g_file_test().
type FileTest int

const (
	// FileTestIsRegular: true if the file is a regular file (not a directory).
	// Note that this test will also return true if the tested file is a symlink
	// to a regular file.
	FileTestIsRegular FileTest = 0b1
	// FileTestIsSymlink: true if the file is a symlink.
	FileTestIsSymlink FileTest = 0b10
	// FileTestIsDir: true if the file is a directory.
	FileTestIsDir FileTest = 0b100
	// FileTestIsExecutable: true if the file is executable.
	FileTestIsExecutable FileTest = 0b1000
	// FileTestExists: true if the file exists. It may or may not be a regular
	// file.
	FileTestExists FileTest = 0b10000
)

// Basename gets the name of the file without any leading directory components.
// It returns a pointer into the given file name string.
func Basename(fileName string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.gchar
	var goret1 string

	cret = C.g_basename(fileName)

	goret1 = C.GoString(cret)

	return goret1
}

// BuildFilenamev behaves exactly like g_build_filename(), but takes the path
// elements as a string array, instead of varargs. This function is mainly meant
// for language bindings.
func BuildFilenamev(args []string) string {
	var arg1 **C.gchar

	arg1 = C.malloc(len(args) * (unsafe.Sizeof(int(0)) + 1))
	defer C.free(unsafe.Pointer(arg1))

	{
		var out []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg1), int(len(args)))

		for i := range args {
			out[i] = (*C.gchar)(C.CString(args[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	var cret *C.gchar
	var goret1 string

	cret = C.g_build_filenamev(args)

	goret1 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return goret1
}

// BuildPathv behaves exactly like g_build_path(), but takes the path elements
// as a string array, instead of varargs. This function is mainly meant for
// language bindings.
func BuildPathv(separator string, args []string) string {
	var arg1 *C.gchar
	var arg2 **C.gchar

	arg1 = (*C.gchar)(C.CString(separator))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.malloc(len(args) * (unsafe.Sizeof(int(0)) + 1))
	defer C.free(unsafe.Pointer(arg2))

	{
		var out []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg2), int(len(args)))

		for i := range args {
			out[i] = (*C.gchar)(C.CString(args[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	var cret *C.gchar
	var goret1 string

	cret = C.g_build_pathv(separator, args)

	goret1 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return goret1
}

// CanonicalizeFilename gets the canonical file name from @filename. All triple
// slashes are turned into single slashes, and all `..` and `.`s resolved
// against @relative_to.
//
// Symlinks are not followed, and the returned path is guaranteed to be
// absolute.
//
// If @filename is an absolute path, @relative_to is ignored. Otherwise,
// @relative_to will be prepended to @filename to make it absolute. @relative_to
// must be an absolute path, or nil. If @relative_to is nil, it'll fallback to
// g_get_current_dir().
//
// This function never fails, and will canonicalize file paths even if they
// don't exist.
//
// No file system I/O is done.
func CanonicalizeFilename(filename string, relativeTo string) string {
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(relativeTo))
	defer C.free(unsafe.Pointer(arg2))

	var cret *C.gchar
	var goret1 string

	cret = C.g_canonicalize_filename(filename, relativeTo)

	goret1 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return goret1
}

// DirMakeTmp creates a subdirectory in the preferred directory for temporary
// files (as returned by g_get_tmp_dir()).
//
// @tmpl should be a string in the GLib file name encoding containing a sequence
// of six 'X' characters, as the parameter to g_mkstemp(). However, unlike these
// functions, the template should only be a basename, no directory components
// are allowed. If template is nil, a default template is used.
//
// Note that in contrast to g_mkdtemp() (and mkdtemp()) @tmpl is not modified,
// and might thus be a read-only literal string.
func DirMakeTmp(tmpl string) (filename string, err error) {
	var arg1 *C.gchar
	var errout *C.GError

	arg1 = (*C.gchar)(C.CString(tmpl))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.gchar
	var goret1 string
	var goerr error

	cret = C.g_dir_make_tmp(tmpl, &errout)

	goret1 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))
	if errout != nil {
		goerr = fmt.Errorf("%d: %s", errout.code, C.GoString(errout.message))
		C.g_error_free(errout)
	}

	return goret1, goerr
}

// FileErrorFromErrno gets a Error constant based on the passed-in @err_no. For
// example, if you pass in `EEXIST` this function returns FILE_ERROR_EXIST.
// Unlike `errno` values, you can portably assume that all Error values will
// exist.
//
// Normally a Error value goes into a #GError returned from a function that
// manipulates files. So you would use g_file_error_from_errno() when
// constructing a #GError.
func FileErrorFromErrno(errNo int) FileError {
	var arg1 C.gint

	arg1 = C.gint(errNo)

	var cret C.GFileError
	var goret1 FileError

	cret = C.g_file_error_from_errno(errNo)

	goret1 = FileError(cret)

	return goret1
}

// FileGetContents reads an entire file into allocated memory, with good error
// checking.
//
// If the call was successful, it returns true and sets @contents to the file
// contents and @length to the length of the file contents in bytes. The string
// stored in @contents will be nul-terminated, so for text files you can pass
// nil for the @length argument. If the call was not successful, it returns
// false and sets @error. The error domain is FILE_ERROR. Possible error codes
// are those in the Error enumeration. In the error case, @contents is set to
// nil and @length is set to zero.
func FileGetContents(filename string) (contents []byte, length uint, err error) {
	var arg1 *C.gchar
	var errout *C.GError

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	var goerr error

	C.g_file_get_contents(filename, &arg2, &arg3, &errout)

	if errout != nil {
		goerr = fmt.Errorf("%d: %s", errout.code, C.GoString(errout.message))
		C.g_error_free(errout)
	}

	return ret2, ret3, goerr
}

// FileOpenTmp opens a file for writing in the preferred directory for temporary
// files (as returned by g_get_tmp_dir()).
//
// @tmpl should be a string in the GLib file name encoding containing a sequence
// of six 'X' characters, as the parameter to g_mkstemp(). However, unlike these
// functions, the template should only be a basename, no directory components
// are allowed. If template is nil, a default template is used.
//
// Note that in contrast to g_mkstemp() (and mkstemp()) @tmpl is not modified,
// and might thus be a read-only literal string.
//
// Upon success, and if @name_used is non-nil, the actual name used is returned
// in @name_used. This string should be freed with g_free() when not needed any
// longer. The returned name is in the GLib file name encoding.
func FileOpenTmp(tmpl string) (nameUsed string, gint int, err error) {
	var arg1 *C.gchar
	var errout *C.GError

	arg1 = (*C.gchar)(C.CString(tmpl))
	defer C.free(unsafe.Pointer(arg1))

	var arg2 **C.gchar
	var ret2 string
	var cret C.gint
	var goret2 int
	var goerr error

	cret = C.g_file_open_tmp(tmpl, &arg2, &errout)

	ret2 = C.GoString(arg2)
	defer C.free(unsafe.Pointer(arg2))
	goret2 = C.gint(cret)
	if errout != nil {
		goerr = fmt.Errorf("%d: %s", errout.code, C.GoString(errout.message))
		C.g_error_free(errout)
	}

	return ret2, goret2, goerr
}

// FileReadLink reads the contents of the symbolic link @filename like the POSIX
// readlink() function. The returned string is in the encoding used for
// filenames. Use g_filename_to_utf8() to convert it to UTF-8.
func FileReadLink(filename string) (filename string, err error) {
	var arg1 *C.gchar
	var errout *C.GError

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.gchar
	var goret1 string
	var goerr error

	cret = C.g_file_read_link(filename, &errout)

	goret1 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))
	if errout != nil {
		goerr = fmt.Errorf("%d: %s", errout.code, C.GoString(errout.message))
		C.g_error_free(errout)
	}

	return goret1, goerr
}

// FileSetContents writes all of @contents to a file named @filename. This is a
// convenience wrapper around calling g_file_set_contents() with `flags` set to
// `G_FILE_SET_CONTENTS_CONSISTENT | G_FILE_SET_CONTENTS_ONLY_EXISTING` and
// `mode` set to `0666`.
func FileSetContents(filename string, contents []byte) error {

	var errout *C.GError

	var goerr error

	C.g_file_set_contents(filename, contents, length, &errout)

	if errout != nil {
		goerr = fmt.Errorf("%d: %s", errout.code, C.GoString(errout.message))
		C.g_error_free(errout)
	}

}

// FileTest returns true if any of the tests in the bitfield @test are true. For
// example, `(G_FILE_TEST_EXISTS | G_FILE_TEST_IS_DIR)` will return true if the
// file exists; the check whether it's a directory doesn't matter since the
// existence test is true. With the current set of available tests, there's no
// point passing in more than one test at a time.
//
// Apart from G_FILE_TEST_IS_SYMLINK all tests follow symbolic links, so for a
// symbolic link to a regular file g_file_test() will return true for both
// G_FILE_TEST_IS_SYMLINK and G_FILE_TEST_IS_REGULAR.
//
// Note, that for a dangling symbolic link g_file_test() will return true for
// G_FILE_TEST_IS_SYMLINK and false for all other flags.
//
// You should never use g_file_test() to test whether it is safe to perform an
// operation, because there is always the possibility of the condition changing
// before you actually perform the operation. For example, you might think you
// could use G_FILE_TEST_IS_SYMLINK to know whether it is safe to write to a
// file without being tricked into writing into a different location. It doesn't
// work!
//
//    // DON'T DO THIS
//    if (!g_file_test (filename, G_FILE_TEST_IS_SYMLINK))
//      {
//        fd = g_open (filename, O_WRONLY);
//        // write to fd
//      }
//
// Another thing to note is that G_FILE_TEST_EXISTS and
// G_FILE_TEST_IS_EXECUTABLE are implemented using the access() system call.
// This usually doesn't matter, but if your program is setuid or setgid it means
// that these tests will give you the answer for the real user ID and group ID,
// rather than the effective user ID and group ID.
//
// On Windows, there are no symlinks, so testing for G_FILE_TEST_IS_SYMLINK will
// always return false. Testing for G_FILE_TEST_IS_EXECUTABLE will just check
// that the file exists and its name indicates that it is executable, checking
// for well-known extensions and those listed in the `PATHEXT` environment
// variable.
func FileTest(filename string, test FileTest) bool {
	var arg1 *C.gchar
	var arg2 C.GFileTest

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GFileTest)(test)

	var cret C.gboolean
	var goret1 bool

	cret = C.g_file_test(filename, test)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// GetCurrentDir gets the current directory.
//
// The returned string should be freed when no longer needed. The encoding of
// the returned string is system defined. On Windows, it is always UTF-8.
//
// Since GLib 2.40, this function will return the value of the "PWD" environment
// variable if it is set and it happens to be the same as the current directory.
// This can make a difference in the case that the current directory is the
// target of a symbolic link.
func GetCurrentDir() string {
	var cret *C.gchar
	var goret1 string

	cret = C.g_get_current_dir()

	goret1 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return goret1
}

// MkdirWithParents: create a directory if it doesn't already exist. Create
// intermediate parent directories as needed, too.
func MkdirWithParents(pathname string, mode int) int {
	var arg1 *C.gchar
	var arg2 C.gint

	arg1 = (*C.gchar)(C.CString(pathname))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(mode)

	var cret C.gint
	var goret1 int

	cret = C.g_mkdir_with_parents(pathname, mode)

	goret1 = C.gint(cret)

	return goret1
}

// Mkdtemp creates a temporary directory. See the mkdtemp() documentation on
// most UNIX-like systems.
//
// The parameter is a string that should follow the rules for mkdtemp()
// templates, i.e. contain the string "XXXXXX". g_mkdtemp() is slightly more
// flexible than mkdtemp() in that the sequence does not have to occur at the
// very end of the template. The X string will be modified to form the name of a
// directory that didn't exist. The string should be in the GLib file name
// encoding. Most importantly, on Windows it should be in UTF-8.
//
// If you are going to be creating a temporary directory inside the directory
// returned by g_get_tmp_dir(), you might want to use g_dir_make_tmp() instead.
func Mkdtemp(tmpl string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(tmpl))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.gchar
	var goret1 string

	cret = C.g_mkdtemp(tmpl)

	goret1 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return goret1
}

// MkdtempFull creates a temporary directory. See the mkdtemp() documentation on
// most UNIX-like systems.
//
// The parameter is a string that should follow the rules for mkdtemp()
// templates, i.e. contain the string "XXXXXX". g_mkdtemp_full() is slightly
// more flexible than mkdtemp() in that the sequence does not have to occur at
// the very end of the template and you can pass a @mode. The X string will be
// modified to form the name of a directory that didn't exist. The string should
// be in the GLib file name encoding. Most importantly, on Windows it should be
// in UTF-8.
//
// If you are going to be creating a temporary directory inside the directory
// returned by g_get_tmp_dir(), you might want to use g_dir_make_tmp() instead.
func MkdtempFull(tmpl string, mode int) string {
	var arg1 *C.gchar
	var arg2 C.gint

	arg1 = (*C.gchar)(C.CString(tmpl))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(mode)

	var cret *C.gchar
	var goret1 string

	cret = C.g_mkdtemp_full(tmpl, mode)

	goret1 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return goret1
}

// Mkstemp opens a temporary file. See the mkstemp() documentation on most
// UNIX-like systems.
//
// The parameter is a string that should follow the rules for mkstemp()
// templates, i.e. contain the string "XXXXXX". g_mkstemp() is slightly more
// flexible than mkstemp() in that the sequence does not have to occur at the
// very end of the template. The X string will be modified to form the name of a
// file that didn't exist. The string should be in the GLib file name encoding.
// Most importantly, on Windows it should be in UTF-8.
func Mkstemp(tmpl string) int {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(tmpl))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.gint
	var goret1 int

	cret = C.g_mkstemp(tmpl)

	goret1 = C.gint(cret)

	return goret1
}

// MkstempFull opens a temporary file. See the mkstemp() documentation on most
// UNIX-like systems.
//
// The parameter is a string that should follow the rules for mkstemp()
// templates, i.e. contain the string "XXXXXX". g_mkstemp_full() is slightly
// more flexible than mkstemp() in that the sequence does not have to occur at
// the very end of the template and you can pass a @mode and additional @flags.
// The X string will be modified to form the name of a file that didn't exist.
// The string should be in the GLib file name encoding. Most importantly, on
// Windows it should be in UTF-8.
func MkstempFull(tmpl string, flags int, mode int) int {
	var arg1 *C.gchar
	var arg2 C.gint
	var arg3 C.gint

	arg1 = (*C.gchar)(C.CString(tmpl))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(flags)
	arg3 = C.gint(mode)

	var cret C.gint
	var goret1 int

	cret = C.g_mkstemp_full(tmpl, flags, mode)

	goret1 = C.gint(cret)

	return goret1
}

// PathGetBasename gets the last component of the filename.
//
// If @file_name ends with a directory separator it gets the component before
// the last slash. If @file_name consists only of directory separators (and on
// Windows, possibly a drive letter), a single separator is returned. If
// @file_name is empty, it gets ".".
func PathGetBasename(fileName string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.gchar
	var goret1 string

	cret = C.g_path_get_basename(fileName)

	goret1 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return goret1
}

// PathGetDirname gets the directory components of a file name. For example, the
// directory component of `/usr/bin/test` is `/usr/bin`. The directory component
// of `/` is `/`.
//
// If the file name has no directory components "." is returned. The returned
// string should be freed when no longer needed.
func PathGetDirname(fileName string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.gchar
	var goret1 string

	cret = C.g_path_get_dirname(fileName)

	goret1 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return goret1
}

// PathIsAbsolute returns true if the given @file_name is an absolute file name.
// Note that this is a somewhat vague concept on Windows.
//
// On POSIX systems, an absolute file name is well-defined. It always starts
// from the single root directory. For example "/usr/local".
//
// On Windows, the concepts of current drive and drive-specific current
// directory introduce vagueness. This function interprets as an absolute file
// name one that either begins with a directory separator such as "\Users\tml"
// or begins with the root on a drive, for example "C:\Windows". The first case
// also includes UNC paths such as "\\\\myserver\docs\foo". In all cases, either
// slashes or backslashes are accepted.
//
// Note that a file name relative to the current drive root does not truly
// specify a file uniquely over time and across processes, as the current drive
// is a per-process value and can be changed.
//
// File names relative the current directory on some specific drive, such as
// "D:foo/bar", are not interpreted as absolute by this function, but they
// obviously are not relative to the normal current directory as returned by
// getcwd() or g_get_current_dir() either. Such paths should be avoided, or need
// to be handled using Windows-specific code.
func PathIsAbsolute(fileName string) bool {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.gboolean
	var goret1 bool

	cret = C.g_path_is_absolute(fileName)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// PathSkipRoot returns a pointer into @file_name after the root component, i.e.
// after the "/" in UNIX or "C:\" under Windows. If @file_name is not an
// absolute path it returns nil.
func PathSkipRoot(fileName string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.gchar
	var goret1 string

	cret = C.g_path_skip_root(fileName)

	goret1 = C.GoString(cret)

	return goret1
}
