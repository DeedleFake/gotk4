// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"runtime"
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <glib.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_uri_get_type()), F: marshalURI},
	})
}

// URIError: error codes returned by #GUri methods.
type URIError int

const (
	// URIErrorFailed: generic error if no more specific error is available. See
	// the error message for details.
	URIErrorFailed URIError = 0
	// URIErrorBadScheme: the scheme of a URI could not be parsed.
	URIErrorBadScheme URIError = 1
	// URIErrorBadUser: the user/userinfo of a URI could not be parsed.
	URIErrorBadUser URIError = 2
	// URIErrorBadPassword: the password of a URI could not be parsed.
	URIErrorBadPassword URIError = 3
	// URIErrorBadAuthParams: the authentication parameters of a URI could not
	// be parsed.
	URIErrorBadAuthParams URIError = 4
	// URIErrorBadHost: the host of a URI could not be parsed.
	URIErrorBadHost URIError = 5
	// URIErrorBadPort: the port of a URI could not be parsed.
	URIErrorBadPort URIError = 6
	// URIErrorBadPath: the path of a URI could not be parsed.
	URIErrorBadPath URIError = 7
	// URIErrorBadQuery: the query of a URI could not be parsed.
	URIErrorBadQuery URIError = 8
	// URIErrorBadFragment: the fragment of a URI could not be parsed.
	URIErrorBadFragment URIError = 9
)

// URIFlags flags that describe a URI.
//
// When parsing a URI, if you need to choose different flags based on the type
// of URI, you can use g_uri_peek_scheme() on the URI string to check the scheme
// first, and use that to decide what flags to parse it with.
type URIFlags int

const (
	// URIFlagsNone: no flags set.
	URIFlagsNone URIFlags = 0b0
	// URIFlagsParseRelaxed: parse the URI more relaxedly than the RFC 3986
	// (https://tools.ietf.org/html/rfc3986) grammar specifies, fixing up or
	// ignoring common mistakes in URIs coming from external sources. This is
	// also needed for some obscure URI schemes where `;` separates the host
	// from the path. Don’t use this flag unless you need to.
	URIFlagsParseRelaxed URIFlags = 0b1
	// URIFlagsHasPassword: the userinfo field may contain a password, which
	// will be separated from the username by `:`.
	URIFlagsHasPassword URIFlags = 0b10
	// URIFlagsHasAuthParams: the userinfo may contain additional
	// authentication-related parameters, which will be separated from the
	// username and/or password by `;`.
	URIFlagsHasAuthParams URIFlags = 0b100
	// URIFlagsEncoded: when parsing a URI, this indicates that `%`-encoded
	// characters in the userinfo, path, query, and fragment fields should not
	// be decoded. (And likewise the host field if G_URI_FLAGS_NON_DNS is also
	// set.) When building a URI, it indicates that you have already `%`-encoded
	// the components, and so #GUri should not do any encoding itself.
	URIFlagsEncoded URIFlags = 0b1000
	// URIFlagsNonDns: the host component should not be assumed to be a DNS
	// hostname or IP address (for example, for `smb` URIs with NetBIOS
	// hostnames).
	URIFlagsNonDns URIFlags = 0b10000
	// URIFlagsEncodedQuery: same as G_URI_FLAGS_ENCODED, for the query field
	// only.
	URIFlagsEncodedQuery URIFlags = 0b100000
	// URIFlagsEncodedPath: same as G_URI_FLAGS_ENCODED, for the path only.
	URIFlagsEncodedPath URIFlags = 0b1000000
	// URIFlagsEncodedFragment: same as G_URI_FLAGS_ENCODED, for the fragment
	// only.
	URIFlagsEncodedFragment URIFlags = 0b10000000
)

// URIHideFlags flags describing what parts of the URI to hide in
// g_uri_to_string_partial(). Note that G_URI_HIDE_PASSWORD and
// G_URI_HIDE_AUTH_PARAMS will only work if the #GUri was parsed with the
// corresponding flags.
type URIHideFlags int

const (
	// URIHideFlagsNone: no flags set.
	URIHideFlagsNone URIHideFlags = 0b0
	// URIHideFlagsUserinfo: hide the userinfo.
	URIHideFlagsUserinfo URIHideFlags = 0b1
	// URIHideFlagsPassword: hide the password.
	URIHideFlagsPassword URIHideFlags = 0b10
	// URIHideFlagsAuthParams: hide the auth_params.
	URIHideFlagsAuthParams URIHideFlags = 0b100
	// URIHideFlagsQuery: hide the query.
	URIHideFlagsQuery URIHideFlags = 0b1000
	// URIHideFlagsFragment: hide the fragment.
	URIHideFlagsFragment URIHideFlags = 0b10000
)

// URIParamsFlags flags modifying the way parameters are handled by
// g_uri_parse_params() and ParamsIter.
type URIParamsFlags int

const (
	// URIParamsFlagsNone: no flags set.
	URIParamsFlagsNone URIParamsFlags = 0b0
	// URIParamsFlagsCaseInsensitive: parameter names are case insensitive.
	URIParamsFlagsCaseInsensitive URIParamsFlags = 0b1
	// URIParamsFlagsWwwForm: replace `+` with space character. Only useful for
	// URLs on the web, using the `https` or `http` schemas.
	URIParamsFlagsWwwForm URIParamsFlags = 0b10
	// URIParamsFlagsParseRelaxed: see G_URI_FLAGS_PARSE_RELAXED.
	URIParamsFlagsParseRelaxed URIParamsFlags = 0b100
)

// URIBuild creates a new #GUri from the given components according to @flags.
//
// See also g_uri_build_with_user(), which allows specifying the components of
// the "userinfo" separately.
func URIBuild(flags URIFlags, scheme string, userinfo string, host string, port int, path string, query string, fragment string) *URI {
	var arg1 C.GUriFlags
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 *C.gchar
	var arg5 C.gint
	var arg6 *C.gchar
	var arg7 *C.gchar
	var arg8 *C.gchar

	arg1 = (C.GUriFlags)(flags)
	arg2 = (*C.gchar)(C.CString(scheme))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(userinfo))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gchar)(C.CString(host))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = C.gint(port)
	arg6 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg6))
	arg7 = (*C.gchar)(C.CString(query))
	defer C.free(unsafe.Pointer(arg7))
	arg8 = (*C.gchar)(C.CString(fragment))
	defer C.free(unsafe.Pointer(arg8))

	var cret *C.GUri
	var ret1 *URI

	cret = C.g_uri_build(flags, scheme, userinfo, host, port, path, query, fragment)

	ret1 = WrapURI(unsafe.Pointer(cret))
	runtime.SetFinalizer(ret1, func(v *URI) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return ret1
}

// URIBuildWithUser creates a new #GUri from the given components according to
// @flags (G_URI_FLAGS_HAS_PASSWORD is added unconditionally). The @flags must
// be coherent with the passed values, in particular use `%`-encoded values with
// G_URI_FLAGS_ENCODED.
//
// In contrast to g_uri_build(), this allows specifying the components of the
// ‘userinfo’ field separately. Note that @user must be non-nil if either
// @password or @auth_params is non-nil.
func URIBuildWithUser(flags URIFlags, scheme string, user string, password string, authParams string, host string, port int, path string, query string, fragment string) *URI {
	var arg1 C.GUriFlags
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 *C.gchar
	var arg5 *C.gchar
	var arg6 *C.gchar
	var arg7 C.gint
	var arg8 *C.gchar
	var arg9 *C.gchar
	var arg10 *C.gchar

	arg1 = (C.GUriFlags)(flags)
	arg2 = (*C.gchar)(C.CString(scheme))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(user))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gchar)(C.CString(password))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.gchar)(C.CString(authParams))
	defer C.free(unsafe.Pointer(arg5))
	arg6 = (*C.gchar)(C.CString(host))
	defer C.free(unsafe.Pointer(arg6))
	arg7 = C.gint(port)
	arg8 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg8))
	arg9 = (*C.gchar)(C.CString(query))
	defer C.free(unsafe.Pointer(arg9))
	arg10 = (*C.gchar)(C.CString(fragment))
	defer C.free(unsafe.Pointer(arg10))

	var cret *C.GUri
	var ret1 *URI

	cret = C.g_uri_build_with_user(flags, scheme, user, password, authParams, host, port, path, query, fragment)

	ret1 = WrapURI(unsafe.Pointer(cret))
	runtime.SetFinalizer(ret1, func(v *URI) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return ret1
}

// URIEscapeString escapes a string for use in a URI.
//
// Normally all characters that are not "unreserved" (i.e. ASCII alphanumerical
// characters plus dash, dot, underscore and tilde) are escaped. But if you
// specify characters in @reserved_chars_allowed they are not escaped. This is
// useful for the "reserved" characters in the URI specification, since those
// are allowed unescaped in some portions of a URI.
func URIEscapeString(unescaped string, reservedCharsAllowed string, allowUTF8 bool) string {
	var arg1 *C.char
	var arg2 *C.char
	var arg3 C.gboolean

	arg1 = (*C.char)(C.CString(unescaped))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.char)(C.CString(reservedCharsAllowed))
	defer C.free(unsafe.Pointer(arg2))
	if allowUTF8 {
		arg3 = C.gboolean(1)
	}

	var cret *C.char
	var ret1 string

	cret = C.g_uri_escape_string(unescaped, reservedCharsAllowed, allowUTF8)

	ret1 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return ret1
}

// URIIsValid parses @uri_string according to @flags, to determine whether it is
// a valid [absolute URI][relative-absolute-uris], i.e. it does not need to be
// resolved relative to another URI using g_uri_parse_relative().
//
// If it’s not a valid URI, an error is returned explaining how it’s invalid.
//
// See g_uri_split(), and the definition of Flags, for more information on the
// effect of @flags.
func URIIsValid(uriString string, flags URIFlags) error {
	var arg1 *C.gchar
	var arg2 C.GUriFlags
	var errout *C.GError

	arg1 = (*C.gchar)(C.CString(uriString))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GUriFlags)(flags)

	var goerr error

	C.g_uri_is_valid(uriString, flags, &errout)

	if errout != nil {
		goerr = fmt.Errorf("%d: %s", errout.code, C.GoString(errout.message))
		C.g_error_free(errout)
	}

}

// URIJoin joins the given components together according to @flags to create an
// absolute URI string. @path may not be nil (though it may be the empty
// string).
//
// When @host is present, @path must either be empty or begin with a slash (`/`)
// character. When @host is not present, @path cannot begin with two slash
// characters (`//`). See RFC 3986, section 3
// (https://tools.ietf.org/html/rfc3986#section-3).
//
// See also g_uri_join_with_user(), which allows specifying the components of
// the ‘userinfo’ separately.
//
// G_URI_FLAGS_HAS_PASSWORD and G_URI_FLAGS_HAS_AUTH_PARAMS are ignored if set
// in @flags.
func URIJoin(flags URIFlags, scheme string, userinfo string, host string, port int, path string, query string, fragment string) string {
	var arg1 C.GUriFlags
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 *C.gchar
	var arg5 C.gint
	var arg6 *C.gchar
	var arg7 *C.gchar
	var arg8 *C.gchar

	arg1 = (C.GUriFlags)(flags)
	arg2 = (*C.gchar)(C.CString(scheme))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(userinfo))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gchar)(C.CString(host))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = C.gint(port)
	arg6 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg6))
	arg7 = (*C.gchar)(C.CString(query))
	defer C.free(unsafe.Pointer(arg7))
	arg8 = (*C.gchar)(C.CString(fragment))
	defer C.free(unsafe.Pointer(arg8))

	var cret *C.gchar
	var ret1 string

	cret = C.g_uri_join(flags, scheme, userinfo, host, port, path, query, fragment)

	ret1 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return ret1
}

// URIJoinWithUser joins the given components together according to @flags to
// create an absolute URI string. @path may not be nil (though it may be the
// empty string).
//
// In contrast to g_uri_join(), this allows specifying the components of the
// ‘userinfo’ separately. It otherwise behaves the same.
//
// G_URI_FLAGS_HAS_PASSWORD and G_URI_FLAGS_HAS_AUTH_PARAMS are ignored if set
// in @flags.
func URIJoinWithUser(flags URIFlags, scheme string, user string, password string, authParams string, host string, port int, path string, query string, fragment string) string {
	var arg1 C.GUriFlags
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 *C.gchar
	var arg5 *C.gchar
	var arg6 *C.gchar
	var arg7 C.gint
	var arg8 *C.gchar
	var arg9 *C.gchar
	var arg10 *C.gchar

	arg1 = (C.GUriFlags)(flags)
	arg2 = (*C.gchar)(C.CString(scheme))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(user))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gchar)(C.CString(password))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.gchar)(C.CString(authParams))
	defer C.free(unsafe.Pointer(arg5))
	arg6 = (*C.gchar)(C.CString(host))
	defer C.free(unsafe.Pointer(arg6))
	arg7 = C.gint(port)
	arg8 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg8))
	arg9 = (*C.gchar)(C.CString(query))
	defer C.free(unsafe.Pointer(arg9))
	arg10 = (*C.gchar)(C.CString(fragment))
	defer C.free(unsafe.Pointer(arg10))

	var cret *C.gchar
	var ret1 string

	cret = C.g_uri_join_with_user(flags, scheme, user, password, authParams, host, port, path, query, fragment)

	ret1 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return ret1
}

// URIParse parses @uri_string according to @flags. If the result is not a valid
// [absolute URI][relative-absolute-uris], it will be discarded, and an error
// returned.
func URIParse(uriString string, flags URIFlags) (uri *URI, err error) {
	var arg1 *C.gchar
	var arg2 C.GUriFlags
	var errout *C.GError

	arg1 = (*C.gchar)(C.CString(uriString))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GUriFlags)(flags)

	var cret *C.GUri
	var ret1 *URI
	var goerr error

	cret = C.g_uri_parse(uriString, flags, &errout)

	ret1 = WrapURI(unsafe.Pointer(cret))
	runtime.SetFinalizer(ret1, func(v *URI) {
		C.free(unsafe.Pointer(v.Native()))
	})
	if errout != nil {
		goerr = fmt.Errorf("%d: %s", errout.code, C.GoString(errout.message))
		C.g_error_free(errout)
	}

	return ret1, goerr
}

// URIParseParams: many URI schemes include one or more attribute/value pairs as
// part of the URI value. This method can be used to parse them into a hash
// table. When an attribute has multiple occurrences, the last value is the
// final returned value. If you need to handle repeated attributes differently,
// use ParamsIter.
//
// The @params string is assumed to still be `%`-encoded, but the returned
// values will be fully decoded. (Thus it is possible that the returned values
// may contain `=` or @separators, if the value was encoded in the input.)
// Invalid `%`-encoding is treated as with the G_URI_FLAGS_PARSE_RELAXED rules
// for g_uri_parse(). (However, if @params is the path or query string from a
// #GUri that was parsed without G_URI_FLAGS_PARSE_RELAXED and
// G_URI_FLAGS_ENCODED, then you already know that it does not contain any
// invalid encoding.)
//
// G_URI_PARAMS_WWW_FORM is handled as documented for g_uri_params_iter_init().
//
// If G_URI_PARAMS_CASE_INSENSITIVE is passed to @flags, attributes will be
// compared case-insensitively, so a params string `attr=123&Attr=456` will only
// return a single attribute–value pair, `Attr=456`. Case will be preserved in
// the returned attributes.
//
// If @params cannot be parsed (for example, it contains two @separators
// characters in a row), then @error is set and nil is returned.
func URIParseParams(params string, length int, separators string, flags URIParamsFlags) (hashTable *HashTable, err error) {
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 *C.gchar
	var arg4 C.GUriParamsFlags
	var errout *C.GError

	arg1 = (*C.gchar)(C.CString(params))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(length)
	arg3 = (*C.gchar)(C.CString(separators))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (C.GUriParamsFlags)(flags)

	var cret *C.GHashTable
	var ret1 *HashTable
	var goerr error

	cret = C.g_uri_parse_params(params, length, separators, flags, &errout)

	ret1 = WrapHashTable(unsafe.Pointer(cret))
	runtime.SetFinalizer(ret1, func(v *HashTable) {
		C.free(unsafe.Pointer(v.Native()))
	})
	if errout != nil {
		goerr = fmt.Errorf("%d: %s", errout.code, C.GoString(errout.message))
		C.g_error_free(errout)
	}

	return ret1, goerr
}

// URIParseScheme gets the scheme portion of a URI string. RFC 3986
// (https://tools.ietf.org/html/rfc3986#section-3) decodes the scheme as:
//
//    URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
//
// Common schemes include `file`, `https`, `svn+ssh`, etc.
func URIParseScheme(uri string) string {
	var arg1 *C.char

	arg1 = (*C.char)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.char
	var ret1 string

	cret = C.g_uri_parse_scheme(uri)

	ret1 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return ret1
}

// URIPeekScheme gets the scheme portion of a URI string. RFC 3986
// (https://tools.ietf.org/html/rfc3986#section-3) decodes the scheme as:
//
//    URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
//
// Common schemes include `file`, `https`, `svn+ssh`, etc.
//
// Unlike g_uri_parse_scheme(), the returned scheme is normalized to
// all-lowercase and does not need to be freed.
func URIPeekScheme(uri string) string {
	var arg1 *C.char

	arg1 = (*C.char)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.char
	var ret1 string

	cret = C.g_uri_peek_scheme(uri)

	ret1 = C.GoString(cret)

	return ret1
}

// URIResolveRelative parses @uri_ref according to @flags and, if it is a
// [relative URI][relative-absolute-uris], resolves it relative to
// @base_uri_string. If the result is not a valid absolute URI, it will be
// discarded, and an error returned.
//
// (If @base_uri_string is nil, this just returns @uri_ref, or nil if @uri_ref
// is invalid or not absolute.)
func URIResolveRelative(baseURIString string, uriRef string, flags URIFlags) (utf8 string, err error) {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 C.GUriFlags
	var errout *C.GError

	arg1 = (*C.gchar)(C.CString(baseURIString))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(uriRef))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (C.GUriFlags)(flags)

	var cret *C.gchar
	var ret1 string
	var goerr error

	cret = C.g_uri_resolve_relative(baseURIString, uriRef, flags, &errout)

	ret1 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))
	if errout != nil {
		goerr = fmt.Errorf("%d: %s", errout.code, C.GoString(errout.message))
		C.g_error_free(errout)
	}

	return ret1, goerr
}

// URISplit parses @uri_ref (which can be an [absolute or relative
// URI][relative-absolute-uris]) according to @flags, and returns the pieces.
// Any component that doesn't appear in @uri_ref will be returned as nil (but
// note that all URIs always have a path component, though it may be the empty
// string).
//
// If @flags contains G_URI_FLAGS_ENCODED, then `%`-encoded characters in
// @uri_ref will remain encoded in the output strings. (If not, then all such
// characters will be decoded.) Note that decoding will only work if the URI
// components are ASCII or UTF-8, so you will need to use G_URI_FLAGS_ENCODED if
// they are not.
//
// Note that the G_URI_FLAGS_HAS_PASSWORD and G_URI_FLAGS_HAS_AUTH_PARAMS @flags
// are ignored by g_uri_split(), since it always returns only the full userinfo;
// use g_uri_split_with_user() if you want it split up.
func URISplit(uriRef string, flags URIFlags) (scheme string, userinfo string, host string, port int, path string, query string, fragment string, err error) {
	var arg1 *C.gchar
	var arg2 C.GUriFlags
	var errout *C.GError

	arg1 = (*C.gchar)(C.CString(uriRef))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GUriFlags)(flags)

	var arg3 *C.gchar
	var ret3 string
	var arg4 *C.gchar
	var ret4 string
	var arg5 *C.gchar
	var ret5 string
	var arg6 C.gint
	var ret6 int
	var arg7 *C.gchar
	var ret7 string
	var arg8 *C.gchar
	var ret8 string
	var arg9 *C.gchar
	var ret9 string
	var goerr error

	C.g_uri_split(uriRef, flags, &arg3, &arg4, &arg5, &arg6, &arg7, &arg8, &arg9, &errout)

	ret3 = C.GoString(arg3)
	defer C.free(unsafe.Pointer(arg3))
	ret4 = C.GoString(arg4)
	defer C.free(unsafe.Pointer(arg4))
	ret5 = C.GoString(arg5)
	defer C.free(unsafe.Pointer(arg5))
	ret6 = C.gint(arg6)
	ret7 = C.GoString(arg7)
	defer C.free(unsafe.Pointer(arg7))
	ret8 = C.GoString(arg8)
	defer C.free(unsafe.Pointer(arg8))
	ret9 = C.GoString(arg9)
	defer C.free(unsafe.Pointer(arg9))
	if errout != nil {
		goerr = fmt.Errorf("%d: %s", errout.code, C.GoString(errout.message))
		C.g_error_free(errout)
	}

	return ret3, ret4, ret5, ret6, ret7, ret8, ret9, goerr
}

// URISplitNetwork parses @uri_string (which must be an [absolute
// URI][relative-absolute-uris]) according to @flags, and returns the pieces
// relevant to connecting to a host. See the documentation for g_uri_split() for
// more details; this is mostly a wrapper around that function with simpler
// arguments. However, it will return an error if @uri_string is a relative URI,
// or does not contain a hostname component.
func URISplitNetwork(uriString string, flags URIFlags) (scheme string, host string, port int, err error) {
	var arg1 *C.gchar
	var arg2 C.GUriFlags
	var errout *C.GError

	arg1 = (*C.gchar)(C.CString(uriString))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GUriFlags)(flags)

	var arg3 *C.gchar
	var ret3 string
	var arg4 *C.gchar
	var ret4 string
	var arg5 C.gint
	var ret5 int
	var goerr error

	C.g_uri_split_network(uriString, flags, &arg3, &arg4, &arg5, &errout)

	ret3 = C.GoString(arg3)
	defer C.free(unsafe.Pointer(arg3))
	ret4 = C.GoString(arg4)
	defer C.free(unsafe.Pointer(arg4))
	ret5 = C.gint(arg5)
	if errout != nil {
		goerr = fmt.Errorf("%d: %s", errout.code, C.GoString(errout.message))
		C.g_error_free(errout)
	}

	return ret3, ret4, ret5, goerr
}

// URISplitWithUser parses @uri_ref (which can be an [absolute or relative
// URI][relative-absolute-uris]) according to @flags, and returns the pieces.
// Any component that doesn't appear in @uri_ref will be returned as nil (but
// note that all URIs always have a path component, though it may be the empty
// string).
//
// See g_uri_split(), and the definition of Flags, for more information on the
// effect of @flags. Note that @password will only be parsed out if @flags
// contains G_URI_FLAGS_HAS_PASSWORD, and @auth_params will only be parsed out
// if @flags contains G_URI_FLAGS_HAS_AUTH_PARAMS.
func URISplitWithUser(uriRef string, flags URIFlags) (scheme string, user string, password string, authParams string, host string, port int, path string, query string, fragment string, err error) {
	var arg1 *C.gchar
	var arg2 C.GUriFlags
	var errout *C.GError

	arg1 = (*C.gchar)(C.CString(uriRef))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GUriFlags)(flags)

	var arg3 *C.gchar
	var ret3 string
	var arg4 *C.gchar
	var ret4 string
	var arg5 *C.gchar
	var ret5 string
	var arg6 *C.gchar
	var ret6 string
	var arg7 *C.gchar
	var ret7 string
	var arg8 C.gint
	var ret8 int
	var arg9 *C.gchar
	var ret9 string
	var arg10 *C.gchar
	var ret10 string
	var arg11 *C.gchar
	var ret11 string
	var goerr error

	C.g_uri_split_with_user(uriRef, flags, &arg3, &arg4, &arg5, &arg6, &arg7, &arg8, &arg9, &arg10, &arg11, &errout)

	ret3 = C.GoString(arg3)
	defer C.free(unsafe.Pointer(arg3))
	ret4 = C.GoString(arg4)
	defer C.free(unsafe.Pointer(arg4))
	ret5 = C.GoString(arg5)
	defer C.free(unsafe.Pointer(arg5))
	ret6 = C.GoString(arg6)
	defer C.free(unsafe.Pointer(arg6))
	ret7 = C.GoString(arg7)
	defer C.free(unsafe.Pointer(arg7))
	ret8 = C.gint(arg8)
	ret9 = C.GoString(arg9)
	defer C.free(unsafe.Pointer(arg9))
	ret10 = C.GoString(arg10)
	defer C.free(unsafe.Pointer(arg10))
	ret11 = C.GoString(arg11)
	defer C.free(unsafe.Pointer(arg11))
	if errout != nil {
		goerr = fmt.Errorf("%d: %s", errout.code, C.GoString(errout.message))
		C.g_error_free(errout)
	}

	return ret3, ret4, ret5, ret6, ret7, ret8, ret9, ret10, ret11, goerr
}

// URIUnescapeBytes unescapes a segment of an escaped string as binary data.
//
// Note that in contrast to g_uri_unescape_string(), this does allow nul bytes
// to appear in the output.
//
// If any of the characters in @illegal_characters appears as an escaped
// character in @escaped_string, then that is an error and nil will be returned.
// This is useful if you want to avoid for instance having a slash being
// expanded in an escaped path element, which might confuse pathname handling.
func URIUnescapeBytes(escapedString string, length int, illegalCharacters string) (bytes *Bytes, err error) {
	var arg1 *C.char
	var arg2 C.gssize
	var arg3 *C.char
	var errout *C.GError

	arg1 = (*C.char)(C.CString(escapedString))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(length)
	arg3 = (*C.char)(C.CString(illegalCharacters))
	defer C.free(unsafe.Pointer(arg3))

	var cret *C.GBytes
	var ret1 *Bytes
	var goerr error

	cret = C.g_uri_unescape_bytes(escapedString, length, illegalCharacters, &errout)

	ret1 = WrapBytes(unsafe.Pointer(cret))
	runtime.SetFinalizer(ret1, func(v *Bytes) {
		C.free(unsafe.Pointer(v.Native()))
	})
	if errout != nil {
		goerr = fmt.Errorf("%d: %s", errout.code, C.GoString(errout.message))
		C.g_error_free(errout)
	}

	return ret1, goerr
}

// URIUnescapeSegment unescapes a segment of an escaped string.
//
// If any of the characters in @illegal_characters or the NUL character appears
// as an escaped character in @escaped_string, then that is an error and nil
// will be returned. This is useful if you want to avoid for instance having a
// slash being expanded in an escaped path element, which might confuse pathname
// handling.
//
// Note: `NUL` byte is not accepted in the output, in contrast to
// g_uri_unescape_bytes().
func URIUnescapeSegment(escapedString string, escapedStringEnd string, illegalCharacters string) string {
	var arg1 *C.char
	var arg2 *C.char
	var arg3 *C.char

	arg1 = (*C.char)(C.CString(escapedString))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.char)(C.CString(escapedStringEnd))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.char)(C.CString(illegalCharacters))
	defer C.free(unsafe.Pointer(arg3))

	var cret *C.char
	var ret1 string

	cret = C.g_uri_unescape_segment(escapedString, escapedStringEnd, illegalCharacters)

	ret1 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return ret1
}

// URIUnescapeString unescapes a whole escaped string.
//
// If any of the characters in @illegal_characters or the NUL character appears
// as an escaped character in @escaped_string, then that is an error and nil
// will be returned. This is useful if you want to avoid for instance having a
// slash being expanded in an escaped path element, which might confuse pathname
// handling.
func URIUnescapeString(escapedString string, illegalCharacters string) string {
	var arg1 *C.char
	var arg2 *C.char

	arg1 = (*C.char)(C.CString(escapedString))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.char)(C.CString(illegalCharacters))
	defer C.free(unsafe.Pointer(arg2))

	var cret *C.char
	var ret1 string

	cret = C.g_uri_unescape_string(escapedString, illegalCharacters)

	ret1 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return ret1
}

// URI: the #GUri type and related functions can be used to parse URIs into
// their components, and build valid URIs from individual components.
//
// Note that #GUri scope is to help manipulate URIs in various applications,
// following RFC 3986 (https://tools.ietf.org/html/rfc3986). In particular, it
// doesn't intend to cover web browser needs, and doesn't implement the WHATWG
// URL (https://url.spec.whatwg.org/) standard. No APIs are provided to help
// prevent homograph attacks
// (https://en.wikipedia.org/wiki/IDN_homograph_attack), so #GUri is not
// suitable for formatting URIs for display to the user for making
// security-sensitive decisions.
//
//
// Relative and absolute URIs
//
// As defined in RFC 3986 (https://tools.ietf.org/html/rfc3986#section-4), the
// hierarchical nature of URIs means that they can either be ‘relative
// references’ (sometimes referred to as ‘relative URIs’) or ‘URIs’ (for
// clarity, ‘URIs’ are referred to in this documentation as ‘absolute URIs’ —
// although in constrast to RFC 3986
// (https://tools.ietf.org/html/rfc3986#section-4.3), fragment identifiers are
// always allowed).
//
// Relative references have one or more components of the URI missing. In
// particular, they have no scheme. Any other component, such as hostname,
// query, etc. may be missing, apart from a path, which has to be specified (but
// may be empty). The path may be relative, starting with `./` rather than `/`.
//
// For example, a valid relative reference is `./path?query`, `/?query#fragment`
// or `//example.com`.
//
// Absolute URIs have a scheme specified. Any other components of the URI which
// are missing are specified as explicitly unset in the URI, rather than being
// resolved relative to a base URI using g_uri_parse_relative().
//
// For example, a valid absolute URI is `file:///home/bob` or
// `https://search.com?query=string`.
//
// A #GUri instance is always an absolute URI. A string may be an absolute URI
// or a relative reference; see the documentation for individual functions as to
// what forms they accept.
//
//
// Parsing URIs
//
// The most minimalist APIs for parsing URIs are g_uri_split() and
// g_uri_split_with_user(). These split a URI into its component parts, and
// return the parts; the difference between the two is that g_uri_split() treats
// the ‘userinfo’ component of the URI as a single element, while
// g_uri_split_with_user() can (depending on the Flags you pass) treat it as
// containing a username, password, and authentication parameters.
// Alternatively, g_uri_split_network() can be used when you are only interested
// in the components that are needed to initiate a network connection to the
// service (scheme, host, and port).
//
// g_uri_parse() is similar to g_uri_split(), but instead of returning
// individual strings, it returns a #GUri structure (and it requires that the
// URI be an absolute URI).
//
// g_uri_resolve_relative() and g_uri_parse_relative() allow you to resolve a
// relative URI relative to a base URI. g_uri_resolve_relative() takes two
// strings and returns a string, and g_uri_parse_relative() takes a #GUri and a
// string and returns a #GUri.
//
// All of the parsing functions take a Flags argument describing exactly how to
// parse the URI; see the documentation for that type for more details on the
// specific flags that you can pass. If you need to choose different flags based
// on the type of URI, you can use g_uri_peek_scheme() on the URI string to
// check the scheme first, and use that to decide what flags to parse it with.
//
// For example, you might want to use G_URI_PARAMS_WWW_FORM when parsing the
// params for a web URI, so compare the result of g_uri_peek_scheme() against
// `http` and `https`.
//
//
// Building URIs
//
// g_uri_join() and g_uri_join_with_user() can be used to construct valid URI
// strings from a set of component strings. They are the inverse of
// g_uri_split() and g_uri_split_with_user().
//
// Similarly, g_uri_build() and g_uri_build_with_user() can be used to construct
// a #GUri from a set of component strings.
//
// As with the parsing functions, the building functions take a Flags argument.
// In particular, it is important to keep in mind whether the URI components you
// are using are already `%`-encoded. If so, you must pass the
// G_URI_FLAGS_ENCODED flag.
//
// `file://` URIs
//
// Note that Windows and Unix both define special rules for parsing `file://`
// URIs (involving non-UTF-8 character sets on Unix, and the interpretation of
// path separators on Windows). #GUri does not implement these rules. Use
// g_filename_from_uri() and g_filename_to_uri() if you want to properly convert
// between `file://` URIs and local filenames.
//
//
// URI Equality
//
// Note that there is no `g_uri_equal ()` function, because comparing URIs
// usefully requires scheme-specific knowledge that #GUri does not have. For
// example, `http://example.com/` and `http://EXAMPLE.COM:80` have exactly the
// same meaning according to the HTTP specification, and `data:,foo` and
// `data:;base64,Zm9v` resolve to the same thing according to the `data:` URI
// specification.
type URI struct {
	native C.GUri
}

// WrapURI wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapURI(ptr unsafe.Pointer) *URI {
	if ptr == nil {
		return nil
	}

	return (*URI)(ptr)
}

func marshalURI(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapURI(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (u *URI) Native() unsafe.Pointer {
	return unsafe.Pointer(&u.native)
}

// AuthParams gets @uri's authentication parameters, which may contain
// `%`-encoding, depending on the flags with which @uri was created. (If @uri
// was not created with G_URI_FLAGS_HAS_AUTH_PARAMS then this will be nil.)
//
// Depending on the URI scheme, g_uri_parse_params() may be useful for further
// parsing this information.
func (u *URI) AuthParams() string {
	var arg0 *C.GUri

	arg0 = (*C.GUri)(unsafe.Pointer(u.Native()))

	var cret *C.gchar
	var ret1 string

	cret = C.g_uri_get_auth_params(arg0)

	ret1 = C.GoString(cret)

	return ret1
}

// Flags gets @uri's flags set upon construction.
func (u *URI) Flags() URIFlags {
	var arg0 *C.GUri

	arg0 = (*C.GUri)(unsafe.Pointer(u.Native()))

	var cret C.GUriFlags
	var ret1 URIFlags

	cret = C.g_uri_get_flags(arg0)

	ret1 = URIFlags(cret)

	return ret1
}

// Fragment gets @uri's fragment, which may contain `%`-encoding, depending on
// the flags with which @uri was created.
func (u *URI) Fragment() string {
	var arg0 *C.GUri

	arg0 = (*C.GUri)(unsafe.Pointer(u.Native()))

	var cret *C.gchar
	var ret1 string

	cret = C.g_uri_get_fragment(arg0)

	ret1 = C.GoString(cret)

	return ret1
}

// Host gets @uri's host. This will never have `%`-encoded characters, unless it
// is non-UTF-8 (which can only be the case if @uri was created with
// G_URI_FLAGS_NON_DNS).
//
// If @uri contained an IPv6 address literal, this value will be just that
// address, without the brackets around it that are necessary in the string form
// of the URI. Note that in this case there may also be a scope ID attached to
// the address. Eg, `fe80::1234%“em1` (or `fe80::1234%“25em1` if the string is
// still encoded).
func (u *URI) Host() string {
	var arg0 *C.GUri

	arg0 = (*C.GUri)(unsafe.Pointer(u.Native()))

	var cret *C.gchar
	var ret1 string

	cret = C.g_uri_get_host(arg0)

	ret1 = C.GoString(cret)

	return ret1
}

// Password gets @uri's password, which may contain `%`-encoding, depending on
// the flags with which @uri was created. (If @uri was not created with
// G_URI_FLAGS_HAS_PASSWORD then this will be nil.)
func (u *URI) Password() string {
	var arg0 *C.GUri

	arg0 = (*C.GUri)(unsafe.Pointer(u.Native()))

	var cret *C.gchar
	var ret1 string

	cret = C.g_uri_get_password(arg0)

	ret1 = C.GoString(cret)

	return ret1
}

// Path gets @uri's path, which may contain `%`-encoding, depending on the flags
// with which @uri was created.
func (u *URI) Path() string {
	var arg0 *C.GUri

	arg0 = (*C.GUri)(unsafe.Pointer(u.Native()))

	var cret *C.gchar
	var ret1 string

	cret = C.g_uri_get_path(arg0)

	ret1 = C.GoString(cret)

	return ret1
}

// Port gets @uri's port.
func (u *URI) Port() int {
	var arg0 *C.GUri

	arg0 = (*C.GUri)(unsafe.Pointer(u.Native()))

	var cret C.gint
	var ret1 int

	cret = C.g_uri_get_port(arg0)

	ret1 = C.gint(cret)

	return ret1
}

// Query gets @uri's query, which may contain `%`-encoding, depending on the
// flags with which @uri was created.
//
// For queries consisting of a series of `name=value` parameters, ParamsIter or
// g_uri_parse_params() may be useful.
func (u *URI) Query() string {
	var arg0 *C.GUri

	arg0 = (*C.GUri)(unsafe.Pointer(u.Native()))

	var cret *C.gchar
	var ret1 string

	cret = C.g_uri_get_query(arg0)

	ret1 = C.GoString(cret)

	return ret1
}

// Scheme gets @uri's scheme. Note that this will always be all-lowercase,
// regardless of the string or strings that @uri was created from.
func (u *URI) Scheme() string {
	var arg0 *C.GUri

	arg0 = (*C.GUri)(unsafe.Pointer(u.Native()))

	var cret *C.gchar
	var ret1 string

	cret = C.g_uri_get_scheme(arg0)

	ret1 = C.GoString(cret)

	return ret1
}

// User gets the ‘username’ component of @uri's userinfo, which may contain
// `%`-encoding, depending on the flags with which @uri was created. If @uri was
// not created with G_URI_FLAGS_HAS_PASSWORD or G_URI_FLAGS_HAS_AUTH_PARAMS,
// this is the same as g_uri_get_userinfo().
func (u *URI) User() string {
	var arg0 *C.GUri

	arg0 = (*C.GUri)(unsafe.Pointer(u.Native()))

	var cret *C.gchar
	var ret1 string

	cret = C.g_uri_get_user(arg0)

	ret1 = C.GoString(cret)

	return ret1
}

// Userinfo gets @uri's userinfo, which may contain `%`-encoding, depending on
// the flags with which @uri was created.
func (u *URI) Userinfo() string {
	var arg0 *C.GUri

	arg0 = (*C.GUri)(unsafe.Pointer(u.Native()))

	var cret *C.gchar
	var ret1 string

	cret = C.g_uri_get_userinfo(arg0)

	ret1 = C.GoString(cret)

	return ret1
}

// ParseRelative parses @uri_ref according to @flags and, if it is a [relative
// URI][relative-absolute-uris], resolves it relative to @base_uri. If the
// result is not a valid absolute URI, it will be discarded, and an error
// returned.
func (b *URI) ParseRelative(uriRef string, flags URIFlags) (uri *URI, err error) {
	var arg0 *C.GUri
	var arg1 *C.gchar
	var arg2 C.GUriFlags
	var errout *C.GError

	arg0 = (*C.GUri)(unsafe.Pointer(b.Native()))
	arg1 = (*C.gchar)(C.CString(uriRef))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GUriFlags)(flags)

	var cret *C.GUri
	var ret1 *URI
	var goerr error

	cret = C.g_uri_parse_relative(arg0, uriRef, flags, &errout)

	ret1 = WrapURI(unsafe.Pointer(cret))
	runtime.SetFinalizer(ret1, func(v *URI) {
		C.free(unsafe.Pointer(v.Native()))
	})
	if errout != nil {
		goerr = fmt.Errorf("%d: %s", errout.code, C.GoString(errout.message))
		C.g_error_free(errout)
	}

	return ret1, goerr
}

// Ref increments the reference count of @uri by one.
func (u *URI) Ref() *URI {
	var arg0 *C.GUri

	arg0 = (*C.GUri)(unsafe.Pointer(u.Native()))

	var cret *C.GUri
	var ret1 *URI

	cret = C.g_uri_ref(arg0)

	ret1 = WrapURI(unsafe.Pointer(cret))
	runtime.SetFinalizer(ret1, func(v *URI) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return ret1
}

// String returns a string representing @uri.
//
// This is not guaranteed to return a string which is identical to the string
// that @uri was parsed from. However, if the source URI was syntactically
// correct (according to RFC 3986), and it was parsed with G_URI_FLAGS_ENCODED,
// then g_uri_to_string() is guaranteed to return a string which is at least
// semantically equivalent to the source URI (according to RFC 3986).
//
// If @uri might contain sensitive details, such as authentication parameters,
// or private data in its query string, and the returned string is going to be
// logged, then consider using g_uri_to_string_partial() to redact parts.
func (u *URI) String() string {
	var arg0 *C.GUri

	arg0 = (*C.GUri)(unsafe.Pointer(u.Native()))

	var cret *C.char
	var ret1 string

	cret = C.g_uri_to_string(arg0)

	ret1 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return ret1
}

// ToStringPartial returns a string representing @uri, subject to the options in
// @flags. See g_uri_to_string() and HideFlags for more details.
func (u *URI) ToStringPartial(flags URIHideFlags) string {
	var arg0 *C.GUri
	var arg1 C.GUriHideFlags

	arg0 = (*C.GUri)(unsafe.Pointer(u.Native()))
	arg1 = (C.GUriHideFlags)(flags)

	var cret *C.char
	var ret1 string

	cret = C.g_uri_to_string_partial(arg0, flags)

	ret1 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return ret1
}

// Unref: atomically decrements the reference count of @uri by one.
//
// When the reference count reaches zero, the resources allocated by @uri are
// freed
func (u *URI) Unref() {
	var arg0 *C.GUri

	arg0 = (*C.GUri)(unsafe.Pointer(u.Native()))

	C.g_uri_unref(arg0)
}

// URIParamsIter: many URI schemes include one or more attribute/value pairs as
// part of the URI value. For example
// `scheme://server/path?query=string&is=there` has two attributes –
// `query=string` and `is=there` – in its query part.
//
// A ParamsIter structure represents an iterator that can be used to iterate
// over the attribute/value pairs of a URI query string. ParamsIter structures
// are typically allocated on the stack and then initialized with
// g_uri_params_iter_init(). See the documentation for g_uri_params_iter_init()
// for a usage example.
type URIParamsIter struct {
	native C.GUriParamsIter
}

// WrapURIParamsIter wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapURIParamsIter(ptr unsafe.Pointer) *URIParamsIter {
	if ptr == nil {
		return nil
	}

	return (*URIParamsIter)(ptr)
}

func marshalURIParamsIter(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapURIParamsIter(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (u *URIParamsIter) Native() unsafe.Pointer {
	return unsafe.Pointer(&u.native)
}

// Init initializes an attribute/value pair iterator.
//
// The iterator keeps pointers to the @params and @separators arguments, those
// variables must thus outlive the iterator and not be modified during the
// iteration.
//
// If G_URI_PARAMS_WWW_FORM is passed in @flags, `+` characters in the param
// string will be replaced with spaces in the output. For example, `foo=bar+baz`
// will give attribute `foo` with value `bar baz`. This is commonly used on the
// web (the `https` and `http` schemes only), but is deprecated in favour of the
// equivalent of encoding spaces as `20`.
//
// Unlike with g_uri_parse_params(), G_URI_PARAMS_CASE_INSENSITIVE has no effect
// if passed to @flags for g_uri_params_iter_init(). The caller is responsible
// for doing their own case-insensitive comparisons.
//
//    GUriParamsIter iter;
//    GError *error = NULL;
//    gchar *unowned_attr, *unowned_value;
//
//    g_uri_params_iter_init (&iter, "foo=bar&baz=bar&Foo=frob&baz=bar2", -1, "&", G_URI_PARAMS_NONE);
//    while (g_uri_params_iter_next (&iter, &unowned_attr, &unowned_value, &error))
//      {
//        g_autofree gchar *attr = g_steal_pointer (&unowned_attr);
//        g_autofree gchar *value = g_steal_pointer (&unowned_value);
//        // do something with attr and value; this code will be called 4 times
//        // for the params string in this example: once with attr=foo and value=bar,
//        // then with baz/bar, then Foo/frob, then baz/bar2.
//      }
//    if (error)
//      // handle parsing error
func (i *URIParamsIter) Init(params string, length int, separators string, flags URIParamsFlags) {
	var arg0 *C.GUriParamsIter
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 *C.gchar
	var arg4 C.GUriParamsFlags

	arg0 = (*C.GUriParamsIter)(unsafe.Pointer(i.Native()))
	arg1 = (*C.gchar)(C.CString(params))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(length)
	arg3 = (*C.gchar)(C.CString(separators))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (C.GUriParamsFlags)(flags)

	C.g_uri_params_iter_init(arg0, params, length, separators, flags)
}

// Next advances @iter and retrieves the next attribute/value. false is returned
// if an error has occurred (in which case @error is set), or if the end of the
// iteration is reached (in which case @attribute and @value are set to nil and
// the iterator becomes invalid). If true is returned, g_uri_params_iter_next()
// may be called again to receive another attribute/value pair.
//
// Note that the same @attribute may be returned multiple times, since URIs
// allow repeated attributes.
func (i *URIParamsIter) Next() (attribute string, value string, err error) {
	var arg0 *C.GUriParamsIter
	var errout *C.GError

	arg0 = (*C.GUriParamsIter)(unsafe.Pointer(i.Native()))

	var arg1 *C.gchar
	var ret1 string
	var arg2 *C.gchar
	var ret2 string
	var goerr error

	C.g_uri_params_iter_next(arg0, &arg1, &arg2, &errout)

	ret1 = C.GoString(arg1)
	defer C.free(unsafe.Pointer(arg1))
	ret2 = C.GoString(arg2)
	defer C.free(unsafe.Pointer(arg2))
	if errout != nil {
		goerr = fmt.Errorf("%d: %s", errout.code, C.GoString(errout.message))
		C.g_error_free(errout)
	}

	return ret1, ret2, goerr
}
