// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"reflect"
	"runtime"
	"unsafe"
)

// #cgo pkg-config: glib-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <stdbool.h>
// #include <glib.h>
import "C"

// ConvertError: error codes returned by character set conversion routines.
type ConvertError int

const (
	// ConvertErrorNoConversion: conversion between the requested character sets
	// is not supported.
	ConvertErrorNoConversion ConvertError = 0
	// ConvertErrorIllegalSequence: invalid byte sequence in conversion input;
	// or the character sequence could not be represented in the target
	// character set.
	ConvertErrorIllegalSequence ConvertError = 1
	// ConvertErrorFailed: conversion failed for some reason.
	ConvertErrorFailed ConvertError = 2
	// ConvertErrorPartialInput: partial character sequence at end of input.
	ConvertErrorPartialInput ConvertError = 3
	// ConvertErrorBadURI: URI is invalid.
	ConvertErrorBadURI ConvertError = 4
	// ConvertErrorNotAbsolutePath: pathname is not an absolute path.
	ConvertErrorNotAbsolutePath ConvertError = 5
	// ConvertErrorNoMemory: no memory available. Since: 2.40
	ConvertErrorNoMemory ConvertError = 6
	// ConvertErrorEmbeddedNUL: an embedded NUL character is present in
	// conversion output where a NUL-terminated string is expected. Since: 2.56
	ConvertErrorEmbeddedNUL ConvertError = 7
)

// Convert converts a string from one character set to another.
//
// Note that you should use g_iconv() for streaming conversions. Despite the
// fact that @bytes_read can return information about partial characters, the
// g_convert_... functions are not generally suitable for streaming. If the
// underlying converter maintains internal state, then this won't be preserved
// across successive calls to g_convert(), g_convert_with_iconv() or
// g_convert_with_fallback(). (An example of this is the GNU C converter for
// CP1255 which does not emit a base character until it knows that the next
// character is not a mark that could combine with the base character.)
//
// Using extensions such as "//TRANSLIT" may not work (or may not work well) on
// many platforms. Consider using g_str_to_ascii() instead.
func Convert(str []byte, toCodeset string, fromCodeset string) (bytesRead uint, bytesWritten uint, guint8s []byte, err error) {
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 *C.gchar
	var arg4 *C.gchar
	var arg5 *C.gsize // out
	var arg6 *C.gsize // out
	var gError *C.GError

	arg1 = (*C.gchar)(unsafe.Pointer(&str[0]))
	arg2 = len(str)
	defer runtime.KeepAlive(str)
	arg3 = (*C.gchar)(C.CString(toCodeset))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gchar)(C.CString(fromCodeset))
	defer C.free(unsafe.Pointer(arg4))

	ret := C.g_convert(arg1, arg2, arg3, arg4, &arg5, &arg6, &gError)

	var ret0 uint
	var ret1 uint
	var ret2 []byte
	var goError error

	ret0 = uint(arg5)

	ret1 = uint(arg6)

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret2))
		sliceHeader.Data = uintptr(unsafe.Pointer(ret))
		sliceHeader.Len = arg6
		sliceHeader.Cap = arg6
		runtime.SetFinalizer(&ret, func() {
			C.free(unsafe.Pointer(ret))
		})
		defer runtime.KeepAlive(ret)
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}

// ConvertWithFallback converts a string from one character set to another,
// possibly including fallback sequences for characters not representable in the
// output. Note that it is not guaranteed that the specification for the
// fallback sequences in @fallback will be honored. Some systems may do an
// approximate conversion from @from_codeset to @to_codeset in their iconv()
// functions, in which case GLib will simply return that approximate conversion.
//
// Note that you should use g_iconv() for streaming conversions. Despite the
// fact that @bytes_read can return information about partial characters, the
// g_convert_... functions are not generally suitable for streaming. If the
// underlying converter maintains internal state, then this won't be preserved
// across successive calls to g_convert(), g_convert_with_iconv() or
// g_convert_with_fallback(). (An example of this is the GNU C converter for
// CP1255 which does not emit a base character until it knows that the next
// character is not a mark that could combine with the base character.)
func ConvertWithFallback(str []byte, toCodeset string, fromCodeset string, fallback string) (bytesRead uint, bytesWritten uint, guint8s []byte, err error) {
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 *C.gchar
	var arg4 *C.gchar
	var arg5 *C.gchar
	var arg6 *C.gsize // out
	var arg7 *C.gsize // out
	var gError *C.GError

	arg1 = (*C.gchar)(unsafe.Pointer(&str[0]))
	arg2 = len(str)
	defer runtime.KeepAlive(str)
	arg3 = (*C.gchar)(C.CString(toCodeset))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gchar)(C.CString(fromCodeset))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.gchar)(C.CString(fallback))
	defer C.free(unsafe.Pointer(arg5))

	ret := C.g_convert_with_fallback(arg1, arg2, arg3, arg4, arg5, &arg6, &arg7, &gError)

	var ret0 uint
	var ret1 uint
	var ret2 []byte
	var goError error

	ret0 = uint(arg6)

	ret1 = uint(arg7)

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret2))
		sliceHeader.Data = uintptr(unsafe.Pointer(ret))
		sliceHeader.Len = arg7
		sliceHeader.Cap = arg7
		runtime.SetFinalizer(&ret, func() {
			C.free(unsafe.Pointer(ret))
		})
		defer runtime.KeepAlive(ret)
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}

// ConvertWithIconv converts a string from one character set to another.
//
// Note that you should use g_iconv() for streaming conversions. Despite the
// fact that @bytes_read can return information about partial characters, the
// g_convert_... functions are not generally suitable for streaming. If the
// underlying converter maintains internal state, then this won't be preserved
// across successive calls to g_convert(), g_convert_with_iconv() or
// g_convert_with_fallback(). (An example of this is the GNU C converter for
// CP1255 which does not emit a base character until it knows that the next
// character is not a mark that could combine with the base character.)
//
// Characters which are valid in the input character set, but which have no
// representation in the output character set will result in a
// G_CONVERT_ERROR_ILLEGAL_SEQUENCE error. This is in contrast to the iconv()
// specification, which leaves this behaviour implementation defined. Note that
// this is the same error code as is returned for an invalid byte sequence in
// the input character set. To get defined behaviour for conversion of
// unrepresentable characters, use g_convert_with_fallback().
func ConvertWithIconv(str []byte, converter IConv) (bytesRead uint, bytesWritten uint, guint8s []byte, err error) {
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 C.GIConv
	var arg4 *C.gsize // out
	var arg5 *C.gsize // out
	var gError *C.GError

	arg1 = (*C.gchar)(unsafe.Pointer(&str[0]))
	arg2 = len(str)
	defer runtime.KeepAlive(str)
	arg3 = (C.GIConv)(converter.Native())

	ret := C.g_convert_with_iconv(arg1, arg2, arg3, &arg4, &arg5, &gError)

	var ret0 uint
	var ret1 uint
	var ret2 []byte
	var goError error

	ret0 = uint(arg4)

	ret1 = uint(arg5)

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret2))
		sliceHeader.Data = uintptr(unsafe.Pointer(ret))
		sliceHeader.Len = arg5
		sliceHeader.Cap = arg5
		runtime.SetFinalizer(&ret, func() {
			C.free(unsafe.Pointer(ret))
		})
		defer runtime.KeepAlive(ret)
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}

// FilenameDisplayBasename returns the display basename for the particular
// filename, guaranteed to be valid UTF-8. The display name might not be
// identical to the filename, for instance there might be problems converting it
// to UTF-8, and some files can be translated in the display.
//
// If GLib cannot make sense of the encoding of @filename, as a last resort it
// replaces unknown characters with U+FFFD, the Unicode replacement character.
// You can search the result for the UTF-8 encoding of this character (which is
// "\357\277\275" in octal notation) to find out if @filename was in an invalid
// encoding.
//
// You must pass the whole absolute pathname to this functions so that
// translation of well known locations can be done.
//
// This function is preferred over g_filename_display_name() if you know the
// whole path, as it allows translation.
func FilenameDisplayBasename(filename string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_filename_display_basename(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// FilenameDisplayName converts a filename into a valid UTF-8 string. The
// conversion is not necessarily reversible, so you should keep the original
// around and use the return value of this function only for display purposes.
// Unlike g_filename_to_utf8(), the result is guaranteed to be non-nil even if
// the filename actually isn't in the GLib file name encoding.
//
// If GLib cannot make sense of the encoding of @filename, as a last resort it
// replaces unknown characters with U+FFFD, the Unicode replacement character.
// You can search the result for the UTF-8 encoding of this character (which is
// "\357\277\275" in octal notation) to find out if @filename was in an invalid
// encoding.
//
// If you know the whole pathname of the file you should use
// g_filename_display_basename(), since that allows location-based translation
// of filenames.
func FilenameDisplayName(filename string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_filename_display_name(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// FilenameFromURI converts an escaped ASCII-encoded URI to a local filename in
// the encoding used for filenames.
func FilenameFromURI(uri string) (hostname string, filename string, err error) {
	var arg1 *C.gchar
	var arg2 **C.gchar // out
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_filename_from_uri(arg1, &arg2, &gError)

	var ret0 string
	var ret1 string
	var goError error

	ret0 = C.GoString(arg2)
	C.free(unsafe.Pointer(arg2))

	ret1 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// FilenameFromUTF8 converts a string from UTF-8 to the encoding GLib uses for
// filenames. Note that on Windows GLib uses UTF-8 for filenames; on other
// platforms, this function indirectly depends on the [current
// locale][setlocale].
//
// The input string shall not contain nul characters even if the @len argument
// is positive. A nul character found inside the string will result in error
// G_CONVERT_ERROR_ILLEGAL_SEQUENCE. If the filename encoding is not UTF-8 and
// the conversion output contains a nul character, the error
// G_CONVERT_ERROR_EMBEDDED_NUL is set and the function returns nil.
func FilenameFromUTF8(utf8String string, len int) (bytesRead uint, bytesWritten uint, filename string, err error) {
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 *C.gsize // out
	var arg4 *C.gsize // out
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(utf8String))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(len)

	ret := C.g_filename_from_utf8(arg1, arg2, &arg3, &arg4, &gError)

	var ret0 uint
	var ret1 uint
	var ret2 string
	var goError error

	ret0 = uint(arg3)

	ret1 = uint(arg4)

	ret2 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}

// FilenameToURI converts an absolute filename to an escaped ASCII-encoded URI,
// with the path component following Section 3.3. of RFC 2396.
func FilenameToURI(filename string, hostname string) (utf8 string, err error) {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(hostname))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_filename_to_uri(arg1, arg2, &gError)

	var ret0 string
	var goError error

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// FilenameToUTF8 converts a string which is in the encoding used by GLib for
// filenames into a UTF-8 string. Note that on Windows GLib uses UTF-8 for
// filenames; on other platforms, this function indirectly depends on the
// [current locale][setlocale].
//
// The input string shall not contain nul characters even if the @len argument
// is positive. A nul character found inside the string will result in error
// G_CONVERT_ERROR_ILLEGAL_SEQUENCE. If the source encoding is not UTF-8 and the
// conversion output contains a nul character, the error
// G_CONVERT_ERROR_EMBEDDED_NUL is set and the function returns nil. Use
// g_convert() to produce output that may contain embedded nul characters.
func FilenameToUTF8(opsysstring string, len int) (bytesRead uint, bytesWritten uint, utf8 string, err error) {
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 *C.gsize // out
	var arg4 *C.gsize // out
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(opsysstring))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(len)

	ret := C.g_filename_to_utf8(arg1, arg2, &arg3, &arg4, &gError)

	var ret0 uint
	var ret1 uint
	var ret2 string
	var goError error

	ret0 = uint(arg3)

	ret1 = uint(arg4)

	ret2 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}

// GetFilenameCharsets determines the preferred character sets used for
// filenames. The first character set from the @charsets is the filename
// encoding, the subsequent character sets are used when trying to generate a
// displayable representation of a filename, see g_filename_display_name().
//
// On Unix, the character sets are determined by consulting the environment
// variables `G_FILENAME_ENCODING` and `G_BROKEN_FILENAMES`. On Windows, the
// character set used in the GLib API is always UTF-8 and said environment
// variables have no effect.
//
// `G_FILENAME_ENCODING` may be set to a comma-separated list of character set
// names. The special token "\@locale" is taken to mean the character set for
// the [current locale][setlocale]. If `G_FILENAME_ENCODING` is not set, but
// `G_BROKEN_FILENAMES` is, the character set of the current locale is taken as
// the filename encoding. If neither environment variable is set, UTF-8 is taken
// as the filename encoding, but the character set of the current locale is also
// put in the list of encodings.
//
// The returned @charsets belong to GLib and must not be freed.
//
// Note that on Unix, regardless of the locale character set or
// `G_FILENAME_ENCODING` value, the actual file names present on a system might
// be in any random encoding or just gibberish.
func GetFilenameCharsets() (filenameCharsets []string, ok bool) {
	var arg1 ***C.gchar // out

	ret := C.g_get_filename_charsets(&arg1)

	var ret0 []string
	var ret1 bool

	{
		var length uint
		for p := unsafe.Pointer(arg1); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (**C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(arg1)) + i))
			ret0[i] = C.GoString(src)
		}
	}

	ret1 = C.bool(ret) != 0

	return ret0, ret1
}

// Iconv: same as the standard UNIX routine iconv(), but may be implemented via
// libiconv on UNIX flavors that lack a native implementation.
//
// GLib provides g_convert() and g_locale_to_utf8() which are likely more
// convenient than the raw iconv wrappers.
//
// Note that the behaviour of iconv() for characters which are valid in the
// input character set, but which have no representation in the output character
// set, is implementation defined. This function may return success (with a
// positive number of non-reversible conversions as replacement characters were
// used), or it may return -1 and set an error such as EILSEQ, in such a
// situation.
func Iconv(converter IConv, inbuf string, inbytesLeft uint, outbuf string, outbytesLeft uint) uint {
	var arg1 C.GIConv
	var arg2 **C.gchar
	var arg3 *C.gsize
	var arg4 **C.gchar
	var arg5 *C.gsize

	arg1 = (C.GIConv)(converter.Native())
	arg2 = (*C.gchar)(C.CString(inbuf))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gsize)(inbytesLeft)
	arg4 = (*C.gchar)(C.CString(outbuf))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.gsize)(outbytesLeft)

	ret := C.g_iconv(arg1, arg2, arg3, arg4, arg5)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// IconvOpen: same as the standard UNIX routine iconv_open(), but may be
// implemented via libiconv on UNIX flavors that lack a native implementation.
//
// GLib provides g_convert() and g_locale_to_utf8() which are likely more
// convenient than the raw iconv wrappers.
func IconvOpen(toCodeset string, fromCodeset string) IConv {
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg1 = (*C.gchar)(C.CString(toCodeset))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(fromCodeset))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_iconv_open(arg1, arg2)

	var ret0 IConv

	{
		ret0 = WrapIConv(unsafe.Pointer(ret))
	}

	return ret0
}

// LocaleFromUTF8 converts a string from UTF-8 to the encoding used for strings
// by the C runtime (usually the same as that used by the operating system) in
// the [current locale][setlocale]. On Windows this means the system codepage.
//
// The input string shall not contain nul characters even if the @len argument
// is positive. A nul character found inside the string will result in error
// G_CONVERT_ERROR_ILLEGAL_SEQUENCE. Use g_convert() to convert input that may
// contain embedded nul characters.
func LocaleFromUTF8(utf8String string, len int) (bytesRead uint, bytesWritten uint, guint8s []byte, err error) {
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 *C.gsize // out
	var arg4 *C.gsize // out
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(utf8String))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(len)

	ret := C.g_locale_from_utf8(arg1, arg2, &arg3, &arg4, &gError)

	var ret0 uint
	var ret1 uint
	var ret2 []byte
	var goError error

	ret0 = uint(arg3)

	ret1 = uint(arg4)

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret2))
		sliceHeader.Data = uintptr(unsafe.Pointer(ret))
		sliceHeader.Len = arg4
		sliceHeader.Cap = arg4
		runtime.SetFinalizer(&ret, func() {
			C.free(unsafe.Pointer(ret))
		})
		defer runtime.KeepAlive(ret)
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}

// LocaleToUTF8 converts a string which is in the encoding used for strings by
// the C runtime (usually the same as that used by the operating system) in the
// [current locale][setlocale] into a UTF-8 string.
//
// If the source encoding is not UTF-8 and the conversion output contains a nul
// character, the error G_CONVERT_ERROR_EMBEDDED_NUL is set and the function
// returns nil. If the source encoding is UTF-8, an embedded nul character is
// treated with the G_CONVERT_ERROR_ILLEGAL_SEQUENCE error for backward
// compatibility with earlier versions of this library. Use g_convert() to
// produce output that may contain embedded nul characters.
func LocaleToUTF8(opsysstring []byte) (bytesRead uint, bytesWritten uint, utf8 string, err error) {
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 *C.gsize // out
	var arg4 *C.gsize // out
	var gError *C.GError

	arg1 = (*C.gchar)(unsafe.Pointer(&opsysstring[0]))
	arg2 = len(opsysstring)
	defer runtime.KeepAlive(opsysstring)

	ret := C.g_locale_to_utf8(arg1, arg2, &arg3, &arg4, &gError)

	var ret0 uint
	var ret1 uint
	var ret2 string
	var goError error

	ret0 = uint(arg3)

	ret1 = uint(arg4)

	ret2 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}

// URIListExtractUris splits an URI list conforming to the text/uri-list mime
// type defined in RFC 2483 into individual URIs, discarding any comments. The
// URIs are not validated.
func URIListExtractUris(uriList string) []string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(uriList))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_uri_list_extract_uris(arg1)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// IConv: the GIConv struct wraps an iconv() conversion descriptor. It contains
// private data and should only be accessed using the following functions.
type IConv struct {
	native C.GIConv
}

// WrapIConv wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapIConv(ptr unsafe.Pointer) *IConv {
	if ptr == nil {
		return nil
	}

	return (*IConv)(ptr)
}

func marshalIConv(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapIConv(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (i *IConv) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

// _: same as the standard UNIX routine iconv(), but may be implemented via
// libiconv on UNIX flavors that lack a native implementation.
//
// GLib provides g_convert() and g_locale_to_utf8() which are likely more
// convenient than the raw iconv wrappers.
//
// Note that the behaviour of iconv() for characters which are valid in the
// input character set, but which have no representation in the output character
// set, is implementation defined. This function may return success (with a
// positive number of non-reversible conversions as replacement characters were
// used), or it may return -1 and set an error such as EILSEQ, in such a
// situation.
func (c *IConv) _(inbuf string, inbytesLeft uint, outbuf string, outbytesLeft uint) uint {
	var arg0 C.GIConv
	var arg1 **C.gchar
	var arg2 *C.gsize
	var arg3 **C.gchar
	var arg4 *C.gsize

	arg0 = (C.GIConv)(c.Native())
	arg1 = (*C.gchar)(C.CString(inbuf))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gsize)(inbytesLeft)
	arg3 = (*C.gchar)(C.CString(outbuf))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gsize)(outbytesLeft)

	ret := C.g_iconv(arg0, arg1, arg2, arg3, arg4)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Close: same as the standard UNIX routine iconv_close(), but may be
// implemented via libiconv on UNIX flavors that lack a native implementation.
// Should be called to clean up the conversion descriptor from g_iconv_open()
// when you are done converting things.
//
// GLib provides g_convert() and g_locale_to_utf8() which are likely more
// convenient than the raw iconv wrappers.
func (c *IConv) Close() int {
	var arg0 C.GIConv

	arg0 = (C.GIConv)(c.Native())

	ret := C.g_iconv_close(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}
