// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
)

// #cgo pkg-config: glib-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <stdbool.h>
// #include <glib.h>
import "C"

// Strv: a typedef alias for gchar**. This is mostly useful when used together
// with g_auto().
type Strv string

// NumberParserError: error codes returned by functions converting a string to a
// number.
type NumberParserError int

const (
	// NumberParserErrorInvalid: string was not a valid number.
	NumberParserErrorInvalid NumberParserError = 0
	// NumberParserErrorOutOfBounds: string was a number, but out of bounds.
	NumberParserErrorOutOfBounds NumberParserError = 1
)

type ASCIIType int

const (
	ASCIITypeAlnum ASCIIType = 0b1

	ASCIITypeAlpha ASCIIType = 0b10

	ASCIITypeCntrl ASCIIType = 0b100

	ASCIITypeDigit ASCIIType = 0b1000

	ASCIITypeGraph ASCIIType = 0b10000

	ASCIITypeLower ASCIIType = 0b100000

	ASCIITypePrint ASCIIType = 0b1000000

	ASCIITypePunct ASCIIType = 0b10000000

	ASCIITypeSpace ASCIIType = 0b100000000

	ASCIITypeUpper ASCIIType = 0b1000000000

	ASCIITypeXDigit ASCIIType = 0b10000000000
)

// ASCIIDigitValue determines the numeric value of a character as a decimal
// digit. Differs from g_unichar_digit_value() because it takes a char, so
// there's no worry about sign extension if characters are signed.
func ASCIIDigitValue(c byte) int {
	var arg1 C.gchar

	arg1 = C.gchar(c)

	ret := C.g_ascii_digit_value(arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ASCIIDtostr converts a #gdouble to a string, using the '.' as decimal point.
//
// This function generates enough precision that converting the string back
// using g_ascii_strtod() gives the same machine-number (on machines with IEEE
// compatible 64bit doubles). It is guaranteed that the size of the resulting
// string will never be larger than @G_ASCII_DTOSTR_BUF_SIZE bytes, including
// the terminating nul character, which is always added.
func ASCIIDtostr(buffer string, bufLen int, d float64) string {
	var arg1 *C.gchar
	var arg2 C.gint
	var arg3 C.gdouble

	arg1 = (*C.gchar)(C.CString(buffer))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(bufLen)
	arg3 = C.gdouble(d)

	ret := C.g_ascii_dtostr(arg1, arg2, arg3)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// ASCIIFormatd converts a #gdouble to a string, using the '.' as decimal point.
// To format the number you pass in a printf()-style format string. Allowed
// conversion specifiers are 'e', 'E', 'f', 'F', 'g' and 'G'.
//
// The returned buffer is guaranteed to be nul-terminated.
//
// If you just want to want to serialize the value into a string, use
// g_ascii_dtostr().
func ASCIIFormatd(buffer string, bufLen int, format string, d float64) string {
	var arg1 *C.gchar
	var arg2 C.gint
	var arg3 *C.gchar
	var arg4 C.gdouble

	arg1 = (*C.gchar)(C.CString(buffer))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(bufLen)
	arg3 = (*C.gchar)(C.CString(format))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = C.gdouble(d)

	ret := C.g_ascii_formatd(arg1, arg2, arg3, arg4)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// ASCIIStrcasecmp: compare two strings, ignoring the case of ASCII characters.
//
// Unlike the BSD strcasecmp() function, this only recognizes standard ASCII
// letters and ignores the locale, treating all non-ASCII bytes as if they are
// not letters.
//
// This function should be used only on strings that are known to be in
// encodings where the bytes corresponding to ASCII letters always represent
// themselves. This includes UTF-8 and the ISO-8859-* charsets, but not for
// instance double-byte encodings like the Windows Codepage 932, where the
// trailing bytes of double-byte characters include all ASCII letters. If you
// compare two CP932 strings using this function, you will get false matches.
//
// Both @s1 and @s2 must be non-nil.
func ASCIIStrcasecmp(s1 string, s2 string) int {
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg1 = (*C.gchar)(C.CString(s1))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(s2))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_ascii_strcasecmp(arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ASCIIStrdown converts all upper case ASCII letters to lower case ASCII
// letters.
func ASCIIStrdown(str string, len int) string {
	var arg1 *C.gchar
	var arg2 C.gssize

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(len)

	ret := C.g_ascii_strdown(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// ASCIIStringToSigned: a convenience function for converting a string to a
// signed number.
//
// This function assumes that @str contains only a number of the given @base
// that is within inclusive bounds limited by @min and @max. If this is true,
// then the converted number is stored in @out_num. An empty string is not a
// valid input. A string with leading or trailing whitespace is also an invalid
// input.
//
// @base can be between 2 and 36 inclusive. Hexadecimal numbers must not be
// prefixed with "0x" or "0X". Such a problem does not exist for octal numbers,
// since they were usually prefixed with a zero which does not change the value
// of the parsed number.
//
// Parsing failures result in an error with the G_NUMBER_PARSER_ERROR domain. If
// the input is invalid, the error code will be G_NUMBER_PARSER_ERROR_INVALID.
// If the parsed number is out of bounds - G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS.
//
// See g_ascii_strtoll() if you have more complex needs such as parsing a string
// which starts with a number, but then has other characters.
func ASCIIStringToSigned(str string, base uint, min int64, max int64) (outNum int64, err error) {
	var arg1 *C.gchar
	var arg2 C.guint
	var arg3 C.gint64
	var arg4 C.gint64
	var arg5 *C.gint64 // out
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.guint(base)
	arg3 = C.gint64(min)
	arg4 = C.gint64(max)

	ret := C.g_ascii_string_to_signed(arg1, arg2, arg3, arg4, &arg5, &gError)

	var ret0 int64
	var goError error

	ret0 = int64(arg5)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// ASCIIStringToUnsigned: a convenience function for converting a string to an
// unsigned number.
//
// This function assumes that @str contains only a number of the given @base
// that is within inclusive bounds limited by @min and @max. If this is true,
// then the converted number is stored in @out_num. An empty string is not a
// valid input. A string with leading or trailing whitespace is also an invalid
// input. A string with a leading sign (`-` or `+`) is not a valid input for the
// unsigned parser.
//
// @base can be between 2 and 36 inclusive. Hexadecimal numbers must not be
// prefixed with "0x" or "0X". Such a problem does not exist for octal numbers,
// since they were usually prefixed with a zero which does not change the value
// of the parsed number.
//
// Parsing failures result in an error with the G_NUMBER_PARSER_ERROR domain. If
// the input is invalid, the error code will be G_NUMBER_PARSER_ERROR_INVALID.
// If the parsed number is out of bounds - G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS.
//
// See g_ascii_strtoull() if you have more complex needs such as parsing a
// string which starts with a number, but then has other characters.
func ASCIIStringToUnsigned(str string, base uint, min uint64, max uint64) (outNum uint64, err error) {
	var arg1 *C.gchar
	var arg2 C.guint
	var arg3 C.guint64
	var arg4 C.guint64
	var arg5 *C.guint64 // out
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.guint(base)
	arg3 = C.guint64(min)
	arg4 = C.guint64(max)

	ret := C.g_ascii_string_to_unsigned(arg1, arg2, arg3, arg4, &arg5, &gError)

	var ret0 uint64
	var goError error

	ret0 = uint64(arg5)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// ASCIIStrncasecmp: compare @s1 and @s2, ignoring the case of ASCII characters
// and any characters after the first @n in each string.
//
// Unlike the BSD strcasecmp() function, this only recognizes standard ASCII
// letters and ignores the locale, treating all non-ASCII characters as if they
// are not letters.
//
// The same warning as in g_ascii_strcasecmp() applies: Use this function only
// on strings known to be in encodings where bytes corresponding to ASCII
// letters always represent themselves.
func ASCIIStrncasecmp(s1 string, s2 string, n uint) int {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 C.gsize

	arg1 = (*C.gchar)(C.CString(s1))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(s2))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.gsize(n)

	ret := C.g_ascii_strncasecmp(arg1, arg2, arg3)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ASCIIStrtod converts a string to a #gdouble value.
//
// This function behaves like the standard strtod() function does in the C
// locale. It does this without actually changing the current locale, since that
// would not be thread-safe. A limitation of the implementation is that this
// function will still accept localized versions of infinities and NANs.
//
// This function is typically used when reading configuration files or other
// non-user input that should be locale independent. To handle input from the
// user you should normally use the locale-sensitive system strtod() function.
//
// To convert from a #gdouble to a string in a locale-insensitive way, use
// g_ascii_dtostr().
//
// If the correct value would cause overflow, plus or minus HUGE_VAL is returned
// (according to the sign of the value), and ERANGE is stored in errno. If the
// correct value would cause underflow, zero is returned and ERANGE is stored in
// errno.
//
// This function resets errno before calling strtod() so that you can reliably
// detect overflow and underflow.
func ASCIIStrtod(nptr string) (endptr string, gdouble float64) {
	var arg1 *C.gchar
	var arg2 **C.gchar // out

	arg1 = (*C.gchar)(C.CString(nptr))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_ascii_strtod(arg1, &arg2)

	var ret0 string
	var ret1 float64

	ret0 = C.GoString(arg2)

	ret1 = float64(ret)

	return ret0, ret1
}

// ASCIIStrtoll converts a string to a #gint64 value. This function behaves like
// the standard strtoll() function does in the C locale. It does this without
// actually changing the current locale, since that would not be thread-safe.
//
// This function is typically used when reading configuration files or other
// non-user input that should be locale independent. To handle input from the
// user you should normally use the locale-sensitive system strtoll() function.
//
// If the correct value would cause overflow, G_MAXINT64 or G_MININT64 is
// returned, and `ERANGE` is stored in `errno`. If the base is outside the valid
// range, zero is returned, and `EINVAL` is stored in `errno`. If the string
// conversion fails, zero is returned, and @endptr returns @nptr (if @endptr is
// non-nil).
func ASCIIStrtoll(nptr string, base uint) (endptr string, gint64 int64) {
	var arg1 *C.gchar
	var arg2 **C.gchar // out
	var arg3 C.guint

	arg1 = (*C.gchar)(C.CString(nptr))
	defer C.free(unsafe.Pointer(arg1))
	arg3 = C.guint(base)

	ret := C.g_ascii_strtoll(arg1, &arg2, arg3)

	var ret0 string
	var ret1 int64

	ret0 = C.GoString(arg2)

	ret1 = int64(ret)

	return ret0, ret1
}

// ASCIIStrtoull converts a string to a #guint64 value. This function behaves
// like the standard strtoull() function does in the C locale. It does this
// without actually changing the current locale, since that would not be
// thread-safe.
//
// Note that input with a leading minus sign (`-`) is accepted, and will return
// the negation of the parsed number, unless that would overflow a #guint64.
// Critically, this means you cannot assume that a short fixed length input will
// never result in a low return value, as the input could have a leading `-`.
//
// This function is typically used when reading configuration files or other
// non-user input that should be locale independent. To handle input from the
// user you should normally use the locale-sensitive system strtoull() function.
//
// If the correct value would cause overflow, G_MAXUINT64 is returned, and
// `ERANGE` is stored in `errno`. If the base is outside the valid range, zero
// is returned, and `EINVAL` is stored in `errno`. If the string conversion
// fails, zero is returned, and @endptr returns @nptr (if @endptr is non-nil).
func ASCIIStrtoull(nptr string, base uint) (endptr string, guint64 uint64) {
	var arg1 *C.gchar
	var arg2 **C.gchar // out
	var arg3 C.guint

	arg1 = (*C.gchar)(C.CString(nptr))
	defer C.free(unsafe.Pointer(arg1))
	arg3 = C.guint(base)

	ret := C.g_ascii_strtoull(arg1, &arg2, arg3)

	var ret0 string
	var ret1 uint64

	ret0 = C.GoString(arg2)

	ret1 = uint64(ret)

	return ret0, ret1
}

// ASCIIStrup converts all lower case ASCII letters to upper case ASCII letters.
func ASCIIStrup(str string, len int) string {
	var arg1 *C.gchar
	var arg2 C.gssize

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(len)

	ret := C.g_ascii_strup(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// ASCIIToLower: convert a character to ASCII lower case.
//
// Unlike the standard C library tolower() function, this only recognizes
// standard ASCII letters and ignores the locale, returning all non-ASCII
// characters unchanged, even if they are lower case letters in a particular
// character set. Also unlike the standard library function, this takes and
// returns a char, not an int, so don't call it on EOF but no need to worry
// about casting to #guchar before passing a possibly non-ASCII character in.
func ASCIIToLower(c byte) byte {
	var arg1 C.gchar

	arg1 = C.gchar(c)

	ret := C.g_ascii_tolower(arg1)

	var ret0 byte

	ret0 = byte(ret)

	return ret0
}

// ASCIIToUpper: convert a character to ASCII upper case.
//
// Unlike the standard C library toupper() function, this only recognizes
// standard ASCII letters and ignores the locale, returning all non-ASCII
// characters unchanged, even if they are upper case letters in a particular
// character set. Also unlike the standard library function, this takes and
// returns a char, not an int, so don't call it on EOF but no need to worry
// about casting to #guchar before passing a possibly non-ASCII character in.
func ASCIIToUpper(c byte) byte {
	var arg1 C.gchar

	arg1 = C.gchar(c)

	ret := C.g_ascii_toupper(arg1)

	var ret0 byte

	ret0 = byte(ret)

	return ret0
}

// ASCIIXDigitValue determines the numeric value of a character as a hexadecimal
// digit. Differs from g_unichar_xdigit_value() because it takes a char, so
// there's no worry about sign extension if characters are signed.
func ASCIIXDigitValue(c byte) int {
	var arg1 C.gchar

	arg1 = C.gchar(c)

	ret := C.g_ascii_xdigit_value(arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Memdup allocates @byte_size bytes of memory, and copies @byte_size bytes into
// it from @mem. If @mem is nil it returns nil.
func Memdup(mem interface{}, byteSize uint) interface{} {
	var arg1 C.gpointer
	var arg2 C.guint

	arg1 = C.gpointer(box.Assign(mem))
	arg2 = C.guint(byteSize)

	ret := C.g_memdup(arg1, arg2)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// Memdup2 allocates @byte_size bytes of memory, and copies @byte_size bytes
// into it from @mem. If @mem is nil it returns nil.
//
// This replaces g_memdup(), which was prone to integer overflows when
// converting the argument from a #gsize to a #guint.
func Memdup2(mem interface{}, byteSize uint) interface{} {
	var arg1 C.gpointer
	var arg2 C.gsize

	arg1 = C.gpointer(box.Assign(mem))
	arg2 = C.gsize(byteSize)

	ret := C.g_memdup2(arg1, arg2)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// Stpcpy copies a nul-terminated string into the dest buffer, include the
// trailing nul, and return a pointer to the trailing nul byte. This is useful
// for concatenating multiple strings together without having to repeatedly scan
// for the end.
func Stpcpy(dest string, src string) string {
	var arg1 *C.gchar
	var arg2 *C.char

	arg1 = (*C.gchar)(C.CString(dest))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(src))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_stpcpy(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// StrHasPrefix looks whether the string @str begins with @prefix.
func StrHasPrefix(str string, prefix string) bool {
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(prefix))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_str_has_prefix(arg1, arg2)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// StrHasSuffix looks whether the string @str ends with @suffix.
func StrHasSuffix(str string, suffix string) bool {
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(suffix))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_str_has_suffix(arg1, arg2)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// StrIsASCII determines if a string is pure ASCII. A string is pure ASCII if it
// contains no bytes with the high bit set.
func StrIsASCII(str string) bool {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_str_is_ascii(arg1)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// StrMatchString checks if a search conducted for @search_term should match
// @potential_hit.
//
// This function calls g_str_tokenize_and_fold() on both @search_term and
// @potential_hit. ASCII alternates are never taken for @search_term but will be
// taken for @potential_hit according to the value of @accept_alternates.
//
// A hit occurs when each folded token in @search_term is a prefix of a folded
// token from @potential_hit.
//
// Depending on how you're performing the search, it will typically be faster to
// call g_str_tokenize_and_fold() on each string in your corpus and build an
// index on the returned folded tokens, then call g_str_tokenize_and_fold() on
// the search term and perform lookups into that index.
//
// As some examples, searching for ‘fred’ would match the potential hit ‘Smith,
// Fred’ and also ‘Frédéric’. Searching for ‘Fréd’ would match ‘Frédéric’ but
// not ‘Frederic’ (due to the one-directional nature of accent matching).
// Searching ‘fo’ would match ‘Foo’ and ‘Bar Foo Baz’, but not ‘SFO’ (because no
// word has ‘fo’ as a prefix).
func StrMatchString(searchTerm string, potentialHit string, acceptAlternates bool) bool {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 C.gboolean

	arg1 = (*C.gchar)(C.CString(searchTerm))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(potentialHit))
	defer C.free(unsafe.Pointer(arg2))
	if acceptAlternates {
		arg3 = C.TRUE
	}

	ret := C.g_str_match_string(arg1, arg2, arg3)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// StrToASCII: transliterate @str to plain ASCII.
//
// For best results, @str should be in composed normalised form.
//
// This function performs a reasonably good set of character replacements. The
// particular set of replacements that is done may change by version or even by
// runtime environment.
//
// If the source language of @str is known, it can used to improve the accuracy
// of the translation by passing it as @from_locale. It should be a valid POSIX
// locale string (of the form `language[_territory][.codeset][@modifier]`).
//
// If @from_locale is nil then the current locale is used.
//
// If you want to do translation for no specific locale, and you want it to be
// done independently of the currently locale, specify `"C"` for @from_locale.
func StrToASCII(str string, fromLocale string) string {
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(fromLocale))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_str_to_ascii(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// StrTokenizeAndFold tokenises @string and performs folding on each token.
//
// A token is a non-empty sequence of alphanumeric characters in the source
// string, separated by non-alphanumeric characters. An "alphanumeric" character
// for this purpose is one that matches g_unichar_isalnum() or
// g_unichar_ismark().
//
// Each token is then (Unicode) normalised and case-folded. If @ascii_alternates
// is non-nil and some of the returned tokens contain non-ASCII characters,
// ASCII alternatives will be generated.
//
// The number of ASCII alternatives that are generated and the method for doing
// so is unspecified, but @translit_locale (if specified) may improve the
// transliteration if the language of the source string is known.
func StrTokenizeAndFold(string string, translitLocale string) (asciiAlternates []string, utf8s []string) {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 ***C.gchar // out

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(translitLocale))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_str_tokenize_and_fold(arg1, arg2, &arg3)

	var ret0 []string
	var ret1 []string

	{
		var length uint
		for p := unsafe.Pointer(arg3); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (**C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(arg3)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret1 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret1[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0, ret1
}

// Strcanon: for each character in @string, if the character is not in
// @valid_chars, replaces the character with @substitutor. Modifies @string in
// place, and return @string itself, not a copy. The return value is to allow
// nesting such as
//
//    reformatted = g_strcanon (g_strdup (const_str), "abc", '?');
//    ...
//    g_free (reformatted);
func Strcanon(string string, validChars string, substitutor byte) string {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 C.gchar

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(validChars))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.gchar(substitutor)

	ret := C.g_strcanon(arg1, arg2, arg3)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Strcasecmp: a case-insensitive string comparison, corresponding to the
// standard strcasecmp() function on platforms which support it.
func Strcasecmp(s1 string, s2 string) int {
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg1 = (*C.gchar)(C.CString(s1))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(s2))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_strcasecmp(arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Strchomp removes trailing whitespace from a string.
//
// This function doesn't allocate or reallocate any memory; it modifies @string
// in place. Therefore, it cannot be used on statically allocated strings.
//
// The pointer to @string is returned to allow the nesting of functions.
//
// Also see g_strchug() and g_strstrip().
func Strchomp(string string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_strchomp(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Strchug removes leading whitespace from a string, by moving the rest of the
// characters forward.
//
// This function doesn't allocate or reallocate any memory; it modifies @string
// in place. Therefore, it cannot be used on statically allocated strings.
//
// The pointer to @string is returned to allow the nesting of functions.
//
// Also see g_strchomp() and g_strstrip().
func Strchug(string string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_strchug(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Strcompress replaces all escaped characters with their one byte equivalent.
//
// This function does the reverse conversion of g_strescape().
func Strcompress(source string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(source))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_strcompress(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Strdelimit converts any delimiter characters in @string to @new_delimiter.
// Any characters in @string which are found in @delimiters are changed to the
// @new_delimiter character. Modifies @string in place, and returns @string
// itself, not a copy. The return value is to allow nesting such as
//
//    reformatted = g_strdelimit (g_strdup (const_str), "abc", '?');
//    ...
//    g_free (reformatted);
func Strdelimit(string string, delimiters string, newDelimiter byte) string {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 C.gchar

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(delimiters))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.gchar(newDelimiter)

	ret := C.g_strdelimit(arg1, arg2, arg3)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Strdown converts a string to lower case.
func Strdown(string string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_strdown(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Strdup duplicates a string. If @str is nil it returns nil. The returned
// string should be freed with g_free() when no longer needed.
func Strdup(str string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_strdup(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Strdupv copies nil-terminated array of strings. The copy is a deep copy; the
// new array should be freed by first freeing each string, then the array
// itself. g_strfreev() does this for you. If called on a nil value, g_strdupv()
// simply returns nil.
func Strdupv(strArray string) []string {
	var arg1 **C.gchar

	arg1 = (*C.gchar)(C.CString(strArray))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_strdupv(arg1)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
		}
	}

	return ret0
}

// Strerror returns a string corresponding to the given error code, e.g. "no
// such process". Unlike strerror(), this always returns a string in UTF-8
// encoding, and the pointer is guaranteed to remain valid for the lifetime of
// the process.
//
// Note that the string may be translated according to the current locale.
//
// The value of errno will not be changed by this function. However, it may be
// changed by intermediate function calls, so you should save its value as soon
// as the call returns:
//
//      int saved_errno;
//
//      ret = read (blah);
//      saved_errno = errno;
//
//      g_strerror (saved_errno);
func Strerror(errnum int) string {
	var arg1 C.gint

	arg1 = C.gint(errnum)

	ret := C.g_strerror(arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Strescape escapes the special characters '\b', '\f', '\n', '\r', '\t', '\v',
// '\' and '"' in the string @source by inserting a '\' before them.
// Additionally all characters in the range 0x01-0x1F (everything below SPACE)
// and in the range 0x7F-0xFF (all non-ASCII chars) are replaced with a '\'
// followed by their octal representation. Characters supplied in @exceptions
// are not escaped.
//
// g_strcompress() does the reverse conversion.
func Strescape(source string, exceptions string) string {
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg1 = (*C.gchar)(C.CString(source))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(exceptions))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_strescape(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Strfreev frees a nil-terminated array of strings, as well as each string it
// contains.
//
// If @str_array is nil, this function simply returns.
func Strfreev(strArray string) {
	var arg1 **C.gchar

	arg1 = (*C.gchar)(C.CString(strArray))
	defer C.free(unsafe.Pointer(arg1))

	C.g_strfreev(arg1)
}

// Strjoinv joins a number of strings together to form one long string, with the
// optional @separator inserted between each of them. The returned string should
// be freed with g_free().
//
// If @str_array has no items, the return value will be an empty string. If
// @str_array contains a single item, @separator will not appear in the
// resulting string.
func Strjoinv(separator string, strArray string) string {
	var arg1 *C.gchar
	var arg2 **C.gchar

	arg1 = (*C.gchar)(C.CString(separator))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(strArray))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_strjoinv(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Strlcat: portability wrapper that calls strlcat() on systems which have it,
// and emulates it otherwise. Appends nul-terminated @src string to @dest,
// guaranteeing nul-termination for @dest. The total size of @dest won't exceed
// @dest_size.
//
// At most @dest_size - 1 characters will be copied. Unlike strncat(),
// @dest_size is the full size of dest, not the space left over. This function
// does not allocate memory. It always nul-terminates (unless @dest_size == 0 or
// there were no nul characters in the @dest_size characters of dest to start
// with).
//
// Caveat: this is supposedly a more secure alternative to strcat() or
// strncat(), but for real security g_strconcat() is harder to mess up.
func Strlcat(dest string, src string, destSize uint) uint {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 C.gsize

	arg1 = (*C.gchar)(C.CString(dest))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(src))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.gsize(destSize)

	ret := C.g_strlcat(arg1, arg2, arg3)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Strlcpy: portability wrapper that calls strlcpy() on systems which have it,
// and emulates strlcpy() otherwise. Copies @src to @dest; @dest is guaranteed
// to be nul-terminated; @src must be nul-terminated; @dest_size is the buffer
// size, not the number of bytes to copy.
//
// At most @dest_size - 1 characters will be copied. Always nul-terminates
// (unless @dest_size is 0). This function does not allocate memory. Unlike
// strncpy(), this function doesn't pad @dest (so it's often faster). It returns
// the size of the attempted result, strlen (src), so if @retval >= @dest_size,
// truncation occurred.
//
// Caveat: strlcpy() is supposedly more secure than strcpy() or strncpy(), but
// if you really want to avoid screwups, g_strdup() is an even better idea.
func Strlcpy(dest string, src string, destSize uint) uint {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 C.gsize

	arg1 = (*C.gchar)(C.CString(dest))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(src))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.gsize(destSize)

	ret := C.g_strlcpy(arg1, arg2, arg3)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Strncasecmp: a case-insensitive string comparison, corresponding to the
// standard strncasecmp() function on platforms which support it. It is similar
// to g_strcasecmp() except it only compares the first @n characters of the
// strings.
func Strncasecmp(s1 string, s2 string, n uint) int {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 C.guint

	arg1 = (*C.gchar)(C.CString(s1))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(s2))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.guint(n)

	ret := C.g_strncasecmp(arg1, arg2, arg3)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Strndup duplicates the first @n bytes of a string, returning a
// newly-allocated buffer @n + 1 bytes long which will always be nul-terminated.
// If @str is less than @n bytes long the buffer is padded with nuls. If @str is
// nil it returns nil. The returned value should be freed when no longer needed.
//
// To copy a number of characters from a UTF-8 encoded string, use
// g_utf8_strncpy() instead.
func Strndup(str string, n uint) string {
	var arg1 *C.gchar
	var arg2 C.gsize

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gsize(n)

	ret := C.g_strndup(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Strnfill creates a new string @length bytes long filled with @fill_char. The
// returned string should be freed when no longer needed.
func Strnfill(length uint, fillChar byte) string {
	var arg1 C.gsize
	var arg2 C.gchar

	arg1 = C.gsize(length)
	arg2 = C.gchar(fillChar)

	ret := C.g_strnfill(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Strreverse reverses all of the bytes in a string. For example, `g_strreverse
// ("abcdef")` will result in "fedcba".
//
// Note that g_strreverse() doesn't work on UTF-8 strings containing multibyte
// characters. For that purpose, use g_utf8_strreverse().
func Strreverse(string string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_strreverse(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Strrstr searches the string @haystack for the last occurrence of the string
// @needle.
func Strrstr(haystack string, needle string) string {
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg1 = (*C.gchar)(C.CString(haystack))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(needle))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_strrstr(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// StrrstrLen searches the string @haystack for the last occurrence of the
// string @needle, limiting the length of the search to @haystack_len.
func StrrstrLen(haystack string, haystackLen int, needle string) string {
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 *C.gchar

	arg1 = (*C.gchar)(C.CString(haystack))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(haystackLen)
	arg3 = (*C.gchar)(C.CString(needle))
	defer C.free(unsafe.Pointer(arg3))

	ret := C.g_strrstr_len(arg1, arg2, arg3)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Strsignal returns a string describing the given signal, e.g. "Segmentation
// fault". You should use this function in preference to strsignal(), because it
// returns a string in UTF-8 encoding, and since not all platforms support the
// strsignal() function.
func Strsignal(signum int) string {
	var arg1 C.gint

	arg1 = C.gint(signum)

	ret := C.g_strsignal(arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Strsplit splits a string into a maximum of @max_tokens pieces, using the
// given @delimiter. If @max_tokens is reached, the remainder of @string is
// appended to the last token.
//
// As an example, the result of g_strsplit (":a:bc::d:", ":", -1) is a
// nil-terminated vector containing the six strings "", "a", "bc", "", "d" and
// "".
//
// As a special case, the result of splitting the empty string "" is an empty
// vector, not a vector containing a single string. The reason for this special
// case is that being able to represent an empty vector is typically more useful
// than consistent handling of empty elements. If you do need to represent empty
// elements, you'll need to check for the empty string before calling
// g_strsplit().
func Strsplit(string string, delimiter string, maxTokens int) []string {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 C.gint

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(delimiter))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.gint(maxTokens)

	ret := C.g_strsplit(arg1, arg2, arg3)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
		}
	}

	return ret0
}

// StrsplitSet splits @string into a number of tokens not containing any of the
// characters in @delimiter. A token is the (possibly empty) longest string that
// does not contain any of the characters in @delimiters. If @max_tokens is
// reached, the remainder is appended to the last token.
//
// For example the result of g_strsplit_set ("abc:def/ghi", ":/", -1) is a
// nil-terminated vector containing the three strings "abc", "def", and "ghi".
//
// The result of g_strsplit_set (":def/ghi:", ":/", -1) is a nil-terminated
// vector containing the four strings "", "def", "ghi", and "".
//
// As a special case, the result of splitting the empty string "" is an empty
// vector, not a vector containing a single string. The reason for this special
// case is that being able to represent an empty vector is typically more useful
// than consistent handling of empty elements. If you do need to represent empty
// elements, you'll need to check for the empty string before calling
// g_strsplit_set().
//
// Note that this function works on bytes not characters, so it can't be used to
// delimit UTF-8 strings for anything but ASCII characters.
func StrsplitSet(string string, delimiters string, maxTokens int) []string {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 C.gint

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(delimiters))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.gint(maxTokens)

	ret := C.g_strsplit_set(arg1, arg2, arg3)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
		}
	}

	return ret0
}

// StrstrLen searches the string @haystack for the first occurrence of the
// string @needle, limiting the length of the search to @haystack_len.
func StrstrLen(haystack string, haystackLen int, needle string) string {
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 *C.gchar

	arg1 = (*C.gchar)(C.CString(haystack))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(haystackLen)
	arg3 = (*C.gchar)(C.CString(needle))
	defer C.free(unsafe.Pointer(arg3))

	ret := C.g_strstr_len(arg1, arg2, arg3)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Strtod converts a string to a #gdouble value. It calls the standard strtod()
// function to handle the conversion, but if the string is not completely
// converted it attempts the conversion again with g_ascii_strtod(), and returns
// the best match.
//
// This function should seldom be used. The normal situation when reading
// numbers not for human consumption is to use g_ascii_strtod(). Only when you
// know that you must expect both locale formatted and C formatted numbers
// should you use this. Make sure that you don't pass strings such as comma
// separated lists of values, since the commas may be interpreted as a decimal
// point in some locales, causing unexpected results.
func Strtod(nptr string) (endptr string, gdouble float64) {
	var arg1 *C.gchar
	var arg2 **C.gchar // out

	arg1 = (*C.gchar)(C.CString(nptr))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_strtod(arg1, &arg2)

	var ret0 string
	var ret1 float64

	ret0 = C.GoString(arg2)

	ret1 = float64(ret)

	return ret0, ret1
}

// Strup converts a string to upper case.
func Strup(string string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_strup(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// StrvContains checks if @strv contains @str. @strv must not be nil.
func StrvContains(strv string, str string) bool {
	var arg1 **C.gchar
	var arg2 *C.gchar

	arg1 = (*C.gchar)(C.CString(strv))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_strv_contains(arg1, arg2)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// StrvEqual checks if @strv1 and @strv2 contain exactly the same elements in
// exactly the same order. Elements are compared using g_str_equal(). To match
// independently of order, sort the arrays first (using g_qsort_with_data() or
// similar).
//
// Two empty arrays are considered equal. Neither @strv1 not @strv2 may be nil.
func StrvEqual(strv1 string, strv2 string) bool {
	var arg1 **C.gchar
	var arg2 **C.gchar

	arg1 = (*C.gchar)(C.CString(strv1))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(strv2))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_strv_equal(arg1, arg2)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// StrvLength returns the length of the given nil-terminated string array
// @str_array. @str_array must not be nil.
func StrvLength(strArray string) uint {
	var arg1 **C.gchar

	arg1 = (*C.gchar)(C.CString(strArray))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_strv_length(arg1)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}
