// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"unsafe"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib.h>
import "C"

// Usleep pauses the current thread for the given number of microseconds.
//
// There are 1 million microseconds per second (represented by the USEC_PER_SEC
// macro). g_usleep() may have limited precision, depending on hardware and
// operating system; don't rely on the exact length of the sleep.
func Usleep(microseconds uint32) {
	var _arg1 C.gulong // out

	_arg1 = (C.gulong)(microseconds)

	C.g_usleep(_arg1)
}

// Timer: opaque datatype that records a start time.
type Timer struct {
	native C.GTimer
}

// WrapTimer wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTimer(ptr unsafe.Pointer) *Timer {
	if ptr == nil {
		return nil
	}

	return (*Timer)(ptr)
}

// Native returns the underlying C source pointer.
func (t *Timer) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// Continue resumes a timer that has previously been stopped with
// g_timer_stop(). g_timer_stop() must be called before using this function.
func (t *Timer) Continue() {
	var _arg0 *C.GTimer // out

	_arg0 = (*C.GTimer)(unsafe.Pointer(t.Native()))

	C.g_timer_continue(_arg0)
}

// Destroy destroys a timer, freeing associated resources.
func (t *Timer) Destroy() {
	var _arg0 *C.GTimer // out

	_arg0 = (*C.GTimer)(unsafe.Pointer(t.Native()))

	C.g_timer_destroy(_arg0)
}

// Elapsed: if @timer has been started but not stopped, obtains the time since
// the timer was started. If @timer has been stopped, obtains the elapsed time
// between the time it was started and the time it was stopped. The return value
// is the number of seconds elapsed, including any fractional part. The
// @microseconds out parameter is essentially useless.
func (t *Timer) Elapsed(microseconds *uint32) float64 {
	var _arg0 *C.GTimer // out
	var _arg1 *C.gulong // out
	var _cret C.gdouble // in

	_arg0 = (*C.GTimer)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.gulong)(microseconds)

	_cret = C.g_timer_elapsed(_arg0, _arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// IsActive exposes whether the timer is currently active.
func (t *Timer) IsActive() bool {
	var _arg0 *C.GTimer  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GTimer)(unsafe.Pointer(t.Native()))

	_cret = C.g_timer_is_active(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Reset: this function is useless; it's fine to call g_timer_start() on an
// already-started timer to reset the start time, so g_timer_reset() serves no
// purpose.
func (t *Timer) Reset() {
	var _arg0 *C.GTimer // out

	_arg0 = (*C.GTimer)(unsafe.Pointer(t.Native()))

	C.g_timer_reset(_arg0)
}

// Start marks a start time, so that future calls to g_timer_elapsed() will
// report the time since g_timer_start() was called. g_timer_new() automatically
// marks the start time, so no need to call g_timer_start() immediately after
// creating the timer.
func (t *Timer) Start() {
	var _arg0 *C.GTimer // out

	_arg0 = (*C.GTimer)(unsafe.Pointer(t.Native()))

	C.g_timer_start(_arg0)
}

// Stop marks an end time, so calls to g_timer_elapsed() will return the
// difference between this end time and the start time.
func (t *Timer) Stop() {
	var _arg0 *C.GTimer // out

	_arg0 = (*C.GTimer)(unsafe.Pointer(t.Native()))

	C.g_timer_stop(_arg0)
}
