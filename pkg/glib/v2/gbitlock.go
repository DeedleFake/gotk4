// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"github.com/diamondburned/gotk4/internal/box"
)

// #cgo pkg-config: glib-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib.h>
import "C"

// BitLock sets the indicated @lock_bit in @address. If the bit is already set,
// this call will block until g_bit_unlock() unsets the corresponding bit.
//
// Attempting to lock on two different bits within the same integer is not
// supported and will very probably cause deadlocks.
//
// The value of the bit that is set is (1u << @bit). If @bit is not between 0
// and 31 then the result is undefined.
//
// This function accesses @address atomically. All other accesses to @address
// must be atomic in order for this function to work reliably.
func BitLock(address int, lockBit int) {
	var arg1 *C.gint
	var arg2 C.gint

	arg1 = (*C.gint)(address)
	arg2 = C.gint(lockBit)

	C.g_bit_lock(arg1, arg2)
}

// BitTrylock sets the indicated @lock_bit in @address, returning true if
// successful. If the bit is already set, returns false immediately.
//
// Attempting to lock on two different bits within the same integer is not
// supported.
//
// The value of the bit that is set is (1u << @bit). If @bit is not between 0
// and 31 then the result is undefined.
//
// This function accesses @address atomically. All other accesses to @address
// must be atomic in order for this function to work reliably.
func BitTrylock(address int, lockBit int) bool {
	var arg1 *C.gint
	var arg2 C.gint

	arg1 = (*C.gint)(address)
	arg2 = C.gint(lockBit)

	ret := C.g_bit_trylock(arg1, arg2)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// BitUnlock clears the indicated @lock_bit in @address. If another thread is
// currently blocked in g_bit_lock() on this same bit then it will be woken up.
//
// This function accesses @address atomically. All other accesses to @address
// must be atomic in order for this function to work reliably.
func BitUnlock(address int, lockBit int) {
	var arg1 *C.gint
	var arg2 C.gint

	arg1 = (*C.gint)(address)
	arg2 = C.gint(lockBit)

	C.g_bit_unlock(arg1, arg2)
}

// PointerBitLock: this is equivalent to g_bit_lock, but working on pointers (or
// other pointer-sized values).
//
// For portability reasons, you may only lock on the bottom 32 bits of the
// pointer.
func PointerBitLock(address interface{}, lockBit int) {
	var arg1 *C.void
	var arg2 C.gint

	arg1 = C.gpointer(box.Assign(address))
	arg2 = C.gint(lockBit)

	C.g_pointer_bit_lock(arg1, arg2)
}

// PointerBitTrylock: this is equivalent to g_bit_trylock, but working on
// pointers (or other pointer-sized values).
//
// For portability reasons, you may only lock on the bottom 32 bits of the
// pointer.
func PointerBitTrylock(address interface{}, lockBit int) bool {
	var arg1 *C.void
	var arg2 C.gint

	arg1 = C.gpointer(box.Assign(address))
	arg2 = C.gint(lockBit)

	ret := C.g_pointer_bit_trylock(arg1, arg2)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// PointerBitUnlock: this is equivalent to g_bit_unlock, but working on pointers
// (or other pointer-sized values).
//
// For portability reasons, you may only lock on the bottom 32 bits of the
// pointer.
func PointerBitUnlock(address interface{}, lockBit int) {
	var arg1 *C.void
	var arg2 C.gint

	arg1 = C.gpointer(box.Assign(address))
	arg2 = C.gint(lockBit)

	C.g_pointer_bit_unlock(arg1, arg2)
}
