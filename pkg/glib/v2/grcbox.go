// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"github.com/diamondburned/gotk4/internal/box"
)

// #cgo pkg-config: glib-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib.h>
import "C"

// AtomicRCBoxAcquire: atomically acquires a reference on the data pointed by
// @mem_block.
func AtomicRCBoxAcquire(memBlock interface{}) interface{} {
	var arg1 C.gpointer

	arg1 = C.gpointer(box.Assign(memBlock))

	ret := C.g_atomic_rc_box_acquire(arg1)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// AtomicRCBoxAlloc allocates @block_size bytes of memory, and adds atomic
// reference counting semantics to it.
//
// The data will be freed when its reference count drops to zero.
//
// The allocated data is guaranteed to be suitably aligned for any built-in
// type.
func AtomicRCBoxAlloc(blockSize uint) interface{} {
	var arg1 C.gsize

	arg1 = C.gsize(blockSize)

	ret := C.g_atomic_rc_box_alloc(arg1)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// AtomicRCBoxAlloc0 allocates @block_size bytes of memory, and adds atomic
// reference counting semantics to it.
//
// The contents of the returned data is set to zero.
//
// The data will be freed when its reference count drops to zero.
//
// The allocated data is guaranteed to be suitably aligned for any built-in
// type.
func AtomicRCBoxAlloc0(blockSize uint) interface{} {
	var arg1 C.gsize

	arg1 = C.gsize(blockSize)

	ret := C.g_atomic_rc_box_alloc0(arg1)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// AtomicRCBoxDup allocates a new block of data with atomic reference counting
// semantics, and copies @block_size bytes of @mem_block into it.
func AtomicRCBoxDup(blockSize uint, memBlock interface{}) interface{} {
	var arg1 C.gsize
	var arg2 C.gpointer

	arg1 = C.gsize(blockSize)
	arg2 = C.gpointer(box.Assign(memBlock))

	ret := C.g_atomic_rc_box_dup(arg1, arg2)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// AtomicRCBoxGetSize retrieves the size of the reference counted data pointed
// by @mem_block.
func AtomicRCBoxGetSize(memBlock interface{}) uint {
	var arg1 C.gpointer

	arg1 = C.gpointer(box.Assign(memBlock))

	ret := C.g_atomic_rc_box_get_size(arg1)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// AtomicRCBoxRelease: atomically releases a reference on the data pointed by
// @mem_block.
//
// If the reference was the last one, it will free the resources allocated for
// @mem_block.
func AtomicRCBoxRelease(memBlock interface{}) {
	var arg1 C.gpointer

	arg1 = C.gpointer(box.Assign(memBlock))

	C.g_atomic_rc_box_release(arg1)
}

// RCBoxAcquire acquires a reference on the data pointed by @mem_block.
func RCBoxAcquire(memBlock interface{}) interface{} {
	var arg1 C.gpointer

	arg1 = C.gpointer(box.Assign(memBlock))

	ret := C.g_rc_box_acquire(arg1)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// RCBoxAlloc allocates @block_size bytes of memory, and adds reference counting
// semantics to it.
//
// The data will be freed when its reference count drops to zero.
//
// The allocated data is guaranteed to be suitably aligned for any built-in
// type.
func RCBoxAlloc(blockSize uint) interface{} {
	var arg1 C.gsize

	arg1 = C.gsize(blockSize)

	ret := C.g_rc_box_alloc(arg1)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// RCBoxAlloc0 allocates @block_size bytes of memory, and adds reference
// counting semantics to it.
//
// The contents of the returned data is set to zero.
//
// The data will be freed when its reference count drops to zero.
//
// The allocated data is guaranteed to be suitably aligned for any built-in
// type.
func RCBoxAlloc0(blockSize uint) interface{} {
	var arg1 C.gsize

	arg1 = C.gsize(blockSize)

	ret := C.g_rc_box_alloc0(arg1)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// RCBoxDup allocates a new block of data with reference counting semantics, and
// copies @block_size bytes of @mem_block into it.
func RCBoxDup(blockSize uint, memBlock interface{}) interface{} {
	var arg1 C.gsize
	var arg2 C.gpointer

	arg1 = C.gsize(blockSize)
	arg2 = C.gpointer(box.Assign(memBlock))

	ret := C.g_rc_box_dup(arg1, arg2)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// RCBoxGetSize retrieves the size of the reference counted data pointed by
// @mem_block.
func RCBoxGetSize(memBlock interface{}) uint {
	var arg1 C.gpointer

	arg1 = C.gpointer(box.Assign(memBlock))

	ret := C.g_rc_box_get_size(arg1)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// RCBoxRelease releases a reference on the data pointed by @mem_block.
//
// If the reference was the last one, it will free the resources allocated for
// @mem_block.
func RCBoxRelease(memBlock interface{}) {
	var arg1 C.gpointer

	arg1 = C.gpointer(box.Assign(memBlock))

	C.g_rc_box_release(arg1)
}
