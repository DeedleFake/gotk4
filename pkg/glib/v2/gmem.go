// Code generated by girgen. DO NOT EDIT.

package glib

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib.h>
import "C"

// Free frees the memory pointed to by @mem.
//
// If @mem is nil it simply returns, so there is no need to check @mem against
// nil before calling this function.
func Free(mem interface{}) {
	var arg1 C.gpointer

	arg1 = C.gpointer(mem)

	C.g_free(mem)
}

// Malloc allocates @n_bytes bytes of memory. If @n_bytes is 0 it returns nil.
func Malloc(nBytes uint) interface{} {
	var arg1 C.gsize

	arg1 = C.gsize(nBytes)

	var cret C.gpointer
	var goret1 interface{}

	cret = C.g_malloc(nBytes)

	goret1 = C.gpointer(cret)

	return goret1
}

// Malloc0 allocates @n_bytes bytes of memory, initialized to 0's. If @n_bytes
// is 0 it returns nil.
func Malloc0(nBytes uint) interface{} {
	var arg1 C.gsize

	arg1 = C.gsize(nBytes)

	var cret C.gpointer
	var goret1 interface{}

	cret = C.g_malloc0(nBytes)

	goret1 = C.gpointer(cret)

	return goret1
}

// Malloc0N: this function is similar to g_malloc0(), allocating (@n_blocks *
// @n_block_bytes) bytes, but care is taken to detect possible overflow during
// multiplication.
func Malloc0N(nBlocks uint, nBlockBytes uint) interface{} {
	var arg1 C.gsize
	var arg2 C.gsize

	arg1 = C.gsize(nBlocks)
	arg2 = C.gsize(nBlockBytes)

	var cret C.gpointer
	var goret1 interface{}

	cret = C.g_malloc0_n(nBlocks, nBlockBytes)

	goret1 = C.gpointer(cret)

	return goret1
}

// MallocN: this function is similar to g_malloc(), allocating (@n_blocks *
// @n_block_bytes) bytes, but care is taken to detect possible overflow during
// multiplication.
func MallocN(nBlocks uint, nBlockBytes uint) interface{} {
	var arg1 C.gsize
	var arg2 C.gsize

	arg1 = C.gsize(nBlocks)
	arg2 = C.gsize(nBlockBytes)

	var cret C.gpointer
	var goret1 interface{}

	cret = C.g_malloc_n(nBlocks, nBlockBytes)

	goret1 = C.gpointer(cret)

	return goret1
}

// MemIsSystemMalloc checks whether the allocator used by g_malloc() is the
// system's malloc implementation. If it returns true memory allocated with
// malloc() can be used interchangeably with memory allocated using g_malloc().
// This function is useful for avoiding an extra copy of allocated memory
// returned by a non-GLib-based API.
func MemIsSystemMalloc() bool {
	var cret C.gboolean
	var goret1 bool

	cret = C.g_mem_is_system_malloc()

	goret1 = C.bool(cret) != C.false

	return goret1
}

// MemProfile: GLib used to support some tools for memory profiling, but this no
// longer works. There are many other useful tools for memory profiling these
// days which can be used instead.
func MemProfile() {
	C.g_mem_profile()
}

// Realloc reallocates the memory pointed to by @mem, so that it now has space
// for @n_bytes bytes of memory. It returns the new address of the memory, which
// may have been moved. @mem may be nil, in which case it's considered to have
// zero-length. @n_bytes may be 0, in which case nil will be returned and @mem
// will be freed unless it is nil.
func Realloc(mem interface{}, nBytes uint) interface{} {
	var arg1 C.gpointer
	var arg2 C.gsize

	arg1 = C.gpointer(mem)
	arg2 = C.gsize(nBytes)

	var cret C.gpointer
	var goret1 interface{}

	cret = C.g_realloc(mem, nBytes)

	goret1 = C.gpointer(cret)

	return goret1
}

// ReallocN: this function is similar to g_realloc(), allocating (@n_blocks *
// @n_block_bytes) bytes, but care is taken to detect possible overflow during
// multiplication.
func ReallocN(mem interface{}, nBlocks uint, nBlockBytes uint) interface{} {
	var arg1 C.gpointer
	var arg2 C.gsize
	var arg3 C.gsize

	arg1 = C.gpointer(mem)
	arg2 = C.gsize(nBlocks)
	arg3 = C.gsize(nBlockBytes)

	var cret C.gpointer
	var goret1 interface{}

	cret = C.g_realloc_n(mem, nBlocks, nBlockBytes)

	goret1 = C.gpointer(cret)

	return goret1
}

// TryMalloc attempts to allocate @n_bytes, and returns nil on failure. Contrast
// with g_malloc(), which aborts the program on failure.
func TryMalloc(nBytes uint) interface{} {
	var arg1 C.gsize

	arg1 = C.gsize(nBytes)

	var cret C.gpointer
	var goret1 interface{}

	cret = C.g_try_malloc(nBytes)

	goret1 = C.gpointer(cret)

	return goret1
}

// TryMalloc0 attempts to allocate @n_bytes, initialized to 0's, and returns nil
// on failure. Contrast with g_malloc0(), which aborts the program on failure.
func TryMalloc0(nBytes uint) interface{} {
	var arg1 C.gsize

	arg1 = C.gsize(nBytes)

	var cret C.gpointer
	var goret1 interface{}

	cret = C.g_try_malloc0(nBytes)

	goret1 = C.gpointer(cret)

	return goret1
}

// TryMalloc0N: this function is similar to g_try_malloc0(), allocating
// (@n_blocks * @n_block_bytes) bytes, but care is taken to detect possible
// overflow during multiplication.
func TryMalloc0N(nBlocks uint, nBlockBytes uint) interface{} {
	var arg1 C.gsize
	var arg2 C.gsize

	arg1 = C.gsize(nBlocks)
	arg2 = C.gsize(nBlockBytes)

	var cret C.gpointer
	var goret1 interface{}

	cret = C.g_try_malloc0_n(nBlocks, nBlockBytes)

	goret1 = C.gpointer(cret)

	return goret1
}

// TryMallocN: this function is similar to g_try_malloc(), allocating (@n_blocks
// * @n_block_bytes) bytes, but care is taken to detect possible overflow during
// multiplication.
func TryMallocN(nBlocks uint, nBlockBytes uint) interface{} {
	var arg1 C.gsize
	var arg2 C.gsize

	arg1 = C.gsize(nBlocks)
	arg2 = C.gsize(nBlockBytes)

	var cret C.gpointer
	var goret1 interface{}

	cret = C.g_try_malloc_n(nBlocks, nBlockBytes)

	goret1 = C.gpointer(cret)

	return goret1
}

// TryRealloc attempts to realloc @mem to a new size, @n_bytes, and returns nil
// on failure. Contrast with g_realloc(), which aborts the program on failure.
//
// If @mem is nil, behaves the same as g_try_malloc().
func TryRealloc(mem interface{}, nBytes uint) interface{} {
	var arg1 C.gpointer
	var arg2 C.gsize

	arg1 = C.gpointer(mem)
	arg2 = C.gsize(nBytes)

	var cret C.gpointer
	var goret1 interface{}

	cret = C.g_try_realloc(mem, nBytes)

	goret1 = C.gpointer(cret)

	return goret1
}

// TryReallocN: this function is similar to g_try_realloc(), allocating
// (@n_blocks * @n_block_bytes) bytes, but care is taken to detect possible
// overflow during multiplication.
func TryReallocN(mem interface{}, nBlocks uint, nBlockBytes uint) interface{} {
	var arg1 C.gpointer
	var arg2 C.gsize
	var arg3 C.gsize

	arg1 = C.gpointer(mem)
	arg2 = C.gsize(nBlocks)
	arg3 = C.gsize(nBlockBytes)

	var cret C.gpointer
	var goret1 interface{}

	cret = C.g_try_realloc_n(mem, nBlocks, nBlockBytes)

	goret1 = C.gpointer(cret)

	return goret1
}
