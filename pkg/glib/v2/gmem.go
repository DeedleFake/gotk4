// Code generated by girgen. DO NOT EDIT.

package glib

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib.h>
import "C"

// Free frees the memory pointed to by @mem.
//
// If @mem is nil it simply returns, so there is no need to check @mem against
// nil before calling this function.
func Free(mem interface{}) {
	var _arg1 C.gpointer

	_arg1 = C.gpointer(mem)

	C.g_free(_arg1)
}

// Malloc allocates @n_bytes bytes of memory. If @n_bytes is 0 it returns nil.
func Malloc(nBytes uint) interface{} {
	var _arg1 C.gsize

	_arg1 = C.gsize(nBytes)

	var _cret C.gpointer

	cret = C.g_malloc(_arg1)

	var _gpointer interface{}

	_gpointer = (interface{})(_cret)

	return _gpointer
}

// Malloc0 allocates @n_bytes bytes of memory, initialized to 0's. If @n_bytes
// is 0 it returns nil.
func Malloc0(nBytes uint) interface{} {
	var _arg1 C.gsize

	_arg1 = C.gsize(nBytes)

	var _cret C.gpointer

	cret = C.g_malloc0(_arg1)

	var _gpointer interface{}

	_gpointer = (interface{})(_cret)

	return _gpointer
}

// Malloc0N: this function is similar to g_malloc0(), allocating (@n_blocks *
// @n_block_bytes) bytes, but care is taken to detect possible overflow during
// multiplication.
func Malloc0N(nBlocks uint, nBlockBytes uint) interface{} {
	var _arg1 C.gsize
	var _arg2 C.gsize

	_arg1 = C.gsize(nBlocks)
	_arg2 = C.gsize(nBlockBytes)

	var _cret C.gpointer

	cret = C.g_malloc0_n(_arg1, _arg2)

	var _gpointer interface{}

	_gpointer = (interface{})(_cret)

	return _gpointer
}

// MallocN: this function is similar to g_malloc(), allocating (@n_blocks *
// @n_block_bytes) bytes, but care is taken to detect possible overflow during
// multiplication.
func MallocN(nBlocks uint, nBlockBytes uint) interface{} {
	var _arg1 C.gsize
	var _arg2 C.gsize

	_arg1 = C.gsize(nBlocks)
	_arg2 = C.gsize(nBlockBytes)

	var _cret C.gpointer

	cret = C.g_malloc_n(_arg1, _arg2)

	var _gpointer interface{}

	_gpointer = (interface{})(_cret)

	return _gpointer
}

// MemIsSystemMalloc checks whether the allocator used by g_malloc() is the
// system's malloc implementation. If it returns true memory allocated with
// malloc() can be used interchangeably with memory allocated using g_malloc().
// This function is useful for avoiding an extra copy of allocated memory
// returned by a non-GLib-based API.
func MemIsSystemMalloc() bool {
	var _cret C.gboolean

	cret = C.g_mem_is_system_malloc()

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// MemProfile: GLib used to support some tools for memory profiling, but this no
// longer works. There are many other useful tools for memory profiling these
// days which can be used instead.
func MemProfile() {
	C.g_mem_profile()
}

// Realloc reallocates the memory pointed to by @mem, so that it now has space
// for @n_bytes bytes of memory. It returns the new address of the memory, which
// may have been moved. @mem may be nil, in which case it's considered to have
// zero-length. @n_bytes may be 0, in which case nil will be returned and @mem
// will be freed unless it is nil.
func Realloc(mem interface{}, nBytes uint) interface{} {
	var _arg1 C.gpointer
	var _arg2 C.gsize

	_arg1 = C.gpointer(mem)
	_arg2 = C.gsize(nBytes)

	var _cret C.gpointer

	cret = C.g_realloc(_arg1, _arg2)

	var _gpointer interface{}

	_gpointer = (interface{})(_cret)

	return _gpointer
}

// ReallocN: this function is similar to g_realloc(), allocating (@n_blocks *
// @n_block_bytes) bytes, but care is taken to detect possible overflow during
// multiplication.
func ReallocN(mem interface{}, nBlocks uint, nBlockBytes uint) interface{} {
	var _arg1 C.gpointer
	var _arg2 C.gsize
	var _arg3 C.gsize

	_arg1 = C.gpointer(mem)
	_arg2 = C.gsize(nBlocks)
	_arg3 = C.gsize(nBlockBytes)

	var _cret C.gpointer

	cret = C.g_realloc_n(_arg1, _arg2, _arg3)

	var _gpointer interface{}

	_gpointer = (interface{})(_cret)

	return _gpointer
}

// TryMalloc attempts to allocate @n_bytes, and returns nil on failure. Contrast
// with g_malloc(), which aborts the program on failure.
func TryMalloc(nBytes uint) interface{} {
	var _arg1 C.gsize

	_arg1 = C.gsize(nBytes)

	var _cret C.gpointer

	cret = C.g_try_malloc(_arg1)

	var _gpointer interface{}

	_gpointer = (interface{})(_cret)

	return _gpointer
}

// TryMalloc0 attempts to allocate @n_bytes, initialized to 0's, and returns nil
// on failure. Contrast with g_malloc0(), which aborts the program on failure.
func TryMalloc0(nBytes uint) interface{} {
	var _arg1 C.gsize

	_arg1 = C.gsize(nBytes)

	var _cret C.gpointer

	cret = C.g_try_malloc0(_arg1)

	var _gpointer interface{}

	_gpointer = (interface{})(_cret)

	return _gpointer
}

// TryMalloc0N: this function is similar to g_try_malloc0(), allocating
// (@n_blocks * @n_block_bytes) bytes, but care is taken to detect possible
// overflow during multiplication.
func TryMalloc0N(nBlocks uint, nBlockBytes uint) interface{} {
	var _arg1 C.gsize
	var _arg2 C.gsize

	_arg1 = C.gsize(nBlocks)
	_arg2 = C.gsize(nBlockBytes)

	var _cret C.gpointer

	cret = C.g_try_malloc0_n(_arg1, _arg2)

	var _gpointer interface{}

	_gpointer = (interface{})(_cret)

	return _gpointer
}

// TryMallocN: this function is similar to g_try_malloc(), allocating (@n_blocks
// * @n_block_bytes) bytes, but care is taken to detect possible overflow during
// multiplication.
func TryMallocN(nBlocks uint, nBlockBytes uint) interface{} {
	var _arg1 C.gsize
	var _arg2 C.gsize

	_arg1 = C.gsize(nBlocks)
	_arg2 = C.gsize(nBlockBytes)

	var _cret C.gpointer

	cret = C.g_try_malloc_n(_arg1, _arg2)

	var _gpointer interface{}

	_gpointer = (interface{})(_cret)

	return _gpointer
}

// TryRealloc attempts to realloc @mem to a new size, @n_bytes, and returns nil
// on failure. Contrast with g_realloc(), which aborts the program on failure.
//
// If @mem is nil, behaves the same as g_try_malloc().
func TryRealloc(mem interface{}, nBytes uint) interface{} {
	var _arg1 C.gpointer
	var _arg2 C.gsize

	_arg1 = C.gpointer(mem)
	_arg2 = C.gsize(nBytes)

	var _cret C.gpointer

	cret = C.g_try_realloc(_arg1, _arg2)

	var _gpointer interface{}

	_gpointer = (interface{})(_cret)

	return _gpointer
}

// TryReallocN: this function is similar to g_try_realloc(), allocating
// (@n_blocks * @n_block_bytes) bytes, but care is taken to detect possible
// overflow during multiplication.
func TryReallocN(mem interface{}, nBlocks uint, nBlockBytes uint) interface{} {
	var _arg1 C.gpointer
	var _arg2 C.gsize
	var _arg3 C.gsize

	_arg1 = C.gpointer(mem)
	_arg2 = C.gsize(nBlocks)
	_arg3 = C.gsize(nBlockBytes)

	var _cret C.gpointer

	cret = C.g_try_realloc_n(_arg1, _arg2, _arg3)

	var _gpointer interface{}

	_gpointer = (interface{})(_cret)

	return _gpointer
}
