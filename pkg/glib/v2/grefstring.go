// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"unsafe"
)

// #cgo pkg-config: glib-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib.h>
import "C"

// RefString: a typedef for a reference-counted string. A pointer to a String
// can be treated like a standard `char*` array by all code, but can
// additionally have `g_ref_string_*()` methods called on it. `g_ref_string_*()`
// methods cannot be called on `char*` arrays not allocated using
// g_ref_string_new().
//
// If using String with autocleanups, g_autoptr() must be used rather than
// g_autofree(), so that the reference counting metadata is also freed.
type RefString byte

// RefStringAcquire acquires a reference on a string.
func RefStringAcquire(str string) string {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_ref_string_acquire(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// RefStringLength retrieves the length of @str.
func RefStringLength(str string) uint {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_ref_string_length(arg1)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// NewRefString creates a new reference counted string and copies the contents
// of @str into it.
func NewRefString(str string) string {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_ref_string_new(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// RefStringNewIntern creates a new reference counted string and copies the
// content of @str into it.
//
// If you call this function multiple times with the same @str, or with the same
// contents of @str, it will return a new reference, instead of creating a new
// string.
func RefStringNewIntern(str string) string {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_ref_string_new_intern(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// RefStringNewLen creates a new reference counted string and copies the
// contents of @str into it, up to @len bytes.
//
// Since this function does not stop at nul bytes, it is the caller's
// responsibility to ensure that @str has at least @len addressable bytes.
func RefStringNewLen(str string, len int) string {
	var arg1 *C.char
	var arg2 C.gssize

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(len)

	ret := C.g_ref_string_new_len(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// RefStringRelease releases a reference on a string; if it was the last
// reference, the resources allocated by the string are freed as well.
func RefStringRelease(str string) {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	C.g_ref_string_release(arg1)
}
