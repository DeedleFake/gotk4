// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"unsafe"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib.h>
import "C"

// RefString: a typedef for a reference-counted string. A pointer to a String
// can be treated like a standard `char*` array by all code, but can
// additionally have `g_ref_string_*()` methods called on it. `g_ref_string_*()`
// methods cannot be called on `char*` arrays not allocated using
// g_ref_string_new().
//
// If using String with autocleanups, g_autoptr() must be used rather than
// g_autofree(), so that the reference counting metadata is also freed.
type RefString byte

// RefStringAcquire acquires a reference on a string.
func RefStringAcquire(str string) string {
	var arg1 *C.char

	arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.char
	var ret1 string

	cret = C.g_ref_string_acquire(str)

	ret1 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return ret1
}

// RefStringLength retrieves the length of @str.
func RefStringLength(str string) uint {
	var arg1 *C.char

	arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.gsize
	var ret1 uint

	cret = C.g_ref_string_length(str)

	ret1 = C.gsize(cret)

	return ret1
}

// NewRefString creates a new reference counted string and copies the contents
// of @str into it.
func NewRefString(str string) string {
	var arg1 *C.char

	arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.char
	var ret1 string

	cret = C.g_ref_string_new(str)

	ret1 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return ret1
}

// RefStringNewIntern creates a new reference counted string and copies the
// content of @str into it.
//
// If you call this function multiple times with the same @str, or with the same
// contents of @str, it will return a new reference, instead of creating a new
// string.
func RefStringNewIntern(str string) string {
	var arg1 *C.char

	arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.char
	var ret1 string

	cret = C.g_ref_string_new_intern(str)

	ret1 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return ret1
}

// RefStringNewLen creates a new reference counted string and copies the
// contents of @str into it, up to @len bytes.
//
// Since this function does not stop at nul bytes, it is the caller's
// responsibility to ensure that @str has at least @len addressable bytes.
func RefStringNewLen(str string, len int) string {
	var arg1 *C.char
	var arg2 C.gssize

	arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(len)

	var cret *C.char
	var ret1 string

	cret = C.g_ref_string_new_len(str, len)

	ret1 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return ret1
}

// RefStringRelease releases a reference on a string; if it was the last
// reference, the resources allocated by the string are freed as well.
func RefStringRelease(str string) {
	var arg1 *C.char

	arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	C.g_ref_string_release(str)
}
