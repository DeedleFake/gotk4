// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"runtime"
	"unsafe"
)

// #cgo pkg-config: glib-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <glib.h>
import "C"

// ComputeHMACForBytes computes the HMAC for a binary @data. This is a
// convenience wrapper for g_hmac_new(), g_hmac_get_string() and g_hmac_unref().
//
// The hexadecimal string returned will be in lower case.
func ComputeHMACForBytes(digestType ChecksumType, key *Bytes, data *Bytes) string {
	var arg1 C.GChecksumType
	var arg2 *C.GBytes
	var arg3 *C.GBytes

	arg1 = (C.GChecksumType)(digestType)
	arg2 = (*C.GBytes)(key.Native())
	arg3 = (*C.GBytes)(data.Native())

	ret := C.g_compute_hmac_for_bytes(arg1, arg2, arg3)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// ComputeHMACForData computes the HMAC for a binary @data of @length. This is a
// convenience wrapper for g_hmac_new(), g_hmac_get_string() and g_hmac_unref().
//
// The hexadecimal string returned will be in lower case.
func ComputeHMACForData(digestType ChecksumType, key []byte, data []byte) string {
	var arg1 C.GChecksumType
	var arg2 *C.guchar
	var arg3 C.gsize
	var arg4 *C.guchar
	var arg5 C.gsize

	arg1 = (C.GChecksumType)(digestType)
	arg2 = (*C.guchar)(unsafe.Pointer(&key[0]))
	arg3 = len(key)
	defer runtime.KeepAlive(key)
	arg4 = (*C.guchar)(unsafe.Pointer(&data[0]))
	arg5 = len(data)
	defer runtime.KeepAlive(data)

	ret := C.g_compute_hmac_for_data(arg1, arg2, arg3, arg4, arg5)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// ComputeHMACForString computes the HMAC for a string.
//
// The hexadecimal string returned will be in lower case.
func ComputeHMACForString(digestType ChecksumType, key []byte, str string, length int) string {
	var arg1 C.GChecksumType
	var arg2 *C.guchar
	var arg3 C.gsize
	var arg4 *C.gchar
	var arg5 C.gssize

	arg1 = (C.GChecksumType)(digestType)
	arg2 = (*C.guchar)(unsafe.Pointer(&key[0]))
	arg3 = len(key)
	defer runtime.KeepAlive(key)
	arg4 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = C.gssize(length)

	ret := C.g_compute_hmac_for_string(arg1, arg2, arg3, arg4, arg5)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// HMAC: an opaque structure representing a HMAC operation. To create a new
// GHmac, use g_hmac_new(). To free a GHmac, use g_hmac_unref().
type HMAC struct {
	native C.GHmac
}

// WrapHMAC wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapHMAC(ptr unsafe.Pointer) *HMAC {
	if ptr == nil {
		return nil
	}

	return (*HMAC)(ptr)
}

func marshalHMAC(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapHMAC(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (h *HMAC) Native() unsafe.Pointer {
	return unsafe.Pointer(&h.native)
}

// Copy copies a #GHmac. If @hmac has been closed, by calling
// g_hmac_get_string() or g_hmac_get_digest(), the copied HMAC will be closed as
// well.
func (h *HMAC) Copy() *HMAC {
	var arg0 *C.GHmac

	arg0 = (*C.GHmac)(h.Native())

	ret := C.g_hmac_copy(arg0)

	var ret0 *HMAC

	{
		ret0 = WrapHMAC(unsafe.Pointer(ret))
	}

	return ret0
}

// Digest gets the digest from @checksum as a raw binary array and places it
// into @buffer. The size of the digest depends on the type of checksum.
//
// Once this function has been called, the #GHmac is closed and can no longer be
// updated with g_checksum_update().
func (h *HMAC) Digest(buffer []byte) {
	var arg0 *C.GHmac
	var arg1 *C.guint8
	var arg2 *C.gsize

	arg0 = (*C.GHmac)(h.Native())
	arg1 = (*C.guint8)(unsafe.Pointer(&buffer[0]))
	arg2 = len(buffer)
	defer runtime.KeepAlive(buffer)

	C.g_hmac_get_digest(arg0, arg1, arg2)
}

// String gets the HMAC as a hexadecimal string.
//
// Once this function has been called the #GHmac can no longer be updated with
// g_hmac_update().
//
// The hexadecimal characters will be lower case.
func (h *HMAC) String() string {
	var arg0 *C.GHmac

	arg0 = (*C.GHmac)(h.Native())

	ret := C.g_hmac_get_string(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Ref: atomically increments the reference count of @hmac by one.
//
// This function is MT-safe and may be called from any thread.
func (h *HMAC) Ref() *HMAC {
	var arg0 *C.GHmac

	arg0 = (*C.GHmac)(h.Native())

	ret := C.g_hmac_ref(arg0)

	var ret0 *HMAC

	{
		ret0 = WrapHMAC(unsafe.Pointer(ret))
	}

	return ret0
}

// Unref: atomically decrements the reference count of @hmac by one.
//
// If the reference count drops to 0, all keys and values will be destroyed, and
// all memory allocated by the hash table is released. This function is MT-safe
// and may be called from any thread. Frees the memory allocated for @hmac.
func (h *HMAC) Unref() {
	var arg0 *C.GHmac

	arg0 = (*C.GHmac)(h.Native())

	C.g_hmac_unref(arg0)
}

// Update feeds @data into an existing #GHmac.
//
// The HMAC must still be open, that is g_hmac_get_string() or
// g_hmac_get_digest() must not have been called on @hmac.
func (h *HMAC) Update(data []byte) {
	var arg0 *C.GHmac
	var arg1 *C.guchar
	var arg2 C.gssize

	arg0 = (*C.GHmac)(h.Native())
	arg1 = (*C.guchar)(unsafe.Pointer(&data[0]))
	arg2 = len(data)
	defer runtime.KeepAlive(data)

	C.g_hmac_update(arg0, arg1, arg2)
}
