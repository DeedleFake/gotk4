// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0 glib-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <glib.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_io_channel_get_type()), F: marshalIOChannel},
	})
}

// IOChannelError: error codes returned by OChannel operations.
type IOChannelError int

const (
	// IOChannelErrorFbig: file too large.
	IOChannelErrorFbig IOChannelError = 0
	// IOChannelErrorInval: invalid argument.
	IOChannelErrorInval IOChannelError = 1
	// IOChannelErrorIO: IO error.
	IOChannelErrorIO IOChannelError = 2
	// IOChannelErrorIsdir: file is a directory.
	IOChannelErrorIsdir IOChannelError = 3
	// IOChannelErrorNospc: no space left on device.
	IOChannelErrorNospc IOChannelError = 4
	// IOChannelErrorNxio: no such device or address.
	IOChannelErrorNxio IOChannelError = 5
	// IOChannelErrorOverflow: value too large for defined datatype.
	IOChannelErrorOverflow IOChannelError = 6
	// IOChannelErrorPipe: broken pipe.
	IOChannelErrorPipe IOChannelError = 7
	// IOChannelErrorFailed: some other error.
	IOChannelErrorFailed IOChannelError = 8
)

// IOError is only used by the deprecated functions g_io_channel_read(),
// g_io_channel_write(), and g_io_channel_seek().
type IOError int

const (
	// IOErrorNone: no error
	IOErrorNone IOError = 0
	// IOErrorAgain: an EAGAIN error occurred
	IOErrorAgain IOError = 1
	// IOErrorInval: an EINVAL error occurred
	IOErrorInval IOError = 2
	// IOErrorUnknown: another error occurred
	IOErrorUnknown IOError = 3
)

// IOStatus statuses returned by most of the OFuncs functions.
type IOStatus int

const (
	// IOStatusError: an error occurred.
	IOStatusError IOStatus = 0
	// IOStatusNormal: success.
	IOStatusNormal IOStatus = 1
	// IOStatusEOF: end of file.
	IOStatusEOF IOStatus = 2
	// IOStatusAgain: resource temporarily unavailable.
	IOStatusAgain IOStatus = 3
)

// SeekType: an enumeration specifying the base position for a
// g_io_channel_seek_position() operation.
type SeekType int

const (
	// SeekTypeCur: the current position in the file.
	SeekTypeCur SeekType = 0
	// SeekTypeSet: the start of the file.
	SeekTypeSet SeekType = 1
	// SeekTypeEnd: the end of the file.
	SeekTypeEnd SeekType = 2
)

// IOFlags specifies properties of a OChannel. Some of the flags can only be
// read with g_io_channel_get_flags(), but not changed with
// g_io_channel_set_flags().
type IOFlags int

const (
	// IOFlagsAppend turns on append mode, corresponds to O_APPEND (see the
	// documentation of the UNIX open() syscall)
	IOFlagsAppend IOFlags = 1
	// IOFlagsNonblock turns on nonblocking mode, corresponds to
	// O_NONBLOCK/O_NDELAY (see the documentation of the UNIX open() syscall)
	IOFlagsNonblock IOFlags = 2
	// IOFlagsIsReadable indicates that the io channel is readable. This flag
	// cannot be changed.
	IOFlagsIsReadable IOFlags = 4
	// IOFlagsIsWritable indicates that the io channel is writable. This flag
	// cannot be changed.
	IOFlagsIsWritable IOFlags = 8
	// IOFlagsIsWriteable: a misspelled version of @G_IO_FLAG_IS_WRITABLE that
	// existed before the spelling was fixed in GLib 2.30. It is kept here for
	// compatibility reasons. Deprecated since 2.30
	IOFlagsIsWriteable IOFlags = 8
	// IOFlagsIsSeekable indicates that the io channel is seekable, i.e. that
	// g_io_channel_seek_position() can be used on it. This flag cannot be
	// changed.
	IOFlagsIsSeekable IOFlags = 16
	// IOFlagsMask: the mask that specifies all the valid flags.
	IOFlagsMask IOFlags = 31
	// IOFlagsGetMask: the mask of the flags that are returned from
	// g_io_channel_get_flags()
	IOFlagsGetMask IOFlags = 31
	// IOFlagsSetMask: the mask of the flags that the user can modify with
	// g_io_channel_set_flags()
	IOFlagsSetMask IOFlags = 3
)

// IOChannel: a data structure representing an IO Channel. The fields should be
// considered private and should only be accessed with the following functions.
type IOChannel struct {
	native C.GIOChannel
}

// WrapIOChannel wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapIOChannel(ptr unsafe.Pointer) *IOChannel {
	if ptr == nil {
		return nil
	}

	return (*IOChannel)(ptr)
}

func marshalIOChannel(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapIOChannel(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (i *IOChannel) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

// Close: close an IO channel. Any pending data to be written will be flushed,
// ignoring errors. The channel will not be freed until the last reference is
// dropped using g_io_channel_unref().
func (c *IOChannel) Close() {
	var _arg0 *C.GIOChannel // out

	_arg0 = (*C.GIOChannel)(unsafe.Pointer(c.Native()))

	C.g_io_channel_close(_arg0)
}

// BufferSize gets the buffer size.
func (c *IOChannel) BufferSize() uint {
	var _arg0 *C.GIOChannel // out

	_arg0 = (*C.GIOChannel)(unsafe.Pointer(c.Native()))

	var _cret C.gsize // in

	_cret = C.g_io_channel_get_buffer_size(_arg0)

	var _gsize uint // out

	_gsize = (uint)(_cret)

	return _gsize
}

// Buffered returns whether @channel is buffered.
func (c *IOChannel) Buffered() bool {
	var _arg0 *C.GIOChannel // out

	_arg0 = (*C.GIOChannel)(unsafe.Pointer(c.Native()))

	var _cret C.gboolean // in

	_cret = C.g_io_channel_get_buffered(_arg0)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// CloseOnUnref returns whether the file/socket/whatever associated with
// @channel will be closed when @channel receives its final unref and is
// destroyed. The default value of this is true for channels created by
// g_io_channel_new_file (), and false for all other channels.
func (c *IOChannel) CloseOnUnref() bool {
	var _arg0 *C.GIOChannel // out

	_arg0 = (*C.GIOChannel)(unsafe.Pointer(c.Native()))

	var _cret C.gboolean // in

	_cret = C.g_io_channel_get_close_on_unref(_arg0)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Encoding gets the encoding for the input/output of the channel. The internal
// encoding is always UTF-8. The encoding nil makes the channel safe for binary
// data.
func (c *IOChannel) Encoding() string {
	var _arg0 *C.GIOChannel // out

	_arg0 = (*C.GIOChannel)(unsafe.Pointer(c.Native()))

	var _cret *C.gchar // in

	_cret = C.g_io_channel_get_encoding(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// LineTerm: this returns the string that OChannel uses to determine where in
// the file a line break occurs. A value of nil indicates autodetection.
func (c *IOChannel) LineTerm(length *int) string {
	var _arg0 *C.GIOChannel // out
	var _arg1 *C.gint       // out

	_arg0 = (*C.GIOChannel)(unsafe.Pointer(c.Native()))
	_arg1 = *C.gint(length)

	var _cret *C.gchar // in

	_cret = C.g_io_channel_get_line_term(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Init initializes a OChannel struct.
//
// This is called by each of the above functions when creating a OChannel, and
// so is not often needed by the application programmer (unless you are creating
// a new type of OChannel).
func (c *IOChannel) Init() {
	var _arg0 *C.GIOChannel // out

	_arg0 = (*C.GIOChannel)(unsafe.Pointer(c.Native()))

	C.g_io_channel_init(_arg0)
}

// SetBufferSize sets the buffer size.
func (c *IOChannel) SetBufferSize(size uint) {
	var _arg0 *C.GIOChannel // out
	var _arg1 C.gsize       // out

	_arg0 = (*C.GIOChannel)(unsafe.Pointer(c.Native()))
	_arg1 = C.gsize(size)

	C.g_io_channel_set_buffer_size(_arg0, _arg1)
}

// SetBuffered: the buffering state can only be set if the channel's encoding is
// nil. For any other encoding, the channel must be buffered.
//
// A buffered channel can only be set unbuffered if the channel's internal
// buffers have been flushed. Newly created channels or channels which have
// returned G_IO_STATUS_EOF not require such a flush. For write-only channels, a
// call to g_io_channel_flush () is sufficient. For all other channels, the
// buffers may be flushed by a call to g_io_channel_seek_position (). This
// includes the possibility of seeking with seek type G_SEEK_CUR and an offset
// of zero. Note that this means that socket-based channels cannot be set
// unbuffered once they have had data read from them.
//
// On unbuffered channels, it is safe to mix read and write calls from the new
// and old APIs, if this is necessary for maintaining old code.
//
// The default state of the channel is buffered.
func (c *IOChannel) SetBuffered(buffered bool) {
	var _arg0 *C.GIOChannel // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GIOChannel)(unsafe.Pointer(c.Native()))
	if buffered {
		_arg1 = C.gboolean(1)
	}

	C.g_io_channel_set_buffered(_arg0, _arg1)
}

// SetCloseOnUnref: whether to close the channel on the final unref of the
// OChannel data structure. The default value of this is true for channels
// created by g_io_channel_new_file (), and false for all other channels.
//
// Setting this flag to true for a channel you have already closed can cause
// problems when the final reference to the OChannel is dropped.
func (c *IOChannel) SetCloseOnUnref(doClose bool) {
	var _arg0 *C.GIOChannel // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GIOChannel)(unsafe.Pointer(c.Native()))
	if doClose {
		_arg1 = C.gboolean(1)
	}

	C.g_io_channel_set_close_on_unref(_arg0, _arg1)
}

// SetLineTerm: this sets the string that OChannel uses to determine where in
// the file a line break occurs.
func (c *IOChannel) SetLineTerm(lineTerm string, length int) {
	var _arg0 *C.GIOChannel // out
	var _arg1 *C.gchar      // out
	var _arg2 C.gint        // out

	_arg0 = (*C.GIOChannel)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(lineTerm))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(length)

	C.g_io_channel_set_line_term(_arg0, _arg1, _arg2)
}

// UnixGetFd returns the file descriptor of the OChannel.
//
// On Windows this function returns the file descriptor or socket of the
// OChannel.
func (c *IOChannel) UnixGetFd() int {
	var _arg0 *C.GIOChannel // out

	_arg0 = (*C.GIOChannel)(unsafe.Pointer(c.Native()))

	var _cret C.gint // in

	_cret = C.g_io_channel_unix_get_fd(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Unref decrements the reference count of a OChannel.
func (c *IOChannel) Unref() {
	var _arg0 *C.GIOChannel // out

	_arg0 = (*C.GIOChannel)(unsafe.Pointer(c.Native()))

	C.g_io_channel_unref(_arg0)
}
