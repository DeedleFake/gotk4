// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"runtime"
	"unsafe"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <glib.h>
import "C"

// IOChannelError: error codes returned by OChannel operations.
type IOChannelError int

const (
	// fbig: file too large.
	IOChannelErrorFbig IOChannelError = 0
	// inval: invalid argument.
	IOChannelErrorInval IOChannelError = 1
	// io: IO error.
	IOChannelErrorIO IOChannelError = 2
	// isdir: file is a directory.
	IOChannelErrorIsdir IOChannelError = 3
	// nospc: no space left on device.
	IOChannelErrorNospc IOChannelError = 4
	// nxio: no such device or address.
	IOChannelErrorNxio IOChannelError = 5
	// overflow: value too large for defined datatype.
	IOChannelErrorOverflow IOChannelError = 6
	// pipe: broken pipe.
	IOChannelErrorPipe IOChannelError = 7
	// failed: some other error.
	IOChannelErrorFailed IOChannelError = 8
)

// IOError is only used by the deprecated functions g_io_channel_read(),
// g_io_channel_write(), and g_io_channel_seek().
type IOError int

const (
	// none: no error
	IOErrorNone IOError = 0
	// again: an EAGAIN error occurred
	IOErrorAgain IOError = 1
	// inval: an EINVAL error occurred
	IOErrorInval IOError = 2
	// unknown: another error occurred
	IOErrorUnknown IOError = 3
)

// IOStatus statuses returned by most of the OFuncs functions.
type IOStatus int

const (
	// error: an error occurred.
	IOStatusError IOStatus = 0
	// normal: success.
	IOStatusNormal IOStatus = 1
	// eof: end of file.
	IOStatusEOF IOStatus = 2
	// again: resource temporarily unavailable.
	IOStatusAgain IOStatus = 3
)

// SeekType: an enumeration specifying the base position for a
// g_io_channel_seek_position() operation.
type SeekType int

const (
	// cur: the current position in the file.
	SeekTypeCur SeekType = 0
	// set: the start of the file.
	SeekTypeSet SeekType = 1
	// end: the end of the file.
	SeekTypeEnd SeekType = 2
)

// IOFlags specifies properties of a OChannel. Some of the flags can only be
// read with g_io_channel_get_flags(), but not changed with
// g_io_channel_set_flags().
type IOFlags int

const (
	// IOFlagsAppend turns on append mode, corresponds to O_APPEND (see the
	// documentation of the UNIX open() syscall)
	IOFlagsAppend IOFlags = 0b1
	// IOFlagsNonblock turns on nonblocking mode, corresponds to
	// O_NONBLOCK/O_NDELAY (see the documentation of the UNIX open() syscall)
	IOFlagsNonblock IOFlags = 0b10
	// IOFlagsIsReadable indicates that the io channel is readable. This flag
	// cannot be changed.
	IOFlagsIsReadable IOFlags = 0b100
	// IOFlagsIsWritable indicates that the io channel is writable. This flag
	// cannot be changed.
	IOFlagsIsWritable IOFlags = 0b1000
	// IOFlagsIsWriteable: a misspelled version of @G_IO_FLAG_IS_WRITABLE that
	// existed before the spelling was fixed in GLib 2.30. It is kept here for
	// compatibility reasons. Deprecated since 2.30
	IOFlagsIsWriteable IOFlags = 0b1000
	// IOFlagsIsSeekable indicates that the io channel is seekable, i.e. that
	// g_io_channel_seek_position() can be used on it. This flag cannot be
	// changed.
	IOFlagsIsSeekable IOFlags = 0b10000
	// IOFlagsMask: the mask that specifies all the valid flags.
	IOFlagsMask IOFlags = 0b11111
	// IOFlagsGetMask: the mask of the flags that are returned from
	// g_io_channel_get_flags()
	IOFlagsGetMask IOFlags = 0b11111
	// IOFlagsSetMask: the mask of the flags that the user can modify with
	// g_io_channel_set_flags()
	IOFlagsSetMask IOFlags = 0b11
)

// IOCreateWatch creates a #GSource that's dispatched when @condition is met for
// the given @channel. For example, if condition is IO_IN, the source will be
// dispatched when there's data available for reading.
//
// The callback function invoked by the #GSource should be added with
// g_source_set_callback(), but it has type OFunc (not Func).
//
// g_io_add_watch() is a simpler interface to this same functionality, for the
// case where you want to add the source to the default main loop context at the
// default priority.
//
// On Windows, polling a #GSource created to watch a channel for a socket puts
// the socket in non-blocking mode. This is a side-effect of the implementation
// and unavoidable.
func IOCreateWatch(channel *IOChannel, condition IOCondition) *Source {
	var _arg1 *C.GIOChannel  // out
	var _arg2 C.GIOCondition // out
	var _cret *C.GSource     // in

	_arg1 = (*C.GIOChannel)(unsafe.Pointer(channel.Native()))
	_arg2 = C.GIOCondition(condition)

	_cret = C.g_io_create_watch(_arg1, _arg2)

	var _source *Source // out

	_source = (*Source)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_source, func(v **Source) {
		C.free(unsafe.Pointer(v))
	})

	return _source
}
