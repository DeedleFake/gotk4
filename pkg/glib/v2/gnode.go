// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/box"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <glib.h>
import "C"

// TraverseType specifies the type of traversal performed by g_tree_traverse(),
// g_node_traverse() and g_node_find(). The different orders are illustrated
// here: - In order: A, B, C, D, E, F, G, H, I !
// (Sorted_binary_tree_inorder.svg) - Pre order: F, B, A, D, C, E, G, I, H !
// (Sorted_binary_tree_preorder.svg) - Post order: A, C, E, D, B, H, I, G, F !
// (Sorted_binary_tree_postorder.svg) - Level order: F, B, G, A, D, I, C, E, H !
// (Sorted_binary_tree_breadth-first_traversal.svg)
type TraverseType int

const (
	// InOrder vists a node's left child first, then the node itself, then its
	// right child. This is the one to use if you want the output sorted
	// according to the compare function.
	TraverseTypeInOrder TraverseType = iota
	// PreOrder visits a node, then its children.
	TraverseTypePreOrder
	// PostOrder visits the node's children, then the node itself.
	TraverseTypePostOrder
	// LevelOrder is not implemented for [balanced binary
	// trees][glib-Balanced-Binary-Trees]. For [n-ary trees][glib-N-ary-Trees],
	// it vists the root node first, then its children, then its grandchildren,
	// and so on. Note that this is less efficient than the other orders.
	TraverseTypeLevelOrder
)

// TraverseFlags specifies which nodes are visited during several of the tree
// functions, including g_node_traverse() and g_node_find().
type TraverseFlags int

const (
	// TraverseFlagsLeaves: only leaf nodes should be visited. This name has
	// been introduced in 2.6, for older version use G_TRAVERSE_LEAFS.
	TraverseFlagsLeaves TraverseFlags = 0b1
	// TraverseFlagsNonLeaves: only non-leaf nodes should be visited. This name
	// has been introduced in 2.6, for older version use G_TRAVERSE_NON_LEAFS.
	TraverseFlagsNonLeaves TraverseFlags = 0b10
	// TraverseFlagsAll nodes should be visited.
	TraverseFlagsAll TraverseFlags = 0b11
	// TraverseFlagsMask of all traverse flags.
	TraverseFlagsMask TraverseFlags = 0b11
	// TraverseFlagsLeafs: identical to G_TRAVERSE_LEAVES.
	TraverseFlagsLeafs TraverseFlags = 0b1
	// TraverseFlagsNonLeafs: identical to G_TRAVERSE_NON_LEAVES.
	TraverseFlagsNonLeafs TraverseFlags = 0b10
)

// Node: the #GNode struct represents one node in a [n-ary
// tree][glib-N-ary-Trees].
type Node struct {
	native C.GNode
}

// WrapNode wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapNode(ptr unsafe.Pointer) *Node {
	return (*Node)(ptr)
}

// Native returns the underlying C source pointer.
func (n *Node) Native() unsafe.Pointer {
	return unsafe.Pointer(&n.native)
}

// ChildIndex gets the position of the first child of a #GNode which contains
// the given data.
func (node *Node) ChildIndex(data interface{}) int {
	var _arg0 *C.GNode   // out
	var _arg1 C.gpointer // out
	var _cret C.gint     // in

	_arg0 = (*C.GNode)(unsafe.Pointer(node))
	_arg1 = (C.gpointer)(box.Assign(data))

	_cret = C.g_node_child_index(_arg0, _arg1)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ChildPosition gets the position of a #GNode with respect to its siblings.
// @child must be a child of @node. The first child is numbered 0, the second 1,
// and so on.
func (node *Node) ChildPosition(child *Node) int {
	var _arg0 *C.GNode // out
	var _arg1 *C.GNode // out
	var _cret C.gint   // in

	_arg0 = (*C.GNode)(unsafe.Pointer(node))
	_arg1 = (*C.GNode)(unsafe.Pointer(child))

	_cret = C.g_node_child_position(_arg0, _arg1)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Depth gets the depth of a #GNode.
//
// If @node is nil the depth is 0. The root node has a depth of 1. For the
// children of the root node the depth is 2. And so on.
func (node *Node) Depth() uint {
	var _arg0 *C.GNode // out
	var _cret C.guint  // in

	_arg0 = (*C.GNode)(unsafe.Pointer(node))

	_cret = C.g_node_depth(_arg0)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Destroy removes @root and its children from the tree, freeing any memory
// allocated.
func (root *Node) Destroy() {
	var _arg0 *C.GNode // out

	_arg0 = (*C.GNode)(unsafe.Pointer(root))

	C.g_node_destroy(_arg0)
}

// IsAncestor returns true if @node is an ancestor of @descendant. This is true
// if node is the parent of @descendant, or if node is the grandparent of
// @descendant etc.
func (node *Node) IsAncestor(descendant *Node) bool {
	var _arg0 *C.GNode   // out
	var _arg1 *C.GNode   // out
	var _cret C.gboolean // in

	_arg0 = (*C.GNode)(unsafe.Pointer(node))
	_arg1 = (*C.GNode)(unsafe.Pointer(descendant))

	_cret = C.g_node_is_ancestor(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MaxHeight gets the maximum height of all branches beneath a #GNode. This is
// the maximum distance from the #GNode to all leaf nodes.
//
// If @root is nil, 0 is returned. If @root has no children, 1 is returned. If
// @root has children, 2 is returned. And so on.
func (root *Node) MaxHeight() uint {
	var _arg0 *C.GNode // out
	var _cret C.guint  // in

	_arg0 = (*C.GNode)(unsafe.Pointer(root))

	_cret = C.g_node_max_height(_arg0)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// NChildren gets the number of children of a #GNode.
func (node *Node) NChildren() uint {
	var _arg0 *C.GNode // out
	var _cret C.guint  // in

	_arg0 = (*C.GNode)(unsafe.Pointer(node))

	_cret = C.g_node_n_children(_arg0)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// ReverseChildren reverses the order of the children of a #GNode. (It doesn't
// change the order of the grandchildren.)
func (node *Node) ReverseChildren() {
	var _arg0 *C.GNode // out

	_arg0 = (*C.GNode)(unsafe.Pointer(node))

	C.g_node_reverse_children(_arg0)
}

// Unlink unlinks a #GNode from a tree, resulting in two separate trees.
func (node *Node) Unlink() {
	var _arg0 *C.GNode // out

	_arg0 = (*C.GNode)(unsafe.Pointer(node))

	C.g_node_unlink(_arg0)
}
