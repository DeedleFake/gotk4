// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/ptr"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <glib.h>
import "C"

// ByteArrayFree frees the memory allocated by the Array. If @free_segment is
// true it frees the actual byte data. If the reference count of @array is
// greater than one, the Array wrapper is preserved but the size of @array will
// be set to zero.
func ByteArrayFree(array []byte, freeSegment bool) byte {
	var arg1 *C.GByteArray
	var arg2 C.gboolean

	arg1 = C.malloc(len(array) * (C.sizeof_guint8 + 1))
	defer C.free(unsafe.Pointer(arg1))

	{
		var out []C.guint8
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg1), int(len(array)))

		for i := range array {
			out[i] = C.guint8(array[i])
		}
	}
	if freeSegment {
		arg2 = C.gboolean(1)
	}

	var cret *C.guint8
	var goret1 byte

	cret = C.g_byte_array_free(array, freeSegment)

	goret1 = *C.guint8(cret)

	return goret1
}

// ByteArrayFreeToBytes transfers the data from the Array into a new immutable
// #GBytes.
//
// The Array is freed unless the reference count of @array is greater than one,
// the Array wrapper is preserved but the size of @array will be set to zero.
//
// This is identical to using g_bytes_new_take() and g_byte_array_free()
// together.
func ByteArrayFreeToBytes(array []byte) *Bytes {
	var arg1 *C.GByteArray

	arg1 = C.malloc(len(array) * (C.sizeof_guint8 + 1))
	{
		var out []C.guint8
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg1), int(len(array)))

		for i := range array {
			out[i] = C.guint8(array[i])
		}
	}

	var cret *C.GBytes
	var goret1 *Bytes

	cret = C.g_byte_array_free_to_bytes(array)

	goret1 = WrapBytes(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret1, func(v *Bytes) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret1
}

// NewByteArray creates a new Array with a reference count of 1.
func NewByteArray() []byte {
	var cret *C.GByteArray
	var goret1 []byte

	cret = C.g_byte_array_new()

	{
		var length int
		for p := cret; *p != 0; p = (*C.GByteArray)(ptr.Add(unsafe.Pointer(p), C.sizeof_guint8)) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		goret1 = make([]byte, length)
		for i := uintptr(0); i < uintptr(length); i += C.sizeof_guint8 {
			src := (C.guint8)(ptr.Add(unsafe.Pointer(cret), i))
			goret1[i] = C.guint8(src)
		}
	}

	return goret1
}

// ByteArrayNewTake: create byte array containing the data. The data will be
// owned by the array and will be freed with g_free(), i.e. it could be
// allocated using g_strdup().
func ByteArrayNewTake(data []byte) []byte {

	var cret *C.GByteArray
	var goret1 []byte

	cret = C.g_byte_array_new_take(data, len)

	{
		var length int
		for p := cret; *p != 0; p = (*C.GByteArray)(ptr.Add(unsafe.Pointer(p), C.sizeof_guint8)) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		goret1 = make([]byte, length)
		for i := uintptr(0); i < uintptr(length); i += C.sizeof_guint8 {
			src := (C.guint8)(ptr.Add(unsafe.Pointer(cret), i))
			goret1[i] = C.guint8(src)
		}
	}

	return goret1
}

// ByteArraySteal frees the data in the array and resets the size to zero, while
// the underlying array is preserved for use elsewhere and returned to the
// caller.
func ByteArraySteal(array []byte) (len uint, guint8 byte) {
	var arg1 *C.GByteArray

	arg1 = C.malloc(len(array) * (C.sizeof_guint8 + 1))
	defer C.free(unsafe.Pointer(arg1))

	{
		var out []C.guint8
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg1), int(len(array)))

		for i := range array {
			out[i] = C.guint8(array[i])
		}
	}

	var arg2 *C.gsize
	var ret2 uint
	var cret *C.guint8
	var goret2 byte

	cret = C.g_byte_array_steal(array, &arg2)

	ret2 = *C.gsize(arg2)
	goret2 = *C.guint8(cret)

	return ret2, goret2
}

// ByteArrayUnref: atomically decrements the reference count of @array by one.
// If the reference count drops to 0, all memory allocated by the array is
// released. This function is thread-safe and may be called from any thread.
func ByteArrayUnref(array []byte) {
	var arg1 *C.GByteArray

	arg1 = C.malloc(len(array) * (C.sizeof_guint8 + 1))
	defer C.free(unsafe.Pointer(arg1))

	{
		var out []C.guint8
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg1), int(len(array)))

		for i := range array {
			out[i] = C.guint8(array[i])
		}
	}

	C.g_byte_array_unref(array)
}

// PtrArrayFind checks whether @needle exists in @haystack. If the element is
// found, true is returned and the elementâ€™s index is returned in @index_ (if
// non-nil). Otherwise, false is returned and @index_ is undefined. If @needle
// exists multiple times in @haystack, the index of the first instance is
// returned.
//
// This does pointer comparisons only. If you want to use more complex equality
// checks, such as string comparisons, use g_ptr_array_find_with_equal_func().
func PtrArrayFind(haystack []interface{}, needle interface{}) (index_ uint, ok bool) {
	var arg1 *C.GPtrArray
	var arg2 C.gpointer

	arg1 = C.malloc(len(haystack) * (C.sizeof_gpointer + 1))
	defer C.free(unsafe.Pointer(arg1))

	{
		var out []C.gpointer
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg1), int(len(haystack)))

		for i := range haystack {
			out[i] = C.gpointer(haystack[i])
		}
	}
	arg2 = C.gpointer(needle)

	var arg3 *C.guint
	var ret3 uint
	var cret C.gboolean
	var goret2 bool

	cret = C.g_ptr_array_find(haystack, needle, &arg3)

	ret3 = *C.guint(arg3)
	goret2 = C.bool(cret) != C.false

	return ret3, goret2
}

// Array contains the public fields of a GArray.
type Array struct {
	native C.GArray
}

// WrapArray wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapArray(ptr unsafe.Pointer) *Array {
	if ptr == nil {
		return nil
	}

	return (*Array)(ptr)
}

func marshalArray(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapArray(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (a *Array) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// Data gets the field inside the struct.
func (a *Array) Data() string {
	v = C.GoString(a.native.data)
}

// Len gets the field inside the struct.
func (a *Array) Len() uint {
	v = C.guint(a.native.len)
}

// ByteArray contains the public fields of a GByteArray.
type ByteArray struct {
	native C.GByteArray
}

// WrapByteArray wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapByteArray(ptr unsafe.Pointer) *ByteArray {
	if ptr == nil {
		return nil
	}

	return (*ByteArray)(ptr)
}

func marshalByteArray(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapByteArray(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (b *ByteArray) Native() unsafe.Pointer {
	return unsafe.Pointer(&b.native)
}

// Data gets the field inside the struct.
func (b *ByteArray) Data() byte {
	v = *C.guint8(b.native.data)
}

// Len gets the field inside the struct.
func (b *ByteArray) Len() uint {
	v = C.guint(b.native.len)
}

// Bytes: a simple refcounted data type representing an immutable sequence of
// zero or more bytes from an unspecified origin.
//
// The purpose of a #GBytes is to keep the memory region that it holds alive for
// as long as anyone holds a reference to the bytes. When the last reference
// count is dropped, the memory is released. Multiple unrelated callers can use
// byte data in the #GBytes without coordinating their activities, resting
// assured that the byte data will not change or move while they hold a
// reference.
//
// A #GBytes can come from many different origins that may have different
// procedures for freeing the memory region. Examples are memory from
// g_malloc(), from memory slices, from a File or memory from other allocators.
//
// #GBytes work well as keys in Table. Use g_bytes_equal() and g_bytes_hash() as
// parameters to g_hash_table_new() or g_hash_table_new_full(). #GBytes can also
// be used as keys in a #GTree by passing the g_bytes_compare() function to
// g_tree_new().
//
// The data pointed to by this bytes must not be modified. For a mutable array
// of bytes see Array. Use g_bytes_unref_to_array() to create a mutable array
// for a #GBytes sequence. To create an immutable #GBytes from a mutable Array,
// use the g_byte_array_free_to_bytes() function.
type Bytes struct {
	native C.GBytes
}

// WrapBytes wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapBytes(ptr unsafe.Pointer) *Bytes {
	if ptr == nil {
		return nil
	}

	return (*Bytes)(ptr)
}

func marshalBytes(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapBytes(unsafe.Pointer(b)), nil
}

// NewBytes constructs a struct Bytes.
func NewBytes(data []byte) *Bytes {

	var cret *C.GBytes
	var goret1 *Bytes

	cret = C.g_bytes_new(data, size)

	goret1 = WrapBytes(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret1, func(v *Bytes) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret1
}

// NewBytesStatic constructs a struct Bytes.
func NewBytesStatic(data []byte) *Bytes {

	var cret *C.GBytes
	var goret1 *Bytes

	cret = C.g_bytes_new_static(data, size)

	goret1 = WrapBytes(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret1, func(v *Bytes) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret1
}

// NewBytesTake constructs a struct Bytes.
func NewBytesTake(data []byte) *Bytes {

	var cret *C.GBytes
	var goret1 *Bytes

	cret = C.g_bytes_new_take(data, size)

	goret1 = WrapBytes(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret1, func(v *Bytes) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret1
}

// Native returns the underlying C source pointer.
func (b *Bytes) Native() unsafe.Pointer {
	return unsafe.Pointer(&b.native)
}

// Compare compares the two #GBytes values.
//
// This function can be used to sort GBytes instances in lexicographical order.
//
// If @bytes1 and @bytes2 have different length but the shorter one is a prefix
// of the longer one then the shorter one is considered to be less than the
// longer one. Otherwise the first byte where both differ is used for
// comparison. If @bytes1 has a smaller value at that position it is considered
// less, otherwise greater than @bytes2.
func (b *Bytes) Compare(bytes2 Bytes) int {
	var arg0 C.gpointer
	var arg1 C.gpointer

	arg0 = (C.gpointer)(unsafe.Pointer(b.Native()))
	arg1 = (C.gpointer)(unsafe.Pointer(bytes2.Native()))

	var cret C.gint
	var goret1 int

	cret = C.g_bytes_compare(arg0, bytes2)

	goret1 = C.gint(cret)

	return goret1
}

// Equal compares the two #GBytes values being pointed to and returns true if
// they are equal.
//
// This function can be passed to g_hash_table_new() as the @key_equal_func
// parameter, when using non-nil #GBytes pointers as keys in a Table.
func (b *Bytes) Equal(bytes2 Bytes) bool {
	var arg0 C.gpointer
	var arg1 C.gpointer

	arg0 = (C.gpointer)(unsafe.Pointer(b.Native()))
	arg1 = (C.gpointer)(unsafe.Pointer(bytes2.Native()))

	var cret C.gboolean
	var goret1 bool

	cret = C.g_bytes_equal(arg0, bytes2)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// Data: get the byte data in the #GBytes. This data should not be modified.
//
// This function will always return the same pointer for a given #GBytes.
//
// nil may be returned if @size is 0. This is not guaranteed, as the #GBytes may
// represent an empty string with @data non-nil and @size as 0. nil will not be
// returned if @size is non-zero.
func (b *Bytes) Data() (size uint, guint8s []byte) {
	var arg0 *C.GBytes

	arg0 = (*C.GBytes)(unsafe.Pointer(b.Native()))

	var cret C.gpointer
	var arg1 *C.gsize
	var goret2 []byte

	cret = C.g_bytes_get_data(arg0, &arg1)

	goret2 = make([]byte, arg1)
	for i := 0; i < uintptr(arg1); i++ {
		src := (C.guint8)(ptr.Add(unsafe.Pointer(cret), i))
		goret2[i] = C.guint8(src)
	}

	return ret1, goret2
}

// Size: get the size of the byte data in the #GBytes.
//
// This function will always return the same value for a given #GBytes.
func (b *Bytes) Size() uint {
	var arg0 *C.GBytes

	arg0 = (*C.GBytes)(unsafe.Pointer(b.Native()))

	var cret C.gsize
	var goret1 uint

	cret = C.g_bytes_get_size(arg0)

	goret1 = C.gsize(cret)

	return goret1
}

// Hash creates an integer hash code for the byte data in the #GBytes.
//
// This function can be passed to g_hash_table_new() as the @key_hash_func
// parameter, when using non-nil #GBytes pointers as keys in a Table.
func (b *Bytes) Hash() uint {
	var arg0 C.gpointer

	arg0 = (C.gpointer)(unsafe.Pointer(b.Native()))

	var cret C.guint
	var goret1 uint

	cret = C.g_bytes_hash(arg0)

	goret1 = C.guint(cret)

	return goret1
}

// NewFromBytes creates a #GBytes which is a subsection of another #GBytes. The
// @offset + @length may not be longer than the size of @bytes.
//
// A reference to @bytes will be held by the newly created #GBytes until the
// byte data is no longer needed.
//
// Since 2.56, if @offset is 0 and @length matches the size of @bytes, then
// @bytes will be returned with the reference count incremented by 1. If @bytes
// is a slice of another #GBytes, then the resulting #GBytes will reference the
// same #GBytes instead of @bytes. This allows consumers to simplify the usage
// of #GBytes when asynchronously writing to streams.
func (b *Bytes) NewFromBytes(offset uint, length uint) *Bytes {
	var arg0 *C.GBytes
	var arg1 C.gsize
	var arg2 C.gsize

	arg0 = (*C.GBytes)(unsafe.Pointer(b.Native()))
	arg1 = C.gsize(offset)
	arg2 = C.gsize(length)

	var cret *C.GBytes
	var goret1 *Bytes

	cret = C.g_bytes_new_from_bytes(arg0, offset, length)

	goret1 = WrapBytes(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret1, func(v *Bytes) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret1
}

// Ref: increase the reference count on @bytes.
func (b *Bytes) Ref() *Bytes {
	var arg0 *C.GBytes

	arg0 = (*C.GBytes)(unsafe.Pointer(b.Native()))

	var cret *C.GBytes
	var goret1 *Bytes

	cret = C.g_bytes_ref(arg0)

	goret1 = WrapBytes(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret1, func(v *Bytes) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret1
}

// Unref releases a reference on @bytes. This may result in the bytes being
// freed. If @bytes is nil, it will return immediately.
func (b *Bytes) Unref() {
	var arg0 *C.GBytes

	arg0 = (*C.GBytes)(unsafe.Pointer(b.Native()))

	C.g_bytes_unref(arg0)
}

// UnrefToArray unreferences the bytes, and returns a new mutable Array
// containing the same byte data.
//
// As an optimization, the byte data is transferred to the array without copying
// if this was the last reference to bytes and bytes was created with
// g_bytes_new(), g_bytes_new_take() or g_byte_array_free_to_bytes(). In all
// other cases the data is copied.
func (b *Bytes) UnrefToArray() []byte {
	var arg0 *C.GBytes

	arg0 = (*C.GBytes)(unsafe.Pointer(b.Native()))

	var cret *C.GByteArray
	var goret1 []byte

	cret = C.g_bytes_unref_to_array(arg0)

	{
		var length int
		for p := cret; *p != 0; p = (*C.GByteArray)(ptr.Add(unsafe.Pointer(p), C.sizeof_guint8)) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		goret1 = make([]byte, length)
		for i := uintptr(0); i < uintptr(length); i += C.sizeof_guint8 {
			src := (C.guint8)(ptr.Add(unsafe.Pointer(cret), i))
			goret1[i] = C.guint8(src)
		}
	}

	return goret1
}

// UnrefToData unreferences the bytes, and returns a pointer the same byte data
// contents.
//
// As an optimization, the byte data is returned without copying if this was the
// last reference to bytes and bytes was created with g_bytes_new(),
// g_bytes_new_take() or g_byte_array_free_to_bytes(). In all other cases the
// data is copied.
func (b *Bytes) UnrefToData() (size uint, guint8s []byte) {
	var arg0 *C.GBytes

	arg0 = (*C.GBytes)(unsafe.Pointer(b.Native()))

	var cret C.gpointer
	var arg1 *C.gsize
	var goret2 []byte

	cret = C.g_bytes_unref_to_data(arg0, &arg1)

	ptr.SetSlice(unsafe.Pointer(&goret2), unsafe.Pointer(cret), int(arg1))
	runtime.SetFinalizer(&goret2, func(v *[]byte) {
		C.free(ptr.Slice(unsafe.Pointer(v)))
	})

	return ret1, goret2
}

// PtrArray contains the public fields of a pointer array.
type PtrArray struct {
	native C.GPtrArray
}

// WrapPtrArray wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPtrArray(ptr unsafe.Pointer) *PtrArray {
	if ptr == nil {
		return nil
	}

	return (*PtrArray)(ptr)
}

func marshalPtrArray(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapPtrArray(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (p *PtrArray) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

// Pdata gets the field inside the struct.
func (p *PtrArray) Pdata() interface{} {
	v = *C.gpointer(p.native.pdata)
}

// Len gets the field inside the struct.
func (p *PtrArray) Len() uint {
	v = C.guint(p.native.len)
}
