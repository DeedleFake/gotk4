// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
)

// #cgo pkg-config: glib-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <glib.h>
import "C"

// ByteArrayFree frees the memory allocated by the Array. If @free_segment is
// true it frees the actual byte data. If the reference count of @array is
// greater than one, the Array wrapper is preserved but the size of @array will
// be set to zero.
func ByteArrayFree(array []byte, freeSegment bool) byte {
	var arg1 *C.GByteArray
	var arg2 C.gboolean

	{
		var dst []C.guint8
		ptr := C.malloc(C.sizeof_guint8 * (len(array) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(array)
		sliceHeader.Cap = len(array)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(array); i++ {
			src := array[i]
			dst[i] = C.guint8(src)
		}

		arg1 = (*C.GByteArray)(unsafe.Pointer(ptr))
	}
	if freeSegment {
		arg2 = C.TRUE
	}

	ret := C.g_byte_array_free(arg1, arg2)

	var ret0 byte

	ret0 = byte(ret)

	return ret0
}

// ByteArrayFreeToBytes transfers the data from the Array into a new immutable
// #GBytes.
//
// The Array is freed unless the reference count of @array is greater than one,
// the Array wrapper is preserved but the size of @array will be set to zero.
//
// This is identical to using g_bytes_new_take() and g_byte_array_free()
// together.
func ByteArrayFreeToBytes(array []byte) *Bytes {
	var arg1 *C.GByteArray

	{
		var dst []C.guint8
		ptr := C.malloc(C.sizeof_guint8 * (len(array) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(array)
		sliceHeader.Cap = len(array)

		for i := 0; i < len(array); i++ {
			src := array[i]
			dst[i] = C.guint8(src)
		}

		arg1 = (*C.GByteArray)(unsafe.Pointer(ptr))
	}

	ret := C.g_byte_array_free_to_bytes(arg1)

	var ret0 *Bytes

	{
		ret0 = WrapBytes(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Bytes) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewByteArray creates a new Array with a reference count of 1.
func NewByteArray() []byte {
	ret := C.g_byte_array_new()

	var ret0 []byte

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]byte, length)
		for i := 0; i < length; i++ {
			src := (C.guint8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = byte(src)
		}
	}

	return ret0
}

// ByteArrayNewTake: create byte array containing the data. The data will be
// owned by the array and will be freed with g_free(), i.e. it could be
// allocated using g_strdup().
//
// Do not use it if @len is greater than G_MAXUINT. Array stores the length of
// its data in #guint, which may be shorter than #gsize.
func ByteArrayNewTake(data []byte) []byte {
	var arg1 *C.guint8
	var arg2 C.gsize

	{
		var dst []C.guint8
		ptr := C.malloc(C.sizeof_guint8 * len(data))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(data)
		sliceHeader.Cap = len(data)

		for i := 0; i < len(data); i++ {
			src := data[i]
			dst[i] = C.guint8(src)
		}

		arg1 = (*C.guint8)(unsafe.Pointer(ptr))
		arg2 = len(data)
	}

	ret := C.g_byte_array_new_take(arg1, arg2)

	var ret0 []byte

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]byte, length)
		for i := 0; i < length; i++ {
			src := (C.guint8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = byte(src)
		}
	}

	return ret0
}

// ByteArraySteal frees the data in the array and resets the size to zero, while
// the underlying array is preserved for use elsewhere and returned to the
// caller.
func ByteArraySteal(array []byte) (len uint, guint8 byte) {
	var arg1 *C.GByteArray
	var arg2 *C.gsize // out

	{
		var dst []C.guint8
		ptr := C.malloc(C.sizeof_guint8 * (len(array) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(array)
		sliceHeader.Cap = len(array)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(array); i++ {
			src := array[i]
			dst[i] = C.guint8(src)
		}

		arg1 = (*C.GByteArray)(unsafe.Pointer(ptr))
	}

	ret := C.g_byte_array_steal(arg1, &arg2)

	var ret0 uint
	var ret1 byte

	ret0 = uint(arg2)

	ret1 = byte(ret)

	return ret0, ret1
}

// ByteArrayUnref: atomically decrements the reference count of @array by one.
// If the reference count drops to 0, all memory allocated by the array is
// released. This function is thread-safe and may be called from any thread.
func ByteArrayUnref(array []byte) {
	var arg1 *C.GByteArray

	{
		var dst []C.guint8
		ptr := C.malloc(C.sizeof_guint8 * (len(array) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(array)
		sliceHeader.Cap = len(array)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(array); i++ {
			src := array[i]
			dst[i] = C.guint8(src)
		}

		arg1 = (*C.GByteArray)(unsafe.Pointer(ptr))
	}

	C.g_byte_array_unref(arg1)
}

// PtrArrayFind checks whether @needle exists in @haystack. If the element is
// found, true is returned and the element’s index is returned in @index_ (if
// non-nil). Otherwise, false is returned and @index_ is undefined. If @needle
// exists multiple times in @haystack, the index of the first instance is
// returned.
//
// This does pointer comparisons only. If you want to use more complex equality
// checks, such as string comparisons, use g_ptr_array_find_with_equal_func().
func PtrArrayFind(haystack []interface{}, needle interface{}) (index_ uint, ok bool) {
	var arg1 *C.GPtrArray
	var arg2 C.gpointer
	var arg3 *C.guint // out

	{
		var dst []C.gpointer
		ptr := C.malloc(C.sizeof_gpointer * (len(haystack) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(haystack)
		sliceHeader.Cap = len(haystack)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(haystack); i++ {
			src := haystack[i]
			dst[i] = C.gpointer(box.Assign(src))
		}

		arg1 = (*C.GPtrArray)(unsafe.Pointer(ptr))
	}
	arg2 = C.gpointer(box.Assign(needle))

	ret := C.g_ptr_array_find(arg1, arg2, &arg3)

	var ret0 uint
	var ret1 bool

	ret0 = uint(arg3)

	ret1 = C.bool(ret) != 0

	return ret0, ret1
}

// PtrArrayFindWithEqualFunc checks whether @needle exists in @haystack, using
// the given @equal_func. If the element is found, true is returned and the
// element’s index is returned in @index_ (if non-nil). Otherwise, false is
// returned and @index_ is undefined. If @needle exists multiple times in
// @haystack, the index of the first instance is returned.
//
// @equal_func is called with the element from the array as its first parameter,
// and @needle as its second parameter. If @equal_func is nil, pointer equality
// is used.
func PtrArrayFindWithEqualFunc(haystack []interface{}, needle interface{}, equalFunc EqualFunc) (index_ uint, ok bool) {
	var arg1 *C.GPtrArray
	var arg2 C.gpointer
	var arg3 C.GEqualFunc
	var arg4 *C.guint // out

	{
		var dst []C.gpointer
		ptr := C.malloc(C.sizeof_gpointer * (len(haystack) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(haystack)
		sliceHeader.Cap = len(haystack)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(haystack); i++ {
			src := haystack[i]
			dst[i] = C.gpointer(box.Assign(src))
		}

		arg1 = (*C.GPtrArray)(unsafe.Pointer(ptr))
	}
	arg2 = C.gpointer(box.Assign(needle))

	ret := C.g_ptr_array_find_with_equal_func(arg1, arg2, arg3, &arg4)

	var ret0 uint
	var ret1 bool

	ret0 = uint(arg4)

	ret1 = C.bool(ret) != 0

	return ret0, ret1
}

// Array contains the public fields of a GArray.
type Array struct {
	native C.GArray
}

// WrapArray wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapArray(ptr unsafe.Pointer) *Array {
	if ptr == nil {
		return nil
	}

	return (*Array)(ptr)
}

func marshalArray(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapArray(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (a *Array) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// Data gets the field inside the struct.
func (a *Array) Data() string {
	var ret string
	ret = C.GoString(a.native.data)
	return ret
}

// Len gets the field inside the struct.
func (a *Array) Len() uint {
	var ret uint
	ret = uint(a.native.len)
	return ret
}

// ByteArray contains the public fields of a GByteArray.
type ByteArray struct {
	native C.GByteArray
}

// WrapByteArray wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapByteArray(ptr unsafe.Pointer) *ByteArray {
	if ptr == nil {
		return nil
	}

	return (*ByteArray)(ptr)
}

func marshalByteArray(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapByteArray(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (b *ByteArray) Native() unsafe.Pointer {
	return unsafe.Pointer(&b.native)
}

// Data gets the field inside the struct.
func (b *ByteArray) Data() byte {
	var ret byte
	ret = byte(b.native.data)
	return ret
}

// Len gets the field inside the struct.
func (b *ByteArray) Len() uint {
	var ret uint
	ret = uint(b.native.len)
	return ret
}

// Bytes: a simple refcounted data type representing an immutable sequence of
// zero or more bytes from an unspecified origin.
//
// The purpose of a #GBytes is to keep the memory region that it holds alive for
// as long as anyone holds a reference to the bytes. When the last reference
// count is dropped, the memory is released. Multiple unrelated callers can use
// byte data in the #GBytes without coordinating their activities, resting
// assured that the byte data will not change or move while they hold a
// reference.
//
// A #GBytes can come from many different origins that may have different
// procedures for freeing the memory region. Examples are memory from
// g_malloc(), from memory slices, from a File or memory from other allocators.
//
// #GBytes work well as keys in Table. Use g_bytes_equal() and g_bytes_hash() as
// parameters to g_hash_table_new() or g_hash_table_new_full(). #GBytes can also
// be used as keys in a #GTree by passing the g_bytes_compare() function to
// g_tree_new().
//
// The data pointed to by this bytes must not be modified. For a mutable array
// of bytes see Array. Use g_bytes_unref_to_array() to create a mutable array
// for a #GBytes sequence. To create an immutable #GBytes from a mutable Array,
// use the g_byte_array_free_to_bytes() function.
type Bytes struct {
	native C.GBytes
}

// WrapBytes wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapBytes(ptr unsafe.Pointer) *Bytes {
	if ptr == nil {
		return nil
	}

	return (*Bytes)(ptr)
}

func marshalBytes(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapBytes(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (b *Bytes) Native() unsafe.Pointer {
	return unsafe.Pointer(&b.native)
}

// NewBytes constructs a struct Bytes.
func NewBytes(data []byte) *Bytes {
	var arg1 C.gpointer
	var arg2 C.gsize

	arg1 = (C.gpointer)(unsafe.Pointer(&data[0]))
	arg2 = len(data)
	defer runtime.KeepAlive(data)

	ret := C.g_bytes_new(arg1, arg2)

	var ret0 *Bytes

	{
		ret0 = WrapBytes(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Bytes) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewBytesStatic constructs a struct Bytes.
func NewBytesStatic(data []byte) *Bytes {
	var arg1 C.gpointer
	var arg2 C.gsize

	{
		var dst []C.guint8
		ptr := C.malloc(C.sizeof_guint8 * len(data))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(data)
		sliceHeader.Cap = len(data)

		for i := 0; i < len(data); i++ {
			src := data[i]
			dst[i] = C.guint8(src)
		}

		arg1 = (C.gpointer)(unsafe.Pointer(ptr))
		arg2 = len(data)
	}

	ret := C.g_bytes_new_static(arg1, arg2)

	var ret0 *Bytes

	{
		ret0 = WrapBytes(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Bytes) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewBytesTake constructs a struct Bytes.
func NewBytesTake(data []byte) *Bytes {
	var arg1 C.gpointer
	var arg2 C.gsize

	{
		var dst []C.guint8
		ptr := C.malloc(C.sizeof_guint8 * len(data))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(data)
		sliceHeader.Cap = len(data)

		for i := 0; i < len(data); i++ {
			src := data[i]
			dst[i] = C.guint8(src)
		}

		arg1 = (C.gpointer)(unsafe.Pointer(ptr))
		arg2 = len(data)
	}

	ret := C.g_bytes_new_take(arg1, arg2)

	var ret0 *Bytes

	{
		ret0 = WrapBytes(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Bytes) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Compare compares the two #GBytes values.
//
// This function can be used to sort GBytes instances in lexicographical order.
//
// If @bytes1 and @bytes2 have different length but the shorter one is a prefix
// of the longer one then the shorter one is considered to be less than the
// longer one. Otherwise the first byte where both differ is used for
// comparison. If @bytes1 has a smaller value at that position it is considered
// less, otherwise greater than @bytes2.
func (b *Bytes) Compare(bytes2 Bytes) int {
	var arg0 C.gpointer
	var arg1 C.gpointer

	arg0 = (C.gpointer)(b.Native())
	arg1 = (C.gpointer)(bytes2.Native())

	ret := C.g_bytes_compare(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Equal compares the two #GBytes values being pointed to and returns true if
// they are equal.
//
// This function can be passed to g_hash_table_new() as the @key_equal_func
// parameter, when using non-nil #GBytes pointers as keys in a Table.
func (b *Bytes) Equal(bytes2 Bytes) bool {
	var arg0 C.gpointer
	var arg1 C.gpointer

	arg0 = (C.gpointer)(b.Native())
	arg1 = (C.gpointer)(bytes2.Native())

	ret := C.g_bytes_equal(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// Data: get the byte data in the #GBytes. This data should not be modified.
//
// This function will always return the same pointer for a given #GBytes.
//
// nil may be returned if @size is 0. This is not guaranteed, as the #GBytes may
// represent an empty string with @data non-nil and @size as 0. nil will not be
// returned if @size is non-zero.
func (b *Bytes) Data() (size uint, guint8s []byte) {
	var arg0 *C.GBytes
	var arg1 *C.gsize // out

	arg0 = (*C.GBytes)(b.Native())

	ret := C.g_bytes_get_data(arg0, &arg1)

	var ret0 uint
	var ret1 []byte

	ret0 = uint(arg1)

	{
		ret1 = make([]byte, arg1)
		for i := 0; i < uintptr(arg1); i++ {
			src := (C.guint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = byte(src)
		}
	}

	return ret0, ret1
}

// Size: get the size of the byte data in the #GBytes.
//
// This function will always return the same value for a given #GBytes.
func (b *Bytes) Size() uint {
	var arg0 *C.GBytes

	arg0 = (*C.GBytes)(b.Native())

	ret := C.g_bytes_get_size(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Hash creates an integer hash code for the byte data in the #GBytes.
//
// This function can be passed to g_hash_table_new() as the @key_hash_func
// parameter, when using non-nil #GBytes pointers as keys in a Table.
func (b *Bytes) Hash() uint {
	var arg0 C.gpointer

	arg0 = (C.gpointer)(b.Native())

	ret := C.g_bytes_hash(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// NewFromBytes creates a #GBytes which is a subsection of another #GBytes. The
// @offset + @length may not be longer than the size of @bytes.
//
// A reference to @bytes will be held by the newly created #GBytes until the
// byte data is no longer needed.
//
// Since 2.56, if @offset is 0 and @length matches the size of @bytes, then
// @bytes will be returned with the reference count incremented by 1. If @bytes
// is a slice of another #GBytes, then the resulting #GBytes will reference the
// same #GBytes instead of @bytes. This allows consumers to simplify the usage
// of #GBytes when asynchronously writing to streams.
func (b *Bytes) NewFromBytes(offset uint, length uint) *Bytes {
	var arg0 *C.GBytes
	var arg1 C.gsize
	var arg2 C.gsize

	arg0 = (*C.GBytes)(b.Native())
	arg1 = C.gsize(offset)
	arg2 = C.gsize(length)

	ret := C.g_bytes_new_from_bytes(arg0, arg1, arg2)

	var ret0 *Bytes

	{
		ret0 = WrapBytes(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Bytes) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Ref: increase the reference count on @bytes.
func (b *Bytes) Ref() *Bytes {
	var arg0 *C.GBytes

	arg0 = (*C.GBytes)(b.Native())

	ret := C.g_bytes_ref(arg0)

	var ret0 *Bytes

	{
		ret0 = WrapBytes(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Bytes) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Unref releases a reference on @bytes. This may result in the bytes being
// freed. If @bytes is nil, it will return immediately.
func (b *Bytes) Unref() {
	var arg0 *C.GBytes

	arg0 = (*C.GBytes)(b.Native())

	C.g_bytes_unref(arg0)
}

// UnrefToArray unreferences the bytes, and returns a new mutable Array
// containing the same byte data.
//
// As an optimization, the byte data is transferred to the array without copying
// if this was the last reference to bytes and bytes was created with
// g_bytes_new(), g_bytes_new_take() or g_byte_array_free_to_bytes(). In all
// other cases the data is copied.
//
// Do not use it if @bytes contains more than G_MAXUINT bytes. Array stores the
// length of its data in #guint, which may be shorter than #gsize, that @bytes
// is using.
func (b *Bytes) UnrefToArray() []byte {
	var arg0 *C.GBytes

	arg0 = (*C.GBytes)(b.Native())

	ret := C.g_bytes_unref_to_array(arg0)

	var ret0 []byte

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]byte, length)
		for i := 0; i < length; i++ {
			src := (C.guint8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = byte(src)
		}
	}

	return ret0
}

// UnrefToData unreferences the bytes, and returns a pointer the same byte data
// contents.
//
// As an optimization, the byte data is returned without copying if this was the
// last reference to bytes and bytes was created with g_bytes_new(),
// g_bytes_new_take() or g_byte_array_free_to_bytes(). In all other cases the
// data is copied.
func (b *Bytes) UnrefToData() (size uint, guint8s []byte) {
	var arg0 *C.GBytes
	var arg1 *C.gsize // out

	arg0 = (*C.GBytes)(b.Native())

	ret := C.g_bytes_unref_to_data(arg0, &arg1)

	var ret0 uint
	var ret1 []byte

	ret0 = uint(arg1)

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret1))
		sliceHeader.Data = uintptr(unsafe.Pointer(ret))
		sliceHeader.Len = arg1
		sliceHeader.Cap = arg1
		runtime.SetFinalizer(&ret, func() {
			C.free(unsafe.Pointer(ret))
		})
		defer runtime.KeepAlive(ret)
	}

	return ret0, ret1
}

// PtrArray contains the public fields of a pointer array.
type PtrArray struct {
	native C.GPtrArray
}

// WrapPtrArray wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPtrArray(ptr unsafe.Pointer) *PtrArray {
	if ptr == nil {
		return nil
	}

	return (*PtrArray)(ptr)
}

func marshalPtrArray(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapPtrArray(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (p *PtrArray) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

// Pdata gets the field inside the struct.
func (p *PtrArray) Pdata() interface{} {
	var ret interface{}
	ret = box.Get(uintptr(p.native.pdata))
	return ret
}

// Len gets the field inside the struct.
func (p *PtrArray) Len() uint {
	var ret uint
	ret = uint(p.native.len)
	return ret
}
