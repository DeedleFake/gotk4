// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"unsafe"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <glib.h>
import "C"

// ByteArrayFree frees the memory allocated by the Array. If @free_segment is
// true it frees the actual byte data. If the reference count of @array is
// greater than one, the Array wrapper is preserved but the size of @array will
// be set to zero.
func ByteArrayFree(array []byte, freeSegment bool) {
	var arg1 *C.GByteArray
	var arg2 C.gboolean

	arg1 = C.malloc(len(array) * (C.sizeof_guint8 + 1))
	defer C.free(unsafe.Pointer(arg1))

	{
		var out []C.guint8
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg1), int(len(array)))

		for i := range array {
			out[i] = C.guint8(array[i])
		}
	}
	if freeSegment {
		arg2 = C.gboolean(1)
	}

	C.g_byte_array_free(arg1, arg2)
}

// ByteArrayFreeToBytes transfers the data from the Array into a new immutable
// #GBytes.
//
// The Array is freed unless the reference count of @array is greater than one,
// the Array wrapper is preserved but the size of @array will be set to zero.
//
// This is identical to using g_bytes_new_take() and g_byte_array_free()
// together.
func ByteArrayFreeToBytes(array []byte) {
	var arg1 *C.GByteArray

	arg1 = C.malloc(len(array) * (C.sizeof_guint8 + 1))
	{
		var out []C.guint8
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg1), int(len(array)))

		for i := range array {
			out[i] = C.guint8(array[i])
		}
	}

	C.g_byte_array_free_to_bytes(arg1)
}

// NewByteArray creates a new Array with a reference count of 1.
func NewByteArray() {
	C.g_byte_array_new()
}

// ByteArrayNewTake: create byte array containing the data. The data will be
// owned by the array and will be freed with g_free(), i.e. it could be
// allocated using g_strdup().
func ByteArrayNewTake() {
	C.g_byte_array_new_take(arg1, arg2)
}

// ByteArraySteal frees the data in the array and resets the size to zero, while
// the underlying array is preserved for use elsewhere and returned to the
// caller.
func ByteArraySteal(array []byte) uint {
	var arg1 *C.GByteArray

	arg1 = C.malloc(len(array) * (C.sizeof_guint8 + 1))
	defer C.free(unsafe.Pointer(arg1))

	{
		var out []C.guint8
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg1), int(len(array)))

		for i := range array {
			out[i] = C.guint8(array[i])
		}
	}

	var arg2 C.gsize
	var len uint

	C.g_byte_array_steal(arg1, &arg2)

	len = uint(&arg2)

	return len
}

// ByteArrayUnref: atomically decrements the reference count of @array by one.
// If the reference count drops to 0, all memory allocated by the array is
// released. This function is thread-safe and may be called from any thread.
func ByteArrayUnref(array []byte) {
	var arg1 *C.GByteArray

	arg1 = C.malloc(len(array) * (C.sizeof_guint8 + 1))
	defer C.free(unsafe.Pointer(arg1))

	{
		var out []C.guint8
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg1), int(len(array)))

		for i := range array {
			out[i] = C.guint8(array[i])
		}
	}

	C.g_byte_array_unref(arg1)
}

// PtrArrayFind checks whether @needle exists in @haystack. If the element is
// found, true is returned and the elementâ€™s index is returned in @index_ (if
// non-nil). Otherwise, false is returned and @index_ is undefined. If @needle
// exists multiple times in @haystack, the index of the first instance is
// returned.
//
// This does pointer comparisons only. If you want to use more complex equality
// checks, such as string comparisons, use g_ptr_array_find_with_equal_func().
func PtrArrayFind(haystack []interface{}, needle interface{}) (index_ uint, ok bool) {
	var arg1 *C.GPtrArray
	var arg2 C.gpointer

	arg1 = C.malloc(len(haystack) * (C.sizeof_gpointer + 1))
	defer C.free(unsafe.Pointer(arg1))

	{
		var out []C.gpointer
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg1), int(len(haystack)))

		for i := range haystack {
			out[i] = C.gpointer(haystack[i])
		}
	}
	arg2 = C.gpointer(needle)

	var arg3 C.guint
	var index_ uint
	var cret C.gboolean
	var ok bool

	cret = C.g_ptr_array_find(arg1, arg2, &arg3)

	index_ = uint(&arg3)
	if cret {
		ok = true
	}

	return index_, ok
}

// Array contains the public fields of a GArray.
type Array struct {
	native C.GArray
}

// WrapArray wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapArray(ptr unsafe.Pointer) *Array {
	if ptr == nil {
		return nil
	}

	return (*Array)(ptr)
}

func marshalArray(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapArray(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (a *Array) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// Data gets the field inside the struct.
func (a *Array) Data() string {
	var v string
	v = C.GoString(a.native.data)
	return v
}

// Len gets the field inside the struct.
func (a *Array) Len() uint {
	var v uint
	v = uint(a.native.len)
	return v
}

// ByteArray contains the public fields of a GByteArray.
type ByteArray struct {
	native C.GByteArray
}

// WrapByteArray wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapByteArray(ptr unsafe.Pointer) *ByteArray {
	if ptr == nil {
		return nil
	}

	return (*ByteArray)(ptr)
}

func marshalByteArray(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapByteArray(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (b *ByteArray) Native() unsafe.Pointer {
	return unsafe.Pointer(&b.native)
}

// Data gets the field inside the struct.
func (b *ByteArray) Data() byte {
	var v byte
	v = byte(b.native.data)
	return v
}

// Len gets the field inside the struct.
func (b *ByteArray) Len() uint {
	var v uint
	v = uint(b.native.len)
	return v
}

// Bytes: a simple refcounted data type representing an immutable sequence of
// zero or more bytes from an unspecified origin.
//
// The purpose of a #GBytes is to keep the memory region that it holds alive for
// as long as anyone holds a reference to the bytes. When the last reference
// count is dropped, the memory is released. Multiple unrelated callers can use
// byte data in the #GBytes without coordinating their activities, resting
// assured that the byte data will not change or move while they hold a
// reference.
//
// A #GBytes can come from many different origins that may have different
// procedures for freeing the memory region. Examples are memory from
// g_malloc(), from memory slices, from a File or memory from other allocators.
//
// #GBytes work well as keys in Table. Use g_bytes_equal() and g_bytes_hash() as
// parameters to g_hash_table_new() or g_hash_table_new_full(). #GBytes can also
// be used as keys in a #GTree by passing the g_bytes_compare() function to
// g_tree_new().
//
// The data pointed to by this bytes must not be modified. For a mutable array
// of bytes see Array. Use g_bytes_unref_to_array() to create a mutable array
// for a #GBytes sequence. To create an immutable #GBytes from a mutable Array,
// use the g_byte_array_free_to_bytes() function.
type Bytes struct {
	native C.GBytes
}

// WrapBytes wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapBytes(ptr unsafe.Pointer) *Bytes {
	if ptr == nil {
		return nil
	}

	return (*Bytes)(ptr)
}

func marshalBytes(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapBytes(unsafe.Pointer(b)), nil
}

// NewBytes constructs a struct Bytes.
func NewBytes() {
	C.g_bytes_new(arg1, arg2)
}

// NewBytesStatic constructs a struct Bytes.
func NewBytesStatic() {
	C.g_bytes_new_static(arg1, arg2)
}

// NewBytesTake constructs a struct Bytes.
func NewBytesTake() {
	C.g_bytes_new_take(arg1, arg2)
}

// Native returns the underlying C source pointer.
func (b *Bytes) Native() unsafe.Pointer {
	return unsafe.Pointer(&b.native)
}

// Compare compares the two #GBytes values.
//
// This function can be used to sort GBytes instances in lexicographical order.
//
// If @bytes1 and @bytes2 have different length but the shorter one is a prefix
// of the longer one then the shorter one is considered to be less than the
// longer one. Otherwise the first byte where both differ is used for
// comparison. If @bytes1 has a smaller value at that position it is considered
// less, otherwise greater than @bytes2.
func (b *Bytes) Compare(b Bytes, bytes2 Bytes) {
	var arg0 C.gpointer
	var arg1 C.gpointer

	arg0 = (C.gpointer)(unsafe.Pointer(b.Native()))
	arg1 = (C.gpointer)(unsafe.Pointer(bytes2.Native()))

	C.g_bytes_compare(arg0, arg1)
}

// Equal compares the two #GBytes values being pointed to and returns true if
// they are equal.
//
// This function can be passed to g_hash_table_new() as the @key_equal_func
// parameter, when using non-nil #GBytes pointers as keys in a Table.
func (b *Bytes) Equal(b Bytes, bytes2 Bytes) bool {
	var arg0 C.gpointer
	var arg1 C.gpointer

	arg0 = (C.gpointer)(unsafe.Pointer(b.Native()))
	arg1 = (C.gpointer)(unsafe.Pointer(bytes2.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.g_bytes_equal(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// Data: get the byte data in the #GBytes. This data should not be modified.
//
// This function will always return the same pointer for a given #GBytes.
//
// nil may be returned if @size is 0. This is not guaranteed, as the #GBytes may
// represent an empty string with @data non-nil and @size as 0. nil will not be
// returned if @size is non-zero.
func (b *Bytes) Data(b *Bytes) uint {
	var arg0 *C.GBytes

	arg0 = (*C.GBytes)(unsafe.Pointer(b.Native()))

	var arg1 C.gsize
	var size uint

	C.g_bytes_get_data(arg0, &arg1)

	size = uint(&arg1)

	return size
}

// Size: get the size of the byte data in the #GBytes.
//
// This function will always return the same value for a given #GBytes.
func (b *Bytes) Size(b *Bytes) {
	var arg0 *C.GBytes

	arg0 = (*C.GBytes)(unsafe.Pointer(b.Native()))

	C.g_bytes_get_size(arg0)
}

// Hash creates an integer hash code for the byte data in the #GBytes.
//
// This function can be passed to g_hash_table_new() as the @key_hash_func
// parameter, when using non-nil #GBytes pointers as keys in a Table.
func (b *Bytes) Hash(b Bytes) {
	var arg0 C.gpointer

	arg0 = (C.gpointer)(unsafe.Pointer(b.Native()))

	C.g_bytes_hash(arg0)
}

// NewFromBytes creates a #GBytes which is a subsection of another #GBytes. The
// @offset + @length may not be longer than the size of @bytes.
//
// A reference to @bytes will be held by the newly created #GBytes until the
// byte data is no longer needed.
//
// Since 2.56, if @offset is 0 and @length matches the size of @bytes, then
// @bytes will be returned with the reference count incremented by 1. If @bytes
// is a slice of another #GBytes, then the resulting #GBytes will reference the
// same #GBytes instead of @bytes. This allows consumers to simplify the usage
// of #GBytes when asynchronously writing to streams.
func (b *Bytes) NewFromBytes(b *Bytes, offset uint, length uint) {
	var arg0 *C.GBytes
	var arg1 C.gsize
	var arg2 C.gsize

	arg0 = (*C.GBytes)(unsafe.Pointer(b.Native()))
	arg1 = C.gsize(offset)
	arg2 = C.gsize(length)

	C.g_bytes_new_from_bytes(arg0, arg1, arg2)
}

// Ref: increase the reference count on @bytes.
func (b *Bytes) Ref(b *Bytes) {
	var arg0 *C.GBytes

	arg0 = (*C.GBytes)(unsafe.Pointer(b.Native()))

	C.g_bytes_ref(arg0)
}

// Unref releases a reference on @bytes. This may result in the bytes being
// freed. If @bytes is nil, it will return immediately.
func (b *Bytes) Unref(b *Bytes) {
	var arg0 *C.GBytes

	arg0 = (*C.GBytes)(unsafe.Pointer(b.Native()))

	C.g_bytes_unref(arg0)
}

// UnrefToArray unreferences the bytes, and returns a new mutable Array
// containing the same byte data.
//
// As an optimization, the byte data is transferred to the array without copying
// if this was the last reference to bytes and bytes was created with
// g_bytes_new(), g_bytes_new_take() or g_byte_array_free_to_bytes(). In all
// other cases the data is copied.
func (b *Bytes) UnrefToArray(b *Bytes) {
	var arg0 *C.GBytes

	arg0 = (*C.GBytes)(unsafe.Pointer(b.Native()))

	C.g_bytes_unref_to_array(arg0)
}

// UnrefToData unreferences the bytes, and returns a pointer the same byte data
// contents.
//
// As an optimization, the byte data is returned without copying if this was the
// last reference to bytes and bytes was created with g_bytes_new(),
// g_bytes_new_take() or g_byte_array_free_to_bytes(). In all other cases the
// data is copied.
func (b *Bytes) UnrefToData(b *Bytes) uint {
	var arg0 *C.GBytes

	arg0 = (*C.GBytes)(unsafe.Pointer(b.Native()))

	var arg1 C.gsize
	var size uint

	C.g_bytes_unref_to_data(arg0, &arg1)

	size = uint(&arg1)

	return size
}

// PtrArray contains the public fields of a pointer array.
type PtrArray struct {
	native C.GPtrArray
}

// WrapPtrArray wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPtrArray(ptr unsafe.Pointer) *PtrArray {
	if ptr == nil {
		return nil
	}

	return (*PtrArray)(ptr)
}

func marshalPtrArray(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapPtrArray(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (p *PtrArray) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

// Pdata gets the field inside the struct.
func (p *PtrArray) Pdata() interface{} {
	var v interface{}
	v = interface{}(p.native.pdata)
	return v
}

// Len gets the field inside the struct.
func (p *PtrArray) Len() uint {
	var v uint
	v = uint(p.native.len)
	return v
}
