// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"unsafe"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <glib.h>
import "C"

// Array contains the public fields of a GArray.
type Array struct {
	native C.GArray
}

// WrapArray wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapArray(ptr unsafe.Pointer) *Array {
	if ptr == nil {
		return nil
	}

	return (*Array)(ptr)
}

func marshalArray(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapArray(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (a *Array) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// Data gets the field inside the struct.
func (a *Array) Data() string {
	var v string
	v = C.GoString(a.native.data)
	return v
}

// Len gets the field inside the struct.
func (a *Array) Len() uint {
	var v uint
	v = uint(a.native.len)
	return v
}

// ByteArray contains the public fields of a GByteArray.
type ByteArray struct {
	native C.GByteArray
}

// WrapByteArray wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapByteArray(ptr unsafe.Pointer) *ByteArray {
	if ptr == nil {
		return nil
	}

	return (*ByteArray)(ptr)
}

func marshalByteArray(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapByteArray(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (b *ByteArray) Native() unsafe.Pointer {
	return unsafe.Pointer(&b.native)
}

// Data gets the field inside the struct.
func (b *ByteArray) Data() byte {
	var v byte
	v = byte(b.native.data)
	return v
}

// Len gets the field inside the struct.
func (b *ByteArray) Len() uint {
	var v uint
	v = uint(b.native.len)
	return v
}

// Bytes: a simple refcounted data type representing an immutable sequence of
// zero or more bytes from an unspecified origin.
//
// The purpose of a #GBytes is to keep the memory region that it holds alive for
// as long as anyone holds a reference to the bytes. When the last reference
// count is dropped, the memory is released. Multiple unrelated callers can use
// byte data in the #GBytes without coordinating their activities, resting
// assured that the byte data will not change or move while they hold a
// reference.
//
// A #GBytes can come from many different origins that may have different
// procedures for freeing the memory region. Examples are memory from
// g_malloc(), from memory slices, from a File or memory from other allocators.
//
// #GBytes work well as keys in Table. Use g_bytes_equal() and g_bytes_hash() as
// parameters to g_hash_table_new() or g_hash_table_new_full(). #GBytes can also
// be used as keys in a #GTree by passing the g_bytes_compare() function to
// g_tree_new().
//
// The data pointed to by this bytes must not be modified. For a mutable array
// of bytes see Array. Use g_bytes_unref_to_array() to create a mutable array
// for a #GBytes sequence. To create an immutable #GBytes from a mutable Array,
// use the g_byte_array_free_to_bytes() function.
type Bytes struct {
	native C.GBytes
}

// WrapBytes wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapBytes(ptr unsafe.Pointer) *Bytes {
	if ptr == nil {
		return nil
	}

	return (*Bytes)(ptr)
}

func marshalBytes(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapBytes(unsafe.Pointer(b)), nil
}

// NewBytes constructs a struct Bytes.
func NewBytes() *Bytes {
	cret := new(C.GBytes)
	var goret *Bytes

	cret = C.g_bytes_new(arg1, arg2)

	goret = WrapBytes(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *Bytes) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// NewBytesStatic constructs a struct Bytes.
func NewBytesStatic() *Bytes {
	cret := new(C.GBytes)
	var goret *Bytes

	cret = C.g_bytes_new_static(arg1, arg2)

	goret = WrapBytes(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *Bytes) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// NewBytesTake constructs a struct Bytes.
func NewBytesTake() *Bytes {
	cret := new(C.GBytes)
	var goret *Bytes

	cret = C.g_bytes_new_take(arg1, arg2)

	goret = WrapBytes(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *Bytes) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// Native returns the underlying C source pointer.
func (b *Bytes) Native() unsafe.Pointer {
	return unsafe.Pointer(&b.native)
}

// Compare compares the two #GBytes values.
//
// This function can be used to sort GBytes instances in lexicographical order.
//
// If @bytes1 and @bytes2 have different length but the shorter one is a prefix
// of the longer one then the shorter one is considered to be less than the
// longer one. Otherwise the first byte where both differ is used for
// comparison. If @bytes1 has a smaller value at that position it is considered
// less, otherwise greater than @bytes2.
func (b *Bytes) Compare(bytes2 Bytes) int {
	var arg0 C.gpointer
	var arg1 C.gpointer

	arg0 = (C.gpointer)(unsafe.Pointer(b.Native()))
	arg1 = (C.gpointer)(unsafe.Pointer(bytes2.Native()))

	var cret C.gint
	var goret int

	cret = C.g_bytes_compare(arg0, arg1)

	goret = int(cret)

	return goret
}

// Equal compares the two #GBytes values being pointed to and returns true if
// they are equal.
//
// This function can be passed to g_hash_table_new() as the @key_equal_func
// parameter, when using non-nil #GBytes pointers as keys in a Table.
func (b *Bytes) Equal(bytes2 Bytes) bool {
	var arg0 C.gpointer
	var arg1 C.gpointer

	arg0 = (C.gpointer)(unsafe.Pointer(b.Native()))
	arg1 = (C.gpointer)(unsafe.Pointer(bytes2.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.g_bytes_equal(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// Data: get the byte data in the #GBytes. This data should not be modified.
//
// This function will always return the same pointer for a given #GBytes.
//
// nil may be returned if @size is 0. This is not guaranteed, as the #GBytes may
// represent an empty string with @data non-nil and @size as 0. nil will not be
// returned if @size is non-zero.
func (b *Bytes) Data() []byte {
	var arg0 *C.GBytes

	arg0 = (*C.GBytes)(unsafe.Pointer(b.Native()))

	var cret C.gpointer
	var arg1 *C.gsize
	var goret []byte

	cret = C.g_bytes_get_data(arg0, arg1)

	goret = make([]byte, arg1)
	for i := 0; i < uintptr(arg1); i++ {
		src := (C.guint8)(ptr.Add(unsafe.Pointer(cret), i))
		goret[i] = byte(src)
	}

	return ret1, goret
}

// Size: get the size of the byte data in the #GBytes.
//
// This function will always return the same value for a given #GBytes.
func (b *Bytes) Size() uint {
	var arg0 *C.GBytes

	arg0 = (*C.GBytes)(unsafe.Pointer(b.Native()))

	var cret C.gsize
	var goret uint

	cret = C.g_bytes_get_size(arg0)

	goret = uint(cret)

	return goret
}

// Hash creates an integer hash code for the byte data in the #GBytes.
//
// This function can be passed to g_hash_table_new() as the @key_hash_func
// parameter, when using non-nil #GBytes pointers as keys in a Table.
func (b *Bytes) Hash() uint {
	var arg0 C.gpointer

	arg0 = (C.gpointer)(unsafe.Pointer(b.Native()))

	var cret C.guint
	var goret uint

	cret = C.g_bytes_hash(arg0)

	goret = uint(cret)

	return goret
}

// NewFromBytes creates a #GBytes which is a subsection of another #GBytes. The
// @offset + @length may not be longer than the size of @bytes.
//
// A reference to @bytes will be held by the newly created #GBytes until the
// byte data is no longer needed.
//
// Since 2.56, if @offset is 0 and @length matches the size of @bytes, then
// @bytes will be returned with the reference count incremented by 1. If @bytes
// is a slice of another #GBytes, then the resulting #GBytes will reference the
// same #GBytes instead of @bytes. This allows consumers to simplify the usage
// of #GBytes when asynchronously writing to streams.
func (b *Bytes) NewFromBytes(offset uint, length uint) *Bytes {
	var arg0 *C.GBytes
	var arg1 C.gsize
	var arg2 C.gsize

	arg0 = (*C.GBytes)(unsafe.Pointer(b.Native()))
	arg1 = C.gsize(offset)
	arg2 = C.gsize(length)

	cret := new(C.GBytes)
	var goret *Bytes

	cret = C.g_bytes_new_from_bytes(arg0, arg1, arg2)

	goret = WrapBytes(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *Bytes) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// Ref: increase the reference count on @bytes.
func (b *Bytes) Ref() *Bytes {
	var arg0 *C.GBytes

	arg0 = (*C.GBytes)(unsafe.Pointer(b.Native()))

	cret := new(C.GBytes)
	var goret *Bytes

	cret = C.g_bytes_ref(arg0)

	goret = WrapBytes(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *Bytes) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// Unref releases a reference on @bytes. This may result in the bytes being
// freed. If @bytes is nil, it will return immediately.
func (b *Bytes) Unref() {
	var arg0 *C.GBytes

	arg0 = (*C.GBytes)(unsafe.Pointer(b.Native()))

	C.g_bytes_unref(arg0)
}

// UnrefToArray unreferences the bytes, and returns a new mutable Array
// containing the same byte data.
//
// As an optimization, the byte data is transferred to the array without copying
// if this was the last reference to bytes and bytes was created with
// g_bytes_new(), g_bytes_new_take() or g_byte_array_free_to_bytes(). In all
// other cases the data is copied.
//
// Do not use it if @bytes contains more than G_MAXUINT bytes. Array stores the
// length of its data in #guint, which may be shorter than #gsize, that @bytes
// is using.
func (b *Bytes) UnrefToArray() []byte {
	var arg0 *C.GBytes

	arg0 = (*C.GBytes)(unsafe.Pointer(b.Native()))

	var cret *C.GByteArray
	var goret []byte

	cret = C.g_bytes_unref_to_array(arg0)

	{
		var length int
		for p := cret; *p != 0; p = (*C.GByteArray)(ptr.Add(unsafe.Pointer(p), C.sizeof_guint8)) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		goret = make([]byte, length)
		for i := uintptr(0); i < uintptr(length); i += C.sizeof_guint8 {
			src := (C.guint8)(ptr.Add(unsafe.Pointer(cret), i))
			goret[i] = byte(src)
		}
	}

	return goret
}

// UnrefToData unreferences the bytes, and returns a pointer the same byte data
// contents.
//
// As an optimization, the byte data is returned without copying if this was the
// last reference to bytes and bytes was created with g_bytes_new(),
// g_bytes_new_take() or g_byte_array_free_to_bytes(). In all other cases the
// data is copied.
func (b *Bytes) UnrefToData() []byte {
	var arg0 *C.GBytes

	arg0 = (*C.GBytes)(unsafe.Pointer(b.Native()))

	var cret C.gpointer
	var arg1 *C.gsize
	var goret []byte

	cret = C.g_bytes_unref_to_data(arg0, arg1)

	ptr.SetSlice(unsafe.Pointer(&goret), unsafe.Pointer(cret), int(arg1))
	runtime.SetFinalizer(&goret, func(v *[]byte) {
		C.free(ptr.Slice(unsafe.Pointer(v)))
	})

	return ret1, goret
}

// PtrArray contains the public fields of a pointer array.
type PtrArray struct {
	native C.GPtrArray
}

// WrapPtrArray wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPtrArray(ptr unsafe.Pointer) *PtrArray {
	if ptr == nil {
		return nil
	}

	return (*PtrArray)(ptr)
}

func marshalPtrArray(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapPtrArray(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (p *PtrArray) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

// Pdata gets the field inside the struct.
func (p *PtrArray) Pdata() interface{} {
	var v interface{}
	v = interface{}(p.native.pdata)
	return v
}

// Len gets the field inside the struct.
func (p *PtrArray) Len() uint {
	var v uint
	v = uint(p.native.len)
	return v
}
