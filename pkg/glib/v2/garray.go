// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"runtime"
	"runtime/cgo"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <glib.h>
// extern void callbackDelete(gpointer);
import "C"

// Array contains the public fields of a GArray.
//
// An instance of this type is always passed by reference.
type Array struct {
	*array
}

// array is the struct that's finalized.
type array struct {
	native *C.GArray
}

func marshalArray(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return &Array{&array{(*C.GArray)(unsafe.Pointer(b))}}, nil
}

// Data: pointer to the element data. The data may be moved as elements are
// added to the #GArray.
func (a *Array) Data() string {
	var v string // out
	v = C.GoString((*C.gchar)(unsafe.Pointer(a.native.data)))
	return v
}

// Len: number of elements in the #GArray not including the possible terminating
// zero element.
func (a *Array) Len() uint {
	var v uint // out
	v = uint(a.native.len)
	return v
}

// ByteArray contains the public fields of a GByteArray.
//
// An instance of this type is always passed by reference.
type ByteArray struct {
	*byteArray
}

// byteArray is the struct that's finalized.
type byteArray struct {
	native *C.GByteArray
}

func marshalByteArray(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return &ByteArray{&byteArray{(*C.GByteArray)(unsafe.Pointer(b))}}, nil
}

// Data: pointer to the element data. The data may be moved as elements are
// added to the Array
func (b *ByteArray) Data() *byte {
	var v *byte // out
	v = (*byte)(unsafe.Pointer(b.native.data))
	return v
}

// Len: number of elements in the Array
func (b *ByteArray) Len() uint {
	var v uint // out
	v = uint(b.native.len)
	return v
}

// Bytes: simple refcounted data type representing an immutable sequence of zero
// or more bytes from an unspecified origin.
//
// The purpose of a #GBytes is to keep the memory region that it holds alive for
// as long as anyone holds a reference to the bytes. When the last reference
// count is dropped, the memory is released. Multiple unrelated callers can use
// byte data in the #GBytes without coordinating their activities, resting
// assured that the byte data will not change or move while they hold a
// reference.
//
// A #GBytes can come from many different origins that may have different
// procedures for freeing the memory region. Examples are memory from
// g_malloc(), from memory slices, from a File or memory from other allocators.
//
// #GBytes work well as keys in Table. Use g_bytes_equal() and g_bytes_hash() as
// parameters to g_hash_table_new() or g_hash_table_new_full(). #GBytes can also
// be used as keys in a #GTree by passing the g_bytes_compare() function to
// g_tree_new().
//
// The data pointed to by this bytes must not be modified. For a mutable array
// of bytes see Array. Use g_bytes_unref_to_array() to create a mutable array
// for a #GBytes sequence. To create an immutable #GBytes from a mutable Array,
// use the g_byte_array_free_to_bytes() function.
//
// An instance of this type is always passed by reference.
type Bytes struct {
	*bytes
}

// bytes is the struct that's finalized.
type bytes struct {
	native *C.GBytes
}

func marshalBytes(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return &Bytes{&bytes{(*C.GBytes)(unsafe.Pointer(b))}}, nil
}

// PtrArray contains the public fields of a pointer array.
//
// An instance of this type is always passed by reference.
type PtrArray struct {
	*ptrArray
}

// ptrArray is the struct that's finalized.
type ptrArray struct {
	native *C.GPtrArray
}

func marshalPtrArray(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return &PtrArray{&ptrArray{(*C.GPtrArray)(unsafe.Pointer(b))}}, nil
}

// Pdata points to the array of pointers, which may be moved when the array
// grows
func (p *PtrArray) Pdata() *cgo.Handle {
	var v *cgo.Handle // out
	v = (*cgo.Handle)(unsafe.Pointer(p.native.pdata))
	return v
}

// Len: number of pointers in the array
func (p *PtrArray) Len() uint {
	var v uint // out
	v = uint(p.native.len)
	return v
}

// UseBytes is similar to NewBytes, except the given Go byte slice is
// not copied, but will be kept alive for the lifetime of the GBytes.
// Note that the user must NOT modify data.
//
// Refer to g_bytes_new_with_free_func() for more information.
func UseBytes(data []byte) *Bytes {
	byteID := gbox.Assign(data)

	v := C.g_bytes_new_with_free_func(
		C.gconstpointer(unsafe.Pointer(&data[0])),
		C.gsize(len(data)),
		C.GDestroyNotify((*[0]byte)(C.callbackDelete)),
		C.gpointer(byteID),
	)

	_bytes := (*Bytes)(gextras.NewStructNative(unsafe.Pointer(v)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	return _bytes
}
