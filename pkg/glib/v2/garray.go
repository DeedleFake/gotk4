// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"runtime"
	"unsafe"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib.h>
import "C"

// ByteArrayFree frees the memory allocated by the Array. If @free_segment is
// true it frees the actual byte data. If the reference count of @array is
// greater than one, the Array wrapper is preserved but the size of @array will
// be set to zero.
func ByteArrayFree(array []byte, freeSegment bool) *byte {
	var _arg1 *C.GByteArray
	var _arg2 C.gboolean // out
	var _cret *C.guint8  // in

	_arg1 = C.g_byte_array_new_take((*C.guint8)(&array[0]), C.gsize(len(array)))
	defer C.g_byte_array_steal(_arg1, nil)
	if freeSegment {
		_arg2 = C.TRUE
	}

	_cret = C.g_byte_array_free(_arg1, _arg2)

	var _guint8 *byte // out

	_guint8 = (*byte)(unsafe.Pointer(_cret))

	return _guint8
}

// NewByteArray creates a new Array with a reference count of 1.
func NewByteArray() []byte {
	var _cret *C.GByteArray

	_cret = C.g_byte_array_new()

	var _guint8s []byte

	{
		var len uintptr
		p := C.g_byte_array_steal(&_cret, (*C.gsize)(&len))
		_guint8s = unsafe.Slice((*byte)(p), len)
		runtime.SetFinalizer(&_guint8s, func(v *[]byte) {
			C.free(unsafe.Pointer(&(*v)[0]))
		})
	}

	return _guint8s
}

// ByteArrayNewTake: create byte array containing the data. The data will be
// owned by the array and will be freed with g_free(), i.e. it could be
// allocated using g_strdup().
//
// Do not use it if @len is greater than G_MAXUINT. Array stores the length of
// its data in #guint, which may be shorter than #gsize.
func ByteArrayNewTake(data []byte) []byte {
	var _arg1 *C.guint8
	var _arg2 C.gsize
	var _cret *C.GByteArray

	_arg2 = C.gsize(len(data))
	_arg1 = (*C.guint8)(C.malloc(C.ulong(len(data)) * C.ulong(C.sizeof_guint8)))
	{
		out := unsafe.Slice(_arg1, len(data))
		for i := range data {
			out[i] = C.guint8(data[i])
		}
	}

	_cret = C.g_byte_array_new_take(_arg1, _arg2)

	var _guint8s []byte

	{
		var len uintptr
		p := C.g_byte_array_steal(&_cret, (*C.gsize)(&len))
		_guint8s = unsafe.Slice((*byte)(p), len)
		runtime.SetFinalizer(&_guint8s, func(v *[]byte) {
			C.free(unsafe.Pointer(&(*v)[0]))
		})
	}

	return _guint8s
}

// ByteArraySteal frees the data in the array and resets the size to zero, while
// the underlying array is preserved for use elsewhere and returned to the
// caller.
func ByteArraySteal(array []byte) (uint, *byte) {
	var _arg1 *C.GByteArray
	var _arg2 C.gsize   // in
	var _cret *C.guint8 // in

	_arg1 = C.g_byte_array_new_take((*C.guint8)(&array[0]), C.gsize(len(array)))
	defer C.g_byte_array_steal(_arg1, nil)

	_cret = C.g_byte_array_steal(_arg1, &_arg2)

	var _len uint     // out
	var _guint8 *byte // out

	_len = uint(_arg2)
	_guint8 = (*byte)(unsafe.Pointer(_cret))

	return _len, _guint8
}

// ByteArrayUnref: atomically decrements the reference count of @array by one.
// If the reference count drops to 0, all memory allocated by the array is
// released. This function is thread-safe and may be called from any thread.
func ByteArrayUnref(array []byte) {
	var _arg1 *C.GByteArray

	_arg1 = C.g_byte_array_new_take((*C.guint8)(&array[0]), C.gsize(len(array)))
	defer C.g_byte_array_steal(_arg1, nil)

	C.g_byte_array_unref(_arg1)
}
