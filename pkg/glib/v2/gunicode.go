// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib.h>
import "C"

// NormalizeMode defines how a Unicode string is transformed in a canonical
// form, standardizing such issues as whether a character with an accent is
// represented as a base character and combining accent or as a single
// precomposed character. Unicode strings should generally be normalized before
// comparing them.
type NormalizeMode int

const (
	// Default: standardize differences that do not affect the text content,
	// such as the above-mentioned accent representation
	Default NormalizeMode = 0
	// NFD: another name for G_NORMALIZE_DEFAULT
	NFD NormalizeMode = 0
	// DefaultCompose: like G_NORMALIZE_DEFAULT, but with composed forms rather
	// than a maximally decomposed form
	DefaultCompose NormalizeMode = 1
	// NFC: another name for G_NORMALIZE_DEFAULT_COMPOSE
	NFC NormalizeMode = 1
	// All: beyond G_NORMALIZE_DEFAULT also standardize the "compatibility"
	// characters in Unicode, such as SUPERSCRIPT THREE to the standard forms
	// (in this case DIGIT THREE). Formatting information may be lost but for
	// most text operations such characters should be considered the same
	All NormalizeMode = 2
	// NFKD: another name for G_NORMALIZE_ALL
	NFKD NormalizeMode = 2
	// AllCompose: like G_NORMALIZE_ALL, but with composed forms rather than a
	// maximally decomposed form
	AllCompose NormalizeMode = 3
	// NFKC: another name for G_NORMALIZE_ALL_COMPOSE
	NFKC NormalizeMode = 3
)

// UnicodeBreakType: these are the possible line break classifications.
//
// Since new unicode versions may add new types here, applications should be
// ready to handle unknown values. They may be regarded as
// G_UNICODE_BREAK_UNKNOWN.
//
// See Unicode Line Breaking Algorithm
// (http://www.unicode.org/unicode/reports/tr14/).
type UnicodeBreakType int

const (
	// Mandatory: mandatory Break (BK)
	Mandatory UnicodeBreakType = iota
	// CarriageReturn: carriage Return (CR)
	CarriageReturn
	// LineFeed: line Feed (LF)
	LineFeed
	// CombiningMark: attached Characters and Combining Marks (CM)
	CombiningMark
	// Surrogate surrogates (SG)
	Surrogate
	// ZeroWidthSpace: zero Width Space (ZW)
	ZeroWidthSpace
	// Inseparable: inseparable (IN)
	Inseparable
	// NonBreakingGlue: non-breaking ("Glue") (GL)
	NonBreakingGlue
	// Contingent: contingent Break Opportunity (CB)
	Contingent
	// Space: space (SP)
	Space
	// After: break Opportunity After (BA)
	After
	// Before: break Opportunity Before (BB)
	Before
	// BeforeAndAfter: break Opportunity Before and After (B2)
	BeforeAndAfter
	// Hyphen: hyphen (HY)
	Hyphen
	// NonStarter: nonstarter (NS)
	NonStarter
	// OpenPunctuation: opening Punctuation (OP)
	OpenPunctuation
	// ClosePunctuation: closing Punctuation (CL)
	ClosePunctuation
	// Quotation ambiguous Quotation (QU)
	Quotation
	// Exclamation: exclamation/Interrogation (EX)
	Exclamation
	// Ideographic: ideographic (ID)
	Ideographic
	// Numeric: numeric (NU)
	Numeric
	// InfixSeparator: infix Separator (Numeric) (IS)
	InfixSeparator
	// Symbol symbols Allowing Break After (SY)
	Symbol
	// Alphabetic: ordinary Alphabetic and Symbol Characters (AL)
	Alphabetic
	// Prefix: prefix (Numeric) (PR)
	Prefix
	// Postfix: postfix (Numeric) (PO)
	Postfix
	// ComplexContext: complex Content Dependent (South East Asian) (SA)
	ComplexContext
	// Ambiguous ambiguous (Alphabetic or Ideographic) (AI)
	Ambiguous
	// Unknown: unknown (XX)
	Unknown
	// NextLine: next Line (NL)
	NextLine
	// WordJoiner: word Joiner (WJ)
	WordJoiner
	// HangulLJamo: hangul L Jamo (JL)
	HangulLJamo
	// HangulVJamo: hangul V Jamo (JV)
	HangulVJamo
	// HangulTJamo: hangul T Jamo (JT)
	HangulTJamo
	// HangulLvSyllable: hangul LV Syllable (H2)
	HangulLvSyllable
	// HangulLvtSyllable: hangul LVT Syllable (H3)
	HangulLvtSyllable
	// CloseParanthesis: closing Parenthesis (CP). Since 2.28
	CloseParanthesis
	// ConditionalJapaneseStarter: conditional Japanese Starter (CJ). Since:
	// 2.32
	ConditionalJapaneseStarter
	// HebrewLetter: hebrew Letter (HL). Since: 2.32
	HebrewLetter
	// RegionalIndicator: regional Indicator (RI). Since: 2.36
	RegionalIndicator
	// EmojiBase: emoji Base (EB). Since: 2.50
	EmojiBase
	// EmojiModifier: emoji Modifier (EM). Since: 2.50
	EmojiModifier
	// ZeroWidthJoiner: zero Width Joiner (ZWJ). Since: 2.50
	ZeroWidthJoiner
)

// UnicodeScript: the Script enumeration identifies different writing systems.
// The values correspond to the names as defined in the Unicode standard. The
// enumeration has been added in GLib 2.14, and is interchangeable with Script.
//
// Note that new types may be added in the future. Applications should be ready
// to handle unknown values. See Unicode Standard Annex #24: Script names
// (http://www.unicode.org/reports/tr24/).
type UnicodeScript int

const (
	// InvalidCode: value never returned from g_unichar_get_script()
	InvalidCode UnicodeScript = -1
	// Common: character used by multiple different scripts
	Common UnicodeScript = 0
	// Inherited: mark glyph that takes its script from the base glyph to which
	// it is attached
	Inherited UnicodeScript = 1
	// Arabic: arabic
	Arabic UnicodeScript = 2
	// Armenian: armenian
	Armenian UnicodeScript = 3
	// Bengali: bengali
	Bengali UnicodeScript = 4
	// Bopomofo: bopomofo
	Bopomofo UnicodeScript = 5
	// Cherokee: cherokee
	Cherokee UnicodeScript = 6
	// Coptic: coptic
	Coptic UnicodeScript = 7
	// Cyrillic: cyrillic
	Cyrillic UnicodeScript = 8
	// Deseret: deseret
	Deseret UnicodeScript = 9
	// Devanagari: devanagari
	Devanagari UnicodeScript = 10
	// Ethiopic: ethiopic
	Ethiopic UnicodeScript = 11
	// Georgian: georgian
	Georgian UnicodeScript = 12
	// Gothic: gothic
	Gothic UnicodeScript = 13
	// Greek: greek
	Greek UnicodeScript = 14
	// Gujarati: gujarati
	Gujarati UnicodeScript = 15
	// Gurmukhi: gurmukhi
	Gurmukhi UnicodeScript = 16
	// Han: han
	Han UnicodeScript = 17
	// Hangul: hangul
	Hangul UnicodeScript = 18
	// Hebrew: hebrew
	Hebrew UnicodeScript = 19
	// Hiragana: hiragana
	Hiragana UnicodeScript = 20
	// Kannada: kannada
	Kannada UnicodeScript = 21
	// Katakana: katakana
	Katakana UnicodeScript = 22
	// Khmer: khmer
	Khmer UnicodeScript = 23
	// Lao: lao
	Lao UnicodeScript = 24
	// Latin: latin
	Latin UnicodeScript = 25
	// Malayalam: malayalam
	Malayalam UnicodeScript = 26
	// Mongolian: mongolian
	Mongolian UnicodeScript = 27
	// Myanmar: myanmar
	Myanmar UnicodeScript = 28
	// Ogham: ogham
	Ogham UnicodeScript = 29
	// OldItalic: old Italic
	OldItalic UnicodeScript = 30
	// Oriya: oriya
	Oriya UnicodeScript = 31
	// Runic: runic
	Runic UnicodeScript = 32
	// Sinhala: sinhala
	Sinhala UnicodeScript = 33
	// Syriac: syriac
	Syriac UnicodeScript = 34
	// Tamil: tamil
	Tamil UnicodeScript = 35
	// Telugu: telugu
	Telugu UnicodeScript = 36
	// Thaana: thaana
	Thaana UnicodeScript = 37
	// Thai: thai
	Thai UnicodeScript = 38
	// Tibetan: tibetan
	Tibetan UnicodeScript = 39
	// CanadianAboriginal: canadian Aboriginal
	CanadianAboriginal UnicodeScript = 40
	// Yi: yi
	Yi UnicodeScript = 41
	// Tagalog: tagalog
	Tagalog UnicodeScript = 42
	// Hanunoo: hanunoo
	Hanunoo UnicodeScript = 43
	// Buhid: buhid
	Buhid UnicodeScript = 44
	// Tagbanwa: tagbanwa
	Tagbanwa UnicodeScript = 45
	// Braille: braille
	Braille UnicodeScript = 46
	// Cypriot: cypriot
	Cypriot UnicodeScript = 47
	// Limbu: limbu
	Limbu UnicodeScript = 48
	// Osmanya: osmanya
	Osmanya UnicodeScript = 49
	// Shavian: shavian
	Shavian UnicodeScript = 50
	// LinearB: linear B
	LinearB UnicodeScript = 51
	// TaiLe: tai Le
	TaiLe UnicodeScript = 52
	// Ugaritic: ugaritic
	Ugaritic UnicodeScript = 53
	// NewTaiLue: new Tai Lue
	NewTaiLue UnicodeScript = 54
	// Buginese: buginese
	Buginese UnicodeScript = 55
	// Glagolitic: glagolitic
	Glagolitic UnicodeScript = 56
	// Tifinagh: tifinagh
	Tifinagh UnicodeScript = 57
	// SylotiNagri: syloti Nagri
	SylotiNagri UnicodeScript = 58
	// OldPersian: old Persian
	OldPersian UnicodeScript = 59
	// Kharoshthi: kharoshthi
	Kharoshthi UnicodeScript = 60
	// Unknown: unassigned code point
	Unknown UnicodeScript = 61
	// Balinese: balinese
	Balinese UnicodeScript = 62
	// Cuneiform: cuneiform
	Cuneiform UnicodeScript = 63
	// Phoenician: phoenician
	Phoenician UnicodeScript = 64
	// PhagsPa: phags-pa
	PhagsPa UnicodeScript = 65
	// Nko: n'Ko
	Nko UnicodeScript = 66
	// KayahLi: kayah Li. Since 2.16.3
	KayahLi UnicodeScript = 67
	// Lepcha: lepcha. Since 2.16.3
	Lepcha UnicodeScript = 68
	// Rejang: rejang. Since 2.16.3
	Rejang UnicodeScript = 69
	// Sundanese: sundanese. Since 2.16.3
	Sundanese UnicodeScript = 70
	// Saurashtra: saurashtra. Since 2.16.3
	Saurashtra UnicodeScript = 71
	// Cham: cham. Since 2.16.3
	Cham UnicodeScript = 72
	// OlChiki: ol Chiki. Since 2.16.3
	OlChiki UnicodeScript = 73
	// Vai: vai. Since 2.16.3
	Vai UnicodeScript = 74
	// Carian: carian. Since 2.16.3
	Carian UnicodeScript = 75
	// Lycian: lycian. Since 2.16.3
	Lycian UnicodeScript = 76
	// Lydian: lydian. Since 2.16.3
	Lydian UnicodeScript = 77
	// Avestan: avestan. Since 2.26
	Avestan UnicodeScript = 78
	// Bamum: bamum. Since 2.26
	Bamum UnicodeScript = 79
	// EgyptianHieroglyphs: egyptian Hieroglpyhs. Since 2.26
	EgyptianHieroglyphs UnicodeScript = 80
	// ImperialAramaic: imperial Aramaic. Since 2.26
	ImperialAramaic UnicodeScript = 81
	// InscriptionalPahlavi: inscriptional Pahlavi. Since 2.26
	InscriptionalPahlavi UnicodeScript = 82
	// InscriptionalParthian: inscriptional Parthian. Since 2.26
	InscriptionalParthian UnicodeScript = 83
	// Javanese: javanese. Since 2.26
	Javanese UnicodeScript = 84
	// Kaithi: kaithi. Since 2.26
	Kaithi UnicodeScript = 85
	// Lisu: lisu. Since 2.26
	Lisu UnicodeScript = 86
	// MeeteiMayek: meetei Mayek. Since 2.26
	MeeteiMayek UnicodeScript = 87
	// OldSouthArabian: old South Arabian. Since 2.26
	OldSouthArabian UnicodeScript = 88
	// OldTurkic: old Turkic. Since 2.28
	OldTurkic UnicodeScript = 89
	// Samaritan: samaritan. Since 2.26
	Samaritan UnicodeScript = 90
	// TaiTham: tai Tham. Since 2.26
	TaiTham UnicodeScript = 91
	// TaiViet: tai Viet. Since 2.26
	TaiViet UnicodeScript = 92
	// Batak: batak. Since 2.28
	Batak UnicodeScript = 93
	// Brahmi: brahmi. Since 2.28
	Brahmi UnicodeScript = 94
	// Mandaic: mandaic. Since 2.28
	Mandaic UnicodeScript = 95
	// Chakma: chakma. Since: 2.32
	Chakma UnicodeScript = 96
	// MeroiticCursive: meroitic Cursive. Since: 2.32
	MeroiticCursive UnicodeScript = 97
	// MeroiticHieroglyphs: meroitic Hieroglyphs. Since: 2.32
	MeroiticHieroglyphs UnicodeScript = 98
	// Miao: miao. Since: 2.32
	Miao UnicodeScript = 99
	// Sharada: sharada. Since: 2.32
	Sharada UnicodeScript = 100
	// SoraSompeng: sora Sompeng. Since: 2.32
	SoraSompeng UnicodeScript = 101
	// Takri: takri. Since: 2.32
	Takri UnicodeScript = 102
	// BassaVah: bassa. Since: 2.42
	BassaVah UnicodeScript = 103
	// CaucasianAlbanian: caucasian Albanian. Since: 2.42
	CaucasianAlbanian UnicodeScript = 104
	// Duployan: duployan. Since: 2.42
	Duployan UnicodeScript = 105
	// Elbasan: elbasan. Since: 2.42
	Elbasan UnicodeScript = 106
	// Grantha: grantha. Since: 2.42
	Grantha UnicodeScript = 107
	// Khojki: kjohki. Since: 2.42
	Khojki UnicodeScript = 108
	// Khudawadi: khudawadi, Sindhi. Since: 2.42
	Khudawadi UnicodeScript = 109
	// LinearA: linear A. Since: 2.42
	LinearA UnicodeScript = 110
	// Mahajani: mahajani. Since: 2.42
	Mahajani UnicodeScript = 111
	// Manichaean: manichaean. Since: 2.42
	Manichaean UnicodeScript = 112
	// MendeKikakui: mende Kikakui. Since: 2.42
	MendeKikakui UnicodeScript = 113
	// Modi: modi. Since: 2.42
	Modi UnicodeScript = 114
	// Mro: mro. Since: 2.42
	Mro UnicodeScript = 115
	// Nabataean: nabataean. Since: 2.42
	Nabataean UnicodeScript = 116
	// OldNorthArabian: old North Arabian. Since: 2.42
	OldNorthArabian UnicodeScript = 117
	// OldPermic: old Permic. Since: 2.42
	OldPermic UnicodeScript = 118
	// PahawhHmong: pahawh Hmong. Since: 2.42
	PahawhHmong UnicodeScript = 119
	// Palmyrene: palmyrene. Since: 2.42
	Palmyrene UnicodeScript = 120
	// PauCinHau: pau Cin Hau. Since: 2.42
	PauCinHau UnicodeScript = 121
	// PsalterPahlavi: psalter Pahlavi. Since: 2.42
	PsalterPahlavi UnicodeScript = 122
	// Siddham: siddham. Since: 2.42
	Siddham UnicodeScript = 123
	// Tirhuta: tirhuta. Since: 2.42
	Tirhuta UnicodeScript = 124
	// WarangCiti: warang Citi. Since: 2.42
	WarangCiti UnicodeScript = 125
	// Ahom: ahom. Since: 2.48
	Ahom UnicodeScript = 126
	// AnatolianHieroglyphs: anatolian Hieroglyphs. Since: 2.48
	AnatolianHieroglyphs UnicodeScript = 127
	// Hatran: hatran. Since: 2.48
	Hatran UnicodeScript = 128
	// Multani: multani. Since: 2.48
	Multani UnicodeScript = 129
	// OldHungarian: old Hungarian. Since: 2.48
	OldHungarian UnicodeScript = 130
	// Signwriting: signwriting. Since: 2.48
	Signwriting UnicodeScript = 131
	// Adlam: adlam. Since: 2.50
	Adlam UnicodeScript = 132
	// Bhaiksuki: bhaiksuki. Since: 2.50
	Bhaiksuki UnicodeScript = 133
	// Marchen: marchen. Since: 2.50
	Marchen UnicodeScript = 134
	// Newa: newa. Since: 2.50
	Newa UnicodeScript = 135
	// Osage: osage. Since: 2.50
	Osage UnicodeScript = 136
	// Tangut: tangut. Since: 2.50
	Tangut UnicodeScript = 137
	// MasaramGondi: masaram Gondi. Since: 2.54
	MasaramGondi UnicodeScript = 138
	// Nushu: nushu. Since: 2.54
	Nushu UnicodeScript = 139
	// Soyombo: soyombo. Since: 2.54
	Soyombo UnicodeScript = 140
	// ZanabazarSquare: zanabazar Square. Since: 2.54
	ZanabazarSquare UnicodeScript = 141
	// Dogra: dogra. Since: 2.58
	Dogra UnicodeScript = 142
	// GunjalaGondi: gunjala Gondi. Since: 2.58
	GunjalaGondi UnicodeScript = 143
	// HanifiRohingya: hanifi Rohingya. Since: 2.58
	HanifiRohingya UnicodeScript = 144
	// Makasar: makasar. Since: 2.58
	Makasar UnicodeScript = 145
	// Medefaidrin: medefaidrin. Since: 2.58
	Medefaidrin UnicodeScript = 146
	// OldSogdian: old Sogdian. Since: 2.58
	OldSogdian UnicodeScript = 147
	// Sogdian: sogdian. Since: 2.58
	Sogdian UnicodeScript = 148
	// Elymaic: elym. Since: 2.62
	Elymaic UnicodeScript = 149
	// Nandinagari: nand. Since: 2.62
	Nandinagari UnicodeScript = 150
	// NyiakengPuachueHmong: rohg. Since: 2.62
	NyiakengPuachueHmong UnicodeScript = 151
	// Wancho: wcho. Since: 2.62
	Wancho UnicodeScript = 152
	// Chorasmian: chorasmian. Since: 2.66
	Chorasmian UnicodeScript = 153
	// DivesAkuru dives Akuru. Since: 2.66
	DivesAkuru UnicodeScript = 154
	// KhitanSmallScript: khitan small script. Since: 2.66
	KhitanSmallScript UnicodeScript = 155
	// Yezidi: yezidi. Since: 2.66
	Yezidi UnicodeScript = 156
)

// UnicodeType: these are the possible character classifications from the
// Unicode specification. See Unicode Character Database
// (http://www.unicode.org/reports/tr44/Category_Values).
type UnicodeType int

const (
	// Control: general category "Other, Control" (Cc)
	Control UnicodeType = iota
	// Format: general category "Other, Format" (Cf)
	Format
	// Unassigned: general category "Other, Not Assigned" (Cn)
	Unassigned
	// PrivateUse: general category "Other, Private Use" (Co)
	PrivateUse
	// Surrogate: general category "Other, Surrogate" (Cs)
	Surrogate
	// LowercaseLetter: general category "Letter, Lowercase" (Ll)
	LowercaseLetter
	// ModifierLetter: general category "Letter, Modifier" (Lm)
	ModifierLetter
	// OtherLetter: general category "Letter, Other" (Lo)
	OtherLetter
	// TitlecaseLetter: general category "Letter, Titlecase" (Lt)
	TitlecaseLetter
	// UppercaseLetter: general category "Letter, Uppercase" (Lu)
	UppercaseLetter
	// SpacingMark: general category "Mark, Spacing" (Mc)
	SpacingMark
	// EnclosingMark: general category "Mark, Enclosing" (Me)
	EnclosingMark
	// NonSpacingMark: general category "Mark, Nonspacing" (Mn)
	NonSpacingMark
	// DecimalNumber: general category "Number, Decimal Digit" (Nd)
	DecimalNumber
	// LetterNumber: general category "Number, Letter" (Nl)
	LetterNumber
	// OtherNumber: general category "Number, Other" (No)
	OtherNumber
	// ConnectPunctuation: general category "Punctuation, Connector" (Pc)
	ConnectPunctuation
	// DashPunctuation: general category "Punctuation, Dash" (Pd)
	DashPunctuation
	// ClosePunctuation: general category "Punctuation, Close" (Pe)
	ClosePunctuation
	// FinalPunctuation: general category "Punctuation, Final quote" (Pf)
	FinalPunctuation
	// InitialPunctuation: general category "Punctuation, Initial quote" (Pi)
	InitialPunctuation
	// OtherPunctuation: general category "Punctuation, Other" (Po)
	OtherPunctuation
	// OpenPunctuation: general category "Punctuation, Open" (Ps)
	OpenPunctuation
	// CurrencySymbol: general category "Symbol, Currency" (Sc)
	CurrencySymbol
	// ModifierSymbol: general category "Symbol, Modifier" (Sk)
	ModifierSymbol
	// MathSymbol: general category "Symbol, Math" (Sm)
	MathSymbol
	// OtherSymbol: general category "Symbol, Other" (So)
	OtherSymbol
	// LineSeparator: general category "Separator, Line" (Zl)
	LineSeparator
	// ParagraphSeparator: general category "Separator, Paragraph" (Zp)
	ParagraphSeparator
	// SpaceSeparator: general category "Separator, Space" (Zs)
	SpaceSeparator
)

// UCS4ToUTF16: convert a string from UCS-4 to UTF-16. A 0 character will be
// added to the result after the converted text.
func UCS4ToUTF16(str *uint32, len int32) (itemsRead int32, itemsWritten int32, guint16 *uint16, goerr error) {
	var _arg1 *C.gunichar  // out
	var _arg2 C.glong      // out
	var _arg3 C.glong      // in
	var _arg4 C.glong      // in
	var _cret *C.gunichar2 // in
	var _cerr *C.GError    // in

	_arg1 = (*C.gunichar)(unsafe.Pointer(str))
	_arg2 = C.glong(len)

	_cret = C.g_ucs4_to_utf16(_arg1, _arg2, &_arg3, &_arg4, &_cerr)

	var _itemsRead int32    // out
	var _itemsWritten int32 // out
	var _guint16 *uint16    // out
	var _goerr error        // out

	_itemsRead = int32(_arg3)
	_itemsWritten = int32(_arg4)
	_guint16 = (*uint16)(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _itemsRead, _itemsWritten, _guint16, _goerr
}

// UCS4ToUTF8: convert a string from a 32-bit fixed width representation as
// UCS-4. to UTF-8. The result will be terminated with a 0 byte.
func UCS4ToUTF8(str *uint32, len int32) (itemsRead int32, itemsWritten int32, utf8 string, goerr error) {
	var _arg1 *C.gunichar // out
	var _arg2 C.glong     // out
	var _arg3 C.glong     // in
	var _arg4 C.glong     // in
	var _cret *C.gchar    // in
	var _cerr *C.GError   // in

	_arg1 = (*C.gunichar)(unsafe.Pointer(str))
	_arg2 = C.glong(len)

	_cret = C.g_ucs4_to_utf8(_arg1, _arg2, &_arg3, &_arg4, &_cerr)

	var _itemsRead int32    // out
	var _itemsWritten int32 // out
	var _utf8 string        // out
	var _goerr error        // out

	_itemsRead = int32(_arg3)
	_itemsWritten = int32(_arg4)
	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _itemsRead, _itemsWritten, _utf8, _goerr
}

// UnicharBreakType determines the break type of @c. @c should be a Unicode
// character (to derive a character from UTF-8 encoded text, use
// g_utf8_get_char()). The break type is used to find word and line breaks
// ("text boundaries"), Pango implements the Unicode boundary resolution
// algorithms and normally you would use a function such as pango_break()
// instead of caring about break types yourself.
func UnicharBreakType(c uint32) UnicodeBreakType {
	var _arg1 C.gunichar          // out
	var _cret C.GUnicodeBreakType // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_break_type(_arg1)

	var _unicodeBreakType UnicodeBreakType // out

	_unicodeBreakType = UnicodeBreakType(_cret)

	return _unicodeBreakType
}

// UnicharCombiningClass determines the canonical combining class of a Unicode
// character.
func UnicharCombiningClass(uc uint32) int {
	var _arg1 C.gunichar // out
	var _cret C.gint     // in

	_arg1 = C.gunichar(uc)

	_cret = C.g_unichar_combining_class(_arg1)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// UnicharCompose performs a single composition step of the Unicode canonical
// composition algorithm.
//
// This function includes algorithmic Hangul Jamo composition, but it is not
// exactly the inverse of g_unichar_decompose(). No composition can have either
// of @a or @b equal to zero. To be precise, this function composes if and only
// if there exists a Primary Composite P which is canonically equivalent to the
// sequence <@a,@b>. See the Unicode Standard for the definition of Primary
// Composite.
//
// If @a and @b do not compose a new character, @ch is set to zero.
//
// See UAX#15 (http://unicode.org/reports/tr15/) for details.
func UnicharCompose(a uint32, b uint32) (uint32, bool) {
	var _arg1 C.gunichar // out
	var _arg2 C.gunichar // out
	var _arg3 C.gunichar // in
	var _cret C.gboolean // in

	_arg1 = C.gunichar(a)
	_arg2 = C.gunichar(b)

	_cret = C.g_unichar_compose(_arg1, _arg2, &_arg3)

	var _ch uint32 // out
	var _ok bool   // out

	_ch = uint32(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _ch, _ok
}

// UnicharDecompose performs a single decomposition step of the Unicode
// canonical decomposition algorithm.
//
// This function does not include compatibility decompositions. It does,
// however, include algorithmic Hangul Jamo decomposition, as well as
// 'singleton' decompositions which replace a character by a single other
// character. In the case of singletons *@b will be set to zero.
//
// If @ch is not decomposable, *@a is set to @ch and *@b is set to zero.
//
// Note that the way Unicode decomposition pairs are defined, it is guaranteed
// that @b would not decompose further, but @a may itself decompose. To get the
// full canonical decomposition for @ch, one would need to recursively call this
// function on @a. Or use g_unichar_fully_decompose().
//
// See UAX#15 (http://unicode.org/reports/tr15/) for details.
func UnicharDecompose(ch uint32) (a uint32, b uint32, ok bool) {
	var _arg1 C.gunichar // out
	var _arg2 C.gunichar // in
	var _arg3 C.gunichar // in
	var _cret C.gboolean // in

	_arg1 = C.gunichar(ch)

	_cret = C.g_unichar_decompose(_arg1, &_arg2, &_arg3)

	var _a uint32 // out
	var _b uint32 // out
	var _ok bool  // out

	_a = uint32(_arg2)
	_b = uint32(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _a, _b, _ok
}

// UnicharDigitValue determines the numeric value of a character as a decimal
// digit.
func UnicharDigitValue(c uint32) int {
	var _arg1 C.gunichar // out
	var _cret C.gint     // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_digit_value(_arg1)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// UnicharFullyDecompose computes the canonical or compatibility decomposition
// of a Unicode character. For compatibility decomposition, pass true for
// @compat; for canonical decomposition pass false for @compat.
//
// The decomposed sequence is placed in @result. Only up to @result_len
// characters are written into @result. The length of the full decomposition
// (irrespective of @result_len) is returned by the function. For canonical
// decomposition, currently all decompositions are of length at most 4, but this
// may change in the future (very unlikely though). At any rate, Unicode does
// guarantee that a buffer of length 18 is always enough for both compatibility
// and canonical decompositions, so that is the size recommended. This is
// provided as G_UNICHAR_MAX_DECOMPOSITION_LENGTH.
//
// See UAX#15 (http://unicode.org/reports/tr15/) for details.
func UnicharFullyDecompose(ch uint32, compat bool, resultLen uint) (uint32, uint) {
	var _arg1 C.gunichar // out
	var _arg2 C.gboolean // out
	var _arg3 C.gunichar // in
	var _arg4 C.gsize    // out
	var _cret C.gsize    // in

	_arg1 = C.gunichar(ch)
	if compat {
		_arg2 = C.TRUE
	}
	_arg4 = C.gsize(resultLen)

	_cret = C.g_unichar_fully_decompose(_arg1, _arg2, &_arg3, _arg4)

	var _result uint32 // out
	var _gsize uint    // out

	_result = uint32(_arg3)
	_gsize = uint(_cret)

	return _result, _gsize
}

// UnicharGetMirrorChar: in Unicode, some characters are "mirrored". This means
// that their images are mirrored horizontally in text that is laid out from
// right to left. For instance, "(" would become its mirror image, ")", in
// right-to-left text.
//
// If @ch has the Unicode mirrored property and there is another unicode
// character that typically has a glyph that is the mirror image of @ch's glyph
// and @mirrored_ch is set, it puts that character in the address pointed to by
// @mirrored_ch. Otherwise the original character is put.
func UnicharGetMirrorChar(ch uint32, mirroredCh *uint32) bool {
	var _arg1 C.gunichar  // out
	var _arg2 *C.gunichar // out
	var _cret C.gboolean  // in

	_arg1 = C.gunichar(ch)
	_arg2 = (*C.gunichar)(unsafe.Pointer(mirroredCh))

	_cret = C.g_unichar_get_mirror_char(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharGetScript looks up the Script for a particular character (as defined
// by Unicode Standard Annex \#24). No check is made for @ch being a valid
// Unicode character; if you pass in invalid character, the result is undefined.
//
// This function is equivalent to pango_script_for_unichar() and the two are
// interchangeable.
func UnicharGetScript(ch uint32) UnicodeScript {
	var _arg1 C.gunichar       // out
	var _cret C.GUnicodeScript // in

	_arg1 = C.gunichar(ch)

	_cret = C.g_unichar_get_script(_arg1)

	var _unicodeScript UnicodeScript // out

	_unicodeScript = UnicodeScript(_cret)

	return _unicodeScript
}

// UnicharIsalnum determines whether a character is alphanumeric. Given some
// UTF-8 text, obtain a character value with g_utf8_get_char().
func UnicharIsalnum(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_isalnum(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsalpha determines whether a character is alphabetic (i.e. a letter).
// Given some UTF-8 text, obtain a character value with g_utf8_get_char().
func UnicharIsalpha(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_isalpha(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIscntrl determines whether a character is a control character. Given
// some UTF-8 text, obtain a character value with g_utf8_get_char().
func UnicharIscntrl(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_iscntrl(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsdefined determines if a given character is assigned in the Unicode
// standard.
func UnicharIsdefined(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_isdefined(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsdigit determines whether a character is numeric (i.e. a digit). This
// covers ASCII 0-9 and also digits in other languages/scripts. Given some UTF-8
// text, obtain a character value with g_utf8_get_char().
func UnicharIsdigit(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_isdigit(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsgraph determines whether a character is printable and not a space
// (returns false for control characters, format characters, and spaces).
// g_unichar_isprint() is similar, but returns true for spaces. Given some UTF-8
// text, obtain a character value with g_utf8_get_char().
func UnicharIsgraph(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_isgraph(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIslower determines whether a character is a lowercase letter. Given
// some UTF-8 text, obtain a character value with g_utf8_get_char().
func UnicharIslower(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_islower(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsmark determines whether a character is a mark (non-spacing mark,
// combining mark, or enclosing mark in Unicode speak). Given some UTF-8 text,
// obtain a character value with g_utf8_get_char().
//
// Note: in most cases where isalpha characters are allowed, ismark characters
// should be allowed to as they are essential for writing most European
// languages as well as many non-Latin scripts.
func UnicharIsmark(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_ismark(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsprint determines whether a character is printable. Unlike
// g_unichar_isgraph(), returns true for spaces. Given some UTF-8 text, obtain a
// character value with g_utf8_get_char().
func UnicharIsprint(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_isprint(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIspunct determines whether a character is punctuation or a symbol.
// Given some UTF-8 text, obtain a character value with g_utf8_get_char().
func UnicharIspunct(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_ispunct(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsspace determines whether a character is a space, tab, or line
// separator (newline, carriage return, etc.). Given some UTF-8 text, obtain a
// character value with g_utf8_get_char().
//
// (Note: don't use this to do word breaking; you have to use Pango or
// equivalent to get word breaking right, the algorithm is fairly complex.)
func UnicharIsspace(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_isspace(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIstitle determines if a character is titlecase. Some characters in
// Unicode which are composites, such as the DZ digraph have three case variants
// instead of just two. The titlecase form is used at the beginning of a word
// where only the first letter is capitalized. The titlecase form of the DZ
// digraph is U+01F2 LATIN CAPITAL LETTTER D WITH SMALL LETTER Z.
func UnicharIstitle(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_istitle(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsupper determines if a character is uppercase.
func UnicharIsupper(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_isupper(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIswide determines if a character is typically rendered in a
// double-width cell.
func UnicharIswide(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_iswide(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIswideCjk determines if a character is typically rendered in a
// double-width cell under legacy East Asian locales. If a character is wide
// according to g_unichar_iswide(), then it is also reported wide with this
// function, but the converse is not necessarily true. See the Unicode Standard
// Annex #11 (http://www.unicode.org/reports/tr11/) for details.
//
// If a character passes the g_unichar_iswide() test then it will also pass this
// test, but not the other way around. Note that some characters may pass both
// this test and g_unichar_iszerowidth().
func UnicharIswideCjk(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_iswide_cjk(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsxdigit determines if a character is a hexadecimal digit.
func UnicharIsxdigit(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_isxdigit(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIszerowidth determines if a given character typically takes zero width
// when rendered. The return value is true for all non-spacing and enclosing
// marks (e.g., combining accents), format characters, zero-width space, but not
// U+00AD SOFT HYPHEN.
//
// A typical use of this function is with one of g_unichar_iswide() or
// g_unichar_iswide_cjk() to determine the number of cells a string occupies
// when displayed on a grid display (terminals). However, note that not all
// terminals support zero-width rendering of zero-width marks.
func UnicharIszerowidth(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_iszerowidth(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharToLower converts a character to lower case.
func UnicharToLower(c uint32) uint32 {
	var _arg1 C.gunichar // out
	var _cret C.gunichar // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_tolower(_arg1)

	var _gunichar uint32 // out

	_gunichar = uint32(_cret)

	return _gunichar
}

// UnicharToTitle converts a character to the titlecase.
func UnicharToTitle(c uint32) uint32 {
	var _arg1 C.gunichar // out
	var _cret C.gunichar // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_totitle(_arg1)

	var _gunichar uint32 // out

	_gunichar = uint32(_cret)

	return _gunichar
}

// UnicharToUpper converts a character to uppercase.
func UnicharToUpper(c uint32) uint32 {
	var _arg1 C.gunichar // out
	var _cret C.gunichar // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_toupper(_arg1)

	var _gunichar uint32 // out

	_gunichar = uint32(_cret)

	return _gunichar
}

// UnicharType classifies a Unicode character by type.
func UnicharType(c uint32) UnicodeType {
	var _arg1 C.gunichar     // out
	var _cret C.GUnicodeType // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_type(_arg1)

	var _unicodeType UnicodeType // out

	_unicodeType = UnicodeType(_cret)

	return _unicodeType
}

// UnicharValidate checks whether @ch is a valid Unicode character. Some
// possible integer values of @ch will not be valid. 0 is considered a valid
// character, though it's normally a string terminator.
func UnicharValidate(ch uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(ch)

	_cret = C.g_unichar_validate(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharXDigitValue determines the numeric value of a character as a
// hexadecimal digit.
func UnicharXDigitValue(c uint32) int {
	var _arg1 C.gunichar // out
	var _cret C.gint     // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_xdigit_value(_arg1)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// UnicodeCanonicalDecomposition computes the canonical decomposition of a
// Unicode character.
//
// Deprecated: since version 2.30.
func UnicodeCanonicalDecomposition(ch uint32, resultLen *uint) *uint32 {
	var _arg1 C.gunichar  // out
	var _arg2 *C.gsize    // out
	var _cret *C.gunichar // in

	_arg1 = C.gunichar(ch)
	_arg2 = (*C.gsize)(unsafe.Pointer(resultLen))

	_cret = C.g_unicode_canonical_decomposition(_arg1, _arg2)

	var _gunichar *uint32 // out

	_gunichar = (*uint32)(unsafe.Pointer(_cret))

	return _gunichar
}

// UnicodeCanonicalOrdering computes the canonical ordering of a string
// in-place. This rearranges decomposed characters in the string according to
// their combining classes. See the Unicode manual for more information.
func UnicodeCanonicalOrdering(_string *uint32, len uint) {
	var _arg1 *C.gunichar // out
	var _arg2 C.gsize     // out

	_arg1 = (*C.gunichar)(unsafe.Pointer(_string))
	_arg2 = C.gsize(len)

	C.g_unicode_canonical_ordering(_arg1, _arg2)
}

// UnicodeScriptFromISO15924 looks up the Unicode script for @iso15924. ISO
// 15924 assigns four-letter codes to scripts. For example, the code for Arabic
// is 'Arab'. This function accepts four letter codes encoded as a @guint32 in a
// big-endian fashion. That is, the code expected for Arabic is 0x41726162 (0x41
// is ASCII code for 'A', 0x72 is ASCII code for 'r', etc).
//
// See Codes for the representation of names of scripts
// (http://unicode.org/iso15924/codelists.html) for details.
func UnicodeScriptFromISO15924(iso15924 uint32) UnicodeScript {
	var _arg1 C.guint32        // out
	var _cret C.GUnicodeScript // in

	_arg1 = C.guint32(iso15924)

	_cret = C.g_unicode_script_from_iso15924(_arg1)

	var _unicodeScript UnicodeScript // out

	_unicodeScript = UnicodeScript(_cret)

	return _unicodeScript
}

// UnicodeScriptToISO15924 looks up the ISO 15924 code for @script. ISO 15924
// assigns four-letter codes to scripts. For example, the code for Arabic is
// 'Arab'. The four letter codes are encoded as a @guint32 by this function in a
// big-endian fashion. That is, the code returned for Arabic is 0x41726162 (0x41
// is ASCII code for 'A', 0x72 is ASCII code for 'r', etc).
//
// See Codes for the representation of names of scripts
// (http://unicode.org/iso15924/codelists.html) for details.
func UnicodeScriptToISO15924(script UnicodeScript) uint32 {
	var _arg1 C.GUnicodeScript // out
	var _cret C.guint32        // in

	_arg1 = C.GUnicodeScript(script)

	_cret = C.g_unicode_script_to_iso15924(_arg1)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// UTF16ToUCS4: convert a string from UTF-16 to UCS-4. The result will be
// nul-terminated.
func UTF16ToUCS4(str *uint16, len int32) (itemsRead int32, itemsWritten int32, gunichar *uint32, goerr error) {
	var _arg1 *C.gunichar2 // out
	var _arg2 C.glong      // out
	var _arg3 C.glong      // in
	var _arg4 C.glong      // in
	var _cret *C.gunichar  // in
	var _cerr *C.GError    // in

	_arg1 = (*C.gunichar2)(unsafe.Pointer(str))
	_arg2 = C.glong(len)

	_cret = C.g_utf16_to_ucs4(_arg1, _arg2, &_arg3, &_arg4, &_cerr)

	var _itemsRead int32    // out
	var _itemsWritten int32 // out
	var _gunichar *uint32   // out
	var _goerr error        // out

	_itemsRead = int32(_arg3)
	_itemsWritten = int32(_arg4)
	_gunichar = (*uint32)(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _itemsRead, _itemsWritten, _gunichar, _goerr
}

// UTF16ToUTF8: convert a string from UTF-16 to UTF-8. The result will be
// terminated with a 0 byte.
//
// Note that the input is expected to be already in native endianness, an
// initial byte-order-mark character is not handled specially. g_convert() can
// be used to convert a byte buffer of UTF-16 data of ambiguous endianness.
//
// Further note that this function does not validate the result string; it may
// e.g. include embedded NUL characters. The only validation done by this
// function is to ensure that the input can be correctly interpreted as UTF-16,
// i.e. it doesn't contain unpaired surrogates or partial character sequences.
func UTF16ToUTF8(str *uint16, len int32) (itemsRead int32, itemsWritten int32, utf8 string, goerr error) {
	var _arg1 *C.gunichar2 // out
	var _arg2 C.glong      // out
	var _arg3 C.glong      // in
	var _arg4 C.glong      // in
	var _cret *C.gchar     // in
	var _cerr *C.GError    // in

	_arg1 = (*C.gunichar2)(unsafe.Pointer(str))
	_arg2 = C.glong(len)

	_cret = C.g_utf16_to_utf8(_arg1, _arg2, &_arg3, &_arg4, &_cerr)

	var _itemsRead int32    // out
	var _itemsWritten int32 // out
	var _utf8 string        // out
	var _goerr error        // out

	_itemsRead = int32(_arg3)
	_itemsWritten = int32(_arg4)
	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _itemsRead, _itemsWritten, _utf8, _goerr
}

// UTF8Casefold converts a string into a form that is independent of case. The
// result will not correspond to any particular case, but can be compared for
// equality or ordered with the results of calling g_utf8_casefold() on other
// strings.
//
// Note that calling g_utf8_casefold() followed by g_utf8_collate() is only an
// approximation to the correct linguistic case insensitive ordering, though it
// is a fairly good one. Getting this exactly right would require a more
// sophisticated collation function that takes case sensitivity into account.
// GLib does not currently provide such a function.
func UTF8Casefold(str string, len int) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(len)

	_cret = C.g_utf8_casefold(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8Collate compares two strings for ordering using the linguistically
// correct rules for the [current locale][setlocale]. When sorting a large
// number of strings, it will be significantly faster to obtain collation keys
// with g_utf8_collate_key() and compare the keys with strcmp() when sorting
// instead of sorting the original strings.
func UTF8Collate(str1 string, str2 string) int {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _cret C.gint   // in

	_arg1 = (*C.gchar)(C.CString(str1))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(str2))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_utf8_collate(_arg1, _arg2)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// UTF8CollateKey converts a string into a collation key that can be compared
// with other collation keys produced by the same function using strcmp().
//
// The results of comparing the collation keys of two strings with strcmp() will
// always be the same as comparing the two original keys with g_utf8_collate().
//
// Note that this function depends on the [current locale][setlocale].
func UTF8CollateKey(str string, len int) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(len)

	_cret = C.g_utf8_collate_key(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8CollateKeyForFilename converts a string into a collation key that can be
// compared with other collation keys produced by the same function using
// strcmp().
//
// In order to sort filenames correctly, this function treats the dot '.' as a
// special case. Most dictionary orderings seem to consider it insignificant,
// thus producing the ordering "event.c" "eventgenerator.c" "event.h" instead of
// "event.c" "event.h" "eventgenerator.c". Also, we would like to treat numbers
// intelligently so that "file1" "file10" "file5" is sorted as "file1" "file5"
// "file10".
//
// Note that this function depends on the [current locale][setlocale].
func UTF8CollateKeyForFilename(str string, len int) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(len)

	_cret = C.g_utf8_collate_key_for_filename(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8FindNextChar finds the start of the next UTF-8 character in the string
// after @p.
//
// @p does not have to be at the beginning of a UTF-8 character. No check is
// made to see if the character found is actually valid other than it starts
// with an appropriate byte.
//
// If @end is nil, the return value will never be nil: if the end of the string
// is reached, a pointer to the terminating nul byte is returned. If @end is
// non-nil, the return value will be nil if the end of the string is reached.
func UTF8FindNextChar(p string, end string) string {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(p))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(end))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_utf8_find_next_char(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// UTF8FindPrevChar: given a position @p with a UTF-8 encoded string @str, find
// the start of the previous UTF-8 character starting before @p. Returns nil if
// no UTF-8 characters are present in @str before @p.
//
// @p does not have to be at the beginning of a UTF-8 character. No check is
// made to see if the character found is actually valid other than it starts
// with an appropriate byte.
func UTF8FindPrevChar(str string, p string) string {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(p))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_utf8_find_prev_char(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// UTF8GetChar converts a sequence of bytes encoded as UTF-8 to a Unicode
// character.
//
// If @p does not point to a valid UTF-8 encoded character, results are
// undefined. If you are not sure that the bytes are complete valid Unicode
// characters, you should use g_utf8_get_char_validated() instead.
func UTF8GetChar(p string) uint32 {
	var _arg1 *C.gchar   // out
	var _cret C.gunichar // in

	_arg1 = (*C.gchar)(C.CString(p))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_utf8_get_char(_arg1)

	var _gunichar uint32 // out

	_gunichar = uint32(_cret)

	return _gunichar
}

// UTF8GetCharValidated: convert a sequence of bytes encoded as UTF-8 to a
// Unicode character. This function checks for incomplete characters, for
// invalid characters such as characters that are out of the range of Unicode,
// and for overlong encodings of valid characters.
//
// Note that g_utf8_get_char_validated() returns (gunichar)-2 if @max_len is
// positive and any of the bytes in the first UTF-8 character sequence are nul.
func UTF8GetCharValidated(p string, maxLen int) uint32 {
	var _arg1 *C.gchar   // out
	var _arg2 C.gssize   // out
	var _cret C.gunichar // in

	_arg1 = (*C.gchar)(C.CString(p))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(maxLen)

	_cret = C.g_utf8_get_char_validated(_arg1, _arg2)

	var _gunichar uint32 // out

	_gunichar = uint32(_cret)

	return _gunichar
}

// UTF8MakeValid: if the provided string is valid UTF-8, return a copy of it. If
// not, return a copy in which bytes that could not be interpreted as valid
// Unicode are replaced with the Unicode replacement character (U+FFFD).
//
// For example, this is an appropriate function to use if you have received a
// string that was incorrectly declared to be UTF-8, and you need a valid UTF-8
// version of it that can be logged or displayed to the user, with the
// assumption that it is close enough to ASCII or UTF-8 to be mostly readable
// as-is.
func UTF8MakeValid(str string, len int) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(len)

	_cret = C.g_utf8_make_valid(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8Normalize converts a string into canonical form, standardizing such
// issues as whether a character with an accent is represented as a base
// character and combining accent or as a single precomposed character. The
// string has to be valid UTF-8, otherwise nil is returned. You should generally
// call g_utf8_normalize() before comparing two Unicode strings.
//
// The normalization mode G_NORMALIZE_DEFAULT only standardizes differences that
// do not affect the text content, such as the above-mentioned accent
// representation. G_NORMALIZE_ALL also standardizes the "compatibility"
// characters in Unicode, such as SUPERSCRIPT THREE to the standard forms (in
// this case DIGIT THREE). Formatting information may be lost but for most text
// operations such characters should be considered the same.
//
// G_NORMALIZE_DEFAULT_COMPOSE and G_NORMALIZE_ALL_COMPOSE are like
// G_NORMALIZE_DEFAULT and G_NORMALIZE_ALL, but returned a result with composed
// forms rather than a maximally decomposed form. This is often useful if you
// intend to convert the string to a legacy encoding or pass it to a system with
// less capable Unicode handling.
func UTF8Normalize(str string, len int, mode NormalizeMode) string {
	var _arg1 *C.gchar         // out
	var _arg2 C.gssize         // out
	var _arg3 C.GNormalizeMode // out
	var _cret *C.gchar         // in

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(len)
	_arg3 = C.GNormalizeMode(mode)

	_cret = C.g_utf8_normalize(_arg1, _arg2, _arg3)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8OffsetToPointer converts from an integer character offset to a pointer to
// a position within the string.
//
// Since 2.10, this function allows to pass a negative @offset to step
// backwards. It is usually worth stepping backwards from the end instead of
// forwards if @offset is in the last fourth of the string, since moving forward
// is about 3 times faster than moving backward.
//
// Note that this function doesn't abort when reaching the end of @str.
// Therefore you should be sure that @offset is within string boundaries before
// calling that function. Call g_utf8_strlen() when unsure. This limitation
// exists as this function is called frequently during text rendering and
// therefore has to be as fast as possible.
func UTF8OffsetToPointer(str string, offset int32) string {
	var _arg1 *C.gchar // out
	var _arg2 C.glong  // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.glong(offset)

	_cret = C.g_utf8_offset_to_pointer(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// UTF8PointerToOffset converts from a pointer to position within a string to an
// integer character offset.
//
// Since 2.10, this function allows @pos to be before @str, and returns a
// negative offset in this case.
func UTF8PointerToOffset(str string, pos string) int32 {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _cret C.glong  // in

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(pos))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_utf8_pointer_to_offset(_arg1, _arg2)

	var _glong int32 // out

	_glong = int32(_cret)

	return _glong
}

// UTF8PrevChar finds the previous UTF-8 character in the string before @p.
//
// @p does not have to be at the beginning of a UTF-8 character. No check is
// made to see if the character found is actually valid other than it starts
// with an appropriate byte. If @p might be the first character of the string,
// you must use g_utf8_find_prev_char() instead.
func UTF8PrevChar(p string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(p))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_utf8_prev_char(_arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// UTF8Strchr finds the leftmost occurrence of the given Unicode character in a
// UTF-8 encoded string, while limiting the search to @len bytes. If @len is -1,
// allow unbounded search.
func UTF8Strchr(p string, len int, c uint32) string {
	var _arg1 *C.gchar   // out
	var _arg2 C.gssize   // out
	var _arg3 C.gunichar // out
	var _cret *C.gchar   // in

	_arg1 = (*C.gchar)(C.CString(p))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(len)
	_arg3 = C.gunichar(c)

	_cret = C.g_utf8_strchr(_arg1, _arg2, _arg3)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// UTF8Strdown converts all Unicode characters in the string that have a case to
// lowercase. The exact manner that this is done depends on the current locale,
// and may result in the number of characters in the string changing.
func UTF8Strdown(str string, len int) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(len)

	_cret = C.g_utf8_strdown(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8Strlen computes the length of the string in characters, not including the
// terminating nul character. If the @max'th byte falls in the middle of a
// character, the last (partial) character is not counted.
func UTF8Strlen(p string, max int) int32 {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize // out
	var _cret C.glong  // in

	_arg1 = (*C.gchar)(C.CString(p))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(max)

	_cret = C.g_utf8_strlen(_arg1, _arg2)

	var _glong int32 // out

	_glong = int32(_cret)

	return _glong
}

// UTF8Strncpy: like the standard C strncpy() function, but copies a given
// number of characters instead of a given number of bytes. The @src string must
// be valid UTF-8 encoded text. (Use g_utf8_validate() on all text before trying
// to use UTF-8 utility functions with it.)
//
// Note you must ensure @dest is at least 4 * @n to fit the largest possible
// UTF-8 characters
func UTF8Strncpy(dest string, src string, n uint) string {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _arg3 C.gsize  // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(dest))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(src))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.gsize(n)

	_cret = C.g_utf8_strncpy(_arg1, _arg2, _arg3)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// UTF8Strrchr: find the rightmost occurrence of the given Unicode character in
// a UTF-8 encoded string, while limiting the search to @len bytes. If @len is
// -1, allow unbounded search.
func UTF8Strrchr(p string, len int, c uint32) string {
	var _arg1 *C.gchar   // out
	var _arg2 C.gssize   // out
	var _arg3 C.gunichar // out
	var _cret *C.gchar   // in

	_arg1 = (*C.gchar)(C.CString(p))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(len)
	_arg3 = C.gunichar(c)

	_cret = C.g_utf8_strrchr(_arg1, _arg2, _arg3)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// UTF8Strreverse reverses a UTF-8 string. @str must be valid UTF-8 encoded
// text. (Use g_utf8_validate() on all text before trying to use UTF-8 utility
// functions with it.)
//
// This function is intended for programmatic uses of reversed strings. It pays
// no attention to decomposed characters, combining marks, byte order marks,
// directional indicators (LRM, LRO, etc) and similar characters which might
// need special handling when reversing a string for display purposes.
//
// Note that unlike g_strreverse(), this function returns newly-allocated
// memory, which should be freed with g_free() when no longer needed.
func UTF8Strreverse(str string, len int) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(len)

	_cret = C.g_utf8_strreverse(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8Strup converts all Unicode characters in the string that have a case to
// uppercase. The exact manner that this is done depends on the current locale,
// and may result in the number of characters in the string increasing. (For
// instance, the German ess-zet will be changed to SS.)
func UTF8Strup(str string, len int) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(len)

	_cret = C.g_utf8_strup(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8Substring copies a substring out of a UTF-8 encoded string. The substring
// will contain @end_pos - @start_pos characters.
func UTF8Substring(str string, startPos int32, endPos int32) string {
	var _arg1 *C.gchar // out
	var _arg2 C.glong  // out
	var _arg3 C.glong  // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.glong(startPos)
	_arg3 = C.glong(endPos)

	_cret = C.g_utf8_substring(_arg1, _arg2, _arg3)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8ToUCS4: convert a string from UTF-8 to a 32-bit fixed width
// representation as UCS-4. A trailing 0 character will be added to the string
// after the converted text.
func UTF8ToUCS4(str string, len int32) (itemsRead int32, itemsWritten int32, gunichar *uint32, goerr error) {
	var _arg1 *C.gchar    // out
	var _arg2 C.glong     // out
	var _arg3 C.glong     // in
	var _arg4 C.glong     // in
	var _cret *C.gunichar // in
	var _cerr *C.GError   // in

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.glong(len)

	_cret = C.g_utf8_to_ucs4(_arg1, _arg2, &_arg3, &_arg4, &_cerr)

	var _itemsRead int32    // out
	var _itemsWritten int32 // out
	var _gunichar *uint32   // out
	var _goerr error        // out

	_itemsRead = int32(_arg3)
	_itemsWritten = int32(_arg4)
	_gunichar = (*uint32)(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _itemsRead, _itemsWritten, _gunichar, _goerr
}

// UTF8ToUCS4Fast: convert a string from UTF-8 to a 32-bit fixed width
// representation as UCS-4, assuming valid UTF-8 input. This function is roughly
// twice as fast as g_utf8_to_ucs4() but does no error checking on the input. A
// trailing 0 character will be added to the string after the converted text.
func UTF8ToUCS4Fast(str string, len int32) (int32, *uint32) {
	var _arg1 *C.gchar    // out
	var _arg2 C.glong     // out
	var _arg3 C.glong     // in
	var _cret *C.gunichar // in

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.glong(len)

	_cret = C.g_utf8_to_ucs4_fast(_arg1, _arg2, &_arg3)

	var _itemsWritten int32 // out
	var _gunichar *uint32   // out

	_itemsWritten = int32(_arg3)
	_gunichar = (*uint32)(unsafe.Pointer(_cret))

	return _itemsWritten, _gunichar
}

// UTF8ToUTF16: convert a string from UTF-8 to UTF-16. A 0 character will be
// added to the result after the converted text.
func UTF8ToUTF16(str string, len int32) (itemsRead int32, itemsWritten int32, guint16 *uint16, goerr error) {
	var _arg1 *C.gchar     // out
	var _arg2 C.glong      // out
	var _arg3 C.glong      // in
	var _arg4 C.glong      // in
	var _cret *C.gunichar2 // in
	var _cerr *C.GError    // in

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.glong(len)

	_cret = C.g_utf8_to_utf16(_arg1, _arg2, &_arg3, &_arg4, &_cerr)

	var _itemsRead int32    // out
	var _itemsWritten int32 // out
	var _guint16 *uint16    // out
	var _goerr error        // out

	_itemsRead = int32(_arg3)
	_itemsWritten = int32(_arg4)
	_guint16 = (*uint16)(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _itemsRead, _itemsWritten, _guint16, _goerr
}

// UTF8Validate validates UTF-8 encoded text. @str is the text to validate; if
// @str is nul-terminated, then @max_len can be -1, otherwise @max_len should be
// the number of bytes to validate. If @end is non-nil, then the end of the
// valid range will be stored there (i.e. the start of the first invalid
// character if some bytes were invalid, or the end of the text being validated
// otherwise).
//
// Note that g_utf8_validate() returns false if @max_len is positive and any of
// the @max_len bytes are nul.
//
// Returns true if all of @str was valid. Many GLib and GTK+ routines require
// valid UTF-8 as input; so data read from a file or the network should be
// checked with g_utf8_validate() before doing anything else with it.
func UTF8Validate(str []byte) (string, bool) {
	var _arg1 *C.gchar
	var _arg2 C.gssize
	var _arg3 *C.gchar   // in
	var _cret C.gboolean // in

	_arg2 = C.gssize(len(str))
	_arg1 = (*C.gchar)(unsafe.Pointer(&str[0]))

	_cret = C.g_utf8_validate(_arg1, _arg2, &_arg3)

	var _end string // out
	var _ok bool    // out

	_end = C.GoString(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _end, _ok
}

// UTF8ValidateLen validates UTF-8 encoded text.
//
// As with g_utf8_validate(), but @max_len must be set, and hence this function
// will always return false if any of the bytes of @str are nul.
func UTF8ValidateLen(str []byte) (string, bool) {
	var _arg1 *C.gchar
	var _arg2 C.gsize
	var _arg3 *C.gchar   // in
	var _cret C.gboolean // in

	_arg2 = C.gsize(len(str))
	_arg1 = (*C.gchar)(unsafe.Pointer(&str[0]))

	_cret = C.g_utf8_validate_len(_arg1, _arg2, &_arg3)

	var _end string // out
	var _ok bool    // out

	_end = C.GoString(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _end, _ok
}
