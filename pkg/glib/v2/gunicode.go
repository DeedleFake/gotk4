// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"unsafe"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib.h>
import "C"

// NormalizeMode defines how a Unicode string is transformed in a canonical
// form, standardizing such issues as whether a character with an accent is
// represented as a base character and combining accent or as a single
// precomposed character. Unicode strings should generally be normalized before
// comparing them.
type NormalizeMode int

const (
	// NormalizeModeDefault: standardize differences that do not affect the text
	// content, such as the above-mentioned accent representation
	NormalizeModeDefault NormalizeMode = 0
	// NormalizeModeNFD: another name for G_NORMALIZE_DEFAULT
	NormalizeModeNFD NormalizeMode = 0
	// NormalizeModeDefaultCompose: like G_NORMALIZE_DEFAULT, but with composed
	// forms rather than a maximally decomposed form
	NormalizeModeDefaultCompose NormalizeMode = 1
	// NormalizeModeNFC: another name for G_NORMALIZE_DEFAULT_COMPOSE
	NormalizeModeNFC NormalizeMode = 1
	// NormalizeModeAll: beyond G_NORMALIZE_DEFAULT also standardize the
	// "compatibility" characters in Unicode, such as SUPERSCRIPT THREE to the
	// standard forms (in this case DIGIT THREE). Formatting information may be
	// lost but for most text operations such characters should be considered
	// the same
	NormalizeModeAll NormalizeMode = 2
	// NormalizeModeNFKD: another name for G_NORMALIZE_ALL
	NormalizeModeNFKD NormalizeMode = 2
	// NormalizeModeAllCompose: like G_NORMALIZE_ALL, but with composed forms
	// rather than a maximally decomposed form
	NormalizeModeAllCompose NormalizeMode = 3
	// NormalizeModeNFKC: another name for G_NORMALIZE_ALL_COMPOSE
	NormalizeModeNFKC NormalizeMode = 3
)

// UnicodeBreakType: these are the possible line break classifications.
//
// Since new unicode versions may add new types here, applications should be
// ready to handle unknown values. They may be regarded as
// G_UNICODE_BREAK_UNKNOWN.
//
// See Unicode Line Breaking Algorithm
// (http://www.unicode.org/unicode/reports/tr14/).
type UnicodeBreakType int

const (
	// UnicodeBreakTypeMandatory: mandatory Break (BK)
	UnicodeBreakTypeMandatory UnicodeBreakType = 0
	// UnicodeBreakTypeCarriageReturn: carriage Return (CR)
	UnicodeBreakTypeCarriageReturn UnicodeBreakType = 1
	// UnicodeBreakTypeLineFeed: line Feed (LF)
	UnicodeBreakTypeLineFeed UnicodeBreakType = 2
	// UnicodeBreakTypeCombiningMark: attached Characters and Combining Marks
	// (CM)
	UnicodeBreakTypeCombiningMark UnicodeBreakType = 3
	// UnicodeBreakTypeSurrogate surrogates (SG)
	UnicodeBreakTypeSurrogate UnicodeBreakType = 4
	// UnicodeBreakTypeZeroWidthSpace: zero Width Space (ZW)
	UnicodeBreakTypeZeroWidthSpace UnicodeBreakType = 5
	// UnicodeBreakTypeInseparable: inseparable (IN)
	UnicodeBreakTypeInseparable UnicodeBreakType = 6
	// UnicodeBreakTypeNonBreakingGlue: non-breaking ("Glue") (GL)
	UnicodeBreakTypeNonBreakingGlue UnicodeBreakType = 7
	// UnicodeBreakTypeContingent: contingent Break Opportunity (CB)
	UnicodeBreakTypeContingent UnicodeBreakType = 8
	// UnicodeBreakTypeSpace: space (SP)
	UnicodeBreakTypeSpace UnicodeBreakType = 9
	// UnicodeBreakTypeAfter: break Opportunity After (BA)
	UnicodeBreakTypeAfter UnicodeBreakType = 10
	// UnicodeBreakTypeBefore: break Opportunity Before (BB)
	UnicodeBreakTypeBefore UnicodeBreakType = 11
	// UnicodeBreakTypeBeforeAndAfter: break Opportunity Before and After (B2)
	UnicodeBreakTypeBeforeAndAfter UnicodeBreakType = 12
	// UnicodeBreakTypeHyphen: hyphen (HY)
	UnicodeBreakTypeHyphen UnicodeBreakType = 13
	// UnicodeBreakTypeNonStarter: nonstarter (NS)
	UnicodeBreakTypeNonStarter UnicodeBreakType = 14
	// UnicodeBreakTypeOpenPunctuation: opening Punctuation (OP)
	UnicodeBreakTypeOpenPunctuation UnicodeBreakType = 15
	// UnicodeBreakTypeClosePunctuation: closing Punctuation (CL)
	UnicodeBreakTypeClosePunctuation UnicodeBreakType = 16
	// UnicodeBreakTypeQuotation ambiguous Quotation (QU)
	UnicodeBreakTypeQuotation UnicodeBreakType = 17
	// UnicodeBreakTypeExclamation: exclamation/Interrogation (EX)
	UnicodeBreakTypeExclamation UnicodeBreakType = 18
	// UnicodeBreakTypeIdeographic: ideographic (ID)
	UnicodeBreakTypeIdeographic UnicodeBreakType = 19
	// UnicodeBreakTypeNumeric: numeric (NU)
	UnicodeBreakTypeNumeric UnicodeBreakType = 20
	// UnicodeBreakTypeInfixSeparator: infix Separator (Numeric) (IS)
	UnicodeBreakTypeInfixSeparator UnicodeBreakType = 21
	// UnicodeBreakTypeSymbol symbols Allowing Break After (SY)
	UnicodeBreakTypeSymbol UnicodeBreakType = 22
	// UnicodeBreakTypeAlphabetic: ordinary Alphabetic and Symbol Characters
	// (AL)
	UnicodeBreakTypeAlphabetic UnicodeBreakType = 23
	// UnicodeBreakTypePrefix: prefix (Numeric) (PR)
	UnicodeBreakTypePrefix UnicodeBreakType = 24
	// UnicodeBreakTypePostfix: postfix (Numeric) (PO)
	UnicodeBreakTypePostfix UnicodeBreakType = 25
	// UnicodeBreakTypeComplexContext: complex Content Dependent (South East
	// Asian) (SA)
	UnicodeBreakTypeComplexContext UnicodeBreakType = 26
	// UnicodeBreakTypeAmbiguous ambiguous (Alphabetic or Ideographic) (AI)
	UnicodeBreakTypeAmbiguous UnicodeBreakType = 27
	// UnicodeBreakTypeUnknown: unknown (XX)
	UnicodeBreakTypeUnknown UnicodeBreakType = 28
	// UnicodeBreakTypeNextLine: next Line (NL)
	UnicodeBreakTypeNextLine UnicodeBreakType = 29
	// UnicodeBreakTypeWordJoiner: word Joiner (WJ)
	UnicodeBreakTypeWordJoiner UnicodeBreakType = 30
	// UnicodeBreakTypeHangulLJamo: hangul L Jamo (JL)
	UnicodeBreakTypeHangulLJamo UnicodeBreakType = 31
	// UnicodeBreakTypeHangulVJamo: hangul V Jamo (JV)
	UnicodeBreakTypeHangulVJamo UnicodeBreakType = 32
	// UnicodeBreakTypeHangulTJamo: hangul T Jamo (JT)
	UnicodeBreakTypeHangulTJamo UnicodeBreakType = 33
	// UnicodeBreakTypeHangulLvSyllable: hangul LV Syllable (H2)
	UnicodeBreakTypeHangulLvSyllable UnicodeBreakType = 34
	// UnicodeBreakTypeHangulLvtSyllable: hangul LVT Syllable (H3)
	UnicodeBreakTypeHangulLvtSyllable UnicodeBreakType = 35
	// UnicodeBreakTypeCloseParanthesis: closing Parenthesis (CP). Since 2.28
	UnicodeBreakTypeCloseParanthesis UnicodeBreakType = 36
	// UnicodeBreakTypeConditionalJapaneseStarter: conditional Japanese Starter
	// (CJ). Since: 2.32
	UnicodeBreakTypeConditionalJapaneseStarter UnicodeBreakType = 37
	// UnicodeBreakTypeHebrewLetter: hebrew Letter (HL). Since: 2.32
	UnicodeBreakTypeHebrewLetter UnicodeBreakType = 38
	// UnicodeBreakTypeRegionalIndicator: regional Indicator (RI). Since: 2.36
	UnicodeBreakTypeRegionalIndicator UnicodeBreakType = 39
	// UnicodeBreakTypeEmojiBase: emoji Base (EB). Since: 2.50
	UnicodeBreakTypeEmojiBase UnicodeBreakType = 40
	// UnicodeBreakTypeEmojiModifier: emoji Modifier (EM). Since: 2.50
	UnicodeBreakTypeEmojiModifier UnicodeBreakType = 41
	// UnicodeBreakTypeZeroWidthJoiner: zero Width Joiner (ZWJ). Since: 2.50
	UnicodeBreakTypeZeroWidthJoiner UnicodeBreakType = 42
)

// UnicodeScript: the Script enumeration identifies different writing systems.
// The values correspond to the names as defined in the Unicode standard. The
// enumeration has been added in GLib 2.14, and is interchangeable with Script.
//
// Note that new types may be added in the future. Applications should be ready
// to handle unknown values. See Unicode Standard Annex #24: Script names
// (http://www.unicode.org/reports/tr24/).
type UnicodeScript int

const (
	// UnicodeScriptInvalidCode: a value never returned from
	// g_unichar_get_script()
	UnicodeScriptInvalidCode UnicodeScript = -1
	// UnicodeScriptCommon: a character used by multiple different scripts
	UnicodeScriptCommon UnicodeScript = 0
	// UnicodeScriptInherited: a mark glyph that takes its script from the base
	// glyph to which it is attached
	UnicodeScriptInherited UnicodeScript = 1
	// UnicodeScriptArabic: arabic
	UnicodeScriptArabic UnicodeScript = 2
	// UnicodeScriptArmenian: armenian
	UnicodeScriptArmenian UnicodeScript = 3
	// UnicodeScriptBengali: bengali
	UnicodeScriptBengali UnicodeScript = 4
	// UnicodeScriptBopomofo: bopomofo
	UnicodeScriptBopomofo UnicodeScript = 5
	// UnicodeScriptCherokee: cherokee
	UnicodeScriptCherokee UnicodeScript = 6
	// UnicodeScriptCoptic: coptic
	UnicodeScriptCoptic UnicodeScript = 7
	// UnicodeScriptCyrillic: cyrillic
	UnicodeScriptCyrillic UnicodeScript = 8
	// UnicodeScriptDeseret: deseret
	UnicodeScriptDeseret UnicodeScript = 9
	// UnicodeScriptDevanagari: devanagari
	UnicodeScriptDevanagari UnicodeScript = 10
	// UnicodeScriptEthiopic: ethiopic
	UnicodeScriptEthiopic UnicodeScript = 11
	// UnicodeScriptGeorgian: georgian
	UnicodeScriptGeorgian UnicodeScript = 12
	// UnicodeScriptGothic: gothic
	UnicodeScriptGothic UnicodeScript = 13
	// UnicodeScriptGreek: greek
	UnicodeScriptGreek UnicodeScript = 14
	// UnicodeScriptGujarati: gujarati
	UnicodeScriptGujarati UnicodeScript = 15
	// UnicodeScriptGurmukhi: gurmukhi
	UnicodeScriptGurmukhi UnicodeScript = 16
	// UnicodeScriptHan: han
	UnicodeScriptHan UnicodeScript = 17
	// UnicodeScriptHangul: hangul
	UnicodeScriptHangul UnicodeScript = 18
	// UnicodeScriptHebrew: hebrew
	UnicodeScriptHebrew UnicodeScript = 19
	// UnicodeScriptHiragana: hiragana
	UnicodeScriptHiragana UnicodeScript = 20
	// UnicodeScriptKannada: kannada
	UnicodeScriptKannada UnicodeScript = 21
	// UnicodeScriptKatakana: katakana
	UnicodeScriptKatakana UnicodeScript = 22
	// UnicodeScriptKhmer: khmer
	UnicodeScriptKhmer UnicodeScript = 23
	// UnicodeScriptLao: lao
	UnicodeScriptLao UnicodeScript = 24
	// UnicodeScriptLatin: latin
	UnicodeScriptLatin UnicodeScript = 25
	// UnicodeScriptMalayalam: malayalam
	UnicodeScriptMalayalam UnicodeScript = 26
	// UnicodeScriptMongolian: mongolian
	UnicodeScriptMongolian UnicodeScript = 27
	// UnicodeScriptMyanmar: myanmar
	UnicodeScriptMyanmar UnicodeScript = 28
	// UnicodeScriptOgham: ogham
	UnicodeScriptOgham UnicodeScript = 29
	// UnicodeScriptOldItalic: old Italic
	UnicodeScriptOldItalic UnicodeScript = 30
	// UnicodeScriptOriya: oriya
	UnicodeScriptOriya UnicodeScript = 31
	// UnicodeScriptRunic: runic
	UnicodeScriptRunic UnicodeScript = 32
	// UnicodeScriptSinhala: sinhala
	UnicodeScriptSinhala UnicodeScript = 33
	// UnicodeScriptSyriac: syriac
	UnicodeScriptSyriac UnicodeScript = 34
	// UnicodeScriptTamil: tamil
	UnicodeScriptTamil UnicodeScript = 35
	// UnicodeScriptTelugu: telugu
	UnicodeScriptTelugu UnicodeScript = 36
	// UnicodeScriptThaana: thaana
	UnicodeScriptThaana UnicodeScript = 37
	// UnicodeScriptThai: thai
	UnicodeScriptThai UnicodeScript = 38
	// UnicodeScriptTibetan: tibetan
	UnicodeScriptTibetan UnicodeScript = 39
	// UnicodeScriptCanadianAboriginal: canadian Aboriginal
	UnicodeScriptCanadianAboriginal UnicodeScript = 40
	// UnicodeScriptYi: yi
	UnicodeScriptYi UnicodeScript = 41
	// UnicodeScriptTagalog: tagalog
	UnicodeScriptTagalog UnicodeScript = 42
	// UnicodeScriptHanunoo: hanunoo
	UnicodeScriptHanunoo UnicodeScript = 43
	// UnicodeScriptBuhid: buhid
	UnicodeScriptBuhid UnicodeScript = 44
	// UnicodeScriptTagbanwa: tagbanwa
	UnicodeScriptTagbanwa UnicodeScript = 45
	// UnicodeScriptBraille: braille
	UnicodeScriptBraille UnicodeScript = 46
	// UnicodeScriptCypriot: cypriot
	UnicodeScriptCypriot UnicodeScript = 47
	// UnicodeScriptLimbu: limbu
	UnicodeScriptLimbu UnicodeScript = 48
	// UnicodeScriptOsmanya: osmanya
	UnicodeScriptOsmanya UnicodeScript = 49
	// UnicodeScriptShavian: shavian
	UnicodeScriptShavian UnicodeScript = 50
	// UnicodeScriptLinearB: linear B
	UnicodeScriptLinearB UnicodeScript = 51
	// UnicodeScriptTaiLe: tai Le
	UnicodeScriptTaiLe UnicodeScript = 52
	// UnicodeScriptUgaritic: ugaritic
	UnicodeScriptUgaritic UnicodeScript = 53
	// UnicodeScriptNewTaiLue: new Tai Lue
	UnicodeScriptNewTaiLue UnicodeScript = 54
	// UnicodeScriptBuginese: buginese
	UnicodeScriptBuginese UnicodeScript = 55
	// UnicodeScriptGlagolitic: glagolitic
	UnicodeScriptGlagolitic UnicodeScript = 56
	// UnicodeScriptTifinagh: tifinagh
	UnicodeScriptTifinagh UnicodeScript = 57
	// UnicodeScriptSylotiNagri: syloti Nagri
	UnicodeScriptSylotiNagri UnicodeScript = 58
	// UnicodeScriptOldPersian: old Persian
	UnicodeScriptOldPersian UnicodeScript = 59
	// UnicodeScriptKharoshthi: kharoshthi
	UnicodeScriptKharoshthi UnicodeScript = 60
	// UnicodeScriptUnknown: an unassigned code point
	UnicodeScriptUnknown UnicodeScript = 61
	// UnicodeScriptBalinese: balinese
	UnicodeScriptBalinese UnicodeScript = 62
	// UnicodeScriptCuneiform: cuneiform
	UnicodeScriptCuneiform UnicodeScript = 63
	// UnicodeScriptPhoenician: phoenician
	UnicodeScriptPhoenician UnicodeScript = 64
	// UnicodeScriptPhagsPa: phags-pa
	UnicodeScriptPhagsPa UnicodeScript = 65
	// UnicodeScriptNko: n'Ko
	UnicodeScriptNko UnicodeScript = 66
	// UnicodeScriptKayahLi: kayah Li. Since 2.16.3
	UnicodeScriptKayahLi UnicodeScript = 67
	// UnicodeScriptLepcha: lepcha. Since 2.16.3
	UnicodeScriptLepcha UnicodeScript = 68
	// UnicodeScriptRejang: rejang. Since 2.16.3
	UnicodeScriptRejang UnicodeScript = 69
	// UnicodeScriptSundanese: sundanese. Since 2.16.3
	UnicodeScriptSundanese UnicodeScript = 70
	// UnicodeScriptSaurashtra: saurashtra. Since 2.16.3
	UnicodeScriptSaurashtra UnicodeScript = 71
	// UnicodeScriptCham: cham. Since 2.16.3
	UnicodeScriptCham UnicodeScript = 72
	// UnicodeScriptOlChiki: ol Chiki. Since 2.16.3
	UnicodeScriptOlChiki UnicodeScript = 73
	// UnicodeScriptVai: vai. Since 2.16.3
	UnicodeScriptVai UnicodeScript = 74
	// UnicodeScriptCarian: carian. Since 2.16.3
	UnicodeScriptCarian UnicodeScript = 75
	// UnicodeScriptLycian: lycian. Since 2.16.3
	UnicodeScriptLycian UnicodeScript = 76
	// UnicodeScriptLydian: lydian. Since 2.16.3
	UnicodeScriptLydian UnicodeScript = 77
	// UnicodeScriptAvestan: avestan. Since 2.26
	UnicodeScriptAvestan UnicodeScript = 78
	// UnicodeScriptBamum: bamum. Since 2.26
	UnicodeScriptBamum UnicodeScript = 79
	// UnicodeScriptEgyptianHieroglyphs: egyptian Hieroglpyhs. Since 2.26
	UnicodeScriptEgyptianHieroglyphs UnicodeScript = 80
	// UnicodeScriptImperialAramaic: imperial Aramaic. Since 2.26
	UnicodeScriptImperialAramaic UnicodeScript = 81
	// UnicodeScriptInscriptionalPahlavi: inscriptional Pahlavi. Since 2.26
	UnicodeScriptInscriptionalPahlavi UnicodeScript = 82
	// UnicodeScriptInscriptionalParthian: inscriptional Parthian. Since 2.26
	UnicodeScriptInscriptionalParthian UnicodeScript = 83
	// UnicodeScriptJavanese: javanese. Since 2.26
	UnicodeScriptJavanese UnicodeScript = 84
	// UnicodeScriptKaithi: kaithi. Since 2.26
	UnicodeScriptKaithi UnicodeScript = 85
	// UnicodeScriptLisu: lisu. Since 2.26
	UnicodeScriptLisu UnicodeScript = 86
	// UnicodeScriptMeeteiMayek: meetei Mayek. Since 2.26
	UnicodeScriptMeeteiMayek UnicodeScript = 87
	// UnicodeScriptOldSouthArabian: old South Arabian. Since 2.26
	UnicodeScriptOldSouthArabian UnicodeScript = 88
	// UnicodeScriptOldTurkic: old Turkic. Since 2.28
	UnicodeScriptOldTurkic UnicodeScript = 89
	// UnicodeScriptSamaritan: samaritan. Since 2.26
	UnicodeScriptSamaritan UnicodeScript = 90
	// UnicodeScriptTaiTham: tai Tham. Since 2.26
	UnicodeScriptTaiTham UnicodeScript = 91
	// UnicodeScriptTaiViet: tai Viet. Since 2.26
	UnicodeScriptTaiViet UnicodeScript = 92
	// UnicodeScriptBatak: batak. Since 2.28
	UnicodeScriptBatak UnicodeScript = 93
	// UnicodeScriptBrahmi: brahmi. Since 2.28
	UnicodeScriptBrahmi UnicodeScript = 94
	// UnicodeScriptMandaic: mandaic. Since 2.28
	UnicodeScriptMandaic UnicodeScript = 95
	// UnicodeScriptChakma: chakma. Since: 2.32
	UnicodeScriptChakma UnicodeScript = 96
	// UnicodeScriptMeroiticCursive: meroitic Cursive. Since: 2.32
	UnicodeScriptMeroiticCursive UnicodeScript = 97
	// UnicodeScriptMeroiticHieroglyphs: meroitic Hieroglyphs. Since: 2.32
	UnicodeScriptMeroiticHieroglyphs UnicodeScript = 98
	// UnicodeScriptMiao: miao. Since: 2.32
	UnicodeScriptMiao UnicodeScript = 99
	// UnicodeScriptSharada: sharada. Since: 2.32
	UnicodeScriptSharada UnicodeScript = 100
	// UnicodeScriptSoraSompeng: sora Sompeng. Since: 2.32
	UnicodeScriptSoraSompeng UnicodeScript = 101
	// UnicodeScriptTakri: takri. Since: 2.32
	UnicodeScriptTakri UnicodeScript = 102
	// UnicodeScriptBassaVah: bassa. Since: 2.42
	UnicodeScriptBassaVah UnicodeScript = 103
	// UnicodeScriptCaucasianAlbanian: caucasian Albanian. Since: 2.42
	UnicodeScriptCaucasianAlbanian UnicodeScript = 104
	// UnicodeScriptDuployan: duployan. Since: 2.42
	UnicodeScriptDuployan UnicodeScript = 105
	// UnicodeScriptElbasan: elbasan. Since: 2.42
	UnicodeScriptElbasan UnicodeScript = 106
	// UnicodeScriptGrantha: grantha. Since: 2.42
	UnicodeScriptGrantha UnicodeScript = 107
	// UnicodeScriptKhojki: kjohki. Since: 2.42
	UnicodeScriptKhojki UnicodeScript = 108
	// UnicodeScriptKhudawadi: khudawadi, Sindhi. Since: 2.42
	UnicodeScriptKhudawadi UnicodeScript = 109
	// UnicodeScriptLinearA: linear A. Since: 2.42
	UnicodeScriptLinearA UnicodeScript = 110
	// UnicodeScriptMahajani: mahajani. Since: 2.42
	UnicodeScriptMahajani UnicodeScript = 111
	// UnicodeScriptManichaean: manichaean. Since: 2.42
	UnicodeScriptManichaean UnicodeScript = 112
	// UnicodeScriptMendeKikakui: mende Kikakui. Since: 2.42
	UnicodeScriptMendeKikakui UnicodeScript = 113
	// UnicodeScriptModi: modi. Since: 2.42
	UnicodeScriptModi UnicodeScript = 114
	// UnicodeScriptMro: mro. Since: 2.42
	UnicodeScriptMro UnicodeScript = 115
	// UnicodeScriptNabataean: nabataean. Since: 2.42
	UnicodeScriptNabataean UnicodeScript = 116
	// UnicodeScriptOldNorthArabian: old North Arabian. Since: 2.42
	UnicodeScriptOldNorthArabian UnicodeScript = 117
	// UnicodeScriptOldPermic: old Permic. Since: 2.42
	UnicodeScriptOldPermic UnicodeScript = 118
	// UnicodeScriptPahawhHmong: pahawh Hmong. Since: 2.42
	UnicodeScriptPahawhHmong UnicodeScript = 119
	// UnicodeScriptPalmyrene: palmyrene. Since: 2.42
	UnicodeScriptPalmyrene UnicodeScript = 120
	// UnicodeScriptPauCinHau: pau Cin Hau. Since: 2.42
	UnicodeScriptPauCinHau UnicodeScript = 121
	// UnicodeScriptPsalterPahlavi: psalter Pahlavi. Since: 2.42
	UnicodeScriptPsalterPahlavi UnicodeScript = 122
	// UnicodeScriptSiddham: siddham. Since: 2.42
	UnicodeScriptSiddham UnicodeScript = 123
	// UnicodeScriptTirhuta: tirhuta. Since: 2.42
	UnicodeScriptTirhuta UnicodeScript = 124
	// UnicodeScriptWarangCiti: warang Citi. Since: 2.42
	UnicodeScriptWarangCiti UnicodeScript = 125
	// UnicodeScriptAhom: ahom. Since: 2.48
	UnicodeScriptAhom UnicodeScript = 126
	// UnicodeScriptAnatolianHieroglyphs: anatolian Hieroglyphs. Since: 2.48
	UnicodeScriptAnatolianHieroglyphs UnicodeScript = 127
	// UnicodeScriptHatran: hatran. Since: 2.48
	UnicodeScriptHatran UnicodeScript = 128
	// UnicodeScriptMultani: multani. Since: 2.48
	UnicodeScriptMultani UnicodeScript = 129
	// UnicodeScriptOldHungarian: old Hungarian. Since: 2.48
	UnicodeScriptOldHungarian UnicodeScript = 130
	// UnicodeScriptSignwriting: signwriting. Since: 2.48
	UnicodeScriptSignwriting UnicodeScript = 131
	// UnicodeScriptAdlam: adlam. Since: 2.50
	UnicodeScriptAdlam UnicodeScript = 132
	// UnicodeScriptBhaiksuki: bhaiksuki. Since: 2.50
	UnicodeScriptBhaiksuki UnicodeScript = 133
	// UnicodeScriptMarchen: marchen. Since: 2.50
	UnicodeScriptMarchen UnicodeScript = 134
	// UnicodeScriptNewa: newa. Since: 2.50
	UnicodeScriptNewa UnicodeScript = 135
	// UnicodeScriptOsage: osage. Since: 2.50
	UnicodeScriptOsage UnicodeScript = 136
	// UnicodeScriptTangut: tangut. Since: 2.50
	UnicodeScriptTangut UnicodeScript = 137
	// UnicodeScriptMasaramGondi: masaram Gondi. Since: 2.54
	UnicodeScriptMasaramGondi UnicodeScript = 138
	// UnicodeScriptNushu: nushu. Since: 2.54
	UnicodeScriptNushu UnicodeScript = 139
	// UnicodeScriptSoyombo: soyombo. Since: 2.54
	UnicodeScriptSoyombo UnicodeScript = 140
	// UnicodeScriptZanabazarSquare: zanabazar Square. Since: 2.54
	UnicodeScriptZanabazarSquare UnicodeScript = 141
	// UnicodeScriptDogra: dogra. Since: 2.58
	UnicodeScriptDogra UnicodeScript = 142
	// UnicodeScriptGunjalaGondi: gunjala Gondi. Since: 2.58
	UnicodeScriptGunjalaGondi UnicodeScript = 143
	// UnicodeScriptHanifiRohingya: hanifi Rohingya. Since: 2.58
	UnicodeScriptHanifiRohingya UnicodeScript = 144
	// UnicodeScriptMakasar: makasar. Since: 2.58
	UnicodeScriptMakasar UnicodeScript = 145
	// UnicodeScriptMedefaidrin: medefaidrin. Since: 2.58
	UnicodeScriptMedefaidrin UnicodeScript = 146
	// UnicodeScriptOldSogdian: old Sogdian. Since: 2.58
	UnicodeScriptOldSogdian UnicodeScript = 147
	// UnicodeScriptSogdian: sogdian. Since: 2.58
	UnicodeScriptSogdian UnicodeScript = 148
	// UnicodeScriptElymaic: elym. Since: 2.62
	UnicodeScriptElymaic UnicodeScript = 149
	// UnicodeScriptNandinagari: nand. Since: 2.62
	UnicodeScriptNandinagari UnicodeScript = 150
	// UnicodeScriptNyiakengPuachueHmong: rohg. Since: 2.62
	UnicodeScriptNyiakengPuachueHmong UnicodeScript = 151
	// UnicodeScriptWancho: wcho. Since: 2.62
	UnicodeScriptWancho UnicodeScript = 152
	// UnicodeScriptChorasmian: chorasmian. Since: 2.66
	UnicodeScriptChorasmian UnicodeScript = 153
	// UnicodeScriptDivesAkuru dives Akuru. Since: 2.66
	UnicodeScriptDivesAkuru UnicodeScript = 154
	// UnicodeScriptKhitanSmallScript: khitan small script. Since: 2.66
	UnicodeScriptKhitanSmallScript UnicodeScript = 155
	// UnicodeScriptYezidi: yezidi. Since: 2.66
	UnicodeScriptYezidi UnicodeScript = 156
)

// UnicodeType: these are the possible character classifications from the
// Unicode specification. See Unicode Character Database
// (http://www.unicode.org/reports/tr44/Category_Values).
type UnicodeType int

const (
	// UnicodeTypeControl: general category "Other, Control" (Cc)
	UnicodeTypeControl UnicodeType = 0
	// UnicodeTypeFormat: general category "Other, Format" (Cf)
	UnicodeTypeFormat UnicodeType = 1
	// UnicodeTypeUnassigned: general category "Other, Not Assigned" (Cn)
	UnicodeTypeUnassigned UnicodeType = 2
	// UnicodeTypePrivateUse: general category "Other, Private Use" (Co)
	UnicodeTypePrivateUse UnicodeType = 3
	// UnicodeTypeSurrogate: general category "Other, Surrogate" (Cs)
	UnicodeTypeSurrogate UnicodeType = 4
	// UnicodeTypeLowercaseLetter: general category "Letter, Lowercase" (Ll)
	UnicodeTypeLowercaseLetter UnicodeType = 5
	// UnicodeTypeModifierLetter: general category "Letter, Modifier" (Lm)
	UnicodeTypeModifierLetter UnicodeType = 6
	// UnicodeTypeOtherLetter: general category "Letter, Other" (Lo)
	UnicodeTypeOtherLetter UnicodeType = 7
	// UnicodeTypeTitlecaseLetter: general category "Letter, Titlecase" (Lt)
	UnicodeTypeTitlecaseLetter UnicodeType = 8
	// UnicodeTypeUppercaseLetter: general category "Letter, Uppercase" (Lu)
	UnicodeTypeUppercaseLetter UnicodeType = 9
	// UnicodeTypeSpacingMark: general category "Mark, Spacing" (Mc)
	UnicodeTypeSpacingMark UnicodeType = 10
	// UnicodeTypeEnclosingMark: general category "Mark, Enclosing" (Me)
	UnicodeTypeEnclosingMark UnicodeType = 11
	// UnicodeTypeNonSpacingMark: general category "Mark, Nonspacing" (Mn)
	UnicodeTypeNonSpacingMark UnicodeType = 12
	// UnicodeTypeDecimalNumber: general category "Number, Decimal Digit" (Nd)
	UnicodeTypeDecimalNumber UnicodeType = 13
	// UnicodeTypeLetterNumber: general category "Number, Letter" (Nl)
	UnicodeTypeLetterNumber UnicodeType = 14
	// UnicodeTypeOtherNumber: general category "Number, Other" (No)
	UnicodeTypeOtherNumber UnicodeType = 15
	// UnicodeTypeConnectPunctuation: general category "Punctuation, Connector"
	// (Pc)
	UnicodeTypeConnectPunctuation UnicodeType = 16
	// UnicodeTypeDashPunctuation: general category "Punctuation, Dash" (Pd)
	UnicodeTypeDashPunctuation UnicodeType = 17
	// UnicodeTypeClosePunctuation: general category "Punctuation, Close" (Pe)
	UnicodeTypeClosePunctuation UnicodeType = 18
	// UnicodeTypeFinalPunctuation: general category "Punctuation, Final quote"
	// (Pf)
	UnicodeTypeFinalPunctuation UnicodeType = 19
	// UnicodeTypeInitialPunctuation: general category "Punctuation, Initial
	// quote" (Pi)
	UnicodeTypeInitialPunctuation UnicodeType = 20
	// UnicodeTypeOtherPunctuation: general category "Punctuation, Other" (Po)
	UnicodeTypeOtherPunctuation UnicodeType = 21
	// UnicodeTypeOpenPunctuation: general category "Punctuation, Open" (Ps)
	UnicodeTypeOpenPunctuation UnicodeType = 22
	// UnicodeTypeCurrencySymbol: general category "Symbol, Currency" (Sc)
	UnicodeTypeCurrencySymbol UnicodeType = 23
	// UnicodeTypeModifierSymbol: general category "Symbol, Modifier" (Sk)
	UnicodeTypeModifierSymbol UnicodeType = 24
	// UnicodeTypeMathSymbol: general category "Symbol, Math" (Sm)
	UnicodeTypeMathSymbol UnicodeType = 25
	// UnicodeTypeOtherSymbol: general category "Symbol, Other" (So)
	UnicodeTypeOtherSymbol UnicodeType = 26
	// UnicodeTypeLineSeparator: general category "Separator, Line" (Zl)
	UnicodeTypeLineSeparator UnicodeType = 27
	// UnicodeTypeParagraphSeparator: general category "Separator, Paragraph"
	// (Zp)
	UnicodeTypeParagraphSeparator UnicodeType = 28
	// UnicodeTypeSpaceSeparator: general category "Separator, Space" (Zs)
	UnicodeTypeSpaceSeparator UnicodeType = 29
)

// UnicharCombiningClass determines the canonical combining class of a Unicode
// character.
func UnicharCombiningClass(uc uint32) int {
	var _arg1 C.gunichar // out

	_arg1 = C.gunichar(uc)

	var _cret C.gint // in

	_cret = C.g_unichar_combining_class(_arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// UnicharCompose performs a single composition step of the Unicode canonical
// composition algorithm.
//
// This function includes algorithmic Hangul Jamo composition, but it is not
// exactly the inverse of g_unichar_decompose(). No composition can have either
// of @a or @b equal to zero. To be precise, this function composes if and only
// if there exists a Primary Composite P which is canonically equivalent to the
// sequence <@a,@b>. See the Unicode Standard for the definition of Primary
// Composite.
//
// If @a and @b do not compose a new character, @ch is set to zero.
//
// See UAX#15 (http://unicode.org/reports/tr15/) for details.
func UnicharCompose(a uint32, b uint32) (uint32, bool) {
	var _arg1 C.gunichar // out
	var _arg2 C.gunichar // out

	_arg1 = C.gunichar(a)
	_arg2 = C.gunichar(b)

	var _arg3 C.gunichar // in
	var _cret C.gboolean // in

	_cret = C.g_unichar_compose(_arg1, _arg2, &_arg3)

	var _ch uint32 // out
	var _ok bool   // out

	_ch = (uint32)(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _ch, _ok
}

// UnicharDecompose performs a single decomposition step of the Unicode
// canonical decomposition algorithm.
//
// This function does not include compatibility decompositions. It does,
// however, include algorithmic Hangul Jamo decomposition, as well as
// 'singleton' decompositions which replace a character by a single other
// character. In the case of singletons *@b will be set to zero.
//
// If @ch is not decomposable, *@a is set to @ch and *@b is set to zero.
//
// Note that the way Unicode decomposition pairs are defined, it is guaranteed
// that @b would not decompose further, but @a may itself decompose. To get the
// full canonical decomposition for @ch, one would need to recursively call this
// function on @a. Or use g_unichar_fully_decompose().
//
// See UAX#15 (http://unicode.org/reports/tr15/) for details.
func UnicharDecompose(ch uint32) (a uint32, b uint32, ok bool) {
	var _arg1 C.gunichar // out

	_arg1 = C.gunichar(ch)

	var _arg2 C.gunichar // in
	var _arg3 C.gunichar // in
	var _cret C.gboolean // in

	_cret = C.g_unichar_decompose(_arg1, &_arg2, &_arg3)

	var _a uint32 // out
	var _b uint32 // out
	var _ok bool  // out

	_a = (uint32)(_arg2)
	_b = (uint32)(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _a, _b, _ok
}

// UnicharDigitValue determines the numeric value of a character as a decimal
// digit.
func UnicharDigitValue(c uint32) int {
	var _arg1 C.gunichar // out

	_arg1 = C.gunichar(c)

	var _cret C.gint // in

	_cret = C.g_unichar_digit_value(_arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// UnicharFullyDecompose computes the canonical or compatibility decomposition
// of a Unicode character. For compatibility decomposition, pass true for
// @compat; for canonical decomposition pass false for @compat.
//
// The decomposed sequence is placed in @result. Only up to @result_len
// characters are written into @result. The length of the full decomposition
// (irrespective of @result_len) is returned by the function. For canonical
// decomposition, currently all decompositions are of length at most 4, but this
// may change in the future (very unlikely though). At any rate, Unicode does
// guarantee that a buffer of length 18 is always enough for both compatibility
// and canonical decompositions, so that is the size recommended. This is
// provided as G_UNICHAR_MAX_DECOMPOSITION_LENGTH.
//
// See UAX#15 (http://unicode.org/reports/tr15/) for details.
func UnicharFullyDecompose(ch uint32, compat bool, resultLen uint) (uint32, uint) {
	var _arg1 C.gunichar // out
	var _arg2 C.gboolean // out
	var _arg4 C.gsize    // out

	_arg1 = C.gunichar(ch)
	if compat {
		_arg2 = C.TRUE
	}
	_arg4 = C.gsize(resultLen)

	var _arg3 C.gunichar // in
	var _cret C.gsize    // in

	_cret = C.g_unichar_fully_decompose(_arg1, _arg2, _arg4, &_arg3)

	var _result uint32 // out
	var _gsize uint    // out

	_result = (uint32)(_arg3)
	_gsize = (uint)(_cret)

	return _result, _gsize
}

// UnicharGetMirrorChar: in Unicode, some characters are "mirrored". This means
// that their images are mirrored horizontally in text that is laid out from
// right to left. For instance, "(" would become its mirror image, ")", in
// right-to-left text.
//
// If @ch has the Unicode mirrored property and there is another unicode
// character that typically has a glyph that is the mirror image of @ch's glyph
// and @mirrored_ch is set, it puts that character in the address pointed to by
// @mirrored_ch. Otherwise the original character is put.
func UnicharGetMirrorChar(ch uint32, mirroredCh *uint32) bool {
	var _arg1 C.gunichar  // out
	var _arg2 *C.gunichar // out

	_arg1 = C.gunichar(ch)
	_arg2 = *C.gunichar(mirroredCh)

	var _cret C.gboolean // in

	_cret = C.g_unichar_get_mirror_char(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsalnum determines whether a character is alphanumeric. Given some
// UTF-8 text, obtain a character value with g_utf8_get_char().
func UnicharIsalnum(c uint32) bool {
	var _arg1 C.gunichar // out

	_arg1 = C.gunichar(c)

	var _cret C.gboolean // in

	_cret = C.g_unichar_isalnum(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsalpha determines whether a character is alphabetic (i.e. a letter).
// Given some UTF-8 text, obtain a character value with g_utf8_get_char().
func UnicharIsalpha(c uint32) bool {
	var _arg1 C.gunichar // out

	_arg1 = C.gunichar(c)

	var _cret C.gboolean // in

	_cret = C.g_unichar_isalpha(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIscntrl determines whether a character is a control character. Given
// some UTF-8 text, obtain a character value with g_utf8_get_char().
func UnicharIscntrl(c uint32) bool {
	var _arg1 C.gunichar // out

	_arg1 = C.gunichar(c)

	var _cret C.gboolean // in

	_cret = C.g_unichar_iscntrl(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsdefined determines if a given character is assigned in the Unicode
// standard.
func UnicharIsdefined(c uint32) bool {
	var _arg1 C.gunichar // out

	_arg1 = C.gunichar(c)

	var _cret C.gboolean // in

	_cret = C.g_unichar_isdefined(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsdigit determines whether a character is numeric (i.e. a digit). This
// covers ASCII 0-9 and also digits in other languages/scripts. Given some UTF-8
// text, obtain a character value with g_utf8_get_char().
func UnicharIsdigit(c uint32) bool {
	var _arg1 C.gunichar // out

	_arg1 = C.gunichar(c)

	var _cret C.gboolean // in

	_cret = C.g_unichar_isdigit(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsgraph determines whether a character is printable and not a space
// (returns false for control characters, format characters, and spaces).
// g_unichar_isprint() is similar, but returns true for spaces. Given some UTF-8
// text, obtain a character value with g_utf8_get_char().
func UnicharIsgraph(c uint32) bool {
	var _arg1 C.gunichar // out

	_arg1 = C.gunichar(c)

	var _cret C.gboolean // in

	_cret = C.g_unichar_isgraph(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIslower determines whether a character is a lowercase letter. Given
// some UTF-8 text, obtain a character value with g_utf8_get_char().
func UnicharIslower(c uint32) bool {
	var _arg1 C.gunichar // out

	_arg1 = C.gunichar(c)

	var _cret C.gboolean // in

	_cret = C.g_unichar_islower(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsmark determines whether a character is a mark (non-spacing mark,
// combining mark, or enclosing mark in Unicode speak). Given some UTF-8 text,
// obtain a character value with g_utf8_get_char().
//
// Note: in most cases where isalpha characters are allowed, ismark characters
// should be allowed to as they are essential for writing most European
// languages as well as many non-Latin scripts.
func UnicharIsmark(c uint32) bool {
	var _arg1 C.gunichar // out

	_arg1 = C.gunichar(c)

	var _cret C.gboolean // in

	_cret = C.g_unichar_ismark(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsprint determines whether a character is printable. Unlike
// g_unichar_isgraph(), returns true for spaces. Given some UTF-8 text, obtain a
// character value with g_utf8_get_char().
func UnicharIsprint(c uint32) bool {
	var _arg1 C.gunichar // out

	_arg1 = C.gunichar(c)

	var _cret C.gboolean // in

	_cret = C.g_unichar_isprint(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIspunct determines whether a character is punctuation or a symbol.
// Given some UTF-8 text, obtain a character value with g_utf8_get_char().
func UnicharIspunct(c uint32) bool {
	var _arg1 C.gunichar // out

	_arg1 = C.gunichar(c)

	var _cret C.gboolean // in

	_cret = C.g_unichar_ispunct(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsspace determines whether a character is a space, tab, or line
// separator (newline, carriage return, etc.). Given some UTF-8 text, obtain a
// character value with g_utf8_get_char().
//
// (Note: don't use this to do word breaking; you have to use Pango or
// equivalent to get word breaking right, the algorithm is fairly complex.)
func UnicharIsspace(c uint32) bool {
	var _arg1 C.gunichar // out

	_arg1 = C.gunichar(c)

	var _cret C.gboolean // in

	_cret = C.g_unichar_isspace(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIstitle determines if a character is titlecase. Some characters in
// Unicode which are composites, such as the DZ digraph have three case variants
// instead of just two. The titlecase form is used at the beginning of a word
// where only the first letter is capitalized. The titlecase form of the DZ
// digraph is U+01F2 LATIN CAPITAL LETTTER D WITH SMALL LETTER Z.
func UnicharIstitle(c uint32) bool {
	var _arg1 C.gunichar // out

	_arg1 = C.gunichar(c)

	var _cret C.gboolean // in

	_cret = C.g_unichar_istitle(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsupper determines if a character is uppercase.
func UnicharIsupper(c uint32) bool {
	var _arg1 C.gunichar // out

	_arg1 = C.gunichar(c)

	var _cret C.gboolean // in

	_cret = C.g_unichar_isupper(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIswide determines if a character is typically rendered in a
// double-width cell.
func UnicharIswide(c uint32) bool {
	var _arg1 C.gunichar // out

	_arg1 = C.gunichar(c)

	var _cret C.gboolean // in

	_cret = C.g_unichar_iswide(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIswideCjk determines if a character is typically rendered in a
// double-width cell under legacy East Asian locales. If a character is wide
// according to g_unichar_iswide(), then it is also reported wide with this
// function, but the converse is not necessarily true. See the Unicode Standard
// Annex #11 (http://www.unicode.org/reports/tr11/) for details.
//
// If a character passes the g_unichar_iswide() test then it will also pass this
// test, but not the other way around. Note that some characters may pass both
// this test and g_unichar_iszerowidth().
func UnicharIswideCjk(c uint32) bool {
	var _arg1 C.gunichar // out

	_arg1 = C.gunichar(c)

	var _cret C.gboolean // in

	_cret = C.g_unichar_iswide_cjk(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsxdigit determines if a character is a hexadecimal digit.
func UnicharIsxdigit(c uint32) bool {
	var _arg1 C.gunichar // out

	_arg1 = C.gunichar(c)

	var _cret C.gboolean // in

	_cret = C.g_unichar_isxdigit(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIszerowidth determines if a given character typically takes zero width
// when rendered. The return value is true for all non-spacing and enclosing
// marks (e.g., combining accents), format characters, zero-width space, but not
// U+00AD SOFT HYPHEN.
//
// A typical use of this function is with one of g_unichar_iswide() or
// g_unichar_iswide_cjk() to determine the number of cells a string occupies
// when displayed on a grid display (terminals). However, note that not all
// terminals support zero-width rendering of zero-width marks.
func UnicharIszerowidth(c uint32) bool {
	var _arg1 C.gunichar // out

	_arg1 = C.gunichar(c)

	var _cret C.gboolean // in

	_cret = C.g_unichar_iszerowidth(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharToUTF8 converts a single character to UTF-8.
func UnicharToUTF8(c uint32) (string, int) {
	var _arg1 C.gunichar // out

	_arg1 = C.gunichar(c)

	var _arg2 C.gchar // in
	var _cret C.gint  // in

	_cret = C.g_unichar_to_utf8(_arg1, &_arg2)

	var _outbuf string // out
	var _gint int      // out

	_outbuf = C.GoString(_arg2)
	_gint = (int)(_cret)

	return _outbuf, _gint
}

// UnicharToLower converts a character to lower case.
func UnicharToLower(c uint32) uint32 {
	var _arg1 C.gunichar // out

	_arg1 = C.gunichar(c)

	var _cret C.gunichar // in

	_cret = C.g_unichar_tolower(_arg1)

	var _gunichar uint32 // out

	_gunichar = (uint32)(_cret)

	return _gunichar
}

// UnicharTotitle converts a character to the titlecase.
func UnicharTotitle(c uint32) uint32 {
	var _arg1 C.gunichar // out

	_arg1 = C.gunichar(c)

	var _cret C.gunichar // in

	_cret = C.g_unichar_totitle(_arg1)

	var _gunichar uint32 // out

	_gunichar = (uint32)(_cret)

	return _gunichar
}

// UnicharToUpper converts a character to uppercase.
func UnicharToUpper(c uint32) uint32 {
	var _arg1 C.gunichar // out

	_arg1 = C.gunichar(c)

	var _cret C.gunichar // in

	_cret = C.g_unichar_toupper(_arg1)

	var _gunichar uint32 // out

	_gunichar = (uint32)(_cret)

	return _gunichar
}

// UnicharValidate checks whether @ch is a valid Unicode character. Some
// possible integer values of @ch will not be valid. 0 is considered a valid
// character, though it's normally a string terminator.
func UnicharValidate(ch uint32) bool {
	var _arg1 C.gunichar // out

	_arg1 = C.gunichar(ch)

	var _cret C.gboolean // in

	_cret = C.g_unichar_validate(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharXDigitValue determines the numeric value of a character as a
// hexadecimal digit.
func UnicharXDigitValue(c uint32) int {
	var _arg1 C.gunichar // out

	_arg1 = C.gunichar(c)

	var _cret C.gint // in

	_cret = C.g_unichar_xdigit_value(_arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// UnicodeCanonicalDecomposition computes the canonical decomposition of a
// Unicode character.
func UnicodeCanonicalDecomposition(ch uint32, resultLen *uint) *uint32 {
	var _arg1 C.gunichar // out
	var _arg2 *C.gsize   // out

	_arg1 = C.gunichar(ch)
	_arg2 = *C.gsize(resultLen)

	var _cret *C.gunichar // in

	_cret = C.g_unicode_canonical_decomposition(_arg1, _arg2)

	var _gunichar *uint32 // out

	_gunichar = (*uint32)(_cret)

	return _gunichar
}

// UnicodeCanonicalOrdering computes the canonical ordering of a string
// in-place. This rearranges decomposed characters in the string according to
// their combining classes. See the Unicode manual for more information.
func UnicodeCanonicalOrdering(string *uint32, len uint) {
	var _arg1 *C.gunichar // out
	var _arg2 C.gsize     // out

	_arg1 = *C.gunichar(string)
	_arg2 = C.gsize(len)

	C.g_unicode_canonical_ordering(_arg1, _arg2)
}

// UnicodeScriptToIso15924 looks up the ISO 15924 code for @script. ISO 15924
// assigns four-letter codes to scripts. For example, the code for Arabic is
// 'Arab'. The four letter codes are encoded as a @guint32 by this function in a
// big-endian fashion. That is, the code returned for Arabic is 0x41726162 (0x41
// is ASCII code for 'A', 0x72 is ASCII code for 'r', etc).
//
// See Codes for the representation of names of scripts
// (http://unicode.org/iso15924/codelists.html) for details.
func UnicodeScriptToIso15924(script UnicodeScript) uint32 {
	var _arg1 C.GUnicodeScript // out

	_arg1 = (C.GUnicodeScript)(script)

	var _cret C.guint32 // in

	_cret = C.g_unicode_script_to_iso15924(_arg1)

	var _guint32 uint32 // out

	_guint32 = (uint32)(_cret)

	return _guint32
}

// UTF8Casefold converts a string into a form that is independent of case. The
// result will not correspond to any particular case, but can be compared for
// equality or ordered with the results of calling g_utf8_casefold() on other
// strings.
//
// Note that calling g_utf8_casefold() followed by g_utf8_collate() is only an
// approximation to the correct linguistic case insensitive ordering, though it
// is a fairly good one. Getting this exactly right would require a more
// sophisticated collation function that takes case sensitivity into account.
// GLib does not currently provide such a function.
func UTF8Casefold(str string, len int) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize // out

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(len)

	var _cret *C.gchar // in

	_cret = C.g_utf8_casefold(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8Collate compares two strings for ordering using the linguistically
// correct rules for the [current locale][setlocale]. When sorting a large
// number of strings, it will be significantly faster to obtain collation keys
// with g_utf8_collate_key() and compare the keys with strcmp() when sorting
// instead of sorting the original strings.
func UTF8Collate(str1 string, str2 string) int {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out

	_arg1 = (*C.gchar)(C.CString(str1))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(str2))
	defer C.free(unsafe.Pointer(_arg2))

	var _cret C.gint // in

	_cret = C.g_utf8_collate(_arg1, _arg2)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// UTF8CollateKey converts a string into a collation key that can be compared
// with other collation keys produced by the same function using strcmp().
//
// The results of comparing the collation keys of two strings with strcmp() will
// always be the same as comparing the two original keys with g_utf8_collate().
//
// Note that this function depends on the [current locale][setlocale].
func UTF8CollateKey(str string, len int) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize // out

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(len)

	var _cret *C.gchar // in

	_cret = C.g_utf8_collate_key(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8CollateKeyForFilename converts a string into a collation key that can be
// compared with other collation keys produced by the same function using
// strcmp().
//
// In order to sort filenames correctly, this function treats the dot '.' as a
// special case. Most dictionary orderings seem to consider it insignificant,
// thus producing the ordering "event.c" "eventgenerator.c" "event.h" instead of
// "event.c" "event.h" "eventgenerator.c". Also, we would like to treat numbers
// intelligently so that "file1" "file10" "file5" is sorted as "file1" "file5"
// "file10".
//
// Note that this function depends on the [current locale][setlocale].
func UTF8CollateKeyForFilename(str string, len int) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize // out

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(len)

	var _cret *C.gchar // in

	_cret = C.g_utf8_collate_key_for_filename(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8FindNextChar finds the start of the next UTF-8 character in the string
// after @p.
//
// @p does not have to be at the beginning of a UTF-8 character. No check is
// made to see if the character found is actually valid other than it starts
// with an appropriate byte.
//
// If @end is nil, the return value will never be nil: if the end of the string
// is reached, a pointer to the terminating nul byte is returned. If @end is
// non-nil, the return value will be nil if the end of the string is reached.
func UTF8FindNextChar(p string, end string) string {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out

	_arg1 = (*C.gchar)(C.CString(p))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(end))
	defer C.free(unsafe.Pointer(_arg2))

	var _cret *C.gchar // in

	_cret = C.g_utf8_find_next_char(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// UTF8FindPrevChar: given a position @p with a UTF-8 encoded string @str, find
// the start of the previous UTF-8 character starting before @p. Returns nil if
// no UTF-8 characters are present in @str before @p.
//
// @p does not have to be at the beginning of a UTF-8 character. No check is
// made to see if the character found is actually valid other than it starts
// with an appropriate byte.
func UTF8FindPrevChar(str string, p string) string {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(p))
	defer C.free(unsafe.Pointer(_arg2))

	var _cret *C.gchar // in

	_cret = C.g_utf8_find_prev_char(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// UTF8GetChar converts a sequence of bytes encoded as UTF-8 to a Unicode
// character.
//
// If @p does not point to a valid UTF-8 encoded character, results are
// undefined. If you are not sure that the bytes are complete valid Unicode
// characters, you should use g_utf8_get_char_validated() instead.
func UTF8GetChar(p string) uint32 {
	var _arg1 *C.gchar // out

	_arg1 = (*C.gchar)(C.CString(p))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret C.gunichar // in

	_cret = C.g_utf8_get_char(_arg1)

	var _gunichar uint32 // out

	_gunichar = (uint32)(_cret)

	return _gunichar
}

// UTF8GetCharValidated: convert a sequence of bytes encoded as UTF-8 to a
// Unicode character. This function checks for incomplete characters, for
// invalid characters such as characters that are out of the range of Unicode,
// and for overlong encodings of valid characters.
//
// Note that g_utf8_get_char_validated() returns (gunichar)-2 if @max_len is
// positive and any of the bytes in the first UTF-8 character sequence are nul.
func UTF8GetCharValidated(p string, maxLen int) uint32 {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize // out

	_arg1 = (*C.gchar)(C.CString(p))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(maxLen)

	var _cret C.gunichar // in

	_cret = C.g_utf8_get_char_validated(_arg1, _arg2)

	var _gunichar uint32 // out

	_gunichar = (uint32)(_cret)

	return _gunichar
}

// UTF8MakeValid: if the provided string is valid UTF-8, return a copy of it. If
// not, return a copy in which bytes that could not be interpreted as valid
// Unicode are replaced with the Unicode replacement character (U+FFFD).
//
// For example, this is an appropriate function to use if you have received a
// string that was incorrectly declared to be UTF-8, and you need a valid UTF-8
// version of it that can be logged or displayed to the user, with the
// assumption that it is close enough to ASCII or UTF-8 to be mostly readable
// as-is.
func UTF8MakeValid(str string, len int) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize // out

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(len)

	var _cret *C.gchar // in

	_cret = C.g_utf8_make_valid(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8Normalize converts a string into canonical form, standardizing such
// issues as whether a character with an accent is represented as a base
// character and combining accent or as a single precomposed character. The
// string has to be valid UTF-8, otherwise nil is returned. You should generally
// call g_utf8_normalize() before comparing two Unicode strings.
//
// The normalization mode G_NORMALIZE_DEFAULT only standardizes differences that
// do not affect the text content, such as the above-mentioned accent
// representation. G_NORMALIZE_ALL also standardizes the "compatibility"
// characters in Unicode, such as SUPERSCRIPT THREE to the standard forms (in
// this case DIGIT THREE). Formatting information may be lost but for most text
// operations such characters should be considered the same.
//
// G_NORMALIZE_DEFAULT_COMPOSE and G_NORMALIZE_ALL_COMPOSE are like
// G_NORMALIZE_DEFAULT and G_NORMALIZE_ALL, but returned a result with composed
// forms rather than a maximally decomposed form. This is often useful if you
// intend to convert the string to a legacy encoding or pass it to a system with
// less capable Unicode handling.
func UTF8Normalize(str string, len int, mode NormalizeMode) string {
	var _arg1 *C.gchar         // out
	var _arg2 C.gssize         // out
	var _arg3 C.GNormalizeMode // out

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(len)
	_arg3 = (C.GNormalizeMode)(mode)

	var _cret *C.gchar // in

	_cret = C.g_utf8_normalize(_arg1, _arg2, _arg3)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8OffsetToPointer converts from an integer character offset to a pointer to
// a position within the string.
//
// Since 2.10, this function allows to pass a negative @offset to step
// backwards. It is usually worth stepping backwards from the end instead of
// forwards if @offset is in the last fourth of the string, since moving forward
// is about 3 times faster than moving backward.
//
// Note that this function doesn't abort when reaching the end of @str.
// Therefore you should be sure that @offset is within string boundaries before
// calling that function. Call g_utf8_strlen() when unsure. This limitation
// exists as this function is called frequently during text rendering and
// therefore has to be as fast as possible.
func UTF8OffsetToPointer(str string, offset int32) string {
	var _arg1 *C.gchar // out
	var _arg2 C.glong  // out

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.glong(offset)

	var _cret *C.gchar // in

	_cret = C.g_utf8_offset_to_pointer(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// UTF8PointerToOffset converts from a pointer to position within a string to an
// integer character offset.
//
// Since 2.10, this function allows @pos to be before @str, and returns a
// negative offset in this case.
func UTF8PointerToOffset(str string, pos string) int32 {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(pos))
	defer C.free(unsafe.Pointer(_arg2))

	var _cret C.glong // in

	_cret = C.g_utf8_pointer_to_offset(_arg1, _arg2)

	var _glong int32 // out

	_glong = (int32)(_cret)

	return _glong
}

// UTF8PrevChar finds the previous UTF-8 character in the string before @p.
//
// @p does not have to be at the beginning of a UTF-8 character. No check is
// made to see if the character found is actually valid other than it starts
// with an appropriate byte. If @p might be the first character of the string,
// you must use g_utf8_find_prev_char() instead.
func UTF8PrevChar(p string) string {
	var _arg1 *C.gchar // out

	_arg1 = (*C.gchar)(C.CString(p))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret *C.gchar // in

	_cret = C.g_utf8_prev_char(_arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// UTF8Strchr finds the leftmost occurrence of the given Unicode character in a
// UTF-8 encoded string, while limiting the search to @len bytes. If @len is -1,
// allow unbounded search.
func UTF8Strchr(p string, len int, c uint32) string {
	var _arg1 *C.gchar   // out
	var _arg2 C.gssize   // out
	var _arg3 C.gunichar // out

	_arg1 = (*C.gchar)(C.CString(p))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(len)
	_arg3 = C.gunichar(c)

	var _cret *C.gchar // in

	_cret = C.g_utf8_strchr(_arg1, _arg2, _arg3)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// UTF8Strdown converts all Unicode characters in the string that have a case to
// lowercase. The exact manner that this is done depends on the current locale,
// and may result in the number of characters in the string changing.
func UTF8Strdown(str string, len int) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize // out

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(len)

	var _cret *C.gchar // in

	_cret = C.g_utf8_strdown(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8Strlen computes the length of the string in characters, not including the
// terminating nul character. If the @max'th byte falls in the middle of a
// character, the last (partial) character is not counted.
func UTF8Strlen(p string, max int) int32 {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize // out

	_arg1 = (*C.gchar)(C.CString(p))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(max)

	var _cret C.glong // in

	_cret = C.g_utf8_strlen(_arg1, _arg2)

	var _glong int32 // out

	_glong = (int32)(_cret)

	return _glong
}

// UTF8Strncpy: like the standard C strncpy() function, but copies a given
// number of characters instead of a given number of bytes. The @src string must
// be valid UTF-8 encoded text. (Use g_utf8_validate() on all text before trying
// to use UTF-8 utility functions with it.)
//
// Note you must ensure @dest is at least 4 * @n to fit the largest possible
// UTF-8 characters
func UTF8Strncpy(dest string, src string, n uint) string {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _arg3 C.gsize  // out

	_arg1 = (*C.gchar)(C.CString(dest))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(src))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.gsize(n)

	var _cret *C.gchar // in

	_cret = C.g_utf8_strncpy(_arg1, _arg2, _arg3)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// UTF8Strrchr: find the rightmost occurrence of the given Unicode character in
// a UTF-8 encoded string, while limiting the search to @len bytes. If @len is
// -1, allow unbounded search.
func UTF8Strrchr(p string, len int, c uint32) string {
	var _arg1 *C.gchar   // out
	var _arg2 C.gssize   // out
	var _arg3 C.gunichar // out

	_arg1 = (*C.gchar)(C.CString(p))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(len)
	_arg3 = C.gunichar(c)

	var _cret *C.gchar // in

	_cret = C.g_utf8_strrchr(_arg1, _arg2, _arg3)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// UTF8Strreverse reverses a UTF-8 string. @str must be valid UTF-8 encoded
// text. (Use g_utf8_validate() on all text before trying to use UTF-8 utility
// functions with it.)
//
// This function is intended for programmatic uses of reversed strings. It pays
// no attention to decomposed characters, combining marks, byte order marks,
// directional indicators (LRM, LRO, etc) and similar characters which might
// need special handling when reversing a string for display purposes.
//
// Note that unlike g_strreverse(), this function returns newly-allocated
// memory, which should be freed with g_free() when no longer needed.
func UTF8Strreverse(str string, len int) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize // out

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(len)

	var _cret *C.gchar // in

	_cret = C.g_utf8_strreverse(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8Strup converts all Unicode characters in the string that have a case to
// uppercase. The exact manner that this is done depends on the current locale,
// and may result in the number of characters in the string increasing. (For
// instance, the German ess-zet will be changed to SS.)
func UTF8Strup(str string, len int) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize // out

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(len)

	var _cret *C.gchar // in

	_cret = C.g_utf8_strup(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8Substring copies a substring out of a UTF-8 encoded string. The substring
// will contain @end_pos - @start_pos characters.
func UTF8Substring(str string, startPos int32, endPos int32) string {
	var _arg1 *C.gchar // out
	var _arg2 C.glong  // out
	var _arg3 C.glong  // out

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.glong(startPos)
	_arg3 = C.glong(endPos)

	var _cret *C.gchar // in

	_cret = C.g_utf8_substring(_arg1, _arg2, _arg3)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8ToUcs4Fast: convert a string from UTF-8 to a 32-bit fixed width
// representation as UCS-4, assuming valid UTF-8 input. This function is roughly
// twice as fast as g_utf8_to_ucs4() but does no error checking on the input. A
// trailing 0 character will be added to the string after the converted text.
func UTF8ToUcs4Fast(str string, len int32) (int32, *uint32) {
	var _arg1 *C.gchar // out
	var _arg2 C.glong  // out

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.glong(len)

	var _arg3 C.glong     // in
	var _cret *C.gunichar // in

	_cret = C.g_utf8_to_ucs4_fast(_arg1, _arg2, &_arg3)

	var _itemsWritten int32 // out
	var _gunichar *uint32   // out

	_itemsWritten = (int32)(_arg3)
	_gunichar = (*uint32)(_cret)

	return _itemsWritten, _gunichar
}

// UTF8Validate validates UTF-8 encoded text. @str is the text to validate; if
// @str is nul-terminated, then @max_len can be -1, otherwise @max_len should be
// the number of bytes to validate. If @end is non-nil, then the end of the
// valid range will be stored there (i.e. the start of the first invalid
// character if some bytes were invalid, or the end of the text being validated
// otherwise).
//
// Note that g_utf8_validate() returns false if @max_len is positive and any of
// the @max_len bytes are nul.
//
// Returns true if all of @str was valid. Many GLib and GTK+ routines require
// valid UTF-8 as input; so data read from a file or the network should be
// checked with g_utf8_validate() before doing anything else with it.
func UTF8Validate(str []byte) (string, bool) {
	var _arg1 *C.gchar
	var _arg2 C.gssize

	_arg2 = C.gssize(len(str))
	_arg1 = (*C.gchar)(unsafe.Pointer(&str[0]))

	var _arg3 *C.gchar   // in
	var _cret C.gboolean // in

	_cret = C.g_utf8_validate(_arg1, _arg2, &_arg3)

	var _end string // out
	var _ok bool    // out

	_end = C.GoString(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _end, _ok
}

// UTF8ValidateLen validates UTF-8 encoded text.
//
// As with g_utf8_validate(), but @max_len must be set, and hence this function
// will always return false if any of the bytes of @str are nul.
func UTF8ValidateLen(str []byte) (string, bool) {
	var _arg1 *C.gchar
	var _arg2 C.gsize

	_arg2 = C.gsize(len(str))
	_arg1 = (*C.gchar)(unsafe.Pointer(&str[0]))

	var _arg3 *C.gchar   // in
	var _cret C.gboolean // in

	_cret = C.g_utf8_validate_len(_arg1, _arg2, &_arg3)

	var _end string // out
	var _ok bool    // out

	_end = C.GoString(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _end, _ok
}
