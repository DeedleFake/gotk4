// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <glib.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_tree_get_type()), F: marshalTree},
	})
}

// Tree: the GTree struct is an opaque data structure representing a [balanced
// binary tree][glib-Balanced-Binary-Trees]. It should be accessed only by using
// the following functions.
type Tree C.GTree

// WrapTree wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTree(ptr unsafe.Pointer) *Tree {
	return (*Tree)(ptr)
}

func marshalTree(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*Tree)(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *Tree) Native() unsafe.Pointer {
	return unsafe.Pointer(t)
}

// Destroy gets the upper bound node corresponding to the given key, or nil if
// the tree is empty or all the nodes in the tree have keys that are lower than
// or equal to the searched key.
//
// The upper bound is the first node that has its key strictly greater than the
// searched key.
func (t *Tree) Destroy() {
	var _arg0 *C.GTree // out

	_arg0 = (*C.GTree)(unsafe.Pointer(t.Native()))

	C.g_tree_destroy(_arg0)
}

// Height gets the upper bound node corresponding to the given key, or nil if
// the tree is empty or all the nodes in the tree have keys that are lower than
// or equal to the searched key.
//
// The upper bound is the first node that has its key strictly greater than the
// searched key.
func (t *Tree) Height() int {
	var _arg0 *C.GTree // out
	var _cret C.gint   // in

	_arg0 = (*C.GTree)(unsafe.Pointer(t.Native()))

	_cret = C.g_tree_height(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Insert gets the upper bound node corresponding to the given key, or nil if
// the tree is empty or all the nodes in the tree have keys that are lower than
// or equal to the searched key.
//
// The upper bound is the first node that has its key strictly greater than the
// searched key.
func (t *Tree) Insert(key interface{}, value interface{}) {
	var _arg0 *C.GTree   // out
	var _arg1 C.gpointer // out
	var _arg2 C.gpointer // out

	_arg0 = (*C.GTree)(unsafe.Pointer(t.Native()))
	_arg1 = C.gpointer(box.Assign(unsafe.Pointer(key)))
	_arg2 = C.gpointer(box.Assign(unsafe.Pointer(value)))

	C.g_tree_insert(_arg0, _arg1, _arg2)
}

// InsertNode gets the upper bound node corresponding to the given key, or nil
// if the tree is empty or all the nodes in the tree have keys that are lower
// than or equal to the searched key.
//
// The upper bound is the first node that has its key strictly greater than the
// searched key.
func (t *Tree) InsertNode(key interface{}, value interface{}) *TreeNode {
	var _arg0 *C.GTree     // out
	var _arg1 C.gpointer   // out
	var _arg2 C.gpointer   // out
	var _cret *C.GTreeNode // in

	_arg0 = (*C.GTree)(unsafe.Pointer(t.Native()))
	_arg1 = C.gpointer(box.Assign(unsafe.Pointer(key)))
	_arg2 = C.gpointer(box.Assign(unsafe.Pointer(value)))

	_cret = C.g_tree_insert_node(_arg0, _arg1, _arg2)

	var _treeNode *TreeNode // out

	_treeNode = (*TreeNode)(unsafe.Pointer(_cret))

	return _treeNode
}

// Lookup gets the upper bound node corresponding to the given key, or nil if
// the tree is empty or all the nodes in the tree have keys that are lower than
// or equal to the searched key.
//
// The upper bound is the first node that has its key strictly greater than the
// searched key.
func (t *Tree) Lookup(key interface{}) interface{} {
	var _arg0 *C.GTree        // out
	var _arg1 C.gconstpointer // out
	var _cret C.gpointer      // in

	_arg0 = (*C.GTree)(unsafe.Pointer(t.Native()))
	_arg1 = C.gconstpointer(box.Assign(unsafe.Pointer(key)))

	_cret = C.g_tree_lookup(_arg0, _arg1)

	var _gpointer interface{} // out

	_gpointer = box.Get(uintptr(_cret))

	return _gpointer
}

// LookupExtended gets the upper bound node corresponding to the given key, or
// nil if the tree is empty or all the nodes in the tree have keys that are
// lower than or equal to the searched key.
//
// The upper bound is the first node that has its key strictly greater than the
// searched key.
func (t *Tree) LookupExtended(lookupKey interface{}) (origKey interface{}, value interface{}, ok bool) {
	var _arg0 *C.GTree        // out
	var _arg1 C.gconstpointer // out
	var _arg2 C.gpointer      // in
	var _arg3 C.gpointer      // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GTree)(unsafe.Pointer(t.Native()))
	_arg1 = C.gconstpointer(box.Assign(unsafe.Pointer(lookupKey)))

	_cret = C.g_tree_lookup_extended(_arg0, _arg1, &_arg2, &_arg3)

	var _origKey interface{} // out
	var _value interface{}   // out
	var _ok bool             // out

	_origKey = box.Get(uintptr(_arg2))
	_value = box.Get(uintptr(_arg3))
	if _cret != 0 {
		_ok = true
	}

	return _origKey, _value, _ok
}

// LookupNode gets the upper bound node corresponding to the given key, or nil
// if the tree is empty or all the nodes in the tree have keys that are lower
// than or equal to the searched key.
//
// The upper bound is the first node that has its key strictly greater than the
// searched key.
func (t *Tree) LookupNode(key interface{}) *TreeNode {
	var _arg0 *C.GTree        // out
	var _arg1 C.gconstpointer // out
	var _cret *C.GTreeNode    // in

	_arg0 = (*C.GTree)(unsafe.Pointer(t.Native()))
	_arg1 = C.gconstpointer(box.Assign(unsafe.Pointer(key)))

	_cret = C.g_tree_lookup_node(_arg0, _arg1)

	var _treeNode *TreeNode // out

	_treeNode = (*TreeNode)(unsafe.Pointer(_cret))

	return _treeNode
}

// LowerBound gets the upper bound node corresponding to the given key, or nil
// if the tree is empty or all the nodes in the tree have keys that are lower
// than or equal to the searched key.
//
// The upper bound is the first node that has its key strictly greater than the
// searched key.
func (t *Tree) LowerBound(key interface{}) *TreeNode {
	var _arg0 *C.GTree        // out
	var _arg1 C.gconstpointer // out
	var _cret *C.GTreeNode    // in

	_arg0 = (*C.GTree)(unsafe.Pointer(t.Native()))
	_arg1 = C.gconstpointer(box.Assign(unsafe.Pointer(key)))

	_cret = C.g_tree_lower_bound(_arg0, _arg1)

	var _treeNode *TreeNode // out

	_treeNode = (*TreeNode)(unsafe.Pointer(_cret))

	return _treeNode
}

// Nnodes gets the upper bound node corresponding to the given key, or nil if
// the tree is empty or all the nodes in the tree have keys that are lower than
// or equal to the searched key.
//
// The upper bound is the first node that has its key strictly greater than the
// searched key.
func (t *Tree) Nnodes() int {
	var _arg0 *C.GTree // out
	var _cret C.gint   // in

	_arg0 = (*C.GTree)(unsafe.Pointer(t.Native()))

	_cret = C.g_tree_nnodes(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// NodeFirst gets the upper bound node corresponding to the given key, or nil if
// the tree is empty or all the nodes in the tree have keys that are lower than
// or equal to the searched key.
//
// The upper bound is the first node that has its key strictly greater than the
// searched key.
func (t *Tree) NodeFirst() *TreeNode {
	var _arg0 *C.GTree     // out
	var _cret *C.GTreeNode // in

	_arg0 = (*C.GTree)(unsafe.Pointer(t.Native()))

	_cret = C.g_tree_node_first(_arg0)

	var _treeNode *TreeNode // out

	_treeNode = (*TreeNode)(unsafe.Pointer(_cret))

	return _treeNode
}

// NodeLast gets the upper bound node corresponding to the given key, or nil if
// the tree is empty or all the nodes in the tree have keys that are lower than
// or equal to the searched key.
//
// The upper bound is the first node that has its key strictly greater than the
// searched key.
func (t *Tree) NodeLast() *TreeNode {
	var _arg0 *C.GTree     // out
	var _cret *C.GTreeNode // in

	_arg0 = (*C.GTree)(unsafe.Pointer(t.Native()))

	_cret = C.g_tree_node_last(_arg0)

	var _treeNode *TreeNode // out

	_treeNode = (*TreeNode)(unsafe.Pointer(_cret))

	return _treeNode
}

// Ref gets the upper bound node corresponding to the given key, or nil if the
// tree is empty or all the nodes in the tree have keys that are lower than or
// equal to the searched key.
//
// The upper bound is the first node that has its key strictly greater than the
// searched key.
func (t *Tree) Ref() *Tree {
	var _arg0 *C.GTree // out
	var _cret *C.GTree // in

	_arg0 = (*C.GTree)(unsafe.Pointer(t.Native()))

	_cret = C.g_tree_ref(_arg0)

	var _ret *Tree // out

	_ret = (*Tree)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_ret, func(v **Tree) {
		C.free(unsafe.Pointer(v))
	})

	return _ret
}

// Remove gets the upper bound node corresponding to the given key, or nil if
// the tree is empty or all the nodes in the tree have keys that are lower than
// or equal to the searched key.
//
// The upper bound is the first node that has its key strictly greater than the
// searched key.
func (t *Tree) Remove(key interface{}) bool {
	var _arg0 *C.GTree        // out
	var _arg1 C.gconstpointer // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GTree)(unsafe.Pointer(t.Native()))
	_arg1 = C.gconstpointer(box.Assign(unsafe.Pointer(key)))

	_cret = C.g_tree_remove(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Replace gets the upper bound node corresponding to the given key, or nil if
// the tree is empty or all the nodes in the tree have keys that are lower than
// or equal to the searched key.
//
// The upper bound is the first node that has its key strictly greater than the
// searched key.
func (t *Tree) Replace(key interface{}, value interface{}) {
	var _arg0 *C.GTree   // out
	var _arg1 C.gpointer // out
	var _arg2 C.gpointer // out

	_arg0 = (*C.GTree)(unsafe.Pointer(t.Native()))
	_arg1 = C.gpointer(box.Assign(unsafe.Pointer(key)))
	_arg2 = C.gpointer(box.Assign(unsafe.Pointer(value)))

	C.g_tree_replace(_arg0, _arg1, _arg2)
}

// ReplaceNode gets the upper bound node corresponding to the given key, or nil
// if the tree is empty or all the nodes in the tree have keys that are lower
// than or equal to the searched key.
//
// The upper bound is the first node that has its key strictly greater than the
// searched key.
func (t *Tree) ReplaceNode(key interface{}, value interface{}) *TreeNode {
	var _arg0 *C.GTree     // out
	var _arg1 C.gpointer   // out
	var _arg2 C.gpointer   // out
	var _cret *C.GTreeNode // in

	_arg0 = (*C.GTree)(unsafe.Pointer(t.Native()))
	_arg1 = C.gpointer(box.Assign(unsafe.Pointer(key)))
	_arg2 = C.gpointer(box.Assign(unsafe.Pointer(value)))

	_cret = C.g_tree_replace_node(_arg0, _arg1, _arg2)

	var _treeNode *TreeNode // out

	_treeNode = (*TreeNode)(unsafe.Pointer(_cret))

	return _treeNode
}

// Steal gets the upper bound node corresponding to the given key, or nil if the
// tree is empty or all the nodes in the tree have keys that are lower than or
// equal to the searched key.
//
// The upper bound is the first node that has its key strictly greater than the
// searched key.
func (t *Tree) Steal(key interface{}) bool {
	var _arg0 *C.GTree        // out
	var _arg1 C.gconstpointer // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GTree)(unsafe.Pointer(t.Native()))
	_arg1 = C.gconstpointer(box.Assign(unsafe.Pointer(key)))

	_cret = C.g_tree_steal(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Unref gets the upper bound node corresponding to the given key, or nil if the
// tree is empty or all the nodes in the tree have keys that are lower than or
// equal to the searched key.
//
// The upper bound is the first node that has its key strictly greater than the
// searched key.
func (t *Tree) Unref() {
	var _arg0 *C.GTree // out

	_arg0 = (*C.GTree)(unsafe.Pointer(t.Native()))

	C.g_tree_unref(_arg0)
}

// UpperBound gets the upper bound node corresponding to the given key, or nil
// if the tree is empty or all the nodes in the tree have keys that are lower
// than or equal to the searched key.
//
// The upper bound is the first node that has its key strictly greater than the
// searched key.
func (t *Tree) UpperBound(key interface{}) *TreeNode {
	var _arg0 *C.GTree        // out
	var _arg1 C.gconstpointer // out
	var _cret *C.GTreeNode    // in

	_arg0 = (*C.GTree)(unsafe.Pointer(t.Native()))
	_arg1 = C.gconstpointer(box.Assign(unsafe.Pointer(key)))

	_cret = C.g_tree_upper_bound(_arg0, _arg1)

	var _treeNode *TreeNode // out

	_treeNode = (*TreeNode)(unsafe.Pointer(_cret))

	return _treeNode
}

// TreeNode: an opaque type which identifies a specific node in a #GTree.
type TreeNode C.GTreeNode

// WrapTreeNode wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTreeNode(ptr unsafe.Pointer) *TreeNode {
	return (*TreeNode)(ptr)
}

// Native returns the underlying C source pointer.
func (t *TreeNode) Native() unsafe.Pointer {
	return unsafe.Pointer(t)
}

// Key gets the value stored at a particular tree node.
func (n *TreeNode) Key() interface{} {
	var _arg0 *C.GTreeNode // out
	var _cret C.gpointer   // in

	_arg0 = (*C.GTreeNode)(unsafe.Pointer(n.Native()))

	_cret = C.g_tree_node_key(_arg0)

	var _gpointer interface{} // out

	_gpointer = box.Get(uintptr(_cret))

	return _gpointer
}

// Next gets the value stored at a particular tree node.
func (n *TreeNode) Next() *TreeNode {
	var _arg0 *C.GTreeNode // out
	var _cret *C.GTreeNode // in

	_arg0 = (*C.GTreeNode)(unsafe.Pointer(n.Native()))

	_cret = C.g_tree_node_next(_arg0)

	var _treeNode *TreeNode // out

	_treeNode = (*TreeNode)(unsafe.Pointer(_cret))

	return _treeNode
}

// Previous gets the value stored at a particular tree node.
func (n *TreeNode) Previous() *TreeNode {
	var _arg0 *C.GTreeNode // out
	var _cret *C.GTreeNode // in

	_arg0 = (*C.GTreeNode)(unsafe.Pointer(n.Native()))

	_cret = C.g_tree_node_previous(_arg0)

	var _treeNode *TreeNode // out

	_treeNode = (*TreeNode)(unsafe.Pointer(_cret))

	return _treeNode
}

// Value gets the value stored at a particular tree node.
func (n *TreeNode) Value() interface{} {
	var _arg0 *C.GTreeNode // out
	var _cret C.gpointer   // in

	_arg0 = (*C.GTreeNode)(unsafe.Pointer(n.Native()))

	_cret = C.g_tree_node_value(_arg0)

	var _gpointer interface{} // out

	_gpointer = box.Get(uintptr(_cret))

	return _gpointer
}
