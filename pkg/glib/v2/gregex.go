// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <glib.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_match_info_get_type()), F: marshalMatchInfo},
		{T: externglib.Type(C.g_regex_get_type()), F: marshalRegex},
	})
}

// RegexError: error codes returned by regular expressions functions.
type RegexError int

const (
	// Compile: compilation of the regular expression failed.
	Compile RegexError = 0
	// Optimize: optimization of the regular expression failed.
	Optimize RegexError = 1
	// Replace: replacement failed due to an ill-formed replacement string.
	Replace RegexError = 2
	// Match: the match process failed.
	Match RegexError = 3
	// Internal: internal error of the regular expression engine. Since 2.16
	Internal RegexError = 4
	// StrayBackslash: "\\" at end of pattern. Since 2.16
	StrayBackslash RegexError = 101
	// MissingControlChar: "\\c" at end of pattern. Since 2.16
	MissingControlChar RegexError = 102
	// UnrecognizedEscape: unrecognized character follows "\\". Since 2.16
	UnrecognizedEscape RegexError = 103
	// QuantifiersOutOfOrder numbers out of order in "{}" quantifier. Since 2.16
	QuantifiersOutOfOrder RegexError = 104
	// QuantifierTooBig: number too big in "{}" quantifier. Since 2.16
	QuantifierTooBig RegexError = 105
	// UnterminatedCharacterClass: missing terminating "]" for character class.
	// Since 2.16
	UnterminatedCharacterClass RegexError = 106
	// InvalidEscapeInCharacterClass: invalid escape sequence in character
	// class. Since 2.16
	InvalidEscapeInCharacterClass RegexError = 107
	// RangeOutOfOrder: range out of order in character class. Since 2.16
	RangeOutOfOrder RegexError = 108
	// NothingToRepeat: nothing to repeat. Since 2.16
	NothingToRepeat RegexError = 109
	// UnrecognizedCharacter: unrecognized character after "(?", "(?<" or "(?P".
	// Since 2.16
	UnrecognizedCharacter RegexError = 112
	// PosixNamedClassOutsideClass: POSIX named classes are supported only
	// within a class. Since 2.16
	PosixNamedClassOutsideClass RegexError = 113
	// UnmatchedParenthesis: missing terminating ")" or ")" without opening "(".
	// Since 2.16
	UnmatchedParenthesis RegexError = 114
	// InexistentSubpatternReference: reference to non-existent subpattern.
	// Since 2.16
	InexistentSubpatternReference RegexError = 115
	// UnterminatedComment: missing terminating ")" after comment. Since 2.16
	UnterminatedComment RegexError = 118
	// ExpressionTooLarge: regular expression too large. Since 2.16
	ExpressionTooLarge RegexError = 120
	// MemoryError: failed to get memory. Since 2.16
	MemoryError RegexError = 121
	// VariableLengthLookbehind: lookbehind assertion is not fixed length. Since
	// 2.16
	VariableLengthLookbehind RegexError = 125
	// MalformedCondition: malformed number or name after "(?(". Since 2.16
	MalformedCondition RegexError = 126
	// TooManyConditionalBranches: conditional group contains more than two
	// branches. Since 2.16
	TooManyConditionalBranches RegexError = 127
	// AssertionExpected: assertion expected after "(?(". Since 2.16
	AssertionExpected RegexError = 128
	// UnknownPosixClassName: unknown POSIX class name. Since 2.16
	UnknownPosixClassName RegexError = 130
	// PosixCollatingElementsNotSupported: POSIX collating elements are not
	// supported. Since 2.16
	PosixCollatingElementsNotSupported RegexError = 131
	// HexCodeTooLarge: character value in "\\x{...}" sequence is too large.
	// Since 2.16
	HexCodeTooLarge RegexError = 134
	// InvalidCondition: invalid condition "(?(0)". Since 2.16
	InvalidCondition RegexError = 135
	// SingleByteMatchInLookbehind: \\C not allowed in lookbehind assertion.
	// Since 2.16
	SingleByteMatchInLookbehind RegexError = 136
	// InfiniteLoop: recursive call could loop indefinitely. Since 2.16
	InfiniteLoop RegexError = 140
	// MissingSubpatternNameTerminator: missing terminator in subpattern name.
	// Since 2.16
	MissingSubpatternNameTerminator RegexError = 142
	// DuplicateSubpatternName: two named subpatterns have the same name. Since
	// 2.16
	DuplicateSubpatternName RegexError = 143
	// MalformedProperty: malformed "\\P" or "\\p" sequence. Since 2.16
	MalformedProperty RegexError = 146
	// UnknownProperty: unknown property name after "\\P" or "\\p". Since 2.16
	UnknownProperty RegexError = 147
	// SubpatternNameTooLong: subpattern name is too long (maximum 32
	// characters). Since 2.16
	SubpatternNameTooLong RegexError = 148
	// TooManySubpatterns: too many named subpatterns (maximum 10,000). Since
	// 2.16
	TooManySubpatterns RegexError = 149
	// InvalidOctalValue: octal value is greater than "\\377". Since 2.16
	InvalidOctalValue RegexError = 151
	// TooManyBranchesInDefine: "DEFINE" group contains more than one branch.
	// Since 2.16
	TooManyBranchesInDefine RegexError = 154
	// DefineRepetion: repeating a "DEFINE" group is not allowed. This error is
	// never raised. Since: 2.16 Deprecated: 2.34
	DefineRepetion RegexError = 155
	// InconsistentNewlineOptions: inconsistent newline options. Since 2.16
	InconsistentNewlineOptions RegexError = 156
	// MissingBackReference: "\\g" is not followed by a braced, angle-bracketed,
	// or quoted name or number, or by a plain number. Since: 2.16
	MissingBackReference RegexError = 157
	// InvalidRelativeReference: relative reference must not be zero. Since:
	// 2.34
	InvalidRelativeReference RegexError = 158
	// BacktrackingControlVerbArgumentForbidden: the backtracing control verb
	// used does not allow an argument. Since: 2.34
	BacktrackingControlVerbArgumentForbidden RegexError = 159
	// UnknownBacktrackingControlVerb: unknown backtracing control verb. Since:
	// 2.34
	UnknownBacktrackingControlVerb RegexError = 160
	// NumberTooBig: number is too big in escape sequence. Since: 2.34
	NumberTooBig RegexError = 161
	// MissingSubpatternName: missing subpattern name. Since: 2.34
	MissingSubpatternName RegexError = 162
	// MissingDigit: missing digit. Since 2.34
	MissingDigit RegexError = 163
	// InvalidDataCharacter: in JavaScript compatibility mode, "[" is an invalid
	// data character. Since: 2.34
	InvalidDataCharacter RegexError = 164
	// ExtraSubpatternName: different names for subpatterns of the same number
	// are not allowed. Since: 2.34
	ExtraSubpatternName RegexError = 165
	// BacktrackingControlVerbArgumentRequired: the backtracing control verb
	// requires an argument. Since: 2.34
	BacktrackingControlVerbArgumentRequired RegexError = 166
	// InvalidControlChar: "\\c" must be followed by an ASCII character. Since:
	// 2.34
	InvalidControlChar RegexError = 168
	// MissingName: "\\k" is not followed by a braced, angle-bracketed, or
	// quoted name. Since: 2.34
	MissingName RegexError = 169
	// NotSupportedInClass: "\\N" is not supported in a class. Since: 2.34
	NotSupportedInClass RegexError = 171
	// TooManyForwardReferences: too many forward references. Since: 2.34
	TooManyForwardReferences RegexError = 172
	// NameTooLong: the name is too long in "(*MARK)", "(*PRUNE)", "(*SKIP)", or
	// "(*THEN)". Since: 2.34
	NameTooLong RegexError = 175
	// CharacterValueTooLarge: the character value in the \\u sequence is too
	// large. Since: 2.34
	CharacterValueTooLarge RegexError = 176
)

// RegexCompileFlags flags specifying compile-time options.
type RegexCompileFlags int

const (
	// RegexCompileFlagsCaseless letters in the pattern match both upper- and
	// lowercase letters. This option can be changed within a pattern by a
	// "(?i)" option setting.
	RegexCompileFlagsCaseless RegexCompileFlags = 0b1
	// RegexCompileFlagsMultiline: by default, GRegex treats the strings as
	// consisting of a single line of characters (even if it actually contains
	// newlines). The "start of line" metacharacter ("^") matches only at the
	// start of the string, while the "end of line" metacharacter ("$") matches
	// only at the end of the string, or before a terminating newline (unless
	// REGEX_DOLLAR_ENDONLY is set). When REGEX_MULTILINE is set, the "start of
	// line" and "end of line" constructs match immediately following or
	// immediately before any newline in the string, respectively, as well as at
	// the very start and end. This can be changed within a pattern by a "(?m)"
	// option setting.
	RegexCompileFlagsMultiline RegexCompileFlags = 0b10
	// RegexCompileFlagsDotall: dot metacharacter (".") in the pattern matches
	// all characters, including newlines. Without it, newlines are excluded.
	// This option can be changed within a pattern by a ("?s") option setting.
	RegexCompileFlagsDotall RegexCompileFlags = 0b100
	// RegexCompileFlagsExtended: whitespace data characters in the pattern are
	// totally ignored except when escaped or inside a character class.
	// Whitespace does not include the VT character (code 11). In addition,
	// characters between an unescaped "#" outside a character class and the
	// next newline character, inclusive, are also ignored. This can be changed
	// within a pattern by a "(?x)" option setting.
	RegexCompileFlagsExtended RegexCompileFlags = 0b1000
	// RegexCompileFlagsAnchored: the pattern is forced to be "anchored", that
	// is, it is constrained to match only at the first matching point in the
	// string that is being searched. This effect can also be achieved by
	// appropriate constructs in the pattern itself such as the "^"
	// metacharacter.
	RegexCompileFlagsAnchored RegexCompileFlags = 0b10000
	// RegexCompileFlagsDollarEndonly: dollar metacharacter ("$") in the pattern
	// matches only at the end of the string. Without this option, a dollar also
	// matches immediately before the final character if it is a newline (but
	// not before any other newlines). This option is ignored if REGEX_MULTILINE
	// is set.
	RegexCompileFlagsDollarEndonly RegexCompileFlags = 0b100000
	// RegexCompileFlagsUngreedy inverts the "greediness" of the quantifiers so
	// that they are not greedy by default, but become greedy if followed by
	// "?". It can also be set by a "(?U)" option setting within the pattern.
	RegexCompileFlagsUngreedy RegexCompileFlags = 0b1000000000
	// RegexCompileFlagsRaw: usually strings must be valid UTF-8 strings, using
	// this flag they are considered as a raw sequence of bytes.
	RegexCompileFlagsRaw RegexCompileFlags = 0b100000000000
	// RegexCompileFlagsNoAutoCapture disables the use of numbered capturing
	// parentheses in the pattern. Any opening parenthesis that is not followed
	// by "?" behaves as if it were followed by "?:" but named parentheses can
	// still be used for capturing (and they acquire numbers in the usual way).
	RegexCompileFlagsNoAutoCapture RegexCompileFlags = 0b1000000000000
	// RegexCompileFlagsOptimize: optimize the regular expression. If the
	// pattern will be used many times, then it may be worth the effort to
	// optimize it to improve the speed of matches.
	RegexCompileFlagsOptimize RegexCompileFlags = 0b10000000000000
	// RegexCompileFlagsFirstline limits an unanchored pattern to match before
	// (or at) the first newline. Since: 2.34
	RegexCompileFlagsFirstline RegexCompileFlags = 0b1000000000000000000
	// RegexCompileFlagsDupnames names used to identify capturing subpatterns
	// need not be unique. This can be helpful for certain types of pattern when
	// it is known that only one instance of the named subpattern can ever be
	// matched.
	RegexCompileFlagsDupnames RegexCompileFlags = 0b10000000000000000000
	// RegexCompileFlagsNewlineCr: usually any newline character or character
	// sequence is recognized. If this option is set, the only recognized
	// newline character is '\r'.
	RegexCompileFlagsNewlineCr RegexCompileFlags = 0b100000000000000000000
	// RegexCompileFlagsNewlineLf: usually any newline character or character
	// sequence is recognized. If this option is set, the only recognized
	// newline character is '\n'.
	RegexCompileFlagsNewlineLf RegexCompileFlags = 0b1000000000000000000000
	// RegexCompileFlagsNewlineCrlf: usually any newline character or character
	// sequence is recognized. If this option is set, the only recognized
	// newline character sequence is '\r\n'.
	RegexCompileFlagsNewlineCrlf RegexCompileFlags = 0b1100000000000000000000
	// RegexCompileFlagsNewlineAnycrlf: usually any newline character or
	// character sequence is recognized. If this option is set, the only
	// recognized newline character sequences are '\r', '\n', and '\r\n'. Since:
	// 2.34
	RegexCompileFlagsNewlineAnycrlf RegexCompileFlags = 0b10100000000000000000000
	// RegexCompileFlagsBsrAnycrlf: usually any newline character or character
	// sequence is recognised. If this option is set, then "\R" only recognizes
	// the newline characters '\r', '\n' and '\r\n'. Since: 2.34
	RegexCompileFlagsBsrAnycrlf RegexCompileFlags = 0b100000000000000000000000
	// RegexCompileFlagsJavascriptCompat changes behaviour so that it is
	// compatible with JavaScript rather than PCRE. Since: 2.34
	RegexCompileFlagsJavascriptCompat RegexCompileFlags = 0b10000000000000000000000000
)

// RegexMatchFlags flags specifying match-time options.
type RegexMatchFlags int

const (
	// RegexMatchFlagsAnchored: the pattern is forced to be "anchored", that is,
	// it is constrained to match only at the first matching point in the string
	// that is being searched. This effect can also be achieved by appropriate
	// constructs in the pattern itself such as the "^" metacharacter.
	RegexMatchFlagsAnchored RegexMatchFlags = 0b10000
	// RegexMatchFlagsNotbol specifies that first character of the string is not
	// the beginning of a line, so the circumflex metacharacter should not match
	// before it. Setting this without REGEX_MULTILINE (at compile time) causes
	// circumflex never to match. This option affects only the behaviour of the
	// circumflex metacharacter, it does not affect "\A".
	RegexMatchFlagsNotbol RegexMatchFlags = 0b10000000
	// RegexMatchFlagsNoteol specifies that the end of the subject string is not
	// the end of a line, so the dollar metacharacter should not match it nor
	// (except in multiline mode) a newline immediately before it. Setting this
	// without REGEX_MULTILINE (at compile time) causes dollar never to match.
	// This option affects only the behaviour of the dollar metacharacter, it
	// does not affect "\Z" or "\z".
	RegexMatchFlagsNoteol RegexMatchFlags = 0b100000000
	// RegexMatchFlagsNotempty: empty string is not considered to be a valid
	// match if this option is set. If there are alternatives in the pattern,
	// they are tried. If all the alternatives match the empty string, the
	// entire match fails. For example, if the pattern "a?b?" is applied to a
	// string not beginning with "a" or "b", it matches the empty string at the
	// start of the string. With this flag set, this match is not valid, so
	// GRegex searches further into the string for occurrences of "a" or "b".
	RegexMatchFlagsNotempty RegexMatchFlags = 0b10000000000
	// RegexMatchFlagsPartial turns on the partial matching feature, for more
	// documentation on partial matching see g_match_info_is_partial_match().
	RegexMatchFlagsPartial RegexMatchFlags = 0b1000000000000000
	// RegexMatchFlagsNewlineCr overrides the newline definition set when
	// creating a new #GRegex, setting the '\r' character as line terminator.
	RegexMatchFlagsNewlineCr RegexMatchFlags = 0b100000000000000000000
	// RegexMatchFlagsNewlineLf overrides the newline definition set when
	// creating a new #GRegex, setting the '\n' character as line terminator.
	RegexMatchFlagsNewlineLf RegexMatchFlags = 0b1000000000000000000000
	// RegexMatchFlagsNewlineCrlf overrides the newline definition set when
	// creating a new #GRegex, setting the '\r\n' characters sequence as line
	// terminator.
	RegexMatchFlagsNewlineCrlf RegexMatchFlags = 0b1100000000000000000000
	// RegexMatchFlagsNewlineAny overrides the newline definition set when
	// creating a new #GRegex, any Unicode newline sequence is recognised as a
	// newline. These are '\r', '\n' and '\rn', and the single characters U+000B
	// LINE TABULATION, U+000C FORM FEED (FF), U+0085 NEXT LINE (NEL), U+2028
	// LINE SEPARATOR and U+2029 PARAGRAPH SEPARATOR.
	RegexMatchFlagsNewlineAny RegexMatchFlags = 0b10000000000000000000000
	// RegexMatchFlagsNewlineAnycrlf overrides the newline definition set when
	// creating a new #GRegex; any '\r', '\n', or '\r\n' character sequence is
	// recognized as a newline. Since: 2.34
	RegexMatchFlagsNewlineAnycrlf RegexMatchFlags = 0b10100000000000000000000
	// RegexMatchFlagsBsrAnycrlf overrides the newline definition for "\R" set
	// when creating a new #GRegex; only '\r', '\n', or '\r\n' character
	// sequences are recognized as a newline by "\R". Since: 2.34
	RegexMatchFlagsBsrAnycrlf RegexMatchFlags = 0b100000000000000000000000
	// RegexMatchFlagsBsrAny overrides the newline definition for "\R" set when
	// creating a new #GRegex; any Unicode newline character or character
	// sequence are recognized as a newline by "\R". These are '\r', '\n' and
	// '\rn', and the single characters U+000B LINE TABULATION, U+000C FORM FEED
	// (FF), U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and U+2029 PARAGRAPH
	// SEPARATOR. Since: 2.34
	RegexMatchFlagsBsrAny RegexMatchFlags = 0b1000000000000000000000000
	// RegexMatchFlagsPartialSoft alias for REGEX_MATCH_PARTIAL. Since: 2.34
	RegexMatchFlagsPartialSoft RegexMatchFlags = 0b1000000000000000
	// RegexMatchFlagsPartialHard turns on the partial matching feature. In
	// contrast to to REGEX_MATCH_PARTIAL_SOFT, this stops matching as soon as a
	// partial match is found, without continuing to search for a possible
	// complete match. See g_match_info_is_partial_match() for more information.
	// Since: 2.34
	RegexMatchFlagsPartialHard RegexMatchFlags = 0b1000000000000000000000000000
	// RegexMatchFlagsNotemptyAtstart: like REGEX_MATCH_NOTEMPTY, but only
	// applied to the start of the matched string. For anchored patterns this
	// can only happen for pattern containing "\K". Since: 2.34
	RegexMatchFlagsNotemptyAtstart RegexMatchFlags = 0b10000000000000000000000000000
)

// MatchInfo is an opaque struct used to return information about matches.
type MatchInfo struct {
	native C.GMatchInfo
}

// WrapMatchInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMatchInfo(ptr unsafe.Pointer) *MatchInfo {
	return (*MatchInfo)(ptr)
}

func marshalMatchInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*MatchInfo)(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (m *MatchInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&m.native)
}

// ExpandReferences returns a new string containing the text in
// @string_to_expand with references and escape sequences expanded. References
// refer to the last match done with @string against @regex and have the same
// syntax used by g_regex_replace().
//
// The @string_to_expand must be UTF-8 encoded even if REGEX_RAW was passed to
// g_regex_new().
//
// The backreferences are extracted from the string passed to the match
// function, so you cannot call this function after freeing the string.
//
// @match_info may be nil in which case @string_to_expand must not contain
// references. For instance "foo\n" does not refer to an actual pattern and '\n'
// merely will be replaced with \n character, while to expand "\0" (whole match)
// one needs the result of a match. Use g_regex_check_replacement() to find out
// whether @string_to_expand contains references.
func (m *MatchInfo) ExpandReferences(stringToExpand string) (string, error) {
	var _arg0 *C.GMatchInfo // out
	var _arg1 *C.gchar      // out
	var _cret *C.gchar      // in
	var _cerr *C.GError     // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m))
	_arg1 = (*C.gchar)(C.CString(stringToExpand))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_match_info_expand_references(_arg0, _arg1, &_cerr)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _utf8, _goerr
}

// Fetch retrieves the text matching the @match_num'th capturing parentheses. 0
// is the full text of the match, 1 is the first paren set, 2 the second, and so
// on.
//
// If @match_num is a valid sub pattern but it didn't match anything (e.g. sub
// pattern 1, matching "b" against "(a)?b") then an empty string is returned.
//
// If the match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved string is not
// that of a set of parentheses but that of a matched substring. Substrings are
// matched in reverse order of length, so 0 is the longest match.
//
// The string is fetched from the string passed to the match function, so you
// cannot call this function after freeing the string.
func (m *MatchInfo) Fetch(matchNum int) string {
	var _arg0 *C.GMatchInfo // out
	var _arg1 C.gint        // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m))
	_arg1 = C.gint(matchNum)

	_cret = C.g_match_info_fetch(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// FetchAll bundles up pointers to each of the matching substrings from a match
// and stores them in an array of gchar pointers. The first element in the
// returned array is the match number 0, i.e. the entire matched text.
//
// If a sub pattern didn't match anything (e.g. sub pattern 1, matching "b"
// against "(a)?b") then an empty string is inserted.
//
// If the last match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved strings are
// not that matched by sets of parentheses but that of the matched substring.
// Substrings are matched in reverse order of length, so the first one is the
// longest match.
//
// The strings are fetched from the string passed to the match function, so you
// cannot call this function after freeing the string.
func (m *MatchInfo) FetchAll() []string {
	var _arg0 *C.GMatchInfo // out
	var _cret **C.gchar

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m))

	_cret = C.g_match_info_fetch_all(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// FetchNamed retrieves the text matching the capturing parentheses named @name.
//
// If @name is a valid sub pattern name but it didn't match anything (e.g. sub
// pattern "X", matching "b" against "(?P<X>a)?b") then an empty string is
// returned.
//
// The string is fetched from the string passed to the match function, so you
// cannot call this function after freeing the string.
func (m *MatchInfo) FetchNamed(name string) string {
	var _arg0 *C.GMatchInfo // out
	var _arg1 *C.gchar      // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_match_info_fetch_named(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// FetchNamedPos retrieves the position in bytes of the capturing parentheses
// named @name.
//
// If @name is a valid sub pattern name but it didn't match anything (e.g. sub
// pattern "X", matching "b" against "(?P<X>a)?b") then @start_pos and @end_pos
// are set to -1 and true is returned.
func (m *MatchInfo) FetchNamedPos(name string) (startPos int, endPos int, ok bool) {
	var _arg0 *C.GMatchInfo // out
	var _arg1 *C.gchar      // out
	var _arg2 C.gint        // in
	var _arg3 C.gint        // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_match_info_fetch_named_pos(_arg0, _arg1, &_arg2, &_arg3)

	var _startPos int // out
	var _endPos int   // out
	var _ok bool      // out

	_startPos = int(_arg2)
	_endPos = int(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _startPos, _endPos, _ok
}

// FetchPos retrieves the position in bytes of the @match_num'th capturing
// parentheses. 0 is the full text of the match, 1 is the first paren set, 2 the
// second, and so on.
//
// If @match_num is a valid sub pattern but it didn't match anything (e.g. sub
// pattern 1, matching "b" against "(a)?b") then @start_pos and @end_pos are set
// to -1 and true is returned.
//
// If the match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved position is
// not that of a set of parentheses but that of a matched substring. Substrings
// are matched in reverse order of length, so 0 is the longest match.
func (m *MatchInfo) FetchPos(matchNum int) (startPos int, endPos int, ok bool) {
	var _arg0 *C.GMatchInfo // out
	var _arg1 C.gint        // out
	var _arg2 C.gint        // in
	var _arg3 C.gint        // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m))
	_arg1 = C.gint(matchNum)

	_cret = C.g_match_info_fetch_pos(_arg0, _arg1, &_arg2, &_arg3)

	var _startPos int // out
	var _endPos int   // out
	var _ok bool      // out

	_startPos = int(_arg2)
	_endPos = int(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _startPos, _endPos, _ok
}

// Free: if @match_info is not nil, calls g_match_info_unref(); otherwise does
// nothing.
func (m *MatchInfo) free() {
	var _arg0 *C.GMatchInfo // out

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m))

	C.g_match_info_free(_arg0)
}

// MatchCount retrieves the number of matched substrings (including substring 0,
// that is the whole matched text), so 1 is returned if the pattern has no
// substrings in it and 0 is returned if the match failed.
//
// If the last match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved count is not
// that of the number of capturing parentheses but that of the number of matched
// substrings.
func (m *MatchInfo) MatchCount() int {
	var _arg0 *C.GMatchInfo // out
	var _cret C.gint        // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m))

	_cret = C.g_match_info_get_match_count(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Regex returns #GRegex object used in @match_info. It belongs to Glib and must
// not be freed. Use g_regex_ref() if you need to keep it after you free
// @match_info object.
func (m *MatchInfo) Regex() *Regex {
	var _arg0 *C.GMatchInfo // out
	var _cret *C.GRegex     // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m))

	_cret = C.g_match_info_get_regex(_arg0)

	var _regex *Regex // out

	_regex = (*Regex)(unsafe.Pointer(_cret))
	C.g_regex_ref(_cret)
	runtime.SetFinalizer(_regex, func(v *Regex) {
		C.g_regex_unref((*C.GRegex)(unsafe.Pointer(v)))
	})

	return _regex
}

// String returns the string searched with @match_info. This is the string
// passed to g_regex_match() or g_regex_replace() so you may not free it before
// calling this function.
func (m *MatchInfo) String() string {
	var _arg0 *C.GMatchInfo // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m))

	_cret = C.g_match_info_get_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// IsPartialMatch: usually if the string passed to g_regex_match*() matches as
// far as it goes, but is too short to match the entire pattern, false is
// returned. There are circumstances where it might be helpful to distinguish
// this case from other cases in which there is no match.
//
// Consider, for example, an application where a human is required to type in
// data for a field with specific formatting requirements. An example might be a
// date in the form ddmmmyy, defined by the pattern
// "^\d?\d(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\d\d$". If the
// application sees the user’s keystrokes one by one, and can check that what
// has been typed so far is potentially valid, it is able to raise an error as
// soon as a mistake is made.
//
// GRegex supports the concept of partial matching by means of the
// REGEX_MATCH_PARTIAL_SOFT and REGEX_MATCH_PARTIAL_HARD flags. When they are
// used, the return code for g_regex_match() or g_regex_match_full() is, as
// usual, true for a complete match, false otherwise. But, when these functions
// return false, you can check if the match was partial calling
// g_match_info_is_partial_match().
//
// The difference between REGEX_MATCH_PARTIAL_SOFT and REGEX_MATCH_PARTIAL_HARD
// is that when a partial match is encountered with REGEX_MATCH_PARTIAL_SOFT,
// matching continues to search for a possible complete match, while with
// REGEX_MATCH_PARTIAL_HARD matching stops at the partial match. When both
// REGEX_MATCH_PARTIAL_SOFT and REGEX_MATCH_PARTIAL_HARD are set, the latter
// takes precedence.
//
// There were formerly some restrictions on the pattern for partial matching.
// The restrictions no longer apply.
//
// See pcrepartial(3) for more information on partial matching.
func (m *MatchInfo) IsPartialMatch() bool {
	var _arg0 *C.GMatchInfo // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m))

	_cret = C.g_match_info_is_partial_match(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Matches returns whether the previous match operation succeeded.
func (m *MatchInfo) Matches() bool {
	var _arg0 *C.GMatchInfo // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m))

	_cret = C.g_match_info_matches(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Next scans for the next match using the same parameters of the previous call
// to g_regex_match_full() or g_regex_match() that returned @match_info.
//
// The match is done on the string passed to the match function, so you cannot
// free it before calling this function.
func (m *MatchInfo) Next() error {
	var _arg0 *C.GMatchInfo // out
	var _cerr *C.GError     // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m))

	C.g_match_info_next(_arg0, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// Ref increases reference count of @match_info by 1.
func (m *MatchInfo) ref() *MatchInfo {
	var _arg0 *C.GMatchInfo // out
	var _cret *C.GMatchInfo // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m))

	_cret = C.g_match_info_ref(_arg0)

	var _matchInfo *MatchInfo // out

	_matchInfo = (*MatchInfo)(unsafe.Pointer(_cret))
	C.g_match_info_ref(_cret)
	runtime.SetFinalizer(_matchInfo, func(v *MatchInfo) {
		C.g_match_info_unref((*C.GMatchInfo)(unsafe.Pointer(v)))
	})

	return _matchInfo
}

// Unref decreases reference count of @match_info by 1. When reference count
// drops to zero, it frees all the memory associated with the match_info
// structure.
func (m *MatchInfo) unref() {
	var _arg0 *C.GMatchInfo // out

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m))

	C.g_match_info_unref(_arg0)
}

// Regex: the g_regex_*() functions implement regular expression pattern
// matching using syntax and semantics similar to Perl regular expression.
//
// Some functions accept a @start_position argument, setting it differs from
// just passing over a shortened string and setting REGEX_MATCH_NOTBOL in the
// case of a pattern that begins with any kind of lookbehind assertion. For
// example, consider the pattern "\Biss\B" which finds occurrences of "iss" in
// the middle of words. ("\B" matches only if the current position in the
// subject is not a word boundary.) When applied to the string "Mississipi" from
// the fourth byte, namely "issipi", it does not match, because "\B" is always
// false at the start of the subject, which is deemed to be a word boundary.
// However, if the entire string is passed , but with @start_position set to 4,
// it finds the second occurrence of "iss" because it is able to look behind the
// starting point to discover that it is preceded by a letter.
//
// Note that, unless you set the REGEX_RAW flag, all the strings passed to these
// functions must be encoded in UTF-8. The lengths and the positions inside the
// strings are in bytes and not in characters, so, for instance, "\xc3\xa0"
// (i.e. "à") is two bytes long but it is treated as a single character. If you
// set REGEX_RAW the strings can be non-valid UTF-8 strings and a byte is
// treated as a character, so "\xc3\xa0" is two bytes and two characters long.
//
// When matching a pattern, "\n" matches only against a "\n" character in the
// string, and "\r" matches only a "\r" character. To match any newline sequence
// use "\R". This particular group matches either the two-character sequence CR
// + LF ("\r\n"), or one of the single characters LF (linefeed, U+000A, "\n"),
// VT vertical tab, U+000B, "\v"), FF (formfeed, U+000C, "\f"), CR (carriage
// return, U+000D, "\r"), NEL (next line, U+0085), LS (line separator, U+2028),
// or PS (paragraph separator, U+2029).
//
// The behaviour of the dot, circumflex, and dollar metacharacters are affected
// by newline characters, the default is to recognize any newline character (the
// same characters recognized by "\R"). This can be changed with
// REGEX_NEWLINE_CR, REGEX_NEWLINE_LF and REGEX_NEWLINE_CRLF compile options,
// and with REGEX_MATCH_NEWLINE_ANY, REGEX_MATCH_NEWLINE_CR,
// REGEX_MATCH_NEWLINE_LF and REGEX_MATCH_NEWLINE_CRLF match options. These
// settings are also relevant when compiling a pattern if REGEX_EXTENDED is set,
// and an unescaped "#" outside a character class is encountered. This indicates
// a comment that lasts until after the next newline.
//
// When setting the G_REGEX_JAVASCRIPT_COMPAT flag, pattern syntax and pattern
// matching is changed to be compatible with the way that regular expressions
// work in JavaScript. More precisely, a lonely ']' character in the pattern is
// a syntax error; the '\x' escape only allows 0 to 2 hexadecimal digits, and
// you must use the '\u' escape sequence with 4 hex digits to specify a unicode
// codepoint instead of '\x' or 'x{....}'. If '\x' or '\u' are not followed by
// the specified number of hex digits, they match 'x' and 'u' literally; also
// '\U' always matches 'U' instead of being an error in the pattern. Finally,
// pattern matching is modified so that back references to an unset subpattern
// group produces a match with the empty string instead of an error. See
// pcreapi(3) for more information.
//
// Creating and manipulating the same #GRegex structure from different threads
// is not a problem as #GRegex does not modify its internal state between
// creation and destruction, on the other hand Info is not threadsafe.
//
// The regular expressions low-level functionalities are obtained through the
// excellent PCRE (http://www.pcre.org/) library written by Philip Hazel.
type Regex struct {
	native C.GRegex
}

// WrapRegex wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRegex(ptr unsafe.Pointer) *Regex {
	return (*Regex)(ptr)
}

func marshalRegex(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*Regex)(unsafe.Pointer(b)), nil
}

// NewRegex constructs a struct Regex.
func NewRegex(pattern string, compileOptions RegexCompileFlags, matchOptions RegexMatchFlags) (*Regex, error) {
	var _arg1 *C.gchar             // out
	var _arg2 C.GRegexCompileFlags // out
	var _arg3 C.GRegexMatchFlags   // out
	var _cret *C.GRegex            // in
	var _cerr *C.GError            // in

	_arg1 = (*C.gchar)(C.CString(pattern))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GRegexCompileFlags(compileOptions)
	_arg3 = C.GRegexMatchFlags(matchOptions)

	_cret = C.g_regex_new(_arg1, _arg2, _arg3, &_cerr)

	var _regex *Regex // out
	var _goerr error  // out

	_regex = (*Regex)(unsafe.Pointer(_cret))
	C.g_regex_ref(_cret)
	runtime.SetFinalizer(_regex, func(v *Regex) {
		C.g_regex_unref((*C.GRegex)(unsafe.Pointer(v)))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _regex, _goerr
}

// Native returns the underlying C source pointer.
func (r *Regex) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// CaptureCount returns the number of capturing subpatterns in the pattern.
func (r *Regex) CaptureCount() int {
	var _arg0 *C.GRegex // out
	var _cret C.gint    // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r))

	_cret = C.g_regex_get_capture_count(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// CompileFlags returns the compile options that @regex was created with.
//
// Depending on the version of PCRE that is used, this may or may not include
// flags set by option expressions such as `(?i)` found at the top-level within
// the compiled pattern.
func (r *Regex) CompileFlags() RegexCompileFlags {
	var _arg0 *C.GRegex            // out
	var _cret C.GRegexCompileFlags // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r))

	_cret = C.g_regex_get_compile_flags(_arg0)

	var _regexCompileFlags RegexCompileFlags // out

	_regexCompileFlags = RegexCompileFlags(_cret)

	return _regexCompileFlags
}

// HasCrOrLf checks whether the pattern contains explicit CR or LF references.
func (r *Regex) HasCrOrLf() bool {
	var _arg0 *C.GRegex  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r))

	_cret = C.g_regex_get_has_cr_or_lf(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MatchFlags returns the match options that @regex was created with.
func (r *Regex) MatchFlags() RegexMatchFlags {
	var _arg0 *C.GRegex          // out
	var _cret C.GRegexMatchFlags // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r))

	_cret = C.g_regex_get_match_flags(_arg0)

	var _regexMatchFlags RegexMatchFlags // out

	_regexMatchFlags = RegexMatchFlags(_cret)

	return _regexMatchFlags
}

// MaxBackref returns the number of the highest back reference in the pattern,
// or 0 if the pattern does not contain back references.
func (r *Regex) MaxBackref() int {
	var _arg0 *C.GRegex // out
	var _cret C.gint    // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r))

	_cret = C.g_regex_get_max_backref(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// MaxLookbehind gets the number of characters in the longest lookbehind
// assertion in the pattern. This information is useful when doing multi-segment
// matching using the partial matching facilities.
func (r *Regex) MaxLookbehind() int {
	var _arg0 *C.GRegex // out
	var _cret C.gint    // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r))

	_cret = C.g_regex_get_max_lookbehind(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Pattern gets the pattern string associated with @regex, i.e. a copy of the
// string passed to g_regex_new().
func (r *Regex) Pattern() string {
	var _arg0 *C.GRegex // out
	var _cret *C.gchar  // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r))

	_cret = C.g_regex_get_pattern(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// StringNumber retrieves the number of the subexpression named @name.
func (r *Regex) StringNumber(name string) int {
	var _arg0 *C.GRegex // out
	var _arg1 *C.gchar  // out
	var _cret C.gint    // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_regex_get_string_number(_arg0, _arg1)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Match scans for a match in @string for the pattern in @regex. The
// @match_options are combined with the match options specified when the @regex
// structure was created, letting you have more flexibility in reusing #GRegex
// structures.
//
// Unless G_REGEX_RAW is specified in the options, @string must be valid UTF-8.
//
// A Info structure, used to get information on the match, is stored in
// @match_info if not nil. Note that if @match_info is not nil then it is
// created even if the function returns false, i.e. you must free it regardless
// if regular expression actually matched.
//
// To retrieve all the non-overlapping matches of the pattern in string you can
// use g_match_info_next().
//
//    static void
//    print_uppercase_words (const gchar *string)
//    {
//      // Print all uppercase-only words.
//      GRegex *regex;
//      GMatchInfo *match_info;
//
//      regex = g_regex_new ("[A-Z]+", 0, 0, NULL);
//      g_regex_match (regex, string, 0, &match_info);
//      while (g_match_info_matches (match_info))
//        {
//          gchar *word = g_match_info_fetch (match_info, 0);
//          g_print ("Found: s\n", word);
//          g_free (word);
//          g_match_info_next (match_info, NULL);
//        }
//      g_match_info_free (match_info);
//      g_regex_unref (regex);
//    }
//
// @string is not copied and is used in Info internally. If you use any Info
// method (except g_match_info_free()) after freeing or modifying @string then
// the behaviour is undefined.
func (r *Regex) Match(_string string, matchOptions RegexMatchFlags) (*MatchInfo, bool) {
	var _arg0 *C.GRegex          // out
	var _arg1 *C.gchar           // out
	var _arg2 C.GRegexMatchFlags // out
	var _arg3 *C.GMatchInfo      // in
	var _cret C.gboolean         // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r))
	_arg1 = (*C.gchar)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GRegexMatchFlags(matchOptions)

	_cret = C.g_regex_match(_arg0, _arg1, _arg2, &_arg3)

	var _matchInfo *MatchInfo // out
	var _ok bool              // out

	_matchInfo = (*MatchInfo)(unsafe.Pointer(_arg3))
	C.g_match_info_ref(_arg3)
	runtime.SetFinalizer(_matchInfo, func(v *MatchInfo) {
		C.g_match_info_unref((*C.GMatchInfo)(unsafe.Pointer(v)))
	})
	if _cret != 0 {
		_ok = true
	}

	return _matchInfo, _ok
}

// MatchAll: using the standard algorithm for regular expression matching only
// the longest match in the string is retrieved. This function uses a different
// algorithm so it can retrieve all the possible matches. For more documentation
// see g_regex_match_all_full().
//
// A Info structure, used to get information on the match, is stored in
// @match_info if not nil. Note that if @match_info is not nil then it is
// created even if the function returns false, i.e. you must free it regardless
// if regular expression actually matched.
//
// @string is not copied and is used in Info internally. If you use any Info
// method (except g_match_info_free()) after freeing or modifying @string then
// the behaviour is undefined.
func (r *Regex) MatchAll(_string string, matchOptions RegexMatchFlags) (*MatchInfo, bool) {
	var _arg0 *C.GRegex          // out
	var _arg1 *C.gchar           // out
	var _arg2 C.GRegexMatchFlags // out
	var _arg3 *C.GMatchInfo      // in
	var _cret C.gboolean         // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r))
	_arg1 = (*C.gchar)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GRegexMatchFlags(matchOptions)

	_cret = C.g_regex_match_all(_arg0, _arg1, _arg2, &_arg3)

	var _matchInfo *MatchInfo // out
	var _ok bool              // out

	_matchInfo = (*MatchInfo)(unsafe.Pointer(_arg3))
	C.g_match_info_ref(_arg3)
	runtime.SetFinalizer(_matchInfo, func(v *MatchInfo) {
		C.g_match_info_unref((*C.GMatchInfo)(unsafe.Pointer(v)))
	})
	if _cret != 0 {
		_ok = true
	}

	return _matchInfo, _ok
}

// MatchAllFull: using the standard algorithm for regular expression matching
// only the longest match in the @string is retrieved, it is not possible to
// obtain all the available matches. For instance matching "<a> <b> <c>" against
// the pattern "<.*>" you get "<a> <b> <c>".
//
// This function uses a different algorithm (called DFA, i.e. deterministic
// finite automaton), so it can retrieve all the possible matches, all starting
// at the same point in the string. For instance matching "<a> <b> <c>" against
// the pattern "<.*>;" you would obtain three matches: "<a> <b> <c>", "<a> <b>"
// and "<a>".
//
// The number of matched strings is retrieved using
// g_match_info_get_match_count(). To obtain the matched strings and their
// position you can use, respectively, g_match_info_fetch() and
// g_match_info_fetch_pos(). Note that the strings are returned in reverse order
// of length; that is, the longest matching string is given first.
//
// Note that the DFA algorithm is slower than the standard one and it is not
// able to capture substrings, so backreferences do not work.
//
// Setting @start_position differs from just passing over a shortened string and
// setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind
// of lookbehind assertion, such as "\b".
//
// Unless G_REGEX_RAW is specified in the options, @string must be valid UTF-8.
//
// A Info structure, used to get information on the match, is stored in
// @match_info if not nil. Note that if @match_info is not nil then it is
// created even if the function returns false, i.e. you must free it regardless
// if regular expression actually matched.
//
// @string is not copied and is used in Info internally. If you use any Info
// method (except g_match_info_free()) after freeing or modifying @string then
// the behaviour is undefined.
func (r *Regex) MatchAllFull(_string []byte, startPosition int, matchOptions RegexMatchFlags) (*MatchInfo, error) {
	var _arg0 *C.GRegex // out
	var _arg1 *C.gchar
	var _arg2 C.gssize
	var _arg3 C.gint             // out
	var _arg4 C.GRegexMatchFlags // out
	var _arg5 *C.GMatchInfo      // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r))
	_arg2 = C.gssize(len(_string))
	_arg1 = (*C.gchar)(unsafe.Pointer(&_string[0]))
	_arg3 = C.gint(startPosition)
	_arg4 = C.GRegexMatchFlags(matchOptions)

	C.g_regex_match_all_full(_arg0, _arg1, _arg2, _arg3, _arg4, &_arg5, &_cerr)

	var _matchInfo *MatchInfo // out
	var _goerr error          // out

	_matchInfo = (*MatchInfo)(unsafe.Pointer(_arg5))
	C.g_match_info_ref(_arg5)
	runtime.SetFinalizer(_matchInfo, func(v *MatchInfo) {
		C.g_match_info_unref((*C.GMatchInfo)(unsafe.Pointer(v)))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _matchInfo, _goerr
}

// MatchFull scans for a match in @string for the pattern in @regex. The
// @match_options are combined with the match options specified when the @regex
// structure was created, letting you have more flexibility in reusing #GRegex
// structures.
//
// Setting @start_position differs from just passing over a shortened string and
// setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind
// of lookbehind assertion, such as "\b".
//
// Unless G_REGEX_RAW is specified in the options, @string must be valid UTF-8.
//
// A Info structure, used to get information on the match, is stored in
// @match_info if not nil. Note that if @match_info is not nil then it is
// created even if the function returns false, i.e. you must free it regardless
// if regular expression actually matched.
//
// @string is not copied and is used in Info internally. If you use any Info
// method (except g_match_info_free()) after freeing or modifying @string then
// the behaviour is undefined.
//
// To retrieve all the non-overlapping matches of the pattern in string you can
// use g_match_info_next().
//
//    static void
//    print_uppercase_words (const gchar *string)
//    {
//      // Print all uppercase-only words.
//      GRegex *regex;
//      GMatchInfo *match_info;
//      GError *error = NULL;
//
//      regex = g_regex_new ("[A-Z]+", 0, 0, NULL);
//      g_regex_match_full (regex, string, -1, 0, 0, &match_info, &error);
//      while (g_match_info_matches (match_info))
//        {
//          gchar *word = g_match_info_fetch (match_info, 0);
//          g_print ("Found: s\n", word);
//          g_free (word);
//          g_match_info_next (match_info, &error);
//        }
//      g_match_info_free (match_info);
//      g_regex_unref (regex);
//      if (error != NULL)
//        {
//          g_printerr ("Error while matching: s\n", error->message);
//          g_error_free (error);
//        }
//    }
func (r *Regex) MatchFull(_string []byte, startPosition int, matchOptions RegexMatchFlags) (*MatchInfo, error) {
	var _arg0 *C.GRegex // out
	var _arg1 *C.gchar
	var _arg2 C.gssize
	var _arg3 C.gint             // out
	var _arg4 C.GRegexMatchFlags // out
	var _arg5 *C.GMatchInfo      // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r))
	_arg2 = C.gssize(len(_string))
	_arg1 = (*C.gchar)(unsafe.Pointer(&_string[0]))
	_arg3 = C.gint(startPosition)
	_arg4 = C.GRegexMatchFlags(matchOptions)

	C.g_regex_match_full(_arg0, _arg1, _arg2, _arg3, _arg4, &_arg5, &_cerr)

	var _matchInfo *MatchInfo // out
	var _goerr error          // out

	_matchInfo = (*MatchInfo)(unsafe.Pointer(_arg5))
	C.g_match_info_ref(_arg5)
	runtime.SetFinalizer(_matchInfo, func(v *MatchInfo) {
		C.g_match_info_unref((*C.GMatchInfo)(unsafe.Pointer(v)))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _matchInfo, _goerr
}

// Ref increases reference count of @regex by 1.
func (r *Regex) ref() *Regex {
	var _arg0 *C.GRegex // out
	var _cret *C.GRegex // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r))

	_cret = C.g_regex_ref(_arg0)

	var _ret *Regex // out

	_ret = (*Regex)(unsafe.Pointer(_cret))
	C.g_regex_ref(_cret)
	runtime.SetFinalizer(_ret, func(v *Regex) {
		C.g_regex_unref((*C.GRegex)(unsafe.Pointer(v)))
	})

	return _ret
}

// Replace replaces all occurrences of the pattern in @regex with the
// replacement text. Backreferences of the form '\number' or '\g<number>' in the
// replacement text are interpolated by the number-th captured subexpression of
// the match, '\g<name>' refers to the captured subexpression with the given
// name. '\0' refers to the complete match, but '\0' followed by a number is the
// octal representation of a character. To include a literal '\' in the
// replacement, write '\\\\'.
//
// There are also escapes that changes the case of the following text:
//
// - \l: Convert to lower case the next character - \u: Convert to upper case
// the next character - \L: Convert to lower case till \E - \U: Convert to upper
// case till \E - \E: End case modification
//
// If you do not need to use backreferences use g_regex_replace_literal().
//
// The @replacement string must be UTF-8 encoded even if REGEX_RAW was passed to
// g_regex_new(). If you want to use not UTF-8 encoded strings you can use
// g_regex_replace_literal().
//
// Setting @start_position differs from just passing over a shortened string and
// setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind
// of lookbehind assertion, such as "\b".
func (r *Regex) Replace(_string []byte, startPosition int, replacement string, matchOptions RegexMatchFlags) (string, error) {
	var _arg0 *C.GRegex // out
	var _arg1 *C.gchar
	var _arg2 C.gssize
	var _arg3 C.gint             // out
	var _arg4 *C.gchar           // out
	var _arg5 C.GRegexMatchFlags // out
	var _cret *C.gchar           // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r))
	_arg2 = C.gssize(len(_string))
	_arg1 = (*C.gchar)(unsafe.Pointer(&_string[0]))
	_arg3 = C.gint(startPosition)
	_arg4 = (*C.gchar)(C.CString(replacement))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = C.GRegexMatchFlags(matchOptions)

	_cret = C.g_regex_replace(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _utf8, _goerr
}

// ReplaceLiteral replaces all occurrences of the pattern in @regex with the
// replacement text. @replacement is replaced literally, to include
// backreferences use g_regex_replace().
//
// Setting @start_position differs from just passing over a shortened string and
// setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind
// of lookbehind assertion, such as "\b".
func (r *Regex) ReplaceLiteral(_string []byte, startPosition int, replacement string, matchOptions RegexMatchFlags) (string, error) {
	var _arg0 *C.GRegex // out
	var _arg1 *C.gchar
	var _arg2 C.gssize
	var _arg3 C.gint             // out
	var _arg4 *C.gchar           // out
	var _arg5 C.GRegexMatchFlags // out
	var _cret *C.gchar           // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r))
	_arg2 = C.gssize(len(_string))
	_arg1 = (*C.gchar)(unsafe.Pointer(&_string[0]))
	_arg3 = C.gint(startPosition)
	_arg4 = (*C.gchar)(C.CString(replacement))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = C.GRegexMatchFlags(matchOptions)

	_cret = C.g_regex_replace_literal(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _utf8, _goerr
}

// Split breaks the string on the pattern, and returns an array of the tokens.
// If the pattern contains capturing parentheses, then the text for each of the
// substrings will also be returned. If the pattern does not match anywhere in
// the string, then the whole string is returned as the first token.
//
// As a special case, the result of splitting the empty string "" is an empty
// vector, not a vector containing a single string. The reason for this special
// case is that being able to represent an empty vector is typically more useful
// than consistent handling of empty elements. If you do need to represent empty
// elements, you'll need to check for the empty string before calling this
// function.
//
// A pattern that can match empty strings splits @string into separate
// characters wherever it matches the empty string between characters. For
// example splitting "ab c" using as a separator "\s*", you will get "a", "b"
// and "c".
func (r *Regex) Split(_string string, matchOptions RegexMatchFlags) []string {
	var _arg0 *C.GRegex          // out
	var _arg1 *C.gchar           // out
	var _arg2 C.GRegexMatchFlags // out
	var _cret **C.gchar

	_arg0 = (*C.GRegex)(unsafe.Pointer(r))
	_arg1 = (*C.gchar)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GRegexMatchFlags(matchOptions)

	_cret = C.g_regex_split(_arg0, _arg1, _arg2)

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// SplitFull breaks the string on the pattern, and returns an array of the
// tokens. If the pattern contains capturing parentheses, then the text for each
// of the substrings will also be returned. If the pattern does not match
// anywhere in the string, then the whole string is returned as the first token.
//
// As a special case, the result of splitting the empty string "" is an empty
// vector, not a vector containing a single string. The reason for this special
// case is that being able to represent an empty vector is typically more useful
// than consistent handling of empty elements. If you do need to represent empty
// elements, you'll need to check for the empty string before calling this
// function.
//
// A pattern that can match empty strings splits @string into separate
// characters wherever it matches the empty string between characters. For
// example splitting "ab c" using as a separator "\s*", you will get "a", "b"
// and "c".
//
// Setting @start_position differs from just passing over a shortened string and
// setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind
// of lookbehind assertion, such as "\b".
func (r *Regex) SplitFull(_string []byte, startPosition int, matchOptions RegexMatchFlags, maxTokens int) ([]string, error) {
	var _arg0 *C.GRegex // out
	var _arg1 *C.gchar
	var _arg2 C.gssize
	var _arg3 C.gint             // out
	var _arg4 C.GRegexMatchFlags // out
	var _arg5 C.gint             // out
	var _cret **C.gchar
	var _cerr *C.GError // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r))
	_arg2 = C.gssize(len(_string))
	_arg1 = (*C.gchar)(unsafe.Pointer(&_string[0]))
	_arg3 = C.gint(startPosition)
	_arg4 = C.GRegexMatchFlags(matchOptions)
	_arg5 = C.gint(maxTokens)

	_cret = C.g_regex_split_full(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _utf8s []string
	var _goerr error // out

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _utf8s, _goerr
}

// Unref decreases reference count of @regex by 1. When reference count drops to
// zero, it frees all the memory associated with the regex structure.
func (r *Regex) unref() {
	var _arg0 *C.GRegex // out

	_arg0 = (*C.GRegex)(unsafe.Pointer(r))

	C.g_regex_unref(_arg0)
}
