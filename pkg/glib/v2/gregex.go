// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <glib.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_match_info_get_type()), F: marshalMatchInfo},
		{T: externglib.Type(C.g_regex_get_type()), F: marshalRegex},
	})
}

// RegexError: error codes returned by regular expressions functions.
type RegexError int

const (
	// compile: compilation of the regular expression failed.
	RegexErrorCompile RegexError = 0
	// optimize: optimization of the regular expression failed.
	RegexErrorOptimize RegexError = 1
	// replace: replacement failed due to an ill-formed replacement string.
	RegexErrorReplace RegexError = 2
	// match: the match process failed.
	RegexErrorMatch RegexError = 3
	// internal: internal error of the regular expression engine. Since 2.16
	RegexErrorInternal RegexError = 4
	// StrayBackslash: "\\" at end of pattern. Since 2.16
	RegexErrorStrayBackslash RegexError = 101
	// MissingControlChar: "\\c" at end of pattern. Since 2.16
	RegexErrorMissingControlChar RegexError = 102
	// UnrecognizedEscape: unrecognized character follows "\\". Since 2.16
	RegexErrorUnrecognizedEscape RegexError = 103
	// QuantifiersOutOfOrder numbers out of order in "{}" quantifier. Since 2.16
	RegexErrorQuantifiersOutOfOrder RegexError = 104
	// QuantifierTooBig: number too big in "{}" quantifier. Since 2.16
	RegexErrorQuantifierTooBig RegexError = 105
	// UnterminatedCharacterClass: missing terminating "]" for character class.
	// Since 2.16
	RegexErrorUnterminatedCharacterClass RegexError = 106
	// InvalidEscapeInCharacterClass: invalid escape sequence in character
	// class. Since 2.16
	RegexErrorInvalidEscapeInCharacterClass RegexError = 107
	// RangeOutOfOrder: range out of order in character class. Since 2.16
	RegexErrorRangeOutOfOrder RegexError = 108
	// NothingToRepeat: nothing to repeat. Since 2.16
	RegexErrorNothingToRepeat RegexError = 109
	// UnrecognizedCharacter: unrecognized character after "(?", "(?<" or "(?P".
	// Since 2.16
	RegexErrorUnrecognizedCharacter RegexError = 112
	// PosixNamedClassOutsideClass: POSIX named classes are supported only
	// within a class. Since 2.16
	RegexErrorPosixNamedClassOutsideClass RegexError = 113
	// UnmatchedParenthesis: missing terminating ")" or ")" without opening "(".
	// Since 2.16
	RegexErrorUnmatchedParenthesis RegexError = 114
	// InexistentSubpatternReference: reference to non-existent subpattern.
	// Since 2.16
	RegexErrorInexistentSubpatternReference RegexError = 115
	// UnterminatedComment: missing terminating ")" after comment. Since 2.16
	RegexErrorUnterminatedComment RegexError = 118
	// ExpressionTooLarge: regular expression too large. Since 2.16
	RegexErrorExpressionTooLarge RegexError = 120
	// MemoryError: failed to get memory. Since 2.16
	RegexErrorMemoryError RegexError = 121
	// VariableLengthLookbehind: lookbehind assertion is not fixed length. Since
	// 2.16
	RegexErrorVariableLengthLookbehind RegexError = 125
	// MalformedCondition: malformed number or name after "(?(". Since 2.16
	RegexErrorMalformedCondition RegexError = 126
	// TooManyConditionalBranches: conditional group contains more than two
	// branches. Since 2.16
	RegexErrorTooManyConditionalBranches RegexError = 127
	// AssertionExpected: assertion expected after "(?(". Since 2.16
	RegexErrorAssertionExpected RegexError = 128
	// UnknownPosixClassName: unknown POSIX class name. Since 2.16
	RegexErrorUnknownPosixClassName RegexError = 130
	// PosixCollatingElementsNotSupported: POSIX collating elements are not
	// supported. Since 2.16
	RegexErrorPosixCollatingElementsNotSupported RegexError = 131
	// HexCodeTooLarge: character value in "\\x{...}" sequence is too large.
	// Since 2.16
	RegexErrorHexCodeTooLarge RegexError = 134
	// InvalidCondition: invalid condition "(?(0)". Since 2.16
	RegexErrorInvalidCondition RegexError = 135
	// SingleByteMatchInLookbehind: \\C not allowed in lookbehind assertion.
	// Since 2.16
	RegexErrorSingleByteMatchInLookbehind RegexError = 136
	// InfiniteLoop: recursive call could loop indefinitely. Since 2.16
	RegexErrorInfiniteLoop RegexError = 140
	// MissingSubpatternNameTerminator: missing terminator in subpattern name.
	// Since 2.16
	RegexErrorMissingSubpatternNameTerminator RegexError = 142
	// DuplicateSubpatternName: two named subpatterns have the same name. Since
	// 2.16
	RegexErrorDuplicateSubpatternName RegexError = 143
	// MalformedProperty: malformed "\\P" or "\\p" sequence. Since 2.16
	RegexErrorMalformedProperty RegexError = 146
	// UnknownProperty: unknown property name after "\\P" or "\\p". Since 2.16
	RegexErrorUnknownProperty RegexError = 147
	// SubpatternNameTooLong: subpattern name is too long (maximum 32
	// characters). Since 2.16
	RegexErrorSubpatternNameTooLong RegexError = 148
	// TooManySubpatterns: too many named subpatterns (maximum 10,000). Since
	// 2.16
	RegexErrorTooManySubpatterns RegexError = 149
	// InvalidOctalValue: octal value is greater than "\\377". Since 2.16
	RegexErrorInvalidOctalValue RegexError = 151
	// TooManyBranchesInDefine: "DEFINE" group contains more than one branch.
	// Since 2.16
	RegexErrorTooManyBranchesInDefine RegexError = 154
	// DefineRepetion: repeating a "DEFINE" group is not allowed. This error is
	// never raised. Since: 2.16 Deprecated: 2.34
	RegexErrorDefineRepetion RegexError = 155
	// InconsistentNewlineOptions: inconsistent newline options. Since 2.16
	RegexErrorInconsistentNewlineOptions RegexError = 156
	// MissingBackReference: "\\g" is not followed by a braced, angle-bracketed,
	// or quoted name or number, or by a plain number. Since: 2.16
	RegexErrorMissingBackReference RegexError = 157
	// InvalidRelativeReference: relative reference must not be zero. Since:
	// 2.34
	RegexErrorInvalidRelativeReference RegexError = 158
	// BacktrackingControlVerbArgumentForbidden: the backtracing control verb
	// used does not allow an argument. Since: 2.34
	RegexErrorBacktrackingControlVerbArgumentForbidden RegexError = 159
	// UnknownBacktrackingControlVerb: unknown backtracing control verb. Since:
	// 2.34
	RegexErrorUnknownBacktrackingControlVerb RegexError = 160
	// NumberTooBig: number is too big in escape sequence. Since: 2.34
	RegexErrorNumberTooBig RegexError = 161
	// MissingSubpatternName: missing subpattern name. Since: 2.34
	RegexErrorMissingSubpatternName RegexError = 162
	// MissingDigit: missing digit. Since 2.34
	RegexErrorMissingDigit RegexError = 163
	// InvalidDataCharacter: in JavaScript compatibility mode, "[" is an invalid
	// data character. Since: 2.34
	RegexErrorInvalidDataCharacter RegexError = 164
	// ExtraSubpatternName: different names for subpatterns of the same number
	// are not allowed. Since: 2.34
	RegexErrorExtraSubpatternName RegexError = 165
	// BacktrackingControlVerbArgumentRequired: the backtracing control verb
	// requires an argument. Since: 2.34
	RegexErrorBacktrackingControlVerbArgumentRequired RegexError = 166
	// InvalidControlChar: "\\c" must be followed by an ASCII character. Since:
	// 2.34
	RegexErrorInvalidControlChar RegexError = 168
	// MissingName: "\\k" is not followed by a braced, angle-bracketed, or
	// quoted name. Since: 2.34
	RegexErrorMissingName RegexError = 169
	// NotSupportedInClass: "\\N" is not supported in a class. Since: 2.34
	RegexErrorNotSupportedInClass RegexError = 171
	// TooManyForwardReferences: too many forward references. Since: 2.34
	RegexErrorTooManyForwardReferences RegexError = 172
	// NameTooLong: the name is too long in "(*MARK)", "(*PRUNE)", "(*SKIP)", or
	// "(*THEN)". Since: 2.34
	RegexErrorNameTooLong RegexError = 175
	// CharacterValueTooLarge: the character value in the \\u sequence is too
	// large. Since: 2.34
	RegexErrorCharacterValueTooLarge RegexError = 176
)

// RegexCompileFlags flags specifying compile-time options.
type RegexCompileFlags int

const (
	// RegexCompileFlagsCaseless letters in the pattern match both upper- and
	// lowercase letters. This option can be changed within a pattern by a
	// "(?i)" option setting.
	RegexCompileFlagsCaseless RegexCompileFlags = 0b1
	// RegexCompileFlagsMultiline: by default, GRegex treats the strings as
	// consisting of a single line of characters (even if it actually contains
	// newlines). The "start of line" metacharacter ("^") matches only at the
	// start of the string, while the "end of line" metacharacter ("$") matches
	// only at the end of the string, or before a terminating newline (unless
	// REGEX_DOLLAR_ENDONLY is set). When REGEX_MULTILINE is set, the "start of
	// line" and "end of line" constructs match immediately following or
	// immediately before any newline in the string, respectively, as well as at
	// the very start and end. This can be changed within a pattern by a "(?m)"
	// option setting.
	RegexCompileFlagsMultiline RegexCompileFlags = 0b10
	// RegexCompileFlagsDotall: a dot metacharacter (".") in the pattern matches
	// all characters, including newlines. Without it, newlines are excluded.
	// This option can be changed within a pattern by a ("?s") option setting.
	RegexCompileFlagsDotall RegexCompileFlags = 0b100
	// RegexCompileFlagsExtended: whitespace data characters in the pattern are
	// totally ignored except when escaped or inside a character class.
	// Whitespace does not include the VT character (code 11). In addition,
	// characters between an unescaped "#" outside a character class and the
	// next newline character, inclusive, are also ignored. This can be changed
	// within a pattern by a "(?x)" option setting.
	RegexCompileFlagsExtended RegexCompileFlags = 0b1000
	// RegexCompileFlagsAnchored: the pattern is forced to be "anchored", that
	// is, it is constrained to match only at the first matching point in the
	// string that is being searched. This effect can also be achieved by
	// appropriate constructs in the pattern itself such as the "^"
	// metacharacter.
	RegexCompileFlagsAnchored RegexCompileFlags = 0b10000
	// RegexCompileFlagsDollarEndonly: a dollar metacharacter ("$") in the
	// pattern matches only at the end of the string. Without this option, a
	// dollar also matches immediately before the final character if it is a
	// newline (but not before any other newlines). This option is ignored if
	// REGEX_MULTILINE is set.
	RegexCompileFlagsDollarEndonly RegexCompileFlags = 0b100000
	// RegexCompileFlagsUngreedy inverts the "greediness" of the quantifiers so
	// that they are not greedy by default, but become greedy if followed by
	// "?". It can also be set by a "(?U)" option setting within the pattern.
	RegexCompileFlagsUngreedy RegexCompileFlags = 0b1000000000
	// RegexCompileFlagsRaw: usually strings must be valid UTF-8 strings, using
	// this flag they are considered as a raw sequence of bytes.
	RegexCompileFlagsRaw RegexCompileFlags = 0b100000000000
	// RegexCompileFlagsNoAutoCapture disables the use of numbered capturing
	// parentheses in the pattern. Any opening parenthesis that is not followed
	// by "?" behaves as if it were followed by "?:" but named parentheses can
	// still be used for capturing (and they acquire numbers in the usual way).
	RegexCompileFlagsNoAutoCapture RegexCompileFlags = 0b1000000000000
	// RegexCompileFlagsOptimize: optimize the regular expression. If the
	// pattern will be used many times, then it may be worth the effort to
	// optimize it to improve the speed of matches.
	RegexCompileFlagsOptimize RegexCompileFlags = 0b10000000000000
	// RegexCompileFlagsFirstline limits an unanchored pattern to match before
	// (or at) the first newline. Since: 2.34
	RegexCompileFlagsFirstline RegexCompileFlags = 0b1000000000000000000
	// RegexCompileFlagsDupnames names used to identify capturing subpatterns
	// need not be unique. This can be helpful for certain types of pattern when
	// it is known that only one instance of the named subpattern can ever be
	// matched.
	RegexCompileFlagsDupnames RegexCompileFlags = 0b10000000000000000000
	// RegexCompileFlagsNewlineCr: usually any newline character or character
	// sequence is recognized. If this option is set, the only recognized
	// newline character is '\r'.
	RegexCompileFlagsNewlineCr RegexCompileFlags = 0b100000000000000000000
	// RegexCompileFlagsNewlineLf: usually any newline character or character
	// sequence is recognized. If this option is set, the only recognized
	// newline character is '\n'.
	RegexCompileFlagsNewlineLf RegexCompileFlags = 0b1000000000000000000000
	// RegexCompileFlagsNewlineCrlf: usually any newline character or character
	// sequence is recognized. If this option is set, the only recognized
	// newline character sequence is '\r\n'.
	RegexCompileFlagsNewlineCrlf RegexCompileFlags = 0b1100000000000000000000
	// RegexCompileFlagsNewlineAnycrlf: usually any newline character or
	// character sequence is recognized. If this option is set, the only
	// recognized newline character sequences are '\r', '\n', and '\r\n'. Since:
	// 2.34
	RegexCompileFlagsNewlineAnycrlf RegexCompileFlags = 0b10100000000000000000000
	// RegexCompileFlagsBsrAnycrlf: usually any newline character or character
	// sequence is recognised. If this option is set, then "\R" only recognizes
	// the newline characters '\r', '\n' and '\r\n'. Since: 2.34
	RegexCompileFlagsBsrAnycrlf RegexCompileFlags = 0b100000000000000000000000
	// RegexCompileFlagsJavascriptCompat changes behaviour so that it is
	// compatible with JavaScript rather than PCRE. Since: 2.34
	RegexCompileFlagsJavascriptCompat RegexCompileFlags = 0b10000000000000000000000000
)

// RegexMatchFlags flags specifying match-time options.
type RegexMatchFlags int

const (
	// RegexMatchFlagsAnchored: the pattern is forced to be "anchored", that is,
	// it is constrained to match only at the first matching point in the string
	// that is being searched. This effect can also be achieved by appropriate
	// constructs in the pattern itself such as the "^" metacharacter.
	RegexMatchFlagsAnchored RegexMatchFlags = 0b10000
	// RegexMatchFlagsNotbol specifies that first character of the string is not
	// the beginning of a line, so the circumflex metacharacter should not match
	// before it. Setting this without REGEX_MULTILINE (at compile time) causes
	// circumflex never to match. This option affects only the behaviour of the
	// circumflex metacharacter, it does not affect "\A".
	RegexMatchFlagsNotbol RegexMatchFlags = 0b10000000
	// RegexMatchFlagsNoteol specifies that the end of the subject string is not
	// the end of a line, so the dollar metacharacter should not match it nor
	// (except in multiline mode) a newline immediately before it. Setting this
	// without REGEX_MULTILINE (at compile time) causes dollar never to match.
	// This option affects only the behaviour of the dollar metacharacter, it
	// does not affect "\Z" or "\z".
	RegexMatchFlagsNoteol RegexMatchFlags = 0b100000000
	// RegexMatchFlagsNotempty: an empty string is not considered to be a valid
	// match if this option is set. If there are alternatives in the pattern,
	// they are tried. If all the alternatives match the empty string, the
	// entire match fails. For example, if the pattern "a?b?" is applied to a
	// string not beginning with "a" or "b", it matches the empty string at the
	// start of the string. With this flag set, this match is not valid, so
	// GRegex searches further into the string for occurrences of "a" or "b".
	RegexMatchFlagsNotempty RegexMatchFlags = 0b10000000000
	// RegexMatchFlagsPartial turns on the partial matching feature, for more
	// documentation on partial matching see g_match_info_is_partial_match().
	RegexMatchFlagsPartial RegexMatchFlags = 0b1000000000000000
	// RegexMatchFlagsNewlineCr overrides the newline definition set when
	// creating a new #GRegex, setting the '\r' character as line terminator.
	RegexMatchFlagsNewlineCr RegexMatchFlags = 0b100000000000000000000
	// RegexMatchFlagsNewlineLf overrides the newline definition set when
	// creating a new #GRegex, setting the '\n' character as line terminator.
	RegexMatchFlagsNewlineLf RegexMatchFlags = 0b1000000000000000000000
	// RegexMatchFlagsNewlineCrlf overrides the newline definition set when
	// creating a new #GRegex, setting the '\r\n' characters sequence as line
	// terminator.
	RegexMatchFlagsNewlineCrlf RegexMatchFlags = 0b1100000000000000000000
	// RegexMatchFlagsNewlineAny overrides the newline definition set when
	// creating a new #GRegex, any Unicode newline sequence is recognised as a
	// newline. These are '\r', '\n' and '\rn', and the single characters U+000B
	// LINE TABULATION, U+000C FORM FEED (FF), U+0085 NEXT LINE (NEL), U+2028
	// LINE SEPARATOR and U+2029 PARAGRAPH SEPARATOR.
	RegexMatchFlagsNewlineAny RegexMatchFlags = 0b10000000000000000000000
	// RegexMatchFlagsNewlineAnycrlf overrides the newline definition set when
	// creating a new #GRegex; any '\r', '\n', or '\r\n' character sequence is
	// recognized as a newline. Since: 2.34
	RegexMatchFlagsNewlineAnycrlf RegexMatchFlags = 0b10100000000000000000000
	// RegexMatchFlagsBsrAnycrlf overrides the newline definition for "\R" set
	// when creating a new #GRegex; only '\r', '\n', or '\r\n' character
	// sequences are recognized as a newline by "\R". Since: 2.34
	RegexMatchFlagsBsrAnycrlf RegexMatchFlags = 0b100000000000000000000000
	// RegexMatchFlagsBsrAny overrides the newline definition for "\R" set when
	// creating a new #GRegex; any Unicode newline character or character
	// sequence are recognized as a newline by "\R". These are '\r', '\n' and
	// '\rn', and the single characters U+000B LINE TABULATION, U+000C FORM FEED
	// (FF), U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and U+2029 PARAGRAPH
	// SEPARATOR. Since: 2.34
	RegexMatchFlagsBsrAny RegexMatchFlags = 0b1000000000000000000000000
	// RegexMatchFlagsPartialSoft: an alias for REGEX_MATCH_PARTIAL. Since: 2.34
	RegexMatchFlagsPartialSoft RegexMatchFlags = 0b1000000000000000
	// RegexMatchFlagsPartialHard turns on the partial matching feature. In
	// contrast to to REGEX_MATCH_PARTIAL_SOFT, this stops matching as soon as a
	// partial match is found, without continuing to search for a possible
	// complete match. See g_match_info_is_partial_match() for more information.
	// Since: 2.34
	RegexMatchFlagsPartialHard RegexMatchFlags = 0b1000000000000000000000000000
	// RegexMatchFlagsNotemptyAtstart: like REGEX_MATCH_NOTEMPTY, but only
	// applied to the start of the matched string. For anchored patterns this
	// can only happen for pattern containing "\K". Since: 2.34
	RegexMatchFlagsNotemptyAtstart RegexMatchFlags = 0b10000000000000000000000000000
)

// MatchInfo: a GMatchInfo is an opaque struct used to return information about
// matches.
type MatchInfo C.GMatchInfo

// WrapMatchInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMatchInfo(ptr unsafe.Pointer) *MatchInfo {
	return (*MatchInfo)(ptr)
}

func marshalMatchInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*MatchInfo)(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (m *MatchInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(m)
}

// ExpandReferences decreases reference count of @match_info by 1. When
// reference count drops to zero, it frees all the memory associated with the
// match_info structure.
func (m *MatchInfo) ExpandReferences(stringToExpand string) (string, error) {
	var _arg0 *C.GMatchInfo // out
	var _arg1 *C.gchar      // out
	var _cret *C.gchar      // in
	var _cerr *C.GError     // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(stringToExpand))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_match_info_expand_references(_arg0, _arg1, &_cerr)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _utf8, _goerr
}

// Fetch decreases reference count of @match_info by 1. When reference count
// drops to zero, it frees all the memory associated with the match_info
// structure.
func (m *MatchInfo) Fetch(matchNum int) string {
	var _arg0 *C.GMatchInfo // out
	var _arg1 C.gint        // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))
	_arg1 = C.gint(matchNum)

	_cret = C.g_match_info_fetch(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// FetchAll decreases reference count of @match_info by 1. When reference count
// drops to zero, it frees all the memory associated with the match_info
// structure.
func (m *MatchInfo) FetchAll() []string {
	var _arg0 *C.GMatchInfo // out
	var _cret **C.gchar

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))

	_cret = C.g_match_info_fetch_all(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// FetchNamed decreases reference count of @match_info by 1. When reference
// count drops to zero, it frees all the memory associated with the match_info
// structure.
func (m *MatchInfo) FetchNamed(name string) string {
	var _arg0 *C.GMatchInfo // out
	var _arg1 *C.gchar      // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_match_info_fetch_named(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// FetchNamedPos decreases reference count of @match_info by 1. When reference
// count drops to zero, it frees all the memory associated with the match_info
// structure.
func (m *MatchInfo) FetchNamedPos(name string) (startPos int, endPos int, ok bool) {
	var _arg0 *C.GMatchInfo // out
	var _arg1 *C.gchar      // out
	var _arg2 C.gint        // in
	var _arg3 C.gint        // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_match_info_fetch_named_pos(_arg0, _arg1, &_arg2, &_arg3)

	var _startPos int // out
	var _endPos int   // out
	var _ok bool      // out

	_startPos = int(_arg2)
	_endPos = int(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _startPos, _endPos, _ok
}

// FetchPos decreases reference count of @match_info by 1. When reference count
// drops to zero, it frees all the memory associated with the match_info
// structure.
func (m *MatchInfo) FetchPos(matchNum int) (startPos int, endPos int, ok bool) {
	var _arg0 *C.GMatchInfo // out
	var _arg1 C.gint        // out
	var _arg2 C.gint        // in
	var _arg3 C.gint        // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))
	_arg1 = C.gint(matchNum)

	_cret = C.g_match_info_fetch_pos(_arg0, _arg1, &_arg2, &_arg3)

	var _startPos int // out
	var _endPos int   // out
	var _ok bool      // out

	_startPos = int(_arg2)
	_endPos = int(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _startPos, _endPos, _ok
}

// Free decreases reference count of @match_info by 1. When reference count
// drops to zero, it frees all the memory associated with the match_info
// structure.
func (m *MatchInfo) Free() {
	var _arg0 *C.GMatchInfo // out

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))

	C.g_match_info_free(_arg0)
}

// MatchCount decreases reference count of @match_info by 1. When reference
// count drops to zero, it frees all the memory associated with the match_info
// structure.
func (m *MatchInfo) MatchCount() int {
	var _arg0 *C.GMatchInfo // out
	var _cret C.gint        // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))

	_cret = C.g_match_info_get_match_count(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Regex decreases reference count of @match_info by 1. When reference count
// drops to zero, it frees all the memory associated with the match_info
// structure.
func (m *MatchInfo) Regex() *Regex {
	var _arg0 *C.GMatchInfo // out
	var _cret *C.GRegex     // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))

	_cret = C.g_match_info_get_regex(_arg0)

	var _regex *Regex // out

	_regex = (*Regex)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_regex, func(v **Regex) {
		C.free(unsafe.Pointer(v))
	})

	return _regex
}

// String decreases reference count of @match_info by 1. When reference count
// drops to zero, it frees all the memory associated with the match_info
// structure.
func (m *MatchInfo) String() string {
	var _arg0 *C.GMatchInfo // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))

	_cret = C.g_match_info_get_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// IsPartialMatch decreases reference count of @match_info by 1. When reference
// count drops to zero, it frees all the memory associated with the match_info
// structure.
func (m *MatchInfo) IsPartialMatch() bool {
	var _arg0 *C.GMatchInfo // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))

	_cret = C.g_match_info_is_partial_match(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Matches decreases reference count of @match_info by 1. When reference count
// drops to zero, it frees all the memory associated with the match_info
// structure.
func (m *MatchInfo) Matches() bool {
	var _arg0 *C.GMatchInfo // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))

	_cret = C.g_match_info_matches(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Next decreases reference count of @match_info by 1. When reference count
// drops to zero, it frees all the memory associated with the match_info
// structure.
func (m *MatchInfo) Next() error {
	var _arg0 *C.GMatchInfo // out
	var _cerr *C.GError     // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))

	C.g_match_info_next(_arg0, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// Ref decreases reference count of @match_info by 1. When reference count drops
// to zero, it frees all the memory associated with the match_info structure.
func (m *MatchInfo) Ref() *MatchInfo {
	var _arg0 *C.GMatchInfo // out
	var _cret *C.GMatchInfo // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))

	_cret = C.g_match_info_ref(_arg0)

	var _matchInfo *MatchInfo // out

	_matchInfo = (*MatchInfo)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_matchInfo, func(v **MatchInfo) {
		C.free(unsafe.Pointer(v))
	})

	return _matchInfo
}

// Unref decreases reference count of @match_info by 1. When reference count
// drops to zero, it frees all the memory associated with the match_info
// structure.
func (m *MatchInfo) Unref() {
	var _arg0 *C.GMatchInfo // out

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))

	C.g_match_info_unref(_arg0)
}

// Regex: the g_regex_*() functions implement regular expression pattern
// matching using syntax and semantics similar to Perl regular expression.
//
// Some functions accept a @start_position argument, setting it differs from
// just passing over a shortened string and setting REGEX_MATCH_NOTBOL in the
// case of a pattern that begins with any kind of lookbehind assertion. For
// example, consider the pattern "\Biss\B" which finds occurrences of "iss" in
// the middle of words. ("\B" matches only if the current position in the
// subject is not a word boundary.) When applied to the string "Mississipi" from
// the fourth byte, namely "issipi", it does not match, because "\B" is always
// false at the start of the subject, which is deemed to be a word boundary.
// However, if the entire string is passed , but with @start_position set to 4,
// it finds the second occurrence of "iss" because it is able to look behind the
// starting point to discover that it is preceded by a letter.
//
// Note that, unless you set the REGEX_RAW flag, all the strings passed to these
// functions must be encoded in UTF-8. The lengths and the positions inside the
// strings are in bytes and not in characters, so, for instance, "\xc3\xa0"
// (i.e. "à") is two bytes long but it is treated as a single character. If you
// set REGEX_RAW the strings can be non-valid UTF-8 strings and a byte is
// treated as a character, so "\xc3\xa0" is two bytes and two characters long.
//
// When matching a pattern, "\n" matches only against a "\n" character in the
// string, and "\r" matches only a "\r" character. To match any newline sequence
// use "\R". This particular group matches either the two-character sequence CR
// + LF ("\r\n"), or one of the single characters LF (linefeed, U+000A, "\n"),
// VT vertical tab, U+000B, "\v"), FF (formfeed, U+000C, "\f"), CR (carriage
// return, U+000D, "\r"), NEL (next line, U+0085), LS (line separator, U+2028),
// or PS (paragraph separator, U+2029).
//
// The behaviour of the dot, circumflex, and dollar metacharacters are affected
// by newline characters, the default is to recognize any newline character (the
// same characters recognized by "\R"). This can be changed with
// REGEX_NEWLINE_CR, REGEX_NEWLINE_LF and REGEX_NEWLINE_CRLF compile options,
// and with REGEX_MATCH_NEWLINE_ANY, REGEX_MATCH_NEWLINE_CR,
// REGEX_MATCH_NEWLINE_LF and REGEX_MATCH_NEWLINE_CRLF match options. These
// settings are also relevant when compiling a pattern if REGEX_EXTENDED is set,
// and an unescaped "#" outside a character class is encountered. This indicates
// a comment that lasts until after the next newline.
//
// When setting the G_REGEX_JAVASCRIPT_COMPAT flag, pattern syntax and pattern
// matching is changed to be compatible with the way that regular expressions
// work in JavaScript. More precisely, a lonely ']' character in the pattern is
// a syntax error; the '\x' escape only allows 0 to 2 hexadecimal digits, and
// you must use the '\u' escape sequence with 4 hex digits to specify a unicode
// codepoint instead of '\x' or 'x{....}'. If '\x' or '\u' are not followed by
// the specified number of hex digits, they match 'x' and 'u' literally; also
// '\U' always matches 'U' instead of being an error in the pattern. Finally,
// pattern matching is modified so that back references to an unset subpattern
// group produces a match with the empty string instead of an error. See
// pcreapi(3) for more information.
//
// Creating and manipulating the same #GRegex structure from different threads
// is not a problem as #GRegex does not modify its internal state between
// creation and destruction, on the other hand Info is not threadsafe.
//
// The regular expressions low-level functionalities are obtained through the
// excellent PCRE (http://www.pcre.org/) library written by Philip Hazel.
type Regex C.GRegex

// WrapRegex wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRegex(ptr unsafe.Pointer) *Regex {
	return (*Regex)(ptr)
}

func marshalRegex(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*Regex)(unsafe.Pointer(b)), nil
}

// NewRegex constructs a struct Regex.
func NewRegex(pattern string, compileOptions RegexCompileFlags, matchOptions RegexMatchFlags) (*Regex, error) {
	var _arg1 *C.gchar             // out
	var _arg2 C.GRegexCompileFlags // out
	var _arg3 C.GRegexMatchFlags   // out
	var _cret *C.GRegex            // in
	var _cerr *C.GError            // in

	_arg1 = (*C.gchar)(C.CString(pattern))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GRegexCompileFlags(compileOptions)
	_arg3 = C.GRegexMatchFlags(matchOptions)

	_cret = C.g_regex_new(_arg1, _arg2, _arg3, &_cerr)

	var _regex *Regex // out
	var _goerr error  // out

	_regex = (*Regex)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_regex, func(v **Regex) {
		C.free(unsafe.Pointer(v))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _regex, _goerr
}

// Native returns the underlying C source pointer.
func (r *Regex) Native() unsafe.Pointer {
	return unsafe.Pointer(r)
}

// CaptureCount decreases reference count of @regex by 1. When reference count
// drops to zero, it frees all the memory associated with the regex structure.
func (r *Regex) CaptureCount() int {
	var _arg0 *C.GRegex // out
	var _cret C.gint    // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))

	_cret = C.g_regex_get_capture_count(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// CompileFlags decreases reference count of @regex by 1. When reference count
// drops to zero, it frees all the memory associated with the regex structure.
func (r *Regex) CompileFlags() RegexCompileFlags {
	var _arg0 *C.GRegex            // out
	var _cret C.GRegexCompileFlags // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))

	_cret = C.g_regex_get_compile_flags(_arg0)

	var _regexCompileFlags RegexCompileFlags // out

	_regexCompileFlags = RegexCompileFlags(_cret)

	return _regexCompileFlags
}

// HasCrOrLf decreases reference count of @regex by 1. When reference count
// drops to zero, it frees all the memory associated with the regex structure.
func (r *Regex) HasCrOrLf() bool {
	var _arg0 *C.GRegex  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))

	_cret = C.g_regex_get_has_cr_or_lf(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MatchFlags decreases reference count of @regex by 1. When reference count
// drops to zero, it frees all the memory associated with the regex structure.
func (r *Regex) MatchFlags() RegexMatchFlags {
	var _arg0 *C.GRegex          // out
	var _cret C.GRegexMatchFlags // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))

	_cret = C.g_regex_get_match_flags(_arg0)

	var _regexMatchFlags RegexMatchFlags // out

	_regexMatchFlags = RegexMatchFlags(_cret)

	return _regexMatchFlags
}

// MaxBackref decreases reference count of @regex by 1. When reference count
// drops to zero, it frees all the memory associated with the regex structure.
func (r *Regex) MaxBackref() int {
	var _arg0 *C.GRegex // out
	var _cret C.gint    // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))

	_cret = C.g_regex_get_max_backref(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// MaxLookbehind decreases reference count of @regex by 1. When reference count
// drops to zero, it frees all the memory associated with the regex structure.
func (r *Regex) MaxLookbehind() int {
	var _arg0 *C.GRegex // out
	var _cret C.gint    // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))

	_cret = C.g_regex_get_max_lookbehind(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Pattern decreases reference count of @regex by 1. When reference count drops
// to zero, it frees all the memory associated with the regex structure.
func (r *Regex) Pattern() string {
	var _arg0 *C.GRegex // out
	var _cret *C.gchar  // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))

	_cret = C.g_regex_get_pattern(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// StringNumber decreases reference count of @regex by 1. When reference count
// drops to zero, it frees all the memory associated with the regex structure.
func (r *Regex) StringNumber(name string) int {
	var _arg0 *C.GRegex // out
	var _arg1 *C.gchar  // out
	var _cret C.gint    // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_regex_get_string_number(_arg0, _arg1)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Match decreases reference count of @regex by 1. When reference count drops to
// zero, it frees all the memory associated with the regex structure.
func (r *Regex) Match(_string string, matchOptions RegexMatchFlags) (*MatchInfo, bool) {
	var _arg0 *C.GRegex          // out
	var _arg1 *C.gchar           // out
	var _arg2 C.GRegexMatchFlags // out
	var _arg3 *C.GMatchInfo      // in
	var _cret C.gboolean         // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.gchar)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GRegexMatchFlags(matchOptions)

	_cret = C.g_regex_match(_arg0, _arg1, _arg2, &_arg3)

	var _matchInfo *MatchInfo // out
	var _ok bool              // out

	_matchInfo = (*MatchInfo)(unsafe.Pointer(_arg3))
	runtime.SetFinalizer(&_matchInfo, func(v **MatchInfo) {
		C.free(unsafe.Pointer(v))
	})
	if _cret != 0 {
		_ok = true
	}

	return _matchInfo, _ok
}

// MatchAll decreases reference count of @regex by 1. When reference count drops
// to zero, it frees all the memory associated with the regex structure.
func (r *Regex) MatchAll(_string string, matchOptions RegexMatchFlags) (*MatchInfo, bool) {
	var _arg0 *C.GRegex          // out
	var _arg1 *C.gchar           // out
	var _arg2 C.GRegexMatchFlags // out
	var _arg3 *C.GMatchInfo      // in
	var _cret C.gboolean         // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.gchar)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GRegexMatchFlags(matchOptions)

	_cret = C.g_regex_match_all(_arg0, _arg1, _arg2, &_arg3)

	var _matchInfo *MatchInfo // out
	var _ok bool              // out

	_matchInfo = (*MatchInfo)(unsafe.Pointer(_arg3))
	runtime.SetFinalizer(&_matchInfo, func(v **MatchInfo) {
		C.free(unsafe.Pointer(v))
	})
	if _cret != 0 {
		_ok = true
	}

	return _matchInfo, _ok
}

// MatchAllFull decreases reference count of @regex by 1. When reference count
// drops to zero, it frees all the memory associated with the regex structure.
func (r *Regex) MatchAllFull(_string []byte, startPosition int, matchOptions RegexMatchFlags) (*MatchInfo, error) {
	var _arg0 *C.GRegex // out
	var _arg1 *C.gchar
	var _arg2 C.gssize
	var _arg3 C.gint             // out
	var _arg4 C.GRegexMatchFlags // out
	var _arg5 *C.GMatchInfo      // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))
	_arg2 = C.gssize(len(_string))
	_arg1 = (*C.gchar)(unsafe.Pointer(&_string[0]))
	_arg3 = C.gint(startPosition)
	_arg4 = C.GRegexMatchFlags(matchOptions)

	C.g_regex_match_all_full(_arg0, _arg1, _arg2, _arg3, _arg4, &_arg5, &_cerr)

	var _matchInfo *MatchInfo // out
	var _goerr error          // out

	_matchInfo = (*MatchInfo)(unsafe.Pointer(_arg5))
	runtime.SetFinalizer(&_matchInfo, func(v **MatchInfo) {
		C.free(unsafe.Pointer(v))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _matchInfo, _goerr
}

// MatchFull decreases reference count of @regex by 1. When reference count
// drops to zero, it frees all the memory associated with the regex structure.
func (r *Regex) MatchFull(_string []byte, startPosition int, matchOptions RegexMatchFlags) (*MatchInfo, error) {
	var _arg0 *C.GRegex // out
	var _arg1 *C.gchar
	var _arg2 C.gssize
	var _arg3 C.gint             // out
	var _arg4 C.GRegexMatchFlags // out
	var _arg5 *C.GMatchInfo      // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))
	_arg2 = C.gssize(len(_string))
	_arg1 = (*C.gchar)(unsafe.Pointer(&_string[0]))
	_arg3 = C.gint(startPosition)
	_arg4 = C.GRegexMatchFlags(matchOptions)

	C.g_regex_match_full(_arg0, _arg1, _arg2, _arg3, _arg4, &_arg5, &_cerr)

	var _matchInfo *MatchInfo // out
	var _goerr error          // out

	_matchInfo = (*MatchInfo)(unsafe.Pointer(_arg5))
	runtime.SetFinalizer(&_matchInfo, func(v **MatchInfo) {
		C.free(unsafe.Pointer(v))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _matchInfo, _goerr
}

// Ref decreases reference count of @regex by 1. When reference count drops to
// zero, it frees all the memory associated with the regex structure.
func (r *Regex) Ref() *Regex {
	var _arg0 *C.GRegex // out
	var _cret *C.GRegex // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))

	_cret = C.g_regex_ref(_arg0)

	var _ret *Regex // out

	_ret = (*Regex)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_ret, func(v **Regex) {
		C.free(unsafe.Pointer(v))
	})

	return _ret
}

// Replace decreases reference count of @regex by 1. When reference count drops
// to zero, it frees all the memory associated with the regex structure.
func (r *Regex) Replace(_string []byte, startPosition int, replacement string, matchOptions RegexMatchFlags) (string, error) {
	var _arg0 *C.GRegex // out
	var _arg1 *C.gchar
	var _arg2 C.gssize
	var _arg3 C.gint             // out
	var _arg4 *C.gchar           // out
	var _arg5 C.GRegexMatchFlags // out
	var _cret *C.gchar           // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))
	_arg2 = C.gssize(len(_string))
	_arg1 = (*C.gchar)(unsafe.Pointer(&_string[0]))
	_arg3 = C.gint(startPosition)
	_arg4 = (*C.gchar)(C.CString(replacement))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = C.GRegexMatchFlags(matchOptions)

	_cret = C.g_regex_replace(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _utf8, _goerr
}

// ReplaceLiteral decreases reference count of @regex by 1. When reference count
// drops to zero, it frees all the memory associated with the regex structure.
func (r *Regex) ReplaceLiteral(_string []byte, startPosition int, replacement string, matchOptions RegexMatchFlags) (string, error) {
	var _arg0 *C.GRegex // out
	var _arg1 *C.gchar
	var _arg2 C.gssize
	var _arg3 C.gint             // out
	var _arg4 *C.gchar           // out
	var _arg5 C.GRegexMatchFlags // out
	var _cret *C.gchar           // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))
	_arg2 = C.gssize(len(_string))
	_arg1 = (*C.gchar)(unsafe.Pointer(&_string[0]))
	_arg3 = C.gint(startPosition)
	_arg4 = (*C.gchar)(C.CString(replacement))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = C.GRegexMatchFlags(matchOptions)

	_cret = C.g_regex_replace_literal(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _utf8, _goerr
}

// Split decreases reference count of @regex by 1. When reference count drops to
// zero, it frees all the memory associated with the regex structure.
func (r *Regex) Split(_string string, matchOptions RegexMatchFlags) []string {
	var _arg0 *C.GRegex          // out
	var _arg1 *C.gchar           // out
	var _arg2 C.GRegexMatchFlags // out
	var _cret **C.gchar

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.gchar)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GRegexMatchFlags(matchOptions)

	_cret = C.g_regex_split(_arg0, _arg1, _arg2)

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// SplitFull decreases reference count of @regex by 1. When reference count
// drops to zero, it frees all the memory associated with the regex structure.
func (r *Regex) SplitFull(_string []byte, startPosition int, matchOptions RegexMatchFlags, maxTokens int) ([]string, error) {
	var _arg0 *C.GRegex // out
	var _arg1 *C.gchar
	var _arg2 C.gssize
	var _arg3 C.gint             // out
	var _arg4 C.GRegexMatchFlags // out
	var _arg5 C.gint             // out
	var _cret **C.gchar
	var _cerr *C.GError // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))
	_arg2 = C.gssize(len(_string))
	_arg1 = (*C.gchar)(unsafe.Pointer(&_string[0]))
	_arg3 = C.gint(startPosition)
	_arg4 = C.GRegexMatchFlags(matchOptions)
	_arg5 = C.gint(maxTokens)

	_cret = C.g_regex_split_full(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _utf8s []string
	var _goerr error // out

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _utf8s, _goerr
}

// Unref decreases reference count of @regex by 1. When reference count drops to
// zero, it frees all the memory associated with the regex structure.
func (r *Regex) Unref() {
	var _arg0 *C.GRegex // out

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))

	C.g_regex_unref(_arg0)
}
