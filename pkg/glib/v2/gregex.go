// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: glib-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <stdbool.h>
// #include <glib.h>
//
// gboolean gotk4_RegexEvalCallback( GMatchInfo*, GString*, gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_match_info_get_type()), F: marshalMatchInfo},
		{T: externglib.Type(C.g_regex_get_type()), F: marshalRegex},
	})
}

// RegexError: error codes returned by regular expressions functions.
type RegexError int

const (
	// RegexErrorCompile: compilation of the regular expression failed.
	RegexErrorCompile RegexError = 0
	// RegexErrorOptimize: optimization of the regular expression failed.
	RegexErrorOptimize RegexError = 1
	// RegexErrorReplace: replacement failed due to an ill-formed replacement
	// string.
	RegexErrorReplace RegexError = 2
	// RegexErrorMatch: the match process failed.
	RegexErrorMatch RegexError = 3
	// RegexErrorInternal: internal error of the regular expression engine.
	// Since 2.16
	RegexErrorInternal RegexError = 4
	// RegexErrorStrayBackslash: "\\" at end of pattern. Since 2.16
	RegexErrorStrayBackslash RegexError = 101
	// RegexErrorMissingControlChar: "\\c" at end of pattern. Since 2.16
	RegexErrorMissingControlChar RegexError = 102
	// RegexErrorUnrecognizedEscape: unrecognized character follows "\\". Since
	// 2.16
	RegexErrorUnrecognizedEscape RegexError = 103
	// RegexErrorQuantifiersOutOfOrder numbers out of order in "{}" quantifier.
	// Since 2.16
	RegexErrorQuantifiersOutOfOrder RegexError = 104
	// RegexErrorQuantifierTooBig: number too big in "{}" quantifier. Since 2.16
	RegexErrorQuantifierTooBig RegexError = 105
	// RegexErrorUnterminatedCharacterClass: missing terminating "]" for
	// character class. Since 2.16
	RegexErrorUnterminatedCharacterClass RegexError = 106
	// RegexErrorInvalidEscapeInCharacterClass: invalid escape sequence in
	// character class. Since 2.16
	RegexErrorInvalidEscapeInCharacterClass RegexError = 107
	// RegexErrorRangeOutOfOrder: range out of order in character class. Since
	// 2.16
	RegexErrorRangeOutOfOrder RegexError = 108
	// RegexErrorNothingToRepeat: nothing to repeat. Since 2.16
	RegexErrorNothingToRepeat RegexError = 109
	// RegexErrorUnrecognizedCharacter: unrecognized character after "(?", "(?<"
	// or "(?P". Since 2.16
	RegexErrorUnrecognizedCharacter RegexError = 112
	// RegexErrorPosixNamedClassOutsideClass: POSIX named classes are supported
	// only within a class. Since 2.16
	RegexErrorPosixNamedClassOutsideClass RegexError = 113
	// RegexErrorUnmatchedParenthesis: missing terminating ")" or ")" without
	// opening "(". Since 2.16
	RegexErrorUnmatchedParenthesis RegexError = 114
	// RegexErrorInexistentSubpatternReference: reference to non-existent
	// subpattern. Since 2.16
	RegexErrorInexistentSubpatternReference RegexError = 115
	// RegexErrorUnterminatedComment: missing terminating ")" after comment.
	// Since 2.16
	RegexErrorUnterminatedComment RegexError = 118
	// RegexErrorExpressionTooLarge: regular expression too large. Since 2.16
	RegexErrorExpressionTooLarge RegexError = 120
	// RegexErrorMemoryError: failed to get memory. Since 2.16
	RegexErrorMemoryError RegexError = 121
	// RegexErrorVariableLengthLookbehind: lookbehind assertion is not fixed
	// length. Since 2.16
	RegexErrorVariableLengthLookbehind RegexError = 125
	// RegexErrorMalformedCondition: malformed number or name after "(?(". Since
	// 2.16
	RegexErrorMalformedCondition RegexError = 126
	// RegexErrorTooManyConditionalBranches: conditional group contains more
	// than two branches. Since 2.16
	RegexErrorTooManyConditionalBranches RegexError = 127
	// RegexErrorAssertionExpected: assertion expected after "(?(". Since 2.16
	RegexErrorAssertionExpected RegexError = 128
	// RegexErrorUnknownPosixClassName: unknown POSIX class name. Since 2.16
	RegexErrorUnknownPosixClassName RegexError = 130
	// RegexErrorPosixCollatingElementsNotSupported: POSIX collating elements
	// are not supported. Since 2.16
	RegexErrorPosixCollatingElementsNotSupported RegexError = 131
	// RegexErrorHexCodeTooLarge: character value in "\\x{...}" sequence is too
	// large. Since 2.16
	RegexErrorHexCodeTooLarge RegexError = 134
	// RegexErrorInvalidCondition: invalid condition "(?(0)". Since 2.16
	RegexErrorInvalidCondition RegexError = 135
	// RegexErrorSingleByteMatchInLookbehind: \\C not allowed in lookbehind
	// assertion. Since 2.16
	RegexErrorSingleByteMatchInLookbehind RegexError = 136
	// RegexErrorInfiniteLoop: recursive call could loop indefinitely. Since
	// 2.16
	RegexErrorInfiniteLoop RegexError = 140
	// RegexErrorMissingSubpatternNameTerminator: missing terminator in
	// subpattern name. Since 2.16
	RegexErrorMissingSubpatternNameTerminator RegexError = 142
	// RegexErrorDuplicateSubpatternName: two named subpatterns have the same
	// name. Since 2.16
	RegexErrorDuplicateSubpatternName RegexError = 143
	// RegexErrorMalformedProperty: malformed "\\P" or "\\p" sequence. Since
	// 2.16
	RegexErrorMalformedProperty RegexError = 146
	// RegexErrorUnknownProperty: unknown property name after "\\P" or "\\p".
	// Since 2.16
	RegexErrorUnknownProperty RegexError = 147
	// RegexErrorSubpatternNameTooLong: subpattern name is too long (maximum 32
	// characters). Since 2.16
	RegexErrorSubpatternNameTooLong RegexError = 148
	// RegexErrorTooManySubpatterns: too many named subpatterns (maximum
	// 10,000). Since 2.16
	RegexErrorTooManySubpatterns RegexError = 149
	// RegexErrorInvalidOctalValue: octal value is greater than "\\377". Since
	// 2.16
	RegexErrorInvalidOctalValue RegexError = 151
	// RegexErrorTooManyBranchesInDefine: "DEFINE" group contains more than one
	// branch. Since 2.16
	RegexErrorTooManyBranchesInDefine RegexError = 154
	// RegexErrorDefineRepetion: repeating a "DEFINE" group is not allowed. This
	// error is never raised. Since: 2.16 Deprecated: 2.34
	RegexErrorDefineRepetion RegexError = 155
	// RegexErrorInconsistentNewlineOptions: inconsistent newline options. Since
	// 2.16
	RegexErrorInconsistentNewlineOptions RegexError = 156
	// RegexErrorMissingBackReference: "\\g" is not followed by a braced,
	// angle-bracketed, or quoted name or number, or by a plain number. Since:
	// 2.16
	RegexErrorMissingBackReference RegexError = 157
	// RegexErrorInvalidRelativeReference: relative reference must not be zero.
	// Since: 2.34
	RegexErrorInvalidRelativeReference RegexError = 158
	// RegexErrorBacktrackingControlVerbArgumentForbidden: the backtracing
	// control verb used does not allow an argument. Since: 2.34
	RegexErrorBacktrackingControlVerbArgumentForbidden RegexError = 159
	// RegexErrorUnknownBacktrackingControlVerb: unknown backtracing control
	// verb. Since: 2.34
	RegexErrorUnknownBacktrackingControlVerb RegexError = 160
	// RegexErrorNumberTooBig: number is too big in escape sequence. Since: 2.34
	RegexErrorNumberTooBig RegexError = 161
	// RegexErrorMissingSubpatternName: missing subpattern name. Since: 2.34
	RegexErrorMissingSubpatternName RegexError = 162
	// RegexErrorMissingDigit: missing digit. Since 2.34
	RegexErrorMissingDigit RegexError = 163
	// RegexErrorInvalidDataCharacter: in JavaScript compatibility mode, "[" is
	// an invalid data character. Since: 2.34
	RegexErrorInvalidDataCharacter RegexError = 164
	// RegexErrorExtraSubpatternName: different names for subpatterns of the
	// same number are not allowed. Since: 2.34
	RegexErrorExtraSubpatternName RegexError = 165
	// RegexErrorBacktrackingControlVerbArgumentRequired: the backtracing
	// control verb requires an argument. Since: 2.34
	RegexErrorBacktrackingControlVerbArgumentRequired RegexError = 166
	// RegexErrorInvalidControlChar: "\\c" must be followed by an ASCII
	// character. Since: 2.34
	RegexErrorInvalidControlChar RegexError = 168
	// RegexErrorMissingName: "\\k" is not followed by a braced,
	// angle-bracketed, or quoted name. Since: 2.34
	RegexErrorMissingName RegexError = 169
	// RegexErrorNotSupportedInClass: "\\N" is not supported in a class. Since:
	// 2.34
	RegexErrorNotSupportedInClass RegexError = 171
	// RegexErrorTooManyForwardReferences: too many forward references. Since:
	// 2.34
	RegexErrorTooManyForwardReferences RegexError = 172
	// RegexErrorNameTooLong: the name is too long in "(*MARK)", "(*PRUNE)",
	// "(*SKIP)", or "(*THEN)". Since: 2.34
	RegexErrorNameTooLong RegexError = 175
	// RegexErrorCharacterValueTooLarge: the character value in the \\u sequence
	// is too large. Since: 2.34
	RegexErrorCharacterValueTooLarge RegexError = 176
)

// RegexCompileFlags flags specifying compile-time options.
type RegexCompileFlags int

const (
	// RegexCompileFlagsCaseless letters in the pattern match both upper- and
	// lowercase letters. This option can be changed within a pattern by a
	// "(?i)" option setting.
	RegexCompileFlagsCaseless RegexCompileFlags = 0b1
	// RegexCompileFlagsMultiline: by default, GRegex treats the strings as
	// consisting of a single line of characters (even if it actually contains
	// newlines). The "start of line" metacharacter ("^") matches only at the
	// start of the string, while the "end of line" metacharacter ("$") matches
	// only at the end of the string, or before a terminating newline (unless
	// REGEX_DOLLAR_ENDONLY is set). When REGEX_MULTILINE is set, the "start of
	// line" and "end of line" constructs match immediately following or
	// immediately before any newline in the string, respectively, as well as at
	// the very start and end. This can be changed within a pattern by a "(?m)"
	// option setting.
	RegexCompileFlagsMultiline RegexCompileFlags = 0b10
	// RegexCompileFlagsDotall: a dot metacharacter (".") in the pattern matches
	// all characters, including newlines. Without it, newlines are excluded.
	// This option can be changed within a pattern by a ("?s") option setting.
	RegexCompileFlagsDotall RegexCompileFlags = 0b100
	// RegexCompileFlagsExtended: whitespace data characters in the pattern are
	// totally ignored except when escaped or inside a character class.
	// Whitespace does not include the VT character (code 11). In addition,
	// characters between an unescaped "#" outside a character class and the
	// next newline character, inclusive, are also ignored. This can be changed
	// within a pattern by a "(?x)" option setting.
	RegexCompileFlagsExtended RegexCompileFlags = 0b1000
	// RegexCompileFlagsAnchored: the pattern is forced to be "anchored", that
	// is, it is constrained to match only at the first matching point in the
	// string that is being searched. This effect can also be achieved by
	// appropriate constructs in the pattern itself such as the "^"
	// metacharacter.
	RegexCompileFlagsAnchored RegexCompileFlags = 0b10000
	// RegexCompileFlagsDollarEndonly: a dollar metacharacter ("$") in the
	// pattern matches only at the end of the string. Without this option, a
	// dollar also matches immediately before the final character if it is a
	// newline (but not before any other newlines). This option is ignored if
	// REGEX_MULTILINE is set.
	RegexCompileFlagsDollarEndonly RegexCompileFlags = 0b100000
	// RegexCompileFlagsUngreedy inverts the "greediness" of the quantifiers so
	// that they are not greedy by default, but become greedy if followed by
	// "?". It can also be set by a "(?U)" option setting within the pattern.
	RegexCompileFlagsUngreedy RegexCompileFlags = 0b1000000000
	// RegexCompileFlagsRaw: usually strings must be valid UTF-8 strings, using
	// this flag they are considered as a raw sequence of bytes.
	RegexCompileFlagsRaw RegexCompileFlags = 0b100000000000
	// RegexCompileFlagsNoAutoCapture disables the use of numbered capturing
	// parentheses in the pattern. Any opening parenthesis that is not followed
	// by "?" behaves as if it were followed by "?:" but named parentheses can
	// still be used for capturing (and they acquire numbers in the usual way).
	RegexCompileFlagsNoAutoCapture RegexCompileFlags = 0b1000000000000
	// RegexCompileFlagsOptimize: optimize the regular expression. If the
	// pattern will be used many times, then it may be worth the effort to
	// optimize it to improve the speed of matches.
	RegexCompileFlagsOptimize RegexCompileFlags = 0b10000000000000
	// RegexCompileFlagsFirstline limits an unanchored pattern to match before
	// (or at) the first newline. Since: 2.34
	RegexCompileFlagsFirstline RegexCompileFlags = 0b1000000000000000000
	// RegexCompileFlagsDupnames names used to identify capturing subpatterns
	// need not be unique. This can be helpful for certain types of pattern when
	// it is known that only one instance of the named subpattern can ever be
	// matched.
	RegexCompileFlagsDupnames RegexCompileFlags = 0b10000000000000000000
	// RegexCompileFlagsNewlineCr: usually any newline character or character
	// sequence is recognized. If this option is set, the only recognized
	// newline character is '\r'.
	RegexCompileFlagsNewlineCr RegexCompileFlags = 0b100000000000000000000
	// RegexCompileFlagsNewlineLf: usually any newline character or character
	// sequence is recognized. If this option is set, the only recognized
	// newline character is '\n'.
	RegexCompileFlagsNewlineLf RegexCompileFlags = 0b1000000000000000000000
	// RegexCompileFlagsNewlineCrlf: usually any newline character or character
	// sequence is recognized. If this option is set, the only recognized
	// newline character sequence is '\r\n'.
	RegexCompileFlagsNewlineCrlf RegexCompileFlags = 0b1100000000000000000000
	// RegexCompileFlagsNewlineAnycrlf: usually any newline character or
	// character sequence is recognized. If this option is set, the only
	// recognized newline character sequences are '\r', '\n', and '\r\n'. Since:
	// 2.34
	RegexCompileFlagsNewlineAnycrlf RegexCompileFlags = 0b10100000000000000000000
	// RegexCompileFlagsBsrAnycrlf: usually any newline character or character
	// sequence is recognised. If this option is set, then "\R" only recognizes
	// the newline characters '\r', '\n' and '\r\n'. Since: 2.34
	RegexCompileFlagsBsrAnycrlf RegexCompileFlags = 0b100000000000000000000000
	// RegexCompileFlagsJavascriptCompat changes behaviour so that it is
	// compatible with JavaScript rather than PCRE. Since: 2.34
	RegexCompileFlagsJavascriptCompat RegexCompileFlags = 0b10000000000000000000000000
)

// RegexMatchFlags flags specifying match-time options.
type RegexMatchFlags int

const (
	// RegexMatchFlagsAnchored: the pattern is forced to be "anchored", that is,
	// it is constrained to match only at the first matching point in the string
	// that is being searched. This effect can also be achieved by appropriate
	// constructs in the pattern itself such as the "^" metacharacter.
	RegexMatchFlagsAnchored RegexMatchFlags = 0b10000
	// RegexMatchFlagsNotbol specifies that first character of the string is not
	// the beginning of a line, so the circumflex metacharacter should not match
	// before it. Setting this without REGEX_MULTILINE (at compile time) causes
	// circumflex never to match. This option affects only the behaviour of the
	// circumflex metacharacter, it does not affect "\A".
	RegexMatchFlagsNotbol RegexMatchFlags = 0b10000000
	// RegexMatchFlagsNoteol specifies that the end of the subject string is not
	// the end of a line, so the dollar metacharacter should not match it nor
	// (except in multiline mode) a newline immediately before it. Setting this
	// without REGEX_MULTILINE (at compile time) causes dollar never to match.
	// This option affects only the behaviour of the dollar metacharacter, it
	// does not affect "\Z" or "\z".
	RegexMatchFlagsNoteol RegexMatchFlags = 0b100000000
	// RegexMatchFlagsNotempty: an empty string is not considered to be a valid
	// match if this option is set. If there are alternatives in the pattern,
	// they are tried. If all the alternatives match the empty string, the
	// entire match fails. For example, if the pattern "a?b?" is applied to a
	// string not beginning with "a" or "b", it matches the empty string at the
	// start of the string. With this flag set, this match is not valid, so
	// GRegex searches further into the string for occurrences of "a" or "b".
	RegexMatchFlagsNotempty RegexMatchFlags = 0b10000000000
	// RegexMatchFlagsPartial turns on the partial matching feature, for more
	// documentation on partial matching see g_match_info_is_partial_match().
	RegexMatchFlagsPartial RegexMatchFlags = 0b1000000000000000
	// RegexMatchFlagsNewlineCr overrides the newline definition set when
	// creating a new #GRegex, setting the '\r' character as line terminator.
	RegexMatchFlagsNewlineCr RegexMatchFlags = 0b100000000000000000000
	// RegexMatchFlagsNewlineLf overrides the newline definition set when
	// creating a new #GRegex, setting the '\n' character as line terminator.
	RegexMatchFlagsNewlineLf RegexMatchFlags = 0b1000000000000000000000
	// RegexMatchFlagsNewlineCrlf overrides the newline definition set when
	// creating a new #GRegex, setting the '\r\n' characters sequence as line
	// terminator.
	RegexMatchFlagsNewlineCrlf RegexMatchFlags = 0b1100000000000000000000
	// RegexMatchFlagsNewlineAny overrides the newline definition set when
	// creating a new #GRegex, any Unicode newline sequence is recognised as a
	// newline. These are '\r', '\n' and '\rn', and the single characters U+000B
	// LINE TABULATION, U+000C FORM FEED (FF), U+0085 NEXT LINE (NEL), U+2028
	// LINE SEPARATOR and U+2029 PARAGRAPH SEPARATOR.
	RegexMatchFlagsNewlineAny RegexMatchFlags = 0b10000000000000000000000
	// RegexMatchFlagsNewlineAnycrlf overrides the newline definition set when
	// creating a new #GRegex; any '\r', '\n', or '\r\n' character sequence is
	// recognized as a newline. Since: 2.34
	RegexMatchFlagsNewlineAnycrlf RegexMatchFlags = 0b10100000000000000000000
	// RegexMatchFlagsBsrAnycrlf overrides the newline definition for "\R" set
	// when creating a new #GRegex; only '\r', '\n', or '\r\n' character
	// sequences are recognized as a newline by "\R". Since: 2.34
	RegexMatchFlagsBsrAnycrlf RegexMatchFlags = 0b100000000000000000000000
	// RegexMatchFlagsBsrAny overrides the newline definition for "\R" set when
	// creating a new #GRegex; any Unicode newline character or character
	// sequence are recognized as a newline by "\R". These are '\r', '\n' and
	// '\rn', and the single characters U+000B LINE TABULATION, U+000C FORM FEED
	// (FF), U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and U+2029 PARAGRAPH
	// SEPARATOR. Since: 2.34
	RegexMatchFlagsBsrAny RegexMatchFlags = 0b1000000000000000000000000
	// RegexMatchFlagsPartialSoft: an alias for REGEX_MATCH_PARTIAL. Since: 2.34
	RegexMatchFlagsPartialSoft RegexMatchFlags = 0b1000000000000000
	// RegexMatchFlagsPartialHard turns on the partial matching feature. In
	// contrast to to REGEX_MATCH_PARTIAL_SOFT, this stops matching as soon as a
	// partial match is found, without continuing to search for a possible
	// complete match. See g_match_info_is_partial_match() for more information.
	// Since: 2.34
	RegexMatchFlagsPartialHard RegexMatchFlags = 0b1000000000000000000000000000
	// RegexMatchFlagsNotemptyAtstart: like REGEX_MATCH_NOTEMPTY, but only
	// applied to the start of the matched string. For anchored patterns this
	// can only happen for pattern containing "\K". Since: 2.34
	RegexMatchFlagsNotemptyAtstart RegexMatchFlags = 0b10000000000000000000000000000
)

// RegexEvalCallback specifies the type of the function passed to
// g_regex_replace_eval(). It is called for each occurrence of the pattern in
// the string passed to g_regex_replace_eval(), and it should append the
// replacement to @result.
type RegexEvalCallback func(matchInfo *MatchInfo, result *String) bool

//export gotk4_RegexEvalCallback
func gotk4_RegexEvalCallback(arg0 *C.GMatchInfo, arg1 *C.GString, arg2 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var matchInfo *MatchInfo
	var result *String

	{
		matchInfo = WrapMatchInfo(unsafe.Pointer(arg0))
	}

	{
		result = WrapString(unsafe.Pointer(arg1))
	}

	ok := v.(RegexEvalCallback)(matchInfo, result)
}

// RegexCheckReplacement checks whether @replacement is a valid replacement
// string (see g_regex_replace()), i.e. that all escape sequences in it are
// valid.
//
// If @has_references is not nil then @replacement is checked for pattern
// references. For instance, replacement text 'foo\n' does not contain
// references and may be evaluated without information about actual match, but
// '\0\1' (whole match followed by first subpattern) requires valid Info object.
func RegexCheckReplacement(replacement string) (hasReferences bool, err error) {
	var arg1 *C.gchar
	var arg2 *C.gboolean // out
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(replacement))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_regex_check_replacement(arg1, &arg2, &gError)

	var ret0 bool
	var goError error

	ret0 = C.bool(arg2) != C.false

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// RegexEscapeNUL escapes the nul characters in @string to "\x00". It can be
// used to compile a regex with embedded nul characters.
//
// For completeness, @length can be -1 for a nul-terminated string. In this case
// the output string will be of course equal to @string.
func RegexEscapeNUL(string string, length int) string {
	var arg1 *C.gchar
	var arg2 C.gint

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(length)

	ret := C.g_regex_escape_nul(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// RegexEscapeString escapes the special characters used for regular expressions
// in @string, for instance "a.b*c" becomes "a\.b\*c". This function is useful
// to dynamically generate regular expressions.
//
// @string can contain nul characters that are replaced with "\0", in this case
// remember to specify the correct length of @string in @length.
func RegexEscapeString(string []string) string {
	var arg1 *C.gchar
	var arg2 C.gint

	{
		var dst []C.gchar
		ptr := C.malloc(C.sizeof_gchar * len(string))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(string)
		sliceHeader.Cap = len(string)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(string); i++ {
			src := string[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg1 = (*C.gchar)(unsafe.Pointer(ptr))
		arg2 = len(string)
	}

	ret := C.g_regex_escape_string(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// RegexMatchSimple scans for a match in @string for @pattern.
//
// This function is equivalent to g_regex_match() but it does not require to
// compile the pattern with g_regex_new(), avoiding some lines of code when you
// need just to do a match without extracting substrings, capture counts, and so
// on.
//
// If this function is to be called on the same @pattern more than once, it's
// more efficient to compile the pattern once with g_regex_new() and then use
// g_regex_match().
func RegexMatchSimple(pattern string, string string, compileOptions RegexCompileFlags, matchOptions RegexMatchFlags) bool {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 C.GRegexCompileFlags
	var arg4 C.GRegexMatchFlags

	arg1 = (*C.gchar)(C.CString(pattern))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (C.GRegexCompileFlags)(compileOptions)
	arg4 = (C.GRegexMatchFlags)(matchOptions)

	ret := C.g_regex_match_simple(arg1, arg2, arg3, arg4)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// RegexSplitSimple breaks the string on the pattern, and returns an array of
// the tokens. If the pattern contains capturing parentheses, then the text for
// each of the substrings will also be returned. If the pattern does not match
// anywhere in the string, then the whole string is returned as the first token.
//
// This function is equivalent to g_regex_split() but it does not require to
// compile the pattern with g_regex_new(), avoiding some lines of code when you
// need just to do a split without extracting substrings, capture counts, and so
// on.
//
// If this function is to be called on the same @pattern more than once, it's
// more efficient to compile the pattern once with g_regex_new() and then use
// g_regex_split().
//
// As a special case, the result of splitting the empty string "" is an empty
// vector, not a vector containing a single string. The reason for this special
// case is that being able to represent an empty vector is typically more useful
// than consistent handling of empty elements. If you do need to represent empty
// elements, you'll need to check for the empty string before calling this
// function.
//
// A pattern that can match empty strings splits @string into separate
// characters wherever it matches the empty string between characters. For
// example splitting "ab c" using as a separator "\s*", you will get "a", "b"
// and "c".
func RegexSplitSimple(pattern string, string string, compileOptions RegexCompileFlags, matchOptions RegexMatchFlags) []string {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 C.GRegexCompileFlags
	var arg4 C.GRegexMatchFlags

	arg1 = (*C.gchar)(C.CString(pattern))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (C.GRegexCompileFlags)(compileOptions)
	arg4 = (C.GRegexMatchFlags)(matchOptions)

	ret := C.g_regex_split_simple(arg1, arg2, arg3, arg4)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// MatchInfo: a GMatchInfo is an opaque struct used to return information about
// matches.
type MatchInfo struct {
	native C.GMatchInfo
}

// WrapMatchInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMatchInfo(ptr unsafe.Pointer) *MatchInfo {
	if ptr == nil {
		return nil
	}

	return (*MatchInfo)(ptr)
}

func marshalMatchInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapMatchInfo(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (m *MatchInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&m.native)
}

// ExpandReferences returns a new string containing the text in
// @string_to_expand with references and escape sequences expanded. References
// refer to the last match done with @string against @regex and have the same
// syntax used by g_regex_replace().
//
// The @string_to_expand must be UTF-8 encoded even if REGEX_RAW was passed to
// g_regex_new().
//
// The backreferences are extracted from the string passed to the match
// function, so you cannot call this function after freeing the string.
//
// @match_info may be nil in which case @string_to_expand must not contain
// references. For instance "foo\n" does not refer to an actual pattern and '\n'
// merely will be replaced with \n character, while to expand "\0" (whole match)
// one needs the result of a match. Use g_regex_check_replacement() to find out
// whether @string_to_expand contains references.
func (m *MatchInfo) ExpandReferences(stringToExpand string) (utf8 string, err error) {
	var arg0 *C.GMatchInfo
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GMatchInfo)(m.Native())
	arg1 = (*C.gchar)(C.CString(stringToExpand))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_match_info_expand_references(arg0, arg1, &gError)

	var ret0 string
	var goError error

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Fetch retrieves the text matching the @match_num'th capturing parentheses. 0
// is the full text of the match, 1 is the first paren set, 2 the second, and so
// on.
//
// If @match_num is a valid sub pattern but it didn't match anything (e.g. sub
// pattern 1, matching "b" against "(a)?b") then an empty string is returned.
//
// If the match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved string is not
// that of a set of parentheses but that of a matched substring. Substrings are
// matched in reverse order of length, so 0 is the longest match.
//
// The string is fetched from the string passed to the match function, so you
// cannot call this function after freeing the string.
func (m *MatchInfo) Fetch(matchNum int) string {
	var arg0 *C.GMatchInfo
	var arg1 C.gint

	arg0 = (*C.GMatchInfo)(m.Native())
	arg1 = C.gint(matchNum)

	ret := C.g_match_info_fetch(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// FetchAll bundles up pointers to each of the matching substrings from a match
// and stores them in an array of gchar pointers. The first element in the
// returned array is the match number 0, i.e. the entire matched text.
//
// If a sub pattern didn't match anything (e.g. sub pattern 1, matching "b"
// against "(a)?b") then an empty string is inserted.
//
// If the last match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved strings are
// not that matched by sets of parentheses but that of the matched substring.
// Substrings are matched in reverse order of length, so the first one is the
// longest match.
//
// The strings are fetched from the string passed to the match function, so you
// cannot call this function after freeing the string.
func (m *MatchInfo) FetchAll() []string {
	var arg0 *C.GMatchInfo

	arg0 = (*C.GMatchInfo)(m.Native())

	ret := C.g_match_info_fetch_all(arg0)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// FetchNamed retrieves the text matching the capturing parentheses named @name.
//
// If @name is a valid sub pattern name but it didn't match anything (e.g. sub
// pattern "X", matching "b" against "(?P<X>a)?b") then an empty string is
// returned.
//
// The string is fetched from the string passed to the match function, so you
// cannot call this function after freeing the string.
func (m *MatchInfo) FetchNamed(name string) string {
	var arg0 *C.GMatchInfo
	var arg1 *C.gchar

	arg0 = (*C.GMatchInfo)(m.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_match_info_fetch_named(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// FetchNamedPos retrieves the position in bytes of the capturing parentheses
// named @name.
//
// If @name is a valid sub pattern name but it didn't match anything (e.g. sub
// pattern "X", matching "b" against "(?P<X>a)?b") then @start_pos and @end_pos
// are set to -1 and true is returned.
func (m *MatchInfo) FetchNamedPos(name string) (startPos int, endPos int, ok bool) {
	var arg0 *C.GMatchInfo
	var arg1 *C.gchar
	var arg2 *C.gint // out
	var arg3 *C.gint // out

	arg0 = (*C.GMatchInfo)(m.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_match_info_fetch_named_pos(arg0, arg1, &arg2, &arg3)

	var ret0 int
	var ret1 int
	var ret2 bool

	ret0 = int(arg2)

	ret1 = int(arg3)

	ret2 = C.bool(ret) != C.false

	return ret0, ret1, ret2
}

// FetchPos retrieves the position in bytes of the @match_num'th capturing
// parentheses. 0 is the full text of the match, 1 is the first paren set, 2 the
// second, and so on.
//
// If @match_num is a valid sub pattern but it didn't match anything (e.g. sub
// pattern 1, matching "b" against "(a)?b") then @start_pos and @end_pos are set
// to -1 and true is returned.
//
// If the match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved position is
// not that of a set of parentheses but that of a matched substring. Substrings
// are matched in reverse order of length, so 0 is the longest match.
func (m *MatchInfo) FetchPos(matchNum int) (startPos int, endPos int, ok bool) {
	var arg0 *C.GMatchInfo
	var arg1 C.gint
	var arg2 *C.gint // out
	var arg3 *C.gint // out

	arg0 = (*C.GMatchInfo)(m.Native())
	arg1 = C.gint(matchNum)

	ret := C.g_match_info_fetch_pos(arg0, arg1, &arg2, &arg3)

	var ret0 int
	var ret1 int
	var ret2 bool

	ret0 = int(arg2)

	ret1 = int(arg3)

	ret2 = C.bool(ret) != C.false

	return ret0, ret1, ret2
}

// Free: if @match_info is not nil, calls g_match_info_unref(); otherwise does
// nothing.
func (m *MatchInfo) Free() {
	var arg0 *C.GMatchInfo

	arg0 = (*C.GMatchInfo)(m.Native())

	C.g_match_info_free(arg0)
}

// MatchCount retrieves the number of matched substrings (including substring 0,
// that is the whole matched text), so 1 is returned if the pattern has no
// substrings in it and 0 is returned if the match failed.
//
// If the last match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved count is not
// that of the number of capturing parentheses but that of the number of matched
// substrings.
func (m *MatchInfo) MatchCount() int {
	var arg0 *C.GMatchInfo

	arg0 = (*C.GMatchInfo)(m.Native())

	ret := C.g_match_info_get_match_count(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Regex returns #GRegex object used in @match_info. It belongs to Glib and must
// not be freed. Use g_regex_ref() if you need to keep it after you free
// @match_info object.
func (m *MatchInfo) Regex() *Regex {
	var arg0 *C.GMatchInfo

	arg0 = (*C.GMatchInfo)(m.Native())

	ret := C.g_match_info_get_regex(arg0)

	var ret0 *Regex

	{
		ret0 = WrapRegex(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Regex) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// String returns the string searched with @match_info. This is the string
// passed to g_regex_match() or g_regex_replace() so you may not free it before
// calling this function.
func (m *MatchInfo) String() string {
	var arg0 *C.GMatchInfo

	arg0 = (*C.GMatchInfo)(m.Native())

	ret := C.g_match_info_get_string(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// IsPartialMatch: usually if the string passed to g_regex_match*() matches as
// far as it goes, but is too short to match the entire pattern, false is
// returned. There are circumstances where it might be helpful to distinguish
// this case from other cases in which there is no match.
//
// Consider, for example, an application where a human is required to type in
// data for a field with specific formatting requirements. An example might be a
// date in the form ddmmmyy, defined by the pattern
// "^\d?\d(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\d\d$". If the
// application sees the user’s keystrokes one by one, and can check that what
// has been typed so far is potentially valid, it is able to raise an error as
// soon as a mistake is made.
//
// GRegex supports the concept of partial matching by means of the
// REGEX_MATCH_PARTIAL_SOFT and REGEX_MATCH_PARTIAL_HARD flags. When they are
// used, the return code for g_regex_match() or g_regex_match_full() is, as
// usual, true for a complete match, false otherwise. But, when these functions
// return false, you can check if the match was partial calling
// g_match_info_is_partial_match().
//
// The difference between REGEX_MATCH_PARTIAL_SOFT and REGEX_MATCH_PARTIAL_HARD
// is that when a partial match is encountered with REGEX_MATCH_PARTIAL_SOFT,
// matching continues to search for a possible complete match, while with
// REGEX_MATCH_PARTIAL_HARD matching stops at the partial match. When both
// REGEX_MATCH_PARTIAL_SOFT and REGEX_MATCH_PARTIAL_HARD are set, the latter
// takes precedence.
//
// There were formerly some restrictions on the pattern for partial matching.
// The restrictions no longer apply.
//
// See pcrepartial(3) for more information on partial matching.
func (m *MatchInfo) IsPartialMatch() bool {
	var arg0 *C.GMatchInfo

	arg0 = (*C.GMatchInfo)(m.Native())

	ret := C.g_match_info_is_partial_match(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// Matches returns whether the previous match operation succeeded.
func (m *MatchInfo) Matches() bool {
	var arg0 *C.GMatchInfo

	arg0 = (*C.GMatchInfo)(m.Native())

	ret := C.g_match_info_matches(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// Next scans for the next match using the same parameters of the previous call
// to g_regex_match_full() or g_regex_match() that returned @match_info.
//
// The match is done on the string passed to the match function, so you cannot
// free it before calling this function.
func (m *MatchInfo) Next() error {
	var arg0 *C.GMatchInfo
	var gError *C.GError

	arg0 = (*C.GMatchInfo)(m.Native())

	ret := C.g_match_info_next(arg0, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// Ref increases reference count of @match_info by 1.
func (m *MatchInfo) Ref() *MatchInfo {
	var arg0 *C.GMatchInfo

	arg0 = (*C.GMatchInfo)(m.Native())

	ret := C.g_match_info_ref(arg0)

	var ret0 *MatchInfo

	{
		ret0 = WrapMatchInfo(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *MatchInfo) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Unref decreases reference count of @match_info by 1. When reference count
// drops to zero, it frees all the memory associated with the match_info
// structure.
func (m *MatchInfo) Unref() {
	var arg0 *C.GMatchInfo

	arg0 = (*C.GMatchInfo)(m.Native())

	C.g_match_info_unref(arg0)
}

// Regex: the g_regex_*() functions implement regular expression pattern
// matching using syntax and semantics similar to Perl regular expression.
//
// Some functions accept a @start_position argument, setting it differs from
// just passing over a shortened string and setting REGEX_MATCH_NOTBOL in the
// case of a pattern that begins with any kind of lookbehind assertion. For
// example, consider the pattern "\Biss\B" which finds occurrences of "iss" in
// the middle of words. ("\B" matches only if the current position in the
// subject is not a word boundary.) When applied to the string "Mississipi" from
// the fourth byte, namely "issipi", it does not match, because "\B" is always
// false at the start of the subject, which is deemed to be a word boundary.
// However, if the entire string is passed , but with @start_position set to 4,
// it finds the second occurrence of "iss" because it is able to look behind the
// starting point to discover that it is preceded by a letter.
//
// Note that, unless you set the REGEX_RAW flag, all the strings passed to these
// functions must be encoded in UTF-8. The lengths and the positions inside the
// strings are in bytes and not in characters, so, for instance, "\xc3\xa0"
// (i.e. "à") is two bytes long but it is treated as a single character. If you
// set REGEX_RAW the strings can be non-valid UTF-8 strings and a byte is
// treated as a character, so "\xc3\xa0" is two bytes and two characters long.
//
// When matching a pattern, "\n" matches only against a "\n" character in the
// string, and "\r" matches only a "\r" character. To match any newline sequence
// use "\R". This particular group matches either the two-character sequence CR
// + LF ("\r\n"), or one of the single characters LF (linefeed, U+000A, "\n"),
// VT vertical tab, U+000B, "\v"), FF (formfeed, U+000C, "\f"), CR (carriage
// return, U+000D, "\r"), NEL (next line, U+0085), LS (line separator, U+2028),
// or PS (paragraph separator, U+2029).
//
// The behaviour of the dot, circumflex, and dollar metacharacters are affected
// by newline characters, the default is to recognize any newline character (the
// same characters recognized by "\R"). This can be changed with
// REGEX_NEWLINE_CR, REGEX_NEWLINE_LF and REGEX_NEWLINE_CRLF compile options,
// and with REGEX_MATCH_NEWLINE_ANY, REGEX_MATCH_NEWLINE_CR,
// REGEX_MATCH_NEWLINE_LF and REGEX_MATCH_NEWLINE_CRLF match options. These
// settings are also relevant when compiling a pattern if REGEX_EXTENDED is set,
// and an unescaped "#" outside a character class is encountered. This indicates
// a comment that lasts until after the next newline.
//
// When setting the G_REGEX_JAVASCRIPT_COMPAT flag, pattern syntax and pattern
// matching is changed to be compatible with the way that regular expressions
// work in JavaScript. More precisely, a lonely ']' character in the pattern is
// a syntax error; the '\x' escape only allows 0 to 2 hexadecimal digits, and
// you must use the '\u' escape sequence with 4 hex digits to specify a unicode
// codepoint instead of '\x' or 'x{....}'. If '\x' or '\u' are not followed by
// the specified number of hex digits, they match 'x' and 'u' literally; also
// '\U' always matches 'U' instead of being an error in the pattern. Finally,
// pattern matching is modified so that back references to an unset subpattern
// group produces a match with the empty string instead of an error. See
// pcreapi(3) for more information.
//
// Creating and manipulating the same #GRegex structure from different threads
// is not a problem as #GRegex does not modify its internal state between
// creation and destruction, on the other hand Info is not threadsafe.
//
// The regular expressions low-level functionalities are obtained through the
// excellent PCRE (http://www.pcre.org/) library written by Philip Hazel.
type Regex struct {
	native C.GRegex
}

// WrapRegex wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRegex(ptr unsafe.Pointer) *Regex {
	if ptr == nil {
		return nil
	}

	return (*Regex)(ptr)
}

func marshalRegex(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRegex(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *Regex) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// NewRegex constructs a struct Regex.
func NewRegex(pattern string, compileOptions RegexCompileFlags, matchOptions RegexMatchFlags) (regex *Regex, err error) {
	var arg1 *C.gchar
	var arg2 C.GRegexCompileFlags
	var arg3 C.GRegexMatchFlags
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(pattern))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GRegexCompileFlags)(compileOptions)
	arg3 = (C.GRegexMatchFlags)(matchOptions)

	ret := C.g_regex_new(arg1, arg2, arg3, &gError)

	var ret0 *Regex
	var goError error

	{
		ret0 = WrapRegex(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Regex) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// CaptureCount returns the number of capturing subpatterns in the pattern.
func (r *Regex) CaptureCount() int {
	var arg0 *C.GRegex

	arg0 = (*C.GRegex)(r.Native())

	ret := C.g_regex_get_capture_count(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// CompileFlags returns the compile options that @regex was created with.
//
// Depending on the version of PCRE that is used, this may or may not include
// flags set by option expressions such as `(?i)` found at the top-level within
// the compiled pattern.
func (r *Regex) CompileFlags() RegexCompileFlags {
	var arg0 *C.GRegex

	arg0 = (*C.GRegex)(r.Native())

	ret := C.g_regex_get_compile_flags(arg0)

	var ret0 RegexCompileFlags

	ret0 = RegexCompileFlags(ret)

	return ret0
}

// HasCrOrLf checks whether the pattern contains explicit CR or LF references.
func (r *Regex) HasCrOrLf() bool {
	var arg0 *C.GRegex

	arg0 = (*C.GRegex)(r.Native())

	ret := C.g_regex_get_has_cr_or_lf(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// MatchFlags returns the match options that @regex was created with.
func (r *Regex) MatchFlags() RegexMatchFlags {
	var arg0 *C.GRegex

	arg0 = (*C.GRegex)(r.Native())

	ret := C.g_regex_get_match_flags(arg0)

	var ret0 RegexMatchFlags

	ret0 = RegexMatchFlags(ret)

	return ret0
}

// MaxBackref returns the number of the highest back reference in the pattern,
// or 0 if the pattern does not contain back references.
func (r *Regex) MaxBackref() int {
	var arg0 *C.GRegex

	arg0 = (*C.GRegex)(r.Native())

	ret := C.g_regex_get_max_backref(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// MaxLookbehind gets the number of characters in the longest lookbehind
// assertion in the pattern. This information is useful when doing multi-segment
// matching using the partial matching facilities.
func (r *Regex) MaxLookbehind() int {
	var arg0 *C.GRegex

	arg0 = (*C.GRegex)(r.Native())

	ret := C.g_regex_get_max_lookbehind(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Pattern gets the pattern string associated with @regex, i.e. a copy of the
// string passed to g_regex_new().
func (r *Regex) Pattern() string {
	var arg0 *C.GRegex

	arg0 = (*C.GRegex)(r.Native())

	ret := C.g_regex_get_pattern(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// StringNumber retrieves the number of the subexpression named @name.
func (r *Regex) StringNumber(name string) int {
	var arg0 *C.GRegex
	var arg1 *C.gchar

	arg0 = (*C.GRegex)(r.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_regex_get_string_number(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Match scans for a match in @string for the pattern in @regex. The
// @match_options are combined with the match options specified when the @regex
// structure was created, letting you have more flexibility in reusing #GRegex
// structures.
//
// Unless G_REGEX_RAW is specified in the options, @string must be valid UTF-8.
//
// A Info structure, used to get information on the match, is stored in
// @match_info if not nil. Note that if @match_info is not nil then it is
// created even if the function returns false, i.e. you must free it regardless
// if regular expression actually matched.
//
// To retrieve all the non-overlapping matches of the pattern in string you can
// use g_match_info_next().
//
//    static void
//    print_uppercase_words (const gchar *string)
//    {
//      // Print all uppercase-only words.
//      GRegex *regex;
//      GMatchInfo *match_info;
//
//      regex = g_regex_new ("[A-Z]+", 0, 0, NULL);
//      g_regex_match (regex, string, 0, &match_info);
//      while (g_match_info_matches (match_info))
//        {
//          gchar *word = g_match_info_fetch (match_info, 0);
//          g_print ("Found: s\n", word);
//          g_free (word);
//          g_match_info_next (match_info, NULL);
//        }
//      g_match_info_free (match_info);
//      g_regex_unref (regex);
//    }
//
// @string is not copied and is used in Info internally. If you use any Info
// method (except g_match_info_free()) after freeing or modifying @string then
// the behaviour is undefined.
func (r *Regex) Match(string string, matchOptions RegexMatchFlags) (matchInfo *MatchInfo, ok bool) {
	var arg0 *C.GRegex
	var arg1 *C.gchar
	var arg2 C.GRegexMatchFlags
	var arg3 **C.GMatchInfo // out

	arg0 = (*C.GRegex)(r.Native())
	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GRegexMatchFlags)(matchOptions)

	ret := C.g_regex_match(arg0, arg1, arg2, &arg3)

	var ret0 **MatchInfo
	var ret1 bool

	{
		ret0 = WrapMatchInfo(unsafe.Pointer(arg3))
		runtime.SetFinalizer(ret0, func(v **MatchInfo) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	ret1 = C.bool(ret) != C.false

	return ret0, ret1
}

// MatchAll: using the standard algorithm for regular expression matching only
// the longest match in the string is retrieved. This function uses a different
// algorithm so it can retrieve all the possible matches. For more documentation
// see g_regex_match_all_full().
//
// A Info structure, used to get information on the match, is stored in
// @match_info if not nil. Note that if @match_info is not nil then it is
// created even if the function returns false, i.e. you must free it regardless
// if regular expression actually matched.
//
// @string is not copied and is used in Info internally. If you use any Info
// method (except g_match_info_free()) after freeing or modifying @string then
// the behaviour is undefined.
func (r *Regex) MatchAll(string string, matchOptions RegexMatchFlags) (matchInfo *MatchInfo, ok bool) {
	var arg0 *C.GRegex
	var arg1 *C.gchar
	var arg2 C.GRegexMatchFlags
	var arg3 **C.GMatchInfo // out

	arg0 = (*C.GRegex)(r.Native())
	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GRegexMatchFlags)(matchOptions)

	ret := C.g_regex_match_all(arg0, arg1, arg2, &arg3)

	var ret0 **MatchInfo
	var ret1 bool

	{
		ret0 = WrapMatchInfo(unsafe.Pointer(arg3))
		runtime.SetFinalizer(ret0, func(v **MatchInfo) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	ret1 = C.bool(ret) != C.false

	return ret0, ret1
}

// MatchAllFull: using the standard algorithm for regular expression matching
// only the longest match in the @string is retrieved, it is not possible to
// obtain all the available matches. For instance matching "<a> <b> <c>" against
// the pattern "<.*>" you get "<a> <b> <c>".
//
// This function uses a different algorithm (called DFA, i.e. deterministic
// finite automaton), so it can retrieve all the possible matches, all starting
// at the same point in the string. For instance matching "<a> <b> <c>" against
// the pattern "<.*>;" you would obtain three matches: "<a> <b> <c>", "<a> <b>"
// and "<a>".
//
// The number of matched strings is retrieved using
// g_match_info_get_match_count(). To obtain the matched strings and their
// position you can use, respectively, g_match_info_fetch() and
// g_match_info_fetch_pos(). Note that the strings are returned in reverse order
// of length; that is, the longest matching string is given first.
//
// Note that the DFA algorithm is slower than the standard one and it is not
// able to capture substrings, so backreferences do not work.
//
// Setting @start_position differs from just passing over a shortened string and
// setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind
// of lookbehind assertion, such as "\b".
//
// Unless G_REGEX_RAW is specified in the options, @string must be valid UTF-8.
//
// A Info structure, used to get information on the match, is stored in
// @match_info if not nil. Note that if @match_info is not nil then it is
// created even if the function returns false, i.e. you must free it regardless
// if regular expression actually matched.
//
// @string is not copied and is used in Info internally. If you use any Info
// method (except g_match_info_free()) after freeing or modifying @string then
// the behaviour is undefined.
func (r *Regex) MatchAllFull(string []string, startPosition int, matchOptions RegexMatchFlags) (matchInfo *MatchInfo, err error) {
	var arg0 *C.GRegex
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 C.gint
	var arg4 C.GRegexMatchFlags
	var arg5 **C.GMatchInfo // out
	var gError *C.GError

	arg0 = (*C.GRegex)(r.Native())
	{
		var dst []C.gchar
		ptr := C.malloc(C.sizeof_gchar * len(string))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(string)
		sliceHeader.Cap = len(string)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(string); i++ {
			src := string[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg1 = (*C.gchar)(unsafe.Pointer(ptr))
		arg2 = len(string)
	}
	arg3 = C.gint(startPosition)
	arg4 = (C.GRegexMatchFlags)(matchOptions)

	ret := C.g_regex_match_all_full(arg0, arg1, arg2, arg3, arg4, &arg5, &gError)

	var ret0 **MatchInfo
	var goError error

	{
		ret0 = WrapMatchInfo(unsafe.Pointer(arg5))
		runtime.SetFinalizer(ret0, func(v **MatchInfo) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// MatchFull scans for a match in @string for the pattern in @regex. The
// @match_options are combined with the match options specified when the @regex
// structure was created, letting you have more flexibility in reusing #GRegex
// structures.
//
// Setting @start_position differs from just passing over a shortened string and
// setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind
// of lookbehind assertion, such as "\b".
//
// Unless G_REGEX_RAW is specified in the options, @string must be valid UTF-8.
//
// A Info structure, used to get information on the match, is stored in
// @match_info if not nil. Note that if @match_info is not nil then it is
// created even if the function returns false, i.e. you must free it regardless
// if regular expression actually matched.
//
// @string is not copied and is used in Info internally. If you use any Info
// method (except g_match_info_free()) after freeing or modifying @string then
// the behaviour is undefined.
//
// To retrieve all the non-overlapping matches of the pattern in string you can
// use g_match_info_next().
//
//    static void
//    print_uppercase_words (const gchar *string)
//    {
//      // Print all uppercase-only words.
//      GRegex *regex;
//      GMatchInfo *match_info;
//      GError *error = NULL;
//
//      regex = g_regex_new ("[A-Z]+", 0, 0, NULL);
//      g_regex_match_full (regex, string, -1, 0, 0, &match_info, &error);
//      while (g_match_info_matches (match_info))
//        {
//          gchar *word = g_match_info_fetch (match_info, 0);
//          g_print ("Found: s\n", word);
//          g_free (word);
//          g_match_info_next (match_info, &error);
//        }
//      g_match_info_free (match_info);
//      g_regex_unref (regex);
//      if (error != NULL)
//        {
//          g_printerr ("Error while matching: s\n", error->message);
//          g_error_free (error);
//        }
//    }
func (r *Regex) MatchFull(string []string, startPosition int, matchOptions RegexMatchFlags) (matchInfo *MatchInfo, err error) {
	var arg0 *C.GRegex
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 C.gint
	var arg4 C.GRegexMatchFlags
	var arg5 **C.GMatchInfo // out
	var gError *C.GError

	arg0 = (*C.GRegex)(r.Native())
	{
		var dst []C.gchar
		ptr := C.malloc(C.sizeof_gchar * len(string))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(string)
		sliceHeader.Cap = len(string)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(string); i++ {
			src := string[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg1 = (*C.gchar)(unsafe.Pointer(ptr))
		arg2 = len(string)
	}
	arg3 = C.gint(startPosition)
	arg4 = (C.GRegexMatchFlags)(matchOptions)

	ret := C.g_regex_match_full(arg0, arg1, arg2, arg3, arg4, &arg5, &gError)

	var ret0 **MatchInfo
	var goError error

	{
		ret0 = WrapMatchInfo(unsafe.Pointer(arg5))
		runtime.SetFinalizer(ret0, func(v **MatchInfo) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Ref increases reference count of @regex by 1.
func (r *Regex) Ref() *Regex {
	var arg0 *C.GRegex

	arg0 = (*C.GRegex)(r.Native())

	ret := C.g_regex_ref(arg0)

	var ret0 *Regex

	{
		ret0 = WrapRegex(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Regex) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Replace replaces all occurrences of the pattern in @regex with the
// replacement text. Backreferences of the form '\number' or '\g<number>' in the
// replacement text are interpolated by the number-th captured subexpression of
// the match, '\g<name>' refers to the captured subexpression with the given
// name. '\0' refers to the complete match, but '\0' followed by a number is the
// octal representation of a character. To include a literal '\' in the
// replacement, write '\\\\'.
//
// There are also escapes that changes the case of the following text:
//
// - \l: Convert to lower case the next character - \u: Convert to upper case
// the next character - \L: Convert to lower case till \E - \U: Convert to upper
// case till \E - \E: End case modification
//
// If you do not need to use backreferences use g_regex_replace_literal().
//
// The @replacement string must be UTF-8 encoded even if REGEX_RAW was passed to
// g_regex_new(). If you want to use not UTF-8 encoded strings you can use
// g_regex_replace_literal().
//
// Setting @start_position differs from just passing over a shortened string and
// setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind
// of lookbehind assertion, such as "\b".
func (r *Regex) Replace(string []string, startPosition int, replacement string, matchOptions RegexMatchFlags) (utf8 string, err error) {
	var arg0 *C.GRegex
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 C.gint
	var arg4 *C.gchar
	var arg5 C.GRegexMatchFlags
	var gError *C.GError

	arg0 = (*C.GRegex)(r.Native())
	{
		var dst []C.gchar
		ptr := C.malloc(C.sizeof_gchar * len(string))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(string)
		sliceHeader.Cap = len(string)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(string); i++ {
			src := string[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg1 = (*C.gchar)(unsafe.Pointer(ptr))
		arg2 = len(string)
	}
	arg3 = C.gint(startPosition)
	arg4 = (*C.gchar)(C.CString(replacement))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (C.GRegexMatchFlags)(matchOptions)

	ret := C.g_regex_replace(arg0, arg1, arg2, arg3, arg4, arg5, &gError)

	var ret0 string
	var goError error

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// ReplaceEval replaces occurrences of the pattern in regex with the output of
// @eval for that occurrence.
//
// Setting @start_position differs from just passing over a shortened string and
// setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind
// of lookbehind assertion, such as "\b".
//
// The following example uses g_regex_replace_eval() to replace multiple strings
// at once:
//
//    static gboolean
//    eval_cb (const GMatchInfo *info,
//             GString          *res,
//             gpointer          data)
//    {
//      gchar *match;
//      gchar *r;
//
//       match = g_match_info_fetch (info, 0);
//       r = g_hash_table_lookup ((GHashTable *)data, match);
//       g_string_append (res, r);
//       g_free (match);
//
//       return FALSE;
//    }
//
//    ...
//
//    GRegex *reg;
//    GHashTable *h;
//    gchar *res;
//
//    h = g_hash_table_new (g_str_hash, g_str_equal);
//
//    g_hash_table_insert (h, "1", "ONE");
//    g_hash_table_insert (h, "2", "TWO");
//    g_hash_table_insert (h, "3", "THREE");
//    g_hash_table_insert (h, "4", "FOUR");
//
//    reg = g_regex_new ("1|2|3|4", 0, 0, NULL);
//    res = g_regex_replace_eval (reg, text, -1, 0, 0, eval_cb, h, NULL);
//    g_hash_table_destroy (h);
//
//    ...
func (r *Regex) ReplaceEval(string []string, startPosition int, matchOptions RegexMatchFlags, eval RegexEvalCallback) (utf8 string, err error) {
	var arg0 *C.GRegex
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 C.gint
	var arg4 C.GRegexMatchFlags
	var arg5 C.GRegexEvalCallback
	var arg6 C.gpointer
	var gError *C.GError

	arg0 = (*C.GRegex)(r.Native())
	{
		var dst []C.gchar
		ptr := C.malloc(C.sizeof_gchar * len(string))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(string)
		sliceHeader.Cap = len(string)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(string); i++ {
			src := string[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg1 = (*C.gchar)(unsafe.Pointer(ptr))
		arg2 = len(string)
	}
	arg3 = C.gint(startPosition)
	arg4 = (C.GRegexMatchFlags)(matchOptions)
	arg5 = (*[0]byte)(C.gotk4_RegexEvalCallback)
	arg6 = C.gpointer(box.Assign(eval))

	ret := C.g_regex_replace_eval(arg0, arg1, arg2, arg3, arg4, arg5, arg6, &gError)

	var ret0 string
	var goError error

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// ReplaceLiteral replaces all occurrences of the pattern in @regex with the
// replacement text. @replacement is replaced literally, to include
// backreferences use g_regex_replace().
//
// Setting @start_position differs from just passing over a shortened string and
// setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind
// of lookbehind assertion, such as "\b".
func (r *Regex) ReplaceLiteral(string []string, startPosition int, replacement string, matchOptions RegexMatchFlags) (utf8 string, err error) {
	var arg0 *C.GRegex
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 C.gint
	var arg4 *C.gchar
	var arg5 C.GRegexMatchFlags
	var gError *C.GError

	arg0 = (*C.GRegex)(r.Native())
	{
		var dst []C.gchar
		ptr := C.malloc(C.sizeof_gchar * len(string))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(string)
		sliceHeader.Cap = len(string)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(string); i++ {
			src := string[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg1 = (*C.gchar)(unsafe.Pointer(ptr))
		arg2 = len(string)
	}
	arg3 = C.gint(startPosition)
	arg4 = (*C.gchar)(C.CString(replacement))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (C.GRegexMatchFlags)(matchOptions)

	ret := C.g_regex_replace_literal(arg0, arg1, arg2, arg3, arg4, arg5, &gError)

	var ret0 string
	var goError error

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Split breaks the string on the pattern, and returns an array of the tokens.
// If the pattern contains capturing parentheses, then the text for each of the
// substrings will also be returned. If the pattern does not match anywhere in
// the string, then the whole string is returned as the first token.
//
// As a special case, the result of splitting the empty string "" is an empty
// vector, not a vector containing a single string. The reason for this special
// case is that being able to represent an empty vector is typically more useful
// than consistent handling of empty elements. If you do need to represent empty
// elements, you'll need to check for the empty string before calling this
// function.
//
// A pattern that can match empty strings splits @string into separate
// characters wherever it matches the empty string between characters. For
// example splitting "ab c" using as a separator "\s*", you will get "a", "b"
// and "c".
func (r *Regex) Split(string string, matchOptions RegexMatchFlags) []string {
	var arg0 *C.GRegex
	var arg1 *C.gchar
	var arg2 C.GRegexMatchFlags

	arg0 = (*C.GRegex)(r.Native())
	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GRegexMatchFlags)(matchOptions)

	ret := C.g_regex_split(arg0, arg1, arg2)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// SplitFull breaks the string on the pattern, and returns an array of the
// tokens. If the pattern contains capturing parentheses, then the text for each
// of the substrings will also be returned. If the pattern does not match
// anywhere in the string, then the whole string is returned as the first token.
//
// As a special case, the result of splitting the empty string "" is an empty
// vector, not a vector containing a single string. The reason for this special
// case is that being able to represent an empty vector is typically more useful
// than consistent handling of empty elements. If you do need to represent empty
// elements, you'll need to check for the empty string before calling this
// function.
//
// A pattern that can match empty strings splits @string into separate
// characters wherever it matches the empty string between characters. For
// example splitting "ab c" using as a separator "\s*", you will get "a", "b"
// and "c".
//
// Setting @start_position differs from just passing over a shortened string and
// setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind
// of lookbehind assertion, such as "\b".
func (r *Regex) SplitFull(string []string, startPosition int, matchOptions RegexMatchFlags, maxTokens int) (utf8s []string, err error) {
	var arg0 *C.GRegex
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 C.gint
	var arg4 C.GRegexMatchFlags
	var arg5 C.gint
	var gError *C.GError

	arg0 = (*C.GRegex)(r.Native())
	{
		var dst []C.gchar
		ptr := C.malloc(C.sizeof_gchar * len(string))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(string)
		sliceHeader.Cap = len(string)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(string); i++ {
			src := string[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg1 = (*C.gchar)(unsafe.Pointer(ptr))
		arg2 = len(string)
	}
	arg3 = C.gint(startPosition)
	arg4 = (C.GRegexMatchFlags)(matchOptions)
	arg5 = C.gint(maxTokens)

	ret := C.g_regex_split_full(arg0, arg1, arg2, arg3, arg4, arg5, &gError)

	var ret0 []string
	var goError error

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Unref decreases reference count of @regex by 1. When reference count drops to
// zero, it frees all the memory associated with the regex structure.
func (r *Regex) Unref() {
	var arg0 *C.GRegex

	arg0 = (*C.GRegex)(r.Native())

	C.g_regex_unref(arg0)
}
