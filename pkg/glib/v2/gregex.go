// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	"github.com/diamondburned/gotk4/internal/gerror"
	"github.com/diamondburned/gotk4/internal/ptr"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0 glib-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <glib.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_match_info_get_type()), F: marshalMatchInfo},
		{T: externglib.Type(C.g_regex_get_type()), F: marshalRegex},
	})
}

// RegexError: error codes returned by regular expressions functions.
type RegexError int

const (
	// RegexErrorCompile: compilation of the regular expression failed.
	RegexErrorCompile RegexError = 0
	// RegexErrorOptimize: optimization of the regular expression failed.
	RegexErrorOptimize RegexError = 1
	// RegexErrorReplace: replacement failed due to an ill-formed replacement
	// string.
	RegexErrorReplace RegexError = 2
	// RegexErrorMatch: the match process failed.
	RegexErrorMatch RegexError = 3
	// RegexErrorInternal: internal error of the regular expression engine.
	// Since 2.16
	RegexErrorInternal RegexError = 4
	// RegexErrorStrayBackslash: "\\" at end of pattern. Since 2.16
	RegexErrorStrayBackslash RegexError = 101
	// RegexErrorMissingControlChar: "\\c" at end of pattern. Since 2.16
	RegexErrorMissingControlChar RegexError = 102
	// RegexErrorUnrecognizedEscape: unrecognized character follows "\\". Since
	// 2.16
	RegexErrorUnrecognizedEscape RegexError = 103
	// RegexErrorQuantifiersOutOfOrder numbers out of order in "{}" quantifier.
	// Since 2.16
	RegexErrorQuantifiersOutOfOrder RegexError = 104
	// RegexErrorQuantifierTooBig: number too big in "{}" quantifier. Since 2.16
	RegexErrorQuantifierTooBig RegexError = 105
	// RegexErrorUnterminatedCharacterClass: missing terminating "]" for
	// character class. Since 2.16
	RegexErrorUnterminatedCharacterClass RegexError = 106
	// RegexErrorInvalidEscapeInCharacterClass: invalid escape sequence in
	// character class. Since 2.16
	RegexErrorInvalidEscapeInCharacterClass RegexError = 107
	// RegexErrorRangeOutOfOrder: range out of order in character class. Since
	// 2.16
	RegexErrorRangeOutOfOrder RegexError = 108
	// RegexErrorNothingToRepeat: nothing to repeat. Since 2.16
	RegexErrorNothingToRepeat RegexError = 109
	// RegexErrorUnrecognizedCharacter: unrecognized character after "(?", "(?<"
	// or "(?P". Since 2.16
	RegexErrorUnrecognizedCharacter RegexError = 112
	// RegexErrorPosixNamedClassOutsideClass: POSIX named classes are supported
	// only within a class. Since 2.16
	RegexErrorPosixNamedClassOutsideClass RegexError = 113
	// RegexErrorUnmatchedParenthesis: missing terminating ")" or ")" without
	// opening "(". Since 2.16
	RegexErrorUnmatchedParenthesis RegexError = 114
	// RegexErrorInexistentSubpatternReference: reference to non-existent
	// subpattern. Since 2.16
	RegexErrorInexistentSubpatternReference RegexError = 115
	// RegexErrorUnterminatedComment: missing terminating ")" after comment.
	// Since 2.16
	RegexErrorUnterminatedComment RegexError = 118
	// RegexErrorExpressionTooLarge: regular expression too large. Since 2.16
	RegexErrorExpressionTooLarge RegexError = 120
	// RegexErrorMemoryError: failed to get memory. Since 2.16
	RegexErrorMemoryError RegexError = 121
	// RegexErrorVariableLengthLookbehind: lookbehind assertion is not fixed
	// length. Since 2.16
	RegexErrorVariableLengthLookbehind RegexError = 125
	// RegexErrorMalformedCondition: malformed number or name after "(?(". Since
	// 2.16
	RegexErrorMalformedCondition RegexError = 126
	// RegexErrorTooManyConditionalBranches: conditional group contains more
	// than two branches. Since 2.16
	RegexErrorTooManyConditionalBranches RegexError = 127
	// RegexErrorAssertionExpected: assertion expected after "(?(". Since 2.16
	RegexErrorAssertionExpected RegexError = 128
	// RegexErrorUnknownPosixClassName: unknown POSIX class name. Since 2.16
	RegexErrorUnknownPosixClassName RegexError = 130
	// RegexErrorPosixCollatingElementsNotSupported: POSIX collating elements
	// are not supported. Since 2.16
	RegexErrorPosixCollatingElementsNotSupported RegexError = 131
	// RegexErrorHexCodeTooLarge: character value in "\\x{...}" sequence is too
	// large. Since 2.16
	RegexErrorHexCodeTooLarge RegexError = 134
	// RegexErrorInvalidCondition: invalid condition "(?(0)". Since 2.16
	RegexErrorInvalidCondition RegexError = 135
	// RegexErrorSingleByteMatchInLookbehind: \\C not allowed in lookbehind
	// assertion. Since 2.16
	RegexErrorSingleByteMatchInLookbehind RegexError = 136
	// RegexErrorInfiniteLoop: recursive call could loop indefinitely. Since
	// 2.16
	RegexErrorInfiniteLoop RegexError = 140
	// RegexErrorMissingSubpatternNameTerminator: missing terminator in
	// subpattern name. Since 2.16
	RegexErrorMissingSubpatternNameTerminator RegexError = 142
	// RegexErrorDuplicateSubpatternName: two named subpatterns have the same
	// name. Since 2.16
	RegexErrorDuplicateSubpatternName RegexError = 143
	// RegexErrorMalformedProperty: malformed "\\P" or "\\p" sequence. Since
	// 2.16
	RegexErrorMalformedProperty RegexError = 146
	// RegexErrorUnknownProperty: unknown property name after "\\P" or "\\p".
	// Since 2.16
	RegexErrorUnknownProperty RegexError = 147
	// RegexErrorSubpatternNameTooLong: subpattern name is too long (maximum 32
	// characters). Since 2.16
	RegexErrorSubpatternNameTooLong RegexError = 148
	// RegexErrorTooManySubpatterns: too many named subpatterns (maximum
	// 10,000). Since 2.16
	RegexErrorTooManySubpatterns RegexError = 149
	// RegexErrorInvalidOctalValue: octal value is greater than "\\377". Since
	// 2.16
	RegexErrorInvalidOctalValue RegexError = 151
	// RegexErrorTooManyBranchesInDefine: "DEFINE" group contains more than one
	// branch. Since 2.16
	RegexErrorTooManyBranchesInDefine RegexError = 154
	// RegexErrorDefineRepetion: repeating a "DEFINE" group is not allowed. This
	// error is never raised. Since: 2.16 Deprecated: 2.34
	RegexErrorDefineRepetion RegexError = 155
	// RegexErrorInconsistentNewlineOptions: inconsistent newline options. Since
	// 2.16
	RegexErrorInconsistentNewlineOptions RegexError = 156
	// RegexErrorMissingBackReference: "\\g" is not followed by a braced,
	// angle-bracketed, or quoted name or number, or by a plain number. Since:
	// 2.16
	RegexErrorMissingBackReference RegexError = 157
	// RegexErrorInvalidRelativeReference: relative reference must not be zero.
	// Since: 2.34
	RegexErrorInvalidRelativeReference RegexError = 158
	// RegexErrorBacktrackingControlVerbArgumentForbidden: the backtracing
	// control verb used does not allow an argument. Since: 2.34
	RegexErrorBacktrackingControlVerbArgumentForbidden RegexError = 159
	// RegexErrorUnknownBacktrackingControlVerb: unknown backtracing control
	// verb. Since: 2.34
	RegexErrorUnknownBacktrackingControlVerb RegexError = 160
	// RegexErrorNumberTooBig: number is too big in escape sequence. Since: 2.34
	RegexErrorNumberTooBig RegexError = 161
	// RegexErrorMissingSubpatternName: missing subpattern name. Since: 2.34
	RegexErrorMissingSubpatternName RegexError = 162
	// RegexErrorMissingDigit: missing digit. Since 2.34
	RegexErrorMissingDigit RegexError = 163
	// RegexErrorInvalidDataCharacter: in JavaScript compatibility mode, "[" is
	// an invalid data character. Since: 2.34
	RegexErrorInvalidDataCharacter RegexError = 164
	// RegexErrorExtraSubpatternName: different names for subpatterns of the
	// same number are not allowed. Since: 2.34
	RegexErrorExtraSubpatternName RegexError = 165
	// RegexErrorBacktrackingControlVerbArgumentRequired: the backtracing
	// control verb requires an argument. Since: 2.34
	RegexErrorBacktrackingControlVerbArgumentRequired RegexError = 166
	// RegexErrorInvalidControlChar: "\\c" must be followed by an ASCII
	// character. Since: 2.34
	RegexErrorInvalidControlChar RegexError = 168
	// RegexErrorMissingName: "\\k" is not followed by a braced,
	// angle-bracketed, or quoted name. Since: 2.34
	RegexErrorMissingName RegexError = 169
	// RegexErrorNotSupportedInClass: "\\N" is not supported in a class. Since:
	// 2.34
	RegexErrorNotSupportedInClass RegexError = 171
	// RegexErrorTooManyForwardReferences: too many forward references. Since:
	// 2.34
	RegexErrorTooManyForwardReferences RegexError = 172
	// RegexErrorNameTooLong: the name is too long in "(*MARK)", "(*PRUNE)",
	// "(*SKIP)", or "(*THEN)". Since: 2.34
	RegexErrorNameTooLong RegexError = 175
	// RegexErrorCharacterValueTooLarge: the character value in the \\u sequence
	// is too large. Since: 2.34
	RegexErrorCharacterValueTooLarge RegexError = 176
)

// RegexCompileFlags flags specifying compile-time options.
type RegexCompileFlags int

const (
	// RegexCompileFlagsCaseless letters in the pattern match both upper- and
	// lowercase letters. This option can be changed within a pattern by a
	// "(?i)" option setting.
	RegexCompileFlagsCaseless RegexCompileFlags = 1
	// RegexCompileFlagsMultiline: by default, GRegex treats the strings as
	// consisting of a single line of characters (even if it actually contains
	// newlines). The "start of line" metacharacter ("^") matches only at the
	// start of the string, while the "end of line" metacharacter ("$") matches
	// only at the end of the string, or before a terminating newline (unless
	// REGEX_DOLLAR_ENDONLY is set). When REGEX_MULTILINE is set, the "start of
	// line" and "end of line" constructs match immediately following or
	// immediately before any newline in the string, respectively, as well as at
	// the very start and end. This can be changed within a pattern by a "(?m)"
	// option setting.
	RegexCompileFlagsMultiline RegexCompileFlags = 2
	// RegexCompileFlagsDotall: a dot metacharacter (".") in the pattern matches
	// all characters, including newlines. Without it, newlines are excluded.
	// This option can be changed within a pattern by a ("?s") option setting.
	RegexCompileFlagsDotall RegexCompileFlags = 4
	// RegexCompileFlagsExtended: whitespace data characters in the pattern are
	// totally ignored except when escaped or inside a character class.
	// Whitespace does not include the VT character (code 11). In addition,
	// characters between an unescaped "#" outside a character class and the
	// next newline character, inclusive, are also ignored. This can be changed
	// within a pattern by a "(?x)" option setting.
	RegexCompileFlagsExtended RegexCompileFlags = 8
	// RegexCompileFlagsAnchored: the pattern is forced to be "anchored", that
	// is, it is constrained to match only at the first matching point in the
	// string that is being searched. This effect can also be achieved by
	// appropriate constructs in the pattern itself such as the "^"
	// metacharacter.
	RegexCompileFlagsAnchored RegexCompileFlags = 16
	// RegexCompileFlagsDollarEndonly: a dollar metacharacter ("$") in the
	// pattern matches only at the end of the string. Without this option, a
	// dollar also matches immediately before the final character if it is a
	// newline (but not before any other newlines). This option is ignored if
	// REGEX_MULTILINE is set.
	RegexCompileFlagsDollarEndonly RegexCompileFlags = 32
	// RegexCompileFlagsUngreedy inverts the "greediness" of the quantifiers so
	// that they are not greedy by default, but become greedy if followed by
	// "?". It can also be set by a "(?U)" option setting within the pattern.
	RegexCompileFlagsUngreedy RegexCompileFlags = 512
	// RegexCompileFlagsRaw: usually strings must be valid UTF-8 strings, using
	// this flag they are considered as a raw sequence of bytes.
	RegexCompileFlagsRaw RegexCompileFlags = 2048
	// RegexCompileFlagsNoAutoCapture disables the use of numbered capturing
	// parentheses in the pattern. Any opening parenthesis that is not followed
	// by "?" behaves as if it were followed by "?:" but named parentheses can
	// still be used for capturing (and they acquire numbers in the usual way).
	RegexCompileFlagsNoAutoCapture RegexCompileFlags = 4096
	// RegexCompileFlagsOptimize: optimize the regular expression. If the
	// pattern will be used many times, then it may be worth the effort to
	// optimize it to improve the speed of matches.
	RegexCompileFlagsOptimize RegexCompileFlags = 8192
	// RegexCompileFlagsFirstline limits an unanchored pattern to match before
	// (or at) the first newline. Since: 2.34
	RegexCompileFlagsFirstline RegexCompileFlags = 262144
	// RegexCompileFlagsDupnames names used to identify capturing subpatterns
	// need not be unique. This can be helpful for certain types of pattern when
	// it is known that only one instance of the named subpattern can ever be
	// matched.
	RegexCompileFlagsDupnames RegexCompileFlags = 524288
	// RegexCompileFlagsNewlineCr: usually any newline character or character
	// sequence is recognized. If this option is set, the only recognized
	// newline character is '\r'.
	RegexCompileFlagsNewlineCr RegexCompileFlags = 1048576
	// RegexCompileFlagsNewlineLf: usually any newline character or character
	// sequence is recognized. If this option is set, the only recognized
	// newline character is '\n'.
	RegexCompileFlagsNewlineLf RegexCompileFlags = 2097152
	// RegexCompileFlagsNewlineCrlf: usually any newline character or character
	// sequence is recognized. If this option is set, the only recognized
	// newline character sequence is '\r\n'.
	RegexCompileFlagsNewlineCrlf RegexCompileFlags = 3145728
	// RegexCompileFlagsNewlineAnycrlf: usually any newline character or
	// character sequence is recognized. If this option is set, the only
	// recognized newline character sequences are '\r', '\n', and '\r\n'. Since:
	// 2.34
	RegexCompileFlagsNewlineAnycrlf RegexCompileFlags = 5242880
	// RegexCompileFlagsBsrAnycrlf: usually any newline character or character
	// sequence is recognised. If this option is set, then "\R" only recognizes
	// the newline characters '\r', '\n' and '\r\n'. Since: 2.34
	RegexCompileFlagsBsrAnycrlf RegexCompileFlags = 8388608
	// RegexCompileFlagsJavascriptCompat changes behaviour so that it is
	// compatible with JavaScript rather than PCRE. Since: 2.34
	RegexCompileFlagsJavascriptCompat RegexCompileFlags = 33554432
)

// RegexMatchFlags flags specifying match-time options.
type RegexMatchFlags int

const (
	// RegexMatchFlagsAnchored: the pattern is forced to be "anchored", that is,
	// it is constrained to match only at the first matching point in the string
	// that is being searched. This effect can also be achieved by appropriate
	// constructs in the pattern itself such as the "^" metacharacter.
	RegexMatchFlagsAnchored RegexMatchFlags = 16
	// RegexMatchFlagsNotbol specifies that first character of the string is not
	// the beginning of a line, so the circumflex metacharacter should not match
	// before it. Setting this without REGEX_MULTILINE (at compile time) causes
	// circumflex never to match. This option affects only the behaviour of the
	// circumflex metacharacter, it does not affect "\A".
	RegexMatchFlagsNotbol RegexMatchFlags = 128
	// RegexMatchFlagsNoteol specifies that the end of the subject string is not
	// the end of a line, so the dollar metacharacter should not match it nor
	// (except in multiline mode) a newline immediately before it. Setting this
	// without REGEX_MULTILINE (at compile time) causes dollar never to match.
	// This option affects only the behaviour of the dollar metacharacter, it
	// does not affect "\Z" or "\z".
	RegexMatchFlagsNoteol RegexMatchFlags = 256
	// RegexMatchFlagsNotempty: an empty string is not considered to be a valid
	// match if this option is set. If there are alternatives in the pattern,
	// they are tried. If all the alternatives match the empty string, the
	// entire match fails. For example, if the pattern "a?b?" is applied to a
	// string not beginning with "a" or "b", it matches the empty string at the
	// start of the string. With this flag set, this match is not valid, so
	// GRegex searches further into the string for occurrences of "a" or "b".
	RegexMatchFlagsNotempty RegexMatchFlags = 1024
	// RegexMatchFlagsPartial turns on the partial matching feature, for more
	// documentation on partial matching see g_match_info_is_partial_match().
	RegexMatchFlagsPartial RegexMatchFlags = 32768
	// RegexMatchFlagsNewlineCr overrides the newline definition set when
	// creating a new #GRegex, setting the '\r' character as line terminator.
	RegexMatchFlagsNewlineCr RegexMatchFlags = 1048576
	// RegexMatchFlagsNewlineLf overrides the newline definition set when
	// creating a new #GRegex, setting the '\n' character as line terminator.
	RegexMatchFlagsNewlineLf RegexMatchFlags = 2097152
	// RegexMatchFlagsNewlineCrlf overrides the newline definition set when
	// creating a new #GRegex, setting the '\r\n' characters sequence as line
	// terminator.
	RegexMatchFlagsNewlineCrlf RegexMatchFlags = 3145728
	// RegexMatchFlagsNewlineAny overrides the newline definition set when
	// creating a new #GRegex, any Unicode newline sequence is recognised as a
	// newline. These are '\r', '\n' and '\rn', and the single characters U+000B
	// LINE TABULATION, U+000C FORM FEED (FF), U+0085 NEXT LINE (NEL), U+2028
	// LINE SEPARATOR and U+2029 PARAGRAPH SEPARATOR.
	RegexMatchFlagsNewlineAny RegexMatchFlags = 4194304
	// RegexMatchFlagsNewlineAnycrlf overrides the newline definition set when
	// creating a new #GRegex; any '\r', '\n', or '\r\n' character sequence is
	// recognized as a newline. Since: 2.34
	RegexMatchFlagsNewlineAnycrlf RegexMatchFlags = 5242880
	// RegexMatchFlagsBsrAnycrlf overrides the newline definition for "\R" set
	// when creating a new #GRegex; only '\r', '\n', or '\r\n' character
	// sequences are recognized as a newline by "\R". Since: 2.34
	RegexMatchFlagsBsrAnycrlf RegexMatchFlags = 8388608
	// RegexMatchFlagsBsrAny overrides the newline definition for "\R" set when
	// creating a new #GRegex; any Unicode newline character or character
	// sequence are recognized as a newline by "\R". These are '\r', '\n' and
	// '\rn', and the single characters U+000B LINE TABULATION, U+000C FORM FEED
	// (FF), U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and U+2029 PARAGRAPH
	// SEPARATOR. Since: 2.34
	RegexMatchFlagsBsrAny RegexMatchFlags = 16777216
	// RegexMatchFlagsPartialSoft: an alias for REGEX_MATCH_PARTIAL. Since: 2.34
	RegexMatchFlagsPartialSoft RegexMatchFlags = 32768
	// RegexMatchFlagsPartialHard turns on the partial matching feature. In
	// contrast to to REGEX_MATCH_PARTIAL_SOFT, this stops matching as soon as a
	// partial match is found, without continuing to search for a possible
	// complete match. See g_match_info_is_partial_match() for more information.
	// Since: 2.34
	RegexMatchFlagsPartialHard RegexMatchFlags = 134217728
	// RegexMatchFlagsNotemptyAtstart: like REGEX_MATCH_NOTEMPTY, but only
	// applied to the start of the matched string. For anchored patterns this
	// can only happen for pattern containing "\K". Since: 2.34
	RegexMatchFlagsNotemptyAtstart RegexMatchFlags = 268435456
)

// MatchInfo: a GMatchInfo is an opaque struct used to return information about
// matches.
type MatchInfo struct {
	native C.GMatchInfo
}

// WrapMatchInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMatchInfo(ptr unsafe.Pointer) *MatchInfo {
	if ptr == nil {
		return nil
	}

	return (*MatchInfo)(ptr)
}

func marshalMatchInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapMatchInfo(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (m *MatchInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&m.native)
}

// ExpandReferences returns a new string containing the text in
// @string_to_expand with references and escape sequences expanded. References
// refer to the last match done with @string against @regex and have the same
// syntax used by g_regex_replace().
//
// The @string_to_expand must be UTF-8 encoded even if REGEX_RAW was passed to
// g_regex_new().
//
// The backreferences are extracted from the string passed to the match
// function, so you cannot call this function after freeing the string.
//
// @match_info may be nil in which case @string_to_expand must not contain
// references. For instance "foo\n" does not refer to an actual pattern and '\n'
// merely will be replaced with \n character, while to expand "\0" (whole match)
// one needs the result of a match. Use g_regex_check_replacement() to find out
// whether @string_to_expand contains references.
func (m *MatchInfo) ExpandReferences(stringToExpand string) (string, error) {
	var _arg0 *C.GMatchInfo // out
	var _arg1 *C.gchar      // out

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(stringToExpand))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret *C.gchar  // in
	var _cerr *C.GError // in

	_cret = C.g_match_info_expand_references(_arg0, _arg1, &_cerr)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _utf8, _goerr
}

// Fetch retrieves the text matching the @match_num'th capturing parentheses. 0
// is the full text of the match, 1 is the first paren set, 2 the second, and so
// on.
//
// If @match_num is a valid sub pattern but it didn't match anything (e.g. sub
// pattern 1, matching "b" against "(a)?b") then an empty string is returned.
//
// If the match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved string is not
// that of a set of parentheses but that of a matched substring. Substrings are
// matched in reverse order of length, so 0 is the longest match.
//
// The string is fetched from the string passed to the match function, so you
// cannot call this function after freeing the string.
func (m *MatchInfo) Fetch(matchNum int) string {
	var _arg0 *C.GMatchInfo // out
	var _arg1 C.gint        // out

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))
	_arg1 = C.gint(matchNum)

	var _cret *C.gchar // in

	_cret = C.g_match_info_fetch(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// FetchAll bundles up pointers to each of the matching substrings from a match
// and stores them in an array of gchar pointers. The first element in the
// returned array is the match number 0, i.e. the entire matched text.
//
// If a sub pattern didn't match anything (e.g. sub pattern 1, matching "b"
// against "(a)?b") then an empty string is inserted.
//
// If the last match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved strings are
// not that matched by sets of parentheses but that of the matched substring.
// Substrings are matched in reverse order of length, so the first one is the
// longest match.
//
// The strings are fetched from the string passed to the match function, so you
// cannot call this function after freeing the string.
func (m *MatchInfo) FetchAll() []string {
	var _arg0 *C.GMatchInfo // out

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))

	var _cret **C.gchar

	_cret = C.g_match_info_fetch_all(_arg0)

	var _utf8s []string

	{
		var length int
		for p := _cret; *p != 0; p = (**C.gchar)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		var src []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(_cret), int(length))

		_utf8s = make([]string, length)
		for i := range src {
			_utf8s = C.GoString(_cret)
			defer C.free(unsafe.Pointer(_cret))
		}
	}

	return _utf8s
}

// FetchNamed retrieves the text matching the capturing parentheses named @name.
//
// If @name is a valid sub pattern name but it didn't match anything (e.g. sub
// pattern "X", matching "b" against "(?P<X>a)?b") then an empty string is
// returned.
//
// The string is fetched from the string passed to the match function, so you
// cannot call this function after freeing the string.
func (m *MatchInfo) FetchNamed(name string) string {
	var _arg0 *C.GMatchInfo // out
	var _arg1 *C.gchar      // out

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret *C.gchar // in

	_cret = C.g_match_info_fetch_named(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// FetchNamedPos retrieves the position in bytes of the capturing parentheses
// named @name.
//
// If @name is a valid sub pattern name but it didn't match anything (e.g. sub
// pattern "X", matching "b" against "(?P<X>a)?b") then @start_pos and @end_pos
// are set to -1 and true is returned.
func (m *MatchInfo) FetchNamedPos(name string) (startPos int, endPos int, ok bool) {
	var _arg0 *C.GMatchInfo // out
	var _arg1 *C.gchar      // out

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	var _arg2 C.gint     // in
	var _arg3 C.gint     // in
	var _cret C.gboolean // in

	_cret = C.g_match_info_fetch_named_pos(_arg0, _arg1, &_arg2, &_arg3)

	var _startPos int // out
	var _endPos int   // out
	var _ok bool      // out

	_startPos = (int)(_arg2)
	_endPos = (int)(_arg3)
	if _cret {
		_ok = true
	}

	return _startPos, _endPos, _ok
}

// FetchPos retrieves the position in bytes of the @match_num'th capturing
// parentheses. 0 is the full text of the match, 1 is the first paren set, 2 the
// second, and so on.
//
// If @match_num is a valid sub pattern but it didn't match anything (e.g. sub
// pattern 1, matching "b" against "(a)?b") then @start_pos and @end_pos are set
// to -1 and true is returned.
//
// If the match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved position is
// not that of a set of parentheses but that of a matched substring. Substrings
// are matched in reverse order of length, so 0 is the longest match.
func (m *MatchInfo) FetchPos(matchNum int) (startPos int, endPos int, ok bool) {
	var _arg0 *C.GMatchInfo // out
	var _arg1 C.gint        // out

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))
	_arg1 = C.gint(matchNum)

	var _arg2 C.gint     // in
	var _arg3 C.gint     // in
	var _cret C.gboolean // in

	_cret = C.g_match_info_fetch_pos(_arg0, _arg1, &_arg2, &_arg3)

	var _startPos int // out
	var _endPos int   // out
	var _ok bool      // out

	_startPos = (int)(_arg2)
	_endPos = (int)(_arg3)
	if _cret {
		_ok = true
	}

	return _startPos, _endPos, _ok
}

// Free: if @match_info is not nil, calls g_match_info_unref(); otherwise does
// nothing.
func (m *MatchInfo) Free() {
	var _arg0 *C.GMatchInfo // out

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))

	C.g_match_info_free(_arg0)
}

// MatchCount retrieves the number of matched substrings (including substring 0,
// that is the whole matched text), so 1 is returned if the pattern has no
// substrings in it and 0 is returned if the match failed.
//
// If the last match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved count is not
// that of the number of capturing parentheses but that of the number of matched
// substrings.
func (m *MatchInfo) MatchCount() int {
	var _arg0 *C.GMatchInfo // out

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))

	var _cret C.gint // in

	_cret = C.g_match_info_get_match_count(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// String returns the string searched with @match_info. This is the string
// passed to g_regex_match() or g_regex_replace() so you may not free it before
// calling this function.
func (m *MatchInfo) String() string {
	var _arg0 *C.GMatchInfo // out

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))

	var _cret *C.gchar // in

	_cret = C.g_match_info_get_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// IsPartialMatch: usually if the string passed to g_regex_match*() matches as
// far as it goes, but is too short to match the entire pattern, false is
// returned. There are circumstances where it might be helpful to distinguish
// this case from other cases in which there is no match.
//
// Consider, for example, an application where a human is required to type in
// data for a field with specific formatting requirements. An example might be a
// date in the form ddmmmyy, defined by the pattern
// "^\d?\d(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\d\d$". If the
// application sees the user’s keystrokes one by one, and can check that what
// has been typed so far is potentially valid, it is able to raise an error as
// soon as a mistake is made.
//
// GRegex supports the concept of partial matching by means of the
// REGEX_MATCH_PARTIAL_SOFT and REGEX_MATCH_PARTIAL_HARD flags. When they are
// used, the return code for g_regex_match() or g_regex_match_full() is, as
// usual, true for a complete match, false otherwise. But, when these functions
// return false, you can check if the match was partial calling
// g_match_info_is_partial_match().
//
// The difference between REGEX_MATCH_PARTIAL_SOFT and REGEX_MATCH_PARTIAL_HARD
// is that when a partial match is encountered with REGEX_MATCH_PARTIAL_SOFT,
// matching continues to search for a possible complete match, while with
// REGEX_MATCH_PARTIAL_HARD matching stops at the partial match. When both
// REGEX_MATCH_PARTIAL_SOFT and REGEX_MATCH_PARTIAL_HARD are set, the latter
// takes precedence.
//
// There were formerly some restrictions on the pattern for partial matching.
// The restrictions no longer apply.
//
// See pcrepartial(3) for more information on partial matching.
func (m *MatchInfo) IsPartialMatch() bool {
	var _arg0 *C.GMatchInfo // out

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))

	var _cret C.gboolean // in

	_cret = C.g_match_info_is_partial_match(_arg0)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Matches returns whether the previous match operation succeeded.
func (m *MatchInfo) Matches() bool {
	var _arg0 *C.GMatchInfo // out

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))

	var _cret C.gboolean // in

	_cret = C.g_match_info_matches(_arg0)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Next scans for the next match using the same parameters of the previous call
// to g_regex_match_full() or g_regex_match() that returned @match_info.
//
// The match is done on the string passed to the match function, so you cannot
// free it before calling this function.
func (m *MatchInfo) Next() error {
	var _arg0 *C.GMatchInfo // out

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))

	var _cerr *C.GError // in

	C.g_match_info_next(_arg0, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// Unref decreases reference count of @match_info by 1. When reference count
// drops to zero, it frees all the memory associated with the match_info
// structure.
func (m *MatchInfo) Unref() {
	var _arg0 *C.GMatchInfo // out

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(m.Native()))

	C.g_match_info_unref(_arg0)
}

// Regex: the g_regex_*() functions implement regular expression pattern
// matching using syntax and semantics similar to Perl regular expression.
//
// Some functions accept a @start_position argument, setting it differs from
// just passing over a shortened string and setting REGEX_MATCH_NOTBOL in the
// case of a pattern that begins with any kind of lookbehind assertion. For
// example, consider the pattern "\Biss\B" which finds occurrences of "iss" in
// the middle of words. ("\B" matches only if the current position in the
// subject is not a word boundary.) When applied to the string "Mississipi" from
// the fourth byte, namely "issipi", it does not match, because "\B" is always
// false at the start of the subject, which is deemed to be a word boundary.
// However, if the entire string is passed , but with @start_position set to 4,
// it finds the second occurrence of "iss" because it is able to look behind the
// starting point to discover that it is preceded by a letter.
//
// Note that, unless you set the REGEX_RAW flag, all the strings passed to these
// functions must be encoded in UTF-8. The lengths and the positions inside the
// strings are in bytes and not in characters, so, for instance, "\xc3\xa0"
// (i.e. "à") is two bytes long but it is treated as a single character. If you
// set REGEX_RAW the strings can be non-valid UTF-8 strings and a byte is
// treated as a character, so "\xc3\xa0" is two bytes and two characters long.
//
// When matching a pattern, "\n" matches only against a "\n" character in the
// string, and "\r" matches only a "\r" character. To match any newline sequence
// use "\R". This particular group matches either the two-character sequence CR
// + LF ("\r\n"), or one of the single characters LF (linefeed, U+000A, "\n"),
// VT vertical tab, U+000B, "\v"), FF (formfeed, U+000C, "\f"), CR (carriage
// return, U+000D, "\r"), NEL (next line, U+0085), LS (line separator, U+2028),
// or PS (paragraph separator, U+2029).
//
// The behaviour of the dot, circumflex, and dollar metacharacters are affected
// by newline characters, the default is to recognize any newline character (the
// same characters recognized by "\R"). This can be changed with
// REGEX_NEWLINE_CR, REGEX_NEWLINE_LF and REGEX_NEWLINE_CRLF compile options,
// and with REGEX_MATCH_NEWLINE_ANY, REGEX_MATCH_NEWLINE_CR,
// REGEX_MATCH_NEWLINE_LF and REGEX_MATCH_NEWLINE_CRLF match options. These
// settings are also relevant when compiling a pattern if REGEX_EXTENDED is set,
// and an unescaped "#" outside a character class is encountered. This indicates
// a comment that lasts until after the next newline.
//
// When setting the G_REGEX_JAVASCRIPT_COMPAT flag, pattern syntax and pattern
// matching is changed to be compatible with the way that regular expressions
// work in JavaScript. More precisely, a lonely ']' character in the pattern is
// a syntax error; the '\x' escape only allows 0 to 2 hexadecimal digits, and
// you must use the '\u' escape sequence with 4 hex digits to specify a unicode
// codepoint instead of '\x' or 'x{....}'. If '\x' or '\u' are not followed by
// the specified number of hex digits, they match 'x' and 'u' literally; also
// '\U' always matches 'U' instead of being an error in the pattern. Finally,
// pattern matching is modified so that back references to an unset subpattern
// group produces a match with the empty string instead of an error. See
// pcreapi(3) for more information.
//
// Creating and manipulating the same #GRegex structure from different threads
// is not a problem as #GRegex does not modify its internal state between
// creation and destruction, on the other hand Info is not threadsafe.
//
// The regular expressions low-level functionalities are obtained through the
// excellent PCRE (http://www.pcre.org/) library written by Philip Hazel.
type Regex struct {
	native C.GRegex
}

// WrapRegex wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRegex(ptr unsafe.Pointer) *Regex {
	if ptr == nil {
		return nil
	}

	return (*Regex)(ptr)
}

func marshalRegex(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRegex(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *Regex) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// CaptureCount returns the number of capturing subpatterns in the pattern.
func (r *Regex) CaptureCount() int {
	var _arg0 *C.GRegex // out

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))

	var _cret C.gint // in

	_cret = C.g_regex_get_capture_count(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// HasCrOrLf checks whether the pattern contains explicit CR or LF references.
func (r *Regex) HasCrOrLf() bool {
	var _arg0 *C.GRegex // out

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))

	var _cret C.gboolean // in

	_cret = C.g_regex_get_has_cr_or_lf(_arg0)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// MaxBackref returns the number of the highest back reference in the pattern,
// or 0 if the pattern does not contain back references.
func (r *Regex) MaxBackref() int {
	var _arg0 *C.GRegex // out

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))

	var _cret C.gint // in

	_cret = C.g_regex_get_max_backref(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// MaxLookbehind gets the number of characters in the longest lookbehind
// assertion in the pattern. This information is useful when doing multi-segment
// matching using the partial matching facilities.
func (r *Regex) MaxLookbehind() int {
	var _arg0 *C.GRegex // out

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))

	var _cret C.gint // in

	_cret = C.g_regex_get_max_lookbehind(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Pattern gets the pattern string associated with @regex, i.e. a copy of the
// string passed to g_regex_new().
func (r *Regex) Pattern() string {
	var _arg0 *C.GRegex // out

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))

	var _cret *C.gchar // in

	_cret = C.g_regex_get_pattern(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// StringNumber retrieves the number of the subexpression named @name.
func (r *Regex) StringNumber(name string) int {
	var _arg0 *C.GRegex // out
	var _arg1 *C.gchar  // out

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret C.gint // in

	_cret = C.g_regex_get_string_number(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Match scans for a match in @string for the pattern in @regex. The
// @match_options are combined with the match options specified when the @regex
// structure was created, letting you have more flexibility in reusing #GRegex
// structures.
//
// Unless G_REGEX_RAW is specified in the options, @string must be valid UTF-8.
//
// A Info structure, used to get information on the match, is stored in
// @match_info if not nil. Note that if @match_info is not nil then it is
// created even if the function returns false, i.e. you must free it regardless
// if regular expression actually matched.
//
// To retrieve all the non-overlapping matches of the pattern in string you can
// use g_match_info_next().
//
//    static void
//    print_uppercase_words (const gchar *string)
//    {
//      // Print all uppercase-only words.
//      GRegex *regex;
//      GMatchInfo *match_info;
//
//      regex = g_regex_new ("[A-Z]+", 0, 0, NULL);
//      g_regex_match (regex, string, 0, &match_info);
//      while (g_match_info_matches (match_info))
//        {
//          gchar *word = g_match_info_fetch (match_info, 0);
//          g_print ("Found: s\n", word);
//          g_free (word);
//          g_match_info_next (match_info, NULL);
//        }
//      g_match_info_free (match_info);
//      g_regex_unref (regex);
//    }
//
// @string is not copied and is used in Info internally. If you use any Info
// method (except g_match_info_free()) after freeing or modifying @string then
// the behaviour is undefined.
func (r *Regex) Match(string string, matchOptions RegexMatchFlags) (*MatchInfo, bool) {
	var _arg0 *C.GRegex          // out
	var _arg1 *C.gchar           // out
	var _arg2 C.GRegexMatchFlags // out

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GRegexMatchFlags)(matchOptions)

	var _matchInfo *MatchInfo
	var _cret C.gboolean // in

	_cret = C.g_regex_match(_arg0, _arg1, _arg2, (**C.GMatchInfo)(unsafe.Pointer(&_matchInfo)))

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _matchInfo, _ok
}

// MatchAll: using the standard algorithm for regular expression matching only
// the longest match in the string is retrieved. This function uses a different
// algorithm so it can retrieve all the possible matches. For more documentation
// see g_regex_match_all_full().
//
// A Info structure, used to get information on the match, is stored in
// @match_info if not nil. Note that if @match_info is not nil then it is
// created even if the function returns false, i.e. you must free it regardless
// if regular expression actually matched.
//
// @string is not copied and is used in Info internally. If you use any Info
// method (except g_match_info_free()) after freeing or modifying @string then
// the behaviour is undefined.
func (r *Regex) MatchAll(string string, matchOptions RegexMatchFlags) (*MatchInfo, bool) {
	var _arg0 *C.GRegex          // out
	var _arg1 *C.gchar           // out
	var _arg2 C.GRegexMatchFlags // out

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GRegexMatchFlags)(matchOptions)

	var _matchInfo *MatchInfo
	var _cret C.gboolean // in

	_cret = C.g_regex_match_all(_arg0, _arg1, _arg2, (**C.GMatchInfo)(unsafe.Pointer(&_matchInfo)))

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _matchInfo, _ok
}

// MatchAllFull: using the standard algorithm for regular expression matching
// only the longest match in the @string is retrieved, it is not possible to
// obtain all the available matches. For instance matching "<a> <b> <c>" against
// the pattern "<.*>" you get "<a> <b> <c>".
//
// This function uses a different algorithm (called DFA, i.e. deterministic
// finite automaton), so it can retrieve all the possible matches, all starting
// at the same point in the string. For instance matching "<a> <b> <c>" against
// the pattern "<.*>;" you would obtain three matches: "<a> <b> <c>", "<a> <b>"
// and "<a>".
//
// The number of matched strings is retrieved using
// g_match_info_get_match_count(). To obtain the matched strings and their
// position you can use, respectively, g_match_info_fetch() and
// g_match_info_fetch_pos(). Note that the strings are returned in reverse order
// of length; that is, the longest matching string is given first.
//
// Note that the DFA algorithm is slower than the standard one and it is not
// able to capture substrings, so backreferences do not work.
//
// Setting @start_position differs from just passing over a shortened string and
// setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind
// of lookbehind assertion, such as "\b".
//
// Unless G_REGEX_RAW is specified in the options, @string must be valid UTF-8.
//
// A Info structure, used to get information on the match, is stored in
// @match_info if not nil. Note that if @match_info is not nil then it is
// created even if the function returns false, i.e. you must free it regardless
// if regular expression actually matched.
//
// @string is not copied and is used in Info internally. If you use any Info
// method (except g_match_info_free()) after freeing or modifying @string then
// the behaviour is undefined.
func (r *Regex) MatchAllFull(string []string, startPosition int, matchOptions RegexMatchFlags) (*MatchInfo, error) {
	var _arg0 *C.GRegex // out
	var _arg1 *C.gchar
	var _arg2 C.gssize
	var _arg3 C.gint             // out
	var _arg4 C.GRegexMatchFlags // out

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))
	_arg2 = C.gssize(len(string))
	_arg1 = (*C.gchar)(C.malloc(len(string) * C.sizeof_gchar))
	defer C.free(unsafe.Pointer(_arg1))

	{
		var out []C.gchar
		ptr.SetSlice(unsafe.Pointer(&out), unsafe.Pointer(_arg1), int(len(string)))

		for i := range string {
			_arg1 = (C.gchar)(C.CString(string))
			defer C.free(unsafe.Pointer(_arg1))
		}
	}
	_arg3 = C.gint(startPosition)
	_arg4 = (C.GRegexMatchFlags)(matchOptions)

	var _matchInfo *MatchInfo
	var _cerr *C.GError // in

	C.g_regex_match_all_full(_arg0, _arg1, _arg2, _arg3, _arg4, (**C.GMatchInfo)(unsafe.Pointer(&_matchInfo)), &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _matchInfo, _goerr
}

// MatchFull scans for a match in @string for the pattern in @regex. The
// @match_options are combined with the match options specified when the @regex
// structure was created, letting you have more flexibility in reusing #GRegex
// structures.
//
// Setting @start_position differs from just passing over a shortened string and
// setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind
// of lookbehind assertion, such as "\b".
//
// Unless G_REGEX_RAW is specified in the options, @string must be valid UTF-8.
//
// A Info structure, used to get information on the match, is stored in
// @match_info if not nil. Note that if @match_info is not nil then it is
// created even if the function returns false, i.e. you must free it regardless
// if regular expression actually matched.
//
// @string is not copied and is used in Info internally. If you use any Info
// method (except g_match_info_free()) after freeing or modifying @string then
// the behaviour is undefined.
//
// To retrieve all the non-overlapping matches of the pattern in string you can
// use g_match_info_next().
//
//    static void
//    print_uppercase_words (const gchar *string)
//    {
//      // Print all uppercase-only words.
//      GRegex *regex;
//      GMatchInfo *match_info;
//      GError *error = NULL;
//
//      regex = g_regex_new ("[A-Z]+", 0, 0, NULL);
//      g_regex_match_full (regex, string, -1, 0, 0, &match_info, &error);
//      while (g_match_info_matches (match_info))
//        {
//          gchar *word = g_match_info_fetch (match_info, 0);
//          g_print ("Found: s\n", word);
//          g_free (word);
//          g_match_info_next (match_info, &error);
//        }
//      g_match_info_free (match_info);
//      g_regex_unref (regex);
//      if (error != NULL)
//        {
//          g_printerr ("Error while matching: s\n", error->message);
//          g_error_free (error);
//        }
//    }
func (r *Regex) MatchFull(string []string, startPosition int, matchOptions RegexMatchFlags) (*MatchInfo, error) {
	var _arg0 *C.GRegex // out
	var _arg1 *C.gchar
	var _arg2 C.gssize
	var _arg3 C.gint             // out
	var _arg4 C.GRegexMatchFlags // out

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))
	_arg2 = C.gssize(len(string))
	_arg1 = (*C.gchar)(C.malloc(len(string) * C.sizeof_gchar))
	defer C.free(unsafe.Pointer(_arg1))

	{
		var out []C.gchar
		ptr.SetSlice(unsafe.Pointer(&out), unsafe.Pointer(_arg1), int(len(string)))

		for i := range string {
			_arg1 = (C.gchar)(C.CString(string))
			defer C.free(unsafe.Pointer(_arg1))
		}
	}
	_arg3 = C.gint(startPosition)
	_arg4 = (C.GRegexMatchFlags)(matchOptions)

	var _matchInfo *MatchInfo
	var _cerr *C.GError // in

	C.g_regex_match_full(_arg0, _arg1, _arg2, _arg3, _arg4, (**C.GMatchInfo)(unsafe.Pointer(&_matchInfo)), &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _matchInfo, _goerr
}

// Replace replaces all occurrences of the pattern in @regex with the
// replacement text. Backreferences of the form '\number' or '\g<number>' in the
// replacement text are interpolated by the number-th captured subexpression of
// the match, '\g<name>' refers to the captured subexpression with the given
// name. '\0' refers to the complete match, but '\0' followed by a number is the
// octal representation of a character. To include a literal '\' in the
// replacement, write '\\\\'.
//
// There are also escapes that changes the case of the following text:
//
// - \l: Convert to lower case the next character - \u: Convert to upper case
// the next character - \L: Convert to lower case till \E - \U: Convert to upper
// case till \E - \E: End case modification
//
// If you do not need to use backreferences use g_regex_replace_literal().
//
// The @replacement string must be UTF-8 encoded even if REGEX_RAW was passed to
// g_regex_new(). If you want to use not UTF-8 encoded strings you can use
// g_regex_replace_literal().
//
// Setting @start_position differs from just passing over a shortened string and
// setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind
// of lookbehind assertion, such as "\b".
func (r *Regex) Replace(string []string, startPosition int, replacement string, matchOptions RegexMatchFlags) (string, error) {
	var _arg0 *C.GRegex // out
	var _arg1 *C.gchar
	var _arg2 C.gssize
	var _arg3 C.gint             // out
	var _arg4 *C.gchar           // out
	var _arg5 C.GRegexMatchFlags // out

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))
	_arg2 = C.gssize(len(string))
	_arg1 = (*C.gchar)(C.malloc(len(string) * C.sizeof_gchar))
	defer C.free(unsafe.Pointer(_arg1))

	{
		var out []C.gchar
		ptr.SetSlice(unsafe.Pointer(&out), unsafe.Pointer(_arg1), int(len(string)))

		for i := range string {
			_arg1 = (C.gchar)(C.CString(string))
			defer C.free(unsafe.Pointer(_arg1))
		}
	}
	_arg3 = C.gint(startPosition)
	_arg4 = (*C.gchar)(C.CString(replacement))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (C.GRegexMatchFlags)(matchOptions)

	var _cret *C.gchar  // in
	var _cerr *C.GError // in

	_cret = C.g_regex_replace(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _utf8, _goerr
}

// ReplaceEval replaces occurrences of the pattern in regex with the output of
// @eval for that occurrence.
//
// Setting @start_position differs from just passing over a shortened string and
// setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind
// of lookbehind assertion, such as "\b".
//
// The following example uses g_regex_replace_eval() to replace multiple strings
// at once:
//
//    static gboolean
//    eval_cb (const GMatchInfo *info,
//             GString          *res,
//             gpointer          data)
//    {
//      gchar *match;
//      gchar *r;
//
//       match = g_match_info_fetch (info, 0);
//       r = g_hash_table_lookup ((GHashTable *)data, match);
//       g_string_append (res, r);
//       g_free (match);
//
//       return FALSE;
//    }
//
//    ...
//
//    GRegex *reg;
//    GHashTable *h;
//    gchar *res;
//
//    h = g_hash_table_new (g_str_hash, g_str_equal);
//
//    g_hash_table_insert (h, "1", "ONE");
//    g_hash_table_insert (h, "2", "TWO");
//    g_hash_table_insert (h, "3", "THREE");
//    g_hash_table_insert (h, "4", "FOUR");
//
//    reg = g_regex_new ("1|2|3|4", 0, 0, NULL);
//    res = g_regex_replace_eval (reg, text, -1, 0, 0, eval_cb, h, NULL);
//    g_hash_table_destroy (h);
//
//    ...
func (r *Regex) ReplaceEval(string []string, startPosition int, matchOptions RegexMatchFlags, eval RegexEvalCallback) (string, error) {
	var _arg0 *C.GRegex // out
	var _arg1 *C.gchar
	var _arg2 C.gssize
	var _arg3 C.gint               // out
	var _arg4 C.GRegexMatchFlags   // out
	var _arg5 C.GRegexEvalCallback // out
	var _arg6 C.gpointer

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))
	_arg2 = C.gssize(len(string))
	_arg1 = (*C.gchar)(C.malloc(len(string) * C.sizeof_gchar))
	defer C.free(unsafe.Pointer(_arg1))

	{
		var out []C.gchar
		ptr.SetSlice(unsafe.Pointer(&out), unsafe.Pointer(_arg1), int(len(string)))

		for i := range string {
			_arg1 = (C.gchar)(C.CString(string))
			defer C.free(unsafe.Pointer(_arg1))
		}
	}
	_arg3 = C.gint(startPosition)
	_arg4 = (C.GRegexMatchFlags)(matchOptions)
	_arg5 = (*[0]byte)(C.gotk4_RegexEvalCallback)
	_arg6 = C.gpointer(box.Assign(eval))

	var _cret *C.gchar  // in
	var _cerr *C.GError // in

	_cret = C.g_regex_replace_eval(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, &_cerr)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _utf8, _goerr
}

// ReplaceLiteral replaces all occurrences of the pattern in @regex with the
// replacement text. @replacement is replaced literally, to include
// backreferences use g_regex_replace().
//
// Setting @start_position differs from just passing over a shortened string and
// setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind
// of lookbehind assertion, such as "\b".
func (r *Regex) ReplaceLiteral(string []string, startPosition int, replacement string, matchOptions RegexMatchFlags) (string, error) {
	var _arg0 *C.GRegex // out
	var _arg1 *C.gchar
	var _arg2 C.gssize
	var _arg3 C.gint             // out
	var _arg4 *C.gchar           // out
	var _arg5 C.GRegexMatchFlags // out

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))
	_arg2 = C.gssize(len(string))
	_arg1 = (*C.gchar)(C.malloc(len(string) * C.sizeof_gchar))
	defer C.free(unsafe.Pointer(_arg1))

	{
		var out []C.gchar
		ptr.SetSlice(unsafe.Pointer(&out), unsafe.Pointer(_arg1), int(len(string)))

		for i := range string {
			_arg1 = (C.gchar)(C.CString(string))
			defer C.free(unsafe.Pointer(_arg1))
		}
	}
	_arg3 = C.gint(startPosition)
	_arg4 = (*C.gchar)(C.CString(replacement))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (C.GRegexMatchFlags)(matchOptions)

	var _cret *C.gchar  // in
	var _cerr *C.GError // in

	_cret = C.g_regex_replace_literal(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _utf8, _goerr
}

// Split breaks the string on the pattern, and returns an array of the tokens.
// If the pattern contains capturing parentheses, then the text for each of the
// substrings will also be returned. If the pattern does not match anywhere in
// the string, then the whole string is returned as the first token.
//
// As a special case, the result of splitting the empty string "" is an empty
// vector, not a vector containing a single string. The reason for this special
// case is that being able to represent an empty vector is typically more useful
// than consistent handling of empty elements. If you do need to represent empty
// elements, you'll need to check for the empty string before calling this
// function.
//
// A pattern that can match empty strings splits @string into separate
// characters wherever it matches the empty string between characters. For
// example splitting "ab c" using as a separator "\s*", you will get "a", "b"
// and "c".
func (r *Regex) Split(string string, matchOptions RegexMatchFlags) []string {
	var _arg0 *C.GRegex          // out
	var _arg1 *C.gchar           // out
	var _arg2 C.GRegexMatchFlags // out

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GRegexMatchFlags)(matchOptions)

	var _cret **C.gchar

	_cret = C.g_regex_split(_arg0, _arg1, _arg2)

	var _utf8s []string

	{
		var length int
		for p := _cret; *p != 0; p = (**C.gchar)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		var src []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(_cret), int(length))

		_utf8s = make([]string, length)
		for i := range src {
			_utf8s = C.GoString(_cret)
			defer C.free(unsafe.Pointer(_cret))
		}
	}

	return _utf8s
}

// SplitFull breaks the string on the pattern, and returns an array of the
// tokens. If the pattern contains capturing parentheses, then the text for each
// of the substrings will also be returned. If the pattern does not match
// anywhere in the string, then the whole string is returned as the first token.
//
// As a special case, the result of splitting the empty string "" is an empty
// vector, not a vector containing a single string. The reason for this special
// case is that being able to represent an empty vector is typically more useful
// than consistent handling of empty elements. If you do need to represent empty
// elements, you'll need to check for the empty string before calling this
// function.
//
// A pattern that can match empty strings splits @string into separate
// characters wherever it matches the empty string between characters. For
// example splitting "ab c" using as a separator "\s*", you will get "a", "b"
// and "c".
//
// Setting @start_position differs from just passing over a shortened string and
// setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind
// of lookbehind assertion, such as "\b".
func (r *Regex) SplitFull(string []string, startPosition int, matchOptions RegexMatchFlags, maxTokens int) ([]string, error) {
	var _arg0 *C.GRegex // out
	var _arg1 *C.gchar
	var _arg2 C.gssize
	var _arg3 C.gint             // out
	var _arg4 C.GRegexMatchFlags // out
	var _arg5 C.gint             // out

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))
	_arg2 = C.gssize(len(string))
	_arg1 = (*C.gchar)(C.malloc(len(string) * C.sizeof_gchar))
	defer C.free(unsafe.Pointer(_arg1))

	{
		var out []C.gchar
		ptr.SetSlice(unsafe.Pointer(&out), unsafe.Pointer(_arg1), int(len(string)))

		for i := range string {
			_arg1 = (C.gchar)(C.CString(string))
			defer C.free(unsafe.Pointer(_arg1))
		}
	}
	_arg3 = C.gint(startPosition)
	_arg4 = (C.GRegexMatchFlags)(matchOptions)
	_arg5 = C.gint(maxTokens)

	var _cret **C.gchar
	var _cerr *C.GError // in

	_cret = C.g_regex_split_full(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _utf8s []string
	var _goerr error // out

	{
		var length int
		for p := _cret; *p != 0; p = (**C.gchar)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		var src []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(_cret), int(length))

		_utf8s = make([]string, length)
		for i := range src {
			_utf8s = C.GoString(_cret)
			defer C.free(unsafe.Pointer(_cret))
		}
	}
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _utf8s, _goerr
}

// Unref decreases reference count of @regex by 1. When reference count drops to
// zero, it frees all the memory associated with the regex structure.
func (r *Regex) Unref() {
	var _arg0 *C.GRegex // out

	_arg0 = (*C.GRegex)(unsafe.Pointer(r.Native()))

	C.g_regex_unref(_arg0)
}
