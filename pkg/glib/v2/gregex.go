// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <glib.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_match_info_get_type()), F: marshalMatchInfo},
		{T: externglib.Type(C.g_regex_get_type()), F: marshalRegex},
	})
}

// RegexError: error codes returned by regular expressions functions.
type RegexError int

const (
	// Compile: compilation of the regular expression failed.
	RegexErrorCompile RegexError = 0
	// Optimize: optimization of the regular expression failed.
	RegexErrorOptimize RegexError = 1
	// Replace: replacement failed due to an ill-formed replacement string.
	RegexErrorReplace RegexError = 2
	// Match process failed.
	RegexErrorMatch RegexError = 3
	// Internal: internal error of the regular expression engine. Since 2.16
	RegexErrorInternal RegexError = 4
	// StrayBackslash: "\\" at end of pattern. Since 2.16
	RegexErrorStrayBackslash RegexError = 101
	// MissingControlChar: "\\c" at end of pattern. Since 2.16
	RegexErrorMissingControlChar RegexError = 102
	// UnrecognizedEscape: unrecognized character follows "\\". Since 2.16
	RegexErrorUnrecognizedEscape RegexError = 103
	// QuantifiersOutOfOrder numbers out of order in "{}" quantifier. Since 2.16
	RegexErrorQuantifiersOutOfOrder RegexError = 104
	// QuantifierTooBig: number too big in "{}" quantifier. Since 2.16
	RegexErrorQuantifierTooBig RegexError = 105
	// UnterminatedCharacterClass: missing terminating "]" for character class.
	// Since 2.16
	RegexErrorUnterminatedCharacterClass RegexError = 106
	// InvalidEscapeInCharacterClass: invalid escape sequence in character
	// class. Since 2.16
	RegexErrorInvalidEscapeInCharacterClass RegexError = 107
	// RangeOutOfOrder: range out of order in character class. Since 2.16
	RegexErrorRangeOutOfOrder RegexError = 108
	// NothingToRepeat: nothing to repeat. Since 2.16
	RegexErrorNothingToRepeat RegexError = 109
	// UnrecognizedCharacter: unrecognized character after "(?", "(?<" or "(?P".
	// Since 2.16
	RegexErrorUnrecognizedCharacter RegexError = 112
	// PosixNamedClassOutsideClass: POSIX named classes are supported only
	// within a class. Since 2.16
	RegexErrorPosixNamedClassOutsideClass RegexError = 113
	// UnmatchedParenthesis: missing terminating ")" or ")" without opening "(".
	// Since 2.16
	RegexErrorUnmatchedParenthesis RegexError = 114
	// InexistentSubpatternReference: reference to non-existent subpattern.
	// Since 2.16
	RegexErrorInexistentSubpatternReference RegexError = 115
	// UnterminatedComment: missing terminating ")" after comment. Since 2.16
	RegexErrorUnterminatedComment RegexError = 118
	// ExpressionTooLarge: regular expression too large. Since 2.16
	RegexErrorExpressionTooLarge RegexError = 120
	// MemoryError: failed to get memory. Since 2.16
	RegexErrorMemoryError RegexError = 121
	// VariableLengthLookbehind: lookbehind assertion is not fixed length. Since
	// 2.16
	RegexErrorVariableLengthLookbehind RegexError = 125
	// MalformedCondition: malformed number or name after "(?(". Since 2.16
	RegexErrorMalformedCondition RegexError = 126
	// TooManyConditionalBranches: conditional group contains more than two
	// branches. Since 2.16
	RegexErrorTooManyConditionalBranches RegexError = 127
	// AssertionExpected: assertion expected after "(?(". Since 2.16
	RegexErrorAssertionExpected RegexError = 128
	// UnknownPosixClassName: unknown POSIX class name. Since 2.16
	RegexErrorUnknownPosixClassName RegexError = 130
	// PosixCollatingElementsNotSupported: POSIX collating elements are not
	// supported. Since 2.16
	RegexErrorPosixCollatingElementsNotSupported RegexError = 131
	// HexCodeTooLarge: character value in "\\x{...}" sequence is too large.
	// Since 2.16
	RegexErrorHexCodeTooLarge RegexError = 134
	// InvalidCondition: invalid condition "(?(0)". Since 2.16
	RegexErrorInvalidCondition RegexError = 135
	// SingleByteMatchInLookbehind: \\C not allowed in lookbehind assertion.
	// Since 2.16
	RegexErrorSingleByteMatchInLookbehind RegexError = 136
	// InfiniteLoop: recursive call could loop indefinitely. Since 2.16
	RegexErrorInfiniteLoop RegexError = 140
	// MissingSubpatternNameTerminator: missing terminator in subpattern name.
	// Since 2.16
	RegexErrorMissingSubpatternNameTerminator RegexError = 142
	// DuplicateSubpatternName: two named subpatterns have the same name. Since
	// 2.16
	RegexErrorDuplicateSubpatternName RegexError = 143
	// MalformedProperty: malformed "\\P" or "\\p" sequence. Since 2.16
	RegexErrorMalformedProperty RegexError = 146
	// UnknownProperty: unknown property name after "\\P" or "\\p". Since 2.16
	RegexErrorUnknownProperty RegexError = 147
	// SubpatternNameTooLong: subpattern name is too long (maximum 32
	// characters). Since 2.16
	RegexErrorSubpatternNameTooLong RegexError = 148
	// TooManySubpatterns: too many named subpatterns (maximum 10,000). Since
	// 2.16
	RegexErrorTooManySubpatterns RegexError = 149
	// InvalidOctalValue: octal value is greater than "\\377". Since 2.16
	RegexErrorInvalidOctalValue RegexError = 151
	// TooManyBranchesInDefine: "DEFINE" group contains more than one branch.
	// Since 2.16
	RegexErrorTooManyBranchesInDefine RegexError = 154
	// DefineRepetion: repeating a "DEFINE" group is not allowed. This error is
	// never raised. Since: 2.16 Deprecated: 2.34
	RegexErrorDefineRepetion RegexError = 155
	// InconsistentNewlineOptions: inconsistent newline options. Since 2.16
	RegexErrorInconsistentNewlineOptions RegexError = 156
	// MissingBackReference: "\\g" is not followed by a braced, angle-bracketed,
	// or quoted name or number, or by a plain number. Since: 2.16
	RegexErrorMissingBackReference RegexError = 157
	// InvalidRelativeReference: relative reference must not be zero. Since:
	// 2.34
	RegexErrorInvalidRelativeReference RegexError = 158
	// BacktrackingControlVerbArgumentForbidden: backtracing control verb used
	// does not allow an argument. Since: 2.34
	RegexErrorBacktrackingControlVerbArgumentForbidden RegexError = 159
	// UnknownBacktrackingControlVerb: unknown backtracing control verb. Since:
	// 2.34
	RegexErrorUnknownBacktrackingControlVerb RegexError = 160
	// NumberTooBig: number is too big in escape sequence. Since: 2.34
	RegexErrorNumberTooBig RegexError = 161
	// MissingSubpatternName: missing subpattern name. Since: 2.34
	RegexErrorMissingSubpatternName RegexError = 162
	// MissingDigit: missing digit. Since 2.34
	RegexErrorMissingDigit RegexError = 163
	// InvalidDataCharacter: in JavaScript compatibility mode, "[" is an invalid
	// data character. Since: 2.34
	RegexErrorInvalidDataCharacter RegexError = 164
	// ExtraSubpatternName: different names for subpatterns of the same number
	// are not allowed. Since: 2.34
	RegexErrorExtraSubpatternName RegexError = 165
	// BacktrackingControlVerbArgumentRequired: backtracing control verb
	// requires an argument. Since: 2.34
	RegexErrorBacktrackingControlVerbArgumentRequired RegexError = 166
	// InvalidControlChar: "\\c" must be followed by an ASCII character. Since:
	// 2.34
	RegexErrorInvalidControlChar RegexError = 168
	// MissingName: "\\k" is not followed by a braced, angle-bracketed, or
	// quoted name. Since: 2.34
	RegexErrorMissingName RegexError = 169
	// NotSupportedInClass: "\\N" is not supported in a class. Since: 2.34
	RegexErrorNotSupportedInClass RegexError = 171
	// TooManyForwardReferences: too many forward references. Since: 2.34
	RegexErrorTooManyForwardReferences RegexError = 172
	// NameTooLong: name is too long in "(*MARK)", "(*PRUNE)", "(*SKIP)", or
	// "(*THEN)". Since: 2.34
	RegexErrorNameTooLong RegexError = 175
	// CharacterValueTooLarge: character value in the \\u sequence is too large.
	// Since: 2.34
	RegexErrorCharacterValueTooLarge RegexError = 176
)

// RegexCompileFlags flags specifying compile-time options.
type RegexCompileFlags int

const (
	// RegexCompileFlagsCaseless letters in the pattern match both upper- and
	// lowercase letters. This option can be changed within a pattern by a
	// "(?i)" option setting.
	RegexCompileFlagsCaseless RegexCompileFlags = 0b1
	// RegexCompileFlagsMultiline: by default, GRegex treats the strings as
	// consisting of a single line of characters (even if it actually contains
	// newlines). The "start of line" metacharacter ("^") matches only at the
	// start of the string, while the "end of line" metacharacter ("$") matches
	// only at the end of the string, or before a terminating newline (unless
	// REGEX_DOLLAR_ENDONLY is set). When REGEX_MULTILINE is set, the "start of
	// line" and "end of line" constructs match immediately following or
	// immediately before any newline in the string, respectively, as well as at
	// the very start and end. This can be changed within a pattern by a "(?m)"
	// option setting.
	RegexCompileFlagsMultiline RegexCompileFlags = 0b10
	// RegexCompileFlagsDotall: dot metacharacter (".") in the pattern matches
	// all characters, including newlines. Without it, newlines are excluded.
	// This option can be changed within a pattern by a ("?s") option setting.
	RegexCompileFlagsDotall RegexCompileFlags = 0b100
	// RegexCompileFlagsExtended: whitespace data characters in the pattern are
	// totally ignored except when escaped or inside a character class.
	// Whitespace does not include the VT character (code 11). In addition,
	// characters between an unescaped "#" outside a character class and the
	// next newline character, inclusive, are also ignored. This can be changed
	// within a pattern by a "(?x)" option setting.
	RegexCompileFlagsExtended RegexCompileFlags = 0b1000
	// RegexCompileFlagsAnchored: pattern is forced to be "anchored", that is,
	// it is constrained to match only at the first matching point in the string
	// that is being searched. This effect can also be achieved by appropriate
	// constructs in the pattern itself such as the "^" metacharacter.
	RegexCompileFlagsAnchored RegexCompileFlags = 0b10000
	// RegexCompileFlagsDollarEndonly: dollar metacharacter ("$") in the pattern
	// matches only at the end of the string. Without this option, a dollar also
	// matches immediately before the final character if it is a newline (but
	// not before any other newlines). This option is ignored if REGEX_MULTILINE
	// is set.
	RegexCompileFlagsDollarEndonly RegexCompileFlags = 0b100000
	// RegexCompileFlagsUngreedy inverts the "greediness" of the quantifiers so
	// that they are not greedy by default, but become greedy if followed by
	// "?". It can also be set by a "(?U)" option setting within the pattern.
	RegexCompileFlagsUngreedy RegexCompileFlags = 0b1000000000
	// RegexCompileFlagsRaw: usually strings must be valid UTF-8 strings, using
	// this flag they are considered as a raw sequence of bytes.
	RegexCompileFlagsRaw RegexCompileFlags = 0b100000000000
	// RegexCompileFlagsNoAutoCapture disables the use of numbered capturing
	// parentheses in the pattern. Any opening parenthesis that is not followed
	// by "?" behaves as if it were followed by "?:" but named parentheses can
	// still be used for capturing (and they acquire numbers in the usual way).
	RegexCompileFlagsNoAutoCapture RegexCompileFlags = 0b1000000000000
	// RegexCompileFlagsOptimize: optimize the regular expression. If the
	// pattern will be used many times, then it may be worth the effort to
	// optimize it to improve the speed of matches.
	RegexCompileFlagsOptimize RegexCompileFlags = 0b10000000000000
	// RegexCompileFlagsFirstline limits an unanchored pattern to match before
	// (or at) the first newline. Since: 2.34
	RegexCompileFlagsFirstline RegexCompileFlags = 0b1000000000000000000
	// RegexCompileFlagsDupnames names used to identify capturing subpatterns
	// need not be unique. This can be helpful for certain types of pattern when
	// it is known that only one instance of the named subpattern can ever be
	// matched.
	RegexCompileFlagsDupnames RegexCompileFlags = 0b10000000000000000000
	// RegexCompileFlagsNewlineCr: usually any newline character or character
	// sequence is recognized. If this option is set, the only recognized
	// newline character is '\r'.
	RegexCompileFlagsNewlineCr RegexCompileFlags = 0b100000000000000000000
	// RegexCompileFlagsNewlineLf: usually any newline character or character
	// sequence is recognized. If this option is set, the only recognized
	// newline character is '\n'.
	RegexCompileFlagsNewlineLf RegexCompileFlags = 0b1000000000000000000000
	// RegexCompileFlagsNewlineCrlf: usually any newline character or character
	// sequence is recognized. If this option is set, the only recognized
	// newline character sequence is '\r\n'.
	RegexCompileFlagsNewlineCrlf RegexCompileFlags = 0b1100000000000000000000
	// RegexCompileFlagsNewlineAnycrlf: usually any newline character or
	// character sequence is recognized. If this option is set, the only
	// recognized newline character sequences are '\r', '\n', and '\r\n'. Since:
	// 2.34
	RegexCompileFlagsNewlineAnycrlf RegexCompileFlags = 0b10100000000000000000000
	// RegexCompileFlagsBsrAnycrlf: usually any newline character or character
	// sequence is recognised. If this option is set, then "\R" only recognizes
	// the newline characters '\r', '\n' and '\r\n'. Since: 2.34
	RegexCompileFlagsBsrAnycrlf RegexCompileFlags = 0b100000000000000000000000
	// RegexCompileFlagsJavascriptCompat changes behaviour so that it is
	// compatible with JavaScript rather than PCRE. Since: 2.34
	RegexCompileFlagsJavascriptCompat RegexCompileFlags = 0b10000000000000000000000000
)

// RegexMatchFlags flags specifying match-time options.
type RegexMatchFlags int

const (
	// RegexMatchFlagsAnchored: pattern is forced to be "anchored", that is, it
	// is constrained to match only at the first matching point in the string
	// that is being searched. This effect can also be achieved by appropriate
	// constructs in the pattern itself such as the "^" metacharacter.
	RegexMatchFlagsAnchored RegexMatchFlags = 0b10000
	// RegexMatchFlagsNotbol specifies that first character of the string is not
	// the beginning of a line, so the circumflex metacharacter should not match
	// before it. Setting this without REGEX_MULTILINE (at compile time) causes
	// circumflex never to match. This option affects only the behaviour of the
	// circumflex metacharacter, it does not affect "\A".
	RegexMatchFlagsNotbol RegexMatchFlags = 0b10000000
	// RegexMatchFlagsNoteol specifies that the end of the subject string is not
	// the end of a line, so the dollar metacharacter should not match it nor
	// (except in multiline mode) a newline immediately before it. Setting this
	// without REGEX_MULTILINE (at compile time) causes dollar never to match.
	// This option affects only the behaviour of the dollar metacharacter, it
	// does not affect "\Z" or "\z".
	RegexMatchFlagsNoteol RegexMatchFlags = 0b100000000
	// RegexMatchFlagsNotempty: empty string is not considered to be a valid
	// match if this option is set. If there are alternatives in the pattern,
	// they are tried. If all the alternatives match the empty string, the
	// entire match fails. For example, if the pattern "a?b?" is applied to a
	// string not beginning with "a" or "b", it matches the empty string at the
	// start of the string. With this flag set, this match is not valid, so
	// GRegex searches further into the string for occurrences of "a" or "b".
	RegexMatchFlagsNotempty RegexMatchFlags = 0b10000000000
	// RegexMatchFlagsPartial turns on the partial matching feature, for more
	// documentation on partial matching see g_match_info_is_partial_match().
	RegexMatchFlagsPartial RegexMatchFlags = 0b1000000000000000
	// RegexMatchFlagsNewlineCr overrides the newline definition set when
	// creating a new #GRegex, setting the '\r' character as line terminator.
	RegexMatchFlagsNewlineCr RegexMatchFlags = 0b100000000000000000000
	// RegexMatchFlagsNewlineLf overrides the newline definition set when
	// creating a new #GRegex, setting the '\n' character as line terminator.
	RegexMatchFlagsNewlineLf RegexMatchFlags = 0b1000000000000000000000
	// RegexMatchFlagsNewlineCrlf overrides the newline definition set when
	// creating a new #GRegex, setting the '\r\n' characters sequence as line
	// terminator.
	RegexMatchFlagsNewlineCrlf RegexMatchFlags = 0b1100000000000000000000
	// RegexMatchFlagsNewlineAny overrides the newline definition set when
	// creating a new #GRegex, any Unicode newline sequence is recognised as a
	// newline. These are '\r', '\n' and '\rn', and the single characters U+000B
	// LINE TABULATION, U+000C FORM FEED (FF), U+0085 NEXT LINE (NEL), U+2028
	// LINE SEPARATOR and U+2029 PARAGRAPH SEPARATOR.
	RegexMatchFlagsNewlineAny RegexMatchFlags = 0b10000000000000000000000
	// RegexMatchFlagsNewlineAnycrlf overrides the newline definition set when
	// creating a new #GRegex; any '\r', '\n', or '\r\n' character sequence is
	// recognized as a newline. Since: 2.34
	RegexMatchFlagsNewlineAnycrlf RegexMatchFlags = 0b10100000000000000000000
	// RegexMatchFlagsBsrAnycrlf overrides the newline definition for "\R" set
	// when creating a new #GRegex; only '\r', '\n', or '\r\n' character
	// sequences are recognized as a newline by "\R". Since: 2.34
	RegexMatchFlagsBsrAnycrlf RegexMatchFlags = 0b100000000000000000000000
	// RegexMatchFlagsBsrAny overrides the newline definition for "\R" set when
	// creating a new #GRegex; any Unicode newline character or character
	// sequence are recognized as a newline by "\R". These are '\r', '\n' and
	// '\rn', and the single characters U+000B LINE TABULATION, U+000C FORM FEED
	// (FF), U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and U+2029 PARAGRAPH
	// SEPARATOR. Since: 2.34
	RegexMatchFlagsBsrAny RegexMatchFlags = 0b1000000000000000000000000
	// RegexMatchFlagsPartialSoft alias for REGEX_MATCH_PARTIAL. Since: 2.34
	RegexMatchFlagsPartialSoft RegexMatchFlags = 0b1000000000000000
	// RegexMatchFlagsPartialHard turns on the partial matching feature. In
	// contrast to to REGEX_MATCH_PARTIAL_SOFT, this stops matching as soon as a
	// partial match is found, without continuing to search for a possible
	// complete match. See g_match_info_is_partial_match() for more information.
	// Since: 2.34
	RegexMatchFlagsPartialHard RegexMatchFlags = 0b1000000000000000000000000000
	// RegexMatchFlagsNotemptyAtstart: like REGEX_MATCH_NOTEMPTY, but only
	// applied to the start of the matched string. For anchored patterns this
	// can only happen for pattern containing "\K". Since: 2.34
	RegexMatchFlagsNotemptyAtstart RegexMatchFlags = 0b10000000000000000000000000000
)

// MatchInfo is an opaque struct used to return information about matches.
type MatchInfo struct {
	native C.GMatchInfo
}

func marshalMatchInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*MatchInfo)(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (m *MatchInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&m.native)
}

// ExpandReferences returns a new string containing the text in
// @string_to_expand with references and escape sequences expanded. References
// refer to the last match done with @string against @regex and have the same
// syntax used by g_regex_replace().
//
// The @string_to_expand must be UTF-8 encoded even if REGEX_RAW was passed to
// g_regex_new().
//
// The backreferences are extracted from the string passed to the match
// function, so you cannot call this function after freeing the string.
//
// @match_info may be nil in which case @string_to_expand must not contain
// references. For instance "foo\n" does not refer to an actual pattern and '\n'
// merely will be replaced with \n character, while to expand "\0" (whole match)
// one needs the result of a match. Use g_regex_check_replacement() to find out
// whether @string_to_expand contains references.
func (matchInfo *MatchInfo) ExpandReferences(stringToExpand string) (string, error) {
	var _arg0 *C.GMatchInfo // out
	var _arg1 *C.gchar      // out
	var _cret *C.gchar      // in
	var _cerr *C.GError     // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(matchInfo))
	_arg1 = (*C.gchar)(C.CString(stringToExpand))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_match_info_expand_references(_arg0, _arg1, &_cerr)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _utf8, _goerr
}

// Fetch retrieves the text matching the @match_num'th capturing parentheses. 0
// is the full text of the match, 1 is the first paren set, 2 the second, and so
// on.
//
// If @match_num is a valid sub pattern but it didn't match anything (e.g. sub
// pattern 1, matching "b" against "(a)?b") then an empty string is returned.
//
// If the match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved string is not
// that of a set of parentheses but that of a matched substring. Substrings are
// matched in reverse order of length, so 0 is the longest match.
//
// The string is fetched from the string passed to the match function, so you
// cannot call this function after freeing the string.
func (matchInfo *MatchInfo) Fetch(matchNum int) string {
	var _arg0 *C.GMatchInfo // out
	var _arg1 C.gint        // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(matchInfo))
	_arg1 = C.gint(matchNum)

	_cret = C.g_match_info_fetch(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// FetchAll bundles up pointers to each of the matching substrings from a match
// and stores them in an array of gchar pointers. The first element in the
// returned array is the match number 0, i.e. the entire matched text.
//
// If a sub pattern didn't match anything (e.g. sub pattern 1, matching "b"
// against "(a)?b") then an empty string is inserted.
//
// If the last match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved strings are
// not that matched by sets of parentheses but that of the matched substring.
// Substrings are matched in reverse order of length, so the first one is the
// longest match.
//
// The strings are fetched from the string passed to the match function, so you
// cannot call this function after freeing the string.
func (matchInfo *MatchInfo) FetchAll() []string {
	var _arg0 *C.GMatchInfo // out
	var _cret **C.gchar

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(matchInfo))

	_cret = C.g_match_info_fetch_all(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// FetchNamed retrieves the text matching the capturing parentheses named @name.
//
// If @name is a valid sub pattern name but it didn't match anything (e.g. sub
// pattern "X", matching "b" against "(?P<X>a)?b") then an empty string is
// returned.
//
// The string is fetched from the string passed to the match function, so you
// cannot call this function after freeing the string.
func (matchInfo *MatchInfo) FetchNamed(name string) string {
	var _arg0 *C.GMatchInfo // out
	var _arg1 *C.gchar      // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(matchInfo))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_match_info_fetch_named(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// FetchNamedPos retrieves the position in bytes of the capturing parentheses
// named @name.
//
// If @name is a valid sub pattern name but it didn't match anything (e.g. sub
// pattern "X", matching "b" against "(?P<X>a)?b") then @start_pos and @end_pos
// are set to -1 and true is returned.
func (matchInfo *MatchInfo) FetchNamedPos(name string) (startPos int, endPos int, ok bool) {
	var _arg0 *C.GMatchInfo // out
	var _arg1 *C.gchar      // out
	var _arg2 C.gint        // in
	var _arg3 C.gint        // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(matchInfo))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_match_info_fetch_named_pos(_arg0, _arg1, &_arg2, &_arg3)

	var _startPos int // out
	var _endPos int   // out
	var _ok bool      // out

	_startPos = int(_arg2)
	_endPos = int(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _startPos, _endPos, _ok
}

// FetchPos retrieves the position in bytes of the @match_num'th capturing
// parentheses. 0 is the full text of the match, 1 is the first paren set, 2 the
// second, and so on.
//
// If @match_num is a valid sub pattern but it didn't match anything (e.g. sub
// pattern 1, matching "b" against "(a)?b") then @start_pos and @end_pos are set
// to -1 and true is returned.
//
// If the match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved position is
// not that of a set of parentheses but that of a matched substring. Substrings
// are matched in reverse order of length, so 0 is the longest match.
func (matchInfo *MatchInfo) FetchPos(matchNum int) (startPos int, endPos int, ok bool) {
	var _arg0 *C.GMatchInfo // out
	var _arg1 C.gint        // out
	var _arg2 C.gint        // in
	var _arg3 C.gint        // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(matchInfo))
	_arg1 = C.gint(matchNum)

	_cret = C.g_match_info_fetch_pos(_arg0, _arg1, &_arg2, &_arg3)

	var _startPos int // out
	var _endPos int   // out
	var _ok bool      // out

	_startPos = int(_arg2)
	_endPos = int(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _startPos, _endPos, _ok
}

// Free: if @match_info is not nil, calls g_match_info_unref(); otherwise does
// nothing.
func (matchInfo *MatchInfo) free() {
	var _arg0 *C.GMatchInfo // out

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(matchInfo))

	C.g_match_info_free(_arg0)
}

// MatchCount retrieves the number of matched substrings (including substring 0,
// that is the whole matched text), so 1 is returned if the pattern has no
// substrings in it and 0 is returned if the match failed.
//
// If the last match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved count is not
// that of the number of capturing parentheses but that of the number of matched
// substrings.
func (matchInfo *MatchInfo) MatchCount() int {
	var _arg0 *C.GMatchInfo // out
	var _cret C.gint        // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(matchInfo))

	_cret = C.g_match_info_get_match_count(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Regex returns #GRegex object used in @match_info. It belongs to Glib and must
// not be freed. Use g_regex_ref() if you need to keep it after you free
// @match_info object.
func (matchInfo *MatchInfo) Regex() *Regex {
	var _arg0 *C.GMatchInfo // out
	var _cret *C.GRegex     // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(matchInfo))

	_cret = C.g_match_info_get_regex(_arg0)

	var _regex *Regex // out

	_regex = (*Regex)(unsafe.Pointer(_cret))
	C.g_regex_ref(_cret)
	runtime.SetFinalizer(_regex, func(v *Regex) {
		C.g_regex_unref((*C.GRegex)(unsafe.Pointer(v)))
	})

	return _regex
}

// String returns the string searched with @match_info. This is the string
// passed to g_regex_match() or g_regex_replace() so you may not free it before
// calling this function.
func (matchInfo *MatchInfo) String() string {
	var _arg0 *C.GMatchInfo // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(matchInfo))

	_cret = C.g_match_info_get_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// IsPartialMatch: usually if the string passed to g_regex_match*() matches as
// far as it goes, but is too short to match the entire pattern, false is
// returned. There are circumstances where it might be helpful to distinguish
// this case from other cases in which there is no match.
//
// Consider, for example, an application where a human is required to type in
// data for a field with specific formatting requirements. An example might be a
// date in the form ddmmmyy, defined by the pattern
// "^\d?\d(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\d\d$". If the
// application sees the user’s keystrokes one by one, and can check that what
// has been typed so far is potentially valid, it is able to raise an error as
// soon as a mistake is made.
//
// GRegex supports the concept of partial matching by means of the
// REGEX_MATCH_PARTIAL_SOFT and REGEX_MATCH_PARTIAL_HARD flags. When they are
// used, the return code for g_regex_match() or g_regex_match_full() is, as
// usual, true for a complete match, false otherwise. But, when these functions
// return false, you can check if the match was partial calling
// g_match_info_is_partial_match().
//
// The difference between REGEX_MATCH_PARTIAL_SOFT and REGEX_MATCH_PARTIAL_HARD
// is that when a partial match is encountered with REGEX_MATCH_PARTIAL_SOFT,
// matching continues to search for a possible complete match, while with
// REGEX_MATCH_PARTIAL_HARD matching stops at the partial match. When both
// REGEX_MATCH_PARTIAL_SOFT and REGEX_MATCH_PARTIAL_HARD are set, the latter
// takes precedence.
//
// There were formerly some restrictions on the pattern for partial matching.
// The restrictions no longer apply.
//
// See pcrepartial(3) for more information on partial matching.
func (matchInfo *MatchInfo) IsPartialMatch() bool {
	var _arg0 *C.GMatchInfo // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(matchInfo))

	_cret = C.g_match_info_is_partial_match(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Matches returns whether the previous match operation succeeded.
func (matchInfo *MatchInfo) Matches() bool {
	var _arg0 *C.GMatchInfo // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(matchInfo))

	_cret = C.g_match_info_matches(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Next scans for the next match using the same parameters of the previous call
// to g_regex_match_full() or g_regex_match() that returned @match_info.
//
// The match is done on the string passed to the match function, so you cannot
// free it before calling this function.
func (matchInfo *MatchInfo) Next() error {
	var _arg0 *C.GMatchInfo // out
	var _cerr *C.GError     // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(matchInfo))

	C.g_match_info_next(_arg0, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// Ref increases reference count of @match_info by 1.
func (matchInfo *MatchInfo) ref() *MatchInfo {
	var _arg0 *C.GMatchInfo // out
	var _cret *C.GMatchInfo // in

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(matchInfo))

	_cret = C.g_match_info_ref(_arg0)

	var _matchInfo *MatchInfo // out

	_matchInfo = (*MatchInfo)(unsafe.Pointer(_cret))
	C.g_match_info_ref(_cret)
	runtime.SetFinalizer(_matchInfo, func(v *MatchInfo) {
		C.g_match_info_unref((*C.GMatchInfo)(unsafe.Pointer(v)))
	})

	return _matchInfo
}

// Unref decreases reference count of @match_info by 1. When reference count
// drops to zero, it frees all the memory associated with the match_info
// structure.
func (matchInfo *MatchInfo) unref() {
	var _arg0 *C.GMatchInfo // out

	_arg0 = (*C.GMatchInfo)(unsafe.Pointer(matchInfo))

	C.g_match_info_unref(_arg0)
}

// Regex: g_regex_*() functions implement regular expression pattern matching
// using syntax and semantics similar to Perl regular expression.
//
// Some functions accept a @start_position argument, setting it differs from
// just passing over a shortened string and setting REGEX_MATCH_NOTBOL in the
// case of a pattern that begins with any kind of lookbehind assertion. For
// example, consider the pattern "\Biss\B" which finds occurrences of "iss" in
// the middle of words. ("\B" matches only if the current position in the
// subject is not a word boundary.) When applied to the string "Mississipi" from
// the fourth byte, namely "issipi", it does not match, because "\B" is always
// false at the start of the subject, which is deemed to be a word boundary.
// However, if the entire string is passed , but with @start_position set to 4,
// it finds the second occurrence of "iss" because it is able to look behind the
// starting point to discover that it is preceded by a letter.
//
// Note that, unless you set the REGEX_RAW flag, all the strings passed to these
// functions must be encoded in UTF-8. The lengths and the positions inside the
// strings are in bytes and not in characters, so, for instance, "\xc3\xa0"
// (i.e. "à") is two bytes long but it is treated as a single character. If you
// set REGEX_RAW the strings can be non-valid UTF-8 strings and a byte is
// treated as a character, so "\xc3\xa0" is two bytes and two characters long.
//
// When matching a pattern, "\n" matches only against a "\n" character in the
// string, and "\r" matches only a "\r" character. To match any newline sequence
// use "\R". This particular group matches either the two-character sequence CR
// + LF ("\r\n"), or one of the single characters LF (linefeed, U+000A, "\n"),
// VT vertical tab, U+000B, "\v"), FF (formfeed, U+000C, "\f"), CR (carriage
// return, U+000D, "\r"), NEL (next line, U+0085), LS (line separator, U+2028),
// or PS (paragraph separator, U+2029).
//
// The behaviour of the dot, circumflex, and dollar metacharacters are affected
// by newline characters, the default is to recognize any newline character (the
// same characters recognized by "\R"). This can be changed with
// REGEX_NEWLINE_CR, REGEX_NEWLINE_LF and REGEX_NEWLINE_CRLF compile options,
// and with REGEX_MATCH_NEWLINE_ANY, REGEX_MATCH_NEWLINE_CR,
// REGEX_MATCH_NEWLINE_LF and REGEX_MATCH_NEWLINE_CRLF match options. These
// settings are also relevant when compiling a pattern if REGEX_EXTENDED is set,
// and an unescaped "#" outside a character class is encountered. This indicates
// a comment that lasts until after the next newline.
//
// When setting the G_REGEX_JAVASCRIPT_COMPAT flag, pattern syntax and pattern
// matching is changed to be compatible with the way that regular expressions
// work in JavaScript. More precisely, a lonely ']' character in the pattern is
// a syntax error; the '\x' escape only allows 0 to 2 hexadecimal digits, and
// you must use the '\u' escape sequence with 4 hex digits to specify a unicode
// codepoint instead of '\x' or 'x{....}'. If '\x' or '\u' are not followed by
// the specified number of hex digits, they match 'x' and 'u' literally; also
// '\U' always matches 'U' instead of being an error in the pattern. Finally,
// pattern matching is modified so that back references to an unset subpattern
// group produces a match with the empty string instead of an error. See
// pcreapi(3) for more information.
//
// Creating and manipulating the same #GRegex structure from different threads
// is not a problem as #GRegex does not modify its internal state between
// creation and destruction, on the other hand Info is not threadsafe.
//
// The regular expressions low-level functionalities are obtained through the
// excellent PCRE (http://www.pcre.org/) library written by Philip Hazel.
type Regex struct {
	native C.GRegex
}

func marshalRegex(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*Regex)(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *Regex) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// CaptureCount returns the number of capturing subpatterns in the pattern.
func (regex *Regex) CaptureCount() int {
	var _arg0 *C.GRegex // out
	var _cret C.gint    // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(regex))

	_cret = C.g_regex_get_capture_count(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// CompileFlags returns the compile options that @regex was created with.
//
// Depending on the version of PCRE that is used, this may or may not include
// flags set by option expressions such as `(?i)` found at the top-level within
// the compiled pattern.
func (regex *Regex) CompileFlags() RegexCompileFlags {
	var _arg0 *C.GRegex            // out
	var _cret C.GRegexCompileFlags // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(regex))

	_cret = C.g_regex_get_compile_flags(_arg0)

	var _regexCompileFlags RegexCompileFlags // out

	_regexCompileFlags = (RegexCompileFlags)(_cret)

	return _regexCompileFlags
}

// HasCrOrLf checks whether the pattern contains explicit CR or LF references.
func (regex *Regex) HasCrOrLf() bool {
	var _arg0 *C.GRegex  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(regex))

	_cret = C.g_regex_get_has_cr_or_lf(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MatchFlags returns the match options that @regex was created with.
func (regex *Regex) MatchFlags() RegexMatchFlags {
	var _arg0 *C.GRegex          // out
	var _cret C.GRegexMatchFlags // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(regex))

	_cret = C.g_regex_get_match_flags(_arg0)

	var _regexMatchFlags RegexMatchFlags // out

	_regexMatchFlags = (RegexMatchFlags)(_cret)

	return _regexMatchFlags
}

// MaxBackref returns the number of the highest back reference in the pattern,
// or 0 if the pattern does not contain back references.
func (regex *Regex) MaxBackref() int {
	var _arg0 *C.GRegex // out
	var _cret C.gint    // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(regex))

	_cret = C.g_regex_get_max_backref(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// MaxLookbehind gets the number of characters in the longest lookbehind
// assertion in the pattern. This information is useful when doing multi-segment
// matching using the partial matching facilities.
func (regex *Regex) MaxLookbehind() int {
	var _arg0 *C.GRegex // out
	var _cret C.gint    // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(regex))

	_cret = C.g_regex_get_max_lookbehind(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Pattern gets the pattern string associated with @regex, i.e. a copy of the
// string passed to g_regex_new().
func (regex *Regex) Pattern() string {
	var _arg0 *C.GRegex // out
	var _cret *C.gchar  // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(regex))

	_cret = C.g_regex_get_pattern(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// StringNumber retrieves the number of the subexpression named @name.
func (regex *Regex) StringNumber(name string) int {
	var _arg0 *C.GRegex // out
	var _arg1 *C.gchar  // out
	var _cret C.gint    // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(regex))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_regex_get_string_number(_arg0, _arg1)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Ref increases reference count of @regex by 1.
func (regex *Regex) ref() *Regex {
	var _arg0 *C.GRegex // out
	var _cret *C.GRegex // in

	_arg0 = (*C.GRegex)(unsafe.Pointer(regex))

	_cret = C.g_regex_ref(_arg0)

	var _ret *Regex // out

	_ret = (*Regex)(unsafe.Pointer(_cret))
	C.g_regex_ref(_cret)
	runtime.SetFinalizer(_ret, func(v *Regex) {
		C.g_regex_unref((*C.GRegex)(unsafe.Pointer(v)))
	})

	return _ret
}

// Unref decreases reference count of @regex by 1. When reference count drops to
// zero, it frees all the memory associated with the regex structure.
func (regex *Regex) unref() {
	var _arg0 *C.GRegex // out

	_arg0 = (*C.GRegex)(unsafe.Pointer(regex))

	C.g_regex_unref(_arg0)
}
