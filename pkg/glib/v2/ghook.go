// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
)

// #cgo pkg-config: glib-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <stdbool.h>
// #include <glib.h>
import "C"

// HookFlagMask flags used internally in the #GHook implementation.
type HookFlagMask int

const (
	// HookFlagMaskActive: set if the hook has not been destroyed
	HookFlagMaskActive HookFlagMask = 0b1
	// HookFlagMaskInCall: set if the hook is currently being run
	HookFlagMaskInCall HookFlagMask = 0b10
	// HookFlagMaskMask: a mask covering all bits reserved for hook flags; see
	// G_HOOK_FLAG_USER_SHIFT
	HookFlagMaskMask HookFlagMask = 0b1111
)

// HookDestroy destroys a #GHook, given its ID.
func HookDestroy(hookList *HookList, hookID uint32) bool {
	var arg1 *C.GHookList
	var arg2 C.gulong

	arg1 = (*C.GHookList)(hookList.Native())
	arg2 = C.gulong(hookID)

	ret := C.g_hook_destroy(arg1, arg2)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// HookDestroyLink removes one #GHook from a List, marking it inactive and
// calling g_hook_unref() on it.
func HookDestroyLink(hookList *HookList, hook *Hook) {
	var arg1 *C.GHookList
	var arg2 *C.GHook

	arg1 = (*C.GHookList)(hookList.Native())
	arg2 = (*C.GHook)(hook.Native())

	C.g_hook_destroy_link(arg1, arg2)
}

// HookFree calls the List @finalize_hook function if it exists, and frees the
// memory allocated for the #GHook.
func HookFree(hookList *HookList, hook *Hook) {
	var arg1 *C.GHookList
	var arg2 *C.GHook

	arg1 = (*C.GHookList)(hookList.Native())
	arg2 = (*C.GHook)(hook.Native())

	C.g_hook_free(arg1, arg2)
}

// HookInsertBefore inserts a #GHook into a List, before a given #GHook.
func HookInsertBefore(hookList *HookList, sibling *Hook, hook *Hook) {
	var arg1 *C.GHookList
	var arg2 *C.GHook
	var arg3 *C.GHook

	arg1 = (*C.GHookList)(hookList.Native())
	arg2 = (*C.GHook)(sibling.Native())
	arg3 = (*C.GHook)(hook.Native())

	C.g_hook_insert_before(arg1, arg2, arg3)
}

// HookPrepend prepends a #GHook on the start of a List.
func HookPrepend(hookList *HookList, hook *Hook) {
	var arg1 *C.GHookList
	var arg2 *C.GHook

	arg1 = (*C.GHookList)(hookList.Native())
	arg2 = (*C.GHook)(hook.Native())

	C.g_hook_prepend(arg1, arg2)
}

// HookUnref decrements the reference count of a #GHook. If the reference count
// falls to 0, the #GHook is removed from the List and g_hook_free() is called
// to free it.
func HookUnref(hookList *HookList, hook *Hook) {
	var arg1 *C.GHookList
	var arg2 *C.GHook

	arg1 = (*C.GHookList)(hookList.Native())
	arg2 = (*C.GHook)(hook.Native())

	C.g_hook_unref(arg1, arg2)
}

// Hook: the #GHook struct represents a single hook function in a List.
type Hook struct {
	native C.GHook
}

// WrapHook wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapHook(ptr unsafe.Pointer) *Hook {
	if ptr == nil {
		return nil
	}

	return (*Hook)(ptr)
}

func marshalHook(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapHook(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (h *Hook) Native() unsafe.Pointer {
	return unsafe.Pointer(&h.native)
}

// Data gets the field inside the struct.
func (h *Hook) Data() interface{} {
	var ret interface{}
	ret = box.Get(uintptr(h.native.data))
	return ret
}

// Next gets the field inside the struct.
func (h *Hook) Next() *Hook {
	var ret *Hook
	{
		ret = WrapHook(unsafe.Pointer(h.native.next))
	}
	return ret
}

// Prev gets the field inside the struct.
func (h *Hook) Prev() *Hook {
	var ret *Hook
	{
		ret = WrapHook(unsafe.Pointer(h.native.prev))
	}
	return ret
}

// RefCount gets the field inside the struct.
func (h *Hook) RefCount() uint {
	var ret uint
	ret = uint(h.native.ref_count)
	return ret
}

// HookID gets the field inside the struct.
func (h *Hook) HookID() uint32 {
	var ret uint32
	ret = uint32(h.native.hook_id)
	return ret
}

// Flags gets the field inside the struct.
func (h *Hook) Flags() uint {
	var ret uint
	ret = uint(h.native.flags)
	return ret
}

// Func gets the field inside the struct.
func (h *Hook) Func() interface{} {
	var ret interface{}
	ret = box.Get(uintptr(h.native._func))
	return ret
}

// CompareIds compares the ids of two #GHook elements, returning a negative
// value if the second id is greater than the first.
func (n *Hook) CompareIds(sibling *Hook) int {
	var arg0 *C.GHook
	var arg1 *C.GHook

	arg0 = (*C.GHook)(n.Native())
	arg1 = (*C.GHook)(sibling.Native())

	ret := C.g_hook_compare_ids(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// HookList: the List struct represents a list of hook functions.
type HookList struct {
	native C.GHookList
}

// WrapHookList wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapHookList(ptr unsafe.Pointer) *HookList {
	if ptr == nil {
		return nil
	}

	return (*HookList)(ptr)
}

func marshalHookList(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapHookList(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (h *HookList) Native() unsafe.Pointer {
	return unsafe.Pointer(&h.native)
}

// SeqID gets the field inside the struct.
func (h *HookList) SeqID() uint32 {
	var ret uint32
	ret = uint32(h.native.seq_id)
	return ret
}

// Hooks gets the field inside the struct.
func (h *HookList) Hooks() *Hook {
	var ret *Hook
	{
		ret = WrapHook(unsafe.Pointer(h.native.hooks))
	}
	return ret
}

// Dummy3 gets the field inside the struct.
func (h *HookList) Dummy3() interface{} {
	var ret interface{}
	ret = box.Get(uintptr(h.native.dummy3))
	return ret
}

// Dummy gets the field inside the struct.
func (h *HookList) Dummy() [2]interface{} {
	var ret [2]interface{}
	{
		cArray := ([2]gpointer)(h.native.dummy)

		for i := 0; i < 2; i++ {
			src := cArray[i]
			ret[i] = box.Get(uintptr(src))
		}
	}
	return ret
}

// Clear removes all the #GHook elements from a List.
func (h *HookList) Clear() {
	var arg0 *C.GHookList

	arg0 = (*C.GHookList)(h.Native())

	C.g_hook_list_clear(arg0)
}

// Init initializes a List. This must be called before the List is used.
func (h *HookList) Init(hookSize uint) {
	var arg0 *C.GHookList
	var arg1 C.guint

	arg0 = (*C.GHookList)(h.Native())
	arg1 = C.guint(hookSize)

	C.g_hook_list_init(arg0, arg1)
}

// Invoke calls all of the #GHook functions in a List.
func (h *HookList) Invoke(mayRecurse bool) {
	var arg0 *C.GHookList
	var arg1 C.gboolean

	arg0 = (*C.GHookList)(h.Native())
	if mayRecurse {
		arg1 = C.TRUE
	}

	C.g_hook_list_invoke(arg0, arg1)
}

// InvokeCheck calls all of the #GHook functions in a List. Any function which
// returns false is removed from the List.
func (h *HookList) InvokeCheck(mayRecurse bool) {
	var arg0 *C.GHookList
	var arg1 C.gboolean

	arg0 = (*C.GHookList)(h.Native())
	if mayRecurse {
		arg1 = C.TRUE
	}

	C.g_hook_list_invoke_check(arg0, arg1)
}

// Marshal calls a function on each valid #GHook.
func (h *HookList) Marshal(mayRecurse bool, marshaller HookMarshaller) {
	var arg0 *C.GHookList
	var arg1 C.gboolean
	var arg2 C.GHookMarshaller
	var arg3 C.gpointer

	arg0 = (*C.GHookList)(h.Native())
	if mayRecurse {
		arg1 = C.TRUE
	}
	arg2 = (*[0]byte)(C.gotk4_HookMarshaller)
	arg3 = C.gpointer(box.Assign(marshaller))

	C.g_hook_list_marshal(arg0, arg1, arg2, arg3)
}

// MarshalCheck calls a function on each valid #GHook and destroys it if the
// function returns false.
func (h *HookList) MarshalCheck(mayRecurse bool, marshaller HookCheckMarshaller) {
	var arg0 *C.GHookList
	var arg1 C.gboolean
	var arg2 C.GHookCheckMarshaller
	var arg3 C.gpointer

	arg0 = (*C.GHookList)(h.Native())
	if mayRecurse {
		arg1 = C.TRUE
	}
	arg2 = (*[0]byte)(C.gotk4_HookCheckMarshaller)
	arg3 = C.gpointer(box.Assign(marshaller))

	C.g_hook_list_marshal_check(arg0, arg1, arg2, arg3)
}
