// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"unsafe"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <stdbool.h>
// #include <glib.h>
import "C"

// HookFlagMask flags used internally in the #GHook implementation.
type HookFlagMask int

const (
	// HookFlagMaskActive: set if the hook has not been destroyed
	HookFlagMaskActive HookFlagMask = 0b1
	// HookFlagMaskInCall: set if the hook is currently being run
	HookFlagMaskInCall HookFlagMask = 0b10
	// HookFlagMaskMask: a mask covering all bits reserved for hook flags; see
	// G_HOOK_FLAG_USER_SHIFT
	HookFlagMaskMask HookFlagMask = 0b1111
)

// HookDestroy destroys a #GHook, given its ID.
func HookDestroy(hookList *HookList, hookID uint32) bool {
	var arg1 *C.GHookList
	var arg2 C.gulong

	arg1 = (*C.GHookList)(unsafe.Pointer(hookList.Native()))
	arg2 = C.gulong(hookID)

	var cret C.gboolean
	var goret1 bool

	cret = C.g_hook_destroy(hookList, hookID)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// HookDestroyLink removes one #GHook from a List, marking it inactive and
// calling g_hook_unref() on it.
func HookDestroyLink(hookList *HookList, hook *Hook) {
	var arg1 *C.GHookList
	var arg2 *C.GHook

	arg1 = (*C.GHookList)(unsafe.Pointer(hookList.Native()))
	arg2 = (*C.GHook)(unsafe.Pointer(hook.Native()))

	C.g_hook_destroy_link(hookList, hook)
}

// HookFree calls the List @finalize_hook function if it exists, and frees the
// memory allocated for the #GHook.
func HookFree(hookList *HookList, hook *Hook) {
	var arg1 *C.GHookList
	var arg2 *C.GHook

	arg1 = (*C.GHookList)(unsafe.Pointer(hookList.Native()))
	arg2 = (*C.GHook)(unsafe.Pointer(hook.Native()))

	C.g_hook_free(hookList, hook)
}

// HookInsertBefore inserts a #GHook into a List, before a given #GHook.
func HookInsertBefore(hookList *HookList, sibling *Hook, hook *Hook) {
	var arg1 *C.GHookList
	var arg2 *C.GHook
	var arg3 *C.GHook

	arg1 = (*C.GHookList)(unsafe.Pointer(hookList.Native()))
	arg2 = (*C.GHook)(unsafe.Pointer(sibling.Native()))
	arg3 = (*C.GHook)(unsafe.Pointer(hook.Native()))

	C.g_hook_insert_before(hookList, sibling, hook)
}

// HookPrepend prepends a #GHook on the start of a List.
func HookPrepend(hookList *HookList, hook *Hook) {
	var arg1 *C.GHookList
	var arg2 *C.GHook

	arg1 = (*C.GHookList)(unsafe.Pointer(hookList.Native()))
	arg2 = (*C.GHook)(unsafe.Pointer(hook.Native()))

	C.g_hook_prepend(hookList, hook)
}

// HookUnref decrements the reference count of a #GHook. If the reference count
// falls to 0, the #GHook is removed from the List and g_hook_free() is called
// to free it.
func HookUnref(hookList *HookList, hook *Hook) {
	var arg1 *C.GHookList
	var arg2 *C.GHook

	arg1 = (*C.GHookList)(unsafe.Pointer(hookList.Native()))
	arg2 = (*C.GHook)(unsafe.Pointer(hook.Native()))

	C.g_hook_unref(hookList, hook)
}

// Hook: the #GHook struct represents a single hook function in a List.
type Hook struct {
	native C.GHook
}

// WrapHook wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapHook(ptr unsafe.Pointer) *Hook {
	if ptr == nil {
		return nil
	}

	return (*Hook)(ptr)
}

func marshalHook(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapHook(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (h *Hook) Native() unsafe.Pointer {
	return unsafe.Pointer(&h.native)
}

// Data gets the field inside the struct.
func (h *Hook) Data() interface{} {
	v = C.gpointer(h.native.data)
}

// Next gets the field inside the struct.
func (h *Hook) Next() *Hook {
	v = WrapHook(unsafe.Pointer(h.native.next))
}

// Prev gets the field inside the struct.
func (h *Hook) Prev() *Hook {
	v = WrapHook(unsafe.Pointer(h.native.prev))
}

// RefCount gets the field inside the struct.
func (h *Hook) RefCount() uint {
	v = C.guint(h.native.ref_count)
}

// HookID gets the field inside the struct.
func (h *Hook) HookID() uint32 {
	v = C.gulong(h.native.hook_id)
}

// Flags gets the field inside the struct.
func (h *Hook) Flags() uint {
	v = C.guint(h.native.flags)
}

// Func gets the field inside the struct.
func (h *Hook) Func() interface{} {
	v = C.gpointer(h.native._func)
}

// CompareIds compares the ids of two #GHook elements, returning a negative
// value if the second id is greater than the first.
func (n *Hook) CompareIds(sibling *Hook) int {
	var arg0 *C.GHook
	var arg1 *C.GHook

	arg0 = (*C.GHook)(unsafe.Pointer(n.Native()))
	arg1 = (*C.GHook)(unsafe.Pointer(sibling.Native()))

	var cret C.gint
	var goret1 int

	cret = C.g_hook_compare_ids(arg0, sibling)

	goret1 = C.gint(cret)

	return goret1
}

// HookList: the List struct represents a list of hook functions.
type HookList struct {
	native C.GHookList
}

// WrapHookList wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapHookList(ptr unsafe.Pointer) *HookList {
	if ptr == nil {
		return nil
	}

	return (*HookList)(ptr)
}

func marshalHookList(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapHookList(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (h *HookList) Native() unsafe.Pointer {
	return unsafe.Pointer(&h.native)
}

// SeqID gets the field inside the struct.
func (h *HookList) SeqID() uint32 {
	v = C.gulong(h.native.seq_id)
}

// Hooks gets the field inside the struct.
func (h *HookList) Hooks() *Hook {
	v = WrapHook(unsafe.Pointer(h.native.hooks))
}

// Dummy3 gets the field inside the struct.
func (h *HookList) Dummy3() interface{} {
	v = C.gpointer(h.native.dummy3)
}

// Dummy gets the field inside the struct.
func (h *HookList) Dummy() [2]interface{} {
	v = ([2]interface{})(h.native.dummy)
}

// Clear removes all the #GHook elements from a List.
func (h *HookList) Clear() {
	var arg0 *C.GHookList

	arg0 = (*C.GHookList)(unsafe.Pointer(h.Native()))

	C.g_hook_list_clear(arg0)
}

// Init initializes a List. This must be called before the List is used.
func (h *HookList) Init(hookSize uint) {
	var arg0 *C.GHookList
	var arg1 C.guint

	arg0 = (*C.GHookList)(unsafe.Pointer(h.Native()))
	arg1 = C.guint(hookSize)

	C.g_hook_list_init(arg0, hookSize)
}

// Invoke calls all of the #GHook functions in a List.
func (h *HookList) Invoke(mayRecurse bool) {
	var arg0 *C.GHookList
	var arg1 C.gboolean

	arg0 = (*C.GHookList)(unsafe.Pointer(h.Native()))
	if mayRecurse {
		arg1 = C.gboolean(1)
	}

	C.g_hook_list_invoke(arg0, mayRecurse)
}

// InvokeCheck calls all of the #GHook functions in a List. Any function which
// returns false is removed from the List.
func (h *HookList) InvokeCheck(mayRecurse bool) {
	var arg0 *C.GHookList
	var arg1 C.gboolean

	arg0 = (*C.GHookList)(unsafe.Pointer(h.Native()))
	if mayRecurse {
		arg1 = C.gboolean(1)
	}

	C.g_hook_list_invoke_check(arg0, mayRecurse)
}

// Marshal calls a function on each valid #GHook.
func (h *HookList) Marshal(mayRecurse bool, marshaller HookMarshaller) {
	var arg0 *C.GHookList

	arg0 = (*C.GHookList)(unsafe.Pointer(h.Native()))

	C.g_hook_list_marshal(arg0, mayRecurse, marshaller, marshalData)
}

// MarshalCheck calls a function on each valid #GHook and destroys it if the
// function returns false.
func (h *HookList) MarshalCheck(mayRecurse bool, marshaller HookCheckMarshaller) {
	var arg0 *C.GHookList

	arg0 = (*C.GHookList)(unsafe.Pointer(h.Native()))

	C.g_hook_list_marshal_check(arg0, mayRecurse, marshaller, marshalData)
}
