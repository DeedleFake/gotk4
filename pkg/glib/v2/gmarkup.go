// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <glib.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_markup_parse_context_get_type()), F: marshalMarkupParseContext},
	})
}

// MarkupError: error codes returned by markup parsing.
type MarkupError int

const (
	// MarkupErrorBadUTF8: text being parsed was not valid UTF-8
	MarkupErrorBadUTF8 MarkupError = 0
	// MarkupErrorEmpty: document contained nothing, or only whitespace
	MarkupErrorEmpty MarkupError = 1
	// MarkupErrorParse: document was ill-formed
	MarkupErrorParse MarkupError = 2
	// MarkupErrorUnknownElement: error should be set by Parser functions;
	// element wasn't known
	MarkupErrorUnknownElement MarkupError = 3
	// MarkupErrorUnknownAttribute: error should be set by Parser functions;
	// attribute wasn't known
	MarkupErrorUnknownAttribute MarkupError = 4
	// MarkupErrorInvalidContent: error should be set by Parser functions;
	// content was invalid
	MarkupErrorInvalidContent MarkupError = 5
	// MarkupErrorMissingAttribute: error should be set by Parser functions; a
	// required attribute was missing
	MarkupErrorMissingAttribute MarkupError = 6
)

// MarkupCollectType: a mixed enumerated type and flags field. You must specify
// one type (string, strdup, boolean, tristate). Additionally, you may
// optionally bitwise OR the type with the flag G_MARKUP_COLLECT_OPTIONAL.
//
// It is likely that this enum will be extended in the future to support other
// types.
type MarkupCollectType int

const (
	// MarkupCollectTypeInvalid: used to terminate the list of attributes to
	// collect
	MarkupCollectTypeInvalid MarkupCollectType = 0
	// MarkupCollectTypeString: collect the string pointer directly from the
	// attribute_values[] array. Expects a parameter of type (const char **). If
	// G_MARKUP_COLLECT_OPTIONAL is specified and the attribute isn't present
	// then the pointer will be set to nil
	MarkupCollectTypeString MarkupCollectType = 1
	// MarkupCollectTypeStrdup as with G_MARKUP_COLLECT_STRING, but expects a
	// parameter of type (char **) and g_strdup()s the returned pointer. The
	// pointer must be freed with g_free()
	MarkupCollectTypeStrdup MarkupCollectType = 2
	// MarkupCollectTypeBoolean expects a parameter of type (gboolean *) and
	// parses the attribute value as a boolean. Sets false if the attribute
	// isn't present. Valid boolean values consist of (case-insensitive)
	// "false", "f", "no", "n", "0" and "true", "t", "yes", "y", "1"
	MarkupCollectTypeBoolean MarkupCollectType = 3
	// MarkupCollectTypeTristate as with G_MARKUP_COLLECT_BOOLEAN, but in the
	// case of a missing attribute a value is set that compares equal to neither
	// false nor true G_MARKUP_COLLECT_OPTIONAL is implied
	MarkupCollectTypeTristate MarkupCollectType = 4
	// MarkupCollectTypeOptional: can be bitwise ORed with the other fields. If
	// present, allows the attribute not to appear. A default value is set
	// depending on what value type is used
	MarkupCollectTypeOptional MarkupCollectType = 65536
)

// MarkupParseFlags flags that affect the behaviour of the parser.
type MarkupParseFlags int

const (
	// MarkupParseFlagsDoNotUseThisUnsupportedFlag: flag you should not use
	MarkupParseFlagsDoNotUseThisUnsupportedFlag MarkupParseFlags = 1
	// MarkupParseFlagsTreatCdataAsText: when this flag is set, CDATA marked
	// sections are not passed literally to the @passthrough function of the
	// parser. Instead, the content of the section (without the `<![CDATA[` and
	// `]]>`) is passed to the @text function. This flag was added in GLib 2.12
	MarkupParseFlagsTreatCdataAsText MarkupParseFlags = 2
	// MarkupParseFlagsPrefixErrorPosition: normally errors caught by GMarkup
	// itself have line/column information prefixed to them to let the caller
	// know the location of the error. When this flag is set the location
	// information is also prefixed to errors generated by the Parser
	// implementation functions
	MarkupParseFlagsPrefixErrorPosition MarkupParseFlags = 4
	// MarkupParseFlagsIgnoreQualified: ignore (don't report) qualified
	// attributes and tags, along with their contents. A qualified attribute or
	// tag is one that contains ':' in its name (ie: is in another namespace).
	// Since: 2.40.
	MarkupParseFlagsIgnoreQualified MarkupParseFlags = 8
)

// MarkupEscapeText escapes text so that the markup parser will parse it
// verbatim. Less than, greater than, ampersand, etc. are replaced with the
// corresponding entities. This function would typically be used when writing
// out a file to be parsed with the markup parser.
//
// Note that this function doesn't protect whitespace and line endings from
// being processed according to the XML rules for normalization of line endings
// and attribute values.
//
// Note also that this function will produce character references in the range
// of &#x1; ... &#x1f; for all control sequences except for tabstop, newline and
// carriage return. The character references in this range are not valid XML
// 1.0, but they are valid XML 1.1 and will be accepted by the GMarkup parser.
func MarkupEscapeText(text string, length int) {
	var arg1 *C.gchar
	var arg2 C.gssize

	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(length)

	C.g_markup_escape_text(arg1, arg2)
}

// MarkupParseContext: a parse context is used to parse a stream of bytes that
// you expect to contain marked-up text.
//
// See g_markup_parse_context_new(), Parser, and so on for more details.
type MarkupParseContext struct {
	native C.GMarkupParseContext
}

// WrapMarkupParseContext wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMarkupParseContext(ptr unsafe.Pointer) *MarkupParseContext {
	if ptr == nil {
		return nil
	}

	return (*MarkupParseContext)(ptr)
}

func marshalMarkupParseContext(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapMarkupParseContext(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (m *MarkupParseContext) Native() unsafe.Pointer {
	return unsafe.Pointer(&m.native)
}

// EndParse signals to the ParseContext that all data has been fed into the
// parse context with g_markup_parse_context_parse().
//
// This function reports an error if the document isn't complete, for example if
// elements are still open.
func (c *MarkupParseContext) EndParse(c *MarkupParseContext) error {
	var arg0 *C.GMarkupParseContext

	arg0 = (*C.GMarkupParseContext)(unsafe.Pointer(c.Native()))

	var errout *C.GError
	var err error

	C.g_markup_parse_context_end_parse(arg0, &errout)

	err = gerror.Take(unsafe.Pointer(errout))

	return err
}

// Free frees a ParseContext.
//
// This function can't be called from inside one of the Parser functions or
// while a subparser is pushed.
func (c *MarkupParseContext) Free(c *MarkupParseContext) {
	var arg0 *C.GMarkupParseContext

	arg0 = (*C.GMarkupParseContext)(unsafe.Pointer(c.Native()))

	C.g_markup_parse_context_free(arg0)
}

// Element retrieves the name of the currently open element.
//
// If called from the start_element or end_element handlers this will give the
// element_name as passed to those functions. For the parent elements, see
// g_markup_parse_context_get_element_stack().
func (c *MarkupParseContext) Element(c *MarkupParseContext) {
	var arg0 *C.GMarkupParseContext

	arg0 = (*C.GMarkupParseContext)(unsafe.Pointer(c.Native()))

	C.g_markup_parse_context_get_element(arg0)
}

// ElementStack retrieves the element stack from the internal state of the
// parser.
//
// The returned List is a list of strings where the first item is the currently
// open tag (as would be returned by g_markup_parse_context_get_element()) and
// the next item is its immediate parent.
//
// This function is intended to be used in the start_element and end_element
// handlers where g_markup_parse_context_get_element() would merely return the
// name of the element that is being processed.
func (c *MarkupParseContext) ElementStack(c *MarkupParseContext) {
	var arg0 *C.GMarkupParseContext

	arg0 = (*C.GMarkupParseContext)(unsafe.Pointer(c.Native()))

	C.g_markup_parse_context_get_element_stack(arg0)
}

// Position retrieves the current line number and the number of the character on
// that line. Intended for use in error messages; there are no strict semantics
// for what constitutes the "current" line number other than "the best number we
// could come up with for error messages."
func (c *MarkupParseContext) Position(c *MarkupParseContext) (lineNumber int, charNumber int) {
	var arg0 *C.GMarkupParseContext

	arg0 = (*C.GMarkupParseContext)(unsafe.Pointer(c.Native()))

	var arg1 C.gint
	var lineNumber int
	var arg2 C.gint
	var charNumber int

	C.g_markup_parse_context_get_position(arg0, &arg1, &arg2)

	lineNumber = int(&arg1)
	charNumber = int(&arg2)

	return lineNumber, charNumber
}

// UserData returns the user_data associated with @context.
//
// This will either be the user_data that was provided to
// g_markup_parse_context_new() or to the most recent call of
// g_markup_parse_context_push().
func (c *MarkupParseContext) UserData(c *MarkupParseContext) {
	var arg0 *C.GMarkupParseContext

	arg0 = (*C.GMarkupParseContext)(unsafe.Pointer(c.Native()))

	C.g_markup_parse_context_get_user_data(arg0)
}

// Parse: feed some data to the ParseContext.
//
// The data need not be valid UTF-8; an error will be signaled if it's invalid.
// The data need not be an entire document; you can feed a document into the
// parser incrementally, via multiple calls to this function. Typically, as you
// receive data from a network connection or file, you feed each received chunk
// of data into this function, aborting the process if an error occurs. Once an
// error is reported, no further data may be fed to the ParseContext; all errors
// are fatal.
func (c *MarkupParseContext) Parse(c *MarkupParseContext, text string, textLen int) error {
	var arg0 *C.GMarkupParseContext
	var arg1 *C.gchar
	var arg2 C.gssize

	arg0 = (*C.GMarkupParseContext)(unsafe.Pointer(c.Native()))
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(textLen)

	var errout *C.GError
	var err error

	C.g_markup_parse_context_parse(arg0, arg1, arg2, &errout)

	err = gerror.Take(unsafe.Pointer(errout))

	return err
}

// Pop completes the process of a temporary sub-parser redirection.
//
// This function exists to collect the user_data allocated by a matching call to
// g_markup_parse_context_push(). It must be called in the end_element handler
// corresponding to the start_element handler during which
// g_markup_parse_context_push() was called. You must not call this function
// from the error callback -- the @user_data is provided directly to the
// callback in that case.
//
// This function is not intended to be directly called by users interested in
// invoking subparsers. Instead, it is intended to be used by the subparsers
// themselves to implement a higher-level interface.
func (c *MarkupParseContext) Pop(c *MarkupParseContext) {
	var arg0 *C.GMarkupParseContext

	arg0 = (*C.GMarkupParseContext)(unsafe.Pointer(c.Native()))

	C.g_markup_parse_context_pop(arg0)
}

// Ref increases the reference count of @context.
func (c *MarkupParseContext) Ref(c *MarkupParseContext) {
	var arg0 *C.GMarkupParseContext

	arg0 = (*C.GMarkupParseContext)(unsafe.Pointer(c.Native()))

	C.g_markup_parse_context_ref(arg0)
}

// Unref decreases the reference count of @context. When its reference count
// drops to 0, it is freed.
func (c *MarkupParseContext) Unref(c *MarkupParseContext) {
	var arg0 *C.GMarkupParseContext

	arg0 = (*C.GMarkupParseContext)(unsafe.Pointer(c.Native()))

	C.g_markup_parse_context_unref(arg0)
}
