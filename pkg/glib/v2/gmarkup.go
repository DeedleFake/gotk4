// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <glib.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_markup_parse_context_get_type()), F: marshalMarkupParseContext},
	})
}

// MarkupError: error codes returned by markup parsing.
type MarkupError int

const (
	// BadUTF8: text being parsed was not valid UTF-8
	MarkupErrorBadUTF8 MarkupError = 0
	// empty: document contained nothing, or only whitespace
	MarkupErrorEmpty MarkupError = 1
	// parse: document was ill-formed
	MarkupErrorParse MarkupError = 2
	// UnknownElement: error should be set by Parser functions; element wasn't
	// known
	MarkupErrorUnknownElement MarkupError = 3
	// UnknownAttribute: error should be set by Parser functions; attribute
	// wasn't known
	MarkupErrorUnknownAttribute MarkupError = 4
	// InvalidContent: error should be set by Parser functions; content was
	// invalid
	MarkupErrorInvalidContent MarkupError = 5
	// MissingAttribute: error should be set by Parser functions; a required
	// attribute was missing
	MarkupErrorMissingAttribute MarkupError = 6
)

// MarkupCollectType: a mixed enumerated type and flags field. You must specify
// one type (string, strdup, boolean, tristate). Additionally, you may
// optionally bitwise OR the type with the flag G_MARKUP_COLLECT_OPTIONAL.
//
// It is likely that this enum will be extended in the future to support other
// types.
type MarkupCollectType int

const (
	// MarkupCollectTypeInvalid: used to terminate the list of attributes to
	// collect
	MarkupCollectTypeInvalid MarkupCollectType = 0b0
	// MarkupCollectTypeString: collect the string pointer directly from the
	// attribute_values[] array. Expects a parameter of type (const char **). If
	// G_MARKUP_COLLECT_OPTIONAL is specified and the attribute isn't present
	// then the pointer will be set to nil
	MarkupCollectTypeString MarkupCollectType = 0b1
	// MarkupCollectTypeStrdup as with G_MARKUP_COLLECT_STRING, but expects a
	// parameter of type (char **) and g_strdup()s the returned pointer. The
	// pointer must be freed with g_free()
	MarkupCollectTypeStrdup MarkupCollectType = 0b10
	// MarkupCollectTypeBoolean expects a parameter of type (gboolean *) and
	// parses the attribute value as a boolean. Sets false if the attribute
	// isn't present. Valid boolean values consist of (case-insensitive)
	// "false", "f", "no", "n", "0" and "true", "t", "yes", "y", "1"
	MarkupCollectTypeBoolean MarkupCollectType = 0b11
	// MarkupCollectTypeTristate as with G_MARKUP_COLLECT_BOOLEAN, but in the
	// case of a missing attribute a value is set that compares equal to neither
	// false nor true G_MARKUP_COLLECT_OPTIONAL is implied
	MarkupCollectTypeTristate MarkupCollectType = 0b100
	// MarkupCollectTypeOptional: can be bitwise ORed with the other fields. If
	// present, allows the attribute not to appear. A default value is set
	// depending on what value type is used
	MarkupCollectTypeOptional MarkupCollectType = 0b10000000000000000
)

// MarkupParseFlags flags that affect the behaviour of the parser.
type MarkupParseFlags int

const (
	// MarkupParseFlagsDoNotUseThisUnsupportedFlag: flag you should not use
	MarkupParseFlagsDoNotUseThisUnsupportedFlag MarkupParseFlags = 0b1
	// MarkupParseFlagsTreatCdataAsText: when this flag is set, CDATA marked
	// sections are not passed literally to the @passthrough function of the
	// parser. Instead, the content of the section (without the `<![CDATA[` and
	// `]]>`) is passed to the @text function. This flag was added in GLib 2.12
	MarkupParseFlagsTreatCdataAsText MarkupParseFlags = 0b10
	// MarkupParseFlagsPrefixErrorPosition: normally errors caught by GMarkup
	// itself have line/column information prefixed to them to let the caller
	// know the location of the error. When this flag is set the location
	// information is also prefixed to errors generated by the Parser
	// implementation functions
	MarkupParseFlagsPrefixErrorPosition MarkupParseFlags = 0b100
	// MarkupParseFlagsIgnoreQualified: ignore (don't report) qualified
	// attributes and tags, along with their contents. A qualified attribute or
	// tag is one that contains ':' in its name (ie: is in another namespace).
	// Since: 2.40.
	MarkupParseFlagsIgnoreQualified MarkupParseFlags = 0b1000
)

// MarkupEscapeText escapes text so that the markup parser will parse it
// verbatim. Less than, greater than, ampersand, etc. are replaced with the
// corresponding entities. This function would typically be used when writing
// out a file to be parsed with the markup parser.
//
// Note that this function doesn't protect whitespace and line endings from
// being processed according to the XML rules for normalization of line endings
// and attribute values.
//
// Note also that this function will produce character references in the range
// of &#x1; ... &#x1f; for all control sequences except for tabstop, newline and
// carriage return. The character references in this range are not valid XML
// 1.0, but they are valid XML 1.1 and will be accepted by the GMarkup parser.
func MarkupEscapeText(text string, length int) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(length)

	_cret = C.g_markup_escape_text(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// MarkupParseContext: a parse context is used to parse a stream of bytes that
// you expect to contain marked-up text.
//
// See g_markup_parse_context_new(), Parser, and so on for more details.
type MarkupParseContext C.GMarkupParseContext

// WrapMarkupParseContext wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMarkupParseContext(ptr unsafe.Pointer) *MarkupParseContext {
	return (*MarkupParseContext)(ptr)
}

func marshalMarkupParseContext(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*MarkupParseContext)(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (m *MarkupParseContext) Native() unsafe.Pointer {
	return unsafe.Pointer(m)
}

// EndParse decreases the reference count of @context. When its reference count
// drops to 0, it is freed.
func (c *MarkupParseContext) EndParse() error {
	var _arg0 *C.GMarkupParseContext // out
	var _cerr *C.GError              // in

	_arg0 = (*C.GMarkupParseContext)(unsafe.Pointer(c.Native()))

	C.g_markup_parse_context_end_parse(_arg0, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// Free decreases the reference count of @context. When its reference count
// drops to 0, it is freed.
func (c *MarkupParseContext) Free() {
	var _arg0 *C.GMarkupParseContext // out

	_arg0 = (*C.GMarkupParseContext)(unsafe.Pointer(c.Native()))

	C.g_markup_parse_context_free(_arg0)
}

// Element decreases the reference count of @context. When its reference count
// drops to 0, it is freed.
func (c *MarkupParseContext) Element() string {
	var _arg0 *C.GMarkupParseContext // out
	var _cret *C.gchar               // in

	_arg0 = (*C.GMarkupParseContext)(unsafe.Pointer(c.Native()))

	_cret = C.g_markup_parse_context_get_element(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Position decreases the reference count of @context. When its reference count
// drops to 0, it is freed.
func (c *MarkupParseContext) Position() (lineNumber int, charNumber int) {
	var _arg0 *C.GMarkupParseContext // out
	var _arg1 C.gint                 // in
	var _arg2 C.gint                 // in

	_arg0 = (*C.GMarkupParseContext)(unsafe.Pointer(c.Native()))

	C.g_markup_parse_context_get_position(_arg0, &_arg1, &_arg2)

	var _lineNumber int // out
	var _charNumber int // out

	_lineNumber = int(_arg1)
	_charNumber = int(_arg2)

	return _lineNumber, _charNumber
}

// UserData decreases the reference count of @context. When its reference count
// drops to 0, it is freed.
func (c *MarkupParseContext) UserData() interface{} {
	var _arg0 *C.GMarkupParseContext // out
	var _cret C.gpointer             // in

	_arg0 = (*C.GMarkupParseContext)(unsafe.Pointer(c.Native()))

	_cret = C.g_markup_parse_context_get_user_data(_arg0)

	var _gpointer interface{} // out

	_gpointer = box.Get(uintptr(_cret))

	return _gpointer
}

// Parse decreases the reference count of @context. When its reference count
// drops to 0, it is freed.
func (c *MarkupParseContext) Parse(text string, textLen int) error {
	var _arg0 *C.GMarkupParseContext // out
	var _arg1 *C.gchar               // out
	var _arg2 C.gssize               // out
	var _cerr *C.GError              // in

	_arg0 = (*C.GMarkupParseContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(textLen)

	C.g_markup_parse_context_parse(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// Pop decreases the reference count of @context. When its reference count drops
// to 0, it is freed.
func (c *MarkupParseContext) Pop() interface{} {
	var _arg0 *C.GMarkupParseContext // out
	var _cret C.gpointer             // in

	_arg0 = (*C.GMarkupParseContext)(unsafe.Pointer(c.Native()))

	_cret = C.g_markup_parse_context_pop(_arg0)

	var _gpointer interface{} // out

	_gpointer = box.Get(uintptr(_cret))

	return _gpointer
}

// Push decreases the reference count of @context. When its reference count
// drops to 0, it is freed.
func (c *MarkupParseContext) Push(parser *MarkupParser, userData interface{}) {
	var _arg0 *C.GMarkupParseContext // out
	var _arg1 *C.GMarkupParser       // out
	var _arg2 C.gpointer             // out

	_arg0 = (*C.GMarkupParseContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GMarkupParser)(unsafe.Pointer(parser.Native()))
	_arg2 = C.gpointer(box.Assign(unsafe.Pointer(userData)))

	C.g_markup_parse_context_push(_arg0, _arg1, _arg2)
}

// Ref decreases the reference count of @context. When its reference count drops
// to 0, it is freed.
func (c *MarkupParseContext) Ref() *MarkupParseContext {
	var _arg0 *C.GMarkupParseContext // out
	var _cret *C.GMarkupParseContext // in

	_arg0 = (*C.GMarkupParseContext)(unsafe.Pointer(c.Native()))

	_cret = C.g_markup_parse_context_ref(_arg0)

	var _markupParseContext *MarkupParseContext // out

	_markupParseContext = (*MarkupParseContext)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_markupParseContext, func(v **MarkupParseContext) {
		C.free(unsafe.Pointer(v))
	})

	return _markupParseContext
}

// Unref decreases the reference count of @context. When its reference count
// drops to 0, it is freed.
func (c *MarkupParseContext) Unref() {
	var _arg0 *C.GMarkupParseContext // out

	_arg0 = (*C.GMarkupParseContext)(unsafe.Pointer(c.Native()))

	C.g_markup_parse_context_unref(_arg0)
}

// MarkupParser: any of the fields in Parser can be nil, in which case they will
// be ignored. Except for the @error function, any of these callbacks can set an
// error; in particular the G_MARKUP_ERROR_UNKNOWN_ELEMENT,
// G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE, and G_MARKUP_ERROR_INVALID_CONTENT errors
// are intended to be set from these callbacks. If you set an error from a
// callback, g_markup_parse_context_parse() will report that error back to its
// caller.
type MarkupParser C.GMarkupParser

// WrapMarkupParser wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMarkupParser(ptr unsafe.Pointer) *MarkupParser {
	return (*MarkupParser)(ptr)
}

// Native returns the underlying C source pointer.
func (m *MarkupParser) Native() unsafe.Pointer {
	return unsafe.Pointer(m)
}
