// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"unsafe"
)

// #cgo pkg-config: glib-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <glib.h>
import "C"

// Access: a wrapper for the POSIX access() function. This function is used to
// test a pathname for one or several of read, write or execute permissions, or
// just existence.
//
// On Windows, the file protection mechanism is not at all POSIX-like, and the
// underlying function in the C library only checks the FAT-style READONLY
// attribute, and does not look at the ACL of a file at all. This function is
// this in practise almost useless on Windows. Software that needs to handle
// file permissions on Windows more exactly should use the Win32 API.
//
// See your C library manual for more details about access().
func Access(filename string, mode int) int {
	var arg1 *C.gchar
	var arg2 C.int

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(mode)

	ret := C.g_access(arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Chdir: a wrapper for the POSIX chdir() function. The function changes the
// current directory of the process to @path.
//
// See your C library manual for more details about chdir().
func Chdir(path string) int {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_chdir(arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Close: this wraps the close() call; in case of error, errno will be
// preserved, but the error will also be stored as a #GError in @error.
//
// Besides using #GError, there is another major reason to prefer this function
// over the call provided by the system; on Unix, it will attempt to correctly
// handle EINTR, which has platform-specific semantics.
func Close(fd int) error {
	var arg1 C.gint
	var gError *C.GError

	arg1 = C.gint(fd)

	ret := C.g_close(arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// Rmdir: a wrapper for the POSIX rmdir() function. The rmdir() function deletes
// a directory from the filesystem.
//
// See your C library manual for more details about how rmdir() works on your
// system.
func Rmdir(filename string) int {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_rmdir(arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Unlink: a wrapper for the POSIX unlink() function. The unlink() function
// deletes a name from the filesystem. If this was the last link to the file and
// no processes have it opened, the diskspace occupied by the file is freed.
//
// See your C library manual for more details about unlink(). Note that on
// Windows, it is in general not possible to delete files that are open to some
// process, or mapped into memory.
func Unlink(filename string) int {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_unlink(arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// StatBuf: a type corresponding to the appropriate struct type for the stat()
// system call, depending on the platform and/or compiler being used.
//
// See g_stat() for more information.
type StatBuf struct {
	native C.GStatBuf
}

// WrapStatBuf wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapStatBuf(ptr unsafe.Pointer) *StatBuf {
	if ptr == nil {
		return nil
	}

	return (*StatBuf)(ptr)
}

func marshalStatBuf(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapStatBuf(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *StatBuf) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}
