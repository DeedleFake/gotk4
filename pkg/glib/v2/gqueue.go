// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0 glib-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <glib.h>
import "C"

// Queue contains the public fields of a [Queue][glib-Double-ended-Queues].
type Queue struct {
	native C.GQueue
}

// WrapQueue wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapQueue(ptr unsafe.Pointer) *Queue {
	if ptr == nil {
		return nil
	}

	return (*Queue)(ptr)
}

func marshalQueue(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapQueue(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (q *Queue) Native() unsafe.Pointer {
	return unsafe.Pointer(&q.native)
}

// Clear removes all the elements in @queue. If queue elements contain
// dynamically-allocated memory, they should be freed first.
func (q *Queue) Clear() {
	var _arg0 *C.GQueue // out

	_arg0 = (*C.GQueue)(unsafe.Pointer(q.Native()))

	C.g_queue_clear(_arg0)
}

// DeleteLink removes @link_ from @queue and frees it.
//
// @link_ must be part of @queue.
func (q *Queue) DeleteLink(link_ *List) {
	var _arg0 *C.GQueue // out
	var _arg1 *C.GList  // out

	_arg0 = (*C.GQueue)(unsafe.Pointer(q.Native()))
	_arg1 = (*C.GList)(unsafe.Pointer(link_.Native()))

	C.g_queue_delete_link(_arg0, _arg1)
}

// Foreach calls @func for each element in the queue passing @user_data to the
// function.
//
// It is safe for @func to remove the element from @queue, but it must not
// modify any part of the queue after that element.
func (q *Queue) Foreach(fn Func) {
	var _arg0 *C.GQueue // out
	var _arg1 C.GFunc   // out
	var _arg2 C.gpointer

	_arg0 = (*C.GQueue)(unsafe.Pointer(q.Native()))
	_arg1 = (*[0]byte)(C.gotk4_Func)
	_arg2 = C.gpointer(box.Assign(fn))

	C.g_queue_foreach(_arg0, _arg1, _arg2)
}

// Free frees the memory allocated for the #GQueue. Only call this function if
// @queue was created with g_queue_new(). If queue elements contain
// dynamically-allocated memory, they should be freed first.
//
// If queue elements contain dynamically-allocated memory, you should either use
// g_queue_free_full() or free them manually first.
func (q *Queue) Free() {
	var _arg0 *C.GQueue // out

	_arg0 = (*C.GQueue)(unsafe.Pointer(q.Native()))

	C.g_queue_free(_arg0)
}

// Length returns the number of items in @queue.
func (q *Queue) Length() uint {
	var _arg0 *C.GQueue // out

	_arg0 = (*C.GQueue)(unsafe.Pointer(q.Native()))

	var _cret C.guint // in

	_cret = C.g_queue_get_length(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// Index returns the position of the first element in @queue which contains
// @data.
func (q *Queue) Index(data interface{}) int {
	var _arg0 *C.GQueue  // out
	var _arg1 C.gpointer // out

	_arg0 = (*C.GQueue)(unsafe.Pointer(q.Native()))
	_arg1 = C.gpointer(data)

	var _cret C.gint // in

	_cret = C.g_queue_index(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Init: a statically-allocated #GQueue must be initialized with this function
// before it can be used. Alternatively you can initialize it with QUEUE_INIT.
// It is not necessary to initialize queues created with g_queue_new().
func (q *Queue) Init() {
	var _arg0 *C.GQueue // out

	_arg0 = (*C.GQueue)(unsafe.Pointer(q.Native()))

	C.g_queue_init(_arg0)
}

// InsertAfter inserts @data into @queue after @sibling.
//
// @sibling must be part of @queue. Since GLib 2.44 a nil sibling pushes the
// data at the head of the queue.
func (q *Queue) InsertAfter(sibling *List, data interface{}) {
	var _arg0 *C.GQueue  // out
	var _arg1 *C.GList   // out
	var _arg2 C.gpointer // out

	_arg0 = (*C.GQueue)(unsafe.Pointer(q.Native()))
	_arg1 = (*C.GList)(unsafe.Pointer(sibling.Native()))
	_arg2 = C.gpointer(data)

	C.g_queue_insert_after(_arg0, _arg1, _arg2)
}

// InsertAfterLink inserts @link_ into @queue after @sibling.
//
// @sibling must be part of @queue.
func (q *Queue) InsertAfterLink(sibling *List, link_ *List) {
	var _arg0 *C.GQueue // out
	var _arg1 *C.GList  // out
	var _arg2 *C.GList  // out

	_arg0 = (*C.GQueue)(unsafe.Pointer(q.Native()))
	_arg1 = (*C.GList)(unsafe.Pointer(sibling.Native()))
	_arg2 = (*C.GList)(unsafe.Pointer(link_.Native()))

	C.g_queue_insert_after_link(_arg0, _arg1, _arg2)
}

// InsertBefore inserts @data into @queue before @sibling.
//
// @sibling must be part of @queue. Since GLib 2.44 a nil sibling pushes the
// data at the tail of the queue.
func (q *Queue) InsertBefore(sibling *List, data interface{}) {
	var _arg0 *C.GQueue  // out
	var _arg1 *C.GList   // out
	var _arg2 C.gpointer // out

	_arg0 = (*C.GQueue)(unsafe.Pointer(q.Native()))
	_arg1 = (*C.GList)(unsafe.Pointer(sibling.Native()))
	_arg2 = C.gpointer(data)

	C.g_queue_insert_before(_arg0, _arg1, _arg2)
}

// InsertBeforeLink inserts @link_ into @queue before @sibling.
//
// @sibling must be part of @queue.
func (q *Queue) InsertBeforeLink(sibling *List, link_ *List) {
	var _arg0 *C.GQueue // out
	var _arg1 *C.GList  // out
	var _arg2 *C.GList  // out

	_arg0 = (*C.GQueue)(unsafe.Pointer(q.Native()))
	_arg1 = (*C.GList)(unsafe.Pointer(sibling.Native()))
	_arg2 = (*C.GList)(unsafe.Pointer(link_.Native()))

	C.g_queue_insert_before_link(_arg0, _arg1, _arg2)
}

// InsertSorted inserts @data into @queue using @func to determine the new
// position.
func (q *Queue) InsertSorted(data interface{}, fn CompareDataFunc) {
	var _arg0 *C.GQueue          // out
	var _arg1 C.gpointer         // out
	var _arg2 C.GCompareDataFunc // out
	var _arg3 C.gpointer

	_arg0 = (*C.GQueue)(unsafe.Pointer(q.Native()))
	_arg1 = C.gpointer(data)
	_arg2 = (*[0]byte)(C.gotk4_CompareDataFunc)
	_arg3 = C.gpointer(box.Assign(fn))

	C.g_queue_insert_sorted(_arg0, _arg1, _arg2, _arg3)
}

// IsEmpty returns true if the queue is empty.
func (q *Queue) IsEmpty() bool {
	var _arg0 *C.GQueue // out

	_arg0 = (*C.GQueue)(unsafe.Pointer(q.Native()))

	var _cret C.gboolean // in

	_cret = C.g_queue_is_empty(_arg0)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// LinkIndex returns the position of @link_ in @queue.
func (q *Queue) LinkIndex(link_ *List) int {
	var _arg0 *C.GQueue // out
	var _arg1 *C.GList  // out

	_arg0 = (*C.GQueue)(unsafe.Pointer(q.Native()))
	_arg1 = (*C.GList)(unsafe.Pointer(link_.Native()))

	var _cret C.gint // in

	_cret = C.g_queue_link_index(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// PeekHead returns the first element of the queue.
func (q *Queue) PeekHead() interface{} {
	var _arg0 *C.GQueue // out

	_arg0 = (*C.GQueue)(unsafe.Pointer(q.Native()))

	var _cret C.gpointer // in

	_cret = C.g_queue_peek_head(_arg0)

	var _gpointer interface{} // out

	_gpointer = (interface{})(_cret)

	return _gpointer
}

// PeekNth returns the @n'th element of @queue.
func (q *Queue) PeekNth(n uint) interface{} {
	var _arg0 *C.GQueue // out
	var _arg1 C.guint   // out

	_arg0 = (*C.GQueue)(unsafe.Pointer(q.Native()))
	_arg1 = C.guint(n)

	var _cret C.gpointer // in

	_cret = C.g_queue_peek_nth(_arg0, _arg1)

	var _gpointer interface{} // out

	_gpointer = (interface{})(_cret)

	return _gpointer
}

// PeekTail returns the last element of the queue.
func (q *Queue) PeekTail() interface{} {
	var _arg0 *C.GQueue // out

	_arg0 = (*C.GQueue)(unsafe.Pointer(q.Native()))

	var _cret C.gpointer // in

	_cret = C.g_queue_peek_tail(_arg0)

	var _gpointer interface{} // out

	_gpointer = (interface{})(_cret)

	return _gpointer
}

// PopHead removes the first element of the queue and returns its data.
func (q *Queue) PopHead() interface{} {
	var _arg0 *C.GQueue // out

	_arg0 = (*C.GQueue)(unsafe.Pointer(q.Native()))

	var _cret C.gpointer // in

	_cret = C.g_queue_pop_head(_arg0)

	var _gpointer interface{} // out

	_gpointer = (interface{})(_cret)

	return _gpointer
}

// PopNth removes the @n'th element of @queue and returns its data.
func (q *Queue) PopNth(n uint) interface{} {
	var _arg0 *C.GQueue // out
	var _arg1 C.guint   // out

	_arg0 = (*C.GQueue)(unsafe.Pointer(q.Native()))
	_arg1 = C.guint(n)

	var _cret C.gpointer // in

	_cret = C.g_queue_pop_nth(_arg0, _arg1)

	var _gpointer interface{} // out

	_gpointer = (interface{})(_cret)

	return _gpointer
}

// PopTail removes the last element of the queue and returns its data.
func (q *Queue) PopTail() interface{} {
	var _arg0 *C.GQueue // out

	_arg0 = (*C.GQueue)(unsafe.Pointer(q.Native()))

	var _cret C.gpointer // in

	_cret = C.g_queue_pop_tail(_arg0)

	var _gpointer interface{} // out

	_gpointer = (interface{})(_cret)

	return _gpointer
}

// PushHead adds a new element at the head of the queue.
func (q *Queue) PushHead(data interface{}) {
	var _arg0 *C.GQueue  // out
	var _arg1 C.gpointer // out

	_arg0 = (*C.GQueue)(unsafe.Pointer(q.Native()))
	_arg1 = C.gpointer(data)

	C.g_queue_push_head(_arg0, _arg1)
}

// PushHeadLink adds a new element at the head of the queue.
func (q *Queue) PushHeadLink(link_ *List) {
	var _arg0 *C.GQueue // out
	var _arg1 *C.GList  // out

	_arg0 = (*C.GQueue)(unsafe.Pointer(q.Native()))
	_arg1 = (*C.GList)(unsafe.Pointer(link_.Native()))

	C.g_queue_push_head_link(_arg0, _arg1)
}

// PushNth inserts a new element into @queue at the given position.
func (q *Queue) PushNth(data interface{}, n int) {
	var _arg0 *C.GQueue  // out
	var _arg1 C.gpointer // out
	var _arg2 C.gint     // out

	_arg0 = (*C.GQueue)(unsafe.Pointer(q.Native()))
	_arg1 = C.gpointer(data)
	_arg2 = C.gint(n)

	C.g_queue_push_nth(_arg0, _arg1, _arg2)
}

// PushNthLink inserts @link into @queue at the given position.
func (q *Queue) PushNthLink(n int, link_ *List) {
	var _arg0 *C.GQueue // out
	var _arg1 C.gint    // out
	var _arg2 *C.GList  // out

	_arg0 = (*C.GQueue)(unsafe.Pointer(q.Native()))
	_arg1 = C.gint(n)
	_arg2 = (*C.GList)(unsafe.Pointer(link_.Native()))

	C.g_queue_push_nth_link(_arg0, _arg1, _arg2)
}

// PushTail adds a new element at the tail of the queue.
func (q *Queue) PushTail(data interface{}) {
	var _arg0 *C.GQueue  // out
	var _arg1 C.gpointer // out

	_arg0 = (*C.GQueue)(unsafe.Pointer(q.Native()))
	_arg1 = C.gpointer(data)

	C.g_queue_push_tail(_arg0, _arg1)
}

// PushTailLink adds a new element at the tail of the queue.
func (q *Queue) PushTailLink(link_ *List) {
	var _arg0 *C.GQueue // out
	var _arg1 *C.GList  // out

	_arg0 = (*C.GQueue)(unsafe.Pointer(q.Native()))
	_arg1 = (*C.GList)(unsafe.Pointer(link_.Native()))

	C.g_queue_push_tail_link(_arg0, _arg1)
}

// Remove removes the first element in @queue that contains @data.
func (q *Queue) Remove(data interface{}) bool {
	var _arg0 *C.GQueue  // out
	var _arg1 C.gpointer // out

	_arg0 = (*C.GQueue)(unsafe.Pointer(q.Native()))
	_arg1 = C.gpointer(data)

	var _cret C.gboolean // in

	_cret = C.g_queue_remove(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// RemoveAll: remove all elements whose data equals @data from @queue.
func (q *Queue) RemoveAll(data interface{}) uint {
	var _arg0 *C.GQueue  // out
	var _arg1 C.gpointer // out

	_arg0 = (*C.GQueue)(unsafe.Pointer(q.Native()))
	_arg1 = C.gpointer(data)

	var _cret C.guint // in

	_cret = C.g_queue_remove_all(_arg0, _arg1)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// Reverse reverses the order of the items in @queue.
func (q *Queue) Reverse() {
	var _arg0 *C.GQueue // out

	_arg0 = (*C.GQueue)(unsafe.Pointer(q.Native()))

	C.g_queue_reverse(_arg0)
}

// Sort sorts @queue using @compare_func.
func (q *Queue) Sort(compareFunc CompareDataFunc) {
	var _arg0 *C.GQueue          // out
	var _arg1 C.GCompareDataFunc // out
	var _arg2 C.gpointer

	_arg0 = (*C.GQueue)(unsafe.Pointer(q.Native()))
	_arg1 = (*[0]byte)(C.gotk4_CompareDataFunc)
	_arg2 = C.gpointer(box.Assign(compareFunc))

	C.g_queue_sort(_arg0, _arg1, _arg2)
}

// Unlink unlinks @link_ so that it will no longer be part of @queue. The link
// is not freed.
//
// @link_ must be part of @queue.
func (q *Queue) Unlink(link_ *List) {
	var _arg0 *C.GQueue // out
	var _arg1 *C.GList  // out

	_arg0 = (*C.GQueue)(unsafe.Pointer(q.Native()))
	_arg1 = (*C.GList)(unsafe.Pointer(link_.Native()))

	C.g_queue_unlink(_arg0, _arg1)
}
