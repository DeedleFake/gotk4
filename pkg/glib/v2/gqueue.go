// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
)

// #cgo pkg-config: glib-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <glib.h>
import "C"

// Queue contains the public fields of a [Queue][glib-Double-ended-Queues].
type Queue struct {
	native C.GQueue
}

// WrapQueue wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapQueue(ptr unsafe.Pointer) *Queue {
	if ptr == nil {
		return nil
	}

	return (*Queue)(ptr)
}

func marshalQueue(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapQueue(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (q *Queue) Native() unsafe.Pointer {
	return unsafe.Pointer(&q.native)
}

// Head gets the field inside the struct.
func (q *Queue) Head() *List {
	var ret *List
	{
		ret = WrapList(unsafe.Pointer(q.native.head))
	}
	return ret
}

// Tail gets the field inside the struct.
func (q *Queue) Tail() *List {
	var ret *List
	{
		ret = WrapList(unsafe.Pointer(q.native.tail))
	}
	return ret
}

// Clear removes all the elements in @queue. If queue elements contain
// dynamically-allocated memory, they should be freed first.
func (q *Queue) Clear() {
	var arg0 *C.GQueue

	arg0 = (*C.GQueue)(q.Native())

	C.g_queue_clear(arg0)
}

// ClearFull: convenience method, which frees all the memory used by a #GQueue,
// and calls the provided @free_func on each item in the #GQueue.
func (q *Queue) ClearFull() {
	var arg0 *C.GQueue
	var arg1 C.GDestroyNotify

	arg0 = (*C.GQueue)(q.Native())

	C.g_queue_clear_full(arg0, arg1)
}

// Copy copies a @queue. Note that is a shallow copy. If the elements in the
// queue consist of pointers to data, the pointers are copied, but the actual
// data is not.
func (q *Queue) Copy() *Queue {
	var arg0 *C.GQueue

	arg0 = (*C.GQueue)(q.Native())

	ret := C.g_queue_copy(arg0)

	var ret0 *Queue

	{
		ret0 = WrapQueue(unsafe.Pointer(ret))
	}

	return ret0
}

// DeleteLink removes @link_ from @queue and frees it.
//
// @link_ must be part of @queue.
func (q *Queue) DeleteLink(link_ *List) {
	var arg0 *C.GQueue
	var arg1 *C.GList

	arg0 = (*C.GQueue)(q.Native())
	arg1 = (*C.GList)(link_.Native())

	C.g_queue_delete_link(arg0, arg1)
}

// Find finds the first link in @queue which contains @data.
func (q *Queue) Find(data interface{}) *List {
	var arg0 *C.GQueue
	var arg1 C.gpointer

	arg0 = (*C.GQueue)(q.Native())
	arg1 = C.gpointer(box.Assign(data))

	ret := C.g_queue_find(arg0, arg1)

	var ret0 *List

	{
		ret0 = WrapList(unsafe.Pointer(ret))
	}

	return ret0
}

// Foreach calls @func for each element in the queue passing @user_data to the
// function.
//
// It is safe for @func to remove the element from @queue, but it must not
// modify any part of the queue after that element.
func (q *Queue) Foreach(fn Func) {
	var arg0 *C.GQueue
	var arg1 C.GFunc
	var arg2 C.gpointer

	arg0 = (*C.GQueue)(q.Native())
	arg1 = (*[0]byte)(C.gotk4_Func)
	arg2 = C.gpointer(box.Assign(fn))

	C.g_queue_foreach(arg0, arg1, arg2)
}

// Free frees the memory allocated for the #GQueue. Only call this function if
// @queue was created with g_queue_new(). If queue elements contain
// dynamically-allocated memory, they should be freed first.
//
// If queue elements contain dynamically-allocated memory, you should either use
// g_queue_free_full() or free them manually first.
func (q *Queue) Free() {
	var arg0 *C.GQueue

	arg0 = (*C.GQueue)(q.Native())

	C.g_queue_free(arg0)
}

// Length returns the number of items in @queue.
func (q *Queue) Length() uint {
	var arg0 *C.GQueue

	arg0 = (*C.GQueue)(q.Native())

	ret := C.g_queue_get_length(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Index returns the position of the first element in @queue which contains
// @data.
func (q *Queue) Index(data interface{}) int {
	var arg0 *C.GQueue
	var arg1 C.gpointer

	arg0 = (*C.GQueue)(q.Native())
	arg1 = C.gpointer(box.Assign(data))

	ret := C.g_queue_index(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Init: a statically-allocated #GQueue must be initialized with this function
// before it can be used. Alternatively you can initialize it with QUEUE_INIT.
// It is not necessary to initialize queues created with g_queue_new().
func (q *Queue) Init() {
	var arg0 *C.GQueue

	arg0 = (*C.GQueue)(q.Native())

	C.g_queue_init(arg0)
}

// InsertAfter inserts @data into @queue after @sibling.
//
// @sibling must be part of @queue. Since GLib 2.44 a nil sibling pushes the
// data at the head of the queue.
func (q *Queue) InsertAfter(sibling *List, data interface{}) {
	var arg0 *C.GQueue
	var arg1 *C.GList
	var arg2 C.gpointer

	arg0 = (*C.GQueue)(q.Native())
	arg1 = (*C.GList)(sibling.Native())
	arg2 = C.gpointer(box.Assign(data))

	C.g_queue_insert_after(arg0, arg1, arg2)
}

// InsertAfterLink inserts @link_ into @queue after @sibling.
//
// @sibling must be part of @queue.
func (q *Queue) InsertAfterLink(sibling *List, link_ *List) {
	var arg0 *C.GQueue
	var arg1 *C.GList
	var arg2 *C.GList

	arg0 = (*C.GQueue)(q.Native())
	arg1 = (*C.GList)(sibling.Native())
	arg2 = (*C.GList)(link_.Native())

	C.g_queue_insert_after_link(arg0, arg1, arg2)
}

// InsertBefore inserts @data into @queue before @sibling.
//
// @sibling must be part of @queue. Since GLib 2.44 a nil sibling pushes the
// data at the tail of the queue.
func (q *Queue) InsertBefore(sibling *List, data interface{}) {
	var arg0 *C.GQueue
	var arg1 *C.GList
	var arg2 C.gpointer

	arg0 = (*C.GQueue)(q.Native())
	arg1 = (*C.GList)(sibling.Native())
	arg2 = C.gpointer(box.Assign(data))

	C.g_queue_insert_before(arg0, arg1, arg2)
}

// InsertBeforeLink inserts @link_ into @queue before @sibling.
//
// @sibling must be part of @queue.
func (q *Queue) InsertBeforeLink(sibling *List, link_ *List) {
	var arg0 *C.GQueue
	var arg1 *C.GList
	var arg2 *C.GList

	arg0 = (*C.GQueue)(q.Native())
	arg1 = (*C.GList)(sibling.Native())
	arg2 = (*C.GList)(link_.Native())

	C.g_queue_insert_before_link(arg0, arg1, arg2)
}

// InsertSorted inserts @data into @queue using @func to determine the new
// position.
func (q *Queue) InsertSorted(data interface{}, fn CompareDataFunc) {
	var arg0 *C.GQueue
	var arg1 C.gpointer
	var arg2 C.GCompareDataFunc
	var arg3 C.gpointer

	arg0 = (*C.GQueue)(q.Native())
	arg1 = C.gpointer(box.Assign(data))
	arg2 = (*[0]byte)(C.gotk4_CompareDataFunc)
	arg3 = C.gpointer(box.Assign(fn))

	C.g_queue_insert_sorted(arg0, arg1, arg2, arg3)
}

// IsEmpty returns true if the queue is empty.
func (q *Queue) IsEmpty() bool {
	var arg0 *C.GQueue

	arg0 = (*C.GQueue)(q.Native())

	ret := C.g_queue_is_empty(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// LinkIndex returns the position of @link_ in @queue.
func (q *Queue) LinkIndex(link_ *List) int {
	var arg0 *C.GQueue
	var arg1 *C.GList

	arg0 = (*C.GQueue)(q.Native())
	arg1 = (*C.GList)(link_.Native())

	ret := C.g_queue_link_index(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// PeekHead returns the first element of the queue.
func (q *Queue) PeekHead() interface{} {
	var arg0 *C.GQueue

	arg0 = (*C.GQueue)(q.Native())

	ret := C.g_queue_peek_head(arg0)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// PeekHeadLink returns the first link in @queue.
func (q *Queue) PeekHeadLink() *List {
	var arg0 *C.GQueue

	arg0 = (*C.GQueue)(q.Native())

	ret := C.g_queue_peek_head_link(arg0)

	var ret0 *List

	{
		ret0 = WrapList(unsafe.Pointer(ret))
	}

	return ret0
}

// PeekNth returns the @n'th element of @queue.
func (q *Queue) PeekNth(n uint) interface{} {
	var arg0 *C.GQueue
	var arg1 C.guint

	arg0 = (*C.GQueue)(q.Native())
	arg1 = C.guint(n)

	ret := C.g_queue_peek_nth(arg0, arg1)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// PeekNthLink returns the link at the given position
func (q *Queue) PeekNthLink(n uint) *List {
	var arg0 *C.GQueue
	var arg1 C.guint

	arg0 = (*C.GQueue)(q.Native())
	arg1 = C.guint(n)

	ret := C.g_queue_peek_nth_link(arg0, arg1)

	var ret0 *List

	{
		ret0 = WrapList(unsafe.Pointer(ret))
	}

	return ret0
}

// PeekTail returns the last element of the queue.
func (q *Queue) PeekTail() interface{} {
	var arg0 *C.GQueue

	arg0 = (*C.GQueue)(q.Native())

	ret := C.g_queue_peek_tail(arg0)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// PeekTailLink returns the last link in @queue.
func (q *Queue) PeekTailLink() *List {
	var arg0 *C.GQueue

	arg0 = (*C.GQueue)(q.Native())

	ret := C.g_queue_peek_tail_link(arg0)

	var ret0 *List

	{
		ret0 = WrapList(unsafe.Pointer(ret))
	}

	return ret0
}

// PopHead removes the first element of the queue and returns its data.
func (q *Queue) PopHead() interface{} {
	var arg0 *C.GQueue

	arg0 = (*C.GQueue)(q.Native())

	ret := C.g_queue_pop_head(arg0)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// PopHeadLink removes and returns the first element of the queue.
func (q *Queue) PopHeadLink() *List {
	var arg0 *C.GQueue

	arg0 = (*C.GQueue)(q.Native())

	ret := C.g_queue_pop_head_link(arg0)

	var ret0 *List

	{
		ret0 = WrapList(unsafe.Pointer(ret))
	}

	return ret0
}

// PopNth removes the @n'th element of @queue and returns its data.
func (q *Queue) PopNth(n uint) interface{} {
	var arg0 *C.GQueue
	var arg1 C.guint

	arg0 = (*C.GQueue)(q.Native())
	arg1 = C.guint(n)

	ret := C.g_queue_pop_nth(arg0, arg1)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// PopNthLink removes and returns the link at the given position.
func (q *Queue) PopNthLink(n uint) *List {
	var arg0 *C.GQueue
	var arg1 C.guint

	arg0 = (*C.GQueue)(q.Native())
	arg1 = C.guint(n)

	ret := C.g_queue_pop_nth_link(arg0, arg1)

	var ret0 *List

	{
		ret0 = WrapList(unsafe.Pointer(ret))
	}

	return ret0
}

// PopTail removes the last element of the queue and returns its data.
func (q *Queue) PopTail() interface{} {
	var arg0 *C.GQueue

	arg0 = (*C.GQueue)(q.Native())

	ret := C.g_queue_pop_tail(arg0)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// PopTailLink removes and returns the last element of the queue.
func (q *Queue) PopTailLink() *List {
	var arg0 *C.GQueue

	arg0 = (*C.GQueue)(q.Native())

	ret := C.g_queue_pop_tail_link(arg0)

	var ret0 *List

	{
		ret0 = WrapList(unsafe.Pointer(ret))
	}

	return ret0
}

// PushHead adds a new element at the head of the queue.
func (q *Queue) PushHead(data interface{}) {
	var arg0 *C.GQueue
	var arg1 C.gpointer

	arg0 = (*C.GQueue)(q.Native())
	arg1 = C.gpointer(box.Assign(data))

	C.g_queue_push_head(arg0, arg1)
}

// PushHeadLink adds a new element at the head of the queue.
func (q *Queue) PushHeadLink(link_ *List) {
	var arg0 *C.GQueue
	var arg1 *C.GList

	arg0 = (*C.GQueue)(q.Native())
	arg1 = (*C.GList)(link_.Native())

	C.g_queue_push_head_link(arg0, arg1)
}

// PushNth inserts a new element into @queue at the given position.
func (q *Queue) PushNth(data interface{}, n int) {
	var arg0 *C.GQueue
	var arg1 C.gpointer
	var arg2 C.gint

	arg0 = (*C.GQueue)(q.Native())
	arg1 = C.gpointer(box.Assign(data))
	arg2 = C.gint(n)

	C.g_queue_push_nth(arg0, arg1, arg2)
}

// PushNthLink inserts @link into @queue at the given position.
func (q *Queue) PushNthLink(n int, link_ *List) {
	var arg0 *C.GQueue
	var arg1 C.gint
	var arg2 *C.GList

	arg0 = (*C.GQueue)(q.Native())
	arg1 = C.gint(n)
	arg2 = (*C.GList)(link_.Native())

	C.g_queue_push_nth_link(arg0, arg1, arg2)
}

// PushTail adds a new element at the tail of the queue.
func (q *Queue) PushTail(data interface{}) {
	var arg0 *C.GQueue
	var arg1 C.gpointer

	arg0 = (*C.GQueue)(q.Native())
	arg1 = C.gpointer(box.Assign(data))

	C.g_queue_push_tail(arg0, arg1)
}

// PushTailLink adds a new element at the tail of the queue.
func (q *Queue) PushTailLink(link_ *List) {
	var arg0 *C.GQueue
	var arg1 *C.GList

	arg0 = (*C.GQueue)(q.Native())
	arg1 = (*C.GList)(link_.Native())

	C.g_queue_push_tail_link(arg0, arg1)
}

// Remove removes the first element in @queue that contains @data.
func (q *Queue) Remove(data interface{}) bool {
	var arg0 *C.GQueue
	var arg1 C.gpointer

	arg0 = (*C.GQueue)(q.Native())
	arg1 = C.gpointer(box.Assign(data))

	ret := C.g_queue_remove(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// RemoveAll: remove all elements whose data equals @data from @queue.
func (q *Queue) RemoveAll(data interface{}) uint {
	var arg0 *C.GQueue
	var arg1 C.gpointer

	arg0 = (*C.GQueue)(q.Native())
	arg1 = C.gpointer(box.Assign(data))

	ret := C.g_queue_remove_all(arg0, arg1)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Reverse reverses the order of the items in @queue.
func (q *Queue) Reverse() {
	var arg0 *C.GQueue

	arg0 = (*C.GQueue)(q.Native())

	C.g_queue_reverse(arg0)
}

// Sort sorts @queue using @compare_func.
func (q *Queue) Sort(compareFunc CompareDataFunc) {
	var arg0 *C.GQueue
	var arg1 C.GCompareDataFunc
	var arg2 C.gpointer

	arg0 = (*C.GQueue)(q.Native())
	arg1 = (*[0]byte)(C.gotk4_CompareDataFunc)
	arg2 = C.gpointer(box.Assign(compareFunc))

	C.g_queue_sort(arg0, arg1, arg2)
}

// Unlink unlinks @link_ so that it will no longer be part of @queue. The link
// is not freed.
//
// @link_ must be part of @queue.
func (q *Queue) Unlink(link_ *List) {
	var arg0 *C.GQueue
	var arg1 *C.GList

	arg0 = (*C.GQueue)(q.Native())
	arg1 = (*C.GList)(link_.Native())

	C.g_queue_unlink(arg0, arg1)
}
