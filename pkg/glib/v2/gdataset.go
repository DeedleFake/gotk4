// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0 glib-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <glib.h>
import "C"

// DuplicateFunc: the type of functions that are used to 'duplicate' an object.
// What this means depends on the context, it could just be incrementing the
// reference count, if @data is a ref-counted object.
type DuplicateFunc func(data interface{}) (gpointer interface{})

//export gotk4_DuplicateFunc
func gotk4_DuplicateFunc(arg0 C.gpointer, arg1 C.gpointer) C.gpointer {
	v := box.Get(uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var data interface{} // out

	data = (interface{})(arg0)

	fn := v.(DuplicateFunc)
	gpointer := fn(data)

	cret = C.gpointer(gpointer)

	return gpointer
}

// DatalistClear frees all the data elements of the datalist. The data elements'
// destroy functions are called if they have been set.
func DatalistClear(datalist **Data) {
	var _arg1 **C.GData // out

	_arg1 = (**C.GData)(unsafe.Pointer(datalist.Native()))

	C.g_datalist_clear(_arg1)
}

// DatalistForeach calls the given function for each data element of the
// datalist. The function is called with each data element's #GQuark id and
// data, together with the given @user_data parameter. Note that this function
// is NOT thread-safe. So unless @datalist can be protected from any
// modifications during invocation of this function, it should not be called.
//
// @func can make changes to @datalist, but the iteration will not reflect
// changes made during the g_datalist_foreach() call, other than skipping over
// elements that are removed.
func DatalistForeach(datalist **Data, fn DataForeachFunc) {
	var _arg1 **C.GData          // out
	var _arg2 C.GDataForeachFunc // out
	var _arg3 C.gpointer

	_arg1 = (**C.GData)(unsafe.Pointer(datalist.Native()))
	_arg2 = (*[0]byte)(C.gotk4_DataForeachFunc)
	_arg3 = C.gpointer(box.Assign(fn))

	C.g_datalist_foreach(_arg1, _arg2, _arg3)
}

// DatalistGetData gets a data element, using its string identifier. This is
// slower than g_datalist_id_get_data() because it compares strings.
func DatalistGetData(datalist **Data, key string) interface{} {
	var _arg1 **C.GData // out
	var _arg2 *C.gchar  // out

	_arg1 = (**C.GData)(unsafe.Pointer(datalist.Native()))
	_arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg2))

	var _cret C.gpointer // in

	_cret = C.g_datalist_get_data(_arg1, _arg2)

	var _gpointer interface{} // out

	_gpointer = (interface{})(_cret)

	return _gpointer
}

// DatalistGetFlags gets flags values packed in together with the datalist. See
// g_datalist_set_flags().
func DatalistGetFlags(datalist **Data) uint {
	var _arg1 **C.GData // out

	_arg1 = (**C.GData)(unsafe.Pointer(datalist.Native()))

	var _cret C.guint // in

	_cret = C.g_datalist_get_flags(_arg1)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// DatalistInit resets the datalist to nil. It does not free any memory or call
// any destroy functions.
func DatalistInit(datalist **Data) {
	var _arg1 **C.GData // out

	_arg1 = (**C.GData)(unsafe.Pointer(datalist.Native()))

	C.g_datalist_init(_arg1)
}

// DatalistSetFlags turns on flag values for a data list. This function is used
// to keep a small number of boolean flags in an object with a data list without
// using any additional space. It is not generally useful except in
// circumstances where space is very tight. (It is used in the base #GObject
// type, for example.)
func DatalistSetFlags(datalist **Data, flags uint) {
	var _arg1 **C.GData // out
	var _arg2 C.guint   // out

	_arg1 = (**C.GData)(unsafe.Pointer(datalist.Native()))
	_arg2 = C.guint(flags)

	C.g_datalist_set_flags(_arg1, _arg2)
}

// DatalistUnsetFlags turns off flag values for a data list. See
// g_datalist_unset_flags()
func DatalistUnsetFlags(datalist **Data, flags uint) {
	var _arg1 **C.GData // out
	var _arg2 C.guint   // out

	_arg1 = (**C.GData)(unsafe.Pointer(datalist.Native()))
	_arg2 = C.guint(flags)

	C.g_datalist_unset_flags(_arg1, _arg2)
}

// DatasetDestroy destroys the dataset, freeing all memory allocated, and
// calling any destroy functions set for data elements.
func DatasetDestroy(datasetLocation interface{}) {
	var _arg1 C.gpointer // out

	_arg1 = C.gpointer(datasetLocation)

	C.g_dataset_destroy(_arg1)
}

// DatasetForeach calls the given function for each data element which is
// associated with the given location. Note that this function is NOT
// thread-safe. So unless @dataset_location can be protected from any
// modifications during invocation of this function, it should not be called.
//
// @func can make changes to the dataset, but the iteration will not reflect
// changes made during the g_dataset_foreach() call, other than skipping over
// elements that are removed.
func DatasetForeach(datasetLocation interface{}, fn DataForeachFunc) {
	var _arg1 C.gpointer         // out
	var _arg2 C.GDataForeachFunc // out
	var _arg3 C.gpointer

	_arg1 = C.gpointer(datasetLocation)
	_arg2 = (*[0]byte)(C.gotk4_DataForeachFunc)
	_arg3 = C.gpointer(box.Assign(fn))

	C.g_dataset_foreach(_arg1, _arg2, _arg3)
}

// Data: the #GData struct is an opaque data structure to represent a [Keyed
// Data List][glib-Keyed-Data-Lists]. It should only be accessed via the
// following functions.
type Data struct {
	native C.GData
}

// WrapData wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapData(ptr unsafe.Pointer) *Data {
	if ptr == nil {
		return nil
	}

	return (*Data)(ptr)
}

func marshalData(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapData(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (d *Data) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}
