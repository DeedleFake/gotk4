// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
)

// #cgo pkg-config: glib-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <glib.h>
//
// extern void gotk4_DataForeachFunc(GQuark _0, gpointer _1, gpointer _2);
// extern gpointer gotk4_DuplicateFunc(gpointer _0, gpointer _1);
import "C"

// DataForeachFunc specifies the type of function passed to g_dataset_foreach().
// It is called with each #GQuark id and associated data element, together with
// the @user_data parameter supplied to g_dataset_foreach().
type DataForeachFunc func(keyID Quark, data interface{})

//export gotk4_DataForeachFunc
func gotk4_DataForeachFunc(arg0 C.GQuark, arg1 C.gpointer, arg2 C.gpointer) {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var keyID Quark
	var data interface{}

	{
		var tmp uint32
		tmp = uint32(arg0)
		keyID = Quark(tmp)
	}

	data = box.Get(uintptr(arg1))

	v.(DataForeachFunc)(keyID, data)
}

// DuplicateFunc: the type of functions that are used to 'duplicate' an object.
// What this means depends on the context, it could just be incrementing the
// reference count, if @data is a ref-counted object.
type DuplicateFunc func(data interface{}) interface{}

//export gotk4_DuplicateFunc
func gotk4_DuplicateFunc(arg0 C.gpointer, arg1 C.gpointer) C.gpointer {
	v := box.Get(uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var data interface{}

	data = box.Get(uintptr(arg0))

	gpointer := v.(DuplicateFunc)(data)
}

// DatalistClear frees all the data elements of the datalist. The data elements'
// destroy functions are called if they have been set.
func DatalistClear(datalist **Data) {
	var arg1 **C.GData

	arg1 = (**C.GData)(datalist.Native())

	C.g_datalist_clear(arg1)
}

// DatalistForeach calls the given function for each data element of the
// datalist. The function is called with each data element's #GQuark id and
// data, together with the given @user_data parameter. Note that this function
// is NOT thread-safe. So unless @datalist can be protected from any
// modifications during invocation of this function, it should not be called.
//
// @func can make changes to @datalist, but the iteration will not reflect
// changes made during the g_datalist_foreach() call, other than skipping over
// elements that are removed.
func DatalistForeach(datalist **Data, fn DataForeachFunc) {
	var arg1 **C.GData
	var arg2 C.GDataForeachFunc
	var arg3 C.gpointer

	arg1 = (**C.GData)(datalist.Native())
	arg2 = (*[0]byte)(C.gotk4_DataForeachFunc)
	arg3 = C.gpointer(box.Assign(fn))

	C.g_datalist_foreach(arg1, arg2, arg3)
}

// DatalistGetData gets a data element, using its string identifier. This is
// slower than g_datalist_id_get_data() because it compares strings.
func DatalistGetData(datalist **Data, key string) interface{} {
	var arg1 **C.GData
	var arg2 *C.gchar

	arg1 = (**C.GData)(datalist.Native())
	arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_datalist_get_data(arg1, arg2)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// DatalistGetFlags gets flags values packed in together with the datalist. See
// g_datalist_set_flags().
func DatalistGetFlags(datalist **Data) uint {
	var arg1 **C.GData

	arg1 = (**C.GData)(datalist.Native())

	ret := C.g_datalist_get_flags(arg1)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// DatalistInit resets the datalist to nil. It does not free any memory or call
// any destroy functions.
func DatalistInit(datalist **Data) {
	var arg1 **C.GData

	arg1 = (**C.GData)(datalist.Native())

	C.g_datalist_init(arg1)
}

// DatalistSetFlags turns on flag values for a data list. This function is used
// to keep a small number of boolean flags in an object with a data list without
// using any additional space. It is not generally useful except in
// circumstances where space is very tight. (It is used in the base #GObject
// type, for example.)
func DatalistSetFlags(datalist **Data, flags uint) {
	var arg1 **C.GData
	var arg2 C.guint

	arg1 = (**C.GData)(datalist.Native())
	arg2 = C.guint(flags)

	C.g_datalist_set_flags(arg1, arg2)
}

// DatalistUnsetFlags turns off flag values for a data list. See
// g_datalist_unset_flags()
func DatalistUnsetFlags(datalist **Data, flags uint) {
	var arg1 **C.GData
	var arg2 C.guint

	arg1 = (**C.GData)(datalist.Native())
	arg2 = C.guint(flags)

	C.g_datalist_unset_flags(arg1, arg2)
}

// DatasetDestroy destroys the dataset, freeing all memory allocated, and
// calling any destroy functions set for data elements.
func DatasetDestroy(datasetLocation interface{}) {
	var arg1 C.gpointer

	arg1 = C.gpointer(box.Assign(datasetLocation))

	C.g_dataset_destroy(arg1)
}

// DatasetForeach calls the given function for each data element which is
// associated with the given location. Note that this function is NOT
// thread-safe. So unless @dataset_location can be protected from any
// modifications during invocation of this function, it should not be called.
//
// @func can make changes to the dataset, but the iteration will not reflect
// changes made during the g_dataset_foreach() call, other than skipping over
// elements that are removed.
func DatasetForeach(datasetLocation interface{}, fn DataForeachFunc) {
	var arg1 C.gpointer
	var arg2 C.GDataForeachFunc
	var arg3 C.gpointer

	arg1 = C.gpointer(box.Assign(datasetLocation))
	arg2 = (*[0]byte)(C.gotk4_DataForeachFunc)
	arg3 = C.gpointer(box.Assign(fn))

	C.g_dataset_foreach(arg1, arg2, arg3)
}

// Data: the #GData struct is an opaque data structure to represent a [Keyed
// Data List][glib-Keyed-Data-Lists]. It should only be accessed via the
// following functions.
type Data struct {
	native C.GData
}

// WrapData wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapData(ptr unsafe.Pointer) *Data {
	if ptr == nil {
		return nil
	}

	return (*Data)(ptr)
}

func marshalData(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapData(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (d *Data) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}
