// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <glib.h>
import "C"

// DataForeachFunc specifies the type of function passed to g_dataset_foreach().
// It is called with each #GQuark id and associated data element, together with
// the @user_data parameter supplied to g_dataset_foreach().
type DataForeachFunc func(keyID Quark, data interface{})

//export gotk4_DataForeachFunc
func gotk4_DataForeachFunc(arg0 C.GQuark, arg1 C.gpointer, arg2 C.gpointer) {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	fn := v.(DataForeachFunc)
	fn(keyID, data, userData)
}

// DuplicateFunc: the type of functions that are used to 'duplicate' an object.
// What this means depends on the context, it could just be incrementing the
// reference count, if @data is a ref-counted object.
type DuplicateFunc func(data interface{}) interface{}

//export gotk4_DuplicateFunc
func gotk4_DuplicateFunc(arg0 C.gpointer, arg1 C.gpointer) C.gpointer {
	v := box.Get(uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	fn := v.(DuplicateFunc)
	ret := fn(data, userData)

	cret = C.gpointer(ret)

	return cret
}

// DatalistClear frees all the data elements of the datalist. The data elements'
// destroy functions are called if they have been set.
func DatalistClear(datalist **Data) {
	var arg1 **C.GData

	arg1 = (**C.GData)(unsafe.Pointer(datalist.Native()))

	C.g_datalist_clear(datalist)
}

// DatalistForeach calls the given function for each data element of the
// datalist. The function is called with each data element's #GQuark id and
// data, together with the given @user_data parameter. Note that this function
// is NOT thread-safe. So unless @datalist can be protected from any
// modifications during invocation of this function, it should not be called.
//
// @func can make changes to @datalist, but the iteration will not reflect
// changes made during the g_datalist_foreach() call, other than skipping over
// elements that are removed.
func DatalistForeach(datalist **Data, fn DataForeachFunc) {

	C.g_datalist_foreach(datalist, fn, userData)
}

// DatalistGetData gets a data element, using its string identifier. This is
// slower than g_datalist_id_get_data() because it compares strings.
func DatalistGetData(datalist **Data, key string) interface{} {
	var arg1 **C.GData
	var arg2 *C.gchar

	arg1 = (**C.GData)(unsafe.Pointer(datalist.Native()))
	arg2 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg2))

	var cret C.gpointer
	var goret1 interface{}

	cret = C.g_datalist_get_data(datalist, key)

	goret1 = C.gpointer(cret)

	return goret1
}

// DatalistGetFlags gets flags values packed in together with the datalist. See
// g_datalist_set_flags().
func DatalistGetFlags(datalist **Data) uint {
	var arg1 **C.GData

	arg1 = (**C.GData)(unsafe.Pointer(datalist.Native()))

	var cret C.guint
	var goret1 uint

	cret = C.g_datalist_get_flags(datalist)

	goret1 = C.guint(cret)

	return goret1
}

// DatalistIDDupData: this is a variant of g_datalist_id_get_data() which
// returns a 'duplicate' of the value. @dup_func defines the meaning of
// 'duplicate' in this context, it could e.g. take a reference on a ref-counted
// object.
//
// If the @key_id is not set in the datalist then @dup_func will be called with
// a nil argument.
//
// Note that @dup_func is called while the datalist is locked, so it is not
// allowed to read or modify the datalist.
//
// This function can be useful to avoid races when multiple threads are using
// the same datalist and the same key.
func DatalistIDDupData(datalist **Data, keyID Quark, dupFunc DuplicateFunc) interface{} {

	var cret C.gpointer
	var goret1 interface{}

	cret = C.g_datalist_id_dup_data(datalist, keyID, dupFunc, userData)

	goret1 = C.gpointer(cret)

	return goret1
}

// DatalistInit resets the datalist to nil. It does not free any memory or call
// any destroy functions.
func DatalistInit(datalist **Data) {
	var arg1 **C.GData

	arg1 = (**C.GData)(unsafe.Pointer(datalist.Native()))

	C.g_datalist_init(datalist)
}

// DatalistSetFlags turns on flag values for a data list. This function is used
// to keep a small number of boolean flags in an object with a data list without
// using any additional space. It is not generally useful except in
// circumstances where space is very tight. (It is used in the base #GObject
// type, for example.)
func DatalistSetFlags(datalist **Data, flags uint) {
	var arg1 **C.GData
	var arg2 C.guint

	arg1 = (**C.GData)(unsafe.Pointer(datalist.Native()))
	arg2 = C.guint(flags)

	C.g_datalist_set_flags(datalist, flags)
}

// DatalistUnsetFlags turns off flag values for a data list. See
// g_datalist_unset_flags()
func DatalistUnsetFlags(datalist **Data, flags uint) {
	var arg1 **C.GData
	var arg2 C.guint

	arg1 = (**C.GData)(unsafe.Pointer(datalist.Native()))
	arg2 = C.guint(flags)

	C.g_datalist_unset_flags(datalist, flags)
}

// DatasetDestroy destroys the dataset, freeing all memory allocated, and
// calling any destroy functions set for data elements.
func DatasetDestroy(datasetLocation interface{}) {
	var arg1 C.gpointer

	arg1 = C.gpointer(datasetLocation)

	C.g_dataset_destroy(datasetLocation)
}

// DatasetForeach calls the given function for each data element which is
// associated with the given location. Note that this function is NOT
// thread-safe. So unless @dataset_location can be protected from any
// modifications during invocation of this function, it should not be called.
//
// @func can make changes to the dataset, but the iteration will not reflect
// changes made during the g_dataset_foreach() call, other than skipping over
// elements that are removed.
func DatasetForeach(datasetLocation interface{}, fn DataForeachFunc) {

	C.g_dataset_foreach(datasetLocation, fn, userData)
}

// Data: the #GData struct is an opaque data structure to represent a [Keyed
// Data List][glib-Keyed-Data-Lists]. It should only be accessed via the
// following functions.
type Data struct {
	native C.GData
}

// WrapData wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapData(ptr unsafe.Pointer) *Data {
	if ptr == nil {
		return nil
	}

	return (*Data)(ptr)
}

func marshalData(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapData(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (d *Data) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}
