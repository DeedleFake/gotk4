// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
)

// #cgo pkg-config: glib-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <glib.h>
import "C"

// ThreadPoolGetMaxIdleTime: this function will return the maximum @interval
// that a thread will wait in the thread pool for new tasks before being
// stopped.
//
// If this function returns 0, threads waiting in the thread pool for new work
// are not stopped.
func ThreadPoolGetMaxIdleTime() uint {
	ret := C.g_thread_pool_get_max_idle_time()

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// ThreadPoolGetMaxUnusedThreads returns the maximal allowed number of unused
// threads.
func ThreadPoolGetMaxUnusedThreads() int {
	ret := C.g_thread_pool_get_max_unused_threads()

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ThreadPoolGetNumUnusedThreads returns the number of currently unused threads.
func ThreadPoolGetNumUnusedThreads() uint {
	ret := C.g_thread_pool_get_num_unused_threads()

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// ThreadPoolSetMaxIdleTime: this function will set the maximum @interval that a
// thread waiting in the pool for new tasks can be idle for before being
// stopped. This function is similar to calling
// g_thread_pool_stop_unused_threads() on a regular timeout, except this is done
// on a per thread basis.
//
// By setting @interval to 0, idle threads will not be stopped.
//
// The default value is 15000 (15 seconds).
func ThreadPoolSetMaxIdleTime(interval uint) {
	var arg1 C.guint

	arg1 = C.guint(interval)

	C.g_thread_pool_set_max_idle_time(arg1)
}

// ThreadPoolSetMaxUnusedThreads sets the maximal number of unused threads to
// @max_threads. If @max_threads is -1, no limit is imposed on the number of
// unused threads.
//
// The default value is 2.
func ThreadPoolSetMaxUnusedThreads(maxThreads int) {
	var arg1 C.gint

	arg1 = C.gint(maxThreads)

	C.g_thread_pool_set_max_unused_threads(arg1)
}

// ThreadPoolStopUnusedThreads stops all currently unused threads. This does not
// change the maximal number of unused threads. This function can be used to
// regularly stop all unused threads e.g. from g_timeout_add().
func ThreadPoolStopUnusedThreads() {
	C.g_thread_pool_stop_unused_threads()
}

// ThreadPool: the Pool struct represents a thread pool. It has three public
// read-only members, but the underlying struct is bigger, so you must not copy
// this struct.
type ThreadPool struct {
	native C.GThreadPool
}

// WrapThreadPool wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapThreadPool(ptr unsafe.Pointer) *ThreadPool {
	if ptr == nil {
		return nil
	}

	return (*ThreadPool)(ptr)
}

func marshalThreadPool(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapThreadPool(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *ThreadPool) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// UserData gets the field inside the struct.
func (t *ThreadPool) UserData() interface{} {
	var ret interface{}
	ret = box.Get(uintptr(t.native.user_data))
	return ret
}

// Exclusive gets the field inside the struct.
func (t *ThreadPool) Exclusive() bool {
	var ret bool
	ret = C.bool(t.native.exclusive) != 0
	return ret
}

// Free frees all resources allocated for @pool.
//
// If @immediate is true, no new task is processed for @pool. Otherwise @pool is
// not freed before the last task is processed. Note however, that no thread of
// this pool is interrupted while processing a task. Instead at least all still
// running threads can finish their tasks before the @pool is freed.
//
// If @wait_ is true, this function does not return before all tasks to be
// processed (dependent on @immediate, whether all or only the currently
// running) are ready. Otherwise this function returns immediately.
//
// After calling this function @pool must not be used anymore.
func (p *ThreadPool) Free(immediate bool, wait_ bool) {
	var arg0 *C.GThreadPool
	var arg1 C.gboolean
	var arg2 C.gboolean

	arg0 = (*C.GThreadPool)(p.Native())
	if immediate {
		arg1 = C.TRUE
	}
	if wait_ {
		arg2 = C.TRUE
	}

	C.g_thread_pool_free(arg0, arg1, arg2)
}

// MaxThreads returns the maximal number of threads for @pool.
func (p *ThreadPool) MaxThreads() int {
	var arg0 *C.GThreadPool

	arg0 = (*C.GThreadPool)(p.Native())

	ret := C.g_thread_pool_get_max_threads(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// NumThreads returns the number of threads currently running in @pool.
func (p *ThreadPool) NumThreads() uint {
	var arg0 *C.GThreadPool

	arg0 = (*C.GThreadPool)(p.Native())

	ret := C.g_thread_pool_get_num_threads(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// MoveToFront moves the item to the front of the queue of unprocessed items, so
// that it will be processed next.
func (p *ThreadPool) MoveToFront(data interface{}) bool {
	var arg0 *C.GThreadPool
	var arg1 C.gpointer

	arg0 = (*C.GThreadPool)(p.Native())
	arg1 = C.gpointer(box.Assign(data))

	ret := C.g_thread_pool_move_to_front(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// Push inserts @data into the list of tasks to be executed by @pool.
//
// When the number of currently running threads is lower than the maximal
// allowed number of threads, a new thread is started (or reused) with the
// properties given to g_thread_pool_new(). Otherwise, @data stays in the queue
// until a thread in this pool finishes its previous task and processes @data.
//
// @error can be nil to ignore errors, or non-nil to report errors. An error can
// only occur when a new thread couldn't be created. In that case @data is
// simply appended to the queue of work to do.
//
// Before version 2.32, this function did not return a success status.
func (p *ThreadPool) Push(data interface{}) error {
	var arg0 *C.GThreadPool
	var arg1 C.gpointer
	var gError *C.GError

	arg0 = (*C.GThreadPool)(p.Native())
	arg1 = C.gpointer(box.Assign(data))

	ret := C.g_thread_pool_push(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SetMaxThreads sets the maximal allowed number of threads for @pool. A value
// of -1 means that the maximal number of threads is unlimited. If @pool is an
// exclusive thread pool, setting the maximal number of threads to -1 is not
// allowed.
//
// Setting @max_threads to 0 means stopping all work for @pool. It is
// effectively frozen until @max_threads is set to a non-zero value again.
//
// A thread is never terminated while calling @func, as supplied by
// g_thread_pool_new(). Instead the maximal number of threads only has effect
// for the allocation of new threads in g_thread_pool_push(). A new thread is
// allocated, whenever the number of currently running threads in @pool is
// smaller than the maximal number.
//
// @error can be nil to ignore errors, or non-nil to report errors. An error can
// only occur when a new thread couldn't be created.
//
// Before version 2.32, this function did not return a success status.
func (p *ThreadPool) SetMaxThreads(maxThreads int) error {
	var arg0 *C.GThreadPool
	var arg1 C.gint
	var gError *C.GError

	arg0 = (*C.GThreadPool)(p.Native())
	arg1 = C.gint(maxThreads)

	ret := C.g_thread_pool_set_max_threads(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SetSortFunction sets the function used to sort the list of tasks. This allows
// the tasks to be processed by a priority determined by @func, and not just in
// the order in which they were added to the pool.
//
// Note, if the maximum number of threads is more than 1, the order that threads
// are executed cannot be guaranteed 100%. Threads are scheduled by the
// operating system and are executed at random. It cannot be assumed that
// threads are executed in the order they are created.
func (p *ThreadPool) SetSortFunction(fn CompareDataFunc) {
	var arg0 *C.GThreadPool
	var arg1 C.GCompareDataFunc
	var arg2 C.gpointer

	arg0 = (*C.GThreadPool)(p.Native())
	arg1 = (*[0]byte)(C.gotk4_CompareDataFunc)
	arg2 = C.gpointer(box.Assign(fn))

	C.g_thread_pool_set_sort_function(arg0, arg1, arg2)
}

// Unprocessed returns the number of tasks still unprocessed in @pool.
func (p *ThreadPool) Unprocessed() uint {
	var arg0 *C.GThreadPool

	arg0 = (*C.GThreadPool)(p.Native())

	ret := C.g_thread_pool_unprocessed(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}
