// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/gobject/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk+-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
//
// void gotk4_BuilderConnectFunc(GtkBuilder*, GObject*,  gchar*,  gchar*, GObject*, GConnectFlags, gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_icon_set_get_type()), F: marshalIconSet},
		{T: externglib.Type(C.gtk_icon_source_get_type()), F: marshalIconSource},
		{T: externglib.Type(C.gtk_selection_data_get_type()), F: marshalSelectionData},
		{T: externglib.Type(C.gtk_widget_path_get_type()), F: marshalWidgetPath},
	})
}

// BuilderConnectFunc: this is the signature of a function used to connect
// signals. It is used by the gtk_builder_connect_signals() and
// gtk_builder_connect_signals_full() methods. It is mainly intended for
// interpreted language bindings, but could be useful where the programmer wants
// more control over the signal connection process. Note that this function can
// only be called once, subsequent calls will do nothing.
type BuilderConnectFunc func(builder Builder, object gextras.Objector, signalName string, handlerName string, connectObject gextras.Objector, flags gobject.ConnectFlags)

//export gotk4_BuilderConnectFunc
func gotk4_BuilderConnectFunc(arg0 *C.GtkBuilder, arg1 *C.GObject, arg2 *C.gchar, arg3 *C.gchar, arg4 *C.GObject, arg5 C.GConnectFlags, arg6 C.gpointer) {
	v := box.Get(uintptr(arg6))
	if v == nil {
		panic(`callback not found`)
	}

	var builder Builder
	var object gextras.Objector
	var signalName string
	var handlerName string
	var connectObject gextras.Objector
	var flags gobject.ConnectFlags

	builder = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(Builder)

	object = gextras.CastObject(externglib.Take(unsafe.Pointer(arg1.Native()))).(gextras.Objector)

	signalName = C.GoString(arg2)

	handlerName = C.GoString(arg3)

	connectObject = gextras.CastObject(externglib.Take(unsafe.Pointer(arg4.Native()))).(gextras.Objector)

	flags = gobject.ConnectFlags(arg5)

	v.(BuilderConnectFunc)(builder, object, signalName, handlerName, connectObject, flags)
}

type IconSet struct {
	native C.GtkIconSet
}

// WrapIconSet wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapIconSet(ptr unsafe.Pointer) *IconSet {
	if ptr == nil {
		return nil
	}

	return (*IconSet)(ptr)
}

func marshalIconSet(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapIconSet(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (i *IconSet) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

// NewIconSet constructs a struct IconSet.
func NewIconSet() *IconSet {
	ret := C.gtk_icon_set_new()

	var ret0 *IconSet

	{
		ret0 = WrapIconSet(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *IconSet) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewIconSetFromPixbuf constructs a struct IconSet.
func NewIconSetFromPixbuf(pixbuf gdkpixbuf.Pixbuf) *IconSet {
	var arg1 *C.GdkPixbuf

	arg1 = (*C.GdkPixbuf)(pixbuf.Native())

	ret := C.gtk_icon_set_new_from_pixbuf(arg1)

	var ret0 *IconSet

	{
		ret0 = WrapIconSet(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *IconSet) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// AddSource: icon sets have a list of IconSource, which they use as base icons
// for rendering icons in different states and sizes. Icons are scaled, made to
// look insensitive, etc. in gtk_icon_set_render_icon(), but IconSet needs base
// images to work with. The base images and when to use them are described by a
// IconSource.
//
// This function copies @source, so you can reuse the same source immediately
// without affecting the icon set.
//
// An example of when you’d use this function: a web browser’s "Back to Previous
// Page" icon might point in a different direction in Hebrew and in English; it
// might look different when insensitive; and it might change size depending on
// toolbar mode (small/large icons). So a single icon set would contain all
// those variants of the icon, and you might add a separate source for each one.
//
// You should nearly always add a “default” icon source with all fields
// wildcarded, which will be used as a fallback if no more specific source
// matches. IconSet always prefers more specific icon sources to more generic
// icon sources. The order in which you add the sources to the icon set does not
// matter.
//
// gtk_icon_set_new_from_pixbuf() creates a new icon set with a default icon
// source based on the given pixbuf.
func (i *IconSet) AddSource(source *IconSource) {
	var arg0 *C.GtkIconSet
	var arg1 *C.GtkIconSource

	arg0 = (*C.GtkIconSet)(i.Native())
	arg1 = (*C.GtkIconSource)(source.Native())

	C.gtk_icon_set_add_source(arg0, arg1)
}

// Copy copies @icon_set by value.
func (i *IconSet) Copy() *IconSet {
	var arg0 *C.GtkIconSet

	arg0 = (*C.GtkIconSet)(i.Native())

	ret := C.gtk_icon_set_copy(arg0)

	var ret0 *IconSet

	{
		ret0 = WrapIconSet(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *IconSet) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Sizes obtains a list of icon sizes this icon set can render. The returned
// array must be freed with g_free().
func (i *IconSet) Sizes() (sizes []int, nSizes int) {
	var arg0 *C.GtkIconSet
	var arg1 **C.GtkIconSize // out
	var arg2 *C.gint         // out

	arg0 = (*C.GtkIconSet)(i.Native())

	C.gtk_icon_set_get_sizes(arg0, &arg1, &arg2)

	var ret0 []int
	var ret1 int

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret0))
		sliceHeader.Data = uintptr(unsafe.Pointer(arg1))
		sliceHeader.Len = arg2
		sliceHeader.Cap = arg2
		runtime.SetFinalizer(&arg1, func() {
			C.free(unsafe.Pointer(arg1))
		})
		defer runtime.KeepAlive(arg1)
	}

	ret1 = int(arg2)

	return ret0, ret1
}

// Ref increments the reference count on @icon_set.
func (i *IconSet) Ref() *IconSet {
	var arg0 *C.GtkIconSet

	arg0 = (*C.GtkIconSet)(i.Native())

	ret := C.gtk_icon_set_ref(arg0)

	var ret0 *IconSet

	{
		ret0 = WrapIconSet(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *IconSet) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// RenderIcon renders an icon using gtk_style_render_icon(). In most cases,
// gtk_widget_render_icon() is better, since it automatically provides most of
// the arguments from the current widget settings. This function never returns
// nil; if the icon can’t be rendered (perhaps because an image file fails to
// load), a default "missing image" icon will be returned instead.
func (i *IconSet) RenderIcon(style Style, direction TextDirection, state StateType, size int, widget Widget, detail string) gdkpixbuf.Pixbuf {
	var arg0 *C.GtkIconSet
	var arg1 *C.GtkStyle
	var arg2 C.GtkTextDirection
	var arg3 C.GtkStateType
	var arg4 C.GtkIconSize
	var arg5 *C.GtkWidget
	var arg6 *C.gchar

	arg0 = (*C.GtkIconSet)(i.Native())
	arg1 = (*C.GtkStyle)(style.Native())
	arg2 = (C.GtkTextDirection)(direction)
	arg3 = (C.GtkStateType)(state)
	arg4 = C.GtkIconSize(size)
	arg5 = (*C.GtkWidget)(widget.Native())
	arg6 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(arg6))

	ret := C.gtk_icon_set_render_icon(arg0, arg1, arg2, arg3, arg4, arg5, arg6)

	var ret0 gdkpixbuf.Pixbuf

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gdkpixbuf.Pixbuf)

	return ret0
}

// RenderIconPixbuf renders an icon using gtk_render_icon_pixbuf(). In most
// cases, gtk_widget_render_icon_pixbuf() is better, since it automatically
// provides most of the arguments from the current widget settings. This
// function never returns nil; if the icon can’t be rendered (perhaps because an
// image file fails to load), a default "missing image" icon will be returned
// instead.
func (i *IconSet) RenderIconPixbuf(context StyleContext, size int) gdkpixbuf.Pixbuf {
	var arg0 *C.GtkIconSet
	var arg1 *C.GtkStyleContext
	var arg2 C.GtkIconSize

	arg0 = (*C.GtkIconSet)(i.Native())
	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = C.GtkIconSize(size)

	ret := C.gtk_icon_set_render_icon_pixbuf(arg0, arg1, arg2)

	var ret0 gdkpixbuf.Pixbuf

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gdkpixbuf.Pixbuf)

	return ret0
}

// RenderIconSurface renders an icon using gtk_render_icon_pixbuf() and converts
// it to a cairo surface.
//
// This function never returns nil; if the icon can’t be rendered (perhaps
// because an image file fails to load), a default "missing image" icon will be
// returned instead.
func (i *IconSet) RenderIconSurface(context StyleContext, size int, scale int, forWindow gdk.Window) *cairo.Surface {
	var arg0 *C.GtkIconSet
	var arg1 *C.GtkStyleContext
	var arg2 C.GtkIconSize
	var arg3 C.int
	var arg4 *C.GdkWindow

	arg0 = (*C.GtkIconSet)(i.Native())
	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = C.GtkIconSize(size)
	arg3 = C.int(scale)
	arg4 = (*C.GdkWindow)(forWindow.Native())

	ret := C.gtk_icon_set_render_icon_surface(arg0, arg1, arg2, arg3, arg4)

	var ret0 *cairo.Surface

	{
		ret0 = cairo.WrapSurface(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *cairo.Surface) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Unref decrements the reference count on @icon_set, and frees memory if the
// reference count reaches 0.
func (i *IconSet) Unref() {
	var arg0 *C.GtkIconSet

	arg0 = (*C.GtkIconSet)(i.Native())

	C.gtk_icon_set_unref(arg0)
}

type IconSource struct {
	native C.GtkIconSource
}

// WrapIconSource wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapIconSource(ptr unsafe.Pointer) *IconSource {
	if ptr == nil {
		return nil
	}

	return (*IconSource)(ptr)
}

func marshalIconSource(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapIconSource(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (i *IconSource) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

// NewIconSource constructs a struct IconSource.
func NewIconSource() *IconSource {
	ret := C.gtk_icon_source_new()

	var ret0 *IconSource

	{
		ret0 = WrapIconSource(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *IconSource) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Copy creates a copy of @source; mostly useful for language bindings.
func (s *IconSource) Copy() *IconSource {
	var arg0 *C.GtkIconSource

	arg0 = (*C.GtkIconSource)(s.Native())

	ret := C.gtk_icon_source_copy(arg0)

	var ret0 *IconSource

	{
		ret0 = WrapIconSource(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *IconSource) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Free frees a dynamically-allocated icon source, along with its filename,
// size, and pixbuf fields if those are not nil.
func (s *IconSource) Free() {
	var arg0 *C.GtkIconSource

	arg0 = (*C.GtkIconSource)(s.Native())

	C.gtk_icon_source_free(arg0)
}

// Direction obtains the text direction this icon source applies to. The return
// value is only useful/meaningful if the text direction is not wildcarded.
func (s *IconSource) Direction() TextDirection {
	var arg0 *C.GtkIconSource

	arg0 = (*C.GtkIconSource)(s.Native())

	ret := C.gtk_icon_source_get_direction(arg0)

	var ret0 TextDirection

	ret0 = TextDirection(ret)

	return ret0
}

// DirectionWildcarded gets the value set by
// gtk_icon_source_set_direction_wildcarded().
func (s *IconSource) DirectionWildcarded() bool {
	var arg0 *C.GtkIconSource

	arg0 = (*C.GtkIconSource)(s.Native())

	ret := C.gtk_icon_source_get_direction_wildcarded(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// Filename retrieves the source filename, or nil if none is set. The filename
// is not a copy, and should not be modified or expected to persist beyond the
// lifetime of the icon source.
func (s *IconSource) Filename() string {
	var arg0 *C.GtkIconSource

	arg0 = (*C.GtkIconSource)(s.Native())

	ret := C.gtk_icon_source_get_filename(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// IconName retrieves the source icon name, or nil if none is set. The icon_name
// is not a copy, and should not be modified or expected to persist beyond the
// lifetime of the icon source.
func (s *IconSource) IconName() string {
	var arg0 *C.GtkIconSource

	arg0 = (*C.GtkIconSource)(s.Native())

	ret := C.gtk_icon_source_get_icon_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Pixbuf retrieves the source pixbuf, or nil if none is set. In addition, if a
// filename source is in use, this function in some cases will return the pixbuf
// from loaded from the filename. This is, for example, true for the
// GtkIconSource passed to the Style render_icon() virtual function. The
// reference count on the pixbuf is not incremented.
func (s *IconSource) Pixbuf() gdkpixbuf.Pixbuf {
	var arg0 *C.GtkIconSource

	arg0 = (*C.GtkIconSource)(s.Native())

	ret := C.gtk_icon_source_get_pixbuf(arg0)

	var ret0 gdkpixbuf.Pixbuf

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gdkpixbuf.Pixbuf)

	return ret0
}

// Size obtains the icon size this source applies to. The return value is only
// useful/meaningful if the icon size is not wildcarded.
func (s *IconSource) Size() int {
	var arg0 *C.GtkIconSource

	arg0 = (*C.GtkIconSource)(s.Native())

	ret := C.gtk_icon_source_get_size(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// SizeWildcarded gets the value set by gtk_icon_source_set_size_wildcarded().
func (s *IconSource) SizeWildcarded() bool {
	var arg0 *C.GtkIconSource

	arg0 = (*C.GtkIconSource)(s.Native())

	ret := C.gtk_icon_source_get_size_wildcarded(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// State obtains the widget state this icon source applies to. The return value
// is only useful/meaningful if the widget state is not wildcarded.
func (s *IconSource) State() StateType {
	var arg0 *C.GtkIconSource

	arg0 = (*C.GtkIconSource)(s.Native())

	ret := C.gtk_icon_source_get_state(arg0)

	var ret0 StateType

	ret0 = StateType(ret)

	return ret0
}

// StateWildcarded gets the value set by gtk_icon_source_set_state_wildcarded().
func (s *IconSource) StateWildcarded() bool {
	var arg0 *C.GtkIconSource

	arg0 = (*C.GtkIconSource)(s.Native())

	ret := C.gtk_icon_source_get_state_wildcarded(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// SetDirection sets the text direction this icon source is intended to be used
// with.
//
// Setting the text direction on an icon source makes no difference if the text
// direction is wildcarded. Therefore, you should usually call
// gtk_icon_source_set_direction_wildcarded() to un-wildcard it in addition to
// calling this function.
func (s *IconSource) SetDirection(direction TextDirection) {
	var arg0 *C.GtkIconSource
	var arg1 C.GtkTextDirection

	arg0 = (*C.GtkIconSource)(s.Native())
	arg1 = (C.GtkTextDirection)(direction)

	C.gtk_icon_source_set_direction(arg0, arg1)
}

// SetDirectionWildcarded: if the text direction is wildcarded, this source can
// be used as the base image for an icon in any TextDirection. If the text
// direction is not wildcarded, then the text direction the icon source applies
// to should be set with gtk_icon_source_set_direction(), and the icon source
// will only be used with that text direction.
//
// IconSet prefers non-wildcarded sources (exact matches) over wildcarded
// sources, and will use an exact match when possible.
func (s *IconSource) SetDirectionWildcarded(setting bool) {
	var arg0 *C.GtkIconSource
	var arg1 C.gboolean

	arg0 = (*C.GtkIconSource)(s.Native())
	if setting {
		arg1 = C.TRUE
	}

	C.gtk_icon_source_set_direction_wildcarded(arg0, arg1)
}

// SetFilename sets the name of an image file to use as a base image when
// creating icon variants for IconSet. The filename must be absolute.
func (s *IconSource) SetFilename(filename string) {
	var arg0 *C.GtkIconSource
	var arg1 *C.gchar

	arg0 = (*C.GtkIconSource)(s.Native())
	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_icon_source_set_filename(arg0, arg1)
}

// SetIconName sets the name of an icon to look up in the current icon theme to
// use as a base image when creating icon variants for IconSet.
func (s *IconSource) SetIconName(iconName string) {
	var arg0 *C.GtkIconSource
	var arg1 *C.gchar

	arg0 = (*C.GtkIconSource)(s.Native())
	arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_icon_source_set_icon_name(arg0, arg1)
}

// SetPixbuf sets a pixbuf to use as a base image when creating icon variants
// for IconSet.
func (s *IconSource) SetPixbuf(pixbuf gdkpixbuf.Pixbuf) {
	var arg0 *C.GtkIconSource
	var arg1 *C.GdkPixbuf

	arg0 = (*C.GtkIconSource)(s.Native())
	arg1 = (*C.GdkPixbuf)(pixbuf.Native())

	C.gtk_icon_source_set_pixbuf(arg0, arg1)
}

// SetSize sets the icon size this icon source is intended to be used with.
//
// Setting the icon size on an icon source makes no difference if the size is
// wildcarded. Therefore, you should usually call
// gtk_icon_source_set_size_wildcarded() to un-wildcard it in addition to
// calling this function.
func (s *IconSource) SetSize(size int) {
	var arg0 *C.GtkIconSource
	var arg1 C.GtkIconSize

	arg0 = (*C.GtkIconSource)(s.Native())
	arg1 = C.GtkIconSize(size)

	C.gtk_icon_source_set_size(arg0, arg1)
}

// SetSizeWildcarded: if the icon size is wildcarded, this source can be used as
// the base image for an icon of any size. If the size is not wildcarded, then
// the size the source applies to should be set with gtk_icon_source_set_size()
// and the icon source will only be used with that specific size.
//
// IconSet prefers non-wildcarded sources (exact matches) over wildcarded
// sources, and will use an exact match when possible.
//
// IconSet will normally scale wildcarded source images to produce an
// appropriate icon at a given size, but will not change the size of source
// images that match exactly.
func (s *IconSource) SetSizeWildcarded(setting bool) {
	var arg0 *C.GtkIconSource
	var arg1 C.gboolean

	arg0 = (*C.GtkIconSource)(s.Native())
	if setting {
		arg1 = C.TRUE
	}

	C.gtk_icon_source_set_size_wildcarded(arg0, arg1)
}

// SetState sets the widget state this icon source is intended to be used with.
//
// Setting the widget state on an icon source makes no difference if the state
// is wildcarded. Therefore, you should usually call
// gtk_icon_source_set_state_wildcarded() to un-wildcard it in addition to
// calling this function.
func (s *IconSource) SetState(state StateType) {
	var arg0 *C.GtkIconSource
	var arg1 C.GtkStateType

	arg0 = (*C.GtkIconSource)(s.Native())
	arg1 = (C.GtkStateType)(state)

	C.gtk_icon_source_set_state(arg0, arg1)
}

// SetStateWildcarded: if the widget state is wildcarded, this source can be
// used as the base image for an icon in any StateType. If the widget state is
// not wildcarded, then the state the source applies to should be set with
// gtk_icon_source_set_state() and the icon source will only be used with that
// specific state.
//
// IconSet prefers non-wildcarded sources (exact matches) over wildcarded
// sources, and will use an exact match when possible.
//
// IconSet will normally transform wildcarded source images to produce an
// appropriate icon for a given state, for example lightening an image on
// prelight, but will not modify source images that match exactly.
func (s *IconSource) SetStateWildcarded(setting bool) {
	var arg0 *C.GtkIconSource
	var arg1 C.gboolean

	arg0 = (*C.GtkIconSource)(s.Native())
	if setting {
		arg1 = C.TRUE
	}

	C.gtk_icon_source_set_state_wildcarded(arg0, arg1)
}

type SelectionData struct {
	native C.GtkSelectionData
}

// WrapSelectionData wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSelectionData(ptr unsafe.Pointer) *SelectionData {
	if ptr == nil {
		return nil
	}

	return (*SelectionData)(ptr)
}

func marshalSelectionData(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSelectionData(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *SelectionData) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// Copy makes a copy of a SelectionData-struct and its data.
func (d *SelectionData) Copy() *SelectionData {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(d.Native())

	ret := C.gtk_selection_data_copy(arg0)

	var ret0 *SelectionData

	{
		ret0 = WrapSelectionData(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *SelectionData) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Free frees a SelectionData-struct returned from gtk_selection_data_copy().
func (d *SelectionData) Free() {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(d.Native())

	C.gtk_selection_data_free(arg0)
}

// DataType retrieves the data type of the selection.
func (s *SelectionData) DataType() gdk.Atom {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(s.Native())

	ret := C.gtk_selection_data_get_data_type(arg0)

	var ret0 gdk.Atom

	{
		ret0 = gdk.WrapAtom(unsafe.Pointer(ret))
	}

	return ret0
}

// DataWithLength retrieves the raw data of the selection along with its length.
func (s *SelectionData) DataWithLength() (length int, guint8s []byte) {
	var arg0 *C.GtkSelectionData
	var arg1 *C.gint // out

	arg0 = (*C.GtkSelectionData)(s.Native())

	ret := C.gtk_selection_data_get_data_with_length(arg0, &arg1)

	var ret0 int
	var ret1 []byte

	ret0 = int(arg1)

	{
		ret1 = make([]byte, arg1)
		for i := 0; i < uintptr(arg1); i++ {
			src := (C.guchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = byte(src)
		}
	}

	return ret0, ret1
}

// Display retrieves the display of the selection.
func (s *SelectionData) Display() gdk.Display {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(s.Native())

	ret := C.gtk_selection_data_get_display(arg0)

	var ret0 gdk.Display

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gdk.Display)

	return ret0
}

// Format retrieves the format of the selection.
func (s *SelectionData) Format() int {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(s.Native())

	ret := C.gtk_selection_data_get_format(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Length retrieves the length of the raw data of the selection.
func (s *SelectionData) Length() int {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(s.Native())

	ret := C.gtk_selection_data_get_length(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Pixbuf gets the contents of the selection data as a Pixbuf.
func (s *SelectionData) Pixbuf() gdkpixbuf.Pixbuf {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(s.Native())

	ret := C.gtk_selection_data_get_pixbuf(arg0)

	var ret0 gdkpixbuf.Pixbuf

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gdkpixbuf.Pixbuf)

	return ret0
}

// Selection retrieves the selection Atom of the selection data.
func (s *SelectionData) Selection() gdk.Atom {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(s.Native())

	ret := C.gtk_selection_data_get_selection(arg0)

	var ret0 gdk.Atom

	{
		ret0 = gdk.WrapAtom(unsafe.Pointer(ret))
	}

	return ret0
}

// Target retrieves the target of the selection.
func (s *SelectionData) Target() gdk.Atom {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(s.Native())

	ret := C.gtk_selection_data_get_target(arg0)

	var ret0 gdk.Atom

	{
		ret0 = gdk.WrapAtom(unsafe.Pointer(ret))
	}

	return ret0
}

// Targets gets the contents of @selection_data as an array of targets. This can
// be used to interpret the results of getting the standard TARGETS target that
// is always supplied for any selection.
func (s *SelectionData) Targets() (targets []*gdk.Atom, nAtoms int, ok bool) {
	var arg0 *C.GtkSelectionData
	var arg1 **C.GdkAtom // out
	var arg2 *C.gint     // out

	arg0 = (*C.GtkSelectionData)(s.Native())

	ret := C.gtk_selection_data_get_targets(arg0, &arg1, &arg2)

	var ret0 []*gdk.Atom
	var ret1 int
	var ret2 bool

	{
		ret0 = make([]*gdk.Atom, arg2)
		for i := 0; i < uintptr(arg2); i++ {
			src := (*C.GdkAtom)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			{
				ret0[i] = gdk.WrapAtom(unsafe.Pointer(src))
			}
		}
	}

	ret1 = int(arg2)

	ret2 = C.bool(ret) != C.false

	return ret0, ret1, ret2
}

// Text gets the contents of the selection data as a UTF-8 string.
func (s *SelectionData) Text() string {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(s.Native())

	ret := C.gtk_selection_data_get_text(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Uris gets the contents of the selection data as array of URIs.
func (s *SelectionData) Uris() []string {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(s.Native())

	ret := C.gtk_selection_data_get_uris(arg0)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// Set stores new data into a SelectionData object. Should only be called from a
// selection handler callback. Zero-terminates the stored data.
func (s *SelectionData) Set(typ gdk.Atom, format int, data []byte) {
	var arg0 *C.GtkSelectionData
	var arg1 C.GdkAtom
	var arg2 C.gint
	var arg3 *C.guchar
	var arg4 C.gint

	arg0 = (*C.GtkSelectionData)(s.Native())
	arg1 = (C.GdkAtom)(typ.Native())
	arg2 = C.gint(format)
	arg3 = (*C.guchar)(unsafe.Pointer(&data[0]))
	arg4 = len(data)
	defer runtime.KeepAlive(data)

	C.gtk_selection_data_set(arg0, arg1, arg2, arg3, arg4)
}

// SetPixbuf sets the contents of the selection from a Pixbuf The pixbuf is
// converted to the form determined by @selection_data->target.
func (s *SelectionData) SetPixbuf(pixbuf gdkpixbuf.Pixbuf) bool {
	var arg0 *C.GtkSelectionData
	var arg1 *C.GdkPixbuf

	arg0 = (*C.GtkSelectionData)(s.Native())
	arg1 = (*C.GdkPixbuf)(pixbuf.Native())

	ret := C.gtk_selection_data_set_pixbuf(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// SetText sets the contents of the selection from a UTF-8 encoded string. The
// string is converted to the form determined by @selection_data->target.
func (s *SelectionData) SetText(str string, len int) bool {
	var arg0 *C.GtkSelectionData
	var arg1 *C.gchar
	var arg2 C.gint

	arg0 = (*C.GtkSelectionData)(s.Native())
	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(len)

	ret := C.gtk_selection_data_set_text(arg0, arg1, arg2)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// SetUris sets the contents of the selection from a list of URIs. The string is
// converted to the form determined by @selection_data->target.
func (s *SelectionData) SetUris(uris []string) bool {
	var arg0 *C.GtkSelectionData
	var arg1 **C.gchar

	arg0 = (*C.GtkSelectionData)(s.Native())
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(uris) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(uris)
		sliceHeader.Cap = len(uris)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(uris); i++ {
			src := uris[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg1 = (**C.gchar)(unsafe.Pointer(ptr))
	}

	ret := C.gtk_selection_data_set_uris(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// TargetsIncludeImage: given a SelectionData object holding a list of targets,
// determines if any of the targets in @targets can be used to provide a Pixbuf.
func (s *SelectionData) TargetsIncludeImage(writable bool) bool {
	var arg0 *C.GtkSelectionData
	var arg1 C.gboolean

	arg0 = (*C.GtkSelectionData)(s.Native())
	if writable {
		arg1 = C.TRUE
	}

	ret := C.gtk_selection_data_targets_include_image(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// TargetsIncludeRichText: given a SelectionData object holding a list of
// targets, determines if any of the targets in @targets can be used to provide
// rich text.
func (s *SelectionData) TargetsIncludeRichText(buffer TextBuffer) bool {
	var arg0 *C.GtkSelectionData
	var arg1 *C.GtkTextBuffer

	arg0 = (*C.GtkSelectionData)(s.Native())
	arg1 = (*C.GtkTextBuffer)(buffer.Native())

	ret := C.gtk_selection_data_targets_include_rich_text(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// TargetsIncludeText: given a SelectionData object holding a list of targets,
// determines if any of the targets in @targets can be used to provide text.
func (s *SelectionData) TargetsIncludeText() bool {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(s.Native())

	ret := C.gtk_selection_data_targets_include_text(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// TargetsIncludeURI: given a SelectionData object holding a list of targets,
// determines if any of the targets in @targets can be used to provide a list or
// URIs.
func (s *SelectionData) TargetsIncludeURI() bool {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(s.Native())

	ret := C.gtk_selection_data_targets_include_uri(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// WidgetPath: gtkWidgetPath is a boxed type that represents a widget hierarchy
// from the topmost widget, typically a toplevel, to any child. This widget path
// abstraction is used in StyleContext on behalf of the real widget in order to
// query style information.
//
// If you are using GTK+ widgets, you probably will not need to use this API
// directly, as there is gtk_widget_get_path(), and the style context returned
// by gtk_widget_get_style_context() will be automatically updated on widget
// hierarchy changes.
//
// The widget path generation is generally simple:
//
// Defining a button within a window
//
//    {
//      GtkWidgetPath *path;
//      guint pos;
//
//      path = gtk_widget_path_new ();
//
//      pos = gtk_widget_path_append_type (path, GTK_TYPE_NOTEBOOK);
//      gtk_widget_path_iter_add_region (path, pos, "tab", GTK_REGION_EVEN | GTK_REGION_FIRST);
//
//      pos = gtk_widget_path_append_type (path, GTK_TYPE_LABEL);
//      gtk_widget_path_iter_set_name (path, pos, "first tab label");
//    }
//
// All this information will be used to match the style information that applies
// to the described widget.
type WidgetPath struct {
	native C.GtkWidgetPath
}

// WrapWidgetPath wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapWidgetPath(ptr unsafe.Pointer) *WidgetPath {
	if ptr == nil {
		return nil
	}

	return (*WidgetPath)(ptr)
}

func marshalWidgetPath(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapWidgetPath(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (w *WidgetPath) Native() unsafe.Pointer {
	return unsafe.Pointer(&w.native)
}

// NewWidgetPath constructs a struct WidgetPath.
func NewWidgetPath() *WidgetPath {
	ret := C.gtk_widget_path_new()

	var ret0 *WidgetPath

	{
		ret0 = WrapWidgetPath(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *WidgetPath) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// AppendForWidget appends the data from @widget to the widget hierarchy
// represented by @path. This function is a shortcut for adding information from
// @widget to the given @path. This includes setting the name or adding the
// style classes from @widget.
func (p *WidgetPath) AppendForWidget(widget Widget) int {
	var arg0 *C.GtkWidgetPath
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkWidgetPath)(p.Native())
	arg1 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_path_append_for_widget(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// AppendType appends a widget type to the widget hierarchy represented by
// @path.
func (p *WidgetPath) AppendType(typ externglib.Type) int {
	var arg0 *C.GtkWidgetPath
	var arg1 C.GType

	arg0 = (*C.GtkWidgetPath)(p.Native())
	arg1 = C.GType(typ)

	ret := C.gtk_widget_path_append_type(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// AppendWithSiblings appends a widget type with all its siblings to the widget
// hierarchy represented by @path. Using this function instead of
// gtk_widget_path_append_type() will allow the CSS theming to use sibling
// matches in selectors and apply :nth-child() pseudo classes. In turn, it
// requires a lot more care in widget implementations as widgets need to make
// sure to call gtk_widget_reset_style() on all involved widgets when the
// @siblings path changes.
func (p *WidgetPath) AppendWithSiblings(siblings *WidgetPath, siblingIndex uint) int {
	var arg0 *C.GtkWidgetPath
	var arg1 *C.GtkWidgetPath
	var arg2 C.guint

	arg0 = (*C.GtkWidgetPath)(p.Native())
	arg1 = (*C.GtkWidgetPath)(siblings.Native())
	arg2 = C.guint(siblingIndex)

	ret := C.gtk_widget_path_append_with_siblings(arg0, arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Copy returns a copy of @path
func (p *WidgetPath) Copy() *WidgetPath {
	var arg0 *C.GtkWidgetPath

	arg0 = (*C.GtkWidgetPath)(p.Native())

	ret := C.gtk_widget_path_copy(arg0)

	var ret0 *WidgetPath

	{
		ret0 = WrapWidgetPath(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *WidgetPath) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Free decrements the reference count on @path, freeing the structure if the
// reference count reaches 0.
func (p *WidgetPath) Free() {
	var arg0 *C.GtkWidgetPath

	arg0 = (*C.GtkWidgetPath)(p.Native())

	C.gtk_widget_path_free(arg0)
}

// ObjectType returns the topmost object type, that is, the object type this
// path is representing.
func (p *WidgetPath) ObjectType() externglib.Type {
	var arg0 *C.GtkWidgetPath

	arg0 = (*C.GtkWidgetPath)(p.Native())

	ret := C.gtk_widget_path_get_object_type(arg0)

	var ret0 externglib.Type

	ret0 = externglib.Type(ret)

	return ret0
}

// HasParent returns true if any of the parents of the widget represented in
// @path is of type @type, or any subtype of it.
func (p *WidgetPath) HasParent(typ externglib.Type) bool {
	var arg0 *C.GtkWidgetPath
	var arg1 C.GType

	arg0 = (*C.GtkWidgetPath)(p.Native())
	arg1 = C.GType(typ)

	ret := C.gtk_widget_path_has_parent(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// IsType returns true if the widget type represented by this path is @type, or
// a subtype of it.
func (p *WidgetPath) IsType(typ externglib.Type) bool {
	var arg0 *C.GtkWidgetPath
	var arg1 C.GType

	arg0 = (*C.GtkWidgetPath)(p.Native())
	arg1 = C.GType(typ)

	ret := C.gtk_widget_path_is_type(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// IterAddClass adds the class @name to the widget at position @pos in the
// hierarchy defined in @path. See gtk_style_context_add_class().
func (p *WidgetPath) IterAddClass(pos int, name string) {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint
	var arg2 *C.gchar

	arg0 = (*C.GtkWidgetPath)(p.Native())
	arg1 = C.gint(pos)
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_widget_path_iter_add_class(arg0, arg1, arg2)
}

// IterAddRegion adds the region @name to the widget at position @pos in the
// hierarchy defined in @path. See gtk_style_context_add_region().
//
// Region names must only contain lowercase letters and “-”, starting always
// with a lowercase letter.
func (p *WidgetPath) IterAddRegion(pos int, name string, flags RegionFlags) {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint
	var arg2 *C.gchar
	var arg3 C.GtkRegionFlags

	arg0 = (*C.GtkWidgetPath)(p.Native())
	arg1 = C.gint(pos)
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (C.GtkRegionFlags)(flags)

	C.gtk_widget_path_iter_add_region(arg0, arg1, arg2, arg3)
}

// IterClearClasses removes all classes from the widget at position @pos in the
// hierarchy defined in @path.
func (p *WidgetPath) IterClearClasses(pos int) {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint

	arg0 = (*C.GtkWidgetPath)(p.Native())
	arg1 = C.gint(pos)

	C.gtk_widget_path_iter_clear_classes(arg0, arg1)
}

// IterClearRegions removes all regions from the widget at position @pos in the
// hierarchy defined in @path.
func (p *WidgetPath) IterClearRegions(pos int) {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint

	arg0 = (*C.GtkWidgetPath)(p.Native())
	arg1 = C.gint(pos)

	C.gtk_widget_path_iter_clear_regions(arg0, arg1)
}

// IterGetName returns the name corresponding to the widget found at the
// position @pos in the widget hierarchy defined by @path
func (p *WidgetPath) IterGetName(pos int) string {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint

	arg0 = (*C.GtkWidgetPath)(p.Native())
	arg1 = C.gint(pos)

	ret := C.gtk_widget_path_iter_get_name(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// IterGetObjectName returns the object name that is at position @pos in the
// widget hierarchy defined in @path.
func (p *WidgetPath) IterGetObjectName(pos int) string {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint

	arg0 = (*C.GtkWidgetPath)(p.Native())
	arg1 = C.gint(pos)

	ret := C.gtk_widget_path_iter_get_object_name(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// IterGetObjectType returns the object #GType that is at position @pos in the
// widget hierarchy defined in @path.
func (p *WidgetPath) IterGetObjectType(pos int) externglib.Type {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint

	arg0 = (*C.GtkWidgetPath)(p.Native())
	arg1 = C.gint(pos)

	ret := C.gtk_widget_path_iter_get_object_type(arg0, arg1)

	var ret0 externglib.Type

	ret0 = externglib.Type(ret)

	return ret0
}

// IterGetSiblingIndex returns the index into the list of siblings for the
// element at @pos as returned by gtk_widget_path_iter_get_siblings(). If that
// function would return nil because the element at @pos has no siblings, this
// function will return 0.
func (p *WidgetPath) IterGetSiblingIndex(pos int) uint {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint

	arg0 = (*C.GtkWidgetPath)(p.Native())
	arg1 = C.gint(pos)

	ret := C.gtk_widget_path_iter_get_sibling_index(arg0, arg1)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// IterGetSiblings returns the list of siblings for the element at @pos. If the
// element was not added with siblings, nil is returned.
func (p *WidgetPath) IterGetSiblings(pos int) *WidgetPath {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint

	arg0 = (*C.GtkWidgetPath)(p.Native())
	arg1 = C.gint(pos)

	ret := C.gtk_widget_path_iter_get_siblings(arg0, arg1)

	var ret0 *WidgetPath

	{
		ret0 = WrapWidgetPath(unsafe.Pointer(ret))
	}

	return ret0
}

// IterGetState returns the state flags corresponding to the widget found at the
// position @pos in the widget hierarchy defined by @path
func (p *WidgetPath) IterGetState(pos int) StateFlags {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint

	arg0 = (*C.GtkWidgetPath)(p.Native())
	arg1 = C.gint(pos)

	ret := C.gtk_widget_path_iter_get_state(arg0, arg1)

	var ret0 StateFlags

	ret0 = StateFlags(ret)

	return ret0
}

// IterHasClass returns true if the widget at position @pos has the class @name
// defined, false otherwise.
func (p *WidgetPath) IterHasClass(pos int, name string) bool {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint
	var arg2 *C.gchar

	arg0 = (*C.GtkWidgetPath)(p.Native())
	arg1 = C.gint(pos)
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_widget_path_iter_has_class(arg0, arg1, arg2)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// IterHasName returns true if the widget at position @pos has the name @name,
// false otherwise.
func (p *WidgetPath) IterHasName(pos int, name string) bool {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint
	var arg2 *C.gchar

	arg0 = (*C.GtkWidgetPath)(p.Native())
	arg1 = C.gint(pos)
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_widget_path_iter_has_name(arg0, arg1, arg2)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// IterHasRegion returns true if the widget at position @pos has the class @name
// defined, false otherwise.
func (p *WidgetPath) IterHasRegion(pos int, name string) (flags RegionFlags, ok bool) {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint
	var arg2 *C.gchar
	var arg3 *C.GtkRegionFlags // out

	arg0 = (*C.GtkWidgetPath)(p.Native())
	arg1 = C.gint(pos)
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_widget_path_iter_has_region(arg0, arg1, arg2, &arg3)

	var ret0 *RegionFlags
	var ret1 bool

	ret0 = (*RegionFlags)(arg3)

	ret1 = C.bool(ret) != C.false

	return ret0, ret1
}

// IterListClasses returns a list with all the class names defined for the
// widget at position @pos in the hierarchy defined in @path.
func (p *WidgetPath) IterListClasses(pos int) *glib.SList {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint

	arg0 = (*C.GtkWidgetPath)(p.Native())
	arg1 = C.gint(pos)

	ret := C.gtk_widget_path_iter_list_classes(arg0, arg1)

	var ret0 *glib.SList

	{
		ret0 = glib.WrapSList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.SList) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// IterListRegions returns a list with all the region names defined for the
// widget at position @pos in the hierarchy defined in @path.
func (p *WidgetPath) IterListRegions(pos int) *glib.SList {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint

	arg0 = (*C.GtkWidgetPath)(p.Native())
	arg1 = C.gint(pos)

	ret := C.gtk_widget_path_iter_list_regions(arg0, arg1)

	var ret0 *glib.SList

	{
		ret0 = glib.WrapSList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.SList) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// IterRemoveClass removes the class @name from the widget at position @pos in
// the hierarchy defined in @path.
func (p *WidgetPath) IterRemoveClass(pos int, name string) {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint
	var arg2 *C.gchar

	arg0 = (*C.GtkWidgetPath)(p.Native())
	arg1 = C.gint(pos)
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_widget_path_iter_remove_class(arg0, arg1, arg2)
}

// IterRemoveRegion removes the region @name from the widget at position @pos in
// the hierarchy defined in @path.
func (p *WidgetPath) IterRemoveRegion(pos int, name string) {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint
	var arg2 *C.gchar

	arg0 = (*C.GtkWidgetPath)(p.Native())
	arg1 = C.gint(pos)
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_widget_path_iter_remove_region(arg0, arg1, arg2)
}

// IterSetName sets the widget name for the widget found at position @pos in the
// widget hierarchy defined by @path.
func (p *WidgetPath) IterSetName(pos int, name string) {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint
	var arg2 *C.gchar

	arg0 = (*C.GtkWidgetPath)(p.Native())
	arg1 = C.gint(pos)
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_widget_path_iter_set_name(arg0, arg1, arg2)
}

// IterSetObjectName sets the object name for a given position in the widget
// hierarchy defined by @path.
//
// When set, the object name overrides the object type when matching CSS.
func (p *WidgetPath) IterSetObjectName(pos int, name string) {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint
	var arg2 *C.char

	arg0 = (*C.GtkWidgetPath)(p.Native())
	arg1 = C.gint(pos)
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_widget_path_iter_set_object_name(arg0, arg1, arg2)
}

// IterSetObjectType sets the object type for a given position in the widget
// hierarchy defined by @path.
func (p *WidgetPath) IterSetObjectType(pos int, typ externglib.Type) {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint
	var arg2 C.GType

	arg0 = (*C.GtkWidgetPath)(p.Native())
	arg1 = C.gint(pos)
	arg2 = C.GType(typ)

	C.gtk_widget_path_iter_set_object_type(arg0, arg1, arg2)
}

// IterSetState sets the widget name for the widget found at position @pos in
// the widget hierarchy defined by @path.
//
// If you want to update just a single state flag, you need to do this manually,
// as this function updates all state flags.
//
// Setting a flag
//
//    gtk_widget_path_iter_set_state (path, pos, gtk_widget_path_iter_get_state (path, pos) & ~flag);
func (p *WidgetPath) IterSetState(pos int, state StateFlags) {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint
	var arg2 C.GtkStateFlags

	arg0 = (*C.GtkWidgetPath)(p.Native())
	arg1 = C.gint(pos)
	arg2 = (C.GtkStateFlags)(state)

	C.gtk_widget_path_iter_set_state(arg0, arg1, arg2)
}

// Length returns the number of Widget #GTypes between the represented widget
// and its topmost container.
func (p *WidgetPath) Length() int {
	var arg0 *C.GtkWidgetPath

	arg0 = (*C.GtkWidgetPath)(p.Native())

	ret := C.gtk_widget_path_length(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// PrependType prepends a widget type to the widget hierachy represented by
// @path.
func (p *WidgetPath) PrependType(typ externglib.Type) {
	var arg0 *C.GtkWidgetPath
	var arg1 C.GType

	arg0 = (*C.GtkWidgetPath)(p.Native())
	arg1 = C.GType(typ)

	C.gtk_widget_path_prepend_type(arg0, arg1)
}

// Ref increments the reference count on @path.
func (p *WidgetPath) Ref() *WidgetPath {
	var arg0 *C.GtkWidgetPath

	arg0 = (*C.GtkWidgetPath)(p.Native())

	ret := C.gtk_widget_path_ref(arg0)

	var ret0 *WidgetPath

	{
		ret0 = WrapWidgetPath(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *WidgetPath) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// String dumps the widget path into a string representation. It tries to match
// the CSS style as closely as possible (Note that there might be paths that
// cannot be represented in CSS).
//
// The main use of this code is for debugging purposes, so that you can
// g_print() the path or dump it in a gdb session.
func (p *WidgetPath) String() string {
	var arg0 *C.GtkWidgetPath

	arg0 = (*C.GtkWidgetPath)(p.Native())

	ret := C.gtk_widget_path_to_string(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Unref decrements the reference count on @path, freeing the structure if the
// reference count reaches 0.
func (p *WidgetPath) Unref() {
	var arg0 *C.GtkWidgetPath

	arg0 = (*C.GtkWidgetPath)(p.Native())

	C.gtk_widget_path_unref(arg0)
}
