// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	"github.com/diamondburned/gotk4/pkg/gobject/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_icon_set_get_type()), F: marshalIconSet},
		{T: externglib.Type(C.gtk_icon_source_get_type()), F: marshalIconSource},
		{T: externglib.Type(C.gtk_selection_data_get_type()), F: marshalSelectionData},
		{T: externglib.Type(C.gtk_widget_path_get_type()), F: marshalWidgetPath},
	})
}

// BuilderConnectFunc: this is the signature of a function used to connect
// signals. It is used by the gtk_builder_connect_signals() and
// gtk_builder_connect_signals_full() methods. It is mainly intended for
// interpreted language bindings, but could be useful where the programmer wants
// more control over the signal connection process. Note that this function can
// only be called once, subsequent calls will do nothing.
type BuilderConnectFunc func(builder Builder, object gextras.Objector, signalName string, handlerName string, connectObject gextras.Objector, flags gobject.ConnectFlags)

//export gotk4_BuilderConnectFunc
func gotk4_BuilderConnectFunc(arg0 *C.GtkBuilder, arg1 *C.GObject, arg2 *C.gchar, arg3 *C.gchar, arg4 *C.GObject, arg5 C.GConnectFlags, arg6 C.gpointer) {
	v := box.Get(uintptr(arg6))
	if v == nil {
		panic(`callback not found`)
	}

	fn := v.(BuilderConnectFunc)
	fn(builder, object, signalName, handlerName, connectObject, flags, userData)
}

type IconSet struct {
	native C.GtkIconSet
}

// WrapIconSet wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapIconSet(ptr unsafe.Pointer) *IconSet {
	if ptr == nil {
		return nil
	}

	return (*IconSet)(ptr)
}

func marshalIconSet(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapIconSet(unsafe.Pointer(b)), nil
}

// NewIconSet constructs a struct IconSet.
func NewIconSet() *IconSet {
	var cret *C.GtkIconSet
	var goret1 *IconSet

	cret = C.gtk_icon_set_new()

	goret1 = WrapIconSet(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret1, func(v *IconSet) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret1
}

// NewIconSetFromPixbuf constructs a struct IconSet.
func NewIconSetFromPixbuf(pixbuf gdkpixbuf.Pixbuf) *IconSet {
	var arg1 *C.GdkPixbuf

	arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	var cret *C.GtkIconSet
	var goret1 *IconSet

	cret = C.gtk_icon_set_new_from_pixbuf(pixbuf)

	goret1 = WrapIconSet(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret1, func(v *IconSet) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret1
}

// Native returns the underlying C source pointer.
func (i *IconSet) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

// AddSource: icon sets have a list of IconSource, which they use as base icons
// for rendering icons in different states and sizes. Icons are scaled, made to
// look insensitive, etc. in gtk_icon_set_render_icon(), but IconSet needs base
// images to work with. The base images and when to use them are described by a
// IconSource.
//
// This function copies @source, so you can reuse the same source immediately
// without affecting the icon set.
//
// An example of when you’d use this function: a web browser’s "Back to Previous
// Page" icon might point in a different direction in Hebrew and in English; it
// might look different when insensitive; and it might change size depending on
// toolbar mode (small/large icons). So a single icon set would contain all
// those variants of the icon, and you might add a separate source for each one.
//
// You should nearly always add a “default” icon source with all fields
// wildcarded, which will be used as a fallback if no more specific source
// matches. IconSet always prefers more specific icon sources to more generic
// icon sources. The order in which you add the sources to the icon set does not
// matter.
//
// gtk_icon_set_new_from_pixbuf() creates a new icon set with a default icon
// source based on the given pixbuf.
func (i *IconSet) AddSource(source *IconSource) {
	var arg0 *C.GtkIconSet
	var arg1 *C.GtkIconSource

	arg0 = (*C.GtkIconSet)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkIconSource)(unsafe.Pointer(source.Native()))

	C.gtk_icon_set_add_source(arg0, source)
}

// Copy copies @icon_set by value.
func (i *IconSet) Copy() *IconSet {
	var arg0 *C.GtkIconSet

	arg0 = (*C.GtkIconSet)(unsafe.Pointer(i.Native()))

	var cret *C.GtkIconSet
	var goret1 *IconSet

	cret = C.gtk_icon_set_copy(arg0)

	goret1 = WrapIconSet(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret1, func(v *IconSet) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret1
}

// Sizes obtains a list of icon sizes this icon set can render. The returned
// array must be freed with g_free().
func (i *IconSet) Sizes() (sizes []int, nSizes int) {
	var arg0 *C.GtkIconSet

	arg0 = (*C.GtkIconSet)(unsafe.Pointer(i.Native()))

	C.gtk_icon_set_get_sizes(arg0, &arg1, &arg2)

	return ret1, ret2
}

// Ref increments the reference count on @icon_set.
func (i *IconSet) Ref() *IconSet {
	var arg0 *C.GtkIconSet

	arg0 = (*C.GtkIconSet)(unsafe.Pointer(i.Native()))

	var cret *C.GtkIconSet
	var goret1 *IconSet

	cret = C.gtk_icon_set_ref(arg0)

	goret1 = WrapIconSet(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret1, func(v *IconSet) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret1
}

// RenderIcon renders an icon using gtk_style_render_icon(). In most cases,
// gtk_widget_render_icon() is better, since it automatically provides most of
// the arguments from the current widget settings. This function never returns
// nil; if the icon can’t be rendered (perhaps because an image file fails to
// load), a default "missing image" icon will be returned instead.
func (i *IconSet) RenderIcon(style Style, direction TextDirection, state StateType, size int, widget Widget, detail string) gdkpixbuf.Pixbuf {
	var arg0 *C.GtkIconSet
	var arg1 *C.GtkStyle
	var arg2 C.GtkTextDirection
	var arg3 C.GtkStateType
	var arg4 C.GtkIconSize
	var arg5 *C.GtkWidget
	var arg6 *C.gchar

	arg0 = (*C.GtkIconSet)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
	arg2 = (C.GtkTextDirection)(direction)
	arg3 = (C.GtkStateType)(state)
	arg4 = C.GtkIconSize(size)
	arg5 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	arg6 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(arg6))

	var cret *C.GdkPixbuf
	var goret1 gdkpixbuf.Pixbuf

	cret = C.gtk_icon_set_render_icon(arg0, style, direction, state, size, widget, detail)

	goret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(gdkpixbuf.Pixbuf)

	return goret1
}

// RenderIconPixbuf renders an icon using gtk_render_icon_pixbuf(). In most
// cases, gtk_widget_render_icon_pixbuf() is better, since it automatically
// provides most of the arguments from the current widget settings. This
// function never returns nil; if the icon can’t be rendered (perhaps because an
// image file fails to load), a default "missing image" icon will be returned
// instead.
func (i *IconSet) RenderIconPixbuf(context StyleContext, size int) gdkpixbuf.Pixbuf {
	var arg0 *C.GtkIconSet
	var arg1 *C.GtkStyleContext
	var arg2 C.GtkIconSize

	arg0 = (*C.GtkIconSet)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	arg2 = C.GtkIconSize(size)

	var cret *C.GdkPixbuf
	var goret1 gdkpixbuf.Pixbuf

	cret = C.gtk_icon_set_render_icon_pixbuf(arg0, context, size)

	goret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(gdkpixbuf.Pixbuf)

	return goret1
}

// RenderIconSurface renders an icon using gtk_render_icon_pixbuf() and converts
// it to a cairo surface.
//
// This function never returns nil; if the icon can’t be rendered (perhaps
// because an image file fails to load), a default "missing image" icon will be
// returned instead.
func (i *IconSet) RenderIconSurface(context StyleContext, size int, scale int, forWindow gdk.Window) *cairo.Surface {
	var arg0 *C.GtkIconSet
	var arg1 *C.GtkStyleContext
	var arg2 C.GtkIconSize
	var arg3 C.int
	var arg4 *C.GdkWindow

	arg0 = (*C.GtkIconSet)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	arg2 = C.GtkIconSize(size)
	arg3 = C.int(scale)
	arg4 = (*C.GdkWindow)(unsafe.Pointer(forWindow.Native()))

	var cret *C.cairo_surface_t
	var goret1 *cairo.Surface

	cret = C.gtk_icon_set_render_icon_surface(arg0, context, size, scale, forWindow)

	goret1 = cairo.WrapSurface(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret1, func(v *cairo.Surface) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret1
}

// Unref decrements the reference count on @icon_set, and frees memory if the
// reference count reaches 0.
func (i *IconSet) Unref() {
	var arg0 *C.GtkIconSet

	arg0 = (*C.GtkIconSet)(unsafe.Pointer(i.Native()))

	C.gtk_icon_set_unref(arg0)
}

type IconSource struct {
	native C.GtkIconSource
}

// WrapIconSource wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapIconSource(ptr unsafe.Pointer) *IconSource {
	if ptr == nil {
		return nil
	}

	return (*IconSource)(ptr)
}

func marshalIconSource(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapIconSource(unsafe.Pointer(b)), nil
}

// NewIconSource constructs a struct IconSource.
func NewIconSource() *IconSource {
	var cret *C.GtkIconSource
	var goret1 *IconSource

	cret = C.gtk_icon_source_new()

	goret1 = WrapIconSource(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret1, func(v *IconSource) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret1
}

// Native returns the underlying C source pointer.
func (i *IconSource) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

// Copy creates a copy of @source; mostly useful for language bindings.
func (s *IconSource) Copy() *IconSource {
	var arg0 *C.GtkIconSource

	arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

	var cret *C.GtkIconSource
	var goret1 *IconSource

	cret = C.gtk_icon_source_copy(arg0)

	goret1 = WrapIconSource(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret1, func(v *IconSource) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret1
}

// Free frees a dynamically-allocated icon source, along with its filename,
// size, and pixbuf fields if those are not nil.
func (s *IconSource) Free() {
	var arg0 *C.GtkIconSource

	arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

	C.gtk_icon_source_free(arg0)
}

// Direction obtains the text direction this icon source applies to. The return
// value is only useful/meaningful if the text direction is not wildcarded.
func (s *IconSource) Direction() TextDirection {
	var arg0 *C.GtkIconSource

	arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

	var cret C.GtkTextDirection
	var goret1 TextDirection

	cret = C.gtk_icon_source_get_direction(arg0)

	goret1 = TextDirection(cret)

	return goret1
}

// DirectionWildcarded gets the value set by
// gtk_icon_source_set_direction_wildcarded().
func (s *IconSource) DirectionWildcarded() bool {
	var arg0 *C.GtkIconSource

	arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_icon_source_get_direction_wildcarded(arg0)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// Filename retrieves the source filename, or nil if none is set. The filename
// is not a copy, and should not be modified or expected to persist beyond the
// lifetime of the icon source.
func (s *IconSource) Filename() string {
	var arg0 *C.GtkIconSource

	arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

	var cret *C.gchar
	var goret1 string

	cret = C.gtk_icon_source_get_filename(arg0)

	goret1 = C.GoString(cret)

	return goret1
}

// IconName retrieves the source icon name, or nil if none is set. The icon_name
// is not a copy, and should not be modified or expected to persist beyond the
// lifetime of the icon source.
func (s *IconSource) IconName() string {
	var arg0 *C.GtkIconSource

	arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

	var cret *C.gchar
	var goret1 string

	cret = C.gtk_icon_source_get_icon_name(arg0)

	goret1 = C.GoString(cret)

	return goret1
}

// Pixbuf retrieves the source pixbuf, or nil if none is set. In addition, if a
// filename source is in use, this function in some cases will return the pixbuf
// from loaded from the filename. This is, for example, true for the
// GtkIconSource passed to the Style render_icon() virtual function. The
// reference count on the pixbuf is not incremented.
func (s *IconSource) Pixbuf() gdkpixbuf.Pixbuf {
	var arg0 *C.GtkIconSource

	arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

	var cret *C.GdkPixbuf
	var goret1 gdkpixbuf.Pixbuf

	cret = C.gtk_icon_source_get_pixbuf(arg0)

	goret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(gdkpixbuf.Pixbuf)

	return goret1
}

// Size obtains the icon size this source applies to. The return value is only
// useful/meaningful if the icon size is not wildcarded.
func (s *IconSource) Size() int {
	var arg0 *C.GtkIconSource

	arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

	var cret C.GtkIconSize
	var goret1 int

	cret = C.gtk_icon_source_get_size(arg0)

	goret1 = C.GtkIconSize(cret)

	return goret1
}

// SizeWildcarded gets the value set by gtk_icon_source_set_size_wildcarded().
func (s *IconSource) SizeWildcarded() bool {
	var arg0 *C.GtkIconSource

	arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_icon_source_get_size_wildcarded(arg0)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// State obtains the widget state this icon source applies to. The return value
// is only useful/meaningful if the widget state is not wildcarded.
func (s *IconSource) State() StateType {
	var arg0 *C.GtkIconSource

	arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

	var cret C.GtkStateType
	var goret1 StateType

	cret = C.gtk_icon_source_get_state(arg0)

	goret1 = StateType(cret)

	return goret1
}

// StateWildcarded gets the value set by gtk_icon_source_set_state_wildcarded().
func (s *IconSource) StateWildcarded() bool {
	var arg0 *C.GtkIconSource

	arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_icon_source_get_state_wildcarded(arg0)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// SetDirection sets the text direction this icon source is intended to be used
// with.
//
// Setting the text direction on an icon source makes no difference if the text
// direction is wildcarded. Therefore, you should usually call
// gtk_icon_source_set_direction_wildcarded() to un-wildcard it in addition to
// calling this function.
func (s *IconSource) SetDirection(direction TextDirection) {
	var arg0 *C.GtkIconSource
	var arg1 C.GtkTextDirection

	arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkTextDirection)(direction)

	C.gtk_icon_source_set_direction(arg0, direction)
}

// SetDirectionWildcarded: if the text direction is wildcarded, this source can
// be used as the base image for an icon in any TextDirection. If the text
// direction is not wildcarded, then the text direction the icon source applies
// to should be set with gtk_icon_source_set_direction(), and the icon source
// will only be used with that text direction.
//
// IconSet prefers non-wildcarded sources (exact matches) over wildcarded
// sources, and will use an exact match when possible.
func (s *IconSource) SetDirectionWildcarded(setting bool) {
	var arg0 *C.GtkIconSource
	var arg1 C.gboolean

	arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_icon_source_set_direction_wildcarded(arg0, setting)
}

// SetFilename sets the name of an image file to use as a base image when
// creating icon variants for IconSet. The filename must be absolute.
func (s *IconSource) SetFilename(filename string) {
	var arg0 *C.GtkIconSource
	var arg1 *C.gchar

	arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_icon_source_set_filename(arg0, filename)
}

// SetIconName sets the name of an icon to look up in the current icon theme to
// use as a base image when creating icon variants for IconSet.
func (s *IconSource) SetIconName(iconName string) {
	var arg0 *C.GtkIconSource
	var arg1 *C.gchar

	arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_icon_source_set_icon_name(arg0, iconName)
}

// SetPixbuf sets a pixbuf to use as a base image when creating icon variants
// for IconSet.
func (s *IconSource) SetPixbuf(pixbuf gdkpixbuf.Pixbuf) {
	var arg0 *C.GtkIconSource
	var arg1 *C.GdkPixbuf

	arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	C.gtk_icon_source_set_pixbuf(arg0, pixbuf)
}

// SetSize sets the icon size this icon source is intended to be used with.
//
// Setting the icon size on an icon source makes no difference if the size is
// wildcarded. Therefore, you should usually call
// gtk_icon_source_set_size_wildcarded() to un-wildcard it in addition to
// calling this function.
func (s *IconSource) SetSize(size int) {
	var arg0 *C.GtkIconSource
	var arg1 C.GtkIconSize

	arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))
	arg1 = C.GtkIconSize(size)

	C.gtk_icon_source_set_size(arg0, size)
}

// SetSizeWildcarded: if the icon size is wildcarded, this source can be used as
// the base image for an icon of any size. If the size is not wildcarded, then
// the size the source applies to should be set with gtk_icon_source_set_size()
// and the icon source will only be used with that specific size.
//
// IconSet prefers non-wildcarded sources (exact matches) over wildcarded
// sources, and will use an exact match when possible.
//
// IconSet will normally scale wildcarded source images to produce an
// appropriate icon at a given size, but will not change the size of source
// images that match exactly.
func (s *IconSource) SetSizeWildcarded(setting bool) {
	var arg0 *C.GtkIconSource
	var arg1 C.gboolean

	arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_icon_source_set_size_wildcarded(arg0, setting)
}

// SetState sets the widget state this icon source is intended to be used with.
//
// Setting the widget state on an icon source makes no difference if the state
// is wildcarded. Therefore, you should usually call
// gtk_icon_source_set_state_wildcarded() to un-wildcard it in addition to
// calling this function.
func (s *IconSource) SetState(state StateType) {
	var arg0 *C.GtkIconSource
	var arg1 C.GtkStateType

	arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkStateType)(state)

	C.gtk_icon_source_set_state(arg0, state)
}

// SetStateWildcarded: if the widget state is wildcarded, this source can be
// used as the base image for an icon in any StateType. If the widget state is
// not wildcarded, then the state the source applies to should be set with
// gtk_icon_source_set_state() and the icon source will only be used with that
// specific state.
//
// IconSet prefers non-wildcarded sources (exact matches) over wildcarded
// sources, and will use an exact match when possible.
//
// IconSet will normally transform wildcarded source images to produce an
// appropriate icon for a given state, for example lightening an image on
// prelight, but will not modify source images that match exactly.
func (s *IconSource) SetStateWildcarded(setting bool) {
	var arg0 *C.GtkIconSource
	var arg1 C.gboolean

	arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_icon_source_set_state_wildcarded(arg0, setting)
}

type SelectionData struct {
	native C.GtkSelectionData
}

// WrapSelectionData wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSelectionData(ptr unsafe.Pointer) *SelectionData {
	if ptr == nil {
		return nil
	}

	return (*SelectionData)(ptr)
}

func marshalSelectionData(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSelectionData(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *SelectionData) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// Copy makes a copy of a SelectionData-struct and its data.
func (d *SelectionData) Copy() *SelectionData {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(unsafe.Pointer(d.Native()))

	var cret *C.GtkSelectionData
	var goret1 *SelectionData

	cret = C.gtk_selection_data_copy(arg0)

	goret1 = WrapSelectionData(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret1, func(v *SelectionData) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret1
}

// Free frees a SelectionData-struct returned from gtk_selection_data_copy().
func (d *SelectionData) Free() {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(unsafe.Pointer(d.Native()))

	C.gtk_selection_data_free(arg0)
}

// DataType retrieves the data type of the selection.
func (s *SelectionData) DataType() gdk.Atom {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

	var cret C.GdkAtom
	var goret1 gdk.Atom

	cret = C.gtk_selection_data_get_data_type(arg0)

	goret1 = gdk.WrapAtom(unsafe.Pointer(cret))

	return goret1
}

// DataWithLength retrieves the raw data of the selection along with its length.
func (s *SelectionData) DataWithLength() (length int, guint8s []byte) {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

	var cret *C.guchar
	var arg1 *C.gint
	var goret2 []byte

	cret = C.gtk_selection_data_get_data_with_length(arg0, &arg1)

	goret2 = make([]byte, arg1)
	for i := 0; i < uintptr(arg1); i++ {
		src := (C.guchar)(ptr.Add(unsafe.Pointer(cret), i))
		goret2[i] = C.guchar(src)
	}

	return ret1, goret2
}

// Display retrieves the display of the selection.
func (s *SelectionData) Display() gdk.Display {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

	var cret *C.GdkDisplay
	var goret1 gdk.Display

	cret = C.gtk_selection_data_get_display(arg0)

	goret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(gdk.Display)

	return goret1
}

// Format retrieves the format of the selection.
func (s *SelectionData) Format() int {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

	var cret C.gint
	var goret1 int

	cret = C.gtk_selection_data_get_format(arg0)

	goret1 = C.gint(cret)

	return goret1
}

// Length retrieves the length of the raw data of the selection.
func (s *SelectionData) Length() int {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

	var cret C.gint
	var goret1 int

	cret = C.gtk_selection_data_get_length(arg0)

	goret1 = C.gint(cret)

	return goret1
}

// Pixbuf gets the contents of the selection data as a Pixbuf.
func (s *SelectionData) Pixbuf() gdkpixbuf.Pixbuf {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

	var cret *C.GdkPixbuf
	var goret1 gdkpixbuf.Pixbuf

	cret = C.gtk_selection_data_get_pixbuf(arg0)

	goret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(gdkpixbuf.Pixbuf)

	return goret1
}

// Selection retrieves the selection Atom of the selection data.
func (s *SelectionData) Selection() gdk.Atom {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

	var cret C.GdkAtom
	var goret1 gdk.Atom

	cret = C.gtk_selection_data_get_selection(arg0)

	goret1 = gdk.WrapAtom(unsafe.Pointer(cret))

	return goret1
}

// Target retrieves the target of the selection.
func (s *SelectionData) Target() gdk.Atom {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

	var cret C.GdkAtom
	var goret1 gdk.Atom

	cret = C.gtk_selection_data_get_target(arg0)

	goret1 = gdk.WrapAtom(unsafe.Pointer(cret))

	return goret1
}

// Targets gets the contents of @selection_data as an array of targets. This can
// be used to interpret the results of getting the standard TARGETS target that
// is always supplied for any selection.
func (s *SelectionData) Targets() (targets []*gdk.Atom, nAtoms int, ok bool) {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

	var cret C.gboolean
	var goret3 bool

	cret = C.gtk_selection_data_get_targets(arg0, &arg1, &arg2)

	goret3 = C.bool(cret) != C.false

	return ret1, ret2, goret3
}

// Text gets the contents of the selection data as a UTF-8 string.
func (s *SelectionData) Text() string {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

	var cret *C.guchar
	var goret1 string

	cret = C.gtk_selection_data_get_text(arg0)

	goret1 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return goret1
}

// Uris gets the contents of the selection data as array of URIs.
func (s *SelectionData) Uris() []string {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

	var cret **C.gchar
	var goret1 []string

	cret = C.gtk_selection_data_get_uris(arg0)

	{
		var length int
		for p := cret; *p != 0; p = (**C.gchar)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		goret1 = make([]string, length)
		for i := uintptr(0); i < uintptr(length); i += unsafe.Sizeof(int(0)) {
			src := (*C.gchar)(ptr.Add(unsafe.Pointer(cret), i))
			goret1[i] = C.GoString(src)
			defer C.free(unsafe.Pointer(src))
		}
	}

	return goret1
}

// Set stores new data into a SelectionData object. Should only be called from a
// selection handler callback. Zero-terminates the stored data.
func (s *SelectionData) Set(typ gdk.Atom, format int, data []byte) {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

	C.gtk_selection_data_set(arg0, typ, format, data, length)
}

// SetPixbuf sets the contents of the selection from a Pixbuf The pixbuf is
// converted to the form determined by @selection_data->target.
func (s *SelectionData) SetPixbuf(pixbuf gdkpixbuf.Pixbuf) bool {
	var arg0 *C.GtkSelectionData
	var arg1 *C.GdkPixbuf

	arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_selection_data_set_pixbuf(arg0, pixbuf)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// SetText sets the contents of the selection from a UTF-8 encoded string. The
// string is converted to the form determined by @selection_data->target.
func (s *SelectionData) SetText(str string, len int) bool {
	var arg0 *C.GtkSelectionData
	var arg1 *C.gchar
	var arg2 C.gint

	arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(len)

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_selection_data_set_text(arg0, str, len)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// SetUris sets the contents of the selection from a list of URIs. The string is
// converted to the form determined by @selection_data->target.
func (s *SelectionData) SetUris(uris []string) bool {
	var arg0 *C.GtkSelectionData
	var arg1 **C.gchar

	arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))
	arg1 = C.malloc(len(uris) * (unsafe.Sizeof(int(0)) + 1))
	defer C.free(unsafe.Pointer(arg1))

	{
		var out []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg1), int(len(uris)))

		for i := range uris {
			out[i] = (*C.gchar)(C.CString(uris[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_selection_data_set_uris(arg0, uris)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// TargetsIncludeImage: given a SelectionData object holding a list of targets,
// determines if any of the targets in @targets can be used to provide a Pixbuf.
func (s *SelectionData) TargetsIncludeImage(writable bool) bool {
	var arg0 *C.GtkSelectionData
	var arg1 C.gboolean

	arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))
	if writable {
		arg1 = C.gboolean(1)
	}

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_selection_data_targets_include_image(arg0, writable)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// TargetsIncludeRichText: given a SelectionData object holding a list of
// targets, determines if any of the targets in @targets can be used to provide
// rich text.
func (s *SelectionData) TargetsIncludeRichText(buffer TextBuffer) bool {
	var arg0 *C.GtkSelectionData
	var arg1 *C.GtkTextBuffer

	arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_selection_data_targets_include_rich_text(arg0, buffer)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// TargetsIncludeText: given a SelectionData object holding a list of targets,
// determines if any of the targets in @targets can be used to provide text.
func (s *SelectionData) TargetsIncludeText() bool {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_selection_data_targets_include_text(arg0)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// TargetsIncludeURI: given a SelectionData object holding a list of targets,
// determines if any of the targets in @targets can be used to provide a list or
// URIs.
func (s *SelectionData) TargetsIncludeURI() bool {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_selection_data_targets_include_uri(arg0)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// WidgetPath: gtkWidgetPath is a boxed type that represents a widget hierarchy
// from the topmost widget, typically a toplevel, to any child. This widget path
// abstraction is used in StyleContext on behalf of the real widget in order to
// query style information.
//
// If you are using GTK+ widgets, you probably will not need to use this API
// directly, as there is gtk_widget_get_path(), and the style context returned
// by gtk_widget_get_style_context() will be automatically updated on widget
// hierarchy changes.
//
// The widget path generation is generally simple:
//
// Defining a button within a window
//
//    {
//      GtkWidgetPath *path;
//      guint pos;
//
//      path = gtk_widget_path_new ();
//
//      pos = gtk_widget_path_append_type (path, GTK_TYPE_NOTEBOOK);
//      gtk_widget_path_iter_add_region (path, pos, "tab", GTK_REGION_EVEN | GTK_REGION_FIRST);
//
//      pos = gtk_widget_path_append_type (path, GTK_TYPE_LABEL);
//      gtk_widget_path_iter_set_name (path, pos, "first tab label");
//    }
//
// All this information will be used to match the style information that applies
// to the described widget.
type WidgetPath struct {
	native C.GtkWidgetPath
}

// WrapWidgetPath wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapWidgetPath(ptr unsafe.Pointer) *WidgetPath {
	if ptr == nil {
		return nil
	}

	return (*WidgetPath)(ptr)
}

func marshalWidgetPath(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapWidgetPath(unsafe.Pointer(b)), nil
}

// NewWidgetPath constructs a struct WidgetPath.
func NewWidgetPath() *WidgetPath {
	var cret *C.GtkWidgetPath
	var goret1 *WidgetPath

	cret = C.gtk_widget_path_new()

	goret1 = WrapWidgetPath(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret1, func(v *WidgetPath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret1
}

// Native returns the underlying C source pointer.
func (w *WidgetPath) Native() unsafe.Pointer {
	return unsafe.Pointer(&w.native)
}

// AppendForWidget appends the data from @widget to the widget hierarchy
// represented by @path. This function is a shortcut for adding information from
// @widget to the given @path. This includes setting the name or adding the
// style classes from @widget.
func (p *WidgetPath) AppendForWidget(widget Widget) int {
	var arg0 *C.GtkWidgetPath
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	var cret C.gint
	var goret1 int

	cret = C.gtk_widget_path_append_for_widget(arg0, widget)

	goret1 = C.gint(cret)

	return goret1
}

// AppendType appends a widget type to the widget hierarchy represented by
// @path.
func (p *WidgetPath) AppendType(typ externglib.Type) int {
	var arg0 *C.GtkWidgetPath
	var arg1 C.GType

	arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	arg1 := C.GType(typ)

	var cret C.gint
	var goret1 int

	cret = C.gtk_widget_path_append_type(arg0, typ)

	goret1 = C.gint(cret)

	return goret1
}

// AppendWithSiblings appends a widget type with all its siblings to the widget
// hierarchy represented by @path. Using this function instead of
// gtk_widget_path_append_type() will allow the CSS theming to use sibling
// matches in selectors and apply :nth-child() pseudo classes. In turn, it
// requires a lot more care in widget implementations as widgets need to make
// sure to call gtk_widget_reset_style() on all involved widgets when the
// @siblings path changes.
func (p *WidgetPath) AppendWithSiblings(siblings *WidgetPath, siblingIndex uint) int {
	var arg0 *C.GtkWidgetPath
	var arg1 *C.GtkWidgetPath
	var arg2 C.guint

	arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	arg1 = (*C.GtkWidgetPath)(unsafe.Pointer(siblings.Native()))
	arg2 = C.guint(siblingIndex)

	var cret C.gint
	var goret1 int

	cret = C.gtk_widget_path_append_with_siblings(arg0, siblings, siblingIndex)

	goret1 = C.gint(cret)

	return goret1
}

// Copy returns a copy of @path
func (p *WidgetPath) Copy() *WidgetPath {
	var arg0 *C.GtkWidgetPath

	arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))

	var cret *C.GtkWidgetPath
	var goret1 *WidgetPath

	cret = C.gtk_widget_path_copy(arg0)

	goret1 = WrapWidgetPath(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret1, func(v *WidgetPath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret1
}

// Free decrements the reference count on @path, freeing the structure if the
// reference count reaches 0.
func (p *WidgetPath) Free() {
	var arg0 *C.GtkWidgetPath

	arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))

	C.gtk_widget_path_free(arg0)
}

// ObjectType returns the topmost object type, that is, the object type this
// path is representing.
func (p *WidgetPath) ObjectType() externglib.Type {
	var arg0 *C.GtkWidgetPath

	arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))

	var cret C.GType
	var goret1 externglib.Type

	cret = C.gtk_widget_path_get_object_type(arg0)

	goret1 = externglib.Type(cret)

	return goret1
}

// HasParent returns true if any of the parents of the widget represented in
// @path is of type @type, or any subtype of it.
func (p *WidgetPath) HasParent(typ externglib.Type) bool {
	var arg0 *C.GtkWidgetPath
	var arg1 C.GType

	arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	arg1 := C.GType(typ)

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_widget_path_has_parent(arg0, typ)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// IsType returns true if the widget type represented by this path is @type, or
// a subtype of it.
func (p *WidgetPath) IsType(typ externglib.Type) bool {
	var arg0 *C.GtkWidgetPath
	var arg1 C.GType

	arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	arg1 := C.GType(typ)

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_widget_path_is_type(arg0, typ)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// IterAddClass adds the class @name to the widget at position @pos in the
// hierarchy defined in @path. See gtk_style_context_add_class().
func (p *WidgetPath) IterAddClass(pos int, name string) {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint
	var arg2 *C.gchar

	arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	arg1 = C.gint(pos)
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_widget_path_iter_add_class(arg0, pos, name)
}

// IterAddRegion adds the region @name to the widget at position @pos in the
// hierarchy defined in @path. See gtk_style_context_add_region().
//
// Region names must only contain lowercase letters and “-”, starting always
// with a lowercase letter.
func (p *WidgetPath) IterAddRegion(pos int, name string, flags RegionFlags) {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint
	var arg2 *C.gchar
	var arg3 C.GtkRegionFlags

	arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	arg1 = C.gint(pos)
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (C.GtkRegionFlags)(flags)

	C.gtk_widget_path_iter_add_region(arg0, pos, name, flags)
}

// IterClearClasses removes all classes from the widget at position @pos in the
// hierarchy defined in @path.
func (p *WidgetPath) IterClearClasses(pos int) {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint

	arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	arg1 = C.gint(pos)

	C.gtk_widget_path_iter_clear_classes(arg0, pos)
}

// IterClearRegions removes all regions from the widget at position @pos in the
// hierarchy defined in @path.
func (p *WidgetPath) IterClearRegions(pos int) {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint

	arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	arg1 = C.gint(pos)

	C.gtk_widget_path_iter_clear_regions(arg0, pos)
}

// IterGetName returns the name corresponding to the widget found at the
// position @pos in the widget hierarchy defined by @path
func (p *WidgetPath) IterGetName(pos int) string {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint

	arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	arg1 = C.gint(pos)

	var cret *C.gchar
	var goret1 string

	cret = C.gtk_widget_path_iter_get_name(arg0, pos)

	goret1 = C.GoString(cret)

	return goret1
}

// IterGetObjectName returns the object name that is at position @pos in the
// widget hierarchy defined in @path.
func (p *WidgetPath) IterGetObjectName(pos int) string {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint

	arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	arg1 = C.gint(pos)

	var cret *C.char
	var goret1 string

	cret = C.gtk_widget_path_iter_get_object_name(arg0, pos)

	goret1 = C.GoString(cret)

	return goret1
}

// IterGetObjectType returns the object #GType that is at position @pos in the
// widget hierarchy defined in @path.
func (p *WidgetPath) IterGetObjectType(pos int) externglib.Type {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint

	arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	arg1 = C.gint(pos)

	var cret C.GType
	var goret1 externglib.Type

	cret = C.gtk_widget_path_iter_get_object_type(arg0, pos)

	goret1 = externglib.Type(cret)

	return goret1
}

// IterGetSiblingIndex returns the index into the list of siblings for the
// element at @pos as returned by gtk_widget_path_iter_get_siblings(). If that
// function would return nil because the element at @pos has no siblings, this
// function will return 0.
func (p *WidgetPath) IterGetSiblingIndex(pos int) uint {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint

	arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	arg1 = C.gint(pos)

	var cret C.guint
	var goret1 uint

	cret = C.gtk_widget_path_iter_get_sibling_index(arg0, pos)

	goret1 = C.guint(cret)

	return goret1
}

// IterGetSiblings returns the list of siblings for the element at @pos. If the
// element was not added with siblings, nil is returned.
func (p *WidgetPath) IterGetSiblings(pos int) *WidgetPath {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint

	arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	arg1 = C.gint(pos)

	var cret *C.GtkWidgetPath
	var goret1 *WidgetPath

	cret = C.gtk_widget_path_iter_get_siblings(arg0, pos)

	goret1 = WrapWidgetPath(unsafe.Pointer(cret))

	return goret1
}

// IterGetState returns the state flags corresponding to the widget found at the
// position @pos in the widget hierarchy defined by @path
func (p *WidgetPath) IterGetState(pos int) StateFlags {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint

	arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	arg1 = C.gint(pos)

	var cret C.GtkStateFlags
	var goret1 StateFlags

	cret = C.gtk_widget_path_iter_get_state(arg0, pos)

	goret1 = StateFlags(cret)

	return goret1
}

// IterHasClass returns true if the widget at position @pos has the class @name
// defined, false otherwise.
func (p *WidgetPath) IterHasClass(pos int, name string) bool {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint
	var arg2 *C.gchar

	arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	arg1 = C.gint(pos)
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_widget_path_iter_has_class(arg0, pos, name)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// IterHasName returns true if the widget at position @pos has the name @name,
// false otherwise.
func (p *WidgetPath) IterHasName(pos int, name string) bool {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint
	var arg2 *C.gchar

	arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	arg1 = C.gint(pos)
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_widget_path_iter_has_name(arg0, pos, name)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// IterHasRegion returns true if the widget at position @pos has the class @name
// defined, false otherwise.
func (p *WidgetPath) IterHasRegion(pos int, name string) (flags RegionFlags, ok bool) {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint
	var arg2 *C.gchar

	arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	arg1 = C.gint(pos)
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	var arg3 *C.GtkRegionFlags
	var ret3 *RegionFlags
	var cret C.gboolean
	var goret2 bool

	cret = C.gtk_widget_path_iter_has_region(arg0, pos, name, &arg3)

	ret3 = *RegionFlags(arg3)
	goret2 = C.bool(cret) != C.false

	return ret3, goret2
}

// IterListClasses returns a list with all the class names defined for the
// widget at position @pos in the hierarchy defined in @path.
func (p *WidgetPath) IterListClasses(pos int) *glib.SList {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint

	arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	arg1 = C.gint(pos)

	var cret *C.GSList
	var goret1 *glib.SList

	cret = C.gtk_widget_path_iter_list_classes(arg0, pos)

	goret1 = glib.WrapSList(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret1, func(v *glib.SList) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret1
}

// IterListRegions returns a list with all the region names defined for the
// widget at position @pos in the hierarchy defined in @path.
func (p *WidgetPath) IterListRegions(pos int) *glib.SList {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint

	arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	arg1 = C.gint(pos)

	var cret *C.GSList
	var goret1 *glib.SList

	cret = C.gtk_widget_path_iter_list_regions(arg0, pos)

	goret1 = glib.WrapSList(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret1, func(v *glib.SList) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret1
}

// IterRemoveClass removes the class @name from the widget at position @pos in
// the hierarchy defined in @path.
func (p *WidgetPath) IterRemoveClass(pos int, name string) {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint
	var arg2 *C.gchar

	arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	arg1 = C.gint(pos)
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_widget_path_iter_remove_class(arg0, pos, name)
}

// IterRemoveRegion removes the region @name from the widget at position @pos in
// the hierarchy defined in @path.
func (p *WidgetPath) IterRemoveRegion(pos int, name string) {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint
	var arg2 *C.gchar

	arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	arg1 = C.gint(pos)
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_widget_path_iter_remove_region(arg0, pos, name)
}

// IterSetName sets the widget name for the widget found at position @pos in the
// widget hierarchy defined by @path.
func (p *WidgetPath) IterSetName(pos int, name string) {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint
	var arg2 *C.gchar

	arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	arg1 = C.gint(pos)
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_widget_path_iter_set_name(arg0, pos, name)
}

// IterSetObjectName sets the object name for a given position in the widget
// hierarchy defined by @path.
//
// When set, the object name overrides the object type when matching CSS.
func (p *WidgetPath) IterSetObjectName(pos int, name string) {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint
	var arg2 *C.char

	arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	arg1 = C.gint(pos)
	arg2 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_widget_path_iter_set_object_name(arg0, pos, name)
}

// IterSetObjectType sets the object type for a given position in the widget
// hierarchy defined by @path.
func (p *WidgetPath) IterSetObjectType(pos int, typ externglib.Type) {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint
	var arg2 C.GType

	arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	arg1 = C.gint(pos)
	arg2 := C.GType(typ)

	C.gtk_widget_path_iter_set_object_type(arg0, pos, typ)
}

// IterSetState sets the widget name for the widget found at position @pos in
// the widget hierarchy defined by @path.
//
// If you want to update just a single state flag, you need to do this manually,
// as this function updates all state flags.
//
// Setting a flag
//
//    gtk_widget_path_iter_set_state (path, pos, gtk_widget_path_iter_get_state (path, pos) & ~flag);
func (p *WidgetPath) IterSetState(pos int, state StateFlags) {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint
	var arg2 C.GtkStateFlags

	arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	arg1 = C.gint(pos)
	arg2 = (C.GtkStateFlags)(state)

	C.gtk_widget_path_iter_set_state(arg0, pos, state)
}

// Length returns the number of Widget #GTypes between the represented widget
// and its topmost container.
func (p *WidgetPath) Length() int {
	var arg0 *C.GtkWidgetPath

	arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))

	var cret C.gint
	var goret1 int

	cret = C.gtk_widget_path_length(arg0)

	goret1 = C.gint(cret)

	return goret1
}

// PrependType prepends a widget type to the widget hierachy represented by
// @path.
func (p *WidgetPath) PrependType(typ externglib.Type) {
	var arg0 *C.GtkWidgetPath
	var arg1 C.GType

	arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	arg1 := C.GType(typ)

	C.gtk_widget_path_prepend_type(arg0, typ)
}

// Ref increments the reference count on @path.
func (p *WidgetPath) Ref() *WidgetPath {
	var arg0 *C.GtkWidgetPath

	arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))

	var cret *C.GtkWidgetPath
	var goret1 *WidgetPath

	cret = C.gtk_widget_path_ref(arg0)

	goret1 = WrapWidgetPath(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret1, func(v *WidgetPath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret1
}

// String dumps the widget path into a string representation. It tries to match
// the CSS style as closely as possible (Note that there might be paths that
// cannot be represented in CSS).
//
// The main use of this code is for debugging purposes, so that you can
// g_print() the path or dump it in a gdb session.
func (p *WidgetPath) String() string {
	var arg0 *C.GtkWidgetPath

	arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))

	var cret *C.char
	var goret1 string

	cret = C.gtk_widget_path_to_string(arg0)

	goret1 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return goret1
}

// Unref decrements the reference count on @path, freeing the structure if the
// reference count reaches 0.
func (p *WidgetPath) Unref() {
	var arg0 *C.GtkWidgetPath

	arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))

	C.gtk_widget_path_unref(arg0)
}
