// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_icon_set_get_type()), F: marshalIconSet},
		{T: externglib.Type(C.gtk_icon_source_get_type()), F: marshalIconSource},
		{T: externglib.Type(C.gtk_selection_data_get_type()), F: marshalSelectionData},
		{T: externglib.Type(C.gtk_widget_path_get_type()), F: marshalWidgetPath},
	})
}

type IconSet struct {
	native C.GtkIconSet
}

// WrapIconSet wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapIconSet(ptr unsafe.Pointer) *IconSet {
	if ptr == nil {
		return nil
	}

	return (*IconSet)(ptr)
}

func marshalIconSet(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapIconSet(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (i *IconSet) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

// AddSource: icon sets have a list of IconSource, which they use as base icons
// for rendering icons in different states and sizes. Icons are scaled, made to
// look insensitive, etc. in gtk_icon_set_render_icon(), but IconSet needs base
// images to work with. The base images and when to use them are described by a
// IconSource.
//
// This function copies @source, so you can reuse the same source immediately
// without affecting the icon set.
//
// An example of when you’d use this function: a web browser’s "Back to Previous
// Page" icon might point in a different direction in Hebrew and in English; it
// might look different when insensitive; and it might change size depending on
// toolbar mode (small/large icons). So a single icon set would contain all
// those variants of the icon, and you might add a separate source for each one.
//
// You should nearly always add a “default” icon source with all fields
// wildcarded, which will be used as a fallback if no more specific source
// matches. IconSet always prefers more specific icon sources to more generic
// icon sources. The order in which you add the sources to the icon set does not
// matter.
//
// gtk_icon_set_new_from_pixbuf() creates a new icon set with a default icon
// source based on the given pixbuf.
func (i *IconSet) AddSource(source *IconSource) {
	var _arg0 *C.GtkIconSet
	var _arg1 *C.GtkIconSource

	_arg0 = (*C.GtkIconSet)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkIconSource)(unsafe.Pointer(source.Native()))

	C.gtk_icon_set_add_source(_arg0, _arg1)
}

// Sizes obtains a list of icon sizes this icon set can render. The returned
// array must be freed with g_free().
func (i *IconSet) Sizes() []*int {
	var _arg0 *C.GtkIconSet

	_arg0 = (*C.GtkIconSet)(unsafe.Pointer(i.Native()))

	var _arg1 *C.GtkIconSize
	var _arg2 *C.gint

	C.gtk_icon_set_get_sizes(_arg0, &_arg1, &_arg2)

	var _sizes []*int

	ptr.SetSlice(unsafe.Pointer(&_sizes), unsafe.Pointer(_arg1), int(_arg2))
	runtime.SetFinalizer(&_sizes, func(v *[]*int) {
		C.free(ptr.Slice(unsafe.Pointer(v)))
	})

	return _sizes
}

// Unref decrements the reference count on @icon_set, and frees memory if the
// reference count reaches 0.
func (i *IconSet) Unref() {
	var _arg0 *C.GtkIconSet

	_arg0 = (*C.GtkIconSet)(unsafe.Pointer(i.Native()))

	C.gtk_icon_set_unref(_arg0)
}

type IconSource struct {
	native C.GtkIconSource
}

// WrapIconSource wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapIconSource(ptr unsafe.Pointer) *IconSource {
	if ptr == nil {
		return nil
	}

	return (*IconSource)(ptr)
}

func marshalIconSource(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapIconSource(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (i *IconSource) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

// Free frees a dynamically-allocated icon source, along with its filename,
// size, and pixbuf fields if those are not nil.
func (s *IconSource) Free() {
	var _arg0 *C.GtkIconSource

	_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

	C.gtk_icon_source_free(_arg0)
}

// DirectionWildcarded gets the value set by
// gtk_icon_source_set_direction_wildcarded().
func (s *IconSource) DirectionWildcarded() bool {
	var _arg0 *C.GtkIconSource

	_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_icon_source_get_direction_wildcarded(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Filename retrieves the source filename, or nil if none is set. The filename
// is not a copy, and should not be modified or expected to persist beyond the
// lifetime of the icon source.
func (s *IconSource) Filename() *string {
	var _arg0 *C.GtkIconSource

	_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

	var _cret *C.gchar

	_cret = C.gtk_icon_source_get_filename(_arg0)

	var _filename *string

	_filename = C.GoString(_cret)

	return _filename
}

// IconName retrieves the source icon name, or nil if none is set. The icon_name
// is not a copy, and should not be modified or expected to persist beyond the
// lifetime of the icon source.
func (s *IconSource) IconName() string {
	var _arg0 *C.GtkIconSource

	_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

	var _cret *C.gchar

	_cret = C.gtk_icon_source_get_icon_name(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Size obtains the icon size this source applies to. The return value is only
// useful/meaningful if the icon size is not wildcarded.
func (s *IconSource) Size() int {
	var _arg0 *C.GtkIconSource

	_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

	var _cret C.GtkIconSize

	_cret = C.gtk_icon_source_get_size(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// SizeWildcarded gets the value set by gtk_icon_source_set_size_wildcarded().
func (s *IconSource) SizeWildcarded() bool {
	var _arg0 *C.GtkIconSource

	_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_icon_source_get_size_wildcarded(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// StateWildcarded gets the value set by gtk_icon_source_set_state_wildcarded().
func (s *IconSource) StateWildcarded() bool {
	var _arg0 *C.GtkIconSource

	_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_icon_source_get_state_wildcarded(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// SetDirection sets the text direction this icon source is intended to be used
// with.
//
// Setting the text direction on an icon source makes no difference if the text
// direction is wildcarded. Therefore, you should usually call
// gtk_icon_source_set_direction_wildcarded() to un-wildcard it in addition to
// calling this function.
func (s *IconSource) SetDirection(direction TextDirection) {
	var _arg0 *C.GtkIconSource
	var _arg1 C.GtkTextDirection

	_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkTextDirection)(direction)

	C.gtk_icon_source_set_direction(_arg0, _arg1)
}

// SetDirectionWildcarded: if the text direction is wildcarded, this source can
// be used as the base image for an icon in any TextDirection. If the text
// direction is not wildcarded, then the text direction the icon source applies
// to should be set with gtk_icon_source_set_direction(), and the icon source
// will only be used with that text direction.
//
// IconSet prefers non-wildcarded sources (exact matches) over wildcarded
// sources, and will use an exact match when possible.
func (s *IconSource) SetDirectionWildcarded(setting bool) {
	var _arg0 *C.GtkIconSource
	var _arg1 C.gboolean

	_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.gboolean(1)
	}

	C.gtk_icon_source_set_direction_wildcarded(_arg0, _arg1)
}

// SetFilename sets the name of an image file to use as a base image when
// creating icon variants for IconSet. The filename must be absolute.
func (s *IconSource) SetFilename(filename *string) {
	var _arg0 *C.GtkIconSource
	var _arg1 *C.gchar

	_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_icon_source_set_filename(_arg0, _arg1)
}

// SetIconName sets the name of an icon to look up in the current icon theme to
// use as a base image when creating icon variants for IconSet.
func (s *IconSource) SetIconName(iconName string) {
	var _arg0 *C.GtkIconSource
	var _arg1 *C.gchar

	_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_icon_source_set_icon_name(_arg0, _arg1)
}

// SetPixbuf sets a pixbuf to use as a base image when creating icon variants
// for IconSet.
func (s *IconSource) SetPixbuf(pixbuf gdkpixbuf.Pixbuf) {
	var _arg0 *C.GtkIconSource
	var _arg1 *C.GdkPixbuf

	_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	C.gtk_icon_source_set_pixbuf(_arg0, _arg1)
}

// SetSize sets the icon size this icon source is intended to be used with.
//
// Setting the icon size on an icon source makes no difference if the size is
// wildcarded. Therefore, you should usually call
// gtk_icon_source_set_size_wildcarded() to un-wildcard it in addition to
// calling this function.
func (s *IconSource) SetSize(size int) {
	var _arg0 *C.GtkIconSource
	var _arg1 C.GtkIconSize

	_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))
	_arg1 = C.GtkIconSize(size)

	C.gtk_icon_source_set_size(_arg0, _arg1)
}

// SetSizeWildcarded: if the icon size is wildcarded, this source can be used as
// the base image for an icon of any size. If the size is not wildcarded, then
// the size the source applies to should be set with gtk_icon_source_set_size()
// and the icon source will only be used with that specific size.
//
// IconSet prefers non-wildcarded sources (exact matches) over wildcarded
// sources, and will use an exact match when possible.
//
// IconSet will normally scale wildcarded source images to produce an
// appropriate icon at a given size, but will not change the size of source
// images that match exactly.
func (s *IconSource) SetSizeWildcarded(setting bool) {
	var _arg0 *C.GtkIconSource
	var _arg1 C.gboolean

	_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.gboolean(1)
	}

	C.gtk_icon_source_set_size_wildcarded(_arg0, _arg1)
}

// SetState sets the widget state this icon source is intended to be used with.
//
// Setting the widget state on an icon source makes no difference if the state
// is wildcarded. Therefore, you should usually call
// gtk_icon_source_set_state_wildcarded() to un-wildcard it in addition to
// calling this function.
func (s *IconSource) SetState(state StateType) {
	var _arg0 *C.GtkIconSource
	var _arg1 C.GtkStateType

	_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkStateType)(state)

	C.gtk_icon_source_set_state(_arg0, _arg1)
}

// SetStateWildcarded: if the widget state is wildcarded, this source can be
// used as the base image for an icon in any StateType. If the widget state is
// not wildcarded, then the state the source applies to should be set with
// gtk_icon_source_set_state() and the icon source will only be used with that
// specific state.
//
// IconSet prefers non-wildcarded sources (exact matches) over wildcarded
// sources, and will use an exact match when possible.
//
// IconSet will normally transform wildcarded source images to produce an
// appropriate icon for a given state, for example lightening an image on
// prelight, but will not modify source images that match exactly.
func (s *IconSource) SetStateWildcarded(setting bool) {
	var _arg0 *C.GtkIconSource
	var _arg1 C.gboolean

	_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.gboolean(1)
	}

	C.gtk_icon_source_set_state_wildcarded(_arg0, _arg1)
}

type SelectionData struct {
	native C.GtkSelectionData
}

// WrapSelectionData wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSelectionData(ptr unsafe.Pointer) *SelectionData {
	if ptr == nil {
		return nil
	}

	return (*SelectionData)(ptr)
}

func marshalSelectionData(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSelectionData(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *SelectionData) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// Free frees a SelectionData-struct returned from gtk_selection_data_copy().
func (d *SelectionData) Free() {
	var _arg0 *C.GtkSelectionData

	_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(d.Native()))

	C.gtk_selection_data_free(_arg0)
}

// DataWithLength retrieves the raw data of the selection along with its length.
func (s *SelectionData) DataWithLength() []byte {
	var _arg0 *C.GtkSelectionData

	_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

	var _cret *C.guchar
	var _arg1 *C.gint

	_cret = C.gtk_selection_data_get_data_with_length(_arg0, &_arg1)

	var _guint8s []byte

	{
		var src []C.guchar
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(_cret), int(_arg1))

		_guint8s = make([]byte, _arg1)
		for i := 0; i < uintptr(_arg1); i++ {
			_guint8s = (byte)(_cret)
		}
	}

	return _guint8s
}

// Format retrieves the format of the selection.
func (s *SelectionData) Format() int {
	var _arg0 *C.GtkSelectionData

	_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

	var _cret C.gint

	_cret = C.gtk_selection_data_get_format(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// Length retrieves the length of the raw data of the selection.
func (s *SelectionData) Length() int {
	var _arg0 *C.GtkSelectionData

	_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

	var _cret C.gint

	_cret = C.gtk_selection_data_get_length(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// Text gets the contents of the selection data as a UTF-8 string.
func (s *SelectionData) Text() string {
	var _arg0 *C.GtkSelectionData

	_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

	var _cret *C.guchar

	_cret = C.gtk_selection_data_get_text(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Uris gets the contents of the selection data as array of URIs.
func (s *SelectionData) Uris() []string {
	var _arg0 *C.GtkSelectionData

	_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

	var _cret **C.gchar

	_cret = C.gtk_selection_data_get_uris(_arg0)

	var _utf8s []string

	{
		var length int
		for p := _cret; *p != 0; p = (**C.gchar)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		var src []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(_cret), int(length))

		_utf8s = make([]string, length)
		for i := range src {
			_utf8s = C.GoString(_cret)
			defer C.free(unsafe.Pointer(_cret))
		}
	}

	return _utf8s
}

// Set stores new data into a SelectionData object. Should only be called from a
// selection handler callback. Zero-terminates the stored data.
func (s *SelectionData) Set(typ gdk.Atom, format int, data []byte) {
	var _arg0 *C.GtkSelectionData
	var _arg1 C.GdkAtom
	var _arg2 C.gint
	var _arg3 *C.guchar
	var _arg4 C.gint

	_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GdkAtom)(unsafe.Pointer(typ.Native()))
	_arg2 = C.gint(format)
	_arg4 = C.gint(len(data))
	_arg3 = (*C.guchar)(unsafe.Pointer(&data[0]))

	C.gtk_selection_data_set(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// SetPixbuf sets the contents of the selection from a Pixbuf The pixbuf is
// converted to the form determined by @selection_data->target.
func (s *SelectionData) SetPixbuf(pixbuf gdkpixbuf.Pixbuf) bool {
	var _arg0 *C.GtkSelectionData
	var _arg1 *C.GdkPixbuf

	_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	var _cret C.gboolean

	_cret = C.gtk_selection_data_set_pixbuf(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// SetText sets the contents of the selection from a UTF-8 encoded string. The
// string is converted to the form determined by @selection_data->target.
func (s *SelectionData) SetText(str string, len int) bool {
	var _arg0 *C.GtkSelectionData
	var _arg1 *C.gchar
	var _arg2 C.gint

	_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(len)

	var _cret C.gboolean

	_cret = C.gtk_selection_data_set_text(_arg0, _arg1, _arg2)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// SetUris sets the contents of the selection from a list of URIs. The string is
// converted to the form determined by @selection_data->target.
func (s *SelectionData) SetUris(uris []string) bool {
	var _arg0 *C.GtkSelectionData
	var _arg1 **C.gchar

	_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))
	_arg1 = (**C.gchar)(C.malloc((len(uris) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(_arg1))

	{
		var out []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(_arg1), int(len(uris)))

		for i := range uris {
			_arg1 = (*C.gchar)(C.CString(uris))
			defer C.free(unsafe.Pointer(_arg1))
		}
	}

	var _cret C.gboolean

	_cret = C.gtk_selection_data_set_uris(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// TargetsIncludeImage: given a SelectionData object holding a list of targets,
// determines if any of the targets in @targets can be used to provide a Pixbuf.
func (s *SelectionData) TargetsIncludeImage(writable bool) bool {
	var _arg0 *C.GtkSelectionData
	var _arg1 C.gboolean

	_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))
	if writable {
		_arg1 = C.gboolean(1)
	}

	var _cret C.gboolean

	_cret = C.gtk_selection_data_targets_include_image(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// TargetsIncludeRichText: given a SelectionData object holding a list of
// targets, determines if any of the targets in @targets can be used to provide
// rich text.
func (s *SelectionData) TargetsIncludeRichText(buffer TextBuffer) bool {
	var _arg0 *C.GtkSelectionData
	var _arg1 *C.GtkTextBuffer

	_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	var _cret C.gboolean

	_cret = C.gtk_selection_data_targets_include_rich_text(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// TargetsIncludeText: given a SelectionData object holding a list of targets,
// determines if any of the targets in @targets can be used to provide text.
func (s *SelectionData) TargetsIncludeText() bool {
	var _arg0 *C.GtkSelectionData

	_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_selection_data_targets_include_text(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// TargetsIncludeURI: given a SelectionData object holding a list of targets,
// determines if any of the targets in @targets can be used to provide a list or
// URIs.
func (s *SelectionData) TargetsIncludeURI() bool {
	var _arg0 *C.GtkSelectionData

	_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_selection_data_targets_include_uri(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// WidgetPath: gtkWidgetPath is a boxed type that represents a widget hierarchy
// from the topmost widget, typically a toplevel, to any child. This widget path
// abstraction is used in StyleContext on behalf of the real widget in order to
// query style information.
//
// If you are using GTK+ widgets, you probably will not need to use this API
// directly, as there is gtk_widget_get_path(), and the style context returned
// by gtk_widget_get_style_context() will be automatically updated on widget
// hierarchy changes.
//
// The widget path generation is generally simple:
//
// Defining a button within a window
//
//    {
//      GtkWidgetPath *path;
//      guint pos;
//
//      path = gtk_widget_path_new ();
//
//      pos = gtk_widget_path_append_type (path, GTK_TYPE_NOTEBOOK);
//      gtk_widget_path_iter_add_region (path, pos, "tab", GTK_REGION_EVEN | GTK_REGION_FIRST);
//
//      pos = gtk_widget_path_append_type (path, GTK_TYPE_LABEL);
//      gtk_widget_path_iter_set_name (path, pos, "first tab label");
//    }
//
// All this information will be used to match the style information that applies
// to the described widget.
type WidgetPath struct {
	native C.GtkWidgetPath
}

// WrapWidgetPath wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapWidgetPath(ptr unsafe.Pointer) *WidgetPath {
	if ptr == nil {
		return nil
	}

	return (*WidgetPath)(ptr)
}

func marshalWidgetPath(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapWidgetPath(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (w *WidgetPath) Native() unsafe.Pointer {
	return unsafe.Pointer(&w.native)
}

// AppendForWidget appends the data from @widget to the widget hierarchy
// represented by @path. This function is a shortcut for adding information from
// @widget to the given @path. This includes setting the name or adding the
// style classes from @widget.
func (p *WidgetPath) AppendForWidget(widget Widget) int {
	var _arg0 *C.GtkWidgetPath
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	var _cret C.gint

	_cret = C.gtk_widget_path_append_for_widget(_arg0, _arg1)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// AppendType appends a widget type to the widget hierarchy represented by
// @path.
func (p *WidgetPath) AppendType(typ externglib.Type) int {
	var _arg0 *C.GtkWidgetPath
	var _arg1 C.GType

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = C.GType(typ)

	var _cret C.gint

	_cret = C.gtk_widget_path_append_type(_arg0, _arg1)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// AppendWithSiblings appends a widget type with all its siblings to the widget
// hierarchy represented by @path. Using this function instead of
// gtk_widget_path_append_type() will allow the CSS theming to use sibling
// matches in selectors and apply :nth-child() pseudo classes. In turn, it
// requires a lot more care in widget implementations as widgets need to make
// sure to call gtk_widget_reset_style() on all involved widgets when the
// @siblings path changes.
func (p *WidgetPath) AppendWithSiblings(siblings *WidgetPath, siblingIndex uint) int {
	var _arg0 *C.GtkWidgetPath
	var _arg1 *C.GtkWidgetPath
	var _arg2 C.guint

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkWidgetPath)(unsafe.Pointer(siblings.Native()))
	_arg2 = C.guint(siblingIndex)

	var _cret C.gint

	_cret = C.gtk_widget_path_append_with_siblings(_arg0, _arg1, _arg2)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// Free decrements the reference count on @path, freeing the structure if the
// reference count reaches 0.
func (p *WidgetPath) Free() {
	var _arg0 *C.GtkWidgetPath

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))

	C.gtk_widget_path_free(_arg0)
}

// ObjectType returns the topmost object type, that is, the object type this
// path is representing.
func (p *WidgetPath) ObjectType() externglib.Type {
	var _arg0 *C.GtkWidgetPath

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))

	var _cret C.GType

	_cret = C.gtk_widget_path_get_object_type(_arg0)

	var _gType externglib.Type

	_gType = externglib.Type(_cret)

	return _gType
}

// HasParent returns true if any of the parents of the widget represented in
// @path is of type @type, or any subtype of it.
func (p *WidgetPath) HasParent(typ externglib.Type) bool {
	var _arg0 *C.GtkWidgetPath
	var _arg1 C.GType

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = C.GType(typ)

	var _cret C.gboolean

	_cret = C.gtk_widget_path_has_parent(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// IsType returns true if the widget type represented by this path is @type, or
// a subtype of it.
func (p *WidgetPath) IsType(typ externglib.Type) bool {
	var _arg0 *C.GtkWidgetPath
	var _arg1 C.GType

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = C.GType(typ)

	var _cret C.gboolean

	_cret = C.gtk_widget_path_is_type(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// IterAddClass adds the class @name to the widget at position @pos in the
// hierarchy defined in @path. See gtk_style_context_add_class().
func (p *WidgetPath) IterAddClass(pos int, name string) {
	var _arg0 *C.GtkWidgetPath
	var _arg1 C.gint
	var _arg2 *C.gchar

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = C.gint(pos)
	_arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_widget_path_iter_add_class(_arg0, _arg1, _arg2)
}

// IterAddRegion adds the region @name to the widget at position @pos in the
// hierarchy defined in @path. See gtk_style_context_add_region().
//
// Region names must only contain lowercase letters and “-”, starting always
// with a lowercase letter.
func (p *WidgetPath) IterAddRegion(pos int, name string, flags RegionFlags) {
	var _arg0 *C.GtkWidgetPath
	var _arg1 C.gint
	var _arg2 *C.gchar
	var _arg3 C.GtkRegionFlags

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = C.gint(pos)
	_arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.GtkRegionFlags)(flags)

	C.gtk_widget_path_iter_add_region(_arg0, _arg1, _arg2, _arg3)
}

// IterClearClasses removes all classes from the widget at position @pos in the
// hierarchy defined in @path.
func (p *WidgetPath) IterClearClasses(pos int) {
	var _arg0 *C.GtkWidgetPath
	var _arg1 C.gint

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = C.gint(pos)

	C.gtk_widget_path_iter_clear_classes(_arg0, _arg1)
}

// IterClearRegions removes all regions from the widget at position @pos in the
// hierarchy defined in @path.
func (p *WidgetPath) IterClearRegions(pos int) {
	var _arg0 *C.GtkWidgetPath
	var _arg1 C.gint

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = C.gint(pos)

	C.gtk_widget_path_iter_clear_regions(_arg0, _arg1)
}

// IterGetName returns the name corresponding to the widget found at the
// position @pos in the widget hierarchy defined by @path
func (p *WidgetPath) IterGetName(pos int) string {
	var _arg0 *C.GtkWidgetPath
	var _arg1 C.gint

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = C.gint(pos)

	var _cret *C.gchar

	_cret = C.gtk_widget_path_iter_get_name(_arg0, _arg1)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// IterGetObjectName returns the object name that is at position @pos in the
// widget hierarchy defined in @path.
func (p *WidgetPath) IterGetObjectName(pos int) string {
	var _arg0 *C.GtkWidgetPath
	var _arg1 C.gint

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = C.gint(pos)

	var _cret *C.char

	_cret = C.gtk_widget_path_iter_get_object_name(_arg0, _arg1)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// IterGetObjectType returns the object #GType that is at position @pos in the
// widget hierarchy defined in @path.
func (p *WidgetPath) IterGetObjectType(pos int) externglib.Type {
	var _arg0 *C.GtkWidgetPath
	var _arg1 C.gint

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = C.gint(pos)

	var _cret C.GType

	_cret = C.gtk_widget_path_iter_get_object_type(_arg0, _arg1)

	var _gType externglib.Type

	_gType = externglib.Type(_cret)

	return _gType
}

// IterGetSiblingIndex returns the index into the list of siblings for the
// element at @pos as returned by gtk_widget_path_iter_get_siblings(). If that
// function would return nil because the element at @pos has no siblings, this
// function will return 0.
func (p *WidgetPath) IterGetSiblingIndex(pos int) uint {
	var _arg0 *C.GtkWidgetPath
	var _arg1 C.gint

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = C.gint(pos)

	var _cret C.guint

	_cret = C.gtk_widget_path_iter_get_sibling_index(_arg0, _arg1)

	var _guint uint

	_guint = (uint)(_cret)

	return _guint
}

// IterHasClass returns true if the widget at position @pos has the class @name
// defined, false otherwise.
func (p *WidgetPath) IterHasClass(pos int, name string) bool {
	var _arg0 *C.GtkWidgetPath
	var _arg1 C.gint
	var _arg2 *C.gchar

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = C.gint(pos)
	_arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg2))

	var _cret C.gboolean

	_cret = C.gtk_widget_path_iter_has_class(_arg0, _arg1, _arg2)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// IterHasName returns true if the widget at position @pos has the name @name,
// false otherwise.
func (p *WidgetPath) IterHasName(pos int, name string) bool {
	var _arg0 *C.GtkWidgetPath
	var _arg1 C.gint
	var _arg2 *C.gchar

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = C.gint(pos)
	_arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg2))

	var _cret C.gboolean

	_cret = C.gtk_widget_path_iter_has_name(_arg0, _arg1, _arg2)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// IterRemoveClass removes the class @name from the widget at position @pos in
// the hierarchy defined in @path.
func (p *WidgetPath) IterRemoveClass(pos int, name string) {
	var _arg0 *C.GtkWidgetPath
	var _arg1 C.gint
	var _arg2 *C.gchar

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = C.gint(pos)
	_arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_widget_path_iter_remove_class(_arg0, _arg1, _arg2)
}

// IterRemoveRegion removes the region @name from the widget at position @pos in
// the hierarchy defined in @path.
func (p *WidgetPath) IterRemoveRegion(pos int, name string) {
	var _arg0 *C.GtkWidgetPath
	var _arg1 C.gint
	var _arg2 *C.gchar

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = C.gint(pos)
	_arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_widget_path_iter_remove_region(_arg0, _arg1, _arg2)
}

// IterSetName sets the widget name for the widget found at position @pos in the
// widget hierarchy defined by @path.
func (p *WidgetPath) IterSetName(pos int, name string) {
	var _arg0 *C.GtkWidgetPath
	var _arg1 C.gint
	var _arg2 *C.gchar

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = C.gint(pos)
	_arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_widget_path_iter_set_name(_arg0, _arg1, _arg2)
}

// IterSetObjectName sets the object name for a given position in the widget
// hierarchy defined by @path.
//
// When set, the object name overrides the object type when matching CSS.
func (p *WidgetPath) IterSetObjectName(pos int, name string) {
	var _arg0 *C.GtkWidgetPath
	var _arg1 C.gint
	var _arg2 *C.char

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = C.gint(pos)
	_arg2 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_widget_path_iter_set_object_name(_arg0, _arg1, _arg2)
}

// IterSetObjectType sets the object type for a given position in the widget
// hierarchy defined by @path.
func (p *WidgetPath) IterSetObjectType(pos int, typ externglib.Type) {
	var _arg0 *C.GtkWidgetPath
	var _arg1 C.gint
	var _arg2 C.GType

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = C.gint(pos)
	_arg2 = C.GType(typ)

	C.gtk_widget_path_iter_set_object_type(_arg0, _arg1, _arg2)
}

// IterSetState sets the widget name for the widget found at position @pos in
// the widget hierarchy defined by @path.
//
// If you want to update just a single state flag, you need to do this manually,
// as this function updates all state flags.
//
// Setting a flag
//
//    gtk_widget_path_iter_set_state (path, pos, gtk_widget_path_iter_get_state (path, pos) & ~flag);
func (p *WidgetPath) IterSetState(pos int, state StateFlags) {
	var _arg0 *C.GtkWidgetPath
	var _arg1 C.gint
	var _arg2 C.GtkStateFlags

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = C.gint(pos)
	_arg2 = (C.GtkStateFlags)(state)

	C.gtk_widget_path_iter_set_state(_arg0, _arg1, _arg2)
}

// Length returns the number of Widget #GTypes between the represented widget
// and its topmost container.
func (p *WidgetPath) Length() int {
	var _arg0 *C.GtkWidgetPath

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))

	var _cret C.gint

	_cret = C.gtk_widget_path_length(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// PrependType prepends a widget type to the widget hierachy represented by
// @path.
func (p *WidgetPath) PrependType(typ externglib.Type) {
	var _arg0 *C.GtkWidgetPath
	var _arg1 C.GType

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = C.GType(typ)

	C.gtk_widget_path_prepend_type(_arg0, _arg1)
}

// String dumps the widget path into a string representation. It tries to match
// the CSS style as closely as possible (Note that there might be paths that
// cannot be represented in CSS).
//
// The main use of this code is for debugging purposes, so that you can
// g_print() the path or dump it in a gdb session.
func (p *WidgetPath) String() string {
	var _arg0 *C.GtkWidgetPath

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))

	var _cret *C.char

	_cret = C.gtk_widget_path_to_string(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Unref decrements the reference count on @path, freeing the structure if the
// reference count reaches 0.
func (p *WidgetPath) Unref() {
	var _arg0 *C.GtkWidgetPath

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))

	C.gtk_widget_path_unref(_arg0)
}
