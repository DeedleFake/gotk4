// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk+-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_gesture_single_get_type()), F: marshalGestureSingle},
	})
}

// GestureSingle is a subclass of Gesture, optimized (although not restricted)
// for dealing with mouse and single-touch gestures. Under interaction, these
// gestures stick to the first interacting sequence, which is accessible through
// gtk_gesture_single_get_current_sequence() while the gesture is being
// interacted with.
//
// By default gestures react to both GDK_BUTTON_PRIMARY and touch events,
// gtk_gesture_single_set_touch_only() can be used to change the touch behavior.
// Callers may also specify a different mouse button number to interact with
// through gtk_gesture_single_set_button(), or react to any mouse button by
// setting 0. While the gesture is active, the button being currently pressed
// can be known through gtk_gesture_single_get_current_button().
type GestureSingle interface {
	Gesture

	Button() uint

	CurrentButton() uint

	CurrentSequence() *gdk.EventSequence

	Exclusive() bool

	TouchOnly() bool

	SetButtonGestureSingle(button uint)

	SetExclusiveGestureSingle(exclusive bool)

	SetTouchOnlyGestureSingle(touchOnly bool)
}

// gestureSingle implements the GestureSingle class.
type gestureSingle struct {
	Gesture
}

// WrapGestureSingle wraps a GObject to the right type. It is
// primarily used internally.
func WrapGestureSingle(obj *externglib.Object) GestureSingle {
	return gestureSingle{
		Gesture: WrapGesture(obj),
	}
}

func marshalGestureSingle(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGestureSingle(obj), nil
}

func (g gestureSingle) Button() uint {
	var _arg0 *C.GtkGestureSingle // out
	var _cret C.guint             // in

	_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_single_get_button(_arg0)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

func (g gestureSingle) CurrentButton() uint {
	var _arg0 *C.GtkGestureSingle // out
	var _cret C.guint             // in

	_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_single_get_current_button(_arg0)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

func (g gestureSingle) CurrentSequence() *gdk.EventSequence {
	var _arg0 *C.GtkGestureSingle // out
	var _cret *C.GdkEventSequence // in

	_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_single_get_current_sequence(_arg0)

	var _eventSequence *gdk.EventSequence // out

	_eventSequence = (*gdk.EventSequence)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_eventSequence, func(v **gdk.EventSequence) {
		C.free(unsafe.Pointer(v))
	})

	return _eventSequence
}

func (g gestureSingle) Exclusive() bool {
	var _arg0 *C.GtkGestureSingle // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_single_get_exclusive(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (g gestureSingle) TouchOnly() bool {
	var _arg0 *C.GtkGestureSingle // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_single_get_touch_only(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (g gestureSingle) SetButtonGestureSingle(button uint) {
	var _arg0 *C.GtkGestureSingle // out
	var _arg1 C.guint             // out

	_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))
	_arg1 = C.guint(button)

	C.gtk_gesture_single_set_button(_arg0, _arg1)
}

func (g gestureSingle) SetExclusiveGestureSingle(exclusive bool) {
	var _arg0 *C.GtkGestureSingle // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))
	if exclusive {
		_arg1 = C.TRUE
	}

	C.gtk_gesture_single_set_exclusive(_arg0, _arg1)
}

func (g gestureSingle) SetTouchOnlyGestureSingle(touchOnly bool) {
	var _arg0 *C.GtkGestureSingle // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))
	if touchOnly {
		_arg1 = C.TRUE
	}

	C.gtk_gesture_single_set_touch_only(_arg0, _arg1)
}
