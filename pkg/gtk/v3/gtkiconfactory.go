// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk+-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_icon_factory_get_type()), F: marshalIconFactory},
	})
}

// IconSizeFromName looks up the icon size associated with @name.
func IconSizeFromName(name string) int {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_icon_size_from_name(arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// IconSizeGetName gets the canonical name of the given icon size. The returned
// string is statically allocated and should not be freed.
func IconSizeGetName(size int) string {
	var arg1 C.GtkIconSize

	arg1 = C.GtkIconSize(size)

	ret := C.gtk_icon_size_get_name(arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// IconSizeLookup obtains the pixel size of a semantic icon size @size:
// K_ICON_SIZE_MENU, K_ICON_SIZE_BUTTON, etc. This function isn’t normally
// needed, gtk_icon_theme_load_icon() is the usual way to get an icon for
// rendering, then just look at the size of the rendered pixbuf. The rendered
// pixbuf may not even correspond to the width/height returned by
// gtk_icon_size_lookup(), because themes are free to render the pixbuf however
// they like, including changing the usual size.
func IconSizeLookup(size int) (width int, height int, ok bool) {
	var arg1 C.GtkIconSize
	var arg2 *C.gint // out
	var arg3 *C.gint // out

	arg1 = C.GtkIconSize(size)

	ret := C.gtk_icon_size_lookup(arg1, &arg2, &arg3)

	var ret0 int
	var ret1 int
	var ret2 bool

	ret0 = int(arg2)

	ret1 = int(arg3)

	ret2 = C.bool(ret) != C.false

	return ret0, ret1, ret2
}

// IconSizeLookupForSettings obtains the pixel size of a semantic icon size,
// possibly modified by user preferences for a particular Settings. Normally
// @size would be K_ICON_SIZE_MENU, K_ICON_SIZE_BUTTON, etc. This function isn’t
// normally needed, gtk_widget_render_icon_pixbuf() is the usual way to get an
// icon for rendering, then just look at the size of the rendered pixbuf. The
// rendered pixbuf may not even correspond to the width/height returned by
// gtk_icon_size_lookup(), because themes are free to render the pixbuf however
// they like, including changing the usual size.
func IconSizeLookupForSettings(settings Settings, size int) (width int, height int, ok bool) {
	var arg1 *C.GtkSettings
	var arg2 C.GtkIconSize
	var arg3 *C.gint // out
	var arg4 *C.gint // out

	arg1 = (*C.GtkSettings)(settings.Native())
	arg2 = C.GtkIconSize(size)

	ret := C.gtk_icon_size_lookup_for_settings(arg1, arg2, &arg3, &arg4)

	var ret0 int
	var ret1 int
	var ret2 bool

	ret0 = int(arg3)

	ret1 = int(arg4)

	ret2 = C.bool(ret) != C.false

	return ret0, ret1, ret2
}

// IconSizeRegister registers a new icon size, along the same lines as
// K_ICON_SIZE_MENU, etc. Returns the integer value for the size.
func IconSizeRegister(name string, width int, height int) int {
	var arg1 *C.gchar
	var arg2 C.gint
	var arg3 C.gint

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(width)
	arg3 = C.gint(height)

	ret := C.gtk_icon_size_register(arg1, arg2, arg3)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// IconSizeRegisterAlias registers @alias as another name for @target. So
// calling gtk_icon_size_from_name() with @alias as argument will return
// @target.
func IconSizeRegisterAlias(alias string, target int) {
	var arg1 *C.gchar
	var arg2 C.GtkIconSize

	arg1 = (*C.gchar)(C.CString(alias))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.GtkIconSize(target)

	C.gtk_icon_size_register_alias(arg1, arg2)
}

// IconFactory: an icon factory manages a collection of IconSet; a IconSet
// manages a set of variants of a particular icon (i.e. a IconSet contains
// variants for different sizes and widget states). Icons in an icon factory are
// named by a stock ID, which is a simple string identifying the icon. Each
// Style has a list of IconFactory derived from the current theme; those icon
// factories are consulted first when searching for an icon. If the theme
// doesn’t set a particular icon, GTK+ looks for the icon in a list of default
// icon factories, maintained by gtk_icon_factory_add_default() and
// gtk_icon_factory_remove_default(). Applications with icons should add a
// default icon factory with their icons, which will allow themes to override
// the icons for the application.
//
// To display an icon, always use gtk_style_lookup_icon_set() on the widget that
// will display the icon, or the convenience function gtk_widget_render_icon().
// These functions take the theme into account when looking up the icon to use
// for a given stock ID.
//
//
// GtkIconFactory as GtkBuildable
//
// GtkIconFactory supports a custom <sources> element, which can contain
// multiple <source> elements. The following attributes are allowed:
//
// - stock-id
//
//    The stock id of the source, a string. This attribute is
//    mandatory
//
// - filename
//
//    The filename of the source, a string.  This attribute is
//    optional
//
// - icon-name
//
//    The icon name for the source, a string.  This attribute is
//    optional.
//
// - size
//
//    Size of the icon, a IconSize enum value.  This attribute is
//    optional.
//
// - direction
//
//    Direction of the source, a TextDirection enum value.  This
//    attribute is optional.
//
// - state
//
//    State of the source, a StateType enum value.  This
//    attribute is optional.
//
// A IconFactory UI definition fragment. ##
//
//    <object class="GtkIconFactory" id="iconfactory1">
//      <sources>
//        <source stock-id="apple-red" filename="apple-red.png"/>
//      </sources>
//    </object>
//    <object class="GtkWindow" id="window1">
//      <child>
//        <object class="GtkButton" id="apple_button">
//          <property name="label">apple-red</property>
//          <property name="use-stock">True</property>
//        </object>
//      </child>
//    </object>
type IconFactory interface {
	gextras.Objector
	Buildable

	// Add adds the given @icon_set to the icon factory, under the name
	// @stock_id. @stock_id should be namespaced for your application, e.g.
	// “myapp-whatever-icon”. Normally applications create a IconFactory, then
	// add it to the list of default factories with
	// gtk_icon_factory_add_default(). Then they pass the @stock_id to widgets
	// such as Image to display the icon. Themes can provide an icon with the
	// same name (such as "myapp-whatever-icon") to override your application’s
	// default icons. If an icon already existed in @factory for @stock_id, it
	// is unreferenced and replaced with the new @icon_set.
	Add(stockID string, iconSet *IconSet)
	// AddDefault adds an icon factory to the list of icon factories searched by
	// gtk_style_lookup_icon_set(). This means that, for example,
	// gtk_image_new_from_stock() will be able to find icons in @factory. There
	// will normally be an icon factory added for each library or application
	// that comes with icons. The default icon factories can be overridden by
	// themes.
	AddDefault()
	// Lookup looks up @stock_id in the icon factory, returning an icon set if
	// found, otherwise nil. For display to the user, you should use
	// gtk_style_lookup_icon_set() on the Style for the widget that will display
	// the icon, instead of using this function directly, so that themes are
	// taken into account.
	Lookup(stockID string) *IconSet
	// RemoveDefault removes an icon factory from the list of default icon
	// factories. Not normally used; you might use it for a library that can be
	// unloaded or shut down.
	RemoveDefault()
}

// iconFactory implements the IconFactory interface.
type iconFactory struct {
	gextras.Objector
	Buildable
}

var _ IconFactory = (*iconFactory)(nil)

// WrapIconFactory wraps a GObject to the right type. It is
// primarily used internally.
func WrapIconFactory(obj *externglib.Object) IconFactory {
	return IconFactory{
		Objector:  obj,
		Buildable: WrapBuildable(obj),
	}
}

func marshalIconFactory(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIconFactory(obj), nil
}

// NewIconFactory constructs a class IconFactory.
func NewIconFactory() IconFactory {
	ret := C.gtk_icon_factory_new()

	var ret0 IconFactory

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(IconFactory)

	return ret0
}

// Add adds the given @icon_set to the icon factory, under the name
// @stock_id. @stock_id should be namespaced for your application, e.g.
// “myapp-whatever-icon”. Normally applications create a IconFactory, then
// add it to the list of default factories with
// gtk_icon_factory_add_default(). Then they pass the @stock_id to widgets
// such as Image to display the icon. Themes can provide an icon with the
// same name (such as "myapp-whatever-icon") to override your application’s
// default icons. If an icon already existed in @factory for @stock_id, it
// is unreferenced and replaced with the new @icon_set.
func (f iconFactory) Add(stockID string, iconSet *IconSet) {
	var arg0 *C.GtkIconFactory
	var arg1 *C.gchar
	var arg2 *C.GtkIconSet

	arg0 = (*C.GtkIconFactory)(f.Native())
	arg1 = (*C.gchar)(C.CString(stockID))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GtkIconSet)(iconSet.Native())

	C.gtk_icon_factory_add(arg0, arg1, arg2)
}

// AddDefault adds an icon factory to the list of icon factories searched by
// gtk_style_lookup_icon_set(). This means that, for example,
// gtk_image_new_from_stock() will be able to find icons in @factory. There
// will normally be an icon factory added for each library or application
// that comes with icons. The default icon factories can be overridden by
// themes.
func (f iconFactory) AddDefault() {
	var arg0 *C.GtkIconFactory

	arg0 = (*C.GtkIconFactory)(f.Native())

	C.gtk_icon_factory_add_default(arg0)
}

// Lookup looks up @stock_id in the icon factory, returning an icon set if
// found, otherwise nil. For display to the user, you should use
// gtk_style_lookup_icon_set() on the Style for the widget that will display
// the icon, instead of using this function directly, so that themes are
// taken into account.
func (f iconFactory) Lookup(stockID string) *IconSet {
	var arg0 *C.GtkIconFactory
	var arg1 *C.gchar

	arg0 = (*C.GtkIconFactory)(f.Native())
	arg1 = (*C.gchar)(C.CString(stockID))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_icon_factory_lookup(arg0, arg1)

	var ret0 *IconSet

	{
		ret0 = WrapIconSet(unsafe.Pointer(ret))
	}

	return ret0
}

// RemoveDefault removes an icon factory from the list of default icon
// factories. Not normally used; you might use it for a library that can be
// unloaded or shut down.
func (f iconFactory) RemoveDefault() {
	var arg0 *C.GtkIconFactory

	arg0 = (*C.GtkIconFactory)(f.Native())

	C.gtk_icon_factory_remove_default(arg0)
}

type IconFactoryPrivate struct {
	native C.GtkIconFactoryPrivate
}

// WrapIconFactoryPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapIconFactoryPrivate(ptr unsafe.Pointer) *IconFactoryPrivate {
	if ptr == nil {
		return nil
	}

	return (*IconFactoryPrivate)(ptr)
}

func marshalIconFactoryPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapIconFactoryPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (i *IconFactoryPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}
