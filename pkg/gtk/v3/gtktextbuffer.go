// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_text_buffer_get_type()), F: marshalTextBuffer},
	})
}

// TextBuffer: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
type TextBuffer interface {
	gextras.Objector

	// AddMark adds the mark at position @where. The mark must not be added to
	// another buffer, and if its name is not nil then there must not be another
	// mark in the buffer with the same name.
	//
	// Emits the TextBuffer::mark-set signal as notification of the mark's
	// initial placement.
	AddMark(mark TextMark, where *TextIter)
	// AddSelectionClipboard adds @clipboard to the list of clipboards in which
	// the selection contents of @buffer are available. In most cases,
	// @clipboard will be the Clipboard of type GDK_SELECTION_PRIMARY for a view
	// of @buffer.
	AddSelectionClipboard(clipboard Clipboard)
	// ApplyTag emits the “apply-tag” signal on @buffer. The default handler for
	// the signal applies @tag to the given range. @start and @end do not have
	// to be in order.
	ApplyTag(tag TextTag, start *TextIter, end *TextIter)
	// ApplyTagByName calls gtk_text_tag_table_lookup() on the buffer’s tag
	// table to get a TextTag, then calls gtk_text_buffer_apply_tag().
	ApplyTagByName(name string, start *TextIter, end *TextIter)
	// Backspace performs the appropriate action as if the user hit the delete
	// key with the cursor at the position specified by @iter. In the normal
	// case a single character will be deleted, but when combining accents are
	// involved, more than one character can be deleted, and when precomposed
	// character and accent combinations are involved, less than one character
	// will be deleted.
	//
	// Because the buffer is modified, all outstanding iterators become invalid
	// after calling this function; however, the @iter will be re-initialized to
	// point to the location where text was deleted.
	Backspace(iter *TextIter, interactive bool, defaultEditable bool) bool
	// BeginUserAction: called to indicate that the buffer operations between
	// here and a call to gtk_text_buffer_end_user_action() are part of a single
	// user-visible operation. The operations between
	// gtk_text_buffer_begin_user_action() and gtk_text_buffer_end_user_action()
	// can then be grouped when creating an undo stack. TextBuffer maintains a
	// count of calls to gtk_text_buffer_begin_user_action() that have not been
	// closed with a call to gtk_text_buffer_end_user_action(), and emits the
	// “begin-user-action” and “end-user-action” signals only for the outermost
	// pair of calls. This allows you to build user actions from other user
	// actions.
	//
	// The “interactive” buffer mutation functions, such as
	// gtk_text_buffer_insert_interactive(), automatically call begin/end user
	// action around the buffer operations they perform, so there's no need to
	// add extra calls if you user action consists solely of a single call to
	// one of those functions.
	BeginUserAction()
	// CopyClipboard copies the currently-selected text to a clipboard.
	CopyClipboard(clipboard Clipboard)
	// CreateChildAnchor: this is a convenience function which simply creates a
	// child anchor with gtk_text_child_anchor_new() and inserts it into the
	// buffer with gtk_text_buffer_insert_child_anchor(). The new anchor is
	// owned by the buffer; no reference count is returned to the caller of
	// gtk_text_buffer_create_child_anchor().
	CreateChildAnchor(iter *TextIter) TextChildAnchor
	// CreateMark creates a mark at position @where. If @mark_name is nil, the
	// mark is anonymous; otherwise, the mark can be retrieved by name using
	// gtk_text_buffer_get_mark(). If a mark has left gravity, and text is
	// inserted at the mark’s current location, the mark will be moved to the
	// left of the newly-inserted text. If the mark has right gravity
	// (@left_gravity = false), the mark will end up on the right of
	// newly-inserted text. The standard left-to-right cursor is a mark with
	// right gravity (when you type, the cursor stays on the right side of the
	// text you’re typing).
	//
	// The caller of this function does not own a reference to the returned
	// TextMark, so you can ignore the return value if you like. Marks are owned
	// by the buffer and go away when the buffer does.
	//
	// Emits the TextBuffer::mark-set signal as notification of the mark's
	// initial placement.
	CreateMark(markName string, where *TextIter, leftGravity bool) TextMark
	// CutClipboard copies the currently-selected text to a clipboard, then
	// deletes said text if it’s editable.
	CutClipboard(clipboard Clipboard, defaultEditable bool)
	// Delete deletes text between @start and @end. The order of @start and @end
	// is not actually relevant; gtk_text_buffer_delete() will reorder them.
	// This function actually emits the “delete-range” signal, and the default
	// handler of that signal deletes the text. Because the buffer is modified,
	// all outstanding iterators become invalid after calling this function;
	// however, the @start and @end will be re-initialized to point to the
	// location where text was deleted.
	Delete(start *TextIter, end *TextIter)
	// DeleteInteractive deletes all editable text in the given range. Calls
	// gtk_text_buffer_delete() for each editable sub-range of [@start,@end).
	// @start and @end are revalidated to point to the location of the last
	// deleted range, or left untouched if no text was deleted.
	DeleteInteractive(startIter *TextIter, endIter *TextIter, defaultEditable bool) bool
	// DeleteMark deletes @mark, so that it’s no longer located anywhere in the
	// buffer. Removes the reference the buffer holds to the mark, so if you
	// haven’t called g_object_ref() on the mark, it will be freed. Even if the
	// mark isn’t freed, most operations on @mark become invalid, until it gets
	// added to a buffer again with gtk_text_buffer_add_mark(). Use
	// gtk_text_mark_get_deleted() to find out if a mark has been removed from
	// its buffer. The TextBuffer::mark-deleted signal will be emitted as
	// notification after the mark is deleted.
	DeleteMark(mark TextMark)
	// DeleteMarkByName deletes the mark named @name; the mark must exist. See
	// gtk_text_buffer_delete_mark() for details.
	DeleteMarkByName(name string)
	// DeleteSelection deletes the range between the “insert” and
	// “selection_bound” marks, that is, the currently-selected text. If
	// @interactive is true, the editability of the selection will be considered
	// (users can’t delete uneditable text).
	DeleteSelection(interactive bool, defaultEditable bool) bool
	// Deserialize: this function deserializes rich text in format @format and
	// inserts it at @iter.
	//
	// @formats to be used must be registered using
	// gtk_text_buffer_register_deserialize_format() or
	// gtk_text_buffer_register_deserialize_tagset() beforehand.
	Deserialize(contentBuffer TextBuffer, format gdk.Atom, iter *TextIter, data []byte) error
	// DeserializeGetCanCreateTags: this functions returns the value set with
	// gtk_text_buffer_deserialize_set_can_create_tags()
	DeserializeGetCanCreateTags(format gdk.Atom) bool
	// DeserializeSetCanCreateTags: use this function to allow a rich text
	// deserialization function to create new tags in the receiving buffer. Note
	// that using this function is almost always a bad idea, because the rich
	// text functions you register should know how to map the rich text format
	// they handler to your text buffers set of tags.
	//
	// The ability of creating new (arbitrary!) tags in the receiving buffer is
	// meant for special rich text formats like the internal one that is
	// registered using gtk_text_buffer_register_deserialize_tagset(), because
	// that format is essentially a dump of the internal structure of the source
	// buffer, including its tag names.
	//
	// You should allow creation of tags only if you know what you are doing,
	// e.g. if you defined a tagset name for your application suite’s text
	// buffers and you know that it’s fine to receive new tags from these
	// buffers, because you know that your application can handle the newly
	// created tags.
	DeserializeSetCanCreateTags(format gdk.Atom, canCreateTags bool)
	// EndUserAction: should be paired with a call to
	// gtk_text_buffer_begin_user_action(). See that function for a full
	// explanation.
	EndUserAction()
	// Bounds retrieves the first and last iterators in the buffer, i.e. the
	// entire buffer lies within the range [@start,@end).
	Bounds() (start TextIter, end TextIter)
	// CharCount gets the number of characters in the buffer; note that
	// characters and bytes are not the same, you can’t e.g. expect the contents
	// of the buffer in string form to be this many bytes long. The character
	// count is cached, so this function is very fast.
	CharCount() int
	// CopyTargetList: this function returns the list of targets this text
	// buffer can provide for copying and as DND source. The targets in the list
	// are added with @info values from the TextBufferTargetInfo enum, using
	// gtk_target_list_add_rich_text_targets() and
	// gtk_target_list_add_text_targets().
	CopyTargetList() *TargetList
	// DeserializeFormats: this function returns the rich text deserialize
	// formats registered with @buffer using
	// gtk_text_buffer_register_deserialize_format() or
	// gtk_text_buffer_register_deserialize_tagset()
	DeserializeFormats() (nFormats int, atoms []gdk.Atom)
	// EndIter initializes @iter with the “end iterator,” one past the last
	// valid character in the text buffer. If dereferenced with
	// gtk_text_iter_get_char(), the end iterator has a character value of 0.
	// The entire buffer lies in the range from the first position in the buffer
	// (call gtk_text_buffer_get_start_iter() to get character position 0) to
	// the end iterator.
	EndIter() TextIter
	// HasSelection indicates whether the buffer has some text currently
	// selected.
	HasSelection() bool
	// GetInsert returns the mark that represents the cursor (insertion point).
	// Equivalent to calling gtk_text_buffer_get_mark() to get the mark named
	// “insert”, but very slightly more efficient, and involves less typing.
	GetInsert() TextMark
	// IterAtChildAnchor obtains the location of @anchor within @buffer.
	IterAtChildAnchor(anchor TextChildAnchor) TextIter
	// IterAtLine initializes @iter to the start of the given line. If
	// @line_number is greater than the number of lines in the @buffer, the end
	// iterator is returned.
	IterAtLine(lineNumber int) TextIter
	// IterAtLineIndex obtains an iterator pointing to @byte_index within the
	// given line. @byte_index must be the start of a UTF-8 character. Note
	// bytes, not characters; UTF-8 may encode one character as multiple bytes.
	//
	// Before the 3.20 version, it was not allowed to pass an invalid location.
	//
	// Since the 3.20 version, if @line_number is greater than the number of
	// lines in the @buffer, the end iterator is returned. And if @byte_index is
	// off the end of the line, the iterator at the end of the line is returned.
	IterAtLineIndex(lineNumber int, byteIndex int) TextIter
	// IterAtLineOffset obtains an iterator pointing to @char_offset within the
	// given line. Note characters, not bytes; UTF-8 may encode one character as
	// multiple bytes.
	//
	// Before the 3.20 version, it was not allowed to pass an invalid location.
	//
	// Since the 3.20 version, if @line_number is greater than the number of
	// lines in the @buffer, the end iterator is returned. And if @char_offset
	// is off the end of the line, the iterator at the end of the line is
	// returned.
	IterAtLineOffset(lineNumber int, charOffset int) TextIter
	// IterAtMark initializes @iter with the current position of @mark.
	IterAtMark(mark TextMark) TextIter
	// IterAtOffset initializes @iter to a position @char_offset chars from the
	// start of the entire buffer. If @char_offset is -1 or greater than the
	// number of characters in the buffer, @iter is initialized to the end
	// iterator, the iterator one past the last valid character in the buffer.
	IterAtOffset(charOffset int) TextIter
	// LineCount obtains the number of lines in the buffer. This value is
	// cached, so the function is very fast.
	LineCount() int
	// Mark returns the mark named @name in buffer @buffer, or nil if no such
	// mark exists in the buffer.
	Mark(name string) TextMark
	// Modified indicates whether the buffer has been modified since the last
	// call to gtk_text_buffer_set_modified() set the modification flag to
	// false. Used for example to enable a “save” function in a text editor.
	Modified() bool
	// PasteTargetList: this function returns the list of targets this text
	// buffer supports for pasting and as DND destination. The targets in the
	// list are added with @info values from the TextBufferTargetInfo enum,
	// using gtk_target_list_add_rich_text_targets() and
	// gtk_target_list_add_text_targets().
	PasteTargetList() *TargetList
	// SelectionBound returns the mark that represents the selection bound.
	// Equivalent to calling gtk_text_buffer_get_mark() to get the mark named
	// “selection_bound”, but very slightly more efficient, and involves less
	// typing.
	//
	// The currently-selected text in @buffer is the region between the
	// “selection_bound” and “insert” marks. If “selection_bound” and “insert”
	// are in the same place, then there is no current selection.
	// gtk_text_buffer_get_selection_bounds() is another convenient function for
	// handling the selection, if you just want to know whether there’s a
	// selection and what its bounds are.
	SelectionBound() TextMark
	// SelectionBounds returns true if some text is selected; places the bounds
	// of the selection in @start and @end (if the selection has length 0, then
	// @start and @end are filled in with the same value). @start and @end will
	// be in ascending order. If @start and @end are NULL, then they are not
	// filled in, but the return value still indicates whether text is selected.
	SelectionBounds() (start TextIter, end TextIter, ok bool)
	// SerializeFormats: this function returns the rich text serialize formats
	// registered with @buffer using gtk_text_buffer_register_serialize_format()
	// or gtk_text_buffer_register_serialize_tagset()
	SerializeFormats() (nFormats int, atoms []gdk.Atom)
	// Slice returns the text in the range [@start,@end). Excludes undisplayed
	// text (text marked with tags that set the invisibility attribute) if
	// @include_hidden_chars is false. The returned string includes a 0xFFFC
	// character whenever the buffer contains embedded images, so byte and
	// character indexes into the returned string do correspond to byte and
	// character indexes into the buffer. Contrast with
	// gtk_text_buffer_get_text(). Note that 0xFFFC can occur in normal text as
	// well, so it is not a reliable indicator that a pixbuf or widget is in the
	// buffer.
	Slice(start *TextIter, end *TextIter, includeHiddenChars bool) string
	// StartIter: initialized @iter with the first position in the text buffer.
	// This is the same as using gtk_text_buffer_get_iter_at_offset() to get the
	// iter at character offset 0.
	StartIter() TextIter
	// TagTable: get the TextTagTable associated with this buffer.
	TagTable() TextTagTable
	// Text returns the text in the range [@start,@end). Excludes undisplayed
	// text (text marked with tags that set the invisibility attribute) if
	// @include_hidden_chars is false. Does not include characters representing
	// embedded images, so byte and character indexes into the returned string
	// do not correspond to byte and character indexes into the buffer. Contrast
	// with gtk_text_buffer_get_slice().
	Text(start *TextIter, end *TextIter, includeHiddenChars bool) string
	// Insert inserts @len bytes of @text at position @iter. If @len is -1,
	// @text must be nul-terminated and will be inserted in its entirety. Emits
	// the “insert-text” signal; insertion actually occurs in the default
	// handler for the signal. @iter is invalidated when insertion occurs
	// (because the buffer contents change), but the default signal handler
	// revalidates it to point to the end of the inserted text.
	Insert(iter *TextIter, text string, len int)
	// InsertAtCursor: simply calls gtk_text_buffer_insert(), using the current
	// cursor position as the insertion point.
	InsertAtCursor(text string, len int)
	// InsertChildAnchor inserts a child widget anchor into the text buffer at
	// @iter. The anchor will be counted as one character in character counts,
	// and when obtaining the buffer contents as a string, will be represented
	// by the Unicode “object replacement character” 0xFFFC. Note that the
	// “slice” variants for obtaining portions of the buffer as a string include
	// this character for child anchors, but the “text” variants do not. E.g.
	// see gtk_text_buffer_get_slice() and gtk_text_buffer_get_text(). Consider
	// gtk_text_buffer_create_child_anchor() as a more convenient alternative to
	// this function. The buffer will add a reference to the anchor, so you can
	// unref it after insertion.
	InsertChildAnchor(iter *TextIter, anchor TextChildAnchor)
	// InsertInteractive: like gtk_text_buffer_insert(), but the insertion will
	// not occur if @iter is at a non-editable location in the buffer. Usually
	// you want to prevent insertions at ineditable locations if the insertion
	// results from a user action (is interactive).
	//
	// @default_editable indicates the editability of text that doesn't have a
	// tag affecting editability applied to it. Typically the result of
	// gtk_text_view_get_editable() is appropriate here.
	InsertInteractive(iter *TextIter, text string, len int, defaultEditable bool) bool
	// InsertInteractiveAtCursor calls gtk_text_buffer_insert_interactive() at
	// the cursor position.
	//
	// @default_editable indicates the editability of text that doesn't have a
	// tag affecting editability applied to it. Typically the result of
	// gtk_text_view_get_editable() is appropriate here.
	InsertInteractiveAtCursor(text string, len int, defaultEditable bool) bool
	// InsertMarkup inserts the text in @markup at position @iter. @markup will
	// be inserted in its entirety and must be nul-terminated and valid UTF-8.
	// Emits the TextBuffer::insert-text signal, possibly multiple times;
	// insertion actually occurs in the default handler for the signal. @iter
	// will point to the end of the inserted text on return.
	InsertMarkup(iter *TextIter, markup string, len int)
	// InsertPixbuf inserts an image into the text buffer at @iter. The image
	// will be counted as one character in character counts, and when obtaining
	// the buffer contents as a string, will be represented by the Unicode
	// “object replacement character” 0xFFFC. Note that the “slice” variants for
	// obtaining portions of the buffer as a string include this character for
	// pixbufs, but the “text” variants do not. e.g. see
	// gtk_text_buffer_get_slice() and gtk_text_buffer_get_text().
	InsertPixbuf(iter *TextIter, pixbuf gdkpixbuf.Pixbuf)
	// InsertRange copies text, tags, and pixbufs between @start and @end (the
	// order of @start and @end doesn’t matter) and inserts the copy at @iter.
	// Used instead of simply getting/inserting text because it preserves images
	// and tags. If @start and @end are in a different buffer from @buffer, the
	// two buffers must share the same tag table.
	//
	// Implemented via emissions of the insert_text and apply_tag signals, so
	// expect those.
	InsertRange(iter *TextIter, start *TextIter, end *TextIter)
	// InsertRangeInteractive: same as gtk_text_buffer_insert_range(), but does
	// nothing if the insertion point isn’t editable. The @default_editable
	// parameter indicates whether the text is editable at @iter if no tags
	// enclosing @iter affect editability. Typically the result of
	// gtk_text_view_get_editable() is appropriate here.
	InsertRangeInteractive(iter *TextIter, start *TextIter, end *TextIter, defaultEditable bool) bool
	// MoveMark moves @mark to the new location @where. Emits the
	// TextBuffer::mark-set signal as notification of the move.
	MoveMark(mark TextMark, where *TextIter)
	// MoveMarkByName moves the mark named @name (which must exist) to location
	// @where. See gtk_text_buffer_move_mark() for details.
	MoveMarkByName(name string, where *TextIter)
	// PasteClipboard pastes the contents of a clipboard. If @override_location
	// is nil, the pasted text will be inserted at the cursor position, or the
	// buffer selection will be replaced if the selection is non-empty.
	//
	// Note: pasting is asynchronous, that is, we’ll ask for the paste data and
	// return, and at some point later after the main loop runs, the paste data
	// will be inserted.
	PasteClipboard(clipboard Clipboard, overrideLocation *TextIter, defaultEditable bool)
	// PlaceCursor: this function moves the “insert” and “selection_bound” marks
	// simultaneously. If you move them to the same place in two steps with
	// gtk_text_buffer_move_mark(), you will temporarily select a region in
	// between their old and new locations, which can be pretty inefficient
	// since the temporarily-selected region will force stuff to be
	// recalculated. This function moves them as a unit, which can be optimized.
	PlaceCursor(where *TextIter)
	// RegisterDeserializeFormat: this function registers a rich text
	// deserialization @function along with its @mime_type with the passed
	// @buffer.
	RegisterDeserializeFormat(mimeType string, function TextBufferDeserializeFunc) gdk.Atom
	// RegisterDeserializeTagset: this function registers GTK+’s internal rich
	// text serialization format with the passed @buffer. See
	// gtk_text_buffer_register_serialize_tagset() for details.
	RegisterDeserializeTagset(tagsetName string) gdk.Atom
	// RegisterSerializeFormat: this function registers a rich text
	// serialization @function along with its @mime_type with the passed
	// @buffer.
	RegisterSerializeFormat(mimeType string, function TextBufferSerializeFunc) gdk.Atom
	// RegisterSerializeTagset: this function registers GTK+’s internal rich
	// text serialization format with the passed @buffer. The internal format
	// does not comply to any standard rich text format and only works between
	// TextBuffer instances. It is capable of serializing all of a text buffer’s
	// tags and embedded pixbufs.
	//
	// This function is just a wrapper around
	// gtk_text_buffer_register_serialize_format(). The mime type used for
	// registering is “application/x-gtk-text-buffer-rich-text”, or
	// “application/x-gtk-text-buffer-rich-text;format=@tagset_name” if a
	// @tagset_name was passed.
	//
	// The @tagset_name can be used to restrict the transfer of rich text to
	// buffers with compatible sets of tags, in order to avoid unknown tags from
	// being pasted. It is probably the common case to pass an identifier != nil
	// here, since the nil tagset requires the receiving buffer to deal with
	// with pasting of arbitrary tags.
	RegisterSerializeTagset(tagsetName string) gdk.Atom
	// RemoveAllTags removes all tags in the range between @start and @end. Be
	// careful with this function; it could remove tags added in code unrelated
	// to the code you’re currently writing. That is, using this function is
	// probably a bad idea if you have two or more unrelated code sections that
	// add tags.
	RemoveAllTags(start *TextIter, end *TextIter)
	// RemoveSelectionClipboard removes a Clipboard added with
	// gtk_text_buffer_add_selection_clipboard().
	RemoveSelectionClipboard(clipboard Clipboard)
	// RemoveTag emits the “remove-tag” signal. The default handler for the
	// signal removes all occurrences of @tag from the given range. @start and
	// @end don’t have to be in order.
	RemoveTag(tag TextTag, start *TextIter, end *TextIter)
	// RemoveTagByName calls gtk_text_tag_table_lookup() on the buffer’s tag
	// table to get a TextTag, then calls gtk_text_buffer_remove_tag().
	RemoveTagByName(name string, start *TextIter, end *TextIter)
	// SelectRange: this function moves the “insert” and “selection_bound” marks
	// simultaneously. If you move them in two steps with
	// gtk_text_buffer_move_mark(), you will temporarily select a region in
	// between their old and new locations, which can be pretty inefficient
	// since the temporarily-selected region will force stuff to be
	// recalculated. This function moves them as a unit, which can be optimized.
	SelectRange(ins *TextIter, bound *TextIter)
	// Serialize: this function serializes the portion of text between @start
	// and @end in the rich text format represented by @format.
	//
	// @formats to be used must be registered using
	// gtk_text_buffer_register_serialize_format() or
	// gtk_text_buffer_register_serialize_tagset() beforehand.
	Serialize(contentBuffer TextBuffer, format gdk.Atom, start *TextIter, end *TextIter) (length uint, guint8s []byte)
	// SetModified: used to keep track of whether the buffer has been modified
	// since the last time it was saved. Whenever the buffer is saved to disk,
	// call gtk_text_buffer_set_modified (@buffer, FALSE). When the buffer is
	// modified, it will automatically toggled on the modified bit again. When
	// the modified bit flips, the buffer emits the TextBuffer::modified-changed
	// signal.
	SetModified(setting bool)
	// SetText deletes current contents of @buffer, and inserts @text instead.
	// If @len is -1, @text must be nul-terminated. @text must be valid UTF-8.
	SetText(text string, len int)
	// UnregisterDeserializeFormat: this function unregisters a rich text format
	// that was previously registered using
	// gtk_text_buffer_register_deserialize_format() or
	// gtk_text_buffer_register_deserialize_tagset().
	UnregisterDeserializeFormat(format gdk.Atom)
	// UnregisterSerializeFormat: this function unregisters a rich text format
	// that was previously registered using
	// gtk_text_buffer_register_serialize_format() or
	// gtk_text_buffer_register_serialize_tagset()
	UnregisterSerializeFormat(format gdk.Atom)
}

// textBuffer implements the TextBuffer interface.
type textBuffer struct {
	gextras.Objector
}

var _ TextBuffer = (*textBuffer)(nil)

// WrapTextBuffer wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextBuffer(obj *externglib.Object) TextBuffer {
	return TextBuffer{
		Objector: obj,
	}
}

func marshalTextBuffer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextBuffer(obj), nil
}

// NewTextBuffer constructs a class TextBuffer.
func NewTextBuffer(table TextTagTable) TextBuffer {
	var arg1 *C.GtkTextTagTable

	arg1 = (*C.GtkTextTagTable)(unsafe.Pointer(table.Native()))

	var cret C.GtkTextBuffer
	var ret1 TextBuffer

	cret = C.gtk_text_buffer_new(table)

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(TextBuffer)

	return ret1
}

// AddMark adds the mark at position @where. The mark must not be added to
// another buffer, and if its name is not nil then there must not be another
// mark in the buffer with the same name.
//
// Emits the TextBuffer::mark-set signal as notification of the mark's
// initial placement.
func (b textBuffer) AddMark(mark TextMark, where *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextMark
	var arg2 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))
	arg2 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))

	C.gtk_text_buffer_add_mark(arg0, mark, where)
}

// AddSelectionClipboard adds @clipboard to the list of clipboards in which
// the selection contents of @buffer are available. In most cases,
// @clipboard will be the Clipboard of type GDK_SELECTION_PRIMARY for a view
// of @buffer.
func (b textBuffer) AddSelectionClipboard(clipboard Clipboard) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkClipboard

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkClipboard)(unsafe.Pointer(clipboard.Native()))

	C.gtk_text_buffer_add_selection_clipboard(arg0, clipboard)
}

// ApplyTag emits the “apply-tag” signal on @buffer. The default handler for
// the signal applies @tag to the given range. @start and @end do not have
// to be in order.
func (b textBuffer) ApplyTag(tag TextTag, start *TextIter, end *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextTag
	var arg2 *C.GtkTextIter
	var arg3 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))
	arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_apply_tag(arg0, tag, start, end)
}

// ApplyTagByName calls gtk_text_tag_table_lookup() on the buffer’s tag
// table to get a TextTag, then calls gtk_text_buffer_apply_tag().
func (b textBuffer) ApplyTagByName(name string, start *TextIter, end *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.gchar
	var arg2 *C.GtkTextIter
	var arg3 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_apply_tag_by_name(arg0, name, start, end)
}

// Backspace performs the appropriate action as if the user hit the delete
// key with the cursor at the position specified by @iter. In the normal
// case a single character will be deleted, but when combining accents are
// involved, more than one character can be deleted, and when precomposed
// character and accent combinations are involved, less than one character
// will be deleted.
//
// Because the buffer is modified, all outstanding iterators become invalid
// after calling this function; however, the @iter will be re-initialized to
// point to the location where text was deleted.
func (b textBuffer) Backspace(iter *TextIter, interactive bool, defaultEditable bool) bool {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 C.gboolean
	var arg3 C.gboolean

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	if interactive {
		arg2 = C.gboolean(1)
	}
	if defaultEditable {
		arg3 = C.gboolean(1)
	}

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_text_buffer_backspace(arg0, iter, interactive, defaultEditable)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// BeginUserAction: called to indicate that the buffer operations between
// here and a call to gtk_text_buffer_end_user_action() are part of a single
// user-visible operation. The operations between
// gtk_text_buffer_begin_user_action() and gtk_text_buffer_end_user_action()
// can then be grouped when creating an undo stack. TextBuffer maintains a
// count of calls to gtk_text_buffer_begin_user_action() that have not been
// closed with a call to gtk_text_buffer_end_user_action(), and emits the
// “begin-user-action” and “end-user-action” signals only for the outermost
// pair of calls. This allows you to build user actions from other user
// actions.
//
// The “interactive” buffer mutation functions, such as
// gtk_text_buffer_insert_interactive(), automatically call begin/end user
// action around the buffer operations they perform, so there's no need to
// add extra calls if you user action consists solely of a single call to
// one of those functions.
func (b textBuffer) BeginUserAction() {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	C.gtk_text_buffer_begin_user_action(arg0)
}

// CopyClipboard copies the currently-selected text to a clipboard.
func (b textBuffer) CopyClipboard(clipboard Clipboard) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkClipboard

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkClipboard)(unsafe.Pointer(clipboard.Native()))

	C.gtk_text_buffer_copy_clipboard(arg0, clipboard)
}

// CreateChildAnchor: this is a convenience function which simply creates a
// child anchor with gtk_text_child_anchor_new() and inserts it into the
// buffer with gtk_text_buffer_insert_child_anchor(). The new anchor is
// owned by the buffer; no reference count is returned to the caller of
// gtk_text_buffer_create_child_anchor().
func (b textBuffer) CreateChildAnchor(iter *TextIter) TextChildAnchor {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

	var cret *C.GtkTextChildAnchor
	var ret1 TextChildAnchor

	cret = C.gtk_text_buffer_create_child_anchor(arg0, iter)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(TextChildAnchor)

	return ret1
}

// CreateMark creates a mark at position @where. If @mark_name is nil, the
// mark is anonymous; otherwise, the mark can be retrieved by name using
// gtk_text_buffer_get_mark(). If a mark has left gravity, and text is
// inserted at the mark’s current location, the mark will be moved to the
// left of the newly-inserted text. If the mark has right gravity
// (@left_gravity = false), the mark will end up on the right of
// newly-inserted text. The standard left-to-right cursor is a mark with
// right gravity (when you type, the cursor stays on the right side of the
// text you’re typing).
//
// The caller of this function does not own a reference to the returned
// TextMark, so you can ignore the return value if you like. Marks are owned
// by the buffer and go away when the buffer does.
//
// Emits the TextBuffer::mark-set signal as notification of the mark's
// initial placement.
func (b textBuffer) CreateMark(markName string, where *TextIter, leftGravity bool) TextMark {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.gchar
	var arg2 *C.GtkTextIter
	var arg3 C.gboolean

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.gchar)(C.CString(markName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))
	if leftGravity {
		arg3 = C.gboolean(1)
	}

	var cret *C.GtkTextMark
	var ret1 TextMark

	cret = C.gtk_text_buffer_create_mark(arg0, markName, where, leftGravity)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(TextMark)

	return ret1
}

// CutClipboard copies the currently-selected text to a clipboard, then
// deletes said text if it’s editable.
func (b textBuffer) CutClipboard(clipboard Clipboard, defaultEditable bool) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkClipboard
	var arg2 C.gboolean

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkClipboard)(unsafe.Pointer(clipboard.Native()))
	if defaultEditable {
		arg2 = C.gboolean(1)
	}

	C.gtk_text_buffer_cut_clipboard(arg0, clipboard, defaultEditable)
}

// Delete deletes text between @start and @end. The order of @start and @end
// is not actually relevant; gtk_text_buffer_delete() will reorder them.
// This function actually emits the “delete-range” signal, and the default
// handler of that signal deletes the text. Because the buffer is modified,
// all outstanding iterators become invalid after calling this function;
// however, the @start and @end will be re-initialized to point to the
// location where text was deleted.
func (b textBuffer) Delete(start *TextIter, end *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_delete(arg0, start, end)
}

// DeleteInteractive deletes all editable text in the given range. Calls
// gtk_text_buffer_delete() for each editable sub-range of [@start,@end).
// @start and @end are revalidated to point to the location of the last
// deleted range, or left untouched if no text was deleted.
func (b textBuffer) DeleteInteractive(startIter *TextIter, endIter *TextIter, defaultEditable bool) bool {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextIter
	var arg3 C.gboolean

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(startIter.Native()))
	arg2 = (*C.GtkTextIter)(unsafe.Pointer(endIter.Native()))
	if defaultEditable {
		arg3 = C.gboolean(1)
	}

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_text_buffer_delete_interactive(arg0, startIter, endIter, defaultEditable)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// DeleteMark deletes @mark, so that it’s no longer located anywhere in the
// buffer. Removes the reference the buffer holds to the mark, so if you
// haven’t called g_object_ref() on the mark, it will be freed. Even if the
// mark isn’t freed, most operations on @mark become invalid, until it gets
// added to a buffer again with gtk_text_buffer_add_mark(). Use
// gtk_text_mark_get_deleted() to find out if a mark has been removed from
// its buffer. The TextBuffer::mark-deleted signal will be emitted as
// notification after the mark is deleted.
func (b textBuffer) DeleteMark(mark TextMark) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextMark

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))

	C.gtk_text_buffer_delete_mark(arg0, mark)
}

// DeleteMarkByName deletes the mark named @name; the mark must exist. See
// gtk_text_buffer_delete_mark() for details.
func (b textBuffer) DeleteMarkByName(name string) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.gchar

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_text_buffer_delete_mark_by_name(arg0, name)
}

// DeleteSelection deletes the range between the “insert” and
// “selection_bound” marks, that is, the currently-selected text. If
// @interactive is true, the editability of the selection will be considered
// (users can’t delete uneditable text).
func (b textBuffer) DeleteSelection(interactive bool, defaultEditable bool) bool {
	var arg0 *C.GtkTextBuffer
	var arg1 C.gboolean
	var arg2 C.gboolean

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	if interactive {
		arg1 = C.gboolean(1)
	}
	if defaultEditable {
		arg2 = C.gboolean(1)
	}

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_text_buffer_delete_selection(arg0, interactive, defaultEditable)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// Deserialize: this function deserializes rich text in format @format and
// inserts it at @iter.
//
// @formats to be used must be registered using
// gtk_text_buffer_register_deserialize_format() or
// gtk_text_buffer_register_deserialize_tagset() beforehand.
func (r textBuffer) Deserialize(contentBuffer TextBuffer, format gdk.Atom, iter *TextIter, data []byte) error {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(r.Native()))

	var errout *C.GError
	var goerr error

	C.gtk_text_buffer_deserialize(arg0, contentBuffer, format, iter, data, length, &errout)

	goerr = gerror.Take(unsafe.Pointer(errout))

	return goerr
}

// DeserializeGetCanCreateTags: this functions returns the value set with
// gtk_text_buffer_deserialize_set_can_create_tags()
func (b textBuffer) DeserializeGetCanCreateTags(format gdk.Atom) bool {
	var arg0 *C.GtkTextBuffer
	var arg1 C.GdkAtom

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (C.GdkAtom)(unsafe.Pointer(format.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_text_buffer_deserialize_get_can_create_tags(arg0, format)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// DeserializeSetCanCreateTags: use this function to allow a rich text
// deserialization function to create new tags in the receiving buffer. Note
// that using this function is almost always a bad idea, because the rich
// text functions you register should know how to map the rich text format
// they handler to your text buffers set of tags.
//
// The ability of creating new (arbitrary!) tags in the receiving buffer is
// meant for special rich text formats like the internal one that is
// registered using gtk_text_buffer_register_deserialize_tagset(), because
// that format is essentially a dump of the internal structure of the source
// buffer, including its tag names.
//
// You should allow creation of tags only if you know what you are doing,
// e.g. if you defined a tagset name for your application suite’s text
// buffers and you know that it’s fine to receive new tags from these
// buffers, because you know that your application can handle the newly
// created tags.
func (b textBuffer) DeserializeSetCanCreateTags(format gdk.Atom, canCreateTags bool) {
	var arg0 *C.GtkTextBuffer
	var arg1 C.GdkAtom
	var arg2 C.gboolean

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (C.GdkAtom)(unsafe.Pointer(format.Native()))
	if canCreateTags {
		arg2 = C.gboolean(1)
	}

	C.gtk_text_buffer_deserialize_set_can_create_tags(arg0, format, canCreateTags)
}

// EndUserAction: should be paired with a call to
// gtk_text_buffer_begin_user_action(). See that function for a full
// explanation.
func (b textBuffer) EndUserAction() {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	C.gtk_text_buffer_end_user_action(arg0)
}

// Bounds retrieves the first and last iterators in the buffer, i.e. the
// entire buffer lies within the range [@start,@end).
func (b textBuffer) Bounds() (start TextIter, end TextIter) {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var arg1 C.GtkTextIter
	var ret1 *TextIter
	var arg2 C.GtkTextIter
	var ret2 *TextIter

	C.gtk_text_buffer_get_bounds(arg0, &arg1, &arg2)

	*ret1 = WrapTextIter(unsafe.Pointer(arg1))
	*ret2 = WrapTextIter(unsafe.Pointer(arg2))

	return ret1, ret2
}

// CharCount gets the number of characters in the buffer; note that
// characters and bytes are not the same, you can’t e.g. expect the contents
// of the buffer in string form to be this many bytes long. The character
// count is cached, so this function is very fast.
func (b textBuffer) CharCount() int {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var cret C.gint
	var ret1 int

	cret = C.gtk_text_buffer_get_char_count(arg0)

	ret1 = C.gint(cret)

	return ret1
}

// CopyTargetList: this function returns the list of targets this text
// buffer can provide for copying and as DND source. The targets in the list
// are added with @info values from the TextBufferTargetInfo enum, using
// gtk_target_list_add_rich_text_targets() and
// gtk_target_list_add_text_targets().
func (b textBuffer) CopyTargetList() *TargetList {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var cret *C.GtkTargetList
	var ret1 *TargetList

	cret = C.gtk_text_buffer_get_copy_target_list(arg0)

	ret1 = WrapTargetList(unsafe.Pointer(cret))

	return ret1
}

// DeserializeFormats: this function returns the rich text deserialize
// formats registered with @buffer using
// gtk_text_buffer_register_deserialize_format() or
// gtk_text_buffer_register_deserialize_tagset()
func (b textBuffer) DeserializeFormats() (nFormats int, atoms []gdk.Atom) {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var cret *C.GdkAtom
	var arg1 *C.gint
	var ret2 []gdk.Atom

	cret = C.gtk_text_buffer_get_deserialize_formats(arg0, &arg1)

	ret2 = make([]gdk.Atom, arg1)
	for i := 0; i < uintptr(arg1); i++ {
		src := (C.GdkAtom)(ptr.Add(unsafe.Pointer(cret), i))
		ret2[i] = gdk.WrapAtom(unsafe.Pointer(src))
	}

	return ret1, ret2
}

// EndIter initializes @iter with the “end iterator,” one past the last
// valid character in the text buffer. If dereferenced with
// gtk_text_iter_get_char(), the end iterator has a character value of 0.
// The entire buffer lies in the range from the first position in the buffer
// (call gtk_text_buffer_get_start_iter() to get character position 0) to
// the end iterator.
func (b textBuffer) EndIter() TextIter {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var arg1 C.GtkTextIter
	var ret1 *TextIter

	C.gtk_text_buffer_get_end_iter(arg0, &arg1)

	*ret1 = WrapTextIter(unsafe.Pointer(arg1))

	return ret1
}

// HasSelection indicates whether the buffer has some text currently
// selected.
func (b textBuffer) HasSelection() bool {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_text_buffer_get_has_selection(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// GetInsert returns the mark that represents the cursor (insertion point).
// Equivalent to calling gtk_text_buffer_get_mark() to get the mark named
// “insert”, but very slightly more efficient, and involves less typing.
func (b textBuffer) GetInsert() TextMark {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var cret *C.GtkTextMark
	var ret1 TextMark

	cret = C.gtk_text_buffer_get_insert(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(TextMark)

	return ret1
}

// IterAtChildAnchor obtains the location of @anchor within @buffer.
func (b textBuffer) IterAtChildAnchor(anchor TextChildAnchor) TextIter {
	var arg0 *C.GtkTextBuffer
	var arg2 *C.GtkTextChildAnchor

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg2 = (*C.GtkTextChildAnchor)(unsafe.Pointer(anchor.Native()))

	var arg1 C.GtkTextIter
	var ret1 *TextIter

	C.gtk_text_buffer_get_iter_at_child_anchor(arg0, &arg1, anchor)

	*ret1 = WrapTextIter(unsafe.Pointer(arg1))

	return ret1
}

// IterAtLine initializes @iter to the start of the given line. If
// @line_number is greater than the number of lines in the @buffer, the end
// iterator is returned.
func (b textBuffer) IterAtLine(lineNumber int) TextIter {
	var arg0 *C.GtkTextBuffer
	var arg2 C.gint

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg2 = C.gint(lineNumber)

	var arg1 C.GtkTextIter
	var ret1 *TextIter

	C.gtk_text_buffer_get_iter_at_line(arg0, &arg1, lineNumber)

	*ret1 = WrapTextIter(unsafe.Pointer(arg1))

	return ret1
}

// IterAtLineIndex obtains an iterator pointing to @byte_index within the
// given line. @byte_index must be the start of a UTF-8 character. Note
// bytes, not characters; UTF-8 may encode one character as multiple bytes.
//
// Before the 3.20 version, it was not allowed to pass an invalid location.
//
// Since the 3.20 version, if @line_number is greater than the number of
// lines in the @buffer, the end iterator is returned. And if @byte_index is
// off the end of the line, the iterator at the end of the line is returned.
func (b textBuffer) IterAtLineIndex(lineNumber int, byteIndex int) TextIter {
	var arg0 *C.GtkTextBuffer
	var arg2 C.gint
	var arg3 C.gint

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg2 = C.gint(lineNumber)
	arg3 = C.gint(byteIndex)

	var arg1 C.GtkTextIter
	var ret1 *TextIter

	C.gtk_text_buffer_get_iter_at_line_index(arg0, &arg1, lineNumber, byteIndex)

	*ret1 = WrapTextIter(unsafe.Pointer(arg1))

	return ret1
}

// IterAtLineOffset obtains an iterator pointing to @char_offset within the
// given line. Note characters, not bytes; UTF-8 may encode one character as
// multiple bytes.
//
// Before the 3.20 version, it was not allowed to pass an invalid location.
//
// Since the 3.20 version, if @line_number is greater than the number of
// lines in the @buffer, the end iterator is returned. And if @char_offset
// is off the end of the line, the iterator at the end of the line is
// returned.
func (b textBuffer) IterAtLineOffset(lineNumber int, charOffset int) TextIter {
	var arg0 *C.GtkTextBuffer
	var arg2 C.gint
	var arg3 C.gint

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg2 = C.gint(lineNumber)
	arg3 = C.gint(charOffset)

	var arg1 C.GtkTextIter
	var ret1 *TextIter

	C.gtk_text_buffer_get_iter_at_line_offset(arg0, &arg1, lineNumber, charOffset)

	*ret1 = WrapTextIter(unsafe.Pointer(arg1))

	return ret1
}

// IterAtMark initializes @iter with the current position of @mark.
func (b textBuffer) IterAtMark(mark TextMark) TextIter {
	var arg0 *C.GtkTextBuffer
	var arg2 *C.GtkTextMark

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg2 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))

	var arg1 C.GtkTextIter
	var ret1 *TextIter

	C.gtk_text_buffer_get_iter_at_mark(arg0, &arg1, mark)

	*ret1 = WrapTextIter(unsafe.Pointer(arg1))

	return ret1
}

// IterAtOffset initializes @iter to a position @char_offset chars from the
// start of the entire buffer. If @char_offset is -1 or greater than the
// number of characters in the buffer, @iter is initialized to the end
// iterator, the iterator one past the last valid character in the buffer.
func (b textBuffer) IterAtOffset(charOffset int) TextIter {
	var arg0 *C.GtkTextBuffer
	var arg2 C.gint

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg2 = C.gint(charOffset)

	var arg1 C.GtkTextIter
	var ret1 *TextIter

	C.gtk_text_buffer_get_iter_at_offset(arg0, &arg1, charOffset)

	*ret1 = WrapTextIter(unsafe.Pointer(arg1))

	return ret1
}

// LineCount obtains the number of lines in the buffer. This value is
// cached, so the function is very fast.
func (b textBuffer) LineCount() int {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var cret C.gint
	var ret1 int

	cret = C.gtk_text_buffer_get_line_count(arg0)

	ret1 = C.gint(cret)

	return ret1
}

// Mark returns the mark named @name in buffer @buffer, or nil if no such
// mark exists in the buffer.
func (b textBuffer) Mark(name string) TextMark {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.gchar

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.GtkTextMark
	var ret1 TextMark

	cret = C.gtk_text_buffer_get_mark(arg0, name)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(TextMark)

	return ret1
}

// Modified indicates whether the buffer has been modified since the last
// call to gtk_text_buffer_set_modified() set the modification flag to
// false. Used for example to enable a “save” function in a text editor.
func (b textBuffer) Modified() bool {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_text_buffer_get_modified(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// PasteTargetList: this function returns the list of targets this text
// buffer supports for pasting and as DND destination. The targets in the
// list are added with @info values from the TextBufferTargetInfo enum,
// using gtk_target_list_add_rich_text_targets() and
// gtk_target_list_add_text_targets().
func (b textBuffer) PasteTargetList() *TargetList {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var cret *C.GtkTargetList
	var ret1 *TargetList

	cret = C.gtk_text_buffer_get_paste_target_list(arg0)

	ret1 = WrapTargetList(unsafe.Pointer(cret))

	return ret1
}

// SelectionBound returns the mark that represents the selection bound.
// Equivalent to calling gtk_text_buffer_get_mark() to get the mark named
// “selection_bound”, but very slightly more efficient, and involves less
// typing.
//
// The currently-selected text in @buffer is the region between the
// “selection_bound” and “insert” marks. If “selection_bound” and “insert”
// are in the same place, then there is no current selection.
// gtk_text_buffer_get_selection_bounds() is another convenient function for
// handling the selection, if you just want to know whether there’s a
// selection and what its bounds are.
func (b textBuffer) SelectionBound() TextMark {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var cret *C.GtkTextMark
	var ret1 TextMark

	cret = C.gtk_text_buffer_get_selection_bound(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(TextMark)

	return ret1
}

// SelectionBounds returns true if some text is selected; places the bounds
// of the selection in @start and @end (if the selection has length 0, then
// @start and @end are filled in with the same value). @start and @end will
// be in ascending order. If @start and @end are NULL, then they are not
// filled in, but the return value still indicates whether text is selected.
func (b textBuffer) SelectionBounds() (start TextIter, end TextIter, ok bool) {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var arg1 C.GtkTextIter
	var ret1 *TextIter
	var arg2 C.GtkTextIter
	var ret2 *TextIter
	var cret C.gboolean
	var ret3 bool

	cret = C.gtk_text_buffer_get_selection_bounds(arg0, &arg1, &arg2)

	*ret1 = WrapTextIter(unsafe.Pointer(arg1))
	*ret2 = WrapTextIter(unsafe.Pointer(arg2))
	ret3 = C.bool(cret) != C.false

	return ret1, ret2, ret3
}

// SerializeFormats: this function returns the rich text serialize formats
// registered with @buffer using gtk_text_buffer_register_serialize_format()
// or gtk_text_buffer_register_serialize_tagset()
func (b textBuffer) SerializeFormats() (nFormats int, atoms []gdk.Atom) {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var cret *C.GdkAtom
	var arg1 *C.gint
	var ret2 []gdk.Atom

	cret = C.gtk_text_buffer_get_serialize_formats(arg0, &arg1)

	ret2 = make([]gdk.Atom, arg1)
	for i := 0; i < uintptr(arg1); i++ {
		src := (C.GdkAtom)(ptr.Add(unsafe.Pointer(cret), i))
		ret2[i] = gdk.WrapAtom(unsafe.Pointer(src))
	}

	return ret1, ret2
}

// Slice returns the text in the range [@start,@end). Excludes undisplayed
// text (text marked with tags that set the invisibility attribute) if
// @include_hidden_chars is false. The returned string includes a 0xFFFC
// character whenever the buffer contains embedded images, so byte and
// character indexes into the returned string do correspond to byte and
// character indexes into the buffer. Contrast with
// gtk_text_buffer_get_text(). Note that 0xFFFC can occur in normal text as
// well, so it is not a reliable indicator that a pixbuf or widget is in the
// buffer.
func (b textBuffer) Slice(start *TextIter, end *TextIter, includeHiddenChars bool) string {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextIter
	var arg3 C.gboolean

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))
	if includeHiddenChars {
		arg3 = C.gboolean(1)
	}

	var cret *C.gchar
	var ret1 string

	cret = C.gtk_text_buffer_get_slice(arg0, start, end, includeHiddenChars)

	ret1 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return ret1
}

// StartIter: initialized @iter with the first position in the text buffer.
// This is the same as using gtk_text_buffer_get_iter_at_offset() to get the
// iter at character offset 0.
func (b textBuffer) StartIter() TextIter {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var arg1 C.GtkTextIter
	var ret1 *TextIter

	C.gtk_text_buffer_get_start_iter(arg0, &arg1)

	*ret1 = WrapTextIter(unsafe.Pointer(arg1))

	return ret1
}

// TagTable: get the TextTagTable associated with this buffer.
func (b textBuffer) TagTable() TextTagTable {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var cret *C.GtkTextTagTable
	var ret1 TextTagTable

	cret = C.gtk_text_buffer_get_tag_table(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(TextTagTable)

	return ret1
}

// Text returns the text in the range [@start,@end). Excludes undisplayed
// text (text marked with tags that set the invisibility attribute) if
// @include_hidden_chars is false. Does not include characters representing
// embedded images, so byte and character indexes into the returned string
// do not correspond to byte and character indexes into the buffer. Contrast
// with gtk_text_buffer_get_slice().
func (b textBuffer) Text(start *TextIter, end *TextIter, includeHiddenChars bool) string {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextIter
	var arg3 C.gboolean

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))
	if includeHiddenChars {
		arg3 = C.gboolean(1)
	}

	var cret *C.gchar
	var ret1 string

	cret = C.gtk_text_buffer_get_text(arg0, start, end, includeHiddenChars)

	ret1 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return ret1
}

// Insert inserts @len bytes of @text at position @iter. If @len is -1,
// @text must be nul-terminated and will be inserted in its entirety. Emits
// the “insert-text” signal; insertion actually occurs in the default
// handler for the signal. @iter is invalidated when insertion occurs
// (because the buffer contents change), but the default signal handler
// revalidates it to point to the end of the inserted text.
func (b textBuffer) Insert(iter *TextIter, text string, len int) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.gchar
	var arg3 C.gint

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	arg2 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.gint(len)

	C.gtk_text_buffer_insert(arg0, iter, text, len)
}

// InsertAtCursor: simply calls gtk_text_buffer_insert(), using the current
// cursor position as the insertion point.
func (b textBuffer) InsertAtCursor(text string, len int) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.gchar
	var arg2 C.gint

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(len)

	C.gtk_text_buffer_insert_at_cursor(arg0, text, len)
}

// InsertChildAnchor inserts a child widget anchor into the text buffer at
// @iter. The anchor will be counted as one character in character counts,
// and when obtaining the buffer contents as a string, will be represented
// by the Unicode “object replacement character” 0xFFFC. Note that the
// “slice” variants for obtaining portions of the buffer as a string include
// this character for child anchors, but the “text” variants do not. E.g.
// see gtk_text_buffer_get_slice() and gtk_text_buffer_get_text(). Consider
// gtk_text_buffer_create_child_anchor() as a more convenient alternative to
// this function. The buffer will add a reference to the anchor, so you can
// unref it after insertion.
func (b textBuffer) InsertChildAnchor(iter *TextIter, anchor TextChildAnchor) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextChildAnchor

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	arg2 = (*C.GtkTextChildAnchor)(unsafe.Pointer(anchor.Native()))

	C.gtk_text_buffer_insert_child_anchor(arg0, iter, anchor)
}

// InsertInteractive: like gtk_text_buffer_insert(), but the insertion will
// not occur if @iter is at a non-editable location in the buffer. Usually
// you want to prevent insertions at ineditable locations if the insertion
// results from a user action (is interactive).
//
// @default_editable indicates the editability of text that doesn't have a
// tag affecting editability applied to it. Typically the result of
// gtk_text_view_get_editable() is appropriate here.
func (b textBuffer) InsertInteractive(iter *TextIter, text string, len int, defaultEditable bool) bool {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.gchar
	var arg3 C.gint
	var arg4 C.gboolean

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	arg2 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.gint(len)
	if defaultEditable {
		arg4 = C.gboolean(1)
	}

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_text_buffer_insert_interactive(arg0, iter, text, len, defaultEditable)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// InsertInteractiveAtCursor calls gtk_text_buffer_insert_interactive() at
// the cursor position.
//
// @default_editable indicates the editability of text that doesn't have a
// tag affecting editability applied to it. Typically the result of
// gtk_text_view_get_editable() is appropriate here.
func (b textBuffer) InsertInteractiveAtCursor(text string, len int, defaultEditable bool) bool {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.gchar
	var arg2 C.gint
	var arg3 C.gboolean

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(len)
	if defaultEditable {
		arg3 = C.gboolean(1)
	}

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_text_buffer_insert_interactive_at_cursor(arg0, text, len, defaultEditable)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// InsertMarkup inserts the text in @markup at position @iter. @markup will
// be inserted in its entirety and must be nul-terminated and valid UTF-8.
// Emits the TextBuffer::insert-text signal, possibly multiple times;
// insertion actually occurs in the default handler for the signal. @iter
// will point to the end of the inserted text on return.
func (b textBuffer) InsertMarkup(iter *TextIter, markup string, len int) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.gchar
	var arg3 C.gint

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	arg2 = (*C.gchar)(C.CString(markup))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.gint(len)

	C.gtk_text_buffer_insert_markup(arg0, iter, markup, len)
}

// InsertPixbuf inserts an image into the text buffer at @iter. The image
// will be counted as one character in character counts, and when obtaining
// the buffer contents as a string, will be represented by the Unicode
// “object replacement character” 0xFFFC. Note that the “slice” variants for
// obtaining portions of the buffer as a string include this character for
// pixbufs, but the “text” variants do not. e.g. see
// gtk_text_buffer_get_slice() and gtk_text_buffer_get_text().
func (b textBuffer) InsertPixbuf(iter *TextIter, pixbuf gdkpixbuf.Pixbuf) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GdkPixbuf

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	arg2 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	C.gtk_text_buffer_insert_pixbuf(arg0, iter, pixbuf)
}

// InsertRange copies text, tags, and pixbufs between @start and @end (the
// order of @start and @end doesn’t matter) and inserts the copy at @iter.
// Used instead of simply getting/inserting text because it preserves images
// and tags. If @start and @end are in a different buffer from @buffer, the
// two buffers must share the same tag table.
//
// Implemented via emissions of the insert_text and apply_tag signals, so
// expect those.
func (b textBuffer) InsertRange(iter *TextIter, start *TextIter, end *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextIter
	var arg3 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_insert_range(arg0, iter, start, end)
}

// InsertRangeInteractive: same as gtk_text_buffer_insert_range(), but does
// nothing if the insertion point isn’t editable. The @default_editable
// parameter indicates whether the text is editable at @iter if no tags
// enclosing @iter affect editability. Typically the result of
// gtk_text_view_get_editable() is appropriate here.
func (b textBuffer) InsertRangeInteractive(iter *TextIter, start *TextIter, end *TextIter, defaultEditable bool) bool {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextIter
	var arg3 *C.GtkTextIter
	var arg4 C.gboolean

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))
	if defaultEditable {
		arg4 = C.gboolean(1)
	}

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_text_buffer_insert_range_interactive(arg0, iter, start, end, defaultEditable)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// MoveMark moves @mark to the new location @where. Emits the
// TextBuffer::mark-set signal as notification of the move.
func (b textBuffer) MoveMark(mark TextMark, where *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextMark
	var arg2 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))
	arg2 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))

	C.gtk_text_buffer_move_mark(arg0, mark, where)
}

// MoveMarkByName moves the mark named @name (which must exist) to location
// @where. See gtk_text_buffer_move_mark() for details.
func (b textBuffer) MoveMarkByName(name string, where *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.gchar
	var arg2 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))

	C.gtk_text_buffer_move_mark_by_name(arg0, name, where)
}

// PasteClipboard pastes the contents of a clipboard. If @override_location
// is nil, the pasted text will be inserted at the cursor position, or the
// buffer selection will be replaced if the selection is non-empty.
//
// Note: pasting is asynchronous, that is, we’ll ask for the paste data and
// return, and at some point later after the main loop runs, the paste data
// will be inserted.
func (b textBuffer) PasteClipboard(clipboard Clipboard, overrideLocation *TextIter, defaultEditable bool) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkClipboard
	var arg2 *C.GtkTextIter
	var arg3 C.gboolean

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkClipboard)(unsafe.Pointer(clipboard.Native()))
	arg2 = (*C.GtkTextIter)(unsafe.Pointer(overrideLocation.Native()))
	if defaultEditable {
		arg3 = C.gboolean(1)
	}

	C.gtk_text_buffer_paste_clipboard(arg0, clipboard, overrideLocation, defaultEditable)
}

// PlaceCursor: this function moves the “insert” and “selection_bound” marks
// simultaneously. If you move them to the same place in two steps with
// gtk_text_buffer_move_mark(), you will temporarily select a region in
// between their old and new locations, which can be pretty inefficient
// since the temporarily-selected region will force stuff to be
// recalculated. This function moves them as a unit, which can be optimized.
func (b textBuffer) PlaceCursor(where *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))

	C.gtk_text_buffer_place_cursor(arg0, where)
}

// RegisterDeserializeFormat: this function registers a rich text
// deserialization @function along with its @mime_type with the passed
// @buffer.
func (b textBuffer) RegisterDeserializeFormat(mimeType string, function TextBufferDeserializeFunc) gdk.Atom {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var cret C.GdkAtom
	var ret1 gdk.Atom

	cret = C.gtk_text_buffer_register_deserialize_format(arg0, mimeType, function, userData, userDataDestroy)

	ret1 = gdk.WrapAtom(unsafe.Pointer(cret))

	return ret1
}

// RegisterDeserializeTagset: this function registers GTK+’s internal rich
// text serialization format with the passed @buffer. See
// gtk_text_buffer_register_serialize_tagset() for details.
func (b textBuffer) RegisterDeserializeTagset(tagsetName string) gdk.Atom {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.gchar

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.gchar)(C.CString(tagsetName))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.GdkAtom
	var ret1 gdk.Atom

	cret = C.gtk_text_buffer_register_deserialize_tagset(arg0, tagsetName)

	ret1 = gdk.WrapAtom(unsafe.Pointer(cret))

	return ret1
}

// RegisterSerializeFormat: this function registers a rich text
// serialization @function along with its @mime_type with the passed
// @buffer.
func (b textBuffer) RegisterSerializeFormat(mimeType string, function TextBufferSerializeFunc) gdk.Atom {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var cret C.GdkAtom
	var ret1 gdk.Atom

	cret = C.gtk_text_buffer_register_serialize_format(arg0, mimeType, function, userData, userDataDestroy)

	ret1 = gdk.WrapAtom(unsafe.Pointer(cret))

	return ret1
}

// RegisterSerializeTagset: this function registers GTK+’s internal rich
// text serialization format with the passed @buffer. The internal format
// does not comply to any standard rich text format and only works between
// TextBuffer instances. It is capable of serializing all of a text buffer’s
// tags and embedded pixbufs.
//
// This function is just a wrapper around
// gtk_text_buffer_register_serialize_format(). The mime type used for
// registering is “application/x-gtk-text-buffer-rich-text”, or
// “application/x-gtk-text-buffer-rich-text;format=@tagset_name” if a
// @tagset_name was passed.
//
// The @tagset_name can be used to restrict the transfer of rich text to
// buffers with compatible sets of tags, in order to avoid unknown tags from
// being pasted. It is probably the common case to pass an identifier != nil
// here, since the nil tagset requires the receiving buffer to deal with
// with pasting of arbitrary tags.
func (b textBuffer) RegisterSerializeTagset(tagsetName string) gdk.Atom {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.gchar

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.gchar)(C.CString(tagsetName))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.GdkAtom
	var ret1 gdk.Atom

	cret = C.gtk_text_buffer_register_serialize_tagset(arg0, tagsetName)

	ret1 = gdk.WrapAtom(unsafe.Pointer(cret))

	return ret1
}

// RemoveAllTags removes all tags in the range between @start and @end. Be
// careful with this function; it could remove tags added in code unrelated
// to the code you’re currently writing. That is, using this function is
// probably a bad idea if you have two or more unrelated code sections that
// add tags.
func (b textBuffer) RemoveAllTags(start *TextIter, end *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_remove_all_tags(arg0, start, end)
}

// RemoveSelectionClipboard removes a Clipboard added with
// gtk_text_buffer_add_selection_clipboard().
func (b textBuffer) RemoveSelectionClipboard(clipboard Clipboard) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkClipboard

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkClipboard)(unsafe.Pointer(clipboard.Native()))

	C.gtk_text_buffer_remove_selection_clipboard(arg0, clipboard)
}

// RemoveTag emits the “remove-tag” signal. The default handler for the
// signal removes all occurrences of @tag from the given range. @start and
// @end don’t have to be in order.
func (b textBuffer) RemoveTag(tag TextTag, start *TextIter, end *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextTag
	var arg2 *C.GtkTextIter
	var arg3 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))
	arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_remove_tag(arg0, tag, start, end)
}

// RemoveTagByName calls gtk_text_tag_table_lookup() on the buffer’s tag
// table to get a TextTag, then calls gtk_text_buffer_remove_tag().
func (b textBuffer) RemoveTagByName(name string, start *TextIter, end *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.gchar
	var arg2 *C.GtkTextIter
	var arg3 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_remove_tag_by_name(arg0, name, start, end)
}

// SelectRange: this function moves the “insert” and “selection_bound” marks
// simultaneously. If you move them in two steps with
// gtk_text_buffer_move_mark(), you will temporarily select a region in
// between their old and new locations, which can be pretty inefficient
// since the temporarily-selected region will force stuff to be
// recalculated. This function moves them as a unit, which can be optimized.
func (b textBuffer) SelectRange(ins *TextIter, bound *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(ins.Native()))
	arg2 = (*C.GtkTextIter)(unsafe.Pointer(bound.Native()))

	C.gtk_text_buffer_select_range(arg0, ins, bound)
}

// Serialize: this function serializes the portion of text between @start
// and @end in the rich text format represented by @format.
//
// @formats to be used must be registered using
// gtk_text_buffer_register_serialize_format() or
// gtk_text_buffer_register_serialize_tagset() beforehand.
func (r textBuffer) Serialize(contentBuffer TextBuffer, format gdk.Atom, start *TextIter, end *TextIter) (length uint, guint8s []byte) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextBuffer
	var arg2 C.GdkAtom
	var arg3 *C.GtkTextIter
	var arg4 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(r.Native()))
	arg1 = (*C.GtkTextBuffer)(unsafe.Pointer(contentBuffer.Native()))
	arg2 = (C.GdkAtom)(unsafe.Pointer(format.Native()))
	arg3 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	arg4 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	var cret *C.guint8
	var arg5 *C.gsize
	var ret2 []byte

	cret = C.gtk_text_buffer_serialize(arg0, contentBuffer, format, start, end, &arg5)

	ptr.SetSlice(unsafe.Pointer(&ret2), unsafe.Pointer(cret), int(arg5))
	runtime.SetFinalizer(&ret2, func(v *[]byte) {
		C.free(ptr.Slice(unsafe.Pointer(v)))
	})

	return ret5, ret2
}

// SetModified: used to keep track of whether the buffer has been modified
// since the last time it was saved. Whenever the buffer is saved to disk,
// call gtk_text_buffer_set_modified (@buffer, FALSE). When the buffer is
// modified, it will automatically toggled on the modified bit again. When
// the modified bit flips, the buffer emits the TextBuffer::modified-changed
// signal.
func (b textBuffer) SetModified(setting bool) {
	var arg0 *C.GtkTextBuffer
	var arg1 C.gboolean

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_text_buffer_set_modified(arg0, setting)
}

// SetText deletes current contents of @buffer, and inserts @text instead.
// If @len is -1, @text must be nul-terminated. @text must be valid UTF-8.
func (b textBuffer) SetText(text string, len int) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.gchar
	var arg2 C.gint

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(len)

	C.gtk_text_buffer_set_text(arg0, text, len)
}

// UnregisterDeserializeFormat: this function unregisters a rich text format
// that was previously registered using
// gtk_text_buffer_register_deserialize_format() or
// gtk_text_buffer_register_deserialize_tagset().
func (b textBuffer) UnregisterDeserializeFormat(format gdk.Atom) {
	var arg0 *C.GtkTextBuffer
	var arg1 C.GdkAtom

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (C.GdkAtom)(unsafe.Pointer(format.Native()))

	C.gtk_text_buffer_unregister_deserialize_format(arg0, format)
}

// UnregisterSerializeFormat: this function unregisters a rich text format
// that was previously registered using
// gtk_text_buffer_register_serialize_format() or
// gtk_text_buffer_register_serialize_tagset()
func (b textBuffer) UnregisterSerializeFormat(format gdk.Atom) {
	var arg0 *C.GtkTextBuffer
	var arg1 C.GdkAtom

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (C.GdkAtom)(unsafe.Pointer(format.Native()))

	C.gtk_text_buffer_unregister_serialize_format(arg0, format)
}

type TextBTree struct {
	native C.GtkTextBTree
}

// WrapTextBTree wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTextBTree(ptr unsafe.Pointer) *TextBTree {
	if ptr == nil {
		return nil
	}

	return (*TextBTree)(ptr)
}

func marshalTextBTree(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTextBTree(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TextBTree) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

type TextBufferPrivate struct {
	native C.GtkTextBufferPrivate
}

// WrapTextBufferPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTextBufferPrivate(ptr unsafe.Pointer) *TextBufferPrivate {
	if ptr == nil {
		return nil
	}

	return (*TextBufferPrivate)(ptr)
}

func marshalTextBufferPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTextBufferPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TextBufferPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}
