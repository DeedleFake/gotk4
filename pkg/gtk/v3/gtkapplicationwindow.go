// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/core/box"
	"github.com/diamondburned/gotk4/core/gextras"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk+-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_application_window_get_type()), F: marshalApplicationWindow},
	})
}

// ApplicationWindow is a Window subclass that offers some extra functionality
// for better integration with Application features. Notably, it can handle both
// the application menu as well as the menubar. See
// gtk_application_set_app_menu() and gtk_application_set_menubar().
//
// This class implements the Group and Map interfaces, to let you add
// window-specific actions that will be exported by the associated Application,
// together with its application-wide actions. Window-specific actions are
// prefixed with the “win.” prefix and application-wide actions are prefixed
// with the “app.” prefix. Actions must be addressed with the prefixed name when
// referring to them from a Model.
//
// Note that widgets that are placed inside a ApplicationWindow can also
// activate these actions, if they implement the Actionable interface.
//
// As with Application, the GDK lock will be acquired when processing actions
// arriving from other processes and should therefore be held when activating
// actions locally (if GDK threads are enabled).
//
// The settings Settings:gtk-shell-shows-app-menu and
// Settings:gtk-shell-shows-menubar tell GTK+ whether the desktop environment is
// showing the application menu and menubar models outside the application as
// part of the desktop shell. For instance, on OS X, both menus will be
// displayed remotely; on Windows neither will be. gnome-shell (starting with
// version 3.4) will display the application menu, but not the menubar.
//
// If the desktop environment does not display the menubar, then
// ApplicationWindow will automatically show a MenuBar for it. This behaviour
// can be overridden with the ApplicationWindow:show-menubar property. If the
// desktop environment does not display the application menu, then it will
// automatically be included in the menubar or in the windows client-side
// decorations.
//
// A GtkApplicationWindow with a menubar
//
//    GtkApplication *app = gtk_application_new ("org.gtk.test", 0);
//
//    GtkBuilder *builder = gtk_builder_new_from_string (
//        "<interface>"
//        "  <menu id='menubar'>"
//        "    <submenu label='_Edit'>"
//        "      <item label='_Copy' action='win.copy'/>"
//        "      <item label='_Paste' action='win.paste'/>"
//        "    </submenu>"
//        "  </menu>"
//        "</interface>",
//        -1);
//
//    GMenuModel *menubar = G_MENU_MODEL (gtk_builder_get_object (builder,
//                                                                "menubar"));
//    gtk_application_set_menubar (GTK_APPLICATION (app), menubar);
//    g_object_unref (builder);
//
//    // ...
//
//    GtkWidget *window = gtk_application_window_new (app);
//
//
// Handling fallback yourself
//
// A simple example (https://git.gnome.org/browse/gtk+/tree/examples/sunny.c)
//
// The XML format understood by Builder for Model consists of a toplevel
// `<menu>` element, which contains one or more `<item>` elements. Each `<item>`
// element contains `<attribute>` and `<link>` elements with a mandatory name
// attribute. `<link>` elements have the same content model as `<menu>`. Instead
// of `<link name="submenu>` or `<link name="section">`, you can use `<submenu>`
// or `<section>` elements.
//
// Attribute values can be translated using gettext, like other Builder content.
// `<attribute>` elements can be marked for translation with a
// `translatable="yes"` attribute. It is also possible to specify message
// context and translator comments, using the context and comments attributes.
// To make use of this, the Builder must have been given the gettext domain to
// use.
//
// The following attributes are used when constructing menu items: - "label": a
// user-visible string to display - "action": the prefixed name of the action to
// trigger - "target": the parameter to use when activating the action - "icon"
// and "verb-icon": names of icons that may be displayed - "submenu-action":
// name of an action that may be used to determine if a submenu can be opened -
// "hidden-when": a string used to determine when the item will be hidden.
// Possible values include "action-disabled", "action-missing", "macos-menubar".
//
// The following attributes are used when constructing sections: - "label": a
// user-visible string to use as section heading - "display-hint": a string used
// to determine special formatting for the section. Possible values include
// "horizontal-buttons". - "text-direction": a string used to determine the
// TextDirection to use when "display-hint" is set to "horizontal-buttons".
// Possible values include "rtl", "ltr", and "none".
//
// The following attributes are used when constructing submenus: - "label": a
// user-visible string to display - "icon": icon name to display
type ApplicationWindow interface {
	Window
	gio.ActionGroup

	HelpOverlay() ShortcutsWindow

	ID() uint

	ShowMenubar() bool

	SetHelpOverlayApplicationWindow(helpOverlay ShortcutsWindow)

	SetShowMenubarApplicationWindow(showMenubar bool)
}

// applicationWindow implements the ApplicationWindow class.
type applicationWindow struct {
	Window
}

// WrapApplicationWindow wraps a GObject to the right type. It is
// primarily used internally.
func WrapApplicationWindow(obj *externglib.Object) ApplicationWindow {
	return applicationWindow{
		Window: WrapWindow(obj),
	}
}

func marshalApplicationWindow(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapApplicationWindow(obj), nil
}

func NewApplicationWindow(application Application) ApplicationWindow {
	var _arg1 *C.GtkApplication // out
	var _cret *C.GtkWidget      // in

	_arg1 = (*C.GtkApplication)(unsafe.Pointer(application.Native()))

	_cret = C.gtk_application_window_new(_arg1)

	var _applicationWindow ApplicationWindow // out

	_applicationWindow = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ApplicationWindow)

	return _applicationWindow
}

func (w applicationWindow) HelpOverlay() ShortcutsWindow {
	var _arg0 *C.GtkApplicationWindow // out
	var _cret *C.GtkShortcutsWindow   // in

	_arg0 = (*C.GtkApplicationWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_application_window_get_help_overlay(_arg0)

	var _shortcutsWindow ShortcutsWindow // out

	_shortcutsWindow = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ShortcutsWindow)

	return _shortcutsWindow
}

func (w applicationWindow) ID() uint {
	var _arg0 *C.GtkApplicationWindow // out
	var _cret C.guint                 // in

	_arg0 = (*C.GtkApplicationWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_application_window_get_id(_arg0)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

func (w applicationWindow) ShowMenubar() bool {
	var _arg0 *C.GtkApplicationWindow // out
	var _cret C.gboolean              // in

	_arg0 = (*C.GtkApplicationWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_application_window_get_show_menubar(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w applicationWindow) SetHelpOverlayApplicationWindow(helpOverlay ShortcutsWindow) {
	var _arg0 *C.GtkApplicationWindow // out
	var _arg1 *C.GtkShortcutsWindow   // out

	_arg0 = (*C.GtkApplicationWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkShortcutsWindow)(unsafe.Pointer(helpOverlay.Native()))

	C.gtk_application_window_set_help_overlay(_arg0, _arg1)
}

func (w applicationWindow) SetShowMenubarApplicationWindow(showMenubar bool) {
	var _arg0 *C.GtkApplicationWindow // out
	var _arg1 C.gboolean              // out

	_arg0 = (*C.GtkApplicationWindow)(unsafe.Pointer(w.Native()))
	if showMenubar {
		_arg1 = C.TRUE
	}

	C.gtk_application_window_set_show_menubar(_arg0, _arg1)
}

func (b applicationWindow) AddChild(builder Builder, child gextras.Objector, typ string) {
	WrapBuildable(gextras.InternObject(b)).AddChild(builder, child, typ)
}

func (b applicationWindow) ConstructChild(builder Builder, name string) gextras.Objector {
	return WrapBuildable(gextras.InternObject(b)).ConstructChild(builder, name)
}

func (b applicationWindow) CustomFinished(builder Builder, child gextras.Objector, tagname string, data interface{}) {
	WrapBuildable(gextras.InternObject(b)).CustomFinished(builder, child, tagname, data)
}

func (b applicationWindow) CustomTagEnd(builder Builder, child gextras.Objector, tagname string, data *interface{}) {
	WrapBuildable(gextras.InternObject(b)).CustomTagEnd(builder, child, tagname, data)
}

func (b applicationWindow) CustomTagStart(builder Builder, child gextras.Objector, tagname string) (glib.MarkupParser, interface{}, bool) {
	return WrapBuildable(gextras.InternObject(b)).CustomTagStart(builder, child, tagname)
}

func (b applicationWindow) InternalChild(builder Builder, childname string) gextras.Objector {
	return WrapBuildable(gextras.InternObject(b)).InternalChild(builder, childname)
}

func (b applicationWindow) Name() string {
	return WrapBuildable(gextras.InternObject(b)).Name()
}

func (b applicationWindow) ParserFinished(builder Builder) {
	WrapBuildable(gextras.InternObject(b)).ParserFinished(builder)
}

func (b applicationWindow) SetBuildableProperty(builder Builder, name string, value externglib.Value) {
	WrapBuildable(gextras.InternObject(b)).SetBuildableProperty(builder, name, value)
}

func (b applicationWindow) SetName(name string) {
	WrapBuildable(gextras.InternObject(b)).SetName(name)
}

func (a applicationWindow) ActionAdded(actionName string) {
	gio.WrapActionGroup(gextras.InternObject(a)).ActionAdded(actionName)
}

func (a applicationWindow) ActionEnabledChanged(actionName string, enabled bool) {
	gio.WrapActionGroup(gextras.InternObject(a)).ActionEnabledChanged(actionName, enabled)
}

func (a applicationWindow) ActionRemoved(actionName string) {
	gio.WrapActionGroup(gextras.InternObject(a)).ActionRemoved(actionName)
}

func (a applicationWindow) ActionStateChanged(actionName string, state *glib.Variant) {
	gio.WrapActionGroup(gextras.InternObject(a)).ActionStateChanged(actionName, state)
}

func (a applicationWindow) ActivateAction(actionName string, parameter *glib.Variant) {
	gio.WrapActionGroup(gextras.InternObject(a)).ActivateAction(actionName, parameter)
}

func (a applicationWindow) ChangeActionState(actionName string, value *glib.Variant) {
	gio.WrapActionGroup(gextras.InternObject(a)).ChangeActionState(actionName, value)
}

func (a applicationWindow) ActionEnabled(actionName string) bool {
	return gio.WrapActionGroup(gextras.InternObject(a)).ActionEnabled(actionName)
}

func (a applicationWindow) ActionParameterType(actionName string) *glib.VariantType {
	return gio.WrapActionGroup(gextras.InternObject(a)).ActionParameterType(actionName)
}

func (a applicationWindow) ActionState(actionName string) *glib.Variant {
	return gio.WrapActionGroup(gextras.InternObject(a)).ActionState(actionName)
}

func (a applicationWindow) ActionStateHint(actionName string) *glib.Variant {
	return gio.WrapActionGroup(gextras.InternObject(a)).ActionStateHint(actionName)
}

func (a applicationWindow) ActionStateType(actionName string) *glib.VariantType {
	return gio.WrapActionGroup(gextras.InternObject(a)).ActionStateType(actionName)
}

func (a applicationWindow) HasAction(actionName string) bool {
	return gio.WrapActionGroup(gextras.InternObject(a)).HasAction(actionName)
}

func (a applicationWindow) ListActions() []string {
	return gio.WrapActionGroup(gextras.InternObject(a)).ListActions()
}

func (a applicationWindow) QueryAction(actionName string) (enabled bool, parameterType *glib.VariantType, stateType *glib.VariantType, stateHint *glib.Variant, state *glib.Variant, ok bool) {
	return gio.WrapActionGroup(gextras.InternObject(a)).QueryAction(actionName)
}
