// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk+-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_window_position_get_type()), F: marshalWindowPosition},
		{T: externglib.Type(C.gtk_window_type_get_type()), F: marshalWindowType},
		{T: externglib.Type(C.gtk_window_get_type()), F: marshalWindower},
	})
}

// WindowPosition: window placement can be influenced using this enumeration.
// Note that using K_WIN_POS_CENTER_ALWAYS is almost always a bad idea. It won’t
// necessarily work well with all window managers or on all windowing systems.
type WindowPosition int

const (
	// None: no influence is made on placement.
	WindowPositionNone WindowPosition = iota
	// Center windows should be placed in the center of the screen.
	WindowPositionCenter
	// Mouse windows should be placed at the current mouse position.
	WindowPositionMouse
	// CenterAlways: keep window centered as it changes size, etc.
	WindowPositionCenterAlways
	// CenterOnParent: center the window on its transient parent (see
	// gtk_window_set_transient_for()).
	WindowPositionCenterOnParent
)

func marshalWindowPosition(p uintptr) (interface{}, error) {
	return WindowPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// WindowType can be one of these types. Most things you’d consider a “window”
// should have type K_WINDOW_TOPLEVEL; windows with this type are managed by the
// window manager and have a frame by default (call gtk_window_set_decorated()
// to toggle the frame). Windows with type K_WINDOW_POPUP are ignored by the
// window manager; window manager keybindings won’t work on them, the window
// manager won’t decorate the window with a frame, many GTK+ features that rely
// on the window manager will not work (e.g. resize grips and
// maximization/minimization). K_WINDOW_POPUP is used to implement widgets such
// as Menu or tooltips that you normally don’t think of as windows per se.
// Nearly all windows should be K_WINDOW_TOPLEVEL. In particular, do not use
// K_WINDOW_POPUP just to turn off the window borders; use
// gtk_window_set_decorated() for that.
type WindowType int

const (
	// Toplevel: regular window, such as a dialog.
	WindowTypeToplevel WindowType = iota
	// Popup: special window such as a tooltip.
	WindowTypePopup
)

func marshalWindowType(p uintptr) (interface{}, error) {
	return WindowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// WindowOverrider contains methods that are overridable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type WindowOverrider interface {
	ActivateDefault()
	ActivateFocus()
	EnableDebugging(toggle bool) bool
	KeysChanged()
	// SetFocus: if @focus is not the current focus widget, and is focusable,
	// sets it as the focus widget for the window. If @focus is nil, unsets the
	// focus widget for this window. To set the focus to a particular widget in
	// the toplevel, it is usually more convenient to use
	// gtk_widget_grab_focus() instead of this function.
	SetFocus(focus Widgeter)
}

// Windower describes Window's methods.
type Windower interface {
	// ActivateDefault activates the default widget for the window, unless the
	// current focused widget has been configured to receive the default action
	// (see gtk_widget_set_receives_default()), in which case the focused widget
	// is activated.
	ActivateDefault() bool
	// ActivateFocus activates the current focused widget within the window.
	ActivateFocus() bool
	// ActivateKey activates mnemonics and accelerators for this Window.
	ActivateKey(event *gdk.EventKey) bool
	// AddAccelGroup: associate @accel_group with @window, such that calling
	// gtk_accel_groups_activate() on @window will activate accelerators in
	// @accel_group.
	AddAccelGroup(accelGroup AccelGrouper)
	// AddMnemonic adds a mnemonic to this window.
	AddMnemonic(keyval uint, target Widgeter)
	// BeginMoveDrag starts moving a window.
	BeginMoveDrag(button int, rootX int, rootY int, timestamp uint32)
	// BeginResizeDrag starts resizing a window.
	BeginResizeDrag(edge gdk.WindowEdge, button int, rootX int, rootY int, timestamp uint32)
	// Close requests that the window is closed, similar to what happens when a
	// window manager close button is clicked.
	Close()
	// Deiconify asks to deiconify (i.e.
	Deiconify()
	// Fullscreen asks to place @window in the fullscreen state.
	Fullscreen()
	// FullscreenOnMonitor asks to place @window in the fullscreen state.
	FullscreenOnMonitor(screen gdk.Screener, monitor int)
	// AcceptFocus gets the value set by gtk_window_set_accept_focus().
	AcceptFocus() bool
	// Application gets the Application associated with the window (if any).
	Application() *Application
	// AttachedTo fetches the attach widget for this window.
	AttachedTo() *Widget
	// Decorated returns whether the window has been set to have decorations
	// such as a title bar via gtk_window_set_decorated().
	Decorated() bool
	// DefaultSize gets the default size of the window.
	DefaultSize() (width int, height int)
	// DefaultWidget returns the default widget for @window.
	DefaultWidget() *Widget
	// Deletable returns whether the window has been set to have a close button
	// via gtk_window_set_deletable().
	Deletable() bool
	// DestroyWithParent returns whether the window will be destroyed with its
	// transient parent.
	DestroyWithParent() bool
	// Focus retrieves the current focused widget within the window.
	Focus() *Widget
	// FocusOnMap gets the value set by gtk_window_set_focus_on_map().
	FocusOnMap() bool
	// FocusVisible gets the value of the Window:focus-visible property.
	FocusVisible() bool
	// Gravity gets the value set by gtk_window_set_gravity().
	Gravity() gdk.Gravity
	// Group returns the group for @window or the default group, if @window is
	// nil or if @window does not have an explicit window group.
	Group() *WindowGroup
	// HasResizeGrip determines whether the window may have a resize grip.
	HasResizeGrip() bool
	// HideTitlebarWhenMaximized returns whether the window has requested to
	// have its titlebar hidden when maximized.
	HideTitlebarWhenMaximized() bool
	// Icon gets the value set by gtk_window_set_icon() (or if you've called
	// gtk_window_set_icon_list(), gets the first icon in the icon list).
	Icon() *gdkpixbuf.Pixbuf
	// IconName returns the name of the themed icon for the window, see
	// gtk_window_set_icon_name().
	IconName() string
	// MnemonicModifier returns the mnemonic modifier for this window.
	MnemonicModifier() gdk.ModifierType
	// MnemonicsVisible gets the value of the Window:mnemonics-visible property.
	MnemonicsVisible() bool
	// Modal returns whether the window is modal.
	Modal() bool
	// Opacity fetches the requested opacity for this window.
	Opacity() float64
	// Position: this function returns the position you need to pass to
	// gtk_window_move() to keep @window in its current position.
	Position() (rootX int, rootY int)
	// Resizable gets the value set by gtk_window_set_resizable().
	Resizable() bool
	// ResizeGripArea: if a window has a resize grip, this will retrieve the
	// grip position, width and height into the specified Rectangle.
	ResizeGripArea() (gdk.Rectangle, bool)
	// Role returns the role of the window.
	Role() string
	// Screen returns the Screen associated with @window.
	Screen() *gdk.Screen
	// Size obtains the current size of @window.
	Size() (width int, height int)
	// SkipPagerHint gets the value set by gtk_window_set_skip_pager_hint().
	SkipPagerHint() bool
	// SkipTaskbarHint gets the value set by gtk_window_set_skip_taskbar_hint()
	SkipTaskbarHint() bool
	// Title retrieves the title of the window.
	Title() string
	// Titlebar returns the custom titlebar that has been set with
	// gtk_window_set_titlebar().
	Titlebar() *Widget
	// TransientFor fetches the transient parent for this window.
	TransientFor() *Window
	// TypeHint gets the type hint for this window.
	TypeHint() gdk.WindowTypeHint
	// UrgencyHint gets the value set by gtk_window_set_urgency_hint()
	UrgencyHint() bool
	// WindowType gets the type of the window.
	WindowType() WindowType
	// HasGroup returns whether @window has an explicit window group.
	HasGroup() bool
	// HasToplevelFocus returns whether the input focus is within this
	// GtkWindow.
	HasToplevelFocus() bool
	// Iconify asks to iconify (i.e.
	Iconify()
	// IsActive returns whether the window is part of the current active
	// toplevel.
	IsActive() bool
	// IsMaximized retrieves the current maximized state of @window.
	IsMaximized() bool
	// Maximize asks to maximize @window, so that it becomes full-screen.
	Maximize()
	// MnemonicActivate activates the targets associated with the mnemonic.
	MnemonicActivate(keyval uint, modifier gdk.ModifierType) bool
	// Move asks the [window manager][gtk-X11-arch] to move @window to the given
	// position.
	Move(x int, y int)
	// ParseGeometry parses a standard X Window System geometry string - see the
	// manual page for X (type “man X”) for details on this.
	ParseGeometry(geometry string) bool
	// Present presents a window to the user.
	Present()
	// PresentWithTime presents a window to the user.
	PresentWithTime(timestamp uint32)
	// PropagateKeyEvent: propagate a key press or release event to the focus
	// widget and up the focus container chain until a widget handles @event.
	PropagateKeyEvent(event *gdk.EventKey) bool
	// RemoveAccelGroup reverses the effects of gtk_window_add_accel_group().
	RemoveAccelGroup(accelGroup AccelGrouper)
	// RemoveMnemonic removes a mnemonic from this window.
	RemoveMnemonic(keyval uint, target Widgeter)
	// ReshowWithInitialSize hides @window, then reshows it, resetting the
	// default size and position of the window.
	ReshowWithInitialSize()
	// Resize resizes the window as if the user had done so, obeying geometry
	// constraints.
	Resize(width int, height int)
	// ResizeGripIsVisible determines whether a resize grip is visible for the
	// specified window.
	ResizeGripIsVisible() bool
	// ResizeToGeometry: like gtk_window_resize(), but @width and @height are
	// interpreted in terms of the base size and increment set with
	// gtk_window_set_geometry_hints.
	ResizeToGeometry(width int, height int)
	// SetAcceptFocus windows may set a hint asking the desktop environment not
	// to receive the input focus.
	SetAcceptFocus(setting bool)
	// SetApplication sets or unsets the Application associated with the window.
	SetApplication(application Applicationer)
	// SetAttachedTo marks @window as attached to @attach_widget.
	SetAttachedTo(attachWidget Widgeter)
	// SetDecorated: by default, windows are decorated with a title bar, resize
	// controls, etc.
	SetDecorated(setting bool)
	// SetDefault: default widget is the widget that’s activated when the user
	// presses Enter in a dialog (for example).
	SetDefault(defaultWidget Widgeter)
	// SetDefaultGeometry: like gtk_window_set_default_size(), but @width and
	// @height are interpreted in terms of the base size and increment set with
	// gtk_window_set_geometry_hints.
	SetDefaultGeometry(width int, height int)
	// SetDefaultSize sets the default size of a window.
	SetDefaultSize(width int, height int)
	// SetDeletable: by default, windows have a close button in the window
	// frame.
	SetDeletable(setting bool)
	// SetDestroyWithParent: if @setting is true, then destroying the transient
	// parent of @window will also destroy @window itself.
	SetDestroyWithParent(setting bool)
	// SetFocus: if @focus is not the current focus widget, and is focusable,
	// sets it as the focus widget for the window.
	SetFocus(focus Widgeter)
	// SetFocusOnMap windows may set a hint asking the desktop environment not
	// to receive the input focus when the window is mapped.
	SetFocusOnMap(setting bool)
	// SetFocusVisible sets the Window:focus-visible property.
	SetFocusVisible(setting bool)
	// SetGeometryHints: this function sets up hints about how a window can be
	// resized by the user.
	SetGeometryHints(geometryWidget Widgeter, geometry *gdk.Geometry, geomMask gdk.WindowHints)
	// SetGravity: window gravity defines the meaning of coordinates passed to
	// gtk_window_move().
	SetGravity(gravity gdk.Gravity)
	// SetHasResizeGrip sets whether @window has a corner resize grip.
	SetHasResizeGrip(value bool)
	// SetHasUserRefCount tells GTK+ whether to drop its extra reference to the
	// window when gtk_widget_destroy() is called.
	SetHasUserRefCount(setting bool)
	// SetHideTitlebarWhenMaximized: if @setting is true, then @window will
	// request that it’s titlebar should be hidden when maximized.
	SetHideTitlebarWhenMaximized(setting bool)
	// SetIcon sets up the icon representing a Window.
	SetIcon(icon gdkpixbuf.Pixbufer)
	// SetIconFromFile sets the icon for @window.
	SetIconFromFile(filename string) error
	// SetIconName sets the icon for the window from a named themed icon.
	SetIconName(name string)
	// SetKeepAbove asks to keep @window above, so that it stays on top.
	SetKeepAbove(setting bool)
	// SetKeepBelow asks to keep @window below, so that it stays in bottom.
	SetKeepBelow(setting bool)
	// SetMnemonicModifier sets the mnemonic modifier for this window.
	SetMnemonicModifier(modifier gdk.ModifierType)
	// SetMnemonicsVisible sets the Window:mnemonics-visible property.
	SetMnemonicsVisible(setting bool)
	// SetModal sets a window modal or non-modal.
	SetModal(modal bool)
	// SetOpacity: request the windowing system to make @window partially
	// transparent, with opacity 0 being fully transparent and 1 fully opaque.
	SetOpacity(opacity float64)
	// SetPosition sets a position constraint for this window.
	SetPosition(position WindowPosition)
	// SetResizable sets whether the user can resize a window.
	SetResizable(resizable bool)
	// SetRole: this function is only useful on X11, not with other GTK+
	// targets.
	SetRole(role string)
	// SetScreen sets the Screen where the @window is displayed; if the window
	// is already mapped, it will be unmapped, and then remapped on the new
	// screen.
	SetScreen(screen gdk.Screener)
	// SetSkipPagerHint windows may set a hint asking the desktop environment
	// not to display the window in the pager.
	SetSkipPagerHint(setting bool)
	// SetSkipTaskbarHint windows may set a hint asking the desktop environment
	// not to display the window in the task bar.
	SetSkipTaskbarHint(setting bool)
	// SetStartupID: startup notification identifiers are used by desktop
	// environment to track application startup, to provide user feedback and
	// other features.
	SetStartupID(startupId string)
	// SetTitle sets the title of the Window.
	SetTitle(title string)
	// SetTitlebar sets a custom titlebar for @window.
	SetTitlebar(titlebar Widgeter)
	// SetTransientFor: dialog windows should be set transient for the main
	// application window they were spawned from.
	SetTransientFor(parent Windower)
	// SetTypeHint: by setting the type hint for the window, you allow the
	// window manager to decorate and handle the window in a way which is
	// suitable to the function of the window in your application.
	SetTypeHint(hint gdk.WindowTypeHint)
	// SetUrgencyHint windows may set a hint asking the desktop environment to
	// draw the users attention to the window.
	SetUrgencyHint(setting bool)
	// SetWmclass: don’t use this function.
	SetWmclass(wmclassName string, wmclassClass string)
	// Stick asks to stick @window, which means that it will appear on all user
	// desktops.
	Stick()
	// Unfullscreen asks to toggle off the fullscreen state for @window.
	Unfullscreen()
	// Unmaximize asks to unmaximize @window.
	Unmaximize()
	// Unstick asks to unstick @window, which means that it will appear on only
	// one of the user’s desktops.
	Unstick()
}

// Window is a toplevel window which can contain other widgets. Windows normally
// have decorations that are under the control of the windowing system and allow
// the user to manipulate the window (resize it, move it, close it,...).
//
//
// GtkWindow as GtkBuildable
//
// The GtkWindow implementation of the Buildable interface supports a custom
// <accel-groups> element, which supports any number of <group> elements
// representing the AccelGroup objects you want to add to your window
// (synonymous with gtk_window_add_accel_group().
//
// It also supports the <initial-focus> element, whose name property names the
// widget to receive the focus when the window is mapped.
//
// An example of a UI definition fragment with accel groups:
//
//    <object class="GtkWindow">
//      <accel-groups>
//        <group name="accelgroup1"/>
//      </accel-groups>
//      <initial-focus name="thunderclap"/>
//    </object>
//
//    ...
//
//    <object class="GtkAccelGroup" id="accelgroup1"/>
//
// The GtkWindow implementation of the Buildable interface supports setting a
// child as the titlebar by specifying “titlebar” as the “type” attribute of a
// <child> element.
//
// CSS nodes
//
//    window.background
//    ├── decoration
//    ├── <titlebar child>.titlebar [.default-decoration]
//    ╰── <child>
//
// GtkWindow has a main CSS node with name window and style class .background,
// and a subnode with name decoration.
//
// Style classes that are typically used with the main CSS node are .csd (when
// client-side decorations are in use), .solid-csd (for client-side decorations
// without invisible borders), .ssd (used by mutter when rendering server-side
// decorations). GtkWindow also represents window states with the following
// style classes on the main node: .tiled, .maximized, .fullscreen. Specialized
// types of window often add their own discriminating style classes, such as
// .popup or .tooltip.
//
// GtkWindow adds the .titlebar and .default-decoration style classes to the
// widget that is added as a titlebar child.
type Window struct {
	Bin
}

var (
	_ Windower        = (*Window)(nil)
	_ gextras.Nativer = (*Window)(nil)
)

func wrapWindow(obj *externglib.Object) Windower {
	return &Window{
		Bin: Bin{
			Container: Container{
				Widget: Widget{
					InitiallyUnowned: externglib.InitiallyUnowned{
						Object: obj,
					},
					ImplementorIface: atk.ImplementorIface{
						Object: obj,
					},
					Buildable: Buildable{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalWindower(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWindow(obj), nil
}

// NewWindow creates a new Window, which is a toplevel window that can contain
// other widgets. Nearly always, the type of the window should be
// K_WINDOW_TOPLEVEL. If you’re implementing something like a popup menu from
// scratch (which is a bad idea, just use Menu), you might use K_WINDOW_POPUP.
// K_WINDOW_POPUP is not for dialogs, though in some other toolkits dialogs are
// called “popups”. In GTK+, K_WINDOW_POPUP means a pop-up menu or pop-up
// tooltip. On X11, popup windows are not controlled by the [window
// manager][gtk-X11-arch].
//
// If you simply want an undecorated window (no window borders), use
// gtk_window_set_decorated(), don’t use K_WINDOW_POPUP.
//
// All top-level windows created by gtk_window_new() are stored in an internal
// top-level window list. This list can be obtained from
// gtk_window_list_toplevels(). Due to Gtk+ keeping a reference to the window
// internally, gtk_window_new() does not return a reference to the caller.
//
// To delete a Window, call gtk_widget_destroy().
func NewWindow(typ WindowType) *Window {
	var _arg1 C.GtkWindowType // out
	var _cret *C.GtkWidget    // in

	_arg1 = C.GtkWindowType(typ)

	_cret = C.gtk_window_new(_arg1)

	var _window *Window // out

	_window = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*Window)

	return _window
}

// ActivateDefault activates the default widget for the window, unless the
// current focused widget has been configured to receive the default action (see
// gtk_widget_set_receives_default()), in which case the focused widget is
// activated.
func (window *Window) ActivateDefault() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_activate_default(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ActivateFocus activates the current focused widget within the window.
func (window *Window) ActivateFocus() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_activate_focus(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ActivateKey activates mnemonics and accelerators for this Window. This is
// normally called by the default ::key_press_event handler for toplevel
// windows, however in some cases it may be useful to call this directly when
// overriding the standard key handling for a toplevel window.
func (window *Window) ActivateKey(event *gdk.EventKey) bool {
	var _arg0 *C.GtkWindow   // out
	var _arg1 *C.GdkEventKey // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = (*C.GdkEventKey)(unsafe.Pointer(event))

	_cret = C.gtk_window_activate_key(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AddAccelGroup: associate @accel_group with @window, such that calling
// gtk_accel_groups_activate() on @window will activate accelerators in
// @accel_group.
func (window *Window) AddAccelGroup(accelGroup AccelGrouper) {
	var _arg0 *C.GtkWindow     // out
	var _arg1 *C.GtkAccelGroup // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = (*C.GtkAccelGroup)(unsafe.Pointer((accelGroup).(gextras.Nativer).Native()))

	C.gtk_window_add_accel_group(_arg0, _arg1)
}

// AddMnemonic adds a mnemonic to this window.
func (window *Window) AddMnemonic(keyval uint, target Widgeter) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.guint      // out
	var _arg2 *C.GtkWidget // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = C.guint(keyval)
	_arg2 = (*C.GtkWidget)(unsafe.Pointer((target).(gextras.Nativer).Native()))

	C.gtk_window_add_mnemonic(_arg0, _arg1, _arg2)
}

// BeginMoveDrag starts moving a window. This function is used if an application
// has window movement grips. When GDK can support it, the window movement will
// be done using the standard mechanism for the [window manager][gtk-X11-arch]
// or windowing system. Otherwise, GDK will try to emulate window movement,
// potentially not all that well, depending on the windowing system.
func (window *Window) BeginMoveDrag(button int, rootX int, rootY int, timestamp uint32) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // out
	var _arg3 C.gint       // out
	var _arg4 C.guint32    // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = C.gint(button)
	_arg2 = C.gint(rootX)
	_arg3 = C.gint(rootY)
	_arg4 = C.guint32(timestamp)

	C.gtk_window_begin_move_drag(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// BeginResizeDrag starts resizing a window. This function is used if an
// application has window resizing controls. When GDK can support it, the resize
// will be done using the standard mechanism for the [window
// manager][gtk-X11-arch] or windowing system. Otherwise, GDK will try to
// emulate window resizing, potentially not all that well, depending on the
// windowing system.
func (window *Window) BeginResizeDrag(edge gdk.WindowEdge, button int, rootX int, rootY int, timestamp uint32) {
	var _arg0 *C.GtkWindow    // out
	var _arg1 C.GdkWindowEdge // out
	var _arg2 C.gint          // out
	var _arg3 C.gint          // out
	var _arg4 C.gint          // out
	var _arg5 C.guint32       // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = C.GdkWindowEdge(edge)
	_arg2 = C.gint(button)
	_arg3 = C.gint(rootX)
	_arg4 = C.gint(rootY)
	_arg5 = C.guint32(timestamp)

	C.gtk_window_begin_resize_drag(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}

// Close requests that the window is closed, similar to what happens when a
// window manager close button is clicked.
//
// This function can be used with close buttons in custom titlebars.
func (window *Window) Close() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_window_close(_arg0)
}

// Deiconify asks to deiconify (i.e. unminimize) the specified @window. Note
// that you shouldn’t assume the window is definitely deiconified afterward,
// because other entities (e.g. the user or [window manager][gtk-X11-arch]))
// could iconify it again before your code which assumes deiconification gets to
// run.
//
// You can track iconification via the “window-state-event” signal on Widget.
func (window *Window) Deiconify() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_window_deiconify(_arg0)
}

// Fullscreen asks to place @window in the fullscreen state. Note that you
// shouldn’t assume the window is definitely full screen afterward, because
// other entities (e.g. the user or [window manager][gtk-X11-arch]) could
// unfullscreen it again, and not all window managers honor requests to
// fullscreen windows. But normally the window will end up fullscreen. Just
// don’t write code that crashes if not.
//
// You can track the fullscreen state via the “window-state-event” signal on
// Widget.
func (window *Window) Fullscreen() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_window_fullscreen(_arg0)
}

// FullscreenOnMonitor asks to place @window in the fullscreen state. Note that
// you shouldn't assume the window is definitely full screen afterward.
//
// You can track the fullscreen state via the "window-state-event" signal on
// Widget.
func (window *Window) FullscreenOnMonitor(screen gdk.Screener, monitor int) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GdkScreen // out
	var _arg2 C.gint       // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = (*C.GdkScreen)(unsafe.Pointer((screen).(gextras.Nativer).Native()))
	_arg2 = C.gint(monitor)

	C.gtk_window_fullscreen_on_monitor(_arg0, _arg1, _arg2)
}

// AcceptFocus gets the value set by gtk_window_set_accept_focus().
func (window *Window) AcceptFocus() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_accept_focus(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Application gets the Application associated with the window (if any).
func (window *Window) Application() *Application {
	var _arg0 *C.GtkWindow      // out
	var _cret *C.GtkApplication // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_application(_arg0)

	var _application *Application // out

	_application = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*Application)

	return _application
}

// AttachedTo fetches the attach widget for this window. See
// gtk_window_set_attached_to().
func (window *Window) AttachedTo() *Widget {
	var _arg0 *C.GtkWindow // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_attached_to(_arg0)

	var _widget *Widget // out

	_widget = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*Widget)

	return _widget
}

// Decorated returns whether the window has been set to have decorations such as
// a title bar via gtk_window_set_decorated().
func (window *Window) Decorated() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_decorated(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DefaultSize gets the default size of the window. A value of -1 for the width
// or height indicates that a default size has not been explicitly set for that
// dimension, so the “natural” size of the window will be used.
func (window *Window) DefaultSize() (width int, height int) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gint       // in
	var _arg2 C.gint       // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_window_get_default_size(_arg0, &_arg1, &_arg2)

	var _width int  // out
	var _height int // out

	_width = int(_arg1)
	_height = int(_arg2)

	return _width, _height
}

// DefaultWidget returns the default widget for @window. See
// gtk_window_set_default() for more details.
func (window *Window) DefaultWidget() *Widget {
	var _arg0 *C.GtkWindow // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_default_widget(_arg0)

	var _widget *Widget // out

	_widget = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*Widget)

	return _widget
}

// Deletable returns whether the window has been set to have a close button via
// gtk_window_set_deletable().
func (window *Window) Deletable() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_deletable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DestroyWithParent returns whether the window will be destroyed with its
// transient parent. See gtk_window_set_destroy_with_parent ().
func (window *Window) DestroyWithParent() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_destroy_with_parent(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Focus retrieves the current focused widget within the window. Note that this
// is the widget that would have the focus if the toplevel window focused; if
// the toplevel window is not focused then `gtk_widget_has_focus (widget)` will
// not be true for the widget.
func (window *Window) Focus() *Widget {
	var _arg0 *C.GtkWindow // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_focus(_arg0)

	var _widget *Widget // out

	_widget = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*Widget)

	return _widget
}

// FocusOnMap gets the value set by gtk_window_set_focus_on_map().
func (window *Window) FocusOnMap() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_focus_on_map(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FocusVisible gets the value of the Window:focus-visible property.
func (window *Window) FocusVisible() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_focus_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Gravity gets the value set by gtk_window_set_gravity().
func (window *Window) Gravity() gdk.Gravity {
	var _arg0 *C.GtkWindow // out
	var _cret C.GdkGravity // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_gravity(_arg0)

	var _gravity gdk.Gravity // out

	_gravity = gdk.Gravity(_cret)

	return _gravity
}

// Group returns the group for @window or the default group, if @window is nil
// or if @window does not have an explicit window group.
func (window *Window) Group() *WindowGroup {
	var _arg0 *C.GtkWindow      // out
	var _cret *C.GtkWindowGroup // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_group(_arg0)

	var _windowGroup *WindowGroup // out

	_windowGroup = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*WindowGroup)

	return _windowGroup
}

// HasResizeGrip determines whether the window may have a resize grip.
//
// Deprecated: Resize grips have been removed.
func (window *Window) HasResizeGrip() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_has_resize_grip(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HideTitlebarWhenMaximized returns whether the window has requested to have
// its titlebar hidden when maximized. See
// gtk_window_set_hide_titlebar_when_maximized ().
func (window *Window) HideTitlebarWhenMaximized() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_hide_titlebar_when_maximized(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Icon gets the value set by gtk_window_set_icon() (or if you've called
// gtk_window_set_icon_list(), gets the first icon in the icon list).
func (window *Window) Icon() *gdkpixbuf.Pixbuf {
	var _arg0 *C.GtkWindow // out
	var _cret *C.GdkPixbuf // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_icon(_arg0)

	var _pixbuf *gdkpixbuf.Pixbuf // out

	_pixbuf = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*gdkpixbuf.Pixbuf)

	return _pixbuf
}

// IconName returns the name of the themed icon for the window, see
// gtk_window_set_icon_name().
func (window *Window) IconName() string {
	var _arg0 *C.GtkWindow // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_icon_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// MnemonicModifier returns the mnemonic modifier for this window. See
// gtk_window_set_mnemonic_modifier().
func (window *Window) MnemonicModifier() gdk.ModifierType {
	var _arg0 *C.GtkWindow      // out
	var _cret C.GdkModifierType // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_mnemonic_modifier(_arg0)

	var _modifierType gdk.ModifierType // out

	_modifierType = gdk.ModifierType(_cret)

	return _modifierType
}

// MnemonicsVisible gets the value of the Window:mnemonics-visible property.
func (window *Window) MnemonicsVisible() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_mnemonics_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Modal returns whether the window is modal. See gtk_window_set_modal().
func (window *Window) Modal() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_modal(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Opacity fetches the requested opacity for this window. See
// gtk_window_set_opacity().
//
// Deprecated: Use gtk_widget_get_opacity instead.
func (window *Window) Opacity() float64 {
	var _arg0 *C.GtkWindow // out
	var _cret C.gdouble    // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_opacity(_arg0)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Position: this function returns the position you need to pass to
// gtk_window_move() to keep @window in its current position. This means that
// the meaning of the returned value varies with window gravity. See
// gtk_window_move() for more details.
//
// The reliability of this function depends on the windowing system currently in
// use. Some windowing systems, such as Wayland, do not support a global
// coordinate system, and thus the position of the window will always be (0, 0).
// Others, like X11, do not have a reliable way to obtain the geometry of the
// decorations of a window if they are provided by the window manager.
// Additionally, on X11, window manager have been known to mismanage window
// gravity, which result in windows moving even if you use the coordinates of
// the current position as returned by this function.
//
// If you haven’t changed the window gravity, its gravity will be
// K_GRAVITY_NORTH_WEST. This means that gtk_window_get_position() gets the
// position of the top-left corner of the window manager frame for the window.
// gtk_window_move() sets the position of this same top-left corner.
//
// If a window has gravity K_GRAVITY_STATIC the window manager frame is not
// relevant, and thus gtk_window_get_position() will always produce accurate
// results. However you can’t use static gravity to do things like place a
// window in a corner of the screen, because static gravity ignores the window
// manager decorations.
//
// Ideally, this function should return appropriate values if the window has
// client side decorations, assuming that the windowing system supports global
// coordinates.
//
// In practice, saving the window position should not be left to applications,
// as they lack enough knowledge of the windowing system and the window manager
// state to effectively do so. The appropriate way to implement saving the
// window position is to use a platform-specific protocol, wherever that is
// available.
func (window *Window) Position() (rootX int, rootY int) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gint       // in
	var _arg2 C.gint       // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_window_get_position(_arg0, &_arg1, &_arg2)

	var _rootX int // out
	var _rootY int // out

	_rootX = int(_arg1)
	_rootY = int(_arg2)

	return _rootX, _rootY
}

// Resizable gets the value set by gtk_window_set_resizable().
func (window *Window) Resizable() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_resizable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ResizeGripArea: if a window has a resize grip, this will retrieve the grip
// position, width and height into the specified Rectangle.
//
// Deprecated: Resize grips have been removed.
func (window *Window) ResizeGripArea() (gdk.Rectangle, bool) {
	var _arg0 *C.GtkWindow // out
	var _rect gdk.Rectangle
	var _cret C.gboolean // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_resize_grip_area(_arg0, (*C.GdkRectangle)(unsafe.Pointer(&_rect)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _rect, _ok
}

// Role returns the role of the window. See gtk_window_set_role() for further
// explanation.
func (window *Window) Role() string {
	var _arg0 *C.GtkWindow // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_role(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Screen returns the Screen associated with @window.
func (window *Window) Screen() *gdk.Screen {
	var _arg0 *C.GtkWindow // out
	var _cret *C.GdkScreen // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_screen(_arg0)

	var _screen *gdk.Screen // out

	_screen = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*gdk.Screen)

	return _screen
}

// Size obtains the current size of @window.
//
// If @window is not visible on screen, this function return the size GTK+ will
// suggest to the [window manager][gtk-X11-arch] for the initial window size
// (but this is not reliably the same as the size the window manager will
// actually select). See: gtk_window_set_default_size().
//
// Depending on the windowing system and the window manager constraints, the
// size returned by this function may not match the size set using
// gtk_window_resize(); additionally, since gtk_window_resize() may be
// implemented as an asynchronous operation, GTK+ cannot guarantee in any way
// that this code:
//
//    static void
//    on_size_allocate (GtkWidget *widget, GtkAllocation *allocation)
//    {
//      int new_width, new_height;
//
//      gtk_window_get_size (GTK_WINDOW (widget), &new_width, &new_height);
//
//      ...
//    }
//
// Note that, if you connect to the Widget::size-allocate signal, you should not
// use the dimensions of the Allocation passed to the signal handler, as the
// allocation may contain client side decorations added by GTK+, depending on
// the windowing system in use.
//
// If you are getting a window size in order to position the window on the
// screen, you should, instead, simply set the window’s semantic type with
// gtk_window_set_type_hint(), which allows the window manager to e.g. center
// dialogs. Also, if you set the transient parent of dialogs with
// gtk_window_set_transient_for() window managers will often center the dialog
// over its parent window. It's much preferred to let the window manager handle
// these cases rather than doing it yourself, because all apps will behave
// consistently and according to user or system preferences, if the window
// manager handles it. Also, the window manager can take into account the size
// of the window decorations and border that it may add, and of which GTK+ has
// no knowledge. Additionally, positioning windows in global screen coordinates
// may not be allowed by the windowing system. For more information, see:
// gtk_window_set_position().
func (window *Window) Size() (width int, height int) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gint       // in
	var _arg2 C.gint       // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_window_get_size(_arg0, &_arg1, &_arg2)

	var _width int  // out
	var _height int // out

	_width = int(_arg1)
	_height = int(_arg2)

	return _width, _height
}

// SkipPagerHint gets the value set by gtk_window_set_skip_pager_hint().
func (window *Window) SkipPagerHint() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_skip_pager_hint(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SkipTaskbarHint gets the value set by gtk_window_set_skip_taskbar_hint()
func (window *Window) SkipTaskbarHint() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_skip_taskbar_hint(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Title retrieves the title of the window. See gtk_window_set_title().
func (window *Window) Title() string {
	var _arg0 *C.GtkWindow // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_title(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Titlebar returns the custom titlebar that has been set with
// gtk_window_set_titlebar().
func (window *Window) Titlebar() *Widget {
	var _arg0 *C.GtkWindow // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_titlebar(_arg0)

	var _widget *Widget // out

	_widget = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*Widget)

	return _widget
}

// TransientFor fetches the transient parent for this window. See
// gtk_window_set_transient_for().
func (window *Window) TransientFor() *Window {
	var _arg0 *C.GtkWindow // out
	var _cret *C.GtkWindow // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_transient_for(_arg0)

	var _ret *Window // out

	_ret = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*Window)

	return _ret
}

// TypeHint gets the type hint for this window. See gtk_window_set_type_hint().
func (window *Window) TypeHint() gdk.WindowTypeHint {
	var _arg0 *C.GtkWindow        // out
	var _cret C.GdkWindowTypeHint // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_type_hint(_arg0)

	var _windowTypeHint gdk.WindowTypeHint // out

	_windowTypeHint = gdk.WindowTypeHint(_cret)

	return _windowTypeHint
}

// UrgencyHint gets the value set by gtk_window_set_urgency_hint()
func (window *Window) UrgencyHint() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_urgency_hint(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// WindowType gets the type of the window. See WindowType.
func (window *Window) WindowType() WindowType {
	var _arg0 *C.GtkWindow    // out
	var _cret C.GtkWindowType // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_window_type(_arg0)

	var _windowType WindowType // out

	_windowType = WindowType(_cret)

	return _windowType
}

// HasGroup returns whether @window has an explicit window group.
func (window *Window) HasGroup() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_has_group(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasToplevelFocus returns whether the input focus is within this GtkWindow.
// For real toplevel windows, this is identical to gtk_window_is_active(), but
// for embedded windows, like Plug, the results will differ.
func (window *Window) HasToplevelFocus() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_has_toplevel_focus(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Iconify asks to iconify (i.e. minimize) the specified @window. Note that you
// shouldn’t assume the window is definitely iconified afterward, because other
// entities (e.g. the user or [window manager][gtk-X11-arch]) could deiconify it
// again, or there may not be a window manager in which case iconification isn’t
// possible, etc. But normally the window will end up iconified. Just don’t
// write code that crashes if not.
//
// It’s permitted to call this function before showing a window, in which case
// the window will be iconified before it ever appears onscreen.
//
// You can track iconification via the “window-state-event” signal on Widget.
func (window *Window) Iconify() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_window_iconify(_arg0)
}

// IsActive returns whether the window is part of the current active toplevel.
// (That is, the toplevel window receiving keystrokes.) The return value is true
// if the window is active toplevel itself, but also if it is, say, a Plug
// embedded in the active toplevel. You might use this function if you wanted to
// draw a widget differently in an active window from a widget in an inactive
// window. See gtk_window_has_toplevel_focus()
func (window *Window) IsActive() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_is_active(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsMaximized retrieves the current maximized state of @window.
//
// Note that since maximization is ultimately handled by the window manager and
// happens asynchronously to an application request, you shouldn’t assume the
// return value of this function changing immediately (or at all), as an effect
// of calling gtk_window_maximize() or gtk_window_unmaximize().
func (window *Window) IsMaximized() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_is_maximized(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Maximize asks to maximize @window, so that it becomes full-screen. Note that
// you shouldn’t assume the window is definitely maximized afterward, because
// other entities (e.g. the user or [window manager][gtk-X11-arch]) could
// unmaximize it again, and not all window managers support maximization. But
// normally the window will end up maximized. Just don’t write code that crashes
// if not.
//
// It’s permitted to call this function before showing a window, in which case
// the window will be maximized when it appears onscreen initially.
//
// You can track maximization via the “window-state-event” signal on Widget, or
// by listening to notifications on the Window:is-maximized property.
func (window *Window) Maximize() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_window_maximize(_arg0)
}

// MnemonicActivate activates the targets associated with the mnemonic.
func (window *Window) MnemonicActivate(keyval uint, modifier gdk.ModifierType) bool {
	var _arg0 *C.GtkWindow      // out
	var _arg1 C.guint           // out
	var _arg2 C.GdkModifierType // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = C.guint(keyval)
	_arg2 = C.GdkModifierType(modifier)

	_cret = C.gtk_window_mnemonic_activate(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Move asks the [window manager][gtk-X11-arch] to move @window to the given
// position. Window managers are free to ignore this; most window managers
// ignore requests for initial window positions (instead using a user-defined
// placement algorithm) and honor requests after the window has already been
// shown.
//
// Note: the position is the position of the gravity-determined reference point
// for the window. The gravity determines two things: first, the location of the
// reference point in root window coordinates; and second, which point on the
// window is positioned at the reference point.
//
// By default the gravity is K_GRAVITY_NORTH_WEST, so the reference point is
// simply the @x, @y supplied to gtk_window_move(). The top-left corner of the
// window decorations (aka window frame or border) will be placed at @x, @y.
// Therefore, to position a window at the top left of the screen, you want to
// use the default gravity (which is K_GRAVITY_NORTH_WEST) and move the window
// to 0,0.
//
// To position a window at the bottom right corner of the screen, you would set
// K_GRAVITY_SOUTH_EAST, which means that the reference point is at @x + the
// window width and @y + the window height, and the bottom-right corner of the
// window border will be placed at that reference point. So, to place a window
// in the bottom right corner you would first set gravity to south east, then
// write: `gtk_window_move (window, gdk_screen_width () - window_width,
// gdk_screen_height () - window_height)` (note that this example does not take
// multi-head scenarios into account).
//
// The Extended Window Manager Hints Specification
// (http://www.freedesktop.org/Standards/wm-spec) has a nice table of gravities
// in the “implementation notes” section.
//
// The gtk_window_get_position() documentation may also be relevant.
func (window *Window) Move(x int, y int) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = C.gint(x)
	_arg2 = C.gint(y)

	C.gtk_window_move(_arg0, _arg1, _arg2)
}

// ParseGeometry parses a standard X Window System geometry string - see the
// manual page for X (type “man X”) for details on this.
// gtk_window_parse_geometry() does work on all GTK+ ports including Win32 but
// is primarily intended for an X environment.
//
// If either a size or a position can be extracted from the geometry string,
// gtk_window_parse_geometry() returns true and calls
// gtk_window_set_default_size() and/or gtk_window_move() to resize/move the
// window.
//
// If gtk_window_parse_geometry() returns true, it will also set the
// K_HINT_USER_POS and/or K_HINT_USER_SIZE hints indicating to the window
// manager that the size/position of the window was user-specified. This causes
// most window managers to honor the geometry.
//
// Note that for gtk_window_parse_geometry() to work as expected, it has to be
// called when the window has its “final” size, i.e. after calling
// gtk_widget_show_all() on the contents and gtk_window_set_geometry_hints() on
// the window.
//
//    #include <gtk/gtk.h>
//
//    static void
//    fill_with_content (GtkWidget *vbox)
//    {
//      // fill with content...
//    }
//
//    int
//    main (int argc, char *argv[])
//    {
//      GtkWidget *window, *vbox;
//      GdkGeometry size_hints = {
//        100, 50, 0, 0, 100, 50, 10,
//        10, 0.0, 0.0, GDK_GRAVITY_NORTH_WEST
//      };
//
//      gtk_init (&argc, &argv);
//
//      window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
//      vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
//
//      gtk_container_add (GTK_CONTAINER (window), vbox);
//      fill_with_content (vbox);
//      gtk_widget_show_all (vbox);
//
//      gtk_window_set_geometry_hints (GTK_WINDOW (window),
//    	  			    NULL,
//    				    &size_hints,
//    				    GDK_HINT_MIN_SIZE |
//    				    GDK_HINT_BASE_SIZE |
//    				    GDK_HINT_RESIZE_INC);
//
//      if (argc > 1)
//        {
//          gboolean res;
//          res = gtk_window_parse_geometry (GTK_WINDOW (window),
//                                           argv[1]);
//          if (! res)
//            fprintf (stderr,
//                     "Failed to parse “s”\n",
//                     argv[1]);
//        }
//
//      gtk_widget_show_all (window);
//      gtk_main ();
//
//      return 0;
//    }
//
// Deprecated: Geometry handling in GTK is deprecated.
func (window *Window) ParseGeometry(geometry string) bool {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.gchar     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(geometry)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_window_parse_geometry(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Present presents a window to the user. This function should not be used as
// when it is called, it is too late to gather a valid timestamp to allow focus
// stealing prevention to work correctly.
func (window *Window) Present() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_window_present(_arg0)
}

// PresentWithTime presents a window to the user. This may mean raising the
// window in the stacking order, deiconifying it, moving it to the current
// desktop, and/or giving it the keyboard focus, possibly dependent on the
// user’s platform, window manager, and preferences.
//
// If @window is hidden, this function calls gtk_widget_show() as well.
//
// This function should be used when the user tries to open a window that’s
// already open. Say for example the preferences dialog is currently open, and
// the user chooses Preferences from the menu a second time; use
// gtk_window_present() to move the already-open dialog where the user can see
// it.
//
// Presents a window to the user in response to a user interaction. The
// timestamp should be gathered when the window was requested to be shown (when
// clicking a link for example), rather than once the window is ready to be
// shown.
func (window *Window) PresentWithTime(timestamp uint32) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.guint32    // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = C.guint32(timestamp)

	C.gtk_window_present_with_time(_arg0, _arg1)
}

// PropagateKeyEvent: propagate a key press or release event to the focus widget
// and up the focus container chain until a widget handles @event. This is
// normally called by the default ::key_press_event and ::key_release_event
// handlers for toplevel windows, however in some cases it may be useful to call
// this directly when overriding the standard key handling for a toplevel
// window.
func (window *Window) PropagateKeyEvent(event *gdk.EventKey) bool {
	var _arg0 *C.GtkWindow   // out
	var _arg1 *C.GdkEventKey // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = (*C.GdkEventKey)(unsafe.Pointer(event))

	_cret = C.gtk_window_propagate_key_event(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveAccelGroup reverses the effects of gtk_window_add_accel_group().
func (window *Window) RemoveAccelGroup(accelGroup AccelGrouper) {
	var _arg0 *C.GtkWindow     // out
	var _arg1 *C.GtkAccelGroup // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = (*C.GtkAccelGroup)(unsafe.Pointer((accelGroup).(gextras.Nativer).Native()))

	C.gtk_window_remove_accel_group(_arg0, _arg1)
}

// RemoveMnemonic removes a mnemonic from this window.
func (window *Window) RemoveMnemonic(keyval uint, target Widgeter) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.guint      // out
	var _arg2 *C.GtkWidget // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = C.guint(keyval)
	_arg2 = (*C.GtkWidget)(unsafe.Pointer((target).(gextras.Nativer).Native()))

	C.gtk_window_remove_mnemonic(_arg0, _arg1, _arg2)
}

// ReshowWithInitialSize hides @window, then reshows it, resetting the default
// size and position of the window. Used by GUI builders only.
//
// Deprecated: GUI builders can call gtk_widget_hide(), gtk_widget_unrealize()
// and then gtk_widget_show() on @window themselves, if they still need this
// functionality.
func (window *Window) ReshowWithInitialSize() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_window_reshow_with_initial_size(_arg0)
}

// Resize resizes the window as if the user had done so, obeying geometry
// constraints. The default geometry constraint is that windows may not be
// smaller than their size request; to override this constraint, call
// gtk_widget_set_size_request() to set the window's request to a smaller value.
//
// If gtk_window_resize() is called before showing a window for the first time,
// it overrides any default size set with gtk_window_set_default_size().
//
// Windows may not be resized smaller than 1 by 1 pixels.
//
// When using client side decorations, GTK+ will do its best to adjust the given
// size so that the resulting window size matches the requested size without the
// title bar, borders and shadows added for the client side decorations, but
// there is no guarantee that the result will be totally accurate because these
// widgets added for client side decorations depend on the theme and may not be
// realized or visible at the time gtk_window_resize() is issued.
//
// If the GtkWindow has a titlebar widget (see gtk_window_set_titlebar()), then
// typically, gtk_window_resize() will compensate for the height of the titlebar
// widget only if the height is known when the resulting GtkWindow configuration
// is issued. For example, if new widgets are added after the GtkWindow
// configuration and cause the titlebar widget to grow in height, this will
// result in a window content smaller that specified by gtk_window_resize() and
// not a larger window.
func (window *Window) Resize(width int, height int) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = C.gint(width)
	_arg2 = C.gint(height)

	C.gtk_window_resize(_arg0, _arg1, _arg2)
}

// ResizeGripIsVisible determines whether a resize grip is visible for the
// specified window.
//
// Deprecated: Resize grips have been removed.
func (window *Window) ResizeGripIsVisible() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_resize_grip_is_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ResizeToGeometry: like gtk_window_resize(), but @width and @height are
// interpreted in terms of the base size and increment set with
// gtk_window_set_geometry_hints.
//
// Deprecated: This function does nothing. Use gtk_window_resize() and compute
// the geometry yourself.
func (window *Window) ResizeToGeometry(width int, height int) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = C.gint(width)
	_arg2 = C.gint(height)

	C.gtk_window_resize_to_geometry(_arg0, _arg1, _arg2)
}

// SetAcceptFocus windows may set a hint asking the desktop environment not to
// receive the input focus. This function sets this hint.
func (window *Window) SetAcceptFocus(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_accept_focus(_arg0, _arg1)
}

// SetApplication sets or unsets the Application associated with the window.
//
// The application will be kept alive for at least as long as it has any windows
// associated with it (see g_application_hold() for a way to keep it alive
// without windows).
//
// Normally, the connection between the application and the window will remain
// until the window is destroyed, but you can explicitly remove it by setting
// the @application to nil.
//
// This is equivalent to calling gtk_application_remove_window() and/or
// gtk_application_add_window() on the old/new applications as relevant.
func (window *Window) SetApplication(application Applicationer) {
	var _arg0 *C.GtkWindow      // out
	var _arg1 *C.GtkApplication // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = (*C.GtkApplication)(unsafe.Pointer((application).(gextras.Nativer).Native()))

	C.gtk_window_set_application(_arg0, _arg1)
}

// SetAttachedTo marks @window as attached to @attach_widget. This creates a
// logical binding between the window and the widget it belongs to, which is
// used by GTK+ to propagate information such as styling or accessibility to
// @window as if it was a children of @attach_widget.
//
// Examples of places where specifying this relation is useful are for instance
// a Menu created by a ComboBox, a completion popup window created by Entry or a
// typeahead search entry created by TreeView.
//
// Note that this function should not be confused with
// gtk_window_set_transient_for(), which specifies a window manager relation
// between two toplevels instead.
//
// Passing nil for @attach_widget detaches the window.
func (window *Window) SetAttachedTo(attachWidget Widgeter) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer((attachWidget).(gextras.Nativer).Native()))

	C.gtk_window_set_attached_to(_arg0, _arg1)
}

// SetDecorated: by default, windows are decorated with a title bar, resize
// controls, etc. Some [window managers][gtk-X11-arch] allow GTK+ to disable
// these decorations, creating a borderless window. If you set the decorated
// property to false using this function, GTK+ will do its best to convince the
// window manager not to decorate the window. Depending on the system, this
// function may not have any effect when called on a window that is already
// visible, so you should call it before calling gtk_widget_show().
//
// On Windows, this function always works, since there’s no window manager
// policy involved.
func (window *Window) SetDecorated(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_decorated(_arg0, _arg1)
}

// SetDefault: default widget is the widget that’s activated when the user
// presses Enter in a dialog (for example). This function sets or unsets the
// default widget for a Window. When setting (rather than unsetting) the default
// widget it’s generally easier to call gtk_widget_grab_default() on the widget.
// Before making a widget the default widget, you must call
// gtk_widget_set_can_default() on the widget you’d like to make the default.
func (window *Window) SetDefault(defaultWidget Widgeter) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer((defaultWidget).(gextras.Nativer).Native()))

	C.gtk_window_set_default(_arg0, _arg1)
}

// SetDefaultGeometry: like gtk_window_set_default_size(), but @width and
// @height are interpreted in terms of the base size and increment set with
// gtk_window_set_geometry_hints.
//
// Deprecated: This function does nothing. If you want to set a default size,
// use gtk_window_set_default_size() instead.
func (window *Window) SetDefaultGeometry(width int, height int) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = C.gint(width)
	_arg2 = C.gint(height)

	C.gtk_window_set_default_geometry(_arg0, _arg1, _arg2)
}

// SetDefaultSize sets the default size of a window. If the window’s “natural”
// size (its size request) is larger than the default, the default will be
// ignored. More generally, if the default size does not obey the geometry hints
// for the window (gtk_window_set_geometry_hints() can be used to set these
// explicitly), the default size will be clamped to the nearest permitted size.
//
// Unlike gtk_widget_set_size_request(), which sets a size request for a widget
// and thus would keep users from shrinking the window, this function only sets
// the initial size, just as if the user had resized the window themselves.
// Users can still shrink the window again as they normally would. Setting a
// default size of -1 means to use the “natural” default size (the size request
// of the window).
//
// For more control over a window’s initial size and how resizing works,
// investigate gtk_window_set_geometry_hints().
//
// For some uses, gtk_window_resize() is a more appropriate function.
// gtk_window_resize() changes the current size of the window, rather than the
// size to be used on initial display. gtk_window_resize() always affects the
// window itself, not the geometry widget.
//
// The default size of a window only affects the first time a window is shown;
// if a window is hidden and re-shown, it will remember the size it had prior to
// hiding, rather than using the default size.
//
// Windows can’t actually be 0x0 in size, they must be at least 1x1, but passing
// 0 for @width and @height is OK, resulting in a 1x1 default size.
//
// If you use this function to reestablish a previously saved window size, note
// that the appropriate size to save is the one returned by
// gtk_window_get_size(). Using the window allocation directly will not work in
// all circumstances and can lead to growing or shrinking windows.
func (window *Window) SetDefaultSize(width int, height int) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = C.gint(width)
	_arg2 = C.gint(height)

	C.gtk_window_set_default_size(_arg0, _arg1, _arg2)
}

// SetDeletable: by default, windows have a close button in the window frame.
// Some [window managers][gtk-X11-arch] allow GTK+ to disable this button. If
// you set the deletable property to false using this function, GTK+ will do its
// best to convince the window manager not to show a close button. Depending on
// the system, this function may not have any effect when called on a window
// that is already visible, so you should call it before calling
// gtk_widget_show().
//
// On Windows, this function always works, since there’s no window manager
// policy involved.
func (window *Window) SetDeletable(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_deletable(_arg0, _arg1)
}

// SetDestroyWithParent: if @setting is true, then destroying the transient
// parent of @window will also destroy @window itself. This is useful for
// dialogs that shouldn’t persist beyond the lifetime of the main window they're
// associated with, for example.
func (window *Window) SetDestroyWithParent(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_destroy_with_parent(_arg0, _arg1)
}

// SetFocus: if @focus is not the current focus widget, and is focusable, sets
// it as the focus widget for the window. If @focus is nil, unsets the focus
// widget for this window. To set the focus to a particular widget in the
// toplevel, it is usually more convenient to use gtk_widget_grab_focus()
// instead of this function.
func (window *Window) SetFocus(focus Widgeter) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer((focus).(gextras.Nativer).Native()))

	C.gtk_window_set_focus(_arg0, _arg1)
}

// SetFocusOnMap windows may set a hint asking the desktop environment not to
// receive the input focus when the window is mapped. This function sets this
// hint.
func (window *Window) SetFocusOnMap(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_focus_on_map(_arg0, _arg1)
}

// SetFocusVisible sets the Window:focus-visible property.
func (window *Window) SetFocusVisible(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_focus_visible(_arg0, _arg1)
}

// SetGeometryHints: this function sets up hints about how a window can be
// resized by the user. You can set a minimum and maximum size; allowed resize
// increments (e.g. for xterm, you can only resize by the size of a character);
// aspect ratios; and more. See the Geometry struct.
func (window *Window) SetGeometryHints(geometryWidget Widgeter, geometry *gdk.Geometry, geomMask gdk.WindowHints) {
	var _arg0 *C.GtkWindow     // out
	var _arg1 *C.GtkWidget     // out
	var _arg2 *C.GdkGeometry   // out
	var _arg3 C.GdkWindowHints // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer((geometryWidget).(gextras.Nativer).Native()))
	_arg2 = (*C.GdkGeometry)(unsafe.Pointer(geometry))
	_arg3 = C.GdkWindowHints(geomMask)

	C.gtk_window_set_geometry_hints(_arg0, _arg1, _arg2, _arg3)
}

// SetGravity: window gravity defines the meaning of coordinates passed to
// gtk_window_move(). See gtk_window_move() and Gravity for more details.
//
// The default window gravity is K_GRAVITY_NORTH_WEST which will typically “do
// what you mean.”
func (window *Window) SetGravity(gravity gdk.Gravity) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.GdkGravity // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = C.GdkGravity(gravity)

	C.gtk_window_set_gravity(_arg0, _arg1)
}

// SetHasResizeGrip sets whether @window has a corner resize grip.
//
// Note that the resize grip is only shown if the window is actually resizable
// and not maximized. Use gtk_window_resize_grip_is_visible() to find out if the
// resize grip is currently shown.
//
// Deprecated: Resize grips have been removed.
func (window *Window) SetHasResizeGrip(value bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if value {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_has_resize_grip(_arg0, _arg1)
}

// SetHasUserRefCount tells GTK+ whether to drop its extra reference to the
// window when gtk_widget_destroy() is called.
//
// This function is only exported for the benefit of language bindings which may
// need to keep the window alive until their wrapper object is garbage
// collected. There is no justification for ever calling this function in an
// application.
func (window *Window) SetHasUserRefCount(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_has_user_ref_count(_arg0, _arg1)
}

// SetHideTitlebarWhenMaximized: if @setting is true, then @window will request
// that it’s titlebar should be hidden when maximized. This is useful for
// windows that don’t convey any information other than the application name in
// the titlebar, to put the available screen space to better use. If the
// underlying window system does not support the request, the setting will not
// have any effect.
//
// Note that custom titlebars set with gtk_window_set_titlebar() are not
// affected by this. The application is in full control of their content and
// visibility anyway.
func (window *Window) SetHideTitlebarWhenMaximized(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_hide_titlebar_when_maximized(_arg0, _arg1)
}

// SetIcon sets up the icon representing a Window. This icon is used when the
// window is minimized (also known as iconified). Some window managers or
// desktop environments may also place it in the window frame, or display it in
// other contexts. On others, the icon is not used at all, so your mileage may
// vary.
//
// The icon should be provided in whatever size it was naturally drawn; that is,
// don’t scale the image before passing it to GTK+. Scaling is postponed until
// the last minute, when the desired final size is known, to allow best quality.
//
// If you have your icon hand-drawn in multiple sizes, use
// gtk_window_set_icon_list(). Then the best size will be used.
//
// This function is equivalent to calling gtk_window_set_icon_list() with a
// 1-element list.
//
// See also gtk_window_set_default_icon_list() to set the icon for all windows
// in your application in one go.
func (window *Window) SetIcon(icon gdkpixbuf.Pixbufer) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GdkPixbuf // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer((icon).(gextras.Nativer).Native()))

	C.gtk_window_set_icon(_arg0, _arg1)
}

// SetIconFromFile sets the icon for @window. Warns on failure if @err is nil.
//
// This function is equivalent to calling gtk_window_set_icon() with a pixbuf
// created by loading the image from @filename.
func (window *Window) SetIconFromFile(filename string) error {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.gchar     // out
	var _cerr *C.GError    // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_window_set_icon_from_file(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// SetIconName sets the icon for the window from a named themed icon. See the
// docs for IconTheme for more details. On some platforms, the window icon is
// not used at all.
//
// Note that this has nothing to do with the WM_ICON_NAME property which is
// mentioned in the ICCCM.
func (window *Window) SetIconName(name string) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_window_set_icon_name(_arg0, _arg1)
}

// SetKeepAbove asks to keep @window above, so that it stays on top. Note that
// you shouldn’t assume the window is definitely above afterward, because other
// entities (e.g. the user or [window manager][gtk-X11-arch]) could not keep it
// above, and not all window managers support keeping windows above. But
// normally the window will end kept above. Just don’t write code that crashes
// if not.
//
// It’s permitted to call this function before showing a window, in which case
// the window will be kept above when it appears onscreen initially.
//
// You can track the above state via the “window-state-event” signal on Widget.
//
// Note that, according to the Extended Window Manager Hints Specification
// (http://www.freedesktop.org/Standards/wm-spec), the above state is mainly
// meant for user preferences and should not be used by applications e.g. for
// drawing attention to their dialogs.
func (window *Window) SetKeepAbove(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_keep_above(_arg0, _arg1)
}

// SetKeepBelow asks to keep @window below, so that it stays in bottom. Note
// that you shouldn’t assume the window is definitely below afterward, because
// other entities (e.g. the user or [window manager][gtk-X11-arch]) could not
// keep it below, and not all window managers support putting windows below. But
// normally the window will be kept below. Just don’t write code that crashes if
// not.
//
// It’s permitted to call this function before showing a window, in which case
// the window will be kept below when it appears onscreen initially.
//
// You can track the below state via the “window-state-event” signal on Widget.
//
// Note that, according to the Extended Window Manager Hints Specification
// (http://www.freedesktop.org/Standards/wm-spec), the above state is mainly
// meant for user preferences and should not be used by applications e.g. for
// drawing attention to their dialogs.
func (window *Window) SetKeepBelow(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_keep_below(_arg0, _arg1)
}

// SetMnemonicModifier sets the mnemonic modifier for this window.
func (window *Window) SetMnemonicModifier(modifier gdk.ModifierType) {
	var _arg0 *C.GtkWindow      // out
	var _arg1 C.GdkModifierType // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = C.GdkModifierType(modifier)

	C.gtk_window_set_mnemonic_modifier(_arg0, _arg1)
}

// SetMnemonicsVisible sets the Window:mnemonics-visible property.
func (window *Window) SetMnemonicsVisible(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_mnemonics_visible(_arg0, _arg1)
}

// SetModal sets a window modal or non-modal. Modal windows prevent interaction
// with other windows in the same application. To keep modal dialogs on top of
// main application windows, use gtk_window_set_transient_for() to make the
// dialog transient for the parent; most [window managers][gtk-X11-arch] will
// then disallow lowering the dialog below the parent.
func (window *Window) SetModal(modal bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if modal {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_modal(_arg0, _arg1)
}

// SetOpacity: request the windowing system to make @window partially
// transparent, with opacity 0 being fully transparent and 1 fully opaque.
// (Values of the opacity parameter are clamped to the [0,1] range.) On X11 this
// has any effect only on X screens with a compositing manager running. See
// gtk_widget_is_composited(). On Windows it should work always.
//
// Note that setting a window’s opacity after the window has been shown causes
// it to flicker once on Windows.
//
// Deprecated: Use gtk_widget_set_opacity instead.
func (window *Window) SetOpacity(opacity float64) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gdouble    // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = C.gdouble(opacity)

	C.gtk_window_set_opacity(_arg0, _arg1)
}

// SetPosition sets a position constraint for this window. If the old or new
// constraint is GTK_WIN_POS_CENTER_ALWAYS, this will also cause the window to
// be repositioned to satisfy the new constraint.
func (window *Window) SetPosition(position WindowPosition) {
	var _arg0 *C.GtkWindow        // out
	var _arg1 C.GtkWindowPosition // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = C.GtkWindowPosition(position)

	C.gtk_window_set_position(_arg0, _arg1)
}

// SetResizable sets whether the user can resize a window. Windows are user
// resizable by default.
func (window *Window) SetResizable(resizable bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if resizable {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_resizable(_arg0, _arg1)
}

// SetRole: this function is only useful on X11, not with other GTK+ targets.
//
// In combination with the window title, the window role allows a [window
// manager][gtk-X11-arch] to identify "the same" window when an application is
// restarted. So for example you might set the “toolbox” role on your app’s
// toolbox window, so that when the user restarts their session, the window
// manager can put the toolbox back in the same place.
//
// If a window already has a unique title, you don’t need to set the role, since
// the WM can use the title to identify the window when restoring the session.
func (window *Window) SetRole(role string) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(role)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_window_set_role(_arg0, _arg1)
}

// SetScreen sets the Screen where the @window is displayed; if the window is
// already mapped, it will be unmapped, and then remapped on the new screen.
func (window *Window) SetScreen(screen gdk.Screener) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GdkScreen // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = (*C.GdkScreen)(unsafe.Pointer((screen).(gextras.Nativer).Native()))

	C.gtk_window_set_screen(_arg0, _arg1)
}

// SetSkipPagerHint windows may set a hint asking the desktop environment not to
// display the window in the pager. This function sets this hint. (A "pager" is
// any desktop navigation tool such as a workspace switcher that displays a
// thumbnail representation of the windows on the screen.)
func (window *Window) SetSkipPagerHint(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_skip_pager_hint(_arg0, _arg1)
}

// SetSkipTaskbarHint windows may set a hint asking the desktop environment not
// to display the window in the task bar. This function sets this hint.
func (window *Window) SetSkipTaskbarHint(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_skip_taskbar_hint(_arg0, _arg1)
}

// SetStartupID: startup notification identifiers are used by desktop
// environment to track application startup, to provide user feedback and other
// features. This function changes the corresponding property on the underlying
// GdkWindow. Normally, startup identifier is managed automatically and you
// should only use this function in special cases like transferring focus from
// other processes. You should use this function before calling
// gtk_window_present() or any equivalent function generating a window map
// event.
//
// This function is only useful on X11, not with other GTK+ targets.
func (window *Window) SetStartupID(startupId string) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(startupId)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_window_set_startup_id(_arg0, _arg1)
}

// SetTitle sets the title of the Window. The title of a window will be
// displayed in its title bar; on the X Window System, the title bar is rendered
// by the [window manager][gtk-X11-arch], so exactly how the title appears to
// users may vary according to a user’s exact configuration. The title should
// help a user distinguish this window from other windows they may have open. A
// good title might include the application name and current document filename,
// for example.
func (window *Window) SetTitle(title string) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(title)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_window_set_title(_arg0, _arg1)
}

// SetTitlebar sets a custom titlebar for @window.
//
// A typical widget used here is HeaderBar, as it provides various features
// expected of a titlebar while allowing the addition of child widgets to it.
//
// If you set a custom titlebar, GTK+ will do its best to convince the window
// manager not to put its own titlebar on the window. Depending on the system,
// this function may not work for a window that is already visible, so you set
// the titlebar before calling gtk_widget_show().
func (window *Window) SetTitlebar(titlebar Widgeter) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer((titlebar).(gextras.Nativer).Native()))

	C.gtk_window_set_titlebar(_arg0, _arg1)
}

// SetTransientFor: dialog windows should be set transient for the main
// application window they were spawned from. This allows [window
// managers][gtk-X11-arch] to e.g. keep the dialog on top of the main window, or
// center the dialog over the main window. gtk_dialog_new_with_buttons() and
// other convenience functions in GTK+ will sometimes call
// gtk_window_set_transient_for() on your behalf.
//
// Passing nil for @parent unsets the current transient window.
//
// On Wayland, this function can also be used to attach a new K_WINDOW_POPUP to
// a K_WINDOW_TOPLEVEL parent already mapped on screen so that the
// K_WINDOW_POPUP will be created as a subsurface-based window
// K_WINDOW_SUBSURFACE which can be positioned at will relatively to the
// K_WINDOW_TOPLEVEL surface.
//
// On Windows, this function puts the child window on top of the parent, much as
// the window manager would have done on X.
func (window *Window) SetTransientFor(parent Windower) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = (*C.GtkWindow)(unsafe.Pointer((parent).(gextras.Nativer).Native()))

	C.gtk_window_set_transient_for(_arg0, _arg1)
}

// SetTypeHint: by setting the type hint for the window, you allow the window
// manager to decorate and handle the window in a way which is suitable to the
// function of the window in your application.
//
// This function should be called before the window becomes visible.
//
// gtk_dialog_new_with_buttons() and other convenience functions in GTK+ will
// sometimes call gtk_window_set_type_hint() on your behalf.
func (window *Window) SetTypeHint(hint gdk.WindowTypeHint) {
	var _arg0 *C.GtkWindow        // out
	var _arg1 C.GdkWindowTypeHint // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = C.GdkWindowTypeHint(hint)

	C.gtk_window_set_type_hint(_arg0, _arg1)
}

// SetUrgencyHint windows may set a hint asking the desktop environment to draw
// the users attention to the window. This function sets this hint.
func (window *Window) SetUrgencyHint(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_urgency_hint(_arg0, _arg1)
}

// SetWmclass: don’t use this function. It sets the X Window System “class” and
// “name” hints for a window. According to the ICCCM, you should always set
// these to the same value for all windows in an application, and GTK+ sets them
// to that value by default, so calling this function is sort of pointless.
// However, you may want to call gtk_window_set_role() on each window in your
// application, for the benefit of the session manager. Setting the role allows
// the window manager to restore window positions when loading a saved session.
//
// Deprecated: since version 3.22.
func (window *Window) SetWmclass(wmclassName string, wmclassClass string) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.gchar     // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(wmclassName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(wmclassClass)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_window_set_wmclass(_arg0, _arg1, _arg2)
}

// Stick asks to stick @window, which means that it will appear on all user
// desktops. Note that you shouldn’t assume the window is definitely stuck
// afterward, because other entities (e.g. the user or [window
// manager][gtk-X11-arch] could unstick it again, and some window managers do
// not support sticking windows. But normally the window will end up stuck. Just
// don't write code that crashes if not.
//
// It’s permitted to call this function before showing a window.
//
// You can track stickiness via the “window-state-event” signal on Widget.
func (window *Window) Stick() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_window_stick(_arg0)
}

// Unfullscreen asks to toggle off the fullscreen state for @window. Note that
// you shouldn’t assume the window is definitely not full screen afterward,
// because other entities (e.g. the user or [window manager][gtk-X11-arch])
// could fullscreen it again, and not all window managers honor requests to
// unfullscreen windows. But normally the window will end up restored to its
// normal state. Just don’t write code that crashes if not.
//
// You can track the fullscreen state via the “window-state-event” signal on
// Widget.
func (window *Window) Unfullscreen() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_window_unfullscreen(_arg0)
}

// Unmaximize asks to unmaximize @window. Note that you shouldn’t assume the
// window is definitely unmaximized afterward, because other entities (e.g. the
// user or [window manager][gtk-X11-arch]) could maximize it again, and not all
// window managers honor requests to unmaximize. But normally the window will
// end up unmaximized. Just don’t write code that crashes if not.
//
// You can track maximization via the “window-state-event” signal on Widget.
func (window *Window) Unmaximize() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_window_unmaximize(_arg0)
}

// Unstick asks to unstick @window, which means that it will appear on only one
// of the user’s desktops. Note that you shouldn’t assume the window is
// definitely unstuck afterward, because other entities (e.g. the user or
// [window manager][gtk-X11-arch]) could stick it again. But normally the window
// will end up stuck. Just don’t write code that crashes if not.
//
// You can track stickiness via the “window-state-event” signal on Widget.
func (window *Window) Unstick() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_window_unstick(_arg0)
}

// WindowGetDefaultIconName returns the fallback icon name for windows that has
// been set with gtk_window_set_default_icon_name(). The returned string is
// owned by GTK+ and should not be modified. It is only valid until the next
// call to gtk_window_set_default_icon_name().
func WindowGetDefaultIconName() string {
	var _cret *C.gchar // in

	_cret = C.gtk_window_get_default_icon_name()

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// WindowSetAutoStartupNotification: by default, after showing the first Window,
// GTK+ calls gdk_notify_startup_complete(). Call this function to disable the
// automatic startup notification. You might do this if your first window is a
// splash screen, and you want to delay notification until after your real main
// window has been shown, for example.
//
// In that example, you would disable startup notification temporarily, show
// your splash screen, then re-enable it so that showing the main window would
// automatically result in notification.
func WindowSetAutoStartupNotification(setting bool) {
	var _arg1 C.gboolean // out

	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_auto_startup_notification(_arg1)
}

// WindowSetDefaultIcon sets an icon to be used as fallback for windows that
// haven't had gtk_window_set_icon() called on them from a pixbuf.
func WindowSetDefaultIcon(icon gdkpixbuf.Pixbufer) {
	var _arg1 *C.GdkPixbuf // out

	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer((icon).(gextras.Nativer).Native()))

	C.gtk_window_set_default_icon(_arg1)
}

// WindowSetDefaultIconFromFile sets an icon to be used as fallback for windows
// that haven't had gtk_window_set_icon_list() called on them from a file on
// disk. Warns on failure if @err is nil.
func WindowSetDefaultIconFromFile(filename string) error {
	var _arg1 *C.gchar  // out
	var _cerr *C.GError // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_window_set_default_icon_from_file(_arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// WindowSetDefaultIconName sets an icon to be used as fallback for windows that
// haven't had gtk_window_set_icon_list() called on them from a named themed
// icon, see gtk_window_set_icon_name().
func WindowSetDefaultIconName(name string) {
	var _arg1 *C.gchar // out

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_window_set_default_icon_name(_arg1)
}

// WindowSetInteractiveDebugging opens or closes the [interactive
// debugger][interactive-debugging], which offers access to the widget hierarchy
// of the application and to useful debugging tools.
func WindowSetInteractiveDebugging(enable bool) {
	var _arg1 C.gboolean // out

	if enable {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_interactive_debugging(_arg1)
}
