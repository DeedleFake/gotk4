// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_window_get_type()), F: marshalWindow},
	})
}

// Window: a GtkWindow is a toplevel window which can contain other widgets.
// Windows normally have decorations that are under the control of the windowing
// system and allow the user to manipulate the window (resize it, move it, close
// it,...).
//
//
// GtkWindow as GtkBuildable
//
// The GtkWindow implementation of the Buildable interface supports a custom
// <accel-groups> element, which supports any number of <group> elements
// representing the AccelGroup objects you want to add to your window
// (synonymous with gtk_window_add_accel_group().
//
// It also supports the <initial-focus> element, whose name property names the
// widget to receive the focus when the window is mapped.
//
// An example of a UI definition fragment with accel groups:
//
//    <object class="GtkWindow">
//      <accel-groups>
//        <group name="accelgroup1"/>
//      </accel-groups>
//      <initial-focus name="thunderclap"/>
//    </object>
//
//    ...
//
//    <object class="GtkAccelGroup" id="accelgroup1"/>
//
// The GtkWindow implementation of the Buildable interface supports setting a
// child as the titlebar by specifying “titlebar” as the “type” attribute of a
// <child> element.
//
// CSS nodes
//
//    window.background
//    ├── decoration
//    ├── <titlebar child>.titlebar [.default-decoration]
//    ╰── <child>
//
// GtkWindow has a main CSS node with name window and style class .background,
// and a subnode with name decoration.
//
// Style classes that are typically used with the main CSS node are .csd (when
// client-side decorations are in use), .solid-csd (for client-side decorations
// without invisible borders), .ssd (used by mutter when rendering server-side
// decorations). GtkWindow also represents window states with the following
// style classes on the main node: .tiled, .maximized, .fullscreen. Specialized
// types of window often add their own discriminating style classes, such as
// .popup or .tooltip.
//
// GtkWindow adds the .titlebar and .default-decoration style classes to the
// widget that is added as a titlebar child.
type Window interface {
	Bin
	Buildable

	// ActivateDefault activates the default widget for the window, unless the
	// current focused widget has been configured to receive the default action
	// (see gtk_widget_set_receives_default()), in which case the focused widget
	// is activated.
	ActivateDefault() bool
	// ActivateFocus activates the current focused widget within the window.
	ActivateFocus() bool
	// ActivateKey activates mnemonics and accelerators for this Window. This is
	// normally called by the default ::key_press_event handler for toplevel
	// windows, however in some cases it may be useful to call this directly
	// when overriding the standard key handling for a toplevel window.
	ActivateKey(event *gdk.EventKey) bool
	// AddAccelGroup: associate @accel_group with @window, such that calling
	// gtk_accel_groups_activate() on @window will activate accelerators in
	// @accel_group.
	AddAccelGroup(accelGroup AccelGroup)
	// AddMnemonic adds a mnemonic to this window.
	AddMnemonic(keyval uint, target Widget)
	// BeginMoveDrag starts moving a window. This function is used if an
	// application has window movement grips. When GDK can support it, the
	// window movement will be done using the standard mechanism for the [window
	// manager][gtk-X11-arch] or windowing system. Otherwise, GDK will try to
	// emulate window movement, potentially not all that well, depending on the
	// windowing system.
	BeginMoveDrag(button int, rootX int, rootY int, timestamp uint32)
	// BeginResizeDrag starts resizing a window. This function is used if an
	// application has window resizing controls. When GDK can support it, the
	// resize will be done using the standard mechanism for the [window
	// manager][gtk-X11-arch] or windowing system. Otherwise, GDK will try to
	// emulate window resizing, potentially not all that well, depending on the
	// windowing system.
	BeginResizeDrag(edge gdk.WindowEdge, button int, rootX int, rootY int, timestamp uint32)
	// Close requests that the window is closed, similar to what happens when a
	// window manager close button is clicked.
	//
	// This function can be used with close buttons in custom titlebars.
	Close()
	// Deiconify asks to deiconify (i.e. unminimize) the specified @window. Note
	// that you shouldn’t assume the window is definitely deiconified afterward,
	// because other entities (e.g. the user or [window manager][gtk-X11-arch]))
	// could iconify it again before your code which assumes deiconification
	// gets to run.
	//
	// You can track iconification via the “window-state-event” signal on
	// Widget.
	Deiconify()
	// Fullscreen asks to place @window in the fullscreen state. Note that you
	// shouldn’t assume the window is definitely full screen afterward, because
	// other entities (e.g. the user or [window manager][gtk-X11-arch]) could
	// unfullscreen it again, and not all window managers honor requests to
	// fullscreen windows. But normally the window will end up fullscreen. Just
	// don’t write code that crashes if not.
	//
	// You can track the fullscreen state via the “window-state-event” signal on
	// Widget.
	Fullscreen()
	// FullscreenOnMonitor asks to place @window in the fullscreen state. Note
	// that you shouldn't assume the window is definitely full screen afterward.
	//
	// You can track the fullscreen state via the "window-state-event" signal on
	// Widget.
	FullscreenOnMonitor(screen gdk.Screen, monitor int)
	// AcceptFocus gets the value set by gtk_window_set_accept_focus().
	AcceptFocus() bool
	// Application gets the Application associated with the window (if any).
	Application() Application
	// AttachedTo fetches the attach widget for this window. See
	// gtk_window_set_attached_to().
	AttachedTo() Widget
	// Decorated returns whether the window has been set to have decorations
	// such as a title bar via gtk_window_set_decorated().
	Decorated() bool
	// DefaultSize gets the default size of the window. A value of -1 for the
	// width or height indicates that a default size has not been explicitly set
	// for that dimension, so the “natural” size of the window will be used.
	DefaultSize() (width int, height int)
	// DefaultWidget returns the default widget for @window. See
	// gtk_window_set_default() for more details.
	DefaultWidget() Widget
	// Deletable returns whether the window has been set to have a close button
	// via gtk_window_set_deletable().
	Deletable() bool
	// DestroyWithParent returns whether the window will be destroyed with its
	// transient parent. See gtk_window_set_destroy_with_parent ().
	DestroyWithParent() bool
	// Focus retrieves the current focused widget within the window. Note that
	// this is the widget that would have the focus if the toplevel window
	// focused; if the toplevel window is not focused then `gtk_widget_has_focus
	// (widget)` will not be true for the widget.
	Focus() Widget
	// FocusOnMap gets the value set by gtk_window_set_focus_on_map().
	FocusOnMap() bool
	// FocusVisible gets the value of the Window:focus-visible property.
	FocusVisible() bool
	// Gravity gets the value set by gtk_window_set_gravity().
	Gravity() gdk.Gravity
	// Group returns the group for @window or the default group, if @window is
	// nil or if @window does not have an explicit window group.
	Group() WindowGroup
	// HasResizeGrip determines whether the window may have a resize grip.
	HasResizeGrip() bool
	// HideTitlebarWhenMaximized returns whether the window has requested to
	// have its titlebar hidden when maximized. See
	// gtk_window_set_hide_titlebar_when_maximized ().
	HideTitlebarWhenMaximized() bool
	// Icon gets the value set by gtk_window_set_icon() (or if you've called
	// gtk_window_set_icon_list(), gets the first icon in the icon list).
	Icon() gdkpixbuf.Pixbuf
	// IconList retrieves the list of icons set by gtk_window_set_icon_list().
	// The list is copied, but the reference count on each member won’t be
	// incremented.
	IconList() *glib.List
	// IconName returns the name of the themed icon for the window, see
	// gtk_window_set_icon_name().
	IconName() string
	// MnemonicModifier returns the mnemonic modifier for this window. See
	// gtk_window_set_mnemonic_modifier().
	MnemonicModifier() gdk.ModifierType
	// MnemonicsVisible gets the value of the Window:mnemonics-visible property.
	MnemonicsVisible() bool
	// Modal returns whether the window is modal. See gtk_window_set_modal().
	Modal() bool
	// Opacity fetches the requested opacity for this window. See
	// gtk_window_set_opacity().
	Opacity() float64
	// Position: this function returns the position you need to pass to
	// gtk_window_move() to keep @window in its current position. This means
	// that the meaning of the returned value varies with window gravity. See
	// gtk_window_move() for more details.
	//
	// The reliability of this function depends on the windowing system
	// currently in use. Some windowing systems, such as Wayland, do not support
	// a global coordinate system, and thus the position of the window will
	// always be (0, 0). Others, like X11, do not have a reliable way to obtain
	// the geometry of the decorations of a window if they are provided by the
	// window manager. Additionally, on X11, window manager have been known to
	// mismanage window gravity, which result in windows moving even if you use
	// the coordinates of the current position as returned by this function.
	//
	// If you haven’t changed the window gravity, its gravity will be
	// K_GRAVITY_NORTH_WEST. This means that gtk_window_get_position() gets the
	// position of the top-left corner of the window manager frame for the
	// window. gtk_window_move() sets the position of this same top-left corner.
	//
	// If a window has gravity K_GRAVITY_STATIC the window manager frame is not
	// relevant, and thus gtk_window_get_position() will always produce accurate
	// results. However you can’t use static gravity to do things like place a
	// window in a corner of the screen, because static gravity ignores the
	// window manager decorations.
	//
	// Ideally, this function should return appropriate values if the window has
	// client side decorations, assuming that the windowing system supports
	// global coordinates.
	//
	// In practice, saving the window position should not be left to
	// applications, as they lack enough knowledge of the windowing system and
	// the window manager state to effectively do so. The appropriate way to
	// implement saving the window position is to use a platform-specific
	// protocol, wherever that is available.
	Position() (rootX int, rootY int)
	// Resizable gets the value set by gtk_window_set_resizable().
	Resizable() bool
	// ResizeGripArea: if a window has a resize grip, this will retrieve the
	// grip position, width and height into the specified Rectangle.
	ResizeGripArea() (rect gdk.Rectangle, ok bool)
	// Role returns the role of the window. See gtk_window_set_role() for
	// further explanation.
	Role() string
	// Screen returns the Screen associated with @window.
	Screen() gdk.Screen
	// Size obtains the current size of @window.
	//
	// If @window is not visible on screen, this function return the size GTK+
	// will suggest to the [window manager][gtk-X11-arch] for the initial window
	// size (but this is not reliably the same as the size the window manager
	// will actually select). See: gtk_window_set_default_size().
	//
	// Depending on the windowing system and the window manager constraints, the
	// size returned by this function may not match the size set using
	// gtk_window_resize(); additionally, since gtk_window_resize() may be
	// implemented as an asynchronous operation, GTK+ cannot guarantee in any
	// way that this code:
	//
	//    static void
	//    on_size_allocate (GtkWidget *widget, GtkAllocation *allocation)
	//    {
	//      int new_width, new_height;
	//
	//      gtk_window_get_size (GTK_WINDOW (widget), &new_width, &new_height);
	//
	//      ...
	//    }
	//
	// Note that, if you connect to the Widget::size-allocate signal, you should
	// not use the dimensions of the Allocation passed to the signal handler, as
	// the allocation may contain client side decorations added by GTK+,
	// depending on the windowing system in use.
	//
	// If you are getting a window size in order to position the window on the
	// screen, you should, instead, simply set the window’s semantic type with
	// gtk_window_set_type_hint(), which allows the window manager to e.g.
	// center dialogs. Also, if you set the transient parent of dialogs with
	// gtk_window_set_transient_for() window managers will often center the
	// dialog over its parent window. It's much preferred to let the window
	// manager handle these cases rather than doing it yourself, because all
	// apps will behave consistently and according to user or system
	// preferences, if the window manager handles it. Also, the window manager
	// can take into account the size of the window decorations and border that
	// it may add, and of which GTK+ has no knowledge. Additionally, positioning
	// windows in global screen coordinates may not be allowed by the windowing
	// system. For more information, see: gtk_window_set_position().
	Size() (width int, height int)
	// SkipPagerHint gets the value set by gtk_window_set_skip_pager_hint().
	SkipPagerHint() bool
	// SkipTaskbarHint gets the value set by gtk_window_set_skip_taskbar_hint()
	SkipTaskbarHint() bool
	// Title retrieves the title of the window. See gtk_window_set_title().
	Title() string
	// Titlebar returns the custom titlebar that has been set with
	// gtk_window_set_titlebar().
	Titlebar() Widget
	// TransientFor fetches the transient parent for this window. See
	// gtk_window_set_transient_for().
	TransientFor() Window
	// TypeHint gets the type hint for this window. See
	// gtk_window_set_type_hint().
	TypeHint() gdk.WindowTypeHint
	// UrgencyHint gets the value set by gtk_window_set_urgency_hint()
	UrgencyHint() bool
	// WindowType gets the type of the window. See WindowType.
	WindowType() WindowType
	// HasGroup returns whether @window has an explicit window group.
	HasGroup() bool
	// HasToplevelFocus returns whether the input focus is within this
	// GtkWindow. For real toplevel windows, this is identical to
	// gtk_window_is_active(), but for embedded windows, like Plug, the results
	// will differ.
	HasToplevelFocus() bool
	// Iconify asks to iconify (i.e. minimize) the specified @window. Note that
	// you shouldn’t assume the window is definitely iconified afterward,
	// because other entities (e.g. the user or [window manager][gtk-X11-arch])
	// could deiconify it again, or there may not be a window manager in which
	// case iconification isn’t possible, etc. But normally the window will end
	// up iconified. Just don’t write code that crashes if not.
	//
	// It’s permitted to call this function before showing a window, in which
	// case the window will be iconified before it ever appears onscreen.
	//
	// You can track iconification via the “window-state-event” signal on
	// Widget.
	Iconify()
	// IsActive returns whether the window is part of the current active
	// toplevel. (That is, the toplevel window receiving keystrokes.) The return
	// value is true if the window is active toplevel itself, but also if it is,
	// say, a Plug embedded in the active toplevel. You might use this function
	// if you wanted to draw a widget differently in an active window from a
	// widget in an inactive window. See gtk_window_has_toplevel_focus()
	IsActive() bool
	// IsMaximized retrieves the current maximized state of @window.
	//
	// Note that since maximization is ultimately handled by the window manager
	// and happens asynchronously to an application request, you shouldn’t
	// assume the return value of this function changing immediately (or at
	// all), as an effect of calling gtk_window_maximize() or
	// gtk_window_unmaximize().
	IsMaximized() bool
	// Maximize asks to maximize @window, so that it becomes full-screen. Note
	// that you shouldn’t assume the window is definitely maximized afterward,
	// because other entities (e.g. the user or [window manager][gtk-X11-arch])
	// could unmaximize it again, and not all window managers support
	// maximization. But normally the window will end up maximized. Just don’t
	// write code that crashes if not.
	//
	// It’s permitted to call this function before showing a window, in which
	// case the window will be maximized when it appears onscreen initially.
	//
	// You can track maximization via the “window-state-event” signal on Widget,
	// or by listening to notifications on the Window:is-maximized property.
	Maximize()
	// MnemonicActivate activates the targets associated with the mnemonic.
	MnemonicActivate(keyval uint, modifier gdk.ModifierType) bool
	// Move asks the [window manager][gtk-X11-arch] to move @window to the given
	// position. Window managers are free to ignore this; most window managers
	// ignore requests for initial window positions (instead using a
	// user-defined placement algorithm) and honor requests after the window has
	// already been shown.
	//
	// Note: the position is the position of the gravity-determined reference
	// point for the window. The gravity determines two things: first, the
	// location of the reference point in root window coordinates; and second,
	// which point on the window is positioned at the reference point.
	//
	// By default the gravity is K_GRAVITY_NORTH_WEST, so the reference point is
	// simply the @x, @y supplied to gtk_window_move(). The top-left corner of
	// the window decorations (aka window frame or border) will be placed at @x,
	// @y. Therefore, to position a window at the top left of the screen, you
	// want to use the default gravity (which is K_GRAVITY_NORTH_WEST) and move
	// the window to 0,0.
	//
	// To position a window at the bottom right corner of the screen, you would
	// set K_GRAVITY_SOUTH_EAST, which means that the reference point is at @x +
	// the window width and @y + the window height, and the bottom-right corner
	// of the window border will be placed at that reference point. So, to place
	// a window in the bottom right corner you would first set gravity to south
	// east, then write: `gtk_window_move (window, gdk_screen_width () -
	// window_width, gdk_screen_height () - window_height)` (note that this
	// example does not take multi-head scenarios into account).
	//
	// The Extended Window Manager Hints Specification
	// (http://www.freedesktop.org/Standards/wm-spec) has a nice table of
	// gravities in the “implementation notes” section.
	//
	// The gtk_window_get_position() documentation may also be relevant.
	Move(x int, y int)
	// ParseGeometry parses a standard X Window System geometry string - see the
	// manual page for X (type “man X”) for details on this.
	// gtk_window_parse_geometry() does work on all GTK+ ports including Win32
	// but is primarily intended for an X environment.
	//
	// If either a size or a position can be extracted from the geometry string,
	// gtk_window_parse_geometry() returns true and calls
	// gtk_window_set_default_size() and/or gtk_window_move() to resize/move the
	// window.
	//
	// If gtk_window_parse_geometry() returns true, it will also set the
	// K_HINT_USER_POS and/or K_HINT_USER_SIZE hints indicating to the window
	// manager that the size/position of the window was user-specified. This
	// causes most window managers to honor the geometry.
	//
	// Note that for gtk_window_parse_geometry() to work as expected, it has to
	// be called when the window has its “final” size, i.e. after calling
	// gtk_widget_show_all() on the contents and gtk_window_set_geometry_hints()
	// on the window.
	//
	//    #include <gtk/gtk.h>
	//
	//    static void
	//    fill_with_content (GtkWidget *vbox)
	//    {
	//      // fill with content...
	//    }
	//
	//    int
	//    main (int argc, char *argv[])
	//    {
	//      GtkWidget *window, *vbox;
	//      GdkGeometry size_hints = {
	//        100, 50, 0, 0, 100, 50, 10,
	//        10, 0.0, 0.0, GDK_GRAVITY_NORTH_WEST
	//      };
	//
	//      gtk_init (&argc, &argv);
	//
	//      window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
	//      vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
	//
	//      gtk_container_add (GTK_CONTAINER (window), vbox);
	//      fill_with_content (vbox);
	//      gtk_widget_show_all (vbox);
	//
	//      gtk_window_set_geometry_hints (GTK_WINDOW (window),
	//    	  			    NULL,
	//    				    &size_hints,
	//    				    GDK_HINT_MIN_SIZE |
	//    				    GDK_HINT_BASE_SIZE |
	//    				    GDK_HINT_RESIZE_INC);
	//
	//      if (argc > 1)
	//        {
	//          gboolean res;
	//          res = gtk_window_parse_geometry (GTK_WINDOW (window),
	//                                           argv[1]);
	//          if (! res)
	//            fprintf (stderr,
	//                     "Failed to parse “s”\n",
	//                     argv[1]);
	//        }
	//
	//      gtk_widget_show_all (window);
	//      gtk_main ();
	//
	//      return 0;
	//    }
	ParseGeometry(geometry string) bool
	// Present presents a window to the user. This function should not be used
	// as when it is called, it is too late to gather a valid timestamp to allow
	// focus stealing prevention to work correctly.
	Present()
	// PresentWithTime presents a window to the user. This may mean raising the
	// window in the stacking order, deiconifying it, moving it to the current
	// desktop, and/or giving it the keyboard focus, possibly dependent on the
	// user’s platform, window manager, and preferences.
	//
	// If @window is hidden, this function calls gtk_widget_show() as well.
	//
	// This function should be used when the user tries to open a window that’s
	// already open. Say for example the preferences dialog is currently open,
	// and the user chooses Preferences from the menu a second time; use
	// gtk_window_present() to move the already-open dialog where the user can
	// see it.
	//
	// Presents a window to the user in response to a user interaction. The
	// timestamp should be gathered when the window was requested to be shown
	// (when clicking a link for example), rather than once the window is ready
	// to be shown.
	PresentWithTime(timestamp uint32)
	// PropagateKeyEvent: propagate a key press or release event to the focus
	// widget and up the focus container chain until a widget handles @event.
	// This is normally called by the default ::key_press_event and
	// ::key_release_event handlers for toplevel windows, however in some cases
	// it may be useful to call this directly when overriding the standard key
	// handling for a toplevel window.
	PropagateKeyEvent(event *gdk.EventKey) bool
	// RemoveAccelGroup reverses the effects of gtk_window_add_accel_group().
	RemoveAccelGroup(accelGroup AccelGroup)
	// RemoveMnemonic removes a mnemonic from this window.
	RemoveMnemonic(keyval uint, target Widget)
	// ReshowWithInitialSize hides @window, then reshows it, resetting the
	// default size and position of the window. Used by GUI builders only.
	ReshowWithInitialSize()
	// Resize resizes the window as if the user had done so, obeying geometry
	// constraints. The default geometry constraint is that windows may not be
	// smaller than their size request; to override this constraint, call
	// gtk_widget_set_size_request() to set the window's request to a smaller
	// value.
	//
	// If gtk_window_resize() is called before showing a window for the first
	// time, it overrides any default size set with
	// gtk_window_set_default_size().
	//
	// Windows may not be resized smaller than 1 by 1 pixels.
	//
	// When using client side decorations, GTK+ will do its best to adjust the
	// given size so that the resulting window size matches the requested size
	// without the title bar, borders and shadows added for the client side
	// decorations, but there is no guarantee that the result will be totally
	// accurate because these widgets added for client side decorations depend
	// on the theme and may not be realized or visible at the time
	// gtk_window_resize() is issued.
	//
	// If the GtkWindow has a titlebar widget (see gtk_window_set_titlebar()),
	// then typically, gtk_window_resize() will compensate for the height of the
	// titlebar widget only if the height is known when the resulting GtkWindow
	// configuration is issued. For example, if new widgets are added after the
	// GtkWindow configuration and cause the titlebar widget to grow in height,
	// this will result in a window content smaller that specified by
	// gtk_window_resize() and not a larger window.
	Resize(width int, height int)
	// ResizeGripIsVisible determines whether a resize grip is visible for the
	// specified window.
	ResizeGripIsVisible() bool
	// ResizeToGeometry: like gtk_window_resize(), but @width and @height are
	// interpreted in terms of the base size and increment set with
	// gtk_window_set_geometry_hints.
	ResizeToGeometry(width int, height int)
	// SetAcceptFocus windows may set a hint asking the desktop environment not
	// to receive the input focus. This function sets this hint.
	SetAcceptFocus(setting bool)
	// SetApplication sets or unsets the Application associated with the window.
	//
	// The application will be kept alive for at least as long as it has any
	// windows associated with it (see g_application_hold() for a way to keep it
	// alive without windows).
	//
	// Normally, the connection between the application and the window will
	// remain until the window is destroyed, but you can explicitly remove it by
	// setting the @application to nil.
	//
	// This is equivalent to calling gtk_application_remove_window() and/or
	// gtk_application_add_window() on the old/new applications as relevant.
	SetApplication(application Application)
	// SetAttachedTo marks @window as attached to @attach_widget. This creates a
	// logical binding between the window and the widget it belongs to, which is
	// used by GTK+ to propagate information such as styling or accessibility to
	// @window as if it was a children of @attach_widget.
	//
	// Examples of places where specifying this relation is useful are for
	// instance a Menu created by a ComboBox, a completion popup window created
	// by Entry or a typeahead search entry created by TreeView.
	//
	// Note that this function should not be confused with
	// gtk_window_set_transient_for(), which specifies a window manager relation
	// between two toplevels instead.
	//
	// Passing nil for @attach_widget detaches the window.
	SetAttachedTo(attachWidget Widget)
	// SetDecorated: by default, windows are decorated with a title bar, resize
	// controls, etc. Some [window managers][gtk-X11-arch] allow GTK+ to disable
	// these decorations, creating a borderless window. If you set the decorated
	// property to false using this function, GTK+ will do its best to convince
	// the window manager not to decorate the window. Depending on the system,
	// this function may not have any effect when called on a window that is
	// already visible, so you should call it before calling gtk_widget_show().
	//
	// On Windows, this function always works, since there’s no window manager
	// policy involved.
	SetDecorated(setting bool)
	// SetDefault: the default widget is the widget that’s activated when the
	// user presses Enter in a dialog (for example). This function sets or
	// unsets the default widget for a Window. When setting (rather than
	// unsetting) the default widget it’s generally easier to call
	// gtk_widget_grab_default() on the widget. Before making a widget the
	// default widget, you must call gtk_widget_set_can_default() on the widget
	// you’d like to make the default.
	SetDefault(defaultWidget Widget)
	// SetDefaultGeometry: like gtk_window_set_default_size(), but @width and
	// @height are interpreted in terms of the base size and increment set with
	// gtk_window_set_geometry_hints.
	SetDefaultGeometry(width int, height int)
	// SetDefaultSize sets the default size of a window. If the window’s
	// “natural” size (its size request) is larger than the default, the default
	// will be ignored. More generally, if the default size does not obey the
	// geometry hints for the window (gtk_window_set_geometry_hints() can be
	// used to set these explicitly), the default size will be clamped to the
	// nearest permitted size.
	//
	// Unlike gtk_widget_set_size_request(), which sets a size request for a
	// widget and thus would keep users from shrinking the window, this function
	// only sets the initial size, just as if the user had resized the window
	// themselves. Users can still shrink the window again as they normally
	// would. Setting a default size of -1 means to use the “natural” default
	// size (the size request of the window).
	//
	// For more control over a window’s initial size and how resizing works,
	// investigate gtk_window_set_geometry_hints().
	//
	// For some uses, gtk_window_resize() is a more appropriate function.
	// gtk_window_resize() changes the current size of the window, rather than
	// the size to be used on initial display. gtk_window_resize() always
	// affects the window itself, not the geometry widget.
	//
	// The default size of a window only affects the first time a window is
	// shown; if a window is hidden and re-shown, it will remember the size it
	// had prior to hiding, rather than using the default size.
	//
	// Windows can’t actually be 0x0 in size, they must be at least 1x1, but
	// passing 0 for @width and @height is OK, resulting in a 1x1 default size.
	//
	// If you use this function to reestablish a previously saved window size,
	// note that the appropriate size to save is the one returned by
	// gtk_window_get_size(). Using the window allocation directly will not work
	// in all circumstances and can lead to growing or shrinking windows.
	SetDefaultSize(width int, height int)
	// SetDeletable: by default, windows have a close button in the window
	// frame. Some [window managers][gtk-X11-arch] allow GTK+ to disable this
	// button. If you set the deletable property to false using this function,
	// GTK+ will do its best to convince the window manager not to show a close
	// button. Depending on the system, this function may not have any effect
	// when called on a window that is already visible, so you should call it
	// before calling gtk_widget_show().
	//
	// On Windows, this function always works, since there’s no window manager
	// policy involved.
	SetDeletable(setting bool)
	// SetDestroyWithParent: if @setting is true, then destroying the transient
	// parent of @window will also destroy @window itself. This is useful for
	// dialogs that shouldn’t persist beyond the lifetime of the main window
	// they're associated with, for example.
	SetDestroyWithParent(setting bool)
	// SetFocus: if @focus is not the current focus widget, and is focusable,
	// sets it as the focus widget for the window. If @focus is nil, unsets the
	// focus widget for this window. To set the focus to a particular widget in
	// the toplevel, it is usually more convenient to use
	// gtk_widget_grab_focus() instead of this function.
	SetFocus(focus Widget)
	// SetFocusOnMap windows may set a hint asking the desktop environment not
	// to receive the input focus when the window is mapped. This function sets
	// this hint.
	SetFocusOnMap(setting bool)
	// SetFocusVisible sets the Window:focus-visible property.
	SetFocusVisible(setting bool)
	// SetGeometryHints: this function sets up hints about how a window can be
	// resized by the user. You can set a minimum and maximum size; allowed
	// resize increments (e.g. for xterm, you can only resize by the size of a
	// character); aspect ratios; and more. See the Geometry struct.
	SetGeometryHints(geometryWidget Widget, geometry *gdk.Geometry, geomMask gdk.WindowHints)
	// SetGravity: window gravity defines the meaning of coordinates passed to
	// gtk_window_move(). See gtk_window_move() and Gravity for more details.
	//
	// The default window gravity is K_GRAVITY_NORTH_WEST which will typically
	// “do what you mean.”
	SetGravity(gravity gdk.Gravity)
	// SetHasResizeGrip sets whether @window has a corner resize grip.
	//
	// Note that the resize grip is only shown if the window is actually
	// resizable and not maximized. Use gtk_window_resize_grip_is_visible() to
	// find out if the resize grip is currently shown.
	SetHasResizeGrip(value bool)
	// SetHasUserRefCount tells GTK+ whether to drop its extra reference to the
	// window when gtk_widget_destroy() is called.
	//
	// This function is only exported for the benefit of language bindings which
	// may need to keep the window alive until their wrapper object is garbage
	// collected. There is no justification for ever calling this function in an
	// application.
	SetHasUserRefCount(setting bool)
	// SetHideTitlebarWhenMaximized: if @setting is true, then @window will
	// request that it’s titlebar should be hidden when maximized. This is
	// useful for windows that don’t convey any information other than the
	// application name in the titlebar, to put the available screen space to
	// better use. If the underlying window system does not support the request,
	// the setting will not have any effect.
	//
	// Note that custom titlebars set with gtk_window_set_titlebar() are not
	// affected by this. The application is in full control of their content and
	// visibility anyway.
	SetHideTitlebarWhenMaximized(setting bool)
	// SetIcon sets up the icon representing a Window. This icon is used when
	// the window is minimized (also known as iconified). Some window managers
	// or desktop environments may also place it in the window frame, or display
	// it in other contexts. On others, the icon is not used at all, so your
	// mileage may vary.
	//
	// The icon should be provided in whatever size it was naturally drawn; that
	// is, don’t scale the image before passing it to GTK+. Scaling is postponed
	// until the last minute, when the desired final size is known, to allow
	// best quality.
	//
	// If you have your icon hand-drawn in multiple sizes, use
	// gtk_window_set_icon_list(). Then the best size will be used.
	//
	// This function is equivalent to calling gtk_window_set_icon_list() with a
	// 1-element list.
	//
	// See also gtk_window_set_default_icon_list() to set the icon for all
	// windows in your application in one go.
	SetIcon(icon gdkpixbuf.Pixbuf)
	// SetIconFromFile sets the icon for @window. Warns on failure if @err is
	// nil.
	//
	// This function is equivalent to calling gtk_window_set_icon() with a
	// pixbuf created by loading the image from @filename.
	SetIconFromFile(filename string) error
	// SetIconList sets up the icon representing a Window. The icon is used when
	// the window is minimized (also known as iconified). Some window managers
	// or desktop environments may also place it in the window frame, or display
	// it in other contexts. On others, the icon is not used at all, so your
	// mileage may vary.
	//
	// gtk_window_set_icon_list() allows you to pass in the same icon in several
	// hand-drawn sizes. The list should contain the natural sizes your icon is
	// available in; that is, don’t scale the image before passing it to GTK+.
	// Scaling is postponed until the last minute, when the desired final size
	// is known, to allow best quality.
	//
	// By passing several sizes, you may improve the final image quality of the
	// icon, by reducing or eliminating automatic image scaling.
	//
	// Recommended sizes to provide: 16x16, 32x32, 48x48 at minimum, and larger
	// images (64x64, 128x128) if you have them.
	//
	// See also gtk_window_set_default_icon_list() to set the icon for all
	// windows in your application in one go.
	//
	// Note that transient windows (those who have been set transient for
	// another window using gtk_window_set_transient_for()) will inherit their
	// icon from their transient parent. So there’s no need to explicitly set
	// the icon on transient windows.
	SetIconList(list *glib.List)
	// SetIconName sets the icon for the window from a named themed icon. See
	// the docs for IconTheme for more details. On some platforms, the window
	// icon is not used at all.
	//
	// Note that this has nothing to do with the WM_ICON_NAME property which is
	// mentioned in the ICCCM.
	SetIconName(name string)
	// SetKeepAbove asks to keep @window above, so that it stays on top. Note
	// that you shouldn’t assume the window is definitely above afterward,
	// because other entities (e.g. the user or [window manager][gtk-X11-arch])
	// could not keep it above, and not all window managers support keeping
	// windows above. But normally the window will end kept above. Just don’t
	// write code that crashes if not.
	//
	// It’s permitted to call this function before showing a window, in which
	// case the window will be kept above when it appears onscreen initially.
	//
	// You can track the above state via the “window-state-event” signal on
	// Widget.
	//
	// Note that, according to the Extended Window Manager Hints Specification
	// (http://www.freedesktop.org/Standards/wm-spec), the above state is mainly
	// meant for user preferences and should not be used by applications e.g.
	// for drawing attention to their dialogs.
	SetKeepAbove(setting bool)
	// SetKeepBelow asks to keep @window below, so that it stays in bottom. Note
	// that you shouldn’t assume the window is definitely below afterward,
	// because other entities (e.g. the user or [window manager][gtk-X11-arch])
	// could not keep it below, and not all window managers support putting
	// windows below. But normally the window will be kept below. Just don’t
	// write code that crashes if not.
	//
	// It’s permitted to call this function before showing a window, in which
	// case the window will be kept below when it appears onscreen initially.
	//
	// You can track the below state via the “window-state-event” signal on
	// Widget.
	//
	// Note that, according to the Extended Window Manager Hints Specification
	// (http://www.freedesktop.org/Standards/wm-spec), the above state is mainly
	// meant for user preferences and should not be used by applications e.g.
	// for drawing attention to their dialogs.
	SetKeepBelow(setting bool)
	// SetMnemonicModifier sets the mnemonic modifier for this window.
	SetMnemonicModifier(modifier gdk.ModifierType)
	// SetMnemonicsVisible sets the Window:mnemonics-visible property.
	SetMnemonicsVisible(setting bool)
	// SetModal sets a window modal or non-modal. Modal windows prevent
	// interaction with other windows in the same application. To keep modal
	// dialogs on top of main application windows, use
	// gtk_window_set_transient_for() to make the dialog transient for the
	// parent; most [window managers][gtk-X11-arch] will then disallow lowering
	// the dialog below the parent.
	SetModal(modal bool)
	// SetOpacity: request the windowing system to make @window partially
	// transparent, with opacity 0 being fully transparent and 1 fully opaque.
	// (Values of the opacity parameter are clamped to the [0,1] range.) On X11
	// this has any effect only on X screens with a compositing manager running.
	// See gtk_widget_is_composited(). On Windows it should work always.
	//
	// Note that setting a window’s opacity after the window has been shown
	// causes it to flicker once on Windows.
	SetOpacity(opacity float64)
	// SetPosition sets a position constraint for this window. If the old or new
	// constraint is GTK_WIN_POS_CENTER_ALWAYS, this will also cause the window
	// to be repositioned to satisfy the new constraint.
	SetPosition(position WindowPosition)
	// SetResizable sets whether the user can resize a window. Windows are user
	// resizable by default.
	SetResizable(resizable bool)
	// SetRole: this function is only useful on X11, not with other GTK+
	// targets.
	//
	// In combination with the window title, the window role allows a [window
	// manager][gtk-X11-arch] to identify "the same" window when an application
	// is restarted. So for example you might set the “toolbox” role on your
	// app’s toolbox window, so that when the user restarts their session, the
	// window manager can put the toolbox back in the same place.
	//
	// If a window already has a unique title, you don’t need to set the role,
	// since the WM can use the title to identify the window when restoring the
	// session.
	SetRole(role string)
	// SetScreen sets the Screen where the @window is displayed; if the window
	// is already mapped, it will be unmapped, and then remapped on the new
	// screen.
	SetScreen(screen gdk.Screen)
	// SetSkipPagerHint windows may set a hint asking the desktop environment
	// not to display the window in the pager. This function sets this hint. (A
	// "pager" is any desktop navigation tool such as a workspace switcher that
	// displays a thumbnail representation of the windows on the screen.)
	SetSkipPagerHint(setting bool)
	// SetSkipTaskbarHint windows may set a hint asking the desktop environment
	// not to display the window in the task bar. This function sets this hint.
	SetSkipTaskbarHint(setting bool)
	// SetStartupID: startup notification identifiers are used by desktop
	// environment to track application startup, to provide user feedback and
	// other features. This function changes the corresponding property on the
	// underlying GdkWindow. Normally, startup identifier is managed
	// automatically and you should only use this function in special cases like
	// transferring focus from other processes. You should use this function
	// before calling gtk_window_present() or any equivalent function generating
	// a window map event.
	//
	// This function is only useful on X11, not with other GTK+ targets.
	SetStartupID(startupID string)
	// SetTitle sets the title of the Window. The title of a window will be
	// displayed in its title bar; on the X Window System, the title bar is
	// rendered by the [window manager][gtk-X11-arch], so exactly how the title
	// appears to users may vary according to a user’s exact configuration. The
	// title should help a user distinguish this window from other windows they
	// may have open. A good title might include the application name and
	// current document filename, for example.
	SetTitle(title string)
	// SetTitlebar sets a custom titlebar for @window.
	//
	// A typical widget used here is HeaderBar, as it provides various features
	// expected of a titlebar while allowing the addition of child widgets to
	// it.
	//
	// If you set a custom titlebar, GTK+ will do its best to convince the
	// window manager not to put its own titlebar on the window. Depending on
	// the system, this function may not work for a window that is already
	// visible, so you set the titlebar before calling gtk_widget_show().
	SetTitlebar(titlebar Widget)
	// SetTransientFor: dialog windows should be set transient for the main
	// application window they were spawned from. This allows [window
	// managers][gtk-X11-arch] to e.g. keep the dialog on top of the main
	// window, or center the dialog over the main window.
	// gtk_dialog_new_with_buttons() and other convenience functions in GTK+
	// will sometimes call gtk_window_set_transient_for() on your behalf.
	//
	// Passing nil for @parent unsets the current transient window.
	//
	// On Wayland, this function can also be used to attach a new K_WINDOW_POPUP
	// to a K_WINDOW_TOPLEVEL parent already mapped on screen so that the
	// K_WINDOW_POPUP will be created as a subsurface-based window
	// K_WINDOW_SUBSURFACE which can be positioned at will relatively to the
	// K_WINDOW_TOPLEVEL surface.
	//
	// On Windows, this function puts the child window on top of the parent,
	// much as the window manager would have done on X.
	SetTransientFor(parent Window)
	// SetTypeHint: by setting the type hint for the window, you allow the
	// window manager to decorate and handle the window in a way which is
	// suitable to the function of the window in your application.
	//
	// This function should be called before the window becomes visible.
	//
	// gtk_dialog_new_with_buttons() and other convenience functions in GTK+
	// will sometimes call gtk_window_set_type_hint() on your behalf.
	SetTypeHint(hint gdk.WindowTypeHint)
	// SetUrgencyHint windows may set a hint asking the desktop environment to
	// draw the users attention to the window. This function sets this hint.
	SetUrgencyHint(setting bool)
	// SetWmclass: don’t use this function. It sets the X Window System “class”
	// and “name” hints for a window. According to the ICCCM, you should always
	// set these to the same value for all windows in an application, and GTK+
	// sets them to that value by default, so calling this function is sort of
	// pointless. However, you may want to call gtk_window_set_role() on each
	// window in your application, for the benefit of the session manager.
	// Setting the role allows the window manager to restore window positions
	// when loading a saved session.
	SetWmclass(wmclassName string, wmclassClass string)
	// Stick asks to stick @window, which means that it will appear on all user
	// desktops. Note that you shouldn’t assume the window is definitely stuck
	// afterward, because other entities (e.g. the user or [window
	// manager][gtk-X11-arch] could unstick it again, and some window managers
	// do not support sticking windows. But normally the window will end up
	// stuck. Just don't write code that crashes if not.
	//
	// It’s permitted to call this function before showing a window.
	//
	// You can track stickiness via the “window-state-event” signal on Widget.
	Stick()
	// Unfullscreen asks to toggle off the fullscreen state for @window. Note
	// that you shouldn’t assume the window is definitely not full screen
	// afterward, because other entities (e.g. the user or [window
	// manager][gtk-X11-arch]) could fullscreen it again, and not all window
	// managers honor requests to unfullscreen windows. But normally the window
	// will end up restored to its normal state. Just don’t write code that
	// crashes if not.
	//
	// You can track the fullscreen state via the “window-state-event” signal on
	// Widget.
	Unfullscreen()
	// Unmaximize asks to unmaximize @window. Note that you shouldn’t assume the
	// window is definitely unmaximized afterward, because other entities (e.g.
	// the user or [window manager][gtk-X11-arch]) could maximize it again, and
	// not all window managers honor requests to unmaximize. But normally the
	// window will end up unmaximized. Just don’t write code that crashes if
	// not.
	//
	// You can track maximization via the “window-state-event” signal on Widget.
	Unmaximize()
	// Unstick asks to unstick @window, which means that it will appear on only
	// one of the user’s desktops. Note that you shouldn’t assume the window is
	// definitely unstuck afterward, because other entities (e.g. the user or
	// [window manager][gtk-X11-arch]) could stick it again. But normally the
	// window will end up stuck. Just don’t write code that crashes if not.
	//
	// You can track stickiness via the “window-state-event” signal on Widget.
	Unstick()
}

// window implements the Window interface.
type window struct {
	Bin
	Buildable
}

var _ Window = (*window)(nil)

// WrapWindow wraps a GObject to the right type. It is
// primarily used internally.
func WrapWindow(obj *externglib.Object) Window {
	return Window{
		Bin:       WrapBin(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalWindow(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapWindow(obj), nil
}

// NewWindow constructs a class Window.
func NewWindow(typ WindowType) Window {
	var arg1 C.GtkWindowType

	arg1 = (C.GtkWindowType)(typ)

	var cret C.GtkWindow
	var goret1 Window

	cret = C.gtk_window_new(typ)

	goret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Window)

	return goret1
}

// ActivateDefault activates the default widget for the window, unless the
// current focused widget has been configured to receive the default action
// (see gtk_widget_set_receives_default()), in which case the focused widget
// is activated.
func (w window) ActivateDefault() bool {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_window_activate_default(arg0)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// ActivateFocus activates the current focused widget within the window.
func (w window) ActivateFocus() bool {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_window_activate_focus(arg0)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// ActivateKey activates mnemonics and accelerators for this Window. This is
// normally called by the default ::key_press_event handler for toplevel
// windows, however in some cases it may be useful to call this directly
// when overriding the standard key handling for a toplevel window.
func (w window) ActivateKey(event *gdk.EventKey) bool {
	var arg0 *C.GtkWindow
	var arg1 *C.GdkEventKey

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkEventKey)(unsafe.Pointer(event.Native()))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_window_activate_key(arg0, event)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// AddAccelGroup: associate @accel_group with @window, such that calling
// gtk_accel_groups_activate() on @window will activate accelerators in
// @accel_group.
func (w window) AddAccelGroup(accelGroup AccelGroup) {
	var arg0 *C.GtkWindow
	var arg1 *C.GtkAccelGroup

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GtkAccelGroup)(unsafe.Pointer(accelGroup.Native()))

	C.gtk_window_add_accel_group(arg0, accelGroup)
}

// AddMnemonic adds a mnemonic to this window.
func (w window) AddMnemonic(keyval uint, target Widget) {
	var arg0 *C.GtkWindow
	var arg1 C.guint
	var arg2 *C.GtkWidget

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = C.guint(keyval)
	arg2 = (*C.GtkWidget)(unsafe.Pointer(target.Native()))

	C.gtk_window_add_mnemonic(arg0, keyval, target)
}

// BeginMoveDrag starts moving a window. This function is used if an
// application has window movement grips. When GDK can support it, the
// window movement will be done using the standard mechanism for the [window
// manager][gtk-X11-arch] or windowing system. Otherwise, GDK will try to
// emulate window movement, potentially not all that well, depending on the
// windowing system.
func (w window) BeginMoveDrag(button int, rootX int, rootY int, timestamp uint32) {
	var arg0 *C.GtkWindow
	var arg1 C.gint
	var arg2 C.gint
	var arg3 C.gint
	var arg4 C.guint32

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = C.gint(button)
	arg2 = C.gint(rootX)
	arg3 = C.gint(rootY)
	arg4 = C.guint32(timestamp)

	C.gtk_window_begin_move_drag(arg0, button, rootX, rootY, timestamp)
}

// BeginResizeDrag starts resizing a window. This function is used if an
// application has window resizing controls. When GDK can support it, the
// resize will be done using the standard mechanism for the [window
// manager][gtk-X11-arch] or windowing system. Otherwise, GDK will try to
// emulate window resizing, potentially not all that well, depending on the
// windowing system.
func (w window) BeginResizeDrag(edge gdk.WindowEdge, button int, rootX int, rootY int, timestamp uint32) {
	var arg0 *C.GtkWindow
	var arg1 C.GdkWindowEdge
	var arg2 C.gint
	var arg3 C.gint
	var arg4 C.gint
	var arg5 C.guint32

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (C.GdkWindowEdge)(edge)
	arg2 = C.gint(button)
	arg3 = C.gint(rootX)
	arg4 = C.gint(rootY)
	arg5 = C.guint32(timestamp)

	C.gtk_window_begin_resize_drag(arg0, edge, button, rootX, rootY, timestamp)
}

// Close requests that the window is closed, similar to what happens when a
// window manager close button is clicked.
//
// This function can be used with close buttons in custom titlebars.
func (w window) Close() {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_close(arg0)
}

// Deiconify asks to deiconify (i.e. unminimize) the specified @window. Note
// that you shouldn’t assume the window is definitely deiconified afterward,
// because other entities (e.g. the user or [window manager][gtk-X11-arch]))
// could iconify it again before your code which assumes deiconification
// gets to run.
//
// You can track iconification via the “window-state-event” signal on
// Widget.
func (w window) Deiconify() {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_deiconify(arg0)
}

// Fullscreen asks to place @window in the fullscreen state. Note that you
// shouldn’t assume the window is definitely full screen afterward, because
// other entities (e.g. the user or [window manager][gtk-X11-arch]) could
// unfullscreen it again, and not all window managers honor requests to
// fullscreen windows. But normally the window will end up fullscreen. Just
// don’t write code that crashes if not.
//
// You can track the fullscreen state via the “window-state-event” signal on
// Widget.
func (w window) Fullscreen() {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_fullscreen(arg0)
}

// FullscreenOnMonitor asks to place @window in the fullscreen state. Note
// that you shouldn't assume the window is definitely full screen afterward.
//
// You can track the fullscreen state via the "window-state-event" signal on
// Widget.
func (w window) FullscreenOnMonitor(screen gdk.Screen, monitor int) {
	var arg0 *C.GtkWindow
	var arg1 *C.GdkScreen
	var arg2 C.gint

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkScreen)(unsafe.Pointer(screen.Native()))
	arg2 = C.gint(monitor)

	C.gtk_window_fullscreen_on_monitor(arg0, screen, monitor)
}

// AcceptFocus gets the value set by gtk_window_set_accept_focus().
func (w window) AcceptFocus() bool {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_window_get_accept_focus(arg0)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// Application gets the Application associated with the window (if any).
func (w window) Application() Application {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret *C.GtkApplication
	var goret1 Application

	cret = C.gtk_window_get_application(arg0)

	goret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Application)

	return goret1
}

// AttachedTo fetches the attach widget for this window. See
// gtk_window_set_attached_to().
func (w window) AttachedTo() Widget {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret *C.GtkWidget
	var goret1 Widget

	cret = C.gtk_window_get_attached_to(arg0)

	goret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return goret1
}

// Decorated returns whether the window has been set to have decorations
// such as a title bar via gtk_window_set_decorated().
func (w window) Decorated() bool {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_window_get_decorated(arg0)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// DefaultSize gets the default size of the window. A value of -1 for the
// width or height indicates that a default size has not been explicitly set
// for that dimension, so the “natural” size of the window will be used.
func (w window) DefaultSize() (width int, height int) {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var arg1 *C.gint
	var ret1 int
	var arg2 *C.gint
	var ret2 int

	C.gtk_window_get_default_size(arg0, &arg1, &arg2)

	ret1 = *C.gint(arg1)
	ret2 = *C.gint(arg2)

	return ret1, ret2
}

// DefaultWidget returns the default widget for @window. See
// gtk_window_set_default() for more details.
func (w window) DefaultWidget() Widget {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret *C.GtkWidget
	var goret1 Widget

	cret = C.gtk_window_get_default_widget(arg0)

	goret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return goret1
}

// Deletable returns whether the window has been set to have a close button
// via gtk_window_set_deletable().
func (w window) Deletable() bool {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_window_get_deletable(arg0)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// DestroyWithParent returns whether the window will be destroyed with its
// transient parent. See gtk_window_set_destroy_with_parent ().
func (w window) DestroyWithParent() bool {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_window_get_destroy_with_parent(arg0)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// Focus retrieves the current focused widget within the window. Note that
// this is the widget that would have the focus if the toplevel window
// focused; if the toplevel window is not focused then `gtk_widget_has_focus
// (widget)` will not be true for the widget.
func (w window) Focus() Widget {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret *C.GtkWidget
	var goret1 Widget

	cret = C.gtk_window_get_focus(arg0)

	goret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return goret1
}

// FocusOnMap gets the value set by gtk_window_set_focus_on_map().
func (w window) FocusOnMap() bool {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_window_get_focus_on_map(arg0)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// FocusVisible gets the value of the Window:focus-visible property.
func (w window) FocusVisible() bool {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_window_get_focus_visible(arg0)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// Gravity gets the value set by gtk_window_set_gravity().
func (w window) Gravity() gdk.Gravity {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret C.GdkGravity
	var goret1 gdk.Gravity

	cret = C.gtk_window_get_gravity(arg0)

	goret1 = gdk.Gravity(cret)

	return goret1
}

// Group returns the group for @window or the default group, if @window is
// nil or if @window does not have an explicit window group.
func (w window) Group() WindowGroup {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret *C.GtkWindowGroup
	var goret1 WindowGroup

	cret = C.gtk_window_get_group(arg0)

	goret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(WindowGroup)

	return goret1
}

// HasResizeGrip determines whether the window may have a resize grip.
func (w window) HasResizeGrip() bool {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_window_get_has_resize_grip(arg0)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// HideTitlebarWhenMaximized returns whether the window has requested to
// have its titlebar hidden when maximized. See
// gtk_window_set_hide_titlebar_when_maximized ().
func (w window) HideTitlebarWhenMaximized() bool {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_window_get_hide_titlebar_when_maximized(arg0)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// Icon gets the value set by gtk_window_set_icon() (or if you've called
// gtk_window_set_icon_list(), gets the first icon in the icon list).
func (w window) Icon() gdkpixbuf.Pixbuf {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret *C.GdkPixbuf
	var goret1 gdkpixbuf.Pixbuf

	cret = C.gtk_window_get_icon(arg0)

	goret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(gdkpixbuf.Pixbuf)

	return goret1
}

// IconList retrieves the list of icons set by gtk_window_set_icon_list().
// The list is copied, but the reference count on each member won’t be
// incremented.
func (w window) IconList() *glib.List {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret *C.GList
	var goret1 *glib.List

	cret = C.gtk_window_get_icon_list(arg0)

	goret1 = glib.WrapList(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret1, func(v *glib.List) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret1
}

// IconName returns the name of the themed icon for the window, see
// gtk_window_set_icon_name().
func (w window) IconName() string {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret *C.gchar
	var goret1 string

	cret = C.gtk_window_get_icon_name(arg0)

	goret1 = C.GoString(cret)

	return goret1
}

// MnemonicModifier returns the mnemonic modifier for this window. See
// gtk_window_set_mnemonic_modifier().
func (w window) MnemonicModifier() gdk.ModifierType {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret C.GdkModifierType
	var goret1 gdk.ModifierType

	cret = C.gtk_window_get_mnemonic_modifier(arg0)

	goret1 = gdk.ModifierType(cret)

	return goret1
}

// MnemonicsVisible gets the value of the Window:mnemonics-visible property.
func (w window) MnemonicsVisible() bool {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_window_get_mnemonics_visible(arg0)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// Modal returns whether the window is modal. See gtk_window_set_modal().
func (w window) Modal() bool {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_window_get_modal(arg0)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// Opacity fetches the requested opacity for this window. See
// gtk_window_set_opacity().
func (w window) Opacity() float64 {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret C.gdouble
	var goret1 float64

	cret = C.gtk_window_get_opacity(arg0)

	goret1 = C.gdouble(cret)

	return goret1
}

// Position: this function returns the position you need to pass to
// gtk_window_move() to keep @window in its current position. This means
// that the meaning of the returned value varies with window gravity. See
// gtk_window_move() for more details.
//
// The reliability of this function depends on the windowing system
// currently in use. Some windowing systems, such as Wayland, do not support
// a global coordinate system, and thus the position of the window will
// always be (0, 0). Others, like X11, do not have a reliable way to obtain
// the geometry of the decorations of a window if they are provided by the
// window manager. Additionally, on X11, window manager have been known to
// mismanage window gravity, which result in windows moving even if you use
// the coordinates of the current position as returned by this function.
//
// If you haven’t changed the window gravity, its gravity will be
// K_GRAVITY_NORTH_WEST. This means that gtk_window_get_position() gets the
// position of the top-left corner of the window manager frame for the
// window. gtk_window_move() sets the position of this same top-left corner.
//
// If a window has gravity K_GRAVITY_STATIC the window manager frame is not
// relevant, and thus gtk_window_get_position() will always produce accurate
// results. However you can’t use static gravity to do things like place a
// window in a corner of the screen, because static gravity ignores the
// window manager decorations.
//
// Ideally, this function should return appropriate values if the window has
// client side decorations, assuming that the windowing system supports
// global coordinates.
//
// In practice, saving the window position should not be left to
// applications, as they lack enough knowledge of the windowing system and
// the window manager state to effectively do so. The appropriate way to
// implement saving the window position is to use a platform-specific
// protocol, wherever that is available.
func (w window) Position() (rootX int, rootY int) {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var arg1 *C.gint
	var ret1 int
	var arg2 *C.gint
	var ret2 int

	C.gtk_window_get_position(arg0, &arg1, &arg2)

	ret1 = *C.gint(arg1)
	ret2 = *C.gint(arg2)

	return ret1, ret2
}

// Resizable gets the value set by gtk_window_set_resizable().
func (w window) Resizable() bool {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_window_get_resizable(arg0)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// ResizeGripArea: if a window has a resize grip, this will retrieve the
// grip position, width and height into the specified Rectangle.
func (w window) ResizeGripArea() (rect gdk.Rectangle, ok bool) {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var arg1 *C.GdkRectangle
	var ret1 *gdk.Rectangle
	var cret C.gboolean
	var goret2 bool

	cret = C.gtk_window_get_resize_grip_area(arg0, &arg1)

	ret1 = gdk.WrapRectangle(unsafe.Pointer(arg1))
	goret2 = C.bool(cret) != C.false

	return ret1, goret2
}

// Role returns the role of the window. See gtk_window_set_role() for
// further explanation.
func (w window) Role() string {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret *C.gchar
	var goret1 string

	cret = C.gtk_window_get_role(arg0)

	goret1 = C.GoString(cret)

	return goret1
}

// Screen returns the Screen associated with @window.
func (w window) Screen() gdk.Screen {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret *C.GdkScreen
	var goret1 gdk.Screen

	cret = C.gtk_window_get_screen(arg0)

	goret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(gdk.Screen)

	return goret1
}

// Size obtains the current size of @window.
//
// If @window is not visible on screen, this function return the size GTK+
// will suggest to the [window manager][gtk-X11-arch] for the initial window
// size (but this is not reliably the same as the size the window manager
// will actually select). See: gtk_window_set_default_size().
//
// Depending on the windowing system and the window manager constraints, the
// size returned by this function may not match the size set using
// gtk_window_resize(); additionally, since gtk_window_resize() may be
// implemented as an asynchronous operation, GTK+ cannot guarantee in any
// way that this code:
//
//    static void
//    on_size_allocate (GtkWidget *widget, GtkAllocation *allocation)
//    {
//      int new_width, new_height;
//
//      gtk_window_get_size (GTK_WINDOW (widget), &new_width, &new_height);
//
//      ...
//    }
//
// Note that, if you connect to the Widget::size-allocate signal, you should
// not use the dimensions of the Allocation passed to the signal handler, as
// the allocation may contain client side decorations added by GTK+,
// depending on the windowing system in use.
//
// If you are getting a window size in order to position the window on the
// screen, you should, instead, simply set the window’s semantic type with
// gtk_window_set_type_hint(), which allows the window manager to e.g.
// center dialogs. Also, if you set the transient parent of dialogs with
// gtk_window_set_transient_for() window managers will often center the
// dialog over its parent window. It's much preferred to let the window
// manager handle these cases rather than doing it yourself, because all
// apps will behave consistently and according to user or system
// preferences, if the window manager handles it. Also, the window manager
// can take into account the size of the window decorations and border that
// it may add, and of which GTK+ has no knowledge. Additionally, positioning
// windows in global screen coordinates may not be allowed by the windowing
// system. For more information, see: gtk_window_set_position().
func (w window) Size() (width int, height int) {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var arg1 *C.gint
	var ret1 int
	var arg2 *C.gint
	var ret2 int

	C.gtk_window_get_size(arg0, &arg1, &arg2)

	ret1 = *C.gint(arg1)
	ret2 = *C.gint(arg2)

	return ret1, ret2
}

// SkipPagerHint gets the value set by gtk_window_set_skip_pager_hint().
func (w window) SkipPagerHint() bool {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_window_get_skip_pager_hint(arg0)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// SkipTaskbarHint gets the value set by gtk_window_set_skip_taskbar_hint()
func (w window) SkipTaskbarHint() bool {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_window_get_skip_taskbar_hint(arg0)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// Title retrieves the title of the window. See gtk_window_set_title().
func (w window) Title() string {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret *C.gchar
	var goret1 string

	cret = C.gtk_window_get_title(arg0)

	goret1 = C.GoString(cret)

	return goret1
}

// Titlebar returns the custom titlebar that has been set with
// gtk_window_set_titlebar().
func (w window) Titlebar() Widget {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret *C.GtkWidget
	var goret1 Widget

	cret = C.gtk_window_get_titlebar(arg0)

	goret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return goret1
}

// TransientFor fetches the transient parent for this window. See
// gtk_window_set_transient_for().
func (w window) TransientFor() Window {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret *C.GtkWindow
	var goret1 Window

	cret = C.gtk_window_get_transient_for(arg0)

	goret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Window)

	return goret1
}

// TypeHint gets the type hint for this window. See
// gtk_window_set_type_hint().
func (w window) TypeHint() gdk.WindowTypeHint {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret C.GdkWindowTypeHint
	var goret1 gdk.WindowTypeHint

	cret = C.gtk_window_get_type_hint(arg0)

	goret1 = gdk.WindowTypeHint(cret)

	return goret1
}

// UrgencyHint gets the value set by gtk_window_set_urgency_hint()
func (w window) UrgencyHint() bool {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_window_get_urgency_hint(arg0)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// WindowType gets the type of the window. See WindowType.
func (w window) WindowType() WindowType {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret C.GtkWindowType
	var goret1 WindowType

	cret = C.gtk_window_get_window_type(arg0)

	goret1 = WindowType(cret)

	return goret1
}

// HasGroup returns whether @window has an explicit window group.
func (w window) HasGroup() bool {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_window_has_group(arg0)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// HasToplevelFocus returns whether the input focus is within this
// GtkWindow. For real toplevel windows, this is identical to
// gtk_window_is_active(), but for embedded windows, like Plug, the results
// will differ.
func (w window) HasToplevelFocus() bool {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_window_has_toplevel_focus(arg0)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// Iconify asks to iconify (i.e. minimize) the specified @window. Note that
// you shouldn’t assume the window is definitely iconified afterward,
// because other entities (e.g. the user or [window manager][gtk-X11-arch])
// could deiconify it again, or there may not be a window manager in which
// case iconification isn’t possible, etc. But normally the window will end
// up iconified. Just don’t write code that crashes if not.
//
// It’s permitted to call this function before showing a window, in which
// case the window will be iconified before it ever appears onscreen.
//
// You can track iconification via the “window-state-event” signal on
// Widget.
func (w window) Iconify() {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_iconify(arg0)
}

// IsActive returns whether the window is part of the current active
// toplevel. (That is, the toplevel window receiving keystrokes.) The return
// value is true if the window is active toplevel itself, but also if it is,
// say, a Plug embedded in the active toplevel. You might use this function
// if you wanted to draw a widget differently in an active window from a
// widget in an inactive window. See gtk_window_has_toplevel_focus()
func (w window) IsActive() bool {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_window_is_active(arg0)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// IsMaximized retrieves the current maximized state of @window.
//
// Note that since maximization is ultimately handled by the window manager
// and happens asynchronously to an application request, you shouldn’t
// assume the return value of this function changing immediately (or at
// all), as an effect of calling gtk_window_maximize() or
// gtk_window_unmaximize().
func (w window) IsMaximized() bool {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_window_is_maximized(arg0)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// Maximize asks to maximize @window, so that it becomes full-screen. Note
// that you shouldn’t assume the window is definitely maximized afterward,
// because other entities (e.g. the user or [window manager][gtk-X11-arch])
// could unmaximize it again, and not all window managers support
// maximization. But normally the window will end up maximized. Just don’t
// write code that crashes if not.
//
// It’s permitted to call this function before showing a window, in which
// case the window will be maximized when it appears onscreen initially.
//
// You can track maximization via the “window-state-event” signal on Widget,
// or by listening to notifications on the Window:is-maximized property.
func (w window) Maximize() {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_maximize(arg0)
}

// MnemonicActivate activates the targets associated with the mnemonic.
func (w window) MnemonicActivate(keyval uint, modifier gdk.ModifierType) bool {
	var arg0 *C.GtkWindow
	var arg1 C.guint
	var arg2 C.GdkModifierType

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = C.guint(keyval)
	arg2 = (C.GdkModifierType)(modifier)

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_window_mnemonic_activate(arg0, keyval, modifier)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// Move asks the [window manager][gtk-X11-arch] to move @window to the given
// position. Window managers are free to ignore this; most window managers
// ignore requests for initial window positions (instead using a
// user-defined placement algorithm) and honor requests after the window has
// already been shown.
//
// Note: the position is the position of the gravity-determined reference
// point for the window. The gravity determines two things: first, the
// location of the reference point in root window coordinates; and second,
// which point on the window is positioned at the reference point.
//
// By default the gravity is K_GRAVITY_NORTH_WEST, so the reference point is
// simply the @x, @y supplied to gtk_window_move(). The top-left corner of
// the window decorations (aka window frame or border) will be placed at @x,
// @y. Therefore, to position a window at the top left of the screen, you
// want to use the default gravity (which is K_GRAVITY_NORTH_WEST) and move
// the window to 0,0.
//
// To position a window at the bottom right corner of the screen, you would
// set K_GRAVITY_SOUTH_EAST, which means that the reference point is at @x +
// the window width and @y + the window height, and the bottom-right corner
// of the window border will be placed at that reference point. So, to place
// a window in the bottom right corner you would first set gravity to south
// east, then write: `gtk_window_move (window, gdk_screen_width () -
// window_width, gdk_screen_height () - window_height)` (note that this
// example does not take multi-head scenarios into account).
//
// The Extended Window Manager Hints Specification
// (http://www.freedesktop.org/Standards/wm-spec) has a nice table of
// gravities in the “implementation notes” section.
//
// The gtk_window_get_position() documentation may also be relevant.
func (w window) Move(x int, y int) {
	var arg0 *C.GtkWindow
	var arg1 C.gint
	var arg2 C.gint

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = C.gint(x)
	arg2 = C.gint(y)

	C.gtk_window_move(arg0, x, y)
}

// ParseGeometry parses a standard X Window System geometry string - see the
// manual page for X (type “man X”) for details on this.
// gtk_window_parse_geometry() does work on all GTK+ ports including Win32
// but is primarily intended for an X environment.
//
// If either a size or a position can be extracted from the geometry string,
// gtk_window_parse_geometry() returns true and calls
// gtk_window_set_default_size() and/or gtk_window_move() to resize/move the
// window.
//
// If gtk_window_parse_geometry() returns true, it will also set the
// K_HINT_USER_POS and/or K_HINT_USER_SIZE hints indicating to the window
// manager that the size/position of the window was user-specified. This
// causes most window managers to honor the geometry.
//
// Note that for gtk_window_parse_geometry() to work as expected, it has to
// be called when the window has its “final” size, i.e. after calling
// gtk_widget_show_all() on the contents and gtk_window_set_geometry_hints()
// on the window.
//
//    #include <gtk/gtk.h>
//
//    static void
//    fill_with_content (GtkWidget *vbox)
//    {
//      // fill with content...
//    }
//
//    int
//    main (int argc, char *argv[])
//    {
//      GtkWidget *window, *vbox;
//      GdkGeometry size_hints = {
//        100, 50, 0, 0, 100, 50, 10,
//        10, 0.0, 0.0, GDK_GRAVITY_NORTH_WEST
//      };
//
//      gtk_init (&argc, &argv);
//
//      window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
//      vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
//
//      gtk_container_add (GTK_CONTAINER (window), vbox);
//      fill_with_content (vbox);
//      gtk_widget_show_all (vbox);
//
//      gtk_window_set_geometry_hints (GTK_WINDOW (window),
//    	  			    NULL,
//    				    &size_hints,
//    				    GDK_HINT_MIN_SIZE |
//    				    GDK_HINT_BASE_SIZE |
//    				    GDK_HINT_RESIZE_INC);
//
//      if (argc > 1)
//        {
//          gboolean res;
//          res = gtk_window_parse_geometry (GTK_WINDOW (window),
//                                           argv[1]);
//          if (! res)
//            fprintf (stderr,
//                     "Failed to parse “s”\n",
//                     argv[1]);
//        }
//
//      gtk_widget_show_all (window);
//      gtk_main ();
//
//      return 0;
//    }
func (w window) ParseGeometry(geometry string) bool {
	var arg0 *C.GtkWindow
	var arg1 *C.gchar

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.gchar)(C.CString(geometry))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_window_parse_geometry(arg0, geometry)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// Present presents a window to the user. This function should not be used
// as when it is called, it is too late to gather a valid timestamp to allow
// focus stealing prevention to work correctly.
func (w window) Present() {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_present(arg0)
}

// PresentWithTime presents a window to the user. This may mean raising the
// window in the stacking order, deiconifying it, moving it to the current
// desktop, and/or giving it the keyboard focus, possibly dependent on the
// user’s platform, window manager, and preferences.
//
// If @window is hidden, this function calls gtk_widget_show() as well.
//
// This function should be used when the user tries to open a window that’s
// already open. Say for example the preferences dialog is currently open,
// and the user chooses Preferences from the menu a second time; use
// gtk_window_present() to move the already-open dialog where the user can
// see it.
//
// Presents a window to the user in response to a user interaction. The
// timestamp should be gathered when the window was requested to be shown
// (when clicking a link for example), rather than once the window is ready
// to be shown.
func (w window) PresentWithTime(timestamp uint32) {
	var arg0 *C.GtkWindow
	var arg1 C.guint32

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = C.guint32(timestamp)

	C.gtk_window_present_with_time(arg0, timestamp)
}

// PropagateKeyEvent: propagate a key press or release event to the focus
// widget and up the focus container chain until a widget handles @event.
// This is normally called by the default ::key_press_event and
// ::key_release_event handlers for toplevel windows, however in some cases
// it may be useful to call this directly when overriding the standard key
// handling for a toplevel window.
func (w window) PropagateKeyEvent(event *gdk.EventKey) bool {
	var arg0 *C.GtkWindow
	var arg1 *C.GdkEventKey

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkEventKey)(unsafe.Pointer(event.Native()))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_window_propagate_key_event(arg0, event)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// RemoveAccelGroup reverses the effects of gtk_window_add_accel_group().
func (w window) RemoveAccelGroup(accelGroup AccelGroup) {
	var arg0 *C.GtkWindow
	var arg1 *C.GtkAccelGroup

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GtkAccelGroup)(unsafe.Pointer(accelGroup.Native()))

	C.gtk_window_remove_accel_group(arg0, accelGroup)
}

// RemoveMnemonic removes a mnemonic from this window.
func (w window) RemoveMnemonic(keyval uint, target Widget) {
	var arg0 *C.GtkWindow
	var arg1 C.guint
	var arg2 *C.GtkWidget

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = C.guint(keyval)
	arg2 = (*C.GtkWidget)(unsafe.Pointer(target.Native()))

	C.gtk_window_remove_mnemonic(arg0, keyval, target)
}

// ReshowWithInitialSize hides @window, then reshows it, resetting the
// default size and position of the window. Used by GUI builders only.
func (w window) ReshowWithInitialSize() {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_reshow_with_initial_size(arg0)
}

// Resize resizes the window as if the user had done so, obeying geometry
// constraints. The default geometry constraint is that windows may not be
// smaller than their size request; to override this constraint, call
// gtk_widget_set_size_request() to set the window's request to a smaller
// value.
//
// If gtk_window_resize() is called before showing a window for the first
// time, it overrides any default size set with
// gtk_window_set_default_size().
//
// Windows may not be resized smaller than 1 by 1 pixels.
//
// When using client side decorations, GTK+ will do its best to adjust the
// given size so that the resulting window size matches the requested size
// without the title bar, borders and shadows added for the client side
// decorations, but there is no guarantee that the result will be totally
// accurate because these widgets added for client side decorations depend
// on the theme and may not be realized or visible at the time
// gtk_window_resize() is issued.
//
// If the GtkWindow has a titlebar widget (see gtk_window_set_titlebar()),
// then typically, gtk_window_resize() will compensate for the height of the
// titlebar widget only if the height is known when the resulting GtkWindow
// configuration is issued. For example, if new widgets are added after the
// GtkWindow configuration and cause the titlebar widget to grow in height,
// this will result in a window content smaller that specified by
// gtk_window_resize() and not a larger window.
func (w window) Resize(width int, height int) {
	var arg0 *C.GtkWindow
	var arg1 C.gint
	var arg2 C.gint

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = C.gint(width)
	arg2 = C.gint(height)

	C.gtk_window_resize(arg0, width, height)
}

// ResizeGripIsVisible determines whether a resize grip is visible for the
// specified window.
func (w window) ResizeGripIsVisible() bool {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_window_resize_grip_is_visible(arg0)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// ResizeToGeometry: like gtk_window_resize(), but @width and @height are
// interpreted in terms of the base size and increment set with
// gtk_window_set_geometry_hints.
func (w window) ResizeToGeometry(width int, height int) {
	var arg0 *C.GtkWindow
	var arg1 C.gint
	var arg2 C.gint

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = C.gint(width)
	arg2 = C.gint(height)

	C.gtk_window_resize_to_geometry(arg0, width, height)
}

// SetAcceptFocus windows may set a hint asking the desktop environment not
// to receive the input focus. This function sets this hint.
func (w window) SetAcceptFocus(setting bool) {
	var arg0 *C.GtkWindow
	var arg1 C.gboolean

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_window_set_accept_focus(arg0, setting)
}

// SetApplication sets or unsets the Application associated with the window.
//
// The application will be kept alive for at least as long as it has any
// windows associated with it (see g_application_hold() for a way to keep it
// alive without windows).
//
// Normally, the connection between the application and the window will
// remain until the window is destroyed, but you can explicitly remove it by
// setting the @application to nil.
//
// This is equivalent to calling gtk_application_remove_window() and/or
// gtk_application_add_window() on the old/new applications as relevant.
func (w window) SetApplication(application Application) {
	var arg0 *C.GtkWindow
	var arg1 *C.GtkApplication

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GtkApplication)(unsafe.Pointer(application.Native()))

	C.gtk_window_set_application(arg0, application)
}

// SetAttachedTo marks @window as attached to @attach_widget. This creates a
// logical binding between the window and the widget it belongs to, which is
// used by GTK+ to propagate information such as styling or accessibility to
// @window as if it was a children of @attach_widget.
//
// Examples of places where specifying this relation is useful are for
// instance a Menu created by a ComboBox, a completion popup window created
// by Entry or a typeahead search entry created by TreeView.
//
// Note that this function should not be confused with
// gtk_window_set_transient_for(), which specifies a window manager relation
// between two toplevels instead.
//
// Passing nil for @attach_widget detaches the window.
func (w window) SetAttachedTo(attachWidget Widget) {
	var arg0 *C.GtkWindow
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(attachWidget.Native()))

	C.gtk_window_set_attached_to(arg0, attachWidget)
}

// SetDecorated: by default, windows are decorated with a title bar, resize
// controls, etc. Some [window managers][gtk-X11-arch] allow GTK+ to disable
// these decorations, creating a borderless window. If you set the decorated
// property to false using this function, GTK+ will do its best to convince
// the window manager not to decorate the window. Depending on the system,
// this function may not have any effect when called on a window that is
// already visible, so you should call it before calling gtk_widget_show().
//
// On Windows, this function always works, since there’s no window manager
// policy involved.
func (w window) SetDecorated(setting bool) {
	var arg0 *C.GtkWindow
	var arg1 C.gboolean

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_window_set_decorated(arg0, setting)
}

// SetDefault: the default widget is the widget that’s activated when the
// user presses Enter in a dialog (for example). This function sets or
// unsets the default widget for a Window. When setting (rather than
// unsetting) the default widget it’s generally easier to call
// gtk_widget_grab_default() on the widget. Before making a widget the
// default widget, you must call gtk_widget_set_can_default() on the widget
// you’d like to make the default.
func (w window) SetDefault(defaultWidget Widget) {
	var arg0 *C.GtkWindow
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(defaultWidget.Native()))

	C.gtk_window_set_default(arg0, defaultWidget)
}

// SetDefaultGeometry: like gtk_window_set_default_size(), but @width and
// @height are interpreted in terms of the base size and increment set with
// gtk_window_set_geometry_hints.
func (w window) SetDefaultGeometry(width int, height int) {
	var arg0 *C.GtkWindow
	var arg1 C.gint
	var arg2 C.gint

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = C.gint(width)
	arg2 = C.gint(height)

	C.gtk_window_set_default_geometry(arg0, width, height)
}

// SetDefaultSize sets the default size of a window. If the window’s
// “natural” size (its size request) is larger than the default, the default
// will be ignored. More generally, if the default size does not obey the
// geometry hints for the window (gtk_window_set_geometry_hints() can be
// used to set these explicitly), the default size will be clamped to the
// nearest permitted size.
//
// Unlike gtk_widget_set_size_request(), which sets a size request for a
// widget and thus would keep users from shrinking the window, this function
// only sets the initial size, just as if the user had resized the window
// themselves. Users can still shrink the window again as they normally
// would. Setting a default size of -1 means to use the “natural” default
// size (the size request of the window).
//
// For more control over a window’s initial size and how resizing works,
// investigate gtk_window_set_geometry_hints().
//
// For some uses, gtk_window_resize() is a more appropriate function.
// gtk_window_resize() changes the current size of the window, rather than
// the size to be used on initial display. gtk_window_resize() always
// affects the window itself, not the geometry widget.
//
// The default size of a window only affects the first time a window is
// shown; if a window is hidden and re-shown, it will remember the size it
// had prior to hiding, rather than using the default size.
//
// Windows can’t actually be 0x0 in size, they must be at least 1x1, but
// passing 0 for @width and @height is OK, resulting in a 1x1 default size.
//
// If you use this function to reestablish a previously saved window size,
// note that the appropriate size to save is the one returned by
// gtk_window_get_size(). Using the window allocation directly will not work
// in all circumstances and can lead to growing or shrinking windows.
func (w window) SetDefaultSize(width int, height int) {
	var arg0 *C.GtkWindow
	var arg1 C.gint
	var arg2 C.gint

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = C.gint(width)
	arg2 = C.gint(height)

	C.gtk_window_set_default_size(arg0, width, height)
}

// SetDeletable: by default, windows have a close button in the window
// frame. Some [window managers][gtk-X11-arch] allow GTK+ to disable this
// button. If you set the deletable property to false using this function,
// GTK+ will do its best to convince the window manager not to show a close
// button. Depending on the system, this function may not have any effect
// when called on a window that is already visible, so you should call it
// before calling gtk_widget_show().
//
// On Windows, this function always works, since there’s no window manager
// policy involved.
func (w window) SetDeletable(setting bool) {
	var arg0 *C.GtkWindow
	var arg1 C.gboolean

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_window_set_deletable(arg0, setting)
}

// SetDestroyWithParent: if @setting is true, then destroying the transient
// parent of @window will also destroy @window itself. This is useful for
// dialogs that shouldn’t persist beyond the lifetime of the main window
// they're associated with, for example.
func (w window) SetDestroyWithParent(setting bool) {
	var arg0 *C.GtkWindow
	var arg1 C.gboolean

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_window_set_destroy_with_parent(arg0, setting)
}

// SetFocus: if @focus is not the current focus widget, and is focusable,
// sets it as the focus widget for the window. If @focus is nil, unsets the
// focus widget for this window. To set the focus to a particular widget in
// the toplevel, it is usually more convenient to use
// gtk_widget_grab_focus() instead of this function.
func (w window) SetFocus(focus Widget) {
	var arg0 *C.GtkWindow
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(focus.Native()))

	C.gtk_window_set_focus(arg0, focus)
}

// SetFocusOnMap windows may set a hint asking the desktop environment not
// to receive the input focus when the window is mapped. This function sets
// this hint.
func (w window) SetFocusOnMap(setting bool) {
	var arg0 *C.GtkWindow
	var arg1 C.gboolean

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_window_set_focus_on_map(arg0, setting)
}

// SetFocusVisible sets the Window:focus-visible property.
func (w window) SetFocusVisible(setting bool) {
	var arg0 *C.GtkWindow
	var arg1 C.gboolean

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_window_set_focus_visible(arg0, setting)
}

// SetGeometryHints: this function sets up hints about how a window can be
// resized by the user. You can set a minimum and maximum size; allowed
// resize increments (e.g. for xterm, you can only resize by the size of a
// character); aspect ratios; and more. See the Geometry struct.
func (w window) SetGeometryHints(geometryWidget Widget, geometry *gdk.Geometry, geomMask gdk.WindowHints) {
	var arg0 *C.GtkWindow
	var arg1 *C.GtkWidget
	var arg2 *C.GdkGeometry
	var arg3 C.GdkWindowHints

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(geometryWidget.Native()))
	arg2 = (*C.GdkGeometry)(unsafe.Pointer(geometry.Native()))
	arg3 = (C.GdkWindowHints)(geomMask)

	C.gtk_window_set_geometry_hints(arg0, geometryWidget, geometry, geomMask)
}

// SetGravity: window gravity defines the meaning of coordinates passed to
// gtk_window_move(). See gtk_window_move() and Gravity for more details.
//
// The default window gravity is K_GRAVITY_NORTH_WEST which will typically
// “do what you mean.”
func (w window) SetGravity(gravity gdk.Gravity) {
	var arg0 *C.GtkWindow
	var arg1 C.GdkGravity

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (C.GdkGravity)(gravity)

	C.gtk_window_set_gravity(arg0, gravity)
}

// SetHasResizeGrip sets whether @window has a corner resize grip.
//
// Note that the resize grip is only shown if the window is actually
// resizable and not maximized. Use gtk_window_resize_grip_is_visible() to
// find out if the resize grip is currently shown.
func (w window) SetHasResizeGrip(value bool) {
	var arg0 *C.GtkWindow
	var arg1 C.gboolean

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if value {
		arg1 = C.gboolean(1)
	}

	C.gtk_window_set_has_resize_grip(arg0, value)
}

// SetHasUserRefCount tells GTK+ whether to drop its extra reference to the
// window when gtk_widget_destroy() is called.
//
// This function is only exported for the benefit of language bindings which
// may need to keep the window alive until their wrapper object is garbage
// collected. There is no justification for ever calling this function in an
// application.
func (w window) SetHasUserRefCount(setting bool) {
	var arg0 *C.GtkWindow
	var arg1 C.gboolean

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_window_set_has_user_ref_count(arg0, setting)
}

// SetHideTitlebarWhenMaximized: if @setting is true, then @window will
// request that it’s titlebar should be hidden when maximized. This is
// useful for windows that don’t convey any information other than the
// application name in the titlebar, to put the available screen space to
// better use. If the underlying window system does not support the request,
// the setting will not have any effect.
//
// Note that custom titlebars set with gtk_window_set_titlebar() are not
// affected by this. The application is in full control of their content and
// visibility anyway.
func (w window) SetHideTitlebarWhenMaximized(setting bool) {
	var arg0 *C.GtkWindow
	var arg1 C.gboolean

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_window_set_hide_titlebar_when_maximized(arg0, setting)
}

// SetIcon sets up the icon representing a Window. This icon is used when
// the window is minimized (also known as iconified). Some window managers
// or desktop environments may also place it in the window frame, or display
// it in other contexts. On others, the icon is not used at all, so your
// mileage may vary.
//
// The icon should be provided in whatever size it was naturally drawn; that
// is, don’t scale the image before passing it to GTK+. Scaling is postponed
// until the last minute, when the desired final size is known, to allow
// best quality.
//
// If you have your icon hand-drawn in multiple sizes, use
// gtk_window_set_icon_list(). Then the best size will be used.
//
// This function is equivalent to calling gtk_window_set_icon_list() with a
// 1-element list.
//
// See also gtk_window_set_default_icon_list() to set the icon for all
// windows in your application in one go.
func (w window) SetIcon(icon gdkpixbuf.Pixbuf) {
	var arg0 *C.GtkWindow
	var arg1 *C.GdkPixbuf

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkPixbuf)(unsafe.Pointer(icon.Native()))

	C.gtk_window_set_icon(arg0, icon)
}

// SetIconFromFile sets the icon for @window. Warns on failure if @err is
// nil.
//
// This function is equivalent to calling gtk_window_set_icon() with a
// pixbuf created by loading the image from @filename.
func (w window) SetIconFromFile(filename string) error {
	var arg0 *C.GtkWindow
	var arg1 *C.gchar
	var errout *C.GError

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	var goerr error

	C.gtk_window_set_icon_from_file(arg0, filename, &errout)

	if errout != nil {
		goerr = fmt.Errorf("%d: %s", errout.code, C.GoString(errout.message))
		C.g_error_free(errout)
	}

}

// SetIconList sets up the icon representing a Window. The icon is used when
// the window is minimized (also known as iconified). Some window managers
// or desktop environments may also place it in the window frame, or display
// it in other contexts. On others, the icon is not used at all, so your
// mileage may vary.
//
// gtk_window_set_icon_list() allows you to pass in the same icon in several
// hand-drawn sizes. The list should contain the natural sizes your icon is
// available in; that is, don’t scale the image before passing it to GTK+.
// Scaling is postponed until the last minute, when the desired final size
// is known, to allow best quality.
//
// By passing several sizes, you may improve the final image quality of the
// icon, by reducing or eliminating automatic image scaling.
//
// Recommended sizes to provide: 16x16, 32x32, 48x48 at minimum, and larger
// images (64x64, 128x128) if you have them.
//
// See also gtk_window_set_default_icon_list() to set the icon for all
// windows in your application in one go.
//
// Note that transient windows (those who have been set transient for
// another window using gtk_window_set_transient_for()) will inherit their
// icon from their transient parent. So there’s no need to explicitly set
// the icon on transient windows.
func (w window) SetIconList(list *glib.List) {
	var arg0 *C.GtkWindow
	var arg1 *C.GList

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GList)(unsafe.Pointer(list.Native()))

	C.gtk_window_set_icon_list(arg0, list)
}

// SetIconName sets the icon for the window from a named themed icon. See
// the docs for IconTheme for more details. On some platforms, the window
// icon is not used at all.
//
// Note that this has nothing to do with the WM_ICON_NAME property which is
// mentioned in the ICCCM.
func (w window) SetIconName(name string) {
	var arg0 *C.GtkWindow
	var arg1 *C.gchar

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_window_set_icon_name(arg0, name)
}

// SetKeepAbove asks to keep @window above, so that it stays on top. Note
// that you shouldn’t assume the window is definitely above afterward,
// because other entities (e.g. the user or [window manager][gtk-X11-arch])
// could not keep it above, and not all window managers support keeping
// windows above. But normally the window will end kept above. Just don’t
// write code that crashes if not.
//
// It’s permitted to call this function before showing a window, in which
// case the window will be kept above when it appears onscreen initially.
//
// You can track the above state via the “window-state-event” signal on
// Widget.
//
// Note that, according to the Extended Window Manager Hints Specification
// (http://www.freedesktop.org/Standards/wm-spec), the above state is mainly
// meant for user preferences and should not be used by applications e.g.
// for drawing attention to their dialogs.
func (w window) SetKeepAbove(setting bool) {
	var arg0 *C.GtkWindow
	var arg1 C.gboolean

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_window_set_keep_above(arg0, setting)
}

// SetKeepBelow asks to keep @window below, so that it stays in bottom. Note
// that you shouldn’t assume the window is definitely below afterward,
// because other entities (e.g. the user or [window manager][gtk-X11-arch])
// could not keep it below, and not all window managers support putting
// windows below. But normally the window will be kept below. Just don’t
// write code that crashes if not.
//
// It’s permitted to call this function before showing a window, in which
// case the window will be kept below when it appears onscreen initially.
//
// You can track the below state via the “window-state-event” signal on
// Widget.
//
// Note that, according to the Extended Window Manager Hints Specification
// (http://www.freedesktop.org/Standards/wm-spec), the above state is mainly
// meant for user preferences and should not be used by applications e.g.
// for drawing attention to their dialogs.
func (w window) SetKeepBelow(setting bool) {
	var arg0 *C.GtkWindow
	var arg1 C.gboolean

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_window_set_keep_below(arg0, setting)
}

// SetMnemonicModifier sets the mnemonic modifier for this window.
func (w window) SetMnemonicModifier(modifier gdk.ModifierType) {
	var arg0 *C.GtkWindow
	var arg1 C.GdkModifierType

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (C.GdkModifierType)(modifier)

	C.gtk_window_set_mnemonic_modifier(arg0, modifier)
}

// SetMnemonicsVisible sets the Window:mnemonics-visible property.
func (w window) SetMnemonicsVisible(setting bool) {
	var arg0 *C.GtkWindow
	var arg1 C.gboolean

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_window_set_mnemonics_visible(arg0, setting)
}

// SetModal sets a window modal or non-modal. Modal windows prevent
// interaction with other windows in the same application. To keep modal
// dialogs on top of main application windows, use
// gtk_window_set_transient_for() to make the dialog transient for the
// parent; most [window managers][gtk-X11-arch] will then disallow lowering
// the dialog below the parent.
func (w window) SetModal(modal bool) {
	var arg0 *C.GtkWindow
	var arg1 C.gboolean

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if modal {
		arg1 = C.gboolean(1)
	}

	C.gtk_window_set_modal(arg0, modal)
}

// SetOpacity: request the windowing system to make @window partially
// transparent, with opacity 0 being fully transparent and 1 fully opaque.
// (Values of the opacity parameter are clamped to the [0,1] range.) On X11
// this has any effect only on X screens with a compositing manager running.
// See gtk_widget_is_composited(). On Windows it should work always.
//
// Note that setting a window’s opacity after the window has been shown
// causes it to flicker once on Windows.
func (w window) SetOpacity(opacity float64) {
	var arg0 *C.GtkWindow
	var arg1 C.gdouble

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = C.gdouble(opacity)

	C.gtk_window_set_opacity(arg0, opacity)
}

// SetPosition sets a position constraint for this window. If the old or new
// constraint is GTK_WIN_POS_CENTER_ALWAYS, this will also cause the window
// to be repositioned to satisfy the new constraint.
func (w window) SetPosition(position WindowPosition) {
	var arg0 *C.GtkWindow
	var arg1 C.GtkWindowPosition

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (C.GtkWindowPosition)(position)

	C.gtk_window_set_position(arg0, position)
}

// SetResizable sets whether the user can resize a window. Windows are user
// resizable by default.
func (w window) SetResizable(resizable bool) {
	var arg0 *C.GtkWindow
	var arg1 C.gboolean

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if resizable {
		arg1 = C.gboolean(1)
	}

	C.gtk_window_set_resizable(arg0, resizable)
}

// SetRole: this function is only useful on X11, not with other GTK+
// targets.
//
// In combination with the window title, the window role allows a [window
// manager][gtk-X11-arch] to identify "the same" window when an application
// is restarted. So for example you might set the “toolbox” role on your
// app’s toolbox window, so that when the user restarts their session, the
// window manager can put the toolbox back in the same place.
//
// If a window already has a unique title, you don’t need to set the role,
// since the WM can use the title to identify the window when restoring the
// session.
func (w window) SetRole(role string) {
	var arg0 *C.GtkWindow
	var arg1 *C.gchar

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.gchar)(C.CString(role))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_window_set_role(arg0, role)
}

// SetScreen sets the Screen where the @window is displayed; if the window
// is already mapped, it will be unmapped, and then remapped on the new
// screen.
func (w window) SetScreen(screen gdk.Screen) {
	var arg0 *C.GtkWindow
	var arg1 *C.GdkScreen

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkScreen)(unsafe.Pointer(screen.Native()))

	C.gtk_window_set_screen(arg0, screen)
}

// SetSkipPagerHint windows may set a hint asking the desktop environment
// not to display the window in the pager. This function sets this hint. (A
// "pager" is any desktop navigation tool such as a workspace switcher that
// displays a thumbnail representation of the windows on the screen.)
func (w window) SetSkipPagerHint(setting bool) {
	var arg0 *C.GtkWindow
	var arg1 C.gboolean

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_window_set_skip_pager_hint(arg0, setting)
}

// SetSkipTaskbarHint windows may set a hint asking the desktop environment
// not to display the window in the task bar. This function sets this hint.
func (w window) SetSkipTaskbarHint(setting bool) {
	var arg0 *C.GtkWindow
	var arg1 C.gboolean

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_window_set_skip_taskbar_hint(arg0, setting)
}

// SetStartupID: startup notification identifiers are used by desktop
// environment to track application startup, to provide user feedback and
// other features. This function changes the corresponding property on the
// underlying GdkWindow. Normally, startup identifier is managed
// automatically and you should only use this function in special cases like
// transferring focus from other processes. You should use this function
// before calling gtk_window_present() or any equivalent function generating
// a window map event.
//
// This function is only useful on X11, not with other GTK+ targets.
func (w window) SetStartupID(startupID string) {
	var arg0 *C.GtkWindow
	var arg1 *C.gchar

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.gchar)(C.CString(startupID))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_window_set_startup_id(arg0, startupID)
}

// SetTitle sets the title of the Window. The title of a window will be
// displayed in its title bar; on the X Window System, the title bar is
// rendered by the [window manager][gtk-X11-arch], so exactly how the title
// appears to users may vary according to a user’s exact configuration. The
// title should help a user distinguish this window from other windows they
// may have open. A good title might include the application name and
// current document filename, for example.
func (w window) SetTitle(title string) {
	var arg0 *C.GtkWindow
	var arg1 *C.gchar

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_window_set_title(arg0, title)
}

// SetTitlebar sets a custom titlebar for @window.
//
// A typical widget used here is HeaderBar, as it provides various features
// expected of a titlebar while allowing the addition of child widgets to
// it.
//
// If you set a custom titlebar, GTK+ will do its best to convince the
// window manager not to put its own titlebar on the window. Depending on
// the system, this function may not work for a window that is already
// visible, so you set the titlebar before calling gtk_widget_show().
func (w window) SetTitlebar(titlebar Widget) {
	var arg0 *C.GtkWindow
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(titlebar.Native()))

	C.gtk_window_set_titlebar(arg0, titlebar)
}

// SetTransientFor: dialog windows should be set transient for the main
// application window they were spawned from. This allows [window
// managers][gtk-X11-arch] to e.g. keep the dialog on top of the main
// window, or center the dialog over the main window.
// gtk_dialog_new_with_buttons() and other convenience functions in GTK+
// will sometimes call gtk_window_set_transient_for() on your behalf.
//
// Passing nil for @parent unsets the current transient window.
//
// On Wayland, this function can also be used to attach a new K_WINDOW_POPUP
// to a K_WINDOW_TOPLEVEL parent already mapped on screen so that the
// K_WINDOW_POPUP will be created as a subsurface-based window
// K_WINDOW_SUBSURFACE which can be positioned at will relatively to the
// K_WINDOW_TOPLEVEL surface.
//
// On Windows, this function puts the child window on top of the parent,
// much as the window manager would have done on X.
func (w window) SetTransientFor(parent Window) {
	var arg0 *C.GtkWindow
	var arg1 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))

	C.gtk_window_set_transient_for(arg0, parent)
}

// SetTypeHint: by setting the type hint for the window, you allow the
// window manager to decorate and handle the window in a way which is
// suitable to the function of the window in your application.
//
// This function should be called before the window becomes visible.
//
// gtk_dialog_new_with_buttons() and other convenience functions in GTK+
// will sometimes call gtk_window_set_type_hint() on your behalf.
func (w window) SetTypeHint(hint gdk.WindowTypeHint) {
	var arg0 *C.GtkWindow
	var arg1 C.GdkWindowTypeHint

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (C.GdkWindowTypeHint)(hint)

	C.gtk_window_set_type_hint(arg0, hint)
}

// SetUrgencyHint windows may set a hint asking the desktop environment to
// draw the users attention to the window. This function sets this hint.
func (w window) SetUrgencyHint(setting bool) {
	var arg0 *C.GtkWindow
	var arg1 C.gboolean

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_window_set_urgency_hint(arg0, setting)
}

// SetWmclass: don’t use this function. It sets the X Window System “class”
// and “name” hints for a window. According to the ICCCM, you should always
// set these to the same value for all windows in an application, and GTK+
// sets them to that value by default, so calling this function is sort of
// pointless. However, you may want to call gtk_window_set_role() on each
// window in your application, for the benefit of the session manager.
// Setting the role allows the window manager to restore window positions
// when loading a saved session.
func (w window) SetWmclass(wmclassName string, wmclassClass string) {
	var arg0 *C.GtkWindow
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.gchar)(C.CString(wmclassName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(wmclassClass))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_window_set_wmclass(arg0, wmclassName, wmclassClass)
}

// Stick asks to stick @window, which means that it will appear on all user
// desktops. Note that you shouldn’t assume the window is definitely stuck
// afterward, because other entities (e.g. the user or [window
// manager][gtk-X11-arch] could unstick it again, and some window managers
// do not support sticking windows. But normally the window will end up
// stuck. Just don't write code that crashes if not.
//
// It’s permitted to call this function before showing a window.
//
// You can track stickiness via the “window-state-event” signal on Widget.
func (w window) Stick() {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_stick(arg0)
}

// Unfullscreen asks to toggle off the fullscreen state for @window. Note
// that you shouldn’t assume the window is definitely not full screen
// afterward, because other entities (e.g. the user or [window
// manager][gtk-X11-arch]) could fullscreen it again, and not all window
// managers honor requests to unfullscreen windows. But normally the window
// will end up restored to its normal state. Just don’t write code that
// crashes if not.
//
// You can track the fullscreen state via the “window-state-event” signal on
// Widget.
func (w window) Unfullscreen() {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_unfullscreen(arg0)
}

// Unmaximize asks to unmaximize @window. Note that you shouldn’t assume the
// window is definitely unmaximized afterward, because other entities (e.g.
// the user or [window manager][gtk-X11-arch]) could maximize it again, and
// not all window managers honor requests to unmaximize. But normally the
// window will end up unmaximized. Just don’t write code that crashes if
// not.
//
// You can track maximization via the “window-state-event” signal on Widget.
func (w window) Unmaximize() {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_unmaximize(arg0)
}

// Unstick asks to unstick @window, which means that it will appear on only
// one of the user’s desktops. Note that you shouldn’t assume the window is
// definitely unstuck afterward, because other entities (e.g. the user or
// [window manager][gtk-X11-arch]) could stick it again. But normally the
// window will end up stuck. Just don’t write code that crashes if not.
//
// You can track stickiness via the “window-state-event” signal on Widget.
func (w window) Unstick() {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_unstick(arg0)
}

type WindowGeometryInfo struct {
	native C.GtkWindowGeometryInfo
}

// WrapWindowGeometryInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapWindowGeometryInfo(ptr unsafe.Pointer) *WindowGeometryInfo {
	if ptr == nil {
		return nil
	}

	return (*WindowGeometryInfo)(ptr)
}

func marshalWindowGeometryInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapWindowGeometryInfo(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (w *WindowGeometryInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&w.native)
}

type WindowGroupPrivate struct {
	native C.GtkWindowGroupPrivate
}

// WrapWindowGroupPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapWindowGroupPrivate(ptr unsafe.Pointer) *WindowGroupPrivate {
	if ptr == nil {
		return nil
	}

	return (*WindowGroupPrivate)(ptr)
}

func marshalWindowGroupPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapWindowGroupPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (w *WindowGroupPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&w.native)
}

type WindowPrivate struct {
	native C.GtkWindowPrivate
}

// WrapWindowPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapWindowPrivate(ptr unsafe.Pointer) *WindowPrivate {
	if ptr == nil {
		return nil
	}

	return (*WindowPrivate)(ptr)
}

func marshalWindowPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapWindowPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (w *WindowPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&w.native)
}
