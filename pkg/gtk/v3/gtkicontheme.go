// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk+-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_icon_theme_error_get_type()), F: marshalIconThemeError},
		{T: externglib.Type(C.gtk_icon_lookup_flags_get_type()), F: marshalIconLookupFlags},
		{T: externglib.Type(C.gtk_icon_info_get_type()), F: marshalIconInfor},
		{T: externglib.Type(C.gtk_icon_theme_get_type()), F: marshalIconThemer},
	})
}

// IconThemeError: error codes for GtkIconTheme operations.
type IconThemeError int

const (
	// NotFound: icon specified does not exist in the theme
	IconThemeErrorNotFound IconThemeError = iota
	// Failed: unspecified error occurred.
	IconThemeErrorFailed
)

func marshalIconThemeError(p uintptr) (interface{}, error) {
	return IconThemeError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconLookupFlags: used to specify options for gtk_icon_theme_lookup_icon()
type IconLookupFlags int

const (
	// IconLookupFlagsNoSvg: never get SVG icons, even if gdk-pixbuf supports
	// them. Cannot be used together with GTK_ICON_LOOKUP_FORCE_SVG.
	IconLookupFlagsNoSvg IconLookupFlags = 0b1
	// IconLookupFlagsForceSvg: get SVG icons, even if gdk-pixbuf doesn’t
	// support them. Cannot be used together with GTK_ICON_LOOKUP_NO_SVG.
	IconLookupFlagsForceSvg IconLookupFlags = 0b10
	// IconLookupFlagsUseBuiltin: when passed to gtk_icon_theme_lookup_icon()
	// includes builtin icons as well as files. For a builtin icon,
	// gtk_icon_info_get_filename() is NULL and you need to call
	// gtk_icon_info_get_builtin_pixbuf().
	IconLookupFlagsUseBuiltin IconLookupFlags = 0b100
	// IconLookupFlagsGenericFallback: try to shorten icon name at '-'
	// characters before looking at inherited themes. This flag is only
	// supported in functions that take a single icon name. For more general
	// fallback, see gtk_icon_theme_choose_icon(). Since 2.12.
	IconLookupFlagsGenericFallback IconLookupFlags = 0b1000
	// IconLookupFlagsForceSize always get the icon scaled to the requested
	// size. Since 2.14.
	IconLookupFlagsForceSize IconLookupFlags = 0b10000
	// IconLookupFlagsForceRegular: try to always load regular icons, even when
	// symbolic icon names are given. Since 3.14.
	IconLookupFlagsForceRegular IconLookupFlags = 0b100000
	// IconLookupFlagsForceSymbolic: try to always load symbolic icons, even
	// when regular icon names are given. Since 3.14.
	IconLookupFlagsForceSymbolic IconLookupFlags = 0b1000000
	// IconLookupFlagsDirLTR: try to load a variant of the icon for
	// left-to-right text direction. Since 3.14.
	IconLookupFlagsDirLTR IconLookupFlags = 0b10000000
	// IconLookupFlagsDirRTL: try to load a variant of the icon for
	// right-to-left text direction. Since 3.14.
	IconLookupFlagsDirRTL IconLookupFlags = 0b100000000
)

func marshalIconLookupFlags(p uintptr) (interface{}, error) {
	return IconLookupFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconInfor describes IconInfo's methods.
type IconInfor interface {
	// AttachPoints: this function is deprecated and always returns FALSE.
	AttachPoints() ([]gdk.Point, bool)
	// BaseScale gets the base scale for the icon.
	BaseScale() int
	// BaseSize gets the base size for the icon.
	BaseSize() int
	// BuiltinPixbuf gets the built-in image for this icon, if any.
	BuiltinPixbuf() *gdkpixbuf.Pixbuf
	// DisplayName: this function is deprecated and always returns NULL.
	DisplayName() string
	// EmbeddedRect: this function is deprecated and always returns FALSE.
	EmbeddedRect() (gdk.Rectangle, bool)
	// Filename gets the filename for the icon.
	Filename() string
	// IsSymbolic checks if the icon is symbolic or not.
	IsSymbolic() bool
	// LoadIcon renders an icon previously looked up in an icon theme using
	// gtk_icon_theme_lookup_icon(); the size will be based on the size passed
	// to gtk_icon_theme_lookup_icon().
	LoadIcon() (*gdkpixbuf.Pixbuf, error)
	// LoadIconFinish finishes an async icon load, see
	// gtk_icon_info_load_icon_async().
	LoadIconFinish(res gio.AsyncResulter) (*gdkpixbuf.Pixbuf, error)
	// LoadSurface renders an icon previously looked up in an icon theme using
	// gtk_icon_theme_lookup_icon(); the size will be based on the size passed
	// to gtk_icon_theme_lookup_icon().
	LoadSurface(forWindow gdk.Windower) (*cairo.Surface, error)
	// LoadSymbolic loads an icon, modifying it to match the system colours for
	// the foreground, success, warning and error colors provided.
	LoadSymbolic(fg *gdk.RGBA, successColor *gdk.RGBA, warningColor *gdk.RGBA, errorColor *gdk.RGBA) (bool, *gdkpixbuf.Pixbuf, error)
	// LoadSymbolicFinish finishes an async icon load, see
	// gtk_icon_info_load_symbolic_async().
	LoadSymbolicFinish(res gio.AsyncResulter) (bool, *gdkpixbuf.Pixbuf, error)
	// LoadSymbolicForContext loads an icon, modifying it to match the system
	// colors for the foreground, success, warning and error colors provided.
	LoadSymbolicForContext(context *StyleContext) (bool, *gdkpixbuf.Pixbuf, error)
	// LoadSymbolicForContextFinish finishes an async icon load, see
	// gtk_icon_info_load_symbolic_for_context_async().
	LoadSymbolicForContextFinish(res gio.AsyncResulter) (bool, *gdkpixbuf.Pixbuf, error)
	// LoadSymbolicForStyle loads an icon, modifying it to match the system
	// colours for the foreground, success, warning and error colors provided.
	LoadSymbolicForStyle(style *Style, state StateType) (bool, *gdkpixbuf.Pixbuf, error)
	// SetRawCoordinates sets whether the coordinates returned by
	// gtk_icon_info_get_embedded_rect() and gtk_icon_info_get_attach_points()
	// should be returned in their original form as specified in the icon theme,
	// instead of scaled appropriately for the pixbuf returned by
	// gtk_icon_info_load_icon().
	SetRawCoordinates(rawCoordinates bool)
}

// IconInfo contains information found when looking up an icon in an icon theme.
type IconInfo struct {
	*externglib.Object
}

var (
	_ IconInfor       = (*IconInfo)(nil)
	_ gextras.Nativer = (*IconInfo)(nil)
)

func wrapIconInfo(obj *externglib.Object) *IconInfo {
	return &IconInfo{
		Object: obj,
	}
}

func marshalIconInfor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapIconInfo(obj), nil
}

// NewIconInfoForPixbuf creates a IconInfo for a Pixbuf.
func NewIconInfoForPixbuf(iconTheme *IconTheme, pixbuf *gdkpixbuf.Pixbuf) *IconInfo {
	var _arg1 *C.GtkIconTheme // out
	var _arg2 *C.GdkPixbuf    // out
	var _cret *C.GtkIconInfo  // in

	_arg1 = (*C.GtkIconTheme)(unsafe.Pointer(iconTheme.Native()))
	_arg2 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	_cret = C.gtk_icon_info_new_for_pixbuf(_arg1, _arg2)

	var _iconInfo *IconInfo // out

	_iconInfo = wrapIconInfo(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _iconInfo
}

// AttachPoints: this function is deprecated and always returns FALSE.
//
// Deprecated: Attachment points are deprecated.
func (iconInfo *IconInfo) AttachPoints() ([]gdk.Point, bool) {
	var _arg0 *C.GtkIconInfo // out
	var _arg1 *C.GdkPoint
	var _arg2 C.gint     // in
	var _cret C.gboolean // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(iconInfo.Native()))

	_cret = C.gtk_icon_info_get_attach_points(_arg0, &_arg1, &_arg2)

	var _points []gdk.Point
	var _ok bool // out

	defer C.free(unsafe.Pointer(_arg1))
	_points = make([]gdk.Point, _arg2)
	copy(_points, unsafe.Slice((*gdk.Point)(unsafe.Pointer(_arg1)), _arg2))
	if _cret != 0 {
		_ok = true
	}

	return _points, _ok
}

// BaseScale gets the base scale for the icon. The base scale is a scale for the
// icon that was specified by the icon theme creator. For instance an icon drawn
// for a high-dpi screen with window scale 2 for a base size of 32 will be 64
// pixels tall and have a base scale of 2.
func (iconInfo *IconInfo) BaseScale() int {
	var _arg0 *C.GtkIconInfo // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(iconInfo.Native()))

	_cret = C.gtk_icon_info_get_base_scale(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// BaseSize gets the base size for the icon. The base size is a size for the
// icon that was specified by the icon theme creator. This may be different than
// the actual size of image; an example of this is small emblem icons that can
// be attached to a larger icon. These icons will be given the same base size as
// the larger icons to which they are attached.
//
// Note that for scaled icons the base size does not include the base scale.
func (iconInfo *IconInfo) BaseSize() int {
	var _arg0 *C.GtkIconInfo // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(iconInfo.Native()))

	_cret = C.gtk_icon_info_get_base_size(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// BuiltinPixbuf gets the built-in image for this icon, if any. To allow GTK+ to
// use built in icon images, you must pass the GTK_ICON_LOOKUP_USE_BUILTIN to
// gtk_icon_theme_lookup_icon().
//
// Deprecated: This function is deprecated, use
// gtk_icon_theme_add_resource_path() instead of builtin icons.
func (iconInfo *IconInfo) BuiltinPixbuf() *gdkpixbuf.Pixbuf {
	var _arg0 *C.GtkIconInfo // out
	var _cret *C.GdkPixbuf   // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(iconInfo.Native()))

	_cret = C.gtk_icon_info_get_builtin_pixbuf(_arg0)

	var _pixbuf *gdkpixbuf.Pixbuf // out

	{
		obj := externglib.Take(unsafe.Pointer(_cret))
		_pixbuf = &gdkpixbuf.Pixbuf{
			Object: obj,
			Icon: gio.Icon{
				Object: obj,
			},
		}
	}

	return _pixbuf
}

// DisplayName: this function is deprecated and always returns NULL.
//
// Deprecated: Display names are deprecated.
func (iconInfo *IconInfo) DisplayName() string {
	var _arg0 *C.GtkIconInfo // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(iconInfo.Native()))

	_cret = C.gtk_icon_info_get_display_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// EmbeddedRect: this function is deprecated and always returns FALSE.
//
// Deprecated: Embedded rectangles are deprecated.
func (iconInfo *IconInfo) EmbeddedRect() (gdk.Rectangle, bool) {
	var _arg0 *C.GtkIconInfo // out
	var _rectangle gdk.Rectangle
	var _cret C.gboolean // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(iconInfo.Native()))

	_cret = C.gtk_icon_info_get_embedded_rect(_arg0, (*C.GdkRectangle)(unsafe.Pointer(&_rectangle)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _rectangle, _ok
}

// Filename gets the filename for the icon. If the GTK_ICON_LOOKUP_USE_BUILTIN
// flag was passed to gtk_icon_theme_lookup_icon(), there may be no filename if
// a builtin icon is returned; in this case, you should use
// gtk_icon_info_get_builtin_pixbuf().
func (iconInfo *IconInfo) Filename() string {
	var _arg0 *C.GtkIconInfo // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(iconInfo.Native()))

	_cret = C.gtk_icon_info_get_filename(_arg0)

	var _filename string // out

	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _filename
}

// IsSymbolic checks if the icon is symbolic or not. This currently uses only
// the file name and not the file contents for determining this. This behaviour
// may change in the future.
func (iconInfo *IconInfo) IsSymbolic() bool {
	var _arg0 *C.GtkIconInfo // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(iconInfo.Native()))

	_cret = C.gtk_icon_info_is_symbolic(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LoadIcon renders an icon previously looked up in an icon theme using
// gtk_icon_theme_lookup_icon(); the size will be based on the size passed to
// gtk_icon_theme_lookup_icon(). Note that the resulting pixbuf may not be
// exactly this size; an icon theme may have icons that differ slightly from
// their nominal sizes, and in addition GTK+ will avoid scaling icons that it
// considers sufficiently close to the requested size or for which the source
// image would have to be scaled up too far. (This maintains sharpness.). This
// behaviour can be changed by passing the GTK_ICON_LOOKUP_FORCE_SIZE flag when
// obtaining the IconInfo. If this flag has been specified, the pixbuf returned
// by this function will be scaled to the exact size.
func (iconInfo *IconInfo) LoadIcon() (*gdkpixbuf.Pixbuf, error) {
	var _arg0 *C.GtkIconInfo // out
	var _cret *C.GdkPixbuf   // in
	var _cerr *C.GError      // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(iconInfo.Native()))

	_cret = C.gtk_icon_info_load_icon(_arg0, &_cerr)

	var _pixbuf *gdkpixbuf.Pixbuf // out
	var _goerr error              // out

	{
		obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
		_pixbuf = &gdkpixbuf.Pixbuf{
			Object: obj,
			Icon: gio.Icon{
				Object: obj,
			},
		}
	}
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _pixbuf, _goerr
}

// LoadIconFinish finishes an async icon load, see
// gtk_icon_info_load_icon_async().
func (iconInfo *IconInfo) LoadIconFinish(res gio.AsyncResulter) (*gdkpixbuf.Pixbuf, error) {
	var _arg0 *C.GtkIconInfo  // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GdkPixbuf    // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(iconInfo.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer((res).(gextras.Nativer).Native()))

	_cret = C.gtk_icon_info_load_icon_finish(_arg0, _arg1, &_cerr)

	var _pixbuf *gdkpixbuf.Pixbuf // out
	var _goerr error              // out

	{
		obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
		_pixbuf = &gdkpixbuf.Pixbuf{
			Object: obj,
			Icon: gio.Icon{
				Object: obj,
			},
		}
	}
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _pixbuf, _goerr
}

// LoadSurface renders an icon previously looked up in an icon theme using
// gtk_icon_theme_lookup_icon(); the size will be based on the size passed to
// gtk_icon_theme_lookup_icon(). Note that the resulting surface may not be
// exactly this size; an icon theme may have icons that differ slightly from
// their nominal sizes, and in addition GTK+ will avoid scaling icons that it
// considers sufficiently close to the requested size or for which the source
// image would have to be scaled up too far. (This maintains sharpness.). This
// behaviour can be changed by passing the GTK_ICON_LOOKUP_FORCE_SIZE flag when
// obtaining the IconInfo. If this flag has been specified, the pixbuf returned
// by this function will be scaled to the exact size.
func (iconInfo *IconInfo) LoadSurface(forWindow gdk.Windower) (*cairo.Surface, error) {
	var _arg0 *C.GtkIconInfo     // out
	var _arg1 *C.GdkWindow       // out
	var _cret *C.cairo_surface_t // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(iconInfo.Native()))
	_arg1 = (*C.GdkWindow)(unsafe.Pointer((forWindow).(gextras.Nativer).Native()))

	_cret = C.gtk_icon_info_load_surface(_arg0, _arg1, &_cerr)

	var _surface *cairo.Surface // out
	var _goerr error            // out

	_surface = (*cairo.Surface)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_surface, func(v *cairo.Surface) {
		C.free(unsafe.Pointer(v))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _surface, _goerr
}

// LoadSymbolic loads an icon, modifying it to match the system colours for the
// foreground, success, warning and error colors provided. If the icon is not a
// symbolic one, the function will return the result from
// gtk_icon_info_load_icon().
//
// This allows loading symbolic icons that will match the system theme.
//
// Unless you are implementing a widget, you will want to use
// g_themed_icon_new_with_default_fallbacks() to load the icon.
//
// As implementation details, the icon loaded needs to be of SVG type, contain
// the “symbolic” term as the last component of the icon name, and use the “fg”,
// “success”, “warning” and “error” CSS styles in the SVG file itself.
//
// See the Symbolic Icons Specification
// (http://www.freedesktop.org/wiki/SymbolicIcons) for more information about
// symbolic icons.
func (iconInfo *IconInfo) LoadSymbolic(fg *gdk.RGBA, successColor *gdk.RGBA, warningColor *gdk.RGBA, errorColor *gdk.RGBA) (bool, *gdkpixbuf.Pixbuf, error) {
	var _arg0 *C.GtkIconInfo // out
	var _arg1 *C.GdkRGBA     // out
	var _arg2 *C.GdkRGBA     // out
	var _arg3 *C.GdkRGBA     // out
	var _arg4 *C.GdkRGBA     // out
	var _arg5 C.gboolean     // in
	var _cret *C.GdkPixbuf   // in
	var _cerr *C.GError      // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(iconInfo.Native()))
	_arg1 = (*C.GdkRGBA)(unsafe.Pointer(fg))
	_arg2 = (*C.GdkRGBA)(unsafe.Pointer(successColor))
	_arg3 = (*C.GdkRGBA)(unsafe.Pointer(warningColor))
	_arg4 = (*C.GdkRGBA)(unsafe.Pointer(errorColor))

	_cret = C.gtk_icon_info_load_symbolic(_arg0, _arg1, _arg2, _arg3, _arg4, &_arg5, &_cerr)

	var _wasSymbolic bool         // out
	var _pixbuf *gdkpixbuf.Pixbuf // out
	var _goerr error              // out

	if _arg5 != 0 {
		_wasSymbolic = true
	}
	{
		obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
		_pixbuf = &gdkpixbuf.Pixbuf{
			Object: obj,
			Icon: gio.Icon{
				Object: obj,
			},
		}
	}
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _wasSymbolic, _pixbuf, _goerr
}

// LoadSymbolicFinish finishes an async icon load, see
// gtk_icon_info_load_symbolic_async().
func (iconInfo *IconInfo) LoadSymbolicFinish(res gio.AsyncResulter) (bool, *gdkpixbuf.Pixbuf, error) {
	var _arg0 *C.GtkIconInfo  // out
	var _arg1 *C.GAsyncResult // out
	var _arg2 C.gboolean      // in
	var _cret *C.GdkPixbuf    // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(iconInfo.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer((res).(gextras.Nativer).Native()))

	_cret = C.gtk_icon_info_load_symbolic_finish(_arg0, _arg1, &_arg2, &_cerr)

	var _wasSymbolic bool         // out
	var _pixbuf *gdkpixbuf.Pixbuf // out
	var _goerr error              // out

	if _arg2 != 0 {
		_wasSymbolic = true
	}
	{
		obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
		_pixbuf = &gdkpixbuf.Pixbuf{
			Object: obj,
			Icon: gio.Icon{
				Object: obj,
			},
		}
	}
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _wasSymbolic, _pixbuf, _goerr
}

// LoadSymbolicForContext loads an icon, modifying it to match the system colors
// for the foreground, success, warning and error colors provided. If the icon
// is not a symbolic one, the function will return the result from
// gtk_icon_info_load_icon(). This function uses the regular foreground color
// and the symbolic colors with the names “success_color”, “warning_color” and
// “error_color” from the context.
//
// This allows loading symbolic icons that will match the system theme.
//
// See gtk_icon_info_load_symbolic() for more details.
func (iconInfo *IconInfo) LoadSymbolicForContext(context *StyleContext) (bool, *gdkpixbuf.Pixbuf, error) {
	var _arg0 *C.GtkIconInfo     // out
	var _arg1 *C.GtkStyleContext // out
	var _arg2 C.gboolean         // in
	var _cret *C.GdkPixbuf       // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(iconInfo.Native()))
	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))

	_cret = C.gtk_icon_info_load_symbolic_for_context(_arg0, _arg1, &_arg2, &_cerr)

	var _wasSymbolic bool         // out
	var _pixbuf *gdkpixbuf.Pixbuf // out
	var _goerr error              // out

	if _arg2 != 0 {
		_wasSymbolic = true
	}
	{
		obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
		_pixbuf = &gdkpixbuf.Pixbuf{
			Object: obj,
			Icon: gio.Icon{
				Object: obj,
			},
		}
	}
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _wasSymbolic, _pixbuf, _goerr
}

// LoadSymbolicForContextFinish finishes an async icon load, see
// gtk_icon_info_load_symbolic_for_context_async().
func (iconInfo *IconInfo) LoadSymbolicForContextFinish(res gio.AsyncResulter) (bool, *gdkpixbuf.Pixbuf, error) {
	var _arg0 *C.GtkIconInfo  // out
	var _arg1 *C.GAsyncResult // out
	var _arg2 C.gboolean      // in
	var _cret *C.GdkPixbuf    // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(iconInfo.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer((res).(gextras.Nativer).Native()))

	_cret = C.gtk_icon_info_load_symbolic_for_context_finish(_arg0, _arg1, &_arg2, &_cerr)

	var _wasSymbolic bool         // out
	var _pixbuf *gdkpixbuf.Pixbuf // out
	var _goerr error              // out

	if _arg2 != 0 {
		_wasSymbolic = true
	}
	{
		obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
		_pixbuf = &gdkpixbuf.Pixbuf{
			Object: obj,
			Icon: gio.Icon{
				Object: obj,
			},
		}
	}
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _wasSymbolic, _pixbuf, _goerr
}

// LoadSymbolicForStyle loads an icon, modifying it to match the system colours
// for the foreground, success, warning and error colors provided. If the icon
// is not a symbolic one, the function will return the result from
// gtk_icon_info_load_icon().
//
// This allows loading symbolic icons that will match the system theme.
//
// See gtk_icon_info_load_symbolic() for more details.
//
// Deprecated: Use gtk_icon_info_load_symbolic_for_context() instead.
func (iconInfo *IconInfo) LoadSymbolicForStyle(style *Style, state StateType) (bool, *gdkpixbuf.Pixbuf, error) {
	var _arg0 *C.GtkIconInfo // out
	var _arg1 *C.GtkStyle    // out
	var _arg2 C.GtkStateType // out
	var _arg3 C.gboolean     // in
	var _cret *C.GdkPixbuf   // in
	var _cerr *C.GError      // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(iconInfo.Native()))
	_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
	_arg2 = C.GtkStateType(state)

	_cret = C.gtk_icon_info_load_symbolic_for_style(_arg0, _arg1, _arg2, &_arg3, &_cerr)

	var _wasSymbolic bool         // out
	var _pixbuf *gdkpixbuf.Pixbuf // out
	var _goerr error              // out

	if _arg3 != 0 {
		_wasSymbolic = true
	}
	{
		obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
		_pixbuf = &gdkpixbuf.Pixbuf{
			Object: obj,
			Icon: gio.Icon{
				Object: obj,
			},
		}
	}
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _wasSymbolic, _pixbuf, _goerr
}

// SetRawCoordinates sets whether the coordinates returned by
// gtk_icon_info_get_embedded_rect() and gtk_icon_info_get_attach_points()
// should be returned in their original form as specified in the icon theme,
// instead of scaled appropriately for the pixbuf returned by
// gtk_icon_info_load_icon().
//
// Raw coordinates are somewhat strange; they are specified to be with respect
// to the unscaled pixmap for PNG and XPM icons, but for SVG icons, they are in
// a 1000x1000 coordinate space that is scaled to the final size of the icon.
// You can determine if the icon is an SVG icon by using
// gtk_icon_info_get_filename(), and seeing if it is non-NULL and ends in
// “.svg”.
//
// This function is provided primarily to allow compatibility wrappers for older
// API's, and is not expected to be useful for applications.
//
// Deprecated: Embedded rectangles and attachment points are deprecated.
func (iconInfo *IconInfo) SetRawCoordinates(rawCoordinates bool) {
	var _arg0 *C.GtkIconInfo // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(iconInfo.Native()))
	if rawCoordinates {
		_arg1 = C.TRUE
	}

	C.gtk_icon_info_set_raw_coordinates(_arg0, _arg1)
}

// IconThemeOverrider contains methods that are overridable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type IconThemeOverrider interface {
	Changed()
}

// IconThemer describes IconTheme's methods.
type IconThemer interface {
	// AddResourcePath adds a resource path that will be looked at when looking
	// for icons, similar to search paths.
	AddResourcePath(path string)
	// AppendSearchPath appends a directory to the search path.
	AppendSearchPath(path string)
	// ChooseIcon looks up a named icon and returns a IconInfo containing
	// information such as the filename of the icon.
	ChooseIcon(iconNames []string, size int, flags IconLookupFlags) *IconInfo
	// ChooseIconForScale looks up a named icon for a particular window scale
	// and returns a IconInfo containing information such as the filename of the
	// icon.
	ChooseIconForScale(iconNames []string, size int, scale int, flags IconLookupFlags) *IconInfo
	// ExampleIconName gets the name of an icon that is representative of the
	// current theme (for instance, to use when presenting a list of themes to
	// the user.)
	ExampleIconName() string
	// IconSizes returns an array of integers describing the sizes at which the
	// icon is available without scaling.
	IconSizes(iconName string) []int
	// SearchPath gets the current search path.
	SearchPath() []string
	// HasIcon checks whether an icon theme includes an icon for a particular
	// name.
	HasIcon(iconName string) bool
	// LoadIcon looks up an icon in an icon theme, scales it to the given size
	// and renders it into a pixbuf.
	LoadIcon(iconName string, size int, flags IconLookupFlags) (*gdkpixbuf.Pixbuf, error)
	// LoadIconForScale looks up an icon in an icon theme for a particular
	// window scale, scales it to the given size and renders it into a pixbuf.
	LoadIconForScale(iconName string, size int, scale int, flags IconLookupFlags) (*gdkpixbuf.Pixbuf, error)
	// LoadSurface looks up an icon in an icon theme for a particular window
	// scale, scales it to the given size and renders it into a cairo surface.
	LoadSurface(iconName string, size int, scale int, forWindow gdk.Windower, flags IconLookupFlags) (*cairo.Surface, error)
	// LookupByGicon looks up an icon and returns a IconInfo containing
	// information such as the filename of the icon.
	LookupByGicon(icon gio.Iconer, size int, flags IconLookupFlags) *IconInfo
	// LookupByGiconForScale looks up an icon and returns a IconInfo containing
	// information such as the filename of the icon.
	LookupByGiconForScale(icon gio.Iconer, size int, scale int, flags IconLookupFlags) *IconInfo
	// LookupIcon looks up a named icon and returns a IconInfo containing
	// information such as the filename of the icon.
	LookupIcon(iconName string, size int, flags IconLookupFlags) *IconInfo
	// LookupIconForScale looks up a named icon for a particular window scale
	// and returns a IconInfo containing information such as the filename of the
	// icon.
	LookupIconForScale(iconName string, size int, scale int, flags IconLookupFlags) *IconInfo
	// PrependSearchPath prepends a directory to the search path.
	PrependSearchPath(path string)
	// RescanIfNeeded checks to see if the icon theme has changed; if it has,
	// any currently cached information is discarded and will be reloaded next
	// time icon_theme is accessed.
	RescanIfNeeded() bool
	// SetCustomTheme sets the name of the icon theme that the IconTheme object
	// uses overriding system configuration.
	SetCustomTheme(themeName string)
	// SetScreen sets the screen for an icon theme; the screen is used to track
	// the user’s currently configured icon theme, which might be different for
	// different screens.
	SetScreen(screen *gdk.Screen)
	// SetSearchPath sets the search path for the icon theme object.
	SetSearchPath(path []string)
}

// IconTheme provides a facility for looking up icons by name and size. The main
// reason for using a name rather than simply providing a filename is to allow
// different icons to be used depending on what “icon theme” is selected by the
// user. The operation of icon themes on Linux and Unix follows the Icon Theme
// Specification (http://www.freedesktop.org/Standards/icon-theme-spec) There is
// a fallback icon theme, named hicolor, where applications should install their
// icons, but additional icon themes can be installed as operating system
// vendors and users choose.
//
// Named icons are similar to the deprecated [Stock Items][gtkstock], and the
// distinction between the two may be a bit confusing. A few things to keep in
// mind:
//
// - Stock images usually are used in conjunction with [Stock Items][gtkstock],
// such as GTK_STOCK_OK or GTK_STOCK_OPEN. Named icons are easier to set up and
// therefore are more useful for new icons that an application wants to add,
// such as application icons or window icons.
//
// - Stock images can only be loaded at the symbolic sizes defined by the
// IconSize enumeration, or by custom sizes defined by gtk_icon_size_register(),
// while named icons are more flexible and any pixel size can be specified.
//
// - Because stock images are closely tied to stock items, and thus to actions
// in the user interface, stock images may come in multiple variants for
// different widget states or writing directions.
//
// A good rule of thumb is that if there is a stock image for what you want to
// use, use it, otherwise use a named icon. It turns out that internally stock
// images are generally defined in terms of one or more named icons. (An example
// of the more than one case is icons that depend on writing direction;
// GTK_STOCK_GO_FORWARD uses the two themed icons “gtk-stock-go-forward-ltr” and
// “gtk-stock-go-forward-rtl”.)
//
// In many cases, named themes are used indirectly, via Image or stock items,
// rather than directly, but looking up icons directly is also simple. The
// IconTheme object acts as a database of all the icons in the current theme.
// You can create new IconTheme objects, but it’s much more efficient to use the
// standard icon theme for the Screen so that the icon information is shared
// with other people looking up icons.
//
//    GError *error = NULL;
//    GtkIconTheme *icon_theme;
//    GdkPixbuf *pixbuf;
//
//    icon_theme = gtk_icon_theme_get_default ();
//    pixbuf = gtk_icon_theme_load_icon (icon_theme,
//                                       "my-icon-name", // icon name
//                                       48, // icon size
//                                       0,  // flags
//                                       &error);
//    if (!pixbuf)
//      {
//        g_warning ("Couldn’t load icon: s", error->message);
//        g_error_free (error);
//      }
//    else
//      {
//        // Use the pixbuf
//        g_object_unref (pixbuf);
//      }
type IconTheme struct {
	*externglib.Object
}

var (
	_ IconThemer      = (*IconTheme)(nil)
	_ gextras.Nativer = (*IconTheme)(nil)
)

func wrapIconTheme(obj *externglib.Object) *IconTheme {
	return &IconTheme{
		Object: obj,
	}
}

func marshalIconThemer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapIconTheme(obj), nil
}

// NewIconTheme creates a new icon theme object. Icon theme objects are used to
// lookup up an icon by name in a particular icon theme. Usually, you’ll want to
// use gtk_icon_theme_get_default() or gtk_icon_theme_get_for_screen() rather
// than creating a new icon theme object for scratch.
func NewIconTheme() *IconTheme {
	var _cret *C.GtkIconTheme // in

	_cret = C.gtk_icon_theme_new()

	var _iconTheme *IconTheme // out

	_iconTheme = wrapIconTheme(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _iconTheme
}

// AddResourcePath adds a resource path that will be looked at when looking for
// icons, similar to search paths.
//
// This function should be used to make application-specific icons available as
// part of the icon theme.
//
// The resources are considered as part of the hicolor icon theme and must be
// located in subdirectories that are defined in the hicolor icon theme, such as
// path/16x16/actions/run.png. Icons that are directly placed in the resource
// path instead of a subdirectory are also considered as ultimate fallback.
func (iconTheme *IconTheme) AddResourcePath(path string) {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(iconTheme.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(path)))

	C.gtk_icon_theme_add_resource_path(_arg0, _arg1)
}

// AppendSearchPath appends a directory to the search path. See
// gtk_icon_theme_set_search_path().
func (iconTheme *IconTheme) AppendSearchPath(path string) {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(iconTheme.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(path)))

	C.gtk_icon_theme_append_search_path(_arg0, _arg1)
}

// ChooseIcon looks up a named icon and returns a IconInfo containing
// information such as the filename of the icon. The icon can then be rendered
// into a pixbuf using gtk_icon_info_load_icon(). (gtk_icon_theme_load_icon()
// combines these two steps if all you need is the pixbuf.)
//
// If icon_names contains more than one name, this function tries them all in
// the given order before falling back to inherited icon themes.
func (iconTheme *IconTheme) ChooseIcon(iconNames []string, size int, flags IconLookupFlags) *IconInfo {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 **C.gchar
	var _arg2 C.gint               // out
	var _arg3 C.GtkIconLookupFlags // out
	var _cret *C.GtkIconInfo       // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(iconTheme.Native()))
	{
		_arg1 = (**C.gchar)(C.malloc(C.ulong(len(iconNames)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
		{
			out := unsafe.Slice(_arg1, len(iconNames)+1)
			var zero *C.gchar
			out[len(iconNames)] = zero
			for i := range iconNames {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(iconNames[i])))
			}
		}
	}
	_arg2 = C.gint(size)
	_arg3 = C.GtkIconLookupFlags(flags)

	_cret = C.gtk_icon_theme_choose_icon(_arg0, _arg1, _arg2, _arg3)

	var _iconInfo *IconInfo // out

	_iconInfo = wrapIconInfo(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _iconInfo
}

// ChooseIconForScale looks up a named icon for a particular window scale and
// returns a IconInfo containing information such as the filename of the icon.
// The icon can then be rendered into a pixbuf using gtk_icon_info_load_icon().
// (gtk_icon_theme_load_icon() combines these two steps if all you need is the
// pixbuf.)
//
// If icon_names contains more than one name, this function tries them all in
// the given order before falling back to inherited icon themes.
func (iconTheme *IconTheme) ChooseIconForScale(iconNames []string, size int, scale int, flags IconLookupFlags) *IconInfo {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 **C.gchar
	var _arg2 C.gint               // out
	var _arg3 C.gint               // out
	var _arg4 C.GtkIconLookupFlags // out
	var _cret *C.GtkIconInfo       // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(iconTheme.Native()))
	{
		_arg1 = (**C.gchar)(C.malloc(C.ulong(len(iconNames)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
		{
			out := unsafe.Slice(_arg1, len(iconNames)+1)
			var zero *C.gchar
			out[len(iconNames)] = zero
			for i := range iconNames {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(iconNames[i])))
			}
		}
	}
	_arg2 = C.gint(size)
	_arg3 = C.gint(scale)
	_arg4 = C.GtkIconLookupFlags(flags)

	_cret = C.gtk_icon_theme_choose_icon_for_scale(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _iconInfo *IconInfo // out

	_iconInfo = wrapIconInfo(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _iconInfo
}

// ExampleIconName gets the name of an icon that is representative of the
// current theme (for instance, to use when presenting a list of themes to the
// user.)
func (iconTheme *IconTheme) ExampleIconName() string {
	var _arg0 *C.GtkIconTheme // out
	var _cret *C.char         // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(iconTheme.Native()))

	_cret = C.gtk_icon_theme_get_example_icon_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// IconSizes returns an array of integers describing the sizes at which the icon
// is available without scaling. A size of -1 means that the icon is available
// in a scalable format. The array is zero-terminated.
func (iconTheme *IconTheme) IconSizes(iconName string) []int {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.gchar        // out
	var _cret *C.gint

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(iconTheme.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(iconName)))

	_cret = C.gtk_icon_theme_get_icon_sizes(_arg0, _arg1)

	var _gints []int

	{
		var i int
		var z C.gint
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_gints = make([]int, i)
		for i := range src {
			_gints[i] = int(src[i])
		}
	}

	return _gints
}

// SearchPath gets the current search path. See
// gtk_icon_theme_set_search_path().
func (iconTheme *IconTheme) SearchPath() []string {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 **C.gchar
	var _arg2 C.gint // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(iconTheme.Native()))

	C.gtk_icon_theme_get_search_path(_arg0, &_arg1, &_arg2)

	var _path []string

	defer C.free(unsafe.Pointer(_arg1))
	{
		src := unsafe.Slice(_arg1, _arg2)
		_path = make([]string, _arg2)
		for i := 0; i < int(_arg2); i++ {
			_path[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _path
}

// HasIcon checks whether an icon theme includes an icon for a particular name.
func (iconTheme *IconTheme) HasIcon(iconName string) bool {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(iconTheme.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(iconName)))

	_cret = C.gtk_icon_theme_has_icon(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LoadIcon looks up an icon in an icon theme, scales it to the given size and
// renders it into a pixbuf. This is a convenience function; if more details
// about the icon are needed, use gtk_icon_theme_lookup_icon() followed by
// gtk_icon_info_load_icon().
//
// Note that you probably want to listen for icon theme changes and update the
// icon. This is usually done by connecting to the GtkWidget::style-set signal.
// If for some reason you do not want to update the icon when the icon theme
// changes, you should consider using gdk_pixbuf_copy() to make a private copy
// of the pixbuf returned by this function. Otherwise GTK+ may need to keep the
// old icon theme loaded, which would be a waste of memory.
func (iconTheme *IconTheme) LoadIcon(iconName string, size int, flags IconLookupFlags) (*gdkpixbuf.Pixbuf, error) {
	var _arg0 *C.GtkIconTheme      // out
	var _arg1 *C.gchar             // out
	var _arg2 C.gint               // out
	var _arg3 C.GtkIconLookupFlags // out
	var _cret *C.GdkPixbuf         // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(iconTheme.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(iconName)))
	_arg2 = C.gint(size)
	_arg3 = C.GtkIconLookupFlags(flags)

	_cret = C.gtk_icon_theme_load_icon(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _pixbuf *gdkpixbuf.Pixbuf // out
	var _goerr error              // out

	{
		obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
		_pixbuf = &gdkpixbuf.Pixbuf{
			Object: obj,
			Icon: gio.Icon{
				Object: obj,
			},
		}
	}
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _pixbuf, _goerr
}

// LoadIconForScale looks up an icon in an icon theme for a particular window
// scale, scales it to the given size and renders it into a pixbuf. This is a
// convenience function; if more details about the icon are needed, use
// gtk_icon_theme_lookup_icon() followed by gtk_icon_info_load_icon().
//
// Note that you probably want to listen for icon theme changes and update the
// icon. This is usually done by connecting to the GtkWidget::style-set signal.
// If for some reason you do not want to update the icon when the icon theme
// changes, you should consider using gdk_pixbuf_copy() to make a private copy
// of the pixbuf returned by this function. Otherwise GTK+ may need to keep the
// old icon theme loaded, which would be a waste of memory.
func (iconTheme *IconTheme) LoadIconForScale(iconName string, size int, scale int, flags IconLookupFlags) (*gdkpixbuf.Pixbuf, error) {
	var _arg0 *C.GtkIconTheme      // out
	var _arg1 *C.gchar             // out
	var _arg2 C.gint               // out
	var _arg3 C.gint               // out
	var _arg4 C.GtkIconLookupFlags // out
	var _cret *C.GdkPixbuf         // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(iconTheme.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(iconName)))
	_arg2 = C.gint(size)
	_arg3 = C.gint(scale)
	_arg4 = C.GtkIconLookupFlags(flags)

	_cret = C.gtk_icon_theme_load_icon_for_scale(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)

	var _pixbuf *gdkpixbuf.Pixbuf // out
	var _goerr error              // out

	{
		obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
		_pixbuf = &gdkpixbuf.Pixbuf{
			Object: obj,
			Icon: gio.Icon{
				Object: obj,
			},
		}
	}
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _pixbuf, _goerr
}

// LoadSurface looks up an icon in an icon theme for a particular window scale,
// scales it to the given size and renders it into a cairo surface. This is a
// convenience function; if more details about the icon are needed, use
// gtk_icon_theme_lookup_icon() followed by gtk_icon_info_load_surface().
//
// Note that you probably want to listen for icon theme changes and update the
// icon. This is usually done by connecting to the GtkWidget::style-set signal.
func (iconTheme *IconTheme) LoadSurface(iconName string, size int, scale int, forWindow gdk.Windower, flags IconLookupFlags) (*cairo.Surface, error) {
	var _arg0 *C.GtkIconTheme      // out
	var _arg1 *C.gchar             // out
	var _arg2 C.gint               // out
	var _arg3 C.gint               // out
	var _arg4 *C.GdkWindow         // out
	var _arg5 C.GtkIconLookupFlags // out
	var _cret *C.cairo_surface_t   // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(iconTheme.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(iconName)))
	_arg2 = C.gint(size)
	_arg3 = C.gint(scale)
	_arg4 = (*C.GdkWindow)(unsafe.Pointer((forWindow).(gextras.Nativer).Native()))
	_arg5 = C.GtkIconLookupFlags(flags)

	_cret = C.gtk_icon_theme_load_surface(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _surface *cairo.Surface // out
	var _goerr error            // out

	_surface = (*cairo.Surface)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_surface, func(v *cairo.Surface) {
		C.free(unsafe.Pointer(v))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _surface, _goerr
}

// LookupByGicon looks up an icon and returns a IconInfo containing information
// such as the filename of the icon. The icon can then be rendered into a pixbuf
// using gtk_icon_info_load_icon().
//
// When rendering on displays with high pixel densities you should not use a
// size multiplied by the scaling factor returned by functions like
// gdk_window_get_scale_factor(). Instead, you should use
// gtk_icon_theme_lookup_by_gicon_for_scale(), as the assets loaded for a given
// scaling factor may be different.
func (iconTheme *IconTheme) LookupByGicon(icon gio.Iconer, size int, flags IconLookupFlags) *IconInfo {
	var _arg0 *C.GtkIconTheme      // out
	var _arg1 *C.GIcon             // out
	var _arg2 C.gint               // out
	var _arg3 C.GtkIconLookupFlags // out
	var _cret *C.GtkIconInfo       // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(iconTheme.Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer((icon).(gextras.Nativer).Native()))
	_arg2 = C.gint(size)
	_arg3 = C.GtkIconLookupFlags(flags)

	_cret = C.gtk_icon_theme_lookup_by_gicon(_arg0, _arg1, _arg2, _arg3)

	var _iconInfo *IconInfo // out

	_iconInfo = wrapIconInfo(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _iconInfo
}

// LookupByGiconForScale looks up an icon and returns a IconInfo containing
// information such as the filename of the icon. The icon can then be rendered
// into a pixbuf using gtk_icon_info_load_icon().
func (iconTheme *IconTheme) LookupByGiconForScale(icon gio.Iconer, size int, scale int, flags IconLookupFlags) *IconInfo {
	var _arg0 *C.GtkIconTheme      // out
	var _arg1 *C.GIcon             // out
	var _arg2 C.gint               // out
	var _arg3 C.gint               // out
	var _arg4 C.GtkIconLookupFlags // out
	var _cret *C.GtkIconInfo       // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(iconTheme.Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer((icon).(gextras.Nativer).Native()))
	_arg2 = C.gint(size)
	_arg3 = C.gint(scale)
	_arg4 = C.GtkIconLookupFlags(flags)

	_cret = C.gtk_icon_theme_lookup_by_gicon_for_scale(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _iconInfo *IconInfo // out

	_iconInfo = wrapIconInfo(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _iconInfo
}

// LookupIcon looks up a named icon and returns a IconInfo containing
// information such as the filename of the icon. The icon can then be rendered
// into a pixbuf using gtk_icon_info_load_icon(). (gtk_icon_theme_load_icon()
// combines these two steps if all you need is the pixbuf.)
//
// When rendering on displays with high pixel densities you should not use a
// size multiplied by the scaling factor returned by functions like
// gdk_window_get_scale_factor(). Instead, you should use
// gtk_icon_theme_lookup_icon_for_scale(), as the assets loaded for a given
// scaling factor may be different.
func (iconTheme *IconTheme) LookupIcon(iconName string, size int, flags IconLookupFlags) *IconInfo {
	var _arg0 *C.GtkIconTheme      // out
	var _arg1 *C.gchar             // out
	var _arg2 C.gint               // out
	var _arg3 C.GtkIconLookupFlags // out
	var _cret *C.GtkIconInfo       // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(iconTheme.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(iconName)))
	_arg2 = C.gint(size)
	_arg3 = C.GtkIconLookupFlags(flags)

	_cret = C.gtk_icon_theme_lookup_icon(_arg0, _arg1, _arg2, _arg3)

	var _iconInfo *IconInfo // out

	_iconInfo = wrapIconInfo(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _iconInfo
}

// LookupIconForScale looks up a named icon for a particular window scale and
// returns a IconInfo containing information such as the filename of the icon.
// The icon can then be rendered into a pixbuf using gtk_icon_info_load_icon().
// (gtk_icon_theme_load_icon() combines these two steps if all you need is the
// pixbuf.)
func (iconTheme *IconTheme) LookupIconForScale(iconName string, size int, scale int, flags IconLookupFlags) *IconInfo {
	var _arg0 *C.GtkIconTheme      // out
	var _arg1 *C.gchar             // out
	var _arg2 C.gint               // out
	var _arg3 C.gint               // out
	var _arg4 C.GtkIconLookupFlags // out
	var _cret *C.GtkIconInfo       // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(iconTheme.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(iconName)))
	_arg2 = C.gint(size)
	_arg3 = C.gint(scale)
	_arg4 = C.GtkIconLookupFlags(flags)

	_cret = C.gtk_icon_theme_lookup_icon_for_scale(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _iconInfo *IconInfo // out

	_iconInfo = wrapIconInfo(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _iconInfo
}

// PrependSearchPath prepends a directory to the search path. See
// gtk_icon_theme_set_search_path().
func (iconTheme *IconTheme) PrependSearchPath(path string) {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(iconTheme.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(path)))

	C.gtk_icon_theme_prepend_search_path(_arg0, _arg1)
}

// RescanIfNeeded checks to see if the icon theme has changed; if it has, any
// currently cached information is discarded and will be reloaded next time
// icon_theme is accessed.
func (iconTheme *IconTheme) RescanIfNeeded() bool {
	var _arg0 *C.GtkIconTheme // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(iconTheme.Native()))

	_cret = C.gtk_icon_theme_rescan_if_needed(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetCustomTheme sets the name of the icon theme that the IconTheme object uses
// overriding system configuration. This function cannot be called on the icon
// theme objects returned from gtk_icon_theme_get_default() and
// gtk_icon_theme_get_for_screen().
func (iconTheme *IconTheme) SetCustomTheme(themeName string) {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(iconTheme.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(themeName)))

	C.gtk_icon_theme_set_custom_theme(_arg0, _arg1)
}

// SetScreen sets the screen for an icon theme; the screen is used to track the
// user’s currently configured icon theme, which might be different for
// different screens.
func (iconTheme *IconTheme) SetScreen(screen *gdk.Screen) {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.GdkScreen    // out

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(iconTheme.Native()))
	_arg1 = (*C.GdkScreen)(unsafe.Pointer(screen.Native()))

	C.gtk_icon_theme_set_screen(_arg0, _arg1)
}

// SetSearchPath sets the search path for the icon theme object. When looking
// for an icon theme, GTK+ will search for a subdirectory of one or more of the
// directories in path with the same name as the icon theme containing an
// index.theme file. (Themes from multiple of the path elements are combined to
// allow themes to be extended by adding icons in the user’s home directory.)
//
// In addition if an icon found isn’t found either in the current icon theme or
// the default icon theme, and an image file with the right name is found
// directly in one of the elements of path, then that image will be used for the
// icon name. (This is legacy feature, and new icons should be put into the
// fallback icon theme, which is called hicolor, rather than directly on the
// icon path.)
func (iconTheme *IconTheme) SetSearchPath(path []string) {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 **C.gchar
	var _arg2 C.gint

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(iconTheme.Native()))
	_arg2 = (C.gint)(len(path))
	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(path)) * C.ulong(unsafe.Sizeof(uint(0)))))
	{
		out := unsafe.Slice((**C.gchar)(_arg1), len(path))
		for i := range path {
			out[i] = (*C.gchar)(unsafe.Pointer(C.CString(path[i])))
		}
	}

	C.gtk_icon_theme_set_search_path(_arg0, _arg1, _arg2)
}

// IconThemeAddBuiltinIcon registers a built-in icon for icon theme lookups. The
// idea of built-in icons is to allow an application or library that uses themed
// icons to function requiring files to be present in the file system. For
// instance, the default images for all of GTK+’s stock icons are registered as
// built-icons.
//
// In general, if you use gtk_icon_theme_add_builtin_icon() you should also
// install the icon in the icon theme, so that the icon is generally available.
//
// This function will generally be used with pixbufs loaded via
// gdk_pixbuf_new_from_inline().
//
// Deprecated: Use gtk_icon_theme_add_resource_path() to add
// application-specific icons to the icon theme.
func IconThemeAddBuiltinIcon(iconName string, size int, pixbuf *gdkpixbuf.Pixbuf) {
	var _arg1 *C.gchar     // out
	var _arg2 C.gint       // out
	var _arg3 *C.GdkPixbuf // out

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(iconName)))
	_arg2 = C.gint(size)
	_arg3 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	C.gtk_icon_theme_add_builtin_icon(_arg1, _arg2, _arg3)
}

// IconThemeGetDefault gets the icon theme for the default screen. See
// gtk_icon_theme_get_for_screen().
func IconThemeGetDefault() *IconTheme {
	var _cret *C.GtkIconTheme // in

	_cret = C.gtk_icon_theme_get_default()

	var _iconTheme *IconTheme // out

	_iconTheme = wrapIconTheme(externglib.Take(unsafe.Pointer(_cret)))

	return _iconTheme
}

// IconThemeGetForScreen gets the icon theme object associated with screen; if
// this function has not previously been called for the given screen, a new icon
// theme object will be created and associated with the screen. Icon theme
// objects are fairly expensive to create, so using this function is usually a
// better choice than calling than gtk_icon_theme_new() and setting the screen
// yourself; by using this function a single icon theme object will be shared
// between users.
func IconThemeGetForScreen(screen *gdk.Screen) *IconTheme {
	var _arg1 *C.GdkScreen    // out
	var _cret *C.GtkIconTheme // in

	_arg1 = (*C.GdkScreen)(unsafe.Pointer(screen.Native()))

	_cret = C.gtk_icon_theme_get_for_screen(_arg1)

	var _iconTheme *IconTheme // out

	_iconTheme = wrapIconTheme(externglib.Take(unsafe.Pointer(_cret)))

	return _iconTheme
}
