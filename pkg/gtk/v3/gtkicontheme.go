// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/core/gerror"
	"github.com/diamondburned/gotk4/core/gextras"
	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk+-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_icon_theme_error_get_type()), F: marshalIconThemeError},
		{T: externglib.Type(C.gtk_icon_lookup_flags_get_type()), F: marshalIconLookupFlags},
		{T: externglib.Type(C.gtk_icon_info_get_type()), F: marshalIconInfo},
		{T: externglib.Type(C.gtk_icon_theme_get_type()), F: marshalIconTheme},
	})
}

// IconThemeError: error codes for GtkIconTheme operations.
type IconThemeError int

const (
	// NotFound: the icon specified does not exist in the theme
	IconThemeErrorNotFound IconThemeError = 0
	// failed: an unspecified error occurred.
	IconThemeErrorFailed IconThemeError = 1
)

func marshalIconThemeError(p uintptr) (interface{}, error) {
	return IconThemeError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconLookupFlags: used to specify options for gtk_icon_theme_lookup_icon()
type IconLookupFlags int

const (
	// IconLookupFlagsNoSvg: never get SVG icons, even if gdk-pixbuf supports
	// them. Cannot be used together with GTK_ICON_LOOKUP_FORCE_SVG.
	IconLookupFlagsNoSvg IconLookupFlags = 0b1
	// IconLookupFlagsForceSvg: get SVG icons, even if gdk-pixbuf doesn’t
	// support them. Cannot be used together with GTK_ICON_LOOKUP_NO_SVG.
	IconLookupFlagsForceSvg IconLookupFlags = 0b10
	// IconLookupFlagsUseBuiltin: when passed to gtk_icon_theme_lookup_icon()
	// includes builtin icons as well as files. For a builtin icon,
	// gtk_icon_info_get_filename() is nil and you need to call
	// gtk_icon_info_get_builtin_pixbuf().
	IconLookupFlagsUseBuiltin IconLookupFlags = 0b100
	// IconLookupFlagsGenericFallback: try to shorten icon name at '-'
	// characters before looking at inherited themes. This flag is only
	// supported in functions that take a single icon name. For more general
	// fallback, see gtk_icon_theme_choose_icon(). Since 2.12.
	IconLookupFlagsGenericFallback IconLookupFlags = 0b1000
	// IconLookupFlagsForceSize always get the icon scaled to the requested
	// size. Since 2.14.
	IconLookupFlagsForceSize IconLookupFlags = 0b10000
	// IconLookupFlagsForceRegular: try to always load regular icons, even when
	// symbolic icon names are given. Since 3.14.
	IconLookupFlagsForceRegular IconLookupFlags = 0b100000
	// IconLookupFlagsForceSymbolic: try to always load symbolic icons, even
	// when regular icon names are given. Since 3.14.
	IconLookupFlagsForceSymbolic IconLookupFlags = 0b1000000
	// IconLookupFlagsDirLTR: try to load a variant of the icon for
	// left-to-right text direction. Since 3.14.
	IconLookupFlagsDirLTR IconLookupFlags = 0b10000000
	// IconLookupFlagsDirRTL: try to load a variant of the icon for
	// right-to-left text direction. Since 3.14.
	IconLookupFlagsDirRTL IconLookupFlags = 0b100000000
)

func marshalIconLookupFlags(p uintptr) (interface{}, error) {
	return IconLookupFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconInfo contains information found when looking up an icon in an icon theme.
type IconInfo interface {
	gextras.Objector

	// AttachPoints:
	AttachPoints() ([]gdk.Point, bool)
	// BaseScale:
	BaseScale() int
	// BaseSize:
	BaseSize() int
	// BuiltinPixbuf:
	BuiltinPixbuf() gdkpixbuf.Pixbuf
	// DisplayName:
	DisplayName() string
	// EmbeddedRect:
	EmbeddedRect() (gdk.Rectangle, bool)
	// Filename:
	Filename() string
	// IsSymbolicIconInfo:
	IsSymbolicIconInfo() bool
	// LoadIconIconInfo:
	LoadIconIconInfo() (gdkpixbuf.Pixbuf, error)
	// LoadIconFinishIconInfo:
	LoadIconFinishIconInfo(res gio.AsyncResult) (gdkpixbuf.Pixbuf, error)
	// LoadSurfaceIconInfo:
	LoadSurfaceIconInfo(forWindow gdk.Window) (*cairo.Surface, error)
	// LoadSymbolicIconInfo:
	LoadSymbolicIconInfo(fg *gdk.RGBA, successColor *gdk.RGBA, warningColor *gdk.RGBA, errorColor *gdk.RGBA) (bool, gdkpixbuf.Pixbuf, error)
	// LoadSymbolicFinishIconInfo:
	LoadSymbolicFinishIconInfo(res gio.AsyncResult) (bool, gdkpixbuf.Pixbuf, error)
	// LoadSymbolicForContextIconInfo:
	LoadSymbolicForContextIconInfo(context StyleContext) (bool, gdkpixbuf.Pixbuf, error)
	// LoadSymbolicForContextFinishIconInfo:
	LoadSymbolicForContextFinishIconInfo(res gio.AsyncResult) (bool, gdkpixbuf.Pixbuf, error)
	// LoadSymbolicForStyleIconInfo:
	LoadSymbolicForStyleIconInfo(style Style, state StateType) (bool, gdkpixbuf.Pixbuf, error)
	// SetRawCoordinatesIconInfo:
	SetRawCoordinatesIconInfo(rawCoordinates bool)
}

// iconInfo implements the IconInfo class.
type iconInfo struct {
	gextras.Objector
}

// WrapIconInfo wraps a GObject to the right type. It is
// primarily used internally.
func WrapIconInfo(obj *externglib.Object) IconInfo {
	return iconInfo{
		Objector: obj,
	}
}

func marshalIconInfo(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIconInfo(obj), nil
}

// NewIconInfoForPixbuf:
func NewIconInfoForPixbuf(iconTheme IconTheme, pixbuf gdkpixbuf.Pixbuf) IconInfo {
	var _arg1 *C.GtkIconTheme // out
	var _arg2 *C.GdkPixbuf    // out
	var _cret *C.GtkIconInfo  // in

	_arg1 = (*C.GtkIconTheme)(unsafe.Pointer(iconTheme.Native()))
	_arg2 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	_cret = C.gtk_icon_info_new_for_pixbuf(_arg1, _arg2)

	var _iconInfo IconInfo // out

	_iconInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(IconInfo)

	return _iconInfo
}

func (i iconInfo) AttachPoints() ([]gdk.Point, bool) {
	var _arg0 *C.GtkIconInfo // out
	var _arg1 *C.GdkPoint
	var _arg2 C.gint     // in
	var _cret C.gboolean // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_info_get_attach_points(_arg0, &_arg1, &_arg2)

	var _points []gdk.Point
	var _ok bool // out

	_points = unsafe.Slice((*gdk.Point)(unsafe.Pointer(_arg1)), _arg2)
	runtime.SetFinalizer(&_points, func(v *[]gdk.Point) {
		C.free(unsafe.Pointer(&(*v)[0]))
	})
	if _cret != 0 {
		_ok = true
	}

	return _points, _ok
}

func (i iconInfo) BaseScale() int {
	var _arg0 *C.GtkIconInfo // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_info_get_base_scale(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (i iconInfo) BaseSize() int {
	var _arg0 *C.GtkIconInfo // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_info_get_base_size(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (i iconInfo) BuiltinPixbuf() gdkpixbuf.Pixbuf {
	var _arg0 *C.GtkIconInfo // out
	var _cret *C.GdkPixbuf   // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_info_get_builtin_pixbuf(_arg0)

	var _pixbuf gdkpixbuf.Pixbuf // out

	_pixbuf = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

	return _pixbuf
}

func (i iconInfo) DisplayName() string {
	var _arg0 *C.GtkIconInfo // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_info_get_display_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (i iconInfo) EmbeddedRect() (gdk.Rectangle, bool) {
	var _arg0 *C.GtkIconInfo // out
	var _arg1 C.GdkRectangle // in
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_info_get_embedded_rect(_arg0, &_arg1)

	var _rectangle gdk.Rectangle // out
	var _ok bool                 // out

	{
		var refTmpIn *C.GdkRectangle
		var refTmpOut *gdk.Rectangle

		in0 := &_arg1
		refTmpIn = in0

		refTmpOut = (*gdk.Rectangle)(unsafe.Pointer(refTmpIn))

		_rectangle = *refTmpOut
	}
	if _cret != 0 {
		_ok = true
	}

	return _rectangle, _ok
}

func (i iconInfo) Filename() string {
	var _arg0 *C.GtkIconInfo // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_info_get_filename(_arg0)

	var _filename string // out

	_filename = C.GoString(_cret)

	return _filename
}

func (i iconInfo) IsSymbolicIconInfo() bool {
	var _arg0 *C.GtkIconInfo // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_info_is_symbolic(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (i iconInfo) LoadIconIconInfo() (gdkpixbuf.Pixbuf, error) {
	var _arg0 *C.GtkIconInfo // out
	var _cret *C.GdkPixbuf   // in
	var _cerr *C.GError      // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_info_load_icon(_arg0, &_cerr)

	var _pixbuf gdkpixbuf.Pixbuf // out
	var _goerr error             // out

	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _pixbuf, _goerr
}

func (i iconInfo) LoadIconFinishIconInfo(res gio.AsyncResult) (gdkpixbuf.Pixbuf, error) {
	var _arg0 *C.GtkIconInfo  // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GdkPixbuf    // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.gtk_icon_info_load_icon_finish(_arg0, _arg1, &_cerr)

	var _pixbuf gdkpixbuf.Pixbuf // out
	var _goerr error             // out

	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _pixbuf, _goerr
}

func (i iconInfo) LoadSurfaceIconInfo(forWindow gdk.Window) (*cairo.Surface, error) {
	var _arg0 *C.GtkIconInfo     // out
	var _arg1 *C.GdkWindow       // out
	var _cret *C.cairo_surface_t // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GdkWindow)(unsafe.Pointer(forWindow.Native()))

	_cret = C.gtk_icon_info_load_surface(_arg0, _arg1, &_cerr)

	var _surface *cairo.Surface // out
	var _goerr error            // out

	_surface = (*cairo.Surface)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_surface, func(v **cairo.Surface) {
		C.free(unsafe.Pointer(v))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _surface, _goerr
}

func (i iconInfo) LoadSymbolicIconInfo(fg *gdk.RGBA, successColor *gdk.RGBA, warningColor *gdk.RGBA, errorColor *gdk.RGBA) (bool, gdkpixbuf.Pixbuf, error) {
	var _arg0 *C.GtkIconInfo // out
	var _arg1 *C.GdkRGBA     // out
	var _arg2 *C.GdkRGBA     // out
	var _arg3 *C.GdkRGBA     // out
	var _arg4 *C.GdkRGBA     // out
	var _arg5 C.gboolean     // in
	var _cret *C.GdkPixbuf   // in
	var _cerr *C.GError      // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GdkRGBA)(unsafe.Pointer(fg.Native()))
	_arg2 = (*C.GdkRGBA)(unsafe.Pointer(successColor.Native()))
	_arg3 = (*C.GdkRGBA)(unsafe.Pointer(warningColor.Native()))
	_arg4 = (*C.GdkRGBA)(unsafe.Pointer(errorColor.Native()))

	_cret = C.gtk_icon_info_load_symbolic(_arg0, _arg1, _arg2, _arg3, _arg4, &_arg5, &_cerr)

	var _wasSymbolic bool        // out
	var _pixbuf gdkpixbuf.Pixbuf // out
	var _goerr error             // out

	if _arg5 != 0 {
		_wasSymbolic = true
	}
	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _wasSymbolic, _pixbuf, _goerr
}

func (i iconInfo) LoadSymbolicFinishIconInfo(res gio.AsyncResult) (bool, gdkpixbuf.Pixbuf, error) {
	var _arg0 *C.GtkIconInfo  // out
	var _arg1 *C.GAsyncResult // out
	var _arg2 C.gboolean      // in
	var _cret *C.GdkPixbuf    // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.gtk_icon_info_load_symbolic_finish(_arg0, _arg1, &_arg2, &_cerr)

	var _wasSymbolic bool        // out
	var _pixbuf gdkpixbuf.Pixbuf // out
	var _goerr error             // out

	if _arg2 != 0 {
		_wasSymbolic = true
	}
	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _wasSymbolic, _pixbuf, _goerr
}

func (i iconInfo) LoadSymbolicForContextIconInfo(context StyleContext) (bool, gdkpixbuf.Pixbuf, error) {
	var _arg0 *C.GtkIconInfo     // out
	var _arg1 *C.GtkStyleContext // out
	var _arg2 C.gboolean         // in
	var _cret *C.GdkPixbuf       // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))

	_cret = C.gtk_icon_info_load_symbolic_for_context(_arg0, _arg1, &_arg2, &_cerr)

	var _wasSymbolic bool        // out
	var _pixbuf gdkpixbuf.Pixbuf // out
	var _goerr error             // out

	if _arg2 != 0 {
		_wasSymbolic = true
	}
	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _wasSymbolic, _pixbuf, _goerr
}

func (i iconInfo) LoadSymbolicForContextFinishIconInfo(res gio.AsyncResult) (bool, gdkpixbuf.Pixbuf, error) {
	var _arg0 *C.GtkIconInfo  // out
	var _arg1 *C.GAsyncResult // out
	var _arg2 C.gboolean      // in
	var _cret *C.GdkPixbuf    // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.gtk_icon_info_load_symbolic_for_context_finish(_arg0, _arg1, &_arg2, &_cerr)

	var _wasSymbolic bool        // out
	var _pixbuf gdkpixbuf.Pixbuf // out
	var _goerr error             // out

	if _arg2 != 0 {
		_wasSymbolic = true
	}
	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _wasSymbolic, _pixbuf, _goerr
}

func (i iconInfo) LoadSymbolicForStyleIconInfo(style Style, state StateType) (bool, gdkpixbuf.Pixbuf, error) {
	var _arg0 *C.GtkIconInfo // out
	var _arg1 *C.GtkStyle    // out
	var _arg2 C.GtkStateType // out
	var _arg3 C.gboolean     // in
	var _cret *C.GdkPixbuf   // in
	var _cerr *C.GError      // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
	_arg2 = C.GtkStateType(state)

	_cret = C.gtk_icon_info_load_symbolic_for_style(_arg0, _arg1, _arg2, &_arg3, &_cerr)

	var _wasSymbolic bool        // out
	var _pixbuf gdkpixbuf.Pixbuf // out
	var _goerr error             // out

	if _arg3 != 0 {
		_wasSymbolic = true
	}
	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _wasSymbolic, _pixbuf, _goerr
}

func (i iconInfo) SetRawCoordinatesIconInfo(rawCoordinates bool) {
	var _arg0 *C.GtkIconInfo // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))
	if rawCoordinates {
		_arg1 = C.TRUE
	}

	C.gtk_icon_info_set_raw_coordinates(_arg0, _arg1)
}

// IconTheme provides a facility for looking up icons by name and size. The main
// reason for using a name rather than simply providing a filename is to allow
// different icons to be used depending on what “icon theme” is selected by the
// user. The operation of icon themes on Linux and Unix follows the Icon Theme
// Specification (http://www.freedesktop.org/Standards/icon-theme-spec) There is
// a fallback icon theme, named `hicolor`, where applications should install
// their icons, but additional icon themes can be installed as operating system
// vendors and users choose.
//
// Named icons are similar to the deprecated [Stock Items][gtkstock], and the
// distinction between the two may be a bit confusing. A few things to keep in
// mind:
//
// - Stock images usually are used in conjunction with [Stock Items][gtkstock],
// such as GTK_STOCK_OK or GTK_STOCK_OPEN. Named icons are easier to set up and
// therefore are more useful for new icons that an application wants to add,
// such as application icons or window icons.
//
// - Stock images can only be loaded at the symbolic sizes defined by the
// IconSize enumeration, or by custom sizes defined by gtk_icon_size_register(),
// while named icons are more flexible and any pixel size can be specified.
//
// - Because stock images are closely tied to stock items, and thus to actions
// in the user interface, stock images may come in multiple variants for
// different widget states or writing directions.
//
// A good rule of thumb is that if there is a stock image for what you want to
// use, use it, otherwise use a named icon. It turns out that internally stock
// images are generally defined in terms of one or more named icons. (An example
// of the more than one case is icons that depend on writing direction;
// GTK_STOCK_GO_FORWARD uses the two themed icons “gtk-stock-go-forward-ltr” and
// “gtk-stock-go-forward-rtl”.)
//
// In many cases, named themes are used indirectly, via Image or stock items,
// rather than directly, but looking up icons directly is also simple. The
// IconTheme object acts as a database of all the icons in the current theme.
// You can create new IconTheme objects, but it’s much more efficient to use the
// standard icon theme for the Screen so that the icon information is shared
// with other people looking up icons.
//
//    GError *error = NULL;
//    GtkIconTheme *icon_theme;
//    GdkPixbuf *pixbuf;
//
//    icon_theme = gtk_icon_theme_get_default ();
//    pixbuf = gtk_icon_theme_load_icon (icon_theme,
//                                       "my-icon-name", // icon name
//                                       48, // icon size
//                                       0,  // flags
//                                       &error);
//    if (!pixbuf)
//      {
//        g_warning ("Couldn’t load icon: s", error->message);
//        g_error_free (error);
//      }
//    else
//      {
//        // Use the pixbuf
//        g_object_unref (pixbuf);
//      }
type IconTheme interface {
	gextras.Objector

	// AddResourcePathIconTheme:
	AddResourcePathIconTheme(path string)
	// AppendSearchPathIconTheme:
	AppendSearchPathIconTheme(path string)
	// ChooseIconIconTheme:
	ChooseIconIconTheme(iconNames []string, size int, flags IconLookupFlags) IconInfo
	// ChooseIconForScaleIconTheme:
	ChooseIconForScaleIconTheme(iconNames []string, size int, scale int, flags IconLookupFlags) IconInfo
	// ExampleIconName:
	ExampleIconName() string
	// IconSizes:
	IconSizes(iconName string) []int
	// SearchPath:
	SearchPath() []string
	// HasIconIconTheme:
	HasIconIconTheme(iconName string) bool
	// LoadIconIconTheme:
	LoadIconIconTheme(iconName string, size int, flags IconLookupFlags) (gdkpixbuf.Pixbuf, error)
	// LoadIconForScaleIconTheme:
	LoadIconForScaleIconTheme(iconName string, size int, scale int, flags IconLookupFlags) (gdkpixbuf.Pixbuf, error)
	// LoadSurfaceIconTheme:
	LoadSurfaceIconTheme(iconName string, size int, scale int, forWindow gdk.Window, flags IconLookupFlags) (*cairo.Surface, error)
	// LookupByGIconIconTheme:
	LookupByGIconIconTheme(icon gio.Icon, size int, flags IconLookupFlags) IconInfo
	// LookupByGIconForScaleIconTheme:
	LookupByGIconForScaleIconTheme(icon gio.Icon, size int, scale int, flags IconLookupFlags) IconInfo
	// LookupIconIconTheme:
	LookupIconIconTheme(iconName string, size int, flags IconLookupFlags) IconInfo
	// LookupIconForScaleIconTheme:
	LookupIconForScaleIconTheme(iconName string, size int, scale int, flags IconLookupFlags) IconInfo
	// PrependSearchPathIconTheme:
	PrependSearchPathIconTheme(path string)
	// RescanIfNeededIconTheme:
	RescanIfNeededIconTheme() bool
	// SetCustomThemeIconTheme:
	SetCustomThemeIconTheme(themeName string)
	// SetScreenIconTheme:
	SetScreenIconTheme(screen gdk.Screen)
	// SetSearchPathIconTheme:
	SetSearchPathIconTheme(path []string)
}

// iconTheme implements the IconTheme class.
type iconTheme struct {
	gextras.Objector
}

// WrapIconTheme wraps a GObject to the right type. It is
// primarily used internally.
func WrapIconTheme(obj *externglib.Object) IconTheme {
	return iconTheme{
		Objector: obj,
	}
}

func marshalIconTheme(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIconTheme(obj), nil
}

// NewIconTheme:
func NewIconTheme() IconTheme {
	var _cret *C.GtkIconTheme // in

	_cret = C.gtk_icon_theme_new()

	var _iconTheme IconTheme // out

	_iconTheme = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(IconTheme)

	return _iconTheme
}

func (i iconTheme) AddResourcePathIconTheme(path string) {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_icon_theme_add_resource_path(_arg0, _arg1)
}

func (i iconTheme) AppendSearchPathIconTheme(path string) {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_icon_theme_append_search_path(_arg0, _arg1)
}

func (i iconTheme) ChooseIconIconTheme(iconNames []string, size int, flags IconLookupFlags) IconInfo {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 **C.gchar
	var _arg2 C.gint               // out
	var _arg3 C.GtkIconLookupFlags // out
	var _cret *C.GtkIconInfo       // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(iconNames)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(iconNames))
		for i := range iconNames {
			out[i] = (*C.gchar)(C.CString(iconNames[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}
	_arg2 = C.gint(size)
	_arg3 = C.GtkIconLookupFlags(flags)

	_cret = C.gtk_icon_theme_choose_icon(_arg0, _arg1, _arg2, _arg3)

	var _iconInfo IconInfo // out

	_iconInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(IconInfo)

	return _iconInfo
}

func (i iconTheme) ChooseIconForScaleIconTheme(iconNames []string, size int, scale int, flags IconLookupFlags) IconInfo {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 **C.gchar
	var _arg2 C.gint               // out
	var _arg3 C.gint               // out
	var _arg4 C.GtkIconLookupFlags // out
	var _cret *C.GtkIconInfo       // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(iconNames)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(iconNames))
		for i := range iconNames {
			out[i] = (*C.gchar)(C.CString(iconNames[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}
	_arg2 = C.gint(size)
	_arg3 = C.gint(scale)
	_arg4 = C.GtkIconLookupFlags(flags)

	_cret = C.gtk_icon_theme_choose_icon_for_scale(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _iconInfo IconInfo // out

	_iconInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(IconInfo)

	return _iconInfo
}

func (i iconTheme) ExampleIconName() string {
	var _arg0 *C.GtkIconTheme // out
	var _cret *C.char         // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_theme_get_example_icon_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (i iconTheme) IconSizes(iconName string) []int {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.gchar        // out
	var _cret *C.gint

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_icon_theme_get_icon_sizes(_arg0, _arg1)

	var _gints []int

	{
		var i int
		var z C.gint
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_gints = make([]int, i)
		for i := range src {
			_gints[i] = int(src[i])
		}
	}

	return _gints
}

func (i iconTheme) SearchPath() []string {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 **C.gchar
	var _arg2 C.gint // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))

	C.gtk_icon_theme_get_search_path(_arg0, &_arg1, &_arg2)

	var _path []string

	defer C.free(unsafe.Pointer(_arg1))
	{
		src := unsafe.Slice(_arg1, _arg2)
		_path = make([]string, _arg2)
		for i := 0; i < int(_arg2); i++ {
			_path[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _path
}

func (i iconTheme) HasIconIconTheme(iconName string) bool {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_icon_theme_has_icon(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (i iconTheme) LoadIconIconTheme(iconName string, size int, flags IconLookupFlags) (gdkpixbuf.Pixbuf, error) {
	var _arg0 *C.GtkIconTheme      // out
	var _arg1 *C.gchar             // out
	var _arg2 C.gint               // out
	var _arg3 C.GtkIconLookupFlags // out
	var _cret *C.GdkPixbuf         // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(size)
	_arg3 = C.GtkIconLookupFlags(flags)

	_cret = C.gtk_icon_theme_load_icon(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _pixbuf gdkpixbuf.Pixbuf // out
	var _goerr error             // out

	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _pixbuf, _goerr
}

func (i iconTheme) LoadIconForScaleIconTheme(iconName string, size int, scale int, flags IconLookupFlags) (gdkpixbuf.Pixbuf, error) {
	var _arg0 *C.GtkIconTheme      // out
	var _arg1 *C.gchar             // out
	var _arg2 C.gint               // out
	var _arg3 C.gint               // out
	var _arg4 C.GtkIconLookupFlags // out
	var _cret *C.GdkPixbuf         // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(size)
	_arg3 = C.gint(scale)
	_arg4 = C.GtkIconLookupFlags(flags)

	_cret = C.gtk_icon_theme_load_icon_for_scale(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)

	var _pixbuf gdkpixbuf.Pixbuf // out
	var _goerr error             // out

	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _pixbuf, _goerr
}

func (i iconTheme) LoadSurfaceIconTheme(iconName string, size int, scale int, forWindow gdk.Window, flags IconLookupFlags) (*cairo.Surface, error) {
	var _arg0 *C.GtkIconTheme      // out
	var _arg1 *C.gchar             // out
	var _arg2 C.gint               // out
	var _arg3 C.gint               // out
	var _arg4 *C.GdkWindow         // out
	var _arg5 C.GtkIconLookupFlags // out
	var _cret *C.cairo_surface_t   // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(size)
	_arg3 = C.gint(scale)
	_arg4 = (*C.GdkWindow)(unsafe.Pointer(forWindow.Native()))
	_arg5 = C.GtkIconLookupFlags(flags)

	_cret = C.gtk_icon_theme_load_surface(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _surface *cairo.Surface // out
	var _goerr error            // out

	_surface = (*cairo.Surface)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_surface, func(v **cairo.Surface) {
		C.free(unsafe.Pointer(v))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _surface, _goerr
}

func (i iconTheme) LookupByGIconIconTheme(icon gio.Icon, size int, flags IconLookupFlags) IconInfo {
	var _arg0 *C.GtkIconTheme      // out
	var _arg1 *C.GIcon             // out
	var _arg2 C.gint               // out
	var _arg3 C.GtkIconLookupFlags // out
	var _cret *C.GtkIconInfo       // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))
	_arg2 = C.gint(size)
	_arg3 = C.GtkIconLookupFlags(flags)

	_cret = C.gtk_icon_theme_lookup_by_gicon(_arg0, _arg1, _arg2, _arg3)

	var _iconInfo IconInfo // out

	_iconInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(IconInfo)

	return _iconInfo
}

func (i iconTheme) LookupByGIconForScaleIconTheme(icon gio.Icon, size int, scale int, flags IconLookupFlags) IconInfo {
	var _arg0 *C.GtkIconTheme      // out
	var _arg1 *C.GIcon             // out
	var _arg2 C.gint               // out
	var _arg3 C.gint               // out
	var _arg4 C.GtkIconLookupFlags // out
	var _cret *C.GtkIconInfo       // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))
	_arg2 = C.gint(size)
	_arg3 = C.gint(scale)
	_arg4 = C.GtkIconLookupFlags(flags)

	_cret = C.gtk_icon_theme_lookup_by_gicon_for_scale(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _iconInfo IconInfo // out

	_iconInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(IconInfo)

	return _iconInfo
}

func (i iconTheme) LookupIconIconTheme(iconName string, size int, flags IconLookupFlags) IconInfo {
	var _arg0 *C.GtkIconTheme      // out
	var _arg1 *C.gchar             // out
	var _arg2 C.gint               // out
	var _arg3 C.GtkIconLookupFlags // out
	var _cret *C.GtkIconInfo       // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(size)
	_arg3 = C.GtkIconLookupFlags(flags)

	_cret = C.gtk_icon_theme_lookup_icon(_arg0, _arg1, _arg2, _arg3)

	var _iconInfo IconInfo // out

	_iconInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(IconInfo)

	return _iconInfo
}

func (i iconTheme) LookupIconForScaleIconTheme(iconName string, size int, scale int, flags IconLookupFlags) IconInfo {
	var _arg0 *C.GtkIconTheme      // out
	var _arg1 *C.gchar             // out
	var _arg2 C.gint               // out
	var _arg3 C.gint               // out
	var _arg4 C.GtkIconLookupFlags // out
	var _cret *C.GtkIconInfo       // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(size)
	_arg3 = C.gint(scale)
	_arg4 = C.GtkIconLookupFlags(flags)

	_cret = C.gtk_icon_theme_lookup_icon_for_scale(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _iconInfo IconInfo // out

	_iconInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(IconInfo)

	return _iconInfo
}

func (i iconTheme) PrependSearchPathIconTheme(path string) {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_icon_theme_prepend_search_path(_arg0, _arg1)
}

func (i iconTheme) RescanIfNeededIconTheme() bool {
	var _arg0 *C.GtkIconTheme // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_theme_rescan_if_needed(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (i iconTheme) SetCustomThemeIconTheme(themeName string) {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(themeName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_icon_theme_set_custom_theme(_arg0, _arg1)
}

func (i iconTheme) SetScreenIconTheme(screen gdk.Screen) {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.GdkScreen    // out

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GdkScreen)(unsafe.Pointer(screen.Native()))

	C.gtk_icon_theme_set_screen(_arg0, _arg1)
}

func (i iconTheme) SetSearchPathIconTheme(path []string) {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 **C.gchar
	var _arg2 C.gint

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
	_arg2 = C.gint(len(path))
	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(path)) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(path))
		for i := range path {
			out[i] = (*C.gchar)(C.CString(path[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.gtk_icon_theme_set_search_path(_arg0, _arg1, _arg2)
}
