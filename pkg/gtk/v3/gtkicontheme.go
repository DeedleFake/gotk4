// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk+-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_icon_info_get_type()), F: marshalIconInfo},
		{T: externglib.Type(C.gtk_icon_theme_get_type()), F: marshalIconTheme},
	})
}

// IconInfo contains information found when looking up an icon in an icon theme.
type IconInfo interface {
	gextras.Objector

	// Copy: make a copy of a IconInfo.
	Copy() IconInfo
	// Free: free a IconInfo and associated information
	Free()
	// AttachPoints: this function is deprecated and always returns false.
	AttachPoints() (points []*gdk.Point, nPoints int, ok bool)
	// BaseScale gets the base scale for the icon. The base scale is a scale for
	// the icon that was specified by the icon theme creator. For instance an
	// icon drawn for a high-dpi screen with window scale 2 for a base size of
	// 32 will be 64 pixels tall and have a base scale of 2.
	BaseScale() int
	// BaseSize gets the base size for the icon. The base size is a size for the
	// icon that was specified by the icon theme creator. This may be different
	// than the actual size of image; an example of this is small emblem icons
	// that can be attached to a larger icon. These icons will be given the same
	// base size as the larger icons to which they are attached.
	//
	// Note that for scaled icons the base size does not include the base scale.
	BaseSize() int
	// BuiltinPixbuf gets the built-in image for this icon, if any. To allow
	// GTK+ to use built in icon images, you must pass the
	// GTK_ICON_LOOKUP_USE_BUILTIN to gtk_icon_theme_lookup_icon().
	BuiltinPixbuf() gdkpixbuf.Pixbuf
	// DisplayName: this function is deprecated and always returns nil.
	DisplayName() string
	// EmbeddedRect: this function is deprecated and always returns false.
	EmbeddedRect() (rectangle gdk.Rectangle, ok bool)
	// Filename gets the filename for the icon. If the
	// GTK_ICON_LOOKUP_USE_BUILTIN flag was passed to
	// gtk_icon_theme_lookup_icon(), there may be no filename if a builtin icon
	// is returned; in this case, you should use
	// gtk_icon_info_get_builtin_pixbuf().
	Filename() string
	// IsSymbolic checks if the icon is symbolic or not. This currently uses
	// only the file name and not the file contents for determining this. This
	// behaviour may change in the future.
	IsSymbolic() bool
	// LoadIcon renders an icon previously looked up in an icon theme using
	// gtk_icon_theme_lookup_icon(); the size will be based on the size passed
	// to gtk_icon_theme_lookup_icon(). Note that the resulting pixbuf may not
	// be exactly this size; an icon theme may have icons that differ slightly
	// from their nominal sizes, and in addition GTK+ will avoid scaling icons
	// that it considers sufficiently close to the requested size or for which
	// the source image would have to be scaled up too far. (This maintains
	// sharpness.). This behaviour can be changed by passing the
	// GTK_ICON_LOOKUP_FORCE_SIZE flag when obtaining the IconInfo. If this flag
	// has been specified, the pixbuf returned by this function will be scaled
	// to the exact size.
	LoadIcon() (pixbuf gdkpixbuf.Pixbuf, err error)
	// LoadIconAsync: asynchronously load, render and scale an icon previously
	// looked up from the icon theme using gtk_icon_theme_lookup_icon().
	//
	// For more details, see gtk_icon_info_load_icon() which is the synchronous
	// version of this call.
	LoadIconAsync(cancellable gio.Cancellable, callback gio.AsyncReadyCallback)
	// LoadIconFinish finishes an async icon load, see
	// gtk_icon_info_load_icon_async().
	LoadIconFinish(res gio.AsyncResult) (pixbuf gdkpixbuf.Pixbuf, err error)
	// LoadSurface renders an icon previously looked up in an icon theme using
	// gtk_icon_theme_lookup_icon(); the size will be based on the size passed
	// to gtk_icon_theme_lookup_icon(). Note that the resulting surface may not
	// be exactly this size; an icon theme may have icons that differ slightly
	// from their nominal sizes, and in addition GTK+ will avoid scaling icons
	// that it considers sufficiently close to the requested size or for which
	// the source image would have to be scaled up too far. (This maintains
	// sharpness.). This behaviour can be changed by passing the
	// GTK_ICON_LOOKUP_FORCE_SIZE flag when obtaining the IconInfo. If this flag
	// has been specified, the pixbuf returned by this function will be scaled
	// to the exact size.
	LoadSurface(forWindow gdk.Window) (surface *cairo.Surface, err error)
	// LoadSymbolic loads an icon, modifying it to match the system colours for
	// the foreground, success, warning and error colors provided. If the icon
	// is not a symbolic one, the function will return the result from
	// gtk_icon_info_load_icon().
	//
	// This allows loading symbolic icons that will match the system theme.
	//
	// Unless you are implementing a widget, you will want to use
	// g_themed_icon_new_with_default_fallbacks() to load the icon.
	//
	// As implementation details, the icon loaded needs to be of SVG type,
	// contain the “symbolic” term as the last component of the icon name, and
	// use the “fg”, “success”, “warning” and “error” CSS styles in the SVG file
	// itself.
	//
	// See the Symbolic Icons Specification
	// (http://www.freedesktop.org/wiki/SymbolicIcons) for more information
	// about symbolic icons.
	LoadSymbolic(fg *gdk.RGBA, successColor *gdk.RGBA, warningColor *gdk.RGBA, errorColor *gdk.RGBA) (wasSymbolic bool, pixbuf gdkpixbuf.Pixbuf, err error)
	// LoadSymbolicAsync: asynchronously load, render and scale a symbolic icon
	// previously looked up from the icon theme using
	// gtk_icon_theme_lookup_icon().
	//
	// For more details, see gtk_icon_info_load_symbolic() which is the
	// synchronous version of this call.
	LoadSymbolicAsync(fg *gdk.RGBA, successColor *gdk.RGBA, warningColor *gdk.RGBA, errorColor *gdk.RGBA, cancellable gio.Cancellable, callback gio.AsyncReadyCallback)
	// LoadSymbolicFinish finishes an async icon load, see
	// gtk_icon_info_load_symbolic_async().
	LoadSymbolicFinish(res gio.AsyncResult) (wasSymbolic bool, pixbuf gdkpixbuf.Pixbuf, err error)
	// LoadSymbolicForContext loads an icon, modifying it to match the system
	// colors for the foreground, success, warning and error colors provided. If
	// the icon is not a symbolic one, the function will return the result from
	// gtk_icon_info_load_icon(). This function uses the regular foreground
	// color and the symbolic colors with the names “success_color”,
	// “warning_color” and “error_color” from the context.
	//
	// This allows loading symbolic icons that will match the system theme.
	//
	// See gtk_icon_info_load_symbolic() for more details.
	LoadSymbolicForContext(context StyleContext) (wasSymbolic bool, pixbuf gdkpixbuf.Pixbuf, err error)
	// LoadSymbolicForContextAsync: asynchronously load, render and scale a
	// symbolic icon previously looked up from the icon theme using
	// gtk_icon_theme_lookup_icon().
	//
	// For more details, see gtk_icon_info_load_symbolic_for_context() which is
	// the synchronous version of this call.
	LoadSymbolicForContextAsync(context StyleContext, cancellable gio.Cancellable, callback gio.AsyncReadyCallback)
	// LoadSymbolicForContextFinish finishes an async icon load, see
	// gtk_icon_info_load_symbolic_for_context_async().
	LoadSymbolicForContextFinish(res gio.AsyncResult) (wasSymbolic bool, pixbuf gdkpixbuf.Pixbuf, err error)
	// LoadSymbolicForStyle loads an icon, modifying it to match the system
	// colours for the foreground, success, warning and error colors provided.
	// If the icon is not a symbolic one, the function will return the result
	// from gtk_icon_info_load_icon().
	//
	// This allows loading symbolic icons that will match the system theme.
	//
	// See gtk_icon_info_load_symbolic() for more details.
	LoadSymbolicForStyle(style Style, state StateType) (wasSymbolic bool, pixbuf gdkpixbuf.Pixbuf, err error)
	// SetRawCoordinates sets whether the coordinates returned by
	// gtk_icon_info_get_embedded_rect() and gtk_icon_info_get_attach_points()
	// should be returned in their original form as specified in the icon theme,
	// instead of scaled appropriately for the pixbuf returned by
	// gtk_icon_info_load_icon().
	//
	// Raw coordinates are somewhat strange; they are specified to be with
	// respect to the unscaled pixmap for PNG and XPM icons, but for SVG icons,
	// they are in a 1000x1000 coordinate space that is scaled to the final size
	// of the icon. You can determine if the icon is an SVG icon by using
	// gtk_icon_info_get_filename(), and seeing if it is non-nil and ends in
	// “.svg”.
	//
	// This function is provided primarily to allow compatibility wrappers for
	// older API's, and is not expected to be useful for applications.
	SetRawCoordinates(rawCoordinates bool)
}

// iconInfo implements the IconInfo interface.
type iconInfo struct {
	gextras.Objector
}

var _ IconInfo = (*iconInfo)(nil)

// WrapIconInfo wraps a GObject to the right type. It is
// primarily used internally.
func WrapIconInfo(obj *externglib.Object) IconInfo {
	return IconInfo{
		Objector: obj,
	}
}

func marshalIconInfo(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIconInfo(obj), nil
}

// NewIconInfoForPixbuf constructs a class IconInfo.
func NewIconInfoForPixbuf(iconTheme IconTheme, pixbuf gdkpixbuf.Pixbuf) IconInfo {
	var arg1 *C.GtkIconTheme
	var arg2 *C.GdkPixbuf

	arg1 = (*C.GtkIconTheme)(iconTheme.Native())
	arg2 = (*C.GdkPixbuf)(pixbuf.Native())

	ret := C.gtk_icon_info_new_for_pixbuf(arg1, arg2)

	var ret0 IconInfo

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(IconInfo)

	return ret0
}

// Copy: make a copy of a IconInfo.
func (i iconInfo) Copy() IconInfo {
	var arg0 *C.GtkIconInfo

	arg0 = (*C.GtkIconInfo)(i.Native())

	ret := C.gtk_icon_info_copy(arg0)

	var ret0 IconInfo

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(IconInfo)

	return ret0
}

// Free: free a IconInfo and associated information
func (i iconInfo) Free() {
	var arg0 *C.GtkIconInfo

	arg0 = (*C.GtkIconInfo)(i.Native())

	C.gtk_icon_info_free(arg0)
}

// AttachPoints: this function is deprecated and always returns false.
func (i iconInfo) AttachPoints() (points []*gdk.Point, nPoints int, ok bool) {
	var arg0 *C.GtkIconInfo
	var arg1 **C.GdkPoint // out
	var arg2 *C.gint      // out

	arg0 = (*C.GtkIconInfo)(i.Native())

	ret := C.gtk_icon_info_get_attach_points(arg0, &arg1, &arg2)

	var ret0 []*gdk.Point
	var ret1 int
	var ret2 bool

	{
		ret0 = make([]*gdk.Point, arg2)
		for i := 0; i < uintptr(arg2); i++ {
			src := (*C.GdkPoint)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			{
				ret0[i] = gdk.WrapPoint(unsafe.Pointer(src))
				runtime.SetFinalizer(ret0[i], func(v *gdk.Point) {
					C.free(unsafe.Pointer(v.Native()))
				})
			}
		}
	}

	ret1 = int(arg2)

	ret2 = C.bool(ret) != C.false

	return ret0, ret1, ret2
}

// BaseScale gets the base scale for the icon. The base scale is a scale for
// the icon that was specified by the icon theme creator. For instance an
// icon drawn for a high-dpi screen with window scale 2 for a base size of
// 32 will be 64 pixels tall and have a base scale of 2.
func (i iconInfo) BaseScale() int {
	var arg0 *C.GtkIconInfo

	arg0 = (*C.GtkIconInfo)(i.Native())

	ret := C.gtk_icon_info_get_base_scale(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// BaseSize gets the base size for the icon. The base size is a size for the
// icon that was specified by the icon theme creator. This may be different
// than the actual size of image; an example of this is small emblem icons
// that can be attached to a larger icon. These icons will be given the same
// base size as the larger icons to which they are attached.
//
// Note that for scaled icons the base size does not include the base scale.
func (i iconInfo) BaseSize() int {
	var arg0 *C.GtkIconInfo

	arg0 = (*C.GtkIconInfo)(i.Native())

	ret := C.gtk_icon_info_get_base_size(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// BuiltinPixbuf gets the built-in image for this icon, if any. To allow
// GTK+ to use built in icon images, you must pass the
// GTK_ICON_LOOKUP_USE_BUILTIN to gtk_icon_theme_lookup_icon().
func (i iconInfo) BuiltinPixbuf() gdkpixbuf.Pixbuf {
	var arg0 *C.GtkIconInfo

	arg0 = (*C.GtkIconInfo)(i.Native())

	ret := C.gtk_icon_info_get_builtin_pixbuf(arg0)

	var ret0 gdkpixbuf.Pixbuf

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gdkpixbuf.Pixbuf)

	return ret0
}

// DisplayName: this function is deprecated and always returns nil.
func (i iconInfo) DisplayName() string {
	var arg0 *C.GtkIconInfo

	arg0 = (*C.GtkIconInfo)(i.Native())

	ret := C.gtk_icon_info_get_display_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// EmbeddedRect: this function is deprecated and always returns false.
func (i iconInfo) EmbeddedRect() (rectangle gdk.Rectangle, ok bool) {
	var arg0 *C.GtkIconInfo
	var arg1 *C.GdkRectangle // out

	arg0 = (*C.GtkIconInfo)(i.Native())

	ret := C.gtk_icon_info_get_embedded_rect(arg0, &arg1)

	var ret0 *gdk.Rectangle
	var ret1 bool

	{
		ret0 = gdk.WrapRectangle(unsafe.Pointer(arg1))
	}

	ret1 = C.bool(ret) != C.false

	return ret0, ret1
}

// Filename gets the filename for the icon. If the
// GTK_ICON_LOOKUP_USE_BUILTIN flag was passed to
// gtk_icon_theme_lookup_icon(), there may be no filename if a builtin icon
// is returned; in this case, you should use
// gtk_icon_info_get_builtin_pixbuf().
func (i iconInfo) Filename() string {
	var arg0 *C.GtkIconInfo

	arg0 = (*C.GtkIconInfo)(i.Native())

	ret := C.gtk_icon_info_get_filename(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// IsSymbolic checks if the icon is symbolic or not. This currently uses
// only the file name and not the file contents for determining this. This
// behaviour may change in the future.
func (i iconInfo) IsSymbolic() bool {
	var arg0 *C.GtkIconInfo

	arg0 = (*C.GtkIconInfo)(i.Native())

	ret := C.gtk_icon_info_is_symbolic(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// LoadIcon renders an icon previously looked up in an icon theme using
// gtk_icon_theme_lookup_icon(); the size will be based on the size passed
// to gtk_icon_theme_lookup_icon(). Note that the resulting pixbuf may not
// be exactly this size; an icon theme may have icons that differ slightly
// from their nominal sizes, and in addition GTK+ will avoid scaling icons
// that it considers sufficiently close to the requested size or for which
// the source image would have to be scaled up too far. (This maintains
// sharpness.). This behaviour can be changed by passing the
// GTK_ICON_LOOKUP_FORCE_SIZE flag when obtaining the IconInfo. If this flag
// has been specified, the pixbuf returned by this function will be scaled
// to the exact size.
func (i iconInfo) LoadIcon() (pixbuf gdkpixbuf.Pixbuf, err error) {
	var arg0 *C.GtkIconInfo
	var gError *C.GError

	arg0 = (*C.GtkIconInfo)(i.Native())

	ret := C.gtk_icon_info_load_icon(arg0, &gError)

	var ret0 gdkpixbuf.Pixbuf
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gdkpixbuf.Pixbuf)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// LoadIconAsync: asynchronously load, render and scale an icon previously
// looked up from the icon theme using gtk_icon_theme_lookup_icon().
//
// For more details, see gtk_icon_info_load_icon() which is the synchronous
// version of this call.
func (i iconInfo) LoadIconAsync(cancellable gio.Cancellable, callback gio.AsyncReadyCallback) {
	var arg0 *C.GtkIconInfo
	var arg1 *C.GCancellable
	var arg2 C.GAsyncReadyCallback
	var arg3 C.gpointer

	arg0 = (*C.GtkIconInfo)(i.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())
	arg2 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg3 = C.gpointer(box.Assign(callback))

	C.gtk_icon_info_load_icon_async(arg0, arg1, arg2, arg3)
}

// LoadIconFinish finishes an async icon load, see
// gtk_icon_info_load_icon_async().
func (i iconInfo) LoadIconFinish(res gio.AsyncResult) (pixbuf gdkpixbuf.Pixbuf, err error) {
	var arg0 *C.GtkIconInfo
	var arg1 *C.GAsyncResult
	var gError *C.GError

	arg0 = (*C.GtkIconInfo)(i.Native())
	arg1 = (*C.GAsyncResult)(res.Native())

	ret := C.gtk_icon_info_load_icon_finish(arg0, arg1, &gError)

	var ret0 gdkpixbuf.Pixbuf
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gdkpixbuf.Pixbuf)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// LoadSurface renders an icon previously looked up in an icon theme using
// gtk_icon_theme_lookup_icon(); the size will be based on the size passed
// to gtk_icon_theme_lookup_icon(). Note that the resulting surface may not
// be exactly this size; an icon theme may have icons that differ slightly
// from their nominal sizes, and in addition GTK+ will avoid scaling icons
// that it considers sufficiently close to the requested size or for which
// the source image would have to be scaled up too far. (This maintains
// sharpness.). This behaviour can be changed by passing the
// GTK_ICON_LOOKUP_FORCE_SIZE flag when obtaining the IconInfo. If this flag
// has been specified, the pixbuf returned by this function will be scaled
// to the exact size.
func (i iconInfo) LoadSurface(forWindow gdk.Window) (surface *cairo.Surface, err error) {
	var arg0 *C.GtkIconInfo
	var arg1 *C.GdkWindow
	var gError *C.GError

	arg0 = (*C.GtkIconInfo)(i.Native())
	arg1 = (*C.GdkWindow)(forWindow.Native())

	ret := C.gtk_icon_info_load_surface(arg0, arg1, &gError)

	var ret0 *cairo.Surface
	var goError error

	{
		ret0 = cairo.WrapSurface(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *cairo.Surface) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// LoadSymbolic loads an icon, modifying it to match the system colours for
// the foreground, success, warning and error colors provided. If the icon
// is not a symbolic one, the function will return the result from
// gtk_icon_info_load_icon().
//
// This allows loading symbolic icons that will match the system theme.
//
// Unless you are implementing a widget, you will want to use
// g_themed_icon_new_with_default_fallbacks() to load the icon.
//
// As implementation details, the icon loaded needs to be of SVG type,
// contain the “symbolic” term as the last component of the icon name, and
// use the “fg”, “success”, “warning” and “error” CSS styles in the SVG file
// itself.
//
// See the Symbolic Icons Specification
// (http://www.freedesktop.org/wiki/SymbolicIcons) for more information
// about symbolic icons.
func (i iconInfo) LoadSymbolic(fg *gdk.RGBA, successColor *gdk.RGBA, warningColor *gdk.RGBA, errorColor *gdk.RGBA) (wasSymbolic bool, pixbuf gdkpixbuf.Pixbuf, err error) {
	var arg0 *C.GtkIconInfo
	var arg1 *C.GdkRGBA
	var arg2 *C.GdkRGBA
	var arg3 *C.GdkRGBA
	var arg4 *C.GdkRGBA
	var arg5 *C.gboolean // out
	var gError *C.GError

	arg0 = (*C.GtkIconInfo)(i.Native())
	arg1 = (*C.GdkRGBA)(fg.Native())
	arg2 = (*C.GdkRGBA)(successColor.Native())
	arg3 = (*C.GdkRGBA)(warningColor.Native())
	arg4 = (*C.GdkRGBA)(errorColor.Native())

	ret := C.gtk_icon_info_load_symbolic(arg0, arg1, arg2, arg3, arg4, &arg5, &gError)

	var ret0 bool
	var ret1 gdkpixbuf.Pixbuf
	var goError error

	ret0 = C.bool(arg5) != C.false

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gdkpixbuf.Pixbuf)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// LoadSymbolicAsync: asynchronously load, render and scale a symbolic icon
// previously looked up from the icon theme using
// gtk_icon_theme_lookup_icon().
//
// For more details, see gtk_icon_info_load_symbolic() which is the
// synchronous version of this call.
func (i iconInfo) LoadSymbolicAsync(fg *gdk.RGBA, successColor *gdk.RGBA, warningColor *gdk.RGBA, errorColor *gdk.RGBA, cancellable gio.Cancellable, callback gio.AsyncReadyCallback) {
	var arg0 *C.GtkIconInfo
	var arg1 *C.GdkRGBA
	var arg2 *C.GdkRGBA
	var arg3 *C.GdkRGBA
	var arg4 *C.GdkRGBA
	var arg5 *C.GCancellable
	var arg6 C.GAsyncReadyCallback
	var arg7 C.gpointer

	arg0 = (*C.GtkIconInfo)(i.Native())
	arg1 = (*C.GdkRGBA)(fg.Native())
	arg2 = (*C.GdkRGBA)(successColor.Native())
	arg3 = (*C.GdkRGBA)(warningColor.Native())
	arg4 = (*C.GdkRGBA)(errorColor.Native())
	arg5 = (*C.GCancellable)(cancellable.Native())
	arg6 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg7 = C.gpointer(box.Assign(callback))

	C.gtk_icon_info_load_symbolic_async(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
}

// LoadSymbolicFinish finishes an async icon load, see
// gtk_icon_info_load_symbolic_async().
func (i iconInfo) LoadSymbolicFinish(res gio.AsyncResult) (wasSymbolic bool, pixbuf gdkpixbuf.Pixbuf, err error) {
	var arg0 *C.GtkIconInfo
	var arg1 *C.GAsyncResult
	var arg2 *C.gboolean // out
	var gError *C.GError

	arg0 = (*C.GtkIconInfo)(i.Native())
	arg1 = (*C.GAsyncResult)(res.Native())

	ret := C.gtk_icon_info_load_symbolic_finish(arg0, arg1, &arg2, &gError)

	var ret0 bool
	var ret1 gdkpixbuf.Pixbuf
	var goError error

	ret0 = C.bool(arg2) != C.false

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gdkpixbuf.Pixbuf)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// LoadSymbolicForContext loads an icon, modifying it to match the system
// colors for the foreground, success, warning and error colors provided. If
// the icon is not a symbolic one, the function will return the result from
// gtk_icon_info_load_icon(). This function uses the regular foreground
// color and the symbolic colors with the names “success_color”,
// “warning_color” and “error_color” from the context.
//
// This allows loading symbolic icons that will match the system theme.
//
// See gtk_icon_info_load_symbolic() for more details.
func (i iconInfo) LoadSymbolicForContext(context StyleContext) (wasSymbolic bool, pixbuf gdkpixbuf.Pixbuf, err error) {
	var arg0 *C.GtkIconInfo
	var arg1 *C.GtkStyleContext
	var arg2 *C.gboolean // out
	var gError *C.GError

	arg0 = (*C.GtkIconInfo)(i.Native())
	arg1 = (*C.GtkStyleContext)(context.Native())

	ret := C.gtk_icon_info_load_symbolic_for_context(arg0, arg1, &arg2, &gError)

	var ret0 bool
	var ret1 gdkpixbuf.Pixbuf
	var goError error

	ret0 = C.bool(arg2) != C.false

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gdkpixbuf.Pixbuf)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// LoadSymbolicForContextAsync: asynchronously load, render and scale a
// symbolic icon previously looked up from the icon theme using
// gtk_icon_theme_lookup_icon().
//
// For more details, see gtk_icon_info_load_symbolic_for_context() which is
// the synchronous version of this call.
func (i iconInfo) LoadSymbolicForContextAsync(context StyleContext, cancellable gio.Cancellable, callback gio.AsyncReadyCallback) {
	var arg0 *C.GtkIconInfo
	var arg1 *C.GtkStyleContext
	var arg2 *C.GCancellable
	var arg3 C.GAsyncReadyCallback
	var arg4 C.gpointer

	arg0 = (*C.GtkIconInfo)(i.Native())
	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = (*C.GCancellable)(cancellable.Native())
	arg3 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg4 = C.gpointer(box.Assign(callback))

	C.gtk_icon_info_load_symbolic_for_context_async(arg0, arg1, arg2, arg3, arg4)
}

// LoadSymbolicForContextFinish finishes an async icon load, see
// gtk_icon_info_load_symbolic_for_context_async().
func (i iconInfo) LoadSymbolicForContextFinish(res gio.AsyncResult) (wasSymbolic bool, pixbuf gdkpixbuf.Pixbuf, err error) {
	var arg0 *C.GtkIconInfo
	var arg1 *C.GAsyncResult
	var arg2 *C.gboolean // out
	var gError *C.GError

	arg0 = (*C.GtkIconInfo)(i.Native())
	arg1 = (*C.GAsyncResult)(res.Native())

	ret := C.gtk_icon_info_load_symbolic_for_context_finish(arg0, arg1, &arg2, &gError)

	var ret0 bool
	var ret1 gdkpixbuf.Pixbuf
	var goError error

	ret0 = C.bool(arg2) != C.false

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gdkpixbuf.Pixbuf)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// LoadSymbolicForStyle loads an icon, modifying it to match the system
// colours for the foreground, success, warning and error colors provided.
// If the icon is not a symbolic one, the function will return the result
// from gtk_icon_info_load_icon().
//
// This allows loading symbolic icons that will match the system theme.
//
// See gtk_icon_info_load_symbolic() for more details.
func (i iconInfo) LoadSymbolicForStyle(style Style, state StateType) (wasSymbolic bool, pixbuf gdkpixbuf.Pixbuf, err error) {
	var arg0 *C.GtkIconInfo
	var arg1 *C.GtkStyle
	var arg2 C.GtkStateType
	var arg3 *C.gboolean // out
	var gError *C.GError

	arg0 = (*C.GtkIconInfo)(i.Native())
	arg1 = (*C.GtkStyle)(style.Native())
	arg2 = (C.GtkStateType)(state)

	ret := C.gtk_icon_info_load_symbolic_for_style(arg0, arg1, arg2, &arg3, &gError)

	var ret0 bool
	var ret1 gdkpixbuf.Pixbuf
	var goError error

	ret0 = C.bool(arg3) != C.false

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gdkpixbuf.Pixbuf)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// SetRawCoordinates sets whether the coordinates returned by
// gtk_icon_info_get_embedded_rect() and gtk_icon_info_get_attach_points()
// should be returned in their original form as specified in the icon theme,
// instead of scaled appropriately for the pixbuf returned by
// gtk_icon_info_load_icon().
//
// Raw coordinates are somewhat strange; they are specified to be with
// respect to the unscaled pixmap for PNG and XPM icons, but for SVG icons,
// they are in a 1000x1000 coordinate space that is scaled to the final size
// of the icon. You can determine if the icon is an SVG icon by using
// gtk_icon_info_get_filename(), and seeing if it is non-nil and ends in
// “.svg”.
//
// This function is provided primarily to allow compatibility wrappers for
// older API's, and is not expected to be useful for applications.
func (i iconInfo) SetRawCoordinates(rawCoordinates bool) {
	var arg0 *C.GtkIconInfo
	var arg1 C.gboolean

	arg0 = (*C.GtkIconInfo)(i.Native())
	if rawCoordinates {
		arg1 = C.TRUE
	}

	C.gtk_icon_info_set_raw_coordinates(arg0, arg1)
}

// IconTheme provides a facility for looking up icons by name and size. The main
// reason for using a name rather than simply providing a filename is to allow
// different icons to be used depending on what “icon theme” is selected by the
// user. The operation of icon themes on Linux and Unix follows the Icon Theme
// Specification (http://www.freedesktop.org/Standards/icon-theme-spec) There is
// a fallback icon theme, named `hicolor`, where applications should install
// their icons, but additional icon themes can be installed as operating system
// vendors and users choose.
//
// Named icons are similar to the deprecated [Stock Items][gtkstock], and the
// distinction between the two may be a bit confusing. A few things to keep in
// mind:
//
// - Stock images usually are used in conjunction with [Stock Items][gtkstock],
// such as GTK_STOCK_OK or GTK_STOCK_OPEN. Named icons are easier to set up and
// therefore are more useful for new icons that an application wants to add,
// such as application icons or window icons.
//
// - Stock images can only be loaded at the symbolic sizes defined by the
// IconSize enumeration, or by custom sizes defined by gtk_icon_size_register(),
// while named icons are more flexible and any pixel size can be specified.
//
// - Because stock images are closely tied to stock items, and thus to actions
// in the user interface, stock images may come in multiple variants for
// different widget states or writing directions.
//
// A good rule of thumb is that if there is a stock image for what you want to
// use, use it, otherwise use a named icon. It turns out that internally stock
// images are generally defined in terms of one or more named icons. (An example
// of the more than one case is icons that depend on writing direction;
// GTK_STOCK_GO_FORWARD uses the two themed icons “gtk-stock-go-forward-ltr” and
// “gtk-stock-go-forward-rtl”.)
//
// In many cases, named themes are used indirectly, via Image or stock items,
// rather than directly, but looking up icons directly is also simple. The
// IconTheme object acts as a database of all the icons in the current theme.
// You can create new IconTheme objects, but it’s much more efficient to use the
// standard icon theme for the Screen so that the icon information is shared
// with other people looking up icons.
//
//    GError *error = NULL;
//    GtkIconTheme *icon_theme;
//    GdkPixbuf *pixbuf;
//
//    icon_theme = gtk_icon_theme_get_default ();
//    pixbuf = gtk_icon_theme_load_icon (icon_theme,
//                                       "my-icon-name", // icon name
//                                       48, // icon size
//                                       0,  // flags
//                                       &error);
//    if (!pixbuf)
//      {
//        g_warning ("Couldn’t load icon: s", error->message);
//        g_error_free (error);
//      }
//    else
//      {
//        // Use the pixbuf
//        g_object_unref (pixbuf);
//      }
type IconTheme interface {
	gextras.Objector

	// AddResourcePath adds a resource path that will be looked at when looking
	// for icons, similar to search paths.
	//
	// This function should be used to make application-specific icons available
	// as part of the icon theme.
	//
	// The resources are considered as part of the hicolor icon theme and must
	// be located in subdirectories that are defined in the hicolor icon theme,
	// such as `@path/16x16/actions/run.png`. Icons that are directly placed in
	// the resource path instead of a subdirectory are also considered as
	// ultimate fallback.
	AddResourcePath(path string)
	// AppendSearchPath appends a directory to the search path. See
	// gtk_icon_theme_set_search_path().
	AppendSearchPath(path string)
	// ChooseIcon looks up a named icon and returns a IconInfo containing
	// information such as the filename of the icon. The icon can then be
	// rendered into a pixbuf using gtk_icon_info_load_icon().
	// (gtk_icon_theme_load_icon() combines these two steps if all you need is
	// the pixbuf.)
	//
	// If @icon_names contains more than one name, this function tries them all
	// in the given order before falling back to inherited icon themes.
	ChooseIcon(iconNames []string, size int, flags IconLookupFlags) IconInfo
	// ChooseIconForScale looks up a named icon for a particular window scale
	// and returns a IconInfo containing information such as the filename of the
	// icon. The icon can then be rendered into a pixbuf using
	// gtk_icon_info_load_icon(). (gtk_icon_theme_load_icon() combines these two
	// steps if all you need is the pixbuf.)
	//
	// If @icon_names contains more than one name, this function tries them all
	// in the given order before falling back to inherited icon themes.
	ChooseIconForScale(iconNames []string, size int, scale int, flags IconLookupFlags) IconInfo
	// ExampleIconName gets the name of an icon that is representative of the
	// current theme (for instance, to use when presenting a list of themes to
	// the user.)
	ExampleIconName() string
	// IconSizes returns an array of integers describing the sizes at which the
	// icon is available without scaling. A size of -1 means that the icon is
	// available in a scalable format. The array is zero-terminated.
	IconSizes(iconName string) []int
	// SearchPath gets the current search path. See
	// gtk_icon_theme_set_search_path().
	SearchPath() (path []string, nElements int)
	// HasIcon checks whether an icon theme includes an icon for a particular
	// name.
	HasIcon(iconName string) bool
	// ListContexts gets the list of contexts available within the current
	// hierarchy of icon themes. See gtk_icon_theme_list_icons() for details
	// about contexts.
	ListContexts() *glib.List
	// ListIcons lists the icons in the current icon theme. Only a subset of the
	// icons can be listed by providing a context string. The set of values for
	// the context string is system dependent, but will typically include such
	// values as “Applications” and “MimeTypes”. Contexts are explained in the
	// Icon Theme Specification
	// (http://www.freedesktop.org/wiki/Specifications/icon-theme-spec). The
	// standard contexts are listed in the Icon Naming Specification
	// (http://www.freedesktop.org/wiki/Specifications/icon-naming-spec). Also
	// see gtk_icon_theme_list_contexts().
	ListIcons(context string) *glib.List
	// LoadIcon looks up an icon in an icon theme, scales it to the given size
	// and renders it into a pixbuf. This is a convenience function; if more
	// details about the icon are needed, use gtk_icon_theme_lookup_icon()
	// followed by gtk_icon_info_load_icon().
	//
	// Note that you probably want to listen for icon theme changes and update
	// the icon. This is usually done by connecting to the GtkWidget::style-set
	// signal. If for some reason you do not want to update the icon when the
	// icon theme changes, you should consider using gdk_pixbuf_copy() to make a
	// private copy of the pixbuf returned by this function. Otherwise GTK+ may
	// need to keep the old icon theme loaded, which would be a waste of memory.
	LoadIcon(iconName string, size int, flags IconLookupFlags) (pixbuf gdkpixbuf.Pixbuf, err error)
	// LoadIconForScale looks up an icon in an icon theme for a particular
	// window scale, scales it to the given size and renders it into a pixbuf.
	// This is a convenience function; if more details about the icon are
	// needed, use gtk_icon_theme_lookup_icon() followed by
	// gtk_icon_info_load_icon().
	//
	// Note that you probably want to listen for icon theme changes and update
	// the icon. This is usually done by connecting to the GtkWidget::style-set
	// signal. If for some reason you do not want to update the icon when the
	// icon theme changes, you should consider using gdk_pixbuf_copy() to make a
	// private copy of the pixbuf returned by this function. Otherwise GTK+ may
	// need to keep the old icon theme loaded, which would be a waste of memory.
	LoadIconForScale(iconName string, size int, scale int, flags IconLookupFlags) (pixbuf gdkpixbuf.Pixbuf, err error)
	// LoadSurface looks up an icon in an icon theme for a particular window
	// scale, scales it to the given size and renders it into a cairo surface.
	// This is a convenience function; if more details about the icon are
	// needed, use gtk_icon_theme_lookup_icon() followed by
	// gtk_icon_info_load_surface().
	//
	// Note that you probably want to listen for icon theme changes and update
	// the icon. This is usually done by connecting to the GtkWidget::style-set
	// signal.
	LoadSurface(iconName string, size int, scale int, forWindow gdk.Window, flags IconLookupFlags) (surface *cairo.Surface, err error)
	// LookupByGIcon looks up an icon and returns a IconInfo containing
	// information such as the filename of the icon. The icon can then be
	// rendered into a pixbuf using gtk_icon_info_load_icon().
	//
	// When rendering on displays with high pixel densities you should not use a
	// @size multiplied by the scaling factor returned by functions like
	// gdk_window_get_scale_factor(). Instead, you should use
	// gtk_icon_theme_lookup_by_gicon_for_scale(), as the assets loaded for a
	// given scaling factor may be different.
	LookupByGIcon(icon gio.Icon, size int, flags IconLookupFlags) IconInfo
	// LookupByGIconForScale looks up an icon and returns a IconInfo containing
	// information such as the filename of the icon. The icon can then be
	// rendered into a pixbuf using gtk_icon_info_load_icon().
	LookupByGIconForScale(icon gio.Icon, size int, scale int, flags IconLookupFlags) IconInfo
	// LookupIcon looks up a named icon and returns a IconInfo containing
	// information such as the filename of the icon. The icon can then be
	// rendered into a pixbuf using gtk_icon_info_load_icon().
	// (gtk_icon_theme_load_icon() combines these two steps if all you need is
	// the pixbuf.)
	//
	// When rendering on displays with high pixel densities you should not use a
	// @size multiplied by the scaling factor returned by functions like
	// gdk_window_get_scale_factor(). Instead, you should use
	// gtk_icon_theme_lookup_icon_for_scale(), as the assets loaded for a given
	// scaling factor may be different.
	LookupIcon(iconName string, size int, flags IconLookupFlags) IconInfo
	// LookupIconForScale looks up a named icon for a particular window scale
	// and returns a IconInfo containing information such as the filename of the
	// icon. The icon can then be rendered into a pixbuf using
	// gtk_icon_info_load_icon(). (gtk_icon_theme_load_icon() combines these two
	// steps if all you need is the pixbuf.)
	LookupIconForScale(iconName string, size int, scale int, flags IconLookupFlags) IconInfo
	// PrependSearchPath prepends a directory to the search path. See
	// gtk_icon_theme_set_search_path().
	PrependSearchPath(path string)
	// RescanIfNeeded checks to see if the icon theme has changed; if it has,
	// any currently cached information is discarded and will be reloaded next
	// time @icon_theme is accessed.
	RescanIfNeeded() bool
	// SetCustomTheme sets the name of the icon theme that the IconTheme object
	// uses overriding system configuration. This function cannot be called on
	// the icon theme objects returned from gtk_icon_theme_get_default() and
	// gtk_icon_theme_get_for_screen().
	SetCustomTheme(themeName string)
	// SetScreen sets the screen for an icon theme; the screen is used to track
	// the user’s currently configured icon theme, which might be different for
	// different screens.
	SetScreen(screen gdk.Screen)
	// SetSearchPath sets the search path for the icon theme object. When
	// looking for an icon theme, GTK+ will search for a subdirectory of one or
	// more of the directories in @path with the same name as the icon theme
	// containing an index.theme file. (Themes from multiple of the path
	// elements are combined to allow themes to be extended by adding icons in
	// the user’s home directory.)
	//
	// In addition if an icon found isn’t found either in the current icon theme
	// or the default icon theme, and an image file with the right name is found
	// directly in one of the elements of @path, then that image will be used
	// for the icon name. (This is legacy feature, and new icons should be put
	// into the fallback icon theme, which is called hicolor, rather than
	// directly on the icon path.)
	SetSearchPath(path []string)
}

// iconTheme implements the IconTheme interface.
type iconTheme struct {
	gextras.Objector
}

var _ IconTheme = (*iconTheme)(nil)

// WrapIconTheme wraps a GObject to the right type. It is
// primarily used internally.
func WrapIconTheme(obj *externglib.Object) IconTheme {
	return IconTheme{
		Objector: obj,
	}
}

func marshalIconTheme(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIconTheme(obj), nil
}

// NewIconTheme constructs a class IconTheme.
func NewIconTheme() IconTheme {
	ret := C.gtk_icon_theme_new()

	var ret0 IconTheme

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(IconTheme)

	return ret0
}

// AddResourcePath adds a resource path that will be looked at when looking
// for icons, similar to search paths.
//
// This function should be used to make application-specific icons available
// as part of the icon theme.
//
// The resources are considered as part of the hicolor icon theme and must
// be located in subdirectories that are defined in the hicolor icon theme,
// such as `@path/16x16/actions/run.png`. Icons that are directly placed in
// the resource path instead of a subdirectory are also considered as
// ultimate fallback.
func (i iconTheme) AddResourcePath(path string) {
	var arg0 *C.GtkIconTheme
	var arg1 *C.gchar

	arg0 = (*C.GtkIconTheme)(i.Native())
	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_icon_theme_add_resource_path(arg0, arg1)
}

// AppendSearchPath appends a directory to the search path. See
// gtk_icon_theme_set_search_path().
func (i iconTheme) AppendSearchPath(path string) {
	var arg0 *C.GtkIconTheme
	var arg1 *C.gchar

	arg0 = (*C.GtkIconTheme)(i.Native())
	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_icon_theme_append_search_path(arg0, arg1)
}

// ChooseIcon looks up a named icon and returns a IconInfo containing
// information such as the filename of the icon. The icon can then be
// rendered into a pixbuf using gtk_icon_info_load_icon().
// (gtk_icon_theme_load_icon() combines these two steps if all you need is
// the pixbuf.)
//
// If @icon_names contains more than one name, this function tries them all
// in the given order before falling back to inherited icon themes.
func (i iconTheme) ChooseIcon(iconNames []string, size int, flags IconLookupFlags) IconInfo {
	var arg0 *C.GtkIconTheme
	var arg1 **C.gchar
	var arg2 C.gint
	var arg3 C.GtkIconLookupFlags

	arg0 = (*C.GtkIconTheme)(i.Native())
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(iconNames) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(iconNames)
		sliceHeader.Cap = len(iconNames)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(iconNames); i++ {
			src := iconNames[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg1 = (**C.gchar)(unsafe.Pointer(ptr))
	}
	arg2 = C.gint(size)
	arg3 = (C.GtkIconLookupFlags)(flags)

	ret := C.gtk_icon_theme_choose_icon(arg0, arg1, arg2, arg3)

	var ret0 IconInfo

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(IconInfo)

	return ret0
}

// ChooseIconForScale looks up a named icon for a particular window scale
// and returns a IconInfo containing information such as the filename of the
// icon. The icon can then be rendered into a pixbuf using
// gtk_icon_info_load_icon(). (gtk_icon_theme_load_icon() combines these two
// steps if all you need is the pixbuf.)
//
// If @icon_names contains more than one name, this function tries them all
// in the given order before falling back to inherited icon themes.
func (i iconTheme) ChooseIconForScale(iconNames []string, size int, scale int, flags IconLookupFlags) IconInfo {
	var arg0 *C.GtkIconTheme
	var arg1 **C.gchar
	var arg2 C.gint
	var arg3 C.gint
	var arg4 C.GtkIconLookupFlags

	arg0 = (*C.GtkIconTheme)(i.Native())
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(iconNames) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(iconNames)
		sliceHeader.Cap = len(iconNames)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(iconNames); i++ {
			src := iconNames[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg1 = (**C.gchar)(unsafe.Pointer(ptr))
	}
	arg2 = C.gint(size)
	arg3 = C.gint(scale)
	arg4 = (C.GtkIconLookupFlags)(flags)

	ret := C.gtk_icon_theme_choose_icon_for_scale(arg0, arg1, arg2, arg3, arg4)

	var ret0 IconInfo

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(IconInfo)

	return ret0
}

// ExampleIconName gets the name of an icon that is representative of the
// current theme (for instance, to use when presenting a list of themes to
// the user.)
func (i iconTheme) ExampleIconName() string {
	var arg0 *C.GtkIconTheme

	arg0 = (*C.GtkIconTheme)(i.Native())

	ret := C.gtk_icon_theme_get_example_icon_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// IconSizes returns an array of integers describing the sizes at which the
// icon is available without scaling. A size of -1 means that the icon is
// available in a scalable format. The array is zero-terminated.
func (i iconTheme) IconSizes(iconName string) []int {
	var arg0 *C.GtkIconTheme
	var arg1 *C.gchar

	arg0 = (*C.GtkIconTheme)(i.Native())
	arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_icon_theme_get_icon_sizes(arg0, arg1)

	var ret0 []int

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]int, length)
		for i := 0; i < length; i++ {
			src := (C.gint)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = int(src)
		}
	}

	return ret0
}

// SearchPath gets the current search path. See
// gtk_icon_theme_set_search_path().
func (i iconTheme) SearchPath() (path []string, nElements int) {
	var arg0 *C.GtkIconTheme
	var arg1 ***C.gchar // out
	var arg2 *C.gint    // out

	arg0 = (*C.GtkIconTheme)(i.Native())

	C.gtk_icon_theme_get_search_path(arg0, &arg1, &arg2)

	var ret0 []string
	var ret1 int

	{
		ret0 = make([]string, arg2)
		for i := 0; i < uintptr(arg2); i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	ret1 = int(arg2)

	return ret0, ret1
}

// HasIcon checks whether an icon theme includes an icon for a particular
// name.
func (i iconTheme) HasIcon(iconName string) bool {
	var arg0 *C.GtkIconTheme
	var arg1 *C.gchar

	arg0 = (*C.GtkIconTheme)(i.Native())
	arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_icon_theme_has_icon(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// ListContexts gets the list of contexts available within the current
// hierarchy of icon themes. See gtk_icon_theme_list_icons() for details
// about contexts.
func (i iconTheme) ListContexts() *glib.List {
	var arg0 *C.GtkIconTheme

	arg0 = (*C.GtkIconTheme)(i.Native())

	ret := C.gtk_icon_theme_list_contexts(arg0)

	var ret0 *glib.List

	{
		ret0 = glib.WrapList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.List) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// ListIcons lists the icons in the current icon theme. Only a subset of the
// icons can be listed by providing a context string. The set of values for
// the context string is system dependent, but will typically include such
// values as “Applications” and “MimeTypes”. Contexts are explained in the
// Icon Theme Specification
// (http://www.freedesktop.org/wiki/Specifications/icon-theme-spec). The
// standard contexts are listed in the Icon Naming Specification
// (http://www.freedesktop.org/wiki/Specifications/icon-naming-spec). Also
// see gtk_icon_theme_list_contexts().
func (i iconTheme) ListIcons(context string) *glib.List {
	var arg0 *C.GtkIconTheme
	var arg1 *C.gchar

	arg0 = (*C.GtkIconTheme)(i.Native())
	arg1 = (*C.gchar)(C.CString(context))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_icon_theme_list_icons(arg0, arg1)

	var ret0 *glib.List

	{
		ret0 = glib.WrapList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.List) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// LoadIcon looks up an icon in an icon theme, scales it to the given size
// and renders it into a pixbuf. This is a convenience function; if more
// details about the icon are needed, use gtk_icon_theme_lookup_icon()
// followed by gtk_icon_info_load_icon().
//
// Note that you probably want to listen for icon theme changes and update
// the icon. This is usually done by connecting to the GtkWidget::style-set
// signal. If for some reason you do not want to update the icon when the
// icon theme changes, you should consider using gdk_pixbuf_copy() to make a
// private copy of the pixbuf returned by this function. Otherwise GTK+ may
// need to keep the old icon theme loaded, which would be a waste of memory.
func (i iconTheme) LoadIcon(iconName string, size int, flags IconLookupFlags) (pixbuf gdkpixbuf.Pixbuf, err error) {
	var arg0 *C.GtkIconTheme
	var arg1 *C.gchar
	var arg2 C.gint
	var arg3 C.GtkIconLookupFlags
	var gError *C.GError

	arg0 = (*C.GtkIconTheme)(i.Native())
	arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(size)
	arg3 = (C.GtkIconLookupFlags)(flags)

	ret := C.gtk_icon_theme_load_icon(arg0, arg1, arg2, arg3, &gError)

	var ret0 gdkpixbuf.Pixbuf
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gdkpixbuf.Pixbuf)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// LoadIconForScale looks up an icon in an icon theme for a particular
// window scale, scales it to the given size and renders it into a pixbuf.
// This is a convenience function; if more details about the icon are
// needed, use gtk_icon_theme_lookup_icon() followed by
// gtk_icon_info_load_icon().
//
// Note that you probably want to listen for icon theme changes and update
// the icon. This is usually done by connecting to the GtkWidget::style-set
// signal. If for some reason you do not want to update the icon when the
// icon theme changes, you should consider using gdk_pixbuf_copy() to make a
// private copy of the pixbuf returned by this function. Otherwise GTK+ may
// need to keep the old icon theme loaded, which would be a waste of memory.
func (i iconTheme) LoadIconForScale(iconName string, size int, scale int, flags IconLookupFlags) (pixbuf gdkpixbuf.Pixbuf, err error) {
	var arg0 *C.GtkIconTheme
	var arg1 *C.gchar
	var arg2 C.gint
	var arg3 C.gint
	var arg4 C.GtkIconLookupFlags
	var gError *C.GError

	arg0 = (*C.GtkIconTheme)(i.Native())
	arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(size)
	arg3 = C.gint(scale)
	arg4 = (C.GtkIconLookupFlags)(flags)

	ret := C.gtk_icon_theme_load_icon_for_scale(arg0, arg1, arg2, arg3, arg4, &gError)

	var ret0 gdkpixbuf.Pixbuf
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gdkpixbuf.Pixbuf)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// LoadSurface looks up an icon in an icon theme for a particular window
// scale, scales it to the given size and renders it into a cairo surface.
// This is a convenience function; if more details about the icon are
// needed, use gtk_icon_theme_lookup_icon() followed by
// gtk_icon_info_load_surface().
//
// Note that you probably want to listen for icon theme changes and update
// the icon. This is usually done by connecting to the GtkWidget::style-set
// signal.
func (i iconTheme) LoadSurface(iconName string, size int, scale int, forWindow gdk.Window, flags IconLookupFlags) (surface *cairo.Surface, err error) {
	var arg0 *C.GtkIconTheme
	var arg1 *C.gchar
	var arg2 C.gint
	var arg3 C.gint
	var arg4 *C.GdkWindow
	var arg5 C.GtkIconLookupFlags
	var gError *C.GError

	arg0 = (*C.GtkIconTheme)(i.Native())
	arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(size)
	arg3 = C.gint(scale)
	arg4 = (*C.GdkWindow)(forWindow.Native())
	arg5 = (C.GtkIconLookupFlags)(flags)

	ret := C.gtk_icon_theme_load_surface(arg0, arg1, arg2, arg3, arg4, arg5, &gError)

	var ret0 *cairo.Surface
	var goError error

	{
		ret0 = cairo.WrapSurface(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *cairo.Surface) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// LookupByGIcon looks up an icon and returns a IconInfo containing
// information such as the filename of the icon. The icon can then be
// rendered into a pixbuf using gtk_icon_info_load_icon().
//
// When rendering on displays with high pixel densities you should not use a
// @size multiplied by the scaling factor returned by functions like
// gdk_window_get_scale_factor(). Instead, you should use
// gtk_icon_theme_lookup_by_gicon_for_scale(), as the assets loaded for a
// given scaling factor may be different.
func (i iconTheme) LookupByGIcon(icon gio.Icon, size int, flags IconLookupFlags) IconInfo {
	var arg0 *C.GtkIconTheme
	var arg1 *C.GIcon
	var arg2 C.gint
	var arg3 C.GtkIconLookupFlags

	arg0 = (*C.GtkIconTheme)(i.Native())
	arg1 = (*C.GIcon)(icon.Native())
	arg2 = C.gint(size)
	arg3 = (C.GtkIconLookupFlags)(flags)

	ret := C.gtk_icon_theme_lookup_by_gicon(arg0, arg1, arg2, arg3)

	var ret0 IconInfo

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(IconInfo)

	return ret0
}

// LookupByGIconForScale looks up an icon and returns a IconInfo containing
// information such as the filename of the icon. The icon can then be
// rendered into a pixbuf using gtk_icon_info_load_icon().
func (i iconTheme) LookupByGIconForScale(icon gio.Icon, size int, scale int, flags IconLookupFlags) IconInfo {
	var arg0 *C.GtkIconTheme
	var arg1 *C.GIcon
	var arg2 C.gint
	var arg3 C.gint
	var arg4 C.GtkIconLookupFlags

	arg0 = (*C.GtkIconTheme)(i.Native())
	arg1 = (*C.GIcon)(icon.Native())
	arg2 = C.gint(size)
	arg3 = C.gint(scale)
	arg4 = (C.GtkIconLookupFlags)(flags)

	ret := C.gtk_icon_theme_lookup_by_gicon_for_scale(arg0, arg1, arg2, arg3, arg4)

	var ret0 IconInfo

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(IconInfo)

	return ret0
}

// LookupIcon looks up a named icon and returns a IconInfo containing
// information such as the filename of the icon. The icon can then be
// rendered into a pixbuf using gtk_icon_info_load_icon().
// (gtk_icon_theme_load_icon() combines these two steps if all you need is
// the pixbuf.)
//
// When rendering on displays with high pixel densities you should not use a
// @size multiplied by the scaling factor returned by functions like
// gdk_window_get_scale_factor(). Instead, you should use
// gtk_icon_theme_lookup_icon_for_scale(), as the assets loaded for a given
// scaling factor may be different.
func (i iconTheme) LookupIcon(iconName string, size int, flags IconLookupFlags) IconInfo {
	var arg0 *C.GtkIconTheme
	var arg1 *C.gchar
	var arg2 C.gint
	var arg3 C.GtkIconLookupFlags

	arg0 = (*C.GtkIconTheme)(i.Native())
	arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(size)
	arg3 = (C.GtkIconLookupFlags)(flags)

	ret := C.gtk_icon_theme_lookup_icon(arg0, arg1, arg2, arg3)

	var ret0 IconInfo

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(IconInfo)

	return ret0
}

// LookupIconForScale looks up a named icon for a particular window scale
// and returns a IconInfo containing information such as the filename of the
// icon. The icon can then be rendered into a pixbuf using
// gtk_icon_info_load_icon(). (gtk_icon_theme_load_icon() combines these two
// steps if all you need is the pixbuf.)
func (i iconTheme) LookupIconForScale(iconName string, size int, scale int, flags IconLookupFlags) IconInfo {
	var arg0 *C.GtkIconTheme
	var arg1 *C.gchar
	var arg2 C.gint
	var arg3 C.gint
	var arg4 C.GtkIconLookupFlags

	arg0 = (*C.GtkIconTheme)(i.Native())
	arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(size)
	arg3 = C.gint(scale)
	arg4 = (C.GtkIconLookupFlags)(flags)

	ret := C.gtk_icon_theme_lookup_icon_for_scale(arg0, arg1, arg2, arg3, arg4)

	var ret0 IconInfo

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(IconInfo)

	return ret0
}

// PrependSearchPath prepends a directory to the search path. See
// gtk_icon_theme_set_search_path().
func (i iconTheme) PrependSearchPath(path string) {
	var arg0 *C.GtkIconTheme
	var arg1 *C.gchar

	arg0 = (*C.GtkIconTheme)(i.Native())
	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_icon_theme_prepend_search_path(arg0, arg1)
}

// RescanIfNeeded checks to see if the icon theme has changed; if it has,
// any currently cached information is discarded and will be reloaded next
// time @icon_theme is accessed.
func (i iconTheme) RescanIfNeeded() bool {
	var arg0 *C.GtkIconTheme

	arg0 = (*C.GtkIconTheme)(i.Native())

	ret := C.gtk_icon_theme_rescan_if_needed(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// SetCustomTheme sets the name of the icon theme that the IconTheme object
// uses overriding system configuration. This function cannot be called on
// the icon theme objects returned from gtk_icon_theme_get_default() and
// gtk_icon_theme_get_for_screen().
func (i iconTheme) SetCustomTheme(themeName string) {
	var arg0 *C.GtkIconTheme
	var arg1 *C.gchar

	arg0 = (*C.GtkIconTheme)(i.Native())
	arg1 = (*C.gchar)(C.CString(themeName))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_icon_theme_set_custom_theme(arg0, arg1)
}

// SetScreen sets the screen for an icon theme; the screen is used to track
// the user’s currently configured icon theme, which might be different for
// different screens.
func (i iconTheme) SetScreen(screen gdk.Screen) {
	var arg0 *C.GtkIconTheme
	var arg1 *C.GdkScreen

	arg0 = (*C.GtkIconTheme)(i.Native())
	arg1 = (*C.GdkScreen)(screen.Native())

	C.gtk_icon_theme_set_screen(arg0, arg1)
}

// SetSearchPath sets the search path for the icon theme object. When
// looking for an icon theme, GTK+ will search for a subdirectory of one or
// more of the directories in @path with the same name as the icon theme
// containing an index.theme file. (Themes from multiple of the path
// elements are combined to allow themes to be extended by adding icons in
// the user’s home directory.)
//
// In addition if an icon found isn’t found either in the current icon theme
// or the default icon theme, and an image file with the right name is found
// directly in one of the elements of @path, then that image will be used
// for the icon name. (This is legacy feature, and new icons should be put
// into the fallback icon theme, which is called hicolor, rather than
// directly on the icon path.)
func (i iconTheme) SetSearchPath(path []string) {
	var arg0 *C.GtkIconTheme
	var arg1 **C.gchar
	var arg2 C.gint

	arg0 = (*C.GtkIconTheme)(i.Native())
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * len(path))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(path)
		sliceHeader.Cap = len(path)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(path); i++ {
			src := path[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg1 = (**C.gchar)(unsafe.Pointer(ptr))
		arg2 = len(path)
	}

	C.gtk_icon_theme_set_search_path(arg0, arg1, arg2)
}

type IconThemePrivate struct {
	native C.GtkIconThemePrivate
}

// WrapIconThemePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapIconThemePrivate(ptr unsafe.Pointer) *IconThemePrivate {
	if ptr == nil {
		return nil
	}

	return (*IconThemePrivate)(ptr)
}

func marshalIconThemePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapIconThemePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (i *IconThemePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}
