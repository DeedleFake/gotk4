// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/core/gextras"
	"github.com/diamondburned/gotk4/pkg/cairo"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk+-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_container_get_type()), F: marshalContainer},
	})
}

// Container: a GTK+ user interface is constructed by nesting widgets inside
// widgets. Container widgets are the inner nodes in the resulting tree of
// widgets: they contain other widgets. So, for example, you might have a Window
// containing a Frame containing a Label. If you wanted an image instead of a
// textual label inside the frame, you might replace the Label widget with a
// Image widget.
//
// There are two major kinds of container widgets in GTK+. Both are subclasses
// of the abstract GtkContainer base class.
//
// The first type of container widget has a single child widget and derives from
// Bin. These containers are decorators, which add some kind of functionality to
// the child. For example, a Button makes its child into a clickable button; a
// Frame draws a frame around its child and a Window places its child widget
// inside a top-level window.
//
// The second type of container can have more than one child; its purpose is to
// manage layout. This means that these containers assign sizes and positions to
// their children. For example, a HBox arranges its children in a horizontal
// row, and a Grid arranges the widgets it contains in a two-dimensional grid.
//
// For implementations of Container the virtual method ContainerClass.forall()
// is always required, since it's used for drawing and other internal operations
// on the children. If the Container implementation expect to have non internal
// children it's needed to implement both ContainerClass.add() and
// ContainerClass.remove(). If the GtkContainer implementation has internal
// children, they should be added with gtk_widget_set_parent() on init() and
// removed with gtk_widget_unparent() in the WidgetClass.destroy()
// implementation. See more about implementing custom widgets at
// https://wiki.gnome.org/HowDoI/CustomWidgets
//
//
// Height for width geometry management
//
// GTK+ uses a height-for-width (and width-for-height) geometry management
// system. Height-for-width means that a widget can change how much vertical
// space it needs, depending on the amount of horizontal space that it is given
// (and similar for width-for-height).
//
// There are some things to keep in mind when implementing container widgets
// that make use of GTK+’s height for width geometry management system. First,
// it’s important to note that a container must prioritize one of its
// dimensions, that is to say that a widget or container can only have a
// SizeRequestMode that is GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH or
// GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT. However, every widget and container must
// be able to respond to the APIs for both dimensions, i.e. even if a widget has
// a request mode that is height-for-width, it is possible that its parent will
// request its sizes using the width-for-height APIs.
//
// To ensure that everything works properly, here are some guidelines to follow
// when implementing height-for-width (or width-for-height) containers.
//
// Each request mode involves 2 virtual methods. Height-for-width apis run
// through gtk_widget_get_preferred_width() and then through
// gtk_widget_get_preferred_height_for_width(). When handling requests in the
// opposite SizeRequestMode it is important that every widget request at least
// enough space to display all of its content at all times.
//
// When gtk_widget_get_preferred_height() is called on a container that is
// height-for-width, the container must return the height for its minimum width.
// This is easily achieved by simply calling the reverse apis implemented for
// itself as follows:
//
//    static void
//    foo_container_get_preferred_width_for_height (GtkWidget *widget,
//                                                  gint for_height,
//                                                  gint *min_width,
//                                                  gint *nat_width)
//    {
//       if (i_am_in_height_for_width_mode)
//         {
//           GTK_WIDGET_GET_CLASS (widget)->get_preferred_width (widget,
//                                                               min_width,
//                                                               nat_width);
//         }
//       else
//         {
//           ... execute the real width-for-height request here based on
//           the required width of the children collectively if the
//           container were to be allocated the said height ...
//         }
//    }
//
// Height for width requests are generally implemented in terms of a virtual
// allocation of widgets in the input orientation. Assuming an height-for-width
// request mode, a container would implement the
// get_preferred_height_for_width() virtual function by first calling
// gtk_widget_get_preferred_width() for each of its children.
//
// For each potential group of children that are lined up horizontally, the
// values returned by gtk_widget_get_preferred_width() should be collected in an
// array of RequestedSize structures. Any child spacing should be removed from
// the input @for_width and then the collective size should be allocated using
// the gtk_distribute_natural_allocation() convenience function.
//
// The container will then move on to request the preferred height for each
// child by using gtk_widget_get_preferred_height_for_width() and using the
// sizes stored in the RequestedSize array.
//
// To allocate a height-for-width container, it’s again important to consider
// that a container must prioritize one dimension over the other. So if a
// container is a height-for-width container it must first allocate all widgets
// horizontally using a RequestedSize array and
// gtk_distribute_natural_allocation() and then add any extra space (if and
// where appropriate) for the widget to expand.
//
// After adding all the expand space, the container assumes it was allocated
// sufficient height to fit all of its content. At this time, the container must
// use the total horizontal sizes of each widget to request the height-for-width
// of each of its children and store the requests in a RequestedSize array for
// any widgets that stack vertically (for tabular containers this can be
// generalized into the heights and widths of rows and columns). The vertical
// space must then again be distributed using
// gtk_distribute_natural_allocation() while this time considering the allocated
// height of the widget minus any vertical spacing that the container adds. Then
// vertical expand space should be added where appropriate and available and the
// container should go on to actually allocating the child widgets.
//
// See [GtkWidget’s geometry management section][geometry-management] to learn
// more about implementing height-for-width geometry management for widgets.
//
//
// Child properties
//
// GtkContainer introduces child properties. These are object properties that
// are not specific to either the container or the contained widget, but rather
// to their relation. Typical examples of child properties are the position or
// pack-type of a widget which is contained in a Box.
//
// Use gtk_container_class_install_child_property() to install child properties
// for a container class and gtk_container_class_find_child_property() or
// gtk_container_class_list_child_properties() to get information about existing
// child properties.
//
// To set the value of a child property, use gtk_container_child_set_property(),
// gtk_container_child_set() or gtk_container_child_set_valist(). To obtain the
// value of a child property, use gtk_container_child_get_property(),
// gtk_container_child_get() or gtk_container_child_get_valist(). To emit
// notification about child property changes, use gtk_widget_child_notify().
//
//
// GtkContainer as GtkBuildable
//
// The GtkContainer implementation of the GtkBuildable interface supports a
// <packing> element for children, which can contain multiple <property>
// elements that specify child properties for the child.
//
// Since 2.16, child properties can also be marked as translatable using the
// same “translatable”, “comments” and “context” attributes that are used for
// regular properties.
//
// Since 3.16, containers can have a <focus-chain> element containing multiple
// <widget> elements, one for each child that should be added to the focus
// chain. The ”name” attribute gives the id of the widget.
//
// An example of these properties in UI definitions:
//
//    <object class="GtkBox">
//      <child>
//        <object class="GtkEntry" id="entry1"/>
//        <packing>
//          <property name="pack-type">start</property>
//        </packing>
//      </child>
//      <child>
//        <object class="GtkEntry" id="entry2"/>
//      </child>
//      <focus-chain>
//        <widget name="entry1"/>
//        <widget name="entry2"/>
//      </focus-chain>
//    </object>
type Container interface {
	Widget

	// AddContainer:
	AddContainer(widget Widget)
	// CheckResizeContainer:
	CheckResizeContainer()
	// ChildGetPropertyContainer:
	ChildGetPropertyContainer(child Widget, propertyName string, value externglib.Value)
	// ChildNotifyContainer:
	ChildNotifyContainer(child Widget, childProperty string)
	// ChildSetPropertyContainer:
	ChildSetPropertyContainer(child Widget, propertyName string, value externglib.Value)
	// ChildTypeContainer:
	ChildTypeContainer() externglib.Type
	// BorderWidth:
	BorderWidth() uint
	// FocusChild:
	FocusChild() Widget
	// FocusHAdjustment:
	FocusHAdjustment() Adjustment
	// FocusVAdjustment:
	FocusVAdjustment() Adjustment
	// PathForChild:
	PathForChild(child Widget) *WidgetPath
	// ResizeMode:
	ResizeMode() ResizeMode
	// PropagateDrawContainer:
	PropagateDrawContainer(child Widget, cr *cairo.Context)
	// RemoveContainer:
	RemoveContainer(widget Widget)
	// ResizeChildrenContainer:
	ResizeChildrenContainer()
	// SetBorderWidthContainer:
	SetBorderWidthContainer(borderWidth uint)
	// SetFocusChildContainer:
	SetFocusChildContainer(child Widget)
	// SetFocusHAdjustmentContainer:
	SetFocusHAdjustmentContainer(adjustment Adjustment)
	// SetFocusVAdjustmentContainer:
	SetFocusVAdjustmentContainer(adjustment Adjustment)
	// SetReallocateRedrawsContainer:
	SetReallocateRedrawsContainer(needsRedraws bool)
	// SetResizeModeContainer:
	SetResizeModeContainer(resizeMode ResizeMode)
	// UnsetFocusChainContainer:
	UnsetFocusChainContainer()
}

// container implements the Container class.
type container struct {
	Widget
}

// WrapContainer wraps a GObject to the right type. It is
// primarily used internally.
func WrapContainer(obj *externglib.Object) Container {
	return container{
		Widget: WrapWidget(obj),
	}
}

func marshalContainer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapContainer(obj), nil
}

func (c container) AddContainer(widget Widget) {
	var _arg0 *C.GtkContainer // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_container_add(_arg0, _arg1)
}

func (c container) CheckResizeContainer() {
	var _arg0 *C.GtkContainer // out

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))

	C.gtk_container_check_resize(_arg0)
}

func (c container) ChildGetPropertyContainer(child Widget, propertyName string, value externglib.Value) {
	var _arg0 *C.GtkContainer // out
	var _arg1 *C.GtkWidget    // out
	var _arg2 *C.gchar        // out
	var _arg3 *C.GValue       // out

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.gchar)(C.CString(propertyName))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GValue)(unsafe.Pointer(&value.GValue))

	C.gtk_container_child_get_property(_arg0, _arg1, _arg2, _arg3)
}

func (c container) ChildNotifyContainer(child Widget, childProperty string) {
	var _arg0 *C.GtkContainer // out
	var _arg1 *C.GtkWidget    // out
	var _arg2 *C.gchar        // out

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.gchar)(C.CString(childProperty))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_container_child_notify(_arg0, _arg1, _arg2)
}

func (c container) ChildSetPropertyContainer(child Widget, propertyName string, value externglib.Value) {
	var _arg0 *C.GtkContainer // out
	var _arg1 *C.GtkWidget    // out
	var _arg2 *C.gchar        // out
	var _arg3 *C.GValue       // out

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.gchar)(C.CString(propertyName))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GValue)(unsafe.Pointer(&value.GValue))

	C.gtk_container_child_set_property(_arg0, _arg1, _arg2, _arg3)
}

func (c container) ChildTypeContainer() externglib.Type {
	var _arg0 *C.GtkContainer // out
	var _cret C.GType         // in

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_container_child_type(_arg0)

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

func (c container) BorderWidth() uint {
	var _arg0 *C.GtkContainer // out
	var _cret C.guint         // in

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_container_get_border_width(_arg0)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

func (c container) FocusChild() Widget {
	var _arg0 *C.GtkContainer // out
	var _cret *C.GtkWidget    // in

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_container_get_focus_child(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (c container) FocusHAdjustment() Adjustment {
	var _arg0 *C.GtkContainer  // out
	var _cret *C.GtkAdjustment // in

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_container_get_focus_hadjustment(_arg0)

	var _adjustment Adjustment // out

	_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

	return _adjustment
}

func (c container) FocusVAdjustment() Adjustment {
	var _arg0 *C.GtkContainer  // out
	var _cret *C.GtkAdjustment // in

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_container_get_focus_vadjustment(_arg0)

	var _adjustment Adjustment // out

	_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

	return _adjustment
}

func (c container) PathForChild(child Widget) *WidgetPath {
	var _arg0 *C.GtkContainer  // out
	var _arg1 *C.GtkWidget     // out
	var _cret *C.GtkWidgetPath // in

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	_cret = C.gtk_container_get_path_for_child(_arg0, _arg1)

	var _widgetPath *WidgetPath // out

	_widgetPath = (*WidgetPath)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_widgetPath, func(v **WidgetPath) {
		C.free(unsafe.Pointer(v))
	})

	return _widgetPath
}

func (c container) ResizeMode() ResizeMode {
	var _arg0 *C.GtkContainer // out
	var _cret C.GtkResizeMode // in

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_container_get_resize_mode(_arg0)

	var _resizeMode ResizeMode // out

	_resizeMode = ResizeMode(_cret)

	return _resizeMode
}

func (c container) PropagateDrawContainer(child Widget, cr *cairo.Context) {
	var _arg0 *C.GtkContainer // out
	var _arg1 *C.GtkWidget    // out
	var _arg2 *C.cairo_t      // out

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))

	C.gtk_container_propagate_draw(_arg0, _arg1, _arg2)
}

func (c container) RemoveContainer(widget Widget) {
	var _arg0 *C.GtkContainer // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_container_remove(_arg0, _arg1)
}

func (c container) ResizeChildrenContainer() {
	var _arg0 *C.GtkContainer // out

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))

	C.gtk_container_resize_children(_arg0)
}

func (c container) SetBorderWidthContainer(borderWidth uint) {
	var _arg0 *C.GtkContainer // out
	var _arg1 C.guint         // out

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
	_arg1 = C.guint(borderWidth)

	C.gtk_container_set_border_width(_arg0, _arg1)
}

func (c container) SetFocusChildContainer(child Widget) {
	var _arg0 *C.GtkContainer // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_container_set_focus_child(_arg0, _arg1)
}

func (c container) SetFocusHAdjustmentContainer(adjustment Adjustment) {
	var _arg0 *C.GtkContainer  // out
	var _arg1 *C.GtkAdjustment // out

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	C.gtk_container_set_focus_hadjustment(_arg0, _arg1)
}

func (c container) SetFocusVAdjustmentContainer(adjustment Adjustment) {
	var _arg0 *C.GtkContainer  // out
	var _arg1 *C.GtkAdjustment // out

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	C.gtk_container_set_focus_vadjustment(_arg0, _arg1)
}

func (c container) SetReallocateRedrawsContainer(needsRedraws bool) {
	var _arg0 *C.GtkContainer // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
	if needsRedraws {
		_arg1 = C.TRUE
	}

	C.gtk_container_set_reallocate_redraws(_arg0, _arg1)
}

func (c container) SetResizeModeContainer(resizeMode ResizeMode) {
	var _arg0 *C.GtkContainer // out
	var _arg1 C.GtkResizeMode // out

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
	_arg1 = C.GtkResizeMode(resizeMode)

	C.gtk_container_set_resize_mode(_arg0, _arg1)
}

func (c container) UnsetFocusChainContainer() {
	var _arg0 *C.GtkContainer // out

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))

	C.gtk_container_unset_focus_chain(_arg0)
}

func (b container) AddChild(builder Builder, child gextras.Objector, typ string) {
	WrapBuildable(gextras.InternObject(b)).AddChild(builder, child, typ)
}

func (b container) ConstructChild(builder Builder, name string) gextras.Objector {
	return WrapBuildable(gextras.InternObject(b)).ConstructChild(builder, name)
}

func (b container) InternalChild(builder Builder, childname string) gextras.Objector {
	return WrapBuildable(gextras.InternObject(b)).InternalChild(builder, childname)
}

func (b container) Name() string {
	return WrapBuildable(gextras.InternObject(b)).Name()
}

func (b container) ParserFinished(builder Builder) {
	WrapBuildable(gextras.InternObject(b)).ParserFinished(builder)
}

func (b container) SetBuildableProperty(builder Builder, name string, value externglib.Value) {
	WrapBuildable(gextras.InternObject(b)).SetBuildableProperty(builder, name, value)
}

func (b container) SetName(name string) {
	WrapBuildable(gextras.InternObject(b)).SetName(name)
}
