// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"reflect"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk+-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_rc_style_get_type()), F: marshalRCStyle},
	})
}

// RCAddDefaultFile adds a file to the list of files to be parsed at the end of
// gtk_init().
func RCAddDefaultFile(filename string) {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_rc_add_default_file(arg1)
}

// RCFindModuleInPath searches for a theme engine in the GTK+ search path. This
// function is not useful for applications and should not be used.
func RCFindModuleInPath(moduleFile string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(moduleFile))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_rc_find_module_in_path(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// RCFindPixmapInPath looks up a file in pixmap path for the specified Settings.
// If the file is not found, it outputs a warning message using g_warning() and
// returns nil.
func RCFindPixmapInPath(settings Settings, scanner *glib.Scanner, pixmapFile string) string {
	var arg1 *C.GtkSettings
	var arg2 *C.GScanner
	var arg3 *C.gchar

	arg1 = (*C.GtkSettings)(settings.Native())
	arg2 = (*C.GScanner)(scanner.Native())
	arg3 = (*C.gchar)(C.CString(pixmapFile))
	defer C.free(unsafe.Pointer(arg3))

	ret := C.gtk_rc_find_pixmap_in_path(arg1, arg2, arg3)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// RCGetDefaultFiles retrieves the current list of RC files that will be parsed
// at the end of gtk_init().
func RCGetDefaultFiles() []string {
	ret := C.gtk_rc_get_default_files()

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
		}
	}

	return ret0
}

// RCGetImModuleFile obtains the path to the IM modules file. See the
// documentation of the `GTK_IM_MODULE_FILE` environment variable for more
// details.
func RCGetImModuleFile() string {
	ret := C.gtk_rc_get_im_module_file()

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// RCGetImModulePath obtains the path in which to look for IM modules. See the
// documentation of the `GTK_PATH` environment variable for more details about
// looking up modules. This function is useful solely for utilities supplied
// with GTK+ and should not be used by applications under normal circumstances.
func RCGetImModulePath() string {
	ret := C.gtk_rc_get_im_module_path()

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// RCGetModuleDir returns a directory in which GTK+ looks for theme engines. For
// full information about the search for theme engines, see the docs for
// `GTK_PATH` in [Running GTK+ Applications][gtk-running].
func RCGetModuleDir() string {
	ret := C.gtk_rc_get_module_dir()

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// RCGetStyle finds all matching RC styles for a given widget, composites them
// together, and then creates a Style representing the composite appearance.
// (GTK+ actually keeps a cache of previously created styles, so a new style may
// not be created.)
func RCGetStyle(widget Widget) Style {
	var arg1 *C.GtkWidget

	arg1 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_rc_get_style(arg1)

	var ret0 Style

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Style)

	return ret0
}

// RCGetStyleByPaths creates up a Style from styles defined in a RC file by
// providing the raw components used in matching. This function may be useful
// when creating pseudo-widgets that should be themed like widgets but don’t
// actually have corresponding GTK+ widgets. An example of this would be items
// inside a GNOME canvas widget.
//
// The action of gtk_rc_get_style() is similar to:
//
//    gtk_widget_path (widget, NULL, &path, NULL);
//    gtk_widget_class_path (widget, NULL, &class_path, NULL);
//    gtk_rc_get_style_by_paths (gtk_widget_get_settings (widget),
//                               path, class_path,
//                               G_OBJECT_TYPE (widget));
func RCGetStyleByPaths(settings Settings, widgetPath string, classPath string, typ externglib.Type) Style {
	var arg1 *C.GtkSettings
	var arg2 *C.char
	var arg3 *C.char
	var arg4 C.GType

	arg1 = (*C.GtkSettings)(settings.Native())
	arg2 = (*C.gchar)(C.CString(widgetPath))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(classPath))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = C.GType(typ)

	ret := C.gtk_rc_get_style_by_paths(arg1, arg2, arg3, arg4)

	var ret0 Style

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Style)

	return ret0
}

// RCGetThemeDir returns the standard directory in which themes should be
// installed. (GTK+ does not actually use this directory itself.)
func RCGetThemeDir() string {
	ret := C.gtk_rc_get_theme_dir()

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// RCParse parses a given resource file.
func RCParse(filename string) {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_rc_parse(arg1)
}

// RCParseColor parses a color in the format expected in a RC file.
//
// Note that theme engines should use gtk_rc_parse_color_full() in order to
// support symbolic colors.
func RCParseColor(scanner *glib.Scanner) (color gdk.Color, guint uint) {
	var arg1 *C.GScanner
	var arg2 *C.GdkColor // out

	arg1 = (*C.GScanner)(scanner.Native())

	ret := C.gtk_rc_parse_color(arg1, &arg2)

	var ret0 *gdk.Color
	var ret1 uint

	{
		ret0 = gdk.WrapColor(unsafe.Pointer(arg2))
	}

	ret1 = uint(ret)

	return ret0, ret1
}

// RCParseColorFull parses a color in the format expected in a RC file. If
// @style is not nil, it will be consulted to resolve references to symbolic
// colors.
func RCParseColorFull(scanner *glib.Scanner, style RCStyle) (color gdk.Color, guint uint) {
	var arg1 *C.GScanner
	var arg2 *C.GtkRcStyle
	var arg3 *C.GdkColor // out

	arg1 = (*C.GScanner)(scanner.Native())
	arg2 = (*C.GtkRcStyle)(style.Native())

	ret := C.gtk_rc_parse_color_full(arg1, arg2, &arg3)

	var ret0 *gdk.Color
	var ret1 uint

	{
		ret0 = gdk.WrapColor(unsafe.Pointer(arg3))
	}

	ret1 = uint(ret)

	return ret0, ret1
}

// RCParsePriority parses a PathPriorityType variable from the format expected
// in a RC file.
func RCParsePriority(scanner *glib.Scanner, priority *PathPriorityType) uint {
	var arg1 *C.GScanner
	var arg2 *C.GtkPathPriorityType

	arg1 = (*C.GScanner)(scanner.Native())
	arg2 = (*C.GtkPathPriorityType)(priority)

	ret := C.gtk_rc_parse_priority(arg1, arg2)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// RCParseState parses a StateType variable from the format expected in a RC
// file.
func RCParseState(scanner *glib.Scanner) (state StateType, guint uint) {
	var arg1 *C.GScanner
	var arg2 *C.GtkStateType // out

	arg1 = (*C.GScanner)(scanner.Native())

	ret := C.gtk_rc_parse_state(arg1, &arg2)

	var ret0 *StateType
	var ret1 uint

	ret0 = (*StateType)(arg2)

	ret1 = uint(ret)

	return ret0, ret1
}

// RCParseString parses resource information directly from a string.
func RCParseString(rcString string) {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(rcString))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_rc_parse_string(arg1)
}

// RCReparseAll: if the modification time on any previously read file for the
// default Settings has changed, discard all style information and then reread
// all previously read RC files.
func RCReparseAll() bool {
	ret := C.gtk_rc_reparse_all()

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// RCReparseAllForSettings: if the modification time on any previously read file
// for the given Settings has changed, discard all style information and then
// reread all previously read RC files.
func RCReparseAllForSettings(settings Settings, forceLoad bool) bool {
	var arg1 *C.GtkSettings
	var arg2 C.gboolean

	arg1 = (*C.GtkSettings)(settings.Native())
	if forceLoad {
		arg2 = C.TRUE
	}

	ret := C.gtk_rc_reparse_all_for_settings(arg1, arg2)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// RCResetStyles: this function recomputes the styles for all widgets that use a
// particular Settings object. (There is one Settings object per Screen, see
// gtk_settings_get_for_screen()); It is useful when some global parameter has
// changed that affects the appearance of all widgets, because when a widget
// gets a new style, it will both redraw and recompute any cached information
// about its appearance. As an example, it is used when the default font size
// set by the operating system changes. Note that this function doesn’t affect
// widgets that have a style set explicitly on them with gtk_widget_set_style().
func RCResetStyles(settings Settings) {
	var arg1 *C.GtkSettings

	arg1 = (*C.GtkSettings)(settings.Native())

	C.gtk_rc_reset_styles(arg1)
}

func NewRCScanner() *glib.Scanner {
	ret := C.gtk_rc_scanner_new()

	var ret0 *glib.Scanner

	{
		ret0 = glib.WrapScanner(unsafe.Pointer(ret))
	}

	return ret0
}

// RCSetDefaultFiles sets the list of files that GTK+ will read at the end of
// gtk_init().
func RCSetDefaultFiles(filenames []string) {
	var arg1 **C.gchar

	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(filenames) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(filenames)
		sliceHeader.Cap = len(filenames)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(filenames); i++ {
			src := filenames[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg1 = (**C.gchar)(unsafe.Pointer(ptr))
	}

	C.gtk_rc_set_default_files(arg1)
}

type RCContext struct {
	native C.GtkRcContext
}

// WrapRCContext wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRCContext(ptr unsafe.Pointer) *RCContext {
	if ptr == nil {
		return nil
	}

	return (*RCContext)(ptr)
}

func marshalRCContext(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRCContext(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *RCContext) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// RCProperty: deprecated
type RCProperty struct {
	native C.GtkRcProperty
}

// WrapRCProperty wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRCProperty(ptr unsafe.Pointer) *RCProperty {
	if ptr == nil {
		return nil
	}

	return (*RCProperty)(ptr)
}

func marshalRCProperty(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRCProperty(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *RCProperty) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// TypeName gets the field inside the struct.
func (r *RCProperty) TypeName() glib.Quark {
	var ret glib.Quark
	{
		var tmp uint32
		tmp = uint32(r.native.type_name)
		ret = glib.Quark(tmp)
	}
	return ret
}

// PropertyName gets the field inside the struct.
func (r *RCProperty) PropertyName() glib.Quark {
	var ret glib.Quark
	{
		var tmp uint32
		tmp = uint32(r.native.property_name)
		ret = glib.Quark(tmp)
	}
	return ret
}

// Origin gets the field inside the struct.
func (r *RCProperty) Origin() string {
	var ret string
	ret = C.GoString(r.native.origin)
	return ret
}

// Value gets the field inside the struct.
func (r *RCProperty) Value() *externglib.Value {
	var ret *externglib.Value
	ret = externglib.ValueFromNative(unsafe.Pointer(r.native.value))
	return ret
}

// RCStyle: the RcStyle-struct is used to represent a set of information about
// the appearance of a widget. This can later be composited together with other
// RcStyle-struct<!-- -->s to form a Style.
type RCStyle interface {
	gextras.Objector

	// Copy makes a copy of the specified RcStyle. This function will correctly
	// copy an RC style that is a member of a class derived from RcStyle.
	Copy() RCStyle
}

// rcStyle implements the RCStyle interface.
type rcStyle struct {
	gextras.Objector
}

var _ RCStyle = (*rcStyle)(nil)

// WrapRCStyle wraps a GObject to the right type. It is
// primarily used internally.
func WrapRCStyle(obj *externglib.Object) RCStyle {
	return RCStyle{
		Objector: obj,
	}
}

func marshalRCStyle(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRCStyle(obj), nil
}

// NewRCStyle constructs a class RCStyle.
func NewRCStyle() RCStyle {
	ret := C.gtk_rc_style_new()

	var ret0 RCStyle

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(RCStyle)

	return ret0
}

// Copy makes a copy of the specified RcStyle. This function will correctly
// copy an RC style that is a member of a class derived from RcStyle.
func (o rcStyle) Copy() RCStyle {
	var arg0 *C.GtkRcStyle

	arg0 = (*C.GtkRcStyle)(o.Native())

	ret := C.gtk_rc_style_copy(arg0)

	var ret0 RCStyle

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(RCStyle)

	return ret0
}
