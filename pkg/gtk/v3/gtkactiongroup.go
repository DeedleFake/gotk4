// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	"github.com/diamondburned/gotk4/pkg/gobject/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk+-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <stdbool.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
//
// extern void callbackDelete(gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_action_group_get_type()), F: marshalActionGroup},
	})
}

//export callbackDelete
func callbackDelete(ptr C.gpointer) {
	box.Delete(box.Callback, uintptr(ptr))
}

// ActionEntry structs are used with gtk_action_group_add_actions() to construct
// actions.
type ActionEntry struct {
	native C.GtkActionEntry
}

// WrapActionEntry wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapActionEntry(ptr unsafe.Pointer) *ActionEntry {
	if ptr == nil {
		return nil
	}

	return (*ActionEntry)(ptr)
}

func marshalActionEntry(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapActionEntry(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (a *ActionEntry) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// Name gets the field inside the struct.
func (a *ActionEntry) Name() string {
	var ret string
	ret = C.GoString(a.native.name)
	return ret
}

// StockID gets the field inside the struct.
func (a *ActionEntry) StockID() string {
	var ret string
	ret = C.GoString(a.native.stock_id)
	return ret
}

// Label gets the field inside the struct.
func (a *ActionEntry) Label() string {
	var ret string
	ret = C.GoString(a.native.label)
	return ret
}

// Accelerator gets the field inside the struct.
func (a *ActionEntry) Accelerator() string {
	var ret string
	ret = C.GoString(a.native.accelerator)
	return ret
}

// Tooltip gets the field inside the struct.
func (a *ActionEntry) Tooltip() string {
	var ret string
	ret = C.GoString(a.native.tooltip)
	return ret
}

type ActionGroupPrivate struct {
	native C.GtkActionGroupPrivate
}

// WrapActionGroupPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapActionGroupPrivate(ptr unsafe.Pointer) *ActionGroupPrivate {
	if ptr == nil {
		return nil
	}

	return (*ActionGroupPrivate)(ptr)
}

func marshalActionGroupPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapActionGroupPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (a *ActionGroupPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// RadioActionEntry structs are used with gtk_action_group_add_radio_actions()
// to construct groups of radio actions.
type RadioActionEntry struct {
	native C.GtkRadioActionEntry
}

// WrapRadioActionEntry wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRadioActionEntry(ptr unsafe.Pointer) *RadioActionEntry {
	if ptr == nil {
		return nil
	}

	return (*RadioActionEntry)(ptr)
}

func marshalRadioActionEntry(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRadioActionEntry(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *RadioActionEntry) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// Name gets the field inside the struct.
func (r *RadioActionEntry) Name() string {
	var ret string
	ret = C.GoString(r.native.name)
	return ret
}

// StockID gets the field inside the struct.
func (r *RadioActionEntry) StockID() string {
	var ret string
	ret = C.GoString(r.native.stock_id)
	return ret
}

// Label gets the field inside the struct.
func (r *RadioActionEntry) Label() string {
	var ret string
	ret = C.GoString(r.native.label)
	return ret
}

// Accelerator gets the field inside the struct.
func (r *RadioActionEntry) Accelerator() string {
	var ret string
	ret = C.GoString(r.native.accelerator)
	return ret
}

// Tooltip gets the field inside the struct.
func (r *RadioActionEntry) Tooltip() string {
	var ret string
	ret = C.GoString(r.native.tooltip)
	return ret
}

// Value gets the field inside the struct.
func (r *RadioActionEntry) Value() int {
	var ret int
	ret = int(r.native.value)
	return ret
}

// ToggleActionEntry structs are used with gtk_action_group_add_toggle_actions()
// to construct toggle actions.
type ToggleActionEntry struct {
	native C.GtkToggleActionEntry
}

// WrapToggleActionEntry wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapToggleActionEntry(ptr unsafe.Pointer) *ToggleActionEntry {
	if ptr == nil {
		return nil
	}

	return (*ToggleActionEntry)(ptr)
}

func marshalToggleActionEntry(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapToggleActionEntry(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *ToggleActionEntry) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// Name gets the field inside the struct.
func (t *ToggleActionEntry) Name() string {
	var ret string
	ret = C.GoString(t.native.name)
	return ret
}

// StockID gets the field inside the struct.
func (t *ToggleActionEntry) StockID() string {
	var ret string
	ret = C.GoString(t.native.stock_id)
	return ret
}

// Label gets the field inside the struct.
func (t *ToggleActionEntry) Label() string {
	var ret string
	ret = C.GoString(t.native.label)
	return ret
}

// Accelerator gets the field inside the struct.
func (t *ToggleActionEntry) Accelerator() string {
	var ret string
	ret = C.GoString(t.native.accelerator)
	return ret
}

// Tooltip gets the field inside the struct.
func (t *ToggleActionEntry) Tooltip() string {
	var ret string
	ret = C.GoString(t.native.tooltip)
	return ret
}

// IsActive gets the field inside the struct.
func (t *ToggleActionEntry) IsActive() bool {
	var ret bool
	ret = C.bool(t.native.is_active) != 0
	return ret
}

// ActionGroup actions are organised into groups. An action group is essentially
// a map from names to Action objects.
//
// All actions that would make sense to use in a particular context should be in
// a single group. Multiple action groups may be used for a particular user
// interface. In fact, it is expected that most nontrivial applications will
// make use of multiple groups. For example, in an application that can edit
// multiple documents, one group holding global actions (e.g. quit, about, new),
// and one group per document holding actions that act on that document (eg.
// save, cut/copy/paste, etc). Each window’s menus would be constructed from a
// combination of two action groups.
//
//
// Accelerators
//
// Accelerators are handled by the GTK+ accelerator map. All actions are
// assigned an accelerator path (which normally has the form
// `<Actions>/group-name/action-name`) and a shortcut is associated with this
// accelerator path. All menuitems and toolitems take on this accelerator path.
// The GTK+ accelerator map code makes sure that the correct shortcut is
// displayed next to the menu item.
//
//
// GtkActionGroup as GtkBuildable
//
// The ActionGroup implementation of the Buildable interface accepts Action
// objects as <child> elements in UI definitions.
//
// Note that it is probably more common to define actions and action groups in
// the code, since they are directly related to what the code can do.
//
// The GtkActionGroup implementation of the GtkBuildable interface supports a
// custom <accelerator> element, which has attributes named “key“ and
// “modifiers“ and allows to specify accelerators. This is similar to the
// <accelerator> element of Widget, the main difference is that it doesn’t allow
// you to specify a signal.
//
// A Dialog UI definition fragment. ##
//
//    <object class="GtkActionGroup" id="actiongroup">
//      <child>
//          <object class="GtkAction" id="About">
//              <property name="name">About</property>
//              <property name="stock_id">gtk-about</property>
//              <signal handler="about_activate" name="activate"/>
//          </object>
//          <accelerator key="F1" modifiers="GDK_CONTROL_MASK | GDK_SHIFT_MASK"/>
//      </child>
//    </object>
type ActionGroup interface {
	gextras.Objector
	Buildable

	// AddAction adds an action object to the action group. Note that this
	// function does not set up the accel path of the action, which can lead to
	// problems if a user tries to modify the accelerator of a menuitem
	// associated with the action. Therefore you must either set the accel path
	// yourself with gtk_action_set_accel_path(), or use
	// `gtk_action_group_add_action_with_accel (..., NULL)`.
	AddAction(action Action)
	// AddActionWithAccel adds an action object to the action group and sets up
	// the accelerator.
	//
	// If @accelerator is nil, attempts to use the accelerator associated with
	// the stock_id of the action.
	//
	// Accel paths are set to `<Actions>/group-name/action-name`.
	AddActionWithAccel(action Action, accelerator string)
	// AddActions: this is a convenience function to create a number of actions
	// and add them to the action group.
	//
	// The “activate” signals of the actions are connected to the callbacks and
	// their accel paths are set to `<Actions>/group-name/action-name`.
	AddActions(entries []ActionEntry, userData interface{})
	// AddActionsFull: this variant of gtk_action_group_add_actions() adds a
	// Notify callback for @user_data.
	AddActionsFull(entries []ActionEntry, userData interface{})
	// AddRadioActions: this is a convenience routine to create a group of radio
	// actions and add them to the action group.
	//
	// The “changed” signal of the first radio action is connected to the
	// @on_change callback and the accel paths of the actions are set to
	// `<Actions>/group-name/action-name`.
	AddRadioActions(entries []RadioActionEntry, value int, onChange gobject.Callback)
	// AddRadioActionsFull: this variant of gtk_action_group_add_radio_actions()
	// adds a Notify callback for @user_data.
	AddRadioActionsFull(entries []RadioActionEntry, value int, onChange gobject.Callback)
	// AddToggleActions: this is a convenience function to create a number of
	// toggle actions and add them to the action group.
	//
	// The “activate” signals of the actions are connected to the callbacks and
	// their accel paths are set to `<Actions>/group-name/action-name`.
	AddToggleActions(entries []ToggleActionEntry, userData interface{})
	// AddToggleActionsFull: this variant of
	// gtk_action_group_add_toggle_actions() adds a Notify callback for
	// @user_data.
	AddToggleActionsFull(entries []ToggleActionEntry, userData interface{})
	// AccelGroup gets the accelerator group.
	AccelGroup() AccelGroup
	// Action looks up an action in the action group by name.
	Action(actionName string) Action
	// Name gets the name of the action group.
	Name() string
	// Sensitive returns true if the group is sensitive. The constituent actions
	// can only be logically sensitive (see gtk_action_is_sensitive()) if they
	// are sensitive (see gtk_action_get_sensitive()) and their group is
	// sensitive.
	Sensitive() bool
	// Visible returns true if the group is visible. The constituent actions can
	// only be logically visible (see gtk_action_is_visible()) if they are
	// visible (see gtk_action_get_visible()) and their group is visible.
	Visible() bool
	// ListActions lists the actions in the action group.
	ListActions() *glib.List
	// RemoveAction removes an action object from the action group.
	RemoveAction(action Action)
	// SetAccelGroup sets the accelerator group to be used by every action in
	// this group.
	SetAccelGroup(accelGroup AccelGroup)
	// SetSensitive changes the sensitivity of @action_group
	SetSensitive(sensitive bool)
	// SetTranslateFunc sets a function to be used for translating the @label
	// and @tooltip of ActionEntrys added by gtk_action_group_add_actions().
	//
	// If you’re using gettext(), it is enough to set the translation domain
	// with gtk_action_group_set_translation_domain().
	SetTranslateFunc(fn TranslateFunc)
	// SetTranslationDomain sets the translation domain and uses g_dgettext()
	// for translating the @label and @tooltip of ActionEntrys added by
	// gtk_action_group_add_actions().
	//
	// If you’re not using gettext() for localization, see
	// gtk_action_group_set_translate_func().
	SetTranslationDomain(domain string)
	// SetVisible changes the visible of @action_group.
	SetVisible(visible bool)
	// TranslateString translates a string using the function set with
	// gtk_action_group_set_translate_func(). This is mainly intended for
	// language bindings.
	TranslateString(string string) string
}

// actionGroup implements the ActionGroup interface.
type actionGroup struct {
	gextras.Objector
	Buildable
}

var _ ActionGroup = (*actionGroup)(nil)

// WrapActionGroup wraps a GObject to the right type. It is
// primarily used internally.
func WrapActionGroup(obj *externglib.Object) ActionGroup {
	return ActionGroup{
		Objector:  obj,
		Buildable: WrapBuildable(obj),
	}
}

func marshalActionGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapActionGroup(obj), nil
}

// NewActionGroup constructs a class ActionGroup.
func NewActionGroup(name string) ActionGroup {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_action_group_new(arg1)

	var ret0 ActionGroup

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(ActionGroup)

	return ret0
}

// AddAction adds an action object to the action group. Note that this
// function does not set up the accel path of the action, which can lead to
// problems if a user tries to modify the accelerator of a menuitem
// associated with the action. Therefore you must either set the accel path
// yourself with gtk_action_set_accel_path(), or use
// `gtk_action_group_add_action_with_accel (..., NULL)`.
func (a actionGroup) AddAction(action Action) {
	var arg0 *C.GtkActionGroup
	var arg1 *C.GtkAction

	arg0 = (*C.GtkActionGroup)(a.Native())
	arg1 = (*C.GtkAction)(action.Native())

	C.gtk_action_group_add_action(arg0, arg1)
}

// AddActionWithAccel adds an action object to the action group and sets up
// the accelerator.
//
// If @accelerator is nil, attempts to use the accelerator associated with
// the stock_id of the action.
//
// Accel paths are set to `<Actions>/group-name/action-name`.
func (a actionGroup) AddActionWithAccel(action Action, accelerator string) {
	var arg0 *C.GtkActionGroup
	var arg1 *C.GtkAction
	var arg2 *C.gchar

	arg0 = (*C.GtkActionGroup)(a.Native())
	arg1 = (*C.GtkAction)(action.Native())
	arg2 = (*C.gchar)(C.CString(accelerator))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_action_group_add_action_with_accel(arg0, arg1, arg2)
}

// AddActions: this is a convenience function to create a number of actions
// and add them to the action group.
//
// The “activate” signals of the actions are connected to the callbacks and
// their accel paths are set to `<Actions>/group-name/action-name`.
func (a actionGroup) AddActions(entries []ActionEntry, userData interface{}) {
	var arg0 *C.GtkActionGroup
	var arg1 *C.GtkActionEntry
	var arg2 C.guint
	var arg3 C.gpointer

	arg0 = (*C.GtkActionGroup)(a.Native())
	{
		var dst []C.GtkActionEntry
		ptr := C.malloc(C.sizeof_GtkActionEntry * len(entries))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(entries)
		sliceHeader.Cap = len(entries)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(entries); i++ {
			src := entries[i]
			dst[i] = (C.GtkActionEntry)(src.Native())
		}

		arg1 = (*C.GtkActionEntry)(unsafe.Pointer(ptr))
		arg2 = len(entries)
	}
	arg3 = C.gpointer(box.Assign(userData))

	C.gtk_action_group_add_actions(arg0, arg1, arg2, arg3)
}

// AddActionsFull: this variant of gtk_action_group_add_actions() adds a
// Notify callback for @user_data.
func (a actionGroup) AddActionsFull(entries []ActionEntry, userData interface{}) {
	var arg0 *C.GtkActionGroup
	var arg1 *C.GtkActionEntry
	var arg2 C.guint
	var arg3 C.gpointer
	var arg4 C.GDestroyNotify

	arg0 = (*C.GtkActionGroup)(a.Native())
	{
		var dst []C.GtkActionEntry
		ptr := C.malloc(C.sizeof_GtkActionEntry * len(entries))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(entries)
		sliceHeader.Cap = len(entries)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(entries); i++ {
			src := entries[i]
			dst[i] = (C.GtkActionEntry)(src.Native())
		}

		arg1 = (*C.GtkActionEntry)(unsafe.Pointer(ptr))
		arg2 = len(entries)
	}
	arg3 = C.gpointer(box.Assign(userData))

	C.gtk_action_group_add_actions_full(arg0, arg1, arg2, arg3, arg4)
}

// AddRadioActions: this is a convenience routine to create a group of radio
// actions and add them to the action group.
//
// The “changed” signal of the first radio action is connected to the
// @on_change callback and the accel paths of the actions are set to
// `<Actions>/group-name/action-name`.
func (a actionGroup) AddRadioActions(entries []RadioActionEntry, value int, onChange gobject.Callback) {
	var arg0 *C.GtkActionGroup
	var arg1 *C.GtkRadioActionEntry
	var arg2 C.guint
	var arg3 C.gint
	var arg4 C.GCallback
	var arg5 C.gpointer

	arg0 = (*C.GtkActionGroup)(a.Native())
	{
		var dst []C.GtkRadioActionEntry
		ptr := C.malloc(C.sizeof_GtkRadioActionEntry * len(entries))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(entries)
		sliceHeader.Cap = len(entries)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(entries); i++ {
			src := entries[i]
			dst[i] = (C.GtkRadioActionEntry)(src.Native())
		}

		arg1 = (*C.GtkRadioActionEntry)(unsafe.Pointer(ptr))
		arg2 = len(entries)
	}
	arg3 = C.gint(value)
	arg4 = (*[0]byte)(C.gotk4_Callback)
	arg5 = C.gpointer(box.Assign(onChange))

	C.gtk_action_group_add_radio_actions(arg0, arg1, arg2, arg3, arg4, arg5)
}

// AddRadioActionsFull: this variant of gtk_action_group_add_radio_actions()
// adds a Notify callback for @user_data.
func (a actionGroup) AddRadioActionsFull(entries []RadioActionEntry, value int, onChange gobject.Callback) {
	var arg0 *C.GtkActionGroup
	var arg1 *C.GtkRadioActionEntry
	var arg2 C.guint
	var arg3 C.gint
	var arg4 C.GCallback
	var arg5 C.gpointer
	var arg6 C.GDestroyNotify

	arg0 = (*C.GtkActionGroup)(a.Native())
	{
		var dst []C.GtkRadioActionEntry
		ptr := C.malloc(C.sizeof_GtkRadioActionEntry * len(entries))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(entries)
		sliceHeader.Cap = len(entries)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(entries); i++ {
			src := entries[i]
			dst[i] = (C.GtkRadioActionEntry)(src.Native())
		}

		arg1 = (*C.GtkRadioActionEntry)(unsafe.Pointer(ptr))
		arg2 = len(entries)
	}
	arg3 = C.gint(value)
	arg4 = (*[0]byte)(C.gotk4_Callback)
	arg5 = C.gpointer(box.Assign(onChange))
	arg6 = (*[0]byte)(C.callbackDelete)

	C.gtk_action_group_add_radio_actions_full(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
}

// AddToggleActions: this is a convenience function to create a number of
// toggle actions and add them to the action group.
//
// The “activate” signals of the actions are connected to the callbacks and
// their accel paths are set to `<Actions>/group-name/action-name`.
func (a actionGroup) AddToggleActions(entries []ToggleActionEntry, userData interface{}) {
	var arg0 *C.GtkActionGroup
	var arg1 *C.GtkToggleActionEntry
	var arg2 C.guint
	var arg3 C.gpointer

	arg0 = (*C.GtkActionGroup)(a.Native())
	{
		var dst []C.GtkToggleActionEntry
		ptr := C.malloc(C.sizeof_GtkToggleActionEntry * len(entries))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(entries)
		sliceHeader.Cap = len(entries)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(entries); i++ {
			src := entries[i]
			dst[i] = (C.GtkToggleActionEntry)(src.Native())
		}

		arg1 = (*C.GtkToggleActionEntry)(unsafe.Pointer(ptr))
		arg2 = len(entries)
	}
	arg3 = C.gpointer(box.Assign(userData))

	C.gtk_action_group_add_toggle_actions(arg0, arg1, arg2, arg3)
}

// AddToggleActionsFull: this variant of
// gtk_action_group_add_toggle_actions() adds a Notify callback for
// @user_data.
func (a actionGroup) AddToggleActionsFull(entries []ToggleActionEntry, userData interface{}) {
	var arg0 *C.GtkActionGroup
	var arg1 *C.GtkToggleActionEntry
	var arg2 C.guint
	var arg3 C.gpointer
	var arg4 C.GDestroyNotify

	arg0 = (*C.GtkActionGroup)(a.Native())
	{
		var dst []C.GtkToggleActionEntry
		ptr := C.malloc(C.sizeof_GtkToggleActionEntry * len(entries))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(entries)
		sliceHeader.Cap = len(entries)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(entries); i++ {
			src := entries[i]
			dst[i] = (C.GtkToggleActionEntry)(src.Native())
		}

		arg1 = (*C.GtkToggleActionEntry)(unsafe.Pointer(ptr))
		arg2 = len(entries)
	}
	arg3 = C.gpointer(box.Assign(userData))

	C.gtk_action_group_add_toggle_actions_full(arg0, arg1, arg2, arg3, arg4)
}

// AccelGroup gets the accelerator group.
func (a actionGroup) AccelGroup() AccelGroup {
	var arg0 *C.GtkActionGroup

	arg0 = (*C.GtkActionGroup)(a.Native())

	ret := C.gtk_action_group_get_accel_group(arg0)

	var ret0 AccelGroup

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(AccelGroup)

	return ret0
}

// Action looks up an action in the action group by name.
func (a actionGroup) Action(actionName string) Action {
	var arg0 *C.GtkActionGroup
	var arg1 *C.gchar

	arg0 = (*C.GtkActionGroup)(a.Native())
	arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_action_group_get_action(arg0, arg1)

	var ret0 Action

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Action)

	return ret0
}

// Name gets the name of the action group.
func (a actionGroup) Name() string {
	var arg0 *C.GtkActionGroup

	arg0 = (*C.GtkActionGroup)(a.Native())

	ret := C.gtk_action_group_get_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Sensitive returns true if the group is sensitive. The constituent actions
// can only be logically sensitive (see gtk_action_is_sensitive()) if they
// are sensitive (see gtk_action_get_sensitive()) and their group is
// sensitive.
func (a actionGroup) Sensitive() bool {
	var arg0 *C.GtkActionGroup

	arg0 = (*C.GtkActionGroup)(a.Native())

	ret := C.gtk_action_group_get_sensitive(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// Visible returns true if the group is visible. The constituent actions can
// only be logically visible (see gtk_action_is_visible()) if they are
// visible (see gtk_action_get_visible()) and their group is visible.
func (a actionGroup) Visible() bool {
	var arg0 *C.GtkActionGroup

	arg0 = (*C.GtkActionGroup)(a.Native())

	ret := C.gtk_action_group_get_visible(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// ListActions lists the actions in the action group.
func (a actionGroup) ListActions() *glib.List {
	var arg0 *C.GtkActionGroup

	arg0 = (*C.GtkActionGroup)(a.Native())

	ret := C.gtk_action_group_list_actions(arg0)

	var ret0 *glib.List

	{
		ret0 = glib.WrapList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.List) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// RemoveAction removes an action object from the action group.
func (a actionGroup) RemoveAction(action Action) {
	var arg0 *C.GtkActionGroup
	var arg1 *C.GtkAction

	arg0 = (*C.GtkActionGroup)(a.Native())
	arg1 = (*C.GtkAction)(action.Native())

	C.gtk_action_group_remove_action(arg0, arg1)
}

// SetAccelGroup sets the accelerator group to be used by every action in
// this group.
func (a actionGroup) SetAccelGroup(accelGroup AccelGroup) {
	var arg0 *C.GtkActionGroup
	var arg1 *C.GtkAccelGroup

	arg0 = (*C.GtkActionGroup)(a.Native())
	arg1 = (*C.GtkAccelGroup)(accelGroup.Native())

	C.gtk_action_group_set_accel_group(arg0, arg1)
}

// SetSensitive changes the sensitivity of @action_group
func (a actionGroup) SetSensitive(sensitive bool) {
	var arg0 *C.GtkActionGroup
	var arg1 C.gboolean

	arg0 = (*C.GtkActionGroup)(a.Native())
	if sensitive {
		arg1 = C.TRUE
	}

	C.gtk_action_group_set_sensitive(arg0, arg1)
}

// SetTranslateFunc sets a function to be used for translating the @label
// and @tooltip of ActionEntrys added by gtk_action_group_add_actions().
//
// If you’re using gettext(), it is enough to set the translation domain
// with gtk_action_group_set_translation_domain().
func (a actionGroup) SetTranslateFunc(fn TranslateFunc) {
	var arg0 *C.GtkActionGroup
	var arg1 C.GtkTranslateFunc
	var arg2 C.gpointer
	var arg3 C.GDestroyNotify

	arg0 = (*C.GtkActionGroup)(a.Native())
	arg1 = (*[0]byte)(C.gotk4_TranslateFunc)
	arg2 = C.gpointer(box.Assign(fn))
	arg3 = (*[0]byte)(C.callbackDelete)

	C.gtk_action_group_set_translate_func(arg0, arg1, arg2, arg3)
}

// SetTranslationDomain sets the translation domain and uses g_dgettext()
// for translating the @label and @tooltip of ActionEntrys added by
// gtk_action_group_add_actions().
//
// If you’re not using gettext() for localization, see
// gtk_action_group_set_translate_func().
func (a actionGroup) SetTranslationDomain(domain string) {
	var arg0 *C.GtkActionGroup
	var arg1 *C.gchar

	arg0 = (*C.GtkActionGroup)(a.Native())
	arg1 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_action_group_set_translation_domain(arg0, arg1)
}

// SetVisible changes the visible of @action_group.
func (a actionGroup) SetVisible(visible bool) {
	var arg0 *C.GtkActionGroup
	var arg1 C.gboolean

	arg0 = (*C.GtkActionGroup)(a.Native())
	if visible {
		arg1 = C.TRUE
	}

	C.gtk_action_group_set_visible(arg0, arg1)
}

// TranslateString translates a string using the function set with
// gtk_action_group_set_translate_func(). This is mainly intended for
// language bindings.
func (a actionGroup) TranslateString(string string) string {
	var arg0 *C.GtkActionGroup
	var arg1 *C.gchar

	arg0 = (*C.GtkActionGroup)(a.Native())
	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_action_group_translate_string(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}
