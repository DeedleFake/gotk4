// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: glib-2.0 gtk+-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_accel_flags_get_type()), F: marshalAccelFlags},
		{T: externglib.Type(C.gtk_accel_group_get_type()), F: marshalAccelGroup},
	})
}

// AccelFlags: accelerator flags used with gtk_accel_group_connect().
type AccelFlags int

const (
	// AccelFlagsVisible: accelerator is visible
	AccelFlagsVisible AccelFlags = 1
	// AccelFlagsLocked: accelerator not removable
	AccelFlagsLocked AccelFlags = 2
	// AccelFlagsMask: mask
	AccelFlagsMask AccelFlags = 7
)

func marshalAccelFlags(p uintptr) (interface{}, error) {
	return AccelFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccelGroup: a AccelGroup represents a group of keyboard accelerators,
// typically attached to a toplevel Window (with gtk_window_add_accel_group()).
// Usually you won’t need to create a AccelGroup directly; instead, when using
// UIManager, GTK+ automatically sets up the accelerators for your menus in the
// ui manager’s AccelGroup.
//
// Note that “accelerators” are different from “mnemonics”. Accelerators are
// shortcuts for activating a menu item; they appear alongside the menu item
// they’re a shortcut for. For example “Ctrl+Q” might appear alongside the
// “Quit” menu item. Mnemonics are shortcuts for GUI elements such as text
// entries or buttons; they appear as underlined characters. See
// gtk_label_new_with_mnemonic(). Menu items can have both accelerators and
// mnemonics, of course.
type AccelGroup interface {
	gextras.Objector

	// IsLocked locks are added and removed using gtk_accel_group_lock() and
	// gtk_accel_group_unlock().
	IsLocked() bool
	// Lock locks the given accelerator group.
	//
	// Locking an acelerator group prevents the accelerators contained within it
	// to be changed during runtime. Refer to gtk_accel_map_change_entry() about
	// runtime accelerator changes.
	//
	// If called more than once, @accel_group remains locked until
	// gtk_accel_group_unlock() has been called an equivalent number of times.
	Lock()
	// Unlock undoes the last call to gtk_accel_group_lock() on this
	// @accel_group.
	Unlock()
}

// accelGroup implements the AccelGroup class.
type accelGroup struct {
	gextras.Objector
}

var _ AccelGroup = (*accelGroup)(nil)

// WrapAccelGroup wraps a GObject to the right type. It is
// primarily used internally.
func WrapAccelGroup(obj *externglib.Object) AccelGroup {
	return accelGroup{
		Objector: obj,
	}
}

func marshalAccelGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAccelGroup(obj), nil
}

// NewAccelGroup constructs a class AccelGroup.
func NewAccelGroup() AccelGroup {
	var _cret C.GtkAccelGroup // in

	_cret = C.gtk_accel_group_new()

	var _accelGroup AccelGroup // out

	_accelGroup = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(AccelGroup)

	return _accelGroup
}

// IsLocked locks are added and removed using gtk_accel_group_lock() and
// gtk_accel_group_unlock().
func (a accelGroup) IsLocked() bool {
	var _arg0 *C.GtkAccelGroup // out

	_arg0 = (*C.GtkAccelGroup)(unsafe.Pointer(a.Native()))

	var _cret C.gboolean // in

	_cret = C.gtk_accel_group_get_is_locked(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Lock locks the given accelerator group.
//
// Locking an acelerator group prevents the accelerators contained within it
// to be changed during runtime. Refer to gtk_accel_map_change_entry() about
// runtime accelerator changes.
//
// If called more than once, @accel_group remains locked until
// gtk_accel_group_unlock() has been called an equivalent number of times.
func (a accelGroup) Lock() {
	var _arg0 *C.GtkAccelGroup // out

	_arg0 = (*C.GtkAccelGroup)(unsafe.Pointer(a.Native()))

	C.gtk_accel_group_lock(_arg0)
}

// Unlock undoes the last call to gtk_accel_group_lock() on this
// @accel_group.
func (a accelGroup) Unlock() {
	var _arg0 *C.GtkAccelGroup // out

	_arg0 = (*C.GtkAccelGroup)(unsafe.Pointer(a.Native()))

	C.gtk_accel_group_unlock(_arg0)
}

type AccelGroupEntry struct {
	native C.GtkAccelGroupEntry
}

// WrapAccelGroupEntry wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAccelGroupEntry(ptr unsafe.Pointer) *AccelGroupEntry {
	if ptr == nil {
		return nil
	}

	return (*AccelGroupEntry)(ptr)
}

// Native returns the underlying C source pointer.
func (a *AccelGroupEntry) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// Key gets the field inside the struct.
func (a *AccelGroupEntry) Key() AccelKey {
	var v AccelKey // out
	v = *WrapAccelKey(unsafe.Pointer(&a.native.key))
	return v
}

type AccelKey struct {
	native C.GtkAccelKey
}

// WrapAccelKey wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAccelKey(ptr unsafe.Pointer) *AccelKey {
	if ptr == nil {
		return nil
	}

	return (*AccelKey)(ptr)
}

// Native returns the underlying C source pointer.
func (a *AccelKey) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// AccelKey gets the field inside the struct.
func (a *AccelKey) AccelKey() uint {
	var v uint // out
	v = (uint)(a.native.accel_key)
	return v
}
