// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk+-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_accel_flags_get_type()), F: marshalAccelFlags},
		{T: externglib.Type(C.gtk_accel_group_get_type()), F: marshalAccelGrouper},
	})
}

// AccelFlags: accelerator flags used with gtk_accel_group_connect().
type AccelFlags int

const (
	// AccelFlagsVisible: accelerator is visible
	AccelFlagsVisible AccelFlags = 0b1
	// AccelFlagsLocked: accelerator not removable
	AccelFlagsLocked AccelFlags = 0b10
	// AccelFlagsMask: mask
	AccelFlagsMask AccelFlags = 0b111
)

func marshalAccelFlags(p uintptr) (interface{}, error) {
	return AccelFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AcceleratorGetDefaultModMask gets the modifier mask.
//
// The modifier mask determines which modifiers are considered significant for
// keyboard accelerators. See gtk_accelerator_set_default_mod_mask().
func AcceleratorGetDefaultModMask() gdk.ModifierType {
	var _cret C.GdkModifierType // in

	_cret = C.gtk_accelerator_get_default_mod_mask()

	var _modifierType gdk.ModifierType // out

	_modifierType = gdk.ModifierType(_cret)

	return _modifierType
}

// AcceleratorParse parses a string representing an accelerator. The format
// looks like “<Control>a” or “<Shift><Alt>F1” or “<Release>z” (the last one is
// for key release).
//
// The parser is fairly liberal and allows lower or upper case, and also
// abbreviations such as “<Ctl>” and “<Ctrl>”. Key names are parsed using
// gdk_keyval_from_name(). For character keys the name is not the symbol, but
// the lowercase name, e.g. one would use “<Ctrl>minus” instead of “<Ctrl>-”.
//
// If the parse fails, @accelerator_key and @accelerator_mods will be set to 0
// (zero).
func AcceleratorParse(accelerator string) (uint, gdk.ModifierType) {
	var _arg1 *C.gchar          // out
	var _arg2 C.guint           // in
	var _arg3 C.GdkModifierType // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(accelerator)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_accelerator_parse(_arg1, &_arg2, &_arg3)

	var _acceleratorKey uint              // out
	var _acceleratorMods gdk.ModifierType // out

	_acceleratorKey = uint(_arg2)
	_acceleratorMods = gdk.ModifierType(_arg3)

	return _acceleratorKey, _acceleratorMods
}

// AcceleratorParseWithKeycode parses a string representing an accelerator,
// similarly to gtk_accelerator_parse() but handles keycodes as well. This is
// only useful for system-level components, applications should use
// gtk_accelerator_parse() instead.
//
// If @accelerator_codes is given and the result stored in it is non-nil, the
// result must be freed with g_free().
//
// If a keycode is present in the accelerator and no @accelerator_codes is
// given, the parse will fail.
//
// If the parse fails, @accelerator_key, @accelerator_mods and
// @accelerator_codes will be set to 0 (zero).
func AcceleratorParseWithKeycode(accelerator string) (uint, []uint, gdk.ModifierType) {
	var _arg1 *C.gchar // out
	var _arg2 C.guint  // in
	var _arg3 *C.guint
	var _arg4 C.GdkModifierType // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(accelerator)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_accelerator_parse_with_keycode(_arg1, &_arg2, &_arg3, &_arg4)

	var _acceleratorKey uint // out
	var _acceleratorCodes []uint
	var _acceleratorMods gdk.ModifierType // out

	_acceleratorKey = uint(_arg2)
	{
		var i int
		var z C.guint
		for p := _arg3; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_arg3, i)
		_acceleratorCodes = make([]uint, i)
		for i := range src {
			_acceleratorCodes[i] = uint(src[i])
		}
	}
	_acceleratorMods = gdk.ModifierType(_arg4)

	return _acceleratorKey, _acceleratorCodes, _acceleratorMods
}

// AccelGrouper describes AccelGroup's methods.
type AccelGrouper interface {
	// IsLocked locks are added and removed using gtk_accel_group_lock() and
	// gtk_accel_group_unlock().
	IsLocked() bool
	// ModifierMask gets a ModifierType representing the mask for this
	// @accel_group.
	ModifierMask() gdk.ModifierType
	// Lock locks the given accelerator group.
	Lock()
	// Unlock undoes the last call to gtk_accel_group_lock() on this
	// @accel_group.
	Unlock()
}

// AccelGroup represents a group of keyboard accelerators, typically attached to
// a toplevel Window (with gtk_window_add_accel_group()). Usually you won’t need
// to create a AccelGroup directly; instead, when using UIManager, GTK+
// automatically sets up the accelerators for your menus in the ui manager’s
// AccelGroup.
//
// Note that “accelerators” are different from “mnemonics”. Accelerators are
// shortcuts for activating a menu item; they appear alongside the menu item
// they’re a shortcut for. For example “Ctrl+Q” might appear alongside the
// “Quit” menu item. Mnemonics are shortcuts for GUI elements such as text
// entries or buttons; they appear as underlined characters. See
// gtk_label_new_with_mnemonic(). Menu items can have both accelerators and
// mnemonics, of course.
type AccelGroup struct {
	*externglib.Object
}

var (
	_ AccelGrouper    = (*AccelGroup)(nil)
	_ gextras.Nativer = (*AccelGroup)(nil)
)

func wrapAccelGroup(obj *externglib.Object) AccelGrouper {
	return &AccelGroup{
		Object: obj,
	}
}

func marshalAccelGrouper(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapAccelGroup(obj), nil
}

// NewAccelGroup creates a new AccelGroup.
func NewAccelGroup() *AccelGroup {
	var _cret *C.GtkAccelGroup // in

	_cret = C.gtk_accel_group_new()

	var _accelGroup *AccelGroup // out

	_accelGroup = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*AccelGroup)

	return _accelGroup
}

// IsLocked locks are added and removed using gtk_accel_group_lock() and
// gtk_accel_group_unlock().
func (accelGroup *AccelGroup) IsLocked() bool {
	var _arg0 *C.GtkAccelGroup // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkAccelGroup)(unsafe.Pointer(accelGroup.Native()))

	_cret = C.gtk_accel_group_get_is_locked(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ModifierMask gets a ModifierType representing the mask for this @accel_group.
// For example, K_CONTROL_MASK, K_SHIFT_MASK, etc.
func (accelGroup *AccelGroup) ModifierMask() gdk.ModifierType {
	var _arg0 *C.GtkAccelGroup  // out
	var _cret C.GdkModifierType // in

	_arg0 = (*C.GtkAccelGroup)(unsafe.Pointer(accelGroup.Native()))

	_cret = C.gtk_accel_group_get_modifier_mask(_arg0)

	var _modifierType gdk.ModifierType // out

	_modifierType = gdk.ModifierType(_cret)

	return _modifierType
}

// Lock locks the given accelerator group.
//
// Locking an acelerator group prevents the accelerators contained within it to
// be changed during runtime. Refer to gtk_accel_map_change_entry() about
// runtime accelerator changes.
//
// If called more than once, @accel_group remains locked until
// gtk_accel_group_unlock() has been called an equivalent number of times.
func (accelGroup *AccelGroup) Lock() {
	var _arg0 *C.GtkAccelGroup // out

	_arg0 = (*C.GtkAccelGroup)(unsafe.Pointer(accelGroup.Native()))

	C.gtk_accel_group_lock(_arg0)
}

// Unlock undoes the last call to gtk_accel_group_lock() on this @accel_group.
func (accelGroup *AccelGroup) Unlock() {
	var _arg0 *C.GtkAccelGroup // out

	_arg0 = (*C.GtkAccelGroup)(unsafe.Pointer(accelGroup.Native()))

	C.gtk_accel_group_unlock(_arg0)
}

//
type AccelGroupEntry struct {
	native C.GtkAccelGroupEntry
}

// Native returns the underlying C source pointer.
func (a *AccelGroupEntry) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

//
type AccelKey struct {
	native C.GtkAccelKey
}

// Native returns the underlying C source pointer.
func (a *AccelKey) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}
