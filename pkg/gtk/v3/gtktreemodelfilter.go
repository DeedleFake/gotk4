// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	"github.com/diamondburned/gotk4/internal/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk+-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <stdbool.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
//
// extern void gotk4_TreeModelFilterModifyFunc(GtkTreeModel* _0, GtkTreeIter* _1, GValue* _2, gint _3, gpointer _4);
// extern gboolean gotk4_TreeModelFilterVisibleFunc(GtkTreeModel* _0, GtkTreeIter* _1, gpointer _2);
// extern void callbackDelete(gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_tree_model_filter_get_type()), F: marshalTreeModelFilter},
	})
}

//export callbackDelete
func callbackDelete(ptr C.gpointer) {
	box.Delete(box.Callback, uintptr(ptr))
}

// TreeModelFilterModifyFunc: a function which calculates display values from
// raw values in the model. It must fill @value with the display value for the
// column @column in the row indicated by @iter.
//
// Since this function is called for each data access, it’s not a particularly
// efficient operation.
type TreeModelFilterModifyFunc func(model TreeModel, iter *TreeIter, column int) externglib.Value

//export gotk4_TreeModelFilterModifyFunc
func gotk4_TreeModelFilterModifyFunc(arg0 *C.GtkTreeModel, arg1 *C.GtkTreeIter, arg2 *C.GValue, arg3 C.gint, arg4 C.gpointer) {
	v := box.Get(uintptr(arg4))
	if v == nil {
		panic(`callback not found`)
	}

	var model TreeModel
	var iter *TreeIter
	var column int

	model = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(TreeModel)

	{
		iter = WrapTreeIter(unsafe.Pointer(arg1))
	}

	column = int(arg3)

	value := v.(TreeModelFilterModifyFunc)(model, iter, column)
}

// TreeModelFilterVisibleFunc: a function which decides whether the row
// indicated by @iter is visible.
type TreeModelFilterVisibleFunc func(model TreeModel, iter *TreeIter) bool

//export gotk4_TreeModelFilterVisibleFunc
func gotk4_TreeModelFilterVisibleFunc(arg0 *C.GtkTreeModel, arg1 *C.GtkTreeIter, arg2 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var model TreeModel
	var iter *TreeIter

	model = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(TreeModel)

	{
		iter = WrapTreeIter(unsafe.Pointer(arg1))
	}

	ok := v.(TreeModelFilterVisibleFunc)(model, iter)
}

type TreeModelFilterPrivate struct {
	native C.GtkTreeModelFilterPrivate
}

// WrapTreeModelFilterPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTreeModelFilterPrivate(ptr unsafe.Pointer) *TreeModelFilterPrivate {
	if ptr == nil {
		return nil
	}

	return (*TreeModelFilterPrivate)(ptr)
}

func marshalTreeModelFilterPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTreeModelFilterPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TreeModelFilterPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// TreeModelFilter: a TreeModelFilter is a tree model which wraps another tree
// model, and can do the following things:
//
// - Filter specific rows, based on data from a “visible column”, a column
// storing booleans indicating whether the row should be filtered or not, or
// based on the return value of a “visible function”, which gets a model, iter
// and user_data and returns a boolean indicating whether the row should be
// filtered or not.
//
// - Modify the “appearance” of the model, using a modify function. This is
// extremely powerful and allows for just changing some values and also for
// creating a completely different model based on the given child model.
//
// - Set a different root node, also known as a “virtual root”. You can pass in
// a TreePath indicating the root node for the filter at construction time.
//
// The basic API is similar to TreeModelSort. For an example on its usage, see
// the section on TreeModelSort.
//
// When using TreeModelFilter, it is important to realize that TreeModelFilter
// maintains an internal cache of all nodes which are visible in its clients.
// The cache is likely to be a subtree of the tree exposed by the child model.
// TreeModelFilter will not cache the entire child model when unnecessary to not
// compromise the caching mechanism that is exposed by the reference counting
// scheme. If the child model implements reference counting, unnecessary signals
// may not be emitted because of reference counting rule 3, see the TreeModel
// documentation. (Note that e.g. TreeStore does not implement reference
// counting and will always emit all signals, even when the receiving node is
// not visible).
//
// Because of this, limitations for possible visible functions do apply. In
// general, visible functions should only use data or properties from the node
// for which the visibility state must be determined, its siblings or its
// parents. Usually, having a dependency on the state of any child node is not
// possible, unless references are taken on these explicitly. When no such
// reference exists, no signals may be received for these child nodes (see
// reference couting rule number 3 in the TreeModel section).
//
// Determining the visibility state of a given node based on the state of its
// child nodes is a frequently occurring use case. Therefore, TreeModelFilter
// explicitly supports this. For example, when a node does not have any
// children, you might not want the node to be visible. As soon as the first row
// is added to the node’s child level (or the last row removed), the node’s
// visibility should be updated.
//
// This introduces a dependency from the node on its child nodes. In order to
// accommodate this, TreeModelFilter must make sure the necessary signals are
// received from the child model. This is achieved by building, for all nodes
// which are exposed as visible nodes to TreeModelFilter's clients, the child
// level (if any) and take a reference on the first node in this level.
// Furthermore, for every row-inserted, row-changed or row-deleted signal (also
// these which were not handled because the node was not cached),
// TreeModelFilter will check if the visibility state of any parent node has
// changed.
//
// Beware, however, that this explicit support is limited to these two cases.
// For example, if you want a node to be visible only if two nodes in a child’s
// child level (2 levels deeper) are visible, you are on your own. In this case,
// either rely on TreeStore to emit all signals because it does not implement
// reference counting, or for models that do implement reference counting,
// obtain references on these child levels yourself.
type TreeModelFilter interface {
	gextras.Objector
	TreeDragSource
	TreeModel

	// ClearCache: this function should almost never be called. It clears the
	// @filter of any cached iterators that haven’t been reffed with
	// gtk_tree_model_ref_node(). This might be useful if the child model being
	// filtered is static (and doesn’t change often) and there has been a lot of
	// unreffed access to nodes. As a side effect of this function, all unreffed
	// iters will be invalid.
	ClearCache()
	// ConvertChildIterToIter sets @filter_iter to point to the row in @filter
	// that corresponds to the row pointed at by @child_iter. If @filter_iter
	// was not set, false is returned.
	ConvertChildIterToIter(childIter *TreeIter) (filterIter TreeIter, ok bool)
	// ConvertChildPathToPath converts @child_path to a path relative to
	// @filter. That is, @child_path points to a path in the child model. The
	// rerturned path will point to the same row in the filtered model. If
	// @child_path isn’t a valid path on the child model or points to a row
	// which is not visible in @filter, then nil is returned.
	ConvertChildPathToPath(childPath *TreePath) *TreePath
	// ConvertIterToChildIter sets @child_iter to point to the row pointed to by
	// @filter_iter.
	ConvertIterToChildIter(filterIter *TreeIter) TreeIter
	// ConvertPathToChildPath converts @filter_path to a path on the child model
	// of @filter. That is, @filter_path points to a location in @filter. The
	// returned path will point to the same location in the model not being
	// filtered. If @filter_path does not point to a location in the child
	// model, nil is returned.
	ConvertPathToChildPath(filterPath *TreePath) *TreePath
	// Model returns a pointer to the child model of @filter.
	Model() TreeModel
	// Refilter emits ::row_changed for each row in the child model, which
	// causes the filter to re-evaluate whether a row is visible or not.
	Refilter()
	// SetModifyFunc: with the @n_columns and @types parameters, you give an
	// array of column types for this model (which will be exposed to the parent
	// model/view). The @func, @data and @destroy parameters are for specifying
	// the modify function. The modify function will get called for each data
	// access, the goal of the modify function is to return the data which
	// should be displayed at the location specified using the parameters of the
	// modify function.
	//
	// Note that gtk_tree_model_filter_set_modify_func() can only be called once
	// for a given filter model.
	SetModifyFunc(nColumns int, types []externglib.Type, fn TreeModelFilterModifyFunc)
	// SetVisibleColumn sets @column of the child_model to be the column where
	// @filter should look for visibility information. @columns should be a
	// column of type G_TYPE_BOOLEAN, where true means that a row is visible,
	// and false if not.
	//
	// Note that gtk_tree_model_filter_set_visible_func() or
	// gtk_tree_model_filter_set_visible_column() can only be called once for a
	// given filter model.
	SetVisibleColumn(column int)
	// SetVisibleFunc sets the visible function used when filtering the @filter
	// to be @func. The function should return true if the given row should be
	// visible and false otherwise.
	//
	// If the condition calculated by the function changes over time (e.g.
	// because it depends on some global parameters), you must call
	// gtk_tree_model_filter_refilter() to keep the visibility information of
	// the model up-to-date.
	//
	// Note that @func is called whenever a row is inserted, when it may still
	// be empty. The visible function should therefore take special care of
	// empty rows, like in the example below.
	//
	//    static gboolean
	//    visible_func (GtkTreeModel *model,
	//                  GtkTreeIter  *iter,
	//                  gpointer      data)
	//    {
	//      // Visible if row is non-empty and first column is “HI”
	//      gchar *str;
	//      gboolean visible = FALSE;
	//
	//      gtk_tree_model_get (model, iter, 0, &str, -1);
	//      if (str && strcmp (str, "HI") == 0)
	//        visible = TRUE;
	//      g_free (str);
	//
	//      return visible;
	//    }
	//
	// Note that gtk_tree_model_filter_set_visible_func() or
	// gtk_tree_model_filter_set_visible_column() can only be called once for a
	// given filter model.
	SetVisibleFunc(fn TreeModelFilterVisibleFunc)
}

// treeModelFilter implements the TreeModelFilter interface.
type treeModelFilter struct {
	gextras.Objector
	TreeDragSource
	TreeModel
}

var _ TreeModelFilter = (*treeModelFilter)(nil)

// WrapTreeModelFilter wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeModelFilter(obj *externglib.Object) TreeModelFilter {
	return TreeModelFilter{
		Objector:       obj,
		TreeDragSource: WrapTreeDragSource(obj),
		TreeModel:      WrapTreeModel(obj),
	}
}

func marshalTreeModelFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeModelFilter(obj), nil
}

// ClearCache: this function should almost never be called. It clears the
// @filter of any cached iterators that haven’t been reffed with
// gtk_tree_model_ref_node(). This might be useful if the child model being
// filtered is static (and doesn’t change often) and there has been a lot of
// unreffed access to nodes. As a side effect of this function, all unreffed
// iters will be invalid.
func (f treeModelFilter) ClearCache() {
	var arg0 *C.GtkTreeModelFilter

	arg0 = (*C.GtkTreeModelFilter)(f.Native())

	C.gtk_tree_model_filter_clear_cache(arg0)
}

// ConvertChildIterToIter sets @filter_iter to point to the row in @filter
// that corresponds to the row pointed at by @child_iter. If @filter_iter
// was not set, false is returned.
func (f treeModelFilter) ConvertChildIterToIter(childIter *TreeIter) (filterIter TreeIter, ok bool) {
	var arg0 *C.GtkTreeModelFilter
	var arg1 *C.GtkTreeIter // out
	var arg2 *C.GtkTreeIter

	arg0 = (*C.GtkTreeModelFilter)(f.Native())
	arg2 = (*C.GtkTreeIter)(childIter.Native())

	ret := C.gtk_tree_model_filter_convert_child_iter_to_iter(arg0, &arg1, arg2)

	var ret0 *TreeIter
	var ret1 bool

	{
		ret0 = WrapTreeIter(unsafe.Pointer(arg1))
	}

	ret1 = C.bool(ret) != 0

	return ret0, ret1
}

// ConvertChildPathToPath converts @child_path to a path relative to
// @filter. That is, @child_path points to a path in the child model. The
// rerturned path will point to the same row in the filtered model. If
// @child_path isn’t a valid path on the child model or points to a row
// which is not visible in @filter, then nil is returned.
func (f treeModelFilter) ConvertChildPathToPath(childPath *TreePath) *TreePath {
	var arg0 *C.GtkTreeModelFilter
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkTreeModelFilter)(f.Native())
	arg1 = (*C.GtkTreePath)(childPath.Native())

	ret := C.gtk_tree_model_filter_convert_child_path_to_path(arg0, arg1)

	var ret0 *TreePath

	{
		ret0 = WrapTreePath(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *TreePath) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// ConvertIterToChildIter sets @child_iter to point to the row pointed to by
// @filter_iter.
func (f treeModelFilter) ConvertIterToChildIter(filterIter *TreeIter) TreeIter {
	var arg0 *C.GtkTreeModelFilter
	var arg1 *C.GtkTreeIter // out
	var arg2 *C.GtkTreeIter

	arg0 = (*C.GtkTreeModelFilter)(f.Native())
	arg2 = (*C.GtkTreeIter)(filterIter.Native())

	C.gtk_tree_model_filter_convert_iter_to_child_iter(arg0, &arg1, arg2)

	var ret0 *TreeIter

	{
		ret0 = WrapTreeIter(unsafe.Pointer(arg1))
	}

	return ret0
}

// ConvertPathToChildPath converts @filter_path to a path on the child model
// of @filter. That is, @filter_path points to a location in @filter. The
// returned path will point to the same location in the model not being
// filtered. If @filter_path does not point to a location in the child
// model, nil is returned.
func (f treeModelFilter) ConvertPathToChildPath(filterPath *TreePath) *TreePath {
	var arg0 *C.GtkTreeModelFilter
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkTreeModelFilter)(f.Native())
	arg1 = (*C.GtkTreePath)(filterPath.Native())

	ret := C.gtk_tree_model_filter_convert_path_to_child_path(arg0, arg1)

	var ret0 *TreePath

	{
		ret0 = WrapTreePath(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *TreePath) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Model returns a pointer to the child model of @filter.
func (f treeModelFilter) Model() TreeModel {
	var arg0 *C.GtkTreeModelFilter

	arg0 = (*C.GtkTreeModelFilter)(f.Native())

	ret := C.gtk_tree_model_filter_get_model(arg0)

	var ret0 TreeModel

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(TreeModel)

	return ret0
}

// Refilter emits ::row_changed for each row in the child model, which
// causes the filter to re-evaluate whether a row is visible or not.
func (f treeModelFilter) Refilter() {
	var arg0 *C.GtkTreeModelFilter

	arg0 = (*C.GtkTreeModelFilter)(f.Native())

	C.gtk_tree_model_filter_refilter(arg0)
}

// SetModifyFunc: with the @n_columns and @types parameters, you give an
// array of column types for this model (which will be exposed to the parent
// model/view). The @func, @data and @destroy parameters are for specifying
// the modify function. The modify function will get called for each data
// access, the goal of the modify function is to return the data which
// should be displayed at the location specified using the parameters of the
// modify function.
//
// Note that gtk_tree_model_filter_set_modify_func() can only be called once
// for a given filter model.
func (f treeModelFilter) SetModifyFunc(nColumns int, types []externglib.Type, fn TreeModelFilterModifyFunc) {
	var arg0 *C.GtkTreeModelFilter
	var arg1 C.gint
	var arg2 *C.GType
	var arg3 C.GtkTreeModelFilterModifyFunc
	var arg4 C.gpointer
	var arg5 C.GDestroyNotify

	arg0 = (*C.GtkTreeModelFilter)(f.Native())
	{
		var dst []C.GType
		ptr := C.malloc(C.sizeof_GType * len(types))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(types)
		sliceHeader.Cap = len(types)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(types); i++ {
			src := types[i]
			dst[i] = C.GType(src)
		}

		arg2 = (*C.GType)(unsafe.Pointer(ptr))
		arg1 = len(types)
	}
	arg3 = (*[0]byte)(C.gotk4_TreeModelFilterModifyFunc)
	arg4 = C.gpointer(box.Assign(fn))
	arg5 = (*[0]byte)(C.callbackDelete)

	C.gtk_tree_model_filter_set_modify_func(arg0, arg1, arg2, arg3, arg4, arg5)
}

// SetVisibleColumn sets @column of the child_model to be the column where
// @filter should look for visibility information. @columns should be a
// column of type G_TYPE_BOOLEAN, where true means that a row is visible,
// and false if not.
//
// Note that gtk_tree_model_filter_set_visible_func() or
// gtk_tree_model_filter_set_visible_column() can only be called once for a
// given filter model.
func (f treeModelFilter) SetVisibleColumn(column int) {
	var arg0 *C.GtkTreeModelFilter
	var arg1 C.gint

	arg0 = (*C.GtkTreeModelFilter)(f.Native())
	arg1 = C.gint(column)

	C.gtk_tree_model_filter_set_visible_column(arg0, arg1)
}

// SetVisibleFunc sets the visible function used when filtering the @filter
// to be @func. The function should return true if the given row should be
// visible and false otherwise.
//
// If the condition calculated by the function changes over time (e.g.
// because it depends on some global parameters), you must call
// gtk_tree_model_filter_refilter() to keep the visibility information of
// the model up-to-date.
//
// Note that @func is called whenever a row is inserted, when it may still
// be empty. The visible function should therefore take special care of
// empty rows, like in the example below.
//
//    static gboolean
//    visible_func (GtkTreeModel *model,
//                  GtkTreeIter  *iter,
//                  gpointer      data)
//    {
//      // Visible if row is non-empty and first column is “HI”
//      gchar *str;
//      gboolean visible = FALSE;
//
//      gtk_tree_model_get (model, iter, 0, &str, -1);
//      if (str && strcmp (str, "HI") == 0)
//        visible = TRUE;
//      g_free (str);
//
//      return visible;
//    }
//
// Note that gtk_tree_model_filter_set_visible_func() or
// gtk_tree_model_filter_set_visible_column() can only be called once for a
// given filter model.
func (f treeModelFilter) SetVisibleFunc(fn TreeModelFilterVisibleFunc) {
	var arg0 *C.GtkTreeModelFilter
	var arg1 C.GtkTreeModelFilterVisibleFunc
	var arg2 C.gpointer
	var arg3 C.GDestroyNotify

	arg0 = (*C.GtkTreeModelFilter)(f.Native())
	arg1 = (*[0]byte)(C.gotk4_TreeModelFilterVisibleFunc)
	arg2 = C.gpointer(box.Assign(fn))
	arg3 = (*[0]byte)(C.callbackDelete)

	C.gtk_tree_model_filter_set_visible_func(arg0, arg1, arg2, arg3)
}
