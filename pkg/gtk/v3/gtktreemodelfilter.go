// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/box"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk+-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
//
// gboolean gotk4_TreeModelForeachFunc(GtkTreeModel*, GtkTreePath*, GtkTreeIter*, gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_tree_model_filter_get_type()), F: marshalTreeModelFilter},
	})
}

// TreeModelFilterModifyFunc: function which calculates display values from raw
// values in the model. It must fill @value with the display value for the
// column @column in the row indicated by @iter.
//
// Since this function is called for each data access, it’s not a particularly
// efficient operation.
type TreeModelFilterModifyFunc func(model TreeModel, iter *TreeIter, column int) (value externglib.Value)

//export gotk4_TreeModelFilterModifyFunc
func gotk4_TreeModelFilterModifyFunc(arg0 *C.GtkTreeModel, arg1 *C.GtkTreeIter, arg2 *C.GValue, arg3 C.gint, arg4 C.gpointer) {
	v := box.Get(uintptr(arg4))
	if v == nil {
		panic(`callback not found`)
	}

	var model TreeModel // out
	var iter *TreeIter  // out
	var column int      // out

	model = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0))).(TreeModel)
	iter = (*TreeIter)(unsafe.Pointer(arg1))
	column = int(arg3)

	fn := v.(TreeModelFilterModifyFunc)
	value := fn(model, iter, column)

	arg2 = (*C.GValue)(unsafe.Pointer(&value.GValue))
}

// TreeModelFilterVisibleFunc: function which decides whether the row indicated
// by @iter is visible.
type TreeModelFilterVisibleFunc func(model TreeModel, iter *TreeIter) (ok bool)

//export gotk4_TreeModelFilterVisibleFunc
func gotk4_TreeModelFilterVisibleFunc(arg0 *C.GtkTreeModel, arg1 *C.GtkTreeIter, arg2 C.gpointer) (cret C.gboolean) {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var model TreeModel // out
	var iter *TreeIter  // out

	model = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0))).(TreeModel)
	iter = (*TreeIter)(unsafe.Pointer(arg1))

	fn := v.(TreeModelFilterVisibleFunc)
	ok := fn(model, iter)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// TreeModelFilter is a tree model which wraps another tree model, and can do
// the following things:
//
// - Filter specific rows, based on data from a “visible column”, a column
// storing booleans indicating whether the row should be filtered or not, or
// based on the return value of a “visible function”, which gets a model, iter
// and user_data and returns a boolean indicating whether the row should be
// filtered or not.
//
// - Modify the “appearance” of the model, using a modify function. This is
// extremely powerful and allows for just changing some values and also for
// creating a completely different model based on the given child model.
//
// - Set a different root node, also known as a “virtual root”. You can pass in
// a TreePath indicating the root node for the filter at construction time.
//
// The basic API is similar to TreeModelSort. For an example on its usage, see
// the section on TreeModelSort.
//
// When using TreeModelFilter, it is important to realize that TreeModelFilter
// maintains an internal cache of all nodes which are visible in its clients.
// The cache is likely to be a subtree of the tree exposed by the child model.
// TreeModelFilter will not cache the entire child model when unnecessary to not
// compromise the caching mechanism that is exposed by the reference counting
// scheme. If the child model implements reference counting, unnecessary signals
// may not be emitted because of reference counting rule 3, see the TreeModel
// documentation. (Note that e.g. TreeStore does not implement reference
// counting and will always emit all signals, even when the receiving node is
// not visible).
//
// Because of this, limitations for possible visible functions do apply. In
// general, visible functions should only use data or properties from the node
// for which the visibility state must be determined, its siblings or its
// parents. Usually, having a dependency on the state of any child node is not
// possible, unless references are taken on these explicitly. When no such
// reference exists, no signals may be received for these child nodes (see
// reference couting rule number 3 in the TreeModel section).
//
// Determining the visibility state of a given node based on the state of its
// child nodes is a frequently occurring use case. Therefore, TreeModelFilter
// explicitly supports this. For example, when a node does not have any
// children, you might not want the node to be visible. As soon as the first row
// is added to the node’s child level (or the last row removed), the node’s
// visibility should be updated.
//
// This introduces a dependency from the node on its child nodes. In order to
// accommodate this, TreeModelFilter must make sure the necessary signals are
// received from the child model. This is achieved by building, for all nodes
// which are exposed as visible nodes to TreeModelFilter's clients, the child
// level (if any) and take a reference on the first node in this level.
// Furthermore, for every row-inserted, row-changed or row-deleted signal (also
// these which were not handled because the node was not cached),
// TreeModelFilter will check if the visibility state of any parent node has
// changed.
//
// Beware, however, that this explicit support is limited to these two cases.
// For example, if you want a node to be visible only if two nodes in a child’s
// child level (2 levels deeper) are visible, you are on your own. In this case,
// either rely on TreeStore to emit all signals because it does not implement
// reference counting, or for models that do implement reference counting,
// obtain references on these child levels yourself.
type TreeModelFilter interface {
	gextras.Objector

	// AsTreeDragSource casts the class to the TreeDragSource interface.
	AsTreeDragSource() TreeDragSource
	// AsTreeModel casts the class to the TreeModel interface.
	AsTreeModel() TreeModel

	// DragDataDelete asks the TreeDragSource to delete the row at @path,
	// because it was moved somewhere else via drag-and-drop. Returns false if
	// the deletion fails because @path no longer exists, or for some
	// model-specific reason. Should robustly handle a @path no longer found in
	// the model!
	//
	// This method is inherited from TreeDragSource
	DragDataDelete(path *TreePath) bool
	// DragDataGet asks the TreeDragSource to fill in @selection_data with a
	// representation of the row at @path. @selection_data->target gives the
	// required type of the data. Should robustly handle a @path no longer found
	// in the model!
	//
	// This method is inherited from TreeDragSource
	DragDataGet(path *TreePath, selectionData *SelectionData) bool
	// RowDraggable asks the TreeDragSource whether a particular row can be used
	// as the source of a DND operation. If the source doesn’t implement this
	// interface, the row is assumed draggable.
	//
	// This method is inherited from TreeDragSource
	RowDraggable(path *TreePath) bool
	// NewFilter creates a new TreeModel, with @child_model as the child_model
	// and @root as the virtual root.
	//
	// This method is inherited from TreeModel
	NewFilter(root *TreePath) TreeModel
	// Foreach calls func on each node in model in a depth-first fashion.
	//
	// If @func returns true, then the tree ceases to be walked, and
	// gtk_tree_model_foreach() returns.
	//
	// This method is inherited from TreeModel
	Foreach(fn TreeModelForeachFunc)
	// GetColumnType returns the type of the column.
	//
	// This method is inherited from TreeModel
	GetColumnType(index_ int) externglib.Type
	// GetFlags returns a set of flags supported by this interface.
	//
	// The flags are a bitwise combination of TreeModelFlags. The flags
	// supported should not change during the lifetime of the @tree_model.
	//
	// This method is inherited from TreeModel
	GetFlags() TreeModelFlags
	// GetIter sets @iter to a valid iterator pointing to @path. If @path does
	// not exist, @iter is set to an invalid iterator and false is returned.
	//
	// This method is inherited from TreeModel
	GetIter(path *TreePath) (TreeIter, bool)
	// GetIterFirst initializes @iter with the first iterator in the tree (the
	// one at the path "0") and returns true. Returns false if the tree is
	// empty.
	//
	// This method is inherited from TreeModel
	GetIterFirst() (TreeIter, bool)
	// GetIterFromString sets @iter to a valid iterator pointing to
	// @path_string, if it exists. Otherwise, @iter is left invalid and false is
	// returned.
	//
	// This method is inherited from TreeModel
	GetIterFromString(pathString string) (TreeIter, bool)
	// GetNColumns returns the number of columns supported by @tree_model.
	//
	// This method is inherited from TreeModel
	GetNColumns() int
	// GetPath returns a newly-created TreePath-struct referenced by @iter.
	//
	// This path should be freed with gtk_tree_path_free().
	//
	// This method is inherited from TreeModel
	GetPath(iter *TreeIter) *TreePath
	// GetStringFromIter generates a string representation of the iter.
	//
	// This string is a “:” separated list of numbers. For example, “4:10:0:3”
	// would be an acceptable return value for this string.
	//
	// This method is inherited from TreeModel
	GetStringFromIter(iter *TreeIter) string
	// GetValue initializes and sets @value to that at @column.
	//
	// When done with @value, g_value_unset() needs to be called to free any
	// allocated memory.
	//
	// This method is inherited from TreeModel
	GetValue(iter *TreeIter, column int) externglib.Value
	// IterChildren sets @iter to point to the first child of @parent.
	//
	// If @parent has no children, false is returned and @iter is set to be
	// invalid. @parent will remain a valid node after this function has been
	// called.
	//
	// If @parent is nil returns the first node, equivalent to
	// `gtk_tree_model_get_iter_first (tree_model, iter);`
	//
	// This method is inherited from TreeModel
	IterChildren(parent *TreeIter) (TreeIter, bool)
	// IterHasChild returns true if @iter has children, false otherwise.
	//
	// This method is inherited from TreeModel
	IterHasChild(iter *TreeIter) bool
	// IterNChildren returns the number of children that @iter has.
	//
	// As a special case, if @iter is nil, then the number of toplevel nodes is
	// returned.
	//
	// This method is inherited from TreeModel
	IterNChildren(iter *TreeIter) int
	// IterNext sets @iter to point to the node following it at the current
	// level.
	//
	// If there is no next @iter, false is returned and @iter is set to be
	// invalid.
	//
	// This method is inherited from TreeModel
	IterNext(iter *TreeIter) bool
	// IterNthChild sets @iter to be the child of @parent, using the given
	// index.
	//
	// The first index is 0. If @n is too big, or @parent has no children, @iter
	// is set to an invalid iterator and false is returned. @parent will remain
	// a valid node after this function has been called. As a special case, if
	// @parent is nil, then the @n-th root node is set.
	//
	// This method is inherited from TreeModel
	IterNthChild(parent *TreeIter, n int) (TreeIter, bool)
	// IterParent sets @iter to be the parent of @child.
	//
	// If @child is at the toplevel, and doesn’t have a parent, then @iter is
	// set to an invalid iterator and false is returned. @child will remain a
	// valid node after this function has been called.
	//
	// @iter will be initialized before the lookup is performed, so @child and
	// @iter cannot point to the same memory location.
	//
	// This method is inherited from TreeModel
	IterParent(child *TreeIter) (TreeIter, bool)
	// IterPrevious sets @iter to point to the previous node at the current
	// level.
	//
	// If there is no previous @iter, false is returned and @iter is set to be
	// invalid.
	//
	// This method is inherited from TreeModel
	IterPrevious(iter *TreeIter) bool
	// RefNode lets the tree ref the node.
	//
	// This is an optional method for models to implement. To be more specific,
	// models may ignore this call as it exists primarily for performance
	// reasons.
	//
	// This function is primarily meant as a way for views to let caching models
	// know when nodes are being displayed (and hence, whether or not to cache
	// that node). Being displayed means a node is in an expanded branch,
	// regardless of whether the node is currently visible in the viewport. For
	// example, a file-system based model would not want to keep the entire
	// file-hierarchy in memory, just the sections that are currently being
	// displayed by every current view.
	//
	// A model should be expected to be able to get an iter independent of its
	// reffed state.
	//
	// This method is inherited from TreeModel
	RefNode(iter *TreeIter)
	// RowChanged emits the TreeModel::row-changed signal on @tree_model.
	//
	// This method is inherited from TreeModel
	RowChanged(path *TreePath, iter *TreeIter)
	// RowDeleted emits the TreeModel::row-deleted signal on @tree_model.
	//
	// This should be called by models after a row has been removed. The
	// location pointed to by @path should be the location that the row
	// previously was at. It may not be a valid location anymore.
	//
	// Nodes that are deleted are not unreffed, this means that any outstanding
	// references on the deleted node should not be released.
	//
	// This method is inherited from TreeModel
	RowDeleted(path *TreePath)
	// RowHasChildToggled emits the TreeModel::row-has-child-toggled signal on
	// @tree_model. This should be called by models after the child state of a
	// node changes.
	//
	// This method is inherited from TreeModel
	RowHasChildToggled(path *TreePath, iter *TreeIter)
	// RowInserted emits the TreeModel::row-inserted signal on @tree_model.
	//
	// This method is inherited from TreeModel
	RowInserted(path *TreePath, iter *TreeIter)
	// RowsReorderedWithLength emits the TreeModel::rows-reordered signal on
	// @tree_model.
	//
	// This should be called by models when their rows have been reordered.
	//
	// This method is inherited from TreeModel
	RowsReorderedWithLength(path *TreePath, iter *TreeIter, newOrder []int)
	// UnrefNode lets the tree unref the node.
	//
	// This is an optional method for models to implement. To be more specific,
	// models may ignore this call as it exists primarily for performance
	// reasons. For more information on what this means, see
	// gtk_tree_model_ref_node().
	//
	// Please note that nodes that are deleted are not unreffed.
	//
	// This method is inherited from TreeModel
	UnrefNode(iter *TreeIter)

	// ClearCache: this function should almost never be called. It clears the
	// @filter of any cached iterators that haven’t been reffed with
	// gtk_tree_model_ref_node(). This might be useful if the child model being
	// filtered is static (and doesn’t change often) and there has been a lot of
	// unreffed access to nodes. As a side effect of this function, all unreffed
	// iters will be invalid.
	ClearCache()
	// ConvertChildIterToIter sets @filter_iter to point to the row in @filter
	// that corresponds to the row pointed at by @child_iter. If @filter_iter
	// was not set, false is returned.
	ConvertChildIterToIter(childIter *TreeIter) (TreeIter, bool)
	// ConvertChildPathToPath converts @child_path to a path relative to
	// @filter. That is, @child_path points to a path in the child model. The
	// rerturned path will point to the same row in the filtered model. If
	// @child_path isn’t a valid path on the child model or points to a row
	// which is not visible in @filter, then nil is returned.
	ConvertChildPathToPath(childPath *TreePath) *TreePath
	// ConvertIterToChildIter sets @child_iter to point to the row pointed to by
	// @filter_iter.
	ConvertIterToChildIter(filterIter *TreeIter) TreeIter
	// ConvertPathToChildPath converts @filter_path to a path on the child model
	// of @filter. That is, @filter_path points to a location in @filter. The
	// returned path will point to the same location in the model not being
	// filtered. If @filter_path does not point to a location in the child
	// model, nil is returned.
	ConvertPathToChildPath(filterPath *TreePath) *TreePath
	// Model returns a pointer to the child model of @filter.
	Model() TreeModel
	// Refilter emits ::row_changed for each row in the child model, which
	// causes the filter to re-evaluate whether a row is visible or not.
	Refilter()
	// SetVisibleColumn sets @column of the child_model to be the column where
	// @filter should look for visibility information. @columns should be a
	// column of type G_TYPE_BOOLEAN, where true means that a row is visible,
	// and false if not.
	//
	// Note that gtk_tree_model_filter_set_visible_func() or
	// gtk_tree_model_filter_set_visible_column() can only be called once for a
	// given filter model.
	SetVisibleColumn(column int)
}

// treeModelFilter implements the TreeModelFilter interface.
type treeModelFilter struct {
	*externglib.Object
}

var _ TreeModelFilter = (*treeModelFilter)(nil)

// WrapTreeModelFilter wraps a GObject to a type that implements
// interface TreeModelFilter. It is primarily used internally.
func WrapTreeModelFilter(obj *externglib.Object) TreeModelFilter {
	return treeModelFilter{obj}
}

func marshalTreeModelFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeModelFilter(obj), nil
}

func (t treeModelFilter) AsTreeDragSource() TreeDragSource {
	return WrapTreeDragSource(gextras.InternObject(t))
}

func (t treeModelFilter) AsTreeModel() TreeModel {
	return WrapTreeModel(gextras.InternObject(t))
}

func (d treeModelFilter) DragDataDelete(path *TreePath) bool {
	return WrapTreeDragSource(gextras.InternObject(d)).DragDataDelete(path)
}

func (d treeModelFilter) DragDataGet(path *TreePath, selectionData *SelectionData) bool {
	return WrapTreeDragSource(gextras.InternObject(d)).DragDataGet(path, selectionData)
}

func (d treeModelFilter) RowDraggable(path *TreePath) bool {
	return WrapTreeDragSource(gextras.InternObject(d)).RowDraggable(path)
}

func (c treeModelFilter) NewFilter(root *TreePath) TreeModel {
	return WrapTreeModel(gextras.InternObject(c)).NewFilter(root)
}

func (m treeModelFilter) Foreach(fn TreeModelForeachFunc) {
	WrapTreeModel(gextras.InternObject(m)).Foreach(fn)
}

func (t treeModelFilter) GetColumnType(index_ int) externglib.Type {
	return WrapTreeModel(gextras.InternObject(t)).GetColumnType(index_)
}

func (t treeModelFilter) GetFlags() TreeModelFlags {
	return WrapTreeModel(gextras.InternObject(t)).GetFlags()
}

func (t treeModelFilter) GetIter(path *TreePath) (TreeIter, bool) {
	return WrapTreeModel(gextras.InternObject(t)).GetIter(path)
}

func (t treeModelFilter) GetIterFirst() (TreeIter, bool) {
	return WrapTreeModel(gextras.InternObject(t)).GetIterFirst()
}

func (t treeModelFilter) GetIterFromString(pathString string) (TreeIter, bool) {
	return WrapTreeModel(gextras.InternObject(t)).GetIterFromString(pathString)
}

func (t treeModelFilter) GetNColumns() int {
	return WrapTreeModel(gextras.InternObject(t)).GetNColumns()
}

func (t treeModelFilter) GetPath(iter *TreeIter) *TreePath {
	return WrapTreeModel(gextras.InternObject(t)).GetPath(iter)
}

func (t treeModelFilter) GetStringFromIter(iter *TreeIter) string {
	return WrapTreeModel(gextras.InternObject(t)).GetStringFromIter(iter)
}

func (t treeModelFilter) GetValue(iter *TreeIter, column int) externglib.Value {
	return WrapTreeModel(gextras.InternObject(t)).GetValue(iter, column)
}

func (t treeModelFilter) IterChildren(parent *TreeIter) (TreeIter, bool) {
	return WrapTreeModel(gextras.InternObject(t)).IterChildren(parent)
}

func (t treeModelFilter) IterHasChild(iter *TreeIter) bool {
	return WrapTreeModel(gextras.InternObject(t)).IterHasChild(iter)
}

func (t treeModelFilter) IterNChildren(iter *TreeIter) int {
	return WrapTreeModel(gextras.InternObject(t)).IterNChildren(iter)
}

func (t treeModelFilter) IterNext(iter *TreeIter) bool {
	return WrapTreeModel(gextras.InternObject(t)).IterNext(iter)
}

func (t treeModelFilter) IterNthChild(parent *TreeIter, n int) (TreeIter, bool) {
	return WrapTreeModel(gextras.InternObject(t)).IterNthChild(parent, n)
}

func (t treeModelFilter) IterParent(child *TreeIter) (TreeIter, bool) {
	return WrapTreeModel(gextras.InternObject(t)).IterParent(child)
}

func (t treeModelFilter) IterPrevious(iter *TreeIter) bool {
	return WrapTreeModel(gextras.InternObject(t)).IterPrevious(iter)
}

func (t treeModelFilter) RefNode(iter *TreeIter) {
	WrapTreeModel(gextras.InternObject(t)).RefNode(iter)
}

func (t treeModelFilter) RowChanged(path *TreePath, iter *TreeIter) {
	WrapTreeModel(gextras.InternObject(t)).RowChanged(path, iter)
}

func (t treeModelFilter) RowDeleted(path *TreePath) {
	WrapTreeModel(gextras.InternObject(t)).RowDeleted(path)
}

func (t treeModelFilter) RowHasChildToggled(path *TreePath, iter *TreeIter) {
	WrapTreeModel(gextras.InternObject(t)).RowHasChildToggled(path, iter)
}

func (t treeModelFilter) RowInserted(path *TreePath, iter *TreeIter) {
	WrapTreeModel(gextras.InternObject(t)).RowInserted(path, iter)
}

func (t treeModelFilter) RowsReorderedWithLength(path *TreePath, iter *TreeIter, newOrder []int) {
	WrapTreeModel(gextras.InternObject(t)).RowsReorderedWithLength(path, iter, newOrder)
}

func (t treeModelFilter) UnrefNode(iter *TreeIter) {
	WrapTreeModel(gextras.InternObject(t)).UnrefNode(iter)
}

func (f treeModelFilter) ClearCache() {
	var _arg0 *C.GtkTreeModelFilter // out

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))

	C.gtk_tree_model_filter_clear_cache(_arg0)
}

func (f treeModelFilter) ConvertChildIterToIter(childIter *TreeIter) (TreeIter, bool) {
	var _arg0 *C.GtkTreeModelFilter // out
	var _arg1 C.GtkTreeIter         // in
	var _arg2 *C.GtkTreeIter        // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(childIter))

	_cret = C.gtk_tree_model_filter_convert_child_iter_to_iter(_arg0, &_arg1, _arg2)

	var _filterIter TreeIter // out
	var _ok bool             // out

	{
		var refTmpIn *C.GtkTreeIter
		var refTmpOut *TreeIter

		in0 := &_arg1
		refTmpIn = in0

		refTmpOut = (*TreeIter)(unsafe.Pointer(refTmpIn))

		_filterIter = *refTmpOut
	}
	if _cret != 0 {
		_ok = true
	}

	return _filterIter, _ok
}

func (f treeModelFilter) ConvertChildPathToPath(childPath *TreePath) *TreePath {
	var _arg0 *C.GtkTreeModelFilter // out
	var _arg1 *C.GtkTreePath        // out
	var _cret *C.GtkTreePath        // in

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(childPath))

	_cret = C.gtk_tree_model_filter_convert_child_path_to_path(_arg0, _arg1)

	var _treePath *TreePath // out

	_treePath = (*TreePath)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treePath, func(v *TreePath) {
		C.free(unsafe.Pointer(v))
	})

	return _treePath
}

func (f treeModelFilter) ConvertIterToChildIter(filterIter *TreeIter) TreeIter {
	var _arg0 *C.GtkTreeModelFilter // out
	var _arg1 C.GtkTreeIter         // in
	var _arg2 *C.GtkTreeIter        // out

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(filterIter))

	C.gtk_tree_model_filter_convert_iter_to_child_iter(_arg0, &_arg1, _arg2)

	var _childIter TreeIter // out

	{
		var refTmpIn *C.GtkTreeIter
		var refTmpOut *TreeIter

		in0 := &_arg1
		refTmpIn = in0

		refTmpOut = (*TreeIter)(unsafe.Pointer(refTmpIn))

		_childIter = *refTmpOut
	}

	return _childIter
}

func (f treeModelFilter) ConvertPathToChildPath(filterPath *TreePath) *TreePath {
	var _arg0 *C.GtkTreeModelFilter // out
	var _arg1 *C.GtkTreePath        // out
	var _cret *C.GtkTreePath        // in

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(filterPath))

	_cret = C.gtk_tree_model_filter_convert_path_to_child_path(_arg0, _arg1)

	var _treePath *TreePath // out

	_treePath = (*TreePath)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treePath, func(v *TreePath) {
		C.free(unsafe.Pointer(v))
	})

	return _treePath
}

func (f treeModelFilter) Model() TreeModel {
	var _arg0 *C.GtkTreeModelFilter // out
	var _cret *C.GtkTreeModel       // in

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_tree_model_filter_get_model(_arg0)

	var _treeModel TreeModel // out

	_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeModel)

	return _treeModel
}

func (f treeModelFilter) Refilter() {
	var _arg0 *C.GtkTreeModelFilter // out

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))

	C.gtk_tree_model_filter_refilter(_arg0)
}

func (f treeModelFilter) SetVisibleColumn(column int) {
	var _arg0 *C.GtkTreeModelFilter // out
	var _arg1 C.gint                // out

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))
	_arg1 = C.gint(column)

	C.gtk_tree_model_filter_set_visible_column(_arg0, _arg1)
}
