// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_text_iter_get_type()), F: marshalTextIter},
	})
}

type TextCharPredicate func(ch uint32) bool

//export gotk4_TextCharPredicate
func gotk4_TextCharPredicate(arg0 C.gunichar, arg1 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	fn := v.(TextCharPredicate)
	ret := fn(ch, userData)

	if ret {
		cret = C.gboolean(1)
	}

	return cret
}

// TextIter: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
type TextIter struct {
	native C.GtkTextIter
}

// WrapTextIter wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTextIter(ptr unsafe.Pointer) *TextIter {
	if ptr == nil {
		return nil
	}

	return (*TextIter)(ptr)
}

func marshalTextIter(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTextIter(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TextIter) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// Assign assigns the value of @other to @iter. This function is not useful in
// applications, because iterators can be assigned with `GtkTextIter i = j;`.
// The function is used by language bindings.
func (i *TextIter) Assign(i *TextIter, other *TextIter) {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(other.Native()))

	C.gtk_text_iter_assign(arg0, arg1)
}

// BackwardChar moves backward by one character offset. Returns true if movement
// was possible; if @iter was the first in the buffer (character offset 0),
// gtk_text_iter_backward_char() returns false for convenience when writing
// loops.
func (i *TextIter) BackwardChar(i *TextIter) bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_backward_char(arg0)

	if cret {
		ok = true
	}

	return ok
}

// BackwardChars moves @count characters backward, if possible (if @count would
// move past the start or end of the buffer, moves to the start or end of the
// buffer). The return value indicates whether the iterator moved onto a
// dereferenceable position; if the iterator didn’t move, or moved onto the end
// iterator, then false is returned. If @count is 0, the function does nothing
// and returns false.
func (i *TextIter) BackwardChars(i *TextIter, count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.gint(count)

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_backward_chars(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// BackwardCursorPosition: like gtk_text_iter_forward_cursor_position(), but
// moves backward.
func (i *TextIter) BackwardCursorPosition(i *TextIter) bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_backward_cursor_position(arg0)

	if cret {
		ok = true
	}

	return ok
}

// BackwardCursorPositions moves up to @count cursor positions. See
// gtk_text_iter_forward_cursor_position() for details.
func (i *TextIter) BackwardCursorPositions(i *TextIter, count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.gint(count)

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_backward_cursor_positions(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// BackwardLine moves @iter to the start of the previous line. Returns true if
// @iter could be moved; i.e. if @iter was at character offset 0, this function
// returns false. Therefore if @iter was already on line 0, but not at the start
// of the line, @iter is snapped to the start of the line and the function
// returns true. (Note that this implies that in a loop calling this function,
// the line number may not change on every iteration, if your first iteration is
// on line 0.)
func (i *TextIter) BackwardLine(i *TextIter) bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_backward_line(arg0)

	if cret {
		ok = true
	}

	return ok
}

// BackwardLines moves @count lines backward, if possible (if @count would move
// past the start or end of the buffer, moves to the start or end of the
// buffer). The return value indicates whether the iterator moved onto a
// dereferenceable position; if the iterator didn’t move, or moved onto the end
// iterator, then false is returned. If @count is 0, the function does nothing
// and returns false. If @count is negative, moves forward by 0 - @count lines.
func (i *TextIter) BackwardLines(i *TextIter, count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.gint(count)

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_backward_lines(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// BackwardSearch: same as gtk_text_iter_forward_search(), but moves backward.
//
// @match_end will never be set to a TextIter located after @iter, even if there
// is a possible @match_start before or at @iter.
func (i *TextIter) BackwardSearch(i *TextIter, str string, flags TextSearchFlags, limit *TextIter) (matchStart *TextIter, matchEnd *TextIter, ok bool) {
	var arg0 *C.GtkTextIter
	var arg1 *C.gchar
	var arg2 C.GtkTextSearchFlags
	var arg5 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GtkTextSearchFlags)(flags)
	arg5 = (*C.GtkTextIter)(unsafe.Pointer(limit.Native()))

	var arg3 C.GtkTextIter
	var matchStart *TextIter
	var arg4 C.GtkTextIter
	var matchEnd *TextIter
	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_backward_search(arg0, arg1, arg2, &arg3, &arg4, arg5)

	matchStart = WrapTextIter(unsafe.Pointer(&arg3))
	matchEnd = WrapTextIter(unsafe.Pointer(&arg4))
	if cret {
		ok = true
	}

	return matchStart, matchEnd, ok
}

// BackwardSentenceStart moves backward to the previous sentence start; if @iter
// is already at the start of a sentence, moves backward to the next one.
// Sentence boundaries are determined by Pango and should be correct for nearly
// any language (if not, the correct fix would be to the Pango text boundary
// algorithms).
func (i *TextIter) BackwardSentenceStart(i *TextIter) bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_backward_sentence_start(arg0)

	if cret {
		ok = true
	}

	return ok
}

// BackwardSentenceStarts calls gtk_text_iter_backward_sentence_start() up to
// @count times, or until it returns false. If @count is negative, moves forward
// instead of backward.
func (i *TextIter) BackwardSentenceStarts(i *TextIter, count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.gint(count)

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_backward_sentence_starts(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// BackwardToTagToggle moves backward to the next toggle (on or off) of the
// TextTag @tag, or to the next toggle of any tag if @tag is nil. If no matching
// tag toggles are found, returns false, otherwise true. Does not return toggles
// located at @iter, only toggles before @iter. Sets @iter to the location of
// the toggle, or the start of the buffer if no toggle is found.
func (i *TextIter) BackwardToTagToggle(i *TextIter, tag TextTag) bool {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextTag

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_backward_to_tag_toggle(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// BackwardVisibleCursorPosition moves @iter forward to the previous visible
// cursor position. See gtk_text_iter_backward_cursor_position() for details.
func (i *TextIter) BackwardVisibleCursorPosition(i *TextIter) bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_backward_visible_cursor_position(arg0)

	if cret {
		ok = true
	}

	return ok
}

// BackwardVisibleCursorPositions moves up to @count visible cursor positions.
// See gtk_text_iter_backward_cursor_position() for details.
func (i *TextIter) BackwardVisibleCursorPositions(i *TextIter, count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.gint(count)

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_backward_visible_cursor_positions(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// BackwardVisibleLine moves @iter to the start of the previous visible line.
// Returns true if @iter could be moved; i.e. if @iter was at character offset
// 0, this function returns false. Therefore if @iter was already on line 0, but
// not at the start of the line, @iter is snapped to the start of the line and
// the function returns true. (Note that this implies that in a loop calling
// this function, the line number may not change on every iteration, if your
// first iteration is on line 0.)
func (i *TextIter) BackwardVisibleLine(i *TextIter) bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_backward_visible_line(arg0)

	if cret {
		ok = true
	}

	return ok
}

// BackwardVisibleLines moves @count visible lines backward, if possible (if
// @count would move past the start or end of the buffer, moves to the start or
// end of the buffer). The return value indicates whether the iterator moved
// onto a dereferenceable position; if the iterator didn’t move, or moved onto
// the end iterator, then false is returned. If @count is 0, the function does
// nothing and returns false. If @count is negative, moves forward by 0 - @count
// lines.
func (i *TextIter) BackwardVisibleLines(i *TextIter, count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.gint(count)

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_backward_visible_lines(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// BackwardVisibleWordStart moves backward to the previous visible word start.
// (If @iter is currently on a word start, moves backward to the next one after
// that.) Word breaks are determined by Pango and should be correct for nearly
// any language (if not, the correct fix would be to the Pango word break
// algorithms).
func (i *TextIter) BackwardVisibleWordStart(i *TextIter) bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_backward_visible_word_start(arg0)

	if cret {
		ok = true
	}

	return ok
}

// BackwardVisibleWordStarts calls gtk_text_iter_backward_visible_word_start()
// up to @count times.
func (i *TextIter) BackwardVisibleWordStarts(i *TextIter, count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.gint(count)

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_backward_visible_word_starts(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// BackwardWordStart moves backward to the previous word start. (If @iter is
// currently on a word start, moves backward to the next one after that.) Word
// breaks are determined by Pango and should be correct for nearly any language
// (if not, the correct fix would be to the Pango word break algorithms).
func (i *TextIter) BackwardWordStart(i *TextIter) bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_backward_word_start(arg0)

	if cret {
		ok = true
	}

	return ok
}

// BackwardWordStarts calls gtk_text_iter_backward_word_start() up to @count
// times.
func (i *TextIter) BackwardWordStarts(i *TextIter, count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.gint(count)

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_backward_word_starts(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// BeginsTag returns true if @tag is toggled on at exactly this point. If @tag
// is nil, returns true if any tag is toggled on at this point.
//
// Note that if gtk_text_iter_begins_tag() returns true, it means that @iter is
// at the beginning of the tagged range, and that the character at @iter is
// inside the tagged range. In other words, unlike gtk_text_iter_ends_tag(), if
// gtk_text_iter_begins_tag() returns true, gtk_text_iter_has_tag() will also
// return true for the same parameters.
func (i *TextIter) BeginsTag(i *TextIter, tag TextTag) bool {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextTag

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_begins_tag(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// CanInsert: considering the default editability of the buffer, and tags that
// affect editability, determines whether text inserted at @iter would be
// editable. If text inserted at @iter would be editable then the user should be
// allowed to insert text at @iter. gtk_text_buffer_insert_interactive() uses
// this function to decide whether insertions are allowed at a given position.
func (i *TextIter) CanInsert(i *TextIter, defaultEditability bool) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gboolean

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	if defaultEditability {
		arg1 = C.gboolean(1)
	}

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_can_insert(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// Compare: a qsort()-style function that returns negative if @lhs is less than
// @rhs, positive if @lhs is greater than @rhs, and 0 if they’re equal. Ordering
// is in character offset order, i.e. the first character in the buffer is less
// than the second character in the buffer.
func (l *TextIter) Compare(l *TextIter, rhs *TextIter) {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(l.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(rhs.Native()))

	C.gtk_text_iter_compare(arg0, arg1)
}

// Copy creates a dynamically-allocated copy of an iterator. This function is
// not useful in applications, because iterators can be copied with a simple
// assignment (`GtkTextIter i = j;`). The function is used by language bindings.
func (i *TextIter) Copy(i *TextIter) {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	C.gtk_text_iter_copy(arg0)
}

// Editable returns whether the character at @iter is within an editable region
// of text. Non-editable text is “locked” and can’t be changed by the user via
// TextView. This function is simply a convenience wrapper around
// gtk_text_iter_get_attributes(). If no tags applied to this text affect
// editability, @default_setting will be returned.
//
// You don’t want to use this function to decide whether text can be inserted at
// @iter, because for insertion you don’t want to know whether the char at @iter
// is inside an editable range, you want to know whether a new character
// inserted at @iter would be inside an editable range. Use
// gtk_text_iter_can_insert() to handle this case.
func (i *TextIter) Editable(i *TextIter, defaultSetting bool) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gboolean

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	if defaultSetting {
		arg1 = C.gboolean(1)
	}

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_editable(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// EndsLine returns true if @iter points to the start of the paragraph delimiter
// characters for a line (delimiters will be either a newline, a carriage
// return, a carriage return followed by a newline, or a Unicode paragraph
// separator character). Note that an iterator pointing to the \n of a \r\n pair
// will not be counted as the end of a line, the line ends before the \r. The
// end iterator is considered to be at the end of a line, even though there are
// no paragraph delimiter chars there.
func (i *TextIter) EndsLine(i *TextIter) bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_ends_line(arg0)

	if cret {
		ok = true
	}

	return ok
}

// EndsSentence determines whether @iter ends a sentence. Sentence boundaries
// are determined by Pango and should be correct for nearly any language (if
// not, the correct fix would be to the Pango text boundary algorithms).
func (i *TextIter) EndsSentence(i *TextIter) bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_ends_sentence(arg0)

	if cret {
		ok = true
	}

	return ok
}

// EndsTag returns true if @tag is toggled off at exactly this point. If @tag is
// nil, returns true if any tag is toggled off at this point.
//
// Note that if gtk_text_iter_ends_tag() returns true, it means that @iter is at
// the end of the tagged range, but that the character at @iter is outside the
// tagged range. In other words, unlike gtk_text_iter_starts_tag(), if
// gtk_text_iter_ends_tag() returns true, gtk_text_iter_has_tag() will return
// false for the same parameters.
func (i *TextIter) EndsTag(i *TextIter, tag TextTag) bool {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextTag

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_ends_tag(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// EndsWord determines whether @iter ends a natural-language word. Word breaks
// are determined by Pango and should be correct for nearly any language (if
// not, the correct fix would be to the Pango word break algorithms).
func (i *TextIter) EndsWord(i *TextIter) bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_ends_word(arg0)

	if cret {
		ok = true
	}

	return ok
}

// Equal tests whether two iterators are equal, using the fastest possible
// mechanism. This function is very fast; you can expect it to perform better
// than e.g. getting the character offset for each iterator and comparing the
// offsets yourself. Also, it’s a bit faster than gtk_text_iter_compare().
func (l *TextIter) Equal(l *TextIter, rhs *TextIter) bool {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(l.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(rhs.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_equal(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// ForwardChar moves @iter forward by one character offset. Note that images
// embedded in the buffer occupy 1 character slot, so
// gtk_text_iter_forward_char() may actually move onto an image instead of a
// character, if you have images in your buffer. If @iter is the end iterator or
// one character before it, @iter will now point at the end iterator, and
// gtk_text_iter_forward_char() returns false for convenience when writing
// loops.
func (i *TextIter) ForwardChar(i *TextIter) bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_forward_char(arg0)

	if cret {
		ok = true
	}

	return ok
}

// ForwardChars moves @count characters if possible (if @count would move past
// the start or end of the buffer, moves to the start or end of the buffer). The
// return value indicates whether the new position of @iter is different from
// its original position, and dereferenceable (the last iterator in the buffer
// is not dereferenceable). If @count is 0, the function does nothing and
// returns false.
func (i *TextIter) ForwardChars(i *TextIter, count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.gint(count)

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_forward_chars(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// ForwardCursorPosition moves @iter forward by a single cursor position. Cursor
// positions are (unsurprisingly) positions where the cursor can appear. Perhaps
// surprisingly, there may not be a cursor position between all characters. The
// most common example for European languages would be a carriage return/newline
// sequence. For some Unicode characters, the equivalent of say the letter “a”
// with an accent mark will be represented as two characters, first the letter
// then a "combining mark" that causes the accent to be rendered; so the cursor
// can’t go between those two characters. See also the LogAttr-struct and
// pango_break() function.
func (i *TextIter) ForwardCursorPosition(i *TextIter) bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_forward_cursor_position(arg0)

	if cret {
		ok = true
	}

	return ok
}

// ForwardCursorPositions moves up to @count cursor positions. See
// gtk_text_iter_forward_cursor_position() for details.
func (i *TextIter) ForwardCursorPositions(i *TextIter, count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.gint(count)

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_forward_cursor_positions(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// ForwardLine moves @iter to the start of the next line. If the iter is already
// on the last line of the buffer, moves the iter to the end of the current
// line. If after the operation, the iter is at the end of the buffer and not
// dereferencable, returns false. Otherwise, returns true.
func (i *TextIter) ForwardLine(i *TextIter) bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_forward_line(arg0)

	if cret {
		ok = true
	}

	return ok
}

// ForwardLines moves @count lines forward, if possible (if @count would move
// past the start or end of the buffer, moves to the start or end of the
// buffer). The return value indicates whether the iterator moved onto a
// dereferenceable position; if the iterator didn’t move, or moved onto the end
// iterator, then false is returned. If @count is 0, the function does nothing
// and returns false. If @count is negative, moves backward by 0 - @count lines.
func (i *TextIter) ForwardLines(i *TextIter, count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.gint(count)

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_forward_lines(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// ForwardSearch searches forward for @str. Any match is returned by setting
// @match_start to the first character of the match and @match_end to the first
// character after the match. The search will not continue past @limit. Note
// that a search is a linear or O(n) operation, so you may wish to use @limit to
// avoid locking up your UI on large buffers.
//
// @match_start will never be set to a TextIter located before @iter, even if
// there is a possible @match_end after or at @iter.
func (i *TextIter) ForwardSearch(i *TextIter, str string, flags TextSearchFlags, limit *TextIter) (matchStart *TextIter, matchEnd *TextIter, ok bool) {
	var arg0 *C.GtkTextIter
	var arg1 *C.gchar
	var arg2 C.GtkTextSearchFlags
	var arg5 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GtkTextSearchFlags)(flags)
	arg5 = (*C.GtkTextIter)(unsafe.Pointer(limit.Native()))

	var arg3 C.GtkTextIter
	var matchStart *TextIter
	var arg4 C.GtkTextIter
	var matchEnd *TextIter
	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_forward_search(arg0, arg1, arg2, &arg3, &arg4, arg5)

	matchStart = WrapTextIter(unsafe.Pointer(&arg3))
	matchEnd = WrapTextIter(unsafe.Pointer(&arg4))
	if cret {
		ok = true
	}

	return matchStart, matchEnd, ok
}

// ForwardSentenceEnd moves forward to the next sentence end. (If @iter is at
// the end of a sentence, moves to the next end of sentence.) Sentence
// boundaries are determined by Pango and should be correct for nearly any
// language (if not, the correct fix would be to the Pango text boundary
// algorithms).
func (i *TextIter) ForwardSentenceEnd(i *TextIter) bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_forward_sentence_end(arg0)

	if cret {
		ok = true
	}

	return ok
}

// ForwardSentenceEnds calls gtk_text_iter_forward_sentence_end() @count times
// (or until gtk_text_iter_forward_sentence_end() returns false). If @count is
// negative, moves backward instead of forward.
func (i *TextIter) ForwardSentenceEnds(i *TextIter, count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.gint(count)

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_forward_sentence_ends(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// ForwardToEnd moves @iter forward to the “end iterator,” which points one past
// the last valid character in the buffer. gtk_text_iter_get_char() called on
// the end iterator returns 0, which is convenient for writing loops.
func (i *TextIter) ForwardToEnd(i *TextIter) {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	C.gtk_text_iter_forward_to_end(arg0)
}

// ForwardToLineEnd moves the iterator to point to the paragraph delimiter
// characters, which will be either a newline, a carriage return, a carriage
// return/newline in sequence, or the Unicode paragraph separator character. If
// the iterator is already at the paragraph delimiter characters, moves to the
// paragraph delimiter characters for the next line. If @iter is on the last
// line in the buffer, which does not end in paragraph delimiters, moves to the
// end iterator (end of the last line), and returns false.
func (i *TextIter) ForwardToLineEnd(i *TextIter) bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_forward_to_line_end(arg0)

	if cret {
		ok = true
	}

	return ok
}

// ForwardToTagToggle moves forward to the next toggle (on or off) of the
// TextTag @tag, or to the next toggle of any tag if @tag is nil. If no matching
// tag toggles are found, returns false, otherwise true. Does not return toggles
// located at @iter, only toggles after @iter. Sets @iter to the location of the
// toggle, or to the end of the buffer if no toggle is found.
func (i *TextIter) ForwardToTagToggle(i *TextIter, tag TextTag) bool {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextTag

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_forward_to_tag_toggle(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// ForwardVisibleCursorPosition moves @iter forward to the next visible cursor
// position. See gtk_text_iter_forward_cursor_position() for details.
func (i *TextIter) ForwardVisibleCursorPosition(i *TextIter) bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_forward_visible_cursor_position(arg0)

	if cret {
		ok = true
	}

	return ok
}

// ForwardVisibleCursorPositions moves up to @count visible cursor positions.
// See gtk_text_iter_forward_cursor_position() for details.
func (i *TextIter) ForwardVisibleCursorPositions(i *TextIter, count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.gint(count)

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_forward_visible_cursor_positions(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// ForwardVisibleLine moves @iter to the start of the next visible line. Returns
// true if there was a next line to move to, and false if @iter was simply moved
// to the end of the buffer and is now not dereferenceable, or if @iter was
// already at the end of the buffer.
func (i *TextIter) ForwardVisibleLine(i *TextIter) bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_forward_visible_line(arg0)

	if cret {
		ok = true
	}

	return ok
}

// ForwardVisibleLines moves @count visible lines forward, if possible (if
// @count would move past the start or end of the buffer, moves to the start or
// end of the buffer). The return value indicates whether the iterator moved
// onto a dereferenceable position; if the iterator didn’t move, or moved onto
// the end iterator, then false is returned. If @count is 0, the function does
// nothing and returns false. If @count is negative, moves backward by 0 -
// @count lines.
func (i *TextIter) ForwardVisibleLines(i *TextIter, count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.gint(count)

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_forward_visible_lines(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// ForwardVisibleWordEnd moves forward to the next visible word end. (If @iter
// is currently on a word end, moves forward to the next one after that.) Word
// breaks are determined by Pango and should be correct for nearly any language
// (if not, the correct fix would be to the Pango word break algorithms).
func (i *TextIter) ForwardVisibleWordEnd(i *TextIter) bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_forward_visible_word_end(arg0)

	if cret {
		ok = true
	}

	return ok
}

// ForwardVisibleWordEnds calls gtk_text_iter_forward_visible_word_end() up to
// @count times.
func (i *TextIter) ForwardVisibleWordEnds(i *TextIter, count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.gint(count)

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_forward_visible_word_ends(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// ForwardWordEnd moves forward to the next word end. (If @iter is currently on
// a word end, moves forward to the next one after that.) Word breaks are
// determined by Pango and should be correct for nearly any language (if not,
// the correct fix would be to the Pango word break algorithms).
func (i *TextIter) ForwardWordEnd(i *TextIter) bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_forward_word_end(arg0)

	if cret {
		ok = true
	}

	return ok
}

// ForwardWordEnds calls gtk_text_iter_forward_word_end() up to @count times.
func (i *TextIter) ForwardWordEnds(i *TextIter, count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.gint(count)

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_forward_word_ends(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// Free: free an iterator allocated on the heap. This function is intended for
// use in language bindings, and is not especially useful for applications,
// because iterators can simply be allocated on the stack.
func (i *TextIter) Free(i *TextIter) {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	C.gtk_text_iter_free(arg0)
}

// Attributes computes the effect of any tags applied to this spot in the text.
// The @values parameter should be initialized to the default settings you wish
// to use if no tags are in effect. You’d typically obtain the defaults from
// gtk_text_view_get_default_attributes().
//
// gtk_text_iter_get_attributes() will modify @values, applying the effects of
// any tags present at @iter. If any tags affected @values, the function returns
// true.
func (i *TextIter) Attributes(i *TextIter) (values *TextAttributes, ok bool) {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var arg1 C.GtkTextAttributes
	var values *TextAttributes
	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_get_attributes(arg0, &arg1)

	values = WrapTextAttributes(unsafe.Pointer(&arg1))
	if cret {
		ok = true
	}

	return values, ok
}

// Buffer returns the TextBuffer this iterator is associated with.
func (i *TextIter) Buffer(i *TextIter) {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	C.gtk_text_iter_get_buffer(arg0)
}

// BytesInLine returns the number of bytes in the line containing @iter,
// including the paragraph delimiters.
func (i *TextIter) BytesInLine(i *TextIter) {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	C.gtk_text_iter_get_bytes_in_line(arg0)
}

// Char: the Unicode character at this iterator is returned. (Equivalent to
// operator* on a C++ iterator.) If the element at this iterator is a
// non-character element, such as an image embedded in the buffer, the Unicode
// “unknown” character 0xFFFC is returned. If invoked on the end iterator, zero
// is returned; zero is not a valid Unicode character. So you can write a loop
// which ends when gtk_text_iter_get_char() returns 0.
func (i *TextIter) Char(i *TextIter) {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	C.gtk_text_iter_get_char(arg0)
}

// CharsInLine returns the number of characters in the line containing @iter,
// including the paragraph delimiters.
func (i *TextIter) CharsInLine(i *TextIter) {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	C.gtk_text_iter_get_chars_in_line(arg0)
}

// ChildAnchor: if the location at @iter contains a child anchor, the anchor is
// returned (with no new reference count added). Otherwise, nil is returned.
func (i *TextIter) ChildAnchor(i *TextIter) {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	C.gtk_text_iter_get_child_anchor(arg0)
}

// Language: a convenience wrapper around gtk_text_iter_get_attributes(), which
// returns the language in effect at @iter. If no tags affecting language apply
// to @iter, the return value is identical to that of
// gtk_get_default_language().
func (i *TextIter) Language(i *TextIter) {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	C.gtk_text_iter_get_language(arg0)
}

// Line returns the line number containing the iterator. Lines in a TextBuffer
// are numbered beginning with 0 for the first line in the buffer.
func (i *TextIter) Line(i *TextIter) {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	C.gtk_text_iter_get_line(arg0)
}

// LineIndex returns the byte index of the iterator, counting from the start of
// a newline-terminated line. Remember that TextBuffer encodes text in UTF-8,
// and that characters can require a variable number of bytes to represent.
func (i *TextIter) LineIndex(i *TextIter) {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	C.gtk_text_iter_get_line_index(arg0)
}

// LineOffset returns the character offset of the iterator, counting from the
// start of a newline-terminated line. The first character on the line has
// offset 0.
func (i *TextIter) LineOffset(i *TextIter) {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	C.gtk_text_iter_get_line_offset(arg0)
}

// Marks returns a list of all TextMark at this location. Because marks are not
// iterable (they don’t take up any "space" in the buffer, they are just marks
// in between iterable locations), multiple marks can exist in the same place.
// The returned list is not in any meaningful order.
func (i *TextIter) Marks(i *TextIter) {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	C.gtk_text_iter_get_marks(arg0)
}

// Offset returns the character offset of an iterator. Each character in a
// TextBuffer has an offset, starting with 0 for the first character in the
// buffer. Use gtk_text_buffer_get_iter_at_offset() to convert an offset back
// into an iterator.
func (i *TextIter) Offset(i *TextIter) {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	C.gtk_text_iter_get_offset(arg0)
}

// Pixbuf: if the element at @iter is a pixbuf, the pixbuf is returned (with no
// new reference count added). Otherwise, nil is returned.
func (i *TextIter) Pixbuf(i *TextIter) {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	C.gtk_text_iter_get_pixbuf(arg0)
}

// Slice returns the text in the given range. A “slice” is an array of
// characters encoded in UTF-8 format, including the Unicode “unknown” character
// 0xFFFC for iterable non-character elements in the buffer, such as images.
// Because images are encoded in the slice, byte and character offsets in the
// returned array will correspond to byte offsets in the text buffer. Note that
// 0xFFFC can occur in normal text as well, so it is not a reliable indicator
// that a pixbuf or widget is in the buffer.
func (s *TextIter) Slice(s *TextIter, end *TextIter) {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_iter_get_slice(arg0, arg1)
}

// Tags returns a list of tags that apply to @iter, in ascending order of
// priority (highest-priority tags are last). The TextTag in the list don’t have
// a reference added, but you have to free the list itself.
func (i *TextIter) Tags(i *TextIter) {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	C.gtk_text_iter_get_tags(arg0)
}

// Text returns text in the given range. If the range contains non-text elements
// such as images, the character and byte offsets in the returned string will
// not correspond to character and byte offsets in the buffer. If you want
// offsets to correspond, see gtk_text_iter_get_slice().
func (s *TextIter) Text(s *TextIter, end *TextIter) {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_iter_get_text(arg0, arg1)
}

// ToggledTags returns a list of TextTag that are toggled on or off at this
// point. (If @toggled_on is true, the list contains tags that are toggled on.)
// If a tag is toggled on at @iter, then some non-empty range of characters
// following @iter has that tag applied to it. If a tag is toggled off, then
// some non-empty range following @iter does not have the tag applied to it.
func (i *TextIter) ToggledTags(i *TextIter, toggledOn bool) {
	var arg0 *C.GtkTextIter
	var arg1 C.gboolean

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	if toggledOn {
		arg1 = C.gboolean(1)
	}

	C.gtk_text_iter_get_toggled_tags(arg0, arg1)
}

// VisibleLineIndex returns the number of bytes from the start of the line to
// the given @iter, not counting bytes that are invisible due to tags with the
// “invisible” flag toggled on.
func (i *TextIter) VisibleLineIndex(i *TextIter) {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	C.gtk_text_iter_get_visible_line_index(arg0)
}

// VisibleLineOffset returns the offset in characters from the start of the line
// to the given @iter, not counting characters that are invisible due to tags
// with the “invisible” flag toggled on.
func (i *TextIter) VisibleLineOffset(i *TextIter) {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	C.gtk_text_iter_get_visible_line_offset(arg0)
}

// VisibleSlice: like gtk_text_iter_get_slice(), but invisible text is not
// included. Invisible text is usually invisible because a TextTag with the
// “invisible” attribute turned on has been applied to it.
func (s *TextIter) VisibleSlice(s *TextIter, end *TextIter) {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_iter_get_visible_slice(arg0, arg1)
}

// VisibleText: like gtk_text_iter_get_text(), but invisible text is not
// included. Invisible text is usually invisible because a TextTag with the
// “invisible” attribute turned on has been applied to it.
func (s *TextIter) VisibleText(s *TextIter, end *TextIter) {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_iter_get_visible_text(arg0, arg1)
}

// HasTag returns true if @iter points to a character that is part of a range
// tagged with @tag. See also gtk_text_iter_starts_tag() and
// gtk_text_iter_ends_tag().
func (i *TextIter) HasTag(i *TextIter, tag TextTag) bool {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextTag

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_has_tag(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// InRange checks whether @iter falls in the range [@start, @end). @start and
// @end must be in ascending order.
func (i *TextIter) InRange(i *TextIter, start *TextIter, end *TextIter) bool {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_in_range(arg0, arg1, arg2)

	if cret {
		ok = true
	}

	return ok
}

// InsideSentence determines whether @iter is inside a sentence (as opposed to
// in between two sentences, e.g. after a period and before the first letter of
// the next sentence). Sentence boundaries are determined by Pango and should be
// correct for nearly any language (if not, the correct fix would be to the
// Pango text boundary algorithms).
func (i *TextIter) InsideSentence(i *TextIter) bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_inside_sentence(arg0)

	if cret {
		ok = true
	}

	return ok
}

// InsideWord determines whether the character pointed by @iter is part of a
// natural-language word (as opposed to say inside some whitespace). Word breaks
// are determined by Pango and should be correct for nearly any language (if
// not, the correct fix would be to the Pango word break algorithms).
//
// Note that if gtk_text_iter_starts_word() returns true, then this function
// returns true too, since @iter points to the first character of the word.
func (i *TextIter) InsideWord(i *TextIter) bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_inside_word(arg0)

	if cret {
		ok = true
	}

	return ok
}

// IsCursorPosition: see gtk_text_iter_forward_cursor_position() or LogAttr or
// pango_break() for details on what a cursor position is.
func (i *TextIter) IsCursorPosition(i *TextIter) bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_is_cursor_position(arg0)

	if cret {
		ok = true
	}

	return ok
}

// IsEnd returns true if @iter is the end iterator, i.e. one past the last
// dereferenceable iterator in the buffer. gtk_text_iter_is_end() is the most
// efficient way to check whether an iterator is the end iterator.
func (i *TextIter) IsEnd(i *TextIter) bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_is_end(arg0)

	if cret {
		ok = true
	}

	return ok
}

// IsStart returns true if @iter is the first iterator in the buffer, that is if
// @iter has a character offset of 0.
func (i *TextIter) IsStart(i *TextIter) bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_is_start(arg0)

	if cret {
		ok = true
	}

	return ok
}

// Order swaps the value of @first and @second if @second comes before @first in
// the buffer. That is, ensures that @first and @second are in sequence. Most
// text buffer functions that take a range call this automatically on your
// behalf, so there’s no real reason to call it yourself in those cases. There
// are some exceptions, such as gtk_text_iter_in_range(), that expect a
// pre-sorted range.
func (f *TextIter) Order(f *TextIter, second *TextIter) {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(f.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(second.Native()))

	C.gtk_text_iter_order(arg0, arg1)
}

// SetLine moves iterator @iter to the start of the line @line_number. If
// @line_number is negative or larger than the number of lines in the buffer,
// moves @iter to the start of the last line in the buffer.
func (i *TextIter) SetLine(i *TextIter, lineNumber int) {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.gint(lineNumber)

	C.gtk_text_iter_set_line(arg0, arg1)
}

// SetLineIndex: same as gtk_text_iter_set_line_offset(), but works with a byte
// index. The given byte index must be at the start of a character, it can’t be
// in the middle of a UTF-8 encoded character.
func (i *TextIter) SetLineIndex(i *TextIter, byteOnLine int) {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.gint(byteOnLine)

	C.gtk_text_iter_set_line_index(arg0, arg1)
}

// SetLineOffset moves @iter within a line, to a new character (not byte)
// offset. The given character offset must be less than or equal to the number
// of characters in the line; if equal, @iter moves to the start of the next
// line. See gtk_text_iter_set_line_index() if you have a byte index rather than
// a character offset.
func (i *TextIter) SetLineOffset(i *TextIter, charOnLine int) {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.gint(charOnLine)

	C.gtk_text_iter_set_line_offset(arg0, arg1)
}

// SetOffset sets @iter to point to @char_offset. @char_offset counts from the
// start of the entire text buffer, starting with 0.
func (i *TextIter) SetOffset(i *TextIter, charOffset int) {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.gint(charOffset)

	C.gtk_text_iter_set_offset(arg0, arg1)
}

// SetVisibleLineIndex: like gtk_text_iter_set_line_index(), but the index is in
// visible bytes, i.e. text with a tag making it invisible is not counted in the
// index.
func (i *TextIter) SetVisibleLineIndex(i *TextIter, byteOnLine int) {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.gint(byteOnLine)

	C.gtk_text_iter_set_visible_line_index(arg0, arg1)
}

// SetVisibleLineOffset: like gtk_text_iter_set_line_offset(), but the offset is
// in visible characters, i.e. text with a tag making it invisible is not
// counted in the offset.
func (i *TextIter) SetVisibleLineOffset(i *TextIter, charOnLine int) {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.gint(charOnLine)

	C.gtk_text_iter_set_visible_line_offset(arg0, arg1)
}

// StartsLine returns true if @iter begins a paragraph, i.e. if
// gtk_text_iter_get_line_offset() would return 0. However this function is
// potentially more efficient than gtk_text_iter_get_line_offset() because it
// doesn’t have to compute the offset, it just has to see whether it’s 0.
func (i *TextIter) StartsLine(i *TextIter) bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_starts_line(arg0)

	if cret {
		ok = true
	}

	return ok
}

// StartsSentence determines whether @iter begins a sentence. Sentence
// boundaries are determined by Pango and should be correct for nearly any
// language (if not, the correct fix would be to the Pango text boundary
// algorithms).
func (i *TextIter) StartsSentence(i *TextIter) bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_starts_sentence(arg0)

	if cret {
		ok = true
	}

	return ok
}

// StartsTag returns true if @tag is toggled on at exactly this point. If @tag
// is nil, returns true if any tag is toggled on at this point.
//
// Note that if gtk_text_iter_starts_tag() returns true, it means that @iter is
// at the beginning of the tagged range, and that the character at @iter is
// inside the tagged range. In other words, unlike gtk_text_iter_ends_tag(), if
// gtk_text_iter_starts_tag() returns true, gtk_text_iter_has_tag() will also
// return true for the same parameters.
func (i *TextIter) StartsTag(i *TextIter, tag TextTag) bool {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextTag

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_starts_tag(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// StartsWord determines whether @iter begins a natural-language word. Word
// breaks are determined by Pango and should be correct for nearly any language
// (if not, the correct fix would be to the Pango word break algorithms).
func (i *TextIter) StartsWord(i *TextIter) bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_starts_word(arg0)

	if cret {
		ok = true
	}

	return ok
}

// TogglesTag: this is equivalent to (gtk_text_iter_starts_tag() ||
// gtk_text_iter_ends_tag()), i.e. it tells you whether a range with @tag
// applied to it begins or ends at @iter.
func (i *TextIter) TogglesTag(i *TextIter, tag TextTag) bool {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextTag

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_text_iter_toggles_tag(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}
