// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_label_get_type()), F: marshalLabel},
	})
}

// Label: the Label widget displays a small amount of text. As the name implies,
// most labels are used to label another widget such as a Button, a MenuItem, or
// a ComboBox.
//
// CSS nodes
//
//    const gchar *text =
//    "Go to the"
//    "<a href=\"http://www.gtk.org title=\"&lt;i&gt;Our&lt;/i&gt; website\">"
//    "GTK+ website</a> for more...";
//    GtkWidget *label = gtk_label_new (NULL);
//    gtk_label_set_markup (GTK_LABEL (label), text);
//
// It is possible to implement custom handling for links and their tooltips with
// the Label::activate-link signal and the gtk_label_get_current_uri() function.
type Label interface {
	Misc
	Buildable

	// Angle gets the angle of rotation for the label. See
	// gtk_label_set_angle().
	Angle(l Label)
	// Attributes gets the attribute list that was set on the label using
	// gtk_label_set_attributes(), if any. This function does not reflect
	// attributes that come from the labels markup (see gtk_label_set_markup()).
	// If you want to get the effective attributes for the label, use
	// pango_layout_get_attribute (gtk_label_get_layout (label)).
	Attributes(l Label)
	// CurrentURI returns the URI for the currently active link in the label.
	// The active link is the one under the mouse pointer or, in a selectable
	// label, the link in which the text cursor is currently positioned.
	//
	// This function is intended for use in a Label::activate-link handler or
	// for use in a Widget::query-tooltip handler.
	CurrentURI(l Label)
	// Ellipsize returns the ellipsizing position of the label. See
	// gtk_label_set_ellipsize().
	Ellipsize(l Label)
	// Justify returns the justification of the label. See
	// gtk_label_set_justify().
	Justify(l Label)
	// Label fetches the text from a label widget including any embedded
	// underlines indicating mnemonics and Pango markup. (See
	// gtk_label_get_text()).
	Label(l Label)
	// Layout gets the Layout used to display the label. The layout is useful to
	// e.g. convert text positions to pixel positions, in combination with
	// gtk_label_get_layout_offsets(). The returned layout is owned by the
	// @label so need not be freed by the caller. The @label is free to recreate
	// its layout at any time, so it should be considered read-only.
	Layout(l Label)
	// LayoutOffsets obtains the coordinates where the label will draw the
	// Layout representing the text in the label; useful to convert mouse events
	// into coordinates inside the Layout, e.g. to take some action if some part
	// of the label is clicked. Of course you will need to create a EventBox to
	// receive the events, and pack the label inside it, since labels are
	// windowless (they return false from gtk_widget_get_has_window()). Remember
	// when using the Layout functions you need to convert to and from pixels
	// using PANGO_PIXELS() or NGO_SCALE.
	LayoutOffsets(l Label) (x int, y int)
	// LineWrap returns whether lines in the label are automatically wrapped.
	// See gtk_label_set_line_wrap().
	LineWrap(l Label) bool
	// LineWrapMode returns line wrap mode used by the label. See
	// gtk_label_set_line_wrap_mode().
	LineWrapMode(l Label)
	// Lines gets the number of lines to which an ellipsized, wrapping label
	// should be limited. See gtk_label_set_lines().
	Lines(l Label)
	// MaxWidthChars retrieves the desired maximum width of @label, in
	// characters. See gtk_label_set_width_chars().
	MaxWidthChars(l Label)
	// MnemonicKeyval: if the label has been set so that it has an mnemonic key
	// this function returns the keyval used for the mnemonic accelerator. If
	// there is no mnemonic set up it returns K_KEY_VoidSymbol.
	MnemonicKeyval(l Label)
	// MnemonicWidget retrieves the target of the mnemonic (keyboard shortcut)
	// of this label. See gtk_label_set_mnemonic_widget().
	MnemonicWidget(l Label)
	// Selectable gets the value set by gtk_label_set_selectable().
	Selectable(l Label) bool
	// SelectionBounds gets the selected range of characters in the label,
	// returning true if there’s a selection.
	SelectionBounds(l Label) (start int, end int, ok bool)
	// SingleLineMode returns whether the label is in single line mode.
	SingleLineMode(l Label) bool
	// Text fetches the text from a label widget, as displayed on the screen.
	// This does not include any embedded underlines indicating mnemonics or
	// Pango markup. (See gtk_label_get_label())
	Text(l Label)
	// TrackVisitedLinks returns whether the label is currently keeping track of
	// clicked links.
	TrackVisitedLinks(l Label) bool
	// UseMarkup returns whether the label’s text is interpreted as marked up
	// with the [Pango text markup language][PangoMarkupFormat]. See
	// gtk_label_set_use_markup ().
	UseMarkup(l Label) bool
	// UseUnderline returns whether an embedded underline in the label indicates
	// a mnemonic. See gtk_label_set_use_underline().
	UseUnderline(l Label) bool
	// WidthChars retrieves the desired width of @label, in characters. See
	// gtk_label_set_width_chars().
	WidthChars(l Label)
	// Xalign gets the Label:xalign property for @label.
	Xalign(l Label)
	// Yalign gets the Label:yalign property for @label.
	Yalign(l Label)
	// SelectRegion selects a range of characters in the label, if the label is
	// selectable. See gtk_label_set_selectable(). If the label is not
	// selectable, this function has no effect. If @start_offset or @end_offset
	// are -1, then the end of the label will be substituted.
	SelectRegion(l Label, startOffset int, endOffset int)
	// SetAngle sets the angle of rotation for the label. An angle of 90 reads
	// from from bottom to top, an angle of 270, from top to bottom. The angle
	// setting for the label is ignored if the label is selectable, wrapped, or
	// ellipsized.
	SetAngle(l Label, angle float64)
	// SetAttributes sets a AttrList; the attributes in the list are applied to
	// the label text.
	//
	// The attributes set with this function will be applied and merged with any
	// other attributes previously effected by way of the Label:use-underline or
	// Label:use-markup properties. While it is not recommended to mix markup
	// strings with manually set attributes, if you must; know that the
	// attributes will be applied to the label after the markup string is
	// parsed.
	SetAttributes(l Label, attrs *pango.AttrList)
	// SetEllipsize sets the mode used to ellipsize (add an ellipsis: "...") to
	// the text if there is not enough space to render the entire string.
	SetEllipsize(l Label, mode pango.EllipsizeMode)
	// SetJustify sets the alignment of the lines in the text of the label
	// relative to each other. GTK_JUSTIFY_LEFT is the default value when the
	// widget is first created with gtk_label_new(). If you instead want to set
	// the alignment of the label as a whole, use gtk_widget_set_halign()
	// instead. gtk_label_set_justify() has no effect on labels containing only
	// a single line.
	SetJustify(l Label, jtype Justification)
	// SetLabel sets the text of the label. The label is interpreted as
	// including embedded underlines and/or Pango markup depending on the values
	// of the Label:use-underline and Label:use-markup properties.
	SetLabel(l Label, str string)
	// SetLineWrap toggles line wrapping within the Label widget. true makes it
	// break lines if text exceeds the widget’s size. false lets the text get
	// cut off by the edge of the widget if it exceeds the widget size.
	//
	// Note that setting line wrapping to true does not make the label wrap at
	// its parent container’s width, because GTK+ widgets conceptually can’t
	// make their requisition depend on the parent container’s size. For a label
	// that wraps at a specific position, set the label’s width using
	// gtk_widget_set_size_request().
	SetLineWrap(l Label, wrap bool)
	// SetLineWrapMode: if line wrapping is on (see gtk_label_set_line_wrap())
	// this controls how the line wrapping is done. The default is
	// PANGO_WRAP_WORD which means wrap on word boundaries.
	SetLineWrapMode(l Label, wrapMode pango.WrapMode)
	// SetLines sets the number of lines to which an ellipsized, wrapping label
	// should be limited. This has no effect if the label is not wrapping or
	// ellipsized. Set this to -1 if you don’t want to limit the number of
	// lines.
	SetLines(l Label, lines int)
	// SetMarkup parses @str which is marked up with the [Pango text markup
	// language][PangoMarkupFormat], setting the label’s text and attribute list
	// based on the parse results.
	//
	// If the @str is external data, you may need to escape it with
	// g_markup_escape_text() or g_markup_printf_escaped():
	//
	//    GtkWidget *label = gtk_label_new (NULL);
	//    const char *str = "some text";
	//    const char *format = "<span style=\"italic\">\s</span>";
	//    char *markup;
	//
	//    markup = g_markup_printf_escaped (format, str);
	//    gtk_label_set_markup (GTK_LABEL (label), markup);
	//    g_free (markup);
	//
	// This function will set the Label:use-markup property to true as a side
	// effect.
	//
	// If you set the label contents using the Label:label property you should
	// also ensure that you set the Label:use-markup property accordingly.
	//
	// See also: gtk_label_set_text()
	SetMarkup(l Label, str string)
	// SetMarkupWithMnemonic parses @str which is marked up with the [Pango text
	// markup language][PangoMarkupFormat], setting the label’s text and
	// attribute list based on the parse results. If characters in @str are
	// preceded by an underscore, they are underlined indicating that they
	// represent a keyboard accelerator called a mnemonic.
	//
	// The mnemonic key can be used to activate another widget, chosen
	// automatically, or explicitly using gtk_label_set_mnemonic_widget().
	SetMarkupWithMnemonic(l Label, str string)
	// SetMaxWidthChars sets the desired maximum width in characters of @label
	// to @n_chars.
	SetMaxWidthChars(l Label, nChars int)
	// SetMnemonicWidget: if the label has been set so that it has an mnemonic
	// key (using i.e. gtk_label_set_markup_with_mnemonic(),
	// gtk_label_set_text_with_mnemonic(), gtk_label_new_with_mnemonic() or the
	// “use_underline” property) the label can be associated with a widget that
	// is the target of the mnemonic. When the label is inside a widget (like a
	// Button or a Notebook tab) it is automatically associated with the correct
	// widget, but sometimes (i.e. when the target is a Entry next to the label)
	// you need to set it explicitly using this function.
	//
	// The target widget will be accelerated by emitting the
	// GtkWidget::mnemonic-activate signal on it. The default handler for this
	// signal will activate the widget if there are no mnemonic collisions and
	// toggle focus between the colliding widgets otherwise.
	SetMnemonicWidget(l Label, widget Widget)
	// SetPattern: the pattern of underlines you want under the existing text
	// within the Label widget. For example if the current text of the label
	// says “FooBarBaz” passing a pattern of “___ ___” will underline “Foo” and
	// “Baz” but not “Bar”.
	SetPattern(l Label, pattern string)
	// SetSelectable: selectable labels allow the user to select text from the
	// label, for copy-and-paste.
	SetSelectable(l Label, setting bool)
	// SetSingleLineMode sets whether the label is in single line mode.
	SetSingleLineMode(l Label, singleLineMode bool)
	// SetText sets the text within the Label widget. It overwrites any text
	// that was there before.
	//
	// This function will clear any previously set mnemonic accelerators, and
	// set the Label:use-underline property to false as a side effect.
	//
	// This function will set the Label:use-markup property to false as a side
	// effect.
	//
	// See also: gtk_label_set_markup()
	SetText(l Label, str string)
	// SetTextWithMnemonic sets the label’s text from the string @str. If
	// characters in @str are preceded by an underscore, they are underlined
	// indicating that they represent a keyboard accelerator called a mnemonic.
	// The mnemonic key can be used to activate another widget, chosen
	// automatically, or explicitly using gtk_label_set_mnemonic_widget().
	SetTextWithMnemonic(l Label, str string)
	// SetTrackVisitedLinks sets whether the label should keep track of clicked
	// links (and use a different color for them).
	SetTrackVisitedLinks(l Label, trackLinks bool)
	// SetUseMarkup sets whether the text of the label contains markup in
	// [Pango’s text markup language][PangoMarkupFormat]. See
	// gtk_label_set_markup().
	SetUseMarkup(l Label, setting bool)
	// SetUseUnderline: if true, an underline in the text indicates the next
	// character should be used for the mnemonic accelerator key.
	SetUseUnderline(l Label, setting bool)
	// SetWidthChars sets the desired width in characters of @label to @n_chars.
	SetWidthChars(l Label, nChars int)
	// SetXalign sets the Label:xalign property for @label.
	SetXalign(l Label, xalign float32)
	// SetYalign sets the Label:yalign property for @label.
	SetYalign(l Label, yalign float32)
}

// label implements the Label interface.
type label struct {
	Misc
	Buildable
}

var _ Label = (*label)(nil)

// WrapLabel wraps a GObject to the right type. It is
// primarily used internally.
func WrapLabel(obj *externglib.Object) Label {
	return Label{
		Misc:      WrapMisc(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalLabel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLabel(obj), nil
}

// NewLabel constructs a class Label.
func NewLabel(str string) {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_label_new(arg1)
}

// NewLabelWithMnemonic constructs a class Label.
func NewLabelWithMnemonic(str string) {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_label_new_with_mnemonic(arg1)
}

// Angle gets the angle of rotation for the label. See
// gtk_label_set_angle().
func (l label) Angle(l Label) {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	C.gtk_label_get_angle(arg0)
}

// Attributes gets the attribute list that was set on the label using
// gtk_label_set_attributes(), if any. This function does not reflect
// attributes that come from the labels markup (see gtk_label_set_markup()).
// If you want to get the effective attributes for the label, use
// pango_layout_get_attribute (gtk_label_get_layout (label)).
func (l label) Attributes(l Label) {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	C.gtk_label_get_attributes(arg0)
}

// CurrentURI returns the URI for the currently active link in the label.
// The active link is the one under the mouse pointer or, in a selectable
// label, the link in which the text cursor is currently positioned.
//
// This function is intended for use in a Label::activate-link handler or
// for use in a Widget::query-tooltip handler.
func (l label) CurrentURI(l Label) {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	C.gtk_label_get_current_uri(arg0)
}

// Ellipsize returns the ellipsizing position of the label. See
// gtk_label_set_ellipsize().
func (l label) Ellipsize(l Label) {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	C.gtk_label_get_ellipsize(arg0)
}

// Justify returns the justification of the label. See
// gtk_label_set_justify().
func (l label) Justify(l Label) {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	C.gtk_label_get_justify(arg0)
}

// Label fetches the text from a label widget including any embedded
// underlines indicating mnemonics and Pango markup. (See
// gtk_label_get_text()).
func (l label) Label(l Label) {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	C.gtk_label_get_label(arg0)
}

// Layout gets the Layout used to display the label. The layout is useful to
// e.g. convert text positions to pixel positions, in combination with
// gtk_label_get_layout_offsets(). The returned layout is owned by the
// @label so need not be freed by the caller. The @label is free to recreate
// its layout at any time, so it should be considered read-only.
func (l label) Layout(l Label) {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	C.gtk_label_get_layout(arg0)
}

// LayoutOffsets obtains the coordinates where the label will draw the
// Layout representing the text in the label; useful to convert mouse events
// into coordinates inside the Layout, e.g. to take some action if some part
// of the label is clicked. Of course you will need to create a EventBox to
// receive the events, and pack the label inside it, since labels are
// windowless (they return false from gtk_widget_get_has_window()). Remember
// when using the Layout functions you need to convert to and from pixels
// using PANGO_PIXELS() or NGO_SCALE.
func (l label) LayoutOffsets(l Label) (x int, y int) {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	var arg1 C.gint
	var x int
	var arg2 C.gint
	var y int

	C.gtk_label_get_layout_offsets(arg0, &arg1, &arg2)

	x = int(&arg1)
	y = int(&arg2)

	return x, y
}

// LineWrap returns whether lines in the label are automatically wrapped.
// See gtk_label_set_line_wrap().
func (l label) LineWrap(l Label) bool {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_label_get_line_wrap(arg0)

	if cret {
		ok = true
	}

	return ok
}

// LineWrapMode returns line wrap mode used by the label. See
// gtk_label_set_line_wrap_mode().
func (l label) LineWrapMode(l Label) {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	C.gtk_label_get_line_wrap_mode(arg0)
}

// Lines gets the number of lines to which an ellipsized, wrapping label
// should be limited. See gtk_label_set_lines().
func (l label) Lines(l Label) {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	C.gtk_label_get_lines(arg0)
}

// MaxWidthChars retrieves the desired maximum width of @label, in
// characters. See gtk_label_set_width_chars().
func (l label) MaxWidthChars(l Label) {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	C.gtk_label_get_max_width_chars(arg0)
}

// MnemonicKeyval: if the label has been set so that it has an mnemonic key
// this function returns the keyval used for the mnemonic accelerator. If
// there is no mnemonic set up it returns K_KEY_VoidSymbol.
func (l label) MnemonicKeyval(l Label) {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	C.gtk_label_get_mnemonic_keyval(arg0)
}

// MnemonicWidget retrieves the target of the mnemonic (keyboard shortcut)
// of this label. See gtk_label_set_mnemonic_widget().
func (l label) MnemonicWidget(l Label) {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	C.gtk_label_get_mnemonic_widget(arg0)
}

// Selectable gets the value set by gtk_label_set_selectable().
func (l label) Selectable(l Label) bool {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_label_get_selectable(arg0)

	if cret {
		ok = true
	}

	return ok
}

// SelectionBounds gets the selected range of characters in the label,
// returning true if there’s a selection.
func (l label) SelectionBounds(l Label) (start int, end int, ok bool) {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	var arg1 C.gint
	var start int
	var arg2 C.gint
	var end int
	var cret C.gboolean
	var ok bool

	cret = C.gtk_label_get_selection_bounds(arg0, &arg1, &arg2)

	start = int(&arg1)
	end = int(&arg2)
	if cret {
		ok = true
	}

	return start, end, ok
}

// SingleLineMode returns whether the label is in single line mode.
func (l label) SingleLineMode(l Label) bool {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_label_get_single_line_mode(arg0)

	if cret {
		ok = true
	}

	return ok
}

// Text fetches the text from a label widget, as displayed on the screen.
// This does not include any embedded underlines indicating mnemonics or
// Pango markup. (See gtk_label_get_label())
func (l label) Text(l Label) {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	C.gtk_label_get_text(arg0)
}

// TrackVisitedLinks returns whether the label is currently keeping track of
// clicked links.
func (l label) TrackVisitedLinks(l Label) bool {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_label_get_track_visited_links(arg0)

	if cret {
		ok = true
	}

	return ok
}

// UseMarkup returns whether the label’s text is interpreted as marked up
// with the [Pango text markup language][PangoMarkupFormat]. See
// gtk_label_set_use_markup ().
func (l label) UseMarkup(l Label) bool {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_label_get_use_markup(arg0)

	if cret {
		ok = true
	}

	return ok
}

// UseUnderline returns whether an embedded underline in the label indicates
// a mnemonic. See gtk_label_set_use_underline().
func (l label) UseUnderline(l Label) bool {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_label_get_use_underline(arg0)

	if cret {
		ok = true
	}

	return ok
}

// WidthChars retrieves the desired width of @label, in characters. See
// gtk_label_set_width_chars().
func (l label) WidthChars(l Label) {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	C.gtk_label_get_width_chars(arg0)
}

// Xalign gets the Label:xalign property for @label.
func (l label) Xalign(l Label) {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	C.gtk_label_get_xalign(arg0)
}

// Yalign gets the Label:yalign property for @label.
func (l label) Yalign(l Label) {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	C.gtk_label_get_yalign(arg0)
}

// SelectRegion selects a range of characters in the label, if the label is
// selectable. See gtk_label_set_selectable(). If the label is not
// selectable, this function has no effect. If @start_offset or @end_offset
// are -1, then the end of the label will be substituted.
func (l label) SelectRegion(l Label, startOffset int, endOffset int) {
	var arg0 *C.GtkLabel
	var arg1 C.gint
	var arg2 C.gint

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	arg1 = C.gint(startOffset)
	arg2 = C.gint(endOffset)

	C.gtk_label_select_region(arg0, arg1, arg2)
}

// SetAngle sets the angle of rotation for the label. An angle of 90 reads
// from from bottom to top, an angle of 270, from top to bottom. The angle
// setting for the label is ignored if the label is selectable, wrapped, or
// ellipsized.
func (l label) SetAngle(l Label, angle float64) {
	var arg0 *C.GtkLabel
	var arg1 C.gdouble

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	arg1 = C.gdouble(angle)

	C.gtk_label_set_angle(arg0, arg1)
}

// SetAttributes sets a AttrList; the attributes in the list are applied to
// the label text.
//
// The attributes set with this function will be applied and merged with any
// other attributes previously effected by way of the Label:use-underline or
// Label:use-markup properties. While it is not recommended to mix markup
// strings with manually set attributes, if you must; know that the
// attributes will be applied to the label after the markup string is
// parsed.
func (l label) SetAttributes(l Label, attrs *pango.AttrList) {
	var arg0 *C.GtkLabel
	var arg1 *C.PangoAttrList

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	arg1 = (*C.PangoAttrList)(unsafe.Pointer(attrs.Native()))

	C.gtk_label_set_attributes(arg0, arg1)
}

// SetEllipsize sets the mode used to ellipsize (add an ellipsis: "...") to
// the text if there is not enough space to render the entire string.
func (l label) SetEllipsize(l Label, mode pango.EllipsizeMode) {
	var arg0 *C.GtkLabel
	var arg1 C.PangoEllipsizeMode

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	arg1 = (C.PangoEllipsizeMode)(mode)

	C.gtk_label_set_ellipsize(arg0, arg1)
}

// SetJustify sets the alignment of the lines in the text of the label
// relative to each other. GTK_JUSTIFY_LEFT is the default value when the
// widget is first created with gtk_label_new(). If you instead want to set
// the alignment of the label as a whole, use gtk_widget_set_halign()
// instead. gtk_label_set_justify() has no effect on labels containing only
// a single line.
func (l label) SetJustify(l Label, jtype Justification) {
	var arg0 *C.GtkLabel
	var arg1 C.GtkJustification

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	arg1 = (C.GtkJustification)(jtype)

	C.gtk_label_set_justify(arg0, arg1)
}

// SetLabel sets the text of the label. The label is interpreted as
// including embedded underlines and/or Pango markup depending on the values
// of the Label:use-underline and Label:use-markup properties.
func (l label) SetLabel(l Label, str string) {
	var arg0 *C.GtkLabel
	var arg1 *C.gchar

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_label_set_label(arg0, arg1)
}

// SetLineWrap toggles line wrapping within the Label widget. true makes it
// break lines if text exceeds the widget’s size. false lets the text get
// cut off by the edge of the widget if it exceeds the widget size.
//
// Note that setting line wrapping to true does not make the label wrap at
// its parent container’s width, because GTK+ widgets conceptually can’t
// make their requisition depend on the parent container’s size. For a label
// that wraps at a specific position, set the label’s width using
// gtk_widget_set_size_request().
func (l label) SetLineWrap(l Label, wrap bool) {
	var arg0 *C.GtkLabel
	var arg1 C.gboolean

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	if wrap {
		arg1 = C.gboolean(1)
	}

	C.gtk_label_set_line_wrap(arg0, arg1)
}

// SetLineWrapMode: if line wrapping is on (see gtk_label_set_line_wrap())
// this controls how the line wrapping is done. The default is
// PANGO_WRAP_WORD which means wrap on word boundaries.
func (l label) SetLineWrapMode(l Label, wrapMode pango.WrapMode) {
	var arg0 *C.GtkLabel
	var arg1 C.PangoWrapMode

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	arg1 = (C.PangoWrapMode)(wrapMode)

	C.gtk_label_set_line_wrap_mode(arg0, arg1)
}

// SetLines sets the number of lines to which an ellipsized, wrapping label
// should be limited. This has no effect if the label is not wrapping or
// ellipsized. Set this to -1 if you don’t want to limit the number of
// lines.
func (l label) SetLines(l Label, lines int) {
	var arg0 *C.GtkLabel
	var arg1 C.gint

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	arg1 = C.gint(lines)

	C.gtk_label_set_lines(arg0, arg1)
}

// SetMarkup parses @str which is marked up with the [Pango text markup
// language][PangoMarkupFormat], setting the label’s text and attribute list
// based on the parse results.
//
// If the @str is external data, you may need to escape it with
// g_markup_escape_text() or g_markup_printf_escaped():
//
//    GtkWidget *label = gtk_label_new (NULL);
//    const char *str = "some text";
//    const char *format = "<span style=\"italic\">\s</span>";
//    char *markup;
//
//    markup = g_markup_printf_escaped (format, str);
//    gtk_label_set_markup (GTK_LABEL (label), markup);
//    g_free (markup);
//
// This function will set the Label:use-markup property to true as a side
// effect.
//
// If you set the label contents using the Label:label property you should
// also ensure that you set the Label:use-markup property accordingly.
//
// See also: gtk_label_set_text()
func (l label) SetMarkup(l Label, str string) {
	var arg0 *C.GtkLabel
	var arg1 *C.gchar

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_label_set_markup(arg0, arg1)
}

// SetMarkupWithMnemonic parses @str which is marked up with the [Pango text
// markup language][PangoMarkupFormat], setting the label’s text and
// attribute list based on the parse results. If characters in @str are
// preceded by an underscore, they are underlined indicating that they
// represent a keyboard accelerator called a mnemonic.
//
// The mnemonic key can be used to activate another widget, chosen
// automatically, or explicitly using gtk_label_set_mnemonic_widget().
func (l label) SetMarkupWithMnemonic(l Label, str string) {
	var arg0 *C.GtkLabel
	var arg1 *C.gchar

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_label_set_markup_with_mnemonic(arg0, arg1)
}

// SetMaxWidthChars sets the desired maximum width in characters of @label
// to @n_chars.
func (l label) SetMaxWidthChars(l Label, nChars int) {
	var arg0 *C.GtkLabel
	var arg1 C.gint

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	arg1 = C.gint(nChars)

	C.gtk_label_set_max_width_chars(arg0, arg1)
}

// SetMnemonicWidget: if the label has been set so that it has an mnemonic
// key (using i.e. gtk_label_set_markup_with_mnemonic(),
// gtk_label_set_text_with_mnemonic(), gtk_label_new_with_mnemonic() or the
// “use_underline” property) the label can be associated with a widget that
// is the target of the mnemonic. When the label is inside a widget (like a
// Button or a Notebook tab) it is automatically associated with the correct
// widget, but sometimes (i.e. when the target is a Entry next to the label)
// you need to set it explicitly using this function.
//
// The target widget will be accelerated by emitting the
// GtkWidget::mnemonic-activate signal on it. The default handler for this
// signal will activate the widget if there are no mnemonic collisions and
// toggle focus between the colliding widgets otherwise.
func (l label) SetMnemonicWidget(l Label, widget Widget) {
	var arg0 *C.GtkLabel
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_label_set_mnemonic_widget(arg0, arg1)
}

// SetPattern: the pattern of underlines you want under the existing text
// within the Label widget. For example if the current text of the label
// says “FooBarBaz” passing a pattern of “___ ___” will underline “Foo” and
// “Baz” but not “Bar”.
func (l label) SetPattern(l Label, pattern string) {
	var arg0 *C.GtkLabel
	var arg1 *C.gchar

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	arg1 = (*C.gchar)(C.CString(pattern))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_label_set_pattern(arg0, arg1)
}

// SetSelectable: selectable labels allow the user to select text from the
// label, for copy-and-paste.
func (l label) SetSelectable(l Label, setting bool) {
	var arg0 *C.GtkLabel
	var arg1 C.gboolean

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_label_set_selectable(arg0, arg1)
}

// SetSingleLineMode sets whether the label is in single line mode.
func (l label) SetSingleLineMode(l Label, singleLineMode bool) {
	var arg0 *C.GtkLabel
	var arg1 C.gboolean

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	if singleLineMode {
		arg1 = C.gboolean(1)
	}

	C.gtk_label_set_single_line_mode(arg0, arg1)
}

// SetText sets the text within the Label widget. It overwrites any text
// that was there before.
//
// This function will clear any previously set mnemonic accelerators, and
// set the Label:use-underline property to false as a side effect.
//
// This function will set the Label:use-markup property to false as a side
// effect.
//
// See also: gtk_label_set_markup()
func (l label) SetText(l Label, str string) {
	var arg0 *C.GtkLabel
	var arg1 *C.gchar

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_label_set_text(arg0, arg1)
}

// SetTextWithMnemonic sets the label’s text from the string @str. If
// characters in @str are preceded by an underscore, they are underlined
// indicating that they represent a keyboard accelerator called a mnemonic.
// The mnemonic key can be used to activate another widget, chosen
// automatically, or explicitly using gtk_label_set_mnemonic_widget().
func (l label) SetTextWithMnemonic(l Label, str string) {
	var arg0 *C.GtkLabel
	var arg1 *C.gchar

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_label_set_text_with_mnemonic(arg0, arg1)
}

// SetTrackVisitedLinks sets whether the label should keep track of clicked
// links (and use a different color for them).
func (l label) SetTrackVisitedLinks(l Label, trackLinks bool) {
	var arg0 *C.GtkLabel
	var arg1 C.gboolean

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	if trackLinks {
		arg1 = C.gboolean(1)
	}

	C.gtk_label_set_track_visited_links(arg0, arg1)
}

// SetUseMarkup sets whether the text of the label contains markup in
// [Pango’s text markup language][PangoMarkupFormat]. See
// gtk_label_set_markup().
func (l label) SetUseMarkup(l Label, setting bool) {
	var arg0 *C.GtkLabel
	var arg1 C.gboolean

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_label_set_use_markup(arg0, arg1)
}

// SetUseUnderline: if true, an underline in the text indicates the next
// character should be used for the mnemonic accelerator key.
func (l label) SetUseUnderline(l Label, setting bool) {
	var arg0 *C.GtkLabel
	var arg1 C.gboolean

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_label_set_use_underline(arg0, arg1)
}

// SetWidthChars sets the desired width in characters of @label to @n_chars.
func (l label) SetWidthChars(l Label, nChars int) {
	var arg0 *C.GtkLabel
	var arg1 C.gint

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	arg1 = C.gint(nChars)

	C.gtk_label_set_width_chars(arg0, arg1)
}

// SetXalign sets the Label:xalign property for @label.
func (l label) SetXalign(l Label, xalign float32) {
	var arg0 *C.GtkLabel
	var arg1 C.gfloat

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	arg1 = C.gfloat(xalign)

	C.gtk_label_set_xalign(arg0, arg1)
}

// SetYalign sets the Label:yalign property for @label.
func (l label) SetYalign(l Label, yalign float32) {
	var arg0 *C.GtkLabel
	var arg1 C.gfloat

	arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	arg1 = C.gfloat(yalign)

	C.gtk_label_set_yalign(arg0, arg1)
}

type LabelSelectionInfo struct {
	native C.GtkLabelSelectionInfo
}

// WrapLabelSelectionInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapLabelSelectionInfo(ptr unsafe.Pointer) *LabelSelectionInfo {
	if ptr == nil {
		return nil
	}

	return (*LabelSelectionInfo)(ptr)
}

func marshalLabelSelectionInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapLabelSelectionInfo(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (l *LabelSelectionInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&l.native)
}
