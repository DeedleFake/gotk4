// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/gdk"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf"
	"github.com/diamondburned/gotk4/pkg/gio"
	"github.com/diamondburned/gotk4/pkg/glib"
	"github.com/diamondburned/gotk4/pkg/gobject"
	"github.com/diamondburned/gotk4/pkg/pango"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk+-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
//
// extern gint gotk4_AssistantPageFunc(gint _0, gpointer _1);
// extern void gotk4_BuilderConnectFunc(GtkBuilder* _0, GObject* _1, const gchar* _2, const gchar* _3, GObject* _4, GConnectFlags _5, gpointer _6);
// extern gchar* gotk4_CalendarDetailFunc(GtkCalendar* _0, guint _1, guint _2, guint _3, gpointer _4);
// extern void gotk4_Callback(GtkWidget* _0, gpointer _1);
// extern gboolean gotk4_CellAllocCallback(GtkCellRenderer* _0, const GdkRectangle* _1, const GdkRectangle* _2, gpointer _3);
// extern gboolean gotk4_CellCallback(GtkCellRenderer* _0, gpointer _1);
// extern void gotk4_CellLayoutDataFunc(GtkCellLayout* _0, GtkCellRenderer* _1, GtkTreeModel* _2, GtkTreeIter* _3, gpointer _4);
// extern void gotk4_ClipboardImageReceivedFunc(GtkClipboard* _0, GdkPixbuf* _1, gpointer _2);
// extern void gotk4_ClipboardReceivedFunc(GtkClipboard* _0, GtkSelectionData* _1, gpointer _2);
// extern void gotk4_ClipboardRichTextReceivedFunc(GtkClipboard* _0, GdkAtom _1, const guint8* _2, gsize _3, gpointer _4);
// extern void gotk4_ClipboardTargetsReceivedFunc(GtkClipboard* _0, GdkAtom* _1, gint _2, gpointer _3);
// extern void gotk4_ClipboardTextReceivedFunc(GtkClipboard* _0, const gchar* _1, gpointer _2);
// extern void gotk4_ClipboardURIReceivedFunc(GtkClipboard* _0, gchar** _1, gpointer _2);
// extern gboolean gotk4_EntryCompletionMatchFunc(GtkEntryCompletion* _0, const gchar* _1, GtkTreeIter* _2, gpointer _3);
// extern gboolean gotk4_FileFilterFunc(const GtkFileFilterInfo* _0, gpointer _1);
// extern GtkWidget* gotk4_FlowBoxCreateWidgetFunc(gpointer _0, gpointer _1);
// extern gboolean gotk4_FlowBoxFilterFunc(GtkFlowBoxChild* _0, gpointer _1);
// extern void gotk4_FlowBoxForeachFunc(GtkFlowBox* _0, GtkFlowBoxChild* _1, gpointer _2);
// extern gint gotk4_FlowBoxSortFunc(GtkFlowBoxChild* _0, GtkFlowBoxChild* _1, gpointer _2);
// extern gboolean gotk4_FontFilterFunc(const PangoFontFamily* _0, const PangoFontFace* _1, gpointer _2);
// extern void gotk4_IconViewForeachFunc(GtkIconView* _0, GtkTreePath* _1, gpointer _2);
// extern gint gotk4_KeySnoopFunc(GtkWidget* _0, GdkEventKey* _1, gpointer _2);
// extern GtkWidget* gotk4_ListBoxCreateWidgetFunc(gpointer _0, gpointer _1);
// extern gboolean gotk4_ListBoxFilterFunc(GtkListBoxRow* _0, gpointer _1);
// extern void gotk4_ListBoxForeachFunc(GtkListBox* _0, GtkListBoxRow* _1, gpointer _2);
// extern gint gotk4_ListBoxSortFunc(GtkListBoxRow* _0, GtkListBoxRow* _1, gpointer _2);
// extern void gotk4_ListBoxUpdateHeaderFunc(GtkListBoxRow* _0, GtkListBoxRow* _1, gpointer _2);
// extern void gotk4_MenuPositionFunc(GtkMenu* _0, gint* _1, gint* _2, gboolean* _3, gpointer _4);
// extern void gotk4_PageSetupDoneFunc(GtkPageSetup* _0, gpointer _1);
// extern void gotk4_PrintSettingsFunc(const gchar* _0, const gchar* _1, gpointer _2);
// extern gboolean gotk4_RecentFilterFunc(const GtkRecentFilterInfo* _0, gpointer _1);
// extern gint gotk4_RecentSortFunc(GtkRecentInfo* _0, GtkRecentInfo* _1, gpointer _2);
// extern gboolean gotk4_TextBufferDeserializeFunc(GtkTextBuffer* _0, GtkTextBuffer* _1, GtkTextIter* _2, const guint8* _3, gsize _4, gboolean _5, gpointer _6);
// extern guint8* gotk4_TextBufferSerializeFunc(GtkTextBuffer* _0, GtkTextBuffer* _1, const GtkTextIter* _2, const GtkTextIter* _3, gsize* _4, gpointer _5);
// extern gboolean gotk4_TextCharPredicate(gunichar _0, gpointer _1);
// extern void gotk4_TextTagTableForeach(GtkTextTag* _0, gpointer _1);
// extern gboolean gotk4_TickCallback(GtkWidget* _0, GdkFrameClock* _1, gpointer _2);
// extern gchar* gotk4_TranslateFunc(const gchar* _0, gpointer _1);
// extern void gotk4_TreeCellDataFunc(GtkTreeViewColumn* _0, GtkCellRenderer* _1, GtkTreeModel* _2, GtkTreeIter* _3, gpointer _4);
// extern void gotk4_TreeDestroyCountFunc(GtkTreeView* _0, GtkTreePath* _1, gint _2, gpointer _3);
// extern gint gotk4_TreeIterCompareFunc(GtkTreeModel* _0, GtkTreeIter* _1, GtkTreeIter* _2, gpointer _3);
// extern void gotk4_TreeModelFilterModifyFunc(GtkTreeModel* _0, GtkTreeIter* _1, GValue* _2, gint _3, gpointer _4);
// extern gboolean gotk4_TreeModelFilterVisibleFunc(GtkTreeModel* _0, GtkTreeIter* _1, gpointer _2);
// extern gboolean gotk4_TreeModelForeachFunc(GtkTreeModel* _0, GtkTreePath* _1, GtkTreeIter* _2, gpointer _3);
// extern void gotk4_TreeSelectionForeachFunc(GtkTreeModel* _0, GtkTreePath* _1, GtkTreeIter* _2, gpointer _3);
// extern gboolean gotk4_TreeSelectionFunc(GtkTreeSelection* _0, GtkTreeModel* _1, GtkTreePath* _2, gboolean _3, gpointer _4);
// extern gboolean gotk4_TreeViewColumnDropFunc(GtkTreeView* _0, GtkTreeViewColumn* _1, GtkTreeViewColumn* _2, GtkTreeViewColumn* _3, gpointer _4);
// extern void gotk4_TreeViewMappingFunc(GtkTreeView* _0, GtkTreePath* _1, gpointer _2);
// extern gboolean gotk4_TreeViewRowSeparatorFunc(GtkTreeModel* _0, GtkTreeIter* _1, gpointer _2);
// extern gboolean gotk4_TreeViewSearchEqualFunc(GtkTreeModel* _0, gint _1, const gchar* _2, GtkTreeIter* _3, gpointer _4);
// extern void gotk4_TreeViewSearchPositionFunc(GtkTreeView* _0, GtkWidget* _1, gpointer _2);
// // extern void callbackDelete(gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_align_get_type()), F: marshalAlign},
		{T: externglib.Type(C.gtk_arrow_placement_get_type()), F: marshalArrowPlacement},
		{T: externglib.Type(C.gtk_arrow_type_get_type()), F: marshalArrowType},
		{T: externglib.Type(C.gtk_assistant_page_type_get_type()), F: marshalAssistantPageType},
		{T: externglib.Type(C.gtk_baseline_position_get_type()), F: marshalBaselinePosition},
		{T: externglib.Type(C.gtk_border_style_get_type()), F: marshalBorderStyle},
		{T: externglib.Type(C.gtk_builder_error_get_type()), F: marshalBuilderError},
		{T: externglib.Type(C.gtk_button_box_style_get_type()), F: marshalButtonBoxStyle},
		{T: externglib.Type(C.gtk_button_role_get_type()), F: marshalButtonRole},
		{T: externglib.Type(C.gtk_buttons_type_get_type()), F: marshalButtonsType},
		{T: externglib.Type(C.gtk_cell_renderer_accel_mode_get_type()), F: marshalCellRendererAccelMode},
		{T: externglib.Type(C.gtk_cell_renderer_mode_get_type()), F: marshalCellRendererMode},
		{T: externglib.Type(C.gtk_corner_type_get_type()), F: marshalCornerType},
		{T: externglib.Type(C.gtk_css_provider_error_get_type()), F: marshalCSSProviderError},
		{T: externglib.Type(C.gtk_css_section_type_get_type()), F: marshalCSSSectionType},
		{T: externglib.Type(C.gtk_delete_type_get_type()), F: marshalDeleteType},
		{T: externglib.Type(C.gtk_direction_type_get_type()), F: marshalDirectionType},
		{T: externglib.Type(C.gtk_drag_result_get_type()), F: marshalDragResult},
		{T: externglib.Type(C.gtk_entry_icon_position_get_type()), F: marshalEntryIconPosition},
		{T: externglib.Type(C.gtk_event_sequence_state_get_type()), F: marshalEventSequenceState},
		{T: externglib.Type(C.gtk_expander_style_get_type()), F: marshalExpanderStyle},
		{T: externglib.Type(C.gtk_file_chooser_action_get_type()), F: marshalFileChooserAction},
		{T: externglib.Type(C.gtk_file_chooser_confirmation_get_type()), F: marshalFileChooserConfirmation},
		{T: externglib.Type(C.gtk_file_chooser_error_get_type()), F: marshalFileChooserError},
		{T: externglib.Type(C.gtk_im_preedit_style_get_type()), F: marshalIMPreeditStyle},
		{T: externglib.Type(C.gtk_im_status_style_get_type()), F: marshalIMStatusStyle},
		{T: externglib.Type(C.gtk_icon_size_get_type()), F: marshalIconSize},
		{T: externglib.Type(C.gtk_icon_theme_error_get_type()), F: marshalIconThemeError},
		{T: externglib.Type(C.gtk_icon_view_drop_position_get_type()), F: marshalIconViewDropPosition},
		{T: externglib.Type(C.gtk_image_type_get_type()), F: marshalImageType},
		{T: externglib.Type(C.gtk_input_purpose_get_type()), F: marshalInputPurpose},
		{T: externglib.Type(C.gtk_justification_get_type()), F: marshalJustification},
		{T: externglib.Type(C.gtk_level_bar_mode_get_type()), F: marshalLevelBarMode},
		{T: externglib.Type(C.gtk_license_get_type()), F: marshalLicense},
		{T: externglib.Type(C.gtk_menu_direction_type_get_type()), F: marshalMenuDirectionType},
		{T: externglib.Type(C.gtk_message_type_get_type()), F: marshalMessageType},
		{T: externglib.Type(C.gtk_movement_step_get_type()), F: marshalMovementStep},
		{T: externglib.Type(C.gtk_notebook_tab_get_type()), F: marshalNotebookTab},
		{T: externglib.Type(C.gtk_number_up_layout_get_type()), F: marshalNumberUpLayout},
		{T: externglib.Type(C.gtk_orientation_get_type()), F: marshalOrientation},
		{T: externglib.Type(C.gtk_pack_direction_get_type()), F: marshalPackDirection},
		{T: externglib.Type(C.gtk_pack_type_get_type()), F: marshalPackType},
		{T: externglib.Type(C.gtk_pad_action_type_get_type()), F: marshalPadActionType},
		{T: externglib.Type(C.gtk_page_orientation_get_type()), F: marshalPageOrientation},
		{T: externglib.Type(C.gtk_page_set_get_type()), F: marshalPageSet},
		{T: externglib.Type(C.gtk_pan_direction_get_type()), F: marshalPanDirection},
		{T: externglib.Type(C.gtk_path_priority_type_get_type()), F: marshalPathPriorityType},
		{T: externglib.Type(C.gtk_path_type_get_type()), F: marshalPathType},
		{T: externglib.Type(C.gtk_policy_type_get_type()), F: marshalPolicyType},
		{T: externglib.Type(C.gtk_popover_constraint_get_type()), F: marshalPopoverConstraint},
		{T: externglib.Type(C.gtk_position_type_get_type()), F: marshalPositionType},
		{T: externglib.Type(C.gtk_print_duplex_get_type()), F: marshalPrintDuplex},
		{T: externglib.Type(C.gtk_print_error_get_type()), F: marshalPrintError},
		{T: externglib.Type(C.gtk_print_operation_action_get_type()), F: marshalPrintOperationAction},
		{T: externglib.Type(C.gtk_print_operation_result_get_type()), F: marshalPrintOperationResult},
		{T: externglib.Type(C.gtk_print_pages_get_type()), F: marshalPrintPages},
		{T: externglib.Type(C.gtk_print_quality_get_type()), F: marshalPrintQuality},
		{T: externglib.Type(C.gtk_print_status_get_type()), F: marshalPrintStatus},
		{T: externglib.Type(C.gtk_propagation_phase_get_type()), F: marshalPropagationPhase},
		{T: externglib.Type(C.gtk_rc_token_type_get_type()), F: marshalRCTokenType},
		{T: externglib.Type(C.gtk_recent_chooser_error_get_type()), F: marshalRecentChooserError},
		{T: externglib.Type(C.gtk_recent_manager_error_get_type()), F: marshalRecentManagerError},
		{T: externglib.Type(C.gtk_recent_sort_type_get_type()), F: marshalRecentSortType},
		{T: externglib.Type(C.gtk_relief_style_get_type()), F: marshalReliefStyle},
		{T: externglib.Type(C.gtk_resize_mode_get_type()), F: marshalResizeMode},
		{T: externglib.Type(C.gtk_response_type_get_type()), F: marshalResponseType},
		{T: externglib.Type(C.gtk_revealer_transition_type_get_type()), F: marshalRevealerTransitionType},
		{T: externglib.Type(C.gtk_scroll_step_get_type()), F: marshalScrollStep},
		{T: externglib.Type(C.gtk_scroll_type_get_type()), F: marshalScrollType},
		{T: externglib.Type(C.gtk_scrollable_policy_get_type()), F: marshalScrollablePolicy},
		{T: externglib.Type(C.gtk_selection_mode_get_type()), F: marshalSelectionMode},
		{T: externglib.Type(C.gtk_sensitivity_type_get_type()), F: marshalSensitivityType},
		{T: externglib.Type(C.gtk_shadow_type_get_type()), F: marshalShadowType},
		{T: externglib.Type(C.gtk_shortcut_type_get_type()), F: marshalShortcutType},
		{T: externglib.Type(C.gtk_size_group_mode_get_type()), F: marshalSizeGroupMode},
		{T: externglib.Type(C.gtk_size_request_mode_get_type()), F: marshalSizeRequestMode},
		{T: externglib.Type(C.gtk_sort_type_get_type()), F: marshalSortType},
		{T: externglib.Type(C.gtk_spin_button_update_policy_get_type()), F: marshalSpinButtonUpdatePolicy},
		{T: externglib.Type(C.gtk_spin_type_get_type()), F: marshalSpinType},
		{T: externglib.Type(C.gtk_stack_transition_type_get_type()), F: marshalStackTransitionType},
		{T: externglib.Type(C.gtk_state_type_get_type()), F: marshalStateType},
		{T: externglib.Type(C.gtk_text_buffer_target_info_get_type()), F: marshalTextBufferTargetInfo},
		{T: externglib.Type(C.gtk_text_direction_get_type()), F: marshalTextDirection},
		{T: externglib.Type(C.gtk_text_extend_selection_get_type()), F: marshalTextExtendSelection},
		{T: externglib.Type(C.gtk_text_view_layer_get_type()), F: marshalTextViewLayer},
		{T: externglib.Type(C.gtk_text_window_type_get_type()), F: marshalTextWindowType},
		{T: externglib.Type(C.gtk_toolbar_space_style_get_type()), F: marshalToolbarSpaceStyle},
		{T: externglib.Type(C.gtk_toolbar_style_get_type()), F: marshalToolbarStyle},
		{T: externglib.Type(C.gtk_tree_view_column_sizing_get_type()), F: marshalTreeViewColumnSizing},
		{T: externglib.Type(C.gtk_tree_view_drop_position_get_type()), F: marshalTreeViewDropPosition},
		{T: externglib.Type(C.gtk_tree_view_grid_lines_get_type()), F: marshalTreeViewGridLines},
		{T: externglib.Type(C.gtk_unit_get_type()), F: marshalUnit},
		{T: externglib.Type(C.gtk_widget_help_type_get_type()), F: marshalWidgetHelpType},
		{T: externglib.Type(C.gtk_window_position_get_type()), F: marshalWindowPosition},
		{T: externglib.Type(C.gtk_window_type_get_type()), F: marshalWindowType},
		{T: externglib.Type(C.gtk_wrap_mode_get_type()), F: marshalWrapMode},
		{T: externglib.Type(C.gtk_accel_flags_get_type()), F: marshalAccelFlags},
		{T: externglib.Type(C.gtk_application_inhibit_flags_get_type()), F: marshalApplicationInhibitFlags},
		{T: externglib.Type(C.gtk_attach_options_get_type()), F: marshalAttachOptions},
		{T: externglib.Type(C.gtk_calendar_display_options_get_type()), F: marshalCalendarDisplayOptions},
		{T: externglib.Type(C.gtk_cell_renderer_state_get_type()), F: marshalCellRendererState},
		{T: externglib.Type(C.gtk_debug_flag_get_type()), F: marshalDebugFlag},
		{T: externglib.Type(C.gtk_dest_defaults_get_type()), F: marshalDestDefaults},
		{T: externglib.Type(C.gtk_dialog_flags_get_type()), F: marshalDialogFlags},
		{T: externglib.Type(C.gtk_event_controller_scroll_flags_get_type()), F: marshalEventControllerScrollFlags},
		{T: externglib.Type(C.gtk_file_filter_flags_get_type()), F: marshalFileFilterFlags},
		{T: externglib.Type(C.gtk_font_chooser_level_get_type()), F: marshalFontChooserLevel},
		{T: externglib.Type(C.gtk_icon_lookup_flags_get_type()), F: marshalIconLookupFlags},
		{T: externglib.Type(C.gtk_input_hints_get_type()), F: marshalInputHints},
		{T: externglib.Type(C.gtk_junction_sides_get_type()), F: marshalJunctionSides},
		{T: externglib.Type(C.gtk_places_open_flags_get_type()), F: marshalPlacesOpenFlags},
		{T: externglib.Type(C.gtk_rc_flags_get_type()), F: marshalRCFlags},
		{T: externglib.Type(C.gtk_recent_filter_flags_get_type()), F: marshalRecentFilterFlags},
		{T: externglib.Type(C.gtk_region_flags_get_type()), F: marshalRegionFlags},
		{T: externglib.Type(C.gtk_state_flags_get_type()), F: marshalStateFlags},
		{T: externglib.Type(C.gtk_style_context_print_flags_get_type()), F: marshalStyleContextPrintFlags},
		{T: externglib.Type(C.gtk_target_flags_get_type()), F: marshalTargetFlags},
		{T: externglib.Type(C.gtk_text_search_flags_get_type()), F: marshalTextSearchFlags},
		{T: externglib.Type(C.gtk_tool_palette_drag_targets_get_type()), F: marshalToolPaletteDragTargets},
		{T: externglib.Type(C.gtk_tree_model_flags_get_type()), F: marshalTreeModelFlags},
		{T: externglib.Type(C.gtk_ui_manager_item_type_get_type()), F: marshalUIManagerItemType},
		{T: externglib.Type(C.gtk_activatable_get_type()), F: marshalActivatable},
		{T: externglib.Type(C.gtk_buildable_get_type()), F: marshalBuildable},
		{T: externglib.Type(C.gtk_cell_accessible_parent_get_type()), F: marshalCellAccessibleParent},
		{T: externglib.Type(C.gtk_cell_layout_get_type()), F: marshalCellLayout},
		{T: externglib.Type(C.gtk_color_chooser_get_type()), F: marshalColorChooser},
		{T: externglib.Type(C.gtk_editable_get_type()), F: marshalEditable},
		{T: externglib.Type(C.gtk_file_chooser_get_type()), F: marshalFileChooser},
		{T: externglib.Type(C.gtk_font_chooser_get_type()), F: marshalFontChooser},
		{T: externglib.Type(C.gtk_orientable_get_type()), F: marshalOrientable},
		{T: externglib.Type(C.gtk_print_operation_preview_get_type()), F: marshalPrintOperationPreview},
		{T: externglib.Type(C.gtk_recent_chooser_get_type()), F: marshalRecentChooser},
		{T: externglib.Type(C.gtk_scrollable_get_type()), F: marshalScrollable},
		{T: externglib.Type(C.gtk_style_provider_get_type()), F: marshalStyleProvider},
		{T: externglib.Type(C.gtk_tree_drag_dest_get_type()), F: marshalTreeDragDest},
		{T: externglib.Type(C.gtk_tree_drag_source_get_type()), F: marshalTreeDragSource},
		{T: externglib.Type(C.gtk_tree_model_get_type()), F: marshalTreeModel},
		{T: externglib.Type(C.gtk_tree_sortable_get_type()), F: marshalTreeSortable},
		{T: externglib.Type(C.gtk_border_get_type()), F: marshalBorder},
		{T: externglib.Type(C.gtk_css_section_get_type()), F: marshalCSSSection},
		{T: externglib.Type(C.gtk_gradient_get_type()), F: marshalGradient},
		{T: externglib.Type(C.gtk_icon_set_get_type()), F: marshalIconSet},
		{T: externglib.Type(C.gtk_icon_source_get_type()), F: marshalIconSource},
		{T: externglib.Type(C.gtk_paper_size_get_type()), F: marshalPaperSize},
		{T: externglib.Type(C.gtk_recent_info_get_type()), F: marshalRecentInfo},
		{T: externglib.Type(C.gtk_requisition_get_type()), F: marshalRequisition},
		{T: externglib.Type(C.gtk_selection_data_get_type()), F: marshalSelectionData},
		{T: externglib.Type(C.gtk_symbolic_color_get_type()), F: marshalSymbolicColor},
		{T: externglib.Type(C.gtk_target_entry_get_type()), F: marshalTargetEntry},
		{T: externglib.Type(C.gtk_target_list_get_type()), F: marshalTargetList},
		{T: externglib.Type(C.gtk_text_attributes_get_type()), F: marshalTextAttributes},
		{T: externglib.Type(C.gtk_text_iter_get_type()), F: marshalTextIter},
		{T: externglib.Type(C.gtk_tree_iter_get_type()), F: marshalTreeIter},
		{T: externglib.Type(C.gtk_tree_path_get_type()), F: marshalTreePath},
		{T: externglib.Type(C.gtk_tree_row_reference_get_type()), F: marshalTreeRowReference},
		{T: externglib.Type(C.gtk_widget_path_get_type()), F: marshalWidgetPath},
		{T: externglib.Type(C.gtk_accel_group_get_type()), F: marshalAccelGroup},
		{T: externglib.Type(C.gtk_accel_map_get_type()), F: marshalAccelMap},
		{T: externglib.Type(C.gtk_action_get_type()), F: marshalAction},
		{T: externglib.Type(C.gtk_action_group_get_type()), F: marshalActionGroup},
		{T: externglib.Type(C.gtk_adjustment_get_type()), F: marshalAdjustment},
		{T: externglib.Type(C.gtk_builder_get_type()), F: marshalBuilder},
		{T: externglib.Type(C.gtk_cell_area_get_type()), F: marshalCellArea},
		{T: externglib.Type(C.gtk_cell_area_box_get_type()), F: marshalCellAreaBox},
		{T: externglib.Type(C.gtk_cell_area_context_get_type()), F: marshalCellAreaContext},
		{T: externglib.Type(C.gtk_cell_renderer_get_type()), F: marshalCellRenderer},
		{T: externglib.Type(C.gtk_cell_renderer_accel_get_type()), F: marshalCellRendererAccel},
		{T: externglib.Type(C.gtk_cell_renderer_combo_get_type()), F: marshalCellRendererCombo},
		{T: externglib.Type(C.gtk_cell_renderer_pixbuf_get_type()), F: marshalCellRendererPixbuf},
		{T: externglib.Type(C.gtk_cell_renderer_progress_get_type()), F: marshalCellRendererProgress},
		{T: externglib.Type(C.gtk_cell_renderer_spin_get_type()), F: marshalCellRendererSpin},
		{T: externglib.Type(C.gtk_cell_renderer_spinner_get_type()), F: marshalCellRendererSpinner},
		{T: externglib.Type(C.gtk_cell_renderer_text_get_type()), F: marshalCellRendererText},
		{T: externglib.Type(C.gtk_cell_renderer_toggle_get_type()), F: marshalCellRendererToggle},
		{T: externglib.Type(C.gtk_clipboard_get_type()), F: marshalClipboard},
		{T: externglib.Type(C.gtk_css_provider_get_type()), F: marshalCSSProvider},
		{T: externglib.Type(C.gtk_entry_buffer_get_type()), F: marshalEntryBuffer},
		{T: externglib.Type(C.gtk_entry_completion_get_type()), F: marshalEntryCompletion},
		{T: externglib.Type(C.gtk_event_controller_get_type()), F: marshalEventController},
		{T: externglib.Type(C.gtk_event_controller_key_get_type()), F: marshalEventControllerKey},
		{T: externglib.Type(C.gtk_event_controller_motion_get_type()), F: marshalEventControllerMotion},
		{T: externglib.Type(C.gtk_event_controller_scroll_get_type()), F: marshalEventControllerScroll},
		{T: externglib.Type(C.gtk_file_chooser_native_get_type()), F: marshalFileChooserNative},
		{T: externglib.Type(C.gtk_file_filter_get_type()), F: marshalFileFilter},
		{T: externglib.Type(C.gtk_gesture_get_type()), F: marshalGesture},
		{T: externglib.Type(C.gtk_gesture_drag_get_type()), F: marshalGestureDrag},
		{T: externglib.Type(C.gtk_gesture_long_press_get_type()), F: marshalGestureLongPress},
		{T: externglib.Type(C.gtk_gesture_multi_press_get_type()), F: marshalGestureMultiPress},
		{T: externglib.Type(C.gtk_gesture_pan_get_type()), F: marshalGesturePan},
		{T: externglib.Type(C.gtk_gesture_rotate_get_type()), F: marshalGestureRotate},
		{T: externglib.Type(C.gtk_gesture_single_get_type()), F: marshalGestureSingle},
		{T: externglib.Type(C.gtk_gesture_stylus_get_type()), F: marshalGestureStylus},
		{T: externglib.Type(C.gtk_gesture_swipe_get_type()), F: marshalGestureSwipe},
		{T: externglib.Type(C.gtk_gesture_zoom_get_type()), F: marshalGestureZoom},
		{T: externglib.Type(C.gtk_im_context_get_type()), F: marshalIMContext},
		{T: externglib.Type(C.gtk_im_context_simple_get_type()), F: marshalIMContextSimple},
		{T: externglib.Type(C.gtk_im_multicontext_get_type()), F: marshalIMMulticontext},
		{T: externglib.Type(C.gtk_icon_factory_get_type()), F: marshalIconFactory},
		{T: externglib.Type(C.gtk_icon_info_get_type()), F: marshalIconInfo},
		{T: externglib.Type(C.gtk_icon_theme_get_type()), F: marshalIconTheme},
		{T: externglib.Type(C.gtk_list_store_get_type()), F: marshalListStore},
		{T: externglib.Type(C.gtk_mount_operation_get_type()), F: marshalMountOperation},
		{T: externglib.Type(C.gtk_native_dialog_get_type()), F: marshalNativeDialog},
		{T: externglib.Type(C.gtk_pad_controller_get_type()), F: marshalPadController},
		{T: externglib.Type(C.gtk_page_setup_get_type()), F: marshalPageSetup},
		{T: externglib.Type(C.gtk_print_context_get_type()), F: marshalPrintContext},
		{T: externglib.Type(C.gtk_print_operation_get_type()), F: marshalPrintOperation},
		{T: externglib.Type(C.gtk_print_settings_get_type()), F: marshalPrintSettings},
		{T: externglib.Type(C.gtk_radio_action_get_type()), F: marshalRadioAction},
		{T: externglib.Type(C.gtk_rc_style_get_type()), F: marshalRCStyle},
		{T: externglib.Type(C.gtk_recent_action_get_type()), F: marshalRecentAction},
		{T: externglib.Type(C.gtk_recent_filter_get_type()), F: marshalRecentFilter},
		{T: externglib.Type(C.gtk_recent_manager_get_type()), F: marshalRecentManager},
		{T: externglib.Type(C.gtk_settings_get_type()), F: marshalSettings},
		{T: externglib.Type(C.gtk_size_group_get_type()), F: marshalSizeGroup},
		{T: externglib.Type(C.gtk_status_icon_get_type()), F: marshalStatusIcon},
		{T: externglib.Type(C.gtk_style_get_type()), F: marshalStyle},
		{T: externglib.Type(C.gtk_style_context_get_type()), F: marshalStyleContext},
		{T: externglib.Type(C.gtk_style_properties_get_type()), F: marshalStyleProperties},
		{T: externglib.Type(C.gtk_text_buffer_get_type()), F: marshalTextBuffer},
		{T: externglib.Type(C.gtk_text_child_anchor_get_type()), F: marshalTextChildAnchor},
		{T: externglib.Type(C.gtk_text_mark_get_type()), F: marshalTextMark},
		{T: externglib.Type(C.gtk_text_tag_get_type()), F: marshalTextTag},
		{T: externglib.Type(C.gtk_text_tag_table_get_type()), F: marshalTextTagTable},
		{T: externglib.Type(C.gtk_theming_engine_get_type()), F: marshalThemingEngine},
		{T: externglib.Type(C.gtk_toggle_action_get_type()), F: marshalToggleAction},
		{T: externglib.Type(C.gtk_tooltip_get_type()), F: marshalTooltip},
		{T: externglib.Type(C.gtk_tree_model_filter_get_type()), F: marshalTreeModelFilter},
		{T: externglib.Type(C.gtk_tree_model_sort_get_type()), F: marshalTreeModelSort},
		{T: externglib.Type(C.gtk_tree_selection_get_type()), F: marshalTreeSelection},
		{T: externglib.Type(C.gtk_tree_store_get_type()), F: marshalTreeStore},
		{T: externglib.Type(C.gtk_tree_view_column_get_type()), F: marshalTreeViewColumn},
		{T: externglib.Type(C.gtk_ui_manager_get_type()), F: marshalUIManager},
		{T: externglib.Type(C.gtk_window_group_get_type()), F: marshalWindowGroup},
	})
}

//export callbackDelete
func callbackDelete(ptr C.gpointer) {
	box.Delete(box.Callback, uintptr(ptr))
}

// Allocation: a Allocation-struct of a widget represents region which has been
// allocated to the widget by its parent. It is a subregion of its parents
// allocation. See [GtkWidget’s geometry management
// section][geometry-management] for more information.
type Allocation gdk.Rectangle

type Stock string

// Align controls how a widget deals with extra space in a single (x or y)
// dimension.
//
// Alignment only matters if the widget receives a “too large” allocation, for
// example if you packed the widget with the Widget:expand flag inside a Box,
// then the widget might get extra space. If you have for example a 16x16 icon
// inside a 32x32 space, the icon could be scaled and stretched, it could be
// centered, or it could be positioned to one side of the space.
//
// Note that in horizontal context @GTK_ALIGN_START and @GTK_ALIGN_END are
// interpreted relative to text direction.
//
// GTK_ALIGN_BASELINE support for it is optional for containers and widgets, and
// it is only supported for vertical alignment. When its not supported by a
// child or a container it is treated as @GTK_ALIGN_FILL.
type Align int

const (
	// AlignFill: stretch to fill all space if possible, center if no meaningful
	// way to stretch
	AlignFill Align = 0
	// AlignStart: snap to left or top side, leaving space on right or bottom
	AlignStart Align = 1
	// AlignEnd: snap to right or bottom side, leaving space on left or top
	AlignEnd Align = 2
	// AlignCenter: center natural width of widget inside the allocation
	AlignCenter Align = 3
	// AlignBaseline: align the widget according to the baseline. Since 3.10.
	AlignBaseline Align = 4
)

func marshalAlign(p uintptr) (interface{}, error) {
	return Align(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ArrowPlacement: used to specify the placement of scroll arrows in scrolling
// menus.
type ArrowPlacement int

const (
	// ArrowPlacementBoth: place one arrow on each end of the menu.
	ArrowPlacementBoth ArrowPlacement = 0
	// ArrowPlacementStart: place both arrows at the top of the menu.
	ArrowPlacementStart ArrowPlacement = 1
	// ArrowPlacementEnd: place both arrows at the bottom of the menu.
	ArrowPlacementEnd ArrowPlacement = 2
)

func marshalArrowPlacement(p uintptr) (interface{}, error) {
	return ArrowPlacement(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ArrowType: used to indicate the direction in which an arrow should point.
type ArrowType int

const (
	// ArrowTypeUp represents an upward pointing arrow.
	ArrowTypeUp ArrowType = 0
	// ArrowTypeDown represents a downward pointing arrow.
	ArrowTypeDown ArrowType = 1
	// ArrowTypeLeft represents a left pointing arrow.
	ArrowTypeLeft ArrowType = 2
	// ArrowTypeRight represents a right pointing arrow.
	ArrowTypeRight ArrowType = 3
	// ArrowTypeNone: no arrow. Since 2.10.
	ArrowTypeNone ArrowType = 4
)

func marshalArrowType(p uintptr) (interface{}, error) {
	return ArrowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AssistantPageType: an enum for determining the page role inside the
// Assistant. It's used to handle buttons sensitivity and visibility.
//
// Note that an assistant needs to end its page flow with a page of type
// GTK_ASSISTANT_PAGE_CONFIRM, GTK_ASSISTANT_PAGE_SUMMARY or
// GTK_ASSISTANT_PAGE_PROGRESS to be correct.
//
// The Cancel button will only be shown if the page isn’t “committed”. See
// gtk_assistant_commit() for details.
type AssistantPageType int

const (
	// AssistantPageTypeContent: the page has regular contents. Both the Back
	// and forward buttons will be shown.
	AssistantPageTypeContent AssistantPageType = 0
	// AssistantPageTypeIntro: the page contains an introduction to the
	// assistant task. Only the Forward button will be shown if there is a next
	// page.
	AssistantPageTypeIntro AssistantPageType = 1
	// AssistantPageTypeConfirm: the page lets the user confirm or deny the
	// changes. The Back and Apply buttons will be shown.
	AssistantPageTypeConfirm AssistantPageType = 2
	// AssistantPageTypeSummary: the page informs the user of the changes done.
	// Only the Close button will be shown.
	AssistantPageTypeSummary AssistantPageType = 3
	// AssistantPageTypeProgress: used for tasks that take a long time to
	// complete, blocks the assistant until the page is marked as complete. Only
	// the back button will be shown.
	AssistantPageTypeProgress AssistantPageType = 4
	// AssistantPageTypeCustom: used for when other page types are not
	// appropriate. No buttons will be shown, and the application must add its
	// own buttons through gtk_assistant_add_action_widget().
	AssistantPageTypeCustom AssistantPageType = 5
)

func marshalAssistantPageType(p uintptr) (interface{}, error) {
	return AssistantPageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BaselinePosition: whenever a container has some form of natural row it may
// align children in that row along a common typographical baseline. If the
// amount of verical space in the row is taller than the total requested height
// of the baseline-aligned children then it can use a BaselinePosition to select
// where to put the baseline inside the extra availible space.
type BaselinePosition int

const (
	// BaselinePositionTop: align the baseline at the top
	BaselinePositionTop BaselinePosition = 0
	// BaselinePositionCenter: center the baseline
	BaselinePositionCenter BaselinePosition = 1
	// BaselinePositionBottom: align the baseline at the bottom
	BaselinePositionBottom BaselinePosition = 2
)

func marshalBaselinePosition(p uintptr) (interface{}, error) {
	return BaselinePosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BorderStyle describes how the border of a UI element should be rendered.
type BorderStyle int

const (
	// BorderStyleNone: no visible border
	BorderStyleNone BorderStyle = 0
	// BorderStyleSolid: a single line segment
	BorderStyleSolid BorderStyle = 1
	// BorderStyleInset looks as if the content is sunken into the canvas
	BorderStyleInset BorderStyle = 2
	// BorderStyleOutset looks as if the content is coming out of the canvas
	BorderStyleOutset BorderStyle = 3
	// BorderStyleHidden: same as @GTK_BORDER_STYLE_NONE
	BorderStyleHidden BorderStyle = 4
	// BorderStyleDotted: a series of round dots
	BorderStyleDotted BorderStyle = 5
	// BorderStyleDashed: a series of square-ended dashes
	BorderStyleDashed BorderStyle = 6
	// BorderStyleDouble: two parallel lines with some space between them
	BorderStyleDouble BorderStyle = 7
	// BorderStyleGroove looks as if it were carved in the canvas
	BorderStyleGroove BorderStyle = 8
	// BorderStyleRidge looks as if it were coming out of the canvas
	BorderStyleRidge BorderStyle = 9
)

func marshalBorderStyle(p uintptr) (interface{}, error) {
	return BorderStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BuilderError: error codes that identify various errors that can occur while
// using Builder.
type BuilderError int

const (
	// BuilderErrorInvalidTypeFunction: a type-func attribute didn’t name a
	// function that returns a #GType.
	BuilderErrorInvalidTypeFunction BuilderError = 0
	// BuilderErrorUnhandledTag: the input contained a tag that Builder can’t
	// handle.
	BuilderErrorUnhandledTag BuilderError = 1
	// BuilderErrorMissingAttribute: an attribute that is required by Builder
	// was missing.
	BuilderErrorMissingAttribute BuilderError = 2
	// BuilderErrorInvalidAttribute: Builder found an attribute that it doesn’t
	// understand.
	BuilderErrorInvalidAttribute BuilderError = 3
	// BuilderErrorInvalidTag: Builder found a tag that it doesn’t understand.
	BuilderErrorInvalidTag BuilderError = 4
	// BuilderErrorMissingPropertyValue: a required property value was missing.
	BuilderErrorMissingPropertyValue BuilderError = 5
	// BuilderErrorInvalidValue: Builder couldn’t parse some attribute value.
	BuilderErrorInvalidValue BuilderError = 6
	// BuilderErrorVersionMismatch: the input file requires a newer version of
	// GTK+.
	BuilderErrorVersionMismatch BuilderError = 7
	// BuilderErrorDuplicateID: an object id occurred twice.
	BuilderErrorDuplicateID BuilderError = 8
	// BuilderErrorObjectTypeRefused: a specified object type is of the same
	// type or derived from the type of the composite class being extended with
	// builder XML.
	BuilderErrorObjectTypeRefused BuilderError = 9
	// BuilderErrorTemplateMismatch: the wrong type was specified in a composite
	// class’s template XML
	BuilderErrorTemplateMismatch BuilderError = 10
	// BuilderErrorInvalidProperty: the specified property is unknown for the
	// object class.
	BuilderErrorInvalidProperty BuilderError = 11
	// BuilderErrorInvalidSignal: the specified signal is unknown for the object
	// class.
	BuilderErrorInvalidSignal BuilderError = 12
	// BuilderErrorInvalidID: an object id is unknown
	BuilderErrorInvalidID BuilderError = 13
)

func marshalBuilderError(p uintptr) (interface{}, error) {
	return BuilderError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ButtonBoxStyle: used to dictate the style that a ButtonBox uses to layout the
// buttons it contains.
type ButtonBoxStyle int

const (
	// ButtonBoxStyleSpread buttons are evenly spread across the box.
	ButtonBoxStyleSpread ButtonBoxStyle = 1
	// ButtonBoxStyleEdge buttons are placed at the edges of the box.
	ButtonBoxStyleEdge ButtonBoxStyle = 2
	// ButtonBoxStyleStart buttons are grouped towards the start of the box, (on
	// the left for a HBox, or the top for a VBox).
	ButtonBoxStyleStart ButtonBoxStyle = 3
	// ButtonBoxStyleEnd buttons are grouped towards the end of the box, (on the
	// right for a HBox, or the bottom for a VBox).
	ButtonBoxStyleEnd ButtonBoxStyle = 4
	// ButtonBoxStyleCenter buttons are centered in the box. Since 2.12.
	ButtonBoxStyleCenter ButtonBoxStyle = 5
	// ButtonBoxStyleExpand buttons expand to fill the box. This entails giving
	// buttons a "linked" appearance, making button sizes homogeneous, and
	// setting spacing to 0 (same as calling gtk_box_set_homogeneous() and
	// gtk_box_set_spacing() manually). Since 3.12.
	ButtonBoxStyleExpand ButtonBoxStyle = 6
)

func marshalButtonBoxStyle(p uintptr) (interface{}, error) {
	return ButtonBoxStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ButtonRole: the role specifies the desired appearance of a ModelButton.
type ButtonRole int

const (
	// ButtonRoleNormal: a plain button
	ButtonRoleNormal ButtonRole = 0
	// ButtonRoleCheck: a check button
	ButtonRoleCheck ButtonRole = 1
	// ButtonRoleRadio: a radio button
	ButtonRoleRadio ButtonRole = 2
)

func marshalButtonRole(p uintptr) (interface{}, error) {
	return ButtonRole(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ButtonsType: prebuilt sets of buttons for the dialog. If none of these
// choices are appropriate, simply use GTK_BUTTONS_NONE then call
// gtk_dialog_add_buttons().
//
// > Please note that GTK_BUTTONS_OK, GTK_BUTTONS_YES_NO > and
// GTK_BUTTONS_OK_CANCEL are discouraged by the > GNOME Human Interface
// Guidelines (http://library.gnome.org/devel/hig-book/stable/).
type ButtonsType int

const (
	// ButtonsTypeNone: no buttons at all
	ButtonsTypeNone ButtonsType = 0
	// ButtonsTypeOk: an OK button
	ButtonsTypeOk ButtonsType = 1
	// ButtonsTypeClose: a Close button
	ButtonsTypeClose ButtonsType = 2
	// ButtonsTypeCancel: a Cancel button
	ButtonsTypeCancel ButtonsType = 3
	// ButtonsTypeYesNo yes and No buttons
	ButtonsTypeYesNo ButtonsType = 4
	// ButtonsTypeOkCancel: OK and Cancel buttons
	ButtonsTypeOkCancel ButtonsType = 5
)

func marshalButtonsType(p uintptr) (interface{}, error) {
	return ButtonsType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CellRendererAccelMode determines if the edited accelerators are GTK+
// accelerators. If they are, consumed modifiers are suppressed, only
// accelerators accepted by GTK+ are allowed, and the accelerators are rendered
// in the same way as they are in menus.
type CellRendererAccelMode int

const (
	// CellRendererAccelModeGTK: GTK+ accelerators mode
	CellRendererAccelModeGTK CellRendererAccelMode = 0
	// CellRendererAccelModeOther: other accelerator mode
	CellRendererAccelModeOther CellRendererAccelMode = 1
)

func marshalCellRendererAccelMode(p uintptr) (interface{}, error) {
	return CellRendererAccelMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CellRendererMode identifies how the user can interact with a particular cell.
type CellRendererMode int

const (
	// CellRendererModeInert: the cell is just for display and cannot be
	// interacted with. Note that this doesn’t mean that eg. the row being drawn
	// can’t be selected -- just that a particular element of it cannot be
	// individually modified.
	CellRendererModeInert CellRendererMode = 0
	// CellRendererModeActivatable: the cell can be clicked.
	CellRendererModeActivatable CellRendererMode = 1
	// CellRendererModeEditable: the cell can be edited or otherwise modified.
	CellRendererModeEditable CellRendererMode = 2
)

func marshalCellRendererMode(p uintptr) (interface{}, error) {
	return CellRendererMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CornerType specifies which corner a child widget should be placed in when
// packed into a ScrolledWindow. This is effectively the opposite of where the
// scroll bars are placed.
type CornerType int

const (
	// CornerTypeTopLeft: place the scrollbars on the right and bottom of the
	// widget (default behaviour).
	CornerTypeTopLeft CornerType = 0
	// CornerTypeBottomLeft: place the scrollbars on the top and right of the
	// widget.
	CornerTypeBottomLeft CornerType = 1
	// CornerTypeTopRight: place the scrollbars on the left and bottom of the
	// widget.
	CornerTypeTopRight CornerType = 2
	// CornerTypeBottomRight: place the scrollbars on the top and left of the
	// widget.
	CornerTypeBottomRight CornerType = 3
)

func marshalCornerType(p uintptr) (interface{}, error) {
	return CornerType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CSSProviderError: error codes for GTK_CSS_PROVIDER_ERROR.
type CSSProviderError int

const (
	// CSSProviderErrorFailed: failed.
	CSSProviderErrorFailed CSSProviderError = 0
	// CSSProviderErrorSyntax: syntax error.
	CSSProviderErrorSyntax CSSProviderError = 1
	// CSSProviderErrorImport: import error.
	CSSProviderErrorImport CSSProviderError = 2
	// CSSProviderErrorName: name error.
	CSSProviderErrorName CSSProviderError = 3
	// CSSProviderErrorDeprecated: deprecation error.
	CSSProviderErrorDeprecated CSSProviderError = 4
	// CSSProviderErrorUnknownValue: unknown value.
	CSSProviderErrorUnknownValue CSSProviderError = 5
)

func marshalCSSProviderError(p uintptr) (interface{}, error) {
	return CSSProviderError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CSSSectionType: the different types of sections indicate parts of a CSS
// document as parsed by GTK’s CSS parser. They are oriented towards the CSS
// Grammar (http://www.w3.org/TR/CSS21/grammar.html), but may contain
// extensions.
//
// More types might be added in the future as the parser incorporates more
// features.
type CSSSectionType int

const (
	// CSSSectionTypeDocument: the section describes a complete document. This
	// section time is the only one where gtk_css_section_get_parent() might
	// return nil.
	CSSSectionTypeDocument CSSSectionType = 0
	// CSSSectionTypeImport: the section defines an import rule.
	CSSSectionTypeImport CSSSectionType = 1
	// CSSSectionTypeColorDefinition: the section defines a color. This is a GTK
	// extension to CSS.
	CSSSectionTypeColorDefinition CSSSectionType = 2
	// CSSSectionTypeBindingSet: the section defines a binding set. This is a
	// GTK extension to CSS.
	CSSSectionTypeBindingSet CSSSectionType = 3
	// CSSSectionTypeRuleset: the section defines a CSS ruleset.
	CSSSectionTypeRuleset CSSSectionType = 4
	// CSSSectionTypeSelector: the section defines a CSS selector.
	CSSSectionTypeSelector CSSSectionType = 5
	// CSSSectionTypeDeclaration: the section defines the declaration of a CSS
	// variable.
	CSSSectionTypeDeclaration CSSSectionType = 6
	// CSSSectionTypeValue: the section defines the value of a CSS declaration.
	CSSSectionTypeValue CSSSectionType = 7
	// CSSSectionTypeKeyframes: the section defines keyframes. See [CSS
	// Animations](http://dev.w3.org/csswg/css3-animations/#keyframes) for
	// details. Since 3.6
	CSSSectionTypeKeyframes CSSSectionType = 8
)

func marshalCSSSectionType(p uintptr) (interface{}, error) {
	return CSSSectionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DeleteType: see also: Entry::delete-from-cursor.
type DeleteType int

const (
	// DeleteTypeChars: delete characters.
	DeleteTypeChars DeleteType = 0
	// DeleteTypeWordEnds: delete only the portion of the word to the left/right
	// of cursor if we’re in the middle of a word.
	DeleteTypeWordEnds DeleteType = 1
	// DeleteTypeWords: delete words.
	DeleteTypeWords DeleteType = 2
	// DeleteTypeDisplayLines: delete display-lines. Display-lines refers to the
	// visible lines, with respect to to the current line breaks. As opposed to
	// paragraphs, which are defined by line breaks in the input.
	DeleteTypeDisplayLines DeleteType = 3
	// DeleteTypeDisplayLineEnds: delete only the portion of the display-line to
	// the left/right of cursor.
	DeleteTypeDisplayLineEnds DeleteType = 4
	// DeleteTypeParagraphEnds: delete to the end of the paragraph. Like C-k in
	// Emacs (or its reverse).
	DeleteTypeParagraphEnds DeleteType = 5
	// DeleteTypeParagraphs: delete entire line. Like C-k in pico.
	DeleteTypeParagraphs DeleteType = 6
	// DeleteTypeWhitespace: delete only whitespace. Like M-\ in Emacs.
	DeleteTypeWhitespace DeleteType = 7
)

func marshalDeleteType(p uintptr) (interface{}, error) {
	return DeleteType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DirectionType focus movement types.
type DirectionType int

const (
	// DirectionTypeTabForward: move forward.
	DirectionTypeTabForward DirectionType = 0
	// DirectionTypeTabBackward: move backward.
	DirectionTypeTabBackward DirectionType = 1
	// DirectionTypeUp: move up.
	DirectionTypeUp DirectionType = 2
	// DirectionTypeDown: move down.
	DirectionTypeDown DirectionType = 3
	// DirectionTypeLeft: move left.
	DirectionTypeLeft DirectionType = 4
	// DirectionTypeRight: move right.
	DirectionTypeRight DirectionType = 5
)

func marshalDirectionType(p uintptr) (interface{}, error) {
	return DirectionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DragResult gives an indication why a drag operation failed. The value can by
// obtained by connecting to the Widget::drag-failed signal.
type DragResult int

const (
	// DragResultSuccess: the drag operation was successful.
	DragResultSuccess DragResult = 0
	// DragResultNoTarget: no suitable drag target.
	DragResultNoTarget DragResult = 1
	// DragResultUserCancelled: the user cancelled the drag operation.
	DragResultUserCancelled DragResult = 2
	// DragResultTimeoutExpired: the drag operation timed out.
	DragResultTimeoutExpired DragResult = 3
	// DragResultGrabBroken: the pointer or keyboard grab used for the drag
	// operation was broken.
	DragResultGrabBroken DragResult = 4
	// DragResultError: the drag operation failed due to some unspecified error.
	DragResultError DragResult = 5
)

func marshalDragResult(p uintptr) (interface{}, error) {
	return DragResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EntryIconPosition specifies the side of the entry at which an icon is placed.
type EntryIconPosition int

const (
	// EntryIconPositionPrimary: at the beginning of the entry (depending on the
	// text direction).
	EntryIconPositionPrimary EntryIconPosition = 0
	// EntryIconPositionSecondary: at the end of the entry (depending on the
	// text direction).
	EntryIconPositionSecondary EntryIconPosition = 1
)

func marshalEntryIconPosition(p uintptr) (interface{}, error) {
	return EntryIconPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EventSequenceState describes the state of a EventSequence in a Gesture.
type EventSequenceState int

const (
	// EventSequenceStateNone: the sequence is handled, but not grabbed.
	EventSequenceStateNone EventSequenceState = 0
	// EventSequenceStateClaimed: the sequence is handled and grabbed.
	EventSequenceStateClaimed EventSequenceState = 1
	// EventSequenceStateDenied: the sequence is denied.
	EventSequenceStateDenied EventSequenceState = 2
)

func marshalEventSequenceState(p uintptr) (interface{}, error) {
	return EventSequenceState(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ExpanderStyle: used to specify the style of the expanders drawn by a
// TreeView.
type ExpanderStyle int

const (
	// ExpanderStyleCollapsed: the style used for a collapsed subtree.
	ExpanderStyleCollapsed ExpanderStyle = 0
	// ExpanderStyleSemiCollapsed: intermediate style used during animation.
	ExpanderStyleSemiCollapsed ExpanderStyle = 1
	// ExpanderStyleSemiExpanded: intermediate style used during animation.
	ExpanderStyleSemiExpanded ExpanderStyle = 2
	// ExpanderStyleExpanded: the style used for an expanded subtree.
	ExpanderStyleExpanded ExpanderStyle = 3
)

func marshalExpanderStyle(p uintptr) (interface{}, error) {
	return ExpanderStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileChooserAction describes whether a FileChooser is being used to open
// existing files or to save to a possibly new file.
type FileChooserAction int

const (
	// FileChooserActionOpen indicates open mode. The file chooser will only let
	// the user pick an existing file.
	FileChooserActionOpen FileChooserAction = 0
	// FileChooserActionSave indicates save mode. The file chooser will let the
	// user pick an existing file, or type in a new filename.
	FileChooserActionSave FileChooserAction = 1
	// FileChooserActionSelectFolder indicates an Open mode for selecting
	// folders. The file chooser will let the user pick an existing folder.
	FileChooserActionSelectFolder FileChooserAction = 2
	// FileChooserActionCreateFolder indicates a mode for creating a new folder.
	// The file chooser will let the user name an existing or new folder.
	FileChooserActionCreateFolder FileChooserAction = 3
)

func marshalFileChooserAction(p uintptr) (interface{}, error) {
	return FileChooserAction(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileChooserConfirmation: used as a return value of handlers for the
// FileChooser::confirm-overwrite signal of a FileChooser. This value determines
// whether the file chooser will present the stock confirmation dialog, accept
// the user’s choice of a filename, or let the user choose another filename.
type FileChooserConfirmation int

const (
	// FileChooserConfirmationConfirm: the file chooser will present its stock
	// dialog to confirm about overwriting an existing file.
	FileChooserConfirmationConfirm FileChooserConfirmation = 0
	// FileChooserConfirmationAcceptFilename: the file chooser will terminate
	// and accept the user’s choice of a file name.
	FileChooserConfirmationAcceptFilename FileChooserConfirmation = 1
	// FileChooserConfirmationSelectAgain: the file chooser will continue
	// running, so as to let the user select another file name.
	FileChooserConfirmationSelectAgain FileChooserConfirmation = 2
)

func marshalFileChooserConfirmation(p uintptr) (interface{}, error) {
	return FileChooserConfirmation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileChooserError: these identify the various errors that can occur while
// calling FileChooser functions.
type FileChooserError int

const (
	// FileChooserErrorNonexistent indicates that a file does not exist.
	FileChooserErrorNonexistent FileChooserError = 0
	// FileChooserErrorBadFilename indicates a malformed filename.
	FileChooserErrorBadFilename FileChooserError = 1
	// FileChooserErrorAlreadyExists indicates a duplicate path (e.g. when
	// adding a bookmark).
	FileChooserErrorAlreadyExists FileChooserError = 2
	// FileChooserErrorIncompleteHostname indicates an incomplete hostname (e.g.
	// "http://foo" without a slash after that).
	FileChooserErrorIncompleteHostname FileChooserError = 3
)

func marshalFileChooserError(p uintptr) (interface{}, error) {
	return FileChooserError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IMPreeditStyle: style for input method preedit. See also
// Settings:gtk-im-preedit-style
type IMPreeditStyle int

const (
	// IMPreeditStyleNothing: deprecated
	IMPreeditStyleNothing IMPreeditStyle = 0
	// IMPreeditStyleCallback: deprecated
	IMPreeditStyleCallback IMPreeditStyle = 1
	// IMPreeditStyleNone: deprecated
	IMPreeditStyleNone IMPreeditStyle = 2
)

func marshalIMPreeditStyle(p uintptr) (interface{}, error) {
	return IMPreeditStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IMStatusStyle: style for input method status. See also
// Settings:gtk-im-status-style
type IMStatusStyle int

const (
	// IMStatusStyleNothing: deprecated
	IMStatusStyleNothing IMStatusStyle = 0
	// IMStatusStyleCallback: deprecated
	IMStatusStyleCallback IMStatusStyle = 1
	// IMStatusStyleNone: deprecated
	IMStatusStyleNone IMStatusStyle = 2
)

func marshalIMStatusStyle(p uintptr) (interface{}, error) {
	return IMStatusStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconSize: built-in stock icon sizes.
type IconSize int

const (
	// IconSizeInvalid: invalid size.
	IconSizeInvalid IconSize = 0
	// IconSizeMenu: size appropriate for menus (16px).
	IconSizeMenu IconSize = 1
	// IconSizeSmallToolbar: size appropriate for small toolbars (16px).
	IconSizeSmallToolbar IconSize = 2
	// IconSizeLargeToolbar: size appropriate for large toolbars (24px)
	IconSizeLargeToolbar IconSize = 3
	// IconSizeButton: size appropriate for buttons (16px)
	IconSizeButton IconSize = 4
	// IconSizeDnd: size appropriate for drag and drop (32px)
	IconSizeDnd IconSize = 5
	// IconSizeDialog: size appropriate for dialogs (48px)
	IconSizeDialog IconSize = 6
)

func marshalIconSize(p uintptr) (interface{}, error) {
	return IconSize(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconThemeError: error codes for GtkIconTheme operations.
type IconThemeError int

const (
	// IconThemeErrorNotFound: the icon specified does not exist in the theme
	IconThemeErrorNotFound IconThemeError = 0
	// IconThemeErrorFailed: an unspecified error occurred.
	IconThemeErrorFailed IconThemeError = 1
)

func marshalIconThemeError(p uintptr) (interface{}, error) {
	return IconThemeError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconViewDropPosition: an enum for determining where a dropped item goes.
type IconViewDropPosition int

const (
	// IconViewDropPositionNoDrop: no drop possible
	IconViewDropPositionNoDrop IconViewDropPosition = 0
	// IconViewDropPositionDropInto: dropped item replaces the item
	IconViewDropPositionDropInto IconViewDropPosition = 1
	// IconViewDropPositionDropLeft: droppped item is inserted to the left
	IconViewDropPositionDropLeft IconViewDropPosition = 2
	// IconViewDropPositionDropRight: dropped item is inserted to the right
	IconViewDropPositionDropRight IconViewDropPosition = 3
	// IconViewDropPositionDropAbove: dropped item is inserted above
	IconViewDropPositionDropAbove IconViewDropPosition = 4
	// IconViewDropPositionDropBelow: dropped item is inserted below
	IconViewDropPositionDropBelow IconViewDropPosition = 5
)

func marshalIconViewDropPosition(p uintptr) (interface{}, error) {
	return IconViewDropPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ImageType describes the image data representation used by a Image. If you
// want to get the image from the widget, you can only get the currently-stored
// representation. e.g. if the gtk_image_get_storage_type() returns
// K_IMAGE_PIXBUF, then you can call gtk_image_get_pixbuf() but not
// gtk_image_get_stock(). For empty images, you can request any storage type
// (call any of the "get" functions), but they will all return nil values.
type ImageType int

const (
	// ImageTypeEmpty: there is no image displayed by the widget
	ImageTypeEmpty ImageType = 0
	// ImageTypePixbuf: the widget contains a Pixbuf
	ImageTypePixbuf ImageType = 1
	// ImageTypeStock: the widget contains a [stock item name][gtkstock]
	ImageTypeStock ImageType = 2
	// ImageTypeIconSet: the widget contains a IconSet
	ImageTypeIconSet ImageType = 3
	// ImageTypeAnimation: the widget contains a PixbufAnimation
	ImageTypeAnimation ImageType = 4
	// ImageTypeIconName: the widget contains a named icon. This image type was
	// added in GTK+ 2.6
	ImageTypeIconName ImageType = 5
	// ImageTypeGIcon: the widget contains a #GIcon. This image type was added
	// in GTK+ 2.14
	ImageTypeGIcon ImageType = 6
	// ImageTypeSurface: the widget contains a #cairo_surface_t. This image type
	// was added in GTK+ 3.10
	ImageTypeSurface ImageType = 7
)

func marshalImageType(p uintptr) (interface{}, error) {
	return ImageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// InputPurpose describes primary purpose of the input widget. This information
// is useful for on-screen keyboards and similar input methods to decide which
// keys should be presented to the user.
//
// Note that the purpose is not meant to impose a totally strict rule about
// allowed characters, and does not replace input validation. It is fine for an
// on-screen keyboard to let the user override the character set restriction
// that is expressed by the purpose. The application is expected to validate the
// entry contents, even if it specified a purpose.
//
// The difference between @GTK_INPUT_PURPOSE_DIGITS and
// @GTK_INPUT_PURPOSE_NUMBER is that the former accepts only digits while the
// latter also some punctuation (like commas or points, plus, minus) and “e” or
// “E” as in 3.14E+000.
//
// This enumeration may be extended in the future; input methods should
// interpret unknown values as “free form”.
type InputPurpose int

const (
	// InputPurposeFreeForm: allow any character
	InputPurposeFreeForm InputPurpose = 0
	// InputPurposeAlpha: allow only alphabetic characters
	InputPurposeAlpha InputPurpose = 1
	// InputPurposeDigits: allow only digits
	InputPurposeDigits InputPurpose = 2
	// InputPurposeNumber: edited field expects numbers
	InputPurposeNumber InputPurpose = 3
	// InputPurposePhone: edited field expects phone number
	InputPurposePhone InputPurpose = 4
	// InputPurposeURL: edited field expects URL
	InputPurposeURL InputPurpose = 5
	// InputPurposeEmail: edited field expects email address
	InputPurposeEmail InputPurpose = 6
	// InputPurposeName: edited field expects the name of a person
	InputPurposeName InputPurpose = 7
	// InputPurposePassword: like @GTK_INPUT_PURPOSE_FREE_FORM, but characters
	// are hidden
	InputPurposePassword InputPurpose = 8
	// InputPurposePin: like @GTK_INPUT_PURPOSE_DIGITS, but characters are
	// hidden
	InputPurposePin InputPurpose = 9
	// InputPurposeTerminal: allow any character, in addition to control codes
	InputPurposeTerminal InputPurpose = 10
)

func marshalInputPurpose(p uintptr) (interface{}, error) {
	return InputPurpose(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Justification: used for justifying the text inside a Label widget. (See also
// Alignment).
type Justification int

const (
	// JustificationLeft: the text is placed at the left edge of the label.
	JustificationLeft Justification = 0
	// JustificationRight: the text is placed at the right edge of the label.
	JustificationRight Justification = 1
	// JustificationCenter: the text is placed in the center of the label.
	JustificationCenter Justification = 2
	// JustificationFill: the text is placed is distributed across the label.
	JustificationFill Justification = 3
)

func marshalJustification(p uintptr) (interface{}, error) {
	return Justification(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// LevelBarMode describes how LevelBar contents should be rendered. Note that
// this enumeration could be extended with additional modes in the future.
type LevelBarMode int

const (
	// LevelBarModeContinuous: the bar has a continuous mode
	LevelBarModeContinuous LevelBarMode = 0
	// LevelBarModeDiscrete: the bar has a discrete mode
	LevelBarModeDiscrete LevelBarMode = 1
)

func marshalLevelBarMode(p uintptr) (interface{}, error) {
	return LevelBarMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// License: the type of license for an application.
//
// This enumeration can be expanded at later date.
type License int

const (
	// LicenseUnknown: no license specified
	LicenseUnknown License = 0
	// LicenseCustom: a license text is going to be specified by the developer
	LicenseCustom License = 1
	// LicenseGpl20: the GNU General Public License, version 2.0 or later
	LicenseGpl20 License = 2
	// LicenseGpl30: the GNU General Public License, version 3.0 or later
	LicenseGpl30 License = 3
	// LicenseLgpl21: the GNU Lesser General Public License, version 2.1 or
	// later
	LicenseLgpl21 License = 4
	// LicenseLgpl30: the GNU Lesser General Public License, version 3.0 or
	// later
	LicenseLgpl30 License = 5
	// LicenseBsd: the BSD standard license
	LicenseBsd License = 6
	// LicenseMitX11: the MIT/X11 standard license
	LicenseMitX11 License = 7
	// LicenseArtistic: the Artistic License, version 2.0
	LicenseArtistic License = 8
	// LicenseGpl20Only: the GNU General Public License, version 2.0 only. Since
	// 3.12.
	LicenseGpl20Only License = 9
	// LicenseGpl30Only: the GNU General Public License, version 3.0 only. Since
	// 3.12.
	LicenseGpl30Only License = 10
	// LicenseLgpl21Only: the GNU Lesser General Public License, version 2.1
	// only. Since 3.12.
	LicenseLgpl21Only License = 11
	// LicenseLgpl30Only: the GNU Lesser General Public License, version 3.0
	// only. Since 3.12.
	LicenseLgpl30Only License = 12
	// LicenseAgpl30: the GNU Affero General Public License, version 3.0 or
	// later. Since: 3.22.
	LicenseAgpl30 License = 13
	// LicenseAgpl30Only: the GNU Affero General Public License, version 3.0
	// only. Since: 3.22.27.
	LicenseAgpl30Only License = 14
	// LicenseBsd3: the 3-clause BSD licence. Since: 3.24.20.
	LicenseBsd3 License = 15
	// LicenseApache20: the Apache License, version 2.0. Since: 3.24.20.
	LicenseApache20 License = 16
	// LicenseMpl20: the Mozilla Public License, version 2.0. Since: 3.24.20.
	LicenseMpl20 License = 17
)

func marshalLicense(p uintptr) (interface{}, error) {
	return License(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MenuDirectionType: an enumeration representing directional movements within a
// menu.
type MenuDirectionType int

const (
	// MenuDirectionTypeParent: to the parent menu shell
	MenuDirectionTypeParent MenuDirectionType = 0
	// MenuDirectionTypeChild: to the submenu, if any, associated with the item
	MenuDirectionTypeChild MenuDirectionType = 1
	// MenuDirectionTypeNext: to the next menu item
	MenuDirectionTypeNext MenuDirectionType = 2
	// MenuDirectionTypePrev: to the previous menu item
	MenuDirectionTypePrev MenuDirectionType = 3
)

func marshalMenuDirectionType(p uintptr) (interface{}, error) {
	return MenuDirectionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MessageType: the type of message being displayed in the dialog.
type MessageType int

const (
	// MessageTypeInfo: informational message
	MessageTypeInfo MessageType = 0
	// MessageTypeWarning: non-fatal warning message
	MessageTypeWarning MessageType = 1
	// MessageTypeQuestion: question requiring a choice
	MessageTypeQuestion MessageType = 2
	// MessageTypeError: fatal error message
	MessageTypeError MessageType = 3
	// MessageTypeOther: none of the above
	MessageTypeOther MessageType = 4
)

func marshalMessageType(p uintptr) (interface{}, error) {
	return MessageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

type MovementStep int

const (
	// MovementStepLogicalPositions: move forward or back by graphemes
	MovementStepLogicalPositions MovementStep = 0
	// MovementStepVisualPositions: move left or right by graphemes
	MovementStepVisualPositions MovementStep = 1
	// MovementStepWords: move forward or back by words
	MovementStepWords MovementStep = 2
	// MovementStepDisplayLines: move up or down lines (wrapped lines)
	MovementStepDisplayLines MovementStep = 3
	// MovementStepDisplayLineEnds: move to either end of a line
	MovementStepDisplayLineEnds MovementStep = 4
	// MovementStepParagraphs: move up or down paragraphs (newline-ended lines)
	MovementStepParagraphs MovementStep = 5
	// MovementStepParagraphEnds: move to either end of a paragraph
	MovementStepParagraphEnds MovementStep = 6
	// MovementStepPages: move by pages
	MovementStepPages MovementStep = 7
	// MovementStepBufferEnds: move to ends of the buffer
	MovementStepBufferEnds MovementStep = 8
	// MovementStepHorizontalPages: move horizontally by pages
	MovementStepHorizontalPages MovementStep = 9
)

func marshalMovementStep(p uintptr) (interface{}, error) {
	return MovementStep(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

type NotebookTab int

const (
	NotebookTabFirst NotebookTab = 0

	NotebookTabLast NotebookTab = 1
)

func marshalNotebookTab(p uintptr) (interface{}, error) {
	return NotebookTab(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// NumberUpLayout: used to determine the layout of pages on a sheet when
// printing multiple pages per sheet.
type NumberUpLayout int

const (
	// NumberUpLayoutLrtb: ! (layout-lrtb.png)
	NumberUpLayoutLrtb NumberUpLayout = 0
	// NumberUpLayoutLrbt: ! (layout-lrbt.png)
	NumberUpLayoutLrbt NumberUpLayout = 1
	// NumberUpLayoutRltb: ! (layout-rltb.png)
	NumberUpLayoutRltb NumberUpLayout = 2
	// NumberUpLayoutRlbt: ! (layout-rlbt.png)
	NumberUpLayoutRlbt NumberUpLayout = 3
	// NumberUpLayoutTblr: ! (layout-tblr.png)
	NumberUpLayoutTblr NumberUpLayout = 4
	// NumberUpLayoutTbrl: ! (layout-tbrl.png)
	NumberUpLayoutTbrl NumberUpLayout = 5
	// NumberUpLayoutBtlr: ! (layout-btlr.png)
	NumberUpLayoutBtlr NumberUpLayout = 6
	// NumberUpLayoutBtrl: ! (layout-btrl.png)
	NumberUpLayoutBtrl NumberUpLayout = 7
)

func marshalNumberUpLayout(p uintptr) (interface{}, error) {
	return NumberUpLayout(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Orientation represents the orientation of widgets and other objects which can
// be switched between horizontal and vertical orientation on the fly, like
// Toolbar or GesturePan.
type Orientation int

const (
	// OrientationHorizontal: the element is in horizontal orientation.
	OrientationHorizontal Orientation = 0
	// OrientationVertical: the element is in vertical orientation.
	OrientationVertical Orientation = 1
)

func marshalOrientation(p uintptr) (interface{}, error) {
	return Orientation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PackDirection determines how widgets should be packed inside menubars and
// menuitems contained in menubars.
type PackDirection int

const (
	// PackDirectionLTR widgets are packed left-to-right
	PackDirectionLTR PackDirection = 0
	// PackDirectionRTL widgets are packed right-to-left
	PackDirectionRTL PackDirection = 1
	// PackDirectionTtb widgets are packed top-to-bottom
	PackDirectionTtb PackDirection = 2
	// PackDirectionBtt widgets are packed bottom-to-top
	PackDirectionBtt PackDirection = 3
)

func marshalPackDirection(p uintptr) (interface{}, error) {
	return PackDirection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PackType represents the packing location Box children. (See: VBox, HBox, and
// ButtonBox).
type PackType int

const (
	// PackTypeStart: the child is packed into the start of the box
	PackTypeStart PackType = 0
	// PackTypeEnd: the child is packed into the end of the box
	PackTypeEnd PackType = 1
)

func marshalPackType(p uintptr) (interface{}, error) {
	return PackType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PadActionType: the type of a pad action.
type PadActionType int

const (
	// PadActionTypeButton: action is triggered by a pad button
	PadActionTypeButton PadActionType = 0
	// PadActionTypeRing: action is triggered by a pad ring
	PadActionTypeRing PadActionType = 1
	// PadActionTypeStrip: action is triggered by a pad strip
	PadActionTypeStrip PadActionType = 2
)

func marshalPadActionType(p uintptr) (interface{}, error) {
	return PadActionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PageOrientation: see also gtk_print_settings_set_orientation().
type PageOrientation int

const (
	// PageOrientationPortrait: portrait mode.
	PageOrientationPortrait PageOrientation = 0
	// PageOrientationLandscape: landscape mode.
	PageOrientationLandscape PageOrientation = 1
	// PageOrientationReversePortrait: reverse portrait mode.
	PageOrientationReversePortrait PageOrientation = 2
	// PageOrientationReverseLandscape: reverse landscape mode.
	PageOrientationReverseLandscape PageOrientation = 3
)

func marshalPageOrientation(p uintptr) (interface{}, error) {
	return PageOrientation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PageSet: see also gtk_print_job_set_page_set().
type PageSet int

const (
	// PageSetAll: all pages.
	PageSetAll PageSet = 0
	// PageSetEven: even pages.
	PageSetEven PageSet = 1
	// PageSetOdd: odd pages.
	PageSetOdd PageSet = 2
)

func marshalPageSet(p uintptr) (interface{}, error) {
	return PageSet(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PanDirection describes the panning direction of a GesturePan
type PanDirection int

const (
	// PanDirectionLeft: panned towards the left
	PanDirectionLeft PanDirection = 0
	// PanDirectionRight: panned towards the right
	PanDirectionRight PanDirection = 1
	// PanDirectionUp: panned upwards
	PanDirectionUp PanDirection = 2
	// PanDirectionDown: panned downwards
	PanDirectionDown PanDirection = 3
)

func marshalPanDirection(p uintptr) (interface{}, error) {
	return PanDirection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PathPriorityType priorities for path lookups. See also
// gtk_binding_set_add_path().
type PathPriorityType int

const (
	// PathPriorityTypeLowest: deprecated
	PathPriorityTypeLowest PathPriorityType = 0
	// PathPriorityTypeGTK: deprecated
	PathPriorityTypeGTK PathPriorityType = 4
	// PathPriorityTypeApplication: deprecated
	PathPriorityTypeApplication PathPriorityType = 8
	// PathPriorityTypeTheme: deprecated
	PathPriorityTypeTheme PathPriorityType = 10
	// PathPriorityTypeRC: deprecated
	PathPriorityTypeRC PathPriorityType = 12
	// PathPriorityTypeHighest: deprecated
	PathPriorityTypeHighest PathPriorityType = 15
)

func marshalPathPriorityType(p uintptr) (interface{}, error) {
	return PathPriorityType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PathType: widget path types. See also gtk_binding_set_add_path().
type PathType int

const (
	// PathTypeWidget: deprecated
	PathTypeWidget PathType = 0
	// PathTypeWidgetClass: deprecated
	PathTypeWidgetClass PathType = 1
	// PathTypeClass: deprecated
	PathTypeClass PathType = 2
)

func marshalPathType(p uintptr) (interface{}, error) {
	return PathType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PolicyType determines how the size should be computed to achieve the one of
// the visibility mode for the scrollbars.
type PolicyType int

const (
	// PolicyTypeAlways: the scrollbar is always visible. The view size is
	// independent of the content.
	PolicyTypeAlways PolicyType = 0
	// PolicyTypeAutomatic: the scrollbar will appear and disappear as
	// necessary. For example, when all of a TreeView can not be seen.
	PolicyTypeAutomatic PolicyType = 1
	// PolicyTypeNever: the scrollbar should never appear. In this mode the
	// content determines the size.
	PolicyTypeNever PolicyType = 2
	// PolicyTypeExternal: don't show a scrollbar, but don't force the size to
	// follow the content. This can be used e.g. to make multiple scrolled
	// windows share a scrollbar. Since: 3.16
	PolicyTypeExternal PolicyType = 3
)

func marshalPolicyType(p uintptr) (interface{}, error) {
	return PolicyType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PopoverConstraint describes constraints to positioning of popovers. More
// values may be added to this enumeration in the future.
type PopoverConstraint int

const (
	// PopoverConstraintNone: don't constrain the popover position beyond what
	// is imposed by the implementation
	PopoverConstraintNone PopoverConstraint = 0
	// PopoverConstraintWindow: constrain the popover to the boundaries of the
	// window that it is attached to
	PopoverConstraintWindow PopoverConstraint = 1
)

func marshalPopoverConstraint(p uintptr) (interface{}, error) {
	return PopoverConstraint(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PositionType describes which edge of a widget a certain feature is positioned
// at, e.g. the tabs of a Notebook, the handle of a HandleBox or the label of a
// Scale.
type PositionType int

const (
	// PositionTypeLeft: the feature is at the left edge.
	PositionTypeLeft PositionType = 0
	// PositionTypeRight: the feature is at the right edge.
	PositionTypeRight PositionType = 1
	// PositionTypeTop: the feature is at the top edge.
	PositionTypeTop PositionType = 2
	// PositionTypeBottom: the feature is at the bottom edge.
	PositionTypeBottom PositionType = 3
)

func marshalPositionType(p uintptr) (interface{}, error) {
	return PositionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintDuplex: see also gtk_print_settings_set_duplex().
type PrintDuplex int

const (
	// PrintDuplexSimplex: no duplex.
	PrintDuplexSimplex PrintDuplex = 0
	// PrintDuplexHorizontal: horizontal duplex.
	PrintDuplexHorizontal PrintDuplex = 1
	// PrintDuplexVertical: vertical duplex.
	PrintDuplexVertical PrintDuplex = 2
)

func marshalPrintDuplex(p uintptr) (interface{}, error) {
	return PrintDuplex(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintError: error codes that identify various errors that can occur while
// using the GTK+ printing support.
type PrintError int

const (
	// PrintErrorGeneral: an unspecified error occurred.
	PrintErrorGeneral PrintError = 0
	// PrintErrorInternalError: an internal error occurred.
	PrintErrorInternalError PrintError = 1
	// PrintErrorNomem: a memory allocation failed.
	PrintErrorNomem PrintError = 2
	// PrintErrorInvalidFile: an error occurred while loading a page setup or
	// paper size from a key file.
	PrintErrorInvalidFile PrintError = 3
)

func marshalPrintError(p uintptr) (interface{}, error) {
	return PrintError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintOperationAction: the @action parameter to gtk_print_operation_run()
// determines what action the print operation should perform.
type PrintOperationAction int

const (
	// PrintOperationActionPrintDialog: show the print dialog.
	PrintOperationActionPrintDialog PrintOperationAction = 0
	// PrintOperationActionPrint: start to print without showing the print
	// dialog, based on the current print settings.
	PrintOperationActionPrint PrintOperationAction = 1
	// PrintOperationActionPreview: show the print preview.
	PrintOperationActionPreview PrintOperationAction = 2
	// PrintOperationActionExport: export to a file. This requires the
	// export-filename property to be set.
	PrintOperationActionExport PrintOperationAction = 3
)

func marshalPrintOperationAction(p uintptr) (interface{}, error) {
	return PrintOperationAction(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintOperationResult: a value of this type is returned by
// gtk_print_operation_run().
type PrintOperationResult int

const (
	// PrintOperationResultError: an error has occurred.
	PrintOperationResultError PrintOperationResult = 0
	// PrintOperationResultApply: the print settings should be stored.
	PrintOperationResultApply PrintOperationResult = 1
	// PrintOperationResultCancel: the print operation has been canceled, the
	// print settings should not be stored.
	PrintOperationResultCancel PrintOperationResult = 2
	// PrintOperationResultInProgress: the print operation is not complete yet.
	// This value will only be returned when running asynchronously.
	PrintOperationResultInProgress PrintOperationResult = 3
)

func marshalPrintOperationResult(p uintptr) (interface{}, error) {
	return PrintOperationResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintPages: see also gtk_print_job_set_pages()
type PrintPages int

const (
	// PrintPagesAll: all pages.
	PrintPagesAll PrintPages = 0
	// PrintPagesCurrent: current page.
	PrintPagesCurrent PrintPages = 1
	// PrintPagesRanges: range of pages.
	PrintPagesRanges PrintPages = 2
	// PrintPagesSelection: selected pages.
	PrintPagesSelection PrintPages = 3
)

func marshalPrintPages(p uintptr) (interface{}, error) {
	return PrintPages(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintQuality: see also gtk_print_settings_set_quality().
type PrintQuality int

const (
	// PrintQualityLow: low quality.
	PrintQualityLow PrintQuality = 0
	// PrintQualityNormal: normal quality.
	PrintQualityNormal PrintQuality = 1
	// PrintQualityHigh: high quality.
	PrintQualityHigh PrintQuality = 2
	// PrintQualityDraft: draft quality.
	PrintQualityDraft PrintQuality = 3
)

func marshalPrintQuality(p uintptr) (interface{}, error) {
	return PrintQuality(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintStatus: the status gives a rough indication of the completion of a
// running print operation.
type PrintStatus int

const (
	// PrintStatusInitial: the printing has not started yet; this status is set
	// initially, and while the print dialog is shown.
	PrintStatusInitial PrintStatus = 0
	// PrintStatusPreparing: this status is set while the begin-print signal is
	// emitted and during pagination.
	PrintStatusPreparing PrintStatus = 1
	// PrintStatusGeneratingData: this status is set while the pages are being
	// rendered.
	PrintStatusGeneratingData PrintStatus = 2
	// PrintStatusSendingData: the print job is being sent off to the printer.
	PrintStatusSendingData PrintStatus = 3
	// PrintStatusPending: the print job has been sent to the printer, but is
	// not printed for some reason, e.g. the printer may be stopped.
	PrintStatusPending PrintStatus = 4
	// PrintStatusPendingIssue: some problem has occurred during printing, e.g.
	// a paper jam.
	PrintStatusPendingIssue PrintStatus = 5
	// PrintStatusPrinting: the printer is processing the print job.
	PrintStatusPrinting PrintStatus = 6
	// PrintStatusFinished: the printing has been completed successfully.
	PrintStatusFinished PrintStatus = 7
	// PrintStatusFinishedAborted: the printing has been aborted.
	PrintStatusFinishedAborted PrintStatus = 8
)

func marshalPrintStatus(p uintptr) (interface{}, error) {
	return PrintStatus(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PropagationPhase describes the stage at which events are fed into a
// EventController.
type PropagationPhase int

const (
	// PropagationPhaseNone events are not delivered automatically. Those can be
	// manually fed through gtk_event_controller_handle_event(). This should
	// only be used when full control about when, or whether the controller
	// handles the event is needed.
	PropagationPhaseNone PropagationPhase = 0
	// PropagationPhaseCapture events are delivered in the capture phase. The
	// capture phase happens before the bubble phase, runs from the toplevel
	// down to the event widget. This option should only be used on containers
	// that might possibly handle events before their children do.
	PropagationPhaseCapture PropagationPhase = 1
	// PropagationPhaseBubble events are delivered in the bubble phase. The
	// bubble phase happens after the capture phase, and before the default
	// handlers are run. This phase runs from the event widget, up to the
	// toplevel.
	PropagationPhaseBubble PropagationPhase = 2
	// PropagationPhaseTarget events are delivered in the default widget event
	// handlers, note that widget implementations must chain up on button,
	// motion, touch and grab broken handlers for controllers in this phase to
	// be run.
	PropagationPhaseTarget PropagationPhase = 3
)

func marshalPropagationPhase(p uintptr) (interface{}, error) {
	return PropagationPhase(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RCTokenType: the RcTokenType enumeration represents the tokens in the RC
// file. It is exposed so that theme engines can reuse these tokens when parsing
// the theme-engine specific portions of a RC file.
type RCTokenType int

const (
	// RCTokenTypeInvalid: deprecated
	RCTokenTypeInvalid RCTokenType = 270
	// RCTokenTypeInclude: deprecated
	RCTokenTypeInclude RCTokenType = 271
	// RCTokenTypeNormal: deprecated
	RCTokenTypeNormal RCTokenType = 272
	// RCTokenTypeActive: deprecated
	RCTokenTypeActive RCTokenType = 273
	// RCTokenTypePrelight: deprecated
	RCTokenTypePrelight RCTokenType = 274
	// RCTokenTypeSelected: deprecated
	RCTokenTypeSelected RCTokenType = 275
	// RCTokenTypeInsensitive: deprecated
	RCTokenTypeInsensitive RCTokenType = 276
	// RCTokenTypeFg: deprecated
	RCTokenTypeFg RCTokenType = 277
	// RCTokenTypeBg: deprecated
	RCTokenTypeBg RCTokenType = 278
	// RCTokenTypeText: deprecated
	RCTokenTypeText RCTokenType = 279
	// RCTokenTypeBase: deprecated
	RCTokenTypeBase RCTokenType = 280
	// RCTokenTypeXthickness: deprecated
	RCTokenTypeXthickness RCTokenType = 281
	// RCTokenTypeYthickness: deprecated
	RCTokenTypeYthickness RCTokenType = 282
	// RCTokenTypeFont: deprecated
	RCTokenTypeFont RCTokenType = 283
	// RCTokenTypeFontset: deprecated
	RCTokenTypeFontset RCTokenType = 284
	// RCTokenTypeFontName: deprecated
	RCTokenTypeFontName RCTokenType = 285
	// RCTokenTypeBgPixmap: deprecated
	RCTokenTypeBgPixmap RCTokenType = 286
	// RCTokenTypePixmapPath: deprecated
	RCTokenTypePixmapPath RCTokenType = 287
	// RCTokenTypeStyle: deprecated
	RCTokenTypeStyle RCTokenType = 288
	// RCTokenTypeBinding: deprecated
	RCTokenTypeBinding RCTokenType = 289
	// RCTokenTypeBind: deprecated
	RCTokenTypeBind RCTokenType = 290
	// RCTokenTypeWidget: deprecated
	RCTokenTypeWidget RCTokenType = 291
	// RCTokenTypeWidgetClass: deprecated
	RCTokenTypeWidgetClass RCTokenType = 292
	// RCTokenTypeClass: deprecated
	RCTokenTypeClass RCTokenType = 293
	// RCTokenTypeLowest: deprecated
	RCTokenTypeLowest RCTokenType = 294
	// RCTokenTypeGTK: deprecated
	RCTokenTypeGTK RCTokenType = 295
	// RCTokenTypeApplication: deprecated
	RCTokenTypeApplication RCTokenType = 296
	// RCTokenTypeTheme: deprecated
	RCTokenTypeTheme RCTokenType = 297
	// RCTokenTypeRC: deprecated
	RCTokenTypeRC RCTokenType = 298
	// RCTokenTypeHighest: deprecated
	RCTokenTypeHighest RCTokenType = 299
	// RCTokenTypeEngine: deprecated
	RCTokenTypeEngine RCTokenType = 300
	// RCTokenTypeModulePath: deprecated
	RCTokenTypeModulePath RCTokenType = 301
	// RCTokenTypeImModulePath: deprecated
	RCTokenTypeImModulePath RCTokenType = 302
	// RCTokenTypeImModuleFile: deprecated
	RCTokenTypeImModuleFile RCTokenType = 303
	// RCTokenTypeStock: deprecated
	RCTokenTypeStock RCTokenType = 304
	// RCTokenTypeLTR: deprecated
	RCTokenTypeLTR RCTokenType = 305
	// RCTokenTypeRTL: deprecated
	RCTokenTypeRTL RCTokenType = 306
	// RCTokenTypeColor: deprecated
	RCTokenTypeColor RCTokenType = 307
	// RCTokenTypeUnbind: deprecated
	RCTokenTypeUnbind RCTokenType = 308
	// RCTokenTypeLast: deprecated
	RCTokenTypeLast RCTokenType = 309
)

func marshalRCTokenType(p uintptr) (interface{}, error) {
	return RCTokenType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RecentChooserError: these identify the various errors that can occur while
// calling RecentChooser functions.
type RecentChooserError int

const (
	// RecentChooserErrorNotFound indicates that a file does not exist
	RecentChooserErrorNotFound RecentChooserError = 0
	// RecentChooserErrorInvalidURI indicates a malformed URI
	RecentChooserErrorInvalidURI RecentChooserError = 1
)

func marshalRecentChooserError(p uintptr) (interface{}, error) {
	return RecentChooserError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RecentManagerError: error codes for RecentManager operations
type RecentManagerError int

const (
	// RecentManagerErrorNotFound: the URI specified does not exists in the
	// recently used resources list.
	RecentManagerErrorNotFound RecentManagerError = 0
	// RecentManagerErrorInvalidURI: the URI specified is not valid.
	RecentManagerErrorInvalidURI RecentManagerError = 1
	// RecentManagerErrorInvalidEncoding: the supplied string is not UTF-8
	// encoded.
	RecentManagerErrorInvalidEncoding RecentManagerError = 2
	// RecentManagerErrorNotRegistered: no application has registered the
	// specified item.
	RecentManagerErrorNotRegistered RecentManagerError = 3
	// RecentManagerErrorRead: failure while reading the recently used resources
	// file.
	RecentManagerErrorRead RecentManagerError = 4
	// RecentManagerErrorWrite: failure while writing the recently used
	// resources file.
	RecentManagerErrorWrite RecentManagerError = 5
	// RecentManagerErrorUnknown: unspecified error.
	RecentManagerErrorUnknown RecentManagerError = 6
)

func marshalRecentManagerError(p uintptr) (interface{}, error) {
	return RecentManagerError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RecentSortType: used to specify the sorting method to be applyed to the
// recently used resource list.
type RecentSortType int

const (
	// RecentSortTypeNone: do not sort the returned list of recently used
	// resources.
	RecentSortTypeNone RecentSortType = 0
	// RecentSortTypeMru: sort the returned list with the most recently used
	// items first.
	RecentSortTypeMru RecentSortType = 1
	// RecentSortTypeLru: sort the returned list with the least recently used
	// items first.
	RecentSortTypeLru RecentSortType = 2
	// RecentSortTypeCustom: sort the returned list using a custom sorting
	// function passed using gtk_recent_chooser_set_sort_func().
	RecentSortTypeCustom RecentSortType = 3
)

func marshalRecentSortType(p uintptr) (interface{}, error) {
	return RecentSortType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ReliefStyle: indicated the relief to be drawn around a Button.
type ReliefStyle int

const (
	// ReliefStyleNormal: draw a normal relief.
	ReliefStyleNormal ReliefStyle = 0
	// ReliefStyleHalf: a half relief. Deprecated in 3.14, does the same as
	// @GTK_RELIEF_NORMAL
	ReliefStyleHalf ReliefStyle = 1
	// ReliefStyleNone: no relief.
	ReliefStyleNone ReliefStyle = 2
)

func marshalReliefStyle(p uintptr) (interface{}, error) {
	return ReliefStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

type ResizeMode int

const (
	// ResizeModeParent pass resize request to the parent
	ResizeModeParent ResizeMode = 0
	// ResizeModeQueue: queue resizes on this widget
	ResizeModeQueue ResizeMode = 1
	// ResizeModeImmediate: resize immediately. Deprecated.
	ResizeModeImmediate ResizeMode = 2
)

func marshalResizeMode(p uintptr) (interface{}, error) {
	return ResizeMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResponseType: predefined values for use as response ids in
// gtk_dialog_add_button(). All predefined values are negative; GTK+ leaves
// values of 0 or greater for application-defined response ids.
type ResponseType int

const (
	// ResponseTypeNone: returned if an action widget has no response id, or if
	// the dialog gets programmatically hidden or destroyed
	ResponseTypeNone ResponseType = -1
	// ResponseTypeReject: generic response id, not used by GTK+ dialogs
	ResponseTypeReject ResponseType = -2
	// ResponseTypeAccept: generic response id, not used by GTK+ dialogs
	ResponseTypeAccept ResponseType = -3
	// ResponseTypeDeleteEvent: returned if the dialog is deleted
	ResponseTypeDeleteEvent ResponseType = -4
	// ResponseTypeOk: returned by OK buttons in GTK+ dialogs
	ResponseTypeOk ResponseType = -5
	// ResponseTypeCancel: returned by Cancel buttons in GTK+ dialogs
	ResponseTypeCancel ResponseType = -6
	// ResponseTypeClose: returned by Close buttons in GTK+ dialogs
	ResponseTypeClose ResponseType = -7
	// ResponseTypeYes: returned by Yes buttons in GTK+ dialogs
	ResponseTypeYes ResponseType = -8
	// ResponseTypeNo: returned by No buttons in GTK+ dialogs
	ResponseTypeNo ResponseType = -9
	// ResponseTypeApply: returned by Apply buttons in GTK+ dialogs
	ResponseTypeApply ResponseType = -10
	// ResponseTypeHelp: returned by Help buttons in GTK+ dialogs
	ResponseTypeHelp ResponseType = -11
)

func marshalResponseType(p uintptr) (interface{}, error) {
	return ResponseType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RevealerTransitionType: these enumeration values describe the possible
// transitions when the child of a Revealer widget is shown or hidden.
type RevealerTransitionType int

const (
	// RevealerTransitionTypeNone: no transition
	RevealerTransitionTypeNone RevealerTransitionType = 0
	// RevealerTransitionTypeCrossfade: fade in
	RevealerTransitionTypeCrossfade RevealerTransitionType = 1
	// RevealerTransitionTypeSlideRight: slide in from the left
	RevealerTransitionTypeSlideRight RevealerTransitionType = 2
	// RevealerTransitionTypeSlideLeft: slide in from the right
	RevealerTransitionTypeSlideLeft RevealerTransitionType = 3
	// RevealerTransitionTypeSlideUp: slide in from the bottom
	RevealerTransitionTypeSlideUp RevealerTransitionType = 4
	// RevealerTransitionTypeSlideDown: slide in from the top
	RevealerTransitionTypeSlideDown RevealerTransitionType = 5
)

func marshalRevealerTransitionType(p uintptr) (interface{}, error) {
	return RevealerTransitionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

type ScrollStep int

const (
	// ScrollStepSteps: scroll in steps.
	ScrollStepSteps ScrollStep = 0
	// ScrollStepPages: scroll by pages.
	ScrollStepPages ScrollStep = 1
	// ScrollStepEnds: scroll to ends.
	ScrollStepEnds ScrollStep = 2
	// ScrollStepHorizontalSteps: scroll in horizontal steps.
	ScrollStepHorizontalSteps ScrollStep = 3
	// ScrollStepHorizontalPages: scroll by horizontal pages.
	ScrollStepHorizontalPages ScrollStep = 4
	// ScrollStepHorizontalEnds: scroll to the horizontal ends.
	ScrollStepHorizontalEnds ScrollStep = 5
)

func marshalScrollStep(p uintptr) (interface{}, error) {
	return ScrollStep(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ScrollType: scrolling types.
type ScrollType int

const (
	// ScrollTypeNone: no scrolling.
	ScrollTypeNone ScrollType = 0
	// ScrollTypeJump: jump to new location.
	ScrollTypeJump ScrollType = 1
	// ScrollTypeStepBackward: step backward.
	ScrollTypeStepBackward ScrollType = 2
	// ScrollTypeStepForward: step forward.
	ScrollTypeStepForward ScrollType = 3
	// ScrollTypePageBackward: page backward.
	ScrollTypePageBackward ScrollType = 4
	// ScrollTypePageForward: page forward.
	ScrollTypePageForward ScrollType = 5
	// ScrollTypeStepUp: step up.
	ScrollTypeStepUp ScrollType = 6
	// ScrollTypeStepDown: step down.
	ScrollTypeStepDown ScrollType = 7
	// ScrollTypePageUp: page up.
	ScrollTypePageUp ScrollType = 8
	// ScrollTypePageDown: page down.
	ScrollTypePageDown ScrollType = 9
	// ScrollTypeStepLeft: step to the left.
	ScrollTypeStepLeft ScrollType = 10
	// ScrollTypeStepRight: step to the right.
	ScrollTypeStepRight ScrollType = 11
	// ScrollTypePageLeft: page to the left.
	ScrollTypePageLeft ScrollType = 12
	// ScrollTypePageRight: page to the right.
	ScrollTypePageRight ScrollType = 13
	// ScrollTypeStart: scroll to start.
	ScrollTypeStart ScrollType = 14
	// ScrollTypeEnd: scroll to end.
	ScrollTypeEnd ScrollType = 15
)

func marshalScrollType(p uintptr) (interface{}, error) {
	return ScrollType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ScrollablePolicy defines the policy to be used in a scrollable widget when
// updating the scrolled window adjustments in a given orientation.
type ScrollablePolicy int

const (
	// ScrollablePolicyMinimum: scrollable adjustments are based on the minimum
	// size
	ScrollablePolicyMinimum ScrollablePolicy = 0
	// ScrollablePolicyNatural: scrollable adjustments are based on the natural
	// size
	ScrollablePolicyNatural ScrollablePolicy = 1
)

func marshalScrollablePolicy(p uintptr) (interface{}, error) {
	return ScrollablePolicy(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SelectionMode: used to control what selections users are allowed to make.
type SelectionMode int

const (
	// SelectionModeNone: no selection is possible.
	SelectionModeNone SelectionMode = 0
	// SelectionModeSingle: zero or one element may be selected.
	SelectionModeSingle SelectionMode = 1
	// SelectionModeBrowse: exactly one element is selected. In some
	// circumstances, such as initially or during a search operation, it’s
	// possible for no element to be selected with GTK_SELECTION_BROWSE. What is
	// really enforced is that the user can’t deselect a currently selected
	// element except by selecting another element.
	SelectionModeBrowse SelectionMode = 2
	// SelectionModeMultiple: any number of elements may be selected. The Ctrl
	// key may be used to enlarge the selection, and Shift key to select between
	// the focus and the child pointed to. Some widgets may also allow
	// Click-drag to select a range of elements.
	SelectionModeMultiple SelectionMode = 3
)

func marshalSelectionMode(p uintptr) (interface{}, error) {
	return SelectionMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SensitivityType determines how GTK+ handles the sensitivity of stepper arrows
// at the end of range widgets.
type SensitivityType int

const (
	// SensitivityTypeAuto: the arrow is made insensitive if the thumb is at the
	// end
	SensitivityTypeAuto SensitivityType = 0
	// SensitivityTypeOn: the arrow is always sensitive
	SensitivityTypeOn SensitivityType = 1
	// SensitivityTypeOff: the arrow is always insensitive
	SensitivityTypeOff SensitivityType = 2
)

func marshalSensitivityType(p uintptr) (interface{}, error) {
	return SensitivityType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ShadowType: used to change the appearance of an outline typically provided by
// a Frame.
//
// Note that many themes do not differentiate the appearance of the various
// shadow types: Either their is no visible shadow (@GTK_SHADOW_NONE), or there
// is (any other value).
type ShadowType int

const (
	// ShadowTypeNone: no outline.
	ShadowTypeNone ShadowType = 0
	// ShadowTypeIn: the outline is bevelled inwards.
	ShadowTypeIn ShadowType = 1
	// ShadowTypeOut: the outline is bevelled outwards like a button.
	ShadowTypeOut ShadowType = 2
	// ShadowTypeEtchedIn: the outline has a sunken 3d appearance.
	ShadowTypeEtchedIn ShadowType = 3
	// ShadowTypeEtchedOut: the outline has a raised 3d appearance.
	ShadowTypeEtchedOut ShadowType = 4
)

func marshalShadowType(p uintptr) (interface{}, error) {
	return ShadowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ShortcutType: gtkShortcutType specifies the kind of shortcut that is being
// described. More values may be added to this enumeration over time.
type ShortcutType int

const (
	// ShortcutTypeAccelerator: the shortcut is a keyboard accelerator. The
	// ShortcutsShortcut:accelerator property will be used.
	ShortcutTypeAccelerator ShortcutType = 0
	// ShortcutTypeGesturePinch: the shortcut is a pinch gesture. GTK+ provides
	// an icon and subtitle.
	ShortcutTypeGesturePinch ShortcutType = 1
	// ShortcutTypeGestureStretch: the shortcut is a stretch gesture. GTK+
	// provides an icon and subtitle.
	ShortcutTypeGestureStretch ShortcutType = 2
	// ShortcutTypeGestureRotateClockwise: the shortcut is a clockwise rotation
	// gesture. GTK+ provides an icon and subtitle.
	ShortcutTypeGestureRotateClockwise ShortcutType = 3
	// ShortcutTypeGestureRotateCounterclockwise: the shortcut is a
	// counterclockwise rotation gesture. GTK+ provides an icon and subtitle.
	ShortcutTypeGestureRotateCounterclockwise ShortcutType = 4
	// ShortcutTypeGestureTwoFingerSwipeLeft: the shortcut is a two-finger swipe
	// gesture. GTK+ provides an icon and subtitle.
	ShortcutTypeGestureTwoFingerSwipeLeft ShortcutType = 5
	// ShortcutTypeGestureTwoFingerSwipeRight: the shortcut is a two-finger
	// swipe gesture. GTK+ provides an icon and subtitle.
	ShortcutTypeGestureTwoFingerSwipeRight ShortcutType = 6
	// ShortcutTypeGesture: the shortcut is a gesture. The
	// ShortcutsShortcut:icon property will be used.
	ShortcutTypeGesture ShortcutType = 7
)

func marshalShortcutType(p uintptr) (interface{}, error) {
	return ShortcutType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SizeGroupMode: the mode of the size group determines the directions in which
// the size group affects the requested sizes of its component widgets.
type SizeGroupMode int

const (
	// SizeGroupModeNone: group has no effect
	SizeGroupModeNone SizeGroupMode = 0
	// SizeGroupModeHorizontal: group affects horizontal requisition
	SizeGroupModeHorizontal SizeGroupMode = 1
	// SizeGroupModeVertical: group affects vertical requisition
	SizeGroupModeVertical SizeGroupMode = 2
	// SizeGroupModeBoth: group affects both horizontal and vertical requisition
	SizeGroupModeBoth SizeGroupMode = 3
)

func marshalSizeGroupMode(p uintptr) (interface{}, error) {
	return SizeGroupMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SizeRequestMode specifies a preference for height-for-width or
// width-for-height geometry management.
type SizeRequestMode int

const (
	// SizeRequestModeHeightForWidth: prefer height-for-width geometry
	// management
	SizeRequestModeHeightForWidth SizeRequestMode = 0
	// SizeRequestModeWidthForHeight: prefer width-for-height geometry
	// management
	SizeRequestModeWidthForHeight SizeRequestMode = 1
	// SizeRequestModeConstantSize: don’t trade height-for-width or
	// width-for-height
	SizeRequestModeConstantSize SizeRequestMode = 2
)

func marshalSizeRequestMode(p uintptr) (interface{}, error) {
	return SizeRequestMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SortType determines the direction of a sort.
type SortType int

const (
	// SortTypeAscending: sorting is in ascending order.
	SortTypeAscending SortType = 0
	// SortTypeDescending: sorting is in descending order.
	SortTypeDescending SortType = 1
)

func marshalSortType(p uintptr) (interface{}, error) {
	return SortType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SpinButtonUpdatePolicy: the spin button update policy determines whether the
// spin button displays values even if they are outside the bounds of its
// adjustment. See gtk_spin_button_set_update_policy().
type SpinButtonUpdatePolicy int

const (
	// SpinButtonUpdatePolicyAlways: when refreshing your SpinButton, the value
	// is always displayed
	SpinButtonUpdatePolicyAlways SpinButtonUpdatePolicy = 0
	// SpinButtonUpdatePolicyIfValid: when refreshing your SpinButton, the value
	// is only displayed if it is valid within the bounds of the spin button's
	// adjustment
	SpinButtonUpdatePolicyIfValid SpinButtonUpdatePolicy = 1
)

func marshalSpinButtonUpdatePolicy(p uintptr) (interface{}, error) {
	return SpinButtonUpdatePolicy(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SpinType: the values of the GtkSpinType enumeration are used to specify the
// change to make in gtk_spin_button_spin().
type SpinType int

const (
	// SpinTypeStepForward: increment by the adjustments step increment.
	SpinTypeStepForward SpinType = 0
	// SpinTypeStepBackward: decrement by the adjustments step increment.
	SpinTypeStepBackward SpinType = 1
	// SpinTypePageForward: increment by the adjustments page increment.
	SpinTypePageForward SpinType = 2
	// SpinTypePageBackward: decrement by the adjustments page increment.
	SpinTypePageBackward SpinType = 3
	// SpinTypeHome: go to the adjustments lower bound.
	SpinTypeHome SpinType = 4
	// SpinTypeEnd: go to the adjustments upper bound.
	SpinTypeEnd SpinType = 5
	// SpinTypeUserDefined: change by a specified amount.
	SpinTypeUserDefined SpinType = 6
)

func marshalSpinType(p uintptr) (interface{}, error) {
	return SpinType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// StackTransitionType: these enumeration values describe the possible
// transitions between pages in a Stack widget.
//
// New values may be added to this enumeration over time.
type StackTransitionType int

const (
	// StackTransitionTypeNone: no transition
	StackTransitionTypeNone StackTransitionType = 0
	// StackTransitionTypeCrossfade: a cross-fade
	StackTransitionTypeCrossfade StackTransitionType = 1
	// StackTransitionTypeSlideRight: slide from left to right
	StackTransitionTypeSlideRight StackTransitionType = 2
	// StackTransitionTypeSlideLeft: slide from right to left
	StackTransitionTypeSlideLeft StackTransitionType = 3
	// StackTransitionTypeSlideUp: slide from bottom up
	StackTransitionTypeSlideUp StackTransitionType = 4
	// StackTransitionTypeSlideDown: slide from top down
	StackTransitionTypeSlideDown StackTransitionType = 5
	// StackTransitionTypeSlideLeftRight: slide from left or right according to
	// the children order
	StackTransitionTypeSlideLeftRight StackTransitionType = 6
	// StackTransitionTypeSlideUpDown: slide from top down or bottom up
	// according to the order
	StackTransitionTypeSlideUpDown StackTransitionType = 7
	// StackTransitionTypeOverUp: cover the old page by sliding up. Since 3.12
	StackTransitionTypeOverUp StackTransitionType = 8
	// StackTransitionTypeOverDown: cover the old page by sliding down. Since:
	// 3.12
	StackTransitionTypeOverDown StackTransitionType = 9
	// StackTransitionTypeOverLeft: cover the old page by sliding to the left.
	// Since: 3.12
	StackTransitionTypeOverLeft StackTransitionType = 10
	// StackTransitionTypeOverRight: cover the old page by sliding to the right.
	// Since: 3.12
	StackTransitionTypeOverRight StackTransitionType = 11
	// StackTransitionTypeUnderUp: uncover the new page by sliding up. Since
	// 3.12
	StackTransitionTypeUnderUp StackTransitionType = 12
	// StackTransitionTypeUnderDown: uncover the new page by sliding down.
	// Since: 3.12
	StackTransitionTypeUnderDown StackTransitionType = 13
	// StackTransitionTypeUnderLeft: uncover the new page by sliding to the
	// left. Since: 3.12
	StackTransitionTypeUnderLeft StackTransitionType = 14
	// StackTransitionTypeUnderRight: uncover the new page by sliding to the
	// right. Since: 3.12
	StackTransitionTypeUnderRight StackTransitionType = 15
	// StackTransitionTypeOverUpDown: cover the old page sliding up or uncover
	// the new page sliding down, according to order. Since: 3.12
	StackTransitionTypeOverUpDown StackTransitionType = 16
	// StackTransitionTypeOverDownUp: cover the old page sliding down or uncover
	// the new page sliding up, according to order. Since: 3.14
	StackTransitionTypeOverDownUp StackTransitionType = 17
	// StackTransitionTypeOverLeftRight: cover the old page sliding left or
	// uncover the new page sliding right, according to order. Since: 3.14
	StackTransitionTypeOverLeftRight StackTransitionType = 18
	// StackTransitionTypeOverRightLeft: cover the old page sliding right or
	// uncover the new page sliding left, according to order. Since: 3.14
	StackTransitionTypeOverRightLeft StackTransitionType = 19
)

func marshalStackTransitionType(p uintptr) (interface{}, error) {
	return StackTransitionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// StateType: this type indicates the current state of a widget; the state
// determines how the widget is drawn. The StateType enumeration is also used to
// identify different colors in a Style for drawing, so states can be used for
// subparts of a widget as well as entire widgets.
type StateType int

const (
	// StateTypeNormal: state during normal operation.
	StateTypeNormal StateType = 0
	// StateTypeActive: state of a currently active widget, such as a depressed
	// button.
	StateTypeActive StateType = 1
	// StateTypePrelight: state indicating that the mouse pointer is over the
	// widget and the widget will respond to mouse clicks.
	StateTypePrelight StateType = 2
	// StateTypeSelected: state of a selected item, such the selected row in a
	// list.
	StateTypeSelected StateType = 3
	// StateTypeInsensitive: state indicating that the widget is unresponsive to
	// user actions.
	StateTypeInsensitive StateType = 4
	// StateTypeInconsistent: the widget is inconsistent, such as checkbuttons
	// or radiobuttons that aren’t either set to true nor false, or buttons
	// requiring the user attention.
	StateTypeInconsistent StateType = 5
	// StateTypeFocused: the widget has the keyboard focus.
	StateTypeFocused StateType = 6
)

func marshalStateType(p uintptr) (interface{}, error) {
	return StateType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextBufferTargetInfo: these values are used as “info” for the targets
// contained in the lists returned by gtk_text_buffer_get_copy_target_list() and
// gtk_text_buffer_get_paste_target_list().
//
// The values counts down from `-1` to avoid clashes with application added drag
// destinations which usually start at 0.
type TextBufferTargetInfo int

const (
	// TextBufferTargetInfoBufferContents: buffer contents
	TextBufferTargetInfoBufferContents TextBufferTargetInfo = -1
	// TextBufferTargetInfoRichText: rich text
	TextBufferTargetInfoRichText TextBufferTargetInfo = -2
	// TextBufferTargetInfoText: text
	TextBufferTargetInfoText TextBufferTargetInfo = -3
)

func marshalTextBufferTargetInfo(p uintptr) (interface{}, error) {
	return TextBufferTargetInfo(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextDirection: reading directions for text.
type TextDirection int

const (
	// TextDirectionNone: no direction.
	TextDirectionNone TextDirection = 0
	// TextDirectionLTR: left to right text direction.
	TextDirectionLTR TextDirection = 1
	// TextDirectionRTL: right to left text direction.
	TextDirectionRTL TextDirection = 2
)

func marshalTextDirection(p uintptr) (interface{}, error) {
	return TextDirection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextExtendSelection: granularity types that extend the text selection. Use
// the TextView::extend-selection signal to customize the selection.
type TextExtendSelection int

const (
	// TextExtendSelectionWord selects the current word. It is triggered by a
	// double-click for example.
	TextExtendSelectionWord TextExtendSelection = 0
	// TextExtendSelectionLine selects the current line. It is triggered by a
	// triple-click for example.
	TextExtendSelectionLine TextExtendSelection = 1
)

func marshalTextExtendSelection(p uintptr) (interface{}, error) {
	return TextExtendSelection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextViewLayer: used to reference the layers of TextView for the purpose of
// customized drawing with the ::draw_layer vfunc.
type TextViewLayer int

const (
	// TextViewLayerBelow: old deprecated layer, use
	// GTK_TEXT_VIEW_LAYER_BELOW_TEXT instead
	TextViewLayerBelow TextViewLayer = 0
	// TextViewLayerAbove: old deprecated layer, use
	// GTK_TEXT_VIEW_LAYER_ABOVE_TEXT instead
	TextViewLayerAbove TextViewLayer = 1
	// TextViewLayerBelowText: the layer rendered below the text (but above the
	// background). Since: 3.20
	TextViewLayerBelowText TextViewLayer = 2
	// TextViewLayerAboveText: the layer rendered above the text. Since: 3.20
	TextViewLayerAboveText TextViewLayer = 3
)

func marshalTextViewLayer(p uintptr) (interface{}, error) {
	return TextViewLayer(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextWindowType: used to reference the parts of TextView.
type TextWindowType int

const (
	// TextWindowTypePrivate: invalid value, used as a marker
	TextWindowTypePrivate TextWindowType = 0
	// TextWindowTypeWidget: window that floats over scrolling areas.
	TextWindowTypeWidget TextWindowType = 1
	// TextWindowTypeText: scrollable text window.
	TextWindowTypeText TextWindowType = 2
	// TextWindowTypeLeft: left side border window.
	TextWindowTypeLeft TextWindowType = 3
	// TextWindowTypeRight: right side border window.
	TextWindowTypeRight TextWindowType = 4
	// TextWindowTypeTop: top border window.
	TextWindowTypeTop TextWindowType = 5
	// TextWindowTypeBottom: bottom border window.
	TextWindowTypeBottom TextWindowType = 6
)

func marshalTextWindowType(p uintptr) (interface{}, error) {
	return TextWindowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ToolbarSpaceStyle: whether spacers are vertical lines or just blank.
type ToolbarSpaceStyle int

const (
	// ToolbarSpaceStyleEmpty: use blank spacers.
	ToolbarSpaceStyleEmpty ToolbarSpaceStyle = 0
	// ToolbarSpaceStyleLine: use vertical lines for spacers.
	ToolbarSpaceStyleLine ToolbarSpaceStyle = 1
)

func marshalToolbarSpaceStyle(p uintptr) (interface{}, error) {
	return ToolbarSpaceStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ToolbarStyle: used to customize the appearance of a Toolbar. Note that
// setting the toolbar style overrides the user’s preferences for the default
// toolbar style. Note that if the button has only a label set and
// GTK_TOOLBAR_ICONS is used, the label will be visible, and vice versa.
type ToolbarStyle int

const (
	// ToolbarStyleIcons buttons display only icons in the toolbar.
	ToolbarStyleIcons ToolbarStyle = 0
	// ToolbarStyleText buttons display only text labels in the toolbar.
	ToolbarStyleText ToolbarStyle = 1
	// ToolbarStyleBoth buttons display text and icons in the toolbar.
	ToolbarStyleBoth ToolbarStyle = 2
	// ToolbarStyleBothHoriz buttons display icons and text alongside each
	// other, rather than vertically stacked
	ToolbarStyleBothHoriz ToolbarStyle = 3
)

func marshalToolbarStyle(p uintptr) (interface{}, error) {
	return ToolbarStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TreeViewColumnSizing: the sizing method the column uses to determine its
// width. Please note that @GTK_TREE_VIEW_COLUMN_AUTOSIZE are inefficient for
// large views, and can make columns appear choppy.
type TreeViewColumnSizing int

const (
	// TreeViewColumnSizingGrowOnly columns only get bigger in reaction to
	// changes in the model
	TreeViewColumnSizingGrowOnly TreeViewColumnSizing = 0
	// TreeViewColumnSizingAutosize columns resize to be the optimal size
	// everytime the model changes.
	TreeViewColumnSizingAutosize TreeViewColumnSizing = 1
	// TreeViewColumnSizingFixed columns are a fixed numbers of pixels wide.
	TreeViewColumnSizingFixed TreeViewColumnSizing = 2
)

func marshalTreeViewColumnSizing(p uintptr) (interface{}, error) {
	return TreeViewColumnSizing(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TreeViewDropPosition: an enum for determining where a dropped row goes.
type TreeViewDropPosition int

const (
	// TreeViewDropPositionBefore: dropped row is inserted before
	TreeViewDropPositionBefore TreeViewDropPosition = 0
	// TreeViewDropPositionAfter: dropped row is inserted after
	TreeViewDropPositionAfter TreeViewDropPosition = 1
	// TreeViewDropPositionIntoOrBefore: dropped row becomes a child or is
	// inserted before
	TreeViewDropPositionIntoOrBefore TreeViewDropPosition = 2
	// TreeViewDropPositionIntoOrAfter: dropped row becomes a child or is
	// inserted after
	TreeViewDropPositionIntoOrAfter TreeViewDropPosition = 3
)

func marshalTreeViewDropPosition(p uintptr) (interface{}, error) {
	return TreeViewDropPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TreeViewGridLines: used to indicate which grid lines to draw in a tree view.
type TreeViewGridLines int

const (
	// TreeViewGridLinesNone: no grid lines.
	TreeViewGridLinesNone TreeViewGridLines = 0
	// TreeViewGridLinesHorizontal: horizontal grid lines.
	TreeViewGridLinesHorizontal TreeViewGridLines = 1
	// TreeViewGridLinesVertical: vertical grid lines.
	TreeViewGridLinesVertical TreeViewGridLines = 2
	// TreeViewGridLinesBoth: horizontal and vertical grid lines.
	TreeViewGridLinesBoth TreeViewGridLines = 3
)

func marshalTreeViewGridLines(p uintptr) (interface{}, error) {
	return TreeViewGridLines(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Unit: see also gtk_print_settings_set_paper_width().
type Unit int

const (
	// UnitNone: no units.
	UnitNone Unit = 0
	// UnitPoints dimensions in points.
	UnitPoints Unit = 1
	// UnitInch dimensions in inches.
	UnitInch Unit = 2
	// UnitMm dimensions in millimeters
	UnitMm Unit = 3
)

func marshalUnit(p uintptr) (interface{}, error) {
	return Unit(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// WidgetHelpType kinds of widget-specific help. Used by the ::show-help signal.
type WidgetHelpType int

const (
	// WidgetHelpTypeTooltip: tooltip.
	WidgetHelpTypeTooltip WidgetHelpType = 0
	// WidgetHelpTypeWhatsThis what’s this.
	WidgetHelpTypeWhatsThis WidgetHelpType = 1
)

func marshalWidgetHelpType(p uintptr) (interface{}, error) {
	return WidgetHelpType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// WindowPosition: window placement can be influenced using this enumeration.
// Note that using K_WIN_POS_CENTER_ALWAYS is almost always a bad idea. It won’t
// necessarily work well with all window managers or on all windowing systems.
type WindowPosition int

const (
	// WindowPositionNone: no influence is made on placement.
	WindowPositionNone WindowPosition = 0
	// WindowPositionCenter windows should be placed in the center of the
	// screen.
	WindowPositionCenter WindowPosition = 1
	// WindowPositionMouse windows should be placed at the current mouse
	// position.
	WindowPositionMouse WindowPosition = 2
	// WindowPositionCenterAlways: keep window centered as it changes size, etc.
	WindowPositionCenterAlways WindowPosition = 3
	// WindowPositionCenterOnParent: center the window on its transient parent
	// (see gtk_window_set_transient_for()).
	WindowPositionCenterOnParent WindowPosition = 4
)

func marshalWindowPosition(p uintptr) (interface{}, error) {
	return WindowPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// WindowType: a Window can be one of these types. Most things you’d consider a
// “window” should have type K_WINDOW_TOPLEVEL; windows with this type are
// managed by the window manager and have a frame by default (call
// gtk_window_set_decorated() to toggle the frame). Windows with type
// K_WINDOW_POPUP are ignored by the window manager; window manager keybindings
// won’t work on them, the window manager won’t decorate the window with a
// frame, many GTK+ features that rely on the window manager will not work (e.g.
// resize grips and maximization/minimization). K_WINDOW_POPUP is used to
// implement widgets such as Menu or tooltips that you normally don’t think of
// as windows per se. Nearly all windows should be K_WINDOW_TOPLEVEL. In
// particular, do not use K_WINDOW_POPUP just to turn off the window borders;
// use gtk_window_set_decorated() for that.
type WindowType int

const (
	// WindowTypeToplevel: a regular window, such as a dialog.
	WindowTypeToplevel WindowType = 0
	// WindowTypePopup: a special window such as a tooltip.
	WindowTypePopup WindowType = 1
)

func marshalWindowType(p uintptr) (interface{}, error) {
	return WindowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// WrapMode describes a type of line wrapping.
type WrapMode int

const (
	// WrapModeNone: do not wrap lines; just make the text area wider
	WrapModeNone WrapMode = 0
	// WrapModeChar: wrap text, breaking lines anywhere the cursor can appear
	// (between characters, usually - if you want to be technical, between
	// graphemes, see pango_get_log_attrs())
	WrapModeChar WrapMode = 1
	// WrapModeWord: wrap text, breaking lines in between words
	WrapModeWord WrapMode = 2
	// WrapModeWordChar: wrap text, breaking lines in between words, or if that
	// is not enough, also between graphemes
	WrapModeWordChar WrapMode = 3
)

func marshalWrapMode(p uintptr) (interface{}, error) {
	return WrapMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccelFlags: accelerator flags used with gtk_accel_group_connect().
type AccelFlags int

const (
	// AccelFlagsVisible: accelerator is visible
	AccelFlagsVisible AccelFlags = 0b1
	// AccelFlagsLocked: accelerator not removable
	AccelFlagsLocked AccelFlags = 0b10
	// AccelFlagsMask: mask
	AccelFlagsMask AccelFlags = 0b111
)

func marshalAccelFlags(p uintptr) (interface{}, error) {
	return AccelFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ApplicationInhibitFlags types of user actions that may be blocked by
// gtk_application_inhibit().
type ApplicationInhibitFlags int

const (
	// ApplicationInhibitFlagsLogout: inhibit ending the user session by logging
	// out or by shutting down the computer
	ApplicationInhibitFlagsLogout ApplicationInhibitFlags = 0b1
	// ApplicationInhibitFlagsSwitch: inhibit user switching
	ApplicationInhibitFlagsSwitch ApplicationInhibitFlags = 0b10
	// ApplicationInhibitFlagsSuspend: inhibit suspending the session or
	// computer
	ApplicationInhibitFlagsSuspend ApplicationInhibitFlags = 0b100
	// ApplicationInhibitFlagsIdle: inhibit the session being marked as idle
	// (and possibly locked)
	ApplicationInhibitFlagsIdle ApplicationInhibitFlags = 0b1000
)

func marshalApplicationInhibitFlags(p uintptr) (interface{}, error) {
	return ApplicationInhibitFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AttachOptions denotes the expansion properties that a widget will have when
// it (or its parent) is resized.
type AttachOptions int

const (
	// AttachOptionsExpand: the widget should expand to take up any extra space
	// in its container that has been allocated.
	AttachOptionsExpand AttachOptions = 0b1
	// AttachOptionsShrink: the widget should shrink as and when possible.
	AttachOptionsShrink AttachOptions = 0b10
	// AttachOptionsFill: the widget should fill the space allocated to it.
	AttachOptionsFill AttachOptions = 0b100
)

func marshalAttachOptions(p uintptr) (interface{}, error) {
	return AttachOptions(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CalendarDisplayOptions: these options can be used to influence the display
// and behaviour of a Calendar.
type CalendarDisplayOptions int

const (
	// CalendarDisplayOptionsShowHeading specifies that the month and year
	// should be displayed.
	CalendarDisplayOptionsShowHeading CalendarDisplayOptions = 0b1
	// CalendarDisplayOptionsShowDayNames specifies that three letter day
	// descriptions should be present.
	CalendarDisplayOptionsShowDayNames CalendarDisplayOptions = 0b10
	// CalendarDisplayOptionsNoMonthChange prevents the user from switching
	// months with the calendar.
	CalendarDisplayOptionsNoMonthChange CalendarDisplayOptions = 0b100
	// CalendarDisplayOptionsShowWeekNumbers displays each week numbers of the
	// current year, down the left side of the calendar.
	CalendarDisplayOptionsShowWeekNumbers CalendarDisplayOptions = 0b1000
	// CalendarDisplayOptionsShowDetails: just show an indicator, not the full
	// details text when details are provided. See
	// gtk_calendar_set_detail_func().
	CalendarDisplayOptionsShowDetails CalendarDisplayOptions = 0b100000
)

func marshalCalendarDisplayOptions(p uintptr) (interface{}, error) {
	return CalendarDisplayOptions(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CellRendererState tells how a cell is to be rendered.
type CellRendererState int

const (
	// CellRendererStateSelected: the cell is currently selected, and probably
	// has a selection colored background to render to.
	CellRendererStateSelected CellRendererState = 0b1
	// CellRendererStatePrelit: the mouse is hovering over the cell.
	CellRendererStatePrelit CellRendererState = 0b10
	// CellRendererStateInsensitive: the cell is drawn in an insensitive manner
	CellRendererStateInsensitive CellRendererState = 0b100
	// CellRendererStateSorted: the cell is in a sorted row
	CellRendererStateSorted CellRendererState = 0b1000
	// CellRendererStateFocused: the cell is in the focus row.
	CellRendererStateFocused CellRendererState = 0b10000
	// CellRendererStateExpandable: the cell is in a row that can be expanded.
	// Since 3.4
	CellRendererStateExpandable CellRendererState = 0b100000
	// CellRendererStateExpanded: the cell is in a row that is expanded. Since
	// 3.4
	CellRendererStateExpanded CellRendererState = 0b1000000
)

func marshalCellRendererState(p uintptr) (interface{}, error) {
	return CellRendererState(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

type DebugFlag int

const (
	DebugFlagMisc DebugFlag = 0b1

	DebugFlagPlugsocket DebugFlag = 0b10

	DebugFlagText DebugFlag = 0b100

	DebugFlagTree DebugFlag = 0b1000

	DebugFlagUpdates DebugFlag = 0b10000

	DebugFlagKeybindings DebugFlag = 0b100000

	DebugFlagMultihead DebugFlag = 0b1000000

	DebugFlagModules DebugFlag = 0b10000000

	DebugFlagGeometry DebugFlag = 0b100000000

	DebugFlagIcontheme DebugFlag = 0b1000000000

	DebugFlagPrinting DebugFlag = 0b10000000000

	DebugFlagBuilder DebugFlag = 0b100000000000

	DebugFlagSizeRequest DebugFlag = 0b1000000000000

	DebugFlagNoCSSCache DebugFlag = 0b10000000000000

	DebugFlagBaselines DebugFlag = 0b100000000000000

	DebugFlagPixelCache DebugFlag = 0b1000000000000000

	DebugFlagNoPixelCache DebugFlag = 0b10000000000000000

	DebugFlagInteractive DebugFlag = 0b100000000000000000

	DebugFlagTouchscreen DebugFlag = 0b1000000000000000000

	DebugFlagActions DebugFlag = 0b10000000000000000000

	DebugFlagResize DebugFlag = 0b100000000000000000000

	DebugFlagLayout DebugFlag = 0b1000000000000000000000
)

func marshalDebugFlag(p uintptr) (interface{}, error) {
	return DebugFlag(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DestDefaults: the DestDefaults enumeration specifies the various types of
// action that will be taken on behalf of the user for a drag destination site.
type DestDefaults int

const (
	// DestDefaultsMotion: if set for a widget, GTK+, during a drag over this
	// widget will check if the drag matches this widget’s list of possible
	// targets and actions. GTK+ will then call gdk_drag_status() as
	// appropriate.
	DestDefaultsMotion DestDefaults = 0b1
	// DestDefaultsHighlight: if set for a widget, GTK+ will draw a highlight on
	// this widget as long as a drag is over this widget and the widget drag
	// format and action are acceptable.
	DestDefaultsHighlight DestDefaults = 0b10
	// DestDefaultsDrop: if set for a widget, when a drop occurs, GTK+ will will
	// check if the drag matches this widget’s list of possible targets and
	// actions. If so, GTK+ will call gtk_drag_get_data() on behalf of the
	// widget. Whether or not the drop is successful, GTK+ will call
	// gtk_drag_finish(). If the action was a move, then if the drag was
	// successful, then true will be passed for the @delete parameter to
	// gtk_drag_finish().
	DestDefaultsDrop DestDefaults = 0b100
	// DestDefaultsAll: if set, specifies that all default actions should be
	// taken.
	DestDefaultsAll DestDefaults = 0b111
)

func marshalDestDefaults(p uintptr) (interface{}, error) {
	return DestDefaults(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DialogFlags flags used to influence dialog construction.
type DialogFlags int

const (
	// DialogFlagsModal: make the constructed dialog modal, see
	// gtk_window_set_modal()
	DialogFlagsModal DialogFlags = 0b1
	// DialogFlagsDestroyWithParent: destroy the dialog when its parent is
	// destroyed, see gtk_window_set_destroy_with_parent()
	DialogFlagsDestroyWithParent DialogFlags = 0b10
	// DialogFlagsUseHeaderBar: create dialog with actions in header bar instead
	// of action area. Since 3.12.
	DialogFlagsUseHeaderBar DialogFlags = 0b100
)

func marshalDialogFlags(p uintptr) (interface{}, error) {
	return DialogFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EventControllerScrollFlags describes the behavior of a EventControllerScroll.
type EventControllerScrollFlags int

const (
	// EventControllerScrollFlagsNone: don't emit scroll.
	EventControllerScrollFlagsNone EventControllerScrollFlags = 0b0
	// EventControllerScrollFlagsVertical: emit scroll with vertical deltas.
	EventControllerScrollFlagsVertical EventControllerScrollFlags = 0b1
	// EventControllerScrollFlagsHorizontal: emit scroll with horizontal deltas.
	EventControllerScrollFlagsHorizontal EventControllerScrollFlags = 0b10
	// EventControllerScrollFlagsDiscrete: only emit deltas that are multiples
	// of 1.
	EventControllerScrollFlagsDiscrete EventControllerScrollFlags = 0b100
	// EventControllerScrollFlagsKinetic: emit EventControllerScroll::decelerate
	// after continuous scroll finishes.
	EventControllerScrollFlagsKinetic EventControllerScrollFlags = 0b1000
	// EventControllerScrollFlagsBothAxes: emit scroll on both axes.
	EventControllerScrollFlagsBothAxes EventControllerScrollFlags = 0b11
)

func marshalEventControllerScrollFlags(p uintptr) (interface{}, error) {
	return EventControllerScrollFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileFilterFlags: these flags indicate what parts of a FileFilterInfo struct
// are filled or need to be filled.
type FileFilterFlags int

const (
	// FileFilterFlagsFilename: the filename of the file being tested
	FileFilterFlagsFilename FileFilterFlags = 0b1
	// FileFilterFlagsURI: the URI for the file being tested
	FileFilterFlagsURI FileFilterFlags = 0b10
	// FileFilterFlagsDisplayName: the string that will be used to display the
	// file in the file chooser
	FileFilterFlagsDisplayName FileFilterFlags = 0b100
	// FileFilterFlagsMIMEType: the mime type of the file
	FileFilterFlagsMIMEType FileFilterFlags = 0b1000
)

func marshalFileFilterFlags(p uintptr) (interface{}, error) {
	return FileFilterFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FontChooserLevel: this enumeration specifies the granularity of font
// selection that is desired in a font chooser.
//
// This enumeration may be extended in the future; applications should ignore
// unknown values.
type FontChooserLevel int

const (
	// FontChooserLevelFamily: allow selecting a font family
	FontChooserLevelFamily FontChooserLevel = 0b0
	// FontChooserLevelStyle: allow selecting a specific font face
	FontChooserLevelStyle FontChooserLevel = 0b1
	// FontChooserLevelSize: allow selecting a specific font size
	FontChooserLevelSize FontChooserLevel = 0b10

	FontChooserLevelVariations FontChooserLevel = 0b100
	// FontChooserLevelFeatures: allow selecting specific OpenType font features
	FontChooserLevelFeatures FontChooserLevel = 0b1000
)

func marshalFontChooserLevel(p uintptr) (interface{}, error) {
	return FontChooserLevel(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconLookupFlags: used to specify options for gtk_icon_theme_lookup_icon()
type IconLookupFlags int

const (
	// IconLookupFlagsNoSvg: never get SVG icons, even if gdk-pixbuf supports
	// them. Cannot be used together with GTK_ICON_LOOKUP_FORCE_SVG.
	IconLookupFlagsNoSvg IconLookupFlags = 0b1
	// IconLookupFlagsForceSvg: get SVG icons, even if gdk-pixbuf doesn’t
	// support them. Cannot be used together with GTK_ICON_LOOKUP_NO_SVG.
	IconLookupFlagsForceSvg IconLookupFlags = 0b10
	// IconLookupFlagsUseBuiltin: when passed to gtk_icon_theme_lookup_icon()
	// includes builtin icons as well as files. For a builtin icon,
	// gtk_icon_info_get_filename() is nil and you need to call
	// gtk_icon_info_get_builtin_pixbuf().
	IconLookupFlagsUseBuiltin IconLookupFlags = 0b100
	// IconLookupFlagsGenericFallback: try to shorten icon name at '-'
	// characters before looking at inherited themes. This flag is only
	// supported in functions that take a single icon name. For more general
	// fallback, see gtk_icon_theme_choose_icon(). Since 2.12.
	IconLookupFlagsGenericFallback IconLookupFlags = 0b1000
	// IconLookupFlagsForceSize always get the icon scaled to the requested
	// size. Since 2.14.
	IconLookupFlagsForceSize IconLookupFlags = 0b10000
	// IconLookupFlagsForceRegular: try to always load regular icons, even when
	// symbolic icon names are given. Since 3.14.
	IconLookupFlagsForceRegular IconLookupFlags = 0b100000
	// IconLookupFlagsForceSymbolic: try to always load symbolic icons, even
	// when regular icon names are given. Since 3.14.
	IconLookupFlagsForceSymbolic IconLookupFlags = 0b1000000
	// IconLookupFlagsDirLTR: try to load a variant of the icon for
	// left-to-right text direction. Since 3.14.
	IconLookupFlagsDirLTR IconLookupFlags = 0b10000000
	// IconLookupFlagsDirRTL: try to load a variant of the icon for
	// right-to-left text direction. Since 3.14.
	IconLookupFlagsDirRTL IconLookupFlags = 0b100000000
)

func marshalIconLookupFlags(p uintptr) (interface{}, error) {
	return IconLookupFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// InputHints describes hints that might be taken into account by input methods
// or applications. Note that input methods may already tailor their behaviour
// according to the InputPurpose of the entry.
//
// Some common sense is expected when using these flags - mixing
// @GTK_INPUT_HINT_LOWERCASE with any of the uppercase hints makes no sense.
//
// This enumeration may be extended in the future; input methods should ignore
// unknown values.
type InputHints int

const (
	// InputHintsNone: no special behaviour suggested
	InputHintsNone InputHints = 0b0
	// InputHintsSpellcheck: suggest checking for typos
	InputHintsSpellcheck InputHints = 0b1
	// InputHintsNoSpellcheck: suggest not checking for typos
	InputHintsNoSpellcheck InputHints = 0b10
	// InputHintsWordCompletion: suggest word completion
	InputHintsWordCompletion InputHints = 0b100
	// InputHintsLowercase: suggest to convert all text to lowercase
	InputHintsLowercase InputHints = 0b1000
	// InputHintsUppercaseChars: suggest to capitalize all text
	InputHintsUppercaseChars InputHints = 0b10000
	// InputHintsUppercaseWords: suggest to capitalize the first character of
	// each word
	InputHintsUppercaseWords InputHints = 0b100000
	// InputHintsUppercaseSentences: suggest to capitalize the first word of
	// each sentence
	InputHintsUppercaseSentences InputHints = 0b1000000
	// InputHintsInhibitOsk: suggest to not show an onscreen keyboard (e.g for a
	// calculator that already has all the keys).
	InputHintsInhibitOsk InputHints = 0b10000000
	// InputHintsVerticalWriting: the text is vertical. Since 3.18
	InputHintsVerticalWriting InputHints = 0b100000000
	// InputHintsEmoji: suggest offering Emoji support. Since 3.22.20
	InputHintsEmoji InputHints = 0b1000000000
	// InputHintsNoEmoji: suggest not offering Emoji support. Since 3.22.20
	InputHintsNoEmoji InputHints = 0b10000000000
)

func marshalInputHints(p uintptr) (interface{}, error) {
	return InputHints(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// JunctionSides describes how a rendered element connects to adjacent elements.
type JunctionSides int

const (
	// JunctionSidesNone: no junctions.
	JunctionSidesNone JunctionSides = 0b0
	// JunctionSidesCornerTopleft: element connects on the top-left corner.
	JunctionSidesCornerTopleft JunctionSides = 0b1
	// JunctionSidesCornerTopright: element connects on the top-right corner.
	JunctionSidesCornerTopright JunctionSides = 0b10
	// JunctionSidesCornerBottomleft: element connects on the bottom-left
	// corner.
	JunctionSidesCornerBottomleft JunctionSides = 0b100
	// JunctionSidesCornerBottomright: element connects on the bottom-right
	// corner.
	JunctionSidesCornerBottomright JunctionSides = 0b1000
	// JunctionSidesTop: element connects on the top side.
	JunctionSidesTop JunctionSides = 0b11
	// JunctionSidesBottom: element connects on the bottom side.
	JunctionSidesBottom JunctionSides = 0b1100
	// JunctionSidesLeft: element connects on the left side.
	JunctionSidesLeft JunctionSides = 0b101
	// JunctionSidesRight: element connects on the right side.
	JunctionSidesRight JunctionSides = 0b1010
)

func marshalJunctionSides(p uintptr) (interface{}, error) {
	return JunctionSides(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PlacesOpenFlags: these flags serve two purposes. First, the application can
// call gtk_places_sidebar_set_open_flags() using these flags as a bitmask. This
// tells the sidebar that the application is able to open folders selected from
// the sidebar in various ways, for example, in new tabs or in new windows in
// addition to the normal mode.
//
// Second, when one of these values gets passed back to the application in the
// PlacesSidebar::open-location signal, it means that the application should
// open the selected location in the normal way, in a new tab, or in a new
// window. The sidebar takes care of determining the desired way to open the
// location, based on the modifier keys that the user is pressing at the time
// the selection is made.
//
// If the application never calls gtk_places_sidebar_set_open_flags(), then the
// sidebar will only use K_PLACES_OPEN_NORMAL in the
// PlacesSidebar::open-location signal. This is the default mode of operation.
type PlacesOpenFlags int

const (
	// PlacesOpenFlagsNormal: this is the default mode that PlacesSidebar uses
	// if no other flags are specified. It indicates that the calling
	// application should open the selected location in the normal way, for
	// example, in the folder view beside the sidebar.
	PlacesOpenFlagsNormal PlacesOpenFlags = 0b1
	// PlacesOpenFlagsNewTab: when passed to
	// gtk_places_sidebar_set_open_flags(), this indicates that the application
	// can open folders selected from the sidebar in new tabs. This value will
	// be passed to the PlacesSidebar::open-location signal when the user
	// selects that a location be opened in a new tab instead of in the standard
	// fashion.
	PlacesOpenFlagsNewTab PlacesOpenFlags = 0b10
	// PlacesOpenFlagsNewWindow: similar to @GTK_PLACES_OPEN_NEW_TAB, but
	// indicates that the application can open folders in new windows.
	PlacesOpenFlagsNewWindow PlacesOpenFlags = 0b100
)

func marshalPlacesOpenFlags(p uintptr) (interface{}, error) {
	return PlacesOpenFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RCFlags: deprecated
type RCFlags int

const (
	// RCFlagsFg: deprecated
	RCFlagsFg RCFlags = 0b1
	// RCFlagsBg: deprecated
	RCFlagsBg RCFlags = 0b10
	// RCFlagsText: deprecated
	RCFlagsText RCFlags = 0b100
	// RCFlagsBase: deprecated
	RCFlagsBase RCFlags = 0b1000
)

func marshalRCFlags(p uintptr) (interface{}, error) {
	return RCFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RecentFilterFlags: these flags indicate what parts of a RecentFilterInfo
// struct are filled or need to be filled.
type RecentFilterFlags int

const (
	// RecentFilterFlagsURI: the URI of the file being tested
	RecentFilterFlagsURI RecentFilterFlags = 0b1
	// RecentFilterFlagsDisplayName: the string that will be used to display the
	// file in the recent chooser
	RecentFilterFlagsDisplayName RecentFilterFlags = 0b10
	// RecentFilterFlagsMIMEType: the mime type of the file
	RecentFilterFlagsMIMEType RecentFilterFlags = 0b100
	// RecentFilterFlagsApplication: the list of applications that have
	// registered the file
	RecentFilterFlagsApplication RecentFilterFlags = 0b1000
	// RecentFilterFlagsGroup: the groups to which the file belongs to
	RecentFilterFlagsGroup RecentFilterFlags = 0b10000
	// RecentFilterFlagsAge: the number of days elapsed since the file has been
	// registered
	RecentFilterFlagsAge RecentFilterFlags = 0b100000
)

func marshalRecentFilterFlags(p uintptr) (interface{}, error) {
	return RecentFilterFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RegionFlags describes a region within a widget.
type RegionFlags int

const (
	// RegionFlagsEven: region has an even number within a set.
	RegionFlagsEven RegionFlags = 0b1
	// RegionFlagsOdd: region has an odd number within a set.
	RegionFlagsOdd RegionFlags = 0b10
	// RegionFlagsFirst: region is the first one within a set.
	RegionFlagsFirst RegionFlags = 0b100
	// RegionFlagsLast: region is the last one within a set.
	RegionFlagsLast RegionFlags = 0b1000
	// RegionFlagsOnly: region is the only one within a set.
	RegionFlagsOnly RegionFlags = 0b10000
	// RegionFlagsSorted: region is part of a sorted area.
	RegionFlagsSorted RegionFlags = 0b100000
)

func marshalRegionFlags(p uintptr) (interface{}, error) {
	return RegionFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// StateFlags describes a widget state. Widget states are used to match the
// widget against CSS pseudo-classes. Note that GTK extends the regular CSS
// classes and sometimes uses different names.
type StateFlags int

const (
	// StateFlagsNormal: state during normal operation.
	StateFlagsNormal StateFlags = 0b0
	// StateFlagsActive: widget is active.
	StateFlagsActive StateFlags = 0b1
	// StateFlagsPrelight: widget has a mouse pointer over it.
	StateFlagsPrelight StateFlags = 0b10
	// StateFlagsSelected: widget is selected.
	StateFlagsSelected StateFlags = 0b100
	// StateFlagsInsensitive: widget is insensitive.
	StateFlagsInsensitive StateFlags = 0b1000
	// StateFlagsInconsistent: widget is inconsistent.
	StateFlagsInconsistent StateFlags = 0b10000
	// StateFlagsFocused: widget has the keyboard focus.
	StateFlagsFocused StateFlags = 0b100000
	// StateFlagsBackdrop: widget is in a background toplevel window.
	StateFlagsBackdrop StateFlags = 0b1000000
	// StateFlagsDirLTR: widget is in left-to-right text direction. Since 3.8
	StateFlagsDirLTR StateFlags = 0b10000000
	// StateFlagsDirRTL: widget is in right-to-left text direction. Since 3.8
	StateFlagsDirRTL StateFlags = 0b100000000
	// StateFlagsLink: widget is a link. Since 3.12
	StateFlagsLink StateFlags = 0b1000000000
	// StateFlagsVisited: the location the widget points to has already been
	// visited. Since 3.12
	StateFlagsVisited StateFlags = 0b10000000000
	// StateFlagsChecked: widget is checked. Since 3.14
	StateFlagsChecked StateFlags = 0b100000000000
	// StateFlagsDropActive: widget is highlighted as a drop target for DND.
	// Since 3.20
	StateFlagsDropActive StateFlags = 0b1000000000000
)

func marshalStateFlags(p uintptr) (interface{}, error) {
	return StateFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// StyleContextPrintFlags flags that modify the behavior of
// gtk_style_context_to_string(). New values may be added to this enumeration.
type StyleContextPrintFlags int

const (
	StyleContextPrintFlagsNone StyleContextPrintFlags = 0b0
	// StyleContextPrintFlagsRecurse: print the entire tree of CSS nodes
	// starting at the style context's node
	StyleContextPrintFlagsRecurse StyleContextPrintFlags = 0b1
	// StyleContextPrintFlagsShowStyle: show the values of the CSS properties
	// for each node
	StyleContextPrintFlagsShowStyle StyleContextPrintFlags = 0b10
)

func marshalStyleContextPrintFlags(p uintptr) (interface{}, error) {
	return StyleContextPrintFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TargetFlags: the TargetFlags enumeration is used to specify constraints on a
// TargetEntry.
type TargetFlags int

const (
	// TargetFlagsSameApp: if this is set, the target will only be selected for
	// drags within a single application.
	TargetFlagsSameApp TargetFlags = 0b1
	// TargetFlagsSameWidget: if this is set, the target will only be selected
	// for drags within a single widget.
	TargetFlagsSameWidget TargetFlags = 0b10
	// TargetFlagsOtherApp: if this is set, the target will not be selected for
	// drags within a single application.
	TargetFlagsOtherApp TargetFlags = 0b100
	// TargetFlagsOtherWidget: if this is set, the target will not be selected
	// for drags withing a single widget.
	TargetFlagsOtherWidget TargetFlags = 0b1000
)

func marshalTargetFlags(p uintptr) (interface{}, error) {
	return TargetFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextSearchFlags flags affecting how a search is done.
//
// If neither K_TEXT_SEARCH_VISIBLE_ONLY nor K_TEXT_SEARCH_TEXT_ONLY are
// enabled, the match must be exact; the special 0xFFFC character will match
// embedded pixbufs or child widgets.
type TextSearchFlags int

const (
	// TextSearchFlagsVisibleOnly: search only visible data. A search match may
	// have invisible text interspersed.
	TextSearchFlagsVisibleOnly TextSearchFlags = 0b1
	// TextSearchFlagsTextOnly: search only text. A match may have pixbufs or
	// child widgets mixed inside the matched range.
	TextSearchFlagsTextOnly TextSearchFlags = 0b10
	// TextSearchFlagsCaseInsensitive: the text will be matched regardless of
	// what case it is in.
	TextSearchFlagsCaseInsensitive TextSearchFlags = 0b100
)

func marshalTextSearchFlags(p uintptr) (interface{}, error) {
	return TextSearchFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ToolPaletteDragTargets flags used to specify the supported drag targets.
type ToolPaletteDragTargets int

const (
	// ToolPaletteDragTargetsItems: support drag of items.
	ToolPaletteDragTargetsItems ToolPaletteDragTargets = 0b1
	// ToolPaletteDragTargetsGroups: support drag of groups.
	ToolPaletteDragTargetsGroups ToolPaletteDragTargets = 0b10
)

func marshalToolPaletteDragTargets(p uintptr) (interface{}, error) {
	return ToolPaletteDragTargets(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TreeModelFlags: these flags indicate various properties of a TreeModel.
//
// They are returned by gtk_tree_model_get_flags(), and must be static for the
// lifetime of the object. A more complete description of
// K_TREE_MODEL_ITERS_PERSIST can be found in the overview of this section.
type TreeModelFlags int

const (
	// TreeModelFlagsItersPersist iterators survive all signals emitted by the
	// tree
	TreeModelFlagsItersPersist TreeModelFlags = 0b1
	// TreeModelFlagsListOnly: the model is a list only, and never has children
	TreeModelFlagsListOnly TreeModelFlags = 0b10
)

func marshalTreeModelFlags(p uintptr) (interface{}, error) {
	return TreeModelFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// UIManagerItemType: these enumeration values are used by
// gtk_ui_manager_add_ui() to determine what UI element to create.
type UIManagerItemType int

const (
	// UIManagerItemTypeAuto: pick the type of the UI element according to
	// context.
	UIManagerItemTypeAuto UIManagerItemType = 0b0
	// UIManagerItemTypeMenubar: create a menubar.
	UIManagerItemTypeMenubar UIManagerItemType = 0b1
	// UIManagerItemTypeMenu: create a menu.
	UIManagerItemTypeMenu UIManagerItemType = 0b10
	// UIManagerItemTypeToolbar: create a toolbar.
	UIManagerItemTypeToolbar UIManagerItemType = 0b100
	// UIManagerItemTypePlaceholder: insert a placeholder.
	UIManagerItemTypePlaceholder UIManagerItemType = 0b1000
	// UIManagerItemTypePopup: create a popup menu.
	UIManagerItemTypePopup UIManagerItemType = 0b10000
	// UIManagerItemTypeMenuitem: create a menuitem.
	UIManagerItemTypeMenuitem UIManagerItemType = 0b100000
	// UIManagerItemTypeToolitem: create a toolitem.
	UIManagerItemTypeToolitem UIManagerItemType = 0b1000000
	// UIManagerItemTypeSeparator: create a separator.
	UIManagerItemTypeSeparator UIManagerItemType = 0b10000000
	// UIManagerItemTypeAccelerator: install an accelerator.
	UIManagerItemTypeAccelerator UIManagerItemType = 0b100000000
	// UIManagerItemTypePopupWithAccels: same as GTK_UI_MANAGER_POPUP, but the
	// actions’ accelerators are shown.
	UIManagerItemTypePopupWithAccels UIManagerItemType = 0b1000000000
)

func marshalUIManagerItemType(p uintptr) (interface{}, error) {
	return UIManagerItemType(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AssistantPageFunc: a function used by gtk_assistant_set_forward_page_func()
// to know which is the next page given a current one. It’s called both for
// computing the next page when the user presses the “forward” button and for
// handling the behavior of the “last” button.
type AssistantPageFunc func(currentPage int) int

//export gotk4_AssistantPageFunc
func gotk4_AssistantPageFunc(arg0 C.gint, arg1 C.gpointer) C.gint {
	v := box.Get(uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var currentPage int

	currentPage = int(arg0)

	gint := v.(AssistantPageFunc)(currentPage)
}

// BuilderConnectFunc: this is the signature of a function used to connect
// signals. It is used by the gtk_builder_connect_signals() and
// gtk_builder_connect_signals_full() methods. It is mainly intended for
// interpreted language bindings, but could be useful where the programmer wants
// more control over the signal connection process. Note that this function can
// only be called once, subsequent calls will do nothing.
type BuilderConnectFunc func(builder Builder, object gextras.Objector, signalName string, handlerName string, connectObject gextras.Objector, flags gobject.ConnectFlags)

//export gotk4_BuilderConnectFunc
func gotk4_BuilderConnectFunc(arg0 *C.GtkBuilder, arg1 *C.GObject, arg2 *C.gchar, arg3 *C.gchar, arg4 *C.GObject, arg5 C.GConnectFlags, arg6 C.gpointer) {
	v := box.Get(uintptr(arg6))
	if v == nil {
		panic(`callback not found`)
	}

	var builder Builder
	var object gextras.Objector
	var signalName string
	var handlerName string
	var connectObject gextras.Objector
	var flags gobject.ConnectFlags

	builder = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(Builder)

	object = gextras.CastObject(externglib.Take(unsafe.Pointer(arg1.Native()))).(gextras.Objector)

	signalName = C.GoString(arg2)

	handlerName = C.GoString(arg3)

	connectObject = gextras.CastObject(externglib.Take(unsafe.Pointer(arg4.Native()))).(gextras.Objector)

	flags = gobject.ConnectFlags(arg5)

	v.(BuilderConnectFunc)(builder, object, signalName, handlerName, connectObject, flags)
}

// CalendarDetailFunc: this kind of functions provide Pango markup with detail
// information for the specified day. Examples for such details are holidays or
// appointments. The function returns nil when no information is available.
type CalendarDetailFunc func(calendar Calendar, year uint, month uint, day uint) string

//export gotk4_CalendarDetailFunc
func gotk4_CalendarDetailFunc(arg0 *C.GtkCalendar, arg1 C.guint, arg2 C.guint, arg3 C.guint, arg4 C.gpointer) *C.gchar {
	v := box.Get(uintptr(arg4))
	if v == nil {
		panic(`callback not found`)
	}

	var calendar Calendar
	var year uint
	var month uint
	var day uint

	calendar = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(Calendar)

	year = uint(arg1)

	month = uint(arg2)

	day = uint(arg3)

	utf8 := v.(CalendarDetailFunc)(calendar, year, month, day)
}

// Callback: the type of the callback functions used for e.g. iterating over the
// children of a container, see gtk_container_foreach().
type Callback func(widget Widget)

//export gotk4_Callback
func gotk4_Callback(arg0 *C.GtkWidget, arg1 C.gpointer) {
	v := box.Get(uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var widget Widget

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(Widget)

	v.(Callback)(widget)
}

// CellAllocCallback: the type of the callback functions used for iterating over
// the cell renderers and their allocated areas inside a CellArea, see
// gtk_cell_area_foreach_alloc().
type CellAllocCallback func(renderer CellRenderer, cellArea *gdk.Rectangle, cellBackground *gdk.Rectangle) bool

//export gotk4_CellAllocCallback
func gotk4_CellAllocCallback(arg0 *C.GtkCellRenderer, arg1 *C.GdkRectangle, arg2 *C.GdkRectangle, arg3 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg3))
	if v == nil {
		panic(`callback not found`)
	}

	var renderer CellRenderer
	var cellArea *gdk.Rectangle
	var cellBackground *gdk.Rectangle

	renderer = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(CellRenderer)

	{
		cellArea = gdk.WrapRectangle(unsafe.Pointer(arg1))
	}

	{
		cellBackground = gdk.WrapRectangle(unsafe.Pointer(arg2))
	}

	ok := v.(CellAllocCallback)(renderer, cellArea, cellBackground)
}

// CellCallback: the type of the callback functions used for iterating over the
// cell renderers of a CellArea, see gtk_cell_area_foreach().
type CellCallback func(renderer CellRenderer) bool

//export gotk4_CellCallback
func gotk4_CellCallback(arg0 *C.GtkCellRenderer, arg1 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var renderer CellRenderer

	renderer = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(CellRenderer)

	ok := v.(CellCallback)(renderer)
}

// CellLayoutDataFunc: a function which should set the value of @cell_layout’s
// cell renderer(s) as appropriate.
type CellLayoutDataFunc func(cellLayout CellLayout, cell CellRenderer, treeModel TreeModel, iter *TreeIter)

//export gotk4_CellLayoutDataFunc
func gotk4_CellLayoutDataFunc(arg0 *C.GtkCellLayout, arg1 *C.GtkCellRenderer, arg2 *C.GtkTreeModel, arg3 *C.GtkTreeIter, arg4 C.gpointer) {
	v := box.Get(uintptr(arg4))
	if v == nil {
		panic(`callback not found`)
	}

	var cellLayout CellLayout
	var cell CellRenderer
	var treeModel TreeModel
	var iter *TreeIter

	cellLayout = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(CellLayout)

	cell = gextras.CastObject(externglib.Take(unsafe.Pointer(arg1.Native()))).(CellRenderer)

	treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(arg2.Native()))).(TreeModel)

	{
		iter = WrapTreeIter(unsafe.Pointer(arg3))
	}

	v.(CellLayoutDataFunc)(cellLayout, cell, treeModel, iter)
}

// ClipboardImageReceivedFunc: a function to be called when the results of
// gtk_clipboard_request_image() are received, or when the request fails.
type ClipboardImageReceivedFunc func(clipboard Clipboard, pixbuf gdkpixbuf.Pixbuf)

//export gotk4_ClipboardImageReceivedFunc
func gotk4_ClipboardImageReceivedFunc(arg0 *C.GtkClipboard, arg1 *C.GdkPixbuf, arg2 C.gpointer) {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var clipboard Clipboard
	var pixbuf gdkpixbuf.Pixbuf

	clipboard = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(Clipboard)

	pixbuf = gextras.CastObject(externglib.Take(unsafe.Pointer(arg1.Native()))).(gdkpixbuf.Pixbuf)

	v.(ClipboardImageReceivedFunc)(clipboard, pixbuf)
}

// ClipboardReceivedFunc: a function to be called when the results of
// gtk_clipboard_request_contents() are received, or when the request fails.
type ClipboardReceivedFunc func(clipboard Clipboard, selectionData *SelectionData)

//export gotk4_ClipboardReceivedFunc
func gotk4_ClipboardReceivedFunc(arg0 *C.GtkClipboard, arg1 *C.GtkSelectionData, arg2 C.gpointer) {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var clipboard Clipboard
	var selectionData *SelectionData

	clipboard = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(Clipboard)

	{
		selectionData = WrapSelectionData(unsafe.Pointer(arg1))
	}

	v.(ClipboardReceivedFunc)(clipboard, selectionData)
}

// ClipboardRichTextReceivedFunc: a function to be called when the results of
// gtk_clipboard_request_rich_text() are received, or when the request fails.
type ClipboardRichTextReceivedFunc func(clipboard Clipboard, format gdk.Atom, text string, length uint)

//export gotk4_ClipboardRichTextReceivedFunc
func gotk4_ClipboardRichTextReceivedFunc(arg0 *C.GtkClipboard, arg1 C.GdkAtom, arg2 *C.guint8, arg3 C.gsize, arg4 C.gpointer) {
	v := box.Get(uintptr(arg4))
	if v == nil {
		panic(`callback not found`)
	}

	var clipboard Clipboard
	var format gdk.Atom
	var text string
	var length uint

	clipboard = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(Clipboard)

	{
		format = gdk.WrapAtom(unsafe.Pointer(arg1))
	}

	text = C.GoString(arg2)

	length = uint(arg3)

	v.(ClipboardRichTextReceivedFunc)(clipboard, format, text, length)
}

// ClipboardTargetsReceivedFunc: a function to be called when the results of
// gtk_clipboard_request_targets() are received, or when the request fails.
type ClipboardTargetsReceivedFunc func(clipboard Clipboard, atoms []gdk.Atom)

//export gotk4_ClipboardTargetsReceivedFunc
func gotk4_ClipboardTargetsReceivedFunc(arg0 *C.GtkClipboard, arg1 *C.GdkAtom, arg2 C.gint, arg3 C.gpointer) {
	v := box.Get(uintptr(arg3))
	if v == nil {
		panic(`callback not found`)
	}

	var clipboard Clipboard
	var atoms []gdk.Atom

	clipboard = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(Clipboard)

	{
		atoms = make([]gdk.Atom, arg2)
		for i := 0; i < uintptr(arg2); i++ {
			src := (C.GdkAtom)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			{
				atoms[i] = gdk.WrapAtom(unsafe.Pointer(src))
			}
		}
	}

	v.(ClipboardTargetsReceivedFunc)(clipboard, atoms)
}

// ClipboardTextReceivedFunc: a function to be called when the results of
// gtk_clipboard_request_text() are received, or when the request fails.
type ClipboardTextReceivedFunc func(clipboard Clipboard, text string)

//export gotk4_ClipboardTextReceivedFunc
func gotk4_ClipboardTextReceivedFunc(arg0 *C.GtkClipboard, arg1 *C.gchar, arg2 C.gpointer) {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var clipboard Clipboard
	var text string

	clipboard = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(Clipboard)

	text = C.GoString(arg1)

	v.(ClipboardTextReceivedFunc)(clipboard, text)
}

// ClipboardURIReceivedFunc: a function to be called when the results of
// gtk_clipboard_request_uris() are received, or when the request fails.
type ClipboardURIReceivedFunc func(clipboard Clipboard, uris []string)

//export gotk4_ClipboardURIReceivedFunc
func gotk4_ClipboardURIReceivedFunc(arg0 *C.GtkClipboard, arg1 **C.gchar, arg2 C.gpointer) {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var clipboard Clipboard
	var uris []string

	clipboard = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(Clipboard)

	{
		var length uint
		for p := unsafe.Pointer(arg1); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		uris = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(arg1)) + i))
			uris[i] = C.GoString(src)
		}
	}

	v.(ClipboardURIReceivedFunc)(clipboard, uris)
}

// EntryCompletionMatchFunc: a function which decides whether the row indicated
// by @iter matches a given @key, and should be displayed as a possible
// completion for @key. Note that @key is normalized and case-folded (see
// g_utf8_normalize() and g_utf8_casefold()). If this is not appropriate, match
// functions have access to the unmodified key via `gtk_entry_get_text
// (GTK_ENTRY (gtk_entry_completion_get_entry ()))`.
type EntryCompletionMatchFunc func(completion EntryCompletion, key string, iter *TreeIter) bool

//export gotk4_EntryCompletionMatchFunc
func gotk4_EntryCompletionMatchFunc(arg0 *C.GtkEntryCompletion, arg1 *C.gchar, arg2 *C.GtkTreeIter, arg3 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg3))
	if v == nil {
		panic(`callback not found`)
	}

	var completion EntryCompletion
	var key string
	var iter *TreeIter

	completion = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(EntryCompletion)

	key = C.GoString(arg1)

	{
		iter = WrapTreeIter(unsafe.Pointer(arg2))
	}

	ok := v.(EntryCompletionMatchFunc)(completion, key, iter)
}

// FileFilterFunc: the type of function that is used with custom filters, see
// gtk_file_filter_add_custom().
type FileFilterFunc func(filterInfo *FileFilterInfo) bool

//export gotk4_FileFilterFunc
func gotk4_FileFilterFunc(arg0 *C.GtkFileFilterInfo, arg1 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var filterInfo *FileFilterInfo

	{
		filterInfo = WrapFileFilterInfo(unsafe.Pointer(arg0))
	}

	ok := v.(FileFilterFunc)(filterInfo)
}

// FlowBoxCreateWidgetFunc: called for flow boxes that are bound to a Model with
// gtk_flow_box_bind_model() for each item that gets added to the model.
type FlowBoxCreateWidgetFunc func(item gextras.Objector) Widget

//export gotk4_FlowBoxCreateWidgetFunc
func gotk4_FlowBoxCreateWidgetFunc(arg0 C.gpointer, arg1 C.gpointer) *C.GtkWidget {
	v := box.Get(uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var item gextras.Objector

	item = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(gextras.Objector)

	widget := v.(FlowBoxCreateWidgetFunc)(item)
}

// FlowBoxFilterFunc: a function that will be called whenrever a child changes
// or is added. It lets you control if the child should be visible or not.
type FlowBoxFilterFunc func(child FlowBoxChild) bool

//export gotk4_FlowBoxFilterFunc
func gotk4_FlowBoxFilterFunc(arg0 *C.GtkFlowBoxChild, arg1 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var child FlowBoxChild

	child = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(FlowBoxChild)

	ok := v.(FlowBoxFilterFunc)(child)
}

// FlowBoxForeachFunc: a function used by gtk_flow_box_selected_foreach(). It
// will be called on every selected child of the @box.
type FlowBoxForeachFunc func(box FlowBox, child FlowBoxChild)

//export gotk4_FlowBoxForeachFunc
func gotk4_FlowBoxForeachFunc(arg0 *C.GtkFlowBox, arg1 *C.GtkFlowBoxChild, arg2 C.gpointer) {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var box FlowBox
	var child FlowBoxChild

	box = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(FlowBox)

	child = gextras.CastObject(externglib.Take(unsafe.Pointer(arg1.Native()))).(FlowBoxChild)

	v.(FlowBoxForeachFunc)(box, child)
}

// FlowBoxSortFunc: a function to compare two children to determine which should
// come first.
type FlowBoxSortFunc func(child1 FlowBoxChild, child2 FlowBoxChild) int

//export gotk4_FlowBoxSortFunc
func gotk4_FlowBoxSortFunc(arg0 *C.GtkFlowBoxChild, arg1 *C.GtkFlowBoxChild, arg2 C.gpointer) C.gint {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var child1 FlowBoxChild
	var child2 FlowBoxChild

	child1 = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(FlowBoxChild)

	child2 = gextras.CastObject(externglib.Take(unsafe.Pointer(arg1.Native()))).(FlowBoxChild)

	gint := v.(FlowBoxSortFunc)(child1, child2)
}

// FontFilterFunc: the type of function that is used for deciding what fonts get
// shown in a FontChooser. See gtk_font_chooser_set_filter_func().
type FontFilterFunc func(family pango.FontFamily, face pango.FontFace) bool

//export gotk4_FontFilterFunc
func gotk4_FontFilterFunc(arg0 *C.PangoFontFamily, arg1 *C.PangoFontFace, arg2 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var family pango.FontFamily
	var face pango.FontFace

	family = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(pango.FontFamily)

	face = gextras.CastObject(externglib.Take(unsafe.Pointer(arg1.Native()))).(pango.FontFace)

	ok := v.(FontFilterFunc)(family, face)
}

// IconViewForeachFunc: a function used by gtk_icon_view_selected_foreach() to
// map all selected rows. It will be called on every selected row in the view.
type IconViewForeachFunc func(iconView IconView, path *TreePath)

//export gotk4_IconViewForeachFunc
func gotk4_IconViewForeachFunc(arg0 *C.GtkIconView, arg1 *C.GtkTreePath, arg2 C.gpointer) {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var iconView IconView
	var path *TreePath

	iconView = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(IconView)

	{
		path = WrapTreePath(unsafe.Pointer(arg1))
	}

	v.(IconViewForeachFunc)(iconView, path)
}

// KeySnoopFunc: key snooper functions are called before normal event delivery.
// They can be used to implement custom key event handling.
type KeySnoopFunc func(grabWidget Widget, event *gdk.EventKey) int

//export gotk4_KeySnoopFunc
func gotk4_KeySnoopFunc(arg0 *C.GtkWidget, arg1 *C.GdkEventKey, arg2 C.gpointer) C.gint {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var grabWidget Widget
	var event *gdk.EventKey

	grabWidget = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(Widget)

	{
		event = gdk.WrapEventKey(unsafe.Pointer(arg1))
	}

	gint := v.(KeySnoopFunc)(grabWidget, event)
}

// ListBoxCreateWidgetFunc: called for list boxes that are bound to a Model with
// gtk_list_box_bind_model() for each item that gets added to the model.
//
// Versions of GTK+ prior to 3.18 called gtk_widget_show_all() on the rows
// created by the GtkListBoxCreateWidgetFunc, but this forced all widgets inside
// the row to be shown, and is no longer the case. Applications should be
// updated to show the desired row widgets.
type ListBoxCreateWidgetFunc func(item gextras.Objector) Widget

//export gotk4_ListBoxCreateWidgetFunc
func gotk4_ListBoxCreateWidgetFunc(arg0 C.gpointer, arg1 C.gpointer) *C.GtkWidget {
	v := box.Get(uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var item gextras.Objector

	item = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(gextras.Objector)

	widget := v.(ListBoxCreateWidgetFunc)(item)
}

// ListBoxFilterFunc: will be called whenever the row changes or is added and
// lets you control if the row should be visible or not.
type ListBoxFilterFunc func(row ListBoxRow) bool

//export gotk4_ListBoxFilterFunc
func gotk4_ListBoxFilterFunc(arg0 *C.GtkListBoxRow, arg1 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var row ListBoxRow

	row = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(ListBoxRow)

	ok := v.(ListBoxFilterFunc)(row)
}

// ListBoxForeachFunc: a function used by gtk_list_box_selected_foreach(). It
// will be called on every selected child of the @box.
type ListBoxForeachFunc func(box ListBox, row ListBoxRow)

//export gotk4_ListBoxForeachFunc
func gotk4_ListBoxForeachFunc(arg0 *C.GtkListBox, arg1 *C.GtkListBoxRow, arg2 C.gpointer) {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var box ListBox
	var row ListBoxRow

	box = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(ListBox)

	row = gextras.CastObject(externglib.Take(unsafe.Pointer(arg1.Native()))).(ListBoxRow)

	v.(ListBoxForeachFunc)(box, row)
}

// ListBoxSortFunc: compare two rows to determine which should be first.
type ListBoxSortFunc func(row1 ListBoxRow, row2 ListBoxRow) int

//export gotk4_ListBoxSortFunc
func gotk4_ListBoxSortFunc(arg0 *C.GtkListBoxRow, arg1 *C.GtkListBoxRow, arg2 C.gpointer) C.gint {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var row1 ListBoxRow
	var row2 ListBoxRow

	row1 = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(ListBoxRow)

	row2 = gextras.CastObject(externglib.Take(unsafe.Pointer(arg1.Native()))).(ListBoxRow)

	gint := v.(ListBoxSortFunc)(row1, row2)
}

// ListBoxUpdateHeaderFunc: whenever @row changes or which row is before @row
// changes this is called, which lets you update the header on @row. You may
// remove or set a new one via gtk_list_box_row_set_header() or just change the
// state of the current header widget.
type ListBoxUpdateHeaderFunc func(row ListBoxRow, before ListBoxRow)

//export gotk4_ListBoxUpdateHeaderFunc
func gotk4_ListBoxUpdateHeaderFunc(arg0 *C.GtkListBoxRow, arg1 *C.GtkListBoxRow, arg2 C.gpointer) {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var row ListBoxRow
	var before ListBoxRow

	row = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(ListBoxRow)

	before = gextras.CastObject(externglib.Take(unsafe.Pointer(arg1.Native()))).(ListBoxRow)

	v.(ListBoxUpdateHeaderFunc)(row, before)
}

// MenuPositionFunc: a user function supplied when calling gtk_menu_popup()
// which controls the positioning of the menu when it is displayed. The function
// sets the @x and @y parameters to the coordinates where the menu is to be
// drawn. To make the menu appear on a different monitor than the mouse pointer,
// gtk_menu_set_monitor() must be called.
type MenuPositionFunc func(menu Menu, x int, y int) bool

//export gotk4_MenuPositionFunc
func gotk4_MenuPositionFunc(arg0 *C.GtkMenu, arg1 *C.gint, arg2 *C.gint, arg3 *C.gboolean, arg4 C.gpointer) {
	v := box.Get(uintptr(arg4))
	if v == nil {
		panic(`callback not found`)
	}

	var menu Menu
	var x int
	var y int

	menu = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(Menu)

	x = int(arg1)

	y = int(arg2)

	pushIn := v.(MenuPositionFunc)(menu, x, y)
}

// PageSetupDoneFunc: the type of function that is passed to
// gtk_print_run_page_setup_dialog_async().
//
// This function will be called when the page setup dialog is dismissed, and
// also serves as destroy notify for @data.
type PageSetupDoneFunc func(pageSetup PageSetup)

//export gotk4_PageSetupDoneFunc
func gotk4_PageSetupDoneFunc(arg0 *C.GtkPageSetup, arg1 C.gpointer) {
	v := box.Get(uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var pageSetup PageSetup

	pageSetup = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(PageSetup)

	v.(PageSetupDoneFunc)(pageSetup)
}

type PrintSettingsFunc func(key string, value string)

//export gotk4_PrintSettingsFunc
func gotk4_PrintSettingsFunc(arg0 *C.gchar, arg1 *C.gchar, arg2 C.gpointer) {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var key string
	var value string

	key = C.GoString(arg0)

	value = C.GoString(arg1)

	v.(PrintSettingsFunc)(key, value)
}

// RecentFilterFunc: the type of function that is used with custom filters, see
// gtk_recent_filter_add_custom().
type RecentFilterFunc func(filterInfo *RecentFilterInfo) bool

//export gotk4_RecentFilterFunc
func gotk4_RecentFilterFunc(arg0 *C.GtkRecentFilterInfo, arg1 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var filterInfo *RecentFilterInfo

	{
		filterInfo = WrapRecentFilterInfo(unsafe.Pointer(arg0))
	}

	ok := v.(RecentFilterFunc)(filterInfo)
}

type RecentSortFunc func(a *RecentInfo, b *RecentInfo) int

//export gotk4_RecentSortFunc
func gotk4_RecentSortFunc(arg0 *C.GtkRecentInfo, arg1 *C.GtkRecentInfo, arg2 C.gpointer) C.gint {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var a *RecentInfo
	var b *RecentInfo

	{
		a = WrapRecentInfo(unsafe.Pointer(arg0))
	}

	{
		b = WrapRecentInfo(unsafe.Pointer(arg1))
	}

	gint := v.(RecentSortFunc)(a, b)
}

// TextBufferDeserializeFunc: a function that is called to deserialize rich text
// that has been serialized with gtk_text_buffer_serialize(), and insert it at
// @iter.
type TextBufferDeserializeFunc func(registerBuffer TextBuffer, contentBuffer TextBuffer, iter *TextIter, data []byte, createTags bool) error

//export gotk4_TextBufferDeserializeFunc
func gotk4_TextBufferDeserializeFunc(arg0 *C.GtkTextBuffer, arg1 *C.GtkTextBuffer, arg2 *C.GtkTextIter, arg3 *C.guint8, arg4 C.gsize, arg5 C.gboolean, arg6 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg6))
	if v == nil {
		panic(`callback not found`)
	}

	var registerBuffer TextBuffer
	var contentBuffer TextBuffer
	var iter *TextIter
	var data []byte
	var createTags bool

	registerBuffer = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(TextBuffer)

	contentBuffer = gextras.CastObject(externglib.Take(unsafe.Pointer(arg1.Native()))).(TextBuffer)

	{
		iter = WrapTextIter(unsafe.Pointer(arg2))
	}

	{
		data = make([]byte, arg4)
		for i := 0; i < uintptr(arg4); i++ {
			src := (C.guint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			data[i] = byte(src)
		}
	}

	createTags = C.BOOL(arg5) != 0

	ok := v.(TextBufferDeserializeFunc)(registerBuffer, contentBuffer, iter, data, createTags)
}

// TextBufferSerializeFunc: a function that is called to serialize the content
// of a text buffer. It must return the serialized form of the content.
type TextBufferSerializeFunc func(registerBuffer TextBuffer, contentBuffer TextBuffer, start *TextIter, end *TextIter, length uint) byte

//export gotk4_TextBufferSerializeFunc
func gotk4_TextBufferSerializeFunc(arg0 *C.GtkTextBuffer, arg1 *C.GtkTextBuffer, arg2 *C.GtkTextIter, arg3 *C.GtkTextIter, arg4 *C.gsize, arg5 C.gpointer) *C.guint8 {
	v := box.Get(uintptr(arg5))
	if v == nil {
		panic(`callback not found`)
	}

	var registerBuffer TextBuffer
	var contentBuffer TextBuffer
	var start *TextIter
	var end *TextIter
	var length uint

	registerBuffer = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(TextBuffer)

	contentBuffer = gextras.CastObject(externglib.Take(unsafe.Pointer(arg1.Native()))).(TextBuffer)

	{
		start = WrapTextIter(unsafe.Pointer(arg2))
	}

	{
		end = WrapTextIter(unsafe.Pointer(arg3))
	}

	length = uint(arg4)

	guint8 := v.(TextBufferSerializeFunc)(registerBuffer, contentBuffer, start, end, length)
}

type TextCharPredicate func(ch uint32) bool

//export gotk4_TextCharPredicate
func gotk4_TextCharPredicate(arg0 C.gunichar, arg1 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var ch uint32

	ch = uint32(arg0)

	ok := v.(TextCharPredicate)(ch)
}

type TextTagTableForeach func(tag TextTag)

//export gotk4_TextTagTableForeach
func gotk4_TextTagTableForeach(arg0 *C.GtkTextTag, arg1 C.gpointer) {
	v := box.Get(uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var tag TextTag

	tag = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(TextTag)

	v.(TextTagTableForeach)(tag)
}

// TickCallback: callback type for adding a function to update animations. See
// gtk_widget_add_tick_callback().
type TickCallback func(widget Widget, frameClock gdk.FrameClock) bool

//export gotk4_TickCallback
func gotk4_TickCallback(arg0 *C.GtkWidget, arg1 *C.GdkFrameClock, arg2 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var widget Widget
	var frameClock gdk.FrameClock

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(Widget)

	frameClock = gextras.CastObject(externglib.Take(unsafe.Pointer(arg1.Native()))).(gdk.FrameClock)

	ok := v.(TickCallback)(widget, frameClock)
}

// TranslateFunc: the function used to translate messages in e.g. IconFactory
// and ActionGroup.
type TranslateFunc func(path string) string

//export gotk4_TranslateFunc
func gotk4_TranslateFunc(arg0 *C.gchar, arg1 C.gpointer) *C.gchar {
	v := box.Get(uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var path string

	path = C.GoString(arg0)

	utf8 := v.(TranslateFunc)(path)
}

// TreeCellDataFunc: a function to set the properties of a cell instead of just
// using the straight mapping between the cell and the model. This is useful for
// customizing the cell renderer. For example, a function might get an integer
// from the @tree_model, and render it to the “text” attribute of “cell” by
// converting it to its written equivalent. This is set by calling
// gtk_tree_view_column_set_cell_data_func()
type TreeCellDataFunc func(treeColumn TreeViewColumn, cell CellRenderer, treeModel TreeModel, iter *TreeIter)

//export gotk4_TreeCellDataFunc
func gotk4_TreeCellDataFunc(arg0 *C.GtkTreeViewColumn, arg1 *C.GtkCellRenderer, arg2 *C.GtkTreeModel, arg3 *C.GtkTreeIter, arg4 C.gpointer) {
	v := box.Get(uintptr(arg4))
	if v == nil {
		panic(`callback not found`)
	}

	var treeColumn TreeViewColumn
	var cell CellRenderer
	var treeModel TreeModel
	var iter *TreeIter

	treeColumn = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(TreeViewColumn)

	cell = gextras.CastObject(externglib.Take(unsafe.Pointer(arg1.Native()))).(CellRenderer)

	treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(arg2.Native()))).(TreeModel)

	{
		iter = WrapTreeIter(unsafe.Pointer(arg3))
	}

	v.(TreeCellDataFunc)(treeColumn, cell, treeModel, iter)
}

type TreeDestroyCountFunc func(treeView TreeView, path *TreePath, children int)

//export gotk4_TreeDestroyCountFunc
func gotk4_TreeDestroyCountFunc(arg0 *C.GtkTreeView, arg1 *C.GtkTreePath, arg2 C.gint, arg3 C.gpointer) {
	v := box.Get(uintptr(arg3))
	if v == nil {
		panic(`callback not found`)
	}

	var treeView TreeView
	var path *TreePath
	var children int

	treeView = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(TreeView)

	{
		path = WrapTreePath(unsafe.Pointer(arg1))
	}

	children = int(arg2)

	v.(TreeDestroyCountFunc)(treeView, path, children)
}

// TreeIterCompareFunc: a GtkTreeIterCompareFunc should return a negative
// integer, zero, or a positive integer if @a sorts before @b, @a sorts with @b,
// or @a sorts after @b respectively. If two iters compare as equal, their order
// in the sorted model is undefined. In order to ensure that the TreeSortable
// behaves as expected, the GtkTreeIterCompareFunc must define a partial order
// on the model, i.e. it must be reflexive, antisymmetric and transitive.
//
// For example, if @model is a product catalogue, then a compare function for
// the “price” column could be one which returns `price_of(@a) - price_of(@b)`.
type TreeIterCompareFunc func(model TreeModel, a *TreeIter, b *TreeIter) int

//export gotk4_TreeIterCompareFunc
func gotk4_TreeIterCompareFunc(arg0 *C.GtkTreeModel, arg1 *C.GtkTreeIter, arg2 *C.GtkTreeIter, arg3 C.gpointer) C.gint {
	v := box.Get(uintptr(arg3))
	if v == nil {
		panic(`callback not found`)
	}

	var model TreeModel
	var a *TreeIter
	var b *TreeIter

	model = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(TreeModel)

	{
		a = WrapTreeIter(unsafe.Pointer(arg1))
	}

	{
		b = WrapTreeIter(unsafe.Pointer(arg2))
	}

	gint := v.(TreeIterCompareFunc)(model, a, b)
}

// TreeModelFilterModifyFunc: a function which calculates display values from
// raw values in the model. It must fill @value with the display value for the
// column @column in the row indicated by @iter.
//
// Since this function is called for each data access, it’s not a particularly
// efficient operation.
type TreeModelFilterModifyFunc func(model TreeModel, iter *TreeIter, column int) externglib.Value

//export gotk4_TreeModelFilterModifyFunc
func gotk4_TreeModelFilterModifyFunc(arg0 *C.GtkTreeModel, arg1 *C.GtkTreeIter, arg2 *C.GValue, arg3 C.gint, arg4 C.gpointer) {
	v := box.Get(uintptr(arg4))
	if v == nil {
		panic(`callback not found`)
	}

	var model TreeModel
	var iter *TreeIter
	var column int

	model = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(TreeModel)

	{
		iter = WrapTreeIter(unsafe.Pointer(arg1))
	}

	column = int(arg3)

	value := v.(TreeModelFilterModifyFunc)(model, iter, column)
}

// TreeModelFilterVisibleFunc: a function which decides whether the row
// indicated by @iter is visible.
type TreeModelFilterVisibleFunc func(model TreeModel, iter *TreeIter) bool

//export gotk4_TreeModelFilterVisibleFunc
func gotk4_TreeModelFilterVisibleFunc(arg0 *C.GtkTreeModel, arg1 *C.GtkTreeIter, arg2 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var model TreeModel
	var iter *TreeIter

	model = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(TreeModel)

	{
		iter = WrapTreeIter(unsafe.Pointer(arg1))
	}

	ok := v.(TreeModelFilterVisibleFunc)(model, iter)
}

// TreeModelForeachFunc: type of the callback passed to gtk_tree_model_foreach()
// to iterate over the rows in a tree model.
type TreeModelForeachFunc func(model TreeModel, path *TreePath, iter *TreeIter) bool

//export gotk4_TreeModelForeachFunc
func gotk4_TreeModelForeachFunc(arg0 *C.GtkTreeModel, arg1 *C.GtkTreePath, arg2 *C.GtkTreeIter, arg3 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg3))
	if v == nil {
		panic(`callback not found`)
	}

	var model TreeModel
	var path *TreePath
	var iter *TreeIter

	model = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(TreeModel)

	{
		path = WrapTreePath(unsafe.Pointer(arg1))
	}

	{
		iter = WrapTreeIter(unsafe.Pointer(arg2))
	}

	ok := v.(TreeModelForeachFunc)(model, path, iter)
}

// TreeSelectionForeachFunc: a function used by
// gtk_tree_selection_selected_foreach() to map all selected rows. It will be
// called on every selected row in the view.
type TreeSelectionForeachFunc func(model TreeModel, path *TreePath, iter *TreeIter)

//export gotk4_TreeSelectionForeachFunc
func gotk4_TreeSelectionForeachFunc(arg0 *C.GtkTreeModel, arg1 *C.GtkTreePath, arg2 *C.GtkTreeIter, arg3 C.gpointer) {
	v := box.Get(uintptr(arg3))
	if v == nil {
		panic(`callback not found`)
	}

	var model TreeModel
	var path *TreePath
	var iter *TreeIter

	model = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(TreeModel)

	{
		path = WrapTreePath(unsafe.Pointer(arg1))
	}

	{
		iter = WrapTreeIter(unsafe.Pointer(arg2))
	}

	v.(TreeSelectionForeachFunc)(model, path, iter)
}

// TreeSelectionFunc: a function used by
// gtk_tree_selection_set_select_function() to filter whether or not a row may
// be selected. It is called whenever a row's state might change. A return value
// of true indicates to @selection that it is okay to change the selection.
type TreeSelectionFunc func(selection TreeSelection, model TreeModel, path *TreePath, pathCurrentlySelected bool) bool

//export gotk4_TreeSelectionFunc
func gotk4_TreeSelectionFunc(arg0 *C.GtkTreeSelection, arg1 *C.GtkTreeModel, arg2 *C.GtkTreePath, arg3 C.gboolean, arg4 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg4))
	if v == nil {
		panic(`callback not found`)
	}

	var selection TreeSelection
	var model TreeModel
	var path *TreePath
	var pathCurrentlySelected bool

	selection = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(TreeSelection)

	model = gextras.CastObject(externglib.Take(unsafe.Pointer(arg1.Native()))).(TreeModel)

	{
		path = WrapTreePath(unsafe.Pointer(arg2))
	}

	pathCurrentlySelected = C.BOOL(arg3) != 0

	ok := v.(TreeSelectionFunc)(selection, model, path, pathCurrentlySelected)
}

// TreeViewColumnDropFunc: function type for determining whether @column can be
// dropped in a particular spot (as determined by @prev_column and
// @next_column). In left to right locales, @prev_column is on the left of the
// potential drop spot, and @next_column is on the right. In right to left mode,
// this is reversed. This function should return true if the spot is a valid
// drop spot. Please note that returning true does not actually indicate that
// the column drop was made, but is meant only to indicate a possible drop spot
// to the user.
type TreeViewColumnDropFunc func(treeView TreeView, column TreeViewColumn, prevColumn TreeViewColumn, nextColumn TreeViewColumn) bool

//export gotk4_TreeViewColumnDropFunc
func gotk4_TreeViewColumnDropFunc(arg0 *C.GtkTreeView, arg1 *C.GtkTreeViewColumn, arg2 *C.GtkTreeViewColumn, arg3 *C.GtkTreeViewColumn, arg4 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg4))
	if v == nil {
		panic(`callback not found`)
	}

	var treeView TreeView
	var column TreeViewColumn
	var prevColumn TreeViewColumn
	var nextColumn TreeViewColumn

	treeView = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(TreeView)

	column = gextras.CastObject(externglib.Take(unsafe.Pointer(arg1.Native()))).(TreeViewColumn)

	prevColumn = gextras.CastObject(externglib.Take(unsafe.Pointer(arg2.Native()))).(TreeViewColumn)

	nextColumn = gextras.CastObject(externglib.Take(unsafe.Pointer(arg3.Native()))).(TreeViewColumn)

	ok := v.(TreeViewColumnDropFunc)(treeView, column, prevColumn, nextColumn)
}

// TreeViewMappingFunc: function used for gtk_tree_view_map_expanded_rows().
type TreeViewMappingFunc func(treeView TreeView, path *TreePath)

//export gotk4_TreeViewMappingFunc
func gotk4_TreeViewMappingFunc(arg0 *C.GtkTreeView, arg1 *C.GtkTreePath, arg2 C.gpointer) {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var treeView TreeView
	var path *TreePath

	treeView = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(TreeView)

	{
		path = WrapTreePath(unsafe.Pointer(arg1))
	}

	v.(TreeViewMappingFunc)(treeView, path)
}

// TreeViewRowSeparatorFunc: function type for determining whether the row
// pointed to by @iter should be rendered as a separator. A common way to
// implement this is to have a boolean column in the model, whose values the
// TreeViewRowSeparatorFunc returns.
type TreeViewRowSeparatorFunc func(model TreeModel, iter *TreeIter) bool

//export gotk4_TreeViewRowSeparatorFunc
func gotk4_TreeViewRowSeparatorFunc(arg0 *C.GtkTreeModel, arg1 *C.GtkTreeIter, arg2 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var model TreeModel
	var iter *TreeIter

	model = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(TreeModel)

	{
		iter = WrapTreeIter(unsafe.Pointer(arg1))
	}

	ok := v.(TreeViewRowSeparatorFunc)(model, iter)
}

// TreeViewSearchEqualFunc: a function used for checking whether a row in @model
// matches a search key string entered by the user. Note the return value is
// reversed from what you would normally expect, though it has some similarity
// to strcmp() returning 0 for equal strings.
type TreeViewSearchEqualFunc func(model TreeModel, column int, key string, iter *TreeIter) bool

//export gotk4_TreeViewSearchEqualFunc
func gotk4_TreeViewSearchEqualFunc(arg0 *C.GtkTreeModel, arg1 C.gint, arg2 *C.gchar, arg3 *C.GtkTreeIter, arg4 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg4))
	if v == nil {
		panic(`callback not found`)
	}

	var model TreeModel
	var column int
	var key string
	var iter *TreeIter

	model = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(TreeModel)

	column = int(arg1)

	key = C.GoString(arg2)

	{
		iter = WrapTreeIter(unsafe.Pointer(arg3))
	}

	ok := v.(TreeViewSearchEqualFunc)(model, column, key, iter)
}

type TreeViewSearchPositionFunc func(treeView TreeView, searchDialog Widget)

//export gotk4_TreeViewSearchPositionFunc
func gotk4_TreeViewSearchPositionFunc(arg0 *C.GtkTreeView, arg1 *C.GtkWidget, arg2 C.gpointer) {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var treeView TreeView
	var searchDialog Widget

	treeView = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(TreeView)

	searchDialog = gextras.CastObject(externglib.Take(unsafe.Pointer(arg1.Native()))).(Widget)

	v.(TreeViewSearchPositionFunc)(treeView, searchDialog)
}

// AccelGroupsActivate finds the first accelerator in any AccelGroup attached to
// @object that matches @accel_key and @accel_mods, and activates that
// accelerator.
func AccelGroupsActivate(object gextras.Objector, accelKey uint, accelMods gdk.ModifierType) bool {
	var arg1 *C.GObject
	var arg2 C.guint
	var arg3 C.GdkModifierType

	arg1 = (*C.GObject)(object.Native())
	arg2 = C.guint(accelKey)
	arg3 = (C.GdkModifierType)(accelMods)

	ret := C.gtk_accel_groups_activate(arg1, arg2, arg3)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// AccelGroupsFromObject gets a list of all accel groups which are attached to
// @object.
func AccelGroupsFromObject(object gextras.Objector) *glib.SList {
	var arg1 *C.GObject

	arg1 = (*C.GObject)(object.Native())

	ret := C.gtk_accel_groups_from_object(arg1)

	var ret0 *glib.SList

	{
		ret0 = glib.WrapSList(unsafe.Pointer(ret))
	}

	return ret0
}

// AcceleratorGetDefaultModMask gets the modifier mask.
//
// The modifier mask determines which modifiers are considered significant for
// keyboard accelerators. See gtk_accelerator_set_default_mod_mask().
func AcceleratorGetDefaultModMask() gdk.ModifierType {

	ret := C.gtk_accelerator_get_default_mod_mask()

	var ret0 gdk.ModifierType

	ret0 = gdk.ModifierType(ret)

	return ret0
}

// AcceleratorGetLabel converts an accelerator keyval and modifier mask into a
// string which can be used to represent the accelerator to the user.
func AcceleratorGetLabel(acceleratorKey uint, acceleratorMods gdk.ModifierType) string {
	var arg1 C.guint
	var arg2 C.GdkModifierType

	arg1 = C.guint(acceleratorKey)
	arg2 = (C.GdkModifierType)(acceleratorMods)

	ret := C.gtk_accelerator_get_label(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// AcceleratorGetLabelWithKeycode converts an accelerator keyval and modifier
// mask into a (possibly translated) string that can be displayed to a user,
// similarly to gtk_accelerator_get_label(), but handling keycodes.
//
// This is only useful for system-level components, applications should use
// gtk_accelerator_parse() instead.
func AcceleratorGetLabelWithKeycode(display gdk.Display, acceleratorKey uint, keycode uint, acceleratorMods gdk.ModifierType) string {
	var arg1 *C.GdkDisplay
	var arg2 C.guint
	var arg3 C.guint
	var arg4 C.GdkModifierType

	arg1 = (*C.GdkDisplay)(display.Native())
	arg2 = C.guint(acceleratorKey)
	arg3 = C.guint(keycode)
	arg4 = (C.GdkModifierType)(acceleratorMods)

	ret := C.gtk_accelerator_get_label_with_keycode(arg1, arg2, arg3, arg4)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// AcceleratorName converts an accelerator keyval and modifier mask into a
// string parseable by gtk_accelerator_parse(). For example, if you pass in
// K_KEY_q and K_CONTROL_MASK, this function returns “<Control>q”.
//
// If you need to display accelerators in the user interface, see
// gtk_accelerator_get_label().
func AcceleratorName(acceleratorKey uint, acceleratorMods gdk.ModifierType) string {
	var arg1 C.guint
	var arg2 C.GdkModifierType

	arg1 = C.guint(acceleratorKey)
	arg2 = (C.GdkModifierType)(acceleratorMods)

	ret := C.gtk_accelerator_name(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// AcceleratorNameWithKeycode converts an accelerator keyval and modifier mask
// into a string parseable by gtk_accelerator_parse_with_keycode(), similarly to
// gtk_accelerator_name() but handling keycodes. This is only useful for
// system-level components, applications should use gtk_accelerator_parse()
// instead.
func AcceleratorNameWithKeycode(display gdk.Display, acceleratorKey uint, keycode uint, acceleratorMods gdk.ModifierType) string {
	var arg1 *C.GdkDisplay
	var arg2 C.guint
	var arg3 C.guint
	var arg4 C.GdkModifierType

	arg1 = (*C.GdkDisplay)(display.Native())
	arg2 = C.guint(acceleratorKey)
	arg3 = C.guint(keycode)
	arg4 = (C.GdkModifierType)(acceleratorMods)

	ret := C.gtk_accelerator_name_with_keycode(arg1, arg2, arg3, arg4)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// AcceleratorParse parses a string representing an accelerator. The format
// looks like “<Control>a” or “<Shift><Alt>F1” or “<Release>z” (the last one is
// for key release).
//
// The parser is fairly liberal and allows lower or upper case, and also
// abbreviations such as “<Ctl>” and “<Ctrl>”. Key names are parsed using
// gdk_keyval_from_name(). For character keys the name is not the symbol, but
// the lowercase name, e.g. one would use “<Ctrl>minus” instead of “<Ctrl>-”.
//
// If the parse fails, @accelerator_key and @accelerator_mods will be set to 0
// (zero).
func AcceleratorParse(accelerator string) (acceleratorKey uint, acceleratorMods gdk.ModifierType) {
	var arg1 *C.gchar
	var arg2 *C.guint           // out
	var arg3 *C.GdkModifierType // out

	arg1 = (*C.gchar)(C.CString(accelerator))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_accelerator_parse(arg1, &arg2, &arg3)

	var ret0 uint
	var ret1 *gdk.ModifierType

	ret0 = uint(arg2)

	ret1 = (*gdk.ModifierType)(arg3)

	return ret0, ret1
}

// AcceleratorParseWithKeycode parses a string representing an accelerator,
// similarly to gtk_accelerator_parse() but handles keycodes as well. This is
// only useful for system-level components, applications should use
// gtk_accelerator_parse() instead.
//
// If @accelerator_codes is given and the result stored in it is non-nil, the
// result must be freed with g_free().
//
// If a keycode is present in the accelerator and no @accelerator_codes is
// given, the parse will fail.
//
// If the parse fails, @accelerator_key, @accelerator_mods and
// @accelerator_codes will be set to 0 (zero).
func AcceleratorParseWithKeycode(accelerator string) (acceleratorKey uint, acceleratorCodes []uint, acceleratorMods gdk.ModifierType) {
	var arg1 *C.gchar
	var arg2 *C.guint           // out
	var arg3 **C.guint          // out
	var arg4 *C.GdkModifierType // out

	arg1 = (*C.gchar)(C.CString(accelerator))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_accelerator_parse_with_keycode(arg1, &arg2, &arg3, &arg4)

	var ret0 uint
	var ret1 []uint
	var ret2 *gdk.ModifierType

	ret0 = uint(arg2)

	{
		var length uint
		for p := unsafe.Pointer(arg3); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret1 = make([]uint, length)
		for i := 0; i < length; i++ {
			src := (*C.guint)(unsafe.Pointer(uintptr(unsafe.Pointer(arg3)) + i))
			ret1[i] = uint(src)
		}
	}

	ret2 = (*gdk.ModifierType)(arg4)

	return ret0, ret1, ret2
}

// AcceleratorSetDefaultModMask sets the modifiers that will be considered
// significant for keyboard accelerators. The default mod mask depends on the
// GDK backend in use, but will typically include K_CONTROL_MASK | K_SHIFT_MASK
// | K_MOD1_MASK | K_SUPER_MASK | K_HYPER_MASK | K_META_MASK. In other words,
// Control, Shift, Alt, Super, Hyper and Meta. Other modifiers will by default
// be ignored by AccelGroup.
//
// You must include at least the three modifiers Control, Shift and Alt in any
// value you pass to this function.
//
// The default mod mask should be changed on application startup, before using
// any accelerator groups.
func AcceleratorSetDefaultModMask(defaultModMask gdk.ModifierType) {
	var arg1 C.GdkModifierType

	arg1 = (C.GdkModifierType)(defaultModMask)

	C.gtk_accelerator_set_default_mod_mask(arg1)
}

// AcceleratorValid determines whether a given keyval and modifier mask
// constitute a valid keyboard accelerator. For example, the K_KEY_a keyval plus
// K_CONTROL_MASK is valid - this is a “Ctrl+a” accelerator. But, you can't, for
// instance, use the K_KEY_Control_L keyval as an accelerator.
func AcceleratorValid(keyval uint, modifiers gdk.ModifierType) bool {
	var arg1 C.guint
	var arg2 C.GdkModifierType

	arg1 = C.guint(keyval)
	arg2 = (C.GdkModifierType)(modifiers)

	ret := C.gtk_accelerator_valid(arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// AlternativeDialogButtonOrder returns true if dialogs are expected to use an
// alternative button order on the screen @screen. See
// gtk_dialog_set_alternative_button_order() for more details about alternative
// button order.
//
// If you need to use this function, you should probably connect to the
// ::notify:gtk-alternative-button-order signal on the Settings object
// associated to @screen, in order to be notified if the button order setting
// changes.
func AlternativeDialogButtonOrder(screen gdk.Screen) bool {
	var arg1 *C.GdkScreen

	arg1 = (*C.GdkScreen)(screen.Native())

	ret := C.gtk_alternative_dialog_button_order(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// BindingEntryAddSignalFromString parses a signal description from @signal_desc
// and incorporates it into @binding_set.
//
// Signal descriptions may either bind a key combination to one or more signals:
//
//    bind "key" {
//      "signalname" (param, ...)
//      ...
//    }
//
// Or they may also unbind a key combination:
//
//    unbind "key"
//
// Key combinations must be in a format that can be parsed by
// gtk_accelerator_parse().
func BindingEntryAddSignalFromString(bindingSet *BindingSet, signalDesc string) glib.TokenType {
	var arg1 *C.GtkBindingSet
	var arg2 *C.gchar

	arg1 = (*C.GtkBindingSet)(bindingSet.Native())
	arg2 = (*C.gchar)(C.CString(signalDesc))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_binding_entry_add_signal_from_string(arg1, arg2)

	var ret0 glib.TokenType

	ret0 = glib.TokenType(ret)

	return ret0
}

// BindingEntryAddSignall: override or install a new key binding for @keyval
// with @modifiers on @binding_set.
func BindingEntryAddSignall(bindingSet *BindingSet, keyval uint, modifiers gdk.ModifierType, signalName string, bindingArgs *glib.SList) {
	var arg1 *C.GtkBindingSet
	var arg2 C.guint
	var arg3 C.GdkModifierType
	var arg4 *C.gchar
	var arg5 *C.GSList

	arg1 = (*C.GtkBindingSet)(bindingSet.Native())
	arg2 = C.guint(keyval)
	arg3 = (C.GdkModifierType)(modifiers)
	arg4 = (*C.gchar)(C.CString(signalName))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.GSList)(bindingArgs.Native())

	C.gtk_binding_entry_add_signall(arg1, arg2, arg3, arg4, arg5)
}

// BindingEntryRemove: remove a binding previously installed via
// gtk_binding_entry_add_signal() on @binding_set.
func BindingEntryRemove(bindingSet *BindingSet, keyval uint, modifiers gdk.ModifierType) {
	var arg1 *C.GtkBindingSet
	var arg2 C.guint
	var arg3 C.GdkModifierType

	arg1 = (*C.GtkBindingSet)(bindingSet.Native())
	arg2 = C.guint(keyval)
	arg3 = (C.GdkModifierType)(modifiers)

	C.gtk_binding_entry_remove(arg1, arg2, arg3)
}

// BindingEntrySkip: install a binding on @binding_set which causes key lookups
// to be aborted, to prevent bindings from lower priority sets to be activated.
func BindingEntrySkip(bindingSet *BindingSet, keyval uint, modifiers gdk.ModifierType) {
	var arg1 *C.GtkBindingSet
	var arg2 C.guint
	var arg3 C.GdkModifierType

	arg1 = (*C.GtkBindingSet)(bindingSet.Native())
	arg2 = C.guint(keyval)
	arg3 = (C.GdkModifierType)(modifiers)

	C.gtk_binding_entry_skip(arg1, arg2, arg3)
}

// BindingSetByClass: this function returns the binding set named after the type
// name of the passed in class structure. New binding sets are created on demand
// by this function.
func BindingSetByClass(objectClass interface{}) *BindingSet {
	var arg1 C.gpointer

	arg1 = C.gpointer(box.Assign(objectClass))

	ret := C.gtk_binding_set_by_class(arg1)

	var ret0 *BindingSet

	{
		ret0 = WrapBindingSet(unsafe.Pointer(ret))
	}

	return ret0
}

// BindingSetFind: find a binding set by its globally unique name.
//
// The @set_name can either be a name used for gtk_binding_set_new() or the type
// name of a class used in gtk_binding_set_by_class().
func BindingSetFind(setName string) *BindingSet {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(setName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_binding_set_find(arg1)

	var ret0 *BindingSet

	{
		ret0 = WrapBindingSet(unsafe.Pointer(ret))
	}

	return ret0
}

// NewBindingSet: GTK+ maintains a global list of binding sets. Each binding set
// has a unique name which needs to be specified upon creation.
func NewBindingSet(setName string) *BindingSet {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(setName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_binding_set_new(arg1)

	var ret0 *BindingSet

	{
		ret0 = WrapBindingSet(unsafe.Pointer(ret))
	}

	return ret0
}

// BindingsActivate: find a key binding matching @keyval and @modifiers and
// activate the binding on @object.
func BindingsActivate(object gextras.Objector, keyval uint, modifiers gdk.ModifierType) bool {
	var arg1 *C.GObject
	var arg2 C.guint
	var arg3 C.GdkModifierType

	arg1 = (*C.GObject)(object.Native())
	arg2 = C.guint(keyval)
	arg3 = (C.GdkModifierType)(modifiers)

	ret := C.gtk_bindings_activate(arg1, arg2, arg3)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// BindingsActivateEvent looks up key bindings for @object to find one matching
// @event, and if one was found, activate it.
func BindingsActivateEvent(object gextras.Objector, event *gdk.EventKey) bool {
	var arg1 *C.GObject
	var arg2 *C.GdkEventKey

	arg1 = (*C.GObject)(object.Native())
	arg2 = (*C.GdkEventKey)(event.Native())

	ret := C.gtk_bindings_activate_event(arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

func BuilderErrorQuark() glib.Quark {

	ret := C.gtk_builder_error_quark()

	var ret0 glib.Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

// CairoShouldDrawWindow: this function is supposed to be called in Widget::draw
// implementations for widgets that support multiple windows. @cr must be
// untransformed from invoking of the draw function. This function will return
// true if the contents of the given @window are supposed to be drawn and false
// otherwise. Note that when the drawing was not initiated by the windowing
// system this function will return true for all windows, so you need to draw
// the bottommost window first. Also, do not use “else if” statements to check
// which window should be drawn.
func CairoShouldDrawWindow(cr *cairo.Context, window gdk.Window) bool {
	var arg1 *C.cairo_t
	var arg2 *C.GdkWindow

	arg1 = (*C.cairo_t)(cr.Native())
	arg2 = (*C.GdkWindow)(window.Native())

	ret := C.gtk_cairo_should_draw_window(arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// CairoTransformToWindow transforms the given cairo context @cr that from
// @widget-relative coordinates to @window-relative coordinates. If the
// @widget’s window is not an ancestor of @window, no modification will be
// applied.
//
// This is the inverse to the transformation GTK applies when preparing an
// expose event to be emitted with the Widget::draw signal. It is intended to
// help porting multiwindow widgets from GTK+ 2 to the rendering architecture of
// GTK+ 3.
func CairoTransformToWindow(cr *cairo.Context, widget Widget, window gdk.Window) {
	var arg1 *C.cairo_t
	var arg2 *C.GtkWidget
	var arg3 *C.GdkWindow

	arg1 = (*C.cairo_t)(cr.Native())
	arg2 = (*C.GtkWidget)(widget.Native())
	arg3 = (*C.GdkWindow)(window.Native())

	C.gtk_cairo_transform_to_window(arg1, arg2, arg3)
}

// CheckVersion checks that the GTK+ library in use is compatible with the given
// version. Generally you would pass in the constants K_MAJOR_VERSION,
// K_MINOR_VERSION, K_MICRO_VERSION as the three arguments to this function;
// that produces a check that the library in use is compatible with the version
// of GTK+ the application or module was compiled against.
//
// Compatibility is defined by two things: first the version of the running
// library is newer than the version
// @required_major.required_minor.@required_micro. Second the running library
// must be binary compatible with the version
// @required_major.required_minor.@required_micro (same major version.)
//
// This function is primarily for GTK+ modules; the module can call this
// function to check that it wasn’t loaded into an incompatible version of GTK+.
// However, such a check isn’t completely reliable, since the module may be
// linked against an old version of GTK+ and calling the old version of
// gtk_check_version(), but still get loaded into an application using a newer
// version of GTK+.
func CheckVersion(requiredMajor uint, requiredMinor uint, requiredMicro uint) string {
	var arg1 C.guint
	var arg2 C.guint
	var arg3 C.guint

	arg1 = C.guint(requiredMajor)
	arg2 = C.guint(requiredMinor)
	arg3 = C.guint(requiredMicro)

	ret := C.gtk_check_version(arg1, arg2, arg3)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

func CSSProviderErrorQuark() glib.Quark {

	ret := C.gtk_css_provider_error_quark()

	var ret0 glib.Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

// DeviceGrabAdd adds a GTK+ grab on @device, so all the events on @device and
// its associated pointer or keyboard (if any) are delivered to @widget. If the
// @block_others parameter is true, any other devices will be unable to interact
// with @widget during the grab.
func DeviceGrabAdd(widget Widget, device gdk.Device, blockOthers bool) {
	var arg1 *C.GtkWidget
	var arg2 *C.GdkDevice
	var arg3 C.gboolean

	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = (*C.GdkDevice)(device.Native())
	if blockOthers {
		arg3 = C.TRUE
	}

	C.gtk_device_grab_add(arg1, arg2, arg3)
}

// DeviceGrabRemove removes a device grab from the given widget.
//
// You have to pair calls to gtk_device_grab_add() and gtk_device_grab_remove().
func DeviceGrabRemove(widget Widget, device gdk.Device) {
	var arg1 *C.GtkWidget
	var arg2 *C.GdkDevice

	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = (*C.GdkDevice)(device.Native())

	C.gtk_device_grab_remove(arg1, arg2)
}

// DisableSetlocale prevents gtk_init(), gtk_init_check(), gtk_init_with_args()
// and gtk_parse_args() from automatically calling `setlocale (LC_ALL, "")`. You
// would want to use this function if you wanted to set the locale for your
// program to something other than the user’s locale, or if you wanted to set
// different values for different locale categories.
//
// Most programs should not need to call this function.
func DisableSetlocale() {

	C.gtk_disable_setlocale()
}

// DistributeNaturalAllocation distributes @extra_space to child @sizes by
// bringing smaller children up to natural size first.
//
// The remaining space will be added to the @minimum_size member of the
// GtkRequestedSize struct. If all sizes reach their natural size then the
// remaining space is returned.
func DistributeNaturalAllocation(extraSpace int, nRequestedSizes uint, sizes *RequestedSize) int {
	var arg1 C.gint
	var arg2 C.guint
	var arg3 *C.GtkRequestedSize

	arg1 = C.gint(extraSpace)
	arg2 = C.guint(nRequestedSizes)
	arg3 = (*C.GtkRequestedSize)(sizes.Native())

	ret := C.gtk_distribute_natural_allocation(arg1, arg2, arg3)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// DragCancel cancels an ongoing drag operation on the source side.
//
// If you want to be able to cancel a drag operation in this way, you need to
// keep a pointer to the drag context, either from an explicit call to
// gtk_drag_begin_with_coordinates(), or by connecting to Widget::drag-begin.
//
// If @context does not refer to an ongoing drag operation, this function does
// nothing.
//
// If a drag is cancelled in this way, the @result argument of
// Widget::drag-failed is set to @GTK_DRAG_RESULT_ERROR.
func DragCancel(context gdk.DragContext) {
	var arg1 *C.GdkDragContext

	arg1 = (*C.GdkDragContext)(context.Native())

	C.gtk_drag_cancel(arg1)
}

// DragFinish informs the drag source that the drop is finished, and that the
// data of the drag will no longer be required.
func DragFinish(context gdk.DragContext, success bool, del bool, time_ uint32) {
	var arg1 *C.GdkDragContext
	var arg2 C.gboolean
	var arg3 C.gboolean
	var arg4 C.guint32

	arg1 = (*C.GdkDragContext)(context.Native())
	if success {
		arg2 = C.TRUE
	}
	if del {
		arg3 = C.TRUE
	}
	arg4 = C.guint32(time_)

	C.gtk_drag_finish(arg1, arg2, arg3, arg4)
}

// DragGetSourceWidget determines the source widget for a drag.
func DragGetSourceWidget(context gdk.DragContext) Widget {
	var arg1 *C.GdkDragContext

	arg1 = (*C.GdkDragContext)(context.Native())

	ret := C.gtk_drag_get_source_widget(arg1)

	var ret0 Widget

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Widget)

	return ret0
}

// DragSetIconDefault sets the icon for a particular drag to the default icon.
func DragSetIconDefault(context gdk.DragContext) {
	var arg1 *C.GdkDragContext

	arg1 = (*C.GdkDragContext)(context.Native())

	C.gtk_drag_set_icon_default(arg1)
}

// DragSetIconGIcon sets the icon for a given drag from the given @icon. See the
// documentation for gtk_drag_set_icon_name() for more details about using icons
// in drag and drop.
func DragSetIconGIcon(context gdk.DragContext, icon gio.Icon, hotX int, hotY int) {
	var arg1 *C.GdkDragContext
	var arg2 *C.GIcon
	var arg3 C.gint
	var arg4 C.gint

	arg1 = (*C.GdkDragContext)(context.Native())
	arg2 = (*C.GIcon)(icon.Native())
	arg3 = C.gint(hotX)
	arg4 = C.gint(hotY)

	C.gtk_drag_set_icon_gicon(arg1, arg2, arg3, arg4)
}

// DragSetIconName sets the icon for a given drag from a named themed icon. See
// the docs for IconTheme for more details. Note that the size of the icon
// depends on the icon theme (the icon is loaded at the symbolic size
// K_ICON_SIZE_DND), thus @hot_x and @hot_y have to be used with care.
func DragSetIconName(context gdk.DragContext, iconName string, hotX int, hotY int) {
	var arg1 *C.GdkDragContext
	var arg2 *C.gchar
	var arg3 C.gint
	var arg4 C.gint

	arg1 = (*C.GdkDragContext)(context.Native())
	arg2 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.gint(hotX)
	arg4 = C.gint(hotY)

	C.gtk_drag_set_icon_name(arg1, arg2, arg3, arg4)
}

// DragSetIconPixbuf sets @pixbuf as the icon for a given drag.
func DragSetIconPixbuf(context gdk.DragContext, pixbuf gdkpixbuf.Pixbuf, hotX int, hotY int) {
	var arg1 *C.GdkDragContext
	var arg2 *C.GdkPixbuf
	var arg3 C.gint
	var arg4 C.gint

	arg1 = (*C.GdkDragContext)(context.Native())
	arg2 = (*C.GdkPixbuf)(pixbuf.Native())
	arg3 = C.gint(hotX)
	arg4 = C.gint(hotY)

	C.gtk_drag_set_icon_pixbuf(arg1, arg2, arg3, arg4)
}

// DragSetIconStock sets the icon for a given drag from a stock ID.
func DragSetIconStock(context gdk.DragContext, stockID string, hotX int, hotY int) {
	var arg1 *C.GdkDragContext
	var arg2 *C.gchar
	var arg3 C.gint
	var arg4 C.gint

	arg1 = (*C.GdkDragContext)(context.Native())
	arg2 = (*C.gchar)(C.CString(stockID))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.gint(hotX)
	arg4 = C.gint(hotY)

	C.gtk_drag_set_icon_stock(arg1, arg2, arg3, arg4)
}

// DragSetIconSurface sets @surface as the icon for a given drag. GTK+ retains
// references for the arguments, and will release them when they are no longer
// needed.
//
// To position the surface relative to the mouse, use
// cairo_surface_set_device_offset() on @surface. The mouse cursor will be
// positioned at the (0,0) coordinate of the surface.
func DragSetIconSurface(context gdk.DragContext, surface *cairo.Surface) {
	var arg1 *C.GdkDragContext
	var arg2 *C.cairo_surface_t

	arg1 = (*C.GdkDragContext)(context.Native())
	arg2 = (*C.cairo_surface_t)(surface.Native())

	C.gtk_drag_set_icon_surface(arg1, arg2)
}

// DragSetIconWidget changes the icon for drag operation to a given widget. GTK+
// will not destroy the widget, so if you don’t want it to persist, you should
// connect to the “drag-end” signal and destroy it yourself.
func DragSetIconWidget(context gdk.DragContext, widget Widget, hotX int, hotY int) {
	var arg1 *C.GdkDragContext
	var arg2 *C.GtkWidget
	var arg3 C.gint
	var arg4 C.gint

	arg1 = (*C.GdkDragContext)(context.Native())
	arg2 = (*C.GtkWidget)(widget.Native())
	arg3 = C.gint(hotX)
	arg4 = C.gint(hotY)

	C.gtk_drag_set_icon_widget(arg1, arg2, arg3, arg4)
}

// DrawInsertionCursor draws a text caret on @cr at @location. This is not a
// style function but merely a convenience function for drawing the standard
// cursor shape.
func DrawInsertionCursor(widget Widget, cr *cairo.Context, location *gdk.Rectangle, isPrimary bool, direction TextDirection, drawArrow bool) {
	var arg1 *C.GtkWidget
	var arg2 *C.cairo_t
	var arg3 *C.GdkRectangle
	var arg4 C.gboolean
	var arg5 C.GtkTextDirection
	var arg6 C.gboolean

	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = (*C.GdkRectangle)(location.Native())
	if isPrimary {
		arg4 = C.TRUE
	}
	arg5 = (C.GtkTextDirection)(direction)
	if drawArrow {
		arg6 = C.TRUE
	}

	C.gtk_draw_insertion_cursor(arg1, arg2, arg3, arg4, arg5, arg6)
}

// EventsPending checks if any events are pending.
//
// This can be used to update the UI and invoke timeouts etc. while doing some
// time intensive computation.
//
// Updating the UI during a long computation
//
//     // computation going on...
//
//     while (gtk_events_pending ())
//       gtk_main_iteration ();
//
//     // ...computation continued
func EventsPending() bool {

	ret := C.gtk_events_pending()

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// False: analogical to gtk_true(), this function does nothing but always
// returns false.
func False() bool {

	ret := C.gtk_false()

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// FileChooserErrorQuark registers an error quark for FileChooser if necessary.
func FileChooserErrorQuark() glib.Quark {

	ret := C.gtk_file_chooser_error_quark()

	var ret0 glib.Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

// GetBinaryAge returns the binary age as passed to `libtool` when building the
// GTK+ library the process is running against. If `libtool` means nothing to
// you, don't worry about it.
func GetBinaryAge() uint {

	ret := C.gtk_get_binary_age()

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// GetCurrentEventDevice: if there is a current event and it has a device,
// return that device, otherwise return nil.
func GetCurrentEventDevice() gdk.Device {

	ret := C.gtk_get_current_event_device()

	var ret0 gdk.Device

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gdk.Device)

	return ret0
}

// GetCurrentEventState: if there is a current event and it has a state field,
// place that state field in @state and return true, otherwise return false.
func GetCurrentEventState() (state gdk.ModifierType, ok bool) {
	var arg1 *C.GdkModifierType // out

	ret := C.gtk_get_current_event_state(&arg1)

	var ret0 *gdk.ModifierType
	var ret1 bool

	ret0 = (*gdk.ModifierType)(arg1)

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// GetCurrentEventTime: if there is a current event and it has a timestamp,
// return that timestamp, otherwise return GDK_CURRENT_TIME.
func GetCurrentEventTime() uint32 {

	ret := C.gtk_get_current_event_time()

	var ret0 uint32

	ret0 = uint32(ret)

	return ret0
}

// GetDebugFlags returns the GTK+ debug flags.
//
// This function is intended for GTK+ modules that want to adjust their debug
// output based on GTK+ debug flags.
func GetDebugFlags() uint {

	ret := C.gtk_get_debug_flags()

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// GetDefaultLanguage returns the Language for the default language currently in
// effect. (Note that this can change over the life of an application.) The
// default language is derived from the current locale. It determines, for
// example, whether GTK+ uses the right-to-left or left-to-right text direction.
//
// This function is equivalent to pango_language_get_default(). See that
// function for details.
func GetDefaultLanguage() *pango.Language {

	ret := C.gtk_get_default_language()

	var ret0 *pango.Language

	{
		ret0 = pango.WrapLanguage(unsafe.Pointer(ret))
	}

	return ret0
}

// GetInterfaceAge returns the interface age as passed to `libtool` when
// building the GTK+ library the process is running against. If `libtool` means
// nothing to you, don't worry about it.
func GetInterfaceAge() uint {

	ret := C.gtk_get_interface_age()

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// GetLocaleDirection: get the direction of the current locale. This is the
// expected reading direction for text and UI.
//
// This function depends on the current locale being set with setlocale() and
// will default to setting the GTK_TEXT_DIR_LTR direction otherwise.
// GTK_TEXT_DIR_NONE will never be returned.
//
// GTK+ sets the default text direction according to the locale during
// gtk_init(), and you should normally use gtk_widget_get_direction() or
// gtk_widget_get_default_direction() to obtain the current direcion.
//
// This function is only needed rare cases when the locale is changed after GTK+
// has already been initialized. In this case, you can use it to update the
// default text direction as follows:
//
//    setlocale (LC_ALL, new_locale);
//    direction = gtk_get_locale_direction ();
//    gtk_widget_set_default_direction (direction);
func GetLocaleDirection() TextDirection {

	ret := C.gtk_get_locale_direction()

	var ret0 TextDirection

	ret0 = TextDirection(ret)

	return ret0
}

// GetMajorVersion returns the major version number of the GTK+ library. (e.g.
// in GTK+ version 3.1.5 this is 3.)
//
// This function is in the library, so it represents the GTK+ library your code
// is running against. Contrast with the K_MAJOR_VERSION macro, which represents
// the major version of the GTK+ headers you have included when compiling your
// code.
func GetMajorVersion() uint {

	ret := C.gtk_get_major_version()

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// GetMicroVersion returns the micro version number of the GTK+ library. (e.g.
// in GTK+ version 3.1.5 this is 5.)
//
// This function is in the library, so it represents the GTK+ library your code
// is are running against. Contrast with the K_MICRO_VERSION macro, which
// represents the micro version of the GTK+ headers you have included when
// compiling your code.
func GetMicroVersion() uint {

	ret := C.gtk_get_micro_version()

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// GetMinorVersion returns the minor version number of the GTK+ library. (e.g.
// in GTK+ version 3.1.5 this is 1.)
//
// This function is in the library, so it represents the GTK+ library your code
// is are running against. Contrast with the K_MINOR_VERSION macro, which
// represents the minor version of the GTK+ headers you have included when
// compiling your code.
func GetMinorVersion() uint {

	ret := C.gtk_get_minor_version()

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// GetOptionGroup returns a Group for the commandline arguments recognized by
// GTK+ and GDK.
//
// You should add this group to your Context with g_option_context_add_group(),
// if you are using g_option_context_parse() to parse your commandline
// arguments.
func GetOptionGroup(openDefaultDisplay bool) *glib.OptionGroup {
	var arg1 C.gboolean

	if openDefaultDisplay {
		arg1 = C.TRUE
	}

	ret := C.gtk_get_option_group(arg1)

	var ret0 *glib.OptionGroup

	{
		ret0 = glib.WrapOptionGroup(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.OptionGroup) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// GrabGetCurrent queries the current grab of the default window group.
func GrabGetCurrent() Widget {

	ret := C.gtk_grab_get_current()

	var ret0 Widget

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Widget)

	return ret0
}

// IconSizeFromName looks up the icon size associated with @name.
func IconSizeFromName(name string) int {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_icon_size_from_name(arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// IconSizeGetName gets the canonical name of the given icon size. The returned
// string is statically allocated and should not be freed.
func IconSizeGetName(size int) string {
	var arg1 C.GtkIconSize

	arg1 = C.GtkIconSize(size)

	ret := C.gtk_icon_size_get_name(arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// IconSizeLookup obtains the pixel size of a semantic icon size @size:
// K_ICON_SIZE_MENU, K_ICON_SIZE_BUTTON, etc. This function isn’t normally
// needed, gtk_icon_theme_load_icon() is the usual way to get an icon for
// rendering, then just look at the size of the rendered pixbuf. The rendered
// pixbuf may not even correspond to the width/height returned by
// gtk_icon_size_lookup(), because themes are free to render the pixbuf however
// they like, including changing the usual size.
func IconSizeLookup(size int) (width int, height int, ok bool) {
	var arg1 C.GtkIconSize
	var arg2 *C.gint // out
	var arg3 *C.gint // out

	arg1 = C.GtkIconSize(size)

	ret := C.gtk_icon_size_lookup(arg1, &arg2, &arg3)

	var ret0 int
	var ret1 int
	var ret2 bool

	ret0 = int(arg2)

	ret1 = int(arg3)

	ret2 = C.BOOL(ret) != 0

	return ret0, ret1, ret2
}

// IconSizeLookupForSettings obtains the pixel size of a semantic icon size,
// possibly modified by user preferences for a particular Settings. Normally
// @size would be K_ICON_SIZE_MENU, K_ICON_SIZE_BUTTON, etc. This function isn’t
// normally needed, gtk_widget_render_icon_pixbuf() is the usual way to get an
// icon for rendering, then just look at the size of the rendered pixbuf. The
// rendered pixbuf may not even correspond to the width/height returned by
// gtk_icon_size_lookup(), because themes are free to render the pixbuf however
// they like, including changing the usual size.
func IconSizeLookupForSettings(settings Settings, size int) (width int, height int, ok bool) {
	var arg1 *C.GtkSettings
	var arg2 C.GtkIconSize
	var arg3 *C.gint // out
	var arg4 *C.gint // out

	arg1 = (*C.GtkSettings)(settings.Native())
	arg2 = C.GtkIconSize(size)

	ret := C.gtk_icon_size_lookup_for_settings(arg1, arg2, &arg3, &arg4)

	var ret0 int
	var ret1 int
	var ret2 bool

	ret0 = int(arg3)

	ret1 = int(arg4)

	ret2 = C.BOOL(ret) != 0

	return ret0, ret1, ret2
}

// IconSizeRegister registers a new icon size, along the same lines as
// K_ICON_SIZE_MENU, etc. Returns the integer value for the size.
func IconSizeRegister(name string, width int, height int) int {
	var arg1 *C.gchar
	var arg2 C.gint
	var arg3 C.gint

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(width)
	arg3 = C.gint(height)

	ret := C.gtk_icon_size_register(arg1, arg2, arg3)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// IconSizeRegisterAlias registers @alias as another name for @target. So
// calling gtk_icon_size_from_name() with @alias as argument will return
// @target.
func IconSizeRegisterAlias(alias string, target int) {
	var arg1 *C.gchar
	var arg2 C.GtkIconSize

	arg1 = (*C.gchar)(C.CString(alias))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.GtkIconSize(target)

	C.gtk_icon_size_register_alias(arg1, arg2)
}

func IconThemeErrorQuark() glib.Quark {

	ret := C.gtk_icon_theme_error_quark()

	var ret0 glib.Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

// Init: call this function before using any other GTK+ functions in your GUI
// applications. It will initialize everything needed to operate the toolkit and
// parses some standard command line options.
//
// Although you are expected to pass the @argc, @argv parameters from main() to
// this function, it is possible to pass nil if @argv is not available or
// commandline handling is not required.
//
// @argc and @argv are adjusted accordingly so your own code will never see
// those standard arguments.
//
// Note that there are some alternative ways to initialize GTK+: if you are
// calling gtk_parse_args(), gtk_init_check(), gtk_init_with_args() or
// g_option_context_parse() with the option group returned by
// gtk_get_option_group(), you don’t have to call gtk_init().
//
// And if you are using Application, you don't have to call any of the
// initialization functions either; the Application::startup handler does it for
// you.
//
// This function will terminate your program if it was unable to initialize the
// windowing system for some reason. If you want your program to fall back to a
// textual interface you want to call gtk_init_check() instead.
//
// Since 2.18, GTK+ calls `signal (SIGPIPE, SIG_IGN)` during initialization, to
// ignore SIGPIPE signals, since these are almost never wanted in graphical
// applications. If you do need to handle SIGPIPE for some reason, reset the
// handler after gtk_init(), but notice that other libraries (e.g. libdbus or
// gvfs) might do similar things.
func Init(argc int, argv []string) {
	var arg1 *C.int
	var arg2 ***C.char

	{
		var dst []**C.char
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * len(argv))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(argv)
		sliceHeader.Cap = len(argv)

		for i := 0; i < len(argv); i++ {
			src := argv[i]
			dst[i] = (*C.gchar)(C.CString(src))
		}

		arg2 = (***C.char)(unsafe.Pointer(ptr))
		arg1 = len(argv)
	}

	C.gtk_init(arg1, arg2)
}

// InitCheck: this function does the same work as gtk_init() with only a single
// change: It does not terminate the program if the commandline arguments
// couldn’t be parsed or the windowing system can’t be initialized. Instead it
// returns false on failure.
//
// This way the application can fall back to some other means of communication
// with the user - for example a curses or command line interface.
//
// Note that calling any GTK function or instantiating any GTK type after this
// function returns false results in undefined behavior.
func InitCheck(argc int, argv []string) bool {
	var arg1 *C.int
	var arg2 ***C.char

	{
		var dst []**C.char
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * len(argv))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(argv)
		sliceHeader.Cap = len(argv)

		for i := 0; i < len(argv); i++ {
			src := argv[i]
			dst[i] = (*C.gchar)(C.CString(src))
		}

		arg2 = (***C.char)(unsafe.Pointer(ptr))
		arg1 = len(argv)
	}

	ret := C.gtk_init_check(arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// InitWithArgs: this function does the same work as gtk_init_check().
// Additionally, it allows you to add your own commandline options, and it
// automatically generates nicely formatted `--help` output. Note that your
// program will be terminated after writing out the help output.
func InitWithArgs(argc int, argv []string, parameterString string, entries []glib.OptionEntry, translationDomain string) error {
	var arg1 *C.gint
	var arg2 ***C.gchar
	var arg3 *C.gchar
	var arg4 *C.GOptionEntry
	var arg5 *C.gchar
	var gError *C.GError

	{
		var dst []**C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * len(argv))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(argv)
		sliceHeader.Cap = len(argv)

		for i := 0; i < len(argv); i++ {
			src := argv[i]
			dst[i] = (*C.gchar)(C.CString(src))
		}

		arg2 = (***C.gchar)(unsafe.Pointer(ptr))
		arg1 = len(argv)
	}
	arg3 = (*C.gchar)(C.CString(parameterString))
	defer C.free(unsafe.Pointer(arg3))
	{
		var dst []C.GOptionEntry
		ptr := C.malloc(C.sizeof_GOptionEntry * (len(entries) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(entries)
		sliceHeader.Cap = len(entries)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(entries); i++ {
			src := entries[i]
			dst[i] = (C.GOptionEntry)(src.Native())
		}

		arg4 = (*C.GOptionEntry)(unsafe.Pointer(ptr))
	}
	arg5 = (*C.gchar)(C.CString(translationDomain))
	defer C.free(unsafe.Pointer(arg5))

	ret := C.gtk_init_with_args(arg1, arg2, arg3, arg4, arg5, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// KeySnooperInstall installs a key snooper function, which will get called on
// all key events before delivering them normally.
func KeySnooperInstall(snooper KeySnoopFunc) uint {
	var arg1 C.GtkKeySnoopFunc
	var arg2 C.gpointer

	arg1 = (*[0]byte)(C.gotk4_KeySnoopFunc)
	arg2 = C.gpointer(box.Assign(snooper))

	ret := C.gtk_key_snooper_install(arg1, arg2)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// KeySnooperRemove removes the key snooper function with the given id.
func KeySnooperRemove(snooperHandlerID uint) {
	var arg1 C.guint

	arg1 = C.guint(snooperHandlerID)

	C.gtk_key_snooper_remove(arg1)
}

// Main runs the main loop until gtk_main_quit() is called.
//
// You can nest calls to gtk_main(). In that case gtk_main_quit() will make the
// innermost invocation of the main loop return.
func Main() {

	C.gtk_main()
}

// MainIteration runs a single iteration of the mainloop.
//
// If no events are waiting to be processed GTK+ will block until the next event
// is noticed. If you don’t want to block look at gtk_main_iteration_do() or
// check if any events are pending with gtk_events_pending() first.
func MainIteration() bool {

	ret := C.gtk_main_iteration()

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// MainIterationDo runs a single iteration of the mainloop. If no events are
// available either return or block depending on the value of @blocking.
func MainIterationDo(blocking bool) bool {
	var arg1 C.gboolean

	if blocking {
		arg1 = C.TRUE
	}

	ret := C.gtk_main_iteration_do(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// MainLevel asks for the current nesting level of the main loop.
func MainLevel() uint {

	ret := C.gtk_main_level()

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// MainQuit makes the innermost invocation of the main loop return when it
// regains control.
func MainQuit() {

	C.gtk_main_quit()
}

// PaintArrow draws an arrow in the given rectangle on @cr using the given
// parameters. @arrow_type determines the direction of the arrow.
func PaintArrow(style Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget Widget, detail string, arrowType ArrowType, fill bool, x int, y int, width int, height int) {
	var arg1 *C.GtkStyle
	var arg2 *C.cairo_t
	var arg3 C.GtkStateType
	var arg4 C.GtkShadowType
	var arg5 *C.GtkWidget
	var arg6 *C.gchar
	var arg7 C.GtkArrowType
	var arg8 C.gboolean
	var arg9 C.gint
	var arg10 C.gint
	var arg11 C.gint
	var arg12 C.gint

	arg1 = (*C.GtkStyle)(style.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = (C.GtkStateType)(stateType)
	arg4 = (C.GtkShadowType)(shadowType)
	arg5 = (*C.GtkWidget)(widget.Native())
	arg6 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(arg6))
	arg7 = (C.GtkArrowType)(arrowType)
	if fill {
		arg8 = C.TRUE
	}
	arg9 = C.gint(x)
	arg10 = C.gint(y)
	arg11 = C.gint(width)
	arg12 = C.gint(height)

	C.gtk_paint_arrow(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12)
}

// PaintBox draws a box on @cr with the given parameters.
func PaintBox(style Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget Widget, detail string, x int, y int, width int, height int) {
	var arg1 *C.GtkStyle
	var arg2 *C.cairo_t
	var arg3 C.GtkStateType
	var arg4 C.GtkShadowType
	var arg5 *C.GtkWidget
	var arg6 *C.gchar
	var arg7 C.gint
	var arg8 C.gint
	var arg9 C.gint
	var arg10 C.gint

	arg1 = (*C.GtkStyle)(style.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = (C.GtkStateType)(stateType)
	arg4 = (C.GtkShadowType)(shadowType)
	arg5 = (*C.GtkWidget)(widget.Native())
	arg6 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(arg6))
	arg7 = C.gint(x)
	arg8 = C.gint(y)
	arg9 = C.gint(width)
	arg10 = C.gint(height)

	C.gtk_paint_box(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)
}

// PaintBoxGap draws a box in @cr using the given style and state and shadow
// type, leaving a gap in one side.
func PaintBoxGap(style Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget Widget, detail string, x int, y int, width int, height int, gapSide PositionType, gapX int, gapWidth int) {
	var arg1 *C.GtkStyle
	var arg2 *C.cairo_t
	var arg3 C.GtkStateType
	var arg4 C.GtkShadowType
	var arg5 *C.GtkWidget
	var arg6 *C.gchar
	var arg7 C.gint
	var arg8 C.gint
	var arg9 C.gint
	var arg10 C.gint
	var arg11 C.GtkPositionType
	var arg12 C.gint
	var arg13 C.gint

	arg1 = (*C.GtkStyle)(style.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = (C.GtkStateType)(stateType)
	arg4 = (C.GtkShadowType)(shadowType)
	arg5 = (*C.GtkWidget)(widget.Native())
	arg6 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(arg6))
	arg7 = C.gint(x)
	arg8 = C.gint(y)
	arg9 = C.gint(width)
	arg10 = C.gint(height)
	arg11 = (C.GtkPositionType)(gapSide)
	arg12 = C.gint(gapX)
	arg13 = C.gint(gapWidth)

	C.gtk_paint_box_gap(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13)
}

// PaintCheck draws a check button indicator in the given rectangle on @cr with
// the given parameters.
func PaintCheck(style Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget Widget, detail string, x int, y int, width int, height int) {
	var arg1 *C.GtkStyle
	var arg2 *C.cairo_t
	var arg3 C.GtkStateType
	var arg4 C.GtkShadowType
	var arg5 *C.GtkWidget
	var arg6 *C.gchar
	var arg7 C.gint
	var arg8 C.gint
	var arg9 C.gint
	var arg10 C.gint

	arg1 = (*C.GtkStyle)(style.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = (C.GtkStateType)(stateType)
	arg4 = (C.GtkShadowType)(shadowType)
	arg5 = (*C.GtkWidget)(widget.Native())
	arg6 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(arg6))
	arg7 = C.gint(x)
	arg8 = C.gint(y)
	arg9 = C.gint(width)
	arg10 = C.gint(height)

	C.gtk_paint_check(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)
}

// PaintDiamond draws a diamond in the given rectangle on @window using the
// given parameters.
func PaintDiamond(style Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget Widget, detail string, x int, y int, width int, height int) {
	var arg1 *C.GtkStyle
	var arg2 *C.cairo_t
	var arg3 C.GtkStateType
	var arg4 C.GtkShadowType
	var arg5 *C.GtkWidget
	var arg6 *C.gchar
	var arg7 C.gint
	var arg8 C.gint
	var arg9 C.gint
	var arg10 C.gint

	arg1 = (*C.GtkStyle)(style.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = (C.GtkStateType)(stateType)
	arg4 = (C.GtkShadowType)(shadowType)
	arg5 = (*C.GtkWidget)(widget.Native())
	arg6 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(arg6))
	arg7 = C.gint(x)
	arg8 = C.gint(y)
	arg9 = C.gint(width)
	arg10 = C.gint(height)

	C.gtk_paint_diamond(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)
}

// PaintExpander draws an expander as used in TreeView. @x and @y specify the
// center the expander. The size of the expander is determined by the
// “expander-size” style property of @widget. (If widget is not specified or
// doesn’t have an “expander-size” property, an unspecified default size will be
// used, since the caller doesn't have sufficient information to position the
// expander, this is likely not useful.) The expander is expander_size pixels
// tall in the collapsed position and expander_size pixels wide in the expanded
// position.
func PaintExpander(style Style, cr *cairo.Context, stateType StateType, widget Widget, detail string, x int, y int, expanderStyle ExpanderStyle) {
	var arg1 *C.GtkStyle
	var arg2 *C.cairo_t
	var arg3 C.GtkStateType
	var arg4 *C.GtkWidget
	var arg5 *C.gchar
	var arg6 C.gint
	var arg7 C.gint
	var arg8 C.GtkExpanderStyle

	arg1 = (*C.GtkStyle)(style.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = (C.GtkStateType)(stateType)
	arg4 = (*C.GtkWidget)(widget.Native())
	arg5 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(arg5))
	arg6 = C.gint(x)
	arg7 = C.gint(y)
	arg8 = (C.GtkExpanderStyle)(expanderStyle)

	C.gtk_paint_expander(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
}

// PaintExtension draws an extension, i.e. a notebook tab.
func PaintExtension(style Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget Widget, detail string, x int, y int, width int, height int, gapSide PositionType) {
	var arg1 *C.GtkStyle
	var arg2 *C.cairo_t
	var arg3 C.GtkStateType
	var arg4 C.GtkShadowType
	var arg5 *C.GtkWidget
	var arg6 *C.gchar
	var arg7 C.gint
	var arg8 C.gint
	var arg9 C.gint
	var arg10 C.gint
	var arg11 C.GtkPositionType

	arg1 = (*C.GtkStyle)(style.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = (C.GtkStateType)(stateType)
	arg4 = (C.GtkShadowType)(shadowType)
	arg5 = (*C.GtkWidget)(widget.Native())
	arg6 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(arg6))
	arg7 = C.gint(x)
	arg8 = C.gint(y)
	arg9 = C.gint(width)
	arg10 = C.gint(height)
	arg11 = (C.GtkPositionType)(gapSide)

	C.gtk_paint_extension(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11)
}

// PaintFlatBox draws a flat box on @cr with the given parameters.
func PaintFlatBox(style Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget Widget, detail string, x int, y int, width int, height int) {
	var arg1 *C.GtkStyle
	var arg2 *C.cairo_t
	var arg3 C.GtkStateType
	var arg4 C.GtkShadowType
	var arg5 *C.GtkWidget
	var arg6 *C.gchar
	var arg7 C.gint
	var arg8 C.gint
	var arg9 C.gint
	var arg10 C.gint

	arg1 = (*C.GtkStyle)(style.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = (C.GtkStateType)(stateType)
	arg4 = (C.GtkShadowType)(shadowType)
	arg5 = (*C.GtkWidget)(widget.Native())
	arg6 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(arg6))
	arg7 = C.gint(x)
	arg8 = C.gint(y)
	arg9 = C.gint(width)
	arg10 = C.gint(height)

	C.gtk_paint_flat_box(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)
}

// PaintFocus draws a focus indicator around the given rectangle on @cr using
// the given style.
func PaintFocus(style Style, cr *cairo.Context, stateType StateType, widget Widget, detail string, x int, y int, width int, height int) {
	var arg1 *C.GtkStyle
	var arg2 *C.cairo_t
	var arg3 C.GtkStateType
	var arg4 *C.GtkWidget
	var arg5 *C.gchar
	var arg6 C.gint
	var arg7 C.gint
	var arg8 C.gint
	var arg9 C.gint

	arg1 = (*C.GtkStyle)(style.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = (C.GtkStateType)(stateType)
	arg4 = (*C.GtkWidget)(widget.Native())
	arg5 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(arg5))
	arg6 = C.gint(x)
	arg7 = C.gint(y)
	arg8 = C.gint(width)
	arg9 = C.gint(height)

	C.gtk_paint_focus(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
}

// PaintHandle draws a handle as used in HandleBox and Paned.
func PaintHandle(style Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget Widget, detail string, x int, y int, width int, height int, orientation Orientation) {
	var arg1 *C.GtkStyle
	var arg2 *C.cairo_t
	var arg3 C.GtkStateType
	var arg4 C.GtkShadowType
	var arg5 *C.GtkWidget
	var arg6 *C.gchar
	var arg7 C.gint
	var arg8 C.gint
	var arg9 C.gint
	var arg10 C.gint
	var arg11 C.GtkOrientation

	arg1 = (*C.GtkStyle)(style.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = (C.GtkStateType)(stateType)
	arg4 = (C.GtkShadowType)(shadowType)
	arg5 = (*C.GtkWidget)(widget.Native())
	arg6 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(arg6))
	arg7 = C.gint(x)
	arg8 = C.gint(y)
	arg9 = C.gint(width)
	arg10 = C.gint(height)
	arg11 = (C.GtkOrientation)(orientation)

	C.gtk_paint_handle(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11)
}

// PaintHline draws a horizontal line from (@x1, @y) to (@x2, @y) in @cr using
// the given style and state.
func PaintHline(style Style, cr *cairo.Context, stateType StateType, widget Widget, detail string, x1 int, x2 int, y int) {
	var arg1 *C.GtkStyle
	var arg2 *C.cairo_t
	var arg3 C.GtkStateType
	var arg4 *C.GtkWidget
	var arg5 *C.gchar
	var arg6 C.gint
	var arg7 C.gint
	var arg8 C.gint

	arg1 = (*C.GtkStyle)(style.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = (C.GtkStateType)(stateType)
	arg4 = (*C.GtkWidget)(widget.Native())
	arg5 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(arg5))
	arg6 = C.gint(x1)
	arg7 = C.gint(x2)
	arg8 = C.gint(y)

	C.gtk_paint_hline(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
}

// PaintLayout draws a layout on @cr using the given parameters.
func PaintLayout(style Style, cr *cairo.Context, stateType StateType, useText bool, widget Widget, detail string, x int, y int, layout pango.Layout) {
	var arg1 *C.GtkStyle
	var arg2 *C.cairo_t
	var arg3 C.GtkStateType
	var arg4 C.gboolean
	var arg5 *C.GtkWidget
	var arg6 *C.gchar
	var arg7 C.gint
	var arg8 C.gint
	var arg9 *C.PangoLayout

	arg1 = (*C.GtkStyle)(style.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = (C.GtkStateType)(stateType)
	if useText {
		arg4 = C.TRUE
	}
	arg5 = (*C.GtkWidget)(widget.Native())
	arg6 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(arg6))
	arg7 = C.gint(x)
	arg8 = C.gint(y)
	arg9 = (*C.PangoLayout)(layout.Native())

	C.gtk_paint_layout(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
}

// PaintOption draws a radio button indicator in the given rectangle on @cr with
// the given parameters.
func PaintOption(style Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget Widget, detail string, x int, y int, width int, height int) {
	var arg1 *C.GtkStyle
	var arg2 *C.cairo_t
	var arg3 C.GtkStateType
	var arg4 C.GtkShadowType
	var arg5 *C.GtkWidget
	var arg6 *C.gchar
	var arg7 C.gint
	var arg8 C.gint
	var arg9 C.gint
	var arg10 C.gint

	arg1 = (*C.GtkStyle)(style.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = (C.GtkStateType)(stateType)
	arg4 = (C.GtkShadowType)(shadowType)
	arg5 = (*C.GtkWidget)(widget.Native())
	arg6 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(arg6))
	arg7 = C.gint(x)
	arg8 = C.gint(y)
	arg9 = C.gint(width)
	arg10 = C.gint(height)

	C.gtk_paint_option(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)
}

// PaintResizeGrip draws a resize grip in the given rectangle on @cr using the
// given parameters.
func PaintResizeGrip(style Style, cr *cairo.Context, stateType StateType, widget Widget, detail string, edge gdk.WindowEdge, x int, y int, width int, height int) {
	var arg1 *C.GtkStyle
	var arg2 *C.cairo_t
	var arg3 C.GtkStateType
	var arg4 *C.GtkWidget
	var arg5 *C.gchar
	var arg6 C.GdkWindowEdge
	var arg7 C.gint
	var arg8 C.gint
	var arg9 C.gint
	var arg10 C.gint

	arg1 = (*C.GtkStyle)(style.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = (C.GtkStateType)(stateType)
	arg4 = (*C.GtkWidget)(widget.Native())
	arg5 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(arg5))
	arg6 = (C.GdkWindowEdge)(edge)
	arg7 = C.gint(x)
	arg8 = C.gint(y)
	arg9 = C.gint(width)
	arg10 = C.gint(height)

	C.gtk_paint_resize_grip(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)
}

// PaintShadow draws a shadow around the given rectangle in @cr using the given
// style and state and shadow type.
func PaintShadow(style Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget Widget, detail string, x int, y int, width int, height int) {
	var arg1 *C.GtkStyle
	var arg2 *C.cairo_t
	var arg3 C.GtkStateType
	var arg4 C.GtkShadowType
	var arg5 *C.GtkWidget
	var arg6 *C.gchar
	var arg7 C.gint
	var arg8 C.gint
	var arg9 C.gint
	var arg10 C.gint

	arg1 = (*C.GtkStyle)(style.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = (C.GtkStateType)(stateType)
	arg4 = (C.GtkShadowType)(shadowType)
	arg5 = (*C.GtkWidget)(widget.Native())
	arg6 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(arg6))
	arg7 = C.gint(x)
	arg8 = C.gint(y)
	arg9 = C.gint(width)
	arg10 = C.gint(height)

	C.gtk_paint_shadow(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)
}

// PaintShadowGap draws a shadow around the given rectangle in @cr using the
// given style and state and shadow type, leaving a gap in one side.
func PaintShadowGap(style Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget Widget, detail string, x int, y int, width int, height int, gapSide PositionType, gapX int, gapWidth int) {
	var arg1 *C.GtkStyle
	var arg2 *C.cairo_t
	var arg3 C.GtkStateType
	var arg4 C.GtkShadowType
	var arg5 *C.GtkWidget
	var arg6 *C.gchar
	var arg7 C.gint
	var arg8 C.gint
	var arg9 C.gint
	var arg10 C.gint
	var arg11 C.GtkPositionType
	var arg12 C.gint
	var arg13 C.gint

	arg1 = (*C.GtkStyle)(style.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = (C.GtkStateType)(stateType)
	arg4 = (C.GtkShadowType)(shadowType)
	arg5 = (*C.GtkWidget)(widget.Native())
	arg6 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(arg6))
	arg7 = C.gint(x)
	arg8 = C.gint(y)
	arg9 = C.gint(width)
	arg10 = C.gint(height)
	arg11 = (C.GtkPositionType)(gapSide)
	arg12 = C.gint(gapX)
	arg13 = C.gint(gapWidth)

	C.gtk_paint_shadow_gap(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13)
}

// PaintSlider draws a slider in the given rectangle on @cr using the given
// style and orientation.
func PaintSlider(style Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget Widget, detail string, x int, y int, width int, height int, orientation Orientation) {
	var arg1 *C.GtkStyle
	var arg2 *C.cairo_t
	var arg3 C.GtkStateType
	var arg4 C.GtkShadowType
	var arg5 *C.GtkWidget
	var arg6 *C.gchar
	var arg7 C.gint
	var arg8 C.gint
	var arg9 C.gint
	var arg10 C.gint
	var arg11 C.GtkOrientation

	arg1 = (*C.GtkStyle)(style.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = (C.GtkStateType)(stateType)
	arg4 = (C.GtkShadowType)(shadowType)
	arg5 = (*C.GtkWidget)(widget.Native())
	arg6 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(arg6))
	arg7 = C.gint(x)
	arg8 = C.gint(y)
	arg9 = C.gint(width)
	arg10 = C.gint(height)
	arg11 = (C.GtkOrientation)(orientation)

	C.gtk_paint_slider(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11)
}

// PaintSpinner draws a spinner on @window using the given parameters.
func PaintSpinner(style Style, cr *cairo.Context, stateType StateType, widget Widget, detail string, step uint, x int, y int, width int, height int) {
	var arg1 *C.GtkStyle
	var arg2 *C.cairo_t
	var arg3 C.GtkStateType
	var arg4 *C.GtkWidget
	var arg5 *C.gchar
	var arg6 C.guint
	var arg7 C.gint
	var arg8 C.gint
	var arg9 C.gint
	var arg10 C.gint

	arg1 = (*C.GtkStyle)(style.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = (C.GtkStateType)(stateType)
	arg4 = (*C.GtkWidget)(widget.Native())
	arg5 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(arg5))
	arg6 = C.guint(step)
	arg7 = C.gint(x)
	arg8 = C.gint(y)
	arg9 = C.gint(width)
	arg10 = C.gint(height)

	C.gtk_paint_spinner(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)
}

// PaintTab draws an option menu tab (i.e. the up and down pointing arrows) in
// the given rectangle on @cr using the given parameters.
func PaintTab(style Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget Widget, detail string, x int, y int, width int, height int) {
	var arg1 *C.GtkStyle
	var arg2 *C.cairo_t
	var arg3 C.GtkStateType
	var arg4 C.GtkShadowType
	var arg5 *C.GtkWidget
	var arg6 *C.gchar
	var arg7 C.gint
	var arg8 C.gint
	var arg9 C.gint
	var arg10 C.gint

	arg1 = (*C.GtkStyle)(style.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = (C.GtkStateType)(stateType)
	arg4 = (C.GtkShadowType)(shadowType)
	arg5 = (*C.GtkWidget)(widget.Native())
	arg6 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(arg6))
	arg7 = C.gint(x)
	arg8 = C.gint(y)
	arg9 = C.gint(width)
	arg10 = C.gint(height)

	C.gtk_paint_tab(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)
}

// PaintVline draws a vertical line from (@x, @y1_) to (@x, @y2_) in @cr using
// the given style and state.
func PaintVline(style Style, cr *cairo.Context, stateType StateType, widget Widget, detail string, y1 int, y2 int, x int) {
	var arg1 *C.GtkStyle
	var arg2 *C.cairo_t
	var arg3 C.GtkStateType
	var arg4 *C.GtkWidget
	var arg5 *C.gchar
	var arg6 C.gint
	var arg7 C.gint
	var arg8 C.gint

	arg1 = (*C.GtkStyle)(style.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = (C.GtkStateType)(stateType)
	arg4 = (*C.GtkWidget)(widget.Native())
	arg5 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(arg5))
	arg6 = C.gint(y1)
	arg7 = C.gint(y2)
	arg8 = C.gint(x)

	C.gtk_paint_vline(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
}

// PaperSizeGetDefault returns the name of the default paper size, which depends
// on the current locale.
func PaperSizeGetDefault() string {

	ret := C.gtk_paper_size_get_default()

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// PaperSizeGetPaperSizes creates a list of known paper sizes.
func PaperSizeGetPaperSizes(includeCustom bool) *glib.List {
	var arg1 C.gboolean

	if includeCustom {
		arg1 = C.TRUE
	}

	ret := C.gtk_paper_size_get_paper_sizes(arg1)

	var ret0 *glib.List

	{
		ret0 = glib.WrapList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.List) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// ParseArgs parses command line arguments, and initializes global attributes of
// GTK+, but does not actually open a connection to a display. (See
// gdk_display_open(), gdk_get_display_arg_name())
//
// Any arguments used by GTK+ or GDK are removed from the array and @argc and
// @argv are updated accordingly.
//
// There is no need to call this function explicitly if you are using
// gtk_init(), or gtk_init_check().
//
// Note that many aspects of GTK+ require a display connection to function, so
// this way of initializing GTK+ is really only useful for specialized use
// cases.
func ParseArgs(argc int, argv []string) bool {
	var arg1 *C.int
	var arg2 ***C.char

	{
		var dst []**C.char
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * len(argv))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(argv)
		sliceHeader.Cap = len(argv)

		for i := 0; i < len(argv); i++ {
			src := argv[i]
			dst[i] = (*C.gchar)(C.CString(src))
		}

		arg2 = (***C.char)(unsafe.Pointer(ptr))
		arg1 = len(argv)
	}

	ret := C.gtk_parse_args(arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// PrintErrorQuark registers an error quark for PrintOperation if necessary.
func PrintErrorQuark() glib.Quark {

	ret := C.gtk_print_error_quark()

	var ret0 glib.Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

// PrintRunPageSetupDialog runs a page setup dialog, letting the user modify the
// values from @page_setup. If the user cancels the dialog, the returned
// PageSetup is identical to the passed in @page_setup, otherwise it contains
// the modifications done in the dialog.
//
// Note that this function may use a recursive mainloop to show the page setup
// dialog. See gtk_print_run_page_setup_dialog_async() if this is a problem.
func PrintRunPageSetupDialog(parent Window, pageSetup PageSetup, settings PrintSettings) PageSetup {
	var arg1 *C.GtkWindow
	var arg2 *C.GtkPageSetup
	var arg3 *C.GtkPrintSettings

	arg1 = (*C.GtkWindow)(parent.Native())
	arg2 = (*C.GtkPageSetup)(pageSetup.Native())
	arg3 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_run_page_setup_dialog(arg1, arg2, arg3)

	var ret0 PageSetup

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(PageSetup)

	return ret0
}

// PrintRunPageSetupDialogAsync runs a page setup dialog, letting the user
// modify the values from @page_setup.
//
// In contrast to gtk_print_run_page_setup_dialog(), this function returns after
// showing the page setup dialog on platforms that support this, and calls
// @done_cb from a signal handler for the ::response signal of the dialog.
func PrintRunPageSetupDialogAsync(parent Window, pageSetup PageSetup, settings PrintSettings, doneCb PageSetupDoneFunc) {
	var arg1 *C.GtkWindow
	var arg2 *C.GtkPageSetup
	var arg3 *C.GtkPrintSettings
	var arg4 C.GtkPageSetupDoneFunc
	var arg5 C.gpointer

	arg1 = (*C.GtkWindow)(parent.Native())
	arg2 = (*C.GtkPageSetup)(pageSetup.Native())
	arg3 = (*C.GtkPrintSettings)(settings.Native())
	arg4 = (*[0]byte)(C.gotk4_PageSetupDoneFunc)
	arg5 = C.gpointer(box.Assign(doneCb))

	C.gtk_print_run_page_setup_dialog_async(arg1, arg2, arg3, arg4, arg5)
}

// RCAddDefaultFile adds a file to the list of files to be parsed at the end of
// gtk_init().
func RCAddDefaultFile(filename string) {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_rc_add_default_file(arg1)
}

// RCFindModuleInPath searches for a theme engine in the GTK+ search path. This
// function is not useful for applications and should not be used.
func RCFindModuleInPath(moduleFile string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(moduleFile))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_rc_find_module_in_path(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// RCFindPixmapInPath looks up a file in pixmap path for the specified Settings.
// If the file is not found, it outputs a warning message using g_warning() and
// returns nil.
func RCFindPixmapInPath(settings Settings, scanner *glib.Scanner, pixmapFile string) string {
	var arg1 *C.GtkSettings
	var arg2 *C.GScanner
	var arg3 *C.gchar

	arg1 = (*C.GtkSettings)(settings.Native())
	arg2 = (*C.GScanner)(scanner.Native())
	arg3 = (*C.gchar)(C.CString(pixmapFile))
	defer C.free(unsafe.Pointer(arg3))

	ret := C.gtk_rc_find_pixmap_in_path(arg1, arg2, arg3)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// RCGetDefaultFiles retrieves the current list of RC files that will be parsed
// at the end of gtk_init().
func RCGetDefaultFiles() []string {

	ret := C.gtk_rc_get_default_files()

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
		}
	}

	return ret0
}

// RCGetImModuleFile obtains the path to the IM modules file. See the
// documentation of the `GTK_IM_MODULE_FILE` environment variable for more
// details.
func RCGetImModuleFile() string {

	ret := C.gtk_rc_get_im_module_file()

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// RCGetImModulePath obtains the path in which to look for IM modules. See the
// documentation of the `GTK_PATH` environment variable for more details about
// looking up modules. This function is useful solely for utilities supplied
// with GTK+ and should not be used by applications under normal circumstances.
func RCGetImModulePath() string {

	ret := C.gtk_rc_get_im_module_path()

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// RCGetModuleDir returns a directory in which GTK+ looks for theme engines. For
// full information about the search for theme engines, see the docs for
// `GTK_PATH` in [Running GTK+ Applications][gtk-running].
func RCGetModuleDir() string {

	ret := C.gtk_rc_get_module_dir()

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// RCGetStyle finds all matching RC styles for a given widget, composites them
// together, and then creates a Style representing the composite appearance.
// (GTK+ actually keeps a cache of previously created styles, so a new style may
// not be created.)
func RCGetStyle(widget Widget) Style {
	var arg1 *C.GtkWidget

	arg1 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_rc_get_style(arg1)

	var ret0 Style

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Style)

	return ret0
}

// RCGetStyleByPaths creates up a Style from styles defined in a RC file by
// providing the raw components used in matching. This function may be useful
// when creating pseudo-widgets that should be themed like widgets but don’t
// actually have corresponding GTK+ widgets. An example of this would be items
// inside a GNOME canvas widget.
//
// The action of gtk_rc_get_style() is similar to:
//
//    gtk_widget_path (widget, NULL, &path, NULL);
//    gtk_widget_class_path (widget, NULL, &class_path, NULL);
//    gtk_rc_get_style_by_paths (gtk_widget_get_settings (widget),
//                               path, class_path,
//                               G_OBJECT_TYPE (widget));
func RCGetStyleByPaths(settings Settings, widgetPath string, classPath string, typ externglib.Type) Style {
	var arg1 *C.GtkSettings
	var arg2 *C.char
	var arg3 *C.char
	var arg4 C.GType

	arg1 = (*C.GtkSettings)(settings.Native())
	arg2 = (*C.gchar)(C.CString(widgetPath))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(classPath))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = C.GType(typ)

	ret := C.gtk_rc_get_style_by_paths(arg1, arg2, arg3, arg4)

	var ret0 Style

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Style)

	return ret0
}

// RCGetThemeDir returns the standard directory in which themes should be
// installed. (GTK+ does not actually use this directory itself.)
func RCGetThemeDir() string {

	ret := C.gtk_rc_get_theme_dir()

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// RCParse parses a given resource file.
func RCParse(filename string) {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_rc_parse(arg1)
}

// RCParseColor parses a color in the format expected in a RC file.
//
// Note that theme engines should use gtk_rc_parse_color_full() in order to
// support symbolic colors.
func RCParseColor(scanner *glib.Scanner) (color gdk.Color, guint uint) {
	var arg1 *C.GScanner
	var arg2 *C.GdkColor // out

	arg1 = (*C.GScanner)(scanner.Native())

	ret := C.gtk_rc_parse_color(arg1, &arg2)

	var ret0 *gdk.Color
	var ret1 uint

	{
		ret0 = gdk.WrapColor(unsafe.Pointer(arg2))
	}

	ret1 = uint(ret)

	return ret0, ret1
}

// RCParseColorFull parses a color in the format expected in a RC file. If
// @style is not nil, it will be consulted to resolve references to symbolic
// colors.
func RCParseColorFull(scanner *glib.Scanner, style RCStyle) (color gdk.Color, guint uint) {
	var arg1 *C.GScanner
	var arg2 *C.GtkRcStyle
	var arg3 *C.GdkColor // out

	arg1 = (*C.GScanner)(scanner.Native())
	arg2 = (*C.GtkRcStyle)(style.Native())

	ret := C.gtk_rc_parse_color_full(arg1, arg2, &arg3)

	var ret0 *gdk.Color
	var ret1 uint

	{
		ret0 = gdk.WrapColor(unsafe.Pointer(arg3))
	}

	ret1 = uint(ret)

	return ret0, ret1
}

// RCParsePriority parses a PathPriorityType variable from the format expected
// in a RC file.
func RCParsePriority(scanner *glib.Scanner, priority *PathPriorityType) uint {
	var arg1 *C.GScanner
	var arg2 *C.GtkPathPriorityType

	arg1 = (*C.GScanner)(scanner.Native())
	arg2 = (*C.GtkPathPriorityType)(priority)

	ret := C.gtk_rc_parse_priority(arg1, arg2)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// RCParseState parses a StateType variable from the format expected in a RC
// file.
func RCParseState(scanner *glib.Scanner) (state StateType, guint uint) {
	var arg1 *C.GScanner
	var arg2 *C.GtkStateType // out

	arg1 = (*C.GScanner)(scanner.Native())

	ret := C.gtk_rc_parse_state(arg1, &arg2)

	var ret0 *StateType
	var ret1 uint

	ret0 = (*StateType)(arg2)

	ret1 = uint(ret)

	return ret0, ret1
}

// RCParseString parses resource information directly from a string.
func RCParseString(rcString string) {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(rcString))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_rc_parse_string(arg1)
}

// RCPropertyParseBorder: a RcPropertyParser for use with
// gtk_settings_install_property_parser() or
// gtk_widget_class_install_style_property_parser() which parses borders in the
// form `"{ left, right, top, bottom }"` for integers left, right, top and
// bottom.
func RCPropertyParseBorder(pspec gobject.ParamSpec, gstring *glib.String, propertyValue *externglib.Value) bool {
	var arg1 *C.GParamSpec
	var arg2 *C.GString
	var arg3 *C.GValue

	arg1 = (*C.GParamSpec)(pspec.Native())
	arg2 = (*C.GString)(gstring.Native())
	arg3 = (*C.GValue)(propertyValue.GValue)

	ret := C.gtk_rc_property_parse_border(arg1, arg2, arg3)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// RCPropertyParseColor: a RcPropertyParser for use with
// gtk_settings_install_property_parser() or
// gtk_widget_class_install_style_property_parser() which parses a color given
// either by its name or in the form `{ red, green, blue }` where red, green and
// blue are integers between 0 and 65535 or floating-point numbers between 0 and
// 1.
func RCPropertyParseColor(pspec gobject.ParamSpec, gstring *glib.String, propertyValue *externglib.Value) bool {
	var arg1 *C.GParamSpec
	var arg2 *C.GString
	var arg3 *C.GValue

	arg1 = (*C.GParamSpec)(pspec.Native())
	arg2 = (*C.GString)(gstring.Native())
	arg3 = (*C.GValue)(propertyValue.GValue)

	ret := C.gtk_rc_property_parse_color(arg1, arg2, arg3)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// RCPropertyParseEnum: a RcPropertyParser for use with
// gtk_settings_install_property_parser() or
// gtk_widget_class_install_style_property_parser() which parses a single
// enumeration value.
//
// The enumeration value can be specified by its name, its nickname or its
// numeric value. For consistency with flags parsing, the value may be
// surrounded by parentheses.
func RCPropertyParseEnum(pspec gobject.ParamSpec, gstring *glib.String, propertyValue *externglib.Value) bool {
	var arg1 *C.GParamSpec
	var arg2 *C.GString
	var arg3 *C.GValue

	arg1 = (*C.GParamSpec)(pspec.Native())
	arg2 = (*C.GString)(gstring.Native())
	arg3 = (*C.GValue)(propertyValue.GValue)

	ret := C.gtk_rc_property_parse_enum(arg1, arg2, arg3)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// RCPropertyParseFlags: a RcPropertyParser for use with
// gtk_settings_install_property_parser() or
// gtk_widget_class_install_style_property_parser() which parses flags.
//
// Flags can be specified by their name, their nickname or numerically. Multiple
// flags can be specified in the form `"( flag1 | flag2 | ... )"`.
func RCPropertyParseFlags(pspec gobject.ParamSpec, gstring *glib.String, propertyValue *externglib.Value) bool {
	var arg1 *C.GParamSpec
	var arg2 *C.GString
	var arg3 *C.GValue

	arg1 = (*C.GParamSpec)(pspec.Native())
	arg2 = (*C.GString)(gstring.Native())
	arg3 = (*C.GValue)(propertyValue.GValue)

	ret := C.gtk_rc_property_parse_flags(arg1, arg2, arg3)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// RCPropertyParseRequisition: a RcPropertyParser for use with
// gtk_settings_install_property_parser() or
// gtk_widget_class_install_style_property_parser() which parses a requisition
// in the form `"{ width, height }"` for integers width and height.
func RCPropertyParseRequisition(pspec gobject.ParamSpec, gstring *glib.String, propertyValue *externglib.Value) bool {
	var arg1 *C.GParamSpec
	var arg2 *C.GString
	var arg3 *C.GValue

	arg1 = (*C.GParamSpec)(pspec.Native())
	arg2 = (*C.GString)(gstring.Native())
	arg3 = (*C.GValue)(propertyValue.GValue)

	ret := C.gtk_rc_property_parse_requisition(arg1, arg2, arg3)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// RCReparseAll: if the modification time on any previously read file for the
// default Settings has changed, discard all style information and then reread
// all previously read RC files.
func RCReparseAll() bool {

	ret := C.gtk_rc_reparse_all()

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// RCReparseAllForSettings: if the modification time on any previously read file
// for the given Settings has changed, discard all style information and then
// reread all previously read RC files.
func RCReparseAllForSettings(settings Settings, forceLoad bool) bool {
	var arg1 *C.GtkSettings
	var arg2 C.gboolean

	arg1 = (*C.GtkSettings)(settings.Native())
	if forceLoad {
		arg2 = C.TRUE
	}

	ret := C.gtk_rc_reparse_all_for_settings(arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// RCResetStyles: this function recomputes the styles for all widgets that use a
// particular Settings object. (There is one Settings object per Screen, see
// gtk_settings_get_for_screen()); It is useful when some global parameter has
// changed that affects the appearance of all widgets, because when a widget
// gets a new style, it will both redraw and recompute any cached information
// about its appearance. As an example, it is used when the default font size
// set by the operating system changes. Note that this function doesn’t affect
// widgets that have a style set explicitly on them with gtk_widget_set_style().
func RCResetStyles(settings Settings) {
	var arg1 *C.GtkSettings

	arg1 = (*C.GtkSettings)(settings.Native())

	C.gtk_rc_reset_styles(arg1)
}

func NewRCScanner() *glib.Scanner {

	ret := C.gtk_rc_scanner_new()

	var ret0 *glib.Scanner

	{
		ret0 = glib.WrapScanner(unsafe.Pointer(ret))
	}

	return ret0
}

// RCSetDefaultFiles sets the list of files that GTK+ will read at the end of
// gtk_init().
func RCSetDefaultFiles(filenames []string) {
	var arg1 **C.gchar

	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(filenames) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(filenames)
		sliceHeader.Cap = len(filenames)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(filenames); i++ {
			src := filenames[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg1 = (**C.gchar)(unsafe.Pointer(ptr))
	}

	C.gtk_rc_set_default_files(arg1)
}

func RecentChooserErrorQuark() glib.Quark {

	ret := C.gtk_recent_chooser_error_quark()

	var ret0 glib.Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

func RecentManagerErrorQuark() glib.Quark {

	ret := C.gtk_recent_manager_error_quark()

	var ret0 glib.Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

// RenderActivity renders an activity indicator (such as in Spinner). The state
// GTK_STATE_FLAG_CHECKED determines whether there is activity going on.
func RenderActivity(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var arg1 *C.GtkStyleContext
	var arg2 *C.cairo_t
	var arg3 C.gdouble
	var arg4 C.gdouble
	var arg5 C.gdouble
	var arg6 C.gdouble

	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = C.gdouble(x)
	arg4 = C.gdouble(y)
	arg5 = C.gdouble(width)
	arg6 = C.gdouble(height)

	C.gtk_render_activity(arg1, arg2, arg3, arg4, arg5, arg6)
}

// RenderArrow renders an arrow pointing to @angle.
//
// Typical arrow rendering at 0, 1⁄2 π;, π; and 3⁄2 π:
//
// ! (arrows.png)
func RenderArrow(context StyleContext, cr *cairo.Context, angle float64, x float64, y float64, size float64) {
	var arg1 *C.GtkStyleContext
	var arg2 *C.cairo_t
	var arg3 C.gdouble
	var arg4 C.gdouble
	var arg5 C.gdouble
	var arg6 C.gdouble

	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = C.gdouble(angle)
	arg4 = C.gdouble(x)
	arg5 = C.gdouble(y)
	arg6 = C.gdouble(size)

	C.gtk_render_arrow(arg1, arg2, arg3, arg4, arg5, arg6)
}

// RenderBackground renders the background of an element.
//
// Typical background rendering, showing the effect of `background-image`,
// `border-width` and `border-radius`:
//
// ! (background.png)
func RenderBackground(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var arg1 *C.GtkStyleContext
	var arg2 *C.cairo_t
	var arg3 C.gdouble
	var arg4 C.gdouble
	var arg5 C.gdouble
	var arg6 C.gdouble

	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = C.gdouble(x)
	arg4 = C.gdouble(y)
	arg5 = C.gdouble(width)
	arg6 = C.gdouble(height)

	C.gtk_render_background(arg1, arg2, arg3, arg4, arg5, arg6)
}

// RenderBackgroundGetClip returns the area that will be affected (i.e. drawn
// to) when calling gtk_render_background() for the given @context and
// rectangle.
func RenderBackgroundGetClip(context StyleContext, x float64, y float64, width float64, height float64) gdk.Rectangle {
	var arg1 *C.GtkStyleContext
	var arg2 C.gdouble
	var arg3 C.gdouble
	var arg4 C.gdouble
	var arg5 C.gdouble
	var arg6 *C.GdkRectangle // out

	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = C.gdouble(x)
	arg3 = C.gdouble(y)
	arg4 = C.gdouble(width)
	arg5 = C.gdouble(height)

	C.gtk_render_background_get_clip(arg1, arg2, arg3, arg4, arg5, &arg6)

	var ret0 *gdk.Rectangle

	{
		ret0 = gdk.WrapRectangle(unsafe.Pointer(arg6))
	}

	return ret0
}

// RenderCheck renders a checkmark (as in a CheckButton).
//
// The GTK_STATE_FLAG_CHECKED state determines whether the check is on or off,
// and GTK_STATE_FLAG_INCONSISTENT determines whether it should be marked as
// undefined.
//
// Typical checkmark rendering:
//
// ! (checks.png)
func RenderCheck(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var arg1 *C.GtkStyleContext
	var arg2 *C.cairo_t
	var arg3 C.gdouble
	var arg4 C.gdouble
	var arg5 C.gdouble
	var arg6 C.gdouble

	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = C.gdouble(x)
	arg4 = C.gdouble(y)
	arg5 = C.gdouble(width)
	arg6 = C.gdouble(height)

	C.gtk_render_check(arg1, arg2, arg3, arg4, arg5, arg6)
}

// RenderExpander renders an expander (as used in TreeView and Expander) in the
// area defined by @x, @y, @width, @height. The state GTK_STATE_FLAG_CHECKED
// determines whether the expander is collapsed or expanded.
//
// Typical expander rendering:
//
// ! (expanders.png)
func RenderExpander(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var arg1 *C.GtkStyleContext
	var arg2 *C.cairo_t
	var arg3 C.gdouble
	var arg4 C.gdouble
	var arg5 C.gdouble
	var arg6 C.gdouble

	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = C.gdouble(x)
	arg4 = C.gdouble(y)
	arg5 = C.gdouble(width)
	arg6 = C.gdouble(height)

	C.gtk_render_expander(arg1, arg2, arg3, arg4, arg5, arg6)
}

// RenderExtension renders a extension (as in a Notebook tab) in the rectangle
// defined by @x, @y, @width, @height. The side where the extension connects to
// is defined by @gap_side.
//
// Typical extension rendering:
//
// ! (extensions.png)
func RenderExtension(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64, gapSide PositionType) {
	var arg1 *C.GtkStyleContext
	var arg2 *C.cairo_t
	var arg3 C.gdouble
	var arg4 C.gdouble
	var arg5 C.gdouble
	var arg6 C.gdouble
	var arg7 C.GtkPositionType

	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = C.gdouble(x)
	arg4 = C.gdouble(y)
	arg5 = C.gdouble(width)
	arg6 = C.gdouble(height)
	arg7 = (C.GtkPositionType)(gapSide)

	C.gtk_render_extension(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
}

// RenderFocus renders a focus indicator on the rectangle determined by @x, @y,
// @width, @height.
//
// Typical focus rendering:
//
// ! (focus.png)
func RenderFocus(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var arg1 *C.GtkStyleContext
	var arg2 *C.cairo_t
	var arg3 C.gdouble
	var arg4 C.gdouble
	var arg5 C.gdouble
	var arg6 C.gdouble

	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = C.gdouble(x)
	arg4 = C.gdouble(y)
	arg5 = C.gdouble(width)
	arg6 = C.gdouble(height)

	C.gtk_render_focus(arg1, arg2, arg3, arg4, arg5, arg6)
}

// RenderFrame renders a frame around the rectangle defined by @x, @y, @width,
// @height.
//
// Examples of frame rendering, showing the effect of `border-image`,
// `border-color`, `border-width`, `border-radius` and junctions:
//
// ! (frames.png)
func RenderFrame(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var arg1 *C.GtkStyleContext
	var arg2 *C.cairo_t
	var arg3 C.gdouble
	var arg4 C.gdouble
	var arg5 C.gdouble
	var arg6 C.gdouble

	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = C.gdouble(x)
	arg4 = C.gdouble(y)
	arg5 = C.gdouble(width)
	arg6 = C.gdouble(height)

	C.gtk_render_frame(arg1, arg2, arg3, arg4, arg5, arg6)
}

// RenderFrameGap renders a frame around the rectangle defined by (@x, @y,
// @width, @height), leaving a gap on one side. @xy0_gap and @xy1_gap will mean
// X coordinates for GTK_POS_TOP and GTK_POS_BOTTOM gap sides, and Y coordinates
// for GTK_POS_LEFT and GTK_POS_RIGHT.
//
// Typical rendering of a frame with a gap:
//
// ! (frame-gap.png)
func RenderFrameGap(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64, gapSide PositionType, xy0Gap float64, xy1Gap float64) {
	var arg1 *C.GtkStyleContext
	var arg2 *C.cairo_t
	var arg3 C.gdouble
	var arg4 C.gdouble
	var arg5 C.gdouble
	var arg6 C.gdouble
	var arg7 C.GtkPositionType
	var arg8 C.gdouble
	var arg9 C.gdouble

	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = C.gdouble(x)
	arg4 = C.gdouble(y)
	arg5 = C.gdouble(width)
	arg6 = C.gdouble(height)
	arg7 = (C.GtkPositionType)(gapSide)
	arg8 = C.gdouble(xy0Gap)
	arg9 = C.gdouble(xy1Gap)

	C.gtk_render_frame_gap(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
}

// RenderHandle renders a handle (as in HandleBox, Paned and Window’s resize
// grip), in the rectangle determined by @x, @y, @width, @height.
//
// Handles rendered for the paned and grip classes:
//
// ! (handles.png)
func RenderHandle(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var arg1 *C.GtkStyleContext
	var arg2 *C.cairo_t
	var arg3 C.gdouble
	var arg4 C.gdouble
	var arg5 C.gdouble
	var arg6 C.gdouble

	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = C.gdouble(x)
	arg4 = C.gdouble(y)
	arg5 = C.gdouble(width)
	arg6 = C.gdouble(height)

	C.gtk_render_handle(arg1, arg2, arg3, arg4, arg5, arg6)
}

// RenderIcon renders the icon in @pixbuf at the specified @x and @y
// coordinates.
//
// This function will render the icon in @pixbuf at exactly its size, regardless
// of scaling factors, which may not be appropriate when drawing on displays
// with high pixel densities.
//
// You probably want to use gtk_render_icon_surface() instead, if you already
// have a Cairo surface.
func RenderIcon(context StyleContext, cr *cairo.Context, pixbuf gdkpixbuf.Pixbuf, x float64, y float64) {
	var arg1 *C.GtkStyleContext
	var arg2 *C.cairo_t
	var arg3 *C.GdkPixbuf
	var arg4 C.gdouble
	var arg5 C.gdouble

	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = (*C.GdkPixbuf)(pixbuf.Native())
	arg4 = C.gdouble(x)
	arg5 = C.gdouble(y)

	C.gtk_render_icon(arg1, arg2, arg3, arg4, arg5)
}

// RenderIconPixbuf renders the icon specified by @source at the given @size,
// returning the result in a pixbuf.
func RenderIconPixbuf(context StyleContext, source *IconSource, size int) gdkpixbuf.Pixbuf {
	var arg1 *C.GtkStyleContext
	var arg2 *C.GtkIconSource
	var arg3 C.GtkIconSize

	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = (*C.GtkIconSource)(source.Native())
	arg3 = C.GtkIconSize(size)

	ret := C.gtk_render_icon_pixbuf(arg1, arg2, arg3)

	var ret0 gdkpixbuf.Pixbuf

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gdkpixbuf.Pixbuf)

	return ret0
}

// RenderIconSurface renders the icon in @surface at the specified @x and @y
// coordinates.
func RenderIconSurface(context StyleContext, cr *cairo.Context, surface *cairo.Surface, x float64, y float64) {
	var arg1 *C.GtkStyleContext
	var arg2 *C.cairo_t
	var arg3 *C.cairo_surface_t
	var arg4 C.gdouble
	var arg5 C.gdouble

	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = (*C.cairo_surface_t)(surface.Native())
	arg4 = C.gdouble(x)
	arg5 = C.gdouble(y)

	C.gtk_render_icon_surface(arg1, arg2, arg3, arg4, arg5)
}

// RenderInsertionCursor draws a text caret on @cr at the specified index of
// @layout.
func RenderInsertionCursor(context StyleContext, cr *cairo.Context, x float64, y float64, layout pango.Layout, index int, direction pango.Direction) {
	var arg1 *C.GtkStyleContext
	var arg2 *C.cairo_t
	var arg3 C.gdouble
	var arg4 C.gdouble
	var arg5 *C.PangoLayout
	var arg6 C.int
	var arg7 C.PangoDirection

	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = C.gdouble(x)
	arg4 = C.gdouble(y)
	arg5 = (*C.PangoLayout)(layout.Native())
	arg6 = C.int(index)
	arg7 = (C.PangoDirection)(direction)

	C.gtk_render_insertion_cursor(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
}

// RenderLayout renders @layout on the coordinates @x, @y
func RenderLayout(context StyleContext, cr *cairo.Context, x float64, y float64, layout pango.Layout) {
	var arg1 *C.GtkStyleContext
	var arg2 *C.cairo_t
	var arg3 C.gdouble
	var arg4 C.gdouble
	var arg5 *C.PangoLayout

	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = C.gdouble(x)
	arg4 = C.gdouble(y)
	arg5 = (*C.PangoLayout)(layout.Native())

	C.gtk_render_layout(arg1, arg2, arg3, arg4, arg5)
}

// RenderLine renders a line from (x0, y0) to (x1, y1).
func RenderLine(context StyleContext, cr *cairo.Context, x0 float64, y0 float64, x1 float64, y1 float64) {
	var arg1 *C.GtkStyleContext
	var arg2 *C.cairo_t
	var arg3 C.gdouble
	var arg4 C.gdouble
	var arg5 C.gdouble
	var arg6 C.gdouble

	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = C.gdouble(x0)
	arg4 = C.gdouble(y0)
	arg5 = C.gdouble(x1)
	arg6 = C.gdouble(y1)

	C.gtk_render_line(arg1, arg2, arg3, arg4, arg5, arg6)
}

// RenderOption renders an option mark (as in a RadioButton), the
// GTK_STATE_FLAG_CHECKED state will determine whether the option is on or off,
// and GTK_STATE_FLAG_INCONSISTENT whether it should be marked as undefined.
//
// Typical option mark rendering:
//
// ! (options.png)
func RenderOption(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var arg1 *C.GtkStyleContext
	var arg2 *C.cairo_t
	var arg3 C.gdouble
	var arg4 C.gdouble
	var arg5 C.gdouble
	var arg6 C.gdouble

	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = C.gdouble(x)
	arg4 = C.gdouble(y)
	arg5 = C.gdouble(width)
	arg6 = C.gdouble(height)

	C.gtk_render_option(arg1, arg2, arg3, arg4, arg5, arg6)
}

// RenderSlider renders a slider (as in Scale) in the rectangle defined by @x,
// @y, @width, @height. @orientation defines whether the slider is vertical or
// horizontal.
//
// Typical slider rendering:
//
// ! (sliders.png)
func RenderSlider(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64, orientation Orientation) {
	var arg1 *C.GtkStyleContext
	var arg2 *C.cairo_t
	var arg3 C.gdouble
	var arg4 C.gdouble
	var arg5 C.gdouble
	var arg6 C.gdouble
	var arg7 C.GtkOrientation

	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = C.gdouble(x)
	arg4 = C.gdouble(y)
	arg5 = C.gdouble(width)
	arg6 = C.gdouble(height)
	arg7 = (C.GtkOrientation)(orientation)

	C.gtk_render_slider(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
}

// RGBToHSV converts a color from RGB space to HSV.
//
// Input values must be in the [0.0, 1.0] range; output values will be in the
// same range.
func RGBToHSV(r float64, g float64, b float64) (h float64, s float64, v float64) {
	var arg1 C.gdouble
	var arg2 C.gdouble
	var arg3 C.gdouble
	var arg4 *C.gdouble // out
	var arg5 *C.gdouble // out
	var arg6 *C.gdouble // out

	arg1 = C.gdouble(r)
	arg2 = C.gdouble(g)
	arg3 = C.gdouble(b)

	C.gtk_rgb_to_hsv(arg1, arg2, arg3, &arg4, &arg5, &arg6)

	var ret0 float64
	var ret1 float64
	var ret2 float64

	ret0 = float64(arg4)

	ret1 = float64(arg5)

	ret2 = float64(arg6)

	return ret0, ret1, ret2
}

// SelectionAddTarget appends a specified target to the list of supported
// targets for a given widget and selection.
func SelectionAddTarget(widget Widget, selection gdk.Atom, target gdk.Atom, info uint) {
	var arg1 *C.GtkWidget
	var arg2 C.GdkAtom
	var arg3 C.GdkAtom
	var arg4 C.guint

	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = (C.GdkAtom)(selection.Native())
	arg3 = (C.GdkAtom)(target.Native())
	arg4 = C.guint(info)

	C.gtk_selection_add_target(arg1, arg2, arg3, arg4)
}

// SelectionAddTargets prepends a table of targets to the list of supported
// targets for a given widget and selection.
func SelectionAddTargets(widget Widget, selection gdk.Atom, targets []TargetEntry) {
	var arg1 *C.GtkWidget
	var arg2 C.GdkAtom
	var arg3 *C.GtkTargetEntry
	var arg4 C.guint

	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = (C.GdkAtom)(selection.Native())
	{
		var dst []C.GtkTargetEntry
		ptr := C.malloc(C.sizeof_GtkTargetEntry * len(targets))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(targets)
		sliceHeader.Cap = len(targets)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(targets); i++ {
			src := targets[i]
			dst[i] = (C.GtkTargetEntry)(src.Native())
		}

		arg3 = (*C.GtkTargetEntry)(unsafe.Pointer(ptr))
		arg4 = len(targets)
	}

	C.gtk_selection_add_targets(arg1, arg2, arg3, arg4)
}

// SelectionClearTargets: remove all targets registered for the given selection
// for the widget.
func SelectionClearTargets(widget Widget, selection gdk.Atom) {
	var arg1 *C.GtkWidget
	var arg2 C.GdkAtom

	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = (C.GdkAtom)(selection.Native())

	C.gtk_selection_clear_targets(arg1, arg2)
}

// SelectionConvert requests the contents of a selection. When received, a
// “selection-received” signal will be generated.
func SelectionConvert(widget Widget, selection gdk.Atom, target gdk.Atom, time_ uint32) bool {
	var arg1 *C.GtkWidget
	var arg2 C.GdkAtom
	var arg3 C.GdkAtom
	var arg4 C.guint32

	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = (C.GdkAtom)(selection.Native())
	arg3 = (C.GdkAtom)(target.Native())
	arg4 = C.guint32(time_)

	ret := C.gtk_selection_convert(arg1, arg2, arg3, arg4)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SelectionOwnerSet claims ownership of a given selection for a particular
// widget, or, if @widget is nil, release ownership of the selection.
func SelectionOwnerSet(widget Widget, selection gdk.Atom, time_ uint32) bool {
	var arg1 *C.GtkWidget
	var arg2 C.GdkAtom
	var arg3 C.guint32

	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = (C.GdkAtom)(selection.Native())
	arg3 = C.guint32(time_)

	ret := C.gtk_selection_owner_set(arg1, arg2, arg3)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SelectionOwnerSetForDisplay: claim ownership of a given selection for a
// particular widget, or, if @widget is nil, release ownership of the selection.
func SelectionOwnerSetForDisplay(display gdk.Display, widget Widget, selection gdk.Atom, time_ uint32) bool {
	var arg1 *C.GdkDisplay
	var arg2 *C.GtkWidget
	var arg3 C.GdkAtom
	var arg4 C.guint32

	arg1 = (*C.GdkDisplay)(display.Native())
	arg2 = (*C.GtkWidget)(widget.Native())
	arg3 = (C.GdkAtom)(selection.Native())
	arg4 = C.guint32(time_)

	ret := C.gtk_selection_owner_set_for_display(arg1, arg2, arg3, arg4)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SelectionRemoveAll removes all handlers and unsets ownership of all
// selections for a widget. Called when widget is being destroyed. This function
// will not generally be called by applications.
func SelectionRemoveAll(widget Widget) {
	var arg1 *C.GtkWidget

	arg1 = (*C.GtkWidget)(widget.Native())

	C.gtk_selection_remove_all(arg1)
}

// SetDebugFlags sets the GTK+ debug flags.
func SetDebugFlags(flags uint) {
	var arg1 C.guint

	arg1 = C.guint(flags)

	C.gtk_set_debug_flags(arg1)
}

// ShowURI: a convenience function for launching the default application to show
// the uri. Like gtk_show_uri_on_window(), but takes a screen as transient
// parent instead of a window.
//
// Note that this function is deprecated as it does not pass the necessary
// information for helpers to parent their dialog properly, when run from
// sandboxed applications for example.
func ShowURI(screen gdk.Screen, uri string, timestamp uint32) error {
	var arg1 *C.GdkScreen
	var arg2 *C.gchar
	var arg3 C.guint32
	var gError *C.GError

	arg1 = (*C.GdkScreen)(screen.Native())
	arg2 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.guint32(timestamp)

	ret := C.gtk_show_uri(arg1, arg2, arg3, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// ShowURIOnWindow: this is a convenience function for launching the default
// application to show the uri. The uri must be of a form understood by GIO
// (i.e. you need to install gvfs to get support for uri schemes such as http://
// or ftp://, as only local files are handled by GIO itself). Typical examples
// are - `file:///home/gnome/pict.jpg` - `http://www.gnome.org` -
// `mailto:me@gnome.org`
//
// Ideally the timestamp is taken from the event triggering the gtk_show_uri()
// call. If timestamp is not known you can take GDK_CURRENT_TIME.
//
// This is the recommended call to be used as it passes information necessary
// for sandbox helpers to parent their dialogs properly.
func ShowURIOnWindow(parent Window, uri string, timestamp uint32) error {
	var arg1 *C.GtkWindow
	var arg2 *C.char
	var arg3 C.guint32
	var gError *C.GError

	arg1 = (*C.GtkWindow)(parent.Native())
	arg2 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.guint32(timestamp)

	ret := C.gtk_show_uri_on_window(arg1, arg2, arg3, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// StockAdd registers each of the stock items in @items. If an item already
// exists with the same stock ID as one of the @items, the old item gets
// replaced. The stock items are copied, so GTK+ does not hold any pointer into
// @items and @items can be freed. Use gtk_stock_add_static() if @items is
// persistent and GTK+ need not copy the array.
func StockAdd(items []StockItem) {
	var arg1 *C.GtkStockItem
	var arg2 C.guint

	{
		var dst []C.GtkStockItem
		ptr := C.malloc(C.sizeof_GtkStockItem * len(items))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(items)
		sliceHeader.Cap = len(items)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(items); i++ {
			src := items[i]
			dst[i] = (C.GtkStockItem)(src.Native())
		}

		arg1 = (*C.GtkStockItem)(unsafe.Pointer(ptr))
		arg2 = len(items)
	}

	C.gtk_stock_add(arg1, arg2)
}

// StockAddStatic: same as gtk_stock_add(), but doesn’t copy @items, so @items
// must persist until application exit.
func StockAddStatic(items []StockItem) {
	var arg1 *C.GtkStockItem
	var arg2 C.guint

	{
		var dst []C.GtkStockItem
		ptr := C.malloc(C.sizeof_GtkStockItem * len(items))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(items)
		sliceHeader.Cap = len(items)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(items); i++ {
			src := items[i]
			dst[i] = (C.GtkStockItem)(src.Native())
		}

		arg1 = (*C.GtkStockItem)(unsafe.Pointer(ptr))
		arg2 = len(items)
	}

	C.gtk_stock_add_static(arg1, arg2)
}

// StockListIds retrieves a list of all known stock IDs added to a IconFactory
// or registered with gtk_stock_add(). The list must be freed with
// g_slist_free(), and each string in the list must be freed with g_free().
func StockListIds() *glib.SList {

	ret := C.gtk_stock_list_ids()

	var ret0 *glib.SList

	{
		ret0 = glib.WrapSList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.SList) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// StockLookup fills @item with the registered values for @stock_id, returning
// true if @stock_id was known.
func StockLookup(stockID string) (item StockItem, ok bool) {
	var arg1 *C.gchar
	var arg2 *C.GtkStockItem // out

	arg1 = (*C.gchar)(C.CString(stockID))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_stock_lookup(arg1, &arg2)

	var ret0 *StockItem
	var ret1 bool

	{
		ret0 = WrapStockItem(unsafe.Pointer(arg2))
	}

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// StockSetTranslateFunc sets a function to be used for translating the @label
// of a stock item.
//
// If no function is registered for a translation domain, g_dgettext() is used.
//
// The function is used for all stock items whose @translation_domain matches
// @domain. Note that it is possible to use strings different from the actual
// gettext translation domain of your application for this, as long as your
// TranslateFunc uses the correct domain when calling dgettext(). This can be
// useful, e.g. when dealing with message contexts:
//
//    GtkStockItem items[] = {
//     { MY_ITEM1, NC_("odd items", "Item 1"), 0, 0, "odd-item-domain" },
//     { MY_ITEM2, NC_("even items", "Item 2"), 0, 0, "even-item-domain" },
//    };
//
//    gchar *
//    my_translate_func (const gchar *msgid,
//                       gpointer     data)
//    {
//      gchar *msgctxt = data;
//
//      return (gchar*)g_dpgettext2 (GETTEXT_PACKAGE, msgctxt, msgid);
//    }
//
//    ...
//
//    gtk_stock_add (items, G_N_ELEMENTS (items));
//    gtk_stock_set_translate_func ("odd-item-domain", my_translate_func, "odd items");
//    gtk_stock_set_translate_func ("even-item-domain", my_translate_func, "even items");
func StockSetTranslateFunc(domain string, fn TranslateFunc) {
	var arg1 *C.gchar
	var arg2 C.GtkTranslateFunc
	var arg3 C.gpointer
	var arg4 C.GDestroyNotify

	arg1 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*[0]byte)(C.gotk4_TranslateFunc)
	arg3 = C.gpointer(box.Assign(fn))
	arg4 = (*[0]byte)(C.callbackDelete)

	C.gtk_stock_set_translate_func(arg1, arg2, arg3, arg4)
}

// TargetTableFree: this function frees a target table as returned by
// gtk_target_table_new_from_list()
func TargetTableFree(targets []TargetEntry) {
	var arg1 *C.GtkTargetEntry
	var arg2 C.gint

	{
		var dst []C.GtkTargetEntry
		ptr := C.malloc(C.sizeof_GtkTargetEntry * len(targets))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(targets)
		sliceHeader.Cap = len(targets)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(targets); i++ {
			src := targets[i]
			dst[i] = (C.GtkTargetEntry)(src.Native())
		}

		arg1 = (*C.GtkTargetEntry)(unsafe.Pointer(ptr))
		arg2 = len(targets)
	}

	C.gtk_target_table_free(arg1, arg2)
}

// TargetTableNewFromList: this function creates an TargetEntry array that
// contains the same targets as the passed list. The returned table is newly
// allocated and should be freed using gtk_target_table_free() when no longer
// needed.
func TargetTableNewFromList(list *TargetList) (nTargets int, targetEntrys []TargetEntry) {
	var arg1 *C.GtkTargetList
	var arg2 *C.gint // out

	arg1 = (*C.GtkTargetList)(list.Native())

	ret := C.gtk_target_table_new_from_list(arg1, &arg2)

	var ret0 int
	var ret1 []TargetEntry

	ret0 = int(arg2)

	{
		ret1 = make([]TargetEntry, arg2)
		for i := 0; i < uintptr(arg2); i++ {
			src := (C.GtkTargetEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			{
				ret1[i] = WrapTargetEntry(unsafe.Pointer(src))
				runtime.SetFinalizer(&ret1[i], func(v *TargetEntry) {
					C.free(unsafe.Pointer(v.Native()))
				})
			}
		}
	}

	return ret0, ret1
}

// TargetsIncludeImage determines if any of the targets in @targets can be used
// to provide a Pixbuf.
func TargetsIncludeImage(targets []gdk.Atom, writable bool) bool {
	var arg1 *C.GdkAtom
	var arg2 C.gint
	var arg3 C.gboolean

	arg1 = (*C.GdkAtom)(unsafe.Pointer(&targets[0]))
	arg2 = len(targets)
	defer runtime.KeepAlive(targets)
	if writable {
		arg3 = C.TRUE
	}

	ret := C.gtk_targets_include_image(arg1, arg2, arg3)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// TargetsIncludeRichText determines if any of the targets in @targets can be
// used to provide rich text.
func TargetsIncludeRichText(targets []gdk.Atom, buffer TextBuffer) bool {
	var arg1 *C.GdkAtom
	var arg2 C.gint
	var arg3 *C.GtkTextBuffer

	arg1 = (*C.GdkAtom)(unsafe.Pointer(&targets[0]))
	arg2 = len(targets)
	defer runtime.KeepAlive(targets)
	arg3 = (*C.GtkTextBuffer)(buffer.Native())

	ret := C.gtk_targets_include_rich_text(arg1, arg2, arg3)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// TargetsIncludeText determines if any of the targets in @targets can be used
// to provide text.
func TargetsIncludeText(targets []gdk.Atom) bool {
	var arg1 *C.GdkAtom
	var arg2 C.gint

	arg1 = (*C.GdkAtom)(unsafe.Pointer(&targets[0]))
	arg2 = len(targets)
	defer runtime.KeepAlive(targets)

	ret := C.gtk_targets_include_text(arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// TargetsIncludeURI determines if any of the targets in @targets can be used to
// provide an uri list.
func TargetsIncludeURI(targets []gdk.Atom) bool {
	var arg1 *C.GdkAtom
	var arg2 C.gint

	arg1 = (*C.GdkAtom)(unsafe.Pointer(&targets[0]))
	arg2 = len(targets)
	defer runtime.KeepAlive(targets)

	ret := C.gtk_targets_include_uri(arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// TestCreateSimpleWindow: create a simple window with window title
// @window_title and text contents @dialog_text. The window will quit any
// running gtk_main()-loop when destroyed, and it will automatically be
// destroyed upon test function teardown.
func TestCreateSimpleWindow(windowTitle string, dialogText string) Widget {
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg1 = (*C.gchar)(C.CString(windowTitle))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(dialogText))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_test_create_simple_window(arg1, arg2)

	var ret0 Widget

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Widget)

	return ret0
}

// TestFindLabel: this function will search @widget and all its descendants for
// a GtkLabel widget with a text string matching @label_pattern. The
// @label_pattern may contain asterisks “*” and question marks “?” as
// placeholders, g_pattern_match() is used for the matching. Note that locales
// other than "C“ tend to alter (translate” label strings, so this function is
// genrally only useful in test programs with predetermined locales, see
// gtk_test_init() for more details.
func TestFindLabel(widget Widget, labelPattern string) Widget {
	var arg1 *C.GtkWidget
	var arg2 *C.gchar

	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = (*C.gchar)(C.CString(labelPattern))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_test_find_label(arg1, arg2)

	var ret0 Widget

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Widget)

	return ret0
}

// TestFindSibling: this function will search siblings of @base_widget and
// siblings of its ancestors for all widgets matching @widget_type. Of the
// matching widgets, the one that is geometrically closest to @base_widget will
// be returned. The general purpose of this function is to find the most likely
// “action” widget, relative to another labeling widget. Such as finding a
// button or text entry widget, given its corresponding label widget.
func TestFindSibling(baseWidget Widget, widgetType externglib.Type) Widget {
	var arg1 *C.GtkWidget
	var arg2 C.GType

	arg1 = (*C.GtkWidget)(baseWidget.Native())
	arg2 = C.GType(widgetType)

	ret := C.gtk_test_find_sibling(arg1, arg2)

	var ret0 Widget

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Widget)

	return ret0
}

// TestFindWidget: this function will search the descendants of @widget for a
// widget of type @widget_type that has a label matching @label_pattern next to
// it. This is most useful for automated GUI testing, e.g. to find the “OK”
// button in a dialog and synthesize clicks on it. However see
// gtk_test_find_label(), gtk_test_find_sibling() and gtk_test_widget_click()
// for possible caveats involving the search of such widgets and synthesizing
// widget events.
func TestFindWidget(widget Widget, labelPattern string, widgetType externglib.Type) Widget {
	var arg1 *C.GtkWidget
	var arg2 *C.gchar
	var arg3 C.GType

	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = (*C.gchar)(C.CString(labelPattern))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.GType(widgetType)

	ret := C.gtk_test_find_widget(arg1, arg2, arg3)

	var ret0 Widget

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Widget)

	return ret0
}

// TestListAllTypes: return the type ids that have been registered after calling
// gtk_test_register_all_types().
func TestListAllTypes() (nTypes uint, gTypes []externglib.Type) {
	var arg1 *C.guint // out

	ret := C.gtk_test_list_all_types(&arg1)

	var ret0 uint
	var ret1 []externglib.Type

	ret0 = uint(arg1)

	{
		ret1 = make([]externglib.Type, arg1)
		for i := 0; i < uintptr(arg1); i++ {
			src := (C.GType)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = externglib.Type(src)
		}
	}

	return ret0, ret1
}

// TestRegisterAllTypes: force registration of all core Gtk+ and Gdk object
// types. This allowes to refer to any of those object types via
// g_type_from_name() after calling this function.
func TestRegisterAllTypes() {

	C.gtk_test_register_all_types()
}

// TestSliderGetValue: retrive the literal adjustment value for GtkRange based
// widgets and spin buttons. Note that the value returned by this function is
// anything between the lower and upper bounds of the adjustment belonging to
// @widget, and is not a percentage as passed in to gtk_test_slider_set_perc().
func TestSliderGetValue(widget Widget) float64 {
	var arg1 *C.GtkWidget

	arg1 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_test_slider_get_value(arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// TestSliderSetPerc: this function will adjust the slider position of all
// GtkRange based widgets, such as scrollbars or scales, it’ll also adjust spin
// buttons. The adjustment value of these widgets is set to a value between the
// lower and upper limits, according to the @percentage argument.
func TestSliderSetPerc(widget Widget, percentage float64) {
	var arg1 *C.GtkWidget
	var arg2 C.double

	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = C.double(percentage)

	C.gtk_test_slider_set_perc(arg1, arg2)
}

// TestSpinButtonClick: this function will generate a @button click in the
// upwards or downwards spin button arrow areas, usually leading to an increase
// or decrease of spin button’s value.
func TestSpinButtonClick(spinner SpinButton, button uint, upwards bool) bool {
	var arg1 *C.GtkSpinButton
	var arg2 C.guint
	var arg3 C.gboolean

	arg1 = (*C.GtkSpinButton)(spinner.Native())
	arg2 = C.guint(button)
	if upwards {
		arg3 = C.TRUE
	}

	ret := C.gtk_test_spin_button_click(arg1, arg2, arg3)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// TestTextGet: retrive the text string of @widget if it is a GtkLabel,
// GtkEditable (entry and text widgets) or GtkTextView.
func TestTextGet(widget Widget) string {
	var arg1 *C.GtkWidget

	arg1 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_test_text_get(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// TestTextSet: set the text string of @widget to @string if it is a GtkLabel,
// GtkEditable (entry and text widgets) or GtkTextView.
func TestTextSet(widget Widget, string string) {
	var arg1 *C.GtkWidget
	var arg2 *C.gchar

	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_test_text_set(arg1, arg2)
}

// TestWidgetClick: this function will generate a @button click (button press
// and button release event) in the middle of the first GdkWindow found that
// belongs to @widget. For windowless widgets like Button (which returns false
// from gtk_widget_get_has_window()), this will often be an input-only event
// window. For other widgets, this is usually widget->window. Certain caveats
// should be considered when using this function, in particular because the
// mouse pointer is warped to the button click location, see
// gdk_test_simulate_button() for details.
func TestWidgetClick(widget Widget, button uint, modifiers gdk.ModifierType) bool {
	var arg1 *C.GtkWidget
	var arg2 C.guint
	var arg3 C.GdkModifierType

	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = C.guint(button)
	arg3 = (C.GdkModifierType)(modifiers)

	ret := C.gtk_test_widget_click(arg1, arg2, arg3)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// TestWidgetSendKey: this function will generate keyboard press and release
// events in the middle of the first GdkWindow found that belongs to @widget.
// For windowless widgets like Button (which returns false from
// gtk_widget_get_has_window()), this will often be an input-only event window.
// For other widgets, this is usually widget->window. Certain caveats should be
// considered when using this function, in particular because the mouse pointer
// is warped to the key press location, see gdk_test_simulate_key() for details.
func TestWidgetSendKey(widget Widget, keyval uint, modifiers gdk.ModifierType) bool {
	var arg1 *C.GtkWidget
	var arg2 C.guint
	var arg3 C.GdkModifierType

	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = C.guint(keyval)
	arg3 = (C.GdkModifierType)(modifiers)

	ret := C.gtk_test_widget_send_key(arg1, arg2, arg3)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// TestWidgetWaitForDraw enters the main loop and waits for @widget to be
// “drawn”. In this context that means it waits for the frame clock of @widget
// to have run a full styling, layout and drawing cycle.
//
// This function is intended to be used for syncing with actions that depend on
// @widget relayouting or on interaction with the display server.
func TestWidgetWaitForDraw(widget Widget) {
	var arg1 *C.GtkWidget

	arg1 = (*C.GtkWidget)(widget.Native())

	C.gtk_test_widget_wait_for_draw(arg1)
}

// TreeGetRowDragData obtains a @tree_model and @path from selection data of
// target type GTK_TREE_MODEL_ROW. Normally called from a drag_data_received
// handler. This function can only be used if @selection_data originates from
// the same process that’s calling this function, because a pointer to the tree
// model is being passed around. If you aren’t in the same process, then you'll
// get memory corruption. In the TreeDragDest drag_data_received handler, you
// can assume that selection data of type GTK_TREE_MODEL_ROW is in from the
// current process. The returned path must be freed with gtk_tree_path_free().
func TreeGetRowDragData(selectionData *SelectionData) (treeModel TreeModel, path *TreePath, ok bool) {
	var arg1 *C.GtkSelectionData
	var arg2 **C.GtkTreeModel // out
	var arg3 **C.GtkTreePath  // out

	arg1 = (*C.GtkSelectionData)(selectionData.Native())

	ret := C.gtk_tree_get_row_drag_data(arg1, &arg2, &arg3)

	var ret0 *TreeModel
	var ret1 **TreePath
	var ret2 bool

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(arg2.Native()))).(*TreeModel)

	{
		ret1 = WrapTreePath(unsafe.Pointer(arg3))
		runtime.SetFinalizer(ret1, func(v **TreePath) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	ret2 = C.BOOL(ret) != 0

	return ret0, ret1, ret2
}

// TreeRowReferenceDeleted lets a set of row reference created by
// gtk_tree_row_reference_new_proxy() know that the model emitted the
// TreeModel::row-deleted signal.
func TreeRowReferenceDeleted(proxy gextras.Objector, path *TreePath) {
	var arg1 *C.GObject
	var arg2 *C.GtkTreePath

	arg1 = (*C.GObject)(proxy.Native())
	arg2 = (*C.GtkTreePath)(path.Native())

	C.gtk_tree_row_reference_deleted(arg1, arg2)
}

// TreeRowReferenceInserted lets a set of row reference created by
// gtk_tree_row_reference_new_proxy() know that the model emitted the
// TreeModel::row-inserted signal.
func TreeRowReferenceInserted(proxy gextras.Objector, path *TreePath) {
	var arg1 *C.GObject
	var arg2 *C.GtkTreePath

	arg1 = (*C.GObject)(proxy.Native())
	arg2 = (*C.GtkTreePath)(path.Native())

	C.gtk_tree_row_reference_inserted(arg1, arg2)
}

// TreeSetRowDragData sets selection data of target type GTK_TREE_MODEL_ROW.
// Normally used in a drag_data_get handler.
func TreeSetRowDragData(selectionData *SelectionData, treeModel TreeModel, path *TreePath) bool {
	var arg1 *C.GtkSelectionData
	var arg2 *C.GtkTreeModel
	var arg3 *C.GtkTreePath

	arg1 = (*C.GtkSelectionData)(selectionData.Native())
	arg2 = (*C.GtkTreeModel)(treeModel.Native())
	arg3 = (*C.GtkTreePath)(path.Native())

	ret := C.gtk_tree_set_row_drag_data(arg1, arg2, arg3)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// True: all this function does it to return true.
//
// This can be useful for example if you want to inhibit the deletion of a
// window. Of course you should not do this as the user expects a reaction from
// clicking the close icon of the window...
//
// A persistent window
//
//    #include <gtk/gtk.h>
//
//    int
//    main (int argc, char **argv)
//    {
//      GtkWidget *win, *but;
//      const char *text = "Close yourself. I mean it!";
//
//      gtk_init (&argc, &argv);
//
//      win = gtk_window_new (GTK_WINDOW_TOPLEVEL);
//      g_signal_connect (win,
//                        "delete-event",
//                        G_CALLBACK (gtk_true),
//                        NULL);
//      g_signal_connect (win, "destroy",
//                        G_CALLBACK (gtk_main_quit),
//                        NULL);
//
//      but = gtk_button_new_with_label (text);
//      g_signal_connect_swapped (but, "clicked",
//                                G_CALLBACK (gtk_object_destroy),
//                                win);
//      gtk_container_add (GTK_CONTAINER (win), but);
//
//      gtk_widget_show_all (win);
//
//      gtk_main ();
//
//      return 0;
//    }
func True() bool {

	ret := C.gtk_true()

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ActivatableOverrider contains methods that are overridable. This
// interface is a subset of the interface Activatable.
type ActivatableOverrider interface {
	// SyncActionProperties: this is called to update the activatable
	// completely, this is called internally when the Activatable:related-action
	// property is set or unset and by the implementing class when
	// Activatable:use-action-appearance changes.
	SyncActionProperties(action Action)

	Update(action Action, propertyName string)
}

// Activatable: activatable widgets can be connected to a Action and reflects
// the state of its action. A Activatable can also provide feedback through its
// action, as they are responsible for activating their related actions.
//
//
// Implementing GtkActivatable
//
// When extending a class that is already Activatable; it is only necessary to
// implement the Activatable->sync_action_properties() and Activatable->update()
// methods and chain up to the parent implementation, however when introducing a
// new Activatable class; the Activatable:related-action and
// Activatable:use-action-appearance properties need to be handled by the
// implementor. Handling these properties is mostly a matter of installing the
// action pointer and boolean flag on your instance, and calling
// gtk_activatable_do_set_related_action() and
// gtk_activatable_sync_action_properties() at the appropriate times.
//
// A class fragment implementing Activatable
//
//
//    enum {
//    ...
//
//    PROP_ACTIVATABLE_RELATED_ACTION,
//    PROP_ACTIVATABLE_USE_ACTION_APPEARANCE
//    }
//
//    struct _FooBarPrivate
//    {
//
//      ...
//
//      GtkAction      *action;
//      gboolean        use_action_appearance;
//    };
//
//    ...
//
//    static void foo_bar_activatable_interface_init         (GtkActivatableIface  *iface);
//    static void foo_bar_activatable_update                 (GtkActivatable       *activatable,
//    						           GtkAction            *action,
//    						           const gchar          *property_name);
//    static void foo_bar_activatable_sync_action_properties (GtkActivatable       *activatable,
//    						           GtkAction            *action);
//    ...
//
//
//    static void
//    foo_bar_class_init (FooBarClass *klass)
//    {
//
//      ...
//
//      g_object_class_override_property (gobject_class, PROP_ACTIVATABLE_RELATED_ACTION, "related-action");
//      g_object_class_override_property (gobject_class, PROP_ACTIVATABLE_USE_ACTION_APPEARANCE, "use-action-appearance");
//
//      ...
//    }
//
//
//    static void
//    foo_bar_activatable_interface_init (GtkActivatableIface  *iface)
//    {
//      iface->update = foo_bar_activatable_update;
//      iface->sync_action_properties = foo_bar_activatable_sync_action_properties;
//    }
//
//    ... Break the reference using gtk_activatable_do_set_related_action()...
//
//    static void
//    foo_bar_dispose (GObject *object)
//    {
//      FooBar *bar = FOO_BAR (object);
//      FooBarPrivate *priv = FOO_BAR_GET_PRIVATE (bar);
//
//      ...
//
//      if (priv->action)
//        {
//          gtk_activatable_do_set_related_action (GTK_ACTIVATABLE (bar), NULL);
//          priv->action = NULL;
//        }
//      G_OBJECT_CLASS (foo_bar_parent_class)->dispose (object);
//    }
//
//    ... Handle the “related-action” and “use-action-appearance” properties ...
//
//    static void
//    foo_bar_set_property (GObject         *object,
//                          guint            prop_id,
//                          const GValue    *value,
//                          GParamSpec      *pspec)
//    {
//      FooBar *bar = FOO_BAR (object);
//      FooBarPrivate *priv = FOO_BAR_GET_PRIVATE (bar);
//
//      switch (prop_id)
//        {
//
//          ...
//
//        case PROP_ACTIVATABLE_RELATED_ACTION:
//          foo_bar_set_related_action (bar, g_value_get_object (value));
//          break;
//        case PROP_ACTIVATABLE_USE_ACTION_APPEARANCE:
//          foo_bar_set_use_action_appearance (bar, g_value_get_boolean (value));
//          break;
//        default:
//          G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
//          break;
//        }
//    }
//
//    static void
//    foo_bar_get_property (GObject         *object,
//                             guint            prop_id,
//                             GValue          *value,
//                             GParamSpec      *pspec)
//    {
//      FooBar *bar = FOO_BAR (object);
//      FooBarPrivate *priv = FOO_BAR_GET_PRIVATE (bar);
//
//      switch (prop_id)
//        {
//
//          ...
//
//        case PROP_ACTIVATABLE_RELATED_ACTION:
//          g_value_set_object (value, priv->action);
//          break;
//        case PROP_ACTIVATABLE_USE_ACTION_APPEARANCE:
//          g_value_set_boolean (value, priv->use_action_appearance);
//          break;
//        default:
//          G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
//          break;
//        }
//    }
//
//
//    static void
//    foo_bar_set_use_action_appearance (FooBar   *bar,
//    				   gboolean  use_appearance)
//    {
//      FooBarPrivate *priv = FOO_BAR_GET_PRIVATE (bar);
//
//      if (priv->use_action_appearance != use_appearance)
//        {
//          priv->use_action_appearance = use_appearance;
//
//          gtk_activatable_sync_action_properties (GTK_ACTIVATABLE (bar), priv->action);
//        }
//    }
//
//    ... call gtk_activatable_do_set_related_action() and then assign the action pointer,
//    no need to reference the action here since gtk_activatable_do_set_related_action() already
//    holds a reference here for you...
//    static void
//    foo_bar_set_related_action (FooBar    *bar,
//    			    GtkAction *action)
//    {
//      FooBarPrivate *priv = FOO_BAR_GET_PRIVATE (bar);
//
//      if (priv->action == action)
//        return;
//
//      gtk_activatable_do_set_related_action (GTK_ACTIVATABLE (bar), action);
//
//      priv->action = action;
//    }
//
//    ... Selectively reset and update activatable depending on the use-action-appearance property ...
//    static void
//    gtk_button_activatable_sync_action_properties (GtkActivatable       *activatable,
//    		                                  GtkAction            *action)
//    {
//      GtkButtonPrivate *priv = GTK_BUTTON_GET_PRIVATE (activatable);
//
//      if (!action)
//        return;
//
//      if (gtk_action_is_visible (action))
//        gtk_widget_show (GTK_WIDGET (activatable));
//      else
//        gtk_widget_hide (GTK_WIDGET (activatable));
//
//      gtk_widget_set_sensitive (GTK_WIDGET (activatable), gtk_action_is_sensitive (action));
//
//      ...
//
//      if (priv->use_action_appearance)
//        {
//          if (gtk_action_get_stock_id (action))
//    	foo_bar_set_stock (button, gtk_action_get_stock_id (action));
//          else if (gtk_action_get_label (action))
//    	foo_bar_set_label (button, gtk_action_get_label (action));
//
//          ...
//
//        }
//    }
//
//    static void
//    foo_bar_activatable_update (GtkActivatable       *activatable,
//    			       GtkAction            *action,
//    			       const gchar          *property_name)
//    {
//      FooBarPrivate *priv = FOO_BAR_GET_PRIVATE (activatable);
//
//      if (strcmp (property_name, "visible") == 0)
//        {
//          if (gtk_action_is_visible (action))
//    	gtk_widget_show (GTK_WIDGET (activatable));
//          else
//    	gtk_widget_hide (GTK_WIDGET (activatable));
//        }
//      else if (strcmp (property_name, "sensitive") == 0)
//        gtk_widget_set_sensitive (GTK_WIDGET (activatable), gtk_action_is_sensitive (action));
//
//      ...
//
//      if (!priv->use_action_appearance)
//        return;
//
//      if (strcmp (property_name, "stock-id") == 0)
//        foo_bar_set_stock (button, gtk_action_get_stock_id (action));
//      else if (strcmp (property_name, "label") == 0)
//        foo_bar_set_label (button, gtk_action_get_label (action));
//
//      ...
//    }
type Activatable interface {
	gextras.Objector
	ActivatableOverrider

	// DoSetRelatedAction: this is a utility function for Activatable
	// implementors.
	//
	// When implementing Activatable you must call this when handling changes of
	// the Activatable:related-action, and you must also use this to break
	// references in #GObject->dispose().
	//
	// This function adds a reference to the currently set related action for
	// you, it also makes sure the Activatable->update() method is called when
	// the related Action properties change and registers to the action’s proxy
	// list.
	//
	// > Be careful to call this before setting the local > copy of the Action
	// property, since this function uses > gtk_activatable_get_related_action()
	// to retrieve the > previous action.
	DoSetRelatedAction(action Action)
	// RelatedAction gets the related Action for @activatable.
	RelatedAction() Action
	// UseActionAppearance gets whether this activatable should reset its layout
	// and appearance when setting the related action or when the action changes
	// appearance.
	UseActionAppearance() bool
	// SetRelatedAction sets the related action on the @activatable object.
	//
	// > Activatable implementors need to handle the Activatable:related-action
	// > property and call gtk_activatable_do_set_related_action() when it
	// changes.
	SetRelatedAction(action Action)
	// SetUseActionAppearance sets whether this activatable should reset its
	// layout and appearance when setting the related action or when the action
	// changes appearance
	//
	// > Activatable implementors need to handle the >
	// Activatable:use-action-appearance property and call >
	// gtk_activatable_sync_action_properties() to update @activatable > if
	// needed.
	SetUseActionAppearance(useAppearance bool)
}

// activatable implements the Activatable interface.
type activatable struct {
	gextras.Objector
}

var _ Activatable = (*activatable)(nil)

// WrapActivatable wraps a GObject to a type that implements interface
// Activatable. It is primarily used internally.
func WrapActivatable(obj *externglib.Object) Activatable {
	return Activatable{
		Objector: obj,
	}
}

func marshalActivatable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapActivatable(obj), nil
}

// DoSetRelatedAction: this is a utility function for Activatable
// implementors.
//
// When implementing Activatable you must call this when handling changes of
// the Activatable:related-action, and you must also use this to break
// references in #GObject->dispose().
//
// This function adds a reference to the currently set related action for
// you, it also makes sure the Activatable->update() method is called when
// the related Action properties change and registers to the action’s proxy
// list.
//
// > Be careful to call this before setting the local > copy of the Action
// property, since this function uses > gtk_activatable_get_related_action()
// to retrieve the > previous action.
func (activatable activatable) DoSetRelatedAction(action Action) {
	var arg0 *C.GtkActivatable
	var arg1 *C.GtkAction

	arg0 = (*C.GtkActivatable)(activatable.Native())
	arg1 = (*C.GtkAction)(action.Native())

	C.gtk_activatable_do_set_related_action(arg0, arg1)
}

// RelatedAction gets the related Action for @activatable.
func (activatable activatable) RelatedAction() Action {
	var arg0 *C.GtkActivatable

	arg0 = (*C.GtkActivatable)(activatable.Native())

	ret := C.gtk_activatable_get_related_action(arg0)

	var ret0 Action

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Action)

	return ret0
}

// UseActionAppearance gets whether this activatable should reset its layout
// and appearance when setting the related action or when the action changes
// appearance.
func (activatable activatable) UseActionAppearance() bool {
	var arg0 *C.GtkActivatable

	arg0 = (*C.GtkActivatable)(activatable.Native())

	ret := C.gtk_activatable_get_use_action_appearance(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SetRelatedAction sets the related action on the @activatable object.
//
// > Activatable implementors need to handle the Activatable:related-action
// > property and call gtk_activatable_do_set_related_action() when it
// changes.
func (activatable activatable) SetRelatedAction(action Action) {
	var arg0 *C.GtkActivatable
	var arg1 *C.GtkAction

	arg0 = (*C.GtkActivatable)(activatable.Native())
	arg1 = (*C.GtkAction)(action.Native())

	C.gtk_activatable_set_related_action(arg0, arg1)
}

// SetUseActionAppearance sets whether this activatable should reset its
// layout and appearance when setting the related action or when the action
// changes appearance
//
// > Activatable implementors need to handle the >
// Activatable:use-action-appearance property and call >
// gtk_activatable_sync_action_properties() to update @activatable > if
// needed.
func (activatable activatable) SetUseActionAppearance(useAppearance bool) {
	var arg0 *C.GtkActivatable
	var arg1 C.gboolean

	arg0 = (*C.GtkActivatable)(activatable.Native())
	if useAppearance {
		arg1 = C.TRUE
	}

	C.gtk_activatable_set_use_action_appearance(arg0, arg1)
}

// SyncActionProperties: this is called to update the activatable
// completely, this is called internally when the Activatable:related-action
// property is set or unset and by the implementing class when
// Activatable:use-action-appearance changes.
func (activatable activatable) SyncActionProperties(action Action) {
	var arg0 *C.GtkActivatable
	var arg1 *C.GtkAction

	arg0 = (*C.GtkActivatable)(activatable.Native())
	arg1 = (*C.GtkAction)(action.Native())

	C.gtk_activatable_sync_action_properties(arg0, arg1)
}

// BuildableOverrider contains methods that are overridable. This
// interface is a subset of the interface Buildable.
type BuildableOverrider interface {
	// AddChild adds a child to @buildable. @type is an optional string
	// describing how the child should be added.
	AddChild(builder Builder, child gextras.Objector, typ string)
	// ConstructChild constructs a child of @buildable with the name @name.
	//
	// Builder calls this function if a “constructor” has been specified in the
	// UI definition.
	ConstructChild(builder Builder, name string) gextras.Objector
	// CustomFinished: this is similar to gtk_buildable_parser_finished() but is
	// called once for each custom tag handled by the @buildable.
	CustomFinished(builder Builder, child gextras.Objector, tagname string, data interface{})
	// CustomTagEnd: this is called at the end of each custom element handled by
	// the buildable.
	CustomTagEnd(builder Builder, child gextras.Objector, tagname string, data interface{})
	// InternalChild: get the internal child called @childname of the @buildable
	// object.
	InternalChild(builder Builder, childname string) gextras.Objector
	// Name gets the name of the @buildable object.
	//
	// Builder sets the name based on the [GtkBuilder UI definition][BUILDER-UI]
	// used to construct the @buildable.
	Name() string
	// ParserFinished: called when the builder finishes the parsing of a
	// [GtkBuilder UI definition][BUILDER-UI]. Note that this will be called
	// once for each time gtk_builder_add_from_file() or
	// gtk_builder_add_from_string() is called on a builder.
	ParserFinished(builder Builder)
	// SetBuildableProperty sets the property name @name to @value on the
	// @buildable object.
	SetBuildableProperty(builder Builder, name string, value *externglib.Value)
	// SetName sets the name of the @buildable object.
	SetName(name string)
}

// Buildable: gtkBuildable allows objects to extend and customize their
// deserialization from [GtkBuilder UI descriptions][BUILDER-UI]. The interface
// includes methods for setting names and properties of objects, parsing custom
// tags and constructing child objects.
//
// The GtkBuildable interface is implemented by all widgets and many of the
// non-widget objects that are provided by GTK+. The main user of this interface
// is Builder. There should be very little need for applications to call any of
// these functions directly.
//
// An object only needs to implement this interface if it needs to extend the
// Builder format or run any extra routines at deserialization time.
type Buildable interface {
	gextras.Objector
	BuildableOverrider
}

// buildable implements the Buildable interface.
type buildable struct {
	gextras.Objector
}

var _ Buildable = (*buildable)(nil)

// WrapBuildable wraps a GObject to a type that implements interface
// Buildable. It is primarily used internally.
func WrapBuildable(obj *externglib.Object) Buildable {
	return Buildable{
		Objector: obj,
	}
}

func marshalBuildable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBuildable(obj), nil
}

// AddChild adds a child to @buildable. @type is an optional string
// describing how the child should be added.
func (buildable buildable) AddChild(builder Builder, child gextras.Objector, typ string) {
	var arg0 *C.GtkBuildable
	var arg1 *C.GtkBuilder
	var arg2 *C.GObject
	var arg3 *C.gchar

	arg0 = (*C.GtkBuildable)(buildable.Native())
	arg1 = (*C.GtkBuilder)(builder.Native())
	arg2 = (*C.GObject)(child.Native())
	arg3 = (*C.gchar)(C.CString(typ))
	defer C.free(unsafe.Pointer(arg3))

	C.gtk_buildable_add_child(arg0, arg1, arg2, arg3)
}

// ConstructChild constructs a child of @buildable with the name @name.
//
// Builder calls this function if a “constructor” has been specified in the
// UI definition.
func (buildable buildable) ConstructChild(builder Builder, name string) gextras.Objector {
	var arg0 *C.GtkBuildable
	var arg1 *C.GtkBuilder
	var arg2 *C.gchar

	arg0 = (*C.GtkBuildable)(buildable.Native())
	arg1 = (*C.GtkBuilder)(builder.Native())
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_buildable_construct_child(arg0, arg1, arg2)

	var ret0 gextras.Objector

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gextras.Objector)

	return ret0
}

// CustomFinished: this is similar to gtk_buildable_parser_finished() but is
// called once for each custom tag handled by the @buildable.
func (buildable buildable) CustomFinished(builder Builder, child gextras.Objector, tagname string, data interface{}) {
	var arg0 *C.GtkBuildable
	var arg1 *C.GtkBuilder
	var arg2 *C.GObject
	var arg3 *C.gchar
	var arg4 C.gpointer

	arg0 = (*C.GtkBuildable)(buildable.Native())
	arg1 = (*C.GtkBuilder)(builder.Native())
	arg2 = (*C.GObject)(child.Native())
	arg3 = (*C.gchar)(C.CString(tagname))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = C.gpointer(box.Assign(data))

	C.gtk_buildable_custom_finished(arg0, arg1, arg2, arg3, arg4)
}

// CustomTagEnd: this is called at the end of each custom element handled by
// the buildable.
func (buildable buildable) CustomTagEnd(builder Builder, child gextras.Objector, tagname string, data interface{}) {
	var arg0 *C.GtkBuildable
	var arg1 *C.GtkBuilder
	var arg2 *C.GObject
	var arg3 *C.gchar
	var arg4 *C.gpointer

	arg0 = (*C.GtkBuildable)(buildable.Native())
	arg1 = (*C.GtkBuilder)(builder.Native())
	arg2 = (*C.GObject)(child.Native())
	arg3 = (*C.gchar)(C.CString(tagname))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = C.gpointer(box.Assign(data))

	C.gtk_buildable_custom_tag_end(arg0, arg1, arg2, arg3, arg4)
}

// InternalChild: get the internal child called @childname of the @buildable
// object.
func (buildable buildable) InternalChild(builder Builder, childname string) gextras.Objector {
	var arg0 *C.GtkBuildable
	var arg1 *C.GtkBuilder
	var arg2 *C.gchar

	arg0 = (*C.GtkBuildable)(buildable.Native())
	arg1 = (*C.GtkBuilder)(builder.Native())
	arg2 = (*C.gchar)(C.CString(childname))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_buildable_get_internal_child(arg0, arg1, arg2)

	var ret0 gextras.Objector

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gextras.Objector)

	return ret0
}

// Name gets the name of the @buildable object.
//
// Builder sets the name based on the [GtkBuilder UI definition][BUILDER-UI]
// used to construct the @buildable.
func (buildable buildable) Name() string {
	var arg0 *C.GtkBuildable

	arg0 = (*C.GtkBuildable)(buildable.Native())

	ret := C.gtk_buildable_get_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// ParserFinished: called when the builder finishes the parsing of a
// [GtkBuilder UI definition][BUILDER-UI]. Note that this will be called
// once for each time gtk_builder_add_from_file() or
// gtk_builder_add_from_string() is called on a builder.
func (buildable buildable) ParserFinished(builder Builder) {
	var arg0 *C.GtkBuildable
	var arg1 *C.GtkBuilder

	arg0 = (*C.GtkBuildable)(buildable.Native())
	arg1 = (*C.GtkBuilder)(builder.Native())

	C.gtk_buildable_parser_finished(arg0, arg1)
}

// SetBuildableProperty sets the property name @name to @value on the
// @buildable object.
func (buildable buildable) SetBuildableProperty(builder Builder, name string, value *externglib.Value) {
	var arg0 *C.GtkBuildable
	var arg1 *C.GtkBuilder
	var arg2 *C.gchar
	var arg3 *C.GValue

	arg0 = (*C.GtkBuildable)(buildable.Native())
	arg1 = (*C.GtkBuilder)(builder.Native())
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.GValue)(value.GValue)

	C.gtk_buildable_set_buildable_property(arg0, arg1, arg2, arg3)
}

// SetName sets the name of the @buildable object.
func (buildable buildable) SetName(name string) {
	var arg0 *C.GtkBuildable
	var arg1 *C.gchar

	arg0 = (*C.GtkBuildable)(buildable.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_buildable_set_name(arg0, arg1)
}

// CellAccessibleParentOverrider contains methods that are overridable. This
// interface is a subset of the interface CellAccessibleParent.
type CellAccessibleParentOverrider interface {
	Activate(cell CellAccessible)

	Edit(cell CellAccessible)

	ExpandCollapse(cell CellAccessible)

	CellArea(cell CellAccessible) gdk.Rectangle

	CellPosition(cell CellAccessible) (row int, column int)

	ChildIndex(cell CellAccessible) int

	RendererState(cell CellAccessible) CellRendererState

	GrabFocus(cell CellAccessible) bool
}

type CellAccessibleParent interface {
	gextras.Objector
	CellAccessibleParentOverrider
}

// cellAccessibleParent implements the CellAccessibleParent interface.
type cellAccessibleParent struct {
	gextras.Objector
}

var _ CellAccessibleParent = (*cellAccessibleParent)(nil)

// WrapCellAccessibleParent wraps a GObject to a type that implements interface
// CellAccessibleParent. It is primarily used internally.
func WrapCellAccessibleParent(obj *externglib.Object) CellAccessibleParent {
	return CellAccessibleParent{
		Objector: obj,
	}
}

func marshalCellAccessibleParent(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellAccessibleParent(obj), nil
}

func (parent cellAccessibleParent) Activate(cell CellAccessible) {
	var arg0 *C.GtkCellAccessibleParent
	var arg1 *C.GtkCellAccessible

	arg0 = (*C.GtkCellAccessibleParent)(parent.Native())
	arg1 = (*C.GtkCellAccessible)(cell.Native())

	C.gtk_cell_accessible_parent_activate(arg0, arg1)
}

func (parent cellAccessibleParent) Edit(cell CellAccessible) {
	var arg0 *C.GtkCellAccessibleParent
	var arg1 *C.GtkCellAccessible

	arg0 = (*C.GtkCellAccessibleParent)(parent.Native())
	arg1 = (*C.GtkCellAccessible)(cell.Native())

	C.gtk_cell_accessible_parent_edit(arg0, arg1)
}

func (parent cellAccessibleParent) ExpandCollapse(cell CellAccessible) {
	var arg0 *C.GtkCellAccessibleParent
	var arg1 *C.GtkCellAccessible

	arg0 = (*C.GtkCellAccessibleParent)(parent.Native())
	arg1 = (*C.GtkCellAccessible)(cell.Native())

	C.gtk_cell_accessible_parent_expand_collapse(arg0, arg1)
}

func (parent cellAccessibleParent) CellArea(cell CellAccessible) gdk.Rectangle {
	var arg0 *C.GtkCellAccessibleParent
	var arg1 *C.GtkCellAccessible
	var arg2 *C.GdkRectangle // out

	arg0 = (*C.GtkCellAccessibleParent)(parent.Native())
	arg1 = (*C.GtkCellAccessible)(cell.Native())

	C.gtk_cell_accessible_parent_get_cell_area(arg0, arg1, &arg2)

	var ret0 *gdk.Rectangle

	{
		ret0 = gdk.WrapRectangle(unsafe.Pointer(arg2))
	}

	return ret0
}

func (parent cellAccessibleParent) CellPosition(cell CellAccessible) (row int, column int) {
	var arg0 *C.GtkCellAccessibleParent
	var arg1 *C.GtkCellAccessible
	var arg2 *C.gint // out
	var arg3 *C.gint // out

	arg0 = (*C.GtkCellAccessibleParent)(parent.Native())
	arg1 = (*C.GtkCellAccessible)(cell.Native())

	C.gtk_cell_accessible_parent_get_cell_position(arg0, arg1, &arg2, &arg3)

	var ret0 int
	var ret1 int

	ret0 = int(arg2)

	ret1 = int(arg3)

	return ret0, ret1
}

func (parent cellAccessibleParent) ChildIndex(cell CellAccessible) int {
	var arg0 *C.GtkCellAccessibleParent
	var arg1 *C.GtkCellAccessible

	arg0 = (*C.GtkCellAccessibleParent)(parent.Native())
	arg1 = (*C.GtkCellAccessible)(cell.Native())

	ret := C.gtk_cell_accessible_parent_get_child_index(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

func (parent cellAccessibleParent) RendererState(cell CellAccessible) CellRendererState {
	var arg0 *C.GtkCellAccessibleParent
	var arg1 *C.GtkCellAccessible

	arg0 = (*C.GtkCellAccessibleParent)(parent.Native())
	arg1 = (*C.GtkCellAccessible)(cell.Native())

	ret := C.gtk_cell_accessible_parent_get_renderer_state(arg0, arg1)

	var ret0 CellRendererState

	ret0 = CellRendererState(ret)

	return ret0
}

func (parent cellAccessibleParent) GrabFocus(cell CellAccessible) bool {
	var arg0 *C.GtkCellAccessibleParent
	var arg1 *C.GtkCellAccessible

	arg0 = (*C.GtkCellAccessibleParent)(parent.Native())
	arg1 = (*C.GtkCellAccessible)(cell.Native())

	ret := C.gtk_cell_accessible_parent_grab_focus(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// CellLayoutOverrider contains methods that are overridable. This
// interface is a subset of the interface CellLayout.
type CellLayoutOverrider interface {
	// AddAttribute adds an attribute mapping to the list in @cell_layout.
	//
	// The @column is the column of the model to get a value from, and the
	// @attribute is the parameter on @cell to be set from the value. So for
	// example if column 2 of the model contains strings, you could have the
	// “text” attribute of a CellRendererText get its values from column 2.
	AddAttribute(cell CellRenderer, attribute string, column int)
	// Clear unsets all the mappings on all renderers on @cell_layout and
	// removes all renderers from @cell_layout.
	Clear()
	// ClearAttributes clears all existing attributes previously set with
	// gtk_cell_layout_set_attributes().
	ClearAttributes(cell CellRenderer)
	// Area returns the underlying CellArea which might be @cell_layout if
	// called on a CellArea or might be nil if no CellArea is used by
	// @cell_layout.
	Area() CellArea
	// Cells returns the cell renderers which have been added to @cell_layout.
	Cells() *glib.List
	// PackEnd adds the @cell to the end of @cell_layout. If @expand is false,
	// then the @cell is allocated no more space than it needs. Any unused space
	// is divided evenly between cells for which @expand is true.
	//
	// Note that reusing the same cell renderer is not supported.
	PackEnd(cell CellRenderer, expand bool)
	// PackStart packs the @cell into the beginning of @cell_layout. If @expand
	// is false, then the @cell is allocated no more space than it needs. Any
	// unused space is divided evenly between cells for which @expand is true.
	//
	// Note that reusing the same cell renderer is not supported.
	PackStart(cell CellRenderer, expand bool)
	// Reorder re-inserts @cell at @position.
	//
	// Note that @cell has already to be packed into @cell_layout for this to
	// function properly.
	Reorder(cell CellRenderer, position int)
	// SetCellDataFunc sets the CellLayoutDataFunc to use for @cell_layout.
	//
	// This function is used instead of the standard attributes mapping for
	// setting the column value, and should set the value of @cell_layout’s cell
	// renderer(s) as appropriate.
	//
	// @func may be nil to remove a previously set function.
	SetCellDataFunc(cell CellRenderer, fn CellLayoutDataFunc)
}

// CellLayout is an interface to be implemented by all objects which want to
// provide a TreeViewColumn like API for packing cells, setting attributes and
// data funcs.
//
// One of the notable features provided by implementations of GtkCellLayout are
// attributes. Attributes let you set the properties in flexible ways. They can
// just be set to constant values like regular properties. But they can also be
// mapped to a column of the underlying tree model with
// gtk_cell_layout_set_attributes(), which means that the value of the attribute
// can change from cell to cell as they are rendered by the cell renderer.
// Finally, it is possible to specify a function with
// gtk_cell_layout_set_cell_data_func() that is called to determine the value of
// the attribute for each cell that is rendered.
//
//
// GtkCellLayouts as GtkBuildable
//
// Implementations of GtkCellLayout which also implement the GtkBuildable
// interface (CellView, IconView, ComboBox, EntryCompletion, TreeViewColumn)
// accept GtkCellRenderer objects as <child> elements in UI definitions. They
// support a custom <attributes> element for their children, which can contain
// multiple <attribute> elements. Each <attribute> element has a name attribute
// which specifies a property of the cell renderer; the content of the element
// is the attribute value.
//
// This is an example of a UI definition fragment specifying attributes:
//
//    <object class="GtkCellView">
//      <child>
//        <object class="GtkCellRendererText"/>
//        <attributes>
//          <attribute name="text">0</attribute>
//        </attributes>
//      </child>"
//    </object>
//
// Furthermore for implementations of GtkCellLayout that use a CellArea to lay
// out cells (all GtkCellLayouts in GTK+ use a GtkCellArea) [cell
// properties][cell-properties] can also be defined in the format by specifying
// the custom <cell-packing> attribute which can contain multiple <property>
// elements defined in the normal way.
//
// Here is a UI definition fragment specifying cell properties:
//
//    <object class="GtkTreeViewColumn">
//      <child>
//        <object class="GtkCellRendererText"/>
//        <cell-packing>
//          <property name="align">True</property>
//          <property name="expand">False</property>
//        </cell-packing>
//      </child>"
//    </object>
//
//
// Subclassing GtkCellLayout implementations
//
// When subclassing a widget that implements CellLayout like IconView or
// ComboBox, there are some considerations related to the fact that these
// widgets internally use a CellArea. The cell area is exposed as a
// construct-only property by these widgets. This means that it is possible to
// e.g. do
//
//    static void
//    my_combo_box_init (MyComboBox *b)
//    {
//      GtkCellRenderer *cell;
//
//      cell = gtk_cell_renderer_pixbuf_new ();
//      // The following call causes the default cell area for combo boxes,
//      // a GtkCellAreaBox, to be instantiated
//      gtk_cell_layout_pack_start (GTK_CELL_LAYOUT (b), cell, FALSE);
//      ...
//    }
//
//    GtkWidget *
//    my_combo_box_new (GtkCellArea *area)
//    {
//      // This call is going to cause a warning about area being ignored
//      return g_object_new (MY_TYPE_COMBO_BOX, "cell-area", area, NULL);
//    }
//
// If supporting alternative cell areas with your derived widget is not
// important, then this does not have to concern you. If you want to support
// alternative cell areas, you can do so by moving the problematic calls out of
// init() and into a constructor() for your class.
type CellLayout interface {
	gextras.Objector
	CellLayoutOverrider
}

// cellLayout implements the CellLayout interface.
type cellLayout struct {
	gextras.Objector
}

var _ CellLayout = (*cellLayout)(nil)

// WrapCellLayout wraps a GObject to a type that implements interface
// CellLayout. It is primarily used internally.
func WrapCellLayout(obj *externglib.Object) CellLayout {
	return CellLayout{
		Objector: obj,
	}
}

func marshalCellLayout(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellLayout(obj), nil
}

// AddAttribute adds an attribute mapping to the list in @cell_layout.
//
// The @column is the column of the model to get a value from, and the
// @attribute is the parameter on @cell to be set from the value. So for
// example if column 2 of the model contains strings, you could have the
// “text” attribute of a CellRendererText get its values from column 2.
func (cellLayout cellLayout) AddAttribute(cell CellRenderer, attribute string, column int) {
	var arg0 *C.GtkCellLayout
	var arg1 *C.GtkCellRenderer
	var arg2 *C.gchar
	var arg3 C.gint

	arg0 = (*C.GtkCellLayout)(cellLayout.Native())
	arg1 = (*C.GtkCellRenderer)(cell.Native())
	arg2 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.gint(column)

	C.gtk_cell_layout_add_attribute(arg0, arg1, arg2, arg3)
}

// Clear unsets all the mappings on all renderers on @cell_layout and
// removes all renderers from @cell_layout.
func (cellLayout cellLayout) Clear() {
	var arg0 *C.GtkCellLayout

	arg0 = (*C.GtkCellLayout)(cellLayout.Native())

	C.gtk_cell_layout_clear(arg0)
}

// ClearAttributes clears all existing attributes previously set with
// gtk_cell_layout_set_attributes().
func (cellLayout cellLayout) ClearAttributes(cell CellRenderer) {
	var arg0 *C.GtkCellLayout
	var arg1 *C.GtkCellRenderer

	arg0 = (*C.GtkCellLayout)(cellLayout.Native())
	arg1 = (*C.GtkCellRenderer)(cell.Native())

	C.gtk_cell_layout_clear_attributes(arg0, arg1)
}

// Area returns the underlying CellArea which might be @cell_layout if
// called on a CellArea or might be nil if no CellArea is used by
// @cell_layout.
func (cellLayout cellLayout) Area() CellArea {
	var arg0 *C.GtkCellLayout

	arg0 = (*C.GtkCellLayout)(cellLayout.Native())

	ret := C.gtk_cell_layout_get_area(arg0)

	var ret0 CellArea

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(CellArea)

	return ret0
}

// Cells returns the cell renderers which have been added to @cell_layout.
func (cellLayout cellLayout) Cells() *glib.List {
	var arg0 *C.GtkCellLayout

	arg0 = (*C.GtkCellLayout)(cellLayout.Native())

	ret := C.gtk_cell_layout_get_cells(arg0)

	var ret0 *glib.List

	{
		ret0 = glib.WrapList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.List) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// PackEnd adds the @cell to the end of @cell_layout. If @expand is false,
// then the @cell is allocated no more space than it needs. Any unused space
// is divided evenly between cells for which @expand is true.
//
// Note that reusing the same cell renderer is not supported.
func (cellLayout cellLayout) PackEnd(cell CellRenderer, expand bool) {
	var arg0 *C.GtkCellLayout
	var arg1 *C.GtkCellRenderer
	var arg2 C.gboolean

	arg0 = (*C.GtkCellLayout)(cellLayout.Native())
	arg1 = (*C.GtkCellRenderer)(cell.Native())
	if expand {
		arg2 = C.TRUE
	}

	C.gtk_cell_layout_pack_end(arg0, arg1, arg2)
}

// PackStart packs the @cell into the beginning of @cell_layout. If @expand
// is false, then the @cell is allocated no more space than it needs. Any
// unused space is divided evenly between cells for which @expand is true.
//
// Note that reusing the same cell renderer is not supported.
func (cellLayout cellLayout) PackStart(cell CellRenderer, expand bool) {
	var arg0 *C.GtkCellLayout
	var arg1 *C.GtkCellRenderer
	var arg2 C.gboolean

	arg0 = (*C.GtkCellLayout)(cellLayout.Native())
	arg1 = (*C.GtkCellRenderer)(cell.Native())
	if expand {
		arg2 = C.TRUE
	}

	C.gtk_cell_layout_pack_start(arg0, arg1, arg2)
}

// Reorder re-inserts @cell at @position.
//
// Note that @cell has already to be packed into @cell_layout for this to
// function properly.
func (cellLayout cellLayout) Reorder(cell CellRenderer, position int) {
	var arg0 *C.GtkCellLayout
	var arg1 *C.GtkCellRenderer
	var arg2 C.gint

	arg0 = (*C.GtkCellLayout)(cellLayout.Native())
	arg1 = (*C.GtkCellRenderer)(cell.Native())
	arg2 = C.gint(position)

	C.gtk_cell_layout_reorder(arg0, arg1, arg2)
}

// SetCellDataFunc sets the CellLayoutDataFunc to use for @cell_layout.
//
// This function is used instead of the standard attributes mapping for
// setting the column value, and should set the value of @cell_layout’s cell
// renderer(s) as appropriate.
//
// @func may be nil to remove a previously set function.
func (cellLayout cellLayout) SetCellDataFunc(cell CellRenderer, fn CellLayoutDataFunc) {
	var arg0 *C.GtkCellLayout
	var arg1 *C.GtkCellRenderer
	var arg2 C.GtkCellLayoutDataFunc
	var arg3 C.gpointer
	var arg4 C.GDestroyNotify

	arg0 = (*C.GtkCellLayout)(cellLayout.Native())
	arg1 = (*C.GtkCellRenderer)(cell.Native())
	arg2 = (*[0]byte)(C.gotk4_CellLayoutDataFunc)
	arg3 = C.gpointer(box.Assign(fn))
	arg4 = (*[0]byte)(C.callbackDelete)

	C.gtk_cell_layout_set_cell_data_func(arg0, arg1, arg2, arg3, arg4)
}

// ColorChooserOverrider contains methods that are overridable. This
// interface is a subset of the interface ColorChooser.
type ColorChooserOverrider interface {
	// AddPalette adds a palette to the color chooser. If @orientation is
	// horizontal, the colors are grouped in rows, with @colors_per_line colors
	// in each row. If @horizontal is false, the colors are grouped in columns
	// instead.
	//
	// The default color palette of ColorChooserWidget has 27 colors, organized
	// in columns of 3 colors. The default gray palette has 9 grays in a single
	// row.
	//
	// The layout of the color chooser widget works best when the palettes have
	// 9-10 columns.
	//
	// Calling this function for the first time has the side effect of removing
	// the default color and gray palettes from the color chooser.
	//
	// If @colors is nil, removes all previously added palettes.
	AddPalette(orientation Orientation, colorsPerLine int, nColors int, colors []gdk.RGBA)

	ColorActivated(color *gdk.RGBA)
	// RGBA gets the currently-selected color.
	RGBA() gdk.RGBA
	// SetRGBA sets the color.
	SetRGBA(color *gdk.RGBA)
}

// ColorChooser is an interface that is implemented by widgets for choosing
// colors. Depending on the situation, colors may be allowed to have alpha
// (translucency).
//
// In GTK+, the main widgets that implement this interface are
// ColorChooserWidget, ColorChooserDialog and ColorButton.
type ColorChooser interface {
	gextras.Objector
	ColorChooserOverrider

	// UseAlpha returns whether the color chooser shows the alpha channel.
	UseAlpha() bool
	// SetUseAlpha sets whether or not the color chooser should use the alpha
	// channel.
	SetUseAlpha(useAlpha bool)
}

// colorChooser implements the ColorChooser interface.
type colorChooser struct {
	gextras.Objector
}

var _ ColorChooser = (*colorChooser)(nil)

// WrapColorChooser wraps a GObject to a type that implements interface
// ColorChooser. It is primarily used internally.
func WrapColorChooser(obj *externglib.Object) ColorChooser {
	return ColorChooser{
		Objector: obj,
	}
}

func marshalColorChooser(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapColorChooser(obj), nil
}

// AddPalette adds a palette to the color chooser. If @orientation is
// horizontal, the colors are grouped in rows, with @colors_per_line colors
// in each row. If @horizontal is false, the colors are grouped in columns
// instead.
//
// The default color palette of ColorChooserWidget has 27 colors, organized
// in columns of 3 colors. The default gray palette has 9 grays in a single
// row.
//
// The layout of the color chooser widget works best when the palettes have
// 9-10 columns.
//
// Calling this function for the first time has the side effect of removing
// the default color and gray palettes from the color chooser.
//
// If @colors is nil, removes all previously added palettes.
func (chooser colorChooser) AddPalette(orientation Orientation, colorsPerLine int, nColors int, colors []gdk.RGBA) {
	var arg0 *C.GtkColorChooser
	var arg1 C.GtkOrientation
	var arg2 C.gint
	var arg3 C.gint
	var arg4 *C.GdkRGBA

	arg0 = (*C.GtkColorChooser)(chooser.Native())
	arg1 = (C.GtkOrientation)(orientation)
	arg2 = C.gint(colorsPerLine)
	arg4 = (*C.GdkRGBA)(unsafe.Pointer(&colors[0]))
	arg3 = len(colors)
	defer runtime.KeepAlive(colors)

	C.gtk_color_chooser_add_palette(arg0, arg1, arg2, arg3, arg4)
}

// RGBA gets the currently-selected color.
func (chooser colorChooser) RGBA() gdk.RGBA {
	var arg0 *C.GtkColorChooser
	var arg1 *C.GdkRGBA // out

	arg0 = (*C.GtkColorChooser)(chooser.Native())

	C.gtk_color_chooser_get_rgba(arg0, &arg1)

	var ret0 *gdk.RGBA

	{
		ret0 = gdk.WrapRGBA(unsafe.Pointer(arg1))
	}

	return ret0
}

// UseAlpha returns whether the color chooser shows the alpha channel.
func (chooser colorChooser) UseAlpha() bool {
	var arg0 *C.GtkColorChooser

	arg0 = (*C.GtkColorChooser)(chooser.Native())

	ret := C.gtk_color_chooser_get_use_alpha(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SetRGBA sets the color.
func (chooser colorChooser) SetRGBA(color *gdk.RGBA) {
	var arg0 *C.GtkColorChooser
	var arg1 *C.GdkRGBA

	arg0 = (*C.GtkColorChooser)(chooser.Native())
	arg1 = (*C.GdkRGBA)(color.Native())

	C.gtk_color_chooser_set_rgba(arg0, arg1)
}

// SetUseAlpha sets whether or not the color chooser should use the alpha
// channel.
func (chooser colorChooser) SetUseAlpha(useAlpha bool) {
	var arg0 *C.GtkColorChooser
	var arg1 C.gboolean

	arg0 = (*C.GtkColorChooser)(chooser.Native())
	if useAlpha {
		arg1 = C.TRUE
	}

	C.gtk_color_chooser_set_use_alpha(arg0, arg1)
}

// EditableOverrider contains methods that are overridable. This
// interface is a subset of the interface Editable.
type EditableOverrider interface {
	Changed()
	// DeleteText deletes a sequence of characters. The characters that are
	// deleted are those characters at positions from @start_pos up to, but not
	// including @end_pos. If @end_pos is negative, then the characters deleted
	// are those from @start_pos to the end of the text.
	//
	// Note that the positions are specified in characters, not bytes.
	DeleteText(startPos int, endPos int)
	// DoDeleteText deletes a sequence of characters. The characters that are
	// deleted are those characters at positions from @start_pos up to, but not
	// including @end_pos. If @end_pos is negative, then the characters deleted
	// are those from @start_pos to the end of the text.
	//
	// Note that the positions are specified in characters, not bytes.
	DoDeleteText(startPos int, endPos int)
	// DoInsertText inserts @new_text_length bytes of @new_text into the
	// contents of the widget, at position @position.
	//
	// Note that the position is in characters, not in bytes. The function
	// updates @position to point after the newly inserted text.
	DoInsertText(newText string, newTextLength int, position int)
	// Chars retrieves a sequence of characters. The characters that are
	// retrieved are those characters at positions from @start_pos up to, but
	// not including @end_pos. If @end_pos is negative, then the characters
	// retrieved are those characters from @start_pos to the end of the text.
	//
	// Note that positions are specified in characters, not bytes.
	Chars(startPos int, endPos int) string
	// Position retrieves the current position of the cursor relative to the
	// start of the content of the editable.
	//
	// Note that this position is in characters, not in bytes.
	Position() int
	// SelectionBounds retrieves the selection bound of the editable. start_pos
	// will be filled with the start of the selection and @end_pos with end. If
	// no text was selected both will be identical and false will be returned.
	//
	// Note that positions are specified in characters, not bytes.
	SelectionBounds() (startPos int, endPos int, ok bool)
	// InsertText inserts @new_text_length bytes of @new_text into the contents
	// of the widget, at position @position.
	//
	// Note that the position is in characters, not in bytes. The function
	// updates @position to point after the newly inserted text.
	InsertText(newText string, newTextLength int, position int)
	// SetPosition sets the cursor position in the editable to the given value.
	//
	// The cursor is displayed before the character with the given (base 0)
	// index in the contents of the editable. The value must be less than or
	// equal to the number of characters in the editable. A value of -1
	// indicates that the position should be set after the last character of the
	// editable. Note that @position is in characters, not in bytes.
	SetPosition(position int)
	// SetSelectionBounds selects a region of text. The characters that are
	// selected are those characters at positions from @start_pos up to, but not
	// including @end_pos. If @end_pos is negative, then the characters selected
	// are those characters from @start_pos to the end of the text.
	//
	// Note that positions are specified in characters, not bytes.
	SetSelectionBounds(startPos int, endPos int)
}

// Editable: the Editable interface is an interface which should be implemented
// by text editing widgets, such as Entry and SpinButton. It contains functions
// for generically manipulating an editable widget, a large number of action
// signals used for key bindings, and several signals that an application can
// connect to to modify the behavior of a widget.
//
// As an example of the latter usage, by connecting the following handler to
// Editable::insert-text, an application can convert all entry into a widget
// into uppercase.
//
// Forcing entry to uppercase.
//
//    #include <ctype.h>;
//
//    void
//    insert_text_handler (GtkEditable *editable,
//                         const gchar *text,
//                         gint         length,
//                         gint        *position,
//                         gpointer     data)
//    {
//      gchar *result = g_utf8_strup (text, length);
//
//      g_signal_handlers_block_by_func (editable,
//                                   (gpointer) insert_text_handler, data);
//      gtk_editable_insert_text (editable, result, length, position);
//      g_signal_handlers_unblock_by_func (editable,
//                                         (gpointer) insert_text_handler, data);
//
//      g_signal_stop_emission_by_name (editable, "insert_text");
//
//      g_free (result);
//    }
type Editable interface {
	gextras.Objector
	EditableOverrider

	// CopyClipboard copies the contents of the currently selected content in
	// the editable and puts it on the clipboard.
	CopyClipboard()
	// CutClipboard removes the contents of the currently selected content in
	// the editable and puts it on the clipboard.
	CutClipboard()
	// DeleteSelection deletes the currently selected text of the editable. This
	// call doesn’t do anything if there is no selected text.
	DeleteSelection()
	// Editable retrieves whether @editable is editable. See
	// gtk_editable_set_editable().
	Editable() bool
	// PasteClipboard pastes the content of the clipboard to the current
	// position of the cursor in the editable.
	PasteClipboard()
	// SelectRegion selects a region of text. The characters that are selected
	// are those characters at positions from @start_pos up to, but not
	// including @end_pos. If @end_pos is negative, then the characters selected
	// are those characters from @start_pos to the end of the text.
	//
	// Note that positions are specified in characters, not bytes.
	SelectRegion(startPos int, endPos int)
	// SetEditable determines if the user can edit the text in the editable
	// widget or not.
	SetEditable(isEditable bool)
}

// editable implements the Editable interface.
type editable struct {
	gextras.Objector
}

var _ Editable = (*editable)(nil)

// WrapEditable wraps a GObject to a type that implements interface
// Editable. It is primarily used internally.
func WrapEditable(obj *externglib.Object) Editable {
	return Editable{
		Objector: obj,
	}
}

func marshalEditable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEditable(obj), nil
}

// CopyClipboard copies the contents of the currently selected content in
// the editable and puts it on the clipboard.
func (editable editable) CopyClipboard() {
	var arg0 *C.GtkEditable

	arg0 = (*C.GtkEditable)(editable.Native())

	C.gtk_editable_copy_clipboard(arg0)
}

// CutClipboard removes the contents of the currently selected content in
// the editable and puts it on the clipboard.
func (editable editable) CutClipboard() {
	var arg0 *C.GtkEditable

	arg0 = (*C.GtkEditable)(editable.Native())

	C.gtk_editable_cut_clipboard(arg0)
}

// DeleteSelection deletes the currently selected text of the editable. This
// call doesn’t do anything if there is no selected text.
func (editable editable) DeleteSelection() {
	var arg0 *C.GtkEditable

	arg0 = (*C.GtkEditable)(editable.Native())

	C.gtk_editable_delete_selection(arg0)
}

// DeleteText deletes a sequence of characters. The characters that are
// deleted are those characters at positions from @start_pos up to, but not
// including @end_pos. If @end_pos is negative, then the characters deleted
// are those from @start_pos to the end of the text.
//
// Note that the positions are specified in characters, not bytes.
func (editable editable) DeleteText(startPos int, endPos int) {
	var arg0 *C.GtkEditable
	var arg1 C.gint
	var arg2 C.gint

	arg0 = (*C.GtkEditable)(editable.Native())
	arg1 = C.gint(startPos)
	arg2 = C.gint(endPos)

	C.gtk_editable_delete_text(arg0, arg1, arg2)
}

// Chars retrieves a sequence of characters. The characters that are
// retrieved are those characters at positions from @start_pos up to, but
// not including @end_pos. If @end_pos is negative, then the characters
// retrieved are those characters from @start_pos to the end of the text.
//
// Note that positions are specified in characters, not bytes.
func (editable editable) Chars(startPos int, endPos int) string {
	var arg0 *C.GtkEditable
	var arg1 C.gint
	var arg2 C.gint

	arg0 = (*C.GtkEditable)(editable.Native())
	arg1 = C.gint(startPos)
	arg2 = C.gint(endPos)

	ret := C.gtk_editable_get_chars(arg0, arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Editable retrieves whether @editable is editable. See
// gtk_editable_set_editable().
func (editable editable) Editable() bool {
	var arg0 *C.GtkEditable

	arg0 = (*C.GtkEditable)(editable.Native())

	ret := C.gtk_editable_get_editable(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Position retrieves the current position of the cursor relative to the
// start of the content of the editable.
//
// Note that this position is in characters, not in bytes.
func (editable editable) Position() int {
	var arg0 *C.GtkEditable

	arg0 = (*C.GtkEditable)(editable.Native())

	ret := C.gtk_editable_get_position(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// SelectionBounds retrieves the selection bound of the editable. start_pos
// will be filled with the start of the selection and @end_pos with end. If
// no text was selected both will be identical and false will be returned.
//
// Note that positions are specified in characters, not bytes.
func (editable editable) SelectionBounds() (startPos int, endPos int, ok bool) {
	var arg0 *C.GtkEditable
	var arg1 *C.gint // out
	var arg2 *C.gint // out

	arg0 = (*C.GtkEditable)(editable.Native())

	ret := C.gtk_editable_get_selection_bounds(arg0, &arg1, &arg2)

	var ret0 int
	var ret1 int
	var ret2 bool

	ret0 = int(arg1)

	ret1 = int(arg2)

	ret2 = C.BOOL(ret) != 0

	return ret0, ret1, ret2
}

// InsertText inserts @new_text_length bytes of @new_text into the contents
// of the widget, at position @position.
//
// Note that the position is in characters, not in bytes. The function
// updates @position to point after the newly inserted text.
func (editable editable) InsertText(newText string, newTextLength int, position int) {
	var arg0 *C.GtkEditable
	var arg1 *C.gchar
	var arg2 C.gint
	var arg3 *C.gint

	arg0 = (*C.GtkEditable)(editable.Native())
	arg1 = (*C.gchar)(C.CString(newText))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(newTextLength)
	arg3 = (*C.gint)(position)

	C.gtk_editable_insert_text(arg0, arg1, arg2, arg3)
}

// PasteClipboard pastes the content of the clipboard to the current
// position of the cursor in the editable.
func (editable editable) PasteClipboard() {
	var arg0 *C.GtkEditable

	arg0 = (*C.GtkEditable)(editable.Native())

	C.gtk_editable_paste_clipboard(arg0)
}

// SelectRegion selects a region of text. The characters that are selected
// are those characters at positions from @start_pos up to, but not
// including @end_pos. If @end_pos is negative, then the characters selected
// are those characters from @start_pos to the end of the text.
//
// Note that positions are specified in characters, not bytes.
func (editable editable) SelectRegion(startPos int, endPos int) {
	var arg0 *C.GtkEditable
	var arg1 C.gint
	var arg2 C.gint

	arg0 = (*C.GtkEditable)(editable.Native())
	arg1 = C.gint(startPos)
	arg2 = C.gint(endPos)

	C.gtk_editable_select_region(arg0, arg1, arg2)
}

// SetEditable determines if the user can edit the text in the editable
// widget or not.
func (editable editable) SetEditable(isEditable bool) {
	var arg0 *C.GtkEditable
	var arg1 C.gboolean

	arg0 = (*C.GtkEditable)(editable.Native())
	if isEditable {
		arg1 = C.TRUE
	}

	C.gtk_editable_set_editable(arg0, arg1)
}

// SetPosition sets the cursor position in the editable to the given value.
//
// The cursor is displayed before the character with the given (base 0)
// index in the contents of the editable. The value must be less than or
// equal to the number of characters in the editable. A value of -1
// indicates that the position should be set after the last character of the
// editable. Note that @position is in characters, not in bytes.
func (editable editable) SetPosition(position int) {
	var arg0 *C.GtkEditable
	var arg1 C.gint

	arg0 = (*C.GtkEditable)(editable.Native())
	arg1 = C.gint(position)

	C.gtk_editable_set_position(arg0, arg1)
}

// FileChooser is an interface that can be implemented by file selection
// widgets. In GTK+, the main objects that implement this interface are
// FileChooserWidget, FileChooserDialog, and FileChooserButton. You do not need
// to write an object that implements the FileChooser interface unless you are
// trying to adapt an existing file selector to expose a standard programming
// interface.
//
// FileChooser allows for shortcuts to various places in the filesystem. In the
// default implementation these are displayed in the left pane. It may be a bit
// confusing at first that these shortcuts come from various sources and in
// various flavours, so lets explain the terminology here:
//
// - Bookmarks: are created by the user, by dragging folders from the right pane
// to the left pane, or by using the “Add”. Bookmarks can be renamed and deleted
// by the user.
//
// - Shortcuts: can be provided by the application. For example, a Paint program
// may want to add a shortcut for a Clipart folder. Shortcuts cannot be modified
// by the user.
//
// - Volumes: are provided by the underlying filesystem abstraction. They are
// the “roots” of the filesystem.
//
//
// File Names and Encodings
//
// When the user is finished selecting files in a FileChooser, your program can
// get the selected names either as filenames or as URIs. For URIs, the normal
// escaping rules are applied if the URI contains non-ASCII characters. However,
// filenames are always returned in the character set specified by the
// `G_FILENAME_ENCODING` environment variable. Please see the GLib documentation
// for more details about this variable.
//
// This means that while you can pass the result of
// gtk_file_chooser_get_filename() to g_open() or g_fopen(), you may not be able
// to directly set it as the text of a Label widget unless you convert it first
// to UTF-8, which all GTK+ widgets expect. You should use g_filename_to_utf8()
// to convert filenames into strings that can be passed to GTK+ widgets.
//
//
// Adding a Preview Widget
//
// You can add a custom preview widget to a file chooser and then get
// notification about when the preview needs to be updated. To install a preview
// widget, use gtk_file_chooser_set_preview_widget(). Then, connect to the
// FileChooser::update-preview signal to get notified when you need to update
// the contents of the preview.
//
// Your callback should use gtk_file_chooser_get_preview_filename() to see what
// needs previewing. Once you have generated the preview for the corresponding
// file, you must call gtk_file_chooser_set_preview_widget_active() with a
// boolean flag that indicates whether your callback could successfully generate
// a preview.
//
// Example: Using a Preview Widget
//
//
//      GtkWidget *toggle;
//
//      ...
//
//      toggle = gtk_check_button_new_with_label ("Open file read-only");
//      gtk_widget_show (toggle);
//      gtk_file_chooser_set_extra_widget (my_file_chooser, toggle);
//    }
//
// If you want to set more than one extra widget in the file chooser, you can a
// container such as a Box or a Grid and include your widgets in it. Then, set
// the container as the whole extra widget.
type FileChooser interface {
	gextras.Objector

	// AddChoice adds a 'choice' to the file chooser. This is typically
	// implemented as a combobox or, for boolean choices, as a checkbutton. You
	// can select a value using gtk_file_chooser_set_choice() before the dialog
	// is shown, and you can obtain the user-selected value in the ::response
	// signal handler using gtk_file_chooser_get_choice().
	//
	// Compare gtk_file_chooser_set_extra_widget().
	AddChoice(id string, label string, options []string, optionLabels []string)
	// AddFilter adds @filter to the list of filters that the user can select
	// between. When a filter is selected, only files that are passed by that
	// filter are displayed.
	//
	// Note that the @chooser takes ownership of the filter, so you have to ref
	// and sink it if you want to keep a reference.
	AddFilter(filter FileFilter)
	// AddShortcutFolder adds a folder to be displayed with the shortcut folders
	// in a file chooser. Note that shortcut folders do not get saved, as they
	// are provided by the application. For example, you can use this to add a
	// “/usr/share/mydrawprogram/Clipart” folder to the volume list.
	AddShortcutFolder(folder string) error
	// AddShortcutFolderURI adds a folder URI to be displayed with the shortcut
	// folders in a file chooser. Note that shortcut folders do not get saved,
	// as they are provided by the application. For example, you can use this to
	// add a “file:///usr/share/mydrawprogram/Clipart” folder to the volume
	// list.
	AddShortcutFolderURI(uri string) error
	// Action gets the type of operation that the file chooser is performing;
	// see gtk_file_chooser_set_action().
	Action() FileChooserAction
	// Choice gets the currently selected option in the 'choice' with the given
	// ID.
	Choice(id string) string
	// CreateFolders gets whether file choser will offer to create new folders.
	// See gtk_file_chooser_set_create_folders().
	CreateFolders() bool
	// CurrentFolder gets the current folder of @chooser as a local filename.
	// See gtk_file_chooser_set_current_folder().
	//
	// Note that this is the folder that the file chooser is currently
	// displaying (e.g. "/home/username/Documents"), which is not the same as
	// the currently-selected folder if the chooser is in
	// GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER mode (e.g.
	// "/home/username/Documents/selected-folder/". To get the
	// currently-selected folder in that mode, use gtk_file_chooser_get_uri() as
	// the usual way to get the selection.
	CurrentFolder() string
	// CurrentFolderFile gets the current folder of @chooser as #GFile. See
	// gtk_file_chooser_get_current_folder_uri().
	CurrentFolderFile() gio.File
	// CurrentFolderURI gets the current folder of @chooser as an URI. See
	// gtk_file_chooser_set_current_folder_uri().
	//
	// Note that this is the folder that the file chooser is currently
	// displaying (e.g. "file:///home/username/Documents"), which is not the
	// same as the currently-selected folder if the chooser is in
	// GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER mode (e.g.
	// "file:///home/username/Documents/selected-folder/". To get the
	// currently-selected folder in that mode, use gtk_file_chooser_get_uri() as
	// the usual way to get the selection.
	CurrentFolderURI() string
	// CurrentName gets the current name in the file selector, as entered by the
	// user in the text entry for “Name”.
	//
	// This is meant to be used in save dialogs, to get the currently typed
	// filename when the file itself does not exist yet. For example, an
	// application that adds a custom extra widget to the file chooser for “file
	// format” may want to change the extension of the typed filename based on
	// the chosen format, say, from “.jpg” to “.png”.
	CurrentName() string
	// DoOverwriteConfirmation queries whether a file chooser is set to confirm
	// for overwriting when the user types a file name that already exists.
	DoOverwriteConfirmation() bool
	// ExtraWidget gets the current extra widget; see
	// gtk_file_chooser_set_extra_widget().
	ExtraWidget() Widget
	// File gets the #GFile for the currently selected file in the file
	// selector. If multiple files are selected, one of the files will be
	// returned at random.
	//
	// If the file chooser is in folder mode, this function returns the selected
	// folder.
	File() gio.File
	// Filename gets the filename for the currently selected file in the file
	// selector. The filename is returned as an absolute path. If multiple files
	// are selected, one of the filenames will be returned at random.
	//
	// If the file chooser is in folder mode, this function returns the selected
	// folder.
	Filename() string
	// Filenames lists all the selected files and subfolders in the current
	// folder of @chooser. The returned names are full absolute paths. If files
	// in the current folder cannot be represented as local filenames they will
	// be ignored. (See gtk_file_chooser_get_uris())
	Filenames() *glib.SList
	// Files lists all the selected files and subfolders in the current folder
	// of @chooser as #GFile. An internal function, see
	// gtk_file_chooser_get_uris().
	Files() *glib.SList
	// Filter gets the current filter; see gtk_file_chooser_set_filter().
	Filter() FileFilter
	// LocalOnly gets whether only local files can be selected in the file
	// selector. See gtk_file_chooser_set_local_only()
	LocalOnly() bool
	// PreviewFile gets the #GFile that should be previewed in a custom preview
	// Internal function, see gtk_file_chooser_get_preview_uri().
	PreviewFile() gio.File
	// PreviewFilename gets the filename that should be previewed in a custom
	// preview widget. See gtk_file_chooser_set_preview_widget().
	PreviewFilename() string
	// PreviewURI gets the URI that should be previewed in a custom preview
	// widget. See gtk_file_chooser_set_preview_widget().
	PreviewURI() string
	// PreviewWidget gets the current preview widget; see
	// gtk_file_chooser_set_preview_widget().
	PreviewWidget() Widget
	// PreviewWidgetActive gets whether the preview widget set by
	// gtk_file_chooser_set_preview_widget() should be shown for the current
	// filename. See gtk_file_chooser_set_preview_widget_active().
	PreviewWidgetActive() bool
	// SelectMultiple gets whether multiple files can be selected in the file
	// selector. See gtk_file_chooser_set_select_multiple().
	SelectMultiple() bool
	// ShowHidden gets whether hidden files and folders are displayed in the
	// file selector. See gtk_file_chooser_set_show_hidden().
	ShowHidden() bool
	// URI gets the URI for the currently selected file in the file selector. If
	// multiple files are selected, one of the filenames will be returned at
	// random.
	//
	// If the file chooser is in folder mode, this function returns the selected
	// folder.
	URI() string
	// Uris lists all the selected files and subfolders in the current folder of
	// @chooser. The returned names are full absolute URIs.
	Uris() *glib.SList
	// UsePreviewLabel gets whether a stock label should be drawn with the name
	// of the previewed file. See gtk_file_chooser_set_use_preview_label().
	UsePreviewLabel() bool
	// ListFilters lists the current set of user-selectable filters; see
	// gtk_file_chooser_add_filter(), gtk_file_chooser_remove_filter().
	ListFilters() *glib.SList
	// ListShortcutFolderUris queries the list of shortcut folders in the file
	// chooser, as set by gtk_file_chooser_add_shortcut_folder_uri().
	ListShortcutFolderUris() *glib.SList
	// ListShortcutFolders queries the list of shortcut folders in the file
	// chooser, as set by gtk_file_chooser_add_shortcut_folder().
	ListShortcutFolders() *glib.SList
	// RemoveChoice removes a 'choice' that has been added with
	// gtk_file_chooser_add_choice().
	RemoveChoice(id string)
	// RemoveFilter removes @filter from the list of filters that the user can
	// select between.
	RemoveFilter(filter FileFilter)
	// RemoveShortcutFolder removes a folder from a file chooser’s list of
	// shortcut folders.
	RemoveShortcutFolder(folder string) error
	// RemoveShortcutFolderURI removes a folder URI from a file chooser’s list
	// of shortcut folders.
	RemoveShortcutFolderURI(uri string) error
	// SelectAll selects all the files in the current folder of a file chooser.
	SelectAll()
	// SelectFile selects the file referred to by @file. An internal function.
	// See _gtk_file_chooser_select_uri().
	SelectFile(file gio.File) error
	// SelectFilename selects a filename. If the file name isn’t in the current
	// folder of @chooser, then the current folder of @chooser will be changed
	// to the folder containing @filename.
	SelectFilename(filename string) bool
	// SelectURI selects the file to by @uri. If the URI doesn’t refer to a file
	// in the current folder of @chooser, then the current folder of @chooser
	// will be changed to the folder containing @filename.
	SelectURI(uri string) bool
	// SetAction sets the type of operation that the chooser is performing; the
	// user interface is adapted to suit the selected action. For example, an
	// option to create a new folder might be shown if the action is
	// GTK_FILE_CHOOSER_ACTION_SAVE but not if the action is
	// GTK_FILE_CHOOSER_ACTION_OPEN.
	SetAction(action FileChooserAction)
	// SetChoice selects an option in a 'choice' that has been added with
	// gtk_file_chooser_add_choice(). For a boolean choice, the possible options
	// are "true" and "false".
	SetChoice(id string, option string)
	// SetCreateFolders sets whether file choser will offer to create new
	// folders. This is only relevant if the action is not set to be
	// GTK_FILE_CHOOSER_ACTION_OPEN.
	SetCreateFolders(createFolders bool)
	// SetCurrentFolder sets the current folder for @chooser from a local
	// filename. The user will be shown the full contents of the current folder,
	// plus user interface elements for navigating to other folders.
	//
	// In general, you should not use this function. See the [section on setting
	// up a file chooser dialog][gtkfilechooserdialog-setting-up] for the
	// rationale behind this.
	SetCurrentFolder(filename string) bool
	// SetCurrentFolderFile sets the current folder for @chooser from a #GFile.
	// Internal function, see gtk_file_chooser_set_current_folder_uri().
	SetCurrentFolderFile(file gio.File) error
	// SetCurrentFolderURI sets the current folder for @chooser from an URI. The
	// user will be shown the full contents of the current folder, plus user
	// interface elements for navigating to other folders.
	//
	// In general, you should not use this function. See the [section on setting
	// up a file chooser dialog][gtkfilechooserdialog-setting-up] for the
	// rationale behind this.
	SetCurrentFolderURI(uri string) bool
	// SetCurrentName sets the current name in the file selector, as if entered
	// by the user. Note that the name passed in here is a UTF-8 string rather
	// than a filename. This function is meant for such uses as a suggested name
	// in a “Save As...” dialog. You can pass “Untitled.doc” or a similarly
	// suitable suggestion for the @name.
	//
	// If you want to preselect a particular existing file, you should use
	// gtk_file_chooser_set_filename() or gtk_file_chooser_set_uri() instead.
	// Please see the documentation for those functions for an example of using
	// gtk_file_chooser_set_current_name() as well.
	SetCurrentName(name string)
	// SetDoOverwriteConfirmation sets whether a file chooser in
	// GTK_FILE_CHOOSER_ACTION_SAVE mode will present a confirmation dialog if
	// the user types a file name that already exists. This is false by default.
	//
	// If set to true, the @chooser will emit the FileChooser::confirm-overwrite
	// signal when appropriate.
	//
	// If all you need is the stock confirmation dialog, set this property to
	// true. You can override the way confirmation is done by actually handling
	// the FileChooser::confirm-overwrite signal; please refer to its
	// documentation for the details.
	SetDoOverwriteConfirmation(doOverwriteConfirmation bool)
	// SetExtraWidget sets an application-supplied widget to provide extra
	// options to the user.
	SetExtraWidget(extraWidget Widget)
	// SetFile sets @file as the current filename for the file chooser, by
	// changing to the file’s parent folder and actually selecting the file in
	// list. If the @chooser is in GTK_FILE_CHOOSER_ACTION_SAVE mode, the file’s
	// base name will also appear in the dialog’s file name entry.
	//
	// If the file name isn’t in the current folder of @chooser, then the
	// current folder of @chooser will be changed to the folder containing
	// @filename. This is equivalent to a sequence of
	// gtk_file_chooser_unselect_all() followed by
	// gtk_file_chooser_select_filename().
	//
	// Note that the file must exist, or nothing will be done except for the
	// directory change.
	//
	// If you are implementing a save dialog, you should use this function if
	// you already have a file name to which the user may save; for example,
	// when the user opens an existing file and then does Save As... If you
	// don’t have a file name already — for example, if the user just created a
	// new file and is saving it for the first time, do not call this function.
	// Instead, use something similar to this:
	//
	//    if (document_is_new)
	//      {
	//        // the user just created a new document
	//        gtk_file_chooser_set_current_folder_file (chooser, default_file_for_saving);
	//        gtk_file_chooser_set_current_name (chooser, "Untitled document");
	//      }
	//    else
	//      {
	//        // the user edited an existing document
	//        gtk_file_chooser_set_file (chooser, existing_file);
	//      }
	SetFile(file gio.File) error
	// SetFilename sets @filename as the current filename for the file chooser,
	// by changing to the file’s parent folder and actually selecting the file
	// in list; all other files will be unselected. If the @chooser is in
	// GTK_FILE_CHOOSER_ACTION_SAVE mode, the file’s base name will also appear
	// in the dialog’s file name entry.
	//
	// Note that the file must exist, or nothing will be done except for the
	// directory change.
	//
	// You should use this function only when implementing a save dialog for
	// which you already have a file name to which the user may save. For
	// example, when the user opens an existing file and then does Save As... to
	// save a copy or a modified version. If you don’t have a file name already
	// — for example, if the user just created a new file and is saving it for
	// the first time, do not call this function. Instead, use something similar
	// to this:
	//
	//    if (document_is_new)
	//      {
	//        // the user just created a new document
	//        gtk_file_chooser_set_current_name (chooser, "Untitled document");
	//      }
	//    else
	//      {
	//        // the user edited an existing document
	//        gtk_file_chooser_set_filename (chooser, existing_filename);
	//      }
	//
	// In the first case, the file chooser will present the user with useful
	// suggestions as to where to save his new file. In the second case, the
	// file’s existing location is already known, so the file chooser will use
	// it.
	SetFilename(filename string) bool
	// SetFilter sets the current filter; only the files that pass the filter
	// will be displayed. If the user-selectable list of filters is non-empty,
	// then the filter should be one of the filters in that list. Setting the
	// current filter when the list of filters is empty is useful if you want to
	// restrict the displayed set of files without letting the user change it.
	SetFilter(filter FileFilter)
	// SetLocalOnly sets whether only local files can be selected in the file
	// selector. If @local_only is true (the default), then the selected file or
	// files are guaranteed to be accessible through the operating systems
	// native file system and therefore the application only needs to worry
	// about the filename functions in FileChooser, like
	// gtk_file_chooser_get_filename(), rather than the URI functions like
	// gtk_file_chooser_get_uri(),
	//
	// On some systems non-native files may still be available using the native
	// filesystem via a userspace filesystem (FUSE).
	SetLocalOnly(localOnly bool)
	// SetPreviewWidget sets an application-supplied widget to use to display a
	// custom preview of the currently selected file. To implement a preview,
	// after setting the preview widget, you connect to the
	// FileChooser::update-preview signal, and call
	// gtk_file_chooser_get_preview_filename() or
	// gtk_file_chooser_get_preview_uri() on each change. If you can display a
	// preview of the new file, update your widget and set the preview active
	// using gtk_file_chooser_set_preview_widget_active(). Otherwise, set the
	// preview inactive.
	//
	// When there is no application-supplied preview widget, or the
	// application-supplied preview widget is not active, the file chooser will
	// display no preview at all.
	SetPreviewWidget(previewWidget Widget)
	// SetPreviewWidgetActive sets whether the preview widget set by
	// gtk_file_chooser_set_preview_widget() should be shown for the current
	// filename. When @active is set to false, the file chooser may display an
	// internally generated preview of the current file or it may display no
	// preview at all. See gtk_file_chooser_set_preview_widget() for more
	// details.
	SetPreviewWidgetActive(active bool)
	// SetSelectMultiple sets whether multiple files can be selected in the file
	// selector. This is only relevant if the action is set to be
	// GTK_FILE_CHOOSER_ACTION_OPEN or GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER.
	SetSelectMultiple(selectMultiple bool)
	// SetShowHidden sets whether hidden files and folders are displayed in the
	// file selector.
	SetShowHidden(showHidden bool)
	// SetURI sets the file referred to by @uri as the current file for the file
	// chooser, by changing to the URI’s parent folder and actually selecting
	// the URI in the list. If the @chooser is GTK_FILE_CHOOSER_ACTION_SAVE
	// mode, the URI’s base name will also appear in the dialog’s file name
	// entry.
	//
	// Note that the URI must exist, or nothing will be done except for the
	// directory change.
	//
	// You should use this function only when implementing a save dialog for
	// which you already have a file name to which the user may save. For
	// example, when the user opens an existing file and then does Save As... to
	// save a copy or a modified version. If you don’t have a file name already
	// — for example, if the user just created a new file and is saving it for
	// the first time, do not call this function. Instead, use something similar
	// to this:
	//
	//    if (document_is_new)
	//      {
	//        // the user just created a new document
	//        gtk_file_chooser_set_current_name (chooser, "Untitled document");
	//      }
	//    else
	//      {
	//        // the user edited an existing document
	//        gtk_file_chooser_set_uri (chooser, existing_uri);
	//      }
	//
	// In the first case, the file chooser will present the user with useful
	// suggestions as to where to save his new file. In the second case, the
	// file’s existing location is already known, so the file chooser will use
	// it.
	SetURI(uri string) bool
	// SetUsePreviewLabel sets whether the file chooser should display a stock
	// label with the name of the file that is being previewed; the default is
	// true. Applications that want to draw the whole preview area themselves
	// should set this to false and display the name themselves in their preview
	// widget.
	//
	// See also: gtk_file_chooser_set_preview_widget()
	SetUsePreviewLabel(useLabel bool)
	// UnselectAll unselects all the files in the current folder of a file
	// chooser.
	UnselectAll()
	// UnselectFile unselects the file referred to by @file. If the file is not
	// in the current directory, does not exist, or is otherwise not currently
	// selected, does nothing.
	UnselectFile(file gio.File)
	// UnselectFilename unselects a currently selected filename. If the filename
	// is not in the current directory, does not exist, or is otherwise not
	// currently selected, does nothing.
	UnselectFilename(filename string)
	// UnselectURI unselects the file referred to by @uri. If the file is not in
	// the current directory, does not exist, or is otherwise not currently
	// selected, does nothing.
	UnselectURI(uri string)
}

// fileChooser implements the FileChooser interface.
type fileChooser struct {
	gextras.Objector
}

var _ FileChooser = (*fileChooser)(nil)

// WrapFileChooser wraps a GObject to a type that implements interface
// FileChooser. It is primarily used internally.
func WrapFileChooser(obj *externglib.Object) FileChooser {
	return FileChooser{
		Objector: obj,
	}
}

func marshalFileChooser(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileChooser(obj), nil
}

// AddChoice adds a 'choice' to the file chooser. This is typically
// implemented as a combobox or, for boolean choices, as a checkbutton. You
// can select a value using gtk_file_chooser_set_choice() before the dialog
// is shown, and you can obtain the user-selected value in the ::response
// signal handler using gtk_file_chooser_get_choice().
//
// Compare gtk_file_chooser_set_extra_widget().
func (chooser fileChooser) AddChoice(id string, label string, options []string, optionLabels []string) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char
	var arg2 *C.char
	var arg3 **C.char
	var arg4 **C.char

	arg0 = (*C.GtkFileChooser)(chooser.Native())
	arg1 = (*C.gchar)(C.CString(id))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg2))
	{
		var dst []*C.char
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(options) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(options)
		sliceHeader.Cap = len(options)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(options); i++ {
			src := options[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg3 = (**C.char)(unsafe.Pointer(ptr))
	}
	{
		var dst []*C.char
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(optionLabels) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(optionLabels)
		sliceHeader.Cap = len(optionLabels)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(optionLabels); i++ {
			src := optionLabels[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg4 = (**C.char)(unsafe.Pointer(ptr))
	}

	C.gtk_file_chooser_add_choice(arg0, arg1, arg2, arg3, arg4)
}

// AddFilter adds @filter to the list of filters that the user can select
// between. When a filter is selected, only files that are passed by that
// filter are displayed.
//
// Note that the @chooser takes ownership of the filter, so you have to ref
// and sink it if you want to keep a reference.
func (chooser fileChooser) AddFilter(filter FileFilter) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.GtkFileFilter

	arg0 = (*C.GtkFileChooser)(chooser.Native())
	arg1 = (*C.GtkFileFilter)(filter.Native())

	C.gtk_file_chooser_add_filter(arg0, arg1)
}

// AddShortcutFolder adds a folder to be displayed with the shortcut folders
// in a file chooser. Note that shortcut folders do not get saved, as they
// are provided by the application. For example, you can use this to add a
// “/usr/share/mydrawprogram/Clipart” folder to the volume list.
func (chooser fileChooser) AddShortcutFolder(folder string) error {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char
	var gError *C.GError

	arg0 = (*C.GtkFileChooser)(chooser.Native())
	arg1 = (*C.gchar)(C.CString(folder))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_file_chooser_add_shortcut_folder(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// AddShortcutFolderURI adds a folder URI to be displayed with the shortcut
// folders in a file chooser. Note that shortcut folders do not get saved,
// as they are provided by the application. For example, you can use this to
// add a “file:///usr/share/mydrawprogram/Clipart” folder to the volume
// list.
func (chooser fileChooser) AddShortcutFolderURI(uri string) error {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char
	var gError *C.GError

	arg0 = (*C.GtkFileChooser)(chooser.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_file_chooser_add_shortcut_folder_uri(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// Action gets the type of operation that the file chooser is performing;
// see gtk_file_chooser_set_action().
func (chooser fileChooser) Action() FileChooserAction {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(chooser.Native())

	ret := C.gtk_file_chooser_get_action(arg0)

	var ret0 FileChooserAction

	ret0 = FileChooserAction(ret)

	return ret0
}

// Choice gets the currently selected option in the 'choice' with the given
// ID.
func (chooser fileChooser) Choice(id string) string {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char

	arg0 = (*C.GtkFileChooser)(chooser.Native())
	arg1 = (*C.gchar)(C.CString(id))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_file_chooser_get_choice(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// CreateFolders gets whether file choser will offer to create new folders.
// See gtk_file_chooser_set_create_folders().
func (chooser fileChooser) CreateFolders() bool {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(chooser.Native())

	ret := C.gtk_file_chooser_get_create_folders(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// CurrentFolder gets the current folder of @chooser as a local filename.
// See gtk_file_chooser_set_current_folder().
//
// Note that this is the folder that the file chooser is currently
// displaying (e.g. "/home/username/Documents"), which is not the same as
// the currently-selected folder if the chooser is in
// GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER mode (e.g.
// "/home/username/Documents/selected-folder/". To get the
// currently-selected folder in that mode, use gtk_file_chooser_get_uri() as
// the usual way to get the selection.
func (chooser fileChooser) CurrentFolder() string {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(chooser.Native())

	ret := C.gtk_file_chooser_get_current_folder(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// CurrentFolderFile gets the current folder of @chooser as #GFile. See
// gtk_file_chooser_get_current_folder_uri().
func (chooser fileChooser) CurrentFolderFile() gio.File {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(chooser.Native())

	ret := C.gtk_file_chooser_get_current_folder_file(arg0)

	var ret0 gio.File

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gio.File)

	return ret0
}

// CurrentFolderURI gets the current folder of @chooser as an URI. See
// gtk_file_chooser_set_current_folder_uri().
//
// Note that this is the folder that the file chooser is currently
// displaying (e.g. "file:///home/username/Documents"), which is not the
// same as the currently-selected folder if the chooser is in
// GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER mode (e.g.
// "file:///home/username/Documents/selected-folder/". To get the
// currently-selected folder in that mode, use gtk_file_chooser_get_uri() as
// the usual way to get the selection.
func (chooser fileChooser) CurrentFolderURI() string {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(chooser.Native())

	ret := C.gtk_file_chooser_get_current_folder_uri(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// CurrentName gets the current name in the file selector, as entered by the
// user in the text entry for “Name”.
//
// This is meant to be used in save dialogs, to get the currently typed
// filename when the file itself does not exist yet. For example, an
// application that adds a custom extra widget to the file chooser for “file
// format” may want to change the extension of the typed filename based on
// the chosen format, say, from “.jpg” to “.png”.
func (chooser fileChooser) CurrentName() string {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(chooser.Native())

	ret := C.gtk_file_chooser_get_current_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// DoOverwriteConfirmation queries whether a file chooser is set to confirm
// for overwriting when the user types a file name that already exists.
func (chooser fileChooser) DoOverwriteConfirmation() bool {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(chooser.Native())

	ret := C.gtk_file_chooser_get_do_overwrite_confirmation(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ExtraWidget gets the current extra widget; see
// gtk_file_chooser_set_extra_widget().
func (chooser fileChooser) ExtraWidget() Widget {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(chooser.Native())

	ret := C.gtk_file_chooser_get_extra_widget(arg0)

	var ret0 Widget

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Widget)

	return ret0
}

// File gets the #GFile for the currently selected file in the file
// selector. If multiple files are selected, one of the files will be
// returned at random.
//
// If the file chooser is in folder mode, this function returns the selected
// folder.
func (chooser fileChooser) File() gio.File {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(chooser.Native())

	ret := C.gtk_file_chooser_get_file(arg0)

	var ret0 gio.File

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gio.File)

	return ret0
}

// Filename gets the filename for the currently selected file in the file
// selector. The filename is returned as an absolute path. If multiple files
// are selected, one of the filenames will be returned at random.
//
// If the file chooser is in folder mode, this function returns the selected
// folder.
func (chooser fileChooser) Filename() string {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(chooser.Native())

	ret := C.gtk_file_chooser_get_filename(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Filenames lists all the selected files and subfolders in the current
// folder of @chooser. The returned names are full absolute paths. If files
// in the current folder cannot be represented as local filenames they will
// be ignored. (See gtk_file_chooser_get_uris())
func (chooser fileChooser) Filenames() *glib.SList {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(chooser.Native())

	ret := C.gtk_file_chooser_get_filenames(arg0)

	var ret0 *glib.SList

	{
		ret0 = glib.WrapSList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.SList) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Files lists all the selected files and subfolders in the current folder
// of @chooser as #GFile. An internal function, see
// gtk_file_chooser_get_uris().
func (chooser fileChooser) Files() *glib.SList {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(chooser.Native())

	ret := C.gtk_file_chooser_get_files(arg0)

	var ret0 *glib.SList

	{
		ret0 = glib.WrapSList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.SList) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Filter gets the current filter; see gtk_file_chooser_set_filter().
func (chooser fileChooser) Filter() FileFilter {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(chooser.Native())

	ret := C.gtk_file_chooser_get_filter(arg0)

	var ret0 FileFilter

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(FileFilter)

	return ret0
}

// LocalOnly gets whether only local files can be selected in the file
// selector. See gtk_file_chooser_set_local_only()
func (chooser fileChooser) LocalOnly() bool {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(chooser.Native())

	ret := C.gtk_file_chooser_get_local_only(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// PreviewFile gets the #GFile that should be previewed in a custom preview
// Internal function, see gtk_file_chooser_get_preview_uri().
func (chooser fileChooser) PreviewFile() gio.File {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(chooser.Native())

	ret := C.gtk_file_chooser_get_preview_file(arg0)

	var ret0 gio.File

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gio.File)

	return ret0
}

// PreviewFilename gets the filename that should be previewed in a custom
// preview widget. See gtk_file_chooser_set_preview_widget().
func (chooser fileChooser) PreviewFilename() string {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(chooser.Native())

	ret := C.gtk_file_chooser_get_preview_filename(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// PreviewURI gets the URI that should be previewed in a custom preview
// widget. See gtk_file_chooser_set_preview_widget().
func (chooser fileChooser) PreviewURI() string {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(chooser.Native())

	ret := C.gtk_file_chooser_get_preview_uri(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// PreviewWidget gets the current preview widget; see
// gtk_file_chooser_set_preview_widget().
func (chooser fileChooser) PreviewWidget() Widget {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(chooser.Native())

	ret := C.gtk_file_chooser_get_preview_widget(arg0)

	var ret0 Widget

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Widget)

	return ret0
}

// PreviewWidgetActive gets whether the preview widget set by
// gtk_file_chooser_set_preview_widget() should be shown for the current
// filename. See gtk_file_chooser_set_preview_widget_active().
func (chooser fileChooser) PreviewWidgetActive() bool {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(chooser.Native())

	ret := C.gtk_file_chooser_get_preview_widget_active(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SelectMultiple gets whether multiple files can be selected in the file
// selector. See gtk_file_chooser_set_select_multiple().
func (chooser fileChooser) SelectMultiple() bool {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(chooser.Native())

	ret := C.gtk_file_chooser_get_select_multiple(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ShowHidden gets whether hidden files and folders are displayed in the
// file selector. See gtk_file_chooser_set_show_hidden().
func (chooser fileChooser) ShowHidden() bool {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(chooser.Native())

	ret := C.gtk_file_chooser_get_show_hidden(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// URI gets the URI for the currently selected file in the file selector. If
// multiple files are selected, one of the filenames will be returned at
// random.
//
// If the file chooser is in folder mode, this function returns the selected
// folder.
func (chooser fileChooser) URI() string {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(chooser.Native())

	ret := C.gtk_file_chooser_get_uri(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Uris lists all the selected files and subfolders in the current folder of
// @chooser. The returned names are full absolute URIs.
func (chooser fileChooser) Uris() *glib.SList {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(chooser.Native())

	ret := C.gtk_file_chooser_get_uris(arg0)

	var ret0 *glib.SList

	{
		ret0 = glib.WrapSList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.SList) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// UsePreviewLabel gets whether a stock label should be drawn with the name
// of the previewed file. See gtk_file_chooser_set_use_preview_label().
func (chooser fileChooser) UsePreviewLabel() bool {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(chooser.Native())

	ret := C.gtk_file_chooser_get_use_preview_label(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ListFilters lists the current set of user-selectable filters; see
// gtk_file_chooser_add_filter(), gtk_file_chooser_remove_filter().
func (chooser fileChooser) ListFilters() *glib.SList {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(chooser.Native())

	ret := C.gtk_file_chooser_list_filters(arg0)

	var ret0 *glib.SList

	{
		ret0 = glib.WrapSList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.SList) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// ListShortcutFolderUris queries the list of shortcut folders in the file
// chooser, as set by gtk_file_chooser_add_shortcut_folder_uri().
func (chooser fileChooser) ListShortcutFolderUris() *glib.SList {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(chooser.Native())

	ret := C.gtk_file_chooser_list_shortcut_folder_uris(arg0)

	var ret0 *glib.SList

	{
		ret0 = glib.WrapSList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.SList) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// ListShortcutFolders queries the list of shortcut folders in the file
// chooser, as set by gtk_file_chooser_add_shortcut_folder().
func (chooser fileChooser) ListShortcutFolders() *glib.SList {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(chooser.Native())

	ret := C.gtk_file_chooser_list_shortcut_folders(arg0)

	var ret0 *glib.SList

	{
		ret0 = glib.WrapSList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.SList) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// RemoveChoice removes a 'choice' that has been added with
// gtk_file_chooser_add_choice().
func (chooser fileChooser) RemoveChoice(id string) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char

	arg0 = (*C.GtkFileChooser)(chooser.Native())
	arg1 = (*C.gchar)(C.CString(id))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_file_chooser_remove_choice(arg0, arg1)
}

// RemoveFilter removes @filter from the list of filters that the user can
// select between.
func (chooser fileChooser) RemoveFilter(filter FileFilter) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.GtkFileFilter

	arg0 = (*C.GtkFileChooser)(chooser.Native())
	arg1 = (*C.GtkFileFilter)(filter.Native())

	C.gtk_file_chooser_remove_filter(arg0, arg1)
}

// RemoveShortcutFolder removes a folder from a file chooser’s list of
// shortcut folders.
func (chooser fileChooser) RemoveShortcutFolder(folder string) error {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char
	var gError *C.GError

	arg0 = (*C.GtkFileChooser)(chooser.Native())
	arg1 = (*C.gchar)(C.CString(folder))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_file_chooser_remove_shortcut_folder(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// RemoveShortcutFolderURI removes a folder URI from a file chooser’s list
// of shortcut folders.
func (chooser fileChooser) RemoveShortcutFolderURI(uri string) error {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char
	var gError *C.GError

	arg0 = (*C.GtkFileChooser)(chooser.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_file_chooser_remove_shortcut_folder_uri(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SelectAll selects all the files in the current folder of a file chooser.
func (chooser fileChooser) SelectAll() {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(chooser.Native())

	C.gtk_file_chooser_select_all(arg0)
}

// SelectFile selects the file referred to by @file. An internal function.
// See _gtk_file_chooser_select_uri().
func (chooser fileChooser) SelectFile(file gio.File) error {
	var arg0 *C.GtkFileChooser
	var arg1 *C.GFile
	var gError *C.GError

	arg0 = (*C.GtkFileChooser)(chooser.Native())
	arg1 = (*C.GFile)(file.Native())

	ret := C.gtk_file_chooser_select_file(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SelectFilename selects a filename. If the file name isn’t in the current
// folder of @chooser, then the current folder of @chooser will be changed
// to the folder containing @filename.
func (chooser fileChooser) SelectFilename(filename string) bool {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char

	arg0 = (*C.GtkFileChooser)(chooser.Native())
	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_file_chooser_select_filename(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SelectURI selects the file to by @uri. If the URI doesn’t refer to a file
// in the current folder of @chooser, then the current folder of @chooser
// will be changed to the folder containing @filename.
func (chooser fileChooser) SelectURI(uri string) bool {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char

	arg0 = (*C.GtkFileChooser)(chooser.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_file_chooser_select_uri(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SetAction sets the type of operation that the chooser is performing; the
// user interface is adapted to suit the selected action. For example, an
// option to create a new folder might be shown if the action is
// GTK_FILE_CHOOSER_ACTION_SAVE but not if the action is
// GTK_FILE_CHOOSER_ACTION_OPEN.
func (chooser fileChooser) SetAction(action FileChooserAction) {
	var arg0 *C.GtkFileChooser
	var arg1 C.GtkFileChooserAction

	arg0 = (*C.GtkFileChooser)(chooser.Native())
	arg1 = (C.GtkFileChooserAction)(action)

	C.gtk_file_chooser_set_action(arg0, arg1)
}

// SetChoice selects an option in a 'choice' that has been added with
// gtk_file_chooser_add_choice(). For a boolean choice, the possible options
// are "true" and "false".
func (chooser fileChooser) SetChoice(id string, option string) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char
	var arg2 *C.char

	arg0 = (*C.GtkFileChooser)(chooser.Native())
	arg1 = (*C.gchar)(C.CString(id))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(option))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_file_chooser_set_choice(arg0, arg1, arg2)
}

// SetCreateFolders sets whether file choser will offer to create new
// folders. This is only relevant if the action is not set to be
// GTK_FILE_CHOOSER_ACTION_OPEN.
func (chooser fileChooser) SetCreateFolders(createFolders bool) {
	var arg0 *C.GtkFileChooser
	var arg1 C.gboolean

	arg0 = (*C.GtkFileChooser)(chooser.Native())
	if createFolders {
		arg1 = C.TRUE
	}

	C.gtk_file_chooser_set_create_folders(arg0, arg1)
}

// SetCurrentFolder sets the current folder for @chooser from a local
// filename. The user will be shown the full contents of the current folder,
// plus user interface elements for navigating to other folders.
//
// In general, you should not use this function. See the [section on setting
// up a file chooser dialog][gtkfilechooserdialog-setting-up] for the
// rationale behind this.
func (chooser fileChooser) SetCurrentFolder(filename string) bool {
	var arg0 *C.GtkFileChooser
	var arg1 *C.gchar

	arg0 = (*C.GtkFileChooser)(chooser.Native())
	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_file_chooser_set_current_folder(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SetCurrentFolderFile sets the current folder for @chooser from a #GFile.
// Internal function, see gtk_file_chooser_set_current_folder_uri().
func (chooser fileChooser) SetCurrentFolderFile(file gio.File) error {
	var arg0 *C.GtkFileChooser
	var arg1 *C.GFile
	var gError *C.GError

	arg0 = (*C.GtkFileChooser)(chooser.Native())
	arg1 = (*C.GFile)(file.Native())

	ret := C.gtk_file_chooser_set_current_folder_file(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SetCurrentFolderURI sets the current folder for @chooser from an URI. The
// user will be shown the full contents of the current folder, plus user
// interface elements for navigating to other folders.
//
// In general, you should not use this function. See the [section on setting
// up a file chooser dialog][gtkfilechooserdialog-setting-up] for the
// rationale behind this.
func (chooser fileChooser) SetCurrentFolderURI(uri string) bool {
	var arg0 *C.GtkFileChooser
	var arg1 *C.gchar

	arg0 = (*C.GtkFileChooser)(chooser.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_file_chooser_set_current_folder_uri(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SetCurrentName sets the current name in the file selector, as if entered
// by the user. Note that the name passed in here is a UTF-8 string rather
// than a filename. This function is meant for such uses as a suggested name
// in a “Save As...” dialog. You can pass “Untitled.doc” or a similarly
// suitable suggestion for the @name.
//
// If you want to preselect a particular existing file, you should use
// gtk_file_chooser_set_filename() or gtk_file_chooser_set_uri() instead.
// Please see the documentation for those functions for an example of using
// gtk_file_chooser_set_current_name() as well.
func (chooser fileChooser) SetCurrentName(name string) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.gchar

	arg0 = (*C.GtkFileChooser)(chooser.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_file_chooser_set_current_name(arg0, arg1)
}

// SetDoOverwriteConfirmation sets whether a file chooser in
// GTK_FILE_CHOOSER_ACTION_SAVE mode will present a confirmation dialog if
// the user types a file name that already exists. This is false by default.
//
// If set to true, the @chooser will emit the FileChooser::confirm-overwrite
// signal when appropriate.
//
// If all you need is the stock confirmation dialog, set this property to
// true. You can override the way confirmation is done by actually handling
// the FileChooser::confirm-overwrite signal; please refer to its
// documentation for the details.
func (chooser fileChooser) SetDoOverwriteConfirmation(doOverwriteConfirmation bool) {
	var arg0 *C.GtkFileChooser
	var arg1 C.gboolean

	arg0 = (*C.GtkFileChooser)(chooser.Native())
	if doOverwriteConfirmation {
		arg1 = C.TRUE
	}

	C.gtk_file_chooser_set_do_overwrite_confirmation(arg0, arg1)
}

// SetExtraWidget sets an application-supplied widget to provide extra
// options to the user.
func (chooser fileChooser) SetExtraWidget(extraWidget Widget) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkFileChooser)(chooser.Native())
	arg1 = (*C.GtkWidget)(extraWidget.Native())

	C.gtk_file_chooser_set_extra_widget(arg0, arg1)
}

// SetFile sets @file as the current filename for the file chooser, by
// changing to the file’s parent folder and actually selecting the file in
// list. If the @chooser is in GTK_FILE_CHOOSER_ACTION_SAVE mode, the file’s
// base name will also appear in the dialog’s file name entry.
//
// If the file name isn’t in the current folder of @chooser, then the
// current folder of @chooser will be changed to the folder containing
// @filename. This is equivalent to a sequence of
// gtk_file_chooser_unselect_all() followed by
// gtk_file_chooser_select_filename().
//
// Note that the file must exist, or nothing will be done except for the
// directory change.
//
// If you are implementing a save dialog, you should use this function if
// you already have a file name to which the user may save; for example,
// when the user opens an existing file and then does Save As... If you
// don’t have a file name already — for example, if the user just created a
// new file and is saving it for the first time, do not call this function.
// Instead, use something similar to this:
//
//    if (document_is_new)
//      {
//        // the user just created a new document
//        gtk_file_chooser_set_current_folder_file (chooser, default_file_for_saving);
//        gtk_file_chooser_set_current_name (chooser, "Untitled document");
//      }
//    else
//      {
//        // the user edited an existing document
//        gtk_file_chooser_set_file (chooser, existing_file);
//      }
func (chooser fileChooser) SetFile(file gio.File) error {
	var arg0 *C.GtkFileChooser
	var arg1 *C.GFile
	var gError *C.GError

	arg0 = (*C.GtkFileChooser)(chooser.Native())
	arg1 = (*C.GFile)(file.Native())

	ret := C.gtk_file_chooser_set_file(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SetFilename sets @filename as the current filename for the file chooser,
// by changing to the file’s parent folder and actually selecting the file
// in list; all other files will be unselected. If the @chooser is in
// GTK_FILE_CHOOSER_ACTION_SAVE mode, the file’s base name will also appear
// in the dialog’s file name entry.
//
// Note that the file must exist, or nothing will be done except for the
// directory change.
//
// You should use this function only when implementing a save dialog for
// which you already have a file name to which the user may save. For
// example, when the user opens an existing file and then does Save As... to
// save a copy or a modified version. If you don’t have a file name already
// — for example, if the user just created a new file and is saving it for
// the first time, do not call this function. Instead, use something similar
// to this:
//
//    if (document_is_new)
//      {
//        // the user just created a new document
//        gtk_file_chooser_set_current_name (chooser, "Untitled document");
//      }
//    else
//      {
//        // the user edited an existing document
//        gtk_file_chooser_set_filename (chooser, existing_filename);
//      }
//
// In the first case, the file chooser will present the user with useful
// suggestions as to where to save his new file. In the second case, the
// file’s existing location is already known, so the file chooser will use
// it.
func (chooser fileChooser) SetFilename(filename string) bool {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char

	arg0 = (*C.GtkFileChooser)(chooser.Native())
	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_file_chooser_set_filename(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SetFilter sets the current filter; only the files that pass the filter
// will be displayed. If the user-selectable list of filters is non-empty,
// then the filter should be one of the filters in that list. Setting the
// current filter when the list of filters is empty is useful if you want to
// restrict the displayed set of files without letting the user change it.
func (chooser fileChooser) SetFilter(filter FileFilter) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.GtkFileFilter

	arg0 = (*C.GtkFileChooser)(chooser.Native())
	arg1 = (*C.GtkFileFilter)(filter.Native())

	C.gtk_file_chooser_set_filter(arg0, arg1)
}

// SetLocalOnly sets whether only local files can be selected in the file
// selector. If @local_only is true (the default), then the selected file or
// files are guaranteed to be accessible through the operating systems
// native file system and therefore the application only needs to worry
// about the filename functions in FileChooser, like
// gtk_file_chooser_get_filename(), rather than the URI functions like
// gtk_file_chooser_get_uri(),
//
// On some systems non-native files may still be available using the native
// filesystem via a userspace filesystem (FUSE).
func (chooser fileChooser) SetLocalOnly(localOnly bool) {
	var arg0 *C.GtkFileChooser
	var arg1 C.gboolean

	arg0 = (*C.GtkFileChooser)(chooser.Native())
	if localOnly {
		arg1 = C.TRUE
	}

	C.gtk_file_chooser_set_local_only(arg0, arg1)
}

// SetPreviewWidget sets an application-supplied widget to use to display a
// custom preview of the currently selected file. To implement a preview,
// after setting the preview widget, you connect to the
// FileChooser::update-preview signal, and call
// gtk_file_chooser_get_preview_filename() or
// gtk_file_chooser_get_preview_uri() on each change. If you can display a
// preview of the new file, update your widget and set the preview active
// using gtk_file_chooser_set_preview_widget_active(). Otherwise, set the
// preview inactive.
//
// When there is no application-supplied preview widget, or the
// application-supplied preview widget is not active, the file chooser will
// display no preview at all.
func (chooser fileChooser) SetPreviewWidget(previewWidget Widget) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkFileChooser)(chooser.Native())
	arg1 = (*C.GtkWidget)(previewWidget.Native())

	C.gtk_file_chooser_set_preview_widget(arg0, arg1)
}

// SetPreviewWidgetActive sets whether the preview widget set by
// gtk_file_chooser_set_preview_widget() should be shown for the current
// filename. When @active is set to false, the file chooser may display an
// internally generated preview of the current file or it may display no
// preview at all. See gtk_file_chooser_set_preview_widget() for more
// details.
func (chooser fileChooser) SetPreviewWidgetActive(active bool) {
	var arg0 *C.GtkFileChooser
	var arg1 C.gboolean

	arg0 = (*C.GtkFileChooser)(chooser.Native())
	if active {
		arg1 = C.TRUE
	}

	C.gtk_file_chooser_set_preview_widget_active(arg0, arg1)
}

// SetSelectMultiple sets whether multiple files can be selected in the file
// selector. This is only relevant if the action is set to be
// GTK_FILE_CHOOSER_ACTION_OPEN or GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER.
func (chooser fileChooser) SetSelectMultiple(selectMultiple bool) {
	var arg0 *C.GtkFileChooser
	var arg1 C.gboolean

	arg0 = (*C.GtkFileChooser)(chooser.Native())
	if selectMultiple {
		arg1 = C.TRUE
	}

	C.gtk_file_chooser_set_select_multiple(arg0, arg1)
}

// SetShowHidden sets whether hidden files and folders are displayed in the
// file selector.
func (chooser fileChooser) SetShowHidden(showHidden bool) {
	var arg0 *C.GtkFileChooser
	var arg1 C.gboolean

	arg0 = (*C.GtkFileChooser)(chooser.Native())
	if showHidden {
		arg1 = C.TRUE
	}

	C.gtk_file_chooser_set_show_hidden(arg0, arg1)
}

// SetURI sets the file referred to by @uri as the current file for the file
// chooser, by changing to the URI’s parent folder and actually selecting
// the URI in the list. If the @chooser is GTK_FILE_CHOOSER_ACTION_SAVE
// mode, the URI’s base name will also appear in the dialog’s file name
// entry.
//
// Note that the URI must exist, or nothing will be done except for the
// directory change.
//
// You should use this function only when implementing a save dialog for
// which you already have a file name to which the user may save. For
// example, when the user opens an existing file and then does Save As... to
// save a copy or a modified version. If you don’t have a file name already
// — for example, if the user just created a new file and is saving it for
// the first time, do not call this function. Instead, use something similar
// to this:
//
//    if (document_is_new)
//      {
//        // the user just created a new document
//        gtk_file_chooser_set_current_name (chooser, "Untitled document");
//      }
//    else
//      {
//        // the user edited an existing document
//        gtk_file_chooser_set_uri (chooser, existing_uri);
//      }
//
// In the first case, the file chooser will present the user with useful
// suggestions as to where to save his new file. In the second case, the
// file’s existing location is already known, so the file chooser will use
// it.
func (chooser fileChooser) SetURI(uri string) bool {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char

	arg0 = (*C.GtkFileChooser)(chooser.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_file_chooser_set_uri(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SetUsePreviewLabel sets whether the file chooser should display a stock
// label with the name of the file that is being previewed; the default is
// true. Applications that want to draw the whole preview area themselves
// should set this to false and display the name themselves in their preview
// widget.
//
// See also: gtk_file_chooser_set_preview_widget()
func (chooser fileChooser) SetUsePreviewLabel(useLabel bool) {
	var arg0 *C.GtkFileChooser
	var arg1 C.gboolean

	arg0 = (*C.GtkFileChooser)(chooser.Native())
	if useLabel {
		arg1 = C.TRUE
	}

	C.gtk_file_chooser_set_use_preview_label(arg0, arg1)
}

// UnselectAll unselects all the files in the current folder of a file
// chooser.
func (chooser fileChooser) UnselectAll() {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(chooser.Native())

	C.gtk_file_chooser_unselect_all(arg0)
}

// UnselectFile unselects the file referred to by @file. If the file is not
// in the current directory, does not exist, or is otherwise not currently
// selected, does nothing.
func (chooser fileChooser) UnselectFile(file gio.File) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.GFile

	arg0 = (*C.GtkFileChooser)(chooser.Native())
	arg1 = (*C.GFile)(file.Native())

	C.gtk_file_chooser_unselect_file(arg0, arg1)
}

// UnselectFilename unselects a currently selected filename. If the filename
// is not in the current directory, does not exist, or is otherwise not
// currently selected, does nothing.
func (chooser fileChooser) UnselectFilename(filename string) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char

	arg0 = (*C.GtkFileChooser)(chooser.Native())
	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_file_chooser_unselect_filename(arg0, arg1)
}

// UnselectURI unselects the file referred to by @uri. If the file is not in
// the current directory, does not exist, or is otherwise not currently
// selected, does nothing.
func (chooser fileChooser) UnselectURI(uri string) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char

	arg0 = (*C.GtkFileChooser)(chooser.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_file_chooser_unselect_uri(arg0, arg1)
}

// FontChooserOverrider contains methods that are overridable. This
// interface is a subset of the interface FontChooser.
type FontChooserOverrider interface {
	FontActivated(fontname string)
	// FontFace gets the FontFace representing the selected font group details
	// (i.e. family, slant, weight, width, etc).
	//
	// If the selected font is not installed, returns nil.
	FontFace() pango.FontFace
	// FontFamily gets the FontFamily representing the selected font family.
	// Font families are a collection of font faces.
	//
	// If the selected font is not installed, returns nil.
	FontFamily() pango.FontFamily
	// FontMap gets the custom font map of this font chooser widget, or nil if
	// it does not have one.
	FontMap() pango.FontMap
	// FontSize: the selected font size.
	FontSize() int
	// SetFilterFunc adds a filter function that decides which fonts to display
	// in the font chooser.
	SetFilterFunc(filter FontFilterFunc)
	// SetFontMap sets a custom font map to use for this font chooser widget. A
	// custom font map can be used to present application-specific fonts instead
	// of or in addition to the normal system fonts.
	//
	//    FcConfig *config;
	//    PangoFontMap *fontmap;
	//
	//    config = FcInitLoadConfigAndFonts ();
	//    FcConfigAppFontAddFile (config, my_app_font_file);
	//
	//    fontmap = pango_cairo_font_map_new_for_font_type (CAIRO_FONT_TYPE_FT);
	//    pango_fc_font_map_set_config (PANGO_FC_FONT_MAP (fontmap), config);
	//
	//    gtk_font_chooser_set_font_map (font_chooser, fontmap);
	//
	// Note that other GTK+ widgets will only be able to use the
	// application-specific font if it is present in the font map they use:
	//
	//    context = gtk_widget_get_pango_context (label);
	//    pango_context_set_font_map (context, fontmap);
	SetFontMap(fontmap pango.FontMap)
}

// FontChooser is an interface that can be implemented by widgets displaying the
// list of fonts. In GTK+, the main objects that implement this interface are
// FontChooserWidget, FontChooserDialog and FontButton. The GtkFontChooser
// interface has been introducted in GTK+ 3.2.
type FontChooser interface {
	gextras.Objector
	FontChooserOverrider

	// Font gets the currently-selected font name.
	//
	// Note that this can be a different string than what you set with
	// gtk_font_chooser_set_font(), as the font chooser widget may normalize
	// font names and thus return a string with a different structure. For
	// example, “Helvetica Italic Bold 12” could be normalized to “Helvetica
	// Bold Italic 12”.
	//
	// Use pango_font_description_equal() if you want to compare two font
	// descriptions.
	Font() string
	// FontDesc gets the currently-selected font.
	//
	// Note that this can be a different string than what you set with
	// gtk_font_chooser_set_font(), as the font chooser widget may normalize
	// font names and thus return a string with a different structure. For
	// example, “Helvetica Italic Bold 12” could be normalized to “Helvetica
	// Bold Italic 12”.
	//
	// Use pango_font_description_equal() if you want to compare two font
	// descriptions.
	FontDesc() *pango.FontDescription
	// FontFeatures gets the currently-selected font features.
	FontFeatures() string
	// Language gets the language that is used for font features.
	Language() string
	// Level returns the current level of granularity for selecting fonts.
	Level() FontChooserLevel
	// PreviewText gets the text displayed in the preview area.
	PreviewText() string
	// ShowPreviewEntry returns whether the preview entry is shown or not.
	ShowPreviewEntry() bool
	// SetFont sets the currently-selected font.
	SetFont(fontname string)
	// SetFontDesc sets the currently-selected font from @font_desc.
	SetFontDesc(fontDesc *pango.FontDescription)
	// SetLanguage sets the language to use for font features.
	SetLanguage(language string)
	// SetLevel sets the desired level of granularity for selecting fonts.
	SetLevel(level FontChooserLevel)
	// SetPreviewText sets the text displayed in the preview area. The @text is
	// used to show how the selected font looks.
	SetPreviewText(text string)
	// SetShowPreviewEntry shows or hides the editable preview entry.
	SetShowPreviewEntry(showPreviewEntry bool)
}

// fontChooser implements the FontChooser interface.
type fontChooser struct {
	gextras.Objector
}

var _ FontChooser = (*fontChooser)(nil)

// WrapFontChooser wraps a GObject to a type that implements interface
// FontChooser. It is primarily used internally.
func WrapFontChooser(obj *externglib.Object) FontChooser {
	return FontChooser{
		Objector: obj,
	}
}

func marshalFontChooser(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFontChooser(obj), nil
}

// Font gets the currently-selected font name.
//
// Note that this can be a different string than what you set with
// gtk_font_chooser_set_font(), as the font chooser widget may normalize
// font names and thus return a string with a different structure. For
// example, “Helvetica Italic Bold 12” could be normalized to “Helvetica
// Bold Italic 12”.
//
// Use pango_font_description_equal() if you want to compare two font
// descriptions.
func (fontchooser fontChooser) Font() string {
	var arg0 *C.GtkFontChooser

	arg0 = (*C.GtkFontChooser)(fontchooser.Native())

	ret := C.gtk_font_chooser_get_font(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// FontDesc gets the currently-selected font.
//
// Note that this can be a different string than what you set with
// gtk_font_chooser_set_font(), as the font chooser widget may normalize
// font names and thus return a string with a different structure. For
// example, “Helvetica Italic Bold 12” could be normalized to “Helvetica
// Bold Italic 12”.
//
// Use pango_font_description_equal() if you want to compare two font
// descriptions.
func (fontchooser fontChooser) FontDesc() *pango.FontDescription {
	var arg0 *C.GtkFontChooser

	arg0 = (*C.GtkFontChooser)(fontchooser.Native())

	ret := C.gtk_font_chooser_get_font_desc(arg0)

	var ret0 *pango.FontDescription

	{
		ret0 = pango.WrapFontDescription(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *pango.FontDescription) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// FontFace gets the FontFace representing the selected font group details
// (i.e. family, slant, weight, width, etc).
//
// If the selected font is not installed, returns nil.
func (fontchooser fontChooser) FontFace() pango.FontFace {
	var arg0 *C.GtkFontChooser

	arg0 = (*C.GtkFontChooser)(fontchooser.Native())

	ret := C.gtk_font_chooser_get_font_face(arg0)

	var ret0 pango.FontFace

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(pango.FontFace)

	return ret0
}

// FontFamily gets the FontFamily representing the selected font family.
// Font families are a collection of font faces.
//
// If the selected font is not installed, returns nil.
func (fontchooser fontChooser) FontFamily() pango.FontFamily {
	var arg0 *C.GtkFontChooser

	arg0 = (*C.GtkFontChooser)(fontchooser.Native())

	ret := C.gtk_font_chooser_get_font_family(arg0)

	var ret0 pango.FontFamily

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(pango.FontFamily)

	return ret0
}

// FontFeatures gets the currently-selected font features.
func (fontchooser fontChooser) FontFeatures() string {
	var arg0 *C.GtkFontChooser

	arg0 = (*C.GtkFontChooser)(fontchooser.Native())

	ret := C.gtk_font_chooser_get_font_features(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// FontMap gets the custom font map of this font chooser widget, or nil if
// it does not have one.
func (fontchooser fontChooser) FontMap() pango.FontMap {
	var arg0 *C.GtkFontChooser

	arg0 = (*C.GtkFontChooser)(fontchooser.Native())

	ret := C.gtk_font_chooser_get_font_map(arg0)

	var ret0 pango.FontMap

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(pango.FontMap)

	return ret0
}

// FontSize: the selected font size.
func (fontchooser fontChooser) FontSize() int {
	var arg0 *C.GtkFontChooser

	arg0 = (*C.GtkFontChooser)(fontchooser.Native())

	ret := C.gtk_font_chooser_get_font_size(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Language gets the language that is used for font features.
func (fontchooser fontChooser) Language() string {
	var arg0 *C.GtkFontChooser

	arg0 = (*C.GtkFontChooser)(fontchooser.Native())

	ret := C.gtk_font_chooser_get_language(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Level returns the current level of granularity for selecting fonts.
func (fontchooser fontChooser) Level() FontChooserLevel {
	var arg0 *C.GtkFontChooser

	arg0 = (*C.GtkFontChooser)(fontchooser.Native())

	ret := C.gtk_font_chooser_get_level(arg0)

	var ret0 FontChooserLevel

	ret0 = FontChooserLevel(ret)

	return ret0
}

// PreviewText gets the text displayed in the preview area.
func (fontchooser fontChooser) PreviewText() string {
	var arg0 *C.GtkFontChooser

	arg0 = (*C.GtkFontChooser)(fontchooser.Native())

	ret := C.gtk_font_chooser_get_preview_text(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// ShowPreviewEntry returns whether the preview entry is shown or not.
func (fontchooser fontChooser) ShowPreviewEntry() bool {
	var arg0 *C.GtkFontChooser

	arg0 = (*C.GtkFontChooser)(fontchooser.Native())

	ret := C.gtk_font_chooser_get_show_preview_entry(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SetFilterFunc adds a filter function that decides which fonts to display
// in the font chooser.
func (fontchooser fontChooser) SetFilterFunc(filter FontFilterFunc) {
	var arg0 *C.GtkFontChooser
	var arg1 C.GtkFontFilterFunc
	var arg2 C.gpointer
	var arg3 C.GDestroyNotify

	arg0 = (*C.GtkFontChooser)(fontchooser.Native())
	arg1 = (*[0]byte)(C.gotk4_FontFilterFunc)
	arg2 = C.gpointer(box.Assign(filter))
	arg3 = (*[0]byte)(C.callbackDelete)

	C.gtk_font_chooser_set_filter_func(arg0, arg1, arg2, arg3)
}

// SetFont sets the currently-selected font.
func (fontchooser fontChooser) SetFont(fontname string) {
	var arg0 *C.GtkFontChooser
	var arg1 *C.gchar

	arg0 = (*C.GtkFontChooser)(fontchooser.Native())
	arg1 = (*C.gchar)(C.CString(fontname))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_font_chooser_set_font(arg0, arg1)
}

// SetFontDesc sets the currently-selected font from @font_desc.
func (fontchooser fontChooser) SetFontDesc(fontDesc *pango.FontDescription) {
	var arg0 *C.GtkFontChooser
	var arg1 *C.PangoFontDescription

	arg0 = (*C.GtkFontChooser)(fontchooser.Native())
	arg1 = (*C.PangoFontDescription)(fontDesc.Native())

	C.gtk_font_chooser_set_font_desc(arg0, arg1)
}

// SetFontMap sets a custom font map to use for this font chooser widget. A
// custom font map can be used to present application-specific fonts instead
// of or in addition to the normal system fonts.
//
//    FcConfig *config;
//    PangoFontMap *fontmap;
//
//    config = FcInitLoadConfigAndFonts ();
//    FcConfigAppFontAddFile (config, my_app_font_file);
//
//    fontmap = pango_cairo_font_map_new_for_font_type (CAIRO_FONT_TYPE_FT);
//    pango_fc_font_map_set_config (PANGO_FC_FONT_MAP (fontmap), config);
//
//    gtk_font_chooser_set_font_map (font_chooser, fontmap);
//
// Note that other GTK+ widgets will only be able to use the
// application-specific font if it is present in the font map they use:
//
//    context = gtk_widget_get_pango_context (label);
//    pango_context_set_font_map (context, fontmap);
func (fontchooser fontChooser) SetFontMap(fontmap pango.FontMap) {
	var arg0 *C.GtkFontChooser
	var arg1 *C.PangoFontMap

	arg0 = (*C.GtkFontChooser)(fontchooser.Native())
	arg1 = (*C.PangoFontMap)(fontmap.Native())

	C.gtk_font_chooser_set_font_map(arg0, arg1)
}

// SetLanguage sets the language to use for font features.
func (fontchooser fontChooser) SetLanguage(language string) {
	var arg0 *C.GtkFontChooser
	var arg1 *C.char

	arg0 = (*C.GtkFontChooser)(fontchooser.Native())
	arg1 = (*C.gchar)(C.CString(language))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_font_chooser_set_language(arg0, arg1)
}

// SetLevel sets the desired level of granularity for selecting fonts.
func (fontchooser fontChooser) SetLevel(level FontChooserLevel) {
	var arg0 *C.GtkFontChooser
	var arg1 C.GtkFontChooserLevel

	arg0 = (*C.GtkFontChooser)(fontchooser.Native())
	arg1 = (C.GtkFontChooserLevel)(level)

	C.gtk_font_chooser_set_level(arg0, arg1)
}

// SetPreviewText sets the text displayed in the preview area. The @text is
// used to show how the selected font looks.
func (fontchooser fontChooser) SetPreviewText(text string) {
	var arg0 *C.GtkFontChooser
	var arg1 *C.gchar

	arg0 = (*C.GtkFontChooser)(fontchooser.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_font_chooser_set_preview_text(arg0, arg1)
}

// SetShowPreviewEntry shows or hides the editable preview entry.
func (fontchooser fontChooser) SetShowPreviewEntry(showPreviewEntry bool) {
	var arg0 *C.GtkFontChooser
	var arg1 C.gboolean

	arg0 = (*C.GtkFontChooser)(fontchooser.Native())
	if showPreviewEntry {
		arg1 = C.TRUE
	}

	C.gtk_font_chooser_set_show_preview_entry(arg0, arg1)
}

// Orientable: the Orientable interface is implemented by all widgets that can
// be oriented horizontally or vertically. Historically, such widgets have been
// realized as subclasses of a common base class (e.g Box/HBox/VBox or
// Scale/HScale/VScale). Orientable is more flexible in that it allows the
// orientation to be changed at runtime, allowing the widgets to “flip”.
//
// Orientable was introduced in GTK+ 2.16.
type Orientable interface {
	gextras.Objector

	// Orientation retrieves the orientation of the @orientable.
	Orientation() Orientation
	// SetOrientation sets the orientation of the @orientable.
	SetOrientation(orientation Orientation)
}

// orientable implements the Orientable interface.
type orientable struct {
	gextras.Objector
}

var _ Orientable = (*orientable)(nil)

// WrapOrientable wraps a GObject to a type that implements interface
// Orientable. It is primarily used internally.
func WrapOrientable(obj *externglib.Object) Orientable {
	return Orientable{
		Objector: obj,
	}
}

func marshalOrientable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapOrientable(obj), nil
}

// Orientation retrieves the orientation of the @orientable.
func (orientable orientable) Orientation() Orientation {
	var arg0 *C.GtkOrientable

	arg0 = (*C.GtkOrientable)(orientable.Native())

	ret := C.gtk_orientable_get_orientation(arg0)

	var ret0 Orientation

	ret0 = Orientation(ret)

	return ret0
}

// SetOrientation sets the orientation of the @orientable.
func (orientable orientable) SetOrientation(orientation Orientation) {
	var arg0 *C.GtkOrientable
	var arg1 C.GtkOrientation

	arg0 = (*C.GtkOrientable)(orientable.Native())
	arg1 = (C.GtkOrientation)(orientation)

	C.gtk_orientable_set_orientation(arg0, arg1)
}

// PrintOperationPreviewOverrider contains methods that are overridable. This
// interface is a subset of the interface PrintOperationPreview.
type PrintOperationPreviewOverrider interface {
	// EndPreview ends a preview.
	//
	// This function must be called to finish a custom print preview.
	EndPreview()

	GotPageSize(context PrintContext, pageSetup PageSetup)
	// IsSelected returns whether the given page is included in the set of pages
	// that have been selected for printing.
	IsSelected(pageNr int) bool

	Ready(context PrintContext)
	// RenderPage renders a page to the preview, using the print context that
	// was passed to the PrintOperation::preview handler together with @preview.
	//
	// A custom iprint preview should use this function in its ::expose handler
	// to render the currently selected page.
	//
	// Note that this function requires a suitable cairo context to be
	// associated with the print context.
	RenderPage(pageNr int)
}

type PrintOperationPreview interface {
	gextras.Objector
	PrintOperationPreviewOverrider
}

// printOperationPreview implements the PrintOperationPreview interface.
type printOperationPreview struct {
	gextras.Objector
}

var _ PrintOperationPreview = (*printOperationPreview)(nil)

// WrapPrintOperationPreview wraps a GObject to a type that implements interface
// PrintOperationPreview. It is primarily used internally.
func WrapPrintOperationPreview(obj *externglib.Object) PrintOperationPreview {
	return PrintOperationPreview{
		Objector: obj,
	}
}

func marshalPrintOperationPreview(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPrintOperationPreview(obj), nil
}

// EndPreview ends a preview.
//
// This function must be called to finish a custom print preview.
func (preview printOperationPreview) EndPreview() {
	var arg0 *C.GtkPrintOperationPreview

	arg0 = (*C.GtkPrintOperationPreview)(preview.Native())

	C.gtk_print_operation_preview_end_preview(arg0)
}

// IsSelected returns whether the given page is included in the set of pages
// that have been selected for printing.
func (preview printOperationPreview) IsSelected(pageNr int) bool {
	var arg0 *C.GtkPrintOperationPreview
	var arg1 C.gint

	arg0 = (*C.GtkPrintOperationPreview)(preview.Native())
	arg1 = C.gint(pageNr)

	ret := C.gtk_print_operation_preview_is_selected(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// RenderPage renders a page to the preview, using the print context that
// was passed to the PrintOperation::preview handler together with @preview.
//
// A custom iprint preview should use this function in its ::expose handler
// to render the currently selected page.
//
// Note that this function requires a suitable cairo context to be
// associated with the print context.
func (preview printOperationPreview) RenderPage(pageNr int) {
	var arg0 *C.GtkPrintOperationPreview
	var arg1 C.gint

	arg0 = (*C.GtkPrintOperationPreview)(preview.Native())
	arg1 = C.gint(pageNr)

	C.gtk_print_operation_preview_render_page(arg0, arg1)
}

// RecentChooserOverrider contains methods that are overridable. This
// interface is a subset of the interface RecentChooser.
type RecentChooserOverrider interface {
	// AddFilter adds @filter to the list of RecentFilter objects held by
	// @chooser.
	//
	// If no previous filter objects were defined, this function will call
	// gtk_recent_chooser_set_filter().
	AddFilter(filter RecentFilter)
	// CurrentURI gets the URI currently selected by @chooser.
	CurrentURI() string
	// Items gets the list of recently used resources in form of RecentInfo
	// objects.
	//
	// The return value of this function is affected by the “sort-type” and
	// “limit” properties of @chooser.
	Items() *glib.List

	RecentManager() RecentManager

	ItemActivated()
	// ListFilters gets the RecentFilter objects held by @chooser.
	ListFilters() *glib.SList
	// RemoveFilter removes @filter from the list of RecentFilter objects held
	// by @chooser.
	RemoveFilter(filter RecentFilter)
	// SelectAll selects all the items inside @chooser, if the @chooser supports
	// multiple selection.
	SelectAll()
	// SelectURI selects @uri inside @chooser.
	SelectURI(uri string) error

	SelectionChanged()
	// SetCurrentURI sets @uri as the current URI for @chooser.
	SetCurrentURI(uri string) error
	// SetSortFunc sets the comparison function used when sorting to be
	// @sort_func. If the @chooser has the sort type set to K_RECENT_SORT_CUSTOM
	// then the chooser will sort using this function.
	//
	// To the comparison function will be passed two RecentInfo structs and
	// @sort_data; @sort_func should return a positive integer if the first item
	// comes before the second, zero if the two items are equal and a negative
	// integer if the first item comes after the second.
	SetSortFunc(sortFunc RecentSortFunc)
	// UnselectAll unselects all the items inside @chooser.
	UnselectAll()
	// UnselectURI unselects @uri inside @chooser.
	UnselectURI(uri string)
}

// RecentChooser is an interface that can be implemented by widgets displaying
// the list of recently used files. In GTK+, the main objects that implement
// this interface are RecentChooserWidget, RecentChooserDialog and
// RecentChooserMenu.
//
// Recently used files are supported since GTK+ 2.10.
type RecentChooser interface {
	gextras.Objector
	RecentChooserOverrider

	// CurrentItem gets the RecentInfo currently selected by @chooser.
	CurrentItem() *RecentInfo
	// Filter gets the RecentFilter object currently used by @chooser to affect
	// the display of the recently used resources.
	Filter() RecentFilter
	// Limit gets the number of items returned by gtk_recent_chooser_get_items()
	// and gtk_recent_chooser_get_uris().
	Limit() int
	// LocalOnly gets whether only local resources should be shown in the
	// recently used resources selector. See gtk_recent_chooser_set_local_only()
	LocalOnly() bool
	// SelectMultiple gets whether @chooser can select multiple items.
	SelectMultiple() bool
	// ShowIcons retrieves whether @chooser should show an icon near the
	// resource.
	ShowIcons() bool
	// ShowNotFound retrieves whether @chooser should show the recently used
	// resources that were not found.
	ShowNotFound() bool
	// ShowPrivate returns whether @chooser should display recently used
	// resources registered as private.
	ShowPrivate() bool
	// ShowTips gets whether @chooser should display tooltips containing the
	// full path of a recently user resource.
	ShowTips() bool
	// SortType gets the value set by gtk_recent_chooser_set_sort_type().
	SortType() RecentSortType
	// Uris gets the URI of the recently used resources.
	//
	// The return value of this function is affected by the “sort-type” and
	// “limit” properties of @chooser.
	//
	// Since the returned array is nil terminated, @length may be nil.
	Uris() (length uint, utf8s []string)
	// SetFilter sets @filter as the current RecentFilter object used by
	// @chooser to affect the displayed recently used resources.
	SetFilter(filter RecentFilter)
	// SetLimit sets the number of items that should be returned by
	// gtk_recent_chooser_get_items() and gtk_recent_chooser_get_uris().
	SetLimit(limit int)
	// SetLocalOnly sets whether only local resources, that is resources using
	// the file:// URI scheme, should be shown in the recently used resources
	// selector. If @local_only is true (the default) then the shown resources
	// are guaranteed to be accessible through the operating system native file
	// system.
	SetLocalOnly(localOnly bool)
	// SetSelectMultiple sets whether @chooser can select multiple items.
	SetSelectMultiple(selectMultiple bool)
	// SetShowIcons sets whether @chooser should show an icon near the resource
	// when displaying it.
	SetShowIcons(showIcons bool)
	// SetShowNotFound sets whether @chooser should display the recently used
	// resources that it didn’t find. This only applies to local resources.
	SetShowNotFound(showNotFound bool)
	// SetShowPrivate: whether to show recently used resources marked registered
	// as private.
	SetShowPrivate(showPrivate bool)
	// SetShowTips sets whether to show a tooltips containing the full path of
	// each recently used resource in a RecentChooser widget.
	SetShowTips(showTips bool)
	// SetSortType changes the sorting order of the recently used resources list
	// displayed by @chooser.
	SetSortType(sortType RecentSortType)
}

// recentChooser implements the RecentChooser interface.
type recentChooser struct {
	gextras.Objector
}

var _ RecentChooser = (*recentChooser)(nil)

// WrapRecentChooser wraps a GObject to a type that implements interface
// RecentChooser. It is primarily used internally.
func WrapRecentChooser(obj *externglib.Object) RecentChooser {
	return RecentChooser{
		Objector: obj,
	}
}

func marshalRecentChooser(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRecentChooser(obj), nil
}

// AddFilter adds @filter to the list of RecentFilter objects held by
// @chooser.
//
// If no previous filter objects were defined, this function will call
// gtk_recent_chooser_set_filter().
func (chooser recentChooser) AddFilter(filter RecentFilter) {
	var arg0 *C.GtkRecentChooser
	var arg1 *C.GtkRecentFilter

	arg0 = (*C.GtkRecentChooser)(chooser.Native())
	arg1 = (*C.GtkRecentFilter)(filter.Native())

	C.gtk_recent_chooser_add_filter(arg0, arg1)
}

// CurrentItem gets the RecentInfo currently selected by @chooser.
func (chooser recentChooser) CurrentItem() *RecentInfo {
	var arg0 *C.GtkRecentChooser

	arg0 = (*C.GtkRecentChooser)(chooser.Native())

	ret := C.gtk_recent_chooser_get_current_item(arg0)

	var ret0 *RecentInfo

	{
		ret0 = WrapRecentInfo(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *RecentInfo) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// CurrentURI gets the URI currently selected by @chooser.
func (chooser recentChooser) CurrentURI() string {
	var arg0 *C.GtkRecentChooser

	arg0 = (*C.GtkRecentChooser)(chooser.Native())

	ret := C.gtk_recent_chooser_get_current_uri(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Filter gets the RecentFilter object currently used by @chooser to affect
// the display of the recently used resources.
func (chooser recentChooser) Filter() RecentFilter {
	var arg0 *C.GtkRecentChooser

	arg0 = (*C.GtkRecentChooser)(chooser.Native())

	ret := C.gtk_recent_chooser_get_filter(arg0)

	var ret0 RecentFilter

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(RecentFilter)

	return ret0
}

// Items gets the list of recently used resources in form of RecentInfo
// objects.
//
// The return value of this function is affected by the “sort-type” and
// “limit” properties of @chooser.
func (chooser recentChooser) Items() *glib.List {
	var arg0 *C.GtkRecentChooser

	arg0 = (*C.GtkRecentChooser)(chooser.Native())

	ret := C.gtk_recent_chooser_get_items(arg0)

	var ret0 *glib.List

	{
		ret0 = glib.WrapList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.List) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Limit gets the number of items returned by gtk_recent_chooser_get_items()
// and gtk_recent_chooser_get_uris().
func (chooser recentChooser) Limit() int {
	var arg0 *C.GtkRecentChooser

	arg0 = (*C.GtkRecentChooser)(chooser.Native())

	ret := C.gtk_recent_chooser_get_limit(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// LocalOnly gets whether only local resources should be shown in the
// recently used resources selector. See gtk_recent_chooser_set_local_only()
func (chooser recentChooser) LocalOnly() bool {
	var arg0 *C.GtkRecentChooser

	arg0 = (*C.GtkRecentChooser)(chooser.Native())

	ret := C.gtk_recent_chooser_get_local_only(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SelectMultiple gets whether @chooser can select multiple items.
func (chooser recentChooser) SelectMultiple() bool {
	var arg0 *C.GtkRecentChooser

	arg0 = (*C.GtkRecentChooser)(chooser.Native())

	ret := C.gtk_recent_chooser_get_select_multiple(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ShowIcons retrieves whether @chooser should show an icon near the
// resource.
func (chooser recentChooser) ShowIcons() bool {
	var arg0 *C.GtkRecentChooser

	arg0 = (*C.GtkRecentChooser)(chooser.Native())

	ret := C.gtk_recent_chooser_get_show_icons(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ShowNotFound retrieves whether @chooser should show the recently used
// resources that were not found.
func (chooser recentChooser) ShowNotFound() bool {
	var arg0 *C.GtkRecentChooser

	arg0 = (*C.GtkRecentChooser)(chooser.Native())

	ret := C.gtk_recent_chooser_get_show_not_found(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ShowPrivate returns whether @chooser should display recently used
// resources registered as private.
func (chooser recentChooser) ShowPrivate() bool {
	var arg0 *C.GtkRecentChooser

	arg0 = (*C.GtkRecentChooser)(chooser.Native())

	ret := C.gtk_recent_chooser_get_show_private(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ShowTips gets whether @chooser should display tooltips containing the
// full path of a recently user resource.
func (chooser recentChooser) ShowTips() bool {
	var arg0 *C.GtkRecentChooser

	arg0 = (*C.GtkRecentChooser)(chooser.Native())

	ret := C.gtk_recent_chooser_get_show_tips(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SortType gets the value set by gtk_recent_chooser_set_sort_type().
func (chooser recentChooser) SortType() RecentSortType {
	var arg0 *C.GtkRecentChooser

	arg0 = (*C.GtkRecentChooser)(chooser.Native())

	ret := C.gtk_recent_chooser_get_sort_type(arg0)

	var ret0 RecentSortType

	ret0 = RecentSortType(ret)

	return ret0
}

// Uris gets the URI of the recently used resources.
//
// The return value of this function is affected by the “sort-type” and
// “limit” properties of @chooser.
//
// Since the returned array is nil terminated, @length may be nil.
func (chooser recentChooser) Uris() (length uint, utf8s []string) {
	var arg0 *C.GtkRecentChooser
	var arg1 *C.gsize // out

	arg0 = (*C.GtkRecentChooser)(chooser.Native())

	ret := C.gtk_recent_chooser_get_uris(arg0, &arg1)

	var ret0 uint
	var ret1 []string

	ret0 = uint(arg1)

	{
		ret1 = make([]string, arg1)
		for i := 0; i < uintptr(arg1); i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0, ret1
}

// ListFilters gets the RecentFilter objects held by @chooser.
func (chooser recentChooser) ListFilters() *glib.SList {
	var arg0 *C.GtkRecentChooser

	arg0 = (*C.GtkRecentChooser)(chooser.Native())

	ret := C.gtk_recent_chooser_list_filters(arg0)

	var ret0 *glib.SList

	{
		ret0 = glib.WrapSList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.SList) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// RemoveFilter removes @filter from the list of RecentFilter objects held
// by @chooser.
func (chooser recentChooser) RemoveFilter(filter RecentFilter) {
	var arg0 *C.GtkRecentChooser
	var arg1 *C.GtkRecentFilter

	arg0 = (*C.GtkRecentChooser)(chooser.Native())
	arg1 = (*C.GtkRecentFilter)(filter.Native())

	C.gtk_recent_chooser_remove_filter(arg0, arg1)
}

// SelectAll selects all the items inside @chooser, if the @chooser supports
// multiple selection.
func (chooser recentChooser) SelectAll() {
	var arg0 *C.GtkRecentChooser

	arg0 = (*C.GtkRecentChooser)(chooser.Native())

	C.gtk_recent_chooser_select_all(arg0)
}

// SelectURI selects @uri inside @chooser.
func (chooser recentChooser) SelectURI(uri string) error {
	var arg0 *C.GtkRecentChooser
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GtkRecentChooser)(chooser.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_recent_chooser_select_uri(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SetCurrentURI sets @uri as the current URI for @chooser.
func (chooser recentChooser) SetCurrentURI(uri string) error {
	var arg0 *C.GtkRecentChooser
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GtkRecentChooser)(chooser.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_recent_chooser_set_current_uri(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SetFilter sets @filter as the current RecentFilter object used by
// @chooser to affect the displayed recently used resources.
func (chooser recentChooser) SetFilter(filter RecentFilter) {
	var arg0 *C.GtkRecentChooser
	var arg1 *C.GtkRecentFilter

	arg0 = (*C.GtkRecentChooser)(chooser.Native())
	arg1 = (*C.GtkRecentFilter)(filter.Native())

	C.gtk_recent_chooser_set_filter(arg0, arg1)
}

// SetLimit sets the number of items that should be returned by
// gtk_recent_chooser_get_items() and gtk_recent_chooser_get_uris().
func (chooser recentChooser) SetLimit(limit int) {
	var arg0 *C.GtkRecentChooser
	var arg1 C.gint

	arg0 = (*C.GtkRecentChooser)(chooser.Native())
	arg1 = C.gint(limit)

	C.gtk_recent_chooser_set_limit(arg0, arg1)
}

// SetLocalOnly sets whether only local resources, that is resources using
// the file:// URI scheme, should be shown in the recently used resources
// selector. If @local_only is true (the default) then the shown resources
// are guaranteed to be accessible through the operating system native file
// system.
func (chooser recentChooser) SetLocalOnly(localOnly bool) {
	var arg0 *C.GtkRecentChooser
	var arg1 C.gboolean

	arg0 = (*C.GtkRecentChooser)(chooser.Native())
	if localOnly {
		arg1 = C.TRUE
	}

	C.gtk_recent_chooser_set_local_only(arg0, arg1)
}

// SetSelectMultiple sets whether @chooser can select multiple items.
func (chooser recentChooser) SetSelectMultiple(selectMultiple bool) {
	var arg0 *C.GtkRecentChooser
	var arg1 C.gboolean

	arg0 = (*C.GtkRecentChooser)(chooser.Native())
	if selectMultiple {
		arg1 = C.TRUE
	}

	C.gtk_recent_chooser_set_select_multiple(arg0, arg1)
}

// SetShowIcons sets whether @chooser should show an icon near the resource
// when displaying it.
func (chooser recentChooser) SetShowIcons(showIcons bool) {
	var arg0 *C.GtkRecentChooser
	var arg1 C.gboolean

	arg0 = (*C.GtkRecentChooser)(chooser.Native())
	if showIcons {
		arg1 = C.TRUE
	}

	C.gtk_recent_chooser_set_show_icons(arg0, arg1)
}

// SetShowNotFound sets whether @chooser should display the recently used
// resources that it didn’t find. This only applies to local resources.
func (chooser recentChooser) SetShowNotFound(showNotFound bool) {
	var arg0 *C.GtkRecentChooser
	var arg1 C.gboolean

	arg0 = (*C.GtkRecentChooser)(chooser.Native())
	if showNotFound {
		arg1 = C.TRUE
	}

	C.gtk_recent_chooser_set_show_not_found(arg0, arg1)
}

// SetShowPrivate: whether to show recently used resources marked registered
// as private.
func (chooser recentChooser) SetShowPrivate(showPrivate bool) {
	var arg0 *C.GtkRecentChooser
	var arg1 C.gboolean

	arg0 = (*C.GtkRecentChooser)(chooser.Native())
	if showPrivate {
		arg1 = C.TRUE
	}

	C.gtk_recent_chooser_set_show_private(arg0, arg1)
}

// SetShowTips sets whether to show a tooltips containing the full path of
// each recently used resource in a RecentChooser widget.
func (chooser recentChooser) SetShowTips(showTips bool) {
	var arg0 *C.GtkRecentChooser
	var arg1 C.gboolean

	arg0 = (*C.GtkRecentChooser)(chooser.Native())
	if showTips {
		arg1 = C.TRUE
	}

	C.gtk_recent_chooser_set_show_tips(arg0, arg1)
}

// SetSortFunc sets the comparison function used when sorting to be
// @sort_func. If the @chooser has the sort type set to K_RECENT_SORT_CUSTOM
// then the chooser will sort using this function.
//
// To the comparison function will be passed two RecentInfo structs and
// @sort_data; @sort_func should return a positive integer if the first item
// comes before the second, zero if the two items are equal and a negative
// integer if the first item comes after the second.
func (chooser recentChooser) SetSortFunc(sortFunc RecentSortFunc) {
	var arg0 *C.GtkRecentChooser
	var arg1 C.GtkRecentSortFunc
	var arg2 C.gpointer
	var arg3 C.GDestroyNotify

	arg0 = (*C.GtkRecentChooser)(chooser.Native())
	arg1 = (*[0]byte)(C.gotk4_RecentSortFunc)
	arg2 = C.gpointer(box.Assign(sortFunc))
	arg3 = (*[0]byte)(C.callbackDelete)

	C.gtk_recent_chooser_set_sort_func(arg0, arg1, arg2, arg3)
}

// SetSortType changes the sorting order of the recently used resources list
// displayed by @chooser.
func (chooser recentChooser) SetSortType(sortType RecentSortType) {
	var arg0 *C.GtkRecentChooser
	var arg1 C.GtkRecentSortType

	arg0 = (*C.GtkRecentChooser)(chooser.Native())
	arg1 = (C.GtkRecentSortType)(sortType)

	C.gtk_recent_chooser_set_sort_type(arg0, arg1)
}

// UnselectAll unselects all the items inside @chooser.
func (chooser recentChooser) UnselectAll() {
	var arg0 *C.GtkRecentChooser

	arg0 = (*C.GtkRecentChooser)(chooser.Native())

	C.gtk_recent_chooser_unselect_all(arg0)
}

// UnselectURI unselects @uri inside @chooser.
func (chooser recentChooser) UnselectURI(uri string) {
	var arg0 *C.GtkRecentChooser
	var arg1 *C.gchar

	arg0 = (*C.GtkRecentChooser)(chooser.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_recent_chooser_unselect_uri(arg0, arg1)
}

// ScrollableOverrider contains methods that are overridable. This
// interface is a subset of the interface Scrollable.
type ScrollableOverrider interface {
	// Border returns the size of a non-scrolling border around the outside of
	// the scrollable. An example for this would be treeview headers. GTK+ can
	// use this information to display overlayed graphics, like the overshoot
	// indication, at the right position.
	Border() (border Border, ok bool)
}

// Scrollable is an interface that is implemented by widgets with native
// scrolling ability.
//
// To implement this interface you should override the Scrollable:hadjustment
// and Scrollable:vadjustment properties.
//
//
// Creating a scrollable widget
//
// All scrollable widgets should do the following.
//
// - When a parent widget sets the scrollable child widget’s adjustments, the
// widget should populate the adjustments’ Adjustment:lower, Adjustment:upper,
// Adjustment:step-increment, Adjustment:page-increment and Adjustment:page-size
// properties and connect to the Adjustment::value-changed signal.
//
// - Because its preferred size is the size for a fully expanded widget, the
// scrollable widget must be able to cope with underallocations. This means that
// it must accept any value passed to its WidgetClass.size_allocate() function.
//
// - When the parent allocates space to the scrollable child widget, the widget
// should update the adjustments’ properties with new values.
//
// - When any of the adjustments emits the Adjustment::value-changed signal, the
// scrollable widget should scroll its contents.
type Scrollable interface {
	gextras.Objector
	ScrollableOverrider

	// HAdjustment retrieves the Adjustment used for horizontal scrolling.
	HAdjustment() Adjustment
	// HScrollPolicy gets the horizontal ScrollablePolicy.
	HScrollPolicy() ScrollablePolicy
	// VAdjustment retrieves the Adjustment used for vertical scrolling.
	VAdjustment() Adjustment
	// VScrollPolicy gets the vertical ScrollablePolicy.
	VScrollPolicy() ScrollablePolicy
	// SetHAdjustment sets the horizontal adjustment of the Scrollable.
	SetHAdjustment(hadjustment Adjustment)
	// SetHScrollPolicy sets the ScrollablePolicy to determine whether
	// horizontal scrolling should start below the minimum width or below the
	// natural width.
	SetHScrollPolicy(policy ScrollablePolicy)
	// SetVAdjustment sets the vertical adjustment of the Scrollable.
	SetVAdjustment(vadjustment Adjustment)
	// SetVScrollPolicy sets the ScrollablePolicy to determine whether vertical
	// scrolling should start below the minimum height or below the natural
	// height.
	SetVScrollPolicy(policy ScrollablePolicy)
}

// scrollable implements the Scrollable interface.
type scrollable struct {
	gextras.Objector
}

var _ Scrollable = (*scrollable)(nil)

// WrapScrollable wraps a GObject to a type that implements interface
// Scrollable. It is primarily used internally.
func WrapScrollable(obj *externglib.Object) Scrollable {
	return Scrollable{
		Objector: obj,
	}
}

func marshalScrollable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapScrollable(obj), nil
}

// Border returns the size of a non-scrolling border around the outside of
// the scrollable. An example for this would be treeview headers. GTK+ can
// use this information to display overlayed graphics, like the overshoot
// indication, at the right position.
func (scrollable scrollable) Border() (border Border, ok bool) {
	var arg0 *C.GtkScrollable
	var arg1 *C.GtkBorder // out

	arg0 = (*C.GtkScrollable)(scrollable.Native())

	ret := C.gtk_scrollable_get_border(arg0, &arg1)

	var ret0 *Border
	var ret1 bool

	{
		ret0 = WrapBorder(unsafe.Pointer(arg1))
	}

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// HAdjustment retrieves the Adjustment used for horizontal scrolling.
func (scrollable scrollable) HAdjustment() Adjustment {
	var arg0 *C.GtkScrollable

	arg0 = (*C.GtkScrollable)(scrollable.Native())

	ret := C.gtk_scrollable_get_hadjustment(arg0)

	var ret0 Adjustment

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Adjustment)

	return ret0
}

// HScrollPolicy gets the horizontal ScrollablePolicy.
func (scrollable scrollable) HScrollPolicy() ScrollablePolicy {
	var arg0 *C.GtkScrollable

	arg0 = (*C.GtkScrollable)(scrollable.Native())

	ret := C.gtk_scrollable_get_hscroll_policy(arg0)

	var ret0 ScrollablePolicy

	ret0 = ScrollablePolicy(ret)

	return ret0
}

// VAdjustment retrieves the Adjustment used for vertical scrolling.
func (scrollable scrollable) VAdjustment() Adjustment {
	var arg0 *C.GtkScrollable

	arg0 = (*C.GtkScrollable)(scrollable.Native())

	ret := C.gtk_scrollable_get_vadjustment(arg0)

	var ret0 Adjustment

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Adjustment)

	return ret0
}

// VScrollPolicy gets the vertical ScrollablePolicy.
func (scrollable scrollable) VScrollPolicy() ScrollablePolicy {
	var arg0 *C.GtkScrollable

	arg0 = (*C.GtkScrollable)(scrollable.Native())

	ret := C.gtk_scrollable_get_vscroll_policy(arg0)

	var ret0 ScrollablePolicy

	ret0 = ScrollablePolicy(ret)

	return ret0
}

// SetHAdjustment sets the horizontal adjustment of the Scrollable.
func (scrollable scrollable) SetHAdjustment(hadjustment Adjustment) {
	var arg0 *C.GtkScrollable
	var arg1 *C.GtkAdjustment

	arg0 = (*C.GtkScrollable)(scrollable.Native())
	arg1 = (*C.GtkAdjustment)(hadjustment.Native())

	C.gtk_scrollable_set_hadjustment(arg0, arg1)
}

// SetHScrollPolicy sets the ScrollablePolicy to determine whether
// horizontal scrolling should start below the minimum width or below the
// natural width.
func (scrollable scrollable) SetHScrollPolicy(policy ScrollablePolicy) {
	var arg0 *C.GtkScrollable
	var arg1 C.GtkScrollablePolicy

	arg0 = (*C.GtkScrollable)(scrollable.Native())
	arg1 = (C.GtkScrollablePolicy)(policy)

	C.gtk_scrollable_set_hscroll_policy(arg0, arg1)
}

// SetVAdjustment sets the vertical adjustment of the Scrollable.
func (scrollable scrollable) SetVAdjustment(vadjustment Adjustment) {
	var arg0 *C.GtkScrollable
	var arg1 *C.GtkAdjustment

	arg0 = (*C.GtkScrollable)(scrollable.Native())
	arg1 = (*C.GtkAdjustment)(vadjustment.Native())

	C.gtk_scrollable_set_vadjustment(arg0, arg1)
}

// SetVScrollPolicy sets the ScrollablePolicy to determine whether vertical
// scrolling should start below the minimum height or below the natural
// height.
func (scrollable scrollable) SetVScrollPolicy(policy ScrollablePolicy) {
	var arg0 *C.GtkScrollable
	var arg1 C.GtkScrollablePolicy

	arg0 = (*C.GtkScrollable)(scrollable.Native())
	arg1 = (C.GtkScrollablePolicy)(policy)

	C.gtk_scrollable_set_vscroll_policy(arg0, arg1)
}

// StyleProviderOverrider contains methods that are overridable. This
// interface is a subset of the interface StyleProvider.
type StyleProviderOverrider interface {
	// IconFactory returns the IconFactory defined to be in use for @path, or
	// nil if none is defined.
	IconFactory(path *WidgetPath) IconFactory
	// Style returns the style settings affecting a widget defined by @path, or
	// nil if @provider doesn’t contemplate styling @path.
	Style(path *WidgetPath) StyleProperties
	// StyleProperty looks up a widget style property as defined by @provider
	// for the widget represented by @path.
	StyleProperty(path *WidgetPath, state StateFlags, pspec gobject.ParamSpec) (value externglib.Value, ok bool)
}

// StyleProvider: gtkStyleProvider is an interface used to provide style
// information to a StyleContext. See gtk_style_context_add_provider() and
// gtk_style_context_add_provider_for_screen().
type StyleProvider interface {
	gextras.Objector
	StyleProviderOverrider
}

// styleProvider implements the StyleProvider interface.
type styleProvider struct {
	gextras.Objector
}

var _ StyleProvider = (*styleProvider)(nil)

// WrapStyleProvider wraps a GObject to a type that implements interface
// StyleProvider. It is primarily used internally.
func WrapStyleProvider(obj *externglib.Object) StyleProvider {
	return StyleProvider{
		Objector: obj,
	}
}

func marshalStyleProvider(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStyleProvider(obj), nil
}

// IconFactory returns the IconFactory defined to be in use for @path, or
// nil if none is defined.
func (provider styleProvider) IconFactory(path *WidgetPath) IconFactory {
	var arg0 *C.GtkStyleProvider
	var arg1 *C.GtkWidgetPath

	arg0 = (*C.GtkStyleProvider)(provider.Native())
	arg1 = (*C.GtkWidgetPath)(path.Native())

	ret := C.gtk_style_provider_get_icon_factory(arg0, arg1)

	var ret0 IconFactory

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(IconFactory)

	return ret0
}

// Style returns the style settings affecting a widget defined by @path, or
// nil if @provider doesn’t contemplate styling @path.
func (provider styleProvider) Style(path *WidgetPath) StyleProperties {
	var arg0 *C.GtkStyleProvider
	var arg1 *C.GtkWidgetPath

	arg0 = (*C.GtkStyleProvider)(provider.Native())
	arg1 = (*C.GtkWidgetPath)(path.Native())

	ret := C.gtk_style_provider_get_style(arg0, arg1)

	var ret0 StyleProperties

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(StyleProperties)

	return ret0
}

// StyleProperty looks up a widget style property as defined by @provider
// for the widget represented by @path.
func (provider styleProvider) StyleProperty(path *WidgetPath, state StateFlags, pspec gobject.ParamSpec) (value externglib.Value, ok bool) {
	var arg0 *C.GtkStyleProvider
	var arg1 *C.GtkWidgetPath
	var arg2 C.GtkStateFlags
	var arg3 *C.GParamSpec
	var arg4 *C.GValue // out

	arg0 = (*C.GtkStyleProvider)(provider.Native())
	arg1 = (*C.GtkWidgetPath)(path.Native())
	arg2 = (C.GtkStateFlags)(state)
	arg3 = (*C.GParamSpec)(pspec.Native())

	ret := C.gtk_style_provider_get_style_property(arg0, arg1, arg2, arg3, &arg4)

	var ret0 *externglib.Value
	var ret1 bool

	ret0 = externglib.ValueFromNative(unsafe.Pointer(arg4))

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// TreeDragDestOverrider contains methods that are overridable. This
// interface is a subset of the interface TreeDragDest.
type TreeDragDestOverrider interface {
	// DragDataReceived asks the TreeDragDest to insert a row before the path
	// @dest, deriving the contents of the row from @selection_data. If @dest is
	// outside the tree so that inserting before it is impossible, false will be
	// returned. Also, false may be returned if the new row is not created for
	// some model-specific reason. Should robustly handle a @dest no longer
	// found in the model!
	DragDataReceived(dest *TreePath, selectionData *SelectionData) bool
	// RowDropPossible determines whether a drop is possible before the given
	// @dest_path, at the same depth as @dest_path. i.e., can we drop the data
	// in @selection_data at that location. @dest_path does not have to exist;
	// the return value will almost certainly be false if the parent of
	// @dest_path doesn’t exist, though.
	RowDropPossible(destPath *TreePath, selectionData *SelectionData) bool
}

type TreeDragDest interface {
	gextras.Objector
	TreeDragDestOverrider
}

// treeDragDest implements the TreeDragDest interface.
type treeDragDest struct {
	gextras.Objector
}

var _ TreeDragDest = (*treeDragDest)(nil)

// WrapTreeDragDest wraps a GObject to a type that implements interface
// TreeDragDest. It is primarily used internally.
func WrapTreeDragDest(obj *externglib.Object) TreeDragDest {
	return TreeDragDest{
		Objector: obj,
	}
}

func marshalTreeDragDest(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeDragDest(obj), nil
}

// DragDataReceived asks the TreeDragDest to insert a row before the path
// @dest, deriving the contents of the row from @selection_data. If @dest is
// outside the tree so that inserting before it is impossible, false will be
// returned. Also, false may be returned if the new row is not created for
// some model-specific reason. Should robustly handle a @dest no longer
// found in the model!
func (dragDest treeDragDest) DragDataReceived(dest *TreePath, selectionData *SelectionData) bool {
	var arg0 *C.GtkTreeDragDest
	var arg1 *C.GtkTreePath
	var arg2 *C.GtkSelectionData

	arg0 = (*C.GtkTreeDragDest)(dragDest.Native())
	arg1 = (*C.GtkTreePath)(dest.Native())
	arg2 = (*C.GtkSelectionData)(selectionData.Native())

	ret := C.gtk_tree_drag_dest_drag_data_received(arg0, arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// RowDropPossible determines whether a drop is possible before the given
// @dest_path, at the same depth as @dest_path. i.e., can we drop the data
// in @selection_data at that location. @dest_path does not have to exist;
// the return value will almost certainly be false if the parent of
// @dest_path doesn’t exist, though.
func (dragDest treeDragDest) RowDropPossible(destPath *TreePath, selectionData *SelectionData) bool {
	var arg0 *C.GtkTreeDragDest
	var arg1 *C.GtkTreePath
	var arg2 *C.GtkSelectionData

	arg0 = (*C.GtkTreeDragDest)(dragDest.Native())
	arg1 = (*C.GtkTreePath)(destPath.Native())
	arg2 = (*C.GtkSelectionData)(selectionData.Native())

	ret := C.gtk_tree_drag_dest_row_drop_possible(arg0, arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// TreeDragSourceOverrider contains methods that are overridable. This
// interface is a subset of the interface TreeDragSource.
type TreeDragSourceOverrider interface {
	// DragDataDelete asks the TreeDragSource to delete the row at @path,
	// because it was moved somewhere else via drag-and-drop. Returns false if
	// the deletion fails because @path no longer exists, or for some
	// model-specific reason. Should robustly handle a @path no longer found in
	// the model!
	DragDataDelete(path *TreePath) bool
	// DragDataGet asks the TreeDragSource to fill in @selection_data with a
	// representation of the row at @path. @selection_data->target gives the
	// required type of the data. Should robustly handle a @path no longer found
	// in the model!
	DragDataGet(path *TreePath, selectionData *SelectionData) bool
	// RowDraggable asks the TreeDragSource whether a particular row can be used
	// as the source of a DND operation. If the source doesn’t implement this
	// interface, the row is assumed draggable.
	RowDraggable(path *TreePath) bool
}

type TreeDragSource interface {
	gextras.Objector
	TreeDragSourceOverrider
}

// treeDragSource implements the TreeDragSource interface.
type treeDragSource struct {
	gextras.Objector
}

var _ TreeDragSource = (*treeDragSource)(nil)

// WrapTreeDragSource wraps a GObject to a type that implements interface
// TreeDragSource. It is primarily used internally.
func WrapTreeDragSource(obj *externglib.Object) TreeDragSource {
	return TreeDragSource{
		Objector: obj,
	}
}

func marshalTreeDragSource(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeDragSource(obj), nil
}

// DragDataDelete asks the TreeDragSource to delete the row at @path,
// because it was moved somewhere else via drag-and-drop. Returns false if
// the deletion fails because @path no longer exists, or for some
// model-specific reason. Should robustly handle a @path no longer found in
// the model!
func (dragSource treeDragSource) DragDataDelete(path *TreePath) bool {
	var arg0 *C.GtkTreeDragSource
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkTreeDragSource)(dragSource.Native())
	arg1 = (*C.GtkTreePath)(path.Native())

	ret := C.gtk_tree_drag_source_drag_data_delete(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// DragDataGet asks the TreeDragSource to fill in @selection_data with a
// representation of the row at @path. @selection_data->target gives the
// required type of the data. Should robustly handle a @path no longer found
// in the model!
func (dragSource treeDragSource) DragDataGet(path *TreePath, selectionData *SelectionData) bool {
	var arg0 *C.GtkTreeDragSource
	var arg1 *C.GtkTreePath
	var arg2 *C.GtkSelectionData

	arg0 = (*C.GtkTreeDragSource)(dragSource.Native())
	arg1 = (*C.GtkTreePath)(path.Native())
	arg2 = (*C.GtkSelectionData)(selectionData.Native())

	ret := C.gtk_tree_drag_source_drag_data_get(arg0, arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// RowDraggable asks the TreeDragSource whether a particular row can be used
// as the source of a DND operation. If the source doesn’t implement this
// interface, the row is assumed draggable.
func (dragSource treeDragSource) RowDraggable(path *TreePath) bool {
	var arg0 *C.GtkTreeDragSource
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkTreeDragSource)(dragSource.Native())
	arg1 = (*C.GtkTreePath)(path.Native())

	ret := C.gtk_tree_drag_source_row_draggable(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// TreeModelOverrider contains methods that are overridable. This
// interface is a subset of the interface TreeModel.
type TreeModelOverrider interface {
	// ColumnType returns the type of the column.
	ColumnType(index_ int) externglib.Type
	// Flags returns a set of flags supported by this interface.
	//
	// The flags are a bitwise combination of TreeModelFlags. The flags
	// supported should not change during the lifetime of the @tree_model.
	Flags() TreeModelFlags
	// Iter sets @iter to a valid iterator pointing to @path. If @path does not
	// exist, @iter is set to an invalid iterator and false is returned.
	Iter(path *TreePath) (iter TreeIter, ok bool)
	// NColumns returns the number of columns supported by @tree_model.
	NColumns() int
	// Path returns a newly-created TreePath-struct referenced by @iter.
	//
	// This path should be freed with gtk_tree_path_free().
	Path(iter *TreeIter) *TreePath
	// Value initializes and sets @value to that at @column.
	//
	// When done with @value, g_value_unset() needs to be called to free any
	// allocated memory.
	Value(iter *TreeIter, column int) externglib.Value
	// IterChildren sets @iter to point to the first child of @parent.
	//
	// If @parent has no children, false is returned and @iter is set to be
	// invalid. @parent will remain a valid node after this function has been
	// called.
	//
	// If @parent is nil returns the first node, equivalent to
	// `gtk_tree_model_get_iter_first (tree_model, iter);`
	IterChildren(parent *TreeIter) (iter TreeIter, ok bool)
	// IterHasChild returns true if @iter has children, false otherwise.
	IterHasChild(iter *TreeIter) bool
	// IterNChildren returns the number of children that @iter has.
	//
	// As a special case, if @iter is nil, then the number of toplevel nodes is
	// returned.
	IterNChildren(iter *TreeIter) int
	// IterNext sets @iter to point to the node following it at the current
	// level.
	//
	// If there is no next @iter, false is returned and @iter is set to be
	// invalid.
	IterNext(iter *TreeIter) bool
	// IterNthChild sets @iter to be the child of @parent, using the given
	// index.
	//
	// The first index is 0. If @n is too big, or @parent has no children, @iter
	// is set to an invalid iterator and false is returned. @parent will remain
	// a valid node after this function has been called. As a special case, if
	// @parent is nil, then the @n-th root node is set.
	IterNthChild(parent *TreeIter, n int) (iter TreeIter, ok bool)
	// IterParent sets @iter to be the parent of @child.
	//
	// If @child is at the toplevel, and doesn’t have a parent, then @iter is
	// set to an invalid iterator and false is returned. @child will remain a
	// valid node after this function has been called.
	//
	// @iter will be initialized before the lookup is performed, so @child and
	// @iter cannot point to the same memory location.
	IterParent(child *TreeIter) (iter TreeIter, ok bool)
	// IterPrevious sets @iter to point to the previous node at the current
	// level.
	//
	// If there is no previous @iter, false is returned and @iter is set to be
	// invalid.
	IterPrevious(iter *TreeIter) bool
	// RefNode lets the tree ref the node.
	//
	// This is an optional method for models to implement. To be more specific,
	// models may ignore this call as it exists primarily for performance
	// reasons.
	//
	// This function is primarily meant as a way for views to let caching models
	// know when nodes are being displayed (and hence, whether or not to cache
	// that node). Being displayed means a node is in an expanded branch,
	// regardless of whether the node is currently visible in the viewport. For
	// example, a file-system based model would not want to keep the entire
	// file-hierarchy in memory, just the sections that are currently being
	// displayed by every current view.
	//
	// A model should be expected to be able to get an iter independent of its
	// reffed state.
	RefNode(iter *TreeIter)
	// RowChanged emits the TreeModel::row-changed signal on @tree_model.
	RowChanged(path *TreePath, iter *TreeIter)
	// RowDeleted emits the TreeModel::row-deleted signal on @tree_model.
	//
	// This should be called by models after a row has been removed. The
	// location pointed to by @path should be the location that the row
	// previously was at. It may not be a valid location anymore.
	//
	// Nodes that are deleted are not unreffed, this means that any outstanding
	// references on the deleted node should not be released.
	RowDeleted(path *TreePath)
	// RowHasChildToggled emits the TreeModel::row-has-child-toggled signal on
	// @tree_model. This should be called by models after the child state of a
	// node changes.
	RowHasChildToggled(path *TreePath, iter *TreeIter)
	// RowInserted emits the TreeModel::row-inserted signal on @tree_model.
	RowInserted(path *TreePath, iter *TreeIter)
	// RowsReordered emits the TreeModel::rows-reordered signal on @tree_model.
	//
	// This should be called by models when their rows have been reordered.
	RowsReordered(path *TreePath, iter *TreeIter, newOrder int)
	// UnrefNode lets the tree unref the node.
	//
	// This is an optional method for models to implement. To be more specific,
	// models may ignore this call as it exists primarily for performance
	// reasons. For more information on what this means, see
	// gtk_tree_model_ref_node().
	//
	// Please note that nodes that are deleted are not unreffed.
	UnrefNode(iter *TreeIter)
}

// TreeModel: the TreeModel interface defines a generic tree interface for use
// by the TreeView widget. It is an abstract interface, and is designed to be
// usable with any appropriate data structure. The programmer just has to
// implement this interface on their own data type for it to be viewable by a
// TreeView widget.
//
// The model is represented as a hierarchical tree of strongly-typed, columned
// data. In other words, the model can be seen as a tree where every node has
// different values depending on which column is being queried. The type of data
// found in a column is determined by using the GType system (ie. TYPE_INT,
// K_TYPE_BUTTON, TYPE_POINTER, etc). The types are homogeneous per column
// across all nodes. It is important to note that this interface only provides a
// way of examining a model and observing changes. The implementation of each
// individual model decides how and if changes are made.
//
// In order to make life simpler for programmers who do not need to write their
// own specialized model, two generic models are provided — the TreeStore and
// the ListStore. To use these, the developer simply pushes data into these
// models as necessary. These models provide the data structure as well as all
// appropriate tree interfaces. As a result, implementing drag and drop,
// sorting, and storing data is trivial. For the vast majority of trees and
// lists, these two models are sufficient.
//
// Models are accessed on a node/column level of granularity. One can query for
// the value of a model at a certain node and a certain column on that node.
// There are two structures used to reference a particular node in a model. They
// are the TreePath-struct and the TreeIter-struct (“iter” is short for
// iterator). Most of the interface consists of operations on a TreeIter-struct.
//
// A path is essentially a potential node. It is a location on a model that may
// or may not actually correspond to a node on a specific model. The
// TreePath-struct can be converted into either an array of unsigned integers or
// a string. The string form is a list of numbers separated by a colon. Each
// number refers to the offset at that level. Thus, the path `0` refers to the
// root node and the path `2:4` refers to the fifth child of the third node.
//
// By contrast, a TreeIter-struct is a reference to a specific node on a
// specific model. It is a generic struct with an integer and three generic
// pointers. These are filled in by the model in a model-specific way. One can
// convert a path to an iterator by calling gtk_tree_model_get_iter(). These
// iterators are the primary way of accessing a model and are similar to the
// iterators used by TextBuffer. They are generally statically allocated on the
// stack and only used for a short time. The model interface defines a set of
// operations using them for navigating the model.
//
// It is expected that models fill in the iterator with private data. For
// example, the ListStore model, which is internally a simple linked list,
// stores a list node in one of the pointers. The TreeModelSort stores an array
// and an offset in two of the pointers. Additionally, there is an integer
// field. This field is generally filled with a unique stamp per model. This
// stamp is for catching errors resulting from using invalid iterators with a
// model.
//
// The lifecycle of an iterator can be a little confusing at first. Iterators
// are expected to always be valid for as long as the model is unchanged (and
// doesn’t emit a signal). The model is considered to own all outstanding
// iterators and nothing needs to be done to free them from the user’s point of
// view. Additionally, some models guarantee that an iterator is valid for as
// long as the node it refers to is valid (most notably the TreeStore and
// ListStore). Although generally uninteresting, as one always has to allow for
// the case where iterators do not persist beyond a signal, some very important
// performance enhancements were made in the sort model. As a result, the
// K_TREE_MODEL_ITERS_PERSIST flag was added to indicate this behavior.
//
// To help show some common operation of a model, some examples are provided.
// The first example shows three ways of getting the iter at the location
// `3:2:5`. While the first method shown is easier, the second is much more
// common, as you often get paths from callbacks.
//
// Acquiring a TreeIter-struct
//
//    enum
//    {
//      STRING_COLUMN,
//      INT_COLUMN,
//      N_COLUMNS
//    };
//
//    ...
//
//    GtkTreeModel *list_store;
//    GtkTreeIter iter;
//    gboolean valid;
//    gint row_count = 0;
//
//    // make a new list_store
//    list_store = gtk_list_store_new (N_COLUMNS,
//                                     G_TYPE_STRING,
//                                     G_TYPE_INT);
//
//    // Fill the list store with data
//    populate_model (list_store);
//
//    // Get the first iter in the list, check it is valid and walk
//    // through the list, reading each row.
//
//    valid = gtk_tree_model_get_iter_first (list_store,
//                                           &iter);
//    while (valid)
//     {
//       gchar *str_data;
//       gint   int_data;
//
//       // Make sure you terminate calls to gtk_tree_model_get() with a “-1” value
//       gtk_tree_model_get (list_store, &iter,
//                           STRING_COLUMN, &str_data,
//                           INT_COLUMN, &int_data,
//                           -1);
//
//       // Do something with the data
//       g_print ("Row d: (s,d)\n",
//                row_count, str_data, int_data);
//       g_free (str_data);
//
//       valid = gtk_tree_model_iter_next (list_store,
//                                         &iter);
//       row_count++;
//     }
//
// The TreeModel interface contains two methods for reference counting:
// gtk_tree_model_ref_node() and gtk_tree_model_unref_node(). These two methods
// are optional to implement. The reference counting is meant as a way for views
// to let models know when nodes are being displayed. TreeView will take a
// reference on a node when it is visible, which means the node is either in the
// toplevel or expanded. Being displayed does not mean that the node is
// currently directly visible to the user in the viewport. Based on this
// reference counting scheme a caching model, for example, can decide whether or
// not to cache a node based on the reference count. A file-system based model
// would not want to keep the entire file hierarchy in memory, but just the
// folders that are currently expanded in every current view.
//
// When working with reference counting, the following rules must be taken into
// account:
//
// - Never take a reference on a node without owning a reference on its parent.
// This means that all parent nodes of a referenced node must be referenced as
// well.
//
// - Outstanding references on a deleted node are not released. This is not
// possible because the node has already been deleted by the time the
// row-deleted signal is received.
//
// - Models are not obligated to emit a signal on rows of which none of its
// siblings are referenced. To phrase this differently, signals are only
// required for levels in which nodes are referenced. For the root level
// however, signals must be emitted at all times (however the root level is
// always referenced when any view is attached).
type TreeModel interface {
	gextras.Objector
	TreeModelOverrider

	// NewFilter creates a new TreeModel, with @child_model as the child_model
	// and @root as the virtual root.
	NewFilter(root *TreePath) TreeModel
	// Foreach calls func on each node in model in a depth-first fashion.
	//
	// If @func returns true, then the tree ceases to be walked, and
	// gtk_tree_model_foreach() returns.
	Foreach(fn TreeModelForeachFunc)
	// IterFirst initializes @iter with the first iterator in the tree (the one
	// at the path "0") and returns true. Returns false if the tree is empty.
	IterFirst() (iter TreeIter, ok bool)
	// IterFromString sets @iter to a valid iterator pointing to @path_string,
	// if it exists. Otherwise, @iter is left invalid and false is returned.
	IterFromString(pathString string) (iter TreeIter, ok bool)
	// StringFromIter generates a string representation of the iter.
	//
	// This string is a “:” separated list of numbers. For example, “4:10:0:3”
	// would be an acceptable return value for this string.
	StringFromIter(iter *TreeIter) string
	// RowsReorderedWithLength emits the TreeModel::rows-reordered signal on
	// @tree_model.
	//
	// This should be called by models when their rows have been reordered.
	RowsReorderedWithLength(path *TreePath, iter *TreeIter, newOrder []int)
}

// treeModel implements the TreeModel interface.
type treeModel struct {
	gextras.Objector
}

var _ TreeModel = (*treeModel)(nil)

// WrapTreeModel wraps a GObject to a type that implements interface
// TreeModel. It is primarily used internally.
func WrapTreeModel(obj *externglib.Object) TreeModel {
	return TreeModel{
		Objector: obj,
	}
}

func marshalTreeModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeModel(obj), nil
}

// NewFilter creates a new TreeModel, with @child_model as the child_model
// and @root as the virtual root.
func (childModel treeModel) NewFilter(root *TreePath) TreeModel {
	var arg0 *C.GtkTreeModel
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkTreeModel)(childModel.Native())
	arg1 = (*C.GtkTreePath)(root.Native())

	ret := C.gtk_tree_model_filter_new(arg0, arg1)

	var ret0 TreeModel

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(TreeModel)

	return ret0
}

// Foreach calls func on each node in model in a depth-first fashion.
//
// If @func returns true, then the tree ceases to be walked, and
// gtk_tree_model_foreach() returns.
func (model treeModel) Foreach(fn TreeModelForeachFunc) {
	var arg0 *C.GtkTreeModel
	var arg1 C.GtkTreeModelForeachFunc
	var arg2 C.gpointer

	arg0 = (*C.GtkTreeModel)(model.Native())
	arg1 = (*[0]byte)(C.gotk4_TreeModelForeachFunc)
	arg2 = C.gpointer(box.Assign(fn))

	C.gtk_tree_model_foreach(arg0, arg1, arg2)
}

// ColumnType returns the type of the column.
func (treeModel treeModel) ColumnType(index_ int) externglib.Type {
	var arg0 *C.GtkTreeModel
	var arg1 C.gint

	arg0 = (*C.GtkTreeModel)(treeModel.Native())
	arg1 = C.gint(index_)

	ret := C.gtk_tree_model_get_column_type(arg0, arg1)

	var ret0 externglib.Type

	ret0 = externglib.Type(ret)

	return ret0
}

// Flags returns a set of flags supported by this interface.
//
// The flags are a bitwise combination of TreeModelFlags. The flags
// supported should not change during the lifetime of the @tree_model.
func (treeModel treeModel) Flags() TreeModelFlags {
	var arg0 *C.GtkTreeModel

	arg0 = (*C.GtkTreeModel)(treeModel.Native())

	ret := C.gtk_tree_model_get_flags(arg0)

	var ret0 TreeModelFlags

	ret0 = TreeModelFlags(ret)

	return ret0
}

// Iter sets @iter to a valid iterator pointing to @path. If @path does not
// exist, @iter is set to an invalid iterator and false is returned.
func (treeModel treeModel) Iter(path *TreePath) (iter TreeIter, ok bool) {
	var arg0 *C.GtkTreeModel
	var arg1 *C.GtkTreeIter // out
	var arg2 *C.GtkTreePath

	arg0 = (*C.GtkTreeModel)(treeModel.Native())
	arg2 = (*C.GtkTreePath)(path.Native())

	ret := C.gtk_tree_model_get_iter(arg0, &arg1, arg2)

	var ret0 *TreeIter
	var ret1 bool

	{
		ret0 = WrapTreeIter(unsafe.Pointer(arg1))
	}

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// IterFirst initializes @iter with the first iterator in the tree (the one
// at the path "0") and returns true. Returns false if the tree is empty.
func (treeModel treeModel) IterFirst() (iter TreeIter, ok bool) {
	var arg0 *C.GtkTreeModel
	var arg1 *C.GtkTreeIter // out

	arg0 = (*C.GtkTreeModel)(treeModel.Native())

	ret := C.gtk_tree_model_get_iter_first(arg0, &arg1)

	var ret0 *TreeIter
	var ret1 bool

	{
		ret0 = WrapTreeIter(unsafe.Pointer(arg1))
	}

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// IterFromString sets @iter to a valid iterator pointing to @path_string,
// if it exists. Otherwise, @iter is left invalid and false is returned.
func (treeModel treeModel) IterFromString(pathString string) (iter TreeIter, ok bool) {
	var arg0 *C.GtkTreeModel
	var arg1 *C.GtkTreeIter // out
	var arg2 *C.gchar

	arg0 = (*C.GtkTreeModel)(treeModel.Native())
	arg2 = (*C.gchar)(C.CString(pathString))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_tree_model_get_iter_from_string(arg0, &arg1, arg2)

	var ret0 *TreeIter
	var ret1 bool

	{
		ret0 = WrapTreeIter(unsafe.Pointer(arg1))
	}

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// NColumns returns the number of columns supported by @tree_model.
func (treeModel treeModel) NColumns() int {
	var arg0 *C.GtkTreeModel

	arg0 = (*C.GtkTreeModel)(treeModel.Native())

	ret := C.gtk_tree_model_get_n_columns(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Path returns a newly-created TreePath-struct referenced by @iter.
//
// This path should be freed with gtk_tree_path_free().
func (treeModel treeModel) Path(iter *TreeIter) *TreePath {
	var arg0 *C.GtkTreeModel
	var arg1 *C.GtkTreeIter

	arg0 = (*C.GtkTreeModel)(treeModel.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())

	ret := C.gtk_tree_model_get_path(arg0, arg1)

	var ret0 *TreePath

	{
		ret0 = WrapTreePath(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *TreePath) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// StringFromIter generates a string representation of the iter.
//
// This string is a “:” separated list of numbers. For example, “4:10:0:3”
// would be an acceptable return value for this string.
func (treeModel treeModel) StringFromIter(iter *TreeIter) string {
	var arg0 *C.GtkTreeModel
	var arg1 *C.GtkTreeIter

	arg0 = (*C.GtkTreeModel)(treeModel.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())

	ret := C.gtk_tree_model_get_string_from_iter(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Value initializes and sets @value to that at @column.
//
// When done with @value, g_value_unset() needs to be called to free any
// allocated memory.
func (treeModel treeModel) Value(iter *TreeIter, column int) externglib.Value {
	var arg0 *C.GtkTreeModel
	var arg1 *C.GtkTreeIter
	var arg2 C.gint
	var arg3 *C.GValue // out

	arg0 = (*C.GtkTreeModel)(treeModel.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())
	arg2 = C.gint(column)

	C.gtk_tree_model_get_value(arg0, arg1, arg2, &arg3)

	var ret0 *externglib.Value

	ret0 = externglib.ValueFromNative(unsafe.Pointer(arg3))

	return ret0
}

// IterChildren sets @iter to point to the first child of @parent.
//
// If @parent has no children, false is returned and @iter is set to be
// invalid. @parent will remain a valid node after this function has been
// called.
//
// If @parent is nil returns the first node, equivalent to
// `gtk_tree_model_get_iter_first (tree_model, iter);`
func (treeModel treeModel) IterChildren(parent *TreeIter) (iter TreeIter, ok bool) {
	var arg0 *C.GtkTreeModel
	var arg1 *C.GtkTreeIter // out
	var arg2 *C.GtkTreeIter

	arg0 = (*C.GtkTreeModel)(treeModel.Native())
	arg2 = (*C.GtkTreeIter)(parent.Native())

	ret := C.gtk_tree_model_iter_children(arg0, &arg1, arg2)

	var ret0 *TreeIter
	var ret1 bool

	{
		ret0 = WrapTreeIter(unsafe.Pointer(arg1))
	}

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// IterHasChild returns true if @iter has children, false otherwise.
func (treeModel treeModel) IterHasChild(iter *TreeIter) bool {
	var arg0 *C.GtkTreeModel
	var arg1 *C.GtkTreeIter

	arg0 = (*C.GtkTreeModel)(treeModel.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())

	ret := C.gtk_tree_model_iter_has_child(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IterNChildren returns the number of children that @iter has.
//
// As a special case, if @iter is nil, then the number of toplevel nodes is
// returned.
func (treeModel treeModel) IterNChildren(iter *TreeIter) int {
	var arg0 *C.GtkTreeModel
	var arg1 *C.GtkTreeIter

	arg0 = (*C.GtkTreeModel)(treeModel.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())

	ret := C.gtk_tree_model_iter_n_children(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// IterNext sets @iter to point to the node following it at the current
// level.
//
// If there is no next @iter, false is returned and @iter is set to be
// invalid.
func (treeModel treeModel) IterNext(iter *TreeIter) bool {
	var arg0 *C.GtkTreeModel
	var arg1 *C.GtkTreeIter

	arg0 = (*C.GtkTreeModel)(treeModel.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())

	ret := C.gtk_tree_model_iter_next(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IterNthChild sets @iter to be the child of @parent, using the given
// index.
//
// The first index is 0. If @n is too big, or @parent has no children, @iter
// is set to an invalid iterator and false is returned. @parent will remain
// a valid node after this function has been called. As a special case, if
// @parent is nil, then the @n-th root node is set.
func (treeModel treeModel) IterNthChild(parent *TreeIter, n int) (iter TreeIter, ok bool) {
	var arg0 *C.GtkTreeModel
	var arg1 *C.GtkTreeIter // out
	var arg2 *C.GtkTreeIter
	var arg3 C.gint

	arg0 = (*C.GtkTreeModel)(treeModel.Native())
	arg2 = (*C.GtkTreeIter)(parent.Native())
	arg3 = C.gint(n)

	ret := C.gtk_tree_model_iter_nth_child(arg0, &arg1, arg2, arg3)

	var ret0 *TreeIter
	var ret1 bool

	{
		ret0 = WrapTreeIter(unsafe.Pointer(arg1))
	}

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// IterParent sets @iter to be the parent of @child.
//
// If @child is at the toplevel, and doesn’t have a parent, then @iter is
// set to an invalid iterator and false is returned. @child will remain a
// valid node after this function has been called.
//
// @iter will be initialized before the lookup is performed, so @child and
// @iter cannot point to the same memory location.
func (treeModel treeModel) IterParent(child *TreeIter) (iter TreeIter, ok bool) {
	var arg0 *C.GtkTreeModel
	var arg1 *C.GtkTreeIter // out
	var arg2 *C.GtkTreeIter

	arg0 = (*C.GtkTreeModel)(treeModel.Native())
	arg2 = (*C.GtkTreeIter)(child.Native())

	ret := C.gtk_tree_model_iter_parent(arg0, &arg1, arg2)

	var ret0 *TreeIter
	var ret1 bool

	{
		ret0 = WrapTreeIter(unsafe.Pointer(arg1))
	}

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// IterPrevious sets @iter to point to the previous node at the current
// level.
//
// If there is no previous @iter, false is returned and @iter is set to be
// invalid.
func (treeModel treeModel) IterPrevious(iter *TreeIter) bool {
	var arg0 *C.GtkTreeModel
	var arg1 *C.GtkTreeIter

	arg0 = (*C.GtkTreeModel)(treeModel.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())

	ret := C.gtk_tree_model_iter_previous(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// RefNode lets the tree ref the node.
//
// This is an optional method for models to implement. To be more specific,
// models may ignore this call as it exists primarily for performance
// reasons.
//
// This function is primarily meant as a way for views to let caching models
// know when nodes are being displayed (and hence, whether or not to cache
// that node). Being displayed means a node is in an expanded branch,
// regardless of whether the node is currently visible in the viewport. For
// example, a file-system based model would not want to keep the entire
// file-hierarchy in memory, just the sections that are currently being
// displayed by every current view.
//
// A model should be expected to be able to get an iter independent of its
// reffed state.
func (treeModel treeModel) RefNode(iter *TreeIter) {
	var arg0 *C.GtkTreeModel
	var arg1 *C.GtkTreeIter

	arg0 = (*C.GtkTreeModel)(treeModel.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())

	C.gtk_tree_model_ref_node(arg0, arg1)
}

// RowChanged emits the TreeModel::row-changed signal on @tree_model.
func (treeModel treeModel) RowChanged(path *TreePath, iter *TreeIter) {
	var arg0 *C.GtkTreeModel
	var arg1 *C.GtkTreePath
	var arg2 *C.GtkTreeIter

	arg0 = (*C.GtkTreeModel)(treeModel.Native())
	arg1 = (*C.GtkTreePath)(path.Native())
	arg2 = (*C.GtkTreeIter)(iter.Native())

	C.gtk_tree_model_row_changed(arg0, arg1, arg2)
}

// RowDeleted emits the TreeModel::row-deleted signal on @tree_model.
//
// This should be called by models after a row has been removed. The
// location pointed to by @path should be the location that the row
// previously was at. It may not be a valid location anymore.
//
// Nodes that are deleted are not unreffed, this means that any outstanding
// references on the deleted node should not be released.
func (treeModel treeModel) RowDeleted(path *TreePath) {
	var arg0 *C.GtkTreeModel
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkTreeModel)(treeModel.Native())
	arg1 = (*C.GtkTreePath)(path.Native())

	C.gtk_tree_model_row_deleted(arg0, arg1)
}

// RowHasChildToggled emits the TreeModel::row-has-child-toggled signal on
// @tree_model. This should be called by models after the child state of a
// node changes.
func (treeModel treeModel) RowHasChildToggled(path *TreePath, iter *TreeIter) {
	var arg0 *C.GtkTreeModel
	var arg1 *C.GtkTreePath
	var arg2 *C.GtkTreeIter

	arg0 = (*C.GtkTreeModel)(treeModel.Native())
	arg1 = (*C.GtkTreePath)(path.Native())
	arg2 = (*C.GtkTreeIter)(iter.Native())

	C.gtk_tree_model_row_has_child_toggled(arg0, arg1, arg2)
}

// RowInserted emits the TreeModel::row-inserted signal on @tree_model.
func (treeModel treeModel) RowInserted(path *TreePath, iter *TreeIter) {
	var arg0 *C.GtkTreeModel
	var arg1 *C.GtkTreePath
	var arg2 *C.GtkTreeIter

	arg0 = (*C.GtkTreeModel)(treeModel.Native())
	arg1 = (*C.GtkTreePath)(path.Native())
	arg2 = (*C.GtkTreeIter)(iter.Native())

	C.gtk_tree_model_row_inserted(arg0, arg1, arg2)
}

// RowsReorderedWithLength emits the TreeModel::rows-reordered signal on
// @tree_model.
//
// This should be called by models when their rows have been reordered.
func (treeModel treeModel) RowsReorderedWithLength(path *TreePath, iter *TreeIter, newOrder []int) {
	var arg0 *C.GtkTreeModel
	var arg1 *C.GtkTreePath
	var arg2 *C.GtkTreeIter
	var arg3 *C.gint
	var arg4 C.gint

	arg0 = (*C.GtkTreeModel)(treeModel.Native())
	arg1 = (*C.GtkTreePath)(path.Native())
	arg2 = (*C.GtkTreeIter)(iter.Native())
	arg3 = (*C.gint)(unsafe.Pointer(&newOrder[0]))
	arg4 = len(newOrder)
	defer runtime.KeepAlive(newOrder)

	C.gtk_tree_model_rows_reordered_with_length(arg0, arg1, arg2, arg3, arg4)
}

// UnrefNode lets the tree unref the node.
//
// This is an optional method for models to implement. To be more specific,
// models may ignore this call as it exists primarily for performance
// reasons. For more information on what this means, see
// gtk_tree_model_ref_node().
//
// Please note that nodes that are deleted are not unreffed.
func (treeModel treeModel) UnrefNode(iter *TreeIter) {
	var arg0 *C.GtkTreeModel
	var arg1 *C.GtkTreeIter

	arg0 = (*C.GtkTreeModel)(treeModel.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())

	C.gtk_tree_model_unref_node(arg0, arg1)
}

// TreeSortableOverrider contains methods that are overridable. This
// interface is a subset of the interface TreeSortable.
type TreeSortableOverrider interface {
	// SortColumnID fills in @sort_column_id and @order with the current sort
	// column and the order. It returns true unless the @sort_column_id is
	// GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID or
	// GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID.
	SortColumnID() (sortColumnID int, order SortType, ok bool)
	// HasDefaultSortFunc returns true if the model has a default sort function.
	// This is used primarily by GtkTreeViewColumns in order to determine if a
	// model can go back to the default state, or not.
	HasDefaultSortFunc() bool
	// SetDefaultSortFunc sets the default comparison function used when sorting
	// to be @sort_func. If the current sort column id of @sortable is
	// GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID, then the model will sort using
	// this function.
	//
	// If @sort_func is nil, then there will be no default comparison function.
	// This means that once the model has been sorted, it can’t go back to the
	// default state. In this case, when the current sort column id of @sortable
	// is GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID, the model will be unsorted.
	SetDefaultSortFunc(sortFunc TreeIterCompareFunc)
	// SetSortColumnID sets the current sort column to be @sort_column_id. The
	// @sortable will resort itself to reflect this change, after emitting a
	// TreeSortable::sort-column-changed signal. @sort_column_id may either be a
	// regular column id, or one of the following special values:
	//
	// - GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID: the default sort function
	// will be used, if it is set
	//
	// - GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID: no sorting will occur
	SetSortColumnID(sortColumnID int, order SortType)
	// SetSortFunc sets the comparison function used when sorting to be
	// @sort_func. If the current sort column id of @sortable is the same as
	// @sort_column_id, then the model will sort using this function.
	SetSortFunc(sortColumnID int, sortFunc TreeIterCompareFunc)
	// SortColumnChanged emits a TreeSortable::sort-column-changed signal on
	// @sortable.
	SortColumnChanged()
}

// TreeSortable is an interface to be implemented by tree models which support
// sorting. The TreeView uses the methods provided by this interface to sort the
// model.
type TreeSortable interface {
	TreeModel
	TreeSortableOverrider
}

// treeSortable implements the TreeSortable interface.
type treeSortable struct {
	TreeModel
}

var _ TreeSortable = (*treeSortable)(nil)

// WrapTreeSortable wraps a GObject to a type that implements interface
// TreeSortable. It is primarily used internally.
func WrapTreeSortable(obj *externglib.Object) TreeSortable {
	return TreeSortable{
		TreeModel: WrapTreeModel(obj),
	}
}

func marshalTreeSortable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeSortable(obj), nil
}

// SortColumnID fills in @sort_column_id and @order with the current sort
// column and the order. It returns true unless the @sort_column_id is
// GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID or
// GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID.
func (sortable treeSortable) SortColumnID() (sortColumnID int, order SortType, ok bool) {
	var arg0 *C.GtkTreeSortable
	var arg1 *C.gint        // out
	var arg2 *C.GtkSortType // out

	arg0 = (*C.GtkTreeSortable)(sortable.Native())

	ret := C.gtk_tree_sortable_get_sort_column_id(arg0, &arg1, &arg2)

	var ret0 int
	var ret1 *SortType
	var ret2 bool

	ret0 = int(arg1)

	ret1 = (*SortType)(arg2)

	ret2 = C.BOOL(ret) != 0

	return ret0, ret1, ret2
}

// HasDefaultSortFunc returns true if the model has a default sort function.
// This is used primarily by GtkTreeViewColumns in order to determine if a
// model can go back to the default state, or not.
func (sortable treeSortable) HasDefaultSortFunc() bool {
	var arg0 *C.GtkTreeSortable

	arg0 = (*C.GtkTreeSortable)(sortable.Native())

	ret := C.gtk_tree_sortable_has_default_sort_func(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SetDefaultSortFunc sets the default comparison function used when sorting
// to be @sort_func. If the current sort column id of @sortable is
// GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID, then the model will sort using
// this function.
//
// If @sort_func is nil, then there will be no default comparison function.
// This means that once the model has been sorted, it can’t go back to the
// default state. In this case, when the current sort column id of @sortable
// is GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID, the model will be unsorted.
func (sortable treeSortable) SetDefaultSortFunc(sortFunc TreeIterCompareFunc) {
	var arg0 *C.GtkTreeSortable
	var arg1 C.GtkTreeIterCompareFunc
	var arg2 C.gpointer
	var arg3 C.GDestroyNotify

	arg0 = (*C.GtkTreeSortable)(sortable.Native())
	arg1 = (*[0]byte)(C.gotk4_TreeIterCompareFunc)
	arg2 = C.gpointer(box.Assign(sortFunc))
	arg3 = (*[0]byte)(C.callbackDelete)

	C.gtk_tree_sortable_set_default_sort_func(arg0, arg1, arg2, arg3)
}

// SetSortColumnID sets the current sort column to be @sort_column_id. The
// @sortable will resort itself to reflect this change, after emitting a
// TreeSortable::sort-column-changed signal. @sort_column_id may either be a
// regular column id, or one of the following special values:
//
// - GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID: the default sort function
// will be used, if it is set
//
// - GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID: no sorting will occur
func (sortable treeSortable) SetSortColumnID(sortColumnID int, order SortType) {
	var arg0 *C.GtkTreeSortable
	var arg1 C.gint
	var arg2 C.GtkSortType

	arg0 = (*C.GtkTreeSortable)(sortable.Native())
	arg1 = C.gint(sortColumnID)
	arg2 = (C.GtkSortType)(order)

	C.gtk_tree_sortable_set_sort_column_id(arg0, arg1, arg2)
}

// SetSortFunc sets the comparison function used when sorting to be
// @sort_func. If the current sort column id of @sortable is the same as
// @sort_column_id, then the model will sort using this function.
func (sortable treeSortable) SetSortFunc(sortColumnID int, sortFunc TreeIterCompareFunc) {
	var arg0 *C.GtkTreeSortable
	var arg1 C.gint
	var arg2 C.GtkTreeIterCompareFunc
	var arg3 C.gpointer
	var arg4 C.GDestroyNotify

	arg0 = (*C.GtkTreeSortable)(sortable.Native())
	arg1 = C.gint(sortColumnID)
	arg2 = (*[0]byte)(C.gotk4_TreeIterCompareFunc)
	arg3 = C.gpointer(box.Assign(sortFunc))
	arg4 = (*[0]byte)(C.callbackDelete)

	C.gtk_tree_sortable_set_sort_func(arg0, arg1, arg2, arg3, arg4)
}

// SortColumnChanged emits a TreeSortable::sort-column-changed signal on
// @sortable.
func (sortable treeSortable) SortColumnChanged() {
	var arg0 *C.GtkTreeSortable

	arg0 = (*C.GtkTreeSortable)(sortable.Native())

	C.gtk_tree_sortable_sort_column_changed(arg0)
}

type AboutDialogPrivate struct {
	native C.GtkAboutDialogPrivate
}

// WrapAboutDialogPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAboutDialogPrivate(ptr unsafe.Pointer) *AboutDialogPrivate {
	if ptr == nil {
		return nil
	}

	return (*AboutDialogPrivate)(ptr)
}

func marshalAboutDialogPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapAboutDialogPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (a *AboutDialogPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

type AccelGroupEntry struct {
	native C.GtkAccelGroupEntry
}

// WrapAccelGroupEntry wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAccelGroupEntry(ptr unsafe.Pointer) *AccelGroupEntry {
	if ptr == nil {
		return nil
	}

	return (*AccelGroupEntry)(ptr)
}

func marshalAccelGroupEntry(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapAccelGroupEntry(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (a *AccelGroupEntry) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// Key gets the field inside the struct.
func (a *AccelGroupEntry) Key() AccelKey {
	var ret AccelKey
	{
		ret = WrapAccelKey(unsafe.Pointer(a.native.key))
	}
	return ret
}

// AccelPathQuark gets the field inside the struct.
func (a *AccelGroupEntry) AccelPathQuark() glib.Quark {
	var ret glib.Quark
	{
		var tmp uint32
		tmp = uint32(a.native.accel_path_quark)
		ret = glib.Quark(tmp)
	}
	return ret
}

type AccelGroupPrivate struct {
	native C.GtkAccelGroupPrivate
}

// WrapAccelGroupPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAccelGroupPrivate(ptr unsafe.Pointer) *AccelGroupPrivate {
	if ptr == nil {
		return nil
	}

	return (*AccelGroupPrivate)(ptr)
}

func marshalAccelGroupPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapAccelGroupPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (a *AccelGroupPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

type AccelKey struct {
	native C.GtkAccelKey
}

// WrapAccelKey wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAccelKey(ptr unsafe.Pointer) *AccelKey {
	if ptr == nil {
		return nil
	}

	return (*AccelKey)(ptr)
}

func marshalAccelKey(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapAccelKey(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (a *AccelKey) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// AccelKey gets the field inside the struct.
func (a *AccelKey) AccelKey() uint {
	var ret uint
	ret = uint(a.native.accel_key)
	return ret
}

// AccelMods gets the field inside the struct.
func (a *AccelKey) AccelMods() gdk.ModifierType {
	var ret gdk.ModifierType
	ret = gdk.ModifierType(a.native.accel_mods)
	return ret
}

type AccelLabelPrivate struct {
	native C.GtkAccelLabelPrivate
}

// WrapAccelLabelPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAccelLabelPrivate(ptr unsafe.Pointer) *AccelLabelPrivate {
	if ptr == nil {
		return nil
	}

	return (*AccelLabelPrivate)(ptr)
}

func marshalAccelLabelPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapAccelLabelPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (a *AccelLabelPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

type AccessiblePrivate struct {
	native C.GtkAccessiblePrivate
}

// WrapAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAccessiblePrivate(ptr unsafe.Pointer) *AccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*AccessiblePrivate)(ptr)
}

func marshalAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (a *AccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

type ActionBarPrivate struct {
	native C.GtkActionBarPrivate
}

// WrapActionBarPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapActionBarPrivate(ptr unsafe.Pointer) *ActionBarPrivate {
	if ptr == nil {
		return nil
	}

	return (*ActionBarPrivate)(ptr)
}

func marshalActionBarPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapActionBarPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (a *ActionBarPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// ActionEntry structs are used with gtk_action_group_add_actions() to construct
// actions.
type ActionEntry struct {
	native C.GtkActionEntry
}

// WrapActionEntry wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapActionEntry(ptr unsafe.Pointer) *ActionEntry {
	if ptr == nil {
		return nil
	}

	return (*ActionEntry)(ptr)
}

func marshalActionEntry(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapActionEntry(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (a *ActionEntry) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// Name gets the field inside the struct.
func (a *ActionEntry) Name() string {
	var ret string
	ret = C.GoString(a.native.name)
	return ret
}

// StockID gets the field inside the struct.
func (a *ActionEntry) StockID() string {
	var ret string
	ret = C.GoString(a.native.stock_id)
	return ret
}

// Label gets the field inside the struct.
func (a *ActionEntry) Label() string {
	var ret string
	ret = C.GoString(a.native.label)
	return ret
}

// Accelerator gets the field inside the struct.
func (a *ActionEntry) Accelerator() string {
	var ret string
	ret = C.GoString(a.native.accelerator)
	return ret
}

// Tooltip gets the field inside the struct.
func (a *ActionEntry) Tooltip() string {
	var ret string
	ret = C.GoString(a.native.tooltip)
	return ret
}

type ActionGroupPrivate struct {
	native C.GtkActionGroupPrivate
}

// WrapActionGroupPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapActionGroupPrivate(ptr unsafe.Pointer) *ActionGroupPrivate {
	if ptr == nil {
		return nil
	}

	return (*ActionGroupPrivate)(ptr)
}

func marshalActionGroupPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapActionGroupPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (a *ActionGroupPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

type ActionPrivate struct {
	native C.GtkActionPrivate
}

// WrapActionPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapActionPrivate(ptr unsafe.Pointer) *ActionPrivate {
	if ptr == nil {
		return nil
	}

	return (*ActionPrivate)(ptr)
}

func marshalActionPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapActionPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (a *ActionPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

type AdjustmentPrivate struct {
	native C.GtkAdjustmentPrivate
}

// WrapAdjustmentPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAdjustmentPrivate(ptr unsafe.Pointer) *AdjustmentPrivate {
	if ptr == nil {
		return nil
	}

	return (*AdjustmentPrivate)(ptr)
}

func marshalAdjustmentPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapAdjustmentPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (a *AdjustmentPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

type AlignmentPrivate struct {
	native C.GtkAlignmentPrivate
}

// WrapAlignmentPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAlignmentPrivate(ptr unsafe.Pointer) *AlignmentPrivate {
	if ptr == nil {
		return nil
	}

	return (*AlignmentPrivate)(ptr)
}

func marshalAlignmentPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapAlignmentPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (a *AlignmentPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

type AppChooserButtonPrivate struct {
	native C.GtkAppChooserButtonPrivate
}

// WrapAppChooserButtonPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAppChooserButtonPrivate(ptr unsafe.Pointer) *AppChooserButtonPrivate {
	if ptr == nil {
		return nil
	}

	return (*AppChooserButtonPrivate)(ptr)
}

func marshalAppChooserButtonPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapAppChooserButtonPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (a *AppChooserButtonPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

type AppChooserDialogPrivate struct {
	native C.GtkAppChooserDialogPrivate
}

// WrapAppChooserDialogPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAppChooserDialogPrivate(ptr unsafe.Pointer) *AppChooserDialogPrivate {
	if ptr == nil {
		return nil
	}

	return (*AppChooserDialogPrivate)(ptr)
}

func marshalAppChooserDialogPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapAppChooserDialogPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (a *AppChooserDialogPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

type AppChooserWidgetPrivate struct {
	native C.GtkAppChooserWidgetPrivate
}

// WrapAppChooserWidgetPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAppChooserWidgetPrivate(ptr unsafe.Pointer) *AppChooserWidgetPrivate {
	if ptr == nil {
		return nil
	}

	return (*AppChooserWidgetPrivate)(ptr)
}

func marshalAppChooserWidgetPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapAppChooserWidgetPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (a *AppChooserWidgetPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

type ApplicationPrivate struct {
	native C.GtkApplicationPrivate
}

// WrapApplicationPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapApplicationPrivate(ptr unsafe.Pointer) *ApplicationPrivate {
	if ptr == nil {
		return nil
	}

	return (*ApplicationPrivate)(ptr)
}

func marshalApplicationPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapApplicationPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (a *ApplicationPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

type ApplicationWindowPrivate struct {
	native C.GtkApplicationWindowPrivate
}

// WrapApplicationWindowPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapApplicationWindowPrivate(ptr unsafe.Pointer) *ApplicationWindowPrivate {
	if ptr == nil {
		return nil
	}

	return (*ApplicationWindowPrivate)(ptr)
}

func marshalApplicationWindowPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapApplicationWindowPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (a *ApplicationWindowPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

type ArrowAccessiblePrivate struct {
	native C.GtkArrowAccessiblePrivate
}

// WrapArrowAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapArrowAccessiblePrivate(ptr unsafe.Pointer) *ArrowAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*ArrowAccessiblePrivate)(ptr)
}

func marshalArrowAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapArrowAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (a *ArrowAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

type ArrowPrivate struct {
	native C.GtkArrowPrivate
}

// WrapArrowPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapArrowPrivate(ptr unsafe.Pointer) *ArrowPrivate {
	if ptr == nil {
		return nil
	}

	return (*ArrowPrivate)(ptr)
}

func marshalArrowPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapArrowPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (a *ArrowPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

type AspectFramePrivate struct {
	native C.GtkAspectFramePrivate
}

// WrapAspectFramePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAspectFramePrivate(ptr unsafe.Pointer) *AspectFramePrivate {
	if ptr == nil {
		return nil
	}

	return (*AspectFramePrivate)(ptr)
}

func marshalAspectFramePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapAspectFramePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (a *AspectFramePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

type AssistantPrivate struct {
	native C.GtkAssistantPrivate
}

// WrapAssistantPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAssistantPrivate(ptr unsafe.Pointer) *AssistantPrivate {
	if ptr == nil {
		return nil
	}

	return (*AssistantPrivate)(ptr)
}

func marshalAssistantPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapAssistantPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (a *AssistantPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

type BinPrivate struct {
	native C.GtkBinPrivate
}

// WrapBinPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapBinPrivate(ptr unsafe.Pointer) *BinPrivate {
	if ptr == nil {
		return nil
	}

	return (*BinPrivate)(ptr)
}

func marshalBinPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapBinPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (b *BinPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&b.native)
}

// BindingArg: a BindingArg holds the data associated with an argument for a key
// binding signal emission as stored in BindingSignal.
type BindingArg struct {
	native C.GtkBindingArg
}

// WrapBindingArg wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapBindingArg(ptr unsafe.Pointer) *BindingArg {
	if ptr == nil {
		return nil
	}

	return (*BindingArg)(ptr)
}

func marshalBindingArg(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapBindingArg(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (b *BindingArg) Native() unsafe.Pointer {
	return unsafe.Pointer(&b.native)
}

// ArgType gets the field inside the struct.
func (b *BindingArg) ArgType() externglib.Type {
	var ret externglib.Type
	ret = externglib.Type(b.native.arg_type)
	return ret
}

// BindingEntry: each key binding element of a binding sets binding list is
// represented by a GtkBindingEntry.
type BindingEntry struct {
	native C.GtkBindingEntry
}

// WrapBindingEntry wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapBindingEntry(ptr unsafe.Pointer) *BindingEntry {
	if ptr == nil {
		return nil
	}

	return (*BindingEntry)(ptr)
}

func marshalBindingEntry(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapBindingEntry(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (b *BindingEntry) Native() unsafe.Pointer {
	return unsafe.Pointer(&b.native)
}

// Keyval gets the field inside the struct.
func (b *BindingEntry) Keyval() uint {
	var ret uint
	ret = uint(b.native.keyval)
	return ret
}

// Modifiers gets the field inside the struct.
func (b *BindingEntry) Modifiers() gdk.ModifierType {
	var ret gdk.ModifierType
	ret = gdk.ModifierType(b.native.modifiers)
	return ret
}

// BindingSet gets the field inside the struct.
func (b *BindingEntry) BindingSet() *BindingSet {
	var ret *BindingSet
	{
		ret = WrapBindingSet(unsafe.Pointer(b.native.binding_set))
	}
	return ret
}

// SetNext gets the field inside the struct.
func (b *BindingEntry) SetNext() *BindingEntry {
	var ret *BindingEntry
	{
		ret = WrapBindingEntry(unsafe.Pointer(b.native.set_next))
	}
	return ret
}

// HashNext gets the field inside the struct.
func (b *BindingEntry) HashNext() *BindingEntry {
	var ret *BindingEntry
	{
		ret = WrapBindingEntry(unsafe.Pointer(b.native.hash_next))
	}
	return ret
}

// Signals gets the field inside the struct.
func (b *BindingEntry) Signals() *BindingSignal {
	var ret *BindingSignal
	{
		ret = WrapBindingSignal(unsafe.Pointer(b.native.signals))
	}
	return ret
}

// BindingSet: a binding set maintains a list of activatable key bindings. A
// single binding set can match multiple types of widgets. Similar to style
// contexts, can be matched by any information contained in a widgets
// WidgetPath. When a binding within a set is matched upon activation, an action
// signal is emitted on the target widget to carry out the actual activation.
type BindingSet struct {
	native C.GtkBindingSet
}

// WrapBindingSet wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapBindingSet(ptr unsafe.Pointer) *BindingSet {
	if ptr == nil {
		return nil
	}

	return (*BindingSet)(ptr)
}

func marshalBindingSet(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapBindingSet(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (b *BindingSet) Native() unsafe.Pointer {
	return unsafe.Pointer(&b.native)
}

// SetName gets the field inside the struct.
func (b *BindingSet) SetName() string {
	var ret string
	ret = C.GoString(b.native.set_name)
	return ret
}

// Priority gets the field inside the struct.
func (b *BindingSet) Priority() int {
	var ret int
	ret = int(b.native.priority)
	return ret
}

// WidgetPathPspecs gets the field inside the struct.
func (b *BindingSet) WidgetPathPspecs() *glib.SList {
	var ret *glib.SList
	{
		ret = glib.WrapSList(unsafe.Pointer(b.native.widget_path_pspecs))
	}
	return ret
}

// WidgetClassPspecs gets the field inside the struct.
func (b *BindingSet) WidgetClassPspecs() *glib.SList {
	var ret *glib.SList
	{
		ret = glib.WrapSList(unsafe.Pointer(b.native.widget_class_pspecs))
	}
	return ret
}

// ClassBranchPspecs gets the field inside the struct.
func (b *BindingSet) ClassBranchPspecs() *glib.SList {
	var ret *glib.SList
	{
		ret = glib.WrapSList(unsafe.Pointer(b.native.class_branch_pspecs))
	}
	return ret
}

// Entries gets the field inside the struct.
func (b *BindingSet) Entries() *BindingEntry {
	var ret *BindingEntry
	{
		ret = WrapBindingEntry(unsafe.Pointer(b.native.entries))
	}
	return ret
}

// Current gets the field inside the struct.
func (b *BindingSet) Current() *BindingEntry {
	var ret *BindingEntry
	{
		ret = WrapBindingEntry(unsafe.Pointer(b.native.current))
	}
	return ret
}

// Activate: find a key binding matching @keyval and @modifiers within
// @binding_set and activate the binding on @object.
func (bindingSet *BindingSet) Activate(keyval uint, modifiers gdk.ModifierType, object gextras.Objector) bool {
	var arg0 *C.GtkBindingSet
	var arg1 C.guint
	var arg2 C.GdkModifierType
	var arg3 *C.GObject

	arg0 = (*C.GtkBindingSet)(bindingSet.Native())
	arg1 = C.guint(keyval)
	arg2 = (C.GdkModifierType)(modifiers)
	arg3 = (*C.GObject)(object.Native())

	ret := C.gtk_binding_set_activate(arg0, arg1, arg2, arg3)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// AddPath: this function was used internally by the GtkRC parsing mechanism to
// assign match patterns to BindingSet structures.
//
// In GTK+ 3, these match patterns are unused.
func (bindingSet *BindingSet) AddPath(pathType PathType, pathPattern string, priority PathPriorityType) {
	var arg0 *C.GtkBindingSet
	var arg1 C.GtkPathType
	var arg2 *C.gchar
	var arg3 C.GtkPathPriorityType

	arg0 = (*C.GtkBindingSet)(bindingSet.Native())
	arg1 = (C.GtkPathType)(pathType)
	arg2 = (*C.gchar)(C.CString(pathPattern))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (C.GtkPathPriorityType)(priority)

	C.gtk_binding_set_add_path(arg0, arg1, arg2, arg3)
}

// BindingSignal: a GtkBindingSignal stores the necessary information to
// activate a widget in response to a key press via a signal emission.
type BindingSignal struct {
	native C.GtkBindingSignal
}

// WrapBindingSignal wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapBindingSignal(ptr unsafe.Pointer) *BindingSignal {
	if ptr == nil {
		return nil
	}

	return (*BindingSignal)(ptr)
}

func marshalBindingSignal(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapBindingSignal(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (b *BindingSignal) Native() unsafe.Pointer {
	return unsafe.Pointer(&b.native)
}

// Next gets the field inside the struct.
func (b *BindingSignal) Next() *BindingSignal {
	var ret *BindingSignal
	{
		ret = WrapBindingSignal(unsafe.Pointer(b.native.next))
	}
	return ret
}

// SignalName gets the field inside the struct.
func (b *BindingSignal) SignalName() string {
	var ret string
	ret = C.GoString(b.native.signal_name)
	return ret
}

// NArgs gets the field inside the struct.
func (b *BindingSignal) NArgs() uint {
	var ret uint
	ret = uint(b.native.n_args)
	return ret
}

// Args gets the field inside the struct.
func (b *BindingSignal) Args() []BindingArg {
	var ret []BindingArg
	{
		ret = make([]BindingArg, b.native.n_args)
		for i := 0; i < uintptr(b.native.n_args); i++ {
			src := (C.GtkBindingArg)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			{
				ret[i] = WrapBindingArg(unsafe.Pointer(src))
			}
		}
	}
	return ret
}

type BooleanCellAccessiblePrivate struct {
	native C.GtkBooleanCellAccessiblePrivate
}

// WrapBooleanCellAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapBooleanCellAccessiblePrivate(ptr unsafe.Pointer) *BooleanCellAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*BooleanCellAccessiblePrivate)(ptr)
}

func marshalBooleanCellAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapBooleanCellAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (b *BooleanCellAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&b.native)
}

// Border: a struct that specifies a border around a rectangular area that can
// be of different width on each side.
type Border struct {
	native C.GtkBorder
}

// WrapBorder wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapBorder(ptr unsafe.Pointer) *Border {
	if ptr == nil {
		return nil
	}

	return (*Border)(ptr)
}

func marshalBorder(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapBorder(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (b *Border) Native() unsafe.Pointer {
	return unsafe.Pointer(&b.native)
}

// NewBorder constructs a struct Border.
func NewBorder() *Border {

	ret := C.gtk_border_new()

	var ret0 *Border

	{
		ret0 = WrapBorder(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Border) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Left gets the field inside the struct.
func (b *Border) Left() int16 {
	var ret int16
	ret = int16(b.native.left)
	return ret
}

// Right gets the field inside the struct.
func (b *Border) Right() int16 {
	var ret int16
	ret = int16(b.native.right)
	return ret
}

// Top gets the field inside the struct.
func (b *Border) Top() int16 {
	var ret int16
	ret = int16(b.native.top)
	return ret
}

// Bottom gets the field inside the struct.
func (b *Border) Bottom() int16 {
	var ret int16
	ret = int16(b.native.bottom)
	return ret
}

// Copy copies a Border-struct.
func (border_ *Border) Copy() *Border {
	var arg0 *C.GtkBorder

	arg0 = (*C.GtkBorder)(border_.Native())

	ret := C.gtk_border_copy(arg0)

	var ret0 *Border

	{
		ret0 = WrapBorder(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Border) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Free frees a Border-struct.
func (border_ *Border) Free() {
	var arg0 *C.GtkBorder

	arg0 = (*C.GtkBorder)(border_.Native())

	C.gtk_border_free(arg0)
}

type BoxPrivate struct {
	native C.GtkBoxPrivate
}

// WrapBoxPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapBoxPrivate(ptr unsafe.Pointer) *BoxPrivate {
	if ptr == nil {
		return nil
	}

	return (*BoxPrivate)(ptr)
}

func marshalBoxPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapBoxPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (b *BoxPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&b.native)
}

type BuilderPrivate struct {
	native C.GtkBuilderPrivate
}

// WrapBuilderPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapBuilderPrivate(ptr unsafe.Pointer) *BuilderPrivate {
	if ptr == nil {
		return nil
	}

	return (*BuilderPrivate)(ptr)
}

func marshalBuilderPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapBuilderPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (b *BuilderPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&b.native)
}

type ButtonAccessiblePrivate struct {
	native C.GtkButtonAccessiblePrivate
}

// WrapButtonAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapButtonAccessiblePrivate(ptr unsafe.Pointer) *ButtonAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*ButtonAccessiblePrivate)(ptr)
}

func marshalButtonAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapButtonAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (b *ButtonAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&b.native)
}

type ButtonBoxPrivate struct {
	native C.GtkButtonBoxPrivate
}

// WrapButtonBoxPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapButtonBoxPrivate(ptr unsafe.Pointer) *ButtonBoxPrivate {
	if ptr == nil {
		return nil
	}

	return (*ButtonBoxPrivate)(ptr)
}

func marshalButtonBoxPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapButtonBoxPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (b *ButtonBoxPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&b.native)
}

type ButtonPrivate struct {
	native C.GtkButtonPrivate
}

// WrapButtonPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapButtonPrivate(ptr unsafe.Pointer) *ButtonPrivate {
	if ptr == nil {
		return nil
	}

	return (*ButtonPrivate)(ptr)
}

func marshalButtonPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapButtonPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (b *ButtonPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&b.native)
}

type CalendarPrivate struct {
	native C.GtkCalendarPrivate
}

// WrapCalendarPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapCalendarPrivate(ptr unsafe.Pointer) *CalendarPrivate {
	if ptr == nil {
		return nil
	}

	return (*CalendarPrivate)(ptr)
}

func marshalCalendarPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapCalendarPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *CalendarPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

type CellAccessiblePrivate struct {
	native C.GtkCellAccessiblePrivate
}

// WrapCellAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapCellAccessiblePrivate(ptr unsafe.Pointer) *CellAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*CellAccessiblePrivate)(ptr)
}

func marshalCellAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapCellAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *CellAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

type CellAreaBoxPrivate struct {
	native C.GtkCellAreaBoxPrivate
}

// WrapCellAreaBoxPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapCellAreaBoxPrivate(ptr unsafe.Pointer) *CellAreaBoxPrivate {
	if ptr == nil {
		return nil
	}

	return (*CellAreaBoxPrivate)(ptr)
}

func marshalCellAreaBoxPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapCellAreaBoxPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *CellAreaBoxPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

type CellAreaContextPrivate struct {
	native C.GtkCellAreaContextPrivate
}

// WrapCellAreaContextPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapCellAreaContextPrivate(ptr unsafe.Pointer) *CellAreaContextPrivate {
	if ptr == nil {
		return nil
	}

	return (*CellAreaContextPrivate)(ptr)
}

func marshalCellAreaContextPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapCellAreaContextPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *CellAreaContextPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

type CellAreaPrivate struct {
	native C.GtkCellAreaPrivate
}

// WrapCellAreaPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapCellAreaPrivate(ptr unsafe.Pointer) *CellAreaPrivate {
	if ptr == nil {
		return nil
	}

	return (*CellAreaPrivate)(ptr)
}

func marshalCellAreaPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapCellAreaPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *CellAreaPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

type CellRendererAccelPrivate struct {
	native C.GtkCellRendererAccelPrivate
}

// WrapCellRendererAccelPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapCellRendererAccelPrivate(ptr unsafe.Pointer) *CellRendererAccelPrivate {
	if ptr == nil {
		return nil
	}

	return (*CellRendererAccelPrivate)(ptr)
}

func marshalCellRendererAccelPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapCellRendererAccelPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *CellRendererAccelPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

type CellRendererClassPrivate struct {
	native C.GtkCellRendererClassPrivate
}

// WrapCellRendererClassPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapCellRendererClassPrivate(ptr unsafe.Pointer) *CellRendererClassPrivate {
	if ptr == nil {
		return nil
	}

	return (*CellRendererClassPrivate)(ptr)
}

func marshalCellRendererClassPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapCellRendererClassPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *CellRendererClassPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

type CellRendererComboPrivate struct {
	native C.GtkCellRendererComboPrivate
}

// WrapCellRendererComboPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapCellRendererComboPrivate(ptr unsafe.Pointer) *CellRendererComboPrivate {
	if ptr == nil {
		return nil
	}

	return (*CellRendererComboPrivate)(ptr)
}

func marshalCellRendererComboPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapCellRendererComboPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *CellRendererComboPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

type CellRendererPixbufPrivate struct {
	native C.GtkCellRendererPixbufPrivate
}

// WrapCellRendererPixbufPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapCellRendererPixbufPrivate(ptr unsafe.Pointer) *CellRendererPixbufPrivate {
	if ptr == nil {
		return nil
	}

	return (*CellRendererPixbufPrivate)(ptr)
}

func marshalCellRendererPixbufPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapCellRendererPixbufPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *CellRendererPixbufPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

type CellRendererPrivate struct {
	native C.GtkCellRendererPrivate
}

// WrapCellRendererPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapCellRendererPrivate(ptr unsafe.Pointer) *CellRendererPrivate {
	if ptr == nil {
		return nil
	}

	return (*CellRendererPrivate)(ptr)
}

func marshalCellRendererPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapCellRendererPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *CellRendererPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

type CellRendererProgressPrivate struct {
	native C.GtkCellRendererProgressPrivate
}

// WrapCellRendererProgressPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapCellRendererProgressPrivate(ptr unsafe.Pointer) *CellRendererProgressPrivate {
	if ptr == nil {
		return nil
	}

	return (*CellRendererProgressPrivate)(ptr)
}

func marshalCellRendererProgressPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapCellRendererProgressPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *CellRendererProgressPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

type CellRendererSpinPrivate struct {
	native C.GtkCellRendererSpinPrivate
}

// WrapCellRendererSpinPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapCellRendererSpinPrivate(ptr unsafe.Pointer) *CellRendererSpinPrivate {
	if ptr == nil {
		return nil
	}

	return (*CellRendererSpinPrivate)(ptr)
}

func marshalCellRendererSpinPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapCellRendererSpinPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *CellRendererSpinPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

type CellRendererSpinnerPrivate struct {
	native C.GtkCellRendererSpinnerPrivate
}

// WrapCellRendererSpinnerPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapCellRendererSpinnerPrivate(ptr unsafe.Pointer) *CellRendererSpinnerPrivate {
	if ptr == nil {
		return nil
	}

	return (*CellRendererSpinnerPrivate)(ptr)
}

func marshalCellRendererSpinnerPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapCellRendererSpinnerPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *CellRendererSpinnerPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

type CellRendererTextPrivate struct {
	native C.GtkCellRendererTextPrivate
}

// WrapCellRendererTextPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapCellRendererTextPrivate(ptr unsafe.Pointer) *CellRendererTextPrivate {
	if ptr == nil {
		return nil
	}

	return (*CellRendererTextPrivate)(ptr)
}

func marshalCellRendererTextPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapCellRendererTextPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *CellRendererTextPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

type CellRendererTogglePrivate struct {
	native C.GtkCellRendererTogglePrivate
}

// WrapCellRendererTogglePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapCellRendererTogglePrivate(ptr unsafe.Pointer) *CellRendererTogglePrivate {
	if ptr == nil {
		return nil
	}

	return (*CellRendererTogglePrivate)(ptr)
}

func marshalCellRendererTogglePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapCellRendererTogglePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *CellRendererTogglePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

type CellViewPrivate struct {
	native C.GtkCellViewPrivate
}

// WrapCellViewPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapCellViewPrivate(ptr unsafe.Pointer) *CellViewPrivate {
	if ptr == nil {
		return nil
	}

	return (*CellViewPrivate)(ptr)
}

func marshalCellViewPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapCellViewPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *CellViewPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

type CheckMenuItemAccessiblePrivate struct {
	native C.GtkCheckMenuItemAccessiblePrivate
}

// WrapCheckMenuItemAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapCheckMenuItemAccessiblePrivate(ptr unsafe.Pointer) *CheckMenuItemAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*CheckMenuItemAccessiblePrivate)(ptr)
}

func marshalCheckMenuItemAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapCheckMenuItemAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *CheckMenuItemAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

type CheckMenuItemPrivate struct {
	native C.GtkCheckMenuItemPrivate
}

// WrapCheckMenuItemPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapCheckMenuItemPrivate(ptr unsafe.Pointer) *CheckMenuItemPrivate {
	if ptr == nil {
		return nil
	}

	return (*CheckMenuItemPrivate)(ptr)
}

func marshalCheckMenuItemPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapCheckMenuItemPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *CheckMenuItemPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

type ColorButtonPrivate struct {
	native C.GtkColorButtonPrivate
}

// WrapColorButtonPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapColorButtonPrivate(ptr unsafe.Pointer) *ColorButtonPrivate {
	if ptr == nil {
		return nil
	}

	return (*ColorButtonPrivate)(ptr)
}

func marshalColorButtonPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapColorButtonPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *ColorButtonPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

type ColorChooserDialogPrivate struct {
	native C.GtkColorChooserDialogPrivate
}

// WrapColorChooserDialogPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapColorChooserDialogPrivate(ptr unsafe.Pointer) *ColorChooserDialogPrivate {
	if ptr == nil {
		return nil
	}

	return (*ColorChooserDialogPrivate)(ptr)
}

func marshalColorChooserDialogPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapColorChooserDialogPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *ColorChooserDialogPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

type ColorChooserWidgetPrivate struct {
	native C.GtkColorChooserWidgetPrivate
}

// WrapColorChooserWidgetPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapColorChooserWidgetPrivate(ptr unsafe.Pointer) *ColorChooserWidgetPrivate {
	if ptr == nil {
		return nil
	}

	return (*ColorChooserWidgetPrivate)(ptr)
}

func marshalColorChooserWidgetPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapColorChooserWidgetPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *ColorChooserWidgetPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

type ColorSelectionDialogPrivate struct {
	native C.GtkColorSelectionDialogPrivate
}

// WrapColorSelectionDialogPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapColorSelectionDialogPrivate(ptr unsafe.Pointer) *ColorSelectionDialogPrivate {
	if ptr == nil {
		return nil
	}

	return (*ColorSelectionDialogPrivate)(ptr)
}

func marshalColorSelectionDialogPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapColorSelectionDialogPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *ColorSelectionDialogPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

type ColorSelectionPrivate struct {
	native C.GtkColorSelectionPrivate
}

// WrapColorSelectionPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapColorSelectionPrivate(ptr unsafe.Pointer) *ColorSelectionPrivate {
	if ptr == nil {
		return nil
	}

	return (*ColorSelectionPrivate)(ptr)
}

func marshalColorSelectionPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapColorSelectionPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *ColorSelectionPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

type ComboBoxAccessiblePrivate struct {
	native C.GtkComboBoxAccessiblePrivate
}

// WrapComboBoxAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapComboBoxAccessiblePrivate(ptr unsafe.Pointer) *ComboBoxAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*ComboBoxAccessiblePrivate)(ptr)
}

func marshalComboBoxAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapComboBoxAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *ComboBoxAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

type ComboBoxPrivate struct {
	native C.GtkComboBoxPrivate
}

// WrapComboBoxPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapComboBoxPrivate(ptr unsafe.Pointer) *ComboBoxPrivate {
	if ptr == nil {
		return nil
	}

	return (*ComboBoxPrivate)(ptr)
}

func marshalComboBoxPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapComboBoxPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *ComboBoxPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

type ComboBoxTextPrivate struct {
	native C.GtkComboBoxTextPrivate
}

// WrapComboBoxTextPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapComboBoxTextPrivate(ptr unsafe.Pointer) *ComboBoxTextPrivate {
	if ptr == nil {
		return nil
	}

	return (*ComboBoxTextPrivate)(ptr)
}

func marshalComboBoxTextPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapComboBoxTextPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *ComboBoxTextPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

type ContainerAccessiblePrivate struct {
	native C.GtkContainerAccessiblePrivate
}

// WrapContainerAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapContainerAccessiblePrivate(ptr unsafe.Pointer) *ContainerAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*ContainerAccessiblePrivate)(ptr)
}

func marshalContainerAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapContainerAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *ContainerAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

type ContainerCellAccessiblePrivate struct {
	native C.GtkContainerCellAccessiblePrivate
}

// WrapContainerCellAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapContainerCellAccessiblePrivate(ptr unsafe.Pointer) *ContainerCellAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*ContainerCellAccessiblePrivate)(ptr)
}

func marshalContainerCellAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapContainerCellAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *ContainerCellAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

type ContainerPrivate struct {
	native C.GtkContainerPrivate
}

// WrapContainerPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapContainerPrivate(ptr unsafe.Pointer) *ContainerPrivate {
	if ptr == nil {
		return nil
	}

	return (*ContainerPrivate)(ptr)
}

func marshalContainerPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapContainerPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *ContainerPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

type CSSProviderPrivate struct {
	native C.GtkCssProviderPrivate
}

// WrapCSSProviderPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapCSSProviderPrivate(ptr unsafe.Pointer) *CSSProviderPrivate {
	if ptr == nil {
		return nil
	}

	return (*CSSProviderPrivate)(ptr)
}

func marshalCSSProviderPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapCSSProviderPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *CSSProviderPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

// CSSSection defines a part of a CSS document. Because sections are nested into
// one another, you can use gtk_css_section_get_parent() to get the containing
// region.
type CSSSection struct {
	native C.GtkCssSection
}

// WrapCSSSection wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapCSSSection(ptr unsafe.Pointer) *CSSSection {
	if ptr == nil {
		return nil
	}

	return (*CSSSection)(ptr)
}

func marshalCSSSection(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapCSSSection(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *CSSSection) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

// EndLine returns the line in the CSS document where this section end. The line
// number is 0-indexed, so the first line of the document will return 0. This
// value may change in future invocations of this function if @section is not
// yet parsed completely. This will for example happen in the
// GtkCssProvider::parsing-error signal. The end position and line may be
// identical to the start position and line for sections which failed to parse
// anything successfully.
func (section *CSSSection) EndLine() uint {
	var arg0 *C.GtkCssSection

	arg0 = (*C.GtkCssSection)(section.Native())

	ret := C.gtk_css_section_get_end_line(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// EndPosition returns the offset in bytes from the start of the current line
// returned via gtk_css_section_get_end_line(). This value may change in future
// invocations of this function if @section is not yet parsed completely. This
// will for example happen in the GtkCssProvider::parsing-error signal. The end
// position and line may be identical to the start position and line for
// sections which failed to parse anything successfully.
func (section *CSSSection) EndPosition() uint {
	var arg0 *C.GtkCssSection

	arg0 = (*C.GtkCssSection)(section.Native())

	ret := C.gtk_css_section_get_end_position(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// File gets the file that @section was parsed from. If no such file exists, for
// example because the CSS was loaded via @gtk_css_provider_load_from_data(),
// then nil is returned.
func (section *CSSSection) File() gio.File {
	var arg0 *C.GtkCssSection

	arg0 = (*C.GtkCssSection)(section.Native())

	ret := C.gtk_css_section_get_file(arg0)

	var ret0 gio.File

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gio.File)

	return ret0
}

// Parent gets the parent section for the given @section. The parent section is
// the section that contains this @section. A special case are sections of type
// K_CSS_SECTION_DOCUMENT. Their parent will either be nil if they are the
// original CSS document that was loaded by gtk_css_provider_load_from_file() or
// a section of type K_CSS_SECTION_IMPORT if it was loaded with an import rule
// from a different file.
func (section *CSSSection) Parent() *CSSSection {
	var arg0 *C.GtkCssSection

	arg0 = (*C.GtkCssSection)(section.Native())

	ret := C.gtk_css_section_get_parent(arg0)

	var ret0 *CSSSection

	{
		ret0 = WrapCSSSection(unsafe.Pointer(ret))
	}

	return ret0
}

// SectionType gets the type of information that @section describes.
func (section *CSSSection) SectionType() CSSSectionType {
	var arg0 *C.GtkCssSection

	arg0 = (*C.GtkCssSection)(section.Native())

	ret := C.gtk_css_section_get_section_type(arg0)

	var ret0 CSSSectionType

	ret0 = CSSSectionType(ret)

	return ret0
}

// StartLine returns the line in the CSS document where this section starts. The
// line number is 0-indexed, so the first line of the document will return 0.
func (section *CSSSection) StartLine() uint {
	var arg0 *C.GtkCssSection

	arg0 = (*C.GtkCssSection)(section.Native())

	ret := C.gtk_css_section_get_start_line(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// StartPosition returns the offset in bytes from the start of the current line
// returned via gtk_css_section_get_start_line().
func (section *CSSSection) StartPosition() uint {
	var arg0 *C.GtkCssSection

	arg0 = (*C.GtkCssSection)(section.Native())

	ret := C.gtk_css_section_get_start_position(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Ref increments the reference count on @section.
func (section *CSSSection) Ref() *CSSSection {
	var arg0 *C.GtkCssSection

	arg0 = (*C.GtkCssSection)(section.Native())

	ret := C.gtk_css_section_ref(arg0)

	var ret0 *CSSSection

	{
		ret0 = WrapCSSSection(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *CSSSection) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Unref decrements the reference count on @section, freeing the structure if
// the reference count reaches 0.
func (section *CSSSection) Unref() {
	var arg0 *C.GtkCssSection

	arg0 = (*C.GtkCssSection)(section.Native())

	C.gtk_css_section_unref(arg0)
}

type DialogPrivate struct {
	native C.GtkDialogPrivate
}

// WrapDialogPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDialogPrivate(ptr unsafe.Pointer) *DialogPrivate {
	if ptr == nil {
		return nil
	}

	return (*DialogPrivate)(ptr)
}

func marshalDialogPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDialogPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (d *DialogPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}

type EntryAccessiblePrivate struct {
	native C.GtkEntryAccessiblePrivate
}

// WrapEntryAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapEntryAccessiblePrivate(ptr unsafe.Pointer) *EntryAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*EntryAccessiblePrivate)(ptr)
}

func marshalEntryAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapEntryAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (e *EntryAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&e.native)
}

type EntryBufferPrivate struct {
	native C.GtkEntryBufferPrivate
}

// WrapEntryBufferPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapEntryBufferPrivate(ptr unsafe.Pointer) *EntryBufferPrivate {
	if ptr == nil {
		return nil
	}

	return (*EntryBufferPrivate)(ptr)
}

func marshalEntryBufferPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapEntryBufferPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (e *EntryBufferPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&e.native)
}

type EntryCompletionPrivate struct {
	native C.GtkEntryCompletionPrivate
}

// WrapEntryCompletionPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapEntryCompletionPrivate(ptr unsafe.Pointer) *EntryCompletionPrivate {
	if ptr == nil {
		return nil
	}

	return (*EntryCompletionPrivate)(ptr)
}

func marshalEntryCompletionPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapEntryCompletionPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (e *EntryCompletionPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&e.native)
}

type EntryPrivate struct {
	native C.GtkEntryPrivate
}

// WrapEntryPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapEntryPrivate(ptr unsafe.Pointer) *EntryPrivate {
	if ptr == nil {
		return nil
	}

	return (*EntryPrivate)(ptr)
}

func marshalEntryPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapEntryPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (e *EntryPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&e.native)
}

type EventBoxPrivate struct {
	native C.GtkEventBoxPrivate
}

// WrapEventBoxPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapEventBoxPrivate(ptr unsafe.Pointer) *EventBoxPrivate {
	if ptr == nil {
		return nil
	}

	return (*EventBoxPrivate)(ptr)
}

func marshalEventBoxPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapEventBoxPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (e *EventBoxPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&e.native)
}

type ExpanderAccessiblePrivate struct {
	native C.GtkExpanderAccessiblePrivate
}

// WrapExpanderAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapExpanderAccessiblePrivate(ptr unsafe.Pointer) *ExpanderAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*ExpanderAccessiblePrivate)(ptr)
}

func marshalExpanderAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapExpanderAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (e *ExpanderAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&e.native)
}

type ExpanderPrivate struct {
	native C.GtkExpanderPrivate
}

// WrapExpanderPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapExpanderPrivate(ptr unsafe.Pointer) *ExpanderPrivate {
	if ptr == nil {
		return nil
	}

	return (*ExpanderPrivate)(ptr)
}

func marshalExpanderPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapExpanderPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (e *ExpanderPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&e.native)
}

type FileChooserButtonPrivate struct {
	native C.GtkFileChooserButtonPrivate
}

// WrapFileChooserButtonPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFileChooserButtonPrivate(ptr unsafe.Pointer) *FileChooserButtonPrivate {
	if ptr == nil {
		return nil
	}

	return (*FileChooserButtonPrivate)(ptr)
}

func marshalFileChooserButtonPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapFileChooserButtonPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (f *FileChooserButtonPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&f.native)
}

type FileChooserDialogPrivate struct {
	native C.GtkFileChooserDialogPrivate
}

// WrapFileChooserDialogPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFileChooserDialogPrivate(ptr unsafe.Pointer) *FileChooserDialogPrivate {
	if ptr == nil {
		return nil
	}

	return (*FileChooserDialogPrivate)(ptr)
}

func marshalFileChooserDialogPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapFileChooserDialogPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (f *FileChooserDialogPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&f.native)
}

type FileChooserWidgetPrivate struct {
	native C.GtkFileChooserWidgetPrivate
}

// WrapFileChooserWidgetPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFileChooserWidgetPrivate(ptr unsafe.Pointer) *FileChooserWidgetPrivate {
	if ptr == nil {
		return nil
	}

	return (*FileChooserWidgetPrivate)(ptr)
}

func marshalFileChooserWidgetPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapFileChooserWidgetPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (f *FileChooserWidgetPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&f.native)
}

// FileFilterInfo: a FileFilterInfo-struct is used to pass information about the
// tested file to gtk_file_filter_filter().
type FileFilterInfo struct {
	native C.GtkFileFilterInfo
}

// WrapFileFilterInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFileFilterInfo(ptr unsafe.Pointer) *FileFilterInfo {
	if ptr == nil {
		return nil
	}

	return (*FileFilterInfo)(ptr)
}

func marshalFileFilterInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapFileFilterInfo(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (f *FileFilterInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&f.native)
}

// Contains gets the field inside the struct.
func (f *FileFilterInfo) Contains() FileFilterFlags {
	var ret FileFilterFlags
	ret = FileFilterFlags(f.native.contains)
	return ret
}

// Filename gets the field inside the struct.
func (f *FileFilterInfo) Filename() string {
	var ret string
	ret = C.GoString(f.native.filename)
	return ret
}

// URI gets the field inside the struct.
func (f *FileFilterInfo) URI() string {
	var ret string
	ret = C.GoString(f.native.uri)
	return ret
}

// DisplayName gets the field inside the struct.
func (f *FileFilterInfo) DisplayName() string {
	var ret string
	ret = C.GoString(f.native.display_name)
	return ret
}

// MIMEType gets the field inside the struct.
func (f *FileFilterInfo) MIMEType() string {
	var ret string
	ret = C.GoString(f.native.mime_type)
	return ret
}

type FixedChild struct {
	native C.GtkFixedChild
}

// WrapFixedChild wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFixedChild(ptr unsafe.Pointer) *FixedChild {
	if ptr == nil {
		return nil
	}

	return (*FixedChild)(ptr)
}

func marshalFixedChild(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapFixedChild(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (f *FixedChild) Native() unsafe.Pointer {
	return unsafe.Pointer(&f.native)
}

// Widget gets the field inside the struct.
func (f *FixedChild) Widget() Widget {
	var ret Widget
	ret = gextras.CastObject(externglib.Take(unsafe.Pointer(f.native.widget.Native()))).(Widget)
	return ret
}

// X gets the field inside the struct.
func (f *FixedChild) X() int {
	var ret int
	ret = int(f.native.x)
	return ret
}

// Y gets the field inside the struct.
func (f *FixedChild) Y() int {
	var ret int
	ret = int(f.native.y)
	return ret
}

type FixedPrivate struct {
	native C.GtkFixedPrivate
}

// WrapFixedPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFixedPrivate(ptr unsafe.Pointer) *FixedPrivate {
	if ptr == nil {
		return nil
	}

	return (*FixedPrivate)(ptr)
}

func marshalFixedPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapFixedPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (f *FixedPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&f.native)
}

type FlowBoxAccessiblePrivate struct {
	native C.GtkFlowBoxAccessiblePrivate
}

// WrapFlowBoxAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFlowBoxAccessiblePrivate(ptr unsafe.Pointer) *FlowBoxAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*FlowBoxAccessiblePrivate)(ptr)
}

func marshalFlowBoxAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapFlowBoxAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (f *FlowBoxAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&f.native)
}

type FontButtonPrivate struct {
	native C.GtkFontButtonPrivate
}

// WrapFontButtonPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFontButtonPrivate(ptr unsafe.Pointer) *FontButtonPrivate {
	if ptr == nil {
		return nil
	}

	return (*FontButtonPrivate)(ptr)
}

func marshalFontButtonPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapFontButtonPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (f *FontButtonPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&f.native)
}

type FontChooserDialogPrivate struct {
	native C.GtkFontChooserDialogPrivate
}

// WrapFontChooserDialogPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFontChooserDialogPrivate(ptr unsafe.Pointer) *FontChooserDialogPrivate {
	if ptr == nil {
		return nil
	}

	return (*FontChooserDialogPrivate)(ptr)
}

func marshalFontChooserDialogPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapFontChooserDialogPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (f *FontChooserDialogPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&f.native)
}

type FontChooserWidgetPrivate struct {
	native C.GtkFontChooserWidgetPrivate
}

// WrapFontChooserWidgetPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFontChooserWidgetPrivate(ptr unsafe.Pointer) *FontChooserWidgetPrivate {
	if ptr == nil {
		return nil
	}

	return (*FontChooserWidgetPrivate)(ptr)
}

func marshalFontChooserWidgetPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapFontChooserWidgetPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (f *FontChooserWidgetPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&f.native)
}

type FontSelectionDialogPrivate struct {
	native C.GtkFontSelectionDialogPrivate
}

// WrapFontSelectionDialogPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFontSelectionDialogPrivate(ptr unsafe.Pointer) *FontSelectionDialogPrivate {
	if ptr == nil {
		return nil
	}

	return (*FontSelectionDialogPrivate)(ptr)
}

func marshalFontSelectionDialogPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapFontSelectionDialogPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (f *FontSelectionDialogPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&f.native)
}

type FontSelectionPrivate struct {
	native C.GtkFontSelectionPrivate
}

// WrapFontSelectionPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFontSelectionPrivate(ptr unsafe.Pointer) *FontSelectionPrivate {
	if ptr == nil {
		return nil
	}

	return (*FontSelectionPrivate)(ptr)
}

func marshalFontSelectionPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapFontSelectionPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (f *FontSelectionPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&f.native)
}

type FrameAccessiblePrivate struct {
	native C.GtkFrameAccessiblePrivate
}

// WrapFrameAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFrameAccessiblePrivate(ptr unsafe.Pointer) *FrameAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*FrameAccessiblePrivate)(ptr)
}

func marshalFrameAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapFrameAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (f *FrameAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&f.native)
}

type FramePrivate struct {
	native C.GtkFramePrivate
}

// WrapFramePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFramePrivate(ptr unsafe.Pointer) *FramePrivate {
	if ptr == nil {
		return nil
	}

	return (*FramePrivate)(ptr)
}

func marshalFramePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapFramePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (f *FramePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&f.native)
}

// Gradient: gtkGradient is a boxed type that represents a gradient. It is the
// result of parsing a [gradient expression][gtkcssprovider-gradients]. To
// obtain the gradient represented by a GtkGradient, it has to be resolved with
// gtk_gradient_resolve(), which replaces all symbolic color references by the
// colors they refer to (in a given context) and constructs a #cairo_pattern_t
// value.
//
// It is not normally necessary to deal directly with Gradients, since they are
// mostly used behind the scenes by StyleContext and CssProvider.
//
// Gradient is deprecated. It was used internally by GTK’s CSS engine to
// represent gradients. As its handling is not conforming to modern web
// standards, it is not used anymore. If you want to use gradients in your own
// code, please use Cairo directly.
type Gradient struct {
	native C.GtkGradient
}

// WrapGradient wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapGradient(ptr unsafe.Pointer) *Gradient {
	if ptr == nil {
		return nil
	}

	return (*Gradient)(ptr)
}

func marshalGradient(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapGradient(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (g *Gradient) Native() unsafe.Pointer {
	return unsafe.Pointer(&g.native)
}

// NewGradientLinear constructs a struct Gradient.
func NewGradientLinear(x0 float64, y0 float64, x1 float64, y1 float64) *Gradient {
	var arg1 C.gdouble
	var arg2 C.gdouble
	var arg3 C.gdouble
	var arg4 C.gdouble

	arg1 = C.gdouble(x0)
	arg2 = C.gdouble(y0)
	arg3 = C.gdouble(x1)
	arg4 = C.gdouble(y1)

	ret := C.gtk_gradient_new_linear(arg1, arg2, arg3, arg4)

	var ret0 *Gradient

	{
		ret0 = WrapGradient(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Gradient) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewGradientRadial constructs a struct Gradient.
func NewGradientRadial(x0 float64, y0 float64, radius0 float64, x1 float64, y1 float64, radius1 float64) *Gradient {
	var arg1 C.gdouble
	var arg2 C.gdouble
	var arg3 C.gdouble
	var arg4 C.gdouble
	var arg5 C.gdouble
	var arg6 C.gdouble

	arg1 = C.gdouble(x0)
	arg2 = C.gdouble(y0)
	arg3 = C.gdouble(radius0)
	arg4 = C.gdouble(x1)
	arg5 = C.gdouble(y1)
	arg6 = C.gdouble(radius1)

	ret := C.gtk_gradient_new_radial(arg1, arg2, arg3, arg4, arg5, arg6)

	var ret0 *Gradient

	{
		ret0 = WrapGradient(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Gradient) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// AddColorStop adds a stop color to @gradient.
func (gradient *Gradient) AddColorStop(offset float64, color *SymbolicColor) {
	var arg0 *C.GtkGradient
	var arg1 C.gdouble
	var arg2 *C.GtkSymbolicColor

	arg0 = (*C.GtkGradient)(gradient.Native())
	arg1 = C.gdouble(offset)
	arg2 = (*C.GtkSymbolicColor)(color.Native())

	C.gtk_gradient_add_color_stop(arg0, arg1, arg2)
}

// Ref increases the reference count of @gradient.
func (gradient *Gradient) Ref() *Gradient {
	var arg0 *C.GtkGradient

	arg0 = (*C.GtkGradient)(gradient.Native())

	ret := C.gtk_gradient_ref(arg0)

	var ret0 *Gradient

	{
		ret0 = WrapGradient(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Gradient) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Resolve: if @gradient is resolvable, @resolved_gradient will be filled in
// with the resolved gradient as a cairo_pattern_t, and true will be returned.
// Generally, if @gradient can’t be resolved, it is due to it being defined on
// top of a named color that doesn't exist in @props.
func (gradient *Gradient) Resolve(props StyleProperties) (resolvedGradient *cairo.Pattern, ok bool) {
	var arg0 *C.GtkGradient
	var arg1 *C.GtkStyleProperties
	var arg2 **C.cairo_pattern_t // out

	arg0 = (*C.GtkGradient)(gradient.Native())
	arg1 = (*C.GtkStyleProperties)(props.Native())

	ret := C.gtk_gradient_resolve(arg0, arg1, &arg2)

	var ret0 **cairo.Pattern
	var ret1 bool

	{
		ret0 = cairo.WrapPattern(unsafe.Pointer(arg2))
		runtime.SetFinalizer(ret0, func(v **cairo.Pattern) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

func (gradient *Gradient) ResolveForContext(context StyleContext) *cairo.Pattern {
	var arg0 *C.GtkGradient
	var arg1 *C.GtkStyleContext

	arg0 = (*C.GtkGradient)(gradient.Native())
	arg1 = (*C.GtkStyleContext)(context.Native())

	ret := C.gtk_gradient_resolve_for_context(arg0, arg1)

	var ret0 *cairo.Pattern

	{
		ret0 = cairo.WrapPattern(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *cairo.Pattern) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// String creates a string representation for @gradient that is suitable for
// using in GTK CSS files.
func (gradient *Gradient) String() string {
	var arg0 *C.GtkGradient

	arg0 = (*C.GtkGradient)(gradient.Native())

	ret := C.gtk_gradient_to_string(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Unref decreases the reference count of @gradient, freeing its memory if the
// reference count reaches 0.
func (gradient *Gradient) Unref() {
	var arg0 *C.GtkGradient

	arg0 = (*C.GtkGradient)(gradient.Native())

	C.gtk_gradient_unref(arg0)
}

type GridPrivate struct {
	native C.GtkGridPrivate
}

// WrapGridPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapGridPrivate(ptr unsafe.Pointer) *GridPrivate {
	if ptr == nil {
		return nil
	}

	return (*GridPrivate)(ptr)
}

func marshalGridPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapGridPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (g *GridPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&g.native)
}

type HSVPrivate struct {
	native C.GtkHSVPrivate
}

// WrapHSVPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapHSVPrivate(ptr unsafe.Pointer) *HSVPrivate {
	if ptr == nil {
		return nil
	}

	return (*HSVPrivate)(ptr)
}

func marshalHSVPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapHSVPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (h *HSVPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&h.native)
}

type HandleBoxPrivate struct {
	native C.GtkHandleBoxPrivate
}

// WrapHandleBoxPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapHandleBoxPrivate(ptr unsafe.Pointer) *HandleBoxPrivate {
	if ptr == nil {
		return nil
	}

	return (*HandleBoxPrivate)(ptr)
}

func marshalHandleBoxPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapHandleBoxPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (h *HandleBoxPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&h.native)
}

type HeaderBarAccessiblePrivate struct {
	native C.GtkHeaderBarAccessiblePrivate
}

// WrapHeaderBarAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapHeaderBarAccessiblePrivate(ptr unsafe.Pointer) *HeaderBarAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*HeaderBarAccessiblePrivate)(ptr)
}

func marshalHeaderBarAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapHeaderBarAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (h *HeaderBarAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&h.native)
}

type HeaderBarPrivate struct {
	native C.GtkHeaderBarPrivate
}

// WrapHeaderBarPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapHeaderBarPrivate(ptr unsafe.Pointer) *HeaderBarPrivate {
	if ptr == nil {
		return nil
	}

	return (*HeaderBarPrivate)(ptr)
}

func marshalHeaderBarPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapHeaderBarPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (h *HeaderBarPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&h.native)
}

// IMContextInfo: bookkeeping information about a loadable input method.
type IMContextInfo struct {
	native C.GtkIMContextInfo
}

// WrapIMContextInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapIMContextInfo(ptr unsafe.Pointer) *IMContextInfo {
	if ptr == nil {
		return nil
	}

	return (*IMContextInfo)(ptr)
}

func marshalIMContextInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapIMContextInfo(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (i *IMContextInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

// ContextID gets the field inside the struct.
func (i *IMContextInfo) ContextID() string {
	var ret string
	ret = C.GoString(i.native.context_id)
	return ret
}

// ContextName gets the field inside the struct.
func (i *IMContextInfo) ContextName() string {
	var ret string
	ret = C.GoString(i.native.context_name)
	return ret
}

// Domain gets the field inside the struct.
func (i *IMContextInfo) Domain() string {
	var ret string
	ret = C.GoString(i.native.domain)
	return ret
}

// DomainDirname gets the field inside the struct.
func (i *IMContextInfo) DomainDirname() string {
	var ret string
	ret = C.GoString(i.native.domain_dirname)
	return ret
}

// DefaultLocales gets the field inside the struct.
func (i *IMContextInfo) DefaultLocales() string {
	var ret string
	ret = C.GoString(i.native.default_locales)
	return ret
}

type IMContextSimplePrivate struct {
	native C.GtkIMContextSimplePrivate
}

// WrapIMContextSimplePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapIMContextSimplePrivate(ptr unsafe.Pointer) *IMContextSimplePrivate {
	if ptr == nil {
		return nil
	}

	return (*IMContextSimplePrivate)(ptr)
}

func marshalIMContextSimplePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapIMContextSimplePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (i *IMContextSimplePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

type IMMulticontextPrivate struct {
	native C.GtkIMMulticontextPrivate
}

// WrapIMMulticontextPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapIMMulticontextPrivate(ptr unsafe.Pointer) *IMMulticontextPrivate {
	if ptr == nil {
		return nil
	}

	return (*IMMulticontextPrivate)(ptr)
}

func marshalIMMulticontextPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapIMMulticontextPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (i *IMMulticontextPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

type IconFactoryPrivate struct {
	native C.GtkIconFactoryPrivate
}

// WrapIconFactoryPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapIconFactoryPrivate(ptr unsafe.Pointer) *IconFactoryPrivate {
	if ptr == nil {
		return nil
	}

	return (*IconFactoryPrivate)(ptr)
}

func marshalIconFactoryPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapIconFactoryPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (i *IconFactoryPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

type IconSet struct {
	native C.GtkIconSet
}

// WrapIconSet wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapIconSet(ptr unsafe.Pointer) *IconSet {
	if ptr == nil {
		return nil
	}

	return (*IconSet)(ptr)
}

func marshalIconSet(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapIconSet(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (i *IconSet) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

// NewIconSet constructs a struct IconSet.
func NewIconSet() *IconSet {

	ret := C.gtk_icon_set_new()

	var ret0 *IconSet

	{
		ret0 = WrapIconSet(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *IconSet) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewIconSetFromPixbuf constructs a struct IconSet.
func NewIconSetFromPixbuf(pixbuf gdkpixbuf.Pixbuf) *IconSet {
	var arg1 *C.GdkPixbuf

	arg1 = (*C.GdkPixbuf)(pixbuf.Native())

	ret := C.gtk_icon_set_new_from_pixbuf(arg1)

	var ret0 *IconSet

	{
		ret0 = WrapIconSet(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *IconSet) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// AddSource: icon sets have a list of IconSource, which they use as base icons
// for rendering icons in different states and sizes. Icons are scaled, made to
// look insensitive, etc. in gtk_icon_set_render_icon(), but IconSet needs base
// images to work with. The base images and when to use them are described by a
// IconSource.
//
// This function copies @source, so you can reuse the same source immediately
// without affecting the icon set.
//
// An example of when you’d use this function: a web browser’s "Back to Previous
// Page" icon might point in a different direction in Hebrew and in English; it
// might look different when insensitive; and it might change size depending on
// toolbar mode (small/large icons). So a single icon set would contain all
// those variants of the icon, and you might add a separate source for each one.
//
// You should nearly always add a “default” icon source with all fields
// wildcarded, which will be used as a fallback if no more specific source
// matches. IconSet always prefers more specific icon sources to more generic
// icon sources. The order in which you add the sources to the icon set does not
// matter.
//
// gtk_icon_set_new_from_pixbuf() creates a new icon set with a default icon
// source based on the given pixbuf.
func (iconSet *IconSet) AddSource(source *IconSource) {
	var arg0 *C.GtkIconSet
	var arg1 *C.GtkIconSource

	arg0 = (*C.GtkIconSet)(iconSet.Native())
	arg1 = (*C.GtkIconSource)(source.Native())

	C.gtk_icon_set_add_source(arg0, arg1)
}

// Copy copies @icon_set by value.
func (iconSet *IconSet) Copy() *IconSet {
	var arg0 *C.GtkIconSet

	arg0 = (*C.GtkIconSet)(iconSet.Native())

	ret := C.gtk_icon_set_copy(arg0)

	var ret0 *IconSet

	{
		ret0 = WrapIconSet(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *IconSet) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Sizes obtains a list of icon sizes this icon set can render. The returned
// array must be freed with g_free().
func (iconSet *IconSet) Sizes() (sizes []int, nSizes int) {
	var arg0 *C.GtkIconSet
	var arg1 **C.GtkIconSize // out
	var arg2 *C.gint         // out

	arg0 = (*C.GtkIconSet)(iconSet.Native())

	C.gtk_icon_set_get_sizes(arg0, &arg1, &arg2)

	var ret0 []int
	var ret1 int

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret0))
		sliceHeader.Data = uintptr(unsafe.Pointer(arg1))
		sliceHeader.Len = arg2
		sliceHeader.Cap = arg2
		runtime.SetFinalizer(&arg1, func() {
			C.free(unsafe.Pointer(arg1))
		})
		defer runtime.KeepAlive(arg1)
	}

	ret1 = int(arg2)

	return ret0, ret1
}

// Ref increments the reference count on @icon_set.
func (iconSet *IconSet) Ref() *IconSet {
	var arg0 *C.GtkIconSet

	arg0 = (*C.GtkIconSet)(iconSet.Native())

	ret := C.gtk_icon_set_ref(arg0)

	var ret0 *IconSet

	{
		ret0 = WrapIconSet(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *IconSet) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// RenderIcon renders an icon using gtk_style_render_icon(). In most cases,
// gtk_widget_render_icon() is better, since it automatically provides most of
// the arguments from the current widget settings. This function never returns
// nil; if the icon can’t be rendered (perhaps because an image file fails to
// load), a default "missing image" icon will be returned instead.
func (iconSet *IconSet) RenderIcon(style Style, direction TextDirection, state StateType, size int, widget Widget, detail string) gdkpixbuf.Pixbuf {
	var arg0 *C.GtkIconSet
	var arg1 *C.GtkStyle
	var arg2 C.GtkTextDirection
	var arg3 C.GtkStateType
	var arg4 C.GtkIconSize
	var arg5 *C.GtkWidget
	var arg6 *C.gchar

	arg0 = (*C.GtkIconSet)(iconSet.Native())
	arg1 = (*C.GtkStyle)(style.Native())
	arg2 = (C.GtkTextDirection)(direction)
	arg3 = (C.GtkStateType)(state)
	arg4 = C.GtkIconSize(size)
	arg5 = (*C.GtkWidget)(widget.Native())
	arg6 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(arg6))

	ret := C.gtk_icon_set_render_icon(arg0, arg1, arg2, arg3, arg4, arg5, arg6)

	var ret0 gdkpixbuf.Pixbuf

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gdkpixbuf.Pixbuf)

	return ret0
}

// RenderIconPixbuf renders an icon using gtk_render_icon_pixbuf(). In most
// cases, gtk_widget_render_icon_pixbuf() is better, since it automatically
// provides most of the arguments from the current widget settings. This
// function never returns nil; if the icon can’t be rendered (perhaps because an
// image file fails to load), a default "missing image" icon will be returned
// instead.
func (iconSet *IconSet) RenderIconPixbuf(context StyleContext, size int) gdkpixbuf.Pixbuf {
	var arg0 *C.GtkIconSet
	var arg1 *C.GtkStyleContext
	var arg2 C.GtkIconSize

	arg0 = (*C.GtkIconSet)(iconSet.Native())
	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = C.GtkIconSize(size)

	ret := C.gtk_icon_set_render_icon_pixbuf(arg0, arg1, arg2)

	var ret0 gdkpixbuf.Pixbuf

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gdkpixbuf.Pixbuf)

	return ret0
}

// RenderIconSurface renders an icon using gtk_render_icon_pixbuf() and converts
// it to a cairo surface.
//
// This function never returns nil; if the icon can’t be rendered (perhaps
// because an image file fails to load), a default "missing image" icon will be
// returned instead.
func (iconSet *IconSet) RenderIconSurface(context StyleContext, size int, scale int, forWindow gdk.Window) *cairo.Surface {
	var arg0 *C.GtkIconSet
	var arg1 *C.GtkStyleContext
	var arg2 C.GtkIconSize
	var arg3 C.int
	var arg4 *C.GdkWindow

	arg0 = (*C.GtkIconSet)(iconSet.Native())
	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = C.GtkIconSize(size)
	arg3 = C.int(scale)
	arg4 = (*C.GdkWindow)(forWindow.Native())

	ret := C.gtk_icon_set_render_icon_surface(arg0, arg1, arg2, arg3, arg4)

	var ret0 *cairo.Surface

	{
		ret0 = cairo.WrapSurface(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *cairo.Surface) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Unref decrements the reference count on @icon_set, and frees memory if the
// reference count reaches 0.
func (iconSet *IconSet) Unref() {
	var arg0 *C.GtkIconSet

	arg0 = (*C.GtkIconSet)(iconSet.Native())

	C.gtk_icon_set_unref(arg0)
}

type IconSource struct {
	native C.GtkIconSource
}

// WrapIconSource wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapIconSource(ptr unsafe.Pointer) *IconSource {
	if ptr == nil {
		return nil
	}

	return (*IconSource)(ptr)
}

func marshalIconSource(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapIconSource(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (i *IconSource) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

// NewIconSource constructs a struct IconSource.
func NewIconSource() *IconSource {

	ret := C.gtk_icon_source_new()

	var ret0 *IconSource

	{
		ret0 = WrapIconSource(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *IconSource) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Copy creates a copy of @source; mostly useful for language bindings.
func (source *IconSource) Copy() *IconSource {
	var arg0 *C.GtkIconSource

	arg0 = (*C.GtkIconSource)(source.Native())

	ret := C.gtk_icon_source_copy(arg0)

	var ret0 *IconSource

	{
		ret0 = WrapIconSource(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *IconSource) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Free frees a dynamically-allocated icon source, along with its filename,
// size, and pixbuf fields if those are not nil.
func (source *IconSource) Free() {
	var arg0 *C.GtkIconSource

	arg0 = (*C.GtkIconSource)(source.Native())

	C.gtk_icon_source_free(arg0)
}

// Direction obtains the text direction this icon source applies to. The return
// value is only useful/meaningful if the text direction is not wildcarded.
func (source *IconSource) Direction() TextDirection {
	var arg0 *C.GtkIconSource

	arg0 = (*C.GtkIconSource)(source.Native())

	ret := C.gtk_icon_source_get_direction(arg0)

	var ret0 TextDirection

	ret0 = TextDirection(ret)

	return ret0
}

// DirectionWildcarded gets the value set by
// gtk_icon_source_set_direction_wildcarded().
func (source *IconSource) DirectionWildcarded() bool {
	var arg0 *C.GtkIconSource

	arg0 = (*C.GtkIconSource)(source.Native())

	ret := C.gtk_icon_source_get_direction_wildcarded(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Filename retrieves the source filename, or nil if none is set. The filename
// is not a copy, and should not be modified or expected to persist beyond the
// lifetime of the icon source.
func (source *IconSource) Filename() string {
	var arg0 *C.GtkIconSource

	arg0 = (*C.GtkIconSource)(source.Native())

	ret := C.gtk_icon_source_get_filename(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// IconName retrieves the source icon name, or nil if none is set. The icon_name
// is not a copy, and should not be modified or expected to persist beyond the
// lifetime of the icon source.
func (source *IconSource) IconName() string {
	var arg0 *C.GtkIconSource

	arg0 = (*C.GtkIconSource)(source.Native())

	ret := C.gtk_icon_source_get_icon_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Pixbuf retrieves the source pixbuf, or nil if none is set. In addition, if a
// filename source is in use, this function in some cases will return the pixbuf
// from loaded from the filename. This is, for example, true for the
// GtkIconSource passed to the Style render_icon() virtual function. The
// reference count on the pixbuf is not incremented.
func (source *IconSource) Pixbuf() gdkpixbuf.Pixbuf {
	var arg0 *C.GtkIconSource

	arg0 = (*C.GtkIconSource)(source.Native())

	ret := C.gtk_icon_source_get_pixbuf(arg0)

	var ret0 gdkpixbuf.Pixbuf

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gdkpixbuf.Pixbuf)

	return ret0
}

// Size obtains the icon size this source applies to. The return value is only
// useful/meaningful if the icon size is not wildcarded.
func (source *IconSource) Size() int {
	var arg0 *C.GtkIconSource

	arg0 = (*C.GtkIconSource)(source.Native())

	ret := C.gtk_icon_source_get_size(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// SizeWildcarded gets the value set by gtk_icon_source_set_size_wildcarded().
func (source *IconSource) SizeWildcarded() bool {
	var arg0 *C.GtkIconSource

	arg0 = (*C.GtkIconSource)(source.Native())

	ret := C.gtk_icon_source_get_size_wildcarded(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// State obtains the widget state this icon source applies to. The return value
// is only useful/meaningful if the widget state is not wildcarded.
func (source *IconSource) State() StateType {
	var arg0 *C.GtkIconSource

	arg0 = (*C.GtkIconSource)(source.Native())

	ret := C.gtk_icon_source_get_state(arg0)

	var ret0 StateType

	ret0 = StateType(ret)

	return ret0
}

// StateWildcarded gets the value set by gtk_icon_source_set_state_wildcarded().
func (source *IconSource) StateWildcarded() bool {
	var arg0 *C.GtkIconSource

	arg0 = (*C.GtkIconSource)(source.Native())

	ret := C.gtk_icon_source_get_state_wildcarded(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SetDirection sets the text direction this icon source is intended to be used
// with.
//
// Setting the text direction on an icon source makes no difference if the text
// direction is wildcarded. Therefore, you should usually call
// gtk_icon_source_set_direction_wildcarded() to un-wildcard it in addition to
// calling this function.
func (source *IconSource) SetDirection(direction TextDirection) {
	var arg0 *C.GtkIconSource
	var arg1 C.GtkTextDirection

	arg0 = (*C.GtkIconSource)(source.Native())
	arg1 = (C.GtkTextDirection)(direction)

	C.gtk_icon_source_set_direction(arg0, arg1)
}

// SetDirectionWildcarded: if the text direction is wildcarded, this source can
// be used as the base image for an icon in any TextDirection. If the text
// direction is not wildcarded, then the text direction the icon source applies
// to should be set with gtk_icon_source_set_direction(), and the icon source
// will only be used with that text direction.
//
// IconSet prefers non-wildcarded sources (exact matches) over wildcarded
// sources, and will use an exact match when possible.
func (source *IconSource) SetDirectionWildcarded(setting bool) {
	var arg0 *C.GtkIconSource
	var arg1 C.gboolean

	arg0 = (*C.GtkIconSource)(source.Native())
	if setting {
		arg1 = C.TRUE
	}

	C.gtk_icon_source_set_direction_wildcarded(arg0, arg1)
}

// SetFilename sets the name of an image file to use as a base image when
// creating icon variants for IconSet. The filename must be absolute.
func (source *IconSource) SetFilename(filename string) {
	var arg0 *C.GtkIconSource
	var arg1 *C.gchar

	arg0 = (*C.GtkIconSource)(source.Native())
	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_icon_source_set_filename(arg0, arg1)
}

// SetIconName sets the name of an icon to look up in the current icon theme to
// use as a base image when creating icon variants for IconSet.
func (source *IconSource) SetIconName(iconName string) {
	var arg0 *C.GtkIconSource
	var arg1 *C.gchar

	arg0 = (*C.GtkIconSource)(source.Native())
	arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_icon_source_set_icon_name(arg0, arg1)
}

// SetPixbuf sets a pixbuf to use as a base image when creating icon variants
// for IconSet.
func (source *IconSource) SetPixbuf(pixbuf gdkpixbuf.Pixbuf) {
	var arg0 *C.GtkIconSource
	var arg1 *C.GdkPixbuf

	arg0 = (*C.GtkIconSource)(source.Native())
	arg1 = (*C.GdkPixbuf)(pixbuf.Native())

	C.gtk_icon_source_set_pixbuf(arg0, arg1)
}

// SetSize sets the icon size this icon source is intended to be used with.
//
// Setting the icon size on an icon source makes no difference if the size is
// wildcarded. Therefore, you should usually call
// gtk_icon_source_set_size_wildcarded() to un-wildcard it in addition to
// calling this function.
func (source *IconSource) SetSize(size int) {
	var arg0 *C.GtkIconSource
	var arg1 C.GtkIconSize

	arg0 = (*C.GtkIconSource)(source.Native())
	arg1 = C.GtkIconSize(size)

	C.gtk_icon_source_set_size(arg0, arg1)
}

// SetSizeWildcarded: if the icon size is wildcarded, this source can be used as
// the base image for an icon of any size. If the size is not wildcarded, then
// the size the source applies to should be set with gtk_icon_source_set_size()
// and the icon source will only be used with that specific size.
//
// IconSet prefers non-wildcarded sources (exact matches) over wildcarded
// sources, and will use an exact match when possible.
//
// IconSet will normally scale wildcarded source images to produce an
// appropriate icon at a given size, but will not change the size of source
// images that match exactly.
func (source *IconSource) SetSizeWildcarded(setting bool) {
	var arg0 *C.GtkIconSource
	var arg1 C.gboolean

	arg0 = (*C.GtkIconSource)(source.Native())
	if setting {
		arg1 = C.TRUE
	}

	C.gtk_icon_source_set_size_wildcarded(arg0, arg1)
}

// SetState sets the widget state this icon source is intended to be used with.
//
// Setting the widget state on an icon source makes no difference if the state
// is wildcarded. Therefore, you should usually call
// gtk_icon_source_set_state_wildcarded() to un-wildcard it in addition to
// calling this function.
func (source *IconSource) SetState(state StateType) {
	var arg0 *C.GtkIconSource
	var arg1 C.GtkStateType

	arg0 = (*C.GtkIconSource)(source.Native())
	arg1 = (C.GtkStateType)(state)

	C.gtk_icon_source_set_state(arg0, arg1)
}

// SetStateWildcarded: if the widget state is wildcarded, this source can be
// used as the base image for an icon in any StateType. If the widget state is
// not wildcarded, then the state the source applies to should be set with
// gtk_icon_source_set_state() and the icon source will only be used with that
// specific state.
//
// IconSet prefers non-wildcarded sources (exact matches) over wildcarded
// sources, and will use an exact match when possible.
//
// IconSet will normally transform wildcarded source images to produce an
// appropriate icon for a given state, for example lightening an image on
// prelight, but will not modify source images that match exactly.
func (source *IconSource) SetStateWildcarded(setting bool) {
	var arg0 *C.GtkIconSource
	var arg1 C.gboolean

	arg0 = (*C.GtkIconSource)(source.Native())
	if setting {
		arg1 = C.TRUE
	}

	C.gtk_icon_source_set_state_wildcarded(arg0, arg1)
}

type IconThemePrivate struct {
	native C.GtkIconThemePrivate
}

// WrapIconThemePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapIconThemePrivate(ptr unsafe.Pointer) *IconThemePrivate {
	if ptr == nil {
		return nil
	}

	return (*IconThemePrivate)(ptr)
}

func marshalIconThemePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapIconThemePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (i *IconThemePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

type IconViewAccessiblePrivate struct {
	native C.GtkIconViewAccessiblePrivate
}

// WrapIconViewAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapIconViewAccessiblePrivate(ptr unsafe.Pointer) *IconViewAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*IconViewAccessiblePrivate)(ptr)
}

func marshalIconViewAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapIconViewAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (i *IconViewAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

type IconViewPrivate struct {
	native C.GtkIconViewPrivate
}

// WrapIconViewPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapIconViewPrivate(ptr unsafe.Pointer) *IconViewPrivate {
	if ptr == nil {
		return nil
	}

	return (*IconViewPrivate)(ptr)
}

func marshalIconViewPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapIconViewPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (i *IconViewPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

type ImageAccessiblePrivate struct {
	native C.GtkImageAccessiblePrivate
}

// WrapImageAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapImageAccessiblePrivate(ptr unsafe.Pointer) *ImageAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*ImageAccessiblePrivate)(ptr)
}

func marshalImageAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapImageAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (i *ImageAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

type ImageCellAccessiblePrivate struct {
	native C.GtkImageCellAccessiblePrivate
}

// WrapImageCellAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapImageCellAccessiblePrivate(ptr unsafe.Pointer) *ImageCellAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*ImageCellAccessiblePrivate)(ptr)
}

func marshalImageCellAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapImageCellAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (i *ImageCellAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

type ImageMenuItemPrivate struct {
	native C.GtkImageMenuItemPrivate
}

// WrapImageMenuItemPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapImageMenuItemPrivate(ptr unsafe.Pointer) *ImageMenuItemPrivate {
	if ptr == nil {
		return nil
	}

	return (*ImageMenuItemPrivate)(ptr)
}

func marshalImageMenuItemPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapImageMenuItemPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (i *ImageMenuItemPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

type ImagePrivate struct {
	native C.GtkImagePrivate
}

// WrapImagePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapImagePrivate(ptr unsafe.Pointer) *ImagePrivate {
	if ptr == nil {
		return nil
	}

	return (*ImagePrivate)(ptr)
}

func marshalImagePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapImagePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (i *ImagePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

type InfoBarPrivate struct {
	native C.GtkInfoBarPrivate
}

// WrapInfoBarPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapInfoBarPrivate(ptr unsafe.Pointer) *InfoBarPrivate {
	if ptr == nil {
		return nil
	}

	return (*InfoBarPrivate)(ptr)
}

func marshalInfoBarPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapInfoBarPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (i *InfoBarPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

type InvisiblePrivate struct {
	native C.GtkInvisiblePrivate
}

// WrapInvisiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapInvisiblePrivate(ptr unsafe.Pointer) *InvisiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*InvisiblePrivate)(ptr)
}

func marshalInvisiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapInvisiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (i *InvisiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

type LabelAccessiblePrivate struct {
	native C.GtkLabelAccessiblePrivate
}

// WrapLabelAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapLabelAccessiblePrivate(ptr unsafe.Pointer) *LabelAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*LabelAccessiblePrivate)(ptr)
}

func marshalLabelAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapLabelAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (l *LabelAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&l.native)
}

type LabelPrivate struct {
	native C.GtkLabelPrivate
}

// WrapLabelPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapLabelPrivate(ptr unsafe.Pointer) *LabelPrivate {
	if ptr == nil {
		return nil
	}

	return (*LabelPrivate)(ptr)
}

func marshalLabelPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapLabelPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (l *LabelPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&l.native)
}

type LabelSelectionInfo struct {
	native C.GtkLabelSelectionInfo
}

// WrapLabelSelectionInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapLabelSelectionInfo(ptr unsafe.Pointer) *LabelSelectionInfo {
	if ptr == nil {
		return nil
	}

	return (*LabelSelectionInfo)(ptr)
}

func marshalLabelSelectionInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapLabelSelectionInfo(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (l *LabelSelectionInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&l.native)
}

type LayoutPrivate struct {
	native C.GtkLayoutPrivate
}

// WrapLayoutPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapLayoutPrivate(ptr unsafe.Pointer) *LayoutPrivate {
	if ptr == nil {
		return nil
	}

	return (*LayoutPrivate)(ptr)
}

func marshalLayoutPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapLayoutPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (l *LayoutPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&l.native)
}

type LevelBarAccessiblePrivate struct {
	native C.GtkLevelBarAccessiblePrivate
}

// WrapLevelBarAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapLevelBarAccessiblePrivate(ptr unsafe.Pointer) *LevelBarAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*LevelBarAccessiblePrivate)(ptr)
}

func marshalLevelBarAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapLevelBarAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (l *LevelBarAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&l.native)
}

type LevelBarPrivate struct {
	native C.GtkLevelBarPrivate
}

// WrapLevelBarPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapLevelBarPrivate(ptr unsafe.Pointer) *LevelBarPrivate {
	if ptr == nil {
		return nil
	}

	return (*LevelBarPrivate)(ptr)
}

func marshalLevelBarPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapLevelBarPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (l *LevelBarPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&l.native)
}

type LinkButtonAccessiblePrivate struct {
	native C.GtkLinkButtonAccessiblePrivate
}

// WrapLinkButtonAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapLinkButtonAccessiblePrivate(ptr unsafe.Pointer) *LinkButtonAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*LinkButtonAccessiblePrivate)(ptr)
}

func marshalLinkButtonAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapLinkButtonAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (l *LinkButtonAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&l.native)
}

type LinkButtonPrivate struct {
	native C.GtkLinkButtonPrivate
}

// WrapLinkButtonPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapLinkButtonPrivate(ptr unsafe.Pointer) *LinkButtonPrivate {
	if ptr == nil {
		return nil
	}

	return (*LinkButtonPrivate)(ptr)
}

func marshalLinkButtonPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapLinkButtonPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (l *LinkButtonPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&l.native)
}

type ListBoxAccessiblePrivate struct {
	native C.GtkListBoxAccessiblePrivate
}

// WrapListBoxAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapListBoxAccessiblePrivate(ptr unsafe.Pointer) *ListBoxAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*ListBoxAccessiblePrivate)(ptr)
}

func marshalListBoxAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapListBoxAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (l *ListBoxAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&l.native)
}

type ListStorePrivate struct {
	native C.GtkListStorePrivate
}

// WrapListStorePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapListStorePrivate(ptr unsafe.Pointer) *ListStorePrivate {
	if ptr == nil {
		return nil
	}

	return (*ListStorePrivate)(ptr)
}

func marshalListStorePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapListStorePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (l *ListStorePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&l.native)
}

type LockButtonAccessiblePrivate struct {
	native C.GtkLockButtonAccessiblePrivate
}

// WrapLockButtonAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapLockButtonAccessiblePrivate(ptr unsafe.Pointer) *LockButtonAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*LockButtonAccessiblePrivate)(ptr)
}

func marshalLockButtonAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapLockButtonAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (l *LockButtonAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&l.native)
}

type LockButtonPrivate struct {
	native C.GtkLockButtonPrivate
}

// WrapLockButtonPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapLockButtonPrivate(ptr unsafe.Pointer) *LockButtonPrivate {
	if ptr == nil {
		return nil
	}

	return (*LockButtonPrivate)(ptr)
}

func marshalLockButtonPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapLockButtonPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (l *LockButtonPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&l.native)
}

type MenuAccessiblePrivate struct {
	native C.GtkMenuAccessiblePrivate
}

// WrapMenuAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMenuAccessiblePrivate(ptr unsafe.Pointer) *MenuAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*MenuAccessiblePrivate)(ptr)
}

func marshalMenuAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapMenuAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (m *MenuAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&m.native)
}

type MenuBarPrivate struct {
	native C.GtkMenuBarPrivate
}

// WrapMenuBarPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMenuBarPrivate(ptr unsafe.Pointer) *MenuBarPrivate {
	if ptr == nil {
		return nil
	}

	return (*MenuBarPrivate)(ptr)
}

func marshalMenuBarPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapMenuBarPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (m *MenuBarPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&m.native)
}

type MenuButtonAccessiblePrivate struct {
	native C.GtkMenuButtonAccessiblePrivate
}

// WrapMenuButtonAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMenuButtonAccessiblePrivate(ptr unsafe.Pointer) *MenuButtonAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*MenuButtonAccessiblePrivate)(ptr)
}

func marshalMenuButtonAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapMenuButtonAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (m *MenuButtonAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&m.native)
}

type MenuButtonPrivate struct {
	native C.GtkMenuButtonPrivate
}

// WrapMenuButtonPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMenuButtonPrivate(ptr unsafe.Pointer) *MenuButtonPrivate {
	if ptr == nil {
		return nil
	}

	return (*MenuButtonPrivate)(ptr)
}

func marshalMenuButtonPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapMenuButtonPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (m *MenuButtonPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&m.native)
}

type MenuItemAccessiblePrivate struct {
	native C.GtkMenuItemAccessiblePrivate
}

// WrapMenuItemAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMenuItemAccessiblePrivate(ptr unsafe.Pointer) *MenuItemAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*MenuItemAccessiblePrivate)(ptr)
}

func marshalMenuItemAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapMenuItemAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (m *MenuItemAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&m.native)
}

type MenuItemPrivate struct {
	native C.GtkMenuItemPrivate
}

// WrapMenuItemPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMenuItemPrivate(ptr unsafe.Pointer) *MenuItemPrivate {
	if ptr == nil {
		return nil
	}

	return (*MenuItemPrivate)(ptr)
}

func marshalMenuItemPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapMenuItemPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (m *MenuItemPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&m.native)
}

type MenuPrivate struct {
	native C.GtkMenuPrivate
}

// WrapMenuPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMenuPrivate(ptr unsafe.Pointer) *MenuPrivate {
	if ptr == nil {
		return nil
	}

	return (*MenuPrivate)(ptr)
}

func marshalMenuPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapMenuPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (m *MenuPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&m.native)
}

type MenuShellAccessiblePrivate struct {
	native C.GtkMenuShellAccessiblePrivate
}

// WrapMenuShellAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMenuShellAccessiblePrivate(ptr unsafe.Pointer) *MenuShellAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*MenuShellAccessiblePrivate)(ptr)
}

func marshalMenuShellAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapMenuShellAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (m *MenuShellAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&m.native)
}

type MenuShellPrivate struct {
	native C.GtkMenuShellPrivate
}

// WrapMenuShellPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMenuShellPrivate(ptr unsafe.Pointer) *MenuShellPrivate {
	if ptr == nil {
		return nil
	}

	return (*MenuShellPrivate)(ptr)
}

func marshalMenuShellPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapMenuShellPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (m *MenuShellPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&m.native)
}

type MenuToolButtonPrivate struct {
	native C.GtkMenuToolButtonPrivate
}

// WrapMenuToolButtonPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMenuToolButtonPrivate(ptr unsafe.Pointer) *MenuToolButtonPrivate {
	if ptr == nil {
		return nil
	}

	return (*MenuToolButtonPrivate)(ptr)
}

func marshalMenuToolButtonPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapMenuToolButtonPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (m *MenuToolButtonPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&m.native)
}

type MessageDialogPrivate struct {
	native C.GtkMessageDialogPrivate
}

// WrapMessageDialogPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMessageDialogPrivate(ptr unsafe.Pointer) *MessageDialogPrivate {
	if ptr == nil {
		return nil
	}

	return (*MessageDialogPrivate)(ptr)
}

func marshalMessageDialogPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapMessageDialogPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (m *MessageDialogPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&m.native)
}

type MiscPrivate struct {
	native C.GtkMiscPrivate
}

// WrapMiscPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMiscPrivate(ptr unsafe.Pointer) *MiscPrivate {
	if ptr == nil {
		return nil
	}

	return (*MiscPrivate)(ptr)
}

func marshalMiscPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapMiscPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (m *MiscPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&m.native)
}

type MountOperationPrivate struct {
	native C.GtkMountOperationPrivate
}

// WrapMountOperationPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMountOperationPrivate(ptr unsafe.Pointer) *MountOperationPrivate {
	if ptr == nil {
		return nil
	}

	return (*MountOperationPrivate)(ptr)
}

func marshalMountOperationPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapMountOperationPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (m *MountOperationPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&m.native)
}

type NotebookAccessiblePrivate struct {
	native C.GtkNotebookAccessiblePrivate
}

// WrapNotebookAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapNotebookAccessiblePrivate(ptr unsafe.Pointer) *NotebookAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*NotebookAccessiblePrivate)(ptr)
}

func marshalNotebookAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapNotebookAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (n *NotebookAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&n.native)
}

type NotebookPageAccessiblePrivate struct {
	native C.GtkNotebookPageAccessiblePrivate
}

// WrapNotebookPageAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapNotebookPageAccessiblePrivate(ptr unsafe.Pointer) *NotebookPageAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*NotebookPageAccessiblePrivate)(ptr)
}

func marshalNotebookPageAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapNotebookPageAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (n *NotebookPageAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&n.native)
}

type NotebookPrivate struct {
	native C.GtkNotebookPrivate
}

// WrapNotebookPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapNotebookPrivate(ptr unsafe.Pointer) *NotebookPrivate {
	if ptr == nil {
		return nil
	}

	return (*NotebookPrivate)(ptr)
}

func marshalNotebookPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapNotebookPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (n *NotebookPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&n.native)
}

type NumerableIconPrivate struct {
	native C.GtkNumerableIconPrivate
}

// WrapNumerableIconPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapNumerableIconPrivate(ptr unsafe.Pointer) *NumerableIconPrivate {
	if ptr == nil {
		return nil
	}

	return (*NumerableIconPrivate)(ptr)
}

func marshalNumerableIconPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapNumerableIconPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (n *NumerableIconPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&n.native)
}

type OverlayPrivate struct {
	native C.GtkOverlayPrivate
}

// WrapOverlayPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapOverlayPrivate(ptr unsafe.Pointer) *OverlayPrivate {
	if ptr == nil {
		return nil
	}

	return (*OverlayPrivate)(ptr)
}

func marshalOverlayPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapOverlayPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (o *OverlayPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&o.native)
}

// PadActionEntry: struct defining a pad action entry.
type PadActionEntry struct {
	native C.GtkPadActionEntry
}

// WrapPadActionEntry wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPadActionEntry(ptr unsafe.Pointer) *PadActionEntry {
	if ptr == nil {
		return nil
	}

	return (*PadActionEntry)(ptr)
}

func marshalPadActionEntry(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapPadActionEntry(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (p *PadActionEntry) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

// Type gets the field inside the struct.
func (p *PadActionEntry) Type() PadActionType {
	var ret PadActionType
	ret = PadActionType(p.native._type)
	return ret
}

// Index gets the field inside the struct.
func (p *PadActionEntry) Index() int {
	var ret int
	ret = int(p.native.index)
	return ret
}

// Mode gets the field inside the struct.
func (p *PadActionEntry) Mode() int {
	var ret int
	ret = int(p.native.mode)
	return ret
}

// Label gets the field inside the struct.
func (p *PadActionEntry) Label() string {
	var ret string
	ret = C.GoString(p.native.label)
	return ret
}

// ActionName gets the field inside the struct.
func (p *PadActionEntry) ActionName() string {
	var ret string
	ret = C.GoString(p.native.action_name)
	return ret
}

// PageRange: see also gtk_print_settings_set_page_ranges().
type PageRange struct {
	native C.GtkPageRange
}

// WrapPageRange wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPageRange(ptr unsafe.Pointer) *PageRange {
	if ptr == nil {
		return nil
	}

	return (*PageRange)(ptr)
}

func marshalPageRange(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapPageRange(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (p *PageRange) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

// Start gets the field inside the struct.
func (p *PageRange) Start() int {
	var ret int
	ret = int(p.native.start)
	return ret
}

// End gets the field inside the struct.
func (p *PageRange) End() int {
	var ret int
	ret = int(p.native.end)
	return ret
}

type PanedAccessiblePrivate struct {
	native C.GtkPanedAccessiblePrivate
}

// WrapPanedAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPanedAccessiblePrivate(ptr unsafe.Pointer) *PanedAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*PanedAccessiblePrivate)(ptr)
}

func marshalPanedAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapPanedAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (p *PanedAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

type PanedPrivate struct {
	native C.GtkPanedPrivate
}

// WrapPanedPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPanedPrivate(ptr unsafe.Pointer) *PanedPrivate {
	if ptr == nil {
		return nil
	}

	return (*PanedPrivate)(ptr)
}

func marshalPanedPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapPanedPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (p *PanedPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

// PaperSize: gtkPaperSize handles paper sizes. It uses the standard called PWG
// 5101.1-2002 PWG: Standard for Media Standardized Names
// (http://www.pwg.org/standards.html) to name the paper sizes (and to get the
// data for the page sizes). In addition to standard paper sizes, GtkPaperSize
// allows to construct custom paper sizes with arbitrary dimensions.
//
// The PaperSize object stores not only the dimensions (width and height) of a
// paper size and its name, it also provides default [print
// margins][print-margins].
//
// Printing support has been added in GTK+ 2.10.
type PaperSize struct {
	native C.GtkPaperSize
}

// WrapPaperSize wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPaperSize(ptr unsafe.Pointer) *PaperSize {
	if ptr == nil {
		return nil
	}

	return (*PaperSize)(ptr)
}

func marshalPaperSize(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapPaperSize(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (p *PaperSize) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

// NewPaperSize constructs a struct PaperSize.
func NewPaperSize(name string) *PaperSize {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_paper_size_new(arg1)

	var ret0 *PaperSize

	{
		ret0 = WrapPaperSize(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *PaperSize) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewPaperSizeCustom constructs a struct PaperSize.
func NewPaperSizeCustom(name string, displayName string, width float64, height float64, unit Unit) *PaperSize {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 C.gdouble
	var arg4 C.gdouble
	var arg5 C.GtkUnit

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(displayName))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.gdouble(width)
	arg4 = C.gdouble(height)
	arg5 = (C.GtkUnit)(unit)

	ret := C.gtk_paper_size_new_custom(arg1, arg2, arg3, arg4, arg5)

	var ret0 *PaperSize

	{
		ret0 = WrapPaperSize(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *PaperSize) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewPaperSizeFromGVariant constructs a struct PaperSize.
func NewPaperSizeFromGVariant(variant *glib.Variant) *PaperSize {
	var arg1 *C.GVariant

	arg1 = (*C.GVariant)(variant.Native())

	ret := C.gtk_paper_size_new_from_gvariant(arg1)

	var ret0 *PaperSize

	{
		ret0 = WrapPaperSize(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *PaperSize) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewPaperSizeFromIpp constructs a struct PaperSize.
func NewPaperSizeFromIpp(ippName string, width float64, height float64) *PaperSize {
	var arg1 *C.gchar
	var arg2 C.gdouble
	var arg3 C.gdouble

	arg1 = (*C.gchar)(C.CString(ippName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gdouble(width)
	arg3 = C.gdouble(height)

	ret := C.gtk_paper_size_new_from_ipp(arg1, arg2, arg3)

	var ret0 *PaperSize

	{
		ret0 = WrapPaperSize(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *PaperSize) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewPaperSizeFromKeyFile constructs a struct PaperSize.
func NewPaperSizeFromKeyFile(keyFile *glib.KeyFile, groupName string) (paperSize *PaperSize, err error) {
	var arg1 *C.GKeyFile
	var arg2 *C.gchar
	var gError *C.GError

	arg1 = (*C.GKeyFile)(keyFile.Native())
	arg2 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_paper_size_new_from_key_file(arg1, arg2, &gError)

	var ret0 *PaperSize
	var goError error

	{
		ret0 = WrapPaperSize(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *PaperSize) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// NewPaperSizeFromPpd constructs a struct PaperSize.
func NewPaperSizeFromPpd(ppdName string, ppdDisplayName string, width float64, height float64) *PaperSize {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 C.gdouble
	var arg4 C.gdouble

	arg1 = (*C.gchar)(C.CString(ppdName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(ppdDisplayName))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.gdouble(width)
	arg4 = C.gdouble(height)

	ret := C.gtk_paper_size_new_from_ppd(arg1, arg2, arg3, arg4)

	var ret0 *PaperSize

	{
		ret0 = WrapPaperSize(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *PaperSize) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Copy copies an existing PaperSize.
func (other *PaperSize) Copy() *PaperSize {
	var arg0 *C.GtkPaperSize

	arg0 = (*C.GtkPaperSize)(other.Native())

	ret := C.gtk_paper_size_copy(arg0)

	var ret0 *PaperSize

	{
		ret0 = WrapPaperSize(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *PaperSize) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Free: free the given PaperSize object.
func (size *PaperSize) Free() {
	var arg0 *C.GtkPaperSize

	arg0 = (*C.GtkPaperSize)(size.Native())

	C.gtk_paper_size_free(arg0)
}

// DefaultBottomMargin gets the default bottom margin for the PaperSize.
func (size *PaperSize) DefaultBottomMargin(unit Unit) float64 {
	var arg0 *C.GtkPaperSize
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPaperSize)(size.Native())
	arg1 = (C.GtkUnit)(unit)

	ret := C.gtk_paper_size_get_default_bottom_margin(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// DefaultLeftMargin gets the default left margin for the PaperSize.
func (size *PaperSize) DefaultLeftMargin(unit Unit) float64 {
	var arg0 *C.GtkPaperSize
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPaperSize)(size.Native())
	arg1 = (C.GtkUnit)(unit)

	ret := C.gtk_paper_size_get_default_left_margin(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// DefaultRightMargin gets the default right margin for the PaperSize.
func (size *PaperSize) DefaultRightMargin(unit Unit) float64 {
	var arg0 *C.GtkPaperSize
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPaperSize)(size.Native())
	arg1 = (C.GtkUnit)(unit)

	ret := C.gtk_paper_size_get_default_right_margin(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// DefaultTopMargin gets the default top margin for the PaperSize.
func (size *PaperSize) DefaultTopMargin(unit Unit) float64 {
	var arg0 *C.GtkPaperSize
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPaperSize)(size.Native())
	arg1 = (C.GtkUnit)(unit)

	ret := C.gtk_paper_size_get_default_top_margin(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// DisplayName gets the human-readable name of the PaperSize.
func (size *PaperSize) DisplayName() string {
	var arg0 *C.GtkPaperSize

	arg0 = (*C.GtkPaperSize)(size.Native())

	ret := C.gtk_paper_size_get_display_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Height gets the paper height of the PaperSize, in units of @unit.
func (size *PaperSize) Height(unit Unit) float64 {
	var arg0 *C.GtkPaperSize
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPaperSize)(size.Native())
	arg1 = (C.GtkUnit)(unit)

	ret := C.gtk_paper_size_get_height(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// Name gets the name of the PaperSize.
func (size *PaperSize) Name() string {
	var arg0 *C.GtkPaperSize

	arg0 = (*C.GtkPaperSize)(size.Native())

	ret := C.gtk_paper_size_get_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// PpdName gets the PPD name of the PaperSize, which may be nil.
func (size *PaperSize) PpdName() string {
	var arg0 *C.GtkPaperSize

	arg0 = (*C.GtkPaperSize)(size.Native())

	ret := C.gtk_paper_size_get_ppd_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Width gets the paper width of the PaperSize, in units of @unit.
func (size *PaperSize) Width(unit Unit) float64 {
	var arg0 *C.GtkPaperSize
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPaperSize)(size.Native())
	arg1 = (C.GtkUnit)(unit)

	ret := C.gtk_paper_size_get_width(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// IsCustom returns true if @size is not a standard paper size.
func (size *PaperSize) IsCustom() bool {
	var arg0 *C.GtkPaperSize

	arg0 = (*C.GtkPaperSize)(size.Native())

	ret := C.gtk_paper_size_is_custom(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IsEqual compares two PaperSize objects.
func (size1 *PaperSize) IsEqual(size2 *PaperSize) bool {
	var arg0 *C.GtkPaperSize
	var arg1 *C.GtkPaperSize

	arg0 = (*C.GtkPaperSize)(size1.Native())
	arg1 = (*C.GtkPaperSize)(size2.Native())

	ret := C.gtk_paper_size_is_equal(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IsIpp returns true if @size is an IPP standard paper size.
func (size *PaperSize) IsIpp() bool {
	var arg0 *C.GtkPaperSize

	arg0 = (*C.GtkPaperSize)(size.Native())

	ret := C.gtk_paper_size_is_ipp(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SetSize changes the dimensions of a @size to @width x @height.
func (size *PaperSize) SetSize(width float64, height float64, unit Unit) {
	var arg0 *C.GtkPaperSize
	var arg1 C.gdouble
	var arg2 C.gdouble
	var arg3 C.GtkUnit

	arg0 = (*C.GtkPaperSize)(size.Native())
	arg1 = C.gdouble(width)
	arg2 = C.gdouble(height)
	arg3 = (C.GtkUnit)(unit)

	C.gtk_paper_size_set_size(arg0, arg1, arg2, arg3)
}

// ToGVariant: serialize a paper size to an a{sv} variant.
func (paperSize *PaperSize) ToGVariant() *glib.Variant {
	var arg0 *C.GtkPaperSize

	arg0 = (*C.GtkPaperSize)(paperSize.Native())

	ret := C.gtk_paper_size_to_gvariant(arg0)

	var ret0 *glib.Variant

	{
		ret0 = glib.WrapVariant(unsafe.Pointer(ret))
	}

	return ret0
}

// ToKeyFile: this function adds the paper size from @size to @key_file.
func (size *PaperSize) ToKeyFile(keyFile *glib.KeyFile, groupName string) {
	var arg0 *C.GtkPaperSize
	var arg1 *C.GKeyFile
	var arg2 *C.gchar

	arg0 = (*C.GtkPaperSize)(size.Native())
	arg1 = (*C.GKeyFile)(keyFile.Native())
	arg2 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_paper_size_to_key_file(arg0, arg1, arg2)
}

type PlugAccessiblePrivate struct {
	native C.GtkPlugAccessiblePrivate
}

// WrapPlugAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPlugAccessiblePrivate(ptr unsafe.Pointer) *PlugAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*PlugAccessiblePrivate)(ptr)
}

func marshalPlugAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapPlugAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (p *PlugAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

type PlugPrivate struct {
	native C.GtkPlugPrivate
}

// WrapPlugPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPlugPrivate(ptr unsafe.Pointer) *PlugPrivate {
	if ptr == nil {
		return nil
	}

	return (*PlugPrivate)(ptr)
}

func marshalPlugPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapPlugPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (p *PlugPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

type PopoverPrivate struct {
	native C.GtkPopoverPrivate
}

// WrapPopoverPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPopoverPrivate(ptr unsafe.Pointer) *PopoverPrivate {
	if ptr == nil {
		return nil
	}

	return (*PopoverPrivate)(ptr)
}

func marshalPopoverPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapPopoverPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (p *PopoverPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

type PrintOperationPrivate struct {
	native C.GtkPrintOperationPrivate
}

// WrapPrintOperationPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPrintOperationPrivate(ptr unsafe.Pointer) *PrintOperationPrivate {
	if ptr == nil {
		return nil
	}

	return (*PrintOperationPrivate)(ptr)
}

func marshalPrintOperationPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapPrintOperationPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (p *PrintOperationPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

type ProgressBarAccessiblePrivate struct {
	native C.GtkProgressBarAccessiblePrivate
}

// WrapProgressBarAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapProgressBarAccessiblePrivate(ptr unsafe.Pointer) *ProgressBarAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*ProgressBarAccessiblePrivate)(ptr)
}

func marshalProgressBarAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapProgressBarAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (p *ProgressBarAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

type ProgressBarPrivate struct {
	native C.GtkProgressBarPrivate
}

// WrapProgressBarPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapProgressBarPrivate(ptr unsafe.Pointer) *ProgressBarPrivate {
	if ptr == nil {
		return nil
	}

	return (*ProgressBarPrivate)(ptr)
}

func marshalProgressBarPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapProgressBarPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (p *ProgressBarPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

// RadioActionEntry structs are used with gtk_action_group_add_radio_actions()
// to construct groups of radio actions.
type RadioActionEntry struct {
	native C.GtkRadioActionEntry
}

// WrapRadioActionEntry wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRadioActionEntry(ptr unsafe.Pointer) *RadioActionEntry {
	if ptr == nil {
		return nil
	}

	return (*RadioActionEntry)(ptr)
}

func marshalRadioActionEntry(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRadioActionEntry(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *RadioActionEntry) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// Name gets the field inside the struct.
func (r *RadioActionEntry) Name() string {
	var ret string
	ret = C.GoString(r.native.name)
	return ret
}

// StockID gets the field inside the struct.
func (r *RadioActionEntry) StockID() string {
	var ret string
	ret = C.GoString(r.native.stock_id)
	return ret
}

// Label gets the field inside the struct.
func (r *RadioActionEntry) Label() string {
	var ret string
	ret = C.GoString(r.native.label)
	return ret
}

// Accelerator gets the field inside the struct.
func (r *RadioActionEntry) Accelerator() string {
	var ret string
	ret = C.GoString(r.native.accelerator)
	return ret
}

// Tooltip gets the field inside the struct.
func (r *RadioActionEntry) Tooltip() string {
	var ret string
	ret = C.GoString(r.native.tooltip)
	return ret
}

// Value gets the field inside the struct.
func (r *RadioActionEntry) Value() int {
	var ret int
	ret = int(r.native.value)
	return ret
}

type RadioActionPrivate struct {
	native C.GtkRadioActionPrivate
}

// WrapRadioActionPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRadioActionPrivate(ptr unsafe.Pointer) *RadioActionPrivate {
	if ptr == nil {
		return nil
	}

	return (*RadioActionPrivate)(ptr)
}

func marshalRadioActionPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRadioActionPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *RadioActionPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

type RadioButtonAccessiblePrivate struct {
	native C.GtkRadioButtonAccessiblePrivate
}

// WrapRadioButtonAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRadioButtonAccessiblePrivate(ptr unsafe.Pointer) *RadioButtonAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*RadioButtonAccessiblePrivate)(ptr)
}

func marshalRadioButtonAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRadioButtonAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *RadioButtonAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

type RadioButtonPrivate struct {
	native C.GtkRadioButtonPrivate
}

// WrapRadioButtonPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRadioButtonPrivate(ptr unsafe.Pointer) *RadioButtonPrivate {
	if ptr == nil {
		return nil
	}

	return (*RadioButtonPrivate)(ptr)
}

func marshalRadioButtonPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRadioButtonPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *RadioButtonPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

type RadioMenuItemAccessiblePrivate struct {
	native C.GtkRadioMenuItemAccessiblePrivate
}

// WrapRadioMenuItemAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRadioMenuItemAccessiblePrivate(ptr unsafe.Pointer) *RadioMenuItemAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*RadioMenuItemAccessiblePrivate)(ptr)
}

func marshalRadioMenuItemAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRadioMenuItemAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *RadioMenuItemAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

type RadioMenuItemPrivate struct {
	native C.GtkRadioMenuItemPrivate
}

// WrapRadioMenuItemPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRadioMenuItemPrivate(ptr unsafe.Pointer) *RadioMenuItemPrivate {
	if ptr == nil {
		return nil
	}

	return (*RadioMenuItemPrivate)(ptr)
}

func marshalRadioMenuItemPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRadioMenuItemPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *RadioMenuItemPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

type RangeAccessiblePrivate struct {
	native C.GtkRangeAccessiblePrivate
}

// WrapRangeAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRangeAccessiblePrivate(ptr unsafe.Pointer) *RangeAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*RangeAccessiblePrivate)(ptr)
}

func marshalRangeAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRangeAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *RangeAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

type RangePrivate struct {
	native C.GtkRangePrivate
}

// WrapRangePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRangePrivate(ptr unsafe.Pointer) *RangePrivate {
	if ptr == nil {
		return nil
	}

	return (*RangePrivate)(ptr)
}

func marshalRangePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRangePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *RangePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

type RCContext struct {
	native C.GtkRcContext
}

// WrapRCContext wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRCContext(ptr unsafe.Pointer) *RCContext {
	if ptr == nil {
		return nil
	}

	return (*RCContext)(ptr)
}

func marshalRCContext(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRCContext(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *RCContext) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// RCProperty: deprecated
type RCProperty struct {
	native C.GtkRcProperty
}

// WrapRCProperty wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRCProperty(ptr unsafe.Pointer) *RCProperty {
	if ptr == nil {
		return nil
	}

	return (*RCProperty)(ptr)
}

func marshalRCProperty(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRCProperty(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *RCProperty) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// TypeName gets the field inside the struct.
func (r *RCProperty) TypeName() glib.Quark {
	var ret glib.Quark
	{
		var tmp uint32
		tmp = uint32(r.native.type_name)
		ret = glib.Quark(tmp)
	}
	return ret
}

// PropertyName gets the field inside the struct.
func (r *RCProperty) PropertyName() glib.Quark {
	var ret glib.Quark
	{
		var tmp uint32
		tmp = uint32(r.native.property_name)
		ret = glib.Quark(tmp)
	}
	return ret
}

// Origin gets the field inside the struct.
func (r *RCProperty) Origin() string {
	var ret string
	ret = C.GoString(r.native.origin)
	return ret
}

// Value gets the field inside the struct.
func (r *RCProperty) Value() *externglib.Value {
	var ret *externglib.Value
	ret = externglib.ValueFromNative(unsafe.Pointer(r.native.value))
	return ret
}

type RecentActionPrivate struct {
	native C.GtkRecentActionPrivate
}

// WrapRecentActionPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRecentActionPrivate(ptr unsafe.Pointer) *RecentActionPrivate {
	if ptr == nil {
		return nil
	}

	return (*RecentActionPrivate)(ptr)
}

func marshalRecentActionPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRecentActionPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *RecentActionPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

type RecentChooserDialogPrivate struct {
	native C.GtkRecentChooserDialogPrivate
}

// WrapRecentChooserDialogPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRecentChooserDialogPrivate(ptr unsafe.Pointer) *RecentChooserDialogPrivate {
	if ptr == nil {
		return nil
	}

	return (*RecentChooserDialogPrivate)(ptr)
}

func marshalRecentChooserDialogPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRecentChooserDialogPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *RecentChooserDialogPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

type RecentChooserMenuPrivate struct {
	native C.GtkRecentChooserMenuPrivate
}

// WrapRecentChooserMenuPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRecentChooserMenuPrivate(ptr unsafe.Pointer) *RecentChooserMenuPrivate {
	if ptr == nil {
		return nil
	}

	return (*RecentChooserMenuPrivate)(ptr)
}

func marshalRecentChooserMenuPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRecentChooserMenuPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *RecentChooserMenuPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

type RecentChooserWidgetPrivate struct {
	native C.GtkRecentChooserWidgetPrivate
}

// WrapRecentChooserWidgetPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRecentChooserWidgetPrivate(ptr unsafe.Pointer) *RecentChooserWidgetPrivate {
	if ptr == nil {
		return nil
	}

	return (*RecentChooserWidgetPrivate)(ptr)
}

func marshalRecentChooserWidgetPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRecentChooserWidgetPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *RecentChooserWidgetPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// RecentData: meta-data to be passed to gtk_recent_manager_add_full() when
// registering a recently used resource.
type RecentData struct {
	native C.GtkRecentData
}

// WrapRecentData wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRecentData(ptr unsafe.Pointer) *RecentData {
	if ptr == nil {
		return nil
	}

	return (*RecentData)(ptr)
}

func marshalRecentData(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRecentData(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *RecentData) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// DisplayName gets the field inside the struct.
func (r *RecentData) DisplayName() string {
	var ret string
	ret = C.GoString(r.native.display_name)
	return ret
}

// Description gets the field inside the struct.
func (r *RecentData) Description() string {
	var ret string
	ret = C.GoString(r.native.description)
	return ret
}

// MIMEType gets the field inside the struct.
func (r *RecentData) MIMEType() string {
	var ret string
	ret = C.GoString(r.native.mime_type)
	return ret
}

// AppName gets the field inside the struct.
func (r *RecentData) AppName() string {
	var ret string
	ret = C.GoString(r.native.app_name)
	return ret
}

// AppExec gets the field inside the struct.
func (r *RecentData) AppExec() string {
	var ret string
	ret = C.GoString(r.native.app_exec)
	return ret
}

// Groups gets the field inside the struct.
func (r *RecentData) Groups() []string {
	var ret []string
	{
		var length uint
		for p := unsafe.Pointer(r.native.groups); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(r.native.groups)) + i))
			ret[i] = C.GoString(src)
		}
	}
	return ret
}

// IsPrivate gets the field inside the struct.
func (r *RecentData) IsPrivate() bool {
	var ret bool
	ret = C.BOOL(r.native.is_private) != 0
	return ret
}

// RecentFilterInfo: a GtkRecentFilterInfo struct is used to pass information
// about the tested file to gtk_recent_filter_filter().
type RecentFilterInfo struct {
	native C.GtkRecentFilterInfo
}

// WrapRecentFilterInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRecentFilterInfo(ptr unsafe.Pointer) *RecentFilterInfo {
	if ptr == nil {
		return nil
	}

	return (*RecentFilterInfo)(ptr)
}

func marshalRecentFilterInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRecentFilterInfo(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *RecentFilterInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// Contains gets the field inside the struct.
func (r *RecentFilterInfo) Contains() RecentFilterFlags {
	var ret RecentFilterFlags
	ret = RecentFilterFlags(r.native.contains)
	return ret
}

// URI gets the field inside the struct.
func (r *RecentFilterInfo) URI() string {
	var ret string
	ret = C.GoString(r.native.uri)
	return ret
}

// DisplayName gets the field inside the struct.
func (r *RecentFilterInfo) DisplayName() string {
	var ret string
	ret = C.GoString(r.native.display_name)
	return ret
}

// MIMEType gets the field inside the struct.
func (r *RecentFilterInfo) MIMEType() string {
	var ret string
	ret = C.GoString(r.native.mime_type)
	return ret
}

// Applications gets the field inside the struct.
func (r *RecentFilterInfo) Applications() []string {
	var ret []string
	{
		var length uint
		for p := unsafe.Pointer(r.native.applications); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(r.native.applications)) + i))
			ret[i] = C.GoString(src)
		}
	}
	return ret
}

// Groups gets the field inside the struct.
func (r *RecentFilterInfo) Groups() []string {
	var ret []string
	{
		var length uint
		for p := unsafe.Pointer(r.native.groups); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(r.native.groups)) + i))
			ret[i] = C.GoString(src)
		}
	}
	return ret
}

// Age gets the field inside the struct.
func (r *RecentFilterInfo) Age() int {
	var ret int
	ret = int(r.native.age)
	return ret
}

// RecentInfo contains private data only, and should be accessed using the
// provided API.
//
// RecentInfo constains all the meta-data associated with an entry in the
// recently used files list.
type RecentInfo struct {
	native C.GtkRecentInfo
}

// WrapRecentInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRecentInfo(ptr unsafe.Pointer) *RecentInfo {
	if ptr == nil {
		return nil
	}

	return (*RecentInfo)(ptr)
}

func marshalRecentInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRecentInfo(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *RecentInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// CreateAppInfo creates a Info for the specified RecentInfo
func (info *RecentInfo) CreateAppInfo(appName string) (appInfo gio.AppInfo, err error) {
	var arg0 *C.GtkRecentInfo
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GtkRecentInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(appName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_recent_info_create_app_info(arg0, arg1, &gError)

	var ret0 gio.AppInfo
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gio.AppInfo)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Exists checks whether the resource pointed by @info still exists. At the
// moment this check is done only on resources pointing to local files.
func (info *RecentInfo) Exists() bool {
	var arg0 *C.GtkRecentInfo

	arg0 = (*C.GtkRecentInfo)(info.Native())

	ret := C.gtk_recent_info_exists(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Added gets the timestamp (seconds from system’s Epoch) when the resource was
// added to the recently used resources list.
func (info *RecentInfo) Added() int32 {
	var arg0 *C.GtkRecentInfo

	arg0 = (*C.GtkRecentInfo)(info.Native())

	ret := C.gtk_recent_info_get_added(arg0)

	var ret0 int32

	ret0 = int32(ret)

	return ret0
}

// Age gets the number of days elapsed since the last update of the resource
// pointed by @info.
func (info *RecentInfo) Age() int {
	var arg0 *C.GtkRecentInfo

	arg0 = (*C.GtkRecentInfo)(info.Native())

	ret := C.gtk_recent_info_get_age(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ApplicationInfo gets the data regarding the application that has registered
// the resource pointed by @info.
//
// If the command line contains any escape characters defined inside the storage
// specification, they will be expanded.
func (info *RecentInfo) ApplicationInfo(appName string) (appExec string, count uint, time_ int32, ok bool) {
	var arg0 *C.GtkRecentInfo
	var arg1 *C.gchar
	var arg2 **C.gchar // out
	var arg3 *C.guint  // out
	var arg4 *C.time_t // out

	arg0 = (*C.GtkRecentInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(appName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_recent_info_get_application_info(arg0, arg1, &arg2, &arg3, &arg4)

	var ret0 string
	var ret1 uint
	var ret2 int32
	var ret3 bool

	ret0 = C.GoString(arg2)

	ret1 = uint(arg3)

	ret2 = int32(arg4)

	ret3 = C.BOOL(ret) != 0

	return ret0, ret1, ret2, ret3
}

// Applications retrieves the list of applications that have registered this
// resource.
func (info *RecentInfo) Applications() (length uint, utf8s []string) {
	var arg0 *C.GtkRecentInfo
	var arg1 *C.gsize // out

	arg0 = (*C.GtkRecentInfo)(info.Native())

	ret := C.gtk_recent_info_get_applications(arg0, &arg1)

	var ret0 uint
	var ret1 []string

	ret0 = uint(arg1)

	{
		ret1 = make([]string, arg1)
		for i := 0; i < uintptr(arg1); i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0, ret1
}

// Description gets the (short) description of the resource.
func (info *RecentInfo) Description() string {
	var arg0 *C.GtkRecentInfo

	arg0 = (*C.GtkRecentInfo)(info.Native())

	ret := C.gtk_recent_info_get_description(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// DisplayName gets the name of the resource. If none has been defined, the
// basename of the resource is obtained.
func (info *RecentInfo) DisplayName() string {
	var arg0 *C.GtkRecentInfo

	arg0 = (*C.GtkRecentInfo)(info.Native())

	ret := C.gtk_recent_info_get_display_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// GIcon retrieves the icon associated to the resource MIME type.
func (info *RecentInfo) GIcon() gio.Icon {
	var arg0 *C.GtkRecentInfo

	arg0 = (*C.GtkRecentInfo)(info.Native())

	ret := C.gtk_recent_info_get_gicon(arg0)

	var ret0 gio.Icon

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gio.Icon)

	return ret0
}

// Groups returns all groups registered for the recently used item @info. The
// array of returned group names will be nil terminated, so length might
// optionally be nil.
func (info *RecentInfo) Groups() (length uint, utf8s []string) {
	var arg0 *C.GtkRecentInfo
	var arg1 *C.gsize // out

	arg0 = (*C.GtkRecentInfo)(info.Native())

	ret := C.gtk_recent_info_get_groups(arg0, &arg1)

	var ret0 uint
	var ret1 []string

	ret0 = uint(arg1)

	{
		ret1 = make([]string, arg1)
		for i := 0; i < uintptr(arg1); i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0, ret1
}

// Icon retrieves the icon of size @size associated to the resource MIME type.
func (info *RecentInfo) Icon(size int) gdkpixbuf.Pixbuf {
	var arg0 *C.GtkRecentInfo
	var arg1 C.gint

	arg0 = (*C.GtkRecentInfo)(info.Native())
	arg1 = C.gint(size)

	ret := C.gtk_recent_info_get_icon(arg0, arg1)

	var ret0 gdkpixbuf.Pixbuf

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gdkpixbuf.Pixbuf)

	return ret0
}

// MIMEType gets the MIME type of the resource.
func (info *RecentInfo) MIMEType() string {
	var arg0 *C.GtkRecentInfo

	arg0 = (*C.GtkRecentInfo)(info.Native())

	ret := C.gtk_recent_info_get_mime_type(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Modified gets the timestamp (seconds from system’s Epoch) when the meta-data
// for the resource was last modified.
func (info *RecentInfo) Modified() int32 {
	var arg0 *C.GtkRecentInfo

	arg0 = (*C.GtkRecentInfo)(info.Native())

	ret := C.gtk_recent_info_get_modified(arg0)

	var ret0 int32

	ret0 = int32(ret)

	return ret0
}

// PrivateHint gets the value of the “private” flag. Resources in the recently
// used list that have this flag set to true should only be displayed by the
// applications that have registered them.
func (info *RecentInfo) PrivateHint() bool {
	var arg0 *C.GtkRecentInfo

	arg0 = (*C.GtkRecentInfo)(info.Native())

	ret := C.gtk_recent_info_get_private_hint(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ShortName computes a valid UTF-8 string that can be used as the name of the
// item in a menu or list. For example, calling this function on an item that
// refers to “file:///foo/bar.txt” will yield “bar.txt”.
func (info *RecentInfo) ShortName() string {
	var arg0 *C.GtkRecentInfo

	arg0 = (*C.GtkRecentInfo)(info.Native())

	ret := C.gtk_recent_info_get_short_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// URI gets the URI of the resource.
func (info *RecentInfo) URI() string {
	var arg0 *C.GtkRecentInfo

	arg0 = (*C.GtkRecentInfo)(info.Native())

	ret := C.gtk_recent_info_get_uri(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// URIDisplay gets a displayable version of the resource’s URI. If the resource
// is local, it returns a local path; if the resource is not local, it returns
// the UTF-8 encoded content of gtk_recent_info_get_uri().
func (info *RecentInfo) URIDisplay() string {
	var arg0 *C.GtkRecentInfo

	arg0 = (*C.GtkRecentInfo)(info.Native())

	ret := C.gtk_recent_info_get_uri_display(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Visited gets the timestamp (seconds from system’s Epoch) when the meta-data
// for the resource was last visited.
func (info *RecentInfo) Visited() int32 {
	var arg0 *C.GtkRecentInfo

	arg0 = (*C.GtkRecentInfo)(info.Native())

	ret := C.gtk_recent_info_get_visited(arg0)

	var ret0 int32

	ret0 = int32(ret)

	return ret0
}

// HasApplication checks whether an application registered this resource using
// @app_name.
func (info *RecentInfo) HasApplication(appName string) bool {
	var arg0 *C.GtkRecentInfo
	var arg1 *C.gchar

	arg0 = (*C.GtkRecentInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(appName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_recent_info_has_application(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// HasGroup checks whether @group_name appears inside the groups registered for
// the recently used item @info.
func (info *RecentInfo) HasGroup(groupName string) bool {
	var arg0 *C.GtkRecentInfo
	var arg1 *C.gchar

	arg0 = (*C.GtkRecentInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_recent_info_has_group(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IsLocal checks whether the resource is local or not by looking at the scheme
// of its URI.
func (info *RecentInfo) IsLocal() bool {
	var arg0 *C.GtkRecentInfo

	arg0 = (*C.GtkRecentInfo)(info.Native())

	ret := C.gtk_recent_info_is_local(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// LastApplication gets the name of the last application that have registered
// the recently used resource represented by @info.
func (info *RecentInfo) LastApplication() string {
	var arg0 *C.GtkRecentInfo

	arg0 = (*C.GtkRecentInfo)(info.Native())

	ret := C.gtk_recent_info_last_application(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Match checks whether two RecentInfo-struct point to the same resource.
func (infoA *RecentInfo) Match(infoB *RecentInfo) bool {
	var arg0 *C.GtkRecentInfo
	var arg1 *C.GtkRecentInfo

	arg0 = (*C.GtkRecentInfo)(infoA.Native())
	arg1 = (*C.GtkRecentInfo)(infoB.Native())

	ret := C.gtk_recent_info_match(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Ref increases the reference count of @recent_info by one.
func (info *RecentInfo) Ref() *RecentInfo {
	var arg0 *C.GtkRecentInfo

	arg0 = (*C.GtkRecentInfo)(info.Native())

	ret := C.gtk_recent_info_ref(arg0)

	var ret0 *RecentInfo

	{
		ret0 = WrapRecentInfo(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *RecentInfo) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Unref decreases the reference count of @info by one. If the reference count
// reaches zero, @info is deallocated, and the memory freed.
func (info *RecentInfo) Unref() {
	var arg0 *C.GtkRecentInfo

	arg0 = (*C.GtkRecentInfo)(info.Native())

	C.gtk_recent_info_unref(arg0)
}

type RecentManagerPrivate struct {
	native C.GtkRecentManagerPrivate
}

// WrapRecentManagerPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRecentManagerPrivate(ptr unsafe.Pointer) *RecentManagerPrivate {
	if ptr == nil {
		return nil
	}

	return (*RecentManagerPrivate)(ptr)
}

func marshalRecentManagerPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRecentManagerPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *RecentManagerPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

type RendererCellAccessiblePrivate struct {
	native C.GtkRendererCellAccessiblePrivate
}

// WrapRendererCellAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRendererCellAccessiblePrivate(ptr unsafe.Pointer) *RendererCellAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*RendererCellAccessiblePrivate)(ptr)
}

func marshalRendererCellAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRendererCellAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *RendererCellAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// RequestedSize represents a request of a screen object in a given orientation.
// These are primarily used in container implementations when allocating a
// natural size for children calling. See gtk_distribute_natural_allocation().
type RequestedSize struct {
	native C.GtkRequestedSize
}

// WrapRequestedSize wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRequestedSize(ptr unsafe.Pointer) *RequestedSize {
	if ptr == nil {
		return nil
	}

	return (*RequestedSize)(ptr)
}

func marshalRequestedSize(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRequestedSize(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *RequestedSize) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// Data gets the field inside the struct.
func (r *RequestedSize) Data() interface{} {
	var ret interface{}
	ret = box.Get(uintptr(r.native.data))
	return ret
}

// MinimumSize gets the field inside the struct.
func (r *RequestedSize) MinimumSize() int {
	var ret int
	ret = int(r.native.minimum_size)
	return ret
}

// NaturalSize gets the field inside the struct.
func (r *RequestedSize) NaturalSize() int {
	var ret int
	ret = int(r.native.natural_size)
	return ret
}

// Requisition: a Requisition-struct represents the desired size of a widget.
// See [GtkWidget’s geometry management section][geometry-management] for more
// information.
type Requisition struct {
	native C.GtkRequisition
}

// WrapRequisition wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRequisition(ptr unsafe.Pointer) *Requisition {
	if ptr == nil {
		return nil
	}

	return (*Requisition)(ptr)
}

func marshalRequisition(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRequisition(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *Requisition) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// NewRequisition constructs a struct Requisition.
func NewRequisition() *Requisition {

	ret := C.gtk_requisition_new()

	var ret0 *Requisition

	{
		ret0 = WrapRequisition(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Requisition) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Width gets the field inside the struct.
func (r *Requisition) Width() int {
	var ret int
	ret = int(r.native.width)
	return ret
}

// Height gets the field inside the struct.
func (r *Requisition) Height() int {
	var ret int
	ret = int(r.native.height)
	return ret
}

// Copy copies a Requisition.
func (requisition *Requisition) Copy() *Requisition {
	var arg0 *C.GtkRequisition

	arg0 = (*C.GtkRequisition)(requisition.Native())

	ret := C.gtk_requisition_copy(arg0)

	var ret0 *Requisition

	{
		ret0 = WrapRequisition(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Requisition) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Free frees a Requisition.
func (requisition *Requisition) Free() {
	var arg0 *C.GtkRequisition

	arg0 = (*C.GtkRequisition)(requisition.Native())

	C.gtk_requisition_free(arg0)
}

type ScaleAccessiblePrivate struct {
	native C.GtkScaleAccessiblePrivate
}

// WrapScaleAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapScaleAccessiblePrivate(ptr unsafe.Pointer) *ScaleAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*ScaleAccessiblePrivate)(ptr)
}

func marshalScaleAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapScaleAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *ScaleAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

type ScaleButtonAccessiblePrivate struct {
	native C.GtkScaleButtonAccessiblePrivate
}

// WrapScaleButtonAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapScaleButtonAccessiblePrivate(ptr unsafe.Pointer) *ScaleButtonAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*ScaleButtonAccessiblePrivate)(ptr)
}

func marshalScaleButtonAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapScaleButtonAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *ScaleButtonAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

type ScaleButtonPrivate struct {
	native C.GtkScaleButtonPrivate
}

// WrapScaleButtonPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapScaleButtonPrivate(ptr unsafe.Pointer) *ScaleButtonPrivate {
	if ptr == nil {
		return nil
	}

	return (*ScaleButtonPrivate)(ptr)
}

func marshalScaleButtonPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapScaleButtonPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *ScaleButtonPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

type ScalePrivate struct {
	native C.GtkScalePrivate
}

// WrapScalePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapScalePrivate(ptr unsafe.Pointer) *ScalePrivate {
	if ptr == nil {
		return nil
	}

	return (*ScalePrivate)(ptr)
}

func marshalScalePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapScalePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *ScalePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

type ScrolledWindowAccessiblePrivate struct {
	native C.GtkScrolledWindowAccessiblePrivate
}

// WrapScrolledWindowAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapScrolledWindowAccessiblePrivate(ptr unsafe.Pointer) *ScrolledWindowAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*ScrolledWindowAccessiblePrivate)(ptr)
}

func marshalScrolledWindowAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapScrolledWindowAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *ScrolledWindowAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

type ScrolledWindowPrivate struct {
	native C.GtkScrolledWindowPrivate
}

// WrapScrolledWindowPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapScrolledWindowPrivate(ptr unsafe.Pointer) *ScrolledWindowPrivate {
	if ptr == nil {
		return nil
	}

	return (*ScrolledWindowPrivate)(ptr)
}

func marshalScrolledWindowPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapScrolledWindowPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *ScrolledWindowPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

type SelectionData struct {
	native C.GtkSelectionData
}

// WrapSelectionData wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSelectionData(ptr unsafe.Pointer) *SelectionData {
	if ptr == nil {
		return nil
	}

	return (*SelectionData)(ptr)
}

func marshalSelectionData(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSelectionData(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *SelectionData) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// Copy makes a copy of a SelectionData-struct and its data.
func (data *SelectionData) Copy() *SelectionData {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(data.Native())

	ret := C.gtk_selection_data_copy(arg0)

	var ret0 *SelectionData

	{
		ret0 = WrapSelectionData(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *SelectionData) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Free frees a SelectionData-struct returned from gtk_selection_data_copy().
func (data *SelectionData) Free() {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(data.Native())

	C.gtk_selection_data_free(arg0)
}

// DataType retrieves the data type of the selection.
func (selectionData *SelectionData) DataType() gdk.Atom {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(selectionData.Native())

	ret := C.gtk_selection_data_get_data_type(arg0)

	var ret0 gdk.Atom

	{
		ret0 = gdk.WrapAtom(unsafe.Pointer(ret))
	}

	return ret0
}

// DataWithLength retrieves the raw data of the selection along with its length.
func (selectionData *SelectionData) DataWithLength() (length int, guint8s []byte) {
	var arg0 *C.GtkSelectionData
	var arg1 *C.gint // out

	arg0 = (*C.GtkSelectionData)(selectionData.Native())

	ret := C.gtk_selection_data_get_data_with_length(arg0, &arg1)

	var ret0 int
	var ret1 []byte

	ret0 = int(arg1)

	{
		ret1 = make([]byte, arg1)
		for i := 0; i < uintptr(arg1); i++ {
			src := (C.guchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = byte(src)
		}
	}

	return ret0, ret1
}

// Display retrieves the display of the selection.
func (selectionData *SelectionData) Display() gdk.Display {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(selectionData.Native())

	ret := C.gtk_selection_data_get_display(arg0)

	var ret0 gdk.Display

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gdk.Display)

	return ret0
}

// Format retrieves the format of the selection.
func (selectionData *SelectionData) Format() int {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(selectionData.Native())

	ret := C.gtk_selection_data_get_format(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Length retrieves the length of the raw data of the selection.
func (selectionData *SelectionData) Length() int {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(selectionData.Native())

	ret := C.gtk_selection_data_get_length(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Pixbuf gets the contents of the selection data as a Pixbuf.
func (selectionData *SelectionData) Pixbuf() gdkpixbuf.Pixbuf {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(selectionData.Native())

	ret := C.gtk_selection_data_get_pixbuf(arg0)

	var ret0 gdkpixbuf.Pixbuf

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gdkpixbuf.Pixbuf)

	return ret0
}

// Selection retrieves the selection Atom of the selection data.
func (selectionData *SelectionData) Selection() gdk.Atom {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(selectionData.Native())

	ret := C.gtk_selection_data_get_selection(arg0)

	var ret0 gdk.Atom

	{
		ret0 = gdk.WrapAtom(unsafe.Pointer(ret))
	}

	return ret0
}

// Target retrieves the target of the selection.
func (selectionData *SelectionData) Target() gdk.Atom {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(selectionData.Native())

	ret := C.gtk_selection_data_get_target(arg0)

	var ret0 gdk.Atom

	{
		ret0 = gdk.WrapAtom(unsafe.Pointer(ret))
	}

	return ret0
}

// Targets gets the contents of @selection_data as an array of targets. This can
// be used to interpret the results of getting the standard TARGETS target that
// is always supplied for any selection.
func (selectionData *SelectionData) Targets() (targets []*gdk.Atom, nAtoms int, ok bool) {
	var arg0 *C.GtkSelectionData
	var arg1 **C.GdkAtom // out
	var arg2 *C.gint     // out

	arg0 = (*C.GtkSelectionData)(selectionData.Native())

	ret := C.gtk_selection_data_get_targets(arg0, &arg1, &arg2)

	var ret0 []*gdk.Atom
	var ret1 int
	var ret2 bool

	{
		ret0 = make([]*gdk.Atom, arg2)
		for i := 0; i < uintptr(arg2); i++ {
			src := (*C.GdkAtom)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			{
				ret0[i] = gdk.WrapAtom(unsafe.Pointer(src))
			}
		}
	}

	ret1 = int(arg2)

	ret2 = C.BOOL(ret) != 0

	return ret0, ret1, ret2
}

// Text gets the contents of the selection data as a UTF-8 string.
func (selectionData *SelectionData) Text() string {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(selectionData.Native())

	ret := C.gtk_selection_data_get_text(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Uris gets the contents of the selection data as array of URIs.
func (selectionData *SelectionData) Uris() []string {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(selectionData.Native())

	ret := C.gtk_selection_data_get_uris(arg0)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// Set stores new data into a SelectionData object. Should only be called from a
// selection handler callback. Zero-terminates the stored data.
func (selectionData *SelectionData) Set(typ gdk.Atom, format int, data []byte) {
	var arg0 *C.GtkSelectionData
	var arg1 C.GdkAtom
	var arg2 C.gint
	var arg3 *C.guchar
	var arg4 C.gint

	arg0 = (*C.GtkSelectionData)(selectionData.Native())
	arg1 = (C.GdkAtom)(typ.Native())
	arg2 = C.gint(format)
	arg3 = (*C.guchar)(unsafe.Pointer(&data[0]))
	arg4 = len(data)
	defer runtime.KeepAlive(data)

	C.gtk_selection_data_set(arg0, arg1, arg2, arg3, arg4)
}

// SetPixbuf sets the contents of the selection from a Pixbuf The pixbuf is
// converted to the form determined by @selection_data->target.
func (selectionData *SelectionData) SetPixbuf(pixbuf gdkpixbuf.Pixbuf) bool {
	var arg0 *C.GtkSelectionData
	var arg1 *C.GdkPixbuf

	arg0 = (*C.GtkSelectionData)(selectionData.Native())
	arg1 = (*C.GdkPixbuf)(pixbuf.Native())

	ret := C.gtk_selection_data_set_pixbuf(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SetText sets the contents of the selection from a UTF-8 encoded string. The
// string is converted to the form determined by @selection_data->target.
func (selectionData *SelectionData) SetText(str string, len int) bool {
	var arg0 *C.GtkSelectionData
	var arg1 *C.gchar
	var arg2 C.gint

	arg0 = (*C.GtkSelectionData)(selectionData.Native())
	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(len)

	ret := C.gtk_selection_data_set_text(arg0, arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SetUris sets the contents of the selection from a list of URIs. The string is
// converted to the form determined by @selection_data->target.
func (selectionData *SelectionData) SetUris(uris []string) bool {
	var arg0 *C.GtkSelectionData
	var arg1 **C.gchar

	arg0 = (*C.GtkSelectionData)(selectionData.Native())
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(uris) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(uris)
		sliceHeader.Cap = len(uris)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(uris); i++ {
			src := uris[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg1 = (**C.gchar)(unsafe.Pointer(ptr))
	}

	ret := C.gtk_selection_data_set_uris(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// TargetsIncludeImage: given a SelectionData object holding a list of targets,
// determines if any of the targets in @targets can be used to provide a Pixbuf.
func (selectionData *SelectionData) TargetsIncludeImage(writable bool) bool {
	var arg0 *C.GtkSelectionData
	var arg1 C.gboolean

	arg0 = (*C.GtkSelectionData)(selectionData.Native())
	if writable {
		arg1 = C.TRUE
	}

	ret := C.gtk_selection_data_targets_include_image(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// TargetsIncludeRichText: given a SelectionData object holding a list of
// targets, determines if any of the targets in @targets can be used to provide
// rich text.
func (selectionData *SelectionData) TargetsIncludeRichText(buffer TextBuffer) bool {
	var arg0 *C.GtkSelectionData
	var arg1 *C.GtkTextBuffer

	arg0 = (*C.GtkSelectionData)(selectionData.Native())
	arg1 = (*C.GtkTextBuffer)(buffer.Native())

	ret := C.gtk_selection_data_targets_include_rich_text(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// TargetsIncludeText: given a SelectionData object holding a list of targets,
// determines if any of the targets in @targets can be used to provide text.
func (selectionData *SelectionData) TargetsIncludeText() bool {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(selectionData.Native())

	ret := C.gtk_selection_data_targets_include_text(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// TargetsIncludeURI: given a SelectionData object holding a list of targets,
// determines if any of the targets in @targets can be used to provide a list or
// URIs.
func (selectionData *SelectionData) TargetsIncludeURI() bool {
	var arg0 *C.GtkSelectionData

	arg0 = (*C.GtkSelectionData)(selectionData.Native())

	ret := C.gtk_selection_data_targets_include_uri(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

type SeparatorPrivate struct {
	native C.GtkSeparatorPrivate
}

// WrapSeparatorPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSeparatorPrivate(ptr unsafe.Pointer) *SeparatorPrivate {
	if ptr == nil {
		return nil
	}

	return (*SeparatorPrivate)(ptr)
}

func marshalSeparatorPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSeparatorPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *SeparatorPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

type SeparatorToolItemPrivate struct {
	native C.GtkSeparatorToolItemPrivate
}

// WrapSeparatorToolItemPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSeparatorToolItemPrivate(ptr unsafe.Pointer) *SeparatorToolItemPrivate {
	if ptr == nil {
		return nil
	}

	return (*SeparatorToolItemPrivate)(ptr)
}

func marshalSeparatorToolItemPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSeparatorToolItemPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *SeparatorToolItemPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

type SettingsPrivate struct {
	native C.GtkSettingsPrivate
}

// WrapSettingsPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSettingsPrivate(ptr unsafe.Pointer) *SettingsPrivate {
	if ptr == nil {
		return nil
	}

	return (*SettingsPrivate)(ptr)
}

func marshalSettingsPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSettingsPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *SettingsPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

type SettingsValue struct {
	native C.GtkSettingsValue
}

// WrapSettingsValue wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSettingsValue(ptr unsafe.Pointer) *SettingsValue {
	if ptr == nil {
		return nil
	}

	return (*SettingsValue)(ptr)
}

func marshalSettingsValue(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSettingsValue(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *SettingsValue) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// Origin gets the field inside the struct.
func (s *SettingsValue) Origin() string {
	var ret string
	ret = C.GoString(s.native.origin)
	return ret
}

// Value gets the field inside the struct.
func (s *SettingsValue) Value() *externglib.Value {
	var ret *externglib.Value
	ret = externglib.ValueFromNative(unsafe.Pointer(s.native.value))
	return ret
}

type SizeGroupPrivate struct {
	native C.GtkSizeGroupPrivate
}

// WrapSizeGroupPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSizeGroupPrivate(ptr unsafe.Pointer) *SizeGroupPrivate {
	if ptr == nil {
		return nil
	}

	return (*SizeGroupPrivate)(ptr)
}

func marshalSizeGroupPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSizeGroupPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *SizeGroupPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

type SocketAccessiblePrivate struct {
	native C.GtkSocketAccessiblePrivate
}

// WrapSocketAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSocketAccessiblePrivate(ptr unsafe.Pointer) *SocketAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*SocketAccessiblePrivate)(ptr)
}

func marshalSocketAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSocketAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *SocketAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

type SocketPrivate struct {
	native C.GtkSocketPrivate
}

// WrapSocketPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSocketPrivate(ptr unsafe.Pointer) *SocketPrivate {
	if ptr == nil {
		return nil
	}

	return (*SocketPrivate)(ptr)
}

func marshalSocketPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSocketPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *SocketPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

type SpinButtonAccessiblePrivate struct {
	native C.GtkSpinButtonAccessiblePrivate
}

// WrapSpinButtonAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSpinButtonAccessiblePrivate(ptr unsafe.Pointer) *SpinButtonAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*SpinButtonAccessiblePrivate)(ptr)
}

func marshalSpinButtonAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSpinButtonAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *SpinButtonAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

type SpinButtonPrivate struct {
	native C.GtkSpinButtonPrivate
}

// WrapSpinButtonPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSpinButtonPrivate(ptr unsafe.Pointer) *SpinButtonPrivate {
	if ptr == nil {
		return nil
	}

	return (*SpinButtonPrivate)(ptr)
}

func marshalSpinButtonPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSpinButtonPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *SpinButtonPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

type SpinnerAccessiblePrivate struct {
	native C.GtkSpinnerAccessiblePrivate
}

// WrapSpinnerAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSpinnerAccessiblePrivate(ptr unsafe.Pointer) *SpinnerAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*SpinnerAccessiblePrivate)(ptr)
}

func marshalSpinnerAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSpinnerAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *SpinnerAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

type SpinnerPrivate struct {
	native C.GtkSpinnerPrivate
}

// WrapSpinnerPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSpinnerPrivate(ptr unsafe.Pointer) *SpinnerPrivate {
	if ptr == nil {
		return nil
	}

	return (*SpinnerPrivate)(ptr)
}

func marshalSpinnerPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSpinnerPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *SpinnerPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

type StackSidebarPrivate struct {
	native C.GtkStackSidebarPrivate
}

// WrapStackSidebarPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapStackSidebarPrivate(ptr unsafe.Pointer) *StackSidebarPrivate {
	if ptr == nil {
		return nil
	}

	return (*StackSidebarPrivate)(ptr)
}

func marshalStackSidebarPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapStackSidebarPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *StackSidebarPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

type StatusIconPrivate struct {
	native C.GtkStatusIconPrivate
}

// WrapStatusIconPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapStatusIconPrivate(ptr unsafe.Pointer) *StatusIconPrivate {
	if ptr == nil {
		return nil
	}

	return (*StatusIconPrivate)(ptr)
}

func marshalStatusIconPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapStatusIconPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *StatusIconPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

type StatusbarAccessiblePrivate struct {
	native C.GtkStatusbarAccessiblePrivate
}

// WrapStatusbarAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapStatusbarAccessiblePrivate(ptr unsafe.Pointer) *StatusbarAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*StatusbarAccessiblePrivate)(ptr)
}

func marshalStatusbarAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapStatusbarAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *StatusbarAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

type StatusbarPrivate struct {
	native C.GtkStatusbarPrivate
}

// WrapStatusbarPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapStatusbarPrivate(ptr unsafe.Pointer) *StatusbarPrivate {
	if ptr == nil {
		return nil
	}

	return (*StatusbarPrivate)(ptr)
}

func marshalStatusbarPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapStatusbarPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *StatusbarPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

type StockItem struct {
	native C.GtkStockItem
}

// WrapStockItem wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapStockItem(ptr unsafe.Pointer) *StockItem {
	if ptr == nil {
		return nil
	}

	return (*StockItem)(ptr)
}

func marshalStockItem(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapStockItem(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *StockItem) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// StockID gets the field inside the struct.
func (s *StockItem) StockID() string {
	var ret string
	ret = C.GoString(s.native.stock_id)
	return ret
}

// Label gets the field inside the struct.
func (s *StockItem) Label() string {
	var ret string
	ret = C.GoString(s.native.label)
	return ret
}

// Modifier gets the field inside the struct.
func (s *StockItem) Modifier() gdk.ModifierType {
	var ret gdk.ModifierType
	ret = gdk.ModifierType(s.native.modifier)
	return ret
}

// Keyval gets the field inside the struct.
func (s *StockItem) Keyval() uint {
	var ret uint
	ret = uint(s.native.keyval)
	return ret
}

// TranslationDomain gets the field inside the struct.
func (s *StockItem) TranslationDomain() string {
	var ret string
	ret = C.GoString(s.native.translation_domain)
	return ret
}

// Copy copies a stock item, mostly useful for language bindings and not in
// applications.
func (item *StockItem) Copy() *StockItem {
	var arg0 *C.GtkStockItem

	arg0 = (*C.GtkStockItem)(item.Native())

	ret := C.gtk_stock_item_copy(arg0)

	var ret0 *StockItem

	{
		ret0 = WrapStockItem(unsafe.Pointer(ret))
	}

	return ret0
}

// Free frees a stock item allocated on the heap, such as one returned by
// gtk_stock_item_copy(). Also frees the fields inside the stock item, if they
// are not nil.
func (item *StockItem) Free() {
	var arg0 *C.GtkStockItem

	arg0 = (*C.GtkStockItem)(item.Native())

	C.gtk_stock_item_free(arg0)
}

type StyleContextPrivate struct {
	native C.GtkStyleContextPrivate
}

// WrapStyleContextPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapStyleContextPrivate(ptr unsafe.Pointer) *StyleContextPrivate {
	if ptr == nil {
		return nil
	}

	return (*StyleContextPrivate)(ptr)
}

func marshalStyleContextPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapStyleContextPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *StyleContextPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

type StylePropertiesPrivate struct {
	native C.GtkStylePropertiesPrivate
}

// WrapStylePropertiesPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapStylePropertiesPrivate(ptr unsafe.Pointer) *StylePropertiesPrivate {
	if ptr == nil {
		return nil
	}

	return (*StylePropertiesPrivate)(ptr)
}

func marshalStylePropertiesPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapStylePropertiesPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *StylePropertiesPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

type SwitchAccessiblePrivate struct {
	native C.GtkSwitchAccessiblePrivate
}

// WrapSwitchAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSwitchAccessiblePrivate(ptr unsafe.Pointer) *SwitchAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*SwitchAccessiblePrivate)(ptr)
}

func marshalSwitchAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSwitchAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *SwitchAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

type SwitchPrivate struct {
	native C.GtkSwitchPrivate
}

// WrapSwitchPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSwitchPrivate(ptr unsafe.Pointer) *SwitchPrivate {
	if ptr == nil {
		return nil
	}

	return (*SwitchPrivate)(ptr)
}

func marshalSwitchPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSwitchPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *SwitchPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// SymbolicColor: gtkSymbolicColor is a boxed type that represents a symbolic
// color. It is the result of parsing a [color
// expression][gtkcssprovider-symbolic-colors]. To obtain the color represented
// by a GtkSymbolicColor, it has to be resolved with
// gtk_symbolic_color_resolve(), which replaces all symbolic color references by
// the colors they refer to (in a given context) and evaluates mix, shade and
// other expressions, resulting in a RGBA value.
//
// It is not normally necessary to deal directly with SymbolicColors, since they
// are mostly used behind the scenes by StyleContext and CssProvider.
//
// SymbolicColor is deprecated. Symbolic colors are considered an implementation
// detail of GTK+.
type SymbolicColor struct {
	native C.GtkSymbolicColor
}

// WrapSymbolicColor wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSymbolicColor(ptr unsafe.Pointer) *SymbolicColor {
	if ptr == nil {
		return nil
	}

	return (*SymbolicColor)(ptr)
}

func marshalSymbolicColor(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSymbolicColor(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *SymbolicColor) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// NewSymbolicColorAlpha constructs a struct SymbolicColor.
func NewSymbolicColorAlpha(color *SymbolicColor, factor float64) *SymbolicColor {
	var arg1 *C.GtkSymbolicColor
	var arg2 C.gdouble

	arg1 = (*C.GtkSymbolicColor)(color.Native())
	arg2 = C.gdouble(factor)

	ret := C.gtk_symbolic_color_new_alpha(arg1, arg2)

	var ret0 *SymbolicColor

	{
		ret0 = WrapSymbolicColor(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *SymbolicColor) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewSymbolicColorLiteral constructs a struct SymbolicColor.
func NewSymbolicColorLiteral(color *gdk.RGBA) *SymbolicColor {
	var arg1 *C.GdkRGBA

	arg1 = (*C.GdkRGBA)(color.Native())

	ret := C.gtk_symbolic_color_new_literal(arg1)

	var ret0 *SymbolicColor

	{
		ret0 = WrapSymbolicColor(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *SymbolicColor) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewSymbolicColorMix constructs a struct SymbolicColor.
func NewSymbolicColorMix(color1 *SymbolicColor, color2 *SymbolicColor, factor float64) *SymbolicColor {
	var arg1 *C.GtkSymbolicColor
	var arg2 *C.GtkSymbolicColor
	var arg3 C.gdouble

	arg1 = (*C.GtkSymbolicColor)(color1.Native())
	arg2 = (*C.GtkSymbolicColor)(color2.Native())
	arg3 = C.gdouble(factor)

	ret := C.gtk_symbolic_color_new_mix(arg1, arg2, arg3)

	var ret0 *SymbolicColor

	{
		ret0 = WrapSymbolicColor(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *SymbolicColor) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewSymbolicColorName constructs a struct SymbolicColor.
func NewSymbolicColorName(name string) *SymbolicColor {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_symbolic_color_new_name(arg1)

	var ret0 *SymbolicColor

	{
		ret0 = WrapSymbolicColor(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *SymbolicColor) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewSymbolicColorShade constructs a struct SymbolicColor.
func NewSymbolicColorShade(color *SymbolicColor, factor float64) *SymbolicColor {
	var arg1 *C.GtkSymbolicColor
	var arg2 C.gdouble

	arg1 = (*C.GtkSymbolicColor)(color.Native())
	arg2 = C.gdouble(factor)

	ret := C.gtk_symbolic_color_new_shade(arg1, arg2)

	var ret0 *SymbolicColor

	{
		ret0 = WrapSymbolicColor(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *SymbolicColor) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewSymbolicColorWin32 constructs a struct SymbolicColor.
func NewSymbolicColorWin32(themeClass string, id int) *SymbolicColor {
	var arg1 *C.gchar
	var arg2 C.gint

	arg1 = (*C.gchar)(C.CString(themeClass))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(id)

	ret := C.gtk_symbolic_color_new_win32(arg1, arg2)

	var ret0 *SymbolicColor

	{
		ret0 = WrapSymbolicColor(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *SymbolicColor) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Ref increases the reference count of @color
func (color *SymbolicColor) Ref() *SymbolicColor {
	var arg0 *C.GtkSymbolicColor

	arg0 = (*C.GtkSymbolicColor)(color.Native())

	ret := C.gtk_symbolic_color_ref(arg0)

	var ret0 *SymbolicColor

	{
		ret0 = WrapSymbolicColor(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *SymbolicColor) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Resolve: if @color is resolvable, @resolved_color will be filled in with the
// resolved color, and true will be returned. Generally, if @color can’t be
// resolved, it is due to it being defined on top of a named color that doesn’t
// exist in @props.
//
// When @props is nil, resolving of named colors will fail, so if your @color is
// or references such a color, this function will return false.
func (color *SymbolicColor) Resolve(props StyleProperties) (resolvedColor gdk.RGBA, ok bool) {
	var arg0 *C.GtkSymbolicColor
	var arg1 *C.GtkStyleProperties
	var arg2 *C.GdkRGBA // out

	arg0 = (*C.GtkSymbolicColor)(color.Native())
	arg1 = (*C.GtkStyleProperties)(props.Native())

	ret := C.gtk_symbolic_color_resolve(arg0, arg1, &arg2)

	var ret0 *gdk.RGBA
	var ret1 bool

	{
		ret0 = gdk.WrapRGBA(unsafe.Pointer(arg2))
	}

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// String converts the given @color to a string representation. This is useful
// both for debugging and for serialization of strings. The format of the string
// may change between different versions of GTK, but it is guaranteed that the
// GTK css parser is able to read the string and create the same symbolic color
// from it.
func (color *SymbolicColor) String() string {
	var arg0 *C.GtkSymbolicColor

	arg0 = (*C.GtkSymbolicColor)(color.Native())

	ret := C.gtk_symbolic_color_to_string(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Unref decreases the reference count of @color, freeing its memory if the
// reference count reaches 0.
func (color *SymbolicColor) Unref() {
	var arg0 *C.GtkSymbolicColor

	arg0 = (*C.GtkSymbolicColor)(color.Native())

	C.gtk_symbolic_color_unref(arg0)
}

type TableChild struct {
	native C.GtkTableChild
}

// WrapTableChild wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTableChild(ptr unsafe.Pointer) *TableChild {
	if ptr == nil {
		return nil
	}

	return (*TableChild)(ptr)
}

func marshalTableChild(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTableChild(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TableChild) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// Widget gets the field inside the struct.
func (t *TableChild) Widget() Widget {
	var ret Widget
	ret = gextras.CastObject(externglib.Take(unsafe.Pointer(t.native.widget.Native()))).(Widget)
	return ret
}

// LeftAttach gets the field inside the struct.
func (t *TableChild) LeftAttach() uint16 {
	var ret uint16
	ret = uint16(t.native.left_attach)
	return ret
}

// RightAttach gets the field inside the struct.
func (t *TableChild) RightAttach() uint16 {
	var ret uint16
	ret = uint16(t.native.right_attach)
	return ret
}

// TopAttach gets the field inside the struct.
func (t *TableChild) TopAttach() uint16 {
	var ret uint16
	ret = uint16(t.native.top_attach)
	return ret
}

// BottomAttach gets the field inside the struct.
func (t *TableChild) BottomAttach() uint16 {
	var ret uint16
	ret = uint16(t.native.bottom_attach)
	return ret
}

// Xpadding gets the field inside the struct.
func (t *TableChild) Xpadding() uint16 {
	var ret uint16
	ret = uint16(t.native.xpadding)
	return ret
}

// Ypadding gets the field inside the struct.
func (t *TableChild) Ypadding() uint16 {
	var ret uint16
	ret = uint16(t.native.ypadding)
	return ret
}

type TablePrivate struct {
	native C.GtkTablePrivate
}

// WrapTablePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTablePrivate(ptr unsafe.Pointer) *TablePrivate {
	if ptr == nil {
		return nil
	}

	return (*TablePrivate)(ptr)
}

func marshalTablePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTablePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TablePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

type TableRowCol struct {
	native C.GtkTableRowCol
}

// WrapTableRowCol wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTableRowCol(ptr unsafe.Pointer) *TableRowCol {
	if ptr == nil {
		return nil
	}

	return (*TableRowCol)(ptr)
}

func marshalTableRowCol(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTableRowCol(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TableRowCol) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// Requisition gets the field inside the struct.
func (t *TableRowCol) Requisition() uint16 {
	var ret uint16
	ret = uint16(t.native.requisition)
	return ret
}

// Allocation gets the field inside the struct.
func (t *TableRowCol) Allocation() uint16 {
	var ret uint16
	ret = uint16(t.native.allocation)
	return ret
}

// Spacing gets the field inside the struct.
func (t *TableRowCol) Spacing() uint16 {
	var ret uint16
	ret = uint16(t.native.spacing)
	return ret
}

// TargetEntry: a TargetEntry represents a single type of data than can be
// supplied for by a widget for a selection or for supplied or received during
// drag-and-drop.
type TargetEntry struct {
	native C.GtkTargetEntry
}

// WrapTargetEntry wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTargetEntry(ptr unsafe.Pointer) *TargetEntry {
	if ptr == nil {
		return nil
	}

	return (*TargetEntry)(ptr)
}

func marshalTargetEntry(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTargetEntry(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TargetEntry) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// NewTargetEntry constructs a struct TargetEntry.
func NewTargetEntry(target string, flags uint, info uint) *TargetEntry {
	var arg1 *C.gchar
	var arg2 C.guint
	var arg3 C.guint

	arg1 = (*C.gchar)(C.CString(target))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.guint(flags)
	arg3 = C.guint(info)

	ret := C.gtk_target_entry_new(arg1, arg2, arg3)

	var ret0 *TargetEntry

	{
		ret0 = WrapTargetEntry(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *TargetEntry) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Target gets the field inside the struct.
func (t *TargetEntry) Target() string {
	var ret string
	ret = C.GoString(t.native.target)
	return ret
}

// Flags gets the field inside the struct.
func (t *TargetEntry) Flags() uint {
	var ret uint
	ret = uint(t.native.flags)
	return ret
}

// Info gets the field inside the struct.
func (t *TargetEntry) Info() uint {
	var ret uint
	ret = uint(t.native.info)
	return ret
}

// Copy makes a copy of a TargetEntry and its data.
func (data *TargetEntry) Copy() *TargetEntry {
	var arg0 *C.GtkTargetEntry

	arg0 = (*C.GtkTargetEntry)(data.Native())

	ret := C.gtk_target_entry_copy(arg0)

	var ret0 *TargetEntry

	{
		ret0 = WrapTargetEntry(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *TargetEntry) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Free frees a TargetEntry returned from gtk_target_entry_new() or
// gtk_target_entry_copy().
func (data *TargetEntry) Free() {
	var arg0 *C.GtkTargetEntry

	arg0 = (*C.GtkTargetEntry)(data.Native())

	C.gtk_target_entry_free(arg0)
}

// TargetList: a TargetList-struct is a reference counted list of TargetPair and
// should be treated as opaque.
type TargetList struct {
	native C.GtkTargetList
}

// WrapTargetList wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTargetList(ptr unsafe.Pointer) *TargetList {
	if ptr == nil {
		return nil
	}

	return (*TargetList)(ptr)
}

func marshalTargetList(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTargetList(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TargetList) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// NewTargetList constructs a struct TargetList.
func NewTargetList(targets []TargetEntry) *TargetList {
	var arg1 *C.GtkTargetEntry
	var arg2 C.guint

	{
		var dst []C.GtkTargetEntry
		ptr := C.malloc(C.sizeof_GtkTargetEntry * len(targets))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(targets)
		sliceHeader.Cap = len(targets)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(targets); i++ {
			src := targets[i]
			dst[i] = (C.GtkTargetEntry)(src.Native())
		}

		arg1 = (*C.GtkTargetEntry)(unsafe.Pointer(ptr))
		arg2 = len(targets)
	}

	ret := C.gtk_target_list_new(arg1, arg2)

	var ret0 *TargetList

	{
		ret0 = WrapTargetList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *TargetList) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Add appends another target to a TargetList.
func (list *TargetList) Add(target gdk.Atom, flags uint, info uint) {
	var arg0 *C.GtkTargetList
	var arg1 C.GdkAtom
	var arg2 C.guint
	var arg3 C.guint

	arg0 = (*C.GtkTargetList)(list.Native())
	arg1 = (C.GdkAtom)(target.Native())
	arg2 = C.guint(flags)
	arg3 = C.guint(info)

	C.gtk_target_list_add(arg0, arg1, arg2, arg3)
}

// AddImageTargets appends the image targets supported by SelectionData to the
// target list. All targets are added with the same @info.
func (list *TargetList) AddImageTargets(info uint, writable bool) {
	var arg0 *C.GtkTargetList
	var arg1 C.guint
	var arg2 C.gboolean

	arg0 = (*C.GtkTargetList)(list.Native())
	arg1 = C.guint(info)
	if writable {
		arg2 = C.TRUE
	}

	C.gtk_target_list_add_image_targets(arg0, arg1, arg2)
}

// AddRichTextTargets appends the rich text targets registered with
// gtk_text_buffer_register_serialize_format() or
// gtk_text_buffer_register_deserialize_format() to the target list. All targets
// are added with the same @info.
func (list *TargetList) AddRichTextTargets(info uint, deserializable bool, buffer TextBuffer) {
	var arg0 *C.GtkTargetList
	var arg1 C.guint
	var arg2 C.gboolean
	var arg3 *C.GtkTextBuffer

	arg0 = (*C.GtkTargetList)(list.Native())
	arg1 = C.guint(info)
	if deserializable {
		arg2 = C.TRUE
	}
	arg3 = (*C.GtkTextBuffer)(buffer.Native())

	C.gtk_target_list_add_rich_text_targets(arg0, arg1, arg2, arg3)
}

// AddTable prepends a table of TargetEntry to a target list.
func (list *TargetList) AddTable(targets []TargetEntry) {
	var arg0 *C.GtkTargetList
	var arg1 *C.GtkTargetEntry
	var arg2 C.guint

	arg0 = (*C.GtkTargetList)(list.Native())
	{
		var dst []C.GtkTargetEntry
		ptr := C.malloc(C.sizeof_GtkTargetEntry * len(targets))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(targets)
		sliceHeader.Cap = len(targets)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(targets); i++ {
			src := targets[i]
			dst[i] = (C.GtkTargetEntry)(src.Native())
		}

		arg1 = (*C.GtkTargetEntry)(unsafe.Pointer(ptr))
		arg2 = len(targets)
	}

	C.gtk_target_list_add_table(arg0, arg1, arg2)
}

// AddTextTargets appends the text targets supported by SelectionData to the
// target list. All targets are added with the same @info.
func (list *TargetList) AddTextTargets(info uint) {
	var arg0 *C.GtkTargetList
	var arg1 C.guint

	arg0 = (*C.GtkTargetList)(list.Native())
	arg1 = C.guint(info)

	C.gtk_target_list_add_text_targets(arg0, arg1)
}

// AddURITargets appends the URI targets supported by SelectionData to the
// target list. All targets are added with the same @info.
func (list *TargetList) AddURITargets(info uint) {
	var arg0 *C.GtkTargetList
	var arg1 C.guint

	arg0 = (*C.GtkTargetList)(list.Native())
	arg1 = C.guint(info)

	C.gtk_target_list_add_uri_targets(arg0, arg1)
}

// Find looks up a given target in a TargetList.
func (list *TargetList) Find(target gdk.Atom) (info uint, ok bool) {
	var arg0 *C.GtkTargetList
	var arg1 C.GdkAtom
	var arg2 *C.guint // out

	arg0 = (*C.GtkTargetList)(list.Native())
	arg1 = (C.GdkAtom)(target.Native())

	ret := C.gtk_target_list_find(arg0, arg1, &arg2)

	var ret0 uint
	var ret1 bool

	ret0 = uint(arg2)

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// Ref increases the reference count of a TargetList by one.
func (list *TargetList) Ref() *TargetList {
	var arg0 *C.GtkTargetList

	arg0 = (*C.GtkTargetList)(list.Native())

	ret := C.gtk_target_list_ref(arg0)

	var ret0 *TargetList

	{
		ret0 = WrapTargetList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *TargetList) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Remove removes a target from a target list.
func (list *TargetList) Remove(target gdk.Atom) {
	var arg0 *C.GtkTargetList
	var arg1 C.GdkAtom

	arg0 = (*C.GtkTargetList)(list.Native())
	arg1 = (C.GdkAtom)(target.Native())

	C.gtk_target_list_remove(arg0, arg1)
}

// Unref decreases the reference count of a TargetList by one. If the resulting
// reference count is zero, frees the list.
func (list *TargetList) Unref() {
	var arg0 *C.GtkTargetList

	arg0 = (*C.GtkTargetList)(list.Native())

	C.gtk_target_list_unref(arg0)
}

// TargetPair: a TargetPair is used to represent the same information as a table
// of TargetEntry, but in an efficient form.
type TargetPair struct {
	native C.GtkTargetPair
}

// WrapTargetPair wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTargetPair(ptr unsafe.Pointer) *TargetPair {
	if ptr == nil {
		return nil
	}

	return (*TargetPair)(ptr)
}

func marshalTargetPair(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTargetPair(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TargetPair) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// Target gets the field inside the struct.
func (t *TargetPair) Target() gdk.Atom {
	var ret gdk.Atom
	{
		ret = gdk.WrapAtom(unsafe.Pointer(t.native.target))
	}
	return ret
}

// Flags gets the field inside the struct.
func (t *TargetPair) Flags() uint {
	var ret uint
	ret = uint(t.native.flags)
	return ret
}

// Info gets the field inside the struct.
func (t *TargetPair) Info() uint {
	var ret uint
	ret = uint(t.native.info)
	return ret
}

type TearoffMenuItemPrivate struct {
	native C.GtkTearoffMenuItemPrivate
}

// WrapTearoffMenuItemPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTearoffMenuItemPrivate(ptr unsafe.Pointer) *TearoffMenuItemPrivate {
	if ptr == nil {
		return nil
	}

	return (*TearoffMenuItemPrivate)(ptr)
}

func marshalTearoffMenuItemPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTearoffMenuItemPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TearoffMenuItemPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

type TextAppearance struct {
	native C.GtkTextAppearance
}

// WrapTextAppearance wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTextAppearance(ptr unsafe.Pointer) *TextAppearance {
	if ptr == nil {
		return nil
	}

	return (*TextAppearance)(ptr)
}

func marshalTextAppearance(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTextAppearance(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TextAppearance) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// BgColor gets the field inside the struct.
func (t *TextAppearance) BgColor() gdk.Color {
	var ret gdk.Color
	{
		ret = gdk.WrapColor(unsafe.Pointer(t.native.bg_color))
	}
	return ret
}

// FgColor gets the field inside the struct.
func (t *TextAppearance) FgColor() gdk.Color {
	var ret gdk.Color
	{
		ret = gdk.WrapColor(unsafe.Pointer(t.native.fg_color))
	}
	return ret
}

// Rise gets the field inside the struct.
func (t *TextAppearance) Rise() int {
	var ret int
	ret = int(t.native.rise)
	return ret
}

// TextAttributes: using TextAttributes directly should rarely be necessary.
// It’s primarily useful with gtk_text_iter_get_attributes(). As with most GTK+
// structs, the fields in this struct should only be read, never modified
// directly.
type TextAttributes struct {
	native C.GtkTextAttributes
}

// WrapTextAttributes wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTextAttributes(ptr unsafe.Pointer) *TextAttributes {
	if ptr == nil {
		return nil
	}

	return (*TextAttributes)(ptr)
}

func marshalTextAttributes(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTextAttributes(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TextAttributes) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// NewTextAttributes constructs a struct TextAttributes.
func NewTextAttributes() *TextAttributes {

	ret := C.gtk_text_attributes_new()

	var ret0 *TextAttributes

	{
		ret0 = WrapTextAttributes(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *TextAttributes) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Appearance gets the field inside the struct.
func (t *TextAttributes) Appearance() TextAppearance {
	var ret TextAppearance
	{
		ret = WrapTextAppearance(unsafe.Pointer(t.native.appearance))
	}
	return ret
}

// Justification gets the field inside the struct.
func (t *TextAttributes) Justification() Justification {
	var ret Justification
	ret = Justification(t.native.justification)
	return ret
}

// Direction gets the field inside the struct.
func (t *TextAttributes) Direction() TextDirection {
	var ret TextDirection
	ret = TextDirection(t.native.direction)
	return ret
}

// Font gets the field inside the struct.
func (t *TextAttributes) Font() *pango.FontDescription {
	var ret *pango.FontDescription
	{
		ret = pango.WrapFontDescription(unsafe.Pointer(t.native.font))
	}
	return ret
}

// FontScale gets the field inside the struct.
func (t *TextAttributes) FontScale() float64 {
	var ret float64
	ret = float64(t.native.font_scale)
	return ret
}

// LeftMargin gets the field inside the struct.
func (t *TextAttributes) LeftMargin() int {
	var ret int
	ret = int(t.native.left_margin)
	return ret
}

// RightMargin gets the field inside the struct.
func (t *TextAttributes) RightMargin() int {
	var ret int
	ret = int(t.native.right_margin)
	return ret
}

// Indent gets the field inside the struct.
func (t *TextAttributes) Indent() int {
	var ret int
	ret = int(t.native.indent)
	return ret
}

// PixelsAboveLines gets the field inside the struct.
func (t *TextAttributes) PixelsAboveLines() int {
	var ret int
	ret = int(t.native.pixels_above_lines)
	return ret
}

// PixelsBelowLines gets the field inside the struct.
func (t *TextAttributes) PixelsBelowLines() int {
	var ret int
	ret = int(t.native.pixels_below_lines)
	return ret
}

// PixelsInsideWrap gets the field inside the struct.
func (t *TextAttributes) PixelsInsideWrap() int {
	var ret int
	ret = int(t.native.pixels_inside_wrap)
	return ret
}

// Tabs gets the field inside the struct.
func (t *TextAttributes) Tabs() *pango.TabArray {
	var ret *pango.TabArray
	{
		ret = pango.WrapTabArray(unsafe.Pointer(t.native.tabs))
	}
	return ret
}

// WrapMode gets the field inside the struct.
func (t *TextAttributes) WrapMode() WrapMode {
	var ret WrapMode
	ret = WrapMode(t.native.wrap_mode)
	return ret
}

// Language gets the field inside the struct.
func (t *TextAttributes) Language() *pango.Language {
	var ret *pango.Language
	{
		ret = pango.WrapLanguage(unsafe.Pointer(t.native.language))
	}
	return ret
}

// LetterSpacing gets the field inside the struct.
func (t *TextAttributes) LetterSpacing() int {
	var ret int
	ret = int(t.native.letter_spacing)
	return ret
}

// Copy copies @src and returns a new TextAttributes.
func (src *TextAttributes) Copy() *TextAttributes {
	var arg0 *C.GtkTextAttributes

	arg0 = (*C.GtkTextAttributes)(src.Native())

	ret := C.gtk_text_attributes_copy(arg0)

	var ret0 *TextAttributes

	{
		ret0 = WrapTextAttributes(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *TextAttributes) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// CopyValues copies the values from @src to @dest so that @dest has the same
// values as @src. Frees existing values in @dest.
func (src *TextAttributes) CopyValues(dest *TextAttributes) {
	var arg0 *C.GtkTextAttributes
	var arg1 *C.GtkTextAttributes

	arg0 = (*C.GtkTextAttributes)(src.Native())
	arg1 = (*C.GtkTextAttributes)(dest.Native())

	C.gtk_text_attributes_copy_values(arg0, arg1)
}

// Ref increments the reference count on @values.
func (values *TextAttributes) Ref() *TextAttributes {
	var arg0 *C.GtkTextAttributes

	arg0 = (*C.GtkTextAttributes)(values.Native())

	ret := C.gtk_text_attributes_ref(arg0)

	var ret0 *TextAttributes

	{
		ret0 = WrapTextAttributes(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *TextAttributes) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Unref decrements the reference count on @values, freeing the structure if the
// reference count reaches 0.
func (values *TextAttributes) Unref() {
	var arg0 *C.GtkTextAttributes

	arg0 = (*C.GtkTextAttributes)(values.Native())

	C.gtk_text_attributes_unref(arg0)
}

type TextBTree struct {
	native C.GtkTextBTree
}

// WrapTextBTree wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTextBTree(ptr unsafe.Pointer) *TextBTree {
	if ptr == nil {
		return nil
	}

	return (*TextBTree)(ptr)
}

func marshalTextBTree(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTextBTree(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TextBTree) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

type TextBufferPrivate struct {
	native C.GtkTextBufferPrivate
}

// WrapTextBufferPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTextBufferPrivate(ptr unsafe.Pointer) *TextBufferPrivate {
	if ptr == nil {
		return nil
	}

	return (*TextBufferPrivate)(ptr)
}

func marshalTextBufferPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTextBufferPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TextBufferPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

type TextCellAccessiblePrivate struct {
	native C.GtkTextCellAccessiblePrivate
}

// WrapTextCellAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTextCellAccessiblePrivate(ptr unsafe.Pointer) *TextCellAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*TextCellAccessiblePrivate)(ptr)
}

func marshalTextCellAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTextCellAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TextCellAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// TextIter: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
type TextIter struct {
	native C.GtkTextIter
}

// WrapTextIter wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTextIter(ptr unsafe.Pointer) *TextIter {
	if ptr == nil {
		return nil
	}

	return (*TextIter)(ptr)
}

func marshalTextIter(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTextIter(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TextIter) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// Assign assigns the value of @other to @iter. This function is not useful in
// applications, because iterators can be assigned with `GtkTextIter i = j;`.
// The function is used by language bindings.
func (iter *TextIter) Assign(other *TextIter) {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())
	arg1 = (*C.GtkTextIter)(other.Native())

	C.gtk_text_iter_assign(arg0, arg1)
}

// BackwardChar moves backward by one character offset. Returns true if movement
// was possible; if @iter was the first in the buffer (character offset 0),
// gtk_text_iter_backward_char() returns false for convenience when writing
// loops.
func (iter *TextIter) BackwardChar() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_backward_char(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// BackwardChars moves @count characters backward, if possible (if @count would
// move past the start or end of the buffer, moves to the start or end of the
// buffer). The return value indicates whether the iterator moved onto a
// dereferenceable position; if the iterator didn’t move, or moved onto the end
// iterator, then false is returned. If @count is 0, the function does nothing
// and returns false.
func (iter *TextIter) BackwardChars(count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(iter.Native())
	arg1 = C.gint(count)

	ret := C.gtk_text_iter_backward_chars(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// BackwardCursorPosition: like gtk_text_iter_forward_cursor_position(), but
// moves backward.
func (iter *TextIter) BackwardCursorPosition() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_backward_cursor_position(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// BackwardCursorPositions moves up to @count cursor positions. See
// gtk_text_iter_forward_cursor_position() for details.
func (iter *TextIter) BackwardCursorPositions(count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(iter.Native())
	arg1 = C.gint(count)

	ret := C.gtk_text_iter_backward_cursor_positions(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// BackwardFindChar: same as gtk_text_iter_forward_find_char(), but goes
// backward from @iter.
func (iter *TextIter) BackwardFindChar(pred TextCharPredicate, limit *TextIter) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.GtkTextCharPredicate
	var arg2 C.gpointer
	var arg3 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())
	arg1 = (*[0]byte)(C.gotk4_TextCharPredicate)
	arg2 = C.gpointer(box.Assign(pred))
	arg3 = (*C.GtkTextIter)(limit.Native())

	ret := C.gtk_text_iter_backward_find_char(arg0, arg1, arg2, arg3)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// BackwardLine moves @iter to the start of the previous line. Returns true if
// @iter could be moved; i.e. if @iter was at character offset 0, this function
// returns false. Therefore if @iter was already on line 0, but not at the start
// of the line, @iter is snapped to the start of the line and the function
// returns true. (Note that this implies that in a loop calling this function,
// the line number may not change on every iteration, if your first iteration is
// on line 0.)
func (iter *TextIter) BackwardLine() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_backward_line(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// BackwardLines moves @count lines backward, if possible (if @count would move
// past the start or end of the buffer, moves to the start or end of the
// buffer). The return value indicates whether the iterator moved onto a
// dereferenceable position; if the iterator didn’t move, or moved onto the end
// iterator, then false is returned. If @count is 0, the function does nothing
// and returns false. If @count is negative, moves forward by 0 - @count lines.
func (iter *TextIter) BackwardLines(count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(iter.Native())
	arg1 = C.gint(count)

	ret := C.gtk_text_iter_backward_lines(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// BackwardSearch: same as gtk_text_iter_forward_search(), but moves backward.
//
// @match_end will never be set to a TextIter located after @iter, even if there
// is a possible @match_start before or at @iter.
func (iter *TextIter) BackwardSearch(str string, flags TextSearchFlags, limit *TextIter) (matchStart TextIter, matchEnd TextIter, ok bool) {
	var arg0 *C.GtkTextIter
	var arg1 *C.gchar
	var arg2 C.GtkTextSearchFlags
	var arg3 *C.GtkTextIter // out
	var arg4 *C.GtkTextIter // out
	var arg5 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())
	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GtkTextSearchFlags)(flags)
	arg5 = (*C.GtkTextIter)(limit.Native())

	ret := C.gtk_text_iter_backward_search(arg0, arg1, arg2, &arg3, &arg4, arg5)

	var ret0 *TextIter
	var ret1 *TextIter
	var ret2 bool

	{
		ret0 = WrapTextIter(unsafe.Pointer(arg3))
	}

	{
		ret1 = WrapTextIter(unsafe.Pointer(arg4))
	}

	ret2 = C.BOOL(ret) != 0

	return ret0, ret1, ret2
}

// BackwardSentenceStart moves backward to the previous sentence start; if @iter
// is already at the start of a sentence, moves backward to the next one.
// Sentence boundaries are determined by Pango and should be correct for nearly
// any language (if not, the correct fix would be to the Pango text boundary
// algorithms).
func (iter *TextIter) BackwardSentenceStart() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_backward_sentence_start(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// BackwardSentenceStarts calls gtk_text_iter_backward_sentence_start() up to
// @count times, or until it returns false. If @count is negative, moves forward
// instead of backward.
func (iter *TextIter) BackwardSentenceStarts(count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(iter.Native())
	arg1 = C.gint(count)

	ret := C.gtk_text_iter_backward_sentence_starts(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// BackwardToTagToggle moves backward to the next toggle (on or off) of the
// TextTag @tag, or to the next toggle of any tag if @tag is nil. If no matching
// tag toggles are found, returns false, otherwise true. Does not return toggles
// located at @iter, only toggles before @iter. Sets @iter to the location of
// the toggle, or the start of the buffer if no toggle is found.
func (iter *TextIter) BackwardToTagToggle(tag TextTag) bool {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextTag

	arg0 = (*C.GtkTextIter)(iter.Native())
	arg1 = (*C.GtkTextTag)(tag.Native())

	ret := C.gtk_text_iter_backward_to_tag_toggle(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// BackwardVisibleCursorPosition moves @iter forward to the previous visible
// cursor position. See gtk_text_iter_backward_cursor_position() for details.
func (iter *TextIter) BackwardVisibleCursorPosition() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_backward_visible_cursor_position(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// BackwardVisibleCursorPositions moves up to @count visible cursor positions.
// See gtk_text_iter_backward_cursor_position() for details.
func (iter *TextIter) BackwardVisibleCursorPositions(count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(iter.Native())
	arg1 = C.gint(count)

	ret := C.gtk_text_iter_backward_visible_cursor_positions(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// BackwardVisibleLine moves @iter to the start of the previous visible line.
// Returns true if @iter could be moved; i.e. if @iter was at character offset
// 0, this function returns false. Therefore if @iter was already on line 0, but
// not at the start of the line, @iter is snapped to the start of the line and
// the function returns true. (Note that this implies that in a loop calling
// this function, the line number may not change on every iteration, if your
// first iteration is on line 0.)
func (iter *TextIter) BackwardVisibleLine() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_backward_visible_line(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// BackwardVisibleLines moves @count visible lines backward, if possible (if
// @count would move past the start or end of the buffer, moves to the start or
// end of the buffer). The return value indicates whether the iterator moved
// onto a dereferenceable position; if the iterator didn’t move, or moved onto
// the end iterator, then false is returned. If @count is 0, the function does
// nothing and returns false. If @count is negative, moves forward by 0 - @count
// lines.
func (iter *TextIter) BackwardVisibleLines(count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(iter.Native())
	arg1 = C.gint(count)

	ret := C.gtk_text_iter_backward_visible_lines(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// BackwardVisibleWordStart moves backward to the previous visible word start.
// (If @iter is currently on a word start, moves backward to the next one after
// that.) Word breaks are determined by Pango and should be correct for nearly
// any language (if not, the correct fix would be to the Pango word break
// algorithms).
func (iter *TextIter) BackwardVisibleWordStart() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_backward_visible_word_start(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// BackwardVisibleWordStarts calls gtk_text_iter_backward_visible_word_start()
// up to @count times.
func (iter *TextIter) BackwardVisibleWordStarts(count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(iter.Native())
	arg1 = C.gint(count)

	ret := C.gtk_text_iter_backward_visible_word_starts(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// BackwardWordStart moves backward to the previous word start. (If @iter is
// currently on a word start, moves backward to the next one after that.) Word
// breaks are determined by Pango and should be correct for nearly any language
// (if not, the correct fix would be to the Pango word break algorithms).
func (iter *TextIter) BackwardWordStart() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_backward_word_start(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// BackwardWordStarts calls gtk_text_iter_backward_word_start() up to @count
// times.
func (iter *TextIter) BackwardWordStarts(count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(iter.Native())
	arg1 = C.gint(count)

	ret := C.gtk_text_iter_backward_word_starts(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// BeginsTag returns true if @tag is toggled on at exactly this point. If @tag
// is nil, returns true if any tag is toggled on at this point.
//
// Note that if gtk_text_iter_begins_tag() returns true, it means that @iter is
// at the beginning of the tagged range, and that the character at @iter is
// inside the tagged range. In other words, unlike gtk_text_iter_ends_tag(), if
// gtk_text_iter_begins_tag() returns true, gtk_text_iter_has_tag() will also
// return true for the same parameters.
func (iter *TextIter) BeginsTag(tag TextTag) bool {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextTag

	arg0 = (*C.GtkTextIter)(iter.Native())
	arg1 = (*C.GtkTextTag)(tag.Native())

	ret := C.gtk_text_iter_begins_tag(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// CanInsert: considering the default editability of the buffer, and tags that
// affect editability, determines whether text inserted at @iter would be
// editable. If text inserted at @iter would be editable then the user should be
// allowed to insert text at @iter. gtk_text_buffer_insert_interactive() uses
// this function to decide whether insertions are allowed at a given position.
func (iter *TextIter) CanInsert(defaultEditability bool) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gboolean

	arg0 = (*C.GtkTextIter)(iter.Native())
	if defaultEditability {
		arg1 = C.TRUE
	}

	ret := C.gtk_text_iter_can_insert(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Compare: a qsort()-style function that returns negative if @lhs is less than
// @rhs, positive if @lhs is greater than @rhs, and 0 if they’re equal. Ordering
// is in character offset order, i.e. the first character in the buffer is less
// than the second character in the buffer.
func (lhs *TextIter) Compare(rhs *TextIter) int {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(lhs.Native())
	arg1 = (*C.GtkTextIter)(rhs.Native())

	ret := C.gtk_text_iter_compare(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Copy creates a dynamically-allocated copy of an iterator. This function is
// not useful in applications, because iterators can be copied with a simple
// assignment (`GtkTextIter i = j;`). The function is used by language bindings.
func (iter *TextIter) Copy() *TextIter {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_copy(arg0)

	var ret0 *TextIter

	{
		ret0 = WrapTextIter(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *TextIter) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Editable returns whether the character at @iter is within an editable region
// of text. Non-editable text is “locked” and can’t be changed by the user via
// TextView. This function is simply a convenience wrapper around
// gtk_text_iter_get_attributes(). If no tags applied to this text affect
// editability, @default_setting will be returned.
//
// You don’t want to use this function to decide whether text can be inserted at
// @iter, because for insertion you don’t want to know whether the char at @iter
// is inside an editable range, you want to know whether a new character
// inserted at @iter would be inside an editable range. Use
// gtk_text_iter_can_insert() to handle this case.
func (iter *TextIter) Editable(defaultSetting bool) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gboolean

	arg0 = (*C.GtkTextIter)(iter.Native())
	if defaultSetting {
		arg1 = C.TRUE
	}

	ret := C.gtk_text_iter_editable(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// EndsLine returns true if @iter points to the start of the paragraph delimiter
// characters for a line (delimiters will be either a newline, a carriage
// return, a carriage return followed by a newline, or a Unicode paragraph
// separator character). Note that an iterator pointing to the \n of a \r\n pair
// will not be counted as the end of a line, the line ends before the \r. The
// end iterator is considered to be at the end of a line, even though there are
// no paragraph delimiter chars there.
func (iter *TextIter) EndsLine() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_ends_line(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// EndsSentence determines whether @iter ends a sentence. Sentence boundaries
// are determined by Pango and should be correct for nearly any language (if
// not, the correct fix would be to the Pango text boundary algorithms).
func (iter *TextIter) EndsSentence() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_ends_sentence(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// EndsTag returns true if @tag is toggled off at exactly this point. If @tag is
// nil, returns true if any tag is toggled off at this point.
//
// Note that if gtk_text_iter_ends_tag() returns true, it means that @iter is at
// the end of the tagged range, but that the character at @iter is outside the
// tagged range. In other words, unlike gtk_text_iter_starts_tag(), if
// gtk_text_iter_ends_tag() returns true, gtk_text_iter_has_tag() will return
// false for the same parameters.
func (iter *TextIter) EndsTag(tag TextTag) bool {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextTag

	arg0 = (*C.GtkTextIter)(iter.Native())
	arg1 = (*C.GtkTextTag)(tag.Native())

	ret := C.gtk_text_iter_ends_tag(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// EndsWord determines whether @iter ends a natural-language word. Word breaks
// are determined by Pango and should be correct for nearly any language (if
// not, the correct fix would be to the Pango word break algorithms).
func (iter *TextIter) EndsWord() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_ends_word(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Equal tests whether two iterators are equal, using the fastest possible
// mechanism. This function is very fast; you can expect it to perform better
// than e.g. getting the character offset for each iterator and comparing the
// offsets yourself. Also, it’s a bit faster than gtk_text_iter_compare().
func (lhs *TextIter) Equal(rhs *TextIter) bool {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(lhs.Native())
	arg1 = (*C.GtkTextIter)(rhs.Native())

	ret := C.gtk_text_iter_equal(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ForwardChar moves @iter forward by one character offset. Note that images
// embedded in the buffer occupy 1 character slot, so
// gtk_text_iter_forward_char() may actually move onto an image instead of a
// character, if you have images in your buffer. If @iter is the end iterator or
// one character before it, @iter will now point at the end iterator, and
// gtk_text_iter_forward_char() returns false for convenience when writing
// loops.
func (iter *TextIter) ForwardChar() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_forward_char(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ForwardChars moves @count characters if possible (if @count would move past
// the start or end of the buffer, moves to the start or end of the buffer). The
// return value indicates whether the new position of @iter is different from
// its original position, and dereferenceable (the last iterator in the buffer
// is not dereferenceable). If @count is 0, the function does nothing and
// returns false.
func (iter *TextIter) ForwardChars(count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(iter.Native())
	arg1 = C.gint(count)

	ret := C.gtk_text_iter_forward_chars(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ForwardCursorPosition moves @iter forward by a single cursor position. Cursor
// positions are (unsurprisingly) positions where the cursor can appear. Perhaps
// surprisingly, there may not be a cursor position between all characters. The
// most common example for European languages would be a carriage return/newline
// sequence. For some Unicode characters, the equivalent of say the letter “a”
// with an accent mark will be represented as two characters, first the letter
// then a "combining mark" that causes the accent to be rendered; so the cursor
// can’t go between those two characters. See also the LogAttr-struct and
// pango_break() function.
func (iter *TextIter) ForwardCursorPosition() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_forward_cursor_position(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ForwardCursorPositions moves up to @count cursor positions. See
// gtk_text_iter_forward_cursor_position() for details.
func (iter *TextIter) ForwardCursorPositions(count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(iter.Native())
	arg1 = C.gint(count)

	ret := C.gtk_text_iter_forward_cursor_positions(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ForwardFindChar advances @iter, calling @pred on each character. If @pred
// returns true, returns true and stops scanning. If @pred never returns true,
// @iter is set to @limit if @limit is non-nil, otherwise to the end iterator.
func (iter *TextIter) ForwardFindChar(pred TextCharPredicate, limit *TextIter) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.GtkTextCharPredicate
	var arg2 C.gpointer
	var arg3 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())
	arg1 = (*[0]byte)(C.gotk4_TextCharPredicate)
	arg2 = C.gpointer(box.Assign(pred))
	arg3 = (*C.GtkTextIter)(limit.Native())

	ret := C.gtk_text_iter_forward_find_char(arg0, arg1, arg2, arg3)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ForwardLine moves @iter to the start of the next line. If the iter is already
// on the last line of the buffer, moves the iter to the end of the current
// line. If after the operation, the iter is at the end of the buffer and not
// dereferencable, returns false. Otherwise, returns true.
func (iter *TextIter) ForwardLine() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_forward_line(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ForwardLines moves @count lines forward, if possible (if @count would move
// past the start or end of the buffer, moves to the start or end of the
// buffer). The return value indicates whether the iterator moved onto a
// dereferenceable position; if the iterator didn’t move, or moved onto the end
// iterator, then false is returned. If @count is 0, the function does nothing
// and returns false. If @count is negative, moves backward by 0 - @count lines.
func (iter *TextIter) ForwardLines(count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(iter.Native())
	arg1 = C.gint(count)

	ret := C.gtk_text_iter_forward_lines(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ForwardSearch searches forward for @str. Any match is returned by setting
// @match_start to the first character of the match and @match_end to the first
// character after the match. The search will not continue past @limit. Note
// that a search is a linear or O(n) operation, so you may wish to use @limit to
// avoid locking up your UI on large buffers.
//
// @match_start will never be set to a TextIter located before @iter, even if
// there is a possible @match_end after or at @iter.
func (iter *TextIter) ForwardSearch(str string, flags TextSearchFlags, limit *TextIter) (matchStart TextIter, matchEnd TextIter, ok bool) {
	var arg0 *C.GtkTextIter
	var arg1 *C.gchar
	var arg2 C.GtkTextSearchFlags
	var arg3 *C.GtkTextIter // out
	var arg4 *C.GtkTextIter // out
	var arg5 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())
	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GtkTextSearchFlags)(flags)
	arg5 = (*C.GtkTextIter)(limit.Native())

	ret := C.gtk_text_iter_forward_search(arg0, arg1, arg2, &arg3, &arg4, arg5)

	var ret0 *TextIter
	var ret1 *TextIter
	var ret2 bool

	{
		ret0 = WrapTextIter(unsafe.Pointer(arg3))
	}

	{
		ret1 = WrapTextIter(unsafe.Pointer(arg4))
	}

	ret2 = C.BOOL(ret) != 0

	return ret0, ret1, ret2
}

// ForwardSentenceEnd moves forward to the next sentence end. (If @iter is at
// the end of a sentence, moves to the next end of sentence.) Sentence
// boundaries are determined by Pango and should be correct for nearly any
// language (if not, the correct fix would be to the Pango text boundary
// algorithms).
func (iter *TextIter) ForwardSentenceEnd() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_forward_sentence_end(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ForwardSentenceEnds calls gtk_text_iter_forward_sentence_end() @count times
// (or until gtk_text_iter_forward_sentence_end() returns false). If @count is
// negative, moves backward instead of forward.
func (iter *TextIter) ForwardSentenceEnds(count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(iter.Native())
	arg1 = C.gint(count)

	ret := C.gtk_text_iter_forward_sentence_ends(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ForwardToEnd moves @iter forward to the “end iterator,” which points one past
// the last valid character in the buffer. gtk_text_iter_get_char() called on
// the end iterator returns 0, which is convenient for writing loops.
func (iter *TextIter) ForwardToEnd() {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	C.gtk_text_iter_forward_to_end(arg0)
}

// ForwardToLineEnd moves the iterator to point to the paragraph delimiter
// characters, which will be either a newline, a carriage return, a carriage
// return/newline in sequence, or the Unicode paragraph separator character. If
// the iterator is already at the paragraph delimiter characters, moves to the
// paragraph delimiter characters for the next line. If @iter is on the last
// line in the buffer, which does not end in paragraph delimiters, moves to the
// end iterator (end of the last line), and returns false.
func (iter *TextIter) ForwardToLineEnd() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_forward_to_line_end(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ForwardToTagToggle moves forward to the next toggle (on or off) of the
// TextTag @tag, or to the next toggle of any tag if @tag is nil. If no matching
// tag toggles are found, returns false, otherwise true. Does not return toggles
// located at @iter, only toggles after @iter. Sets @iter to the location of the
// toggle, or to the end of the buffer if no toggle is found.
func (iter *TextIter) ForwardToTagToggle(tag TextTag) bool {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextTag

	arg0 = (*C.GtkTextIter)(iter.Native())
	arg1 = (*C.GtkTextTag)(tag.Native())

	ret := C.gtk_text_iter_forward_to_tag_toggle(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ForwardVisibleCursorPosition moves @iter forward to the next visible cursor
// position. See gtk_text_iter_forward_cursor_position() for details.
func (iter *TextIter) ForwardVisibleCursorPosition() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_forward_visible_cursor_position(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ForwardVisibleCursorPositions moves up to @count visible cursor positions.
// See gtk_text_iter_forward_cursor_position() for details.
func (iter *TextIter) ForwardVisibleCursorPositions(count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(iter.Native())
	arg1 = C.gint(count)

	ret := C.gtk_text_iter_forward_visible_cursor_positions(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ForwardVisibleLine moves @iter to the start of the next visible line. Returns
// true if there was a next line to move to, and false if @iter was simply moved
// to the end of the buffer and is now not dereferenceable, or if @iter was
// already at the end of the buffer.
func (iter *TextIter) ForwardVisibleLine() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_forward_visible_line(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ForwardVisibleLines moves @count visible lines forward, if possible (if
// @count would move past the start or end of the buffer, moves to the start or
// end of the buffer). The return value indicates whether the iterator moved
// onto a dereferenceable position; if the iterator didn’t move, or moved onto
// the end iterator, then false is returned. If @count is 0, the function does
// nothing and returns false. If @count is negative, moves backward by 0 -
// @count lines.
func (iter *TextIter) ForwardVisibleLines(count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(iter.Native())
	arg1 = C.gint(count)

	ret := C.gtk_text_iter_forward_visible_lines(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ForwardVisibleWordEnd moves forward to the next visible word end. (If @iter
// is currently on a word end, moves forward to the next one after that.) Word
// breaks are determined by Pango and should be correct for nearly any language
// (if not, the correct fix would be to the Pango word break algorithms).
func (iter *TextIter) ForwardVisibleWordEnd() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_forward_visible_word_end(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ForwardVisibleWordEnds calls gtk_text_iter_forward_visible_word_end() up to
// @count times.
func (iter *TextIter) ForwardVisibleWordEnds(count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(iter.Native())
	arg1 = C.gint(count)

	ret := C.gtk_text_iter_forward_visible_word_ends(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ForwardWordEnd moves forward to the next word end. (If @iter is currently on
// a word end, moves forward to the next one after that.) Word breaks are
// determined by Pango and should be correct for nearly any language (if not,
// the correct fix would be to the Pango word break algorithms).
func (iter *TextIter) ForwardWordEnd() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_forward_word_end(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ForwardWordEnds calls gtk_text_iter_forward_word_end() up to @count times.
func (iter *TextIter) ForwardWordEnds(count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(iter.Native())
	arg1 = C.gint(count)

	ret := C.gtk_text_iter_forward_word_ends(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Free: free an iterator allocated on the heap. This function is intended for
// use in language bindings, and is not especially useful for applications,
// because iterators can simply be allocated on the stack.
func (iter *TextIter) Free() {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	C.gtk_text_iter_free(arg0)
}

// Attributes computes the effect of any tags applied to this spot in the text.
// The @values parameter should be initialized to the default settings you wish
// to use if no tags are in effect. You’d typically obtain the defaults from
// gtk_text_view_get_default_attributes().
//
// gtk_text_iter_get_attributes() will modify @values, applying the effects of
// any tags present at @iter. If any tags affected @values, the function returns
// true.
func (iter *TextIter) Attributes() (values TextAttributes, ok bool) {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextAttributes // out

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_get_attributes(arg0, &arg1)

	var ret0 *TextAttributes
	var ret1 bool

	{
		ret0 = WrapTextAttributes(unsafe.Pointer(arg1))
	}

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// Buffer returns the TextBuffer this iterator is associated with.
func (iter *TextIter) Buffer() TextBuffer {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_get_buffer(arg0)

	var ret0 TextBuffer

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(TextBuffer)

	return ret0
}

// BytesInLine returns the number of bytes in the line containing @iter,
// including the paragraph delimiters.
func (iter *TextIter) BytesInLine() int {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_get_bytes_in_line(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Char: the Unicode character at this iterator is returned. (Equivalent to
// operator* on a C++ iterator.) If the element at this iterator is a
// non-character element, such as an image embedded in the buffer, the Unicode
// “unknown” character 0xFFFC is returned. If invoked on the end iterator, zero
// is returned; zero is not a valid Unicode character. So you can write a loop
// which ends when gtk_text_iter_get_char() returns 0.
func (iter *TextIter) Char() uint32 {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_get_char(arg0)

	var ret0 uint32

	ret0 = uint32(ret)

	return ret0
}

// CharsInLine returns the number of characters in the line containing @iter,
// including the paragraph delimiters.
func (iter *TextIter) CharsInLine() int {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_get_chars_in_line(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ChildAnchor: if the location at @iter contains a child anchor, the anchor is
// returned (with no new reference count added). Otherwise, nil is returned.
func (iter *TextIter) ChildAnchor() TextChildAnchor {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_get_child_anchor(arg0)

	var ret0 TextChildAnchor

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(TextChildAnchor)

	return ret0
}

// Language: a convenience wrapper around gtk_text_iter_get_attributes(), which
// returns the language in effect at @iter. If no tags affecting language apply
// to @iter, the return value is identical to that of
// gtk_get_default_language().
func (iter *TextIter) Language() *pango.Language {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_get_language(arg0)

	var ret0 *pango.Language

	{
		ret0 = pango.WrapLanguage(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *pango.Language) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Line returns the line number containing the iterator. Lines in a TextBuffer
// are numbered beginning with 0 for the first line in the buffer.
func (iter *TextIter) Line() int {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_get_line(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// LineIndex returns the byte index of the iterator, counting from the start of
// a newline-terminated line. Remember that TextBuffer encodes text in UTF-8,
// and that characters can require a variable number of bytes to represent.
func (iter *TextIter) LineIndex() int {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_get_line_index(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// LineOffset returns the character offset of the iterator, counting from the
// start of a newline-terminated line. The first character on the line has
// offset 0.
func (iter *TextIter) LineOffset() int {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_get_line_offset(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Marks returns a list of all TextMark at this location. Because marks are not
// iterable (they don’t take up any "space" in the buffer, they are just marks
// in between iterable locations), multiple marks can exist in the same place.
// The returned list is not in any meaningful order.
func (iter *TextIter) Marks() *glib.SList {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_get_marks(arg0)

	var ret0 *glib.SList

	{
		ret0 = glib.WrapSList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.SList) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Offset returns the character offset of an iterator. Each character in a
// TextBuffer has an offset, starting with 0 for the first character in the
// buffer. Use gtk_text_buffer_get_iter_at_offset() to convert an offset back
// into an iterator.
func (iter *TextIter) Offset() int {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_get_offset(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Pixbuf: if the element at @iter is a pixbuf, the pixbuf is returned (with no
// new reference count added). Otherwise, nil is returned.
func (iter *TextIter) Pixbuf() gdkpixbuf.Pixbuf {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_get_pixbuf(arg0)

	var ret0 gdkpixbuf.Pixbuf

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gdkpixbuf.Pixbuf)

	return ret0
}

// Slice returns the text in the given range. A “slice” is an array of
// characters encoded in UTF-8 format, including the Unicode “unknown” character
// 0xFFFC for iterable non-character elements in the buffer, such as images.
// Because images are encoded in the slice, byte and character offsets in the
// returned array will correspond to byte offsets in the text buffer. Note that
// 0xFFFC can occur in normal text as well, so it is not a reliable indicator
// that a pixbuf or widget is in the buffer.
func (start *TextIter) Slice(end *TextIter) string {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(start.Native())
	arg1 = (*C.GtkTextIter)(end.Native())

	ret := C.gtk_text_iter_get_slice(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Tags returns a list of tags that apply to @iter, in ascending order of
// priority (highest-priority tags are last). The TextTag in the list don’t have
// a reference added, but you have to free the list itself.
func (iter *TextIter) Tags() *glib.SList {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_get_tags(arg0)

	var ret0 *glib.SList

	{
		ret0 = glib.WrapSList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.SList) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Text returns text in the given range. If the range contains non-text elements
// such as images, the character and byte offsets in the returned string will
// not correspond to character and byte offsets in the buffer. If you want
// offsets to correspond, see gtk_text_iter_get_slice().
func (start *TextIter) Text(end *TextIter) string {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(start.Native())
	arg1 = (*C.GtkTextIter)(end.Native())

	ret := C.gtk_text_iter_get_text(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// ToggledTags returns a list of TextTag that are toggled on or off at this
// point. (If @toggled_on is true, the list contains tags that are toggled on.)
// If a tag is toggled on at @iter, then some non-empty range of characters
// following @iter has that tag applied to it. If a tag is toggled off, then
// some non-empty range following @iter does not have the tag applied to it.
func (iter *TextIter) ToggledTags(toggledOn bool) *glib.SList {
	var arg0 *C.GtkTextIter
	var arg1 C.gboolean

	arg0 = (*C.GtkTextIter)(iter.Native())
	if toggledOn {
		arg1 = C.TRUE
	}

	ret := C.gtk_text_iter_get_toggled_tags(arg0, arg1)

	var ret0 *glib.SList

	{
		ret0 = glib.WrapSList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.SList) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// VisibleLineIndex returns the number of bytes from the start of the line to
// the given @iter, not counting bytes that are invisible due to tags with the
// “invisible” flag toggled on.
func (iter *TextIter) VisibleLineIndex() int {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_get_visible_line_index(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// VisibleLineOffset returns the offset in characters from the start of the line
// to the given @iter, not counting characters that are invisible due to tags
// with the “invisible” flag toggled on.
func (iter *TextIter) VisibleLineOffset() int {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_get_visible_line_offset(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// VisibleSlice: like gtk_text_iter_get_slice(), but invisible text is not
// included. Invisible text is usually invisible because a TextTag with the
// “invisible” attribute turned on has been applied to it.
func (start *TextIter) VisibleSlice(end *TextIter) string {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(start.Native())
	arg1 = (*C.GtkTextIter)(end.Native())

	ret := C.gtk_text_iter_get_visible_slice(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// VisibleText: like gtk_text_iter_get_text(), but invisible text is not
// included. Invisible text is usually invisible because a TextTag with the
// “invisible” attribute turned on has been applied to it.
func (start *TextIter) VisibleText(end *TextIter) string {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(start.Native())
	arg1 = (*C.GtkTextIter)(end.Native())

	ret := C.gtk_text_iter_get_visible_text(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// HasTag returns true if @iter points to a character that is part of a range
// tagged with @tag. See also gtk_text_iter_starts_tag() and
// gtk_text_iter_ends_tag().
func (iter *TextIter) HasTag(tag TextTag) bool {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextTag

	arg0 = (*C.GtkTextIter)(iter.Native())
	arg1 = (*C.GtkTextTag)(tag.Native())

	ret := C.gtk_text_iter_has_tag(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// InRange checks whether @iter falls in the range [@start, @end). @start and
// @end must be in ascending order.
func (iter *TextIter) InRange(start *TextIter, end *TextIter) bool {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())
	arg1 = (*C.GtkTextIter)(start.Native())
	arg2 = (*C.GtkTextIter)(end.Native())

	ret := C.gtk_text_iter_in_range(arg0, arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// InsideSentence determines whether @iter is inside a sentence (as opposed to
// in between two sentences, e.g. after a period and before the first letter of
// the next sentence). Sentence boundaries are determined by Pango and should be
// correct for nearly any language (if not, the correct fix would be to the
// Pango text boundary algorithms).
func (iter *TextIter) InsideSentence() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_inside_sentence(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// InsideWord determines whether the character pointed by @iter is part of a
// natural-language word (as opposed to say inside some whitespace). Word breaks
// are determined by Pango and should be correct for nearly any language (if
// not, the correct fix would be to the Pango word break algorithms).
//
// Note that if gtk_text_iter_starts_word() returns true, then this function
// returns true too, since @iter points to the first character of the word.
func (iter *TextIter) InsideWord() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_inside_word(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IsCursorPosition: see gtk_text_iter_forward_cursor_position() or LogAttr or
// pango_break() for details on what a cursor position is.
func (iter *TextIter) IsCursorPosition() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_is_cursor_position(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IsEnd returns true if @iter is the end iterator, i.e. one past the last
// dereferenceable iterator in the buffer. gtk_text_iter_is_end() is the most
// efficient way to check whether an iterator is the end iterator.
func (iter *TextIter) IsEnd() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_is_end(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IsStart returns true if @iter is the first iterator in the buffer, that is if
// @iter has a character offset of 0.
func (iter *TextIter) IsStart() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_is_start(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Order swaps the value of @first and @second if @second comes before @first in
// the buffer. That is, ensures that @first and @second are in sequence. Most
// text buffer functions that take a range call this automatically on your
// behalf, so there’s no real reason to call it yourself in those cases. There
// are some exceptions, such as gtk_text_iter_in_range(), that expect a
// pre-sorted range.
func (first *TextIter) Order(second *TextIter) {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(first.Native())
	arg1 = (*C.GtkTextIter)(second.Native())

	C.gtk_text_iter_order(arg0, arg1)
}

// SetLine moves iterator @iter to the start of the line @line_number. If
// @line_number is negative or larger than the number of lines in the buffer,
// moves @iter to the start of the last line in the buffer.
func (iter *TextIter) SetLine(lineNumber int) {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(iter.Native())
	arg1 = C.gint(lineNumber)

	C.gtk_text_iter_set_line(arg0, arg1)
}

// SetLineIndex: same as gtk_text_iter_set_line_offset(), but works with a byte
// index. The given byte index must be at the start of a character, it can’t be
// in the middle of a UTF-8 encoded character.
func (iter *TextIter) SetLineIndex(byteOnLine int) {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(iter.Native())
	arg1 = C.gint(byteOnLine)

	C.gtk_text_iter_set_line_index(arg0, arg1)
}

// SetLineOffset moves @iter within a line, to a new character (not byte)
// offset. The given character offset must be less than or equal to the number
// of characters in the line; if equal, @iter moves to the start of the next
// line. See gtk_text_iter_set_line_index() if you have a byte index rather than
// a character offset.
func (iter *TextIter) SetLineOffset(charOnLine int) {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(iter.Native())
	arg1 = C.gint(charOnLine)

	C.gtk_text_iter_set_line_offset(arg0, arg1)
}

// SetOffset sets @iter to point to @char_offset. @char_offset counts from the
// start of the entire text buffer, starting with 0.
func (iter *TextIter) SetOffset(charOffset int) {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(iter.Native())
	arg1 = C.gint(charOffset)

	C.gtk_text_iter_set_offset(arg0, arg1)
}

// SetVisibleLineIndex: like gtk_text_iter_set_line_index(), but the index is in
// visible bytes, i.e. text with a tag making it invisible is not counted in the
// index.
func (iter *TextIter) SetVisibleLineIndex(byteOnLine int) {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(iter.Native())
	arg1 = C.gint(byteOnLine)

	C.gtk_text_iter_set_visible_line_index(arg0, arg1)
}

// SetVisibleLineOffset: like gtk_text_iter_set_line_offset(), but the offset is
// in visible characters, i.e. text with a tag making it invisible is not
// counted in the offset.
func (iter *TextIter) SetVisibleLineOffset(charOnLine int) {
	var arg0 *C.GtkTextIter
	var arg1 C.gint

	arg0 = (*C.GtkTextIter)(iter.Native())
	arg1 = C.gint(charOnLine)

	C.gtk_text_iter_set_visible_line_offset(arg0, arg1)
}

// StartsLine returns true if @iter begins a paragraph, i.e. if
// gtk_text_iter_get_line_offset() would return 0. However this function is
// potentially more efficient than gtk_text_iter_get_line_offset() because it
// doesn’t have to compute the offset, it just has to see whether it’s 0.
func (iter *TextIter) StartsLine() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_starts_line(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// StartsSentence determines whether @iter begins a sentence. Sentence
// boundaries are determined by Pango and should be correct for nearly any
// language (if not, the correct fix would be to the Pango text boundary
// algorithms).
func (iter *TextIter) StartsSentence() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_starts_sentence(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// StartsTag returns true if @tag is toggled on at exactly this point. If @tag
// is nil, returns true if any tag is toggled on at this point.
//
// Note that if gtk_text_iter_starts_tag() returns true, it means that @iter is
// at the beginning of the tagged range, and that the character at @iter is
// inside the tagged range. In other words, unlike gtk_text_iter_ends_tag(), if
// gtk_text_iter_starts_tag() returns true, gtk_text_iter_has_tag() will also
// return true for the same parameters.
func (iter *TextIter) StartsTag(tag TextTag) bool {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextTag

	arg0 = (*C.GtkTextIter)(iter.Native())
	arg1 = (*C.GtkTextTag)(tag.Native())

	ret := C.gtk_text_iter_starts_tag(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// StartsWord determines whether @iter begins a natural-language word. Word
// breaks are determined by Pango and should be correct for nearly any language
// (if not, the correct fix would be to the Pango word break algorithms).
func (iter *TextIter) StartsWord() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_iter_starts_word(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// TogglesTag: this is equivalent to (gtk_text_iter_starts_tag() ||
// gtk_text_iter_ends_tag()), i.e. it tells you whether a range with @tag
// applied to it begins or ends at @iter.
func (iter *TextIter) TogglesTag(tag TextTag) bool {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextTag

	arg0 = (*C.GtkTextIter)(iter.Native())
	arg1 = (*C.GtkTextTag)(tag.Native())

	ret := C.gtk_text_iter_toggles_tag(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

type TextTagPrivate struct {
	native C.GtkTextTagPrivate
}

// WrapTextTagPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTextTagPrivate(ptr unsafe.Pointer) *TextTagPrivate {
	if ptr == nil {
		return nil
	}

	return (*TextTagPrivate)(ptr)
}

func marshalTextTagPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTextTagPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TextTagPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

type TextTagTablePrivate struct {
	native C.GtkTextTagTablePrivate
}

// WrapTextTagTablePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTextTagTablePrivate(ptr unsafe.Pointer) *TextTagTablePrivate {
	if ptr == nil {
		return nil
	}

	return (*TextTagTablePrivate)(ptr)
}

func marshalTextTagTablePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTextTagTablePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TextTagTablePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

type TextViewAccessiblePrivate struct {
	native C.GtkTextViewAccessiblePrivate
}

// WrapTextViewAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTextViewAccessiblePrivate(ptr unsafe.Pointer) *TextViewAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*TextViewAccessiblePrivate)(ptr)
}

func marshalTextViewAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTextViewAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TextViewAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

type TextViewPrivate struct {
	native C.GtkTextViewPrivate
}

// WrapTextViewPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTextViewPrivate(ptr unsafe.Pointer) *TextViewPrivate {
	if ptr == nil {
		return nil
	}

	return (*TextViewPrivate)(ptr)
}

func marshalTextViewPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTextViewPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TextViewPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

type ThemeEngine struct {
	native C.GtkThemeEngine
}

// WrapThemeEngine wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapThemeEngine(ptr unsafe.Pointer) *ThemeEngine {
	if ptr == nil {
		return nil
	}

	return (*ThemeEngine)(ptr)
}

func marshalThemeEngine(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapThemeEngine(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *ThemeEngine) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

type ThemingEnginePrivate struct {
	native C.GtkThemingEnginePrivate
}

// WrapThemingEnginePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapThemingEnginePrivate(ptr unsafe.Pointer) *ThemingEnginePrivate {
	if ptr == nil {
		return nil
	}

	return (*ThemingEnginePrivate)(ptr)
}

func marshalThemingEnginePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapThemingEnginePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *ThemingEnginePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// ToggleActionEntry structs are used with gtk_action_group_add_toggle_actions()
// to construct toggle actions.
type ToggleActionEntry struct {
	native C.GtkToggleActionEntry
}

// WrapToggleActionEntry wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapToggleActionEntry(ptr unsafe.Pointer) *ToggleActionEntry {
	if ptr == nil {
		return nil
	}

	return (*ToggleActionEntry)(ptr)
}

func marshalToggleActionEntry(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapToggleActionEntry(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *ToggleActionEntry) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// Name gets the field inside the struct.
func (t *ToggleActionEntry) Name() string {
	var ret string
	ret = C.GoString(t.native.name)
	return ret
}

// StockID gets the field inside the struct.
func (t *ToggleActionEntry) StockID() string {
	var ret string
	ret = C.GoString(t.native.stock_id)
	return ret
}

// Label gets the field inside the struct.
func (t *ToggleActionEntry) Label() string {
	var ret string
	ret = C.GoString(t.native.label)
	return ret
}

// Accelerator gets the field inside the struct.
func (t *ToggleActionEntry) Accelerator() string {
	var ret string
	ret = C.GoString(t.native.accelerator)
	return ret
}

// Tooltip gets the field inside the struct.
func (t *ToggleActionEntry) Tooltip() string {
	var ret string
	ret = C.GoString(t.native.tooltip)
	return ret
}

// IsActive gets the field inside the struct.
func (t *ToggleActionEntry) IsActive() bool {
	var ret bool
	ret = C.BOOL(t.native.is_active) != 0
	return ret
}

type ToggleActionPrivate struct {
	native C.GtkToggleActionPrivate
}

// WrapToggleActionPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapToggleActionPrivate(ptr unsafe.Pointer) *ToggleActionPrivate {
	if ptr == nil {
		return nil
	}

	return (*ToggleActionPrivate)(ptr)
}

func marshalToggleActionPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapToggleActionPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *ToggleActionPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

type ToggleButtonAccessiblePrivate struct {
	native C.GtkToggleButtonAccessiblePrivate
}

// WrapToggleButtonAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapToggleButtonAccessiblePrivate(ptr unsafe.Pointer) *ToggleButtonAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*ToggleButtonAccessiblePrivate)(ptr)
}

func marshalToggleButtonAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapToggleButtonAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *ToggleButtonAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

type ToggleButtonPrivate struct {
	native C.GtkToggleButtonPrivate
}

// WrapToggleButtonPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapToggleButtonPrivate(ptr unsafe.Pointer) *ToggleButtonPrivate {
	if ptr == nil {
		return nil
	}

	return (*ToggleButtonPrivate)(ptr)
}

func marshalToggleButtonPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapToggleButtonPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *ToggleButtonPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

type ToggleToolButtonPrivate struct {
	native C.GtkToggleToolButtonPrivate
}

// WrapToggleToolButtonPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapToggleToolButtonPrivate(ptr unsafe.Pointer) *ToggleToolButtonPrivate {
	if ptr == nil {
		return nil
	}

	return (*ToggleToolButtonPrivate)(ptr)
}

func marshalToggleToolButtonPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapToggleToolButtonPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *ToggleToolButtonPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

type ToolButtonPrivate struct {
	native C.GtkToolButtonPrivate
}

// WrapToolButtonPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapToolButtonPrivate(ptr unsafe.Pointer) *ToolButtonPrivate {
	if ptr == nil {
		return nil
	}

	return (*ToolButtonPrivate)(ptr)
}

func marshalToolButtonPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapToolButtonPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *ToolButtonPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

type ToolItemGroupPrivate struct {
	native C.GtkToolItemGroupPrivate
}

// WrapToolItemGroupPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapToolItemGroupPrivate(ptr unsafe.Pointer) *ToolItemGroupPrivate {
	if ptr == nil {
		return nil
	}

	return (*ToolItemGroupPrivate)(ptr)
}

func marshalToolItemGroupPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapToolItemGroupPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *ToolItemGroupPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

type ToolItemPrivate struct {
	native C.GtkToolItemPrivate
}

// WrapToolItemPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapToolItemPrivate(ptr unsafe.Pointer) *ToolItemPrivate {
	if ptr == nil {
		return nil
	}

	return (*ToolItemPrivate)(ptr)
}

func marshalToolItemPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapToolItemPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *ToolItemPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

type ToolPalettePrivate struct {
	native C.GtkToolPalettePrivate
}

// WrapToolPalettePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapToolPalettePrivate(ptr unsafe.Pointer) *ToolPalettePrivate {
	if ptr == nil {
		return nil
	}

	return (*ToolPalettePrivate)(ptr)
}

func marshalToolPalettePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapToolPalettePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *ToolPalettePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

type ToolbarPrivate struct {
	native C.GtkToolbarPrivate
}

// WrapToolbarPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapToolbarPrivate(ptr unsafe.Pointer) *ToolbarPrivate {
	if ptr == nil {
		return nil
	}

	return (*ToolbarPrivate)(ptr)
}

func marshalToolbarPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapToolbarPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *ToolbarPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

type ToplevelAccessiblePrivate struct {
	native C.GtkToplevelAccessiblePrivate
}

// WrapToplevelAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapToplevelAccessiblePrivate(ptr unsafe.Pointer) *ToplevelAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*ToplevelAccessiblePrivate)(ptr)
}

func marshalToplevelAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapToplevelAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *ToplevelAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// TreeIter: the TreeIter is the primary structure for accessing a TreeModel.
// Models are expected to put a unique integer in the @stamp member, and put
// model-specific data in the three @user_data members.
type TreeIter struct {
	native C.GtkTreeIter
}

// WrapTreeIter wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTreeIter(ptr unsafe.Pointer) *TreeIter {
	if ptr == nil {
		return nil
	}

	return (*TreeIter)(ptr)
}

func marshalTreeIter(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTreeIter(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TreeIter) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// Stamp gets the field inside the struct.
func (t *TreeIter) Stamp() int {
	var ret int
	ret = int(t.native.stamp)
	return ret
}

// UserData gets the field inside the struct.
func (t *TreeIter) UserData() interface{} {
	var ret interface{}
	ret = box.Get(uintptr(t.native.user_data))
	return ret
}

// UserData2 gets the field inside the struct.
func (t *TreeIter) UserData2() interface{} {
	var ret interface{}
	ret = box.Get(uintptr(t.native.user_data2))
	return ret
}

// UserData3 gets the field inside the struct.
func (t *TreeIter) UserData3() interface{} {
	var ret interface{}
	ret = box.Get(uintptr(t.native.user_data3))
	return ret
}

// Copy creates a dynamically allocated tree iterator as a copy of @iter.
//
// This function is not intended for use in applications, because you can just
// copy the structs by value (`GtkTreeIter new_iter = iter;`). You must free
// this iter with gtk_tree_iter_free().
func (iter *TreeIter) Copy() *TreeIter {
	var arg0 *C.GtkTreeIter

	arg0 = (*C.GtkTreeIter)(iter.Native())

	ret := C.gtk_tree_iter_copy(arg0)

	var ret0 *TreeIter

	{
		ret0 = WrapTreeIter(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *TreeIter) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Free frees an iterator that has been allocated by gtk_tree_iter_copy().
//
// This function is mainly used for language bindings.
func (iter *TreeIter) Free() {
	var arg0 *C.GtkTreeIter

	arg0 = (*C.GtkTreeIter)(iter.Native())

	C.gtk_tree_iter_free(arg0)
}

type TreeModelFilterPrivate struct {
	native C.GtkTreeModelFilterPrivate
}

// WrapTreeModelFilterPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTreeModelFilterPrivate(ptr unsafe.Pointer) *TreeModelFilterPrivate {
	if ptr == nil {
		return nil
	}

	return (*TreeModelFilterPrivate)(ptr)
}

func marshalTreeModelFilterPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTreeModelFilterPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TreeModelFilterPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

type TreeModelSortPrivate struct {
	native C.GtkTreeModelSortPrivate
}

// WrapTreeModelSortPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTreeModelSortPrivate(ptr unsafe.Pointer) *TreeModelSortPrivate {
	if ptr == nil {
		return nil
	}

	return (*TreeModelSortPrivate)(ptr)
}

func marshalTreeModelSortPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTreeModelSortPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TreeModelSortPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

type TreePath struct {
	native C.GtkTreePath
}

// WrapTreePath wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTreePath(ptr unsafe.Pointer) *TreePath {
	if ptr == nil {
		return nil
	}

	return (*TreePath)(ptr)
}

func marshalTreePath(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTreePath(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TreePath) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// NewTreePath constructs a struct TreePath.
func NewTreePath() *TreePath {

	ret := C.gtk_tree_path_new()

	var ret0 *TreePath

	{
		ret0 = WrapTreePath(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *TreePath) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewTreePathFirst constructs a struct TreePath.
func NewTreePathFirst() *TreePath {

	ret := C.gtk_tree_path_new_first()

	var ret0 *TreePath

	{
		ret0 = WrapTreePath(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *TreePath) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewTreePathFromIndicesv constructs a struct TreePath.
func NewTreePathFromIndicesv(indices []int) *TreePath {
	var arg1 *C.gint
	var arg2 C.gsize

	arg1 = (*C.gint)(unsafe.Pointer(&indices[0]))
	arg2 = len(indices)
	defer runtime.KeepAlive(indices)

	ret := C.gtk_tree_path_new_from_indicesv(arg1, arg2)

	var ret0 *TreePath

	{
		ret0 = WrapTreePath(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *TreePath) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewTreePathFromString constructs a struct TreePath.
func NewTreePathFromString(path string) *TreePath {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_tree_path_new_from_string(arg1)

	var ret0 *TreePath

	{
		ret0 = WrapTreePath(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *TreePath) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// AppendIndex appends a new index to a path.
//
// As a result, the depth of the path is increased.
func (path *TreePath) AppendIndex(index_ int) {
	var arg0 *C.GtkTreePath
	var arg1 C.gint

	arg0 = (*C.GtkTreePath)(path.Native())
	arg1 = C.gint(index_)

	C.gtk_tree_path_append_index(arg0, arg1)
}

// Compare compares two paths.
//
// If @a appears before @b in a tree, then -1 is returned. If @b appears before
// @a, then 1 is returned. If the two nodes are equal, then 0 is returned.
func (a *TreePath) Compare(b *TreePath) int {
	var arg0 *C.GtkTreePath
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkTreePath)(a.Native())
	arg1 = (*C.GtkTreePath)(b.Native())

	ret := C.gtk_tree_path_compare(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Copy creates a new TreePath-struct as a copy of @path.
func (path *TreePath) Copy() *TreePath {
	var arg0 *C.GtkTreePath

	arg0 = (*C.GtkTreePath)(path.Native())

	ret := C.gtk_tree_path_copy(arg0)

	var ret0 *TreePath

	{
		ret0 = WrapTreePath(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *TreePath) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Down moves @path to point to the first child of the current path.
func (path *TreePath) Down() {
	var arg0 *C.GtkTreePath

	arg0 = (*C.GtkTreePath)(path.Native())

	C.gtk_tree_path_down(arg0)
}

// Free frees @path. If @path is nil, it simply returns.
func (path *TreePath) Free() {
	var arg0 *C.GtkTreePath

	arg0 = (*C.GtkTreePath)(path.Native())

	C.gtk_tree_path_free(arg0)
}

// Depth returns the current depth of @path.
func (path *TreePath) Depth() int {
	var arg0 *C.GtkTreePath

	arg0 = (*C.GtkTreePath)(path.Native())

	ret := C.gtk_tree_path_get_depth(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// IndicesWithDepth returns the current indices of @path.
//
// This is an array of integers, each representing a node in a tree. It also
// returns the number of elements in the array. The array should not be freed.
func (path *TreePath) IndicesWithDepth() (depth int, gints []int) {
	var arg0 *C.GtkTreePath
	var arg1 *C.gint // out

	arg0 = (*C.GtkTreePath)(path.Native())

	ret := C.gtk_tree_path_get_indices_with_depth(arg0, &arg1)

	var ret0 int
	var ret1 []int

	ret0 = int(arg1)

	{
		ret1 = make([]int, arg1)
		for i := 0; i < uintptr(arg1); i++ {
			src := (C.gint)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = int(src)
		}
	}

	return ret0, ret1
}

// IsAncestor returns true if @descendant is a descendant of @path.
func (path *TreePath) IsAncestor(descendant *TreePath) bool {
	var arg0 *C.GtkTreePath
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkTreePath)(path.Native())
	arg1 = (*C.GtkTreePath)(descendant.Native())

	ret := C.gtk_tree_path_is_ancestor(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IsDescendant returns true if @path is a descendant of @ancestor.
func (path *TreePath) IsDescendant(ancestor *TreePath) bool {
	var arg0 *C.GtkTreePath
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkTreePath)(path.Native())
	arg1 = (*C.GtkTreePath)(ancestor.Native())

	ret := C.gtk_tree_path_is_descendant(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Next moves the @path to point to the next node at the current depth.
func (path *TreePath) Next() {
	var arg0 *C.GtkTreePath

	arg0 = (*C.GtkTreePath)(path.Native())

	C.gtk_tree_path_next(arg0)
}

// PrependIndex prepends a new index to a path.
//
// As a result, the depth of the path is increased.
func (path *TreePath) PrependIndex(index_ int) {
	var arg0 *C.GtkTreePath
	var arg1 C.gint

	arg0 = (*C.GtkTreePath)(path.Native())
	arg1 = C.gint(index_)

	C.gtk_tree_path_prepend_index(arg0, arg1)
}

// Prev moves the @path to point to the previous node at the current depth, if
// it exists.
func (path *TreePath) Prev() bool {
	var arg0 *C.GtkTreePath

	arg0 = (*C.GtkTreePath)(path.Native())

	ret := C.gtk_tree_path_prev(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// String generates a string representation of the path.
//
// This string is a “:” separated list of numbers. For example, “4:10:0:3” would
// be an acceptable return value for this string.
func (path *TreePath) String() string {
	var arg0 *C.GtkTreePath

	arg0 = (*C.GtkTreePath)(path.Native())

	ret := C.gtk_tree_path_to_string(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Up moves the @path to point to its parent node, if it has a parent.
func (path *TreePath) Up() bool {
	var arg0 *C.GtkTreePath

	arg0 = (*C.GtkTreePath)(path.Native())

	ret := C.gtk_tree_path_up(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// TreeRowReference: a GtkTreeRowReference tracks model changes so that it
// always refers to the same row (a TreePath refers to a position, not a fixed
// row). Create a new GtkTreeRowReference with gtk_tree_row_reference_new().
type TreeRowReference struct {
	native C.GtkTreeRowReference
}

// WrapTreeRowReference wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTreeRowReference(ptr unsafe.Pointer) *TreeRowReference {
	if ptr == nil {
		return nil
	}

	return (*TreeRowReference)(ptr)
}

func marshalTreeRowReference(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTreeRowReference(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TreeRowReference) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// NewTreeRowReference constructs a struct TreeRowReference.
func NewTreeRowReference(model TreeModel, path *TreePath) *TreeRowReference {
	var arg1 *C.GtkTreeModel
	var arg2 *C.GtkTreePath

	arg1 = (*C.GtkTreeModel)(model.Native())
	arg2 = (*C.GtkTreePath)(path.Native())

	ret := C.gtk_tree_row_reference_new(arg1, arg2)

	var ret0 *TreeRowReference

	{
		ret0 = WrapTreeRowReference(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *TreeRowReference) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NewTreeRowReferenceProxy constructs a struct TreeRowReference.
func NewTreeRowReferenceProxy(proxy gextras.Objector, model TreeModel, path *TreePath) *TreeRowReference {
	var arg1 *C.GObject
	var arg2 *C.GtkTreeModel
	var arg3 *C.GtkTreePath

	arg1 = (*C.GObject)(proxy.Native())
	arg2 = (*C.GtkTreeModel)(model.Native())
	arg3 = (*C.GtkTreePath)(path.Native())

	ret := C.gtk_tree_row_reference_new_proxy(arg1, arg2, arg3)

	var ret0 *TreeRowReference

	{
		ret0 = WrapTreeRowReference(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *TreeRowReference) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Copy copies a TreeRowReference.
func (reference *TreeRowReference) Copy() *TreeRowReference {
	var arg0 *C.GtkTreeRowReference

	arg0 = (*C.GtkTreeRowReference)(reference.Native())

	ret := C.gtk_tree_row_reference_copy(arg0)

	var ret0 *TreeRowReference

	{
		ret0 = WrapTreeRowReference(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *TreeRowReference) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Free free’s @reference. @reference may be nil
func (reference *TreeRowReference) Free() {
	var arg0 *C.GtkTreeRowReference

	arg0 = (*C.GtkTreeRowReference)(reference.Native())

	C.gtk_tree_row_reference_free(arg0)
}

// Model returns the model that the row reference is monitoring.
func (reference *TreeRowReference) Model() TreeModel {
	var arg0 *C.GtkTreeRowReference

	arg0 = (*C.GtkTreeRowReference)(reference.Native())

	ret := C.gtk_tree_row_reference_get_model(arg0)

	var ret0 TreeModel

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(TreeModel)

	return ret0
}

// Path returns a path that the row reference currently points to, or nil if the
// path pointed to is no longer valid.
func (reference *TreeRowReference) Path() *TreePath {
	var arg0 *C.GtkTreeRowReference

	arg0 = (*C.GtkTreeRowReference)(reference.Native())

	ret := C.gtk_tree_row_reference_get_path(arg0)

	var ret0 *TreePath

	{
		ret0 = WrapTreePath(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *TreePath) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Valid returns true if the @reference is non-nil and refers to a current valid
// path.
func (reference *TreeRowReference) Valid() bool {
	var arg0 *C.GtkTreeRowReference

	arg0 = (*C.GtkTreeRowReference)(reference.Native())

	ret := C.gtk_tree_row_reference_valid(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

type TreeSelectionPrivate struct {
	native C.GtkTreeSelectionPrivate
}

// WrapTreeSelectionPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTreeSelectionPrivate(ptr unsafe.Pointer) *TreeSelectionPrivate {
	if ptr == nil {
		return nil
	}

	return (*TreeSelectionPrivate)(ptr)
}

func marshalTreeSelectionPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTreeSelectionPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TreeSelectionPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

type TreeStorePrivate struct {
	native C.GtkTreeStorePrivate
}

// WrapTreeStorePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTreeStorePrivate(ptr unsafe.Pointer) *TreeStorePrivate {
	if ptr == nil {
		return nil
	}

	return (*TreeStorePrivate)(ptr)
}

func marshalTreeStorePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTreeStorePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TreeStorePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

type TreeViewAccessiblePrivate struct {
	native C.GtkTreeViewAccessiblePrivate
}

// WrapTreeViewAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTreeViewAccessiblePrivate(ptr unsafe.Pointer) *TreeViewAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*TreeViewAccessiblePrivate)(ptr)
}

func marshalTreeViewAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTreeViewAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TreeViewAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

type TreeViewColumnPrivate struct {
	native C.GtkTreeViewColumnPrivate
}

// WrapTreeViewColumnPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTreeViewColumnPrivate(ptr unsafe.Pointer) *TreeViewColumnPrivate {
	if ptr == nil {
		return nil
	}

	return (*TreeViewColumnPrivate)(ptr)
}

func marshalTreeViewColumnPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTreeViewColumnPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TreeViewColumnPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

type TreeViewPrivate struct {
	native C.GtkTreeViewPrivate
}

// WrapTreeViewPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTreeViewPrivate(ptr unsafe.Pointer) *TreeViewPrivate {
	if ptr == nil {
		return nil
	}

	return (*TreeViewPrivate)(ptr)
}

func marshalTreeViewPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTreeViewPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TreeViewPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

type UIManagerPrivate struct {
	native C.GtkUIManagerPrivate
}

// WrapUIManagerPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapUIManagerPrivate(ptr unsafe.Pointer) *UIManagerPrivate {
	if ptr == nil {
		return nil
	}

	return (*UIManagerPrivate)(ptr)
}

func marshalUIManagerPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapUIManagerPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (u *UIManagerPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&u.native)
}

type ViewportPrivate struct {
	native C.GtkViewportPrivate
}

// WrapViewportPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapViewportPrivate(ptr unsafe.Pointer) *ViewportPrivate {
	if ptr == nil {
		return nil
	}

	return (*ViewportPrivate)(ptr)
}

func marshalViewportPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapViewportPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (v *ViewportPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&v.native)
}

type WidgetAccessiblePrivate struct {
	native C.GtkWidgetAccessiblePrivate
}

// WrapWidgetAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapWidgetAccessiblePrivate(ptr unsafe.Pointer) *WidgetAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*WidgetAccessiblePrivate)(ptr)
}

func marshalWidgetAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapWidgetAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (w *WidgetAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&w.native)
}

type WidgetClassPrivate struct {
	native C.GtkWidgetClassPrivate
}

// WrapWidgetClassPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapWidgetClassPrivate(ptr unsafe.Pointer) *WidgetClassPrivate {
	if ptr == nil {
		return nil
	}

	return (*WidgetClassPrivate)(ptr)
}

func marshalWidgetClassPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapWidgetClassPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (w *WidgetClassPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&w.native)
}

// WidgetPath: gtkWidgetPath is a boxed type that represents a widget hierarchy
// from the topmost widget, typically a toplevel, to any child. This widget path
// abstraction is used in StyleContext on behalf of the real widget in order to
// query style information.
//
// If you are using GTK+ widgets, you probably will not need to use this API
// directly, as there is gtk_widget_get_path(), and the style context returned
// by gtk_widget_get_style_context() will be automatically updated on widget
// hierarchy changes.
//
// The widget path generation is generally simple:
//
// Defining a button within a window
//
//    {
//      GtkWidgetPath *path;
//      guint pos;
//
//      path = gtk_widget_path_new ();
//
//      pos = gtk_widget_path_append_type (path, GTK_TYPE_NOTEBOOK);
//      gtk_widget_path_iter_add_region (path, pos, "tab", GTK_REGION_EVEN | GTK_REGION_FIRST);
//
//      pos = gtk_widget_path_append_type (path, GTK_TYPE_LABEL);
//      gtk_widget_path_iter_set_name (path, pos, "first tab label");
//    }
//
// All this information will be used to match the style information that applies
// to the described widget.
type WidgetPath struct {
	native C.GtkWidgetPath
}

// WrapWidgetPath wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapWidgetPath(ptr unsafe.Pointer) *WidgetPath {
	if ptr == nil {
		return nil
	}

	return (*WidgetPath)(ptr)
}

func marshalWidgetPath(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapWidgetPath(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (w *WidgetPath) Native() unsafe.Pointer {
	return unsafe.Pointer(&w.native)
}

// NewWidgetPath constructs a struct WidgetPath.
func NewWidgetPath() *WidgetPath {

	ret := C.gtk_widget_path_new()

	var ret0 *WidgetPath

	{
		ret0 = WrapWidgetPath(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *WidgetPath) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// AppendForWidget appends the data from @widget to the widget hierarchy
// represented by @path. This function is a shortcut for adding information from
// @widget to the given @path. This includes setting the name or adding the
// style classes from @widget.
func (path *WidgetPath) AppendForWidget(widget Widget) int {
	var arg0 *C.GtkWidgetPath
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkWidgetPath)(path.Native())
	arg1 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_path_append_for_widget(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// AppendType appends a widget type to the widget hierarchy represented by
// @path.
func (path *WidgetPath) AppendType(typ externglib.Type) int {
	var arg0 *C.GtkWidgetPath
	var arg1 C.GType

	arg0 = (*C.GtkWidgetPath)(path.Native())
	arg1 = C.GType(typ)

	ret := C.gtk_widget_path_append_type(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// AppendWithSiblings appends a widget type with all its siblings to the widget
// hierarchy represented by @path. Using this function instead of
// gtk_widget_path_append_type() will allow the CSS theming to use sibling
// matches in selectors and apply :nth-child() pseudo classes. In turn, it
// requires a lot more care in widget implementations as widgets need to make
// sure to call gtk_widget_reset_style() on all involved widgets when the
// @siblings path changes.
func (path *WidgetPath) AppendWithSiblings(siblings *WidgetPath, siblingIndex uint) int {
	var arg0 *C.GtkWidgetPath
	var arg1 *C.GtkWidgetPath
	var arg2 C.guint

	arg0 = (*C.GtkWidgetPath)(path.Native())
	arg1 = (*C.GtkWidgetPath)(siblings.Native())
	arg2 = C.guint(siblingIndex)

	ret := C.gtk_widget_path_append_with_siblings(arg0, arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Copy returns a copy of @path
func (path *WidgetPath) Copy() *WidgetPath {
	var arg0 *C.GtkWidgetPath

	arg0 = (*C.GtkWidgetPath)(path.Native())

	ret := C.gtk_widget_path_copy(arg0)

	var ret0 *WidgetPath

	{
		ret0 = WrapWidgetPath(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *WidgetPath) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Free decrements the reference count on @path, freeing the structure if the
// reference count reaches 0.
func (path *WidgetPath) Free() {
	var arg0 *C.GtkWidgetPath

	arg0 = (*C.GtkWidgetPath)(path.Native())

	C.gtk_widget_path_free(arg0)
}

// ObjectType returns the topmost object type, that is, the object type this
// path is representing.
func (path *WidgetPath) ObjectType() externglib.Type {
	var arg0 *C.GtkWidgetPath

	arg0 = (*C.GtkWidgetPath)(path.Native())

	ret := C.gtk_widget_path_get_object_type(arg0)

	var ret0 externglib.Type

	ret0 = externglib.Type(ret)

	return ret0
}

// HasParent returns true if any of the parents of the widget represented in
// @path is of type @type, or any subtype of it.
func (path *WidgetPath) HasParent(typ externglib.Type) bool {
	var arg0 *C.GtkWidgetPath
	var arg1 C.GType

	arg0 = (*C.GtkWidgetPath)(path.Native())
	arg1 = C.GType(typ)

	ret := C.gtk_widget_path_has_parent(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IsType returns true if the widget type represented by this path is @type, or
// a subtype of it.
func (path *WidgetPath) IsType(typ externglib.Type) bool {
	var arg0 *C.GtkWidgetPath
	var arg1 C.GType

	arg0 = (*C.GtkWidgetPath)(path.Native())
	arg1 = C.GType(typ)

	ret := C.gtk_widget_path_is_type(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IterAddClass adds the class @name to the widget at position @pos in the
// hierarchy defined in @path. See gtk_style_context_add_class().
func (path *WidgetPath) IterAddClass(pos int, name string) {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint
	var arg2 *C.gchar

	arg0 = (*C.GtkWidgetPath)(path.Native())
	arg1 = C.gint(pos)
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_widget_path_iter_add_class(arg0, arg1, arg2)
}

// IterAddRegion adds the region @name to the widget at position @pos in the
// hierarchy defined in @path. See gtk_style_context_add_region().
//
// Region names must only contain lowercase letters and “-”, starting always
// with a lowercase letter.
func (path *WidgetPath) IterAddRegion(pos int, name string, flags RegionFlags) {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint
	var arg2 *C.gchar
	var arg3 C.GtkRegionFlags

	arg0 = (*C.GtkWidgetPath)(path.Native())
	arg1 = C.gint(pos)
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (C.GtkRegionFlags)(flags)

	C.gtk_widget_path_iter_add_region(arg0, arg1, arg2, arg3)
}

// IterClearClasses removes all classes from the widget at position @pos in the
// hierarchy defined in @path.
func (path *WidgetPath) IterClearClasses(pos int) {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint

	arg0 = (*C.GtkWidgetPath)(path.Native())
	arg1 = C.gint(pos)

	C.gtk_widget_path_iter_clear_classes(arg0, arg1)
}

// IterClearRegions removes all regions from the widget at position @pos in the
// hierarchy defined in @path.
func (path *WidgetPath) IterClearRegions(pos int) {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint

	arg0 = (*C.GtkWidgetPath)(path.Native())
	arg1 = C.gint(pos)

	C.gtk_widget_path_iter_clear_regions(arg0, arg1)
}

// IterGetName returns the name corresponding to the widget found at the
// position @pos in the widget hierarchy defined by @path
func (path *WidgetPath) IterGetName(pos int) string {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint

	arg0 = (*C.GtkWidgetPath)(path.Native())
	arg1 = C.gint(pos)

	ret := C.gtk_widget_path_iter_get_name(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// IterGetObjectName returns the object name that is at position @pos in the
// widget hierarchy defined in @path.
func (path *WidgetPath) IterGetObjectName(pos int) string {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint

	arg0 = (*C.GtkWidgetPath)(path.Native())
	arg1 = C.gint(pos)

	ret := C.gtk_widget_path_iter_get_object_name(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// IterGetObjectType returns the object #GType that is at position @pos in the
// widget hierarchy defined in @path.
func (path *WidgetPath) IterGetObjectType(pos int) externglib.Type {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint

	arg0 = (*C.GtkWidgetPath)(path.Native())
	arg1 = C.gint(pos)

	ret := C.gtk_widget_path_iter_get_object_type(arg0, arg1)

	var ret0 externglib.Type

	ret0 = externglib.Type(ret)

	return ret0
}

// IterGetSiblingIndex returns the index into the list of siblings for the
// element at @pos as returned by gtk_widget_path_iter_get_siblings(). If that
// function would return nil because the element at @pos has no siblings, this
// function will return 0.
func (path *WidgetPath) IterGetSiblingIndex(pos int) uint {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint

	arg0 = (*C.GtkWidgetPath)(path.Native())
	arg1 = C.gint(pos)

	ret := C.gtk_widget_path_iter_get_sibling_index(arg0, arg1)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// IterGetSiblings returns the list of siblings for the element at @pos. If the
// element was not added with siblings, nil is returned.
func (path *WidgetPath) IterGetSiblings(pos int) *WidgetPath {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint

	arg0 = (*C.GtkWidgetPath)(path.Native())
	arg1 = C.gint(pos)

	ret := C.gtk_widget_path_iter_get_siblings(arg0, arg1)

	var ret0 *WidgetPath

	{
		ret0 = WrapWidgetPath(unsafe.Pointer(ret))
	}

	return ret0
}

// IterGetState returns the state flags corresponding to the widget found at the
// position @pos in the widget hierarchy defined by @path
func (path *WidgetPath) IterGetState(pos int) StateFlags {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint

	arg0 = (*C.GtkWidgetPath)(path.Native())
	arg1 = C.gint(pos)

	ret := C.gtk_widget_path_iter_get_state(arg0, arg1)

	var ret0 StateFlags

	ret0 = StateFlags(ret)

	return ret0
}

// IterHasClass returns true if the widget at position @pos has the class @name
// defined, false otherwise.
func (path *WidgetPath) IterHasClass(pos int, name string) bool {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint
	var arg2 *C.gchar

	arg0 = (*C.GtkWidgetPath)(path.Native())
	arg1 = C.gint(pos)
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_widget_path_iter_has_class(arg0, arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IterHasName returns true if the widget at position @pos has the name @name,
// false otherwise.
func (path *WidgetPath) IterHasName(pos int, name string) bool {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint
	var arg2 *C.gchar

	arg0 = (*C.GtkWidgetPath)(path.Native())
	arg1 = C.gint(pos)
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_widget_path_iter_has_name(arg0, arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IterHasRegion returns true if the widget at position @pos has the class @name
// defined, false otherwise.
func (path *WidgetPath) IterHasRegion(pos int, name string) (flags RegionFlags, ok bool) {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint
	var arg2 *C.gchar
	var arg3 *C.GtkRegionFlags // out

	arg0 = (*C.GtkWidgetPath)(path.Native())
	arg1 = C.gint(pos)
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_widget_path_iter_has_region(arg0, arg1, arg2, &arg3)

	var ret0 *RegionFlags
	var ret1 bool

	ret0 = (*RegionFlags)(arg3)

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// IterListClasses returns a list with all the class names defined for the
// widget at position @pos in the hierarchy defined in @path.
func (path *WidgetPath) IterListClasses(pos int) *glib.SList {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint

	arg0 = (*C.GtkWidgetPath)(path.Native())
	arg1 = C.gint(pos)

	ret := C.gtk_widget_path_iter_list_classes(arg0, arg1)

	var ret0 *glib.SList

	{
		ret0 = glib.WrapSList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.SList) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// IterListRegions returns a list with all the region names defined for the
// widget at position @pos in the hierarchy defined in @path.
func (path *WidgetPath) IterListRegions(pos int) *glib.SList {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint

	arg0 = (*C.GtkWidgetPath)(path.Native())
	arg1 = C.gint(pos)

	ret := C.gtk_widget_path_iter_list_regions(arg0, arg1)

	var ret0 *glib.SList

	{
		ret0 = glib.WrapSList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.SList) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// IterRemoveClass removes the class @name from the widget at position @pos in
// the hierarchy defined in @path.
func (path *WidgetPath) IterRemoveClass(pos int, name string) {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint
	var arg2 *C.gchar

	arg0 = (*C.GtkWidgetPath)(path.Native())
	arg1 = C.gint(pos)
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_widget_path_iter_remove_class(arg0, arg1, arg2)
}

// IterRemoveRegion removes the region @name from the widget at position @pos in
// the hierarchy defined in @path.
func (path *WidgetPath) IterRemoveRegion(pos int, name string) {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint
	var arg2 *C.gchar

	arg0 = (*C.GtkWidgetPath)(path.Native())
	arg1 = C.gint(pos)
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_widget_path_iter_remove_region(arg0, arg1, arg2)
}

// IterSetName sets the widget name for the widget found at position @pos in the
// widget hierarchy defined by @path.
func (path *WidgetPath) IterSetName(pos int, name string) {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint
	var arg2 *C.gchar

	arg0 = (*C.GtkWidgetPath)(path.Native())
	arg1 = C.gint(pos)
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_widget_path_iter_set_name(arg0, arg1, arg2)
}

// IterSetObjectName sets the object name for a given position in the widget
// hierarchy defined by @path.
//
// When set, the object name overrides the object type when matching CSS.
func (path *WidgetPath) IterSetObjectName(pos int, name string) {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint
	var arg2 *C.char

	arg0 = (*C.GtkWidgetPath)(path.Native())
	arg1 = C.gint(pos)
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_widget_path_iter_set_object_name(arg0, arg1, arg2)
}

// IterSetObjectType sets the object type for a given position in the widget
// hierarchy defined by @path.
func (path *WidgetPath) IterSetObjectType(pos int, typ externglib.Type) {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint
	var arg2 C.GType

	arg0 = (*C.GtkWidgetPath)(path.Native())
	arg1 = C.gint(pos)
	arg2 = C.GType(typ)

	C.gtk_widget_path_iter_set_object_type(arg0, arg1, arg2)
}

// IterSetState sets the widget name for the widget found at position @pos in
// the widget hierarchy defined by @path.
//
// If you want to update just a single state flag, you need to do this manually,
// as this function updates all state flags.
//
// Setting a flag
//
//    gtk_widget_path_iter_set_state (path, pos, gtk_widget_path_iter_get_state (path, pos) & ~flag);
func (path *WidgetPath) IterSetState(pos int, state StateFlags) {
	var arg0 *C.GtkWidgetPath
	var arg1 C.gint
	var arg2 C.GtkStateFlags

	arg0 = (*C.GtkWidgetPath)(path.Native())
	arg1 = C.gint(pos)
	arg2 = (C.GtkStateFlags)(state)

	C.gtk_widget_path_iter_set_state(arg0, arg1, arg2)
}

// Length returns the number of Widget #GTypes between the represented widget
// and its topmost container.
func (path *WidgetPath) Length() int {
	var arg0 *C.GtkWidgetPath

	arg0 = (*C.GtkWidgetPath)(path.Native())

	ret := C.gtk_widget_path_length(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// PrependType prepends a widget type to the widget hierachy represented by
// @path.
func (path *WidgetPath) PrependType(typ externglib.Type) {
	var arg0 *C.GtkWidgetPath
	var arg1 C.GType

	arg0 = (*C.GtkWidgetPath)(path.Native())
	arg1 = C.GType(typ)

	C.gtk_widget_path_prepend_type(arg0, arg1)
}

// Ref increments the reference count on @path.
func (path *WidgetPath) Ref() *WidgetPath {
	var arg0 *C.GtkWidgetPath

	arg0 = (*C.GtkWidgetPath)(path.Native())

	ret := C.gtk_widget_path_ref(arg0)

	var ret0 *WidgetPath

	{
		ret0 = WrapWidgetPath(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *WidgetPath) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// String dumps the widget path into a string representation. It tries to match
// the CSS style as closely as possible (Note that there might be paths that
// cannot be represented in CSS).
//
// The main use of this code is for debugging purposes, so that you can
// g_print() the path or dump it in a gdb session.
func (path *WidgetPath) String() string {
	var arg0 *C.GtkWidgetPath

	arg0 = (*C.GtkWidgetPath)(path.Native())

	ret := C.gtk_widget_path_to_string(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Unref decrements the reference count on @path, freeing the structure if the
// reference count reaches 0.
func (path *WidgetPath) Unref() {
	var arg0 *C.GtkWidgetPath

	arg0 = (*C.GtkWidgetPath)(path.Native())

	C.gtk_widget_path_unref(arg0)
}

type WidgetPrivate struct {
	native C.GtkWidgetPrivate
}

// WrapWidgetPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapWidgetPrivate(ptr unsafe.Pointer) *WidgetPrivate {
	if ptr == nil {
		return nil
	}

	return (*WidgetPrivate)(ptr)
}

func marshalWidgetPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapWidgetPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (w *WidgetPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&w.native)
}

type WindowAccessiblePrivate struct {
	native C.GtkWindowAccessiblePrivate
}

// WrapWindowAccessiblePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapWindowAccessiblePrivate(ptr unsafe.Pointer) *WindowAccessiblePrivate {
	if ptr == nil {
		return nil
	}

	return (*WindowAccessiblePrivate)(ptr)
}

func marshalWindowAccessiblePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapWindowAccessiblePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (w *WindowAccessiblePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&w.native)
}

type WindowGeometryInfo struct {
	native C.GtkWindowGeometryInfo
}

// WrapWindowGeometryInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapWindowGeometryInfo(ptr unsafe.Pointer) *WindowGeometryInfo {
	if ptr == nil {
		return nil
	}

	return (*WindowGeometryInfo)(ptr)
}

func marshalWindowGeometryInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapWindowGeometryInfo(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (w *WindowGeometryInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&w.native)
}

type WindowGroupPrivate struct {
	native C.GtkWindowGroupPrivate
}

// WrapWindowGroupPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapWindowGroupPrivate(ptr unsafe.Pointer) *WindowGroupPrivate {
	if ptr == nil {
		return nil
	}

	return (*WindowGroupPrivate)(ptr)
}

func marshalWindowGroupPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapWindowGroupPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (w *WindowGroupPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&w.native)
}

type WindowPrivate struct {
	native C.GtkWindowPrivate
}

// WrapWindowPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapWindowPrivate(ptr unsafe.Pointer) *WindowPrivate {
	if ptr == nil {
		return nil
	}

	return (*WindowPrivate)(ptr)
}

func marshalWindowPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapWindowPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (w *WindowPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&w.native)
}

// AccelGroup: a AccelGroup represents a group of keyboard accelerators,
// typically attached to a toplevel Window (with gtk_window_add_accel_group()).
// Usually you won’t need to create a AccelGroup directly; instead, when using
// UIManager, GTK+ automatically sets up the accelerators for your menus in the
// ui manager’s AccelGroup.
//
// Note that “accelerators” are different from “mnemonics”. Accelerators are
// shortcuts for activating a menu item; they appear alongside the menu item
// they’re a shortcut for. For example “Ctrl+Q” might appear alongside the
// “Quit” menu item. Mnemonics are shortcuts for GUI elements such as text
// entries or buttons; they appear as underlined characters. See
// gtk_label_new_with_mnemonic(). Menu items can have both accelerators and
// mnemonics, of course.
type AccelGroup interface {
	gextras.Objector

	// DisconnectKey removes an accelerator previously installed through
	// gtk_accel_group_connect().
	DisconnectKey(accelKey uint, accelMods gdk.ModifierType) bool
	// Find finds the first entry in an accelerator group for which @find_func
	// returns true and returns its AccelKey.
	Find(findFunc AccelGroupFindFunc) *AccelKey
	// IsLocked locks are added and removed using gtk_accel_group_lock() and
	// gtk_accel_group_unlock().
	IsLocked() bool
	// ModifierMask gets a ModifierType representing the mask for this
	// @accel_group. For example, K_CONTROL_MASK, K_SHIFT_MASK, etc.
	ModifierMask() gdk.ModifierType
	// Lock locks the given accelerator group.
	//
	// Locking an acelerator group prevents the accelerators contained within it
	// to be changed during runtime. Refer to gtk_accel_map_change_entry() about
	// runtime accelerator changes.
	//
	// If called more than once, @accel_group remains locked until
	// gtk_accel_group_unlock() has been called an equivalent number of times.
	Lock()
	// Query queries an accelerator group for all entries matching @accel_key
	// and @accel_mods.
	Query(accelKey uint, accelMods gdk.ModifierType) (nEntries uint, accelGroupEntrys []AccelGroupEntry)
	// Unlock undoes the last call to gtk_accel_group_lock() on this
	// @accel_group.
	Unlock()
}

// accelGroup implements the AccelGroup interface.
type accelGroup struct {
	gextras.Objector
}

var _ AccelGroup = (*accelGroup)(nil)

// WrapAccelGroup wraps a GObject to the right type. It is
// primarily used internally.
func WrapAccelGroup(obj *externglib.Object) AccelGroup {
	return AccelGroup{
		Objector: obj,
	}
}

func marshalAccelGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAccelGroup(obj), nil
}

// NewAccelGroup constructs a class AccelGroup.
func NewAccelGroup() AccelGroup {

	ret := C.gtk_accel_group_new()

	var ret0 AccelGroup

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(AccelGroup)

	return ret0
}

// DisconnectKey removes an accelerator previously installed through
// gtk_accel_group_connect().
func (accelGroup accelGroup) DisconnectKey(accelKey uint, accelMods gdk.ModifierType) bool {
	var arg0 *C.GtkAccelGroup
	var arg1 C.guint
	var arg2 C.GdkModifierType

	arg0 = (*C.GtkAccelGroup)(accelGroup.Native())
	arg1 = C.guint(accelKey)
	arg2 = (C.GdkModifierType)(accelMods)

	ret := C.gtk_accel_group_disconnect_key(arg0, arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Find finds the first entry in an accelerator group for which @find_func
// returns true and returns its AccelKey.
func (accelGroup accelGroup) Find(findFunc AccelGroupFindFunc) *AccelKey {
	var arg0 *C.GtkAccelGroup
	var arg1 C.GtkAccelGroupFindFunc
	var arg2 C.gpointer

	arg0 = (*C.GtkAccelGroup)(accelGroup.Native())
	arg1 = (*[0]byte)(C.gotk4_AccelGroupFindFunc)
	arg2 = C.gpointer(box.Assign(findFunc))

	ret := C.gtk_accel_group_find(arg0, arg1, arg2)

	var ret0 *AccelKey

	{
		ret0 = WrapAccelKey(unsafe.Pointer(ret))
	}

	return ret0
}

// IsLocked locks are added and removed using gtk_accel_group_lock() and
// gtk_accel_group_unlock().
func (accelGroup accelGroup) IsLocked() bool {
	var arg0 *C.GtkAccelGroup

	arg0 = (*C.GtkAccelGroup)(accelGroup.Native())

	ret := C.gtk_accel_group_get_is_locked(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ModifierMask gets a ModifierType representing the mask for this
// @accel_group. For example, K_CONTROL_MASK, K_SHIFT_MASK, etc.
func (accelGroup accelGroup) ModifierMask() gdk.ModifierType {
	var arg0 *C.GtkAccelGroup

	arg0 = (*C.GtkAccelGroup)(accelGroup.Native())

	ret := C.gtk_accel_group_get_modifier_mask(arg0)

	var ret0 gdk.ModifierType

	ret0 = gdk.ModifierType(ret)

	return ret0
}

// Lock locks the given accelerator group.
//
// Locking an acelerator group prevents the accelerators contained within it
// to be changed during runtime. Refer to gtk_accel_map_change_entry() about
// runtime accelerator changes.
//
// If called more than once, @accel_group remains locked until
// gtk_accel_group_unlock() has been called an equivalent number of times.
func (accelGroup accelGroup) Lock() {
	var arg0 *C.GtkAccelGroup

	arg0 = (*C.GtkAccelGroup)(accelGroup.Native())

	C.gtk_accel_group_lock(arg0)
}

// Query queries an accelerator group for all entries matching @accel_key
// and @accel_mods.
func (accelGroup accelGroup) Query(accelKey uint, accelMods gdk.ModifierType) (nEntries uint, accelGroupEntrys []AccelGroupEntry) {
	var arg0 *C.GtkAccelGroup
	var arg1 C.guint
	var arg2 C.GdkModifierType
	var arg3 *C.guint // out

	arg0 = (*C.GtkAccelGroup)(accelGroup.Native())
	arg1 = C.guint(accelKey)
	arg2 = (C.GdkModifierType)(accelMods)

	ret := C.gtk_accel_group_query(arg0, arg1, arg2, &arg3)

	var ret0 uint
	var ret1 []AccelGroupEntry

	ret0 = uint(arg3)

	{
		ret1 = make([]AccelGroupEntry, arg3)
		for i := 0; i < uintptr(arg3); i++ {
			src := (C.GtkAccelGroupEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			{
				ret1[i] = WrapAccelGroupEntry(unsafe.Pointer(src))
			}
		}
	}

	return ret0, ret1
}

// Unlock undoes the last call to gtk_accel_group_lock() on this
// @accel_group.
func (accelGroup accelGroup) Unlock() {
	var arg0 *C.GtkAccelGroup

	arg0 = (*C.GtkAccelGroup)(accelGroup.Native())

	C.gtk_accel_group_unlock(arg0)
}

// AccelMap: accelerator maps are used to define runtime configurable
// accelerators. Functions for manipulating them are are usually used by higher
// level convenience mechanisms like UIManager and are thus considered
// “low-level”. You’ll want to use them if you’re manually creating menus that
// should have user-configurable accelerators.
//
// An accelerator is uniquely defined by: - accelerator path - accelerator key -
// accelerator modifiers
//
// The accelerator path must consist of
// “<WINDOWTYPE>/Category1/Category2/.../Action”, where WINDOWTYPE should be a
// unique application-specific identifier that corresponds to the kind of window
// the accelerator is being used in, e.g. “Gimp-Image”, “Abiword-Document” or
// “Gnumeric-Settings”. The “Category1/.../Action” portion is most appropriately
// chosen by the action the accelerator triggers, i.e. for accelerators on menu
// items, choose the item’s menu path, e.g. “File/Save As”, “Image/View/Zoom” or
// “Edit/Select All”. So a full valid accelerator path may look like:
// “<Gimp-Toolbox>/File/Dialogs/Tool Options...”.
//
// All accelerators are stored inside one global AccelMap that can be obtained
// using gtk_accel_map_get(). See [Monitoring changes][monitoring-changes] for
// additional details.
//
//
// Manipulating accelerators
//
// New accelerators can be added using gtk_accel_map_add_entry(). To search for
// specific accelerator, use gtk_accel_map_lookup_entry(). Modifications of
// existing accelerators should be done using gtk_accel_map_change_entry().
//
// In order to avoid having some accelerators changed, they can be locked using
// gtk_accel_map_lock_path(). Unlocking is done using
// gtk_accel_map_unlock_path().
//
//
// Saving and loading accelerator maps
//
// Accelerator maps can be saved to and loaded from some external resource. For
// simple saving and loading from file, gtk_accel_map_save() and
// gtk_accel_map_load() are provided. Saving and loading can also be done by
// providing file descriptor to gtk_accel_map_save_fd() and
// gtk_accel_map_load_fd().
//
//
// Monitoring changes
//
// AccelMap object is only useful for monitoring changes of accelerators. By
// connecting to AccelMap::changed signal, one can monitor changes of all
// accelerators. It is also possible to monitor only single accelerator path by
// using it as a detail of the AccelMap::changed signal.
type AccelMap interface {
	gextras.Objector
}

// accelMap implements the AccelMap interface.
type accelMap struct {
	gextras.Objector
}

var _ AccelMap = (*accelMap)(nil)

// WrapAccelMap wraps a GObject to the right type. It is
// primarily used internally.
func WrapAccelMap(obj *externglib.Object) AccelMap {
	return AccelMap{
		Objector: obj,
	}
}

func marshalAccelMap(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAccelMap(obj), nil
}

// Action: > In GTK+ 3.10, GtkAction has been deprecated. Use #GAction >
// instead, and associate actions with Actionable widgets. Use > Model for
// creating menus with gtk_menu_new_from_model().
//
// Actions represent operations that the user can be perform, along with some
// information how it should be presented in the interface. Each action provides
// methods to create icons, menu items and toolbar items representing itself.
//
// As well as the callback that is called when the action gets activated, the
// following also gets associated with the action:
//
// - a name (not translated, for path lookup)
//
// - a label (translated, for display)
//
// - an accelerator
//
// - whether label indicates a stock id
//
// - a tooltip (optional, translated)
//
// - a toolbar label (optional, shorter than label)
//
//    The action will also have some state information:
//
// - visible (shown/hidden)
//
// - sensitive (enabled/disabled)
//
// Apart from regular actions, there are [toggle actions][GtkToggleAction],
// which can be toggled between two states and [radio actions][GtkRadioAction],
// of which only one in a group can be in the “active” state. Other actions can
// be implemented as Action subclasses.
//
// Each action can have one or more proxy widgets. To act as an action proxy,
// widget needs to implement Activatable interface. Proxies mirror the state of
// the action and should change when the action’s state changes. Properties that
// are always mirrored by proxies are Action:sensitive and Action:visible.
// Action:gicon, Action:icon-name, Action:label, Action:short-label and
// Action:stock-id properties are only mirorred if proxy widget has
// Activatable:use-action-appearance property set to true.
//
// When the proxy is activated, it should activate its action.
type Action interface {
	gextras.Objector
	Buildable

	// Activate emits the “activate” signal on the specified action, if it isn't
	// insensitive. This gets called by the proxy widgets when they get
	// activated.
	//
	// It can also be used to manually activate an action.
	Activate()
	// BlockActivate: disable activation signals from the action
	//
	// This is needed when updating the state of your proxy Activatable widget
	// could result in calling gtk_action_activate(), this is a convenience
	// function to avoid recursing in those cases (updating toggle state for
	// instance).
	BlockActivate()
	// ConnectAccelerator installs the accelerator for @action if @action has an
	// accel path and group. See gtk_action_set_accel_path() and
	// gtk_action_set_accel_group()
	//
	// Since multiple proxies may independently trigger the installation of the
	// accelerator, the @action counts the number of times this function has
	// been called and doesn’t remove the accelerator until
	// gtk_action_disconnect_accelerator() has been called as many times.
	ConnectAccelerator()
	// CreateIcon: this function is intended for use by action implementations
	// to create icons displayed in the proxy widgets.
	CreateIcon(iconSize int) Widget
	// CreateMenu: if @action provides a Menu widget as a submenu for the menu
	// item or the toolbar item it creates, this function returns an instance of
	// that menu.
	CreateMenu() Widget
	// CreateMenuItem creates a menu item widget that proxies for the given
	// action.
	CreateMenuItem() Widget
	// CreateToolItem creates a toolbar item widget that proxies for the given
	// action.
	CreateToolItem() Widget
	// DisconnectAccelerator undoes the effect of one call to
	// gtk_action_connect_accelerator().
	DisconnectAccelerator()
	// AccelPath returns the accel path for this action.
	AccelPath() string
	// AlwaysShowImage returns whether @action's menu item proxies will always
	// show their image, if available.
	AlwaysShowImage() bool
	// GIcon gets the gicon of @action.
	GIcon() gio.Icon
	// IconName gets the icon name of @action.
	IconName() string
	// IsImportant checks whether @action is important or not
	IsImportant() bool
	// Label gets the label text of @action.
	Label() string
	// Name returns the name of the action.
	Name() string
	// Proxies returns the proxy widgets for an action. See also
	// gtk_activatable_get_related_action().
	Proxies() *glib.SList
	// Sensitive returns whether the action itself is sensitive. Note that this
	// doesn’t necessarily mean effective sensitivity. See
	// gtk_action_is_sensitive() for that.
	Sensitive() bool
	// ShortLabel gets the short label text of @action.
	ShortLabel() string
	// StockID gets the stock id of @action.
	StockID() string
	// Tooltip gets the tooltip text of @action.
	Tooltip() string
	// Visible returns whether the action itself is visible. Note that this
	// doesn’t necessarily mean effective visibility. See
	// gtk_action_is_sensitive() for that.
	Visible() bool
	// VisibleHorizontal checks whether @action is visible when horizontal
	VisibleHorizontal() bool
	// VisibleVertical checks whether @action is visible when horizontal
	VisibleVertical() bool
	// IsSensitive returns whether the action is effectively sensitive.
	IsSensitive() bool
	// IsVisible returns whether the action is effectively visible.
	IsVisible() bool
	// SetAccelGroup sets the AccelGroup in which the accelerator for this
	// action will be installed.
	SetAccelGroup(accelGroup AccelGroup)
	// SetAccelPath sets the accel path for this action. All proxy widgets
	// associated with the action will have this accel path, so that their
	// accelerators are consistent.
	//
	// Note that @accel_path string will be stored in a #GQuark. Therefore, if
	// you pass a static string, you can save some memory by interning it first
	// with g_intern_static_string().
	SetAccelPath(accelPath string)
	// SetAlwaysShowImage sets whether @action's menu item proxies will ignore
	// the Settings:gtk-menu-images setting and always show their image, if
	// available.
	//
	// Use this if the menu item would be useless or hard to use without their
	// image.
	SetAlwaysShowImage(alwaysShow bool)
	// SetGIcon sets the icon of @action.
	SetGIcon(icon gio.Icon)
	// SetIconName sets the icon name on @action
	SetIconName(iconName string)
	// SetIsImportant sets whether the action is important, this attribute is
	// used primarily by toolbar items to decide whether to show a label or not.
	SetIsImportant(isImportant bool)
	// SetLabel sets the label of @action.
	SetLabel(label string)
	// SetSensitive sets the :sensitive property of the action to @sensitive.
	// Note that this doesn’t necessarily mean effective sensitivity. See
	// gtk_action_is_sensitive() for that.
	SetSensitive(sensitive bool)
	// SetShortLabel sets a shorter label text on @action.
	SetShortLabel(shortLabel string)
	// SetStockID sets the stock id on @action
	SetStockID(stockID string)
	// SetTooltip sets the tooltip text on @action
	SetTooltip(tooltip string)
	// SetVisible sets the :visible property of the action to @visible. Note
	// that this doesn’t necessarily mean effective visibility. See
	// gtk_action_is_visible() for that.
	SetVisible(visible bool)
	// SetVisibleHorizontal sets whether @action is visible when horizontal
	SetVisibleHorizontal(visibleHorizontal bool)
	// SetVisibleVertical sets whether @action is visible when vertical
	SetVisibleVertical(visibleVertical bool)
	// UnblockActivate: reenable activation signals from the action
	UnblockActivate()
}

// action implements the Action interface.
type action struct {
	gextras.Objector
	Buildable
}

var _ Action = (*action)(nil)

// WrapAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapAction(obj *externglib.Object) Action {
	return Action{
		Objector:  obj,
		Buildable: WrapBuildable(obj),
	}
}

func marshalAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAction(obj), nil
}

// NewAction constructs a class Action.
func NewAction(name string, label string, tooltip string, stockID string) Action {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 *C.gchar

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(tooltip))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gchar)(C.CString(stockID))
	defer C.free(unsafe.Pointer(arg4))

	ret := C.gtk_action_new(arg1, arg2, arg3, arg4)

	var ret0 Action

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(Action)

	return ret0
}

// Activate emits the “activate” signal on the specified action, if it isn't
// insensitive. This gets called by the proxy widgets when they get
// activated.
//
// It can also be used to manually activate an action.
func (action action) Activate() {
	var arg0 *C.GtkAction

	arg0 = (*C.GtkAction)(action.Native())

	C.gtk_action_activate(arg0)
}

// BlockActivate: disable activation signals from the action
//
// This is needed when updating the state of your proxy Activatable widget
// could result in calling gtk_action_activate(), this is a convenience
// function to avoid recursing in those cases (updating toggle state for
// instance).
func (action action) BlockActivate() {
	var arg0 *C.GtkAction

	arg0 = (*C.GtkAction)(action.Native())

	C.gtk_action_block_activate(arg0)
}

// ConnectAccelerator installs the accelerator for @action if @action has an
// accel path and group. See gtk_action_set_accel_path() and
// gtk_action_set_accel_group()
//
// Since multiple proxies may independently trigger the installation of the
// accelerator, the @action counts the number of times this function has
// been called and doesn’t remove the accelerator until
// gtk_action_disconnect_accelerator() has been called as many times.
func (action action) ConnectAccelerator() {
	var arg0 *C.GtkAction

	arg0 = (*C.GtkAction)(action.Native())

	C.gtk_action_connect_accelerator(arg0)
}

// CreateIcon: this function is intended for use by action implementations
// to create icons displayed in the proxy widgets.
func (action action) CreateIcon(iconSize int) Widget {
	var arg0 *C.GtkAction
	var arg1 C.GtkIconSize

	arg0 = (*C.GtkAction)(action.Native())
	arg1 = C.GtkIconSize(iconSize)

	ret := C.gtk_action_create_icon(arg0, arg1)

	var ret0 Widget

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Widget)

	return ret0
}

// CreateMenu: if @action provides a Menu widget as a submenu for the menu
// item or the toolbar item it creates, this function returns an instance of
// that menu.
func (action action) CreateMenu() Widget {
	var arg0 *C.GtkAction

	arg0 = (*C.GtkAction)(action.Native())

	ret := C.gtk_action_create_menu(arg0)

	var ret0 Widget

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Widget)

	return ret0
}

// CreateMenuItem creates a menu item widget that proxies for the given
// action.
func (action action) CreateMenuItem() Widget {
	var arg0 *C.GtkAction

	arg0 = (*C.GtkAction)(action.Native())

	ret := C.gtk_action_create_menu_item(arg0)

	var ret0 Widget

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Widget)

	return ret0
}

// CreateToolItem creates a toolbar item widget that proxies for the given
// action.
func (action action) CreateToolItem() Widget {
	var arg0 *C.GtkAction

	arg0 = (*C.GtkAction)(action.Native())

	ret := C.gtk_action_create_tool_item(arg0)

	var ret0 Widget

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Widget)

	return ret0
}

// DisconnectAccelerator undoes the effect of one call to
// gtk_action_connect_accelerator().
func (action action) DisconnectAccelerator() {
	var arg0 *C.GtkAction

	arg0 = (*C.GtkAction)(action.Native())

	C.gtk_action_disconnect_accelerator(arg0)
}

// AccelPath returns the accel path for this action.
func (action action) AccelPath() string {
	var arg0 *C.GtkAction

	arg0 = (*C.GtkAction)(action.Native())

	ret := C.gtk_action_get_accel_path(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// AlwaysShowImage returns whether @action's menu item proxies will always
// show their image, if available.
func (action action) AlwaysShowImage() bool {
	var arg0 *C.GtkAction

	arg0 = (*C.GtkAction)(action.Native())

	ret := C.gtk_action_get_always_show_image(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// GIcon gets the gicon of @action.
func (action action) GIcon() gio.Icon {
	var arg0 *C.GtkAction

	arg0 = (*C.GtkAction)(action.Native())

	ret := C.gtk_action_get_gicon(arg0)

	var ret0 gio.Icon

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gio.Icon)

	return ret0
}

// IconName gets the icon name of @action.
func (action action) IconName() string {
	var arg0 *C.GtkAction

	arg0 = (*C.GtkAction)(action.Native())

	ret := C.gtk_action_get_icon_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// IsImportant checks whether @action is important or not
func (action action) IsImportant() bool {
	var arg0 *C.GtkAction

	arg0 = (*C.GtkAction)(action.Native())

	ret := C.gtk_action_get_is_important(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Label gets the label text of @action.
func (action action) Label() string {
	var arg0 *C.GtkAction

	arg0 = (*C.GtkAction)(action.Native())

	ret := C.gtk_action_get_label(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Name returns the name of the action.
func (action action) Name() string {
	var arg0 *C.GtkAction

	arg0 = (*C.GtkAction)(action.Native())

	ret := C.gtk_action_get_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Proxies returns the proxy widgets for an action. See also
// gtk_activatable_get_related_action().
func (action action) Proxies() *glib.SList {
	var arg0 *C.GtkAction

	arg0 = (*C.GtkAction)(action.Native())

	ret := C.gtk_action_get_proxies(arg0)

	var ret0 *glib.SList

	{
		ret0 = glib.WrapSList(unsafe.Pointer(ret))
	}

	return ret0
}

// Sensitive returns whether the action itself is sensitive. Note that this
// doesn’t necessarily mean effective sensitivity. See
// gtk_action_is_sensitive() for that.
func (action action) Sensitive() bool {
	var arg0 *C.GtkAction

	arg0 = (*C.GtkAction)(action.Native())

	ret := C.gtk_action_get_sensitive(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ShortLabel gets the short label text of @action.
func (action action) ShortLabel() string {
	var arg0 *C.GtkAction

	arg0 = (*C.GtkAction)(action.Native())

	ret := C.gtk_action_get_short_label(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// StockID gets the stock id of @action.
func (action action) StockID() string {
	var arg0 *C.GtkAction

	arg0 = (*C.GtkAction)(action.Native())

	ret := C.gtk_action_get_stock_id(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Tooltip gets the tooltip text of @action.
func (action action) Tooltip() string {
	var arg0 *C.GtkAction

	arg0 = (*C.GtkAction)(action.Native())

	ret := C.gtk_action_get_tooltip(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Visible returns whether the action itself is visible. Note that this
// doesn’t necessarily mean effective visibility. See
// gtk_action_is_sensitive() for that.
func (action action) Visible() bool {
	var arg0 *C.GtkAction

	arg0 = (*C.GtkAction)(action.Native())

	ret := C.gtk_action_get_visible(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// VisibleHorizontal checks whether @action is visible when horizontal
func (action action) VisibleHorizontal() bool {
	var arg0 *C.GtkAction

	arg0 = (*C.GtkAction)(action.Native())

	ret := C.gtk_action_get_visible_horizontal(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// VisibleVertical checks whether @action is visible when horizontal
func (action action) VisibleVertical() bool {
	var arg0 *C.GtkAction

	arg0 = (*C.GtkAction)(action.Native())

	ret := C.gtk_action_get_visible_vertical(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IsSensitive returns whether the action is effectively sensitive.
func (action action) IsSensitive() bool {
	var arg0 *C.GtkAction

	arg0 = (*C.GtkAction)(action.Native())

	ret := C.gtk_action_is_sensitive(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IsVisible returns whether the action is effectively visible.
func (action action) IsVisible() bool {
	var arg0 *C.GtkAction

	arg0 = (*C.GtkAction)(action.Native())

	ret := C.gtk_action_is_visible(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SetAccelGroup sets the AccelGroup in which the accelerator for this
// action will be installed.
func (action action) SetAccelGroup(accelGroup AccelGroup) {
	var arg0 *C.GtkAction
	var arg1 *C.GtkAccelGroup

	arg0 = (*C.GtkAction)(action.Native())
	arg1 = (*C.GtkAccelGroup)(accelGroup.Native())

	C.gtk_action_set_accel_group(arg0, arg1)
}

// SetAccelPath sets the accel path for this action. All proxy widgets
// associated with the action will have this accel path, so that their
// accelerators are consistent.
//
// Note that @accel_path string will be stored in a #GQuark. Therefore, if
// you pass a static string, you can save some memory by interning it first
// with g_intern_static_string().
func (action action) SetAccelPath(accelPath string) {
	var arg0 *C.GtkAction
	var arg1 *C.gchar

	arg0 = (*C.GtkAction)(action.Native())
	arg1 = (*C.gchar)(C.CString(accelPath))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_action_set_accel_path(arg0, arg1)
}

// SetAlwaysShowImage sets whether @action's menu item proxies will ignore
// the Settings:gtk-menu-images setting and always show their image, if
// available.
//
// Use this if the menu item would be useless or hard to use without their
// image.
func (action action) SetAlwaysShowImage(alwaysShow bool) {
	var arg0 *C.GtkAction
	var arg1 C.gboolean

	arg0 = (*C.GtkAction)(action.Native())
	if alwaysShow {
		arg1 = C.TRUE
	}

	C.gtk_action_set_always_show_image(arg0, arg1)
}

// SetGIcon sets the icon of @action.
func (action action) SetGIcon(icon gio.Icon) {
	var arg0 *C.GtkAction
	var arg1 *C.GIcon

	arg0 = (*C.GtkAction)(action.Native())
	arg1 = (*C.GIcon)(icon.Native())

	C.gtk_action_set_gicon(arg0, arg1)
}

// SetIconName sets the icon name on @action
func (action action) SetIconName(iconName string) {
	var arg0 *C.GtkAction
	var arg1 *C.gchar

	arg0 = (*C.GtkAction)(action.Native())
	arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_action_set_icon_name(arg0, arg1)
}

// SetIsImportant sets whether the action is important, this attribute is
// used primarily by toolbar items to decide whether to show a label or not.
func (action action) SetIsImportant(isImportant bool) {
	var arg0 *C.GtkAction
	var arg1 C.gboolean

	arg0 = (*C.GtkAction)(action.Native())
	if isImportant {
		arg1 = C.TRUE
	}

	C.gtk_action_set_is_important(arg0, arg1)
}

// SetLabel sets the label of @action.
func (action action) SetLabel(label string) {
	var arg0 *C.GtkAction
	var arg1 *C.gchar

	arg0 = (*C.GtkAction)(action.Native())
	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_action_set_label(arg0, arg1)
}

// SetSensitive sets the :sensitive property of the action to @sensitive.
// Note that this doesn’t necessarily mean effective sensitivity. See
// gtk_action_is_sensitive() for that.
func (action action) SetSensitive(sensitive bool) {
	var arg0 *C.GtkAction
	var arg1 C.gboolean

	arg0 = (*C.GtkAction)(action.Native())
	if sensitive {
		arg1 = C.TRUE
	}

	C.gtk_action_set_sensitive(arg0, arg1)
}

// SetShortLabel sets a shorter label text on @action.
func (action action) SetShortLabel(shortLabel string) {
	var arg0 *C.GtkAction
	var arg1 *C.gchar

	arg0 = (*C.GtkAction)(action.Native())
	arg1 = (*C.gchar)(C.CString(shortLabel))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_action_set_short_label(arg0, arg1)
}

// SetStockID sets the stock id on @action
func (action action) SetStockID(stockID string) {
	var arg0 *C.GtkAction
	var arg1 *C.gchar

	arg0 = (*C.GtkAction)(action.Native())
	arg1 = (*C.gchar)(C.CString(stockID))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_action_set_stock_id(arg0, arg1)
}

// SetTooltip sets the tooltip text on @action
func (action action) SetTooltip(tooltip string) {
	var arg0 *C.GtkAction
	var arg1 *C.gchar

	arg0 = (*C.GtkAction)(action.Native())
	arg1 = (*C.gchar)(C.CString(tooltip))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_action_set_tooltip(arg0, arg1)
}

// SetVisible sets the :visible property of the action to @visible. Note
// that this doesn’t necessarily mean effective visibility. See
// gtk_action_is_visible() for that.
func (action action) SetVisible(visible bool) {
	var arg0 *C.GtkAction
	var arg1 C.gboolean

	arg0 = (*C.GtkAction)(action.Native())
	if visible {
		arg1 = C.TRUE
	}

	C.gtk_action_set_visible(arg0, arg1)
}

// SetVisibleHorizontal sets whether @action is visible when horizontal
func (action action) SetVisibleHorizontal(visibleHorizontal bool) {
	var arg0 *C.GtkAction
	var arg1 C.gboolean

	arg0 = (*C.GtkAction)(action.Native())
	if visibleHorizontal {
		arg1 = C.TRUE
	}

	C.gtk_action_set_visible_horizontal(arg0, arg1)
}

// SetVisibleVertical sets whether @action is visible when vertical
func (action action) SetVisibleVertical(visibleVertical bool) {
	var arg0 *C.GtkAction
	var arg1 C.gboolean

	arg0 = (*C.GtkAction)(action.Native())
	if visibleVertical {
		arg1 = C.TRUE
	}

	C.gtk_action_set_visible_vertical(arg0, arg1)
}

// UnblockActivate: reenable activation signals from the action
func (action action) UnblockActivate() {
	var arg0 *C.GtkAction

	arg0 = (*C.GtkAction)(action.Native())

	C.gtk_action_unblock_activate(arg0)
}

// ActionGroup actions are organised into groups. An action group is essentially
// a map from names to Action objects.
//
// All actions that would make sense to use in a particular context should be in
// a single group. Multiple action groups may be used for a particular user
// interface. In fact, it is expected that most nontrivial applications will
// make use of multiple groups. For example, in an application that can edit
// multiple documents, one group holding global actions (e.g. quit, about, new),
// and one group per document holding actions that act on that document (eg.
// save, cut/copy/paste, etc). Each window’s menus would be constructed from a
// combination of two action groups.
//
//
// Accelerators
//
// Accelerators are handled by the GTK+ accelerator map. All actions are
// assigned an accelerator path (which normally has the form
// `<Actions>/group-name/action-name`) and a shortcut is associated with this
// accelerator path. All menuitems and toolitems take on this accelerator path.
// The GTK+ accelerator map code makes sure that the correct shortcut is
// displayed next to the menu item.
//
//
// GtkActionGroup as GtkBuildable
//
// The ActionGroup implementation of the Buildable interface accepts Action
// objects as <child> elements in UI definitions.
//
// Note that it is probably more common to define actions and action groups in
// the code, since they are directly related to what the code can do.
//
// The GtkActionGroup implementation of the GtkBuildable interface supports a
// custom <accelerator> element, which has attributes named “key“ and
// “modifiers“ and allows to specify accelerators. This is similar to the
// <accelerator> element of Widget, the main difference is that it doesn’t allow
// you to specify a signal.
//
// A Dialog UI definition fragment. ##
//
//    <object class="GtkActionGroup" id="actiongroup">
//      <child>
//          <object class="GtkAction" id="About">
//              <property name="name">About</property>
//              <property name="stock_id">gtk-about</property>
//              <signal handler="about_activate" name="activate"/>
//          </object>
//          <accelerator key="F1" modifiers="GDK_CONTROL_MASK | GDK_SHIFT_MASK"/>
//      </child>
//    </object>
type ActionGroup interface {
	gextras.Objector
	Buildable

	// AddAction adds an action object to the action group. Note that this
	// function does not set up the accel path of the action, which can lead to
	// problems if a user tries to modify the accelerator of a menuitem
	// associated with the action. Therefore you must either set the accel path
	// yourself with gtk_action_set_accel_path(), or use
	// `gtk_action_group_add_action_with_accel (..., NULL)`.
	AddAction(action Action)
	// AddActionWithAccel adds an action object to the action group and sets up
	// the accelerator.
	//
	// If @accelerator is nil, attempts to use the accelerator associated with
	// the stock_id of the action.
	//
	// Accel paths are set to `<Actions>/group-name/action-name`.
	AddActionWithAccel(action Action, accelerator string)
	// AddActions: this is a convenience function to create a number of actions
	// and add them to the action group.
	//
	// The “activate” signals of the actions are connected to the callbacks and
	// their accel paths are set to `<Actions>/group-name/action-name`.
	AddActions(entries []ActionEntry, userData interface{})
	// AddActionsFull: this variant of gtk_action_group_add_actions() adds a
	// Notify callback for @user_data.
	AddActionsFull(entries []ActionEntry, userData interface{})
	// AddRadioActions: this is a convenience routine to create a group of radio
	// actions and add them to the action group.
	//
	// The “changed” signal of the first radio action is connected to the
	// @on_change callback and the accel paths of the actions are set to
	// `<Actions>/group-name/action-name`.
	AddRadioActions(entries []RadioActionEntry, value int, onChange gobject.Callback)
	// AddRadioActionsFull: this variant of gtk_action_group_add_radio_actions()
	// adds a Notify callback for @user_data.
	AddRadioActionsFull(entries []RadioActionEntry, value int, onChange gobject.Callback)
	// AddToggleActions: this is a convenience function to create a number of
	// toggle actions and add them to the action group.
	//
	// The “activate” signals of the actions are connected to the callbacks and
	// their accel paths are set to `<Actions>/group-name/action-name`.
	AddToggleActions(entries []ToggleActionEntry, userData interface{})
	// AddToggleActionsFull: this variant of
	// gtk_action_group_add_toggle_actions() adds a Notify callback for
	// @user_data.
	AddToggleActionsFull(entries []ToggleActionEntry, userData interface{})
	// AccelGroup gets the accelerator group.
	AccelGroup() AccelGroup
	// Action looks up an action in the action group by name.
	Action(actionName string) Action
	// Name gets the name of the action group.
	Name() string
	// Sensitive returns true if the group is sensitive. The constituent actions
	// can only be logically sensitive (see gtk_action_is_sensitive()) if they
	// are sensitive (see gtk_action_get_sensitive()) and their group is
	// sensitive.
	Sensitive() bool
	// Visible returns true if the group is visible. The constituent actions can
	// only be logically visible (see gtk_action_is_visible()) if they are
	// visible (see gtk_action_get_visible()) and their group is visible.
	Visible() bool
	// ListActions lists the actions in the action group.
	ListActions() *glib.List
	// RemoveAction removes an action object from the action group.
	RemoveAction(action Action)
	// SetAccelGroup sets the accelerator group to be used by every action in
	// this group.
	SetAccelGroup(accelGroup AccelGroup)
	// SetSensitive changes the sensitivity of @action_group
	SetSensitive(sensitive bool)
	// SetTranslateFunc sets a function to be used for translating the @label
	// and @tooltip of ActionEntrys added by gtk_action_group_add_actions().
	//
	// If you’re using gettext(), it is enough to set the translation domain
	// with gtk_action_group_set_translation_domain().
	SetTranslateFunc(fn TranslateFunc)
	// SetTranslationDomain sets the translation domain and uses g_dgettext()
	// for translating the @label and @tooltip of ActionEntrys added by
	// gtk_action_group_add_actions().
	//
	// If you’re not using gettext() for localization, see
	// gtk_action_group_set_translate_func().
	SetTranslationDomain(domain string)
	// SetVisible changes the visible of @action_group.
	SetVisible(visible bool)
	// TranslateString translates a string using the function set with
	// gtk_action_group_set_translate_func(). This is mainly intended for
	// language bindings.
	TranslateString(string string) string
}

// actionGroup implements the ActionGroup interface.
type actionGroup struct {
	gextras.Objector
	Buildable
}

var _ ActionGroup = (*actionGroup)(nil)

// WrapActionGroup wraps a GObject to the right type. It is
// primarily used internally.
func WrapActionGroup(obj *externglib.Object) ActionGroup {
	return ActionGroup{
		Objector:  obj,
		Buildable: WrapBuildable(obj),
	}
}

func marshalActionGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapActionGroup(obj), nil
}

// NewActionGroup constructs a class ActionGroup.
func NewActionGroup(name string) ActionGroup {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_action_group_new(arg1)

	var ret0 ActionGroup

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(ActionGroup)

	return ret0
}

// AddAction adds an action object to the action group. Note that this
// function does not set up the accel path of the action, which can lead to
// problems if a user tries to modify the accelerator of a menuitem
// associated with the action. Therefore you must either set the accel path
// yourself with gtk_action_set_accel_path(), or use
// `gtk_action_group_add_action_with_accel (..., NULL)`.
func (actionGroup actionGroup) AddAction(action Action) {
	var arg0 *C.GtkActionGroup
	var arg1 *C.GtkAction

	arg0 = (*C.GtkActionGroup)(actionGroup.Native())
	arg1 = (*C.GtkAction)(action.Native())

	C.gtk_action_group_add_action(arg0, arg1)
}

// AddActionWithAccel adds an action object to the action group and sets up
// the accelerator.
//
// If @accelerator is nil, attempts to use the accelerator associated with
// the stock_id of the action.
//
// Accel paths are set to `<Actions>/group-name/action-name`.
func (actionGroup actionGroup) AddActionWithAccel(action Action, accelerator string) {
	var arg0 *C.GtkActionGroup
	var arg1 *C.GtkAction
	var arg2 *C.gchar

	arg0 = (*C.GtkActionGroup)(actionGroup.Native())
	arg1 = (*C.GtkAction)(action.Native())
	arg2 = (*C.gchar)(C.CString(accelerator))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_action_group_add_action_with_accel(arg0, arg1, arg2)
}

// AddActions: this is a convenience function to create a number of actions
// and add them to the action group.
//
// The “activate” signals of the actions are connected to the callbacks and
// their accel paths are set to `<Actions>/group-name/action-name`.
func (actionGroup actionGroup) AddActions(entries []ActionEntry, userData interface{}) {
	var arg0 *C.GtkActionGroup
	var arg1 *C.GtkActionEntry
	var arg2 C.guint
	var arg3 C.gpointer

	arg0 = (*C.GtkActionGroup)(actionGroup.Native())
	{
		var dst []C.GtkActionEntry
		ptr := C.malloc(C.sizeof_GtkActionEntry * len(entries))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(entries)
		sliceHeader.Cap = len(entries)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(entries); i++ {
			src := entries[i]
			dst[i] = (C.GtkActionEntry)(src.Native())
		}

		arg1 = (*C.GtkActionEntry)(unsafe.Pointer(ptr))
		arg2 = len(entries)
	}
	arg3 = C.gpointer(box.Assign(userData))

	C.gtk_action_group_add_actions(arg0, arg1, arg2, arg3)
}

// AddActionsFull: this variant of gtk_action_group_add_actions() adds a
// Notify callback for @user_data.
func (actionGroup actionGroup) AddActionsFull(entries []ActionEntry, userData interface{}) {
	var arg0 *C.GtkActionGroup
	var arg1 *C.GtkActionEntry
	var arg2 C.guint
	var arg3 C.gpointer
	var arg4 C.GDestroyNotify

	arg0 = (*C.GtkActionGroup)(actionGroup.Native())
	{
		var dst []C.GtkActionEntry
		ptr := C.malloc(C.sizeof_GtkActionEntry * len(entries))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(entries)
		sliceHeader.Cap = len(entries)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(entries); i++ {
			src := entries[i]
			dst[i] = (C.GtkActionEntry)(src.Native())
		}

		arg1 = (*C.GtkActionEntry)(unsafe.Pointer(ptr))
		arg2 = len(entries)
	}
	arg3 = C.gpointer(box.Assign(userData))

	C.gtk_action_group_add_actions_full(arg0, arg1, arg2, arg3, arg4)
}

// AddRadioActions: this is a convenience routine to create a group of radio
// actions and add them to the action group.
//
// The “changed” signal of the first radio action is connected to the
// @on_change callback and the accel paths of the actions are set to
// `<Actions>/group-name/action-name`.
func (actionGroup actionGroup) AddRadioActions(entries []RadioActionEntry, value int, onChange gobject.Callback) {
	var arg0 *C.GtkActionGroup
	var arg1 *C.GtkRadioActionEntry
	var arg2 C.guint
	var arg3 C.gint
	var arg4 C.GCallback
	var arg5 C.gpointer

	arg0 = (*C.GtkActionGroup)(actionGroup.Native())
	{
		var dst []C.GtkRadioActionEntry
		ptr := C.malloc(C.sizeof_GtkRadioActionEntry * len(entries))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(entries)
		sliceHeader.Cap = len(entries)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(entries); i++ {
			src := entries[i]
			dst[i] = (C.GtkRadioActionEntry)(src.Native())
		}

		arg1 = (*C.GtkRadioActionEntry)(unsafe.Pointer(ptr))
		arg2 = len(entries)
	}
	arg3 = C.gint(value)
	arg4 = (*[0]byte)(C.gotk4_Callback)
	arg5 = C.gpointer(box.Assign(onChange))

	C.gtk_action_group_add_radio_actions(arg0, arg1, arg2, arg3, arg4, arg5)
}

// AddRadioActionsFull: this variant of gtk_action_group_add_radio_actions()
// adds a Notify callback for @user_data.
func (actionGroup actionGroup) AddRadioActionsFull(entries []RadioActionEntry, value int, onChange gobject.Callback) {
	var arg0 *C.GtkActionGroup
	var arg1 *C.GtkRadioActionEntry
	var arg2 C.guint
	var arg3 C.gint
	var arg4 C.GCallback
	var arg5 C.gpointer
	var arg6 C.GDestroyNotify

	arg0 = (*C.GtkActionGroup)(actionGroup.Native())
	{
		var dst []C.GtkRadioActionEntry
		ptr := C.malloc(C.sizeof_GtkRadioActionEntry * len(entries))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(entries)
		sliceHeader.Cap = len(entries)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(entries); i++ {
			src := entries[i]
			dst[i] = (C.GtkRadioActionEntry)(src.Native())
		}

		arg1 = (*C.GtkRadioActionEntry)(unsafe.Pointer(ptr))
		arg2 = len(entries)
	}
	arg3 = C.gint(value)
	arg4 = (*[0]byte)(C.gotk4_Callback)
	arg5 = C.gpointer(box.Assign(onChange))
	arg6 = (*[0]byte)(C.callbackDelete)

	C.gtk_action_group_add_radio_actions_full(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
}

// AddToggleActions: this is a convenience function to create a number of
// toggle actions and add them to the action group.
//
// The “activate” signals of the actions are connected to the callbacks and
// their accel paths are set to `<Actions>/group-name/action-name`.
func (actionGroup actionGroup) AddToggleActions(entries []ToggleActionEntry, userData interface{}) {
	var arg0 *C.GtkActionGroup
	var arg1 *C.GtkToggleActionEntry
	var arg2 C.guint
	var arg3 C.gpointer

	arg0 = (*C.GtkActionGroup)(actionGroup.Native())
	{
		var dst []C.GtkToggleActionEntry
		ptr := C.malloc(C.sizeof_GtkToggleActionEntry * len(entries))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(entries)
		sliceHeader.Cap = len(entries)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(entries); i++ {
			src := entries[i]
			dst[i] = (C.GtkToggleActionEntry)(src.Native())
		}

		arg1 = (*C.GtkToggleActionEntry)(unsafe.Pointer(ptr))
		arg2 = len(entries)
	}
	arg3 = C.gpointer(box.Assign(userData))

	C.gtk_action_group_add_toggle_actions(arg0, arg1, arg2, arg3)
}

// AddToggleActionsFull: this variant of
// gtk_action_group_add_toggle_actions() adds a Notify callback for
// @user_data.
func (actionGroup actionGroup) AddToggleActionsFull(entries []ToggleActionEntry, userData interface{}) {
	var arg0 *C.GtkActionGroup
	var arg1 *C.GtkToggleActionEntry
	var arg2 C.guint
	var arg3 C.gpointer
	var arg4 C.GDestroyNotify

	arg0 = (*C.GtkActionGroup)(actionGroup.Native())
	{
		var dst []C.GtkToggleActionEntry
		ptr := C.malloc(C.sizeof_GtkToggleActionEntry * len(entries))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(entries)
		sliceHeader.Cap = len(entries)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(entries); i++ {
			src := entries[i]
			dst[i] = (C.GtkToggleActionEntry)(src.Native())
		}

		arg1 = (*C.GtkToggleActionEntry)(unsafe.Pointer(ptr))
		arg2 = len(entries)
	}
	arg3 = C.gpointer(box.Assign(userData))

	C.gtk_action_group_add_toggle_actions_full(arg0, arg1, arg2, arg3, arg4)
}

// AccelGroup gets the accelerator group.
func (actionGroup actionGroup) AccelGroup() AccelGroup {
	var arg0 *C.GtkActionGroup

	arg0 = (*C.GtkActionGroup)(actionGroup.Native())

	ret := C.gtk_action_group_get_accel_group(arg0)

	var ret0 AccelGroup

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(AccelGroup)

	return ret0
}

// Action looks up an action in the action group by name.
func (actionGroup actionGroup) Action(actionName string) Action {
	var arg0 *C.GtkActionGroup
	var arg1 *C.gchar

	arg0 = (*C.GtkActionGroup)(actionGroup.Native())
	arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_action_group_get_action(arg0, arg1)

	var ret0 Action

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Action)

	return ret0
}

// Name gets the name of the action group.
func (actionGroup actionGroup) Name() string {
	var arg0 *C.GtkActionGroup

	arg0 = (*C.GtkActionGroup)(actionGroup.Native())

	ret := C.gtk_action_group_get_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Sensitive returns true if the group is sensitive. The constituent actions
// can only be logically sensitive (see gtk_action_is_sensitive()) if they
// are sensitive (see gtk_action_get_sensitive()) and their group is
// sensitive.
func (actionGroup actionGroup) Sensitive() bool {
	var arg0 *C.GtkActionGroup

	arg0 = (*C.GtkActionGroup)(actionGroup.Native())

	ret := C.gtk_action_group_get_sensitive(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Visible returns true if the group is visible. The constituent actions can
// only be logically visible (see gtk_action_is_visible()) if they are
// visible (see gtk_action_get_visible()) and their group is visible.
func (actionGroup actionGroup) Visible() bool {
	var arg0 *C.GtkActionGroup

	arg0 = (*C.GtkActionGroup)(actionGroup.Native())

	ret := C.gtk_action_group_get_visible(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ListActions lists the actions in the action group.
func (actionGroup actionGroup) ListActions() *glib.List {
	var arg0 *C.GtkActionGroup

	arg0 = (*C.GtkActionGroup)(actionGroup.Native())

	ret := C.gtk_action_group_list_actions(arg0)

	var ret0 *glib.List

	{
		ret0 = glib.WrapList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.List) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// RemoveAction removes an action object from the action group.
func (actionGroup actionGroup) RemoveAction(action Action) {
	var arg0 *C.GtkActionGroup
	var arg1 *C.GtkAction

	arg0 = (*C.GtkActionGroup)(actionGroup.Native())
	arg1 = (*C.GtkAction)(action.Native())

	C.gtk_action_group_remove_action(arg0, arg1)
}

// SetAccelGroup sets the accelerator group to be used by every action in
// this group.
func (actionGroup actionGroup) SetAccelGroup(accelGroup AccelGroup) {
	var arg0 *C.GtkActionGroup
	var arg1 *C.GtkAccelGroup

	arg0 = (*C.GtkActionGroup)(actionGroup.Native())
	arg1 = (*C.GtkAccelGroup)(accelGroup.Native())

	C.gtk_action_group_set_accel_group(arg0, arg1)
}

// SetSensitive changes the sensitivity of @action_group
func (actionGroup actionGroup) SetSensitive(sensitive bool) {
	var arg0 *C.GtkActionGroup
	var arg1 C.gboolean

	arg0 = (*C.GtkActionGroup)(actionGroup.Native())
	if sensitive {
		arg1 = C.TRUE
	}

	C.gtk_action_group_set_sensitive(arg0, arg1)
}

// SetTranslateFunc sets a function to be used for translating the @label
// and @tooltip of ActionEntrys added by gtk_action_group_add_actions().
//
// If you’re using gettext(), it is enough to set the translation domain
// with gtk_action_group_set_translation_domain().
func (actionGroup actionGroup) SetTranslateFunc(fn TranslateFunc) {
	var arg0 *C.GtkActionGroup
	var arg1 C.GtkTranslateFunc
	var arg2 C.gpointer
	var arg3 C.GDestroyNotify

	arg0 = (*C.GtkActionGroup)(actionGroup.Native())
	arg1 = (*[0]byte)(C.gotk4_TranslateFunc)
	arg2 = C.gpointer(box.Assign(fn))
	arg3 = (*[0]byte)(C.callbackDelete)

	C.gtk_action_group_set_translate_func(arg0, arg1, arg2, arg3)
}

// SetTranslationDomain sets the translation domain and uses g_dgettext()
// for translating the @label and @tooltip of ActionEntrys added by
// gtk_action_group_add_actions().
//
// If you’re not using gettext() for localization, see
// gtk_action_group_set_translate_func().
func (actionGroup actionGroup) SetTranslationDomain(domain string) {
	var arg0 *C.GtkActionGroup
	var arg1 *C.gchar

	arg0 = (*C.GtkActionGroup)(actionGroup.Native())
	arg1 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_action_group_set_translation_domain(arg0, arg1)
}

// SetVisible changes the visible of @action_group.
func (actionGroup actionGroup) SetVisible(visible bool) {
	var arg0 *C.GtkActionGroup
	var arg1 C.gboolean

	arg0 = (*C.GtkActionGroup)(actionGroup.Native())
	if visible {
		arg1 = C.TRUE
	}

	C.gtk_action_group_set_visible(arg0, arg1)
}

// TranslateString translates a string using the function set with
// gtk_action_group_set_translate_func(). This is mainly intended for
// language bindings.
func (actionGroup actionGroup) TranslateString(string string) string {
	var arg0 *C.GtkActionGroup
	var arg1 *C.gchar

	arg0 = (*C.GtkActionGroup)(actionGroup.Native())
	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_action_group_translate_string(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Adjustment: the Adjustment object represents a value which has an associated
// lower and upper bound, together with step and page increments, and a page
// size. It is used within several GTK+ widgets, including SpinButton, Viewport,
// and Range (which is a base class for Scrollbar and Scale).
//
// The Adjustment object does not update the value itself. Instead it is left up
// to the owner of the Adjustment to control the value.
type Adjustment interface {
	gextras.Objector

	// Changed emits a Adjustment::changed signal from the Adjustment. This is
	// typically called by the owner of the Adjustment after it has changed any
	// of the Adjustment properties other than the value.
	Changed()
	// ClampPage updates the Adjustment:value property to ensure that the range
	// between @lower and @upper is in the current page (i.e. between
	// Adjustment:value and Adjustment:value + Adjustment:page-size). If the
	// range is larger than the page size, then only the start of it will be in
	// the current page.
	//
	// A Adjustment::value-changed signal will be emitted if the value is
	// changed.
	ClampPage(lower float64, upper float64)
	// Configure sets all properties of the adjustment at once.
	//
	// Use this function to avoid multiple emissions of the Adjustment::changed
	// signal. See gtk_adjustment_set_lower() for an alternative way of
	// compressing multiple emissions of Adjustment::changed into one.
	Configure(value float64, lower float64, upper float64, stepIncrement float64, pageIncrement float64, pageSize float64)
	// Lower retrieves the minimum value of the adjustment.
	Lower() float64
	// MinimumIncrement gets the smaller of step increment and page increment.
	MinimumIncrement() float64
	// PageIncrement retrieves the page increment of the adjustment.
	PageIncrement() float64
	// PageSize retrieves the page size of the adjustment.
	PageSize() float64
	// StepIncrement retrieves the step increment of the adjustment.
	StepIncrement() float64
	// Upper retrieves the maximum value of the adjustment.
	Upper() float64
	// Value gets the current value of the adjustment. See
	// gtk_adjustment_set_value().
	Value() float64
	// SetLower sets the minimum value of the adjustment.
	//
	// When setting multiple adjustment properties via their individual setters,
	// multiple Adjustment::changed signals will be emitted. However, since the
	// emission of the Adjustment::changed signal is tied to the emission of the
	// #GObject::notify signals of the changed properties, it’s possible to
	// compress the Adjustment::changed signals into one by calling
	// g_object_freeze_notify() and g_object_thaw_notify() around the calls to
	// the individual setters.
	//
	// Alternatively, using a single g_object_set() for all the properties to
	// change, or using gtk_adjustment_configure() has the same effect of
	// compressing Adjustment::changed emissions.
	SetLower(lower float64)
	// SetPageIncrement sets the page increment of the adjustment.
	//
	// See gtk_adjustment_set_lower() about how to compress multiple emissions
	// of the Adjustment::changed signal when setting multiple adjustment
	// properties.
	SetPageIncrement(pageIncrement float64)
	// SetPageSize sets the page size of the adjustment.
	//
	// See gtk_adjustment_set_lower() about how to compress multiple emissions
	// of the GtkAdjustment::changed signal when setting multiple adjustment
	// properties.
	SetPageSize(pageSize float64)
	// SetStepIncrement sets the step increment of the adjustment.
	//
	// See gtk_adjustment_set_lower() about how to compress multiple emissions
	// of the Adjustment::changed signal when setting multiple adjustment
	// properties.
	SetStepIncrement(stepIncrement float64)
	// SetUpper sets the maximum value of the adjustment.
	//
	// Note that values will be restricted by `upper - page-size` if the
	// page-size property is nonzero.
	//
	// See gtk_adjustment_set_lower() about how to compress multiple emissions
	// of the Adjustment::changed signal when setting multiple adjustment
	// properties.
	SetUpper(upper float64)
	// SetValue sets the Adjustment value. The value is clamped to lie between
	// Adjustment:lower and Adjustment:upper.
	//
	// Note that for adjustments which are used in a Scrollbar, the effective
	// range of allowed values goes from Adjustment:lower to Adjustment:upper -
	// Adjustment:page-size.
	SetValue(value float64)
	// ValueChanged emits a Adjustment::value-changed signal from the
	// Adjustment. This is typically called by the owner of the Adjustment after
	// it has changed the Adjustment:value property.
	ValueChanged()
}

// adjustment implements the Adjustment interface.
type adjustment struct {
	gextras.Objector
}

var _ Adjustment = (*adjustment)(nil)

// WrapAdjustment wraps a GObject to the right type. It is
// primarily used internally.
func WrapAdjustment(obj *externglib.Object) Adjustment {
	return Adjustment{
		Objector: obj,
	}
}

func marshalAdjustment(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAdjustment(obj), nil
}

// NewAdjustment constructs a class Adjustment.
func NewAdjustment(value float64, lower float64, upper float64, stepIncrement float64, pageIncrement float64, pageSize float64) Adjustment {
	var arg1 C.gdouble
	var arg2 C.gdouble
	var arg3 C.gdouble
	var arg4 C.gdouble
	var arg5 C.gdouble
	var arg6 C.gdouble

	arg1 = C.gdouble(value)
	arg2 = C.gdouble(lower)
	arg3 = C.gdouble(upper)
	arg4 = C.gdouble(stepIncrement)
	arg5 = C.gdouble(pageIncrement)
	arg6 = C.gdouble(pageSize)

	ret := C.gtk_adjustment_new(arg1, arg2, arg3, arg4, arg5, arg6)

	var ret0 Adjustment

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Adjustment)

	return ret0
}

// Changed emits a Adjustment::changed signal from the Adjustment. This is
// typically called by the owner of the Adjustment after it has changed any
// of the Adjustment properties other than the value.
func (adjustment adjustment) Changed() {
	var arg0 *C.GtkAdjustment

	arg0 = (*C.GtkAdjustment)(adjustment.Native())

	C.gtk_adjustment_changed(arg0)
}

// ClampPage updates the Adjustment:value property to ensure that the range
// between @lower and @upper is in the current page (i.e. between
// Adjustment:value and Adjustment:value + Adjustment:page-size). If the
// range is larger than the page size, then only the start of it will be in
// the current page.
//
// A Adjustment::value-changed signal will be emitted if the value is
// changed.
func (adjustment adjustment) ClampPage(lower float64, upper float64) {
	var arg0 *C.GtkAdjustment
	var arg1 C.gdouble
	var arg2 C.gdouble

	arg0 = (*C.GtkAdjustment)(adjustment.Native())
	arg1 = C.gdouble(lower)
	arg2 = C.gdouble(upper)

	C.gtk_adjustment_clamp_page(arg0, arg1, arg2)
}

// Configure sets all properties of the adjustment at once.
//
// Use this function to avoid multiple emissions of the Adjustment::changed
// signal. See gtk_adjustment_set_lower() for an alternative way of
// compressing multiple emissions of Adjustment::changed into one.
func (adjustment adjustment) Configure(value float64, lower float64, upper float64, stepIncrement float64, pageIncrement float64, pageSize float64) {
	var arg0 *C.GtkAdjustment
	var arg1 C.gdouble
	var arg2 C.gdouble
	var arg3 C.gdouble
	var arg4 C.gdouble
	var arg5 C.gdouble
	var arg6 C.gdouble

	arg0 = (*C.GtkAdjustment)(adjustment.Native())
	arg1 = C.gdouble(value)
	arg2 = C.gdouble(lower)
	arg3 = C.gdouble(upper)
	arg4 = C.gdouble(stepIncrement)
	arg5 = C.gdouble(pageIncrement)
	arg6 = C.gdouble(pageSize)

	C.gtk_adjustment_configure(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
}

// Lower retrieves the minimum value of the adjustment.
func (adjustment adjustment) Lower() float64 {
	var arg0 *C.GtkAdjustment

	arg0 = (*C.GtkAdjustment)(adjustment.Native())

	ret := C.gtk_adjustment_get_lower(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// MinimumIncrement gets the smaller of step increment and page increment.
func (adjustment adjustment) MinimumIncrement() float64 {
	var arg0 *C.GtkAdjustment

	arg0 = (*C.GtkAdjustment)(adjustment.Native())

	ret := C.gtk_adjustment_get_minimum_increment(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// PageIncrement retrieves the page increment of the adjustment.
func (adjustment adjustment) PageIncrement() float64 {
	var arg0 *C.GtkAdjustment

	arg0 = (*C.GtkAdjustment)(adjustment.Native())

	ret := C.gtk_adjustment_get_page_increment(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// PageSize retrieves the page size of the adjustment.
func (adjustment adjustment) PageSize() float64 {
	var arg0 *C.GtkAdjustment

	arg0 = (*C.GtkAdjustment)(adjustment.Native())

	ret := C.gtk_adjustment_get_page_size(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// StepIncrement retrieves the step increment of the adjustment.
func (adjustment adjustment) StepIncrement() float64 {
	var arg0 *C.GtkAdjustment

	arg0 = (*C.GtkAdjustment)(adjustment.Native())

	ret := C.gtk_adjustment_get_step_increment(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// Upper retrieves the maximum value of the adjustment.
func (adjustment adjustment) Upper() float64 {
	var arg0 *C.GtkAdjustment

	arg0 = (*C.GtkAdjustment)(adjustment.Native())

	ret := C.gtk_adjustment_get_upper(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// Value gets the current value of the adjustment. See
// gtk_adjustment_set_value().
func (adjustment adjustment) Value() float64 {
	var arg0 *C.GtkAdjustment

	arg0 = (*C.GtkAdjustment)(adjustment.Native())

	ret := C.gtk_adjustment_get_value(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// SetLower sets the minimum value of the adjustment.
//
// When setting multiple adjustment properties via their individual setters,
// multiple Adjustment::changed signals will be emitted. However, since the
// emission of the Adjustment::changed signal is tied to the emission of the
// #GObject::notify signals of the changed properties, it’s possible to
// compress the Adjustment::changed signals into one by calling
// g_object_freeze_notify() and g_object_thaw_notify() around the calls to
// the individual setters.
//
// Alternatively, using a single g_object_set() for all the properties to
// change, or using gtk_adjustment_configure() has the same effect of
// compressing Adjustment::changed emissions.
func (adjustment adjustment) SetLower(lower float64) {
	var arg0 *C.GtkAdjustment
	var arg1 C.gdouble

	arg0 = (*C.GtkAdjustment)(adjustment.Native())
	arg1 = C.gdouble(lower)

	C.gtk_adjustment_set_lower(arg0, arg1)
}

// SetPageIncrement sets the page increment of the adjustment.
//
// See gtk_adjustment_set_lower() about how to compress multiple emissions
// of the Adjustment::changed signal when setting multiple adjustment
// properties.
func (adjustment adjustment) SetPageIncrement(pageIncrement float64) {
	var arg0 *C.GtkAdjustment
	var arg1 C.gdouble

	arg0 = (*C.GtkAdjustment)(adjustment.Native())
	arg1 = C.gdouble(pageIncrement)

	C.gtk_adjustment_set_page_increment(arg0, arg1)
}

// SetPageSize sets the page size of the adjustment.
//
// See gtk_adjustment_set_lower() about how to compress multiple emissions
// of the GtkAdjustment::changed signal when setting multiple adjustment
// properties.
func (adjustment adjustment) SetPageSize(pageSize float64) {
	var arg0 *C.GtkAdjustment
	var arg1 C.gdouble

	arg0 = (*C.GtkAdjustment)(adjustment.Native())
	arg1 = C.gdouble(pageSize)

	C.gtk_adjustment_set_page_size(arg0, arg1)
}

// SetStepIncrement sets the step increment of the adjustment.
//
// See gtk_adjustment_set_lower() about how to compress multiple emissions
// of the Adjustment::changed signal when setting multiple adjustment
// properties.
func (adjustment adjustment) SetStepIncrement(stepIncrement float64) {
	var arg0 *C.GtkAdjustment
	var arg1 C.gdouble

	arg0 = (*C.GtkAdjustment)(adjustment.Native())
	arg1 = C.gdouble(stepIncrement)

	C.gtk_adjustment_set_step_increment(arg0, arg1)
}

// SetUpper sets the maximum value of the adjustment.
//
// Note that values will be restricted by `upper - page-size` if the
// page-size property is nonzero.
//
// See gtk_adjustment_set_lower() about how to compress multiple emissions
// of the Adjustment::changed signal when setting multiple adjustment
// properties.
func (adjustment adjustment) SetUpper(upper float64) {
	var arg0 *C.GtkAdjustment
	var arg1 C.gdouble

	arg0 = (*C.GtkAdjustment)(adjustment.Native())
	arg1 = C.gdouble(upper)

	C.gtk_adjustment_set_upper(arg0, arg1)
}

// SetValue sets the Adjustment value. The value is clamped to lie between
// Adjustment:lower and Adjustment:upper.
//
// Note that for adjustments which are used in a Scrollbar, the effective
// range of allowed values goes from Adjustment:lower to Adjustment:upper -
// Adjustment:page-size.
func (adjustment adjustment) SetValue(value float64) {
	var arg0 *C.GtkAdjustment
	var arg1 C.gdouble

	arg0 = (*C.GtkAdjustment)(adjustment.Native())
	arg1 = C.gdouble(value)

	C.gtk_adjustment_set_value(arg0, arg1)
}

// ValueChanged emits a Adjustment::value-changed signal from the
// Adjustment. This is typically called by the owner of the Adjustment after
// it has changed the Adjustment:value property.
func (adjustment adjustment) ValueChanged() {
	var arg0 *C.GtkAdjustment

	arg0 = (*C.GtkAdjustment)(adjustment.Native())

	C.gtk_adjustment_value_changed(arg0)
}

// Builder: a GtkBuilder is an auxiliary object that reads textual descriptions
// of a user interface and instantiates the described objects. To create a
// GtkBuilder from a user interface description, call
// gtk_builder_new_from_file(), gtk_builder_new_from_resource() or
// gtk_builder_new_from_string().
//
// In the (unusual) case that you want to add user interface descriptions from
// multiple sources to the same GtkBuilder you can call gtk_builder_new() to get
// an empty builder and populate it by (multiple) calls to
// gtk_builder_add_from_file(), gtk_builder_add_from_resource() or
// gtk_builder_add_from_string().
//
// A GtkBuilder holds a reference to all objects that it has constructed and
// drops these references when it is finalized. This finalization can cause the
// destruction of non-widget objects or widgets which are not contained in a
// toplevel window. For toplevel windows constructed by a builder, it is the
// responsibility of the user to call gtk_widget_destroy() to get rid of them
// and all the widgets they contain.
//
// The functions gtk_builder_get_object() and gtk_builder_get_objects() can be
// used to access the widgets in the interface by the names assigned to them
// inside the UI description. Toplevel windows returned by these functions will
// stay around until the user explicitly destroys them with
// gtk_widget_destroy(). Other widgets will either be part of a larger hierarchy
// constructed by the builder (in which case you should not have to worry about
// their lifecycle), or without a parent, in which case they have to be added to
// some container to make use of them. Non-widget objects need to be reffed with
// g_object_ref() to keep them beyond the lifespan of the builder.
//
// The function gtk_builder_connect_signals() and variants thereof can be used
// to connect handlers to the named signals in the description.
//
//
// GtkBuilder UI Definitions
//
// GtkBuilder parses textual descriptions of user interfaces which are specified
// in an XML format which can be roughly described by the RELAX NG schema below.
// We refer to these descriptions as “GtkBuilder UI definitions” or just “UI
// definitions” if the context is clear. Do not confuse GtkBuilder UI
// Definitions with [GtkUIManager UI Definitions][XML-UI], which are more
// limited in scope. It is common to use `.ui` as the filename extension for
// files containing GtkBuilder UI definitions.
//
// RELAX NG Compact Syntax
// (https://gitlab.gnome.org/GNOME/gtk/-/blob/gtk-3-24/gtk/gtkbuilder.rnc)
//
// The toplevel element is <interface>. It optionally takes a “domain”
// attribute, which will make the builder look for translated strings using
// dgettext() in the domain specified. This can also be done by calling
// gtk_builder_set_translation_domain() on the builder. Objects are described by
// <object> elements, which can contain <property> elements to set properties,
// <signal> elements which connect signals to handlers, and <child> elements,
// which describe child objects (most often widgets inside a container, but also
// e.g. actions in an action group, or columns in a tree model). A <child>
// element contains an <object> element which describes the child object. The
// target toolkit version(s) are described by <requires> elements, the “lib”
// attribute specifies the widget library in question (currently the only
// supported value is “gtk+”) and the “version” attribute specifies the target
// version in the form “<major>.<minor>”. The builder will error out if the
// version requirements are not met.
//
// Typically, the specific kind of object represented by an <object> element is
// specified by the “class” attribute. If the type has not been loaded yet, GTK+
// tries to find the get_type() function from the class name by applying
// heuristics. This works in most cases, but if necessary, it is possible to
// specify the name of the get_type() function explictly with the "type-func"
// attribute. As a special case, GtkBuilder allows to use an object that has
// been constructed by a UIManager in another part of the UI definition by
// specifying the id of the UIManager in the “constructor” attribute and the
// name of the object in the “id” attribute.
//
// Objects may be given a name with the “id” attribute, which allows the
// application to retrieve them from the builder with gtk_builder_get_object().
// An id is also necessary to use the object as property value in other parts of
// the UI definition. GTK+ reserves ids starting and ending with ___ (3
// underscores) for its own purposes.
//
// Setting properties of objects is pretty straightforward with the <property>
// element: the “name” attribute specifies the name of the property, and the
// content of the element specifies the value. If the “translatable” attribute
// is set to a true value, GTK+ uses gettext() (or dgettext() if the builder has
// a translation domain set) to find a translation for the value. This happens
// before the value is parsed, so it can be used for properties of any type, but
// it is probably most useful for string properties. It is also possible to
// specify a context to disambiguate short strings, and comments which may help
// the translators.
//
// GtkBuilder can parse textual representations for the most common property
// types: characters, strings, integers, floating-point numbers, booleans
// (strings like “TRUE”, “t”, “yes”, “y”, “1” are interpreted as true, strings
// like “FALSE”, “f”, “no”, “n”, “0” are interpreted as false), enumerations
// (can be specified by their name, nick or integer value), flags (can be
// specified by their name, nick, integer value, optionally combined with “|”,
// e.g. “GTK_VISIBLE|GTK_REALIZED”) and colors (in a format understood by
// gdk_rgba_parse()).
//
// GVariants can be specified in the format understood by g_variant_parse(), and
// pixbufs can be specified as a filename of an image file to load.
//
// Objects can be referred to by their name and by default refer to objects
// declared in the local xml fragment and objects exposed via
// gtk_builder_expose_object(). In general, GtkBuilder allows forward references
// to objects — declared in the local xml; an object doesn’t have to be
// constructed before it can be referred to. The exception to this rule is that
// an object has to be constructed before it can be used as the value of a
// construct-only property.
//
// It is also possible to bind a property value to another object's property
// value using the attributes "bind-source" to specify the source object of the
// binding, "bind-property" to specify the source property and optionally
// "bind-flags" to specify the binding flags. Internally builder implements this
// using GBinding objects. For more information see g_object_bind_property()
//
// Signal handlers are set up with the <signal> element. The “name” attribute
// specifies the name of the signal, and the “handler” attribute specifies the
// function to connect to the signal. By default, GTK+ tries to find the handler
// using g_module_symbol(), but this can be changed by passing a custom
// BuilderConnectFunc to gtk_builder_connect_signals_full(). The remaining
// attributes, “after”, “swapped” and “object”, have the same meaning as the
// corresponding parameters of the g_signal_connect_object() or
// g_signal_connect_data() functions. A “last_modification_time” attribute is
// also allowed, but it does not have a meaning to the builder.
//
// Sometimes it is necessary to refer to widgets which have implicitly been
// constructed by GTK+ as part of a composite widget, to set properties on them
// or to add further children (e.g. the @vbox of a Dialog). This can be achieved
// by setting the “internal-child” property of the <child> element to a true
// value. Note that GtkBuilder still requires an <object> element for the
// internal child, even if it has already been constructed.
//
// A number of widgets have different places where a child can be added (e.g.
// tabs vs. page content in notebooks). This can be reflected in a UI definition
// by specifying the “type” attribute on a <child> The possible values for the
// “type” attribute are described in the sections describing the widget-specific
// portions of UI definitions.
//
// A GtkBuilder UI Definition
//
//    <interface>
//      <object class="GtkDialog" id="dialog1">
//        <child internal-child="vbox">
//          <object class="GtkBox" id="vbox1">
//            <property name="border-width">10</property>
//            <child internal-child="action_area">
//              <object class="GtkButtonBox" id="hbuttonbox1">
//                <property name="border-width">20</property>
//                <child>
//                  <object class="GtkButton" id="ok_button">
//                    <property name="label">gtk-ok</property>
//                    <property name="use-stock">TRUE</property>
//                    <signal name="clicked" handler="ok_button_clicked"/>
//                  </object>
//                </child>
//              </object>
//            </child>
//          </object>
//        </child>
//      </object>
//    </interface>
//
// Beyond this general structure, several object classes define their own XML
// DTD fragments for filling in the ANY placeholders in the DTD above. Note that
// a custom element in a <child> element gets parsed by the custom tag handler
// of the parent object, while a custom element in an <object> element gets
// parsed by the custom tag handler of the object.
//
// These XML fragments are explained in the documentation of the respective
// objects.
//
// Additionally, since 3.10 a special <template> tag has been added to the
// format allowing one to define a widget class’s components. See the [GtkWidget
// documentation][composite-templates] for details.
type Builder interface {
	gextras.Objector

	// AddFromFile parses a file containing a [GtkBuilder UI
	// definition][BUILDER-UI] and merges it with the current contents of
	// @builder.
	//
	// Most users will probably want to use gtk_builder_new_from_file().
	//
	// If an error occurs, 0 will be returned and @error will be assigned a
	// #GError from the K_BUILDER_ERROR, MARKUP_ERROR or FILE_ERROR domain.
	//
	// It’s not really reasonable to attempt to handle failures of this call.
	// You should not use this function with untrusted files (ie: files that are
	// not part of your application). Broken Builder files can easily crash your
	// program, and it’s possible that memory was leaked leading up to the
	// reported failure. The only reasonable thing to do when an error is
	// detected is to call g_error().
	AddFromFile(filename string) (guint uint, err error)
	// AddFromResource parses a resource file containing a [GtkBuilder UI
	// definition][BUILDER-UI] and merges it with the current contents of
	// @builder.
	//
	// Most users will probably want to use gtk_builder_new_from_resource().
	//
	// If an error occurs, 0 will be returned and @error will be assigned a
	// #GError from the K_BUILDER_ERROR, MARKUP_ERROR or RESOURCE_ERROR domain.
	//
	// It’s not really reasonable to attempt to handle failures of this call.
	// The only reasonable thing to do when an error is detected is to call
	// g_error().
	AddFromResource(resourcePath string) (guint uint, err error)
	// AddFromString parses a string containing a [GtkBuilder UI
	// definition][BUILDER-UI] and merges it with the current contents of
	// @builder.
	//
	// Most users will probably want to use gtk_builder_new_from_string().
	//
	// Upon errors 0 will be returned and @error will be assigned a #GError from
	// the K_BUILDER_ERROR, MARKUP_ERROR or VARIANT_PARSE_ERROR domain.
	//
	// It’s not really reasonable to attempt to handle failures of this call.
	// The only reasonable thing to do when an error is detected is to call
	// g_error().
	AddFromString(buffer string, length uint) (guint uint, err error)
	// AddObjectsFromFile parses a file containing a [GtkBuilder UI
	// definition][BUILDER-UI] building only the requested objects and merges
	// them with the current contents of @builder.
	//
	// Upon errors 0 will be returned and @error will be assigned a #GError from
	// the K_BUILDER_ERROR, MARKUP_ERROR or FILE_ERROR domain.
	//
	// If you are adding an object that depends on an object that is not its
	// child (for instance a TreeView that depends on its TreeModel), you have
	// to explicitly list all of them in @object_ids.
	AddObjectsFromFile(filename string, objectIds []string) (guint uint, err error)
	// AddObjectsFromResource parses a resource file containing a [GtkBuilder UI
	// definition][BUILDER-UI] building only the requested objects and merges
	// them with the current contents of @builder.
	//
	// Upon errors 0 will be returned and @error will be assigned a #GError from
	// the K_BUILDER_ERROR, MARKUP_ERROR or RESOURCE_ERROR domain.
	//
	// If you are adding an object that depends on an object that is not its
	// child (for instance a TreeView that depends on its TreeModel), you have
	// to explicitly list all of them in @object_ids.
	AddObjectsFromResource(resourcePath string, objectIds []string) (guint uint, err error)
	// AddObjectsFromString parses a string containing a [GtkBuilder UI
	// definition][BUILDER-UI] building only the requested objects and merges
	// them with the current contents of @builder.
	//
	// Upon errors 0 will be returned and @error will be assigned a #GError from
	// the K_BUILDER_ERROR or MARKUP_ERROR domain.
	//
	// If you are adding an object that depends on an object that is not its
	// child (for instance a TreeView that depends on its TreeModel), you have
	// to explicitly list all of them in @object_ids.
	AddObjectsFromString(buffer string, length uint, objectIds []string) (guint uint, err error)
	// ConnectSignals: this method is a simpler variation of
	// gtk_builder_connect_signals_full(). It uses symbols explicitly added to
	// @builder with prior calls to gtk_builder_add_callback_symbol(). In the
	// case that symbols are not explicitly added; it uses #GModule’s
	// introspective features (by opening the module nil) to look at the
	// application’s symbol table. From here it tries to match the signal
	// handler names given in the interface description with symbols in the
	// application and connects the signals. Note that this function can only be
	// called once, subsequent calls will do nothing.
	//
	// Note that unless gtk_builder_add_callback_symbol() is called for all
	// signal callbacks which are referenced by the loaded XML, this function
	// will require that #GModule be supported on the platform.
	//
	// If you rely on #GModule support to lookup callbacks in the symbol table,
	// the following details should be noted:
	//
	// When compiling applications for Windows, you must declare signal
	// callbacks with MODULE_EXPORT, or they will not be put in the symbol
	// table. On Linux and Unices, this is not necessary; applications should
	// instead be compiled with the -Wl,--export-dynamic CFLAGS, and linked
	// against gmodule-export-2.0.
	ConnectSignals(userData interface{})
	// ConnectSignalsFull: this function can be thought of the interpreted
	// language binding version of gtk_builder_connect_signals(), except that it
	// does not require GModule to function correctly.
	ConnectSignalsFull(fn BuilderConnectFunc)
	// ExposeObject: add @object to the @builder object pool so it can be
	// referenced just like any other object built by builder.
	ExposeObject(name string, object gextras.Objector)
	// ExtendWithTemplate: main private entry point for building composite
	// container components from template XML.
	//
	// This is exported purely to let gtk-builder-tool validate templates,
	// applications have no need to call this function.
	ExtendWithTemplate(widget Widget, templateType externglib.Type, buffer string, length uint) (guint uint, err error)
	// Application gets the Application associated with the builder.
	//
	// The Application is used for creating action proxies as requested from XML
	// that the builder is loading.
	//
	// By default, the builder uses the default application: the one from
	// g_application_get_default(). If you want to use another application for
	// constructing proxies, use gtk_builder_set_application().
	Application() Application
	// Object gets the object named @name. Note that this function does not
	// increment the reference count of the returned object.
	Object(name string) gextras.Objector
	// Objects gets all objects that have been constructed by @builder. Note
	// that this function does not increment the reference counts of the
	// returned objects.
	Objects() *glib.SList
	// TranslationDomain gets the translation domain of @builder.
	TranslationDomain() string
	// TypeFromName looks up a type by name, using the virtual function that
	// Builder has for that purpose. This is mainly used when implementing the
	// Buildable interface on a type.
	TypeFromName(typeName string) externglib.Type
	// SetApplication sets the application associated with @builder.
	//
	// You only need this function if there is more than one #GApplication in
	// your process. @application cannot be nil.
	SetApplication(application Application)
	// SetTranslationDomain sets the translation domain of @builder. See
	// Builder:translation-domain.
	SetTranslationDomain(domain string)
	// ValueFromString: this function demarshals a value from a string. This
	// function calls g_value_init() on the @value argument, so it need not be
	// initialised beforehand.
	//
	// This function can handle char, uchar, boolean, int, uint, long, ulong,
	// enum, flags, float, double, string, Color, RGBA and Adjustment type
	// values. Support for Widget type values is still to come.
	//
	// Upon errors false will be returned and @error will be assigned a #GError
	// from the K_BUILDER_ERROR domain.
	ValueFromString(pspec gobject.ParamSpec, string string) (value externglib.Value, err error)
	// ValueFromStringType: like gtk_builder_value_from_string(), this function
	// demarshals a value from a string, but takes a #GType instead of Spec.
	// This function calls g_value_init() on the @value argument, so it need not
	// be initialised beforehand.
	//
	// Upon errors false will be returned and @error will be assigned a #GError
	// from the K_BUILDER_ERROR domain.
	ValueFromStringType(typ externglib.Type, string string) (value externglib.Value, err error)
}

// builder implements the Builder interface.
type builder struct {
	gextras.Objector
}

var _ Builder = (*builder)(nil)

// WrapBuilder wraps a GObject to the right type. It is
// primarily used internally.
func WrapBuilder(obj *externglib.Object) Builder {
	return Builder{
		Objector: obj,
	}
}

func marshalBuilder(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBuilder(obj), nil
}

// NewBuilder constructs a class Builder.
func NewBuilder() Builder {

	ret := C.gtk_builder_new()

	var ret0 Builder

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(Builder)

	return ret0
}

// NewBuilderFromFile constructs a class Builder.
func NewBuilderFromFile(filename string) Builder {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_builder_new_from_file(arg1)

	var ret0 Builder

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(Builder)

	return ret0
}

// NewBuilderFromResource constructs a class Builder.
func NewBuilderFromResource(resourcePath string) Builder {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_builder_new_from_resource(arg1)

	var ret0 Builder

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(Builder)

	return ret0
}

// NewBuilderFromString constructs a class Builder.
func NewBuilderFromString(string string, length int) Builder {
	var arg1 *C.gchar
	var arg2 C.gssize

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(length)

	ret := C.gtk_builder_new_from_string(arg1, arg2)

	var ret0 Builder

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(Builder)

	return ret0
}

// AddFromFile parses a file containing a [GtkBuilder UI
// definition][BUILDER-UI] and merges it with the current contents of
// @builder.
//
// Most users will probably want to use gtk_builder_new_from_file().
//
// If an error occurs, 0 will be returned and @error will be assigned a
// #GError from the K_BUILDER_ERROR, MARKUP_ERROR or FILE_ERROR domain.
//
// It’s not really reasonable to attempt to handle failures of this call.
// You should not use this function with untrusted files (ie: files that are
// not part of your application). Broken Builder files can easily crash your
// program, and it’s possible that memory was leaked leading up to the
// reported failure. The only reasonable thing to do when an error is
// detected is to call g_error().
func (builder builder) AddFromFile(filename string) (guint uint, err error) {
	var arg0 *C.GtkBuilder
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GtkBuilder)(builder.Native())
	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_builder_add_from_file(arg0, arg1, &gError)

	var ret0 uint
	var goError error

	ret0 = uint(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// AddFromResource parses a resource file containing a [GtkBuilder UI
// definition][BUILDER-UI] and merges it with the current contents of
// @builder.
//
// Most users will probably want to use gtk_builder_new_from_resource().
//
// If an error occurs, 0 will be returned and @error will be assigned a
// #GError from the K_BUILDER_ERROR, MARKUP_ERROR or RESOURCE_ERROR domain.
//
// It’s not really reasonable to attempt to handle failures of this call.
// The only reasonable thing to do when an error is detected is to call
// g_error().
func (builder builder) AddFromResource(resourcePath string) (guint uint, err error) {
	var arg0 *C.GtkBuilder
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GtkBuilder)(builder.Native())
	arg1 = (*C.gchar)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_builder_add_from_resource(arg0, arg1, &gError)

	var ret0 uint
	var goError error

	ret0 = uint(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// AddFromString parses a string containing a [GtkBuilder UI
// definition][BUILDER-UI] and merges it with the current contents of
// @builder.
//
// Most users will probably want to use gtk_builder_new_from_string().
//
// Upon errors 0 will be returned and @error will be assigned a #GError from
// the K_BUILDER_ERROR, MARKUP_ERROR or VARIANT_PARSE_ERROR domain.
//
// It’s not really reasonable to attempt to handle failures of this call.
// The only reasonable thing to do when an error is detected is to call
// g_error().
func (builder builder) AddFromString(buffer string, length uint) (guint uint, err error) {
	var arg0 *C.GtkBuilder
	var arg1 *C.gchar
	var arg2 C.gsize
	var gError *C.GError

	arg0 = (*C.GtkBuilder)(builder.Native())
	arg1 = (*C.gchar)(C.CString(buffer))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gsize(length)

	ret := C.gtk_builder_add_from_string(arg0, arg1, arg2, &gError)

	var ret0 uint
	var goError error

	ret0 = uint(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// AddObjectsFromFile parses a file containing a [GtkBuilder UI
// definition][BUILDER-UI] building only the requested objects and merges
// them with the current contents of @builder.
//
// Upon errors 0 will be returned and @error will be assigned a #GError from
// the K_BUILDER_ERROR, MARKUP_ERROR or FILE_ERROR domain.
//
// If you are adding an object that depends on an object that is not its
// child (for instance a TreeView that depends on its TreeModel), you have
// to explicitly list all of them in @object_ids.
func (builder builder) AddObjectsFromFile(filename string, objectIds []string) (guint uint, err error) {
	var arg0 *C.GtkBuilder
	var arg1 *C.gchar
	var arg2 **C.gchar
	var gError *C.GError

	arg0 = (*C.GtkBuilder)(builder.Native())
	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(objectIds) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(objectIds)
		sliceHeader.Cap = len(objectIds)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(objectIds); i++ {
			src := objectIds[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg2 = (**C.gchar)(unsafe.Pointer(ptr))
	}

	ret := C.gtk_builder_add_objects_from_file(arg0, arg1, arg2, &gError)

	var ret0 uint
	var goError error

	ret0 = uint(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// AddObjectsFromResource parses a resource file containing a [GtkBuilder UI
// definition][BUILDER-UI] building only the requested objects and merges
// them with the current contents of @builder.
//
// Upon errors 0 will be returned and @error will be assigned a #GError from
// the K_BUILDER_ERROR, MARKUP_ERROR or RESOURCE_ERROR domain.
//
// If you are adding an object that depends on an object that is not its
// child (for instance a TreeView that depends on its TreeModel), you have
// to explicitly list all of them in @object_ids.
func (builder builder) AddObjectsFromResource(resourcePath string, objectIds []string) (guint uint, err error) {
	var arg0 *C.GtkBuilder
	var arg1 *C.gchar
	var arg2 **C.gchar
	var gError *C.GError

	arg0 = (*C.GtkBuilder)(builder.Native())
	arg1 = (*C.gchar)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(arg1))
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(objectIds) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(objectIds)
		sliceHeader.Cap = len(objectIds)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(objectIds); i++ {
			src := objectIds[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg2 = (**C.gchar)(unsafe.Pointer(ptr))
	}

	ret := C.gtk_builder_add_objects_from_resource(arg0, arg1, arg2, &gError)

	var ret0 uint
	var goError error

	ret0 = uint(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// AddObjectsFromString parses a string containing a [GtkBuilder UI
// definition][BUILDER-UI] building only the requested objects and merges
// them with the current contents of @builder.
//
// Upon errors 0 will be returned and @error will be assigned a #GError from
// the K_BUILDER_ERROR or MARKUP_ERROR domain.
//
// If you are adding an object that depends on an object that is not its
// child (for instance a TreeView that depends on its TreeModel), you have
// to explicitly list all of them in @object_ids.
func (builder builder) AddObjectsFromString(buffer string, length uint, objectIds []string) (guint uint, err error) {
	var arg0 *C.GtkBuilder
	var arg1 *C.gchar
	var arg2 C.gsize
	var arg3 **C.gchar
	var gError *C.GError

	arg0 = (*C.GtkBuilder)(builder.Native())
	arg1 = (*C.gchar)(C.CString(buffer))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gsize(length)
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(objectIds) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(objectIds)
		sliceHeader.Cap = len(objectIds)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(objectIds); i++ {
			src := objectIds[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg3 = (**C.gchar)(unsafe.Pointer(ptr))
	}

	ret := C.gtk_builder_add_objects_from_string(arg0, arg1, arg2, arg3, &gError)

	var ret0 uint
	var goError error

	ret0 = uint(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// ConnectSignals: this method is a simpler variation of
// gtk_builder_connect_signals_full(). It uses symbols explicitly added to
// @builder with prior calls to gtk_builder_add_callback_symbol(). In the
// case that symbols are not explicitly added; it uses #GModule’s
// introspective features (by opening the module nil) to look at the
// application’s symbol table. From here it tries to match the signal
// handler names given in the interface description with symbols in the
// application and connects the signals. Note that this function can only be
// called once, subsequent calls will do nothing.
//
// Note that unless gtk_builder_add_callback_symbol() is called for all
// signal callbacks which are referenced by the loaded XML, this function
// will require that #GModule be supported on the platform.
//
// If you rely on #GModule support to lookup callbacks in the symbol table,
// the following details should be noted:
//
// When compiling applications for Windows, you must declare signal
// callbacks with MODULE_EXPORT, or they will not be put in the symbol
// table. On Linux and Unices, this is not necessary; applications should
// instead be compiled with the -Wl,--export-dynamic CFLAGS, and linked
// against gmodule-export-2.0.
func (builder builder) ConnectSignals(userData interface{}) {
	var arg0 *C.GtkBuilder
	var arg1 C.gpointer

	arg0 = (*C.GtkBuilder)(builder.Native())
	arg1 = C.gpointer(box.Assign(userData))

	C.gtk_builder_connect_signals(arg0, arg1)
}

// ConnectSignalsFull: this function can be thought of the interpreted
// language binding version of gtk_builder_connect_signals(), except that it
// does not require GModule to function correctly.
func (builder builder) ConnectSignalsFull(fn BuilderConnectFunc) {
	var arg0 *C.GtkBuilder
	var arg1 C.GtkBuilderConnectFunc
	var arg2 C.gpointer

	arg0 = (*C.GtkBuilder)(builder.Native())
	arg1 = (*[0]byte)(C.gotk4_BuilderConnectFunc)
	arg2 = C.gpointer(box.Assign(fn))

	C.gtk_builder_connect_signals_full(arg0, arg1, arg2)
}

// ExposeObject: add @object to the @builder object pool so it can be
// referenced just like any other object built by builder.
func (builder builder) ExposeObject(name string, object gextras.Objector) {
	var arg0 *C.GtkBuilder
	var arg1 *C.gchar
	var arg2 *C.GObject

	arg0 = (*C.GtkBuilder)(builder.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GObject)(object.Native())

	C.gtk_builder_expose_object(arg0, arg1, arg2)
}

// ExtendWithTemplate: main private entry point for building composite
// container components from template XML.
//
// This is exported purely to let gtk-builder-tool validate templates,
// applications have no need to call this function.
func (builder builder) ExtendWithTemplate(widget Widget, templateType externglib.Type, buffer string, length uint) (guint uint, err error) {
	var arg0 *C.GtkBuilder
	var arg1 *C.GtkWidget
	var arg2 C.GType
	var arg3 *C.gchar
	var arg4 C.gsize
	var gError *C.GError

	arg0 = (*C.GtkBuilder)(builder.Native())
	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = C.GType(templateType)
	arg3 = (*C.gchar)(C.CString(buffer))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = C.gsize(length)

	ret := C.gtk_builder_extend_with_template(arg0, arg1, arg2, arg3, arg4, &gError)

	var ret0 uint
	var goError error

	ret0 = uint(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Application gets the Application associated with the builder.
//
// The Application is used for creating action proxies as requested from XML
// that the builder is loading.
//
// By default, the builder uses the default application: the one from
// g_application_get_default(). If you want to use another application for
// constructing proxies, use gtk_builder_set_application().
func (builder builder) Application() Application {
	var arg0 *C.GtkBuilder

	arg0 = (*C.GtkBuilder)(builder.Native())

	ret := C.gtk_builder_get_application(arg0)

	var ret0 Application

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Application)

	return ret0
}

// Object gets the object named @name. Note that this function does not
// increment the reference count of the returned object.
func (builder builder) Object(name string) gextras.Objector {
	var arg0 *C.GtkBuilder
	var arg1 *C.gchar

	arg0 = (*C.GtkBuilder)(builder.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_builder_get_object(arg0, arg1)

	var ret0 gextras.Objector

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gextras.Objector)

	return ret0
}

// Objects gets all objects that have been constructed by @builder. Note
// that this function does not increment the reference counts of the
// returned objects.
func (builder builder) Objects() *glib.SList {
	var arg0 *C.GtkBuilder

	arg0 = (*C.GtkBuilder)(builder.Native())

	ret := C.gtk_builder_get_objects(arg0)

	var ret0 *glib.SList

	{
		ret0 = glib.WrapSList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.SList) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// TranslationDomain gets the translation domain of @builder.
func (builder builder) TranslationDomain() string {
	var arg0 *C.GtkBuilder

	arg0 = (*C.GtkBuilder)(builder.Native())

	ret := C.gtk_builder_get_translation_domain(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// TypeFromName looks up a type by name, using the virtual function that
// Builder has for that purpose. This is mainly used when implementing the
// Buildable interface on a type.
func (builder builder) TypeFromName(typeName string) externglib.Type {
	var arg0 *C.GtkBuilder
	var arg1 *C.char

	arg0 = (*C.GtkBuilder)(builder.Native())
	arg1 = (*C.gchar)(C.CString(typeName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_builder_get_type_from_name(arg0, arg1)

	var ret0 externglib.Type

	ret0 = externglib.Type(ret)

	return ret0
}

// SetApplication sets the application associated with @builder.
//
// You only need this function if there is more than one #GApplication in
// your process. @application cannot be nil.
func (builder builder) SetApplication(application Application) {
	var arg0 *C.GtkBuilder
	var arg1 *C.GtkApplication

	arg0 = (*C.GtkBuilder)(builder.Native())
	arg1 = (*C.GtkApplication)(application.Native())

	C.gtk_builder_set_application(arg0, arg1)
}

// SetTranslationDomain sets the translation domain of @builder. See
// Builder:translation-domain.
func (builder builder) SetTranslationDomain(domain string) {
	var arg0 *C.GtkBuilder
	var arg1 *C.gchar

	arg0 = (*C.GtkBuilder)(builder.Native())
	arg1 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_builder_set_translation_domain(arg0, arg1)
}

// ValueFromString: this function demarshals a value from a string. This
// function calls g_value_init() on the @value argument, so it need not be
// initialised beforehand.
//
// This function can handle char, uchar, boolean, int, uint, long, ulong,
// enum, flags, float, double, string, Color, RGBA and Adjustment type
// values. Support for Widget type values is still to come.
//
// Upon errors false will be returned and @error will be assigned a #GError
// from the K_BUILDER_ERROR domain.
func (builder builder) ValueFromString(pspec gobject.ParamSpec, string string) (value externglib.Value, err error) {
	var arg0 *C.GtkBuilder
	var arg1 *C.GParamSpec
	var arg2 *C.gchar
	var arg3 *C.GValue // out
	var gError *C.GError

	arg0 = (*C.GtkBuilder)(builder.Native())
	arg1 = (*C.GParamSpec)(pspec.Native())
	arg2 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_builder_value_from_string(arg0, arg1, arg2, &arg3, &gError)

	var ret0 *externglib.Value
	var goError error

	ret0 = externglib.ValueFromNative(unsafe.Pointer(arg3))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// ValueFromStringType: like gtk_builder_value_from_string(), this function
// demarshals a value from a string, but takes a #GType instead of Spec.
// This function calls g_value_init() on the @value argument, so it need not
// be initialised beforehand.
//
// Upon errors false will be returned and @error will be assigned a #GError
// from the K_BUILDER_ERROR domain.
func (builder builder) ValueFromStringType(typ externglib.Type, string string) (value externglib.Value, err error) {
	var arg0 *C.GtkBuilder
	var arg1 C.GType
	var arg2 *C.gchar
	var arg3 *C.GValue // out
	var gError *C.GError

	arg0 = (*C.GtkBuilder)(builder.Native())
	arg1 = C.GType(typ)
	arg2 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_builder_value_from_string_type(arg0, arg1, arg2, &arg3, &gError)

	var ret0 *externglib.Value
	var goError error

	ret0 = externglib.ValueFromNative(unsafe.Pointer(arg3))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// CellArea: the CellArea is an abstract class for CellLayout widgets (also
// referred to as "layouting widgets") to interface with an arbitrary number of
// CellRenderers and interact with the user for a given TreeModel row.
//
// The cell area handles events, focus navigation, drawing and size requests and
// allocations for a given row of data.
//
// Usually users dont have to interact with the CellArea directly unless they
// are implementing a cell-layouting widget themselves.
//
//
// Requesting area sizes
//
// As outlined in [GtkWidget’s geometry management
// section][geometry-management], GTK+ uses a height-for-width geometry
// management system to compute the sizes of widgets and user interfaces.
// CellArea uses the same semantics to calculate the size of an area for an
// arbitrary number of TreeModel rows.
//
// When requesting the size of a cell area one needs to calculate the size for a
// handful of rows, and this will be done differently by different layouting
// widgets. For instance a TreeViewColumn always lines up the areas from top to
// bottom while a IconView on the other hand might enforce that all areas
// received the same width and wrap the areas around, requesting height for more
// cell areas when allocated less width.
//
// It’s also important for areas to maintain some cell alignments with areas
// rendered for adjacent rows (cells can appear “columnized” inside an area even
// when the size of cells are different in each row). For this reason the
// CellArea uses a CellAreaContext object to store the alignments and sizes
// along the way (as well as the overall largest minimum and natural size for
// all the rows which have been calculated with the said context).
//
// The CellAreaContext is an opaque object specific to the CellArea which
// created it (see gtk_cell_area_create_context()). The owning cell-layouting
// widget can create as many contexts as it wishes to calculate sizes of rows
// which should receive the same size in at least one orientation (horizontally
// or vertically), However, it’s important that the same CellAreaContext which
// was used to request the sizes for a given TreeModel row be used when
// rendering or processing events for that row.
//
// In order to request the width of all the rows at the root level of a
// TreeModel one would do the following:
//
//    static gboolean
//    foo_focus (GtkWidget       *widget,
//               GtkDirectionType direction)
//    {
//      Foo        *foo  = FOO (widget);
//      FooPrivate *priv = foo->priv;
//      gint        focus_row;
//      gboolean    have_focus = FALSE;
//
//      focus_row = priv->focus_row;
//
//      if (!gtk_widget_has_focus (widget))
//        gtk_widget_grab_focus (widget);
//
//      valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, priv->focus_row);
//      while (valid)
//        {
//          gtk_cell_area_apply_attributes (priv->area, priv->model, &iter, FALSE, FALSE);
//
//          if (gtk_cell_area_focus (priv->area, direction))
//            {
//               priv->focus_row = focus_row;
//               have_focus = TRUE;
//               break;
//            }
//          else
//            {
//              if (direction == GTK_DIR_RIGHT ||
//                  direction == GTK_DIR_LEFT)
//                break;
//              else if (direction == GTK_DIR_UP ||
//                       direction == GTK_DIR_TAB_BACKWARD)
//               {
//                  if (focus_row == 0)
//                    break;
//                  else
//                   {
//                      focus_row--;
//                      valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, focus_row);
//                   }
//                }
//              else
//                {
//                  if (focus_row == last_row)
//                    break;
//                  else
//                    {
//                      focus_row++;
//                      valid = gtk_tree_model_iter_next (priv->model, &iter);
//                    }
//                }
//            }
//        }
//        return have_focus;
//    }
//
// Note that the layouting widget is responsible for matching the
// GtkDirectionType values to the way it lays out its cells.
//
//
// Cell Properties
//
// The CellArea introduces cell properties for CellRenderers in very much the
// same way that Container introduces [child properties][child-properties] for
// Widgets. This provides some general interfaces for defining the relationship
// cell areas have with their cells. For instance in a CellAreaBox a cell might
// “expand” and receive extra space when the area is allocated more than its
// full natural request, or a cell might be configured to “align” with adjacent
// rows which were requested and rendered with the same CellAreaContext.
//
// Use gtk_cell_area_class_install_cell_property() to install cell properties
// for a cell area class and gtk_cell_area_class_find_cell_property() or
// gtk_cell_area_class_list_cell_properties() to get information about existing
// cell properties.
//
// To set the value of a cell property, use gtk_cell_area_cell_set_property(),
// gtk_cell_area_cell_set() or gtk_cell_area_cell_set_valist(). To obtain the
// value of a cell property, use gtk_cell_area_cell_get_property(),
// gtk_cell_area_cell_get() or gtk_cell_area_cell_get_valist().
type CellArea interface {
	gextras.Objector
	Buildable
	CellLayout

	// Activate activates @area, usually by activating the currently focused
	// cell, however some subclasses which embed widgets in the area can also
	// activate a widget if it currently has the focus.
	Activate(context CellAreaContext, widget Widget, cellArea *gdk.Rectangle, flags CellRendererState, editOnly bool) bool
	// Add adds @renderer to @area with the default child cell properties.
	Add(renderer CellRenderer)
	// AddFocusSibling adds @sibling to @renderer’s focusable area, focus will
	// be drawn around @renderer and all of its siblings if @renderer can focus
	// for a given row.
	//
	// Events handled by focus siblings can also activate the given focusable
	// @renderer.
	AddFocusSibling(renderer CellRenderer, sibling CellRenderer)
	// ApplyAttributes applies any connected attributes to the renderers in
	// @area by pulling the values from @tree_model.
	ApplyAttributes(treeModel TreeModel, iter *TreeIter, isExpander bool, isExpanded bool)
	// AttributeConnect connects an @attribute to apply values from @column for
	// the TreeModel in use.
	AttributeConnect(renderer CellRenderer, attribute string, column int)
	// AttributeDisconnect disconnects @attribute for the @renderer in @area so
	// that attribute will no longer be updated with values from the model.
	AttributeDisconnect(renderer CellRenderer, attribute string)
	// AttributeGetColumn returns the model column that an attribute has been
	// mapped to, or -1 if the attribute is not mapped.
	AttributeGetColumn(renderer CellRenderer, attribute string) int
	// CellGetProperty gets the value of a cell property for @renderer in @area.
	CellGetProperty(renderer CellRenderer, propertyName string, value *externglib.Value)
	// CellSetProperty sets a cell property for @renderer in @area.
	CellSetProperty(renderer CellRenderer, propertyName string, value *externglib.Value)
	// CopyContext: this is sometimes needed for cases where rows need to share
	// alignments in one orientation but may be separately grouped in the
	// opposing orientation.
	//
	// For instance, IconView creates all icons (rows) to have the same width
	// and the cells theirin to have the same horizontal alignments. However
	// each row of icons may have a separate collective height. IconView uses
	// this to request the heights of each row based on a context which was
	// already used to request all the row widths that are to be displayed.
	CopyContext(context CellAreaContext) CellAreaContext
	// CreateContext creates a CellAreaContext to be used with @area for all
	// purposes. CellAreaContext stores geometry information for rows for which
	// it was operated on, it is important to use the same context for the same
	// row of data at all times (i.e. one should render and handle events with
	// the same CellAreaContext which was used to request the size of those rows
	// of data).
	CreateContext() CellAreaContext
	// Focus: this should be called by the @area’s owning layout widget when
	// focus is to be passed to @area, or moved within @area for a given
	// @direction and row data.
	//
	// Implementing CellArea classes should implement this method to receive and
	// navigate focus in its own way particular to how it lays out cells.
	Focus(direction DirectionType) bool
	// Foreach calls @callback for every CellRenderer in @area.
	Foreach(callback CellCallback)
	// ForeachAlloc calls @callback for every CellRenderer in @area with the
	// allocated rectangle inside @cell_area.
	ForeachAlloc(context CellAreaContext, widget Widget, cellArea *gdk.Rectangle, backgroundArea *gdk.Rectangle, callback CellAllocCallback)
	// CellAllocation derives the allocation of @renderer inside @area if @area
	// were to be renderered in @cell_area.
	CellAllocation(context CellAreaContext, widget Widget, renderer CellRenderer, cellArea *gdk.Rectangle) gdk.Rectangle
	// CellAtPosition gets the CellRenderer at @x and @y coordinates inside
	// @area and optionally returns the full cell allocation for it inside
	// @cell_area.
	CellAtPosition(context CellAreaContext, widget Widget, cellArea *gdk.Rectangle, x int, y int) (allocArea gdk.Rectangle, cellRenderer CellRenderer)
	// CurrentPathString gets the current TreePath string for the currently
	// applied TreeIter, this is implicitly updated when
	// gtk_cell_area_apply_attributes() is called and can be used to interact
	// with renderers from CellArea subclasses.
	CurrentPathString() string
	// EditWidget gets the CellEditable widget currently used to edit the
	// currently edited cell.
	EditWidget() CellEditable
	// EditedCell gets the CellRenderer in @area that is currently being edited.
	EditedCell() CellRenderer
	// FocusCell retrieves the currently focused cell for @area
	FocusCell() CellRenderer
	// FocusFromSibling gets the CellRenderer which is expected to be focusable
	// for which @renderer is, or may be a sibling.
	//
	// This is handy for CellArea subclasses when handling events, after
	// determining the renderer at the event location it can then chose to
	// activate the focus cell for which the event cell may have been a sibling.
	FocusFromSibling(renderer CellRenderer) CellRenderer
	// FocusSiblings gets the focus sibling cell renderers for @renderer.
	FocusSiblings(renderer CellRenderer) *glib.List
	// PreferredHeight retrieves a cell area’s initial minimum and natural
	// height.
	//
	// @area will store some geometrical information in @context along the way;
	// when requesting sizes over an arbitrary number of rows, it’s not
	// important to check the @minimum_height and @natural_height of this call
	// but rather to consult gtk_cell_area_context_get_preferred_height() after
	// a series of requests.
	PreferredHeight(context CellAreaContext, widget Widget) (minimumHeight int, naturalHeight int)
	// PreferredHeightForWidth retrieves a cell area’s minimum and natural
	// height if it would be given the specified @width.
	//
	// @area stores some geometrical information in @context along the way while
	// calling gtk_cell_area_get_preferred_width(). It’s important to perform a
	// series of gtk_cell_area_get_preferred_width() requests with @context
	// first and then call gtk_cell_area_get_preferred_height_for_width() on
	// each cell area individually to get the height for width of each fully
	// requested row.
	//
	// If at some point, the width of a single row changes, it should be
	// requested with gtk_cell_area_get_preferred_width() again and then the
	// full width of the requested rows checked again with
	// gtk_cell_area_context_get_preferred_width().
	PreferredHeightForWidth(context CellAreaContext, widget Widget, width int) (minimumHeight int, naturalHeight int)
	// PreferredWidth retrieves a cell area’s initial minimum and natural width.
	//
	// @area will store some geometrical information in @context along the way;
	// when requesting sizes over an arbitrary number of rows, it’s not
	// important to check the @minimum_width and @natural_width of this call but
	// rather to consult gtk_cell_area_context_get_preferred_width() after a
	// series of requests.
	PreferredWidth(context CellAreaContext, widget Widget) (minimumWidth int, naturalWidth int)
	// PreferredWidthForHeight retrieves a cell area’s minimum and natural width
	// if it would be given the specified @height.
	//
	// @area stores some geometrical information in @context along the way while
	// calling gtk_cell_area_get_preferred_height(). It’s important to perform a
	// series of gtk_cell_area_get_preferred_height() requests with @context
	// first and then call gtk_cell_area_get_preferred_width_for_height() on
	// each cell area individually to get the height for width of each fully
	// requested row.
	//
	// If at some point, the height of a single row changes, it should be
	// requested with gtk_cell_area_get_preferred_height() again and then the
	// full height of the requested rows checked again with
	// gtk_cell_area_context_get_preferred_height().
	PreferredWidthForHeight(context CellAreaContext, widget Widget, height int) (minimumWidth int, naturalWidth int)
	// RequestMode gets whether the area prefers a height-for-width layout or a
	// width-for-height layout.
	RequestMode() SizeRequestMode
	// HasRenderer checks if @area contains @renderer.
	HasRenderer(renderer CellRenderer) bool
	// InnerCellArea: this is a convenience function for CellArea
	// implementations to get the inner area where a given CellRenderer will be
	// rendered. It removes any padding previously added by
	// gtk_cell_area_request_renderer().
	InnerCellArea(widget Widget, cellArea *gdk.Rectangle) gdk.Rectangle
	// IsActivatable returns whether the area can do anything when activated,
	// after applying new attributes to @area.
	IsActivatable() bool
	// IsFocusSibling returns whether @sibling is one of @renderer’s focus
	// siblings (see gtk_cell_area_add_focus_sibling()).
	IsFocusSibling(renderer CellRenderer, sibling CellRenderer) bool
	// Remove removes @renderer from @area.
	Remove(renderer CellRenderer)
	// RemoveFocusSibling removes @sibling from @renderer’s focus sibling list
	// (see gtk_cell_area_add_focus_sibling()).
	RemoveFocusSibling(renderer CellRenderer, sibling CellRenderer)
	// Render renders @area’s cells according to @area’s layout onto @widget at
	// the given coordinates.
	Render(context CellAreaContext, widget Widget, cr *cairo.Context, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState, paintFocus bool)
	// RequestRenderer: this is a convenience function for CellArea
	// implementations to request size for cell renderers. It’s important to use
	// this function to request size and then use
	// gtk_cell_area_inner_cell_area() at render and event time since this
	// function will add padding around the cell for focus painting.
	RequestRenderer(renderer CellRenderer, orientation Orientation, widget Widget, forSize int) (minimumSize int, naturalSize int)
	// SetFocusCell: explicitly sets the currently focused cell to @renderer.
	//
	// This is generally called by implementations of CellAreaClass.focus() or
	// CellAreaClass.event(), however it can also be used to implement functions
	// such as gtk_tree_view_set_cursor_on_cell().
	SetFocusCell(renderer CellRenderer)
	// StopEditing: explicitly stops the editing of the currently edited cell.
	//
	// If @canceled is true, the currently edited cell renderer will emit the
	// ::editing-canceled signal, otherwise the the ::editing-done signal will
	// be emitted on the current edit widget.
	//
	// See gtk_cell_area_get_edited_cell() and gtk_cell_area_get_edit_widget().
	StopEditing(canceled bool)
}

// cellArea implements the CellArea interface.
type cellArea struct {
	gextras.Objector
	Buildable
	CellLayout
}

var _ CellArea = (*cellArea)(nil)

// WrapCellArea wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellArea(obj *externglib.Object) CellArea {
	return CellArea{
		Objector:   obj,
		Buildable:  WrapBuildable(obj),
		CellLayout: WrapCellLayout(obj),
	}
}

func marshalCellArea(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellArea(obj), nil
}

// Activate activates @area, usually by activating the currently focused
// cell, however some subclasses which embed widgets in the area can also
// activate a widget if it currently has the focus.
func (area cellArea) Activate(context CellAreaContext, widget Widget, cellArea *gdk.Rectangle, flags CellRendererState, editOnly bool) bool {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellAreaContext
	var arg2 *C.GtkWidget
	var arg3 *C.GdkRectangle
	var arg4 C.GtkCellRendererState
	var arg5 C.gboolean

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellAreaContext)(context.Native())
	arg2 = (*C.GtkWidget)(widget.Native())
	arg3 = (*C.GdkRectangle)(cellArea.Native())
	arg4 = (C.GtkCellRendererState)(flags)
	if editOnly {
		arg5 = C.TRUE
	}

	ret := C.gtk_cell_area_activate(arg0, arg1, arg2, arg3, arg4, arg5)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Add adds @renderer to @area with the default child cell properties.
func (area cellArea) Add(renderer CellRenderer) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellRenderer)(renderer.Native())

	C.gtk_cell_area_add(arg0, arg1)
}

// AddFocusSibling adds @sibling to @renderer’s focusable area, focus will
// be drawn around @renderer and all of its siblings if @renderer can focus
// for a given row.
//
// Events handled by focus siblings can also activate the given focusable
// @renderer.
func (area cellArea) AddFocusSibling(renderer CellRenderer, sibling CellRenderer) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer
	var arg2 *C.GtkCellRenderer

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellRenderer)(renderer.Native())
	arg2 = (*C.GtkCellRenderer)(sibling.Native())

	C.gtk_cell_area_add_focus_sibling(arg0, arg1, arg2)
}

// ApplyAttributes applies any connected attributes to the renderers in
// @area by pulling the values from @tree_model.
func (area cellArea) ApplyAttributes(treeModel TreeModel, iter *TreeIter, isExpander bool, isExpanded bool) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkTreeModel
	var arg2 *C.GtkTreeIter
	var arg3 C.gboolean
	var arg4 C.gboolean

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkTreeModel)(treeModel.Native())
	arg2 = (*C.GtkTreeIter)(iter.Native())
	if isExpander {
		arg3 = C.TRUE
	}
	if isExpanded {
		arg4 = C.TRUE
	}

	C.gtk_cell_area_apply_attributes(arg0, arg1, arg2, arg3, arg4)
}

// AttributeConnect connects an @attribute to apply values from @column for
// the TreeModel in use.
func (area cellArea) AttributeConnect(renderer CellRenderer, attribute string, column int) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer
	var arg2 *C.gchar
	var arg3 C.gint

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellRenderer)(renderer.Native())
	arg2 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.gint(column)

	C.gtk_cell_area_attribute_connect(arg0, arg1, arg2, arg3)
}

// AttributeDisconnect disconnects @attribute for the @renderer in @area so
// that attribute will no longer be updated with values from the model.
func (area cellArea) AttributeDisconnect(renderer CellRenderer, attribute string) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer
	var arg2 *C.gchar

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellRenderer)(renderer.Native())
	arg2 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_cell_area_attribute_disconnect(arg0, arg1, arg2)
}

// AttributeGetColumn returns the model column that an attribute has been
// mapped to, or -1 if the attribute is not mapped.
func (area cellArea) AttributeGetColumn(renderer CellRenderer, attribute string) int {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer
	var arg2 *C.gchar

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellRenderer)(renderer.Native())
	arg2 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_cell_area_attribute_get_column(arg0, arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// CellGetProperty gets the value of a cell property for @renderer in @area.
func (area cellArea) CellGetProperty(renderer CellRenderer, propertyName string, value *externglib.Value) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer
	var arg2 *C.gchar
	var arg3 *C.GValue

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellRenderer)(renderer.Native())
	arg2 = (*C.gchar)(C.CString(propertyName))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.GValue)(value.GValue)

	C.gtk_cell_area_cell_get_property(arg0, arg1, arg2, arg3)
}

// CellSetProperty sets a cell property for @renderer in @area.
func (area cellArea) CellSetProperty(renderer CellRenderer, propertyName string, value *externglib.Value) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer
	var arg2 *C.gchar
	var arg3 *C.GValue

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellRenderer)(renderer.Native())
	arg2 = (*C.gchar)(C.CString(propertyName))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.GValue)(value.GValue)

	C.gtk_cell_area_cell_set_property(arg0, arg1, arg2, arg3)
}

// CopyContext: this is sometimes needed for cases where rows need to share
// alignments in one orientation but may be separately grouped in the
// opposing orientation.
//
// For instance, IconView creates all icons (rows) to have the same width
// and the cells theirin to have the same horizontal alignments. However
// each row of icons may have a separate collective height. IconView uses
// this to request the heights of each row based on a context which was
// already used to request all the row widths that are to be displayed.
func (area cellArea) CopyContext(context CellAreaContext) CellAreaContext {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellAreaContext

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellAreaContext)(context.Native())

	ret := C.gtk_cell_area_copy_context(arg0, arg1)

	var ret0 CellAreaContext

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(CellAreaContext)

	return ret0
}

// CreateContext creates a CellAreaContext to be used with @area for all
// purposes. CellAreaContext stores geometry information for rows for which
// it was operated on, it is important to use the same context for the same
// row of data at all times (i.e. one should render and handle events with
// the same CellAreaContext which was used to request the size of those rows
// of data).
func (area cellArea) CreateContext() CellAreaContext {
	var arg0 *C.GtkCellArea

	arg0 = (*C.GtkCellArea)(area.Native())

	ret := C.gtk_cell_area_create_context(arg0)

	var ret0 CellAreaContext

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(CellAreaContext)

	return ret0
}

// Focus: this should be called by the @area’s owning layout widget when
// focus is to be passed to @area, or moved within @area for a given
// @direction and row data.
//
// Implementing CellArea classes should implement this method to receive and
// navigate focus in its own way particular to how it lays out cells.
func (area cellArea) Focus(direction DirectionType) bool {
	var arg0 *C.GtkCellArea
	var arg1 C.GtkDirectionType

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (C.GtkDirectionType)(direction)

	ret := C.gtk_cell_area_focus(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Foreach calls @callback for every CellRenderer in @area.
func (area cellArea) Foreach(callback CellCallback) {
	var arg0 *C.GtkCellArea
	var arg1 C.GtkCellCallback
	var arg2 C.gpointer

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*[0]byte)(C.gotk4_CellCallback)
	arg2 = C.gpointer(box.Assign(callback))

	C.gtk_cell_area_foreach(arg0, arg1, arg2)
}

// ForeachAlloc calls @callback for every CellRenderer in @area with the
// allocated rectangle inside @cell_area.
func (area cellArea) ForeachAlloc(context CellAreaContext, widget Widget, cellArea *gdk.Rectangle, backgroundArea *gdk.Rectangle, callback CellAllocCallback) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellAreaContext
	var arg2 *C.GtkWidget
	var arg3 *C.GdkRectangle
	var arg4 *C.GdkRectangle
	var arg5 C.GtkCellAllocCallback
	var arg6 C.gpointer

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellAreaContext)(context.Native())
	arg2 = (*C.GtkWidget)(widget.Native())
	arg3 = (*C.GdkRectangle)(cellArea.Native())
	arg4 = (*C.GdkRectangle)(backgroundArea.Native())
	arg5 = (*[0]byte)(C.gotk4_CellAllocCallback)
	arg6 = C.gpointer(box.Assign(callback))

	C.gtk_cell_area_foreach_alloc(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
}

// CellAllocation derives the allocation of @renderer inside @area if @area
// were to be renderered in @cell_area.
func (area cellArea) CellAllocation(context CellAreaContext, widget Widget, renderer CellRenderer, cellArea *gdk.Rectangle) gdk.Rectangle {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellAreaContext
	var arg2 *C.GtkWidget
	var arg3 *C.GtkCellRenderer
	var arg4 *C.GdkRectangle
	var arg5 *C.GdkRectangle // out

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellAreaContext)(context.Native())
	arg2 = (*C.GtkWidget)(widget.Native())
	arg3 = (*C.GtkCellRenderer)(renderer.Native())
	arg4 = (*C.GdkRectangle)(cellArea.Native())

	C.gtk_cell_area_get_cell_allocation(arg0, arg1, arg2, arg3, arg4, &arg5)

	var ret0 *gdk.Rectangle

	{
		ret0 = gdk.WrapRectangle(unsafe.Pointer(arg5))
	}

	return ret0
}

// CellAtPosition gets the CellRenderer at @x and @y coordinates inside
// @area and optionally returns the full cell allocation for it inside
// @cell_area.
func (area cellArea) CellAtPosition(context CellAreaContext, widget Widget, cellArea *gdk.Rectangle, x int, y int) (allocArea gdk.Rectangle, cellRenderer CellRenderer) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellAreaContext
	var arg2 *C.GtkWidget
	var arg3 *C.GdkRectangle
	var arg4 C.gint
	var arg5 C.gint
	var arg6 *C.GdkRectangle // out

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellAreaContext)(context.Native())
	arg2 = (*C.GtkWidget)(widget.Native())
	arg3 = (*C.GdkRectangle)(cellArea.Native())
	arg4 = C.gint(x)
	arg5 = C.gint(y)

	ret := C.gtk_cell_area_get_cell_at_position(arg0, arg1, arg2, arg3, arg4, arg5, &arg6)

	var ret0 *gdk.Rectangle
	var ret1 CellRenderer

	{
		ret0 = gdk.WrapRectangle(unsafe.Pointer(arg6))
	}

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(CellRenderer)

	return ret0, ret1
}

// CurrentPathString gets the current TreePath string for the currently
// applied TreeIter, this is implicitly updated when
// gtk_cell_area_apply_attributes() is called and can be used to interact
// with renderers from CellArea subclasses.
func (area cellArea) CurrentPathString() string {
	var arg0 *C.GtkCellArea

	arg0 = (*C.GtkCellArea)(area.Native())

	ret := C.gtk_cell_area_get_current_path_string(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// EditWidget gets the CellEditable widget currently used to edit the
// currently edited cell.
func (area cellArea) EditWidget() CellEditable {
	var arg0 *C.GtkCellArea

	arg0 = (*C.GtkCellArea)(area.Native())

	ret := C.gtk_cell_area_get_edit_widget(arg0)

	var ret0 CellEditable

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(CellEditable)

	return ret0
}

// EditedCell gets the CellRenderer in @area that is currently being edited.
func (area cellArea) EditedCell() CellRenderer {
	var arg0 *C.GtkCellArea

	arg0 = (*C.GtkCellArea)(area.Native())

	ret := C.gtk_cell_area_get_edited_cell(arg0)

	var ret0 CellRenderer

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(CellRenderer)

	return ret0
}

// FocusCell retrieves the currently focused cell for @area
func (area cellArea) FocusCell() CellRenderer {
	var arg0 *C.GtkCellArea

	arg0 = (*C.GtkCellArea)(area.Native())

	ret := C.gtk_cell_area_get_focus_cell(arg0)

	var ret0 CellRenderer

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(CellRenderer)

	return ret0
}

// FocusFromSibling gets the CellRenderer which is expected to be focusable
// for which @renderer is, or may be a sibling.
//
// This is handy for CellArea subclasses when handling events, after
// determining the renderer at the event location it can then chose to
// activate the focus cell for which the event cell may have been a sibling.
func (area cellArea) FocusFromSibling(renderer CellRenderer) CellRenderer {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellRenderer)(renderer.Native())

	ret := C.gtk_cell_area_get_focus_from_sibling(arg0, arg1)

	var ret0 CellRenderer

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(CellRenderer)

	return ret0
}

// FocusSiblings gets the focus sibling cell renderers for @renderer.
func (area cellArea) FocusSiblings(renderer CellRenderer) *glib.List {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellRenderer)(renderer.Native())

	ret := C.gtk_cell_area_get_focus_siblings(arg0, arg1)

	var ret0 *glib.List

	{
		ret0 = glib.WrapList(unsafe.Pointer(ret))
	}

	return ret0
}

// PreferredHeight retrieves a cell area’s initial minimum and natural
// height.
//
// @area will store some geometrical information in @context along the way;
// when requesting sizes over an arbitrary number of rows, it’s not
// important to check the @minimum_height and @natural_height of this call
// but rather to consult gtk_cell_area_context_get_preferred_height() after
// a series of requests.
func (area cellArea) PreferredHeight(context CellAreaContext, widget Widget) (minimumHeight int, naturalHeight int) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellAreaContext
	var arg2 *C.GtkWidget
	var arg3 *C.gint // out
	var arg4 *C.gint // out

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellAreaContext)(context.Native())
	arg2 = (*C.GtkWidget)(widget.Native())

	C.gtk_cell_area_get_preferred_height(arg0, arg1, arg2, &arg3, &arg4)

	var ret0 int
	var ret1 int

	ret0 = int(arg3)

	ret1 = int(arg4)

	return ret0, ret1
}

// PreferredHeightForWidth retrieves a cell area’s minimum and natural
// height if it would be given the specified @width.
//
// @area stores some geometrical information in @context along the way while
// calling gtk_cell_area_get_preferred_width(). It’s important to perform a
// series of gtk_cell_area_get_preferred_width() requests with @context
// first and then call gtk_cell_area_get_preferred_height_for_width() on
// each cell area individually to get the height for width of each fully
// requested row.
//
// If at some point, the width of a single row changes, it should be
// requested with gtk_cell_area_get_preferred_width() again and then the
// full width of the requested rows checked again with
// gtk_cell_area_context_get_preferred_width().
func (area cellArea) PreferredHeightForWidth(context CellAreaContext, widget Widget, width int) (minimumHeight int, naturalHeight int) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellAreaContext
	var arg2 *C.GtkWidget
	var arg3 C.gint
	var arg4 *C.gint // out
	var arg5 *C.gint // out

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellAreaContext)(context.Native())
	arg2 = (*C.GtkWidget)(widget.Native())
	arg3 = C.gint(width)

	C.gtk_cell_area_get_preferred_height_for_width(arg0, arg1, arg2, arg3, &arg4, &arg5)

	var ret0 int
	var ret1 int

	ret0 = int(arg4)

	ret1 = int(arg5)

	return ret0, ret1
}

// PreferredWidth retrieves a cell area’s initial minimum and natural width.
//
// @area will store some geometrical information in @context along the way;
// when requesting sizes over an arbitrary number of rows, it’s not
// important to check the @minimum_width and @natural_width of this call but
// rather to consult gtk_cell_area_context_get_preferred_width() after a
// series of requests.
func (area cellArea) PreferredWidth(context CellAreaContext, widget Widget) (minimumWidth int, naturalWidth int) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellAreaContext
	var arg2 *C.GtkWidget
	var arg3 *C.gint // out
	var arg4 *C.gint // out

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellAreaContext)(context.Native())
	arg2 = (*C.GtkWidget)(widget.Native())

	C.gtk_cell_area_get_preferred_width(arg0, arg1, arg2, &arg3, &arg4)

	var ret0 int
	var ret1 int

	ret0 = int(arg3)

	ret1 = int(arg4)

	return ret0, ret1
}

// PreferredWidthForHeight retrieves a cell area’s minimum and natural width
// if it would be given the specified @height.
//
// @area stores some geometrical information in @context along the way while
// calling gtk_cell_area_get_preferred_height(). It’s important to perform a
// series of gtk_cell_area_get_preferred_height() requests with @context
// first and then call gtk_cell_area_get_preferred_width_for_height() on
// each cell area individually to get the height for width of each fully
// requested row.
//
// If at some point, the height of a single row changes, it should be
// requested with gtk_cell_area_get_preferred_height() again and then the
// full height of the requested rows checked again with
// gtk_cell_area_context_get_preferred_height().
func (area cellArea) PreferredWidthForHeight(context CellAreaContext, widget Widget, height int) (minimumWidth int, naturalWidth int) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellAreaContext
	var arg2 *C.GtkWidget
	var arg3 C.gint
	var arg4 *C.gint // out
	var arg5 *C.gint // out

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellAreaContext)(context.Native())
	arg2 = (*C.GtkWidget)(widget.Native())
	arg3 = C.gint(height)

	C.gtk_cell_area_get_preferred_width_for_height(arg0, arg1, arg2, arg3, &arg4, &arg5)

	var ret0 int
	var ret1 int

	ret0 = int(arg4)

	ret1 = int(arg5)

	return ret0, ret1
}

// RequestMode gets whether the area prefers a height-for-width layout or a
// width-for-height layout.
func (area cellArea) RequestMode() SizeRequestMode {
	var arg0 *C.GtkCellArea

	arg0 = (*C.GtkCellArea)(area.Native())

	ret := C.gtk_cell_area_get_request_mode(arg0)

	var ret0 SizeRequestMode

	ret0 = SizeRequestMode(ret)

	return ret0
}

// HasRenderer checks if @area contains @renderer.
func (area cellArea) HasRenderer(renderer CellRenderer) bool {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellRenderer)(renderer.Native())

	ret := C.gtk_cell_area_has_renderer(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// InnerCellArea: this is a convenience function for CellArea
// implementations to get the inner area where a given CellRenderer will be
// rendered. It removes any padding previously added by
// gtk_cell_area_request_renderer().
func (area cellArea) InnerCellArea(widget Widget, cellArea *gdk.Rectangle) gdk.Rectangle {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkWidget
	var arg2 *C.GdkRectangle
	var arg3 *C.GdkRectangle // out

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = (*C.GdkRectangle)(cellArea.Native())

	C.gtk_cell_area_inner_cell_area(arg0, arg1, arg2, &arg3)

	var ret0 *gdk.Rectangle

	{
		ret0 = gdk.WrapRectangle(unsafe.Pointer(arg3))
	}

	return ret0
}

// IsActivatable returns whether the area can do anything when activated,
// after applying new attributes to @area.
func (area cellArea) IsActivatable() bool {
	var arg0 *C.GtkCellArea

	arg0 = (*C.GtkCellArea)(area.Native())

	ret := C.gtk_cell_area_is_activatable(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IsFocusSibling returns whether @sibling is one of @renderer’s focus
// siblings (see gtk_cell_area_add_focus_sibling()).
func (area cellArea) IsFocusSibling(renderer CellRenderer, sibling CellRenderer) bool {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer
	var arg2 *C.GtkCellRenderer

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellRenderer)(renderer.Native())
	arg2 = (*C.GtkCellRenderer)(sibling.Native())

	ret := C.gtk_cell_area_is_focus_sibling(arg0, arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Remove removes @renderer from @area.
func (area cellArea) Remove(renderer CellRenderer) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellRenderer)(renderer.Native())

	C.gtk_cell_area_remove(arg0, arg1)
}

// RemoveFocusSibling removes @sibling from @renderer’s focus sibling list
// (see gtk_cell_area_add_focus_sibling()).
func (area cellArea) RemoveFocusSibling(renderer CellRenderer, sibling CellRenderer) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer
	var arg2 *C.GtkCellRenderer

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellRenderer)(renderer.Native())
	arg2 = (*C.GtkCellRenderer)(sibling.Native())

	C.gtk_cell_area_remove_focus_sibling(arg0, arg1, arg2)
}

// Render renders @area’s cells according to @area’s layout onto @widget at
// the given coordinates.
func (area cellArea) Render(context CellAreaContext, widget Widget, cr *cairo.Context, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState, paintFocus bool) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellAreaContext
	var arg2 *C.GtkWidget
	var arg3 *C.cairo_t
	var arg4 *C.GdkRectangle
	var arg5 *C.GdkRectangle
	var arg6 C.GtkCellRendererState
	var arg7 C.gboolean

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellAreaContext)(context.Native())
	arg2 = (*C.GtkWidget)(widget.Native())
	arg3 = (*C.cairo_t)(cr.Native())
	arg4 = (*C.GdkRectangle)(backgroundArea.Native())
	arg5 = (*C.GdkRectangle)(cellArea.Native())
	arg6 = (C.GtkCellRendererState)(flags)
	if paintFocus {
		arg7 = C.TRUE
	}

	C.gtk_cell_area_render(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
}

// RequestRenderer: this is a convenience function for CellArea
// implementations to request size for cell renderers. It’s important to use
// this function to request size and then use
// gtk_cell_area_inner_cell_area() at render and event time since this
// function will add padding around the cell for focus painting.
func (area cellArea) RequestRenderer(renderer CellRenderer, orientation Orientation, widget Widget, forSize int) (minimumSize int, naturalSize int) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer
	var arg2 C.GtkOrientation
	var arg3 *C.GtkWidget
	var arg4 C.gint
	var arg5 *C.gint // out
	var arg6 *C.gint // out

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellRenderer)(renderer.Native())
	arg2 = (C.GtkOrientation)(orientation)
	arg3 = (*C.GtkWidget)(widget.Native())
	arg4 = C.gint(forSize)

	C.gtk_cell_area_request_renderer(arg0, arg1, arg2, arg3, arg4, &arg5, &arg6)

	var ret0 int
	var ret1 int

	ret0 = int(arg5)

	ret1 = int(arg6)

	return ret0, ret1
}

// SetFocusCell: explicitly sets the currently focused cell to @renderer.
//
// This is generally called by implementations of CellAreaClass.focus() or
// CellAreaClass.event(), however it can also be used to implement functions
// such as gtk_tree_view_set_cursor_on_cell().
func (area cellArea) SetFocusCell(renderer CellRenderer) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellRenderer)(renderer.Native())

	C.gtk_cell_area_set_focus_cell(arg0, arg1)
}

// StopEditing: explicitly stops the editing of the currently edited cell.
//
// If @canceled is true, the currently edited cell renderer will emit the
// ::editing-canceled signal, otherwise the the ::editing-done signal will
// be emitted on the current edit widget.
//
// See gtk_cell_area_get_edited_cell() and gtk_cell_area_get_edit_widget().
func (area cellArea) StopEditing(canceled bool) {
	var arg0 *C.GtkCellArea
	var arg1 C.gboolean

	arg0 = (*C.GtkCellArea)(area.Native())
	if canceled {
		arg1 = C.TRUE
	}

	C.gtk_cell_area_stop_editing(arg0, arg1)
}

// CellAreaBox: the CellAreaBox renders cell renderers into a row or a column
// depending on its Orientation.
//
// GtkCellAreaBox uses a notion of packing. Packing refers to adding cell
// renderers with reference to a particular position in a CellAreaBox. There are
// two reference positions: the start and the end of the box. When the
// CellAreaBox is oriented in the GTK_ORIENTATION_VERTICAL orientation, the
// start is defined as the top of the box and the end is defined as the bottom.
// In the GTK_ORIENTATION_HORIZONTAL orientation start is defined as the left
// side and the end is defined as the right side.
//
// Alignments of CellRenderers rendered in adjacent rows can be configured by
// configuring the CellAreaBox align child cell property with
// gtk_cell_area_cell_set_property() or by specifying the "align" argument to
// gtk_cell_area_box_pack_start() and gtk_cell_area_box_pack_end().
type CellAreaBox interface {
	CellArea
	Buildable
	CellLayout
	Orientable

	// Spacing gets the spacing added between cell renderers.
	Spacing() int
	// PackEnd adds @renderer to @box, packed with reference to the end of @box.
	//
	// The @renderer is packed after (away from end of) any other CellRenderer
	// packed with reference to the end of @box.
	PackEnd(renderer CellRenderer, expand bool, align bool, fixed bool)
	// PackStart adds @renderer to @box, packed with reference to the start of
	// @box.
	//
	// The @renderer is packed after any other CellRenderer packed with
	// reference to the start of @box.
	PackStart(renderer CellRenderer, expand bool, align bool, fixed bool)
	// SetSpacing sets the spacing to add between cell renderers in @box.
	SetSpacing(spacing int)
}

// cellAreaBox implements the CellAreaBox interface.
type cellAreaBox struct {
	CellArea
	Buildable
	CellLayout
	Orientable
}

var _ CellAreaBox = (*cellAreaBox)(nil)

// WrapCellAreaBox wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellAreaBox(obj *externglib.Object) CellAreaBox {
	return CellAreaBox{
		CellArea:   WrapCellArea(obj),
		Buildable:  WrapBuildable(obj),
		CellLayout: WrapCellLayout(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalCellAreaBox(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellAreaBox(obj), nil
}

// NewCellAreaBox constructs a class CellAreaBox.
func NewCellAreaBox() CellAreaBox {

	ret := C.gtk_cell_area_box_new()

	var ret0 CellAreaBox

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(CellAreaBox)

	return ret0
}

// Spacing gets the spacing added between cell renderers.
func (box cellAreaBox) Spacing() int {
	var arg0 *C.GtkCellAreaBox

	arg0 = (*C.GtkCellAreaBox)(box.Native())

	ret := C.gtk_cell_area_box_get_spacing(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// PackEnd adds @renderer to @box, packed with reference to the end of @box.
//
// The @renderer is packed after (away from end of) any other CellRenderer
// packed with reference to the end of @box.
func (box cellAreaBox) PackEnd(renderer CellRenderer, expand bool, align bool, fixed bool) {
	var arg0 *C.GtkCellAreaBox
	var arg1 *C.GtkCellRenderer
	var arg2 C.gboolean
	var arg3 C.gboolean
	var arg4 C.gboolean

	arg0 = (*C.GtkCellAreaBox)(box.Native())
	arg1 = (*C.GtkCellRenderer)(renderer.Native())
	if expand {
		arg2 = C.TRUE
	}
	if align {
		arg3 = C.TRUE
	}
	if fixed {
		arg4 = C.TRUE
	}

	C.gtk_cell_area_box_pack_end(arg0, arg1, arg2, arg3, arg4)
}

// PackStart adds @renderer to @box, packed with reference to the start of
// @box.
//
// The @renderer is packed after any other CellRenderer packed with
// reference to the start of @box.
func (box cellAreaBox) PackStart(renderer CellRenderer, expand bool, align bool, fixed bool) {
	var arg0 *C.GtkCellAreaBox
	var arg1 *C.GtkCellRenderer
	var arg2 C.gboolean
	var arg3 C.gboolean
	var arg4 C.gboolean

	arg0 = (*C.GtkCellAreaBox)(box.Native())
	arg1 = (*C.GtkCellRenderer)(renderer.Native())
	if expand {
		arg2 = C.TRUE
	}
	if align {
		arg3 = C.TRUE
	}
	if fixed {
		arg4 = C.TRUE
	}

	C.gtk_cell_area_box_pack_start(arg0, arg1, arg2, arg3, arg4)
}

// SetSpacing sets the spacing to add between cell renderers in @box.
func (box cellAreaBox) SetSpacing(spacing int) {
	var arg0 *C.GtkCellAreaBox
	var arg1 C.gint

	arg0 = (*C.GtkCellAreaBox)(box.Native())
	arg1 = C.gint(spacing)

	C.gtk_cell_area_box_set_spacing(arg0, arg1)
}

// CellAreaContext: the CellAreaContext object is created by a given CellArea
// implementation via its CellAreaClass.create_context() virtual method and is
// used to store cell sizes and alignments for a series of TreeModel rows that
// are requested and rendered in the same context.
//
// CellLayout widgets can create any number of contexts in which to request and
// render groups of data rows. However, it’s important that the same context
// which was used to request sizes for a given TreeModel row also be used for
// the same row when calling other CellArea APIs such as gtk_cell_area_render()
// and gtk_cell_area_event().
type CellAreaContext interface {
	gextras.Objector

	// Allocate allocates a width and/or a height for all rows which are to be
	// rendered with @context.
	//
	// Usually allocation is performed only horizontally or sometimes vertically
	// since a group of rows are usually rendered side by side vertically or
	// horizontally and share either the same width or the same height.
	// Sometimes they are allocated in both horizontal and vertical orientations
	// producing a homogeneous effect of the rows. This is generally the case
	// for TreeView when TreeView:fixed-height-mode is enabled.
	//
	// Since 3.0
	Allocate(width int, height int)
	// Allocation fetches the current allocation size for @context.
	//
	// If the context was not allocated in width or height, or if the context
	// was recently reset with gtk_cell_area_context_reset(), the returned value
	// will be -1.
	Allocation() (width int, height int)
	// Area fetches the CellArea this @context was created by.
	//
	// This is generally unneeded by layouting widgets; however, it is important
	// for the context implementation itself to fetch information about the area
	// it is being used for.
	//
	// For instance at CellAreaContextClass.allocate() time it’s important to
	// know details about any cell spacing that the CellArea is configured with
	// in order to compute a proper allocation.
	Area() CellArea
	// PreferredHeight gets the accumulative preferred height for all rows which
	// have been requested with this context.
	//
	// After gtk_cell_area_context_reset() is called and/or before ever
	// requesting the size of a CellArea, the returned values are 0.
	PreferredHeight() (minimumHeight int, naturalHeight int)
	// PreferredHeightForWidth gets the accumulative preferred height for @width
	// for all rows which have been requested for the same said @width with this
	// context.
	//
	// After gtk_cell_area_context_reset() is called and/or before ever
	// requesting the size of a CellArea, the returned values are -1.
	PreferredHeightForWidth(width int) (minimumHeight int, naturalHeight int)
	// PreferredWidth gets the accumulative preferred width for all rows which
	// have been requested with this context.
	//
	// After gtk_cell_area_context_reset() is called and/or before ever
	// requesting the size of a CellArea, the returned values are 0.
	PreferredWidth() (minimumWidth int, naturalWidth int)
	// PreferredWidthForHeight gets the accumulative preferred width for @height
	// for all rows which have been requested for the same said @height with
	// this context.
	//
	// After gtk_cell_area_context_reset() is called and/or before ever
	// requesting the size of a CellArea, the returned values are -1.
	PreferredWidthForHeight(height int) (minimumWidth int, naturalWidth int)
	// PushPreferredHeight causes the minimum and/or natural height to grow if
	// the new proposed sizes exceed the current minimum and natural height.
	//
	// This is used by CellAreaContext implementations during the request
	// process over a series of TreeModel rows to progressively push the
	// requested height over a series of gtk_cell_area_get_preferred_height()
	// requests.
	PushPreferredHeight(minimumHeight int, naturalHeight int)
	// PushPreferredWidth causes the minimum and/or natural width to grow if the
	// new proposed sizes exceed the current minimum and natural width.
	//
	// This is used by CellAreaContext implementations during the request
	// process over a series of TreeModel rows to progressively push the
	// requested width over a series of gtk_cell_area_get_preferred_width()
	// requests.
	PushPreferredWidth(minimumWidth int, naturalWidth int)
	// Reset resets any previously cached request and allocation data.
	//
	// When underlying TreeModel data changes its important to reset the context
	// if the content size is allowed to shrink. If the content size is only
	// allowed to grow (this is usually an option for views rendering large data
	// stores as a measure of optimization), then only the row that changed or
	// was inserted needs to be (re)requested with
	// gtk_cell_area_get_preferred_width().
	//
	// When the new overall size of the context requires that the allocated size
	// changes (or whenever this allocation changes at all), the variable row
	// sizes need to be re-requested for every row.
	//
	// For instance, if the rows are displayed all with the same width from top
	// to bottom then a change in the allocated width necessitates a
	// recalculation of all the displayed row heights using
	// gtk_cell_area_get_preferred_height_for_width().
	//
	// Since 3.0
	Reset()
}

// cellAreaContext implements the CellAreaContext interface.
type cellAreaContext struct {
	gextras.Objector
}

var _ CellAreaContext = (*cellAreaContext)(nil)

// WrapCellAreaContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellAreaContext(obj *externglib.Object) CellAreaContext {
	return CellAreaContext{
		Objector: obj,
	}
}

func marshalCellAreaContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellAreaContext(obj), nil
}

// Allocate allocates a width and/or a height for all rows which are to be
// rendered with @context.
//
// Usually allocation is performed only horizontally or sometimes vertically
// since a group of rows are usually rendered side by side vertically or
// horizontally and share either the same width or the same height.
// Sometimes they are allocated in both horizontal and vertical orientations
// producing a homogeneous effect of the rows. This is generally the case
// for TreeView when TreeView:fixed-height-mode is enabled.
//
// Since 3.0
func (context cellAreaContext) Allocate(width int, height int) {
	var arg0 *C.GtkCellAreaContext
	var arg1 C.gint
	var arg2 C.gint

	arg0 = (*C.GtkCellAreaContext)(context.Native())
	arg1 = C.gint(width)
	arg2 = C.gint(height)

	C.gtk_cell_area_context_allocate(arg0, arg1, arg2)
}

// Allocation fetches the current allocation size for @context.
//
// If the context was not allocated in width or height, or if the context
// was recently reset with gtk_cell_area_context_reset(), the returned value
// will be -1.
func (context cellAreaContext) Allocation() (width int, height int) {
	var arg0 *C.GtkCellAreaContext
	var arg1 *C.gint // out
	var arg2 *C.gint // out

	arg0 = (*C.GtkCellAreaContext)(context.Native())

	C.gtk_cell_area_context_get_allocation(arg0, &arg1, &arg2)

	var ret0 int
	var ret1 int

	ret0 = int(arg1)

	ret1 = int(arg2)

	return ret0, ret1
}

// Area fetches the CellArea this @context was created by.
//
// This is generally unneeded by layouting widgets; however, it is important
// for the context implementation itself to fetch information about the area
// it is being used for.
//
// For instance at CellAreaContextClass.allocate() time it’s important to
// know details about any cell spacing that the CellArea is configured with
// in order to compute a proper allocation.
func (context cellAreaContext) Area() CellArea {
	var arg0 *C.GtkCellAreaContext

	arg0 = (*C.GtkCellAreaContext)(context.Native())

	ret := C.gtk_cell_area_context_get_area(arg0)

	var ret0 CellArea

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(CellArea)

	return ret0
}

// PreferredHeight gets the accumulative preferred height for all rows which
// have been requested with this context.
//
// After gtk_cell_area_context_reset() is called and/or before ever
// requesting the size of a CellArea, the returned values are 0.
func (context cellAreaContext) PreferredHeight() (minimumHeight int, naturalHeight int) {
	var arg0 *C.GtkCellAreaContext
	var arg1 *C.gint // out
	var arg2 *C.gint // out

	arg0 = (*C.GtkCellAreaContext)(context.Native())

	C.gtk_cell_area_context_get_preferred_height(arg0, &arg1, &arg2)

	var ret0 int
	var ret1 int

	ret0 = int(arg1)

	ret1 = int(arg2)

	return ret0, ret1
}

// PreferredHeightForWidth gets the accumulative preferred height for @width
// for all rows which have been requested for the same said @width with this
// context.
//
// After gtk_cell_area_context_reset() is called and/or before ever
// requesting the size of a CellArea, the returned values are -1.
func (context cellAreaContext) PreferredHeightForWidth(width int) (minimumHeight int, naturalHeight int) {
	var arg0 *C.GtkCellAreaContext
	var arg1 C.gint
	var arg2 *C.gint // out
	var arg3 *C.gint // out

	arg0 = (*C.GtkCellAreaContext)(context.Native())
	arg1 = C.gint(width)

	C.gtk_cell_area_context_get_preferred_height_for_width(arg0, arg1, &arg2, &arg3)

	var ret0 int
	var ret1 int

	ret0 = int(arg2)

	ret1 = int(arg3)

	return ret0, ret1
}

// PreferredWidth gets the accumulative preferred width for all rows which
// have been requested with this context.
//
// After gtk_cell_area_context_reset() is called and/or before ever
// requesting the size of a CellArea, the returned values are 0.
func (context cellAreaContext) PreferredWidth() (minimumWidth int, naturalWidth int) {
	var arg0 *C.GtkCellAreaContext
	var arg1 *C.gint // out
	var arg2 *C.gint // out

	arg0 = (*C.GtkCellAreaContext)(context.Native())

	C.gtk_cell_area_context_get_preferred_width(arg0, &arg1, &arg2)

	var ret0 int
	var ret1 int

	ret0 = int(arg1)

	ret1 = int(arg2)

	return ret0, ret1
}

// PreferredWidthForHeight gets the accumulative preferred width for @height
// for all rows which have been requested for the same said @height with
// this context.
//
// After gtk_cell_area_context_reset() is called and/or before ever
// requesting the size of a CellArea, the returned values are -1.
func (context cellAreaContext) PreferredWidthForHeight(height int) (minimumWidth int, naturalWidth int) {
	var arg0 *C.GtkCellAreaContext
	var arg1 C.gint
	var arg2 *C.gint // out
	var arg3 *C.gint // out

	arg0 = (*C.GtkCellAreaContext)(context.Native())
	arg1 = C.gint(height)

	C.gtk_cell_area_context_get_preferred_width_for_height(arg0, arg1, &arg2, &arg3)

	var ret0 int
	var ret1 int

	ret0 = int(arg2)

	ret1 = int(arg3)

	return ret0, ret1
}

// PushPreferredHeight causes the minimum and/or natural height to grow if
// the new proposed sizes exceed the current minimum and natural height.
//
// This is used by CellAreaContext implementations during the request
// process over a series of TreeModel rows to progressively push the
// requested height over a series of gtk_cell_area_get_preferred_height()
// requests.
func (context cellAreaContext) PushPreferredHeight(minimumHeight int, naturalHeight int) {
	var arg0 *C.GtkCellAreaContext
	var arg1 C.gint
	var arg2 C.gint

	arg0 = (*C.GtkCellAreaContext)(context.Native())
	arg1 = C.gint(minimumHeight)
	arg2 = C.gint(naturalHeight)

	C.gtk_cell_area_context_push_preferred_height(arg0, arg1, arg2)
}

// PushPreferredWidth causes the minimum and/or natural width to grow if the
// new proposed sizes exceed the current minimum and natural width.
//
// This is used by CellAreaContext implementations during the request
// process over a series of TreeModel rows to progressively push the
// requested width over a series of gtk_cell_area_get_preferred_width()
// requests.
func (context cellAreaContext) PushPreferredWidth(minimumWidth int, naturalWidth int) {
	var arg0 *C.GtkCellAreaContext
	var arg1 C.gint
	var arg2 C.gint

	arg0 = (*C.GtkCellAreaContext)(context.Native())
	arg1 = C.gint(minimumWidth)
	arg2 = C.gint(naturalWidth)

	C.gtk_cell_area_context_push_preferred_width(arg0, arg1, arg2)
}

// Reset resets any previously cached request and allocation data.
//
// When underlying TreeModel data changes its important to reset the context
// if the content size is allowed to shrink. If the content size is only
// allowed to grow (this is usually an option for views rendering large data
// stores as a measure of optimization), then only the row that changed or
// was inserted needs to be (re)requested with
// gtk_cell_area_get_preferred_width().
//
// When the new overall size of the context requires that the allocated size
// changes (or whenever this allocation changes at all), the variable row
// sizes need to be re-requested for every row.
//
// For instance, if the rows are displayed all with the same width from top
// to bottom then a change in the allocated width necessitates a
// recalculation of all the displayed row heights using
// gtk_cell_area_get_preferred_height_for_width().
//
// Since 3.0
func (context cellAreaContext) Reset() {
	var arg0 *C.GtkCellAreaContext

	arg0 = (*C.GtkCellAreaContext)(context.Native())

	C.gtk_cell_area_context_reset(arg0)
}

// CellRenderer: the CellRenderer is a base class of a set of objects used for
// rendering a cell to a #cairo_t. These objects are used primarily by the
// TreeView widget, though they aren’t tied to them in any specific way. It is
// worth noting that CellRenderer is not a Widget and cannot be treated as such.
//
// The primary use of a CellRenderer is for drawing a certain graphical elements
// on a #cairo_t. Typically, one cell renderer is used to draw many cells on the
// screen. To this extent, it isn’t expected that a CellRenderer keep any
// permanent state around. Instead, any state is set just prior to use using
// #GObjects property system. Then, the cell is measured using
// gtk_cell_renderer_get_size(). Finally, the cell is rendered in the correct
// location using gtk_cell_renderer_render().
//
// There are a number of rules that must be followed when writing a new
// CellRenderer. First and foremost, it’s important that a certain set of
// properties will always yield a cell renderer of the same size, barring a
// Style change. The CellRenderer also has a number of generic properties that
// are expected to be honored by all children.
//
// Beyond merely rendering a cell, cell renderers can optionally provide active
// user interface elements. A cell renderer can be “activatable” like
// CellRendererToggle, which toggles when it gets activated by a mouse click, or
// it can be “editable” like CellRendererText, which allows the user to edit the
// text using a widget implementing the CellEditable interface, e.g. Entry. To
// make a cell renderer activatable or editable, you have to implement the
// CellRendererClass.activate or CellRendererClass.start_editing virtual
// functions, respectively.
//
// Many properties of CellRenderer and its subclasses have a corresponding “set”
// property, e.g. “cell-background-set” corresponds to “cell-background”. These
// “set” properties reflect whether a property has been set or not. You should
// not set them independently.
type CellRenderer interface {
	gextras.Objector

	// AlignedArea gets the aligned area used by @cell inside @cell_area. Used
	// for finding the appropriate edit and focus rectangle.
	AlignedArea(widget Widget, flags CellRendererState, cellArea *gdk.Rectangle) gdk.Rectangle
	// Alignment fills in @xalign and @yalign with the appropriate values of
	// @cell.
	Alignment() (xalign float32, yalign float32)
	// FixedSize fills in @width and @height with the appropriate size of @cell.
	FixedSize() (width int, height int)
	// Padding fills in @xpad and @ypad with the appropriate values of @cell.
	Padding() (xpad int, ypad int)
	// PreferredHeight retreives a renderer’s natural size when rendered to
	// @widget.
	PreferredHeight(widget Widget) (minimumSize int, naturalSize int)
	// PreferredHeightForWidth retreives a cell renderers’s minimum and natural
	// height if it were rendered to @widget with the specified @width.
	PreferredHeightForWidth(widget Widget, width int) (minimumHeight int, naturalHeight int)
	// PreferredSize retrieves the minimum and natural size of a cell taking
	// into account the widget’s preference for height-for-width management.
	PreferredSize(widget Widget) (minimumSize Requisition, naturalSize Requisition)
	// PreferredWidth retreives a renderer’s natural size when rendered to
	// @widget.
	PreferredWidth(widget Widget) (minimumSize int, naturalSize int)
	// PreferredWidthForHeight retreives a cell renderers’s minimum and natural
	// width if it were rendered to @widget with the specified @height.
	PreferredWidthForHeight(widget Widget, height int) (minimumWidth int, naturalWidth int)
	// RequestMode gets whether the cell renderer prefers a height-for-width
	// layout or a width-for-height layout.
	RequestMode() SizeRequestMode
	// Sensitive returns the cell renderer’s sensitivity.
	Sensitive() bool
	// Size obtains the width and height needed to render the cell. Used by view
	// widgets to determine the appropriate size for the cell_area passed to
	// gtk_cell_renderer_render(). If @cell_area is not nil, fills in the x and
	// y offsets (if set) of the cell relative to this location.
	//
	// Please note that the values set in @width and @height, as well as those
	// in @x_offset and @y_offset are inclusive of the xpad and ypad properties.
	Size(widget Widget, cellArea *gdk.Rectangle) (xOffset int, yOffset int, width int, height int)
	// State translates the cell renderer state to StateFlags, based on the cell
	// renderer and widget sensitivity, and the given CellRendererState.
	State(widget Widget, cellState CellRendererState) StateFlags
	// Visible returns the cell renderer’s visibility.
	Visible() bool
	// IsActivatable checks whether the cell renderer can do something when
	// activated.
	IsActivatable() bool
	// Render invokes the virtual render function of the CellRenderer. The three
	// passed-in rectangles are areas in @cr. Most renderers will draw within
	// @cell_area; the xalign, yalign, xpad, and ypad fields of the CellRenderer
	// should be honored with respect to @cell_area. @background_area includes
	// the blank space around the cell, and also the area containing the tree
	// expander; so the @background_area rectangles for all cells tile to cover
	// the entire @window.
	Render(cr *cairo.Context, widget Widget, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState)
	// SetAlignment sets the renderer’s alignment within its available space.
	SetAlignment(xalign float32, yalign float32)
	// SetFixedSize sets the renderer size to be explicit, independent of the
	// properties set.
	SetFixedSize(width int, height int)
	// SetPadding sets the renderer’s padding.
	SetPadding(xpad int, ypad int)
	// SetSensitive sets the cell renderer’s sensitivity.
	SetSensitive(sensitive bool)
	// SetVisible sets the cell renderer’s visibility.
	SetVisible(visible bool)
	// StartEditing starts editing the contents of this @cell, through a new
	// CellEditable widget created by the CellRendererClass.start_editing
	// virtual function.
	StartEditing(event *gdk.Event, widget Widget, path string, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState) CellEditable
	// StopEditing informs the cell renderer that the editing is stopped. If
	// @canceled is true, the cell renderer will emit the
	// CellRenderer::editing-canceled signal.
	//
	// This function should be called by cell renderer implementations in
	// response to the CellEditable::editing-done signal of CellEditable.
	StopEditing(canceled bool)
}

// cellRenderer implements the CellRenderer interface.
type cellRenderer struct {
	gextras.Objector
}

var _ CellRenderer = (*cellRenderer)(nil)

// WrapCellRenderer wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRenderer(obj *externglib.Object) CellRenderer {
	return CellRenderer{
		Objector: obj,
	}
}

func marshalCellRenderer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRenderer(obj), nil
}

// AlignedArea gets the aligned area used by @cell inside @cell_area. Used
// for finding the appropriate edit and focus rectangle.
func (cell cellRenderer) AlignedArea(widget Widget, flags CellRendererState, cellArea *gdk.Rectangle) gdk.Rectangle {
	var arg0 *C.GtkCellRenderer
	var arg1 *C.GtkWidget
	var arg2 C.GtkCellRendererState
	var arg3 *C.GdkRectangle
	var arg4 *C.GdkRectangle // out

	arg0 = (*C.GtkCellRenderer)(cell.Native())
	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = (C.GtkCellRendererState)(flags)
	arg3 = (*C.GdkRectangle)(cellArea.Native())

	C.gtk_cell_renderer_get_aligned_area(arg0, arg1, arg2, arg3, &arg4)

	var ret0 *gdk.Rectangle

	{
		ret0 = gdk.WrapRectangle(unsafe.Pointer(arg4))
	}

	return ret0
}

// Alignment fills in @xalign and @yalign with the appropriate values of
// @cell.
func (cell cellRenderer) Alignment() (xalign float32, yalign float32) {
	var arg0 *C.GtkCellRenderer
	var arg1 *C.gfloat // out
	var arg2 *C.gfloat // out

	arg0 = (*C.GtkCellRenderer)(cell.Native())

	C.gtk_cell_renderer_get_alignment(arg0, &arg1, &arg2)

	var ret0 float32
	var ret1 float32

	ret0 = float32(arg1)

	ret1 = float32(arg2)

	return ret0, ret1
}

// FixedSize fills in @width and @height with the appropriate size of @cell.
func (cell cellRenderer) FixedSize() (width int, height int) {
	var arg0 *C.GtkCellRenderer
	var arg1 *C.gint // out
	var arg2 *C.gint // out

	arg0 = (*C.GtkCellRenderer)(cell.Native())

	C.gtk_cell_renderer_get_fixed_size(arg0, &arg1, &arg2)

	var ret0 int
	var ret1 int

	ret0 = int(arg1)

	ret1 = int(arg2)

	return ret0, ret1
}

// Padding fills in @xpad and @ypad with the appropriate values of @cell.
func (cell cellRenderer) Padding() (xpad int, ypad int) {
	var arg0 *C.GtkCellRenderer
	var arg1 *C.gint // out
	var arg2 *C.gint // out

	arg0 = (*C.GtkCellRenderer)(cell.Native())

	C.gtk_cell_renderer_get_padding(arg0, &arg1, &arg2)

	var ret0 int
	var ret1 int

	ret0 = int(arg1)

	ret1 = int(arg2)

	return ret0, ret1
}

// PreferredHeight retreives a renderer’s natural size when rendered to
// @widget.
func (cell cellRenderer) PreferredHeight(widget Widget) (minimumSize int, naturalSize int) {
	var arg0 *C.GtkCellRenderer
	var arg1 *C.GtkWidget
	var arg2 *C.gint // out
	var arg3 *C.gint // out

	arg0 = (*C.GtkCellRenderer)(cell.Native())
	arg1 = (*C.GtkWidget)(widget.Native())

	C.gtk_cell_renderer_get_preferred_height(arg0, arg1, &arg2, &arg3)

	var ret0 int
	var ret1 int

	ret0 = int(arg2)

	ret1 = int(arg3)

	return ret0, ret1
}

// PreferredHeightForWidth retreives a cell renderers’s minimum and natural
// height if it were rendered to @widget with the specified @width.
func (cell cellRenderer) PreferredHeightForWidth(widget Widget, width int) (minimumHeight int, naturalHeight int) {
	var arg0 *C.GtkCellRenderer
	var arg1 *C.GtkWidget
	var arg2 C.gint
	var arg3 *C.gint // out
	var arg4 *C.gint // out

	arg0 = (*C.GtkCellRenderer)(cell.Native())
	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = C.gint(width)

	C.gtk_cell_renderer_get_preferred_height_for_width(arg0, arg1, arg2, &arg3, &arg4)

	var ret0 int
	var ret1 int

	ret0 = int(arg3)

	ret1 = int(arg4)

	return ret0, ret1
}

// PreferredSize retrieves the minimum and natural size of a cell taking
// into account the widget’s preference for height-for-width management.
func (cell cellRenderer) PreferredSize(widget Widget) (minimumSize Requisition, naturalSize Requisition) {
	var arg0 *C.GtkCellRenderer
	var arg1 *C.GtkWidget
	var arg2 *C.GtkRequisition // out
	var arg3 *C.GtkRequisition // out

	arg0 = (*C.GtkCellRenderer)(cell.Native())
	arg1 = (*C.GtkWidget)(widget.Native())

	C.gtk_cell_renderer_get_preferred_size(arg0, arg1, &arg2, &arg3)

	var ret0 *Requisition
	var ret1 *Requisition

	{
		ret0 = WrapRequisition(unsafe.Pointer(arg2))
	}

	{
		ret1 = WrapRequisition(unsafe.Pointer(arg3))
	}

	return ret0, ret1
}

// PreferredWidth retreives a renderer’s natural size when rendered to
// @widget.
func (cell cellRenderer) PreferredWidth(widget Widget) (minimumSize int, naturalSize int) {
	var arg0 *C.GtkCellRenderer
	var arg1 *C.GtkWidget
	var arg2 *C.gint // out
	var arg3 *C.gint // out

	arg0 = (*C.GtkCellRenderer)(cell.Native())
	arg1 = (*C.GtkWidget)(widget.Native())

	C.gtk_cell_renderer_get_preferred_width(arg0, arg1, &arg2, &arg3)

	var ret0 int
	var ret1 int

	ret0 = int(arg2)

	ret1 = int(arg3)

	return ret0, ret1
}

// PreferredWidthForHeight retreives a cell renderers’s minimum and natural
// width if it were rendered to @widget with the specified @height.
func (cell cellRenderer) PreferredWidthForHeight(widget Widget, height int) (minimumWidth int, naturalWidth int) {
	var arg0 *C.GtkCellRenderer
	var arg1 *C.GtkWidget
	var arg2 C.gint
	var arg3 *C.gint // out
	var arg4 *C.gint // out

	arg0 = (*C.GtkCellRenderer)(cell.Native())
	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = C.gint(height)

	C.gtk_cell_renderer_get_preferred_width_for_height(arg0, arg1, arg2, &arg3, &arg4)

	var ret0 int
	var ret1 int

	ret0 = int(arg3)

	ret1 = int(arg4)

	return ret0, ret1
}

// RequestMode gets whether the cell renderer prefers a height-for-width
// layout or a width-for-height layout.
func (cell cellRenderer) RequestMode() SizeRequestMode {
	var arg0 *C.GtkCellRenderer

	arg0 = (*C.GtkCellRenderer)(cell.Native())

	ret := C.gtk_cell_renderer_get_request_mode(arg0)

	var ret0 SizeRequestMode

	ret0 = SizeRequestMode(ret)

	return ret0
}

// Sensitive returns the cell renderer’s sensitivity.
func (cell cellRenderer) Sensitive() bool {
	var arg0 *C.GtkCellRenderer

	arg0 = (*C.GtkCellRenderer)(cell.Native())

	ret := C.gtk_cell_renderer_get_sensitive(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Size obtains the width and height needed to render the cell. Used by view
// widgets to determine the appropriate size for the cell_area passed to
// gtk_cell_renderer_render(). If @cell_area is not nil, fills in the x and
// y offsets (if set) of the cell relative to this location.
//
// Please note that the values set in @width and @height, as well as those
// in @x_offset and @y_offset are inclusive of the xpad and ypad properties.
func (cell cellRenderer) Size(widget Widget, cellArea *gdk.Rectangle) (xOffset int, yOffset int, width int, height int) {
	var arg0 *C.GtkCellRenderer
	var arg1 *C.GtkWidget
	var arg2 *C.GdkRectangle
	var arg3 *C.gint // out
	var arg4 *C.gint // out
	var arg5 *C.gint // out
	var arg6 *C.gint // out

	arg0 = (*C.GtkCellRenderer)(cell.Native())
	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = (*C.GdkRectangle)(cellArea.Native())

	C.gtk_cell_renderer_get_size(arg0, arg1, arg2, &arg3, &arg4, &arg5, &arg6)

	var ret0 int
	var ret1 int
	var ret2 int
	var ret3 int

	ret0 = int(arg3)

	ret1 = int(arg4)

	ret2 = int(arg5)

	ret3 = int(arg6)

	return ret0, ret1, ret2, ret3
}

// State translates the cell renderer state to StateFlags, based on the cell
// renderer and widget sensitivity, and the given CellRendererState.
func (cell cellRenderer) State(widget Widget, cellState CellRendererState) StateFlags {
	var arg0 *C.GtkCellRenderer
	var arg1 *C.GtkWidget
	var arg2 C.GtkCellRendererState

	arg0 = (*C.GtkCellRenderer)(cell.Native())
	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = (C.GtkCellRendererState)(cellState)

	ret := C.gtk_cell_renderer_get_state(arg0, arg1, arg2)

	var ret0 StateFlags

	ret0 = StateFlags(ret)

	return ret0
}

// Visible returns the cell renderer’s visibility.
func (cell cellRenderer) Visible() bool {
	var arg0 *C.GtkCellRenderer

	arg0 = (*C.GtkCellRenderer)(cell.Native())

	ret := C.gtk_cell_renderer_get_visible(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IsActivatable checks whether the cell renderer can do something when
// activated.
func (cell cellRenderer) IsActivatable() bool {
	var arg0 *C.GtkCellRenderer

	arg0 = (*C.GtkCellRenderer)(cell.Native())

	ret := C.gtk_cell_renderer_is_activatable(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Render invokes the virtual render function of the CellRenderer. The three
// passed-in rectangles are areas in @cr. Most renderers will draw within
// @cell_area; the xalign, yalign, xpad, and ypad fields of the CellRenderer
// should be honored with respect to @cell_area. @background_area includes
// the blank space around the cell, and also the area containing the tree
// expander; so the @background_area rectangles for all cells tile to cover
// the entire @window.
func (cell cellRenderer) Render(cr *cairo.Context, widget Widget, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState) {
	var arg0 *C.GtkCellRenderer
	var arg1 *C.cairo_t
	var arg2 *C.GtkWidget
	var arg3 *C.GdkRectangle
	var arg4 *C.GdkRectangle
	var arg5 C.GtkCellRendererState

	arg0 = (*C.GtkCellRenderer)(cell.Native())
	arg1 = (*C.cairo_t)(cr.Native())
	arg2 = (*C.GtkWidget)(widget.Native())
	arg3 = (*C.GdkRectangle)(backgroundArea.Native())
	arg4 = (*C.GdkRectangle)(cellArea.Native())
	arg5 = (C.GtkCellRendererState)(flags)

	C.gtk_cell_renderer_render(arg0, arg1, arg2, arg3, arg4, arg5)
}

// SetAlignment sets the renderer’s alignment within its available space.
func (cell cellRenderer) SetAlignment(xalign float32, yalign float32) {
	var arg0 *C.GtkCellRenderer
	var arg1 C.gfloat
	var arg2 C.gfloat

	arg0 = (*C.GtkCellRenderer)(cell.Native())
	arg1 = C.gfloat(xalign)
	arg2 = C.gfloat(yalign)

	C.gtk_cell_renderer_set_alignment(arg0, arg1, arg2)
}

// SetFixedSize sets the renderer size to be explicit, independent of the
// properties set.
func (cell cellRenderer) SetFixedSize(width int, height int) {
	var arg0 *C.GtkCellRenderer
	var arg1 C.gint
	var arg2 C.gint

	arg0 = (*C.GtkCellRenderer)(cell.Native())
	arg1 = C.gint(width)
	arg2 = C.gint(height)

	C.gtk_cell_renderer_set_fixed_size(arg0, arg1, arg2)
}

// SetPadding sets the renderer’s padding.
func (cell cellRenderer) SetPadding(xpad int, ypad int) {
	var arg0 *C.GtkCellRenderer
	var arg1 C.gint
	var arg2 C.gint

	arg0 = (*C.GtkCellRenderer)(cell.Native())
	arg1 = C.gint(xpad)
	arg2 = C.gint(ypad)

	C.gtk_cell_renderer_set_padding(arg0, arg1, arg2)
}

// SetSensitive sets the cell renderer’s sensitivity.
func (cell cellRenderer) SetSensitive(sensitive bool) {
	var arg0 *C.GtkCellRenderer
	var arg1 C.gboolean

	arg0 = (*C.GtkCellRenderer)(cell.Native())
	if sensitive {
		arg1 = C.TRUE
	}

	C.gtk_cell_renderer_set_sensitive(arg0, arg1)
}

// SetVisible sets the cell renderer’s visibility.
func (cell cellRenderer) SetVisible(visible bool) {
	var arg0 *C.GtkCellRenderer
	var arg1 C.gboolean

	arg0 = (*C.GtkCellRenderer)(cell.Native())
	if visible {
		arg1 = C.TRUE
	}

	C.gtk_cell_renderer_set_visible(arg0, arg1)
}

// StartEditing starts editing the contents of this @cell, through a new
// CellEditable widget created by the CellRendererClass.start_editing
// virtual function.
func (cell cellRenderer) StartEditing(event *gdk.Event, widget Widget, path string, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState) CellEditable {
	var arg0 *C.GtkCellRenderer
	var arg1 *C.GdkEvent
	var arg2 *C.GtkWidget
	var arg3 *C.gchar
	var arg4 *C.GdkRectangle
	var arg5 *C.GdkRectangle
	var arg6 C.GtkCellRendererState

	arg0 = (*C.GtkCellRenderer)(cell.Native())
	arg2 = (*C.GtkWidget)(widget.Native())
	arg3 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.GdkRectangle)(backgroundArea.Native())
	arg5 = (*C.GdkRectangle)(cellArea.Native())
	arg6 = (C.GtkCellRendererState)(flags)

	ret := C.gtk_cell_renderer_start_editing(arg0, arg1, arg2, arg3, arg4, arg5, arg6)

	var ret0 CellEditable

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(CellEditable)

	return ret0
}

// StopEditing informs the cell renderer that the editing is stopped. If
// @canceled is true, the cell renderer will emit the
// CellRenderer::editing-canceled signal.
//
// This function should be called by cell renderer implementations in
// response to the CellEditable::editing-done signal of CellEditable.
func (cell cellRenderer) StopEditing(canceled bool) {
	var arg0 *C.GtkCellRenderer
	var arg1 C.gboolean

	arg0 = (*C.GtkCellRenderer)(cell.Native())
	if canceled {
		arg1 = C.TRUE
	}

	C.gtk_cell_renderer_stop_editing(arg0, arg1)
}

// CellRendererAccel displays a keyboard accelerator (i.e. a key combination
// like `Control + a`). If the cell renderer is editable, the accelerator can be
// changed by simply typing the new combination.
//
// The CellRendererAccel cell renderer was added in GTK+ 2.10.
type CellRendererAccel interface {
	CellRendererText
}

// cellRendererAccel implements the CellRendererAccel interface.
type cellRendererAccel struct {
	CellRendererText
}

var _ CellRendererAccel = (*cellRendererAccel)(nil)

// WrapCellRendererAccel wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererAccel(obj *externglib.Object) CellRendererAccel {
	return CellRendererAccel{
		CellRendererText: WrapCellRendererText(obj),
	}
}

func marshalCellRendererAccel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererAccel(obj), nil
}

// NewCellRendererAccel constructs a class CellRendererAccel.
func NewCellRendererAccel() CellRendererAccel {

	ret := C.gtk_cell_renderer_accel_new()

	var ret0 CellRendererAccel

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(CellRendererAccel)

	return ret0
}

// CellRendererCombo renders text in a cell like CellRendererText from which it
// is derived. But while CellRendererText offers a simple entry to edit the
// text, CellRendererCombo offers a ComboBox widget to edit the text. The values
// to display in the combo box are taken from the tree model specified in the
// CellRendererCombo:model property.
//
// The combo cell renderer takes care of adding a text cell renderer to the
// combo box and sets it to display the column specified by its
// CellRendererCombo:text-column property. Further properties of the combo box
// can be set in a handler for the CellRenderer::editing-started signal.
//
// The CellRendererCombo cell renderer was added in GTK+ 2.6.
type CellRendererCombo interface {
	CellRendererText
}

// cellRendererCombo implements the CellRendererCombo interface.
type cellRendererCombo struct {
	CellRendererText
}

var _ CellRendererCombo = (*cellRendererCombo)(nil)

// WrapCellRendererCombo wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererCombo(obj *externglib.Object) CellRendererCombo {
	return CellRendererCombo{
		CellRendererText: WrapCellRendererText(obj),
	}
}

func marshalCellRendererCombo(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererCombo(obj), nil
}

// NewCellRendererCombo constructs a class CellRendererCombo.
func NewCellRendererCombo() CellRendererCombo {

	ret := C.gtk_cell_renderer_combo_new()

	var ret0 CellRendererCombo

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(CellRendererCombo)

	return ret0
}

// CellRendererPixbuf: a CellRendererPixbuf can be used to render an image in a
// cell. It allows to render either a given Pixbuf (set via the
// CellRendererPixbuf:pixbuf property) or a named icon (set via the
// CellRendererPixbuf:icon-name property).
//
// To support the tree view, CellRendererPixbuf also supports rendering two
// alternative pixbufs, when the CellRenderer:is-expander property is true. If
// the CellRenderer:is-expanded property is true and the
// CellRendererPixbuf:pixbuf-expander-open property is set to a pixbuf, it
// renders that pixbuf, if the CellRenderer:is-expanded property is false and
// the CellRendererPixbuf:pixbuf-expander-closed property is set to a pixbuf, it
// renders that one.
type CellRendererPixbuf interface {
	CellRenderer
}

// cellRendererPixbuf implements the CellRendererPixbuf interface.
type cellRendererPixbuf struct {
	CellRenderer
}

var _ CellRendererPixbuf = (*cellRendererPixbuf)(nil)

// WrapCellRendererPixbuf wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererPixbuf(obj *externglib.Object) CellRendererPixbuf {
	return CellRendererPixbuf{
		CellRenderer: WrapCellRenderer(obj),
	}
}

func marshalCellRendererPixbuf(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererPixbuf(obj), nil
}

// NewCellRendererPixbuf constructs a class CellRendererPixbuf.
func NewCellRendererPixbuf() CellRendererPixbuf {

	ret := C.gtk_cell_renderer_pixbuf_new()

	var ret0 CellRendererPixbuf

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(CellRendererPixbuf)

	return ret0
}

// CellRendererProgress renders a numeric value as a progress par in a cell.
// Additionally, it can display a text on top of the progress bar.
//
// The CellRendererProgress cell renderer was added in GTK+ 2.6.
type CellRendererProgress interface {
	CellRenderer
	Orientable
}

// cellRendererProgress implements the CellRendererProgress interface.
type cellRendererProgress struct {
	CellRenderer
	Orientable
}

var _ CellRendererProgress = (*cellRendererProgress)(nil)

// WrapCellRendererProgress wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererProgress(obj *externglib.Object) CellRendererProgress {
	return CellRendererProgress{
		CellRenderer: WrapCellRenderer(obj),
		Orientable:   WrapOrientable(obj),
	}
}

func marshalCellRendererProgress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererProgress(obj), nil
}

// NewCellRendererProgress constructs a class CellRendererProgress.
func NewCellRendererProgress() CellRendererProgress {

	ret := C.gtk_cell_renderer_progress_new()

	var ret0 CellRendererProgress

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(CellRendererProgress)

	return ret0
}

// CellRendererSpin renders text in a cell like CellRendererText from which it
// is derived. But while CellRendererText offers a simple entry to edit the
// text, CellRendererSpin offers a SpinButton widget. Of course, that means that
// the text has to be parseable as a floating point number.
//
// The range of the spinbutton is taken from the adjustment property of the cell
// renderer, which can be set explicitly or mapped to a column in the tree
// model, like all properties of cell renders. CellRendererSpin also has
// properties for the CellRendererSpin:climb-rate and the number of
// CellRendererSpin:digits to display. Other SpinButton properties can be set in
// a handler for the CellRenderer::editing-started signal.
//
// The CellRendererSpin cell renderer was added in GTK+ 2.10.
type CellRendererSpin interface {
	CellRendererText
}

// cellRendererSpin implements the CellRendererSpin interface.
type cellRendererSpin struct {
	CellRendererText
}

var _ CellRendererSpin = (*cellRendererSpin)(nil)

// WrapCellRendererSpin wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererSpin(obj *externglib.Object) CellRendererSpin {
	return CellRendererSpin{
		CellRendererText: WrapCellRendererText(obj),
	}
}

func marshalCellRendererSpin(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererSpin(obj), nil
}

// NewCellRendererSpin constructs a class CellRendererSpin.
func NewCellRendererSpin() CellRendererSpin {

	ret := C.gtk_cell_renderer_spin_new()

	var ret0 CellRendererSpin

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(CellRendererSpin)

	return ret0
}

// CellRendererSpinner: gtkCellRendererSpinner renders a spinning animation in a
// cell, very similar to Spinner. It can often be used as an alternative to a
// CellRendererProgress for displaying indefinite activity, instead of actual
// progress.
//
// To start the animation in a cell, set the CellRendererSpinner:active property
// to true and increment the CellRendererSpinner:pulse property at regular
// intervals. The usual way to set the cell renderer properties for each cell is
// to bind them to columns in your tree model using e.g.
// gtk_tree_view_column_add_attribute().
type CellRendererSpinner interface {
	CellRenderer
}

// cellRendererSpinner implements the CellRendererSpinner interface.
type cellRendererSpinner struct {
	CellRenderer
}

var _ CellRendererSpinner = (*cellRendererSpinner)(nil)

// WrapCellRendererSpinner wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererSpinner(obj *externglib.Object) CellRendererSpinner {
	return CellRendererSpinner{
		CellRenderer: WrapCellRenderer(obj),
	}
}

func marshalCellRendererSpinner(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererSpinner(obj), nil
}

// NewCellRendererSpinner constructs a class CellRendererSpinner.
func NewCellRendererSpinner() CellRendererSpinner {

	ret := C.gtk_cell_renderer_spinner_new()

	var ret0 CellRendererSpinner

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(CellRendererSpinner)

	return ret0
}

// CellRendererText: a CellRendererText renders a given text in its cell, using
// the font, color and style information provided by its properties. The text
// will be ellipsized if it is too long and the CellRendererText:ellipsize
// property allows it.
//
// If the CellRenderer:mode is GTK_CELL_RENDERER_MODE_EDITABLE, the
// CellRendererText allows to edit its text using an entry.
type CellRendererText interface {
	CellRenderer

	// SetFixedHeightFromFont sets the height of a renderer to explicitly be
	// determined by the “font” and “y_pad” property set on it. Further changes
	// in these properties do not affect the height, so they must be accompanied
	// by a subsequent call to this function. Using this function is unflexible,
	// and should really only be used if calculating the size of a cell is too
	// slow (ie, a massive number of cells displayed). If @number_of_rows is -1,
	// then the fixed height is unset, and the height is determined by the
	// properties again.
	SetFixedHeightFromFont(numberOfRows int)
}

// cellRendererText implements the CellRendererText interface.
type cellRendererText struct {
	CellRenderer
}

var _ CellRendererText = (*cellRendererText)(nil)

// WrapCellRendererText wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererText(obj *externglib.Object) CellRendererText {
	return CellRendererText{
		CellRenderer: WrapCellRenderer(obj),
	}
}

func marshalCellRendererText(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererText(obj), nil
}

// NewCellRendererText constructs a class CellRendererText.
func NewCellRendererText() CellRendererText {

	ret := C.gtk_cell_renderer_text_new()

	var ret0 CellRendererText

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(CellRendererText)

	return ret0
}

// SetFixedHeightFromFont sets the height of a renderer to explicitly be
// determined by the “font” and “y_pad” property set on it. Further changes
// in these properties do not affect the height, so they must be accompanied
// by a subsequent call to this function. Using this function is unflexible,
// and should really only be used if calculating the size of a cell is too
// slow (ie, a massive number of cells displayed). If @number_of_rows is -1,
// then the fixed height is unset, and the height is determined by the
// properties again.
func (renderer cellRendererText) SetFixedHeightFromFont(numberOfRows int) {
	var arg0 *C.GtkCellRendererText
	var arg1 C.gint

	arg0 = (*C.GtkCellRendererText)(renderer.Native())
	arg1 = C.gint(numberOfRows)

	C.gtk_cell_renderer_text_set_fixed_height_from_font(arg0, arg1)
}

// CellRendererToggle renders a toggle button in a cell. The button is drawn as
// a radio or a checkbutton, depending on the CellRendererToggle:radio property.
// When activated, it emits the CellRendererToggle::toggled signal.
type CellRendererToggle interface {
	CellRenderer

	// Activatable returns whether the cell renderer is activatable. See
	// gtk_cell_renderer_toggle_set_activatable().
	Activatable() bool
	// Active returns whether the cell renderer is active. See
	// gtk_cell_renderer_toggle_set_active().
	Active() bool
	// Radio returns whether we’re rendering radio toggles rather than
	// checkboxes.
	Radio() bool
	// SetActivatable makes the cell renderer activatable.
	SetActivatable(setting bool)
	// SetActive activates or deactivates a cell renderer.
	SetActive(setting bool)
	// SetRadio: if @radio is true, the cell renderer renders a radio toggle
	// (i.e. a toggle in a group of mutually-exclusive toggles). If false, it
	// renders a check toggle (a standalone boolean option). This can be set
	// globally for the cell renderer, or changed just before rendering each
	// cell in the model (for TreeView, you set up a per-row setting using
	// TreeViewColumn to associate model columns with cell renderer properties).
	SetRadio(radio bool)
}

// cellRendererToggle implements the CellRendererToggle interface.
type cellRendererToggle struct {
	CellRenderer
}

var _ CellRendererToggle = (*cellRendererToggle)(nil)

// WrapCellRendererToggle wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererToggle(obj *externglib.Object) CellRendererToggle {
	return CellRendererToggle{
		CellRenderer: WrapCellRenderer(obj),
	}
}

func marshalCellRendererToggle(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererToggle(obj), nil
}

// NewCellRendererToggle constructs a class CellRendererToggle.
func NewCellRendererToggle() CellRendererToggle {

	ret := C.gtk_cell_renderer_toggle_new()

	var ret0 CellRendererToggle

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(CellRendererToggle)

	return ret0
}

// Activatable returns whether the cell renderer is activatable. See
// gtk_cell_renderer_toggle_set_activatable().
func (toggle cellRendererToggle) Activatable() bool {
	var arg0 *C.GtkCellRendererToggle

	arg0 = (*C.GtkCellRendererToggle)(toggle.Native())

	ret := C.gtk_cell_renderer_toggle_get_activatable(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Active returns whether the cell renderer is active. See
// gtk_cell_renderer_toggle_set_active().
func (toggle cellRendererToggle) Active() bool {
	var arg0 *C.GtkCellRendererToggle

	arg0 = (*C.GtkCellRendererToggle)(toggle.Native())

	ret := C.gtk_cell_renderer_toggle_get_active(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Radio returns whether we’re rendering radio toggles rather than
// checkboxes.
func (toggle cellRendererToggle) Radio() bool {
	var arg0 *C.GtkCellRendererToggle

	arg0 = (*C.GtkCellRendererToggle)(toggle.Native())

	ret := C.gtk_cell_renderer_toggle_get_radio(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SetActivatable makes the cell renderer activatable.
func (toggle cellRendererToggle) SetActivatable(setting bool) {
	var arg0 *C.GtkCellRendererToggle
	var arg1 C.gboolean

	arg0 = (*C.GtkCellRendererToggle)(toggle.Native())
	if setting {
		arg1 = C.TRUE
	}

	C.gtk_cell_renderer_toggle_set_activatable(arg0, arg1)
}

// SetActive activates or deactivates a cell renderer.
func (toggle cellRendererToggle) SetActive(setting bool) {
	var arg0 *C.GtkCellRendererToggle
	var arg1 C.gboolean

	arg0 = (*C.GtkCellRendererToggle)(toggle.Native())
	if setting {
		arg1 = C.TRUE
	}

	C.gtk_cell_renderer_toggle_set_active(arg0, arg1)
}

// SetRadio: if @radio is true, the cell renderer renders a radio toggle
// (i.e. a toggle in a group of mutually-exclusive toggles). If false, it
// renders a check toggle (a standalone boolean option). This can be set
// globally for the cell renderer, or changed just before rendering each
// cell in the model (for TreeView, you set up a per-row setting using
// TreeViewColumn to associate model columns with cell renderer properties).
func (toggle cellRendererToggle) SetRadio(radio bool) {
	var arg0 *C.GtkCellRendererToggle
	var arg1 C.gboolean

	arg0 = (*C.GtkCellRendererToggle)(toggle.Native())
	if radio {
		arg1 = C.TRUE
	}

	C.gtk_cell_renderer_toggle_set_radio(arg0, arg1)
}

// Clipboard: the Clipboard object represents a clipboard of data shared between
// different processes or between different widgets in the same process. Each
// clipboard is identified by a name encoded as a Atom. (Conversion to and from
// strings can be done with gdk_atom_intern() and gdk_atom_name().) The default
// clipboard corresponds to the “CLIPBOARD” atom; another commonly used
// clipboard is the “PRIMARY” clipboard, which, in X, traditionally contains the
// currently selected text.
//
// To support having a number of different formats on the clipboard at the same
// time, the clipboard mechanism allows providing callbacks instead of the
// actual data. When you set the contents of the clipboard, you can either
// supply the data directly (via functions like gtk_clipboard_set_text()), or
// you can supply a callback to be called at a later time when the data is
// needed (via gtk_clipboard_set_with_data() or gtk_clipboard_set_with_owner().)
// Providing a callback also avoids having to make copies of the data when it is
// not needed.
//
// gtk_clipboard_set_with_data() and gtk_clipboard_set_with_owner() are quite
// similar; the choice between the two depends mostly on which is more
// convenient in a particular situation. The former is most useful when you want
// to have a blob of data with callbacks to convert it into the various data
// types that you advertise. When the @clear_func you provided is called, you
// simply free the data blob. The latter is more useful when the contents of
// clipboard reflect the internal state of a #GObject (As an example, for the
// PRIMARY clipboard, when an entry widget provides the clipboard’s contents the
// contents are simply the text within the selected region.) If the contents
// change, the entry widget can call gtk_clipboard_set_with_owner() to update
// the timestamp for clipboard ownership, without having to worry about
// @clear_func being called.
//
// Requesting the data from the clipboard is essentially asynchronous. If the
// contents of the clipboard are provided within the same process, then a direct
// function call will be made to retrieve the data, but if they are provided by
// another process, then the data needs to be retrieved from the other process,
// which may take some time. To avoid blocking the user interface, the call to
// request the selection, gtk_clipboard_request_contents() takes a callback that
// will be called when the contents are received (or when the request fails.) If
// you don’t want to deal with providing a separate callback, you can also use
// gtk_clipboard_wait_for_contents(). What this does is run the GLib main loop
// recursively waiting for the contents. This can simplify the code flow, but
// you still have to be aware that other callbacks in your program can be called
// while this recursive mainloop is running.
//
// Along with the functions to get the clipboard contents as an arbitrary data
// chunk, there are also functions to retrieve it as text,
// gtk_clipboard_request_text() and gtk_clipboard_wait_for_text(). These
// functions take care of determining which formats are advertised by the
// clipboard provider, asking for the clipboard in the best available format and
// converting the results into the UTF-8 encoding. (The standard form for
// representing strings in GTK+.)
type Clipboard interface {
	gextras.Objector

	// Clear clears the contents of the clipboard. Generally this should only be
	// called between the time you call gtk_clipboard_set_with_owner() or
	// gtk_clipboard_set_with_data(), and when the @clear_func you supplied is
	// called. Otherwise, the clipboard may be owned by someone else.
	Clear()
	// Display gets the Display associated with @clipboard
	Display() gdk.Display
	// Owner: if the clipboard contents callbacks were set with
	// gtk_clipboard_set_with_owner(), and the gtk_clipboard_set_with_data() or
	// gtk_clipboard_clear() has not subsequently called, returns the owner set
	// by gtk_clipboard_set_with_owner().
	Owner() gextras.Objector
	// Selection gets the selection that this clipboard is for.
	Selection() gdk.Atom
	// RequestContents requests the contents of clipboard as the given target.
	// When the results of the result are later received the supplied callback
	// will be called.
	RequestContents(target gdk.Atom, callback ClipboardReceivedFunc)
	// RequestImage requests the contents of the clipboard as image. When the
	// image is later received, it will be converted to a Pixbuf, and @callback
	// will be called.
	//
	// The @pixbuf parameter to @callback will contain the resulting Pixbuf if
	// the request succeeded, or nil if it failed. This could happen for various
	// reasons, in particular if the clipboard was empty or if the contents of
	// the clipboard could not be converted into an image.
	RequestImage(callback ClipboardImageReceivedFunc)
	// RequestRichText requests the contents of the clipboard as rich text. When
	// the rich text is later received, @callback will be called.
	//
	// The @text parameter to @callback will contain the resulting rich text if
	// the request succeeded, or nil if it failed. The @length parameter will
	// contain @text’s length. This function can fail for various reasons, in
	// particular if the clipboard was empty or if the contents of the clipboard
	// could not be converted into rich text form.
	RequestRichText(buffer TextBuffer, callback ClipboardRichTextReceivedFunc)
	// RequestTargets requests the contents of the clipboard as list of
	// supported targets. When the list is later received, @callback will be
	// called.
	//
	// The @targets parameter to @callback will contain the resulting targets if
	// the request succeeded, or nil if it failed.
	RequestTargets(callback ClipboardTargetsReceivedFunc)
	// RequestText requests the contents of the clipboard as text. When the text
	// is later received, it will be converted to UTF-8 if necessary, and
	// @callback will be called.
	//
	// The @text parameter to @callback will contain the resulting text if the
	// request succeeded, or nil if it failed. This could happen for various
	// reasons, in particular if the clipboard was empty or if the contents of
	// the clipboard could not be converted into text form.
	RequestText(callback ClipboardTextReceivedFunc)
	// RequestUris requests the contents of the clipboard as URIs. When the URIs
	// are later received @callback will be called.
	//
	// The @uris parameter to @callback will contain the resulting array of URIs
	// if the request succeeded, or nil if it failed. This could happen for
	// various reasons, in particular if the clipboard was empty or if the
	// contents of the clipboard could not be converted into URI form.
	RequestUris(callback ClipboardURIReceivedFunc)
	// SetCanStore hints that the clipboard data should be stored somewhere when
	// the application exits or when gtk_clipboard_store () is called.
	//
	// This value is reset when the clipboard owner changes. Where the clipboard
	// data is stored is platform dependent, see gdk_display_store_clipboard ()
	// for more information.
	SetCanStore(targets []TargetEntry)
	// SetImage sets the contents of the clipboard to the given Pixbuf. GTK+
	// will take responsibility for responding for requests for the image, and
	// for converting the image into the requested format.
	SetImage(pixbuf gdkpixbuf.Pixbuf)
	// SetText sets the contents of the clipboard to the given UTF-8 string.
	// GTK+ will make a copy of the text and take responsibility for responding
	// for requests for the text, and for converting the text into the requested
	// format.
	SetText(text string, len int)
	// Store stores the current clipboard data somewhere so that it will stay
	// around after the application has quit.
	Store()
	// WaitForContents requests the contents of the clipboard using the given
	// target. This function waits for the data to be received using the main
	// loop, so events, timeouts, etc, may be dispatched during the wait.
	WaitForContents(target gdk.Atom) *SelectionData
	// WaitForImage requests the contents of the clipboard as image and converts
	// the result to a Pixbuf. This function waits for the data to be received
	// using the main loop, so events, timeouts, etc, may be dispatched during
	// the wait.
	WaitForImage() gdkpixbuf.Pixbuf
	// WaitForRichText requests the contents of the clipboard as rich text. This
	// function waits for the data to be received using the main loop, so
	// events, timeouts, etc, may be dispatched during the wait.
	WaitForRichText(buffer TextBuffer) (format gdk.Atom, length uint, guint8s []byte)
	// WaitForTargets returns a list of targets that are present on the
	// clipboard, or nil if there aren’t any targets available. The returned
	// list must be freed with g_free(). This function waits for the data to be
	// received using the main loop, so events, timeouts, etc, may be dispatched
	// during the wait.
	WaitForTargets() (targets []*gdk.Atom, nTargets int, ok bool)
	// WaitForText requests the contents of the clipboard as text and converts
	// the result to UTF-8 if necessary. This function waits for the data to be
	// received using the main loop, so events, timeouts, etc, may be dispatched
	// during the wait.
	WaitForText() string
	// WaitForUris requests the contents of the clipboard as URIs. This function
	// waits for the data to be received using the main loop, so events,
	// timeouts, etc, may be dispatched during the wait.
	WaitForUris() []string
	// WaitIsImageAvailable: test to see if there is an image available to be
	// pasted This is done by requesting the TARGETS atom and checking if it
	// contains any of the supported image targets. This function waits for the
	// data to be received using the main loop, so events, timeouts, etc, may be
	// dispatched during the wait.
	//
	// This function is a little faster than calling
	// gtk_clipboard_wait_for_image() since it doesn’t need to retrieve the
	// actual image data.
	WaitIsImageAvailable() bool
	// WaitIsRichTextAvailable: test to see if there is rich text available to
	// be pasted This is done by requesting the TARGETS atom and checking if it
	// contains any of the supported rich text targets. This function waits for
	// the data to be received using the main loop, so events, timeouts, etc,
	// may be dispatched during the wait.
	//
	// This function is a little faster than calling
	// gtk_clipboard_wait_for_rich_text() since it doesn’t need to retrieve the
	// actual text.
	WaitIsRichTextAvailable(buffer TextBuffer) bool
	// WaitIsTargetAvailable checks if a clipboard supports pasting data of a
	// given type. This function can be used to determine if a “Paste” menu item
	// should be insensitive or not.
	//
	// If you want to see if there’s text available on the clipboard, use
	// gtk_clipboard_wait_is_text_available () instead.
	WaitIsTargetAvailable(target gdk.Atom) bool
	// WaitIsTextAvailable: test to see if there is text available to be pasted
	// This is done by requesting the TARGETS atom and checking if it contains
	// any of the supported text targets. This function waits for the data to be
	// received using the main loop, so events, timeouts, etc, may be dispatched
	// during the wait.
	//
	// This function is a little faster than calling
	// gtk_clipboard_wait_for_text() since it doesn’t need to retrieve the
	// actual text.
	WaitIsTextAvailable() bool
	// WaitIsUrisAvailable: test to see if there is a list of URIs available to
	// be pasted This is done by requesting the TARGETS atom and checking if it
	// contains the URI targets. This function waits for the data to be received
	// using the main loop, so events, timeouts, etc, may be dispatched during
	// the wait.
	//
	// This function is a little faster than calling
	// gtk_clipboard_wait_for_uris() since it doesn’t need to retrieve the
	// actual URI data.
	WaitIsUrisAvailable() bool
}

// clipboard implements the Clipboard interface.
type clipboard struct {
	gextras.Objector
}

var _ Clipboard = (*clipboard)(nil)

// WrapClipboard wraps a GObject to the right type. It is
// primarily used internally.
func WrapClipboard(obj *externglib.Object) Clipboard {
	return Clipboard{
		Objector: obj,
	}
}

func marshalClipboard(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapClipboard(obj), nil
}

// Clear clears the contents of the clipboard. Generally this should only be
// called between the time you call gtk_clipboard_set_with_owner() or
// gtk_clipboard_set_with_data(), and when the @clear_func you supplied is
// called. Otherwise, the clipboard may be owned by someone else.
func (clipboard clipboard) Clear() {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(clipboard.Native())

	C.gtk_clipboard_clear(arg0)
}

// Display gets the Display associated with @clipboard
func (clipboard clipboard) Display() gdk.Display {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(clipboard.Native())

	ret := C.gtk_clipboard_get_display(arg0)

	var ret0 gdk.Display

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gdk.Display)

	return ret0
}

// Owner: if the clipboard contents callbacks were set with
// gtk_clipboard_set_with_owner(), and the gtk_clipboard_set_with_data() or
// gtk_clipboard_clear() has not subsequently called, returns the owner set
// by gtk_clipboard_set_with_owner().
func (clipboard clipboard) Owner() gextras.Objector {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(clipboard.Native())

	ret := C.gtk_clipboard_get_owner(arg0)

	var ret0 gextras.Objector

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gextras.Objector)

	return ret0
}

// Selection gets the selection that this clipboard is for.
func (clipboard clipboard) Selection() gdk.Atom {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(clipboard.Native())

	ret := C.gtk_clipboard_get_selection(arg0)

	var ret0 gdk.Atom

	{
		ret0 = gdk.WrapAtom(unsafe.Pointer(ret))
	}

	return ret0
}

// RequestContents requests the contents of clipboard as the given target.
// When the results of the result are later received the supplied callback
// will be called.
func (clipboard clipboard) RequestContents(target gdk.Atom, callback ClipboardReceivedFunc) {
	var arg0 *C.GtkClipboard
	var arg1 C.GdkAtom
	var arg2 C.GtkClipboardReceivedFunc
	var arg3 C.gpointer

	arg0 = (*C.GtkClipboard)(clipboard.Native())
	arg1 = (C.GdkAtom)(target.Native())
	arg2 = (*[0]byte)(C.gotk4_ClipboardReceivedFunc)
	arg3 = C.gpointer(box.Assign(callback))

	C.gtk_clipboard_request_contents(arg0, arg1, arg2, arg3)
}

// RequestImage requests the contents of the clipboard as image. When the
// image is later received, it will be converted to a Pixbuf, and @callback
// will be called.
//
// The @pixbuf parameter to @callback will contain the resulting Pixbuf if
// the request succeeded, or nil if it failed. This could happen for various
// reasons, in particular if the clipboard was empty or if the contents of
// the clipboard could not be converted into an image.
func (clipboard clipboard) RequestImage(callback ClipboardImageReceivedFunc) {
	var arg0 *C.GtkClipboard
	var arg1 C.GtkClipboardImageReceivedFunc
	var arg2 C.gpointer

	arg0 = (*C.GtkClipboard)(clipboard.Native())
	arg1 = (*[0]byte)(C.gotk4_ClipboardImageReceivedFunc)
	arg2 = C.gpointer(box.Assign(callback))

	C.gtk_clipboard_request_image(arg0, arg1, arg2)
}

// RequestRichText requests the contents of the clipboard as rich text. When
// the rich text is later received, @callback will be called.
//
// The @text parameter to @callback will contain the resulting rich text if
// the request succeeded, or nil if it failed. The @length parameter will
// contain @text’s length. This function can fail for various reasons, in
// particular if the clipboard was empty or if the contents of the clipboard
// could not be converted into rich text form.
func (clipboard clipboard) RequestRichText(buffer TextBuffer, callback ClipboardRichTextReceivedFunc) {
	var arg0 *C.GtkClipboard
	var arg1 *C.GtkTextBuffer
	var arg2 C.GtkClipboardRichTextReceivedFunc
	var arg3 C.gpointer

	arg0 = (*C.GtkClipboard)(clipboard.Native())
	arg1 = (*C.GtkTextBuffer)(buffer.Native())
	arg2 = (*[0]byte)(C.gotk4_ClipboardRichTextReceivedFunc)
	arg3 = C.gpointer(box.Assign(callback))

	C.gtk_clipboard_request_rich_text(arg0, arg1, arg2, arg3)
}

// RequestTargets requests the contents of the clipboard as list of
// supported targets. When the list is later received, @callback will be
// called.
//
// The @targets parameter to @callback will contain the resulting targets if
// the request succeeded, or nil if it failed.
func (clipboard clipboard) RequestTargets(callback ClipboardTargetsReceivedFunc) {
	var arg0 *C.GtkClipboard
	var arg1 C.GtkClipboardTargetsReceivedFunc
	var arg2 C.gpointer

	arg0 = (*C.GtkClipboard)(clipboard.Native())
	arg1 = (*[0]byte)(C.gotk4_ClipboardTargetsReceivedFunc)
	arg2 = C.gpointer(box.Assign(callback))

	C.gtk_clipboard_request_targets(arg0, arg1, arg2)
}

// RequestText requests the contents of the clipboard as text. When the text
// is later received, it will be converted to UTF-8 if necessary, and
// @callback will be called.
//
// The @text parameter to @callback will contain the resulting text if the
// request succeeded, or nil if it failed. This could happen for various
// reasons, in particular if the clipboard was empty or if the contents of
// the clipboard could not be converted into text form.
func (clipboard clipboard) RequestText(callback ClipboardTextReceivedFunc) {
	var arg0 *C.GtkClipboard
	var arg1 C.GtkClipboardTextReceivedFunc
	var arg2 C.gpointer

	arg0 = (*C.GtkClipboard)(clipboard.Native())
	arg1 = (*[0]byte)(C.gotk4_ClipboardTextReceivedFunc)
	arg2 = C.gpointer(box.Assign(callback))

	C.gtk_clipboard_request_text(arg0, arg1, arg2)
}

// RequestUris requests the contents of the clipboard as URIs. When the URIs
// are later received @callback will be called.
//
// The @uris parameter to @callback will contain the resulting array of URIs
// if the request succeeded, or nil if it failed. This could happen for
// various reasons, in particular if the clipboard was empty or if the
// contents of the clipboard could not be converted into URI form.
func (clipboard clipboard) RequestUris(callback ClipboardURIReceivedFunc) {
	var arg0 *C.GtkClipboard
	var arg1 C.GtkClipboardURIReceivedFunc
	var arg2 C.gpointer

	arg0 = (*C.GtkClipboard)(clipboard.Native())
	arg1 = (*[0]byte)(C.gotk4_ClipboardURIReceivedFunc)
	arg2 = C.gpointer(box.Assign(callback))

	C.gtk_clipboard_request_uris(arg0, arg1, arg2)
}

// SetCanStore hints that the clipboard data should be stored somewhere when
// the application exits or when gtk_clipboard_store () is called.
//
// This value is reset when the clipboard owner changes. Where the clipboard
// data is stored is platform dependent, see gdk_display_store_clipboard ()
// for more information.
func (clipboard clipboard) SetCanStore(targets []TargetEntry) {
	var arg0 *C.GtkClipboard
	var arg1 *C.GtkTargetEntry
	var arg2 C.gint

	arg0 = (*C.GtkClipboard)(clipboard.Native())
	{
		var dst []C.GtkTargetEntry
		ptr := C.malloc(C.sizeof_GtkTargetEntry * len(targets))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(targets)
		sliceHeader.Cap = len(targets)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(targets); i++ {
			src := targets[i]
			dst[i] = (C.GtkTargetEntry)(src.Native())
		}

		arg1 = (*C.GtkTargetEntry)(unsafe.Pointer(ptr))
		arg2 = len(targets)
	}

	C.gtk_clipboard_set_can_store(arg0, arg1, arg2)
}

// SetImage sets the contents of the clipboard to the given Pixbuf. GTK+
// will take responsibility for responding for requests for the image, and
// for converting the image into the requested format.
func (clipboard clipboard) SetImage(pixbuf gdkpixbuf.Pixbuf) {
	var arg0 *C.GtkClipboard
	var arg1 *C.GdkPixbuf

	arg0 = (*C.GtkClipboard)(clipboard.Native())
	arg1 = (*C.GdkPixbuf)(pixbuf.Native())

	C.gtk_clipboard_set_image(arg0, arg1)
}

// SetText sets the contents of the clipboard to the given UTF-8 string.
// GTK+ will make a copy of the text and take responsibility for responding
// for requests for the text, and for converting the text into the requested
// format.
func (clipboard clipboard) SetText(text string, len int) {
	var arg0 *C.GtkClipboard
	var arg1 *C.gchar
	var arg2 C.gint

	arg0 = (*C.GtkClipboard)(clipboard.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(len)

	C.gtk_clipboard_set_text(arg0, arg1, arg2)
}

// Store stores the current clipboard data somewhere so that it will stay
// around after the application has quit.
func (clipboard clipboard) Store() {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(clipboard.Native())

	C.gtk_clipboard_store(arg0)
}

// WaitForContents requests the contents of the clipboard using the given
// target. This function waits for the data to be received using the main
// loop, so events, timeouts, etc, may be dispatched during the wait.
func (clipboard clipboard) WaitForContents(target gdk.Atom) *SelectionData {
	var arg0 *C.GtkClipboard
	var arg1 C.GdkAtom

	arg0 = (*C.GtkClipboard)(clipboard.Native())
	arg1 = (C.GdkAtom)(target.Native())

	ret := C.gtk_clipboard_wait_for_contents(arg0, arg1)

	var ret0 *SelectionData

	{
		ret0 = WrapSelectionData(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *SelectionData) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// WaitForImage requests the contents of the clipboard as image and converts
// the result to a Pixbuf. This function waits for the data to be received
// using the main loop, so events, timeouts, etc, may be dispatched during
// the wait.
func (clipboard clipboard) WaitForImage() gdkpixbuf.Pixbuf {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(clipboard.Native())

	ret := C.gtk_clipboard_wait_for_image(arg0)

	var ret0 gdkpixbuf.Pixbuf

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gdkpixbuf.Pixbuf)

	return ret0
}

// WaitForRichText requests the contents of the clipboard as rich text. This
// function waits for the data to be received using the main loop, so
// events, timeouts, etc, may be dispatched during the wait.
func (clipboard clipboard) WaitForRichText(buffer TextBuffer) (format gdk.Atom, length uint, guint8s []byte) {
	var arg0 *C.GtkClipboard
	var arg1 *C.GtkTextBuffer
	var arg2 *C.GdkAtom // out
	var arg3 *C.gsize   // out

	arg0 = (*C.GtkClipboard)(clipboard.Native())
	arg1 = (*C.GtkTextBuffer)(buffer.Native())

	ret := C.gtk_clipboard_wait_for_rich_text(arg0, arg1, &arg2, &arg3)

	var ret0 *gdk.Atom
	var ret1 uint
	var ret2 []byte

	{
		ret0 = gdk.WrapAtom(unsafe.Pointer(arg2))
	}

	ret1 = uint(arg3)

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret2))
		sliceHeader.Data = uintptr(unsafe.Pointer(ret))
		sliceHeader.Len = arg3
		sliceHeader.Cap = arg3
		runtime.SetFinalizer(&ret, func() {
			C.free(unsafe.Pointer(ret))
		})
		defer runtime.KeepAlive(ret)
	}

	return ret0, ret1, ret2
}

// WaitForTargets returns a list of targets that are present on the
// clipboard, or nil if there aren’t any targets available. The returned
// list must be freed with g_free(). This function waits for the data to be
// received using the main loop, so events, timeouts, etc, may be dispatched
// during the wait.
func (clipboard clipboard) WaitForTargets() (targets []*gdk.Atom, nTargets int, ok bool) {
	var arg0 *C.GtkClipboard
	var arg1 **C.GdkAtom // out
	var arg2 *C.gint     // out

	arg0 = (*C.GtkClipboard)(clipboard.Native())

	ret := C.gtk_clipboard_wait_for_targets(arg0, &arg1, &arg2)

	var ret0 []*gdk.Atom
	var ret1 int
	var ret2 bool

	{
		ret0 = make([]*gdk.Atom, arg2)
		for i := 0; i < uintptr(arg2); i++ {
			src := (*C.GdkAtom)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			{
				ret0[i] = gdk.WrapAtom(unsafe.Pointer(src))
			}
		}
	}

	ret1 = int(arg2)

	ret2 = C.BOOL(ret) != 0

	return ret0, ret1, ret2
}

// WaitForText requests the contents of the clipboard as text and converts
// the result to UTF-8 if necessary. This function waits for the data to be
// received using the main loop, so events, timeouts, etc, may be dispatched
// during the wait.
func (clipboard clipboard) WaitForText() string {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(clipboard.Native())

	ret := C.gtk_clipboard_wait_for_text(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// WaitForUris requests the contents of the clipboard as URIs. This function
// waits for the data to be received using the main loop, so events,
// timeouts, etc, may be dispatched during the wait.
func (clipboard clipboard) WaitForUris() []string {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(clipboard.Native())

	ret := C.gtk_clipboard_wait_for_uris(arg0)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// WaitIsImageAvailable: test to see if there is an image available to be
// pasted This is done by requesting the TARGETS atom and checking if it
// contains any of the supported image targets. This function waits for the
// data to be received using the main loop, so events, timeouts, etc, may be
// dispatched during the wait.
//
// This function is a little faster than calling
// gtk_clipboard_wait_for_image() since it doesn’t need to retrieve the
// actual image data.
func (clipboard clipboard) WaitIsImageAvailable() bool {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(clipboard.Native())

	ret := C.gtk_clipboard_wait_is_image_available(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// WaitIsRichTextAvailable: test to see if there is rich text available to
// be pasted This is done by requesting the TARGETS atom and checking if it
// contains any of the supported rich text targets. This function waits for
// the data to be received using the main loop, so events, timeouts, etc,
// may be dispatched during the wait.
//
// This function is a little faster than calling
// gtk_clipboard_wait_for_rich_text() since it doesn’t need to retrieve the
// actual text.
func (clipboard clipboard) WaitIsRichTextAvailable(buffer TextBuffer) bool {
	var arg0 *C.GtkClipboard
	var arg1 *C.GtkTextBuffer

	arg0 = (*C.GtkClipboard)(clipboard.Native())
	arg1 = (*C.GtkTextBuffer)(buffer.Native())

	ret := C.gtk_clipboard_wait_is_rich_text_available(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// WaitIsTargetAvailable checks if a clipboard supports pasting data of a
// given type. This function can be used to determine if a “Paste” menu item
// should be insensitive or not.
//
// If you want to see if there’s text available on the clipboard, use
// gtk_clipboard_wait_is_text_available () instead.
func (clipboard clipboard) WaitIsTargetAvailable(target gdk.Atom) bool {
	var arg0 *C.GtkClipboard
	var arg1 C.GdkAtom

	arg0 = (*C.GtkClipboard)(clipboard.Native())
	arg1 = (C.GdkAtom)(target.Native())

	ret := C.gtk_clipboard_wait_is_target_available(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// WaitIsTextAvailable: test to see if there is text available to be pasted
// This is done by requesting the TARGETS atom and checking if it contains
// any of the supported text targets. This function waits for the data to be
// received using the main loop, so events, timeouts, etc, may be dispatched
// during the wait.
//
// This function is a little faster than calling
// gtk_clipboard_wait_for_text() since it doesn’t need to retrieve the
// actual text.
func (clipboard clipboard) WaitIsTextAvailable() bool {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(clipboard.Native())

	ret := C.gtk_clipboard_wait_is_text_available(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// WaitIsUrisAvailable: test to see if there is a list of URIs available to
// be pasted This is done by requesting the TARGETS atom and checking if it
// contains the URI targets. This function waits for the data to be received
// using the main loop, so events, timeouts, etc, may be dispatched during
// the wait.
//
// This function is a little faster than calling
// gtk_clipboard_wait_for_uris() since it doesn’t need to retrieve the
// actual URI data.
func (clipboard clipboard) WaitIsUrisAvailable() bool {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(clipboard.Native())

	ret := C.gtk_clipboard_wait_is_uris_available(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// CSSProvider: gtkCssProvider is an object implementing the StyleProvider
// interface. It is able to parse [CSS-like][css-overview] input in order to
// style widgets.
//
// An application can make GTK+ parse a specific CSS style sheet by calling
// gtk_css_provider_load_from_file() or gtk_css_provider_load_from_resource()
// and adding the provider with gtk_style_context_add_provider() or
// gtk_style_context_add_provider_for_screen().
//
// In addition, certain files will be read when GTK+ is initialized. First, the
// file `$XDG_CONFIG_HOME/gtk-3.0/gtk.css` is loaded if it exists. Then, GTK+
// loads the first existing file among
// `XDG_DATA_HOME/themes/THEME/gtk-VERSION/gtk.css`,
// `$HOME/.themes/THEME/gtk-VERSION/gtk.css`,
// `$XDG_DATA_DIRS/themes/THEME/gtk-VERSION/gtk.css` and
// `DATADIR/share/themes/THEME/gtk-VERSION/gtk.css`, where `THEME` is the name
// of the current theme (see the Settings:gtk-theme-name setting), `DATADIR` is
// the prefix configured when GTK+ was compiled (unless overridden by the
// `GTK_DATA_PREFIX` environment variable), and `VERSION` is the GTK+ version
// number. If no file is found for the current version, GTK+ tries older
// versions all the way back to 3.0.
//
// In the same way, GTK+ tries to load a gtk-keys.css file for the current key
// theme, as defined by Settings:gtk-key-theme-name.
type CSSProvider interface {
	gextras.Objector
	StyleProvider

	// LoadFromData loads @data into @css_provider, and by doing so clears any
	// previously loaded information.
	LoadFromData(data []byte) error
	// LoadFromFile loads the data contained in @file into @css_provider, making
	// it clear any previously loaded information.
	LoadFromFile(file gio.File) error
	// LoadFromPath loads the data contained in @path into @css_provider, making
	// it clear any previously loaded information.
	LoadFromPath(path string) error
	// LoadFromResource loads the data contained in the resource at
	// @resource_path into the CssProvider, clearing any previously loaded
	// information.
	//
	// To track errors while loading CSS, connect to the
	// CssProvider::parsing-error signal.
	LoadFromResource(resourcePath string)
	// String converts the @provider into a string representation in CSS format.
	//
	// Using gtk_css_provider_load_from_data() with the return value from this
	// function on a new provider created with gtk_css_provider_new() will
	// basically create a duplicate of this @provider.
	String() string
}

// cssProvider implements the CSSProvider interface.
type cssProvider struct {
	gextras.Objector
	StyleProvider
}

var _ CSSProvider = (*cssProvider)(nil)

// WrapCSSProvider wraps a GObject to the right type. It is
// primarily used internally.
func WrapCSSProvider(obj *externglib.Object) CSSProvider {
	return CSSProvider{
		Objector:      obj,
		StyleProvider: WrapStyleProvider(obj),
	}
}

func marshalCSSProvider(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCSSProvider(obj), nil
}

// NewCSSProvider constructs a class CSSProvider.
func NewCSSProvider() CSSProvider {

	ret := C.gtk_css_provider_new()

	var ret0 CSSProvider

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(CSSProvider)

	return ret0
}

// LoadFromData loads @data into @css_provider, and by doing so clears any
// previously loaded information.
func (cssProvider cssProvider) LoadFromData(data []byte) error {
	var arg0 *C.GtkCssProvider
	var arg1 *C.gchar
	var arg2 C.gssize
	var gError *C.GError

	arg0 = (*C.GtkCssProvider)(cssProvider.Native())
	arg1 = (*C.gchar)(unsafe.Pointer(&data[0]))
	arg2 = len(data)
	defer runtime.KeepAlive(data)

	ret := C.gtk_css_provider_load_from_data(arg0, arg1, arg2, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// LoadFromFile loads the data contained in @file into @css_provider, making
// it clear any previously loaded information.
func (cssProvider cssProvider) LoadFromFile(file gio.File) error {
	var arg0 *C.GtkCssProvider
	var arg1 *C.GFile
	var gError *C.GError

	arg0 = (*C.GtkCssProvider)(cssProvider.Native())
	arg1 = (*C.GFile)(file.Native())

	ret := C.gtk_css_provider_load_from_file(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// LoadFromPath loads the data contained in @path into @css_provider, making
// it clear any previously loaded information.
func (cssProvider cssProvider) LoadFromPath(path string) error {
	var arg0 *C.GtkCssProvider
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GtkCssProvider)(cssProvider.Native())
	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_css_provider_load_from_path(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// LoadFromResource loads the data contained in the resource at
// @resource_path into the CssProvider, clearing any previously loaded
// information.
//
// To track errors while loading CSS, connect to the
// CssProvider::parsing-error signal.
func (cssProvider cssProvider) LoadFromResource(resourcePath string) {
	var arg0 *C.GtkCssProvider
	var arg1 *C.gchar

	arg0 = (*C.GtkCssProvider)(cssProvider.Native())
	arg1 = (*C.gchar)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_css_provider_load_from_resource(arg0, arg1)
}

// String converts the @provider into a string representation in CSS format.
//
// Using gtk_css_provider_load_from_data() with the return value from this
// function on a new provider created with gtk_css_provider_new() will
// basically create a duplicate of this @provider.
func (provider cssProvider) String() string {
	var arg0 *C.GtkCssProvider

	arg0 = (*C.GtkCssProvider)(provider.Native())

	ret := C.gtk_css_provider_to_string(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// EntryBuffer: the EntryBuffer class contains the actual text displayed in a
// Entry widget.
//
// A single EntryBuffer object can be shared by multiple Entry widgets which
// will then share the same text content, but not the cursor position,
// visibility attributes, icon etc.
//
// EntryBuffer may be derived from. Such a derived class might allow text to be
// stored in an alternate location, such as non-pageable memory, useful in the
// case of important passwords. Or a derived class could integrate with an
// application’s concept of undo/redo.
type EntryBuffer interface {
	gextras.Objector

	// DeleteText deletes a sequence of characters from the buffer. @n_chars
	// characters are deleted starting at @position. If @n_chars is negative,
	// then all characters until the end of the text are deleted.
	//
	// If @position or @n_chars are out of bounds, then they are coerced to sane
	// values.
	//
	// Note that the positions are specified in characters, not bytes.
	DeleteText(position uint, nChars int) uint
	// EmitDeletedText: used when subclassing EntryBuffer
	EmitDeletedText(position uint, nChars uint)
	// EmitInsertedText: used when subclassing EntryBuffer
	EmitInsertedText(position uint, chars string, nChars uint)
	// Bytes retrieves the length in bytes of the buffer. See
	// gtk_entry_buffer_get_length().
	Bytes() uint
	// Length retrieves the length in characters of the buffer.
	Length() uint
	// MaxLength retrieves the maximum allowed length of the text in @buffer.
	// See gtk_entry_buffer_set_max_length().
	MaxLength() int
	// Text retrieves the contents of the buffer.
	//
	// The memory pointer returned by this call will not change unless this
	// object emits a signal, or is finalized.
	Text() string
	// InsertText inserts @n_chars characters of @chars into the contents of the
	// buffer, at position @position.
	//
	// If @n_chars is negative, then characters from chars will be inserted
	// until a null-terminator is found. If @position or @n_chars are out of
	// bounds, or the maximum buffer text length is exceeded, then they are
	// coerced to sane values.
	//
	// Note that the position and length are in characters, not in bytes.
	InsertText(position uint, chars string, nChars int) uint
	// SetMaxLength sets the maximum allowed length of the contents of the
	// buffer. If the current contents are longer than the given length, then
	// they will be truncated to fit.
	SetMaxLength(maxLength int)
	// SetText sets the text in the buffer.
	//
	// This is roughly equivalent to calling gtk_entry_buffer_delete_text() and
	// gtk_entry_buffer_insert_text().
	//
	// Note that @n_chars is in characters, not in bytes.
	SetText(chars string, nChars int)
}

// entryBuffer implements the EntryBuffer interface.
type entryBuffer struct {
	gextras.Objector
}

var _ EntryBuffer = (*entryBuffer)(nil)

// WrapEntryBuffer wraps a GObject to the right type. It is
// primarily used internally.
func WrapEntryBuffer(obj *externglib.Object) EntryBuffer {
	return EntryBuffer{
		Objector: obj,
	}
}

func marshalEntryBuffer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEntryBuffer(obj), nil
}

// NewEntryBuffer constructs a class EntryBuffer.
func NewEntryBuffer(initialChars string, nInitialChars int) EntryBuffer {
	var arg1 *C.gchar
	var arg2 C.gint

	arg1 = (*C.gchar)(C.CString(initialChars))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(nInitialChars)

	ret := C.gtk_entry_buffer_new(arg1, arg2)

	var ret0 EntryBuffer

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(EntryBuffer)

	return ret0
}

// DeleteText deletes a sequence of characters from the buffer. @n_chars
// characters are deleted starting at @position. If @n_chars is negative,
// then all characters until the end of the text are deleted.
//
// If @position or @n_chars are out of bounds, then they are coerced to sane
// values.
//
// Note that the positions are specified in characters, not bytes.
func (buffer entryBuffer) DeleteText(position uint, nChars int) uint {
	var arg0 *C.GtkEntryBuffer
	var arg1 C.guint
	var arg2 C.gint

	arg0 = (*C.GtkEntryBuffer)(buffer.Native())
	arg1 = C.guint(position)
	arg2 = C.gint(nChars)

	ret := C.gtk_entry_buffer_delete_text(arg0, arg1, arg2)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// EmitDeletedText: used when subclassing EntryBuffer
func (buffer entryBuffer) EmitDeletedText(position uint, nChars uint) {
	var arg0 *C.GtkEntryBuffer
	var arg1 C.guint
	var arg2 C.guint

	arg0 = (*C.GtkEntryBuffer)(buffer.Native())
	arg1 = C.guint(position)
	arg2 = C.guint(nChars)

	C.gtk_entry_buffer_emit_deleted_text(arg0, arg1, arg2)
}

// EmitInsertedText: used when subclassing EntryBuffer
func (buffer entryBuffer) EmitInsertedText(position uint, chars string, nChars uint) {
	var arg0 *C.GtkEntryBuffer
	var arg1 C.guint
	var arg2 *C.gchar
	var arg3 C.guint

	arg0 = (*C.GtkEntryBuffer)(buffer.Native())
	arg1 = C.guint(position)
	arg2 = (*C.gchar)(C.CString(chars))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.guint(nChars)

	C.gtk_entry_buffer_emit_inserted_text(arg0, arg1, arg2, arg3)
}

// Bytes retrieves the length in bytes of the buffer. See
// gtk_entry_buffer_get_length().
func (buffer entryBuffer) Bytes() uint {
	var arg0 *C.GtkEntryBuffer

	arg0 = (*C.GtkEntryBuffer)(buffer.Native())

	ret := C.gtk_entry_buffer_get_bytes(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Length retrieves the length in characters of the buffer.
func (buffer entryBuffer) Length() uint {
	var arg0 *C.GtkEntryBuffer

	arg0 = (*C.GtkEntryBuffer)(buffer.Native())

	ret := C.gtk_entry_buffer_get_length(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// MaxLength retrieves the maximum allowed length of the text in @buffer.
// See gtk_entry_buffer_set_max_length().
func (buffer entryBuffer) MaxLength() int {
	var arg0 *C.GtkEntryBuffer

	arg0 = (*C.GtkEntryBuffer)(buffer.Native())

	ret := C.gtk_entry_buffer_get_max_length(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Text retrieves the contents of the buffer.
//
// The memory pointer returned by this call will not change unless this
// object emits a signal, or is finalized.
func (buffer entryBuffer) Text() string {
	var arg0 *C.GtkEntryBuffer

	arg0 = (*C.GtkEntryBuffer)(buffer.Native())

	ret := C.gtk_entry_buffer_get_text(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// InsertText inserts @n_chars characters of @chars into the contents of the
// buffer, at position @position.
//
// If @n_chars is negative, then characters from chars will be inserted
// until a null-terminator is found. If @position or @n_chars are out of
// bounds, or the maximum buffer text length is exceeded, then they are
// coerced to sane values.
//
// Note that the position and length are in characters, not in bytes.
func (buffer entryBuffer) InsertText(position uint, chars string, nChars int) uint {
	var arg0 *C.GtkEntryBuffer
	var arg1 C.guint
	var arg2 *C.gchar
	var arg3 C.gint

	arg0 = (*C.GtkEntryBuffer)(buffer.Native())
	arg1 = C.guint(position)
	arg2 = (*C.gchar)(C.CString(chars))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.gint(nChars)

	ret := C.gtk_entry_buffer_insert_text(arg0, arg1, arg2, arg3)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// SetMaxLength sets the maximum allowed length of the contents of the
// buffer. If the current contents are longer than the given length, then
// they will be truncated to fit.
func (buffer entryBuffer) SetMaxLength(maxLength int) {
	var arg0 *C.GtkEntryBuffer
	var arg1 C.gint

	arg0 = (*C.GtkEntryBuffer)(buffer.Native())
	arg1 = C.gint(maxLength)

	C.gtk_entry_buffer_set_max_length(arg0, arg1)
}

// SetText sets the text in the buffer.
//
// This is roughly equivalent to calling gtk_entry_buffer_delete_text() and
// gtk_entry_buffer_insert_text().
//
// Note that @n_chars is in characters, not in bytes.
func (buffer entryBuffer) SetText(chars string, nChars int) {
	var arg0 *C.GtkEntryBuffer
	var arg1 *C.gchar
	var arg2 C.gint

	arg0 = (*C.GtkEntryBuffer)(buffer.Native())
	arg1 = (*C.gchar)(C.CString(chars))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(nChars)

	C.gtk_entry_buffer_set_text(arg0, arg1, arg2)
}

// EntryCompletion is an auxiliary object to be used in conjunction with Entry
// to provide the completion functionality. It implements the CellLayout
// interface, to allow the user to add extra cells to the TreeView with
// completion matches.
//
// “Completion functionality” means that when the user modifies the text in the
// entry, EntryCompletion checks which rows in the model match the current
// content of the entry, and displays a list of matches. By default, the
// matching is done by comparing the entry text case-insensitively against the
// text column of the model (see gtk_entry_completion_set_text_column()), but
// this can be overridden with a custom match function (see
// gtk_entry_completion_set_match_func()).
//
// When the user selects a completion, the content of the entry is updated. By
// default, the content of the entry is replaced by the text column of the
// model, but this can be overridden by connecting to the
// EntryCompletion::match-selected signal and updating the entry in the signal
// handler. Note that you should return true from the signal handler to suppress
// the default behaviour.
//
// To add completion functionality to an entry, use gtk_entry_set_completion().
//
// In addition to regular completion matches, which will be inserted into the
// entry when they are selected, EntryCompletion also allows to display
// “actions” in the popup window. Their appearance is similar to menuitems, to
// differentiate them clearly from completion strings. When an action is
// selected, the EntryCompletion::action-activated signal is emitted.
//
// GtkEntryCompletion uses a TreeModelFilter model to represent the subset of
// the entire model that is currently matching. While the GtkEntryCompletion
// signals EntryCompletion::match-selected and EntryCompletion::cursor-on-match
// take the original model and an iter pointing to that model as arguments,
// other callbacks and signals (such as CellLayoutDataFuncs or
// CellArea::apply-attributes) will generally take the filter model as argument.
// As long as you are only calling gtk_tree_model_get(), this will make no
// difference to you. If for some reason, you need the original model, use
// gtk_tree_model_filter_get_model(). Don’t forget to use
// gtk_tree_model_filter_convert_iter_to_child_iter() to obtain a matching iter.
type EntryCompletion interface {
	gextras.Objector
	Buildable
	CellLayout

	// Complete requests a completion operation, or in other words a refiltering
	// of the current list with completions, using the current key. The
	// completion list view will be updated accordingly.
	Complete()
	// ComputePrefix computes the common prefix that is shared by all rows in
	// @completion that start with @key. If no row matches @key, nil will be
	// returned. Note that a text column must have been set for this function to
	// work, see gtk_entry_completion_set_text_column() for details.
	ComputePrefix(key string) string
	// DeleteAction deletes the action at @index_ from @completion’s action
	// list.
	//
	// Note that @index_ is a relative position and the position of an action
	// may have changed since it was inserted.
	DeleteAction(index_ int)
	// CompletionPrefix: get the original text entered by the user that
	// triggered the completion or nil if there’s no completion ongoing.
	CompletionPrefix() string
	// Entry gets the entry @completion has been attached to.
	Entry() Widget
	// InlineCompletion returns whether the common prefix of the possible
	// completions should be automatically inserted in the entry.
	InlineCompletion() bool
	// InlineSelection returns true if inline-selection mode is turned on.
	InlineSelection() bool
	// MinimumKeyLength returns the minimum key length as set for @completion.
	MinimumKeyLength() int
	// Model returns the model the EntryCompletion is using as data source.
	// Returns nil if the model is unset.
	Model() TreeModel
	// PopupCompletion returns whether the completions should be presented in a
	// popup window.
	PopupCompletion() bool
	// PopupSetWidth returns whether the completion popup window will be resized
	// to the width of the entry.
	PopupSetWidth() bool
	// PopupSingleMatch returns whether the completion popup window will appear
	// even if there is only a single match.
	PopupSingleMatch() bool
	// TextColumn returns the column in the model of @completion to get strings
	// from.
	TextColumn() int
	// InsertActionMarkup inserts an action in @completion’s action item list at
	// position @index_ with markup @markup.
	InsertActionMarkup(index_ int, markup string)
	// InsertActionText inserts an action in @completion’s action item list at
	// position @index_ with text @text. If you want the action item to have
	// markup, use gtk_entry_completion_insert_action_markup().
	//
	// Note that @index_ is a relative position in the list of actions and the
	// position of an action can change when deleting a different action.
	InsertActionText(index_ int, text string)
	// InsertPrefix requests a prefix insertion.
	InsertPrefix()
	// SetInlineCompletion sets whether the common prefix of the possible
	// completions should be automatically inserted in the entry.
	SetInlineCompletion(inlineCompletion bool)
	// SetInlineSelection sets whether it is possible to cycle through the
	// possible completions inside the entry.
	SetInlineSelection(inlineSelection bool)
	// SetMatchFunc sets the match function for @completion to be @func. The
	// match function is used to determine if a row should or should not be in
	// the completion list.
	SetMatchFunc(fn EntryCompletionMatchFunc)
	// SetMinimumKeyLength requires the length of the search key for @completion
	// to be at least @length. This is useful for long lists, where completing
	// using a small key takes a lot of time and will come up with meaningless
	// results anyway (ie, a too large dataset).
	SetMinimumKeyLength(length int)
	// SetModel sets the model for a EntryCompletion. If @completion already has
	// a model set, it will remove it before setting the new model. If model is
	// nil, then it will unset the model.
	SetModel(model TreeModel)
	// SetPopupCompletion sets whether the completions should be presented in a
	// popup window.
	SetPopupCompletion(popupCompletion bool)
	// SetPopupSetWidth sets whether the completion popup window will be resized
	// to be the same width as the entry.
	SetPopupSetWidth(popupSetWidth bool)
	// SetPopupSingleMatch sets whether the completion popup window will appear
	// even if there is only a single match. You may want to set this to false
	// if you are using [inline
	// completion][GtkEntryCompletion--inline-completion].
	SetPopupSingleMatch(popupSingleMatch bool)
	// SetTextColumn: convenience function for setting up the most used case of
	// this code: a completion list with just strings. This function will set up
	// @completion to have a list displaying all (and just) strings in the
	// completion list, and to get those strings from @column in the model of
	// @completion.
	//
	// This functions creates and adds a CellRendererText for the selected
	// column. If you need to set the text column, but don't want the cell
	// renderer, use g_object_set() to set the EntryCompletion:text-column
	// property directly.
	SetTextColumn(column int)
}

// entryCompletion implements the EntryCompletion interface.
type entryCompletion struct {
	gextras.Objector
	Buildable
	CellLayout
}

var _ EntryCompletion = (*entryCompletion)(nil)

// WrapEntryCompletion wraps a GObject to the right type. It is
// primarily used internally.
func WrapEntryCompletion(obj *externglib.Object) EntryCompletion {
	return EntryCompletion{
		Objector:   obj,
		Buildable:  WrapBuildable(obj),
		CellLayout: WrapCellLayout(obj),
	}
}

func marshalEntryCompletion(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEntryCompletion(obj), nil
}

// NewEntryCompletion constructs a class EntryCompletion.
func NewEntryCompletion() EntryCompletion {

	ret := C.gtk_entry_completion_new()

	var ret0 EntryCompletion

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(EntryCompletion)

	return ret0
}

// NewEntryCompletionWithArea constructs a class EntryCompletion.
func NewEntryCompletionWithArea(area CellArea) EntryCompletion {
	var arg1 *C.GtkCellArea

	arg1 = (*C.GtkCellArea)(area.Native())

	ret := C.gtk_entry_completion_new_with_area(arg1)

	var ret0 EntryCompletion

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(EntryCompletion)

	return ret0
}

// Complete requests a completion operation, or in other words a refiltering
// of the current list with completions, using the current key. The
// completion list view will be updated accordingly.
func (completion entryCompletion) Complete() {
	var arg0 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntryCompletion)(completion.Native())

	C.gtk_entry_completion_complete(arg0)
}

// ComputePrefix computes the common prefix that is shared by all rows in
// @completion that start with @key. If no row matches @key, nil will be
// returned. Note that a text column must have been set for this function to
// work, see gtk_entry_completion_set_text_column() for details.
func (completion entryCompletion) ComputePrefix(key string) string {
	var arg0 *C.GtkEntryCompletion
	var arg1 *C.char

	arg0 = (*C.GtkEntryCompletion)(completion.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_entry_completion_compute_prefix(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// DeleteAction deletes the action at @index_ from @completion’s action
// list.
//
// Note that @index_ is a relative position and the position of an action
// may have changed since it was inserted.
func (completion entryCompletion) DeleteAction(index_ int) {
	var arg0 *C.GtkEntryCompletion
	var arg1 C.gint

	arg0 = (*C.GtkEntryCompletion)(completion.Native())
	arg1 = C.gint(index_)

	C.gtk_entry_completion_delete_action(arg0, arg1)
}

// CompletionPrefix: get the original text entered by the user that
// triggered the completion or nil if there’s no completion ongoing.
func (completion entryCompletion) CompletionPrefix() string {
	var arg0 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntryCompletion)(completion.Native())

	ret := C.gtk_entry_completion_get_completion_prefix(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Entry gets the entry @completion has been attached to.
func (completion entryCompletion) Entry() Widget {
	var arg0 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntryCompletion)(completion.Native())

	ret := C.gtk_entry_completion_get_entry(arg0)

	var ret0 Widget

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Widget)

	return ret0
}

// InlineCompletion returns whether the common prefix of the possible
// completions should be automatically inserted in the entry.
func (completion entryCompletion) InlineCompletion() bool {
	var arg0 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntryCompletion)(completion.Native())

	ret := C.gtk_entry_completion_get_inline_completion(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// InlineSelection returns true if inline-selection mode is turned on.
func (completion entryCompletion) InlineSelection() bool {
	var arg0 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntryCompletion)(completion.Native())

	ret := C.gtk_entry_completion_get_inline_selection(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// MinimumKeyLength returns the minimum key length as set for @completion.
func (completion entryCompletion) MinimumKeyLength() int {
	var arg0 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntryCompletion)(completion.Native())

	ret := C.gtk_entry_completion_get_minimum_key_length(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Model returns the model the EntryCompletion is using as data source.
// Returns nil if the model is unset.
func (completion entryCompletion) Model() TreeModel {
	var arg0 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntryCompletion)(completion.Native())

	ret := C.gtk_entry_completion_get_model(arg0)

	var ret0 TreeModel

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(TreeModel)

	return ret0
}

// PopupCompletion returns whether the completions should be presented in a
// popup window.
func (completion entryCompletion) PopupCompletion() bool {
	var arg0 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntryCompletion)(completion.Native())

	ret := C.gtk_entry_completion_get_popup_completion(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// PopupSetWidth returns whether the completion popup window will be resized
// to the width of the entry.
func (completion entryCompletion) PopupSetWidth() bool {
	var arg0 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntryCompletion)(completion.Native())

	ret := C.gtk_entry_completion_get_popup_set_width(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// PopupSingleMatch returns whether the completion popup window will appear
// even if there is only a single match.
func (completion entryCompletion) PopupSingleMatch() bool {
	var arg0 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntryCompletion)(completion.Native())

	ret := C.gtk_entry_completion_get_popup_single_match(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// TextColumn returns the column in the model of @completion to get strings
// from.
func (completion entryCompletion) TextColumn() int {
	var arg0 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntryCompletion)(completion.Native())

	ret := C.gtk_entry_completion_get_text_column(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// InsertActionMarkup inserts an action in @completion’s action item list at
// position @index_ with markup @markup.
func (completion entryCompletion) InsertActionMarkup(index_ int, markup string) {
	var arg0 *C.GtkEntryCompletion
	var arg1 C.gint
	var arg2 *C.gchar

	arg0 = (*C.GtkEntryCompletion)(completion.Native())
	arg1 = C.gint(index_)
	arg2 = (*C.gchar)(C.CString(markup))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_entry_completion_insert_action_markup(arg0, arg1, arg2)
}

// InsertActionText inserts an action in @completion’s action item list at
// position @index_ with text @text. If you want the action item to have
// markup, use gtk_entry_completion_insert_action_markup().
//
// Note that @index_ is a relative position in the list of actions and the
// position of an action can change when deleting a different action.
func (completion entryCompletion) InsertActionText(index_ int, text string) {
	var arg0 *C.GtkEntryCompletion
	var arg1 C.gint
	var arg2 *C.gchar

	arg0 = (*C.GtkEntryCompletion)(completion.Native())
	arg1 = C.gint(index_)
	arg2 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_entry_completion_insert_action_text(arg0, arg1, arg2)
}

// InsertPrefix requests a prefix insertion.
func (completion entryCompletion) InsertPrefix() {
	var arg0 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntryCompletion)(completion.Native())

	C.gtk_entry_completion_insert_prefix(arg0)
}

// SetInlineCompletion sets whether the common prefix of the possible
// completions should be automatically inserted in the entry.
func (completion entryCompletion) SetInlineCompletion(inlineCompletion bool) {
	var arg0 *C.GtkEntryCompletion
	var arg1 C.gboolean

	arg0 = (*C.GtkEntryCompletion)(completion.Native())
	if inlineCompletion {
		arg1 = C.TRUE
	}

	C.gtk_entry_completion_set_inline_completion(arg0, arg1)
}

// SetInlineSelection sets whether it is possible to cycle through the
// possible completions inside the entry.
func (completion entryCompletion) SetInlineSelection(inlineSelection bool) {
	var arg0 *C.GtkEntryCompletion
	var arg1 C.gboolean

	arg0 = (*C.GtkEntryCompletion)(completion.Native())
	if inlineSelection {
		arg1 = C.TRUE
	}

	C.gtk_entry_completion_set_inline_selection(arg0, arg1)
}

// SetMatchFunc sets the match function for @completion to be @func. The
// match function is used to determine if a row should or should not be in
// the completion list.
func (completion entryCompletion) SetMatchFunc(fn EntryCompletionMatchFunc) {
	var arg0 *C.GtkEntryCompletion
	var arg1 C.GtkEntryCompletionMatchFunc
	var arg2 C.gpointer
	var arg3 C.GDestroyNotify

	arg0 = (*C.GtkEntryCompletion)(completion.Native())
	arg1 = (*[0]byte)(C.gotk4_EntryCompletionMatchFunc)
	arg2 = C.gpointer(box.Assign(fn))
	arg3 = (*[0]byte)(C.callbackDelete)

	C.gtk_entry_completion_set_match_func(arg0, arg1, arg2, arg3)
}

// SetMinimumKeyLength requires the length of the search key for @completion
// to be at least @length. This is useful for long lists, where completing
// using a small key takes a lot of time and will come up with meaningless
// results anyway (ie, a too large dataset).
func (completion entryCompletion) SetMinimumKeyLength(length int) {
	var arg0 *C.GtkEntryCompletion
	var arg1 C.gint

	arg0 = (*C.GtkEntryCompletion)(completion.Native())
	arg1 = C.gint(length)

	C.gtk_entry_completion_set_minimum_key_length(arg0, arg1)
}

// SetModel sets the model for a EntryCompletion. If @completion already has
// a model set, it will remove it before setting the new model. If model is
// nil, then it will unset the model.
func (completion entryCompletion) SetModel(model TreeModel) {
	var arg0 *C.GtkEntryCompletion
	var arg1 *C.GtkTreeModel

	arg0 = (*C.GtkEntryCompletion)(completion.Native())
	arg1 = (*C.GtkTreeModel)(model.Native())

	C.gtk_entry_completion_set_model(arg0, arg1)
}

// SetPopupCompletion sets whether the completions should be presented in a
// popup window.
func (completion entryCompletion) SetPopupCompletion(popupCompletion bool) {
	var arg0 *C.GtkEntryCompletion
	var arg1 C.gboolean

	arg0 = (*C.GtkEntryCompletion)(completion.Native())
	if popupCompletion {
		arg1 = C.TRUE
	}

	C.gtk_entry_completion_set_popup_completion(arg0, arg1)
}

// SetPopupSetWidth sets whether the completion popup window will be resized
// to be the same width as the entry.
func (completion entryCompletion) SetPopupSetWidth(popupSetWidth bool) {
	var arg0 *C.GtkEntryCompletion
	var arg1 C.gboolean

	arg0 = (*C.GtkEntryCompletion)(completion.Native())
	if popupSetWidth {
		arg1 = C.TRUE
	}

	C.gtk_entry_completion_set_popup_set_width(arg0, arg1)
}

// SetPopupSingleMatch sets whether the completion popup window will appear
// even if there is only a single match. You may want to set this to false
// if you are using [inline
// completion][GtkEntryCompletion--inline-completion].
func (completion entryCompletion) SetPopupSingleMatch(popupSingleMatch bool) {
	var arg0 *C.GtkEntryCompletion
	var arg1 C.gboolean

	arg0 = (*C.GtkEntryCompletion)(completion.Native())
	if popupSingleMatch {
		arg1 = C.TRUE
	}

	C.gtk_entry_completion_set_popup_single_match(arg0, arg1)
}

// SetTextColumn: convenience function for setting up the most used case of
// this code: a completion list with just strings. This function will set up
// @completion to have a list displaying all (and just) strings in the
// completion list, and to get those strings from @column in the model of
// @completion.
//
// This functions creates and adds a CellRendererText for the selected
// column. If you need to set the text column, but don't want the cell
// renderer, use g_object_set() to set the EntryCompletion:text-column
// property directly.
func (completion entryCompletion) SetTextColumn(column int) {
	var arg0 *C.GtkEntryCompletion
	var arg1 C.gint

	arg0 = (*C.GtkEntryCompletion)(completion.Native())
	arg1 = C.gint(column)

	C.gtk_entry_completion_set_text_column(arg0, arg1)
}

// EventController is a base, low-level implementation for event controllers.
// Those react to a series of Events, and possibly trigger actions as a
// consequence of those.
type EventController interface {
	gextras.Objector

	// PropagationPhase gets the propagation phase at which @controller handles
	// events.
	PropagationPhase() PropagationPhase
	// Widget returns the Widget this controller relates to.
	Widget() Widget
	// Reset resets the @controller to a clean state. Every interaction the
	// controller did through EventController::handle-event will be dropped at
	// this point.
	Reset()
	// SetPropagationPhase sets the propagation phase at which a controller
	// handles events.
	//
	// If @phase is GTK_PHASE_NONE, no automatic event handling will be
	// performed, but other additional gesture maintenance will. In that phase,
	// the events can be managed by calling gtk_event_controller_handle_event().
	SetPropagationPhase(phase PropagationPhase)
}

// eventController implements the EventController interface.
type eventController struct {
	gextras.Objector
}

var _ EventController = (*eventController)(nil)

// WrapEventController wraps a GObject to the right type. It is
// primarily used internally.
func WrapEventController(obj *externglib.Object) EventController {
	return EventController{
		Objector: obj,
	}
}

func marshalEventController(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEventController(obj), nil
}

// PropagationPhase gets the propagation phase at which @controller handles
// events.
func (controller eventController) PropagationPhase() PropagationPhase {
	var arg0 *C.GtkEventController

	arg0 = (*C.GtkEventController)(controller.Native())

	ret := C.gtk_event_controller_get_propagation_phase(arg0)

	var ret0 PropagationPhase

	ret0 = PropagationPhase(ret)

	return ret0
}

// Widget returns the Widget this controller relates to.
func (controller eventController) Widget() Widget {
	var arg0 *C.GtkEventController

	arg0 = (*C.GtkEventController)(controller.Native())

	ret := C.gtk_event_controller_get_widget(arg0)

	var ret0 Widget

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Widget)

	return ret0
}

// Reset resets the @controller to a clean state. Every interaction the
// controller did through EventController::handle-event will be dropped at
// this point.
func (controller eventController) Reset() {
	var arg0 *C.GtkEventController

	arg0 = (*C.GtkEventController)(controller.Native())

	C.gtk_event_controller_reset(arg0)
}

// SetPropagationPhase sets the propagation phase at which a controller
// handles events.
//
// If @phase is GTK_PHASE_NONE, no automatic event handling will be
// performed, but other additional gesture maintenance will. In that phase,
// the events can be managed by calling gtk_event_controller_handle_event().
func (controller eventController) SetPropagationPhase(phase PropagationPhase) {
	var arg0 *C.GtkEventController
	var arg1 C.GtkPropagationPhase

	arg0 = (*C.GtkEventController)(controller.Native())
	arg1 = (C.GtkPropagationPhase)(phase)

	C.gtk_event_controller_set_propagation_phase(arg0, arg1)
}

// EventControllerKey is an event controller meant for situations where you need
// access to key events.
//
// This object was added in 3.24.
type EventControllerKey interface {
	EventController

	Forward(widget Widget) bool

	Group() uint
	// ImContext gets the IM context of a key controller.
	ImContext() IMContext

	SetImContext(imContext IMContext)
}

// eventControllerKey implements the EventControllerKey interface.
type eventControllerKey struct {
	EventController
}

var _ EventControllerKey = (*eventControllerKey)(nil)

// WrapEventControllerKey wraps a GObject to the right type. It is
// primarily used internally.
func WrapEventControllerKey(obj *externglib.Object) EventControllerKey {
	return EventControllerKey{
		EventController: WrapEventController(obj),
	}
}

func marshalEventControllerKey(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEventControllerKey(obj), nil
}

// NewEventControllerKey constructs a class EventControllerKey.
func NewEventControllerKey(widget Widget) EventControllerKey {
	var arg1 *C.GtkWidget

	arg1 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_event_controller_key_new(arg1)

	var ret0 EventControllerKey

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(EventControllerKey)

	return ret0
}

func (controller eventControllerKey) Forward(widget Widget) bool {
	var arg0 *C.GtkEventControllerKey
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkEventControllerKey)(controller.Native())
	arg1 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_event_controller_key_forward(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

func (controller eventControllerKey) Group() uint {
	var arg0 *C.GtkEventControllerKey

	arg0 = (*C.GtkEventControllerKey)(controller.Native())

	ret := C.gtk_event_controller_key_get_group(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// ImContext gets the IM context of a key controller.
func (controller eventControllerKey) ImContext() IMContext {
	var arg0 *C.GtkEventControllerKey

	arg0 = (*C.GtkEventControllerKey)(controller.Native())

	ret := C.gtk_event_controller_key_get_im_context(arg0)

	var ret0 IMContext

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(IMContext)

	return ret0
}

func (controller eventControllerKey) SetImContext(imContext IMContext) {
	var arg0 *C.GtkEventControllerKey
	var arg1 *C.GtkIMContext

	arg0 = (*C.GtkEventControllerKey)(controller.Native())
	arg1 = (*C.GtkIMContext)(imContext.Native())

	C.gtk_event_controller_key_set_im_context(arg0, arg1)
}

// EventControllerMotion is an event controller meant for situations where you
// need to track the position of the pointer.
//
// This object was added in 3.24.
type EventControllerMotion interface {
	EventController
}

// eventControllerMotion implements the EventControllerMotion interface.
type eventControllerMotion struct {
	EventController
}

var _ EventControllerMotion = (*eventControllerMotion)(nil)

// WrapEventControllerMotion wraps a GObject to the right type. It is
// primarily used internally.
func WrapEventControllerMotion(obj *externglib.Object) EventControllerMotion {
	return EventControllerMotion{
		EventController: WrapEventController(obj),
	}
}

func marshalEventControllerMotion(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEventControllerMotion(obj), nil
}

// NewEventControllerMotion constructs a class EventControllerMotion.
func NewEventControllerMotion(widget Widget) EventControllerMotion {
	var arg1 *C.GtkWidget

	arg1 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_event_controller_motion_new(arg1)

	var ret0 EventControllerMotion

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(EventControllerMotion)

	return ret0
}

// EventControllerScroll is an event controller meant to handle scroll events
// from mice and touchpads. It is capable of handling both discrete and
// continuous scroll events, abstracting them both on the
// EventControllerScroll::scroll signal (deltas in the discrete case are
// multiples of 1).
//
// In the case of continuous scroll events, EventControllerScroll encloses all
// EventControllerScroll::scroll events between two
// EventControllerScroll::scroll-begin and EventControllerScroll::scroll-end
// signals.
//
// The behavior of the event controller can be modified by the flags given at
// creation time, or modified at a later point through
// gtk_event_controller_scroll_set_flags() (e.g. because the scrolling
// conditions of the widget changed).
//
// The controller can be set up to emit motion for either/both vertical and
// horizontal scroll events through K_EVENT_CONTROLLER_SCROLL_VERTICAL,
// K_EVENT_CONTROLLER_SCROLL_HORIZONTAL and K_EVENT_CONTROLLER_SCROLL_BOTH. If
// any axis is disabled, the respective EventControllerScroll::scroll delta will
// be 0. Vertical scroll events will be translated to horizontal motion for the
// devices incapable of horizontal scrolling.
//
// The event controller can also be forced to emit discrete events on all
// devices through K_EVENT_CONTROLLER_SCROLL_DISCRETE. This can be used to
// implement discrete actions triggered through scroll events (e.g. switching
// across combobox options).
//
// The K_EVENT_CONTROLLER_SCROLL_KINETIC flag toggles the emission of the
// EventControllerScroll::decelerate signal, emitted at the end of scrolling
// with two X/Y velocity arguments that are consistent with the motion that was
// received.
//
// This object was added in 3.24.
type EventControllerScroll interface {
	EventController

	// Flags gets the flags conditioning the scroll controller behavior.
	Flags() EventControllerScrollFlags
	// SetFlags sets the flags conditioning scroll controller behavior.
	SetFlags(flags EventControllerScrollFlags)
}

// eventControllerScroll implements the EventControllerScroll interface.
type eventControllerScroll struct {
	EventController
}

var _ EventControllerScroll = (*eventControllerScroll)(nil)

// WrapEventControllerScroll wraps a GObject to the right type. It is
// primarily used internally.
func WrapEventControllerScroll(obj *externglib.Object) EventControllerScroll {
	return EventControllerScroll{
		EventController: WrapEventController(obj),
	}
}

func marshalEventControllerScroll(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEventControllerScroll(obj), nil
}

// NewEventControllerScroll constructs a class EventControllerScroll.
func NewEventControllerScroll(widget Widget, flags EventControllerScrollFlags) EventControllerScroll {
	var arg1 *C.GtkWidget
	var arg2 C.GtkEventControllerScrollFlags

	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = (C.GtkEventControllerScrollFlags)(flags)

	ret := C.gtk_event_controller_scroll_new(arg1, arg2)

	var ret0 EventControllerScroll

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(EventControllerScroll)

	return ret0
}

// Flags gets the flags conditioning the scroll controller behavior.
func (controller eventControllerScroll) Flags() EventControllerScrollFlags {
	var arg0 *C.GtkEventControllerScroll

	arg0 = (*C.GtkEventControllerScroll)(controller.Native())

	ret := C.gtk_event_controller_scroll_get_flags(arg0)

	var ret0 EventControllerScrollFlags

	ret0 = EventControllerScrollFlags(ret)

	return ret0
}

// SetFlags sets the flags conditioning scroll controller behavior.
func (controller eventControllerScroll) SetFlags(flags EventControllerScrollFlags) {
	var arg0 *C.GtkEventControllerScroll
	var arg1 C.GtkEventControllerScrollFlags

	arg0 = (*C.GtkEventControllerScroll)(controller.Native())
	arg1 = (C.GtkEventControllerScrollFlags)(flags)

	C.gtk_event_controller_scroll_set_flags(arg0, arg1)
}

// FileChooserNative is an abstraction of a dialog box suitable for use with
// “File/Open” or “File/Save as” commands. By default, this just uses a
// FileChooserDialog to implement the actual dialog. However, on certain
// platforms, such as Windows and macOS, the native platform file chooser is
// used instead. When the application is running in a sandboxed environment
// without direct filesystem access (such as Flatpak), FileChooserNative may
// call the proper APIs (portals) to let the user choose a file and make it
// available to the application.
//
// While the API of FileChooserNative closely mirrors FileChooserDialog, the
// main difference is that there is no access to any Window or Widget for the
// dialog. This is required, as there may not be one in the case of a platform
// native dialog. Showing, hiding and running the dialog is handled by the
// NativeDialog functions.
//
//
// Typical usage
//
// In the simplest of cases, you can the following code to use FileChooserDialog
// to select a file for opening:
//
//    GtkFileChooserNative *native;
//    GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
//    gint res;
//
//    native = gtk_file_chooser_native_new ("Open File",
//                                          parent_window,
//                                          action,
//                                          "_Open",
//                                          "_Cancel");
//
//    res = gtk_native_dialog_run (GTK_NATIVE_DIALOG (native));
//    if (res == GTK_RESPONSE_ACCEPT)
//      {
//        char *filename;
//        GtkFileChooser *chooser = GTK_FILE_CHOOSER (native);
//        filename = gtk_file_chooser_get_filename (chooser);
//        open_file (filename);
//        g_free (filename);
//      }
//
//    g_object_unref (native);
//
// To use a dialog for saving, you can use this:
//
//    GtkFileChooserNative *native;
//    GtkFileChooser *chooser;
//    GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_SAVE;
//    gint res;
//
//    native = gtk_file_chooser_native_new ("Save File",
//                                          parent_window,
//                                          action,
//                                          "_Save",
//                                          "_Cancel");
//    chooser = GTK_FILE_CHOOSER (native);
//
//    gtk_file_chooser_set_do_overwrite_confirmation (chooser, TRUE);
//
//    if (user_edited_a_new_document)
//      gtk_file_chooser_set_current_name (chooser,
//                                         _("Untitled document"));
//    else
//      gtk_file_chooser_set_filename (chooser,
//                                     existing_filename);
//
//    res = gtk_native_dialog_run (GTK_NATIVE_DIALOG (native));
//    if (res == GTK_RESPONSE_ACCEPT)
//      {
//        char *filename;
//
//        filename = gtk_file_chooser_get_filename (chooser);
//        save_to_file (filename);
//        g_free (filename);
//      }
//
//    g_object_unref (native);
//
// For more information on how to best set up a file dialog, see
// FileChooserDialog.
//
//
// Response Codes
//
// FileChooserNative inherits from NativeDialog, which means it will return
// K_RESPONSE_ACCEPT if the user accepted, and K_RESPONSE_CANCEL if he pressed
// cancel. It can also return K_RESPONSE_DELETE_EVENT if the window was
// unexpectedly closed.
//
// Differences from FileChooserDialog ##
// {#gtkfilechooserdialognative-differences}
//
// There are a few things in the GtkFileChooser API that are not possible to use
// with FileChooserNative, as such use would prohibit the use of a native
// dialog.
//
// There is no support for the signals that are emitted when the user navigates
// in the dialog, including: * FileChooser::current-folder-changed *
// FileChooser::selection-changed * FileChooser::file-activated *
// FileChooser::confirm-overwrite
//
// You can also not use the methods that directly control user navigation: *
// gtk_file_chooser_unselect_filename() * gtk_file_chooser_select_all() *
// gtk_file_chooser_unselect_all()
//
// If you need any of the above you will have to use FileChooserDialog directly.
//
// No operations that change the the dialog work while the dialog is visible.
// Set all the properties that are required before showing the dialog.
//
//
// Win32 details
//
// On windows the IFileDialog implementation (added in Windows Vista) is used.
// It supports many of the features that FileChooserDialog does, but there are
// some things it does not handle:
//
// * Extra widgets added with gtk_file_chooser_set_extra_widget().
//
// * Use of custom previews by connecting to FileChooser::update-preview.
//
// * Any FileFilter added using a mimetype or custom filter.
//
// If any of these features are used the regular FileChooserDialog will be used
// in place of the native one.
//
//
// Portal details
//
// When the org.freedesktop.portal.FileChooser portal is available on the
// session bus, it is used to bring up an out-of-process file chooser. Depending
// on the kind of session the application is running in, this may or may not be
// a GTK+ file chooser. In this situation, the following things are not
// supported and will be silently ignored:
//
// * Extra widgets added with gtk_file_chooser_set_extra_widget().
//
// * Use of custom previews by connecting to FileChooser::update-preview.
//
// * Any FileFilter added with a custom filter.
//
// macOS details
//
// On macOS the NSSavePanel and NSOpenPanel classes are used to provide native
// file chooser dialogs. Some features provided by FileChooserDialog are not
// supported:
//
// * Extra widgets added with gtk_file_chooser_set_extra_widget(), unless the
// widget is an instance of GtkLabel, in which case the label text will be used
// to set the NSSavePanel message instance property.
//
// * Use of custom previews by connecting to FileChooser::update-preview.
//
// * Any FileFilter added with a custom filter.
//
// * Shortcut folders.
type FileChooserNative interface {
	NativeDialog
	FileChooser

	// AcceptLabel retrieves the custom label text for the accept button.
	AcceptLabel() string
	// CancelLabel retrieves the custom label text for the cancel button.
	CancelLabel() string
	// SetAcceptLabel sets the custom label text for the accept button.
	//
	// If characters in @label are preceded by an underscore, they are
	// underlined. If you need a literal underscore character in a label, use
	// “__” (two underscores). The first underlined character represents a
	// keyboard accelerator called a mnemonic. Pressing Alt and that key
	// activates the button.
	SetAcceptLabel(acceptLabel string)
	// SetCancelLabel sets the custom label text for the cancel button.
	//
	// If characters in @label are preceded by an underscore, they are
	// underlined. If you need a literal underscore character in a label, use
	// “__” (two underscores). The first underlined character represents a
	// keyboard accelerator called a mnemonic. Pressing Alt and that key
	// activates the button.
	SetCancelLabel(cancelLabel string)
}

// fileChooserNative implements the FileChooserNative interface.
type fileChooserNative struct {
	NativeDialog
	FileChooser
}

var _ FileChooserNative = (*fileChooserNative)(nil)

// WrapFileChooserNative wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileChooserNative(obj *externglib.Object) FileChooserNative {
	return FileChooserNative{
		NativeDialog: WrapNativeDialog(obj),
		FileChooser:  WrapFileChooser(obj),
	}
}

func marshalFileChooserNative(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileChooserNative(obj), nil
}

// NewFileChooserNative constructs a class FileChooserNative.
func NewFileChooserNative(title string, parent Window, action FileChooserAction, acceptLabel string, cancelLabel string) FileChooserNative {
	var arg1 *C.gchar
	var arg2 *C.GtkWindow
	var arg3 C.GtkFileChooserAction
	var arg4 *C.gchar
	var arg5 *C.gchar

	arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GtkWindow)(parent.Native())
	arg3 = (C.GtkFileChooserAction)(action)
	arg4 = (*C.gchar)(C.CString(acceptLabel))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.gchar)(C.CString(cancelLabel))
	defer C.free(unsafe.Pointer(arg5))

	ret := C.gtk_file_chooser_native_new(arg1, arg2, arg3, arg4, arg5)

	var ret0 FileChooserNative

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(FileChooserNative)

	return ret0
}

// AcceptLabel retrieves the custom label text for the accept button.
func (self fileChooserNative) AcceptLabel() string {
	var arg0 *C.GtkFileChooserNative

	arg0 = (*C.GtkFileChooserNative)(self.Native())

	ret := C.gtk_file_chooser_native_get_accept_label(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// CancelLabel retrieves the custom label text for the cancel button.
func (self fileChooserNative) CancelLabel() string {
	var arg0 *C.GtkFileChooserNative

	arg0 = (*C.GtkFileChooserNative)(self.Native())

	ret := C.gtk_file_chooser_native_get_cancel_label(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// SetAcceptLabel sets the custom label text for the accept button.
//
// If characters in @label are preceded by an underscore, they are
// underlined. If you need a literal underscore character in a label, use
// “__” (two underscores). The first underlined character represents a
// keyboard accelerator called a mnemonic. Pressing Alt and that key
// activates the button.
func (self fileChooserNative) SetAcceptLabel(acceptLabel string) {
	var arg0 *C.GtkFileChooserNative
	var arg1 *C.char

	arg0 = (*C.GtkFileChooserNative)(self.Native())
	arg1 = (*C.gchar)(C.CString(acceptLabel))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_file_chooser_native_set_accept_label(arg0, arg1)
}

// SetCancelLabel sets the custom label text for the cancel button.
//
// If characters in @label are preceded by an underscore, they are
// underlined. If you need a literal underscore character in a label, use
// “__” (two underscores). The first underlined character represents a
// keyboard accelerator called a mnemonic. Pressing Alt and that key
// activates the button.
func (self fileChooserNative) SetCancelLabel(cancelLabel string) {
	var arg0 *C.GtkFileChooserNative
	var arg1 *C.char

	arg0 = (*C.GtkFileChooserNative)(self.Native())
	arg1 = (*C.gchar)(C.CString(cancelLabel))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_file_chooser_native_set_cancel_label(arg0, arg1)
}

// FileFilter: a GtkFileFilter can be used to restrict the files being shown in
// a FileChooser. Files can be filtered based on their name (with
// gtk_file_filter_add_pattern()), on their mime type (with
// gtk_file_filter_add_mime_type()), or by a custom filter function (with
// gtk_file_filter_add_custom()).
//
// Filtering by mime types handles aliasing and subclassing of mime types; e.g.
// a filter for text/plain also matches a file with mime type application/rtf,
// since application/rtf is a subclass of text/plain. Note that FileFilter
// allows wildcards for the subtype of a mime type, so you can e.g. filter for
// image/\*.
//
// Normally, filters are used by adding them to a FileChooser, see
// gtk_file_chooser_add_filter(), but it is also possible to manually use a
// filter on a file with gtk_file_filter_filter().
//
//
// GtkFileFilter as GtkBuildable
//
// The GtkFileFilter implementation of the GtkBuildable interface supports
// adding rules using the <mime-types>, <patterns> and <applications> elements
// and listing the rules within. Specifying a <mime-type> or <pattern> has the
// same effect as as calling gtk_file_filter_add_mime_type() or
// gtk_file_filter_add_pattern().
//
// An example of a UI definition fragment specifying GtkFileFilter rules:
//
//    <object class="GtkFileFilter">
//      <mime-types>
//        <mime-type>text/plain</mime-type>
//        <mime-type>image/ *</mime-type>
//      </mime-types>
//      <patterns>
//        <pattern>*.txt</pattern>
//        <pattern>*.png</pattern>
//      </patterns>
//    </object>
type FileFilter interface {
	gextras.Objector
	Buildable

	// AddCustom adds rule to a filter that allows files based on a custom
	// callback function. The bitfield @needed which is passed in provides
	// information about what sorts of information that the filter function
	// needs; this allows GTK+ to avoid retrieving expensive information when it
	// isn’t needed by the filter.
	AddCustom(needed FileFilterFlags, fn FileFilterFunc)
	// AddMIMEType adds a rule allowing a given mime type to @filter.
	AddMIMEType(mimeType string)
	// AddPattern adds a rule allowing a shell style glob to a filter.
	AddPattern(pattern string)
	// AddPixbufFormats adds a rule allowing image files in the formats
	// supported by GdkPixbuf.
	AddPixbufFormats()
	// Filter tests whether a file should be displayed according to @filter. The
	// FileFilterInfo @filter_info should include the fields returned from
	// gtk_file_filter_get_needed().
	//
	// This function will not typically be used by applications; it is intended
	// principally for use in the implementation of FileChooser.
	Filter(filterInfo *FileFilterInfo) bool
	// Name gets the human-readable name for the filter. See
	// gtk_file_filter_set_name().
	Name() string
	// Needed gets the fields that need to be filled in for the FileFilterInfo
	// passed to gtk_file_filter_filter()
	//
	// This function will not typically be used by applications; it is intended
	// principally for use in the implementation of FileChooser.
	Needed() FileFilterFlags
	// SetName sets the human-readable name of the filter; this is the string
	// that will be displayed in the file selector user interface if there is a
	// selectable list of filters.
	SetName(name string)
	// ToGVariant: serialize a file filter to an a{sv} variant.
	ToGVariant() *glib.Variant
}

// fileFilter implements the FileFilter interface.
type fileFilter struct {
	gextras.Objector
	Buildable
}

var _ FileFilter = (*fileFilter)(nil)

// WrapFileFilter wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileFilter(obj *externglib.Object) FileFilter {
	return FileFilter{
		Objector:  obj,
		Buildable: WrapBuildable(obj),
	}
}

func marshalFileFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileFilter(obj), nil
}

// NewFileFilter constructs a class FileFilter.
func NewFileFilter() FileFilter {

	ret := C.gtk_file_filter_new()

	var ret0 FileFilter

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(FileFilter)

	return ret0
}

// NewFileFilterFromGVariant constructs a class FileFilter.
func NewFileFilterFromGVariant(variant *glib.Variant) FileFilter {
	var arg1 *C.GVariant

	arg1 = (*C.GVariant)(variant.Native())

	ret := C.gtk_file_filter_new_from_gvariant(arg1)

	var ret0 FileFilter

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(FileFilter)

	return ret0
}

// AddCustom adds rule to a filter that allows files based on a custom
// callback function. The bitfield @needed which is passed in provides
// information about what sorts of information that the filter function
// needs; this allows GTK+ to avoid retrieving expensive information when it
// isn’t needed by the filter.
func (filter fileFilter) AddCustom(needed FileFilterFlags, fn FileFilterFunc) {
	var arg0 *C.GtkFileFilter
	var arg1 C.GtkFileFilterFlags
	var arg2 C.GtkFileFilterFunc
	var arg3 C.gpointer
	var arg4 C.GDestroyNotify

	arg0 = (*C.GtkFileFilter)(filter.Native())
	arg1 = (C.GtkFileFilterFlags)(needed)
	arg2 = (*[0]byte)(C.gotk4_FileFilterFunc)
	arg3 = C.gpointer(box.Assign(fn))
	arg4 = (*[0]byte)(C.callbackDelete)

	C.gtk_file_filter_add_custom(arg0, arg1, arg2, arg3, arg4)
}

// AddMIMEType adds a rule allowing a given mime type to @filter.
func (filter fileFilter) AddMIMEType(mimeType string) {
	var arg0 *C.GtkFileFilter
	var arg1 *C.gchar

	arg0 = (*C.GtkFileFilter)(filter.Native())
	arg1 = (*C.gchar)(C.CString(mimeType))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_file_filter_add_mime_type(arg0, arg1)
}

// AddPattern adds a rule allowing a shell style glob to a filter.
func (filter fileFilter) AddPattern(pattern string) {
	var arg0 *C.GtkFileFilter
	var arg1 *C.gchar

	arg0 = (*C.GtkFileFilter)(filter.Native())
	arg1 = (*C.gchar)(C.CString(pattern))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_file_filter_add_pattern(arg0, arg1)
}

// AddPixbufFormats adds a rule allowing image files in the formats
// supported by GdkPixbuf.
func (filter fileFilter) AddPixbufFormats() {
	var arg0 *C.GtkFileFilter

	arg0 = (*C.GtkFileFilter)(filter.Native())

	C.gtk_file_filter_add_pixbuf_formats(arg0)
}

// Filter tests whether a file should be displayed according to @filter. The
// FileFilterInfo @filter_info should include the fields returned from
// gtk_file_filter_get_needed().
//
// This function will not typically be used by applications; it is intended
// principally for use in the implementation of FileChooser.
func (filter fileFilter) Filter(filterInfo *FileFilterInfo) bool {
	var arg0 *C.GtkFileFilter
	var arg1 *C.GtkFileFilterInfo

	arg0 = (*C.GtkFileFilter)(filter.Native())
	arg1 = (*C.GtkFileFilterInfo)(filterInfo.Native())

	ret := C.gtk_file_filter_filter(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Name gets the human-readable name for the filter. See
// gtk_file_filter_set_name().
func (filter fileFilter) Name() string {
	var arg0 *C.GtkFileFilter

	arg0 = (*C.GtkFileFilter)(filter.Native())

	ret := C.gtk_file_filter_get_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Needed gets the fields that need to be filled in for the FileFilterInfo
// passed to gtk_file_filter_filter()
//
// This function will not typically be used by applications; it is intended
// principally for use in the implementation of FileChooser.
func (filter fileFilter) Needed() FileFilterFlags {
	var arg0 *C.GtkFileFilter

	arg0 = (*C.GtkFileFilter)(filter.Native())

	ret := C.gtk_file_filter_get_needed(arg0)

	var ret0 FileFilterFlags

	ret0 = FileFilterFlags(ret)

	return ret0
}

// SetName sets the human-readable name of the filter; this is the string
// that will be displayed in the file selector user interface if there is a
// selectable list of filters.
func (filter fileFilter) SetName(name string) {
	var arg0 *C.GtkFileFilter
	var arg1 *C.gchar

	arg0 = (*C.GtkFileFilter)(filter.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_file_filter_set_name(arg0, arg1)
}

// ToGVariant: serialize a file filter to an a{sv} variant.
func (filter fileFilter) ToGVariant() *glib.Variant {
	var arg0 *C.GtkFileFilter

	arg0 = (*C.GtkFileFilter)(filter.Native())

	ret := C.gtk_file_filter_to_gvariant(arg0)

	var ret0 *glib.Variant

	{
		ret0 = glib.WrapVariant(unsafe.Pointer(ret))
	}

	return ret0
}

// Gesture is the base object for gesture recognition, although this object is
// quite generalized to serve as a base for multi-touch gestures, it is suitable
// to implement single-touch and pointer-based gestures (using the special nil
// EventSequence value for these).
//
// The number of touches that a Gesture need to be recognized is controlled by
// the Gesture:n-points property, if a gesture is keeping track of less or more
// than that number of sequences, it won't check wether the gesture is
// recognized.
//
// As soon as the gesture has the expected number of touches, the gesture will
// run the Gesture::check signal regularly on input events until the gesture is
// recognized, the criteria to consider a gesture as "recognized" is left to
// Gesture subclasses.
//
// A recognized gesture will then emit the following signals: - Gesture::begin
// when the gesture is recognized. - A number of Gesture::update, whenever an
// input event is processed. - Gesture::end when the gesture is no longer
// recognized.
//
//
// Event propagation
//
// In order to receive events, a gesture needs to either set a propagation phase
// through gtk_event_controller_set_propagation_phase(), or feed those manually
// through gtk_event_controller_handle_event().
//
// In the capture phase, events are propagated from the toplevel down to the
// target widget, and gestures that are attached to containers above the widget
// get a chance to interact with the event before it reaches the target.
//
// After the capture phase, GTK+ emits the traditional
// Widget::button-press-event, Widget::button-release-event,
// Widget::touch-event, etc signals. Gestures with the GTK_PHASE_TARGET phase
// are fed events from the default Widget::event handlers.
//
// In the bubble phase, events are propagated up from the target widget to the
// toplevel, and gestures that are attached to containers above the widget get a
// chance to interact with events that have not been handled yet.
//
//
// States of a sequence
//
// Whenever input interaction happens, a single event may trigger a cascade of
// Gestures, both across the parents of the widget receiving the event and in
// parallel within an individual widget. It is a responsibility of the widgets
// using those gestures to set the state of touch sequences accordingly in order
// to enable cooperation of gestures around the EventSequences triggering those.
//
// Within a widget, gestures can be grouped through gtk_gesture_group(), grouped
// gestures synchronize the state of sequences, so calling
// gtk_gesture_set_sequence_state() on one will effectively propagate the state
// throughout the group.
//
// By default, all sequences start out in the K_EVENT_SEQUENCE_NONE state,
// sequences in this state trigger the gesture event handler, but event
// propagation will continue unstopped by gestures.
//
// If a sequence enters into the K_EVENT_SEQUENCE_DENIED state, the gesture
// group will effectively ignore the sequence, letting events go unstopped
// through the gesture, but the "slot" will still remain occupied while the
// touch is active.
//
// If a sequence enters in the K_EVENT_SEQUENCE_CLAIMED state, the gesture group
// will grab all interaction on the sequence, by: - Setting the same sequence to
// K_EVENT_SEQUENCE_DENIED on every other gesture group within the widget, and
// every gesture on parent widgets in the propagation chain. - calling
// Gesture::cancel on every gesture in widgets underneath in the propagation
// chain. - Stopping event propagation after the gesture group handles the
// event.
//
// Note: if a sequence is set early to K_EVENT_SEQUENCE_CLAIMED on
// K_TOUCH_BEGIN/K_BUTTON_PRESS (so those events are captured before reaching
// the event widget, this implies K_PHASE_CAPTURE), one similar event will
// emulated if the sequence changes to K_EVENT_SEQUENCE_DENIED. This way event
// coherence is preserved before event propagation is unstopped again.
//
// Sequence states can't be changed freely, see gtk_gesture_set_sequence_state()
// to know about the possible lifetimes of a EventSequence.
//
//
// Touchpad gestures
//
// On the platforms that support it, Gesture will handle transparently touchpad
// gesture events. The only precautions users of Gesture should do to enable
// this support are: - Enabling GDK_TOUCHPAD_GESTURE_MASK on their Windows - If
// the gesture has GTK_PHASE_NONE, ensuring events of type GDK_TOUCHPAD_SWIPE
// and GDK_TOUCHPAD_PINCH are handled by the Gesture
type Gesture interface {
	EventController

	// BoundingBox: if there are touch sequences being currently handled by
	// @gesture, this function returns true and fills in @rect with the bounding
	// box containing all active touches. Otherwise, false will be returned.
	//
	// Note: This function will yield unexpected results on touchpad gestures.
	// Since there is no correlation between physical and pixel distances, these
	// will look as if constrained in an infinitely small area, @rect width and
	// height will thus be 0 regardless of the number of touchpoints.
	BoundingBox() (rect gdk.Rectangle, ok bool)
	// BoundingBoxCenter: if there are touch sequences being currently handled
	// by @gesture, this function returns true and fills in @x and @y with the
	// center of the bounding box containing all active touches. Otherwise,
	// false will be returned.
	BoundingBoxCenter() (x float64, y float64, ok bool)
	// Device returns the master Device that is currently operating on @gesture,
	// or nil if the gesture is not being interacted.
	Device() gdk.Device
	// GetGroup returns all gestures in the group of @gesture
	GetGroup() *glib.List
	// LastUpdatedSequence returns the EventSequence that was last updated on
	// @gesture.
	LastUpdatedSequence() *gdk.EventSequence
	// Point: if @sequence is currently being interpreted by @gesture, this
	// function returns true and fills in @x and @y with the last coordinates
	// stored for that event sequence. The coordinates are always relative to
	// the widget allocation.
	Point(sequence *gdk.EventSequence) (x float64, y float64, ok bool)
	// SequenceState returns the @sequence state, as seen by @gesture.
	SequenceState(sequence *gdk.EventSequence) EventSequenceState
	// Sequences returns the list of EventSequences currently being interpreted
	// by @gesture.
	Sequences() *glib.List
	// Window returns the user-defined window that receives the events handled
	// by @gesture. See gtk_gesture_set_window() for more information.
	Window() gdk.Window
	// Group adds @gesture to the same group than @group_gesture. Gestures are
	// by default isolated in their own groups.
	//
	// When gestures are grouped, the state of EventSequences is kept in sync
	// for all of those, so calling gtk_gesture_set_sequence_state(), on one
	// will transfer the same value to the others.
	//
	// Groups also perform an "implicit grabbing" of sequences, if a
	// EventSequence state is set to K_EVENT_SEQUENCE_CLAIMED on one group,
	// every other gesture group attached to the same Widget will switch the
	// state for that sequence to K_EVENT_SEQUENCE_DENIED.
	Group(gesture Gesture)
	// HandlesSequence returns true if @gesture is currently handling events
	// corresponding to @sequence.
	HandlesSequence(sequence *gdk.EventSequence) bool
	// IsActive returns true if the gesture is currently active. A gesture is
	// active meanwhile there are touch sequences interacting with it.
	IsActive() bool
	// IsGroupedWith returns true if both gestures pertain to the same group.
	IsGroupedWith(other Gesture) bool
	// IsRecognized returns true if the gesture is currently recognized. A
	// gesture is recognized if there are as many interacting touch sequences as
	// required by @gesture, and Gesture::check returned true for the sequences
	// being currently interpreted.
	IsRecognized() bool
	// SetSequenceState sets the state of @sequence in @gesture. Sequences start
	// in state K_EVENT_SEQUENCE_NONE, and whenever they change state, they can
	// never go back to that state. Likewise, sequences in state
	// K_EVENT_SEQUENCE_DENIED cannot turn back to a not denied state. With
	// these rules, the lifetime of an event sequence is constrained to the next
	// four:
	//
	// * None * None → Denied * None → Claimed * None → Claimed → Denied
	//
	// Note: Due to event handling ordering, it may be unsafe to set the state
	// on another gesture within a Gesture::begin signal handler, as the
	// callback might be executed before the other gesture knows about the
	// sequence. A safe way to perform this could be:
	//
	//    static void
	//    first_gesture_begin_cb (GtkGesture       *first_gesture,
	//                            GdkEventSequence *sequence,
	//                            gpointer          user_data)
	//    {
	//      gtk_gesture_set_sequence_state (first_gesture, sequence, GTK_EVENT_SEQUENCE_CLAIMED);
	//      gtk_gesture_set_sequence_state (second_gesture, sequence, GTK_EVENT_SEQUENCE_DENIED);
	//    }
	//
	//    static void
	//    second_gesture_begin_cb (GtkGesture       *second_gesture,
	//                             GdkEventSequence *sequence,
	//                             gpointer          user_data)
	//    {
	//      if (gtk_gesture_get_sequence_state (first_gesture, sequence) == GTK_EVENT_SEQUENCE_CLAIMED)
	//        gtk_gesture_set_sequence_state (second_gesture, sequence, GTK_EVENT_SEQUENCE_DENIED);
	//    }
	//
	// If both gestures are in the same group, just set the state on the gesture
	// emitting the event, the sequence will be already be initialized to the
	// group's global state when the second gesture processes the event.
	SetSequenceState(sequence *gdk.EventSequence, state EventSequenceState) bool
	// SetState sets the state of all sequences that @gesture is currently
	// interacting with. See gtk_gesture_set_sequence_state() for more details
	// on sequence states.
	SetState(state EventSequenceState) bool
	// SetWindow sets a specific window to receive events about, so @gesture
	// will effectively handle only events targeting @window, or a child of it.
	// @window must pertain to gtk_event_controller_get_widget().
	SetWindow(window gdk.Window)
	// Ungroup separates @gesture into an isolated group.
	Ungroup()
}

// gesture implements the Gesture interface.
type gesture struct {
	EventController
}

var _ Gesture = (*gesture)(nil)

// WrapGesture wraps a GObject to the right type. It is
// primarily used internally.
func WrapGesture(obj *externglib.Object) Gesture {
	return Gesture{
		EventController: WrapEventController(obj),
	}
}

func marshalGesture(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGesture(obj), nil
}

// BoundingBox: if there are touch sequences being currently handled by
// @gesture, this function returns true and fills in @rect with the bounding
// box containing all active touches. Otherwise, false will be returned.
//
// Note: This function will yield unexpected results on touchpad gestures.
// Since there is no correlation between physical and pixel distances, these
// will look as if constrained in an infinitely small area, @rect width and
// height will thus be 0 regardless of the number of touchpoints.
func (gesture gesture) BoundingBox() (rect gdk.Rectangle, ok bool) {
	var arg0 *C.GtkGesture
	var arg1 *C.GdkRectangle // out

	arg0 = (*C.GtkGesture)(gesture.Native())

	ret := C.gtk_gesture_get_bounding_box(arg0, &arg1)

	var ret0 *gdk.Rectangle
	var ret1 bool

	{
		ret0 = gdk.WrapRectangle(unsafe.Pointer(arg1))
	}

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// BoundingBoxCenter: if there are touch sequences being currently handled
// by @gesture, this function returns true and fills in @x and @y with the
// center of the bounding box containing all active touches. Otherwise,
// false will be returned.
func (gesture gesture) BoundingBoxCenter() (x float64, y float64, ok bool) {
	var arg0 *C.GtkGesture
	var arg1 *C.gdouble // out
	var arg2 *C.gdouble // out

	arg0 = (*C.GtkGesture)(gesture.Native())

	ret := C.gtk_gesture_get_bounding_box_center(arg0, &arg1, &arg2)

	var ret0 float64
	var ret1 float64
	var ret2 bool

	ret0 = float64(arg1)

	ret1 = float64(arg2)

	ret2 = C.BOOL(ret) != 0

	return ret0, ret1, ret2
}

// Device returns the master Device that is currently operating on @gesture,
// or nil if the gesture is not being interacted.
func (gesture gesture) Device() gdk.Device {
	var arg0 *C.GtkGesture

	arg0 = (*C.GtkGesture)(gesture.Native())

	ret := C.gtk_gesture_get_device(arg0)

	var ret0 gdk.Device

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gdk.Device)

	return ret0
}

// GetGroup returns all gestures in the group of @gesture
func (gesture gesture) GetGroup() *glib.List {
	var arg0 *C.GtkGesture

	arg0 = (*C.GtkGesture)(gesture.Native())

	ret := C.gtk_gesture_get_group(arg0)

	var ret0 *glib.List

	{
		ret0 = glib.WrapList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.List) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// LastUpdatedSequence returns the EventSequence that was last updated on
// @gesture.
func (gesture gesture) LastUpdatedSequence() *gdk.EventSequence {
	var arg0 *C.GtkGesture

	arg0 = (*C.GtkGesture)(gesture.Native())

	ret := C.gtk_gesture_get_last_updated_sequence(arg0)

	var ret0 *gdk.EventSequence

	{
		ret0 = gdk.WrapEventSequence(unsafe.Pointer(ret))
	}

	return ret0
}

// Point: if @sequence is currently being interpreted by @gesture, this
// function returns true and fills in @x and @y with the last coordinates
// stored for that event sequence. The coordinates are always relative to
// the widget allocation.
func (gesture gesture) Point(sequence *gdk.EventSequence) (x float64, y float64, ok bool) {
	var arg0 *C.GtkGesture
	var arg1 *C.GdkEventSequence
	var arg2 *C.gdouble // out
	var arg3 *C.gdouble // out

	arg0 = (*C.GtkGesture)(gesture.Native())
	arg1 = (*C.GdkEventSequence)(sequence.Native())

	ret := C.gtk_gesture_get_point(arg0, arg1, &arg2, &arg3)

	var ret0 float64
	var ret1 float64
	var ret2 bool

	ret0 = float64(arg2)

	ret1 = float64(arg3)

	ret2 = C.BOOL(ret) != 0

	return ret0, ret1, ret2
}

// SequenceState returns the @sequence state, as seen by @gesture.
func (gesture gesture) SequenceState(sequence *gdk.EventSequence) EventSequenceState {
	var arg0 *C.GtkGesture
	var arg1 *C.GdkEventSequence

	arg0 = (*C.GtkGesture)(gesture.Native())
	arg1 = (*C.GdkEventSequence)(sequence.Native())

	ret := C.gtk_gesture_get_sequence_state(arg0, arg1)

	var ret0 EventSequenceState

	ret0 = EventSequenceState(ret)

	return ret0
}

// Sequences returns the list of EventSequences currently being interpreted
// by @gesture.
func (gesture gesture) Sequences() *glib.List {
	var arg0 *C.GtkGesture

	arg0 = (*C.GtkGesture)(gesture.Native())

	ret := C.gtk_gesture_get_sequences(arg0)

	var ret0 *glib.List

	{
		ret0 = glib.WrapList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.List) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Window returns the user-defined window that receives the events handled
// by @gesture. See gtk_gesture_set_window() for more information.
func (gesture gesture) Window() gdk.Window {
	var arg0 *C.GtkGesture

	arg0 = (*C.GtkGesture)(gesture.Native())

	ret := C.gtk_gesture_get_window(arg0)

	var ret0 gdk.Window

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gdk.Window)

	return ret0
}

// Group adds @gesture to the same group than @group_gesture. Gestures are
// by default isolated in their own groups.
//
// When gestures are grouped, the state of EventSequences is kept in sync
// for all of those, so calling gtk_gesture_set_sequence_state(), on one
// will transfer the same value to the others.
//
// Groups also perform an "implicit grabbing" of sequences, if a
// EventSequence state is set to K_EVENT_SEQUENCE_CLAIMED on one group,
// every other gesture group attached to the same Widget will switch the
// state for that sequence to K_EVENT_SEQUENCE_DENIED.
func (groupGesture gesture) Group(gesture Gesture) {
	var arg0 *C.GtkGesture
	var arg1 *C.GtkGesture

	arg0 = (*C.GtkGesture)(groupGesture.Native())
	arg1 = (*C.GtkGesture)(gesture.Native())

	C.gtk_gesture_group(arg0, arg1)
}

// HandlesSequence returns true if @gesture is currently handling events
// corresponding to @sequence.
func (gesture gesture) HandlesSequence(sequence *gdk.EventSequence) bool {
	var arg0 *C.GtkGesture
	var arg1 *C.GdkEventSequence

	arg0 = (*C.GtkGesture)(gesture.Native())
	arg1 = (*C.GdkEventSequence)(sequence.Native())

	ret := C.gtk_gesture_handles_sequence(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IsActive returns true if the gesture is currently active. A gesture is
// active meanwhile there are touch sequences interacting with it.
func (gesture gesture) IsActive() bool {
	var arg0 *C.GtkGesture

	arg0 = (*C.GtkGesture)(gesture.Native())

	ret := C.gtk_gesture_is_active(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IsGroupedWith returns true if both gestures pertain to the same group.
func (gesture gesture) IsGroupedWith(other Gesture) bool {
	var arg0 *C.GtkGesture
	var arg1 *C.GtkGesture

	arg0 = (*C.GtkGesture)(gesture.Native())
	arg1 = (*C.GtkGesture)(other.Native())

	ret := C.gtk_gesture_is_grouped_with(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IsRecognized returns true if the gesture is currently recognized. A
// gesture is recognized if there are as many interacting touch sequences as
// required by @gesture, and Gesture::check returned true for the sequences
// being currently interpreted.
func (gesture gesture) IsRecognized() bool {
	var arg0 *C.GtkGesture

	arg0 = (*C.GtkGesture)(gesture.Native())

	ret := C.gtk_gesture_is_recognized(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SetSequenceState sets the state of @sequence in @gesture. Sequences start
// in state K_EVENT_SEQUENCE_NONE, and whenever they change state, they can
// never go back to that state. Likewise, sequences in state
// K_EVENT_SEQUENCE_DENIED cannot turn back to a not denied state. With
// these rules, the lifetime of an event sequence is constrained to the next
// four:
//
// * None * None → Denied * None → Claimed * None → Claimed → Denied
//
// Note: Due to event handling ordering, it may be unsafe to set the state
// on another gesture within a Gesture::begin signal handler, as the
// callback might be executed before the other gesture knows about the
// sequence. A safe way to perform this could be:
//
//    static void
//    first_gesture_begin_cb (GtkGesture       *first_gesture,
//                            GdkEventSequence *sequence,
//                            gpointer          user_data)
//    {
//      gtk_gesture_set_sequence_state (first_gesture, sequence, GTK_EVENT_SEQUENCE_CLAIMED);
//      gtk_gesture_set_sequence_state (second_gesture, sequence, GTK_EVENT_SEQUENCE_DENIED);
//    }
//
//    static void
//    second_gesture_begin_cb (GtkGesture       *second_gesture,
//                             GdkEventSequence *sequence,
//                             gpointer          user_data)
//    {
//      if (gtk_gesture_get_sequence_state (first_gesture, sequence) == GTK_EVENT_SEQUENCE_CLAIMED)
//        gtk_gesture_set_sequence_state (second_gesture, sequence, GTK_EVENT_SEQUENCE_DENIED);
//    }
//
// If both gestures are in the same group, just set the state on the gesture
// emitting the event, the sequence will be already be initialized to the
// group's global state when the second gesture processes the event.
func (gesture gesture) SetSequenceState(sequence *gdk.EventSequence, state EventSequenceState) bool {
	var arg0 *C.GtkGesture
	var arg1 *C.GdkEventSequence
	var arg2 C.GtkEventSequenceState

	arg0 = (*C.GtkGesture)(gesture.Native())
	arg1 = (*C.GdkEventSequence)(sequence.Native())
	arg2 = (C.GtkEventSequenceState)(state)

	ret := C.gtk_gesture_set_sequence_state(arg0, arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SetState sets the state of all sequences that @gesture is currently
// interacting with. See gtk_gesture_set_sequence_state() for more details
// on sequence states.
func (gesture gesture) SetState(state EventSequenceState) bool {
	var arg0 *C.GtkGesture
	var arg1 C.GtkEventSequenceState

	arg0 = (*C.GtkGesture)(gesture.Native())
	arg1 = (C.GtkEventSequenceState)(state)

	ret := C.gtk_gesture_set_state(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SetWindow sets a specific window to receive events about, so @gesture
// will effectively handle only events targeting @window, or a child of it.
// @window must pertain to gtk_event_controller_get_widget().
func (gesture gesture) SetWindow(window gdk.Window) {
	var arg0 *C.GtkGesture
	var arg1 *C.GdkWindow

	arg0 = (*C.GtkGesture)(gesture.Native())
	arg1 = (*C.GdkWindow)(window.Native())

	C.gtk_gesture_set_window(arg0, arg1)
}

// Ungroup separates @gesture into an isolated group.
func (gesture gesture) Ungroup() {
	var arg0 *C.GtkGesture

	arg0 = (*C.GtkGesture)(gesture.Native())

	C.gtk_gesture_ungroup(arg0)
}

// GestureDrag is a Gesture implementation that recognizes drag operations. The
// drag operation itself can be tracked throught the GestureDrag::drag-begin,
// GestureDrag::drag-update and GestureDrag::drag-end signals, or the relevant
// coordinates be extracted through gtk_gesture_drag_get_offset() and
// gtk_gesture_drag_get_start_point().
type GestureDrag interface {
	GestureSingle

	// Offset: if the @gesture is active, this function returns true and fills
	// in @x and @y with the coordinates of the current point, as an offset to
	// the starting drag point.
	Offset() (x float64, y float64, ok bool)
	// StartPoint: if the @gesture is active, this function returns true and
	// fills in @x and @y with the drag start coordinates, in window-relative
	// coordinates.
	StartPoint() (x float64, y float64, ok bool)
}

// gestureDrag implements the GestureDrag interface.
type gestureDrag struct {
	GestureSingle
}

var _ GestureDrag = (*gestureDrag)(nil)

// WrapGestureDrag wraps a GObject to the right type. It is
// primarily used internally.
func WrapGestureDrag(obj *externglib.Object) GestureDrag {
	return GestureDrag{
		GestureSingle: WrapGestureSingle(obj),
	}
}

func marshalGestureDrag(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGestureDrag(obj), nil
}

// NewGestureDrag constructs a class GestureDrag.
func NewGestureDrag(widget Widget) GestureDrag {
	var arg1 *C.GtkWidget

	arg1 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_gesture_drag_new(arg1)

	var ret0 GestureDrag

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(GestureDrag)

	return ret0
}

// Offset: if the @gesture is active, this function returns true and fills
// in @x and @y with the coordinates of the current point, as an offset to
// the starting drag point.
func (gesture gestureDrag) Offset() (x float64, y float64, ok bool) {
	var arg0 *C.GtkGestureDrag
	var arg1 *C.gdouble // out
	var arg2 *C.gdouble // out

	arg0 = (*C.GtkGestureDrag)(gesture.Native())

	ret := C.gtk_gesture_drag_get_offset(arg0, &arg1, &arg2)

	var ret0 float64
	var ret1 float64
	var ret2 bool

	ret0 = float64(arg1)

	ret1 = float64(arg2)

	ret2 = C.BOOL(ret) != 0

	return ret0, ret1, ret2
}

// StartPoint: if the @gesture is active, this function returns true and
// fills in @x and @y with the drag start coordinates, in window-relative
// coordinates.
func (gesture gestureDrag) StartPoint() (x float64, y float64, ok bool) {
	var arg0 *C.GtkGestureDrag
	var arg1 *C.gdouble // out
	var arg2 *C.gdouble // out

	arg0 = (*C.GtkGestureDrag)(gesture.Native())

	ret := C.gtk_gesture_drag_get_start_point(arg0, &arg1, &arg2)

	var ret0 float64
	var ret1 float64
	var ret2 bool

	ret0 = float64(arg1)

	ret1 = float64(arg2)

	ret2 = C.BOOL(ret) != 0

	return ret0, ret1, ret2
}

// GestureLongPress is a Gesture implementation able to recognize long presses,
// triggering the GestureLongPress::pressed after the timeout is exceeded.
//
// If the touchpoint is lifted before the timeout passes, or if it drifts too
// far of the initial press point, the GestureLongPress::cancelled signal will
// be emitted.
type GestureLongPress interface {
	GestureSingle
}

// gestureLongPress implements the GestureLongPress interface.
type gestureLongPress struct {
	GestureSingle
}

var _ GestureLongPress = (*gestureLongPress)(nil)

// WrapGestureLongPress wraps a GObject to the right type. It is
// primarily used internally.
func WrapGestureLongPress(obj *externglib.Object) GestureLongPress {
	return GestureLongPress{
		GestureSingle: WrapGestureSingle(obj),
	}
}

func marshalGestureLongPress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGestureLongPress(obj), nil
}

// NewGestureLongPress constructs a class GestureLongPress.
func NewGestureLongPress(widget Widget) GestureLongPress {
	var arg1 *C.GtkWidget

	arg1 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_gesture_long_press_new(arg1)

	var ret0 GestureLongPress

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(GestureLongPress)

	return ret0
}

// GestureMultiPress is a Gesture implementation able to recognize multiple
// clicks on a nearby zone, which can be listened for through the
// GestureMultiPress::pressed signal. Whenever time or distance between clicks
// exceed the GTK+ defaults, GestureMultiPress::stopped is emitted, and the
// click counter is reset.
//
// Callers may also restrict the area that is considered valid for a >1
// touch/button press through gtk_gesture_multi_press_set_area(), so any click
// happening outside that area is considered to be a first click of its own.
type GestureMultiPress interface {
	GestureSingle

	// Area: if an area was set through gtk_gesture_multi_press_set_area(), this
	// function will return true and fill in @rect with the press area. See
	// gtk_gesture_multi_press_set_area() for more details on what the press
	// area represents.
	Area() (rect gdk.Rectangle, ok bool)
	// SetArea: if @rect is non-nil, the press area will be checked to be
	// confined within the rectangle, otherwise the button count will be reset
	// so the press is seen as being the first one. If @rect is nil, the area
	// will be reset to an unrestricted state.
	//
	// Note: The rectangle is only used to determine whether any non-first click
	// falls within the expected area. This is not akin to an input shape.
	SetArea(rect *gdk.Rectangle)
}

// gestureMultiPress implements the GestureMultiPress interface.
type gestureMultiPress struct {
	GestureSingle
}

var _ GestureMultiPress = (*gestureMultiPress)(nil)

// WrapGestureMultiPress wraps a GObject to the right type. It is
// primarily used internally.
func WrapGestureMultiPress(obj *externglib.Object) GestureMultiPress {
	return GestureMultiPress{
		GestureSingle: WrapGestureSingle(obj),
	}
}

func marshalGestureMultiPress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGestureMultiPress(obj), nil
}

// NewGestureMultiPress constructs a class GestureMultiPress.
func NewGestureMultiPress(widget Widget) GestureMultiPress {
	var arg1 *C.GtkWidget

	arg1 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_gesture_multi_press_new(arg1)

	var ret0 GestureMultiPress

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(GestureMultiPress)

	return ret0
}

// Area: if an area was set through gtk_gesture_multi_press_set_area(), this
// function will return true and fill in @rect with the press area. See
// gtk_gesture_multi_press_set_area() for more details on what the press
// area represents.
func (gesture gestureMultiPress) Area() (rect gdk.Rectangle, ok bool) {
	var arg0 *C.GtkGestureMultiPress
	var arg1 *C.GdkRectangle // out

	arg0 = (*C.GtkGestureMultiPress)(gesture.Native())

	ret := C.gtk_gesture_multi_press_get_area(arg0, &arg1)

	var ret0 *gdk.Rectangle
	var ret1 bool

	{
		ret0 = gdk.WrapRectangle(unsafe.Pointer(arg1))
	}

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// SetArea: if @rect is non-nil, the press area will be checked to be
// confined within the rectangle, otherwise the button count will be reset
// so the press is seen as being the first one. If @rect is nil, the area
// will be reset to an unrestricted state.
//
// Note: The rectangle is only used to determine whether any non-first click
// falls within the expected area. This is not akin to an input shape.
func (gesture gestureMultiPress) SetArea(rect *gdk.Rectangle) {
	var arg0 *C.GtkGestureMultiPress
	var arg1 *C.GdkRectangle

	arg0 = (*C.GtkGestureMultiPress)(gesture.Native())
	arg1 = (*C.GdkRectangle)(rect.Native())

	C.gtk_gesture_multi_press_set_area(arg0, arg1)
}

// GesturePan is a Gesture implementation able to recognize pan gestures, those
// are drags that are locked to happen along one axis. The axis that a
// GesturePan handles is defined at construct time, and can be changed through
// gtk_gesture_pan_set_orientation().
//
// When the gesture starts to be recognized, GesturePan will attempt to
// determine as early as possible whether the sequence is moving in the expected
// direction, and denying the sequence if this does not happen.
//
// Once a panning gesture along the expected axis is recognized, the
// GesturePan::pan signal will be emitted as input events are received,
// containing the offset in the given axis.
type GesturePan interface {
	GestureDrag

	// Orientation returns the orientation of the pan gestures that this
	// @gesture expects.
	Orientation() Orientation
	// SetOrientation sets the orientation to be expected on pan gestures.
	SetOrientation(orientation Orientation)
}

// gesturePan implements the GesturePan interface.
type gesturePan struct {
	GestureDrag
}

var _ GesturePan = (*gesturePan)(nil)

// WrapGesturePan wraps a GObject to the right type. It is
// primarily used internally.
func WrapGesturePan(obj *externglib.Object) GesturePan {
	return GesturePan{
		GestureDrag: WrapGestureDrag(obj),
	}
}

func marshalGesturePan(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGesturePan(obj), nil
}

// NewGesturePan constructs a class GesturePan.
func NewGesturePan(widget Widget, orientation Orientation) GesturePan {
	var arg1 *C.GtkWidget
	var arg2 C.GtkOrientation

	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = (C.GtkOrientation)(orientation)

	ret := C.gtk_gesture_pan_new(arg1, arg2)

	var ret0 GesturePan

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(GesturePan)

	return ret0
}

// Orientation returns the orientation of the pan gestures that this
// @gesture expects.
func (gesture gesturePan) Orientation() Orientation {
	var arg0 *C.GtkGesturePan

	arg0 = (*C.GtkGesturePan)(gesture.Native())

	ret := C.gtk_gesture_pan_get_orientation(arg0)

	var ret0 Orientation

	ret0 = Orientation(ret)

	return ret0
}

// SetOrientation sets the orientation to be expected on pan gestures.
func (gesture gesturePan) SetOrientation(orientation Orientation) {
	var arg0 *C.GtkGesturePan
	var arg1 C.GtkOrientation

	arg0 = (*C.GtkGesturePan)(gesture.Native())
	arg1 = (C.GtkOrientation)(orientation)

	C.gtk_gesture_pan_set_orientation(arg0, arg1)
}

// GestureRotate is a Gesture implementation able to recognize 2-finger
// rotations, whenever the angle between both handled sequences changes, the
// GestureRotate::angle-changed signal is emitted.
type GestureRotate interface {
	Gesture

	// AngleDelta: if @gesture is active, this function returns the angle
	// difference in radians since the gesture was first recognized. If @gesture
	// is not active, 0 is returned.
	AngleDelta() float64
}

// gestureRotate implements the GestureRotate interface.
type gestureRotate struct {
	Gesture
}

var _ GestureRotate = (*gestureRotate)(nil)

// WrapGestureRotate wraps a GObject to the right type. It is
// primarily used internally.
func WrapGestureRotate(obj *externglib.Object) GestureRotate {
	return GestureRotate{
		Gesture: WrapGesture(obj),
	}
}

func marshalGestureRotate(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGestureRotate(obj), nil
}

// NewGestureRotate constructs a class GestureRotate.
func NewGestureRotate(widget Widget) GestureRotate {
	var arg1 *C.GtkWidget

	arg1 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_gesture_rotate_new(arg1)

	var ret0 GestureRotate

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(GestureRotate)

	return ret0
}

// AngleDelta: if @gesture is active, this function returns the angle
// difference in radians since the gesture was first recognized. If @gesture
// is not active, 0 is returned.
func (gesture gestureRotate) AngleDelta() float64 {
	var arg0 *C.GtkGestureRotate

	arg0 = (*C.GtkGestureRotate)(gesture.Native())

	ret := C.gtk_gesture_rotate_get_angle_delta(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// GestureSingle is a subclass of Gesture, optimized (although not restricted)
// for dealing with mouse and single-touch gestures. Under interaction, these
// gestures stick to the first interacting sequence, which is accessible through
// gtk_gesture_single_get_current_sequence() while the gesture is being
// interacted with.
//
// By default gestures react to both GDK_BUTTON_PRIMARY and touch events,
// gtk_gesture_single_set_touch_only() can be used to change the touch behavior.
// Callers may also specify a different mouse button number to interact with
// through gtk_gesture_single_set_button(), or react to any mouse button by
// setting 0. While the gesture is active, the button being currently pressed
// can be known through gtk_gesture_single_get_current_button().
type GestureSingle interface {
	Gesture

	// Button returns the button number @gesture listens for, or 0 if @gesture
	// reacts to any button press.
	Button() uint
	// CurrentButton returns the button number currently interacting with
	// @gesture, or 0 if there is none.
	CurrentButton() uint
	// CurrentSequence returns the event sequence currently interacting with
	// @gesture. This is only meaningful if gtk_gesture_is_active() returns
	// true.
	CurrentSequence() *gdk.EventSequence
	// Exclusive gets whether a gesture is exclusive. For more information, see
	// gtk_gesture_single_set_exclusive().
	Exclusive() bool
	// TouchOnly returns true if the gesture is only triggered by touch events.
	TouchOnly() bool
	// SetButton sets the button number @gesture listens to. If non-0, every
	// button press from a different button number will be ignored. Touch events
	// implicitly match with button 1.
	SetButton(button uint)
	// SetExclusive sets whether @gesture is exclusive. An exclusive gesture
	// will only handle pointer and "pointer emulated" touch events, so at any
	// given time, there is only one sequence able to interact with those.
	SetExclusive(exclusive bool)
	// SetTouchOnly: if @touch_only is true, @gesture will only handle events of
	// type K_TOUCH_BEGIN, K_TOUCH_UPDATE or K_TOUCH_END. If false, mouse events
	// will be handled too.
	SetTouchOnly(touchOnly bool)
}

// gestureSingle implements the GestureSingle interface.
type gestureSingle struct {
	Gesture
}

var _ GestureSingle = (*gestureSingle)(nil)

// WrapGestureSingle wraps a GObject to the right type. It is
// primarily used internally.
func WrapGestureSingle(obj *externglib.Object) GestureSingle {
	return GestureSingle{
		Gesture: WrapGesture(obj),
	}
}

func marshalGestureSingle(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGestureSingle(obj), nil
}

// Button returns the button number @gesture listens for, or 0 if @gesture
// reacts to any button press.
func (gesture gestureSingle) Button() uint {
	var arg0 *C.GtkGestureSingle

	arg0 = (*C.GtkGestureSingle)(gesture.Native())

	ret := C.gtk_gesture_single_get_button(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// CurrentButton returns the button number currently interacting with
// @gesture, or 0 if there is none.
func (gesture gestureSingle) CurrentButton() uint {
	var arg0 *C.GtkGestureSingle

	arg0 = (*C.GtkGestureSingle)(gesture.Native())

	ret := C.gtk_gesture_single_get_current_button(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// CurrentSequence returns the event sequence currently interacting with
// @gesture. This is only meaningful if gtk_gesture_is_active() returns
// true.
func (gesture gestureSingle) CurrentSequence() *gdk.EventSequence {
	var arg0 *C.GtkGestureSingle

	arg0 = (*C.GtkGestureSingle)(gesture.Native())

	ret := C.gtk_gesture_single_get_current_sequence(arg0)

	var ret0 *gdk.EventSequence

	{
		ret0 = gdk.WrapEventSequence(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *gdk.EventSequence) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Exclusive gets whether a gesture is exclusive. For more information, see
// gtk_gesture_single_set_exclusive().
func (gesture gestureSingle) Exclusive() bool {
	var arg0 *C.GtkGestureSingle

	arg0 = (*C.GtkGestureSingle)(gesture.Native())

	ret := C.gtk_gesture_single_get_exclusive(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// TouchOnly returns true if the gesture is only triggered by touch events.
func (gesture gestureSingle) TouchOnly() bool {
	var arg0 *C.GtkGestureSingle

	arg0 = (*C.GtkGestureSingle)(gesture.Native())

	ret := C.gtk_gesture_single_get_touch_only(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SetButton sets the button number @gesture listens to. If non-0, every
// button press from a different button number will be ignored. Touch events
// implicitly match with button 1.
func (gesture gestureSingle) SetButton(button uint) {
	var arg0 *C.GtkGestureSingle
	var arg1 C.guint

	arg0 = (*C.GtkGestureSingle)(gesture.Native())
	arg1 = C.guint(button)

	C.gtk_gesture_single_set_button(arg0, arg1)
}

// SetExclusive sets whether @gesture is exclusive. An exclusive gesture
// will only handle pointer and "pointer emulated" touch events, so at any
// given time, there is only one sequence able to interact with those.
func (gesture gestureSingle) SetExclusive(exclusive bool) {
	var arg0 *C.GtkGestureSingle
	var arg1 C.gboolean

	arg0 = (*C.GtkGestureSingle)(gesture.Native())
	if exclusive {
		arg1 = C.TRUE
	}

	C.gtk_gesture_single_set_exclusive(arg0, arg1)
}

// SetTouchOnly: if @touch_only is true, @gesture will only handle events of
// type K_TOUCH_BEGIN, K_TOUCH_UPDATE or K_TOUCH_END. If false, mouse events
// will be handled too.
func (gesture gestureSingle) SetTouchOnly(touchOnly bool) {
	var arg0 *C.GtkGestureSingle
	var arg1 C.gboolean

	arg0 = (*C.GtkGestureSingle)(gesture.Native())
	if touchOnly {
		arg1 = C.TRUE
	}

	C.gtk_gesture_single_set_touch_only(arg0, arg1)
}

// GestureStylus is a Gesture implementation specific to stylus input. The
// provided signals just provide the basic information
type GestureStylus interface {
	GestureSingle

	// Axis returns the current value for the requested @axis. This function
	// must be called from either the GestureStylus:down, GestureStylus:motion,
	// GestureStylus:up or GestureStylus:proximity signals.
	Axis(axis gdk.AxisUse) (value float64, ok bool)
	// DeviceTool returns the DeviceTool currently driving input through this
	// gesture. This function must be called from either the
	// GestureStylus::down, GestureStylus::motion, GestureStylus::up or
	// GestureStylus::proximity signal handlers.
	DeviceTool() gdk.DeviceTool
}

// gestureStylus implements the GestureStylus interface.
type gestureStylus struct {
	GestureSingle
}

var _ GestureStylus = (*gestureStylus)(nil)

// WrapGestureStylus wraps a GObject to the right type. It is
// primarily used internally.
func WrapGestureStylus(obj *externglib.Object) GestureStylus {
	return GestureStylus{
		GestureSingle: WrapGestureSingle(obj),
	}
}

func marshalGestureStylus(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGestureStylus(obj), nil
}

// NewGestureStylus constructs a class GestureStylus.
func NewGestureStylus(widget Widget) GestureStylus {
	var arg1 *C.GtkWidget

	arg1 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_gesture_stylus_new(arg1)

	var ret0 GestureStylus

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(GestureStylus)

	return ret0
}

// Axis returns the current value for the requested @axis. This function
// must be called from either the GestureStylus:down, GestureStylus:motion,
// GestureStylus:up or GestureStylus:proximity signals.
func (gesture gestureStylus) Axis(axis gdk.AxisUse) (value float64, ok bool) {
	var arg0 *C.GtkGestureStylus
	var arg1 C.GdkAxisUse
	var arg2 *C.gdouble // out

	arg0 = (*C.GtkGestureStylus)(gesture.Native())
	arg1 = (C.GdkAxisUse)(axis)

	ret := C.gtk_gesture_stylus_get_axis(arg0, arg1, &arg2)

	var ret0 float64
	var ret1 bool

	ret0 = float64(arg2)

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// DeviceTool returns the DeviceTool currently driving input through this
// gesture. This function must be called from either the
// GestureStylus::down, GestureStylus::motion, GestureStylus::up or
// GestureStylus::proximity signal handlers.
func (gesture gestureStylus) DeviceTool() gdk.DeviceTool {
	var arg0 *C.GtkGestureStylus

	arg0 = (*C.GtkGestureStylus)(gesture.Native())

	ret := C.gtk_gesture_stylus_get_device_tool(arg0)

	var ret0 gdk.DeviceTool

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gdk.DeviceTool)

	return ret0
}

// GestureSwipe is a Gesture implementation able to recognize swipes, after a
// press/move/.../move/release sequence happens, the GestureSwipe::swipe signal
// will be emitted, providing the velocity and directionality of the sequence at
// the time it was lifted.
//
// If the velocity is desired in intermediate points,
// gtk_gesture_swipe_get_velocity() can be called on eg. a Gesture::update
// handler.
//
// All velocities are reported in pixels/sec units.
type GestureSwipe interface {
	GestureSingle

	// Velocity: if the gesture is recognized, this function returns true and
	// fill in @velocity_x and @velocity_y with the recorded velocity, as per
	// the last event(s) processed.
	Velocity() (velocityX float64, velocityY float64, ok bool)
}

// gestureSwipe implements the GestureSwipe interface.
type gestureSwipe struct {
	GestureSingle
}

var _ GestureSwipe = (*gestureSwipe)(nil)

// WrapGestureSwipe wraps a GObject to the right type. It is
// primarily used internally.
func WrapGestureSwipe(obj *externglib.Object) GestureSwipe {
	return GestureSwipe{
		GestureSingle: WrapGestureSingle(obj),
	}
}

func marshalGestureSwipe(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGestureSwipe(obj), nil
}

// NewGestureSwipe constructs a class GestureSwipe.
func NewGestureSwipe(widget Widget) GestureSwipe {
	var arg1 *C.GtkWidget

	arg1 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_gesture_swipe_new(arg1)

	var ret0 GestureSwipe

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(GestureSwipe)

	return ret0
}

// Velocity: if the gesture is recognized, this function returns true and
// fill in @velocity_x and @velocity_y with the recorded velocity, as per
// the last event(s) processed.
func (gesture gestureSwipe) Velocity() (velocityX float64, velocityY float64, ok bool) {
	var arg0 *C.GtkGestureSwipe
	var arg1 *C.gdouble // out
	var arg2 *C.gdouble // out

	arg0 = (*C.GtkGestureSwipe)(gesture.Native())

	ret := C.gtk_gesture_swipe_get_velocity(arg0, &arg1, &arg2)

	var ret0 float64
	var ret1 float64
	var ret2 bool

	ret0 = float64(arg1)

	ret1 = float64(arg2)

	ret2 = C.BOOL(ret) != 0

	return ret0, ret1, ret2
}

// GestureZoom is a Gesture implementation able to recognize pinch/zoom
// gestures, whenever the distance between both tracked sequences changes, the
// GestureZoom::scale-changed signal is emitted to report the scale factor.
type GestureZoom interface {
	Gesture

	// ScaleDelta: if @gesture is active, this function returns the zooming
	// difference since the gesture was recognized (hence the starting point is
	// considered 1:1). If @gesture is not active, 1 is returned.
	ScaleDelta() float64
}

// gestureZoom implements the GestureZoom interface.
type gestureZoom struct {
	Gesture
}

var _ GestureZoom = (*gestureZoom)(nil)

// WrapGestureZoom wraps a GObject to the right type. It is
// primarily used internally.
func WrapGestureZoom(obj *externglib.Object) GestureZoom {
	return GestureZoom{
		Gesture: WrapGesture(obj),
	}
}

func marshalGestureZoom(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGestureZoom(obj), nil
}

// NewGestureZoom constructs a class GestureZoom.
func NewGestureZoom(widget Widget) GestureZoom {
	var arg1 *C.GtkWidget

	arg1 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_gesture_zoom_new(arg1)

	var ret0 GestureZoom

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(GestureZoom)

	return ret0
}

// ScaleDelta: if @gesture is active, this function returns the zooming
// difference since the gesture was recognized (hence the starting point is
// considered 1:1). If @gesture is not active, 1 is returned.
func (gesture gestureZoom) ScaleDelta() float64 {
	var arg0 *C.GtkGestureZoom

	arg0 = (*C.GtkGestureZoom)(gesture.Native())

	ret := C.gtk_gesture_zoom_get_scale_delta(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// IMContext defines the interface for GTK+ input methods. An input method is
// used by GTK+ text input widgets like Entry to map from key events to Unicode
// character strings.
//
// The default input method can be set programmatically via the
// Settings:gtk-im-module GtkSettings property. Alternatively, you may set the
// GTK_IM_MODULE environment variable as documented in [Running GTK+
// Applications][gtk-running].
//
// The Entry Entry:im-module and TextView TextView:im-module properties may also
// be used to set input methods for specific widget instances. For instance, a
// certain entry widget might be expected to contain certain characters which
// would be easier to input with a certain input method.
//
// An input method may consume multiple key events in sequence and finally
// output the composed result. This is called preediting, and an input method
// may provide feedback about this process by displaying the intermediate
// composition states as preedit text. For instance, the default GTK+ input
// method implements the input of arbitrary Unicode code points by holding down
// the Control and Shift keys and then typing “U” followed by the hexadecimal
// digits of the code point. When releasing the Control and Shift keys,
// preediting ends and the character is inserted as text. Ctrl+Shift+u20AC for
// example results in the € sign.
//
// Additional input methods can be made available for use by GTK+ widgets as
// loadable modules. An input method module is a small shared library which
// implements a subclass of IMContext or IMContextSimple and exports these four
// functions:
//
//    GtkIMContext * im_module_create(const gchar *context_id);
//
// This function should return a pointer to a newly created instance of the
// IMContext subclass identified by @context_id. The context ID is the same as
// specified in the IMContextInfo array returned by im_module_list().
//
// After a new loadable input method module has been installed on the system,
// the configuration file `gtk.immodules` needs to be regenerated by
// [gtk-query-immodules-3.0][gtk-query-immodules-3.0], in order for the new
// input method to become available to GTK+ applications.
type IMContext interface {
	gextras.Objector

	// DeleteSurrounding asks the widget that the input context is attached to
	// to delete characters around the cursor position by emitting the
	// GtkIMContext::delete_surrounding signal. Note that @offset and @n_chars
	// are in characters not in bytes which differs from the usage other places
	// in IMContext.
	//
	// In order to use this function, you should first call
	// gtk_im_context_get_surrounding() to get the current context, and call
	// this function immediately afterwards to make sure that you know what you
	// are deleting. You should also account for the fact that even if the
	// signal was handled, the input context might not have deleted all the
	// characters that were requested to be deleted.
	//
	// This function is used by an input method that wants to make subsitutions
	// in the existing text in response to new input. It is not useful for
	// applications.
	DeleteSurrounding(offset int, nChars int) bool
	// FilterKeypress: allow an input method to internally handle key press and
	// release events. If this function returns true, then no further processing
	// should be done for this key event.
	FilterKeypress(event *gdk.EventKey) bool
	// FocusIn: notify the input method that the widget to which this input
	// context corresponds has gained focus. The input method may, for example,
	// change the displayed feedback to reflect this change.
	FocusIn()
	// FocusOut: notify the input method that the widget to which this input
	// context corresponds has lost focus. The input method may, for example,
	// change the displayed feedback or reset the contexts state to reflect this
	// change.
	FocusOut()
	// PreeditString: retrieve the current preedit string for the input context,
	// and a list of attributes to apply to the string. This string should be
	// displayed inserted at the insertion point.
	PreeditString() (str string, attrs *pango.AttrList, cursorPos int)
	// Surrounding retrieves context around the insertion point. Input methods
	// typically want context in order to constrain input text based on existing
	// text; this is important for languages such as Thai where only some
	// sequences of characters are allowed.
	//
	// This function is implemented by emitting the
	// GtkIMContext::retrieve_surrounding signal on the input method; in
	// response to this signal, a widget should provide as much context as is
	// available, up to an entire paragraph, by calling
	// gtk_im_context_set_surrounding(). Note that there is no obligation for a
	// widget to respond to the ::retrieve_surrounding signal, so input methods
	// must be prepared to function without context.
	Surrounding() (text string, cursorIndex int, ok bool)
	// Reset: notify the input method that a change such as a change in cursor
	// position has been made. This will typically cause the input method to
	// clear the preedit state.
	Reset()
	// SetClientWindow: set the client window for the input context; this is the
	// Window in which the input appears. This window is used in order to
	// correctly position status windows, and may also be used for purposes
	// internal to the input method.
	SetClientWindow(window gdk.Window)
	// SetCursorLocation: notify the input method that a change in cursor
	// position has been made. The location is relative to the client window.
	SetCursorLocation(area *gdk.Rectangle)
	// SetSurrounding sets surrounding context around the insertion point and
	// preedit string. This function is expected to be called in response to the
	// GtkIMContext::retrieve_surrounding signal, and will likely have no effect
	// if called at other times.
	SetSurrounding(text string, len int, cursorIndex int)
	// SetUsePreedit sets whether the IM context should use the preedit string
	// to display feedback. If @use_preedit is FALSE (default is TRUE), then the
	// IM context may use some other method to display feedback, such as
	// displaying it in a child of the root window.
	SetUsePreedit(usePreedit bool)
}

// imContext implements the IMContext interface.
type imContext struct {
	gextras.Objector
}

var _ IMContext = (*imContext)(nil)

// WrapIMContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapIMContext(obj *externglib.Object) IMContext {
	return IMContext{
		Objector: obj,
	}
}

func marshalIMContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIMContext(obj), nil
}

// DeleteSurrounding asks the widget that the input context is attached to
// to delete characters around the cursor position by emitting the
// GtkIMContext::delete_surrounding signal. Note that @offset and @n_chars
// are in characters not in bytes which differs from the usage other places
// in IMContext.
//
// In order to use this function, you should first call
// gtk_im_context_get_surrounding() to get the current context, and call
// this function immediately afterwards to make sure that you know what you
// are deleting. You should also account for the fact that even if the
// signal was handled, the input context might not have deleted all the
// characters that were requested to be deleted.
//
// This function is used by an input method that wants to make subsitutions
// in the existing text in response to new input. It is not useful for
// applications.
func (context imContext) DeleteSurrounding(offset int, nChars int) bool {
	var arg0 *C.GtkIMContext
	var arg1 C.gint
	var arg2 C.gint

	arg0 = (*C.GtkIMContext)(context.Native())
	arg1 = C.gint(offset)
	arg2 = C.gint(nChars)

	ret := C.gtk_im_context_delete_surrounding(arg0, arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// FilterKeypress: allow an input method to internally handle key press and
// release events. If this function returns true, then no further processing
// should be done for this key event.
func (context imContext) FilterKeypress(event *gdk.EventKey) bool {
	var arg0 *C.GtkIMContext
	var arg1 *C.GdkEventKey

	arg0 = (*C.GtkIMContext)(context.Native())
	arg1 = (*C.GdkEventKey)(event.Native())

	ret := C.gtk_im_context_filter_keypress(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// FocusIn: notify the input method that the widget to which this input
// context corresponds has gained focus. The input method may, for example,
// change the displayed feedback to reflect this change.
func (context imContext) FocusIn() {
	var arg0 *C.GtkIMContext

	arg0 = (*C.GtkIMContext)(context.Native())

	C.gtk_im_context_focus_in(arg0)
}

// FocusOut: notify the input method that the widget to which this input
// context corresponds has lost focus. The input method may, for example,
// change the displayed feedback or reset the contexts state to reflect this
// change.
func (context imContext) FocusOut() {
	var arg0 *C.GtkIMContext

	arg0 = (*C.GtkIMContext)(context.Native())

	C.gtk_im_context_focus_out(arg0)
}

// PreeditString: retrieve the current preedit string for the input context,
// and a list of attributes to apply to the string. This string should be
// displayed inserted at the insertion point.
func (context imContext) PreeditString() (str string, attrs *pango.AttrList, cursorPos int) {
	var arg0 *C.GtkIMContext
	var arg1 **C.gchar         // out
	var arg2 **C.PangoAttrList // out
	var arg3 *C.gint           // out

	arg0 = (*C.GtkIMContext)(context.Native())

	C.gtk_im_context_get_preedit_string(arg0, &arg1, &arg2, &arg3)

	var ret0 string
	var ret1 **pango.AttrList
	var ret2 int

	ret0 = C.GoString(arg1)
	C.free(unsafe.Pointer(arg1))

	{
		ret1 = pango.WrapAttrList(unsafe.Pointer(arg2))
		runtime.SetFinalizer(ret1, func(v **pango.AttrList) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	ret2 = int(arg3)

	return ret0, ret1, ret2
}

// Surrounding retrieves context around the insertion point. Input methods
// typically want context in order to constrain input text based on existing
// text; this is important for languages such as Thai where only some
// sequences of characters are allowed.
//
// This function is implemented by emitting the
// GtkIMContext::retrieve_surrounding signal on the input method; in
// response to this signal, a widget should provide as much context as is
// available, up to an entire paragraph, by calling
// gtk_im_context_set_surrounding(). Note that there is no obligation for a
// widget to respond to the ::retrieve_surrounding signal, so input methods
// must be prepared to function without context.
func (context imContext) Surrounding() (text string, cursorIndex int, ok bool) {
	var arg0 *C.GtkIMContext
	var arg1 **C.gchar // out
	var arg2 *C.gint   // out

	arg0 = (*C.GtkIMContext)(context.Native())

	ret := C.gtk_im_context_get_surrounding(arg0, &arg1, &arg2)

	var ret0 string
	var ret1 int
	var ret2 bool

	ret0 = C.GoString(arg1)
	C.free(unsafe.Pointer(arg1))

	ret1 = int(arg2)

	ret2 = C.BOOL(ret) != 0

	return ret0, ret1, ret2
}

// Reset: notify the input method that a change such as a change in cursor
// position has been made. This will typically cause the input method to
// clear the preedit state.
func (context imContext) Reset() {
	var arg0 *C.GtkIMContext

	arg0 = (*C.GtkIMContext)(context.Native())

	C.gtk_im_context_reset(arg0)
}

// SetClientWindow: set the client window for the input context; this is the
// Window in which the input appears. This window is used in order to
// correctly position status windows, and may also be used for purposes
// internal to the input method.
func (context imContext) SetClientWindow(window gdk.Window) {
	var arg0 *C.GtkIMContext
	var arg1 *C.GdkWindow

	arg0 = (*C.GtkIMContext)(context.Native())
	arg1 = (*C.GdkWindow)(window.Native())

	C.gtk_im_context_set_client_window(arg0, arg1)
}

// SetCursorLocation: notify the input method that a change in cursor
// position has been made. The location is relative to the client window.
func (context imContext) SetCursorLocation(area *gdk.Rectangle) {
	var arg0 *C.GtkIMContext
	var arg1 *C.GdkRectangle

	arg0 = (*C.GtkIMContext)(context.Native())
	arg1 = (*C.GdkRectangle)(area.Native())

	C.gtk_im_context_set_cursor_location(arg0, arg1)
}

// SetSurrounding sets surrounding context around the insertion point and
// preedit string. This function is expected to be called in response to the
// GtkIMContext::retrieve_surrounding signal, and will likely have no effect
// if called at other times.
func (context imContext) SetSurrounding(text string, len int, cursorIndex int) {
	var arg0 *C.GtkIMContext
	var arg1 *C.gchar
	var arg2 C.gint
	var arg3 C.gint

	arg0 = (*C.GtkIMContext)(context.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(len)
	arg3 = C.gint(cursorIndex)

	C.gtk_im_context_set_surrounding(arg0, arg1, arg2, arg3)
}

// SetUsePreedit sets whether the IM context should use the preedit string
// to display feedback. If @use_preedit is FALSE (default is TRUE), then the
// IM context may use some other method to display feedback, such as
// displaying it in a child of the root window.
func (context imContext) SetUsePreedit(usePreedit bool) {
	var arg0 *C.GtkIMContext
	var arg1 C.gboolean

	arg0 = (*C.GtkIMContext)(context.Native())
	if usePreedit {
		arg1 = C.TRUE
	}

	C.gtk_im_context_set_use_preedit(arg0, arg1)
}

// IMContextSimple: gtkIMContextSimple is a simple input method context
// supporting table-based input methods. It has a built-in table of compose
// sequences that is derived from the X11 Compose files.
//
// GtkIMContextSimple reads additional compose sequences from the first of the
// following files that is found: ~/.config/gtk-3.0/Compose, ~/.XCompose,
// /usr/share/X11/locale/$locale/Compose (for locales that have a nontrivial
// Compose file). The syntax of these files is described in the Compose(5)
// manual page.
//
//
// Unicode characters
//
// GtkIMContextSimple also supports numeric entry of Unicode characters by
// typing Ctrl-Shift-u, followed by a hexadecimal Unicode codepoint. For
// example, Ctrl-Shift-u 1 2 3 Enter yields U+0123 LATIN SMALL LETTER G WITH
// CEDILLA, i.e. ģ.
type IMContextSimple interface {
	IMContext

	// AddComposeFile adds an additional table from the X11 compose file.
	AddComposeFile(composeFile string)
}

// imContextSimple implements the IMContextSimple interface.
type imContextSimple struct {
	IMContext
}

var _ IMContextSimple = (*imContextSimple)(nil)

// WrapIMContextSimple wraps a GObject to the right type. It is
// primarily used internally.
func WrapIMContextSimple(obj *externglib.Object) IMContextSimple {
	return IMContextSimple{
		IMContext: WrapIMContext(obj),
	}
}

func marshalIMContextSimple(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIMContextSimple(obj), nil
}

// NewIMContextSimple constructs a class IMContextSimple.
func NewIMContextSimple() IMContextSimple {

	ret := C.gtk_im_context_simple_new()

	var ret0 IMContextSimple

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(IMContextSimple)

	return ret0
}

// AddComposeFile adds an additional table from the X11 compose file.
func (contextSimple imContextSimple) AddComposeFile(composeFile string) {
	var arg0 *C.GtkIMContextSimple
	var arg1 *C.gchar

	arg0 = (*C.GtkIMContextSimple)(contextSimple.Native())
	arg1 = (*C.gchar)(C.CString(composeFile))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_im_context_simple_add_compose_file(arg0, arg1)
}

type IMMulticontext interface {
	IMContext

	// AppendMenuitems: add menuitems for various available input methods to a
	// menu; the menuitems, when selected, will switch the input method for the
	// context and the global default input method.
	AppendMenuitems(menushell MenuShell)
	// ContextID gets the id of the currently active slave of the @context.
	ContextID() string
	// SetContextID sets the context id for @context.
	//
	// This causes the currently active slave of @context to be replaced by the
	// slave corresponding to the new context id.
	SetContextID(contextID string)
}

// imMulticontext implements the IMMulticontext interface.
type imMulticontext struct {
	IMContext
}

var _ IMMulticontext = (*imMulticontext)(nil)

// WrapIMMulticontext wraps a GObject to the right type. It is
// primarily used internally.
func WrapIMMulticontext(obj *externglib.Object) IMMulticontext {
	return IMMulticontext{
		IMContext: WrapIMContext(obj),
	}
}

func marshalIMMulticontext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIMMulticontext(obj), nil
}

// NewIMMulticontext constructs a class IMMulticontext.
func NewIMMulticontext() IMMulticontext {

	ret := C.gtk_im_multicontext_new()

	var ret0 IMMulticontext

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(IMMulticontext)

	return ret0
}

// AppendMenuitems: add menuitems for various available input methods to a
// menu; the menuitems, when selected, will switch the input method for the
// context and the global default input method.
func (context imMulticontext) AppendMenuitems(menushell MenuShell) {
	var arg0 *C.GtkIMMulticontext
	var arg1 *C.GtkMenuShell

	arg0 = (*C.GtkIMMulticontext)(context.Native())
	arg1 = (*C.GtkMenuShell)(menushell.Native())

	C.gtk_im_multicontext_append_menuitems(arg0, arg1)
}

// ContextID gets the id of the currently active slave of the @context.
func (context imMulticontext) ContextID() string {
	var arg0 *C.GtkIMMulticontext

	arg0 = (*C.GtkIMMulticontext)(context.Native())

	ret := C.gtk_im_multicontext_get_context_id(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// SetContextID sets the context id for @context.
//
// This causes the currently active slave of @context to be replaced by the
// slave corresponding to the new context id.
func (context imMulticontext) SetContextID(contextID string) {
	var arg0 *C.GtkIMMulticontext
	var arg1 *C.char

	arg0 = (*C.GtkIMMulticontext)(context.Native())
	arg1 = (*C.gchar)(C.CString(contextID))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_im_multicontext_set_context_id(arg0, arg1)
}

// IconFactory: an icon factory manages a collection of IconSet; a IconSet
// manages a set of variants of a particular icon (i.e. a IconSet contains
// variants for different sizes and widget states). Icons in an icon factory are
// named by a stock ID, which is a simple string identifying the icon. Each
// Style has a list of IconFactory derived from the current theme; those icon
// factories are consulted first when searching for an icon. If the theme
// doesn’t set a particular icon, GTK+ looks for the icon in a list of default
// icon factories, maintained by gtk_icon_factory_add_default() and
// gtk_icon_factory_remove_default(). Applications with icons should add a
// default icon factory with their icons, which will allow themes to override
// the icons for the application.
//
// To display an icon, always use gtk_style_lookup_icon_set() on the widget that
// will display the icon, or the convenience function gtk_widget_render_icon().
// These functions take the theme into account when looking up the icon to use
// for a given stock ID.
//
//
// GtkIconFactory as GtkBuildable
//
// GtkIconFactory supports a custom <sources> element, which can contain
// multiple <source> elements. The following attributes are allowed:
//
// - stock-id
//
//    The stock id of the source, a string. This attribute is
//    mandatory
//
// - filename
//
//    The filename of the source, a string.  This attribute is
//    optional
//
// - icon-name
//
//    The icon name for the source, a string.  This attribute is
//    optional.
//
// - size
//
//    Size of the icon, a IconSize enum value.  This attribute is
//    optional.
//
// - direction
//
//    Direction of the source, a TextDirection enum value.  This
//    attribute is optional.
//
// - state
//
//    State of the source, a StateType enum value.  This
//    attribute is optional.
//
// A IconFactory UI definition fragment. ##
//
//    <object class="GtkIconFactory" id="iconfactory1">
//      <sources>
//        <source stock-id="apple-red" filename="apple-red.png"/>
//      </sources>
//    </object>
//    <object class="GtkWindow" id="window1">
//      <child>
//        <object class="GtkButton" id="apple_button">
//          <property name="label">apple-red</property>
//          <property name="use-stock">True</property>
//        </object>
//      </child>
//    </object>
type IconFactory interface {
	gextras.Objector
	Buildable

	// Add adds the given @icon_set to the icon factory, under the name
	// @stock_id. @stock_id should be namespaced for your application, e.g.
	// “myapp-whatever-icon”. Normally applications create a IconFactory, then
	// add it to the list of default factories with
	// gtk_icon_factory_add_default(). Then they pass the @stock_id to widgets
	// such as Image to display the icon. Themes can provide an icon with the
	// same name (such as "myapp-whatever-icon") to override your application’s
	// default icons. If an icon already existed in @factory for @stock_id, it
	// is unreferenced and replaced with the new @icon_set.
	Add(stockID string, iconSet *IconSet)
	// AddDefault adds an icon factory to the list of icon factories searched by
	// gtk_style_lookup_icon_set(). This means that, for example,
	// gtk_image_new_from_stock() will be able to find icons in @factory. There
	// will normally be an icon factory added for each library or application
	// that comes with icons. The default icon factories can be overridden by
	// themes.
	AddDefault()
	// Lookup looks up @stock_id in the icon factory, returning an icon set if
	// found, otherwise nil. For display to the user, you should use
	// gtk_style_lookup_icon_set() on the Style for the widget that will display
	// the icon, instead of using this function directly, so that themes are
	// taken into account.
	Lookup(stockID string) *IconSet
	// RemoveDefault removes an icon factory from the list of default icon
	// factories. Not normally used; you might use it for a library that can be
	// unloaded or shut down.
	RemoveDefault()
}

// iconFactory implements the IconFactory interface.
type iconFactory struct {
	gextras.Objector
	Buildable
}

var _ IconFactory = (*iconFactory)(nil)

// WrapIconFactory wraps a GObject to the right type. It is
// primarily used internally.
func WrapIconFactory(obj *externglib.Object) IconFactory {
	return IconFactory{
		Objector:  obj,
		Buildable: WrapBuildable(obj),
	}
}

func marshalIconFactory(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIconFactory(obj), nil
}

// NewIconFactory constructs a class IconFactory.
func NewIconFactory() IconFactory {

	ret := C.gtk_icon_factory_new()

	var ret0 IconFactory

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(IconFactory)

	return ret0
}

// Add adds the given @icon_set to the icon factory, under the name
// @stock_id. @stock_id should be namespaced for your application, e.g.
// “myapp-whatever-icon”. Normally applications create a IconFactory, then
// add it to the list of default factories with
// gtk_icon_factory_add_default(). Then they pass the @stock_id to widgets
// such as Image to display the icon. Themes can provide an icon with the
// same name (such as "myapp-whatever-icon") to override your application’s
// default icons. If an icon already existed in @factory for @stock_id, it
// is unreferenced and replaced with the new @icon_set.
func (factory iconFactory) Add(stockID string, iconSet *IconSet) {
	var arg0 *C.GtkIconFactory
	var arg1 *C.gchar
	var arg2 *C.GtkIconSet

	arg0 = (*C.GtkIconFactory)(factory.Native())
	arg1 = (*C.gchar)(C.CString(stockID))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GtkIconSet)(iconSet.Native())

	C.gtk_icon_factory_add(arg0, arg1, arg2)
}

// AddDefault adds an icon factory to the list of icon factories searched by
// gtk_style_lookup_icon_set(). This means that, for example,
// gtk_image_new_from_stock() will be able to find icons in @factory. There
// will normally be an icon factory added for each library or application
// that comes with icons. The default icon factories can be overridden by
// themes.
func (factory iconFactory) AddDefault() {
	var arg0 *C.GtkIconFactory

	arg0 = (*C.GtkIconFactory)(factory.Native())

	C.gtk_icon_factory_add_default(arg0)
}

// Lookup looks up @stock_id in the icon factory, returning an icon set if
// found, otherwise nil. For display to the user, you should use
// gtk_style_lookup_icon_set() on the Style for the widget that will display
// the icon, instead of using this function directly, so that themes are
// taken into account.
func (factory iconFactory) Lookup(stockID string) *IconSet {
	var arg0 *C.GtkIconFactory
	var arg1 *C.gchar

	arg0 = (*C.GtkIconFactory)(factory.Native())
	arg1 = (*C.gchar)(C.CString(stockID))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_icon_factory_lookup(arg0, arg1)

	var ret0 *IconSet

	{
		ret0 = WrapIconSet(unsafe.Pointer(ret))
	}

	return ret0
}

// RemoveDefault removes an icon factory from the list of default icon
// factories. Not normally used; you might use it for a library that can be
// unloaded or shut down.
func (factory iconFactory) RemoveDefault() {
	var arg0 *C.GtkIconFactory

	arg0 = (*C.GtkIconFactory)(factory.Native())

	C.gtk_icon_factory_remove_default(arg0)
}

// IconInfo contains information found when looking up an icon in an icon theme.
type IconInfo interface {
	gextras.Objector

	// Copy: make a copy of a IconInfo.
	Copy() IconInfo
	// Free: free a IconInfo and associated information
	Free()
	// AttachPoints: this function is deprecated and always returns false.
	AttachPoints() (points []*gdk.Point, nPoints int, ok bool)
	// BaseScale gets the base scale for the icon. The base scale is a scale for
	// the icon that was specified by the icon theme creator. For instance an
	// icon drawn for a high-dpi screen with window scale 2 for a base size of
	// 32 will be 64 pixels tall and have a base scale of 2.
	BaseScale() int
	// BaseSize gets the base size for the icon. The base size is a size for the
	// icon that was specified by the icon theme creator. This may be different
	// than the actual size of image; an example of this is small emblem icons
	// that can be attached to a larger icon. These icons will be given the same
	// base size as the larger icons to which they are attached.
	//
	// Note that for scaled icons the base size does not include the base scale.
	BaseSize() int
	// BuiltinPixbuf gets the built-in image for this icon, if any. To allow
	// GTK+ to use built in icon images, you must pass the
	// GTK_ICON_LOOKUP_USE_BUILTIN to gtk_icon_theme_lookup_icon().
	BuiltinPixbuf() gdkpixbuf.Pixbuf
	// DisplayName: this function is deprecated and always returns nil.
	DisplayName() string
	// EmbeddedRect: this function is deprecated and always returns false.
	EmbeddedRect() (rectangle gdk.Rectangle, ok bool)
	// Filename gets the filename for the icon. If the
	// GTK_ICON_LOOKUP_USE_BUILTIN flag was passed to
	// gtk_icon_theme_lookup_icon(), there may be no filename if a builtin icon
	// is returned; in this case, you should use
	// gtk_icon_info_get_builtin_pixbuf().
	Filename() string
	// IsSymbolic checks if the icon is symbolic or not. This currently uses
	// only the file name and not the file contents for determining this. This
	// behaviour may change in the future.
	IsSymbolic() bool
	// LoadIcon renders an icon previously looked up in an icon theme using
	// gtk_icon_theme_lookup_icon(); the size will be based on the size passed
	// to gtk_icon_theme_lookup_icon(). Note that the resulting pixbuf may not
	// be exactly this size; an icon theme may have icons that differ slightly
	// from their nominal sizes, and in addition GTK+ will avoid scaling icons
	// that it considers sufficiently close to the requested size or for which
	// the source image would have to be scaled up too far. (This maintains
	// sharpness.). This behaviour can be changed by passing the
	// GTK_ICON_LOOKUP_FORCE_SIZE flag when obtaining the IconInfo. If this flag
	// has been specified, the pixbuf returned by this function will be scaled
	// to the exact size.
	LoadIcon() (pixbuf gdkpixbuf.Pixbuf, err error)
	// LoadIconAsync: asynchronously load, render and scale an icon previously
	// looked up from the icon theme using gtk_icon_theme_lookup_icon().
	//
	// For more details, see gtk_icon_info_load_icon() which is the synchronous
	// version of this call.
	LoadIconAsync(cancellable gio.Cancellable, callback gio.AsyncReadyCallback)
	// LoadIconFinish finishes an async icon load, see
	// gtk_icon_info_load_icon_async().
	LoadIconFinish(res gio.AsyncResult) (pixbuf gdkpixbuf.Pixbuf, err error)
	// LoadSurface renders an icon previously looked up in an icon theme using
	// gtk_icon_theme_lookup_icon(); the size will be based on the size passed
	// to gtk_icon_theme_lookup_icon(). Note that the resulting surface may not
	// be exactly this size; an icon theme may have icons that differ slightly
	// from their nominal sizes, and in addition GTK+ will avoid scaling icons
	// that it considers sufficiently close to the requested size or for which
	// the source image would have to be scaled up too far. (This maintains
	// sharpness.). This behaviour can be changed by passing the
	// GTK_ICON_LOOKUP_FORCE_SIZE flag when obtaining the IconInfo. If this flag
	// has been specified, the pixbuf returned by this function will be scaled
	// to the exact size.
	LoadSurface(forWindow gdk.Window) (surface *cairo.Surface, err error)
	// LoadSymbolic loads an icon, modifying it to match the system colours for
	// the foreground, success, warning and error colors provided. If the icon
	// is not a symbolic one, the function will return the result from
	// gtk_icon_info_load_icon().
	//
	// This allows loading symbolic icons that will match the system theme.
	//
	// Unless you are implementing a widget, you will want to use
	// g_themed_icon_new_with_default_fallbacks() to load the icon.
	//
	// As implementation details, the icon loaded needs to be of SVG type,
	// contain the “symbolic” term as the last component of the icon name, and
	// use the “fg”, “success”, “warning” and “error” CSS styles in the SVG file
	// itself.
	//
	// See the Symbolic Icons Specification
	// (http://www.freedesktop.org/wiki/SymbolicIcons) for more information
	// about symbolic icons.
	LoadSymbolic(fg *gdk.RGBA, successColor *gdk.RGBA, warningColor *gdk.RGBA, errorColor *gdk.RGBA) (wasSymbolic bool, pixbuf gdkpixbuf.Pixbuf, err error)
	// LoadSymbolicAsync: asynchronously load, render and scale a symbolic icon
	// previously looked up from the icon theme using
	// gtk_icon_theme_lookup_icon().
	//
	// For more details, see gtk_icon_info_load_symbolic() which is the
	// synchronous version of this call.
	LoadSymbolicAsync(fg *gdk.RGBA, successColor *gdk.RGBA, warningColor *gdk.RGBA, errorColor *gdk.RGBA, cancellable gio.Cancellable, callback gio.AsyncReadyCallback)
	// LoadSymbolicFinish finishes an async icon load, see
	// gtk_icon_info_load_symbolic_async().
	LoadSymbolicFinish(res gio.AsyncResult) (wasSymbolic bool, pixbuf gdkpixbuf.Pixbuf, err error)
	// LoadSymbolicForContext loads an icon, modifying it to match the system
	// colors for the foreground, success, warning and error colors provided. If
	// the icon is not a symbolic one, the function will return the result from
	// gtk_icon_info_load_icon(). This function uses the regular foreground
	// color and the symbolic colors with the names “success_color”,
	// “warning_color” and “error_color” from the context.
	//
	// This allows loading symbolic icons that will match the system theme.
	//
	// See gtk_icon_info_load_symbolic() for more details.
	LoadSymbolicForContext(context StyleContext) (wasSymbolic bool, pixbuf gdkpixbuf.Pixbuf, err error)
	// LoadSymbolicForContextAsync: asynchronously load, render and scale a
	// symbolic icon previously looked up from the icon theme using
	// gtk_icon_theme_lookup_icon().
	//
	// For more details, see gtk_icon_info_load_symbolic_for_context() which is
	// the synchronous version of this call.
	LoadSymbolicForContextAsync(context StyleContext, cancellable gio.Cancellable, callback gio.AsyncReadyCallback)
	// LoadSymbolicForContextFinish finishes an async icon load, see
	// gtk_icon_info_load_symbolic_for_context_async().
	LoadSymbolicForContextFinish(res gio.AsyncResult) (wasSymbolic bool, pixbuf gdkpixbuf.Pixbuf, err error)
	// LoadSymbolicForStyle loads an icon, modifying it to match the system
	// colours for the foreground, success, warning and error colors provided.
	// If the icon is not a symbolic one, the function will return the result
	// from gtk_icon_info_load_icon().
	//
	// This allows loading symbolic icons that will match the system theme.
	//
	// See gtk_icon_info_load_symbolic() for more details.
	LoadSymbolicForStyle(style Style, state StateType) (wasSymbolic bool, pixbuf gdkpixbuf.Pixbuf, err error)
	// SetRawCoordinates sets whether the coordinates returned by
	// gtk_icon_info_get_embedded_rect() and gtk_icon_info_get_attach_points()
	// should be returned in their original form as specified in the icon theme,
	// instead of scaled appropriately for the pixbuf returned by
	// gtk_icon_info_load_icon().
	//
	// Raw coordinates are somewhat strange; they are specified to be with
	// respect to the unscaled pixmap for PNG and XPM icons, but for SVG icons,
	// they are in a 1000x1000 coordinate space that is scaled to the final size
	// of the icon. You can determine if the icon is an SVG icon by using
	// gtk_icon_info_get_filename(), and seeing if it is non-nil and ends in
	// “.svg”.
	//
	// This function is provided primarily to allow compatibility wrappers for
	// older API's, and is not expected to be useful for applications.
	SetRawCoordinates(rawCoordinates bool)
}

// iconInfo implements the IconInfo interface.
type iconInfo struct {
	gextras.Objector
}

var _ IconInfo = (*iconInfo)(nil)

// WrapIconInfo wraps a GObject to the right type. It is
// primarily used internally.
func WrapIconInfo(obj *externglib.Object) IconInfo {
	return IconInfo{
		Objector: obj,
	}
}

func marshalIconInfo(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIconInfo(obj), nil
}

// NewIconInfoForPixbuf constructs a class IconInfo.
func NewIconInfoForPixbuf(iconTheme IconTheme, pixbuf gdkpixbuf.Pixbuf) IconInfo {
	var arg1 *C.GtkIconTheme
	var arg2 *C.GdkPixbuf

	arg1 = (*C.GtkIconTheme)(iconTheme.Native())
	arg2 = (*C.GdkPixbuf)(pixbuf.Native())

	ret := C.gtk_icon_info_new_for_pixbuf(arg1, arg2)

	var ret0 IconInfo

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(IconInfo)

	return ret0
}

// Copy: make a copy of a IconInfo.
func (iconInfo iconInfo) Copy() IconInfo {
	var arg0 *C.GtkIconInfo

	arg0 = (*C.GtkIconInfo)(iconInfo.Native())

	ret := C.gtk_icon_info_copy(arg0)

	var ret0 IconInfo

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(IconInfo)

	return ret0
}

// Free: free a IconInfo and associated information
func (iconInfo iconInfo) Free() {
	var arg0 *C.GtkIconInfo

	arg0 = (*C.GtkIconInfo)(iconInfo.Native())

	C.gtk_icon_info_free(arg0)
}

// AttachPoints: this function is deprecated and always returns false.
func (iconInfo iconInfo) AttachPoints() (points []*gdk.Point, nPoints int, ok bool) {
	var arg0 *C.GtkIconInfo
	var arg1 **C.GdkPoint // out
	var arg2 *C.gint      // out

	arg0 = (*C.GtkIconInfo)(iconInfo.Native())

	ret := C.gtk_icon_info_get_attach_points(arg0, &arg1, &arg2)

	var ret0 []*gdk.Point
	var ret1 int
	var ret2 bool

	{
		ret0 = make([]*gdk.Point, arg2)
		for i := 0; i < uintptr(arg2); i++ {
			src := (*C.GdkPoint)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			{
				ret0[i] = gdk.WrapPoint(unsafe.Pointer(src))
				runtime.SetFinalizer(ret0[i], func(v *gdk.Point) {
					C.free(unsafe.Pointer(v.Native()))
				})
			}
		}
	}

	ret1 = int(arg2)

	ret2 = C.BOOL(ret) != 0

	return ret0, ret1, ret2
}

// BaseScale gets the base scale for the icon. The base scale is a scale for
// the icon that was specified by the icon theme creator. For instance an
// icon drawn for a high-dpi screen with window scale 2 for a base size of
// 32 will be 64 pixels tall and have a base scale of 2.
func (iconInfo iconInfo) BaseScale() int {
	var arg0 *C.GtkIconInfo

	arg0 = (*C.GtkIconInfo)(iconInfo.Native())

	ret := C.gtk_icon_info_get_base_scale(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// BaseSize gets the base size for the icon. The base size is a size for the
// icon that was specified by the icon theme creator. This may be different
// than the actual size of image; an example of this is small emblem icons
// that can be attached to a larger icon. These icons will be given the same
// base size as the larger icons to which they are attached.
//
// Note that for scaled icons the base size does not include the base scale.
func (iconInfo iconInfo) BaseSize() int {
	var arg0 *C.GtkIconInfo

	arg0 = (*C.GtkIconInfo)(iconInfo.Native())

	ret := C.gtk_icon_info_get_base_size(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// BuiltinPixbuf gets the built-in image for this icon, if any. To allow
// GTK+ to use built in icon images, you must pass the
// GTK_ICON_LOOKUP_USE_BUILTIN to gtk_icon_theme_lookup_icon().
func (iconInfo iconInfo) BuiltinPixbuf() gdkpixbuf.Pixbuf {
	var arg0 *C.GtkIconInfo

	arg0 = (*C.GtkIconInfo)(iconInfo.Native())

	ret := C.gtk_icon_info_get_builtin_pixbuf(arg0)

	var ret0 gdkpixbuf.Pixbuf

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gdkpixbuf.Pixbuf)

	return ret0
}

// DisplayName: this function is deprecated and always returns nil.
func (iconInfo iconInfo) DisplayName() string {
	var arg0 *C.GtkIconInfo

	arg0 = (*C.GtkIconInfo)(iconInfo.Native())

	ret := C.gtk_icon_info_get_display_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// EmbeddedRect: this function is deprecated and always returns false.
func (iconInfo iconInfo) EmbeddedRect() (rectangle gdk.Rectangle, ok bool) {
	var arg0 *C.GtkIconInfo
	var arg1 *C.GdkRectangle // out

	arg0 = (*C.GtkIconInfo)(iconInfo.Native())

	ret := C.gtk_icon_info_get_embedded_rect(arg0, &arg1)

	var ret0 *gdk.Rectangle
	var ret1 bool

	{
		ret0 = gdk.WrapRectangle(unsafe.Pointer(arg1))
	}

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// Filename gets the filename for the icon. If the
// GTK_ICON_LOOKUP_USE_BUILTIN flag was passed to
// gtk_icon_theme_lookup_icon(), there may be no filename if a builtin icon
// is returned; in this case, you should use
// gtk_icon_info_get_builtin_pixbuf().
func (iconInfo iconInfo) Filename() string {
	var arg0 *C.GtkIconInfo

	arg0 = (*C.GtkIconInfo)(iconInfo.Native())

	ret := C.gtk_icon_info_get_filename(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// IsSymbolic checks if the icon is symbolic or not. This currently uses
// only the file name and not the file contents for determining this. This
// behaviour may change in the future.
func (iconInfo iconInfo) IsSymbolic() bool {
	var arg0 *C.GtkIconInfo

	arg0 = (*C.GtkIconInfo)(iconInfo.Native())

	ret := C.gtk_icon_info_is_symbolic(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// LoadIcon renders an icon previously looked up in an icon theme using
// gtk_icon_theme_lookup_icon(); the size will be based on the size passed
// to gtk_icon_theme_lookup_icon(). Note that the resulting pixbuf may not
// be exactly this size; an icon theme may have icons that differ slightly
// from their nominal sizes, and in addition GTK+ will avoid scaling icons
// that it considers sufficiently close to the requested size or for which
// the source image would have to be scaled up too far. (This maintains
// sharpness.). This behaviour can be changed by passing the
// GTK_ICON_LOOKUP_FORCE_SIZE flag when obtaining the IconInfo. If this flag
// has been specified, the pixbuf returned by this function will be scaled
// to the exact size.
func (iconInfo iconInfo) LoadIcon() (pixbuf gdkpixbuf.Pixbuf, err error) {
	var arg0 *C.GtkIconInfo
	var gError *C.GError

	arg0 = (*C.GtkIconInfo)(iconInfo.Native())

	ret := C.gtk_icon_info_load_icon(arg0, &gError)

	var ret0 gdkpixbuf.Pixbuf
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gdkpixbuf.Pixbuf)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// LoadIconAsync: asynchronously load, render and scale an icon previously
// looked up from the icon theme using gtk_icon_theme_lookup_icon().
//
// For more details, see gtk_icon_info_load_icon() which is the synchronous
// version of this call.
func (iconInfo iconInfo) LoadIconAsync(cancellable gio.Cancellable, callback gio.AsyncReadyCallback) {
	var arg0 *C.GtkIconInfo
	var arg1 *C.GCancellable
	var arg2 C.GAsyncReadyCallback
	var arg3 C.gpointer

	arg0 = (*C.GtkIconInfo)(iconInfo.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())
	arg2 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg3 = C.gpointer(box.Assign(callback))

	C.gtk_icon_info_load_icon_async(arg0, arg1, arg2, arg3)
}

// LoadIconFinish finishes an async icon load, see
// gtk_icon_info_load_icon_async().
func (iconInfo iconInfo) LoadIconFinish(res gio.AsyncResult) (pixbuf gdkpixbuf.Pixbuf, err error) {
	var arg0 *C.GtkIconInfo
	var arg1 *C.GAsyncResult
	var gError *C.GError

	arg0 = (*C.GtkIconInfo)(iconInfo.Native())
	arg1 = (*C.GAsyncResult)(res.Native())

	ret := C.gtk_icon_info_load_icon_finish(arg0, arg1, &gError)

	var ret0 gdkpixbuf.Pixbuf
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gdkpixbuf.Pixbuf)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// LoadSurface renders an icon previously looked up in an icon theme using
// gtk_icon_theme_lookup_icon(); the size will be based on the size passed
// to gtk_icon_theme_lookup_icon(). Note that the resulting surface may not
// be exactly this size; an icon theme may have icons that differ slightly
// from their nominal sizes, and in addition GTK+ will avoid scaling icons
// that it considers sufficiently close to the requested size or for which
// the source image would have to be scaled up too far. (This maintains
// sharpness.). This behaviour can be changed by passing the
// GTK_ICON_LOOKUP_FORCE_SIZE flag when obtaining the IconInfo. If this flag
// has been specified, the pixbuf returned by this function will be scaled
// to the exact size.
func (iconInfo iconInfo) LoadSurface(forWindow gdk.Window) (surface *cairo.Surface, err error) {
	var arg0 *C.GtkIconInfo
	var arg1 *C.GdkWindow
	var gError *C.GError

	arg0 = (*C.GtkIconInfo)(iconInfo.Native())
	arg1 = (*C.GdkWindow)(forWindow.Native())

	ret := C.gtk_icon_info_load_surface(arg0, arg1, &gError)

	var ret0 *cairo.Surface
	var goError error

	{
		ret0 = cairo.WrapSurface(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *cairo.Surface) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// LoadSymbolic loads an icon, modifying it to match the system colours for
// the foreground, success, warning and error colors provided. If the icon
// is not a symbolic one, the function will return the result from
// gtk_icon_info_load_icon().
//
// This allows loading symbolic icons that will match the system theme.
//
// Unless you are implementing a widget, you will want to use
// g_themed_icon_new_with_default_fallbacks() to load the icon.
//
// As implementation details, the icon loaded needs to be of SVG type,
// contain the “symbolic” term as the last component of the icon name, and
// use the “fg”, “success”, “warning” and “error” CSS styles in the SVG file
// itself.
//
// See the Symbolic Icons Specification
// (http://www.freedesktop.org/wiki/SymbolicIcons) for more information
// about symbolic icons.
func (iconInfo iconInfo) LoadSymbolic(fg *gdk.RGBA, successColor *gdk.RGBA, warningColor *gdk.RGBA, errorColor *gdk.RGBA) (wasSymbolic bool, pixbuf gdkpixbuf.Pixbuf, err error) {
	var arg0 *C.GtkIconInfo
	var arg1 *C.GdkRGBA
	var arg2 *C.GdkRGBA
	var arg3 *C.GdkRGBA
	var arg4 *C.GdkRGBA
	var arg5 *C.gboolean // out
	var gError *C.GError

	arg0 = (*C.GtkIconInfo)(iconInfo.Native())
	arg1 = (*C.GdkRGBA)(fg.Native())
	arg2 = (*C.GdkRGBA)(successColor.Native())
	arg3 = (*C.GdkRGBA)(warningColor.Native())
	arg4 = (*C.GdkRGBA)(errorColor.Native())

	ret := C.gtk_icon_info_load_symbolic(arg0, arg1, arg2, arg3, arg4, &arg5, &gError)

	var ret0 bool
	var ret1 gdkpixbuf.Pixbuf
	var goError error

	ret0 = C.BOOL(arg5) != 0

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gdkpixbuf.Pixbuf)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// LoadSymbolicAsync: asynchronously load, render and scale a symbolic icon
// previously looked up from the icon theme using
// gtk_icon_theme_lookup_icon().
//
// For more details, see gtk_icon_info_load_symbolic() which is the
// synchronous version of this call.
func (iconInfo iconInfo) LoadSymbolicAsync(fg *gdk.RGBA, successColor *gdk.RGBA, warningColor *gdk.RGBA, errorColor *gdk.RGBA, cancellable gio.Cancellable, callback gio.AsyncReadyCallback) {
	var arg0 *C.GtkIconInfo
	var arg1 *C.GdkRGBA
	var arg2 *C.GdkRGBA
	var arg3 *C.GdkRGBA
	var arg4 *C.GdkRGBA
	var arg5 *C.GCancellable
	var arg6 C.GAsyncReadyCallback
	var arg7 C.gpointer

	arg0 = (*C.GtkIconInfo)(iconInfo.Native())
	arg1 = (*C.GdkRGBA)(fg.Native())
	arg2 = (*C.GdkRGBA)(successColor.Native())
	arg3 = (*C.GdkRGBA)(warningColor.Native())
	arg4 = (*C.GdkRGBA)(errorColor.Native())
	arg5 = (*C.GCancellable)(cancellable.Native())
	arg6 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg7 = C.gpointer(box.Assign(callback))

	C.gtk_icon_info_load_symbolic_async(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
}

// LoadSymbolicFinish finishes an async icon load, see
// gtk_icon_info_load_symbolic_async().
func (iconInfo iconInfo) LoadSymbolicFinish(res gio.AsyncResult) (wasSymbolic bool, pixbuf gdkpixbuf.Pixbuf, err error) {
	var arg0 *C.GtkIconInfo
	var arg1 *C.GAsyncResult
	var arg2 *C.gboolean // out
	var gError *C.GError

	arg0 = (*C.GtkIconInfo)(iconInfo.Native())
	arg1 = (*C.GAsyncResult)(res.Native())

	ret := C.gtk_icon_info_load_symbolic_finish(arg0, arg1, &arg2, &gError)

	var ret0 bool
	var ret1 gdkpixbuf.Pixbuf
	var goError error

	ret0 = C.BOOL(arg2) != 0

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gdkpixbuf.Pixbuf)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// LoadSymbolicForContext loads an icon, modifying it to match the system
// colors for the foreground, success, warning and error colors provided. If
// the icon is not a symbolic one, the function will return the result from
// gtk_icon_info_load_icon(). This function uses the regular foreground
// color and the symbolic colors with the names “success_color”,
// “warning_color” and “error_color” from the context.
//
// This allows loading symbolic icons that will match the system theme.
//
// See gtk_icon_info_load_symbolic() for more details.
func (iconInfo iconInfo) LoadSymbolicForContext(context StyleContext) (wasSymbolic bool, pixbuf gdkpixbuf.Pixbuf, err error) {
	var arg0 *C.GtkIconInfo
	var arg1 *C.GtkStyleContext
	var arg2 *C.gboolean // out
	var gError *C.GError

	arg0 = (*C.GtkIconInfo)(iconInfo.Native())
	arg1 = (*C.GtkStyleContext)(context.Native())

	ret := C.gtk_icon_info_load_symbolic_for_context(arg0, arg1, &arg2, &gError)

	var ret0 bool
	var ret1 gdkpixbuf.Pixbuf
	var goError error

	ret0 = C.BOOL(arg2) != 0

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gdkpixbuf.Pixbuf)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// LoadSymbolicForContextAsync: asynchronously load, render and scale a
// symbolic icon previously looked up from the icon theme using
// gtk_icon_theme_lookup_icon().
//
// For more details, see gtk_icon_info_load_symbolic_for_context() which is
// the synchronous version of this call.
func (iconInfo iconInfo) LoadSymbolicForContextAsync(context StyleContext, cancellable gio.Cancellable, callback gio.AsyncReadyCallback) {
	var arg0 *C.GtkIconInfo
	var arg1 *C.GtkStyleContext
	var arg2 *C.GCancellable
	var arg3 C.GAsyncReadyCallback
	var arg4 C.gpointer

	arg0 = (*C.GtkIconInfo)(iconInfo.Native())
	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = (*C.GCancellable)(cancellable.Native())
	arg3 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg4 = C.gpointer(box.Assign(callback))

	C.gtk_icon_info_load_symbolic_for_context_async(arg0, arg1, arg2, arg3, arg4)
}

// LoadSymbolicForContextFinish finishes an async icon load, see
// gtk_icon_info_load_symbolic_for_context_async().
func (iconInfo iconInfo) LoadSymbolicForContextFinish(res gio.AsyncResult) (wasSymbolic bool, pixbuf gdkpixbuf.Pixbuf, err error) {
	var arg0 *C.GtkIconInfo
	var arg1 *C.GAsyncResult
	var arg2 *C.gboolean // out
	var gError *C.GError

	arg0 = (*C.GtkIconInfo)(iconInfo.Native())
	arg1 = (*C.GAsyncResult)(res.Native())

	ret := C.gtk_icon_info_load_symbolic_for_context_finish(arg0, arg1, &arg2, &gError)

	var ret0 bool
	var ret1 gdkpixbuf.Pixbuf
	var goError error

	ret0 = C.BOOL(arg2) != 0

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gdkpixbuf.Pixbuf)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// LoadSymbolicForStyle loads an icon, modifying it to match the system
// colours for the foreground, success, warning and error colors provided.
// If the icon is not a symbolic one, the function will return the result
// from gtk_icon_info_load_icon().
//
// This allows loading symbolic icons that will match the system theme.
//
// See gtk_icon_info_load_symbolic() for more details.
func (iconInfo iconInfo) LoadSymbolicForStyle(style Style, state StateType) (wasSymbolic bool, pixbuf gdkpixbuf.Pixbuf, err error) {
	var arg0 *C.GtkIconInfo
	var arg1 *C.GtkStyle
	var arg2 C.GtkStateType
	var arg3 *C.gboolean // out
	var gError *C.GError

	arg0 = (*C.GtkIconInfo)(iconInfo.Native())
	arg1 = (*C.GtkStyle)(style.Native())
	arg2 = (C.GtkStateType)(state)

	ret := C.gtk_icon_info_load_symbolic_for_style(arg0, arg1, arg2, &arg3, &gError)

	var ret0 bool
	var ret1 gdkpixbuf.Pixbuf
	var goError error

	ret0 = C.BOOL(arg3) != 0

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gdkpixbuf.Pixbuf)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// SetRawCoordinates sets whether the coordinates returned by
// gtk_icon_info_get_embedded_rect() and gtk_icon_info_get_attach_points()
// should be returned in their original form as specified in the icon theme,
// instead of scaled appropriately for the pixbuf returned by
// gtk_icon_info_load_icon().
//
// Raw coordinates are somewhat strange; they are specified to be with
// respect to the unscaled pixmap for PNG and XPM icons, but for SVG icons,
// they are in a 1000x1000 coordinate space that is scaled to the final size
// of the icon. You can determine if the icon is an SVG icon by using
// gtk_icon_info_get_filename(), and seeing if it is non-nil and ends in
// “.svg”.
//
// This function is provided primarily to allow compatibility wrappers for
// older API's, and is not expected to be useful for applications.
func (iconInfo iconInfo) SetRawCoordinates(rawCoordinates bool) {
	var arg0 *C.GtkIconInfo
	var arg1 C.gboolean

	arg0 = (*C.GtkIconInfo)(iconInfo.Native())
	if rawCoordinates {
		arg1 = C.TRUE
	}

	C.gtk_icon_info_set_raw_coordinates(arg0, arg1)
}

// IconTheme provides a facility for looking up icons by name and size. The main
// reason for using a name rather than simply providing a filename is to allow
// different icons to be used depending on what “icon theme” is selected by the
// user. The operation of icon themes on Linux and Unix follows the Icon Theme
// Specification (http://www.freedesktop.org/Standards/icon-theme-spec) There is
// a fallback icon theme, named `hicolor`, where applications should install
// their icons, but additional icon themes can be installed as operating system
// vendors and users choose.
//
// Named icons are similar to the deprecated [Stock Items][gtkstock], and the
// distinction between the two may be a bit confusing. A few things to keep in
// mind:
//
// - Stock images usually are used in conjunction with [Stock Items][gtkstock],
// such as GTK_STOCK_OK or GTK_STOCK_OPEN. Named icons are easier to set up and
// therefore are more useful for new icons that an application wants to add,
// such as application icons or window icons.
//
// - Stock images can only be loaded at the symbolic sizes defined by the
// IconSize enumeration, or by custom sizes defined by gtk_icon_size_register(),
// while named icons are more flexible and any pixel size can be specified.
//
// - Because stock images are closely tied to stock items, and thus to actions
// in the user interface, stock images may come in multiple variants for
// different widget states or writing directions.
//
// A good rule of thumb is that if there is a stock image for what you want to
// use, use it, otherwise use a named icon. It turns out that internally stock
// images are generally defined in terms of one or more named icons. (An example
// of the more than one case is icons that depend on writing direction;
// GTK_STOCK_GO_FORWARD uses the two themed icons “gtk-stock-go-forward-ltr” and
// “gtk-stock-go-forward-rtl”.)
//
// In many cases, named themes are used indirectly, via Image or stock items,
// rather than directly, but looking up icons directly is also simple. The
// IconTheme object acts as a database of all the icons in the current theme.
// You can create new IconTheme objects, but it’s much more efficient to use the
// standard icon theme for the Screen so that the icon information is shared
// with other people looking up icons.
//
//    GError *error = NULL;
//    GtkIconTheme *icon_theme;
//    GdkPixbuf *pixbuf;
//
//    icon_theme = gtk_icon_theme_get_default ();
//    pixbuf = gtk_icon_theme_load_icon (icon_theme,
//                                       "my-icon-name", // icon name
//                                       48, // icon size
//                                       0,  // flags
//                                       &error);
//    if (!pixbuf)
//      {
//        g_warning ("Couldn’t load icon: s", error->message);
//        g_error_free (error);
//      }
//    else
//      {
//        // Use the pixbuf
//        g_object_unref (pixbuf);
//      }
type IconTheme interface {
	gextras.Objector

	// AddResourcePath adds a resource path that will be looked at when looking
	// for icons, similar to search paths.
	//
	// This function should be used to make application-specific icons available
	// as part of the icon theme.
	//
	// The resources are considered as part of the hicolor icon theme and must
	// be located in subdirectories that are defined in the hicolor icon theme,
	// such as `@path/16x16/actions/run.png`. Icons that are directly placed in
	// the resource path instead of a subdirectory are also considered as
	// ultimate fallback.
	AddResourcePath(path string)
	// AppendSearchPath appends a directory to the search path. See
	// gtk_icon_theme_set_search_path().
	AppendSearchPath(path string)
	// ChooseIcon looks up a named icon and returns a IconInfo containing
	// information such as the filename of the icon. The icon can then be
	// rendered into a pixbuf using gtk_icon_info_load_icon().
	// (gtk_icon_theme_load_icon() combines these two steps if all you need is
	// the pixbuf.)
	//
	// If @icon_names contains more than one name, this function tries them all
	// in the given order before falling back to inherited icon themes.
	ChooseIcon(iconNames []string, size int, flags IconLookupFlags) IconInfo
	// ChooseIconForScale looks up a named icon for a particular window scale
	// and returns a IconInfo containing information such as the filename of the
	// icon. The icon can then be rendered into a pixbuf using
	// gtk_icon_info_load_icon(). (gtk_icon_theme_load_icon() combines these two
	// steps if all you need is the pixbuf.)
	//
	// If @icon_names contains more than one name, this function tries them all
	// in the given order before falling back to inherited icon themes.
	ChooseIconForScale(iconNames []string, size int, scale int, flags IconLookupFlags) IconInfo
	// ExampleIconName gets the name of an icon that is representative of the
	// current theme (for instance, to use when presenting a list of themes to
	// the user.)
	ExampleIconName() string
	// IconSizes returns an array of integers describing the sizes at which the
	// icon is available without scaling. A size of -1 means that the icon is
	// available in a scalable format. The array is zero-terminated.
	IconSizes(iconName string) []int
	// SearchPath gets the current search path. See
	// gtk_icon_theme_set_search_path().
	SearchPath() (path []string, nElements int)
	// HasIcon checks whether an icon theme includes an icon for a particular
	// name.
	HasIcon(iconName string) bool
	// ListContexts gets the list of contexts available within the current
	// hierarchy of icon themes. See gtk_icon_theme_list_icons() for details
	// about contexts.
	ListContexts() *glib.List
	// ListIcons lists the icons in the current icon theme. Only a subset of the
	// icons can be listed by providing a context string. The set of values for
	// the context string is system dependent, but will typically include such
	// values as “Applications” and “MimeTypes”. Contexts are explained in the
	// Icon Theme Specification
	// (http://www.freedesktop.org/wiki/Specifications/icon-theme-spec). The
	// standard contexts are listed in the Icon Naming Specification
	// (http://www.freedesktop.org/wiki/Specifications/icon-naming-spec). Also
	// see gtk_icon_theme_list_contexts().
	ListIcons(context string) *glib.List
	// LoadIcon looks up an icon in an icon theme, scales it to the given size
	// and renders it into a pixbuf. This is a convenience function; if more
	// details about the icon are needed, use gtk_icon_theme_lookup_icon()
	// followed by gtk_icon_info_load_icon().
	//
	// Note that you probably want to listen for icon theme changes and update
	// the icon. This is usually done by connecting to the GtkWidget::style-set
	// signal. If for some reason you do not want to update the icon when the
	// icon theme changes, you should consider using gdk_pixbuf_copy() to make a
	// private copy of the pixbuf returned by this function. Otherwise GTK+ may
	// need to keep the old icon theme loaded, which would be a waste of memory.
	LoadIcon(iconName string, size int, flags IconLookupFlags) (pixbuf gdkpixbuf.Pixbuf, err error)
	// LoadIconForScale looks up an icon in an icon theme for a particular
	// window scale, scales it to the given size and renders it into a pixbuf.
	// This is a convenience function; if more details about the icon are
	// needed, use gtk_icon_theme_lookup_icon() followed by
	// gtk_icon_info_load_icon().
	//
	// Note that you probably want to listen for icon theme changes and update
	// the icon. This is usually done by connecting to the GtkWidget::style-set
	// signal. If for some reason you do not want to update the icon when the
	// icon theme changes, you should consider using gdk_pixbuf_copy() to make a
	// private copy of the pixbuf returned by this function. Otherwise GTK+ may
	// need to keep the old icon theme loaded, which would be a waste of memory.
	LoadIconForScale(iconName string, size int, scale int, flags IconLookupFlags) (pixbuf gdkpixbuf.Pixbuf, err error)
	// LoadSurface looks up an icon in an icon theme for a particular window
	// scale, scales it to the given size and renders it into a cairo surface.
	// This is a convenience function; if more details about the icon are
	// needed, use gtk_icon_theme_lookup_icon() followed by
	// gtk_icon_info_load_surface().
	//
	// Note that you probably want to listen for icon theme changes and update
	// the icon. This is usually done by connecting to the GtkWidget::style-set
	// signal.
	LoadSurface(iconName string, size int, scale int, forWindow gdk.Window, flags IconLookupFlags) (surface *cairo.Surface, err error)
	// LookupByGIcon looks up an icon and returns a IconInfo containing
	// information such as the filename of the icon. The icon can then be
	// rendered into a pixbuf using gtk_icon_info_load_icon().
	//
	// When rendering on displays with high pixel densities you should not use a
	// @size multiplied by the scaling factor returned by functions like
	// gdk_window_get_scale_factor(). Instead, you should use
	// gtk_icon_theme_lookup_by_gicon_for_scale(), as the assets loaded for a
	// given scaling factor may be different.
	LookupByGIcon(icon gio.Icon, size int, flags IconLookupFlags) IconInfo
	// LookupByGIconForScale looks up an icon and returns a IconInfo containing
	// information such as the filename of the icon. The icon can then be
	// rendered into a pixbuf using gtk_icon_info_load_icon().
	LookupByGIconForScale(icon gio.Icon, size int, scale int, flags IconLookupFlags) IconInfo
	// LookupIcon looks up a named icon and returns a IconInfo containing
	// information such as the filename of the icon. The icon can then be
	// rendered into a pixbuf using gtk_icon_info_load_icon().
	// (gtk_icon_theme_load_icon() combines these two steps if all you need is
	// the pixbuf.)
	//
	// When rendering on displays with high pixel densities you should not use a
	// @size multiplied by the scaling factor returned by functions like
	// gdk_window_get_scale_factor(). Instead, you should use
	// gtk_icon_theme_lookup_icon_for_scale(), as the assets loaded for a given
	// scaling factor may be different.
	LookupIcon(iconName string, size int, flags IconLookupFlags) IconInfo
	// LookupIconForScale looks up a named icon for a particular window scale
	// and returns a IconInfo containing information such as the filename of the
	// icon. The icon can then be rendered into a pixbuf using
	// gtk_icon_info_load_icon(). (gtk_icon_theme_load_icon() combines these two
	// steps if all you need is the pixbuf.)
	LookupIconForScale(iconName string, size int, scale int, flags IconLookupFlags) IconInfo
	// PrependSearchPath prepends a directory to the search path. See
	// gtk_icon_theme_set_search_path().
	PrependSearchPath(path string)
	// RescanIfNeeded checks to see if the icon theme has changed; if it has,
	// any currently cached information is discarded and will be reloaded next
	// time @icon_theme is accessed.
	RescanIfNeeded() bool
	// SetCustomTheme sets the name of the icon theme that the IconTheme object
	// uses overriding system configuration. This function cannot be called on
	// the icon theme objects returned from gtk_icon_theme_get_default() and
	// gtk_icon_theme_get_for_screen().
	SetCustomTheme(themeName string)
	// SetScreen sets the screen for an icon theme; the screen is used to track
	// the user’s currently configured icon theme, which might be different for
	// different screens.
	SetScreen(screen gdk.Screen)
	// SetSearchPath sets the search path for the icon theme object. When
	// looking for an icon theme, GTK+ will search for a subdirectory of one or
	// more of the directories in @path with the same name as the icon theme
	// containing an index.theme file. (Themes from multiple of the path
	// elements are combined to allow themes to be extended by adding icons in
	// the user’s home directory.)
	//
	// In addition if an icon found isn’t found either in the current icon theme
	// or the default icon theme, and an image file with the right name is found
	// directly in one of the elements of @path, then that image will be used
	// for the icon name. (This is legacy feature, and new icons should be put
	// into the fallback icon theme, which is called hicolor, rather than
	// directly on the icon path.)
	SetSearchPath(path []string)
}

// iconTheme implements the IconTheme interface.
type iconTheme struct {
	gextras.Objector
}

var _ IconTheme = (*iconTheme)(nil)

// WrapIconTheme wraps a GObject to the right type. It is
// primarily used internally.
func WrapIconTheme(obj *externglib.Object) IconTheme {
	return IconTheme{
		Objector: obj,
	}
}

func marshalIconTheme(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIconTheme(obj), nil
}

// NewIconTheme constructs a class IconTheme.
func NewIconTheme() IconTheme {

	ret := C.gtk_icon_theme_new()

	var ret0 IconTheme

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(IconTheme)

	return ret0
}

// AddResourcePath adds a resource path that will be looked at when looking
// for icons, similar to search paths.
//
// This function should be used to make application-specific icons available
// as part of the icon theme.
//
// The resources are considered as part of the hicolor icon theme and must
// be located in subdirectories that are defined in the hicolor icon theme,
// such as `@path/16x16/actions/run.png`. Icons that are directly placed in
// the resource path instead of a subdirectory are also considered as
// ultimate fallback.
func (iconTheme iconTheme) AddResourcePath(path string) {
	var arg0 *C.GtkIconTheme
	var arg1 *C.gchar

	arg0 = (*C.GtkIconTheme)(iconTheme.Native())
	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_icon_theme_add_resource_path(arg0, arg1)
}

// AppendSearchPath appends a directory to the search path. See
// gtk_icon_theme_set_search_path().
func (iconTheme iconTheme) AppendSearchPath(path string) {
	var arg0 *C.GtkIconTheme
	var arg1 *C.gchar

	arg0 = (*C.GtkIconTheme)(iconTheme.Native())
	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_icon_theme_append_search_path(arg0, arg1)
}

// ChooseIcon looks up a named icon and returns a IconInfo containing
// information such as the filename of the icon. The icon can then be
// rendered into a pixbuf using gtk_icon_info_load_icon().
// (gtk_icon_theme_load_icon() combines these two steps if all you need is
// the pixbuf.)
//
// If @icon_names contains more than one name, this function tries them all
// in the given order before falling back to inherited icon themes.
func (iconTheme iconTheme) ChooseIcon(iconNames []string, size int, flags IconLookupFlags) IconInfo {
	var arg0 *C.GtkIconTheme
	var arg1 **C.gchar
	var arg2 C.gint
	var arg3 C.GtkIconLookupFlags

	arg0 = (*C.GtkIconTheme)(iconTheme.Native())
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(iconNames) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(iconNames)
		sliceHeader.Cap = len(iconNames)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(iconNames); i++ {
			src := iconNames[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg1 = (**C.gchar)(unsafe.Pointer(ptr))
	}
	arg2 = C.gint(size)
	arg3 = (C.GtkIconLookupFlags)(flags)

	ret := C.gtk_icon_theme_choose_icon(arg0, arg1, arg2, arg3)

	var ret0 IconInfo

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(IconInfo)

	return ret0
}

// ChooseIconForScale looks up a named icon for a particular window scale
// and returns a IconInfo containing information such as the filename of the
// icon. The icon can then be rendered into a pixbuf using
// gtk_icon_info_load_icon(). (gtk_icon_theme_load_icon() combines these two
// steps if all you need is the pixbuf.)
//
// If @icon_names contains more than one name, this function tries them all
// in the given order before falling back to inherited icon themes.
func (iconTheme iconTheme) ChooseIconForScale(iconNames []string, size int, scale int, flags IconLookupFlags) IconInfo {
	var arg0 *C.GtkIconTheme
	var arg1 **C.gchar
	var arg2 C.gint
	var arg3 C.gint
	var arg4 C.GtkIconLookupFlags

	arg0 = (*C.GtkIconTheme)(iconTheme.Native())
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(iconNames) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(iconNames)
		sliceHeader.Cap = len(iconNames)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(iconNames); i++ {
			src := iconNames[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg1 = (**C.gchar)(unsafe.Pointer(ptr))
	}
	arg2 = C.gint(size)
	arg3 = C.gint(scale)
	arg4 = (C.GtkIconLookupFlags)(flags)

	ret := C.gtk_icon_theme_choose_icon_for_scale(arg0, arg1, arg2, arg3, arg4)

	var ret0 IconInfo

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(IconInfo)

	return ret0
}

// ExampleIconName gets the name of an icon that is representative of the
// current theme (for instance, to use when presenting a list of themes to
// the user.)
func (iconTheme iconTheme) ExampleIconName() string {
	var arg0 *C.GtkIconTheme

	arg0 = (*C.GtkIconTheme)(iconTheme.Native())

	ret := C.gtk_icon_theme_get_example_icon_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// IconSizes returns an array of integers describing the sizes at which the
// icon is available without scaling. A size of -1 means that the icon is
// available in a scalable format. The array is zero-terminated.
func (iconTheme iconTheme) IconSizes(iconName string) []int {
	var arg0 *C.GtkIconTheme
	var arg1 *C.gchar

	arg0 = (*C.GtkIconTheme)(iconTheme.Native())
	arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_icon_theme_get_icon_sizes(arg0, arg1)

	var ret0 []int

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]int, length)
		for i := 0; i < length; i++ {
			src := (C.gint)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = int(src)
		}
	}

	return ret0
}

// SearchPath gets the current search path. See
// gtk_icon_theme_set_search_path().
func (iconTheme iconTheme) SearchPath() (path []string, nElements int) {
	var arg0 *C.GtkIconTheme
	var arg1 ***C.gchar // out
	var arg2 *C.gint    // out

	arg0 = (*C.GtkIconTheme)(iconTheme.Native())

	C.gtk_icon_theme_get_search_path(arg0, &arg1, &arg2)

	var ret0 []string
	var ret1 int

	{
		ret0 = make([]string, arg2)
		for i := 0; i < uintptr(arg2); i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	ret1 = int(arg2)

	return ret0, ret1
}

// HasIcon checks whether an icon theme includes an icon for a particular
// name.
func (iconTheme iconTheme) HasIcon(iconName string) bool {
	var arg0 *C.GtkIconTheme
	var arg1 *C.gchar

	arg0 = (*C.GtkIconTheme)(iconTheme.Native())
	arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_icon_theme_has_icon(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ListContexts gets the list of contexts available within the current
// hierarchy of icon themes. See gtk_icon_theme_list_icons() for details
// about contexts.
func (iconTheme iconTheme) ListContexts() *glib.List {
	var arg0 *C.GtkIconTheme

	arg0 = (*C.GtkIconTheme)(iconTheme.Native())

	ret := C.gtk_icon_theme_list_contexts(arg0)

	var ret0 *glib.List

	{
		ret0 = glib.WrapList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.List) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// ListIcons lists the icons in the current icon theme. Only a subset of the
// icons can be listed by providing a context string. The set of values for
// the context string is system dependent, but will typically include such
// values as “Applications” and “MimeTypes”. Contexts are explained in the
// Icon Theme Specification
// (http://www.freedesktop.org/wiki/Specifications/icon-theme-spec). The
// standard contexts are listed in the Icon Naming Specification
// (http://www.freedesktop.org/wiki/Specifications/icon-naming-spec). Also
// see gtk_icon_theme_list_contexts().
func (iconTheme iconTheme) ListIcons(context string) *glib.List {
	var arg0 *C.GtkIconTheme
	var arg1 *C.gchar

	arg0 = (*C.GtkIconTheme)(iconTheme.Native())
	arg1 = (*C.gchar)(C.CString(context))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_icon_theme_list_icons(arg0, arg1)

	var ret0 *glib.List

	{
		ret0 = glib.WrapList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.List) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// LoadIcon looks up an icon in an icon theme, scales it to the given size
// and renders it into a pixbuf. This is a convenience function; if more
// details about the icon are needed, use gtk_icon_theme_lookup_icon()
// followed by gtk_icon_info_load_icon().
//
// Note that you probably want to listen for icon theme changes and update
// the icon. This is usually done by connecting to the GtkWidget::style-set
// signal. If for some reason you do not want to update the icon when the
// icon theme changes, you should consider using gdk_pixbuf_copy() to make a
// private copy of the pixbuf returned by this function. Otherwise GTK+ may
// need to keep the old icon theme loaded, which would be a waste of memory.
func (iconTheme iconTheme) LoadIcon(iconName string, size int, flags IconLookupFlags) (pixbuf gdkpixbuf.Pixbuf, err error) {
	var arg0 *C.GtkIconTheme
	var arg1 *C.gchar
	var arg2 C.gint
	var arg3 C.GtkIconLookupFlags
	var gError *C.GError

	arg0 = (*C.GtkIconTheme)(iconTheme.Native())
	arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(size)
	arg3 = (C.GtkIconLookupFlags)(flags)

	ret := C.gtk_icon_theme_load_icon(arg0, arg1, arg2, arg3, &gError)

	var ret0 gdkpixbuf.Pixbuf
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gdkpixbuf.Pixbuf)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// LoadIconForScale looks up an icon in an icon theme for a particular
// window scale, scales it to the given size and renders it into a pixbuf.
// This is a convenience function; if more details about the icon are
// needed, use gtk_icon_theme_lookup_icon() followed by
// gtk_icon_info_load_icon().
//
// Note that you probably want to listen for icon theme changes and update
// the icon. This is usually done by connecting to the GtkWidget::style-set
// signal. If for some reason you do not want to update the icon when the
// icon theme changes, you should consider using gdk_pixbuf_copy() to make a
// private copy of the pixbuf returned by this function. Otherwise GTK+ may
// need to keep the old icon theme loaded, which would be a waste of memory.
func (iconTheme iconTheme) LoadIconForScale(iconName string, size int, scale int, flags IconLookupFlags) (pixbuf gdkpixbuf.Pixbuf, err error) {
	var arg0 *C.GtkIconTheme
	var arg1 *C.gchar
	var arg2 C.gint
	var arg3 C.gint
	var arg4 C.GtkIconLookupFlags
	var gError *C.GError

	arg0 = (*C.GtkIconTheme)(iconTheme.Native())
	arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(size)
	arg3 = C.gint(scale)
	arg4 = (C.GtkIconLookupFlags)(flags)

	ret := C.gtk_icon_theme_load_icon_for_scale(arg0, arg1, arg2, arg3, arg4, &gError)

	var ret0 gdkpixbuf.Pixbuf
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gdkpixbuf.Pixbuf)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// LoadSurface looks up an icon in an icon theme for a particular window
// scale, scales it to the given size and renders it into a cairo surface.
// This is a convenience function; if more details about the icon are
// needed, use gtk_icon_theme_lookup_icon() followed by
// gtk_icon_info_load_surface().
//
// Note that you probably want to listen for icon theme changes and update
// the icon. This is usually done by connecting to the GtkWidget::style-set
// signal.
func (iconTheme iconTheme) LoadSurface(iconName string, size int, scale int, forWindow gdk.Window, flags IconLookupFlags) (surface *cairo.Surface, err error) {
	var arg0 *C.GtkIconTheme
	var arg1 *C.gchar
	var arg2 C.gint
	var arg3 C.gint
	var arg4 *C.GdkWindow
	var arg5 C.GtkIconLookupFlags
	var gError *C.GError

	arg0 = (*C.GtkIconTheme)(iconTheme.Native())
	arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(size)
	arg3 = C.gint(scale)
	arg4 = (*C.GdkWindow)(forWindow.Native())
	arg5 = (C.GtkIconLookupFlags)(flags)

	ret := C.gtk_icon_theme_load_surface(arg0, arg1, arg2, arg3, arg4, arg5, &gError)

	var ret0 *cairo.Surface
	var goError error

	{
		ret0 = cairo.WrapSurface(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *cairo.Surface) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// LookupByGIcon looks up an icon and returns a IconInfo containing
// information such as the filename of the icon. The icon can then be
// rendered into a pixbuf using gtk_icon_info_load_icon().
//
// When rendering on displays with high pixel densities you should not use a
// @size multiplied by the scaling factor returned by functions like
// gdk_window_get_scale_factor(). Instead, you should use
// gtk_icon_theme_lookup_by_gicon_for_scale(), as the assets loaded for a
// given scaling factor may be different.
func (iconTheme iconTheme) LookupByGIcon(icon gio.Icon, size int, flags IconLookupFlags) IconInfo {
	var arg0 *C.GtkIconTheme
	var arg1 *C.GIcon
	var arg2 C.gint
	var arg3 C.GtkIconLookupFlags

	arg0 = (*C.GtkIconTheme)(iconTheme.Native())
	arg1 = (*C.GIcon)(icon.Native())
	arg2 = C.gint(size)
	arg3 = (C.GtkIconLookupFlags)(flags)

	ret := C.gtk_icon_theme_lookup_by_gicon(arg0, arg1, arg2, arg3)

	var ret0 IconInfo

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(IconInfo)

	return ret0
}

// LookupByGIconForScale looks up an icon and returns a IconInfo containing
// information such as the filename of the icon. The icon can then be
// rendered into a pixbuf using gtk_icon_info_load_icon().
func (iconTheme iconTheme) LookupByGIconForScale(icon gio.Icon, size int, scale int, flags IconLookupFlags) IconInfo {
	var arg0 *C.GtkIconTheme
	var arg1 *C.GIcon
	var arg2 C.gint
	var arg3 C.gint
	var arg4 C.GtkIconLookupFlags

	arg0 = (*C.GtkIconTheme)(iconTheme.Native())
	arg1 = (*C.GIcon)(icon.Native())
	arg2 = C.gint(size)
	arg3 = C.gint(scale)
	arg4 = (C.GtkIconLookupFlags)(flags)

	ret := C.gtk_icon_theme_lookup_by_gicon_for_scale(arg0, arg1, arg2, arg3, arg4)

	var ret0 IconInfo

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(IconInfo)

	return ret0
}

// LookupIcon looks up a named icon and returns a IconInfo containing
// information such as the filename of the icon. The icon can then be
// rendered into a pixbuf using gtk_icon_info_load_icon().
// (gtk_icon_theme_load_icon() combines these two steps if all you need is
// the pixbuf.)
//
// When rendering on displays with high pixel densities you should not use a
// @size multiplied by the scaling factor returned by functions like
// gdk_window_get_scale_factor(). Instead, you should use
// gtk_icon_theme_lookup_icon_for_scale(), as the assets loaded for a given
// scaling factor may be different.
func (iconTheme iconTheme) LookupIcon(iconName string, size int, flags IconLookupFlags) IconInfo {
	var arg0 *C.GtkIconTheme
	var arg1 *C.gchar
	var arg2 C.gint
	var arg3 C.GtkIconLookupFlags

	arg0 = (*C.GtkIconTheme)(iconTheme.Native())
	arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(size)
	arg3 = (C.GtkIconLookupFlags)(flags)

	ret := C.gtk_icon_theme_lookup_icon(arg0, arg1, arg2, arg3)

	var ret0 IconInfo

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(IconInfo)

	return ret0
}

// LookupIconForScale looks up a named icon for a particular window scale
// and returns a IconInfo containing information such as the filename of the
// icon. The icon can then be rendered into a pixbuf using
// gtk_icon_info_load_icon(). (gtk_icon_theme_load_icon() combines these two
// steps if all you need is the pixbuf.)
func (iconTheme iconTheme) LookupIconForScale(iconName string, size int, scale int, flags IconLookupFlags) IconInfo {
	var arg0 *C.GtkIconTheme
	var arg1 *C.gchar
	var arg2 C.gint
	var arg3 C.gint
	var arg4 C.GtkIconLookupFlags

	arg0 = (*C.GtkIconTheme)(iconTheme.Native())
	arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(size)
	arg3 = C.gint(scale)
	arg4 = (C.GtkIconLookupFlags)(flags)

	ret := C.gtk_icon_theme_lookup_icon_for_scale(arg0, arg1, arg2, arg3, arg4)

	var ret0 IconInfo

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(IconInfo)

	return ret0
}

// PrependSearchPath prepends a directory to the search path. See
// gtk_icon_theme_set_search_path().
func (iconTheme iconTheme) PrependSearchPath(path string) {
	var arg0 *C.GtkIconTheme
	var arg1 *C.gchar

	arg0 = (*C.GtkIconTheme)(iconTheme.Native())
	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_icon_theme_prepend_search_path(arg0, arg1)
}

// RescanIfNeeded checks to see if the icon theme has changed; if it has,
// any currently cached information is discarded and will be reloaded next
// time @icon_theme is accessed.
func (iconTheme iconTheme) RescanIfNeeded() bool {
	var arg0 *C.GtkIconTheme

	arg0 = (*C.GtkIconTheme)(iconTheme.Native())

	ret := C.gtk_icon_theme_rescan_if_needed(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SetCustomTheme sets the name of the icon theme that the IconTheme object
// uses overriding system configuration. This function cannot be called on
// the icon theme objects returned from gtk_icon_theme_get_default() and
// gtk_icon_theme_get_for_screen().
func (iconTheme iconTheme) SetCustomTheme(themeName string) {
	var arg0 *C.GtkIconTheme
	var arg1 *C.gchar

	arg0 = (*C.GtkIconTheme)(iconTheme.Native())
	arg1 = (*C.gchar)(C.CString(themeName))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_icon_theme_set_custom_theme(arg0, arg1)
}

// SetScreen sets the screen for an icon theme; the screen is used to track
// the user’s currently configured icon theme, which might be different for
// different screens.
func (iconTheme iconTheme) SetScreen(screen gdk.Screen) {
	var arg0 *C.GtkIconTheme
	var arg1 *C.GdkScreen

	arg0 = (*C.GtkIconTheme)(iconTheme.Native())
	arg1 = (*C.GdkScreen)(screen.Native())

	C.gtk_icon_theme_set_screen(arg0, arg1)
}

// SetSearchPath sets the search path for the icon theme object. When
// looking for an icon theme, GTK+ will search for a subdirectory of one or
// more of the directories in @path with the same name as the icon theme
// containing an index.theme file. (Themes from multiple of the path
// elements are combined to allow themes to be extended by adding icons in
// the user’s home directory.)
//
// In addition if an icon found isn’t found either in the current icon theme
// or the default icon theme, and an image file with the right name is found
// directly in one of the elements of @path, then that image will be used
// for the icon name. (This is legacy feature, and new icons should be put
// into the fallback icon theme, which is called hicolor, rather than
// directly on the icon path.)
func (iconTheme iconTheme) SetSearchPath(path []string) {
	var arg0 *C.GtkIconTheme
	var arg1 **C.gchar
	var arg2 C.gint

	arg0 = (*C.GtkIconTheme)(iconTheme.Native())
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * len(path))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(path)
		sliceHeader.Cap = len(path)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(path); i++ {
			src := path[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg1 = (**C.gchar)(unsafe.Pointer(ptr))
		arg2 = len(path)
	}

	C.gtk_icon_theme_set_search_path(arg0, arg1, arg2)
}

// ListStore: the ListStore object is a list model for use with a TreeView
// widget. It implements the TreeModel interface, and consequentialy, can use
// all of the methods available there. It also implements the TreeSortable
// interface so it can be sorted by the view. Finally, it also implements the
// tree [drag and drop][gtk3-GtkTreeView-drag-and-drop] interfaces.
//
// The ListStore can accept most GObject types as a column type, though it can’t
// accept all custom types. Internally, it will keep a copy of data passed in
// (such as a string or a boxed pointer). Columns that accept #GObjects are
// handled a little differently. The ListStore will keep a reference to the
// object instead of copying the value. As a result, if the object is modified,
// it is up to the application writer to call gtk_tree_model_row_changed() to
// emit the TreeModel::row_changed signal. This most commonly affects lists with
// Pixbufs stored.
//
// An example for creating a simple list store:
//
//    <object class="GtkListStore">
//      <columns>
//        <column type="gchararray"/>
//        <column type="gchararray"/>
//        <column type="gint"/>
//      </columns>
//      <data>
//        <row>
//          <col id="0">John</col>
//          <col id="1">Doe</col>
//          <col id="2">25</col>
//        </row>
//        <row>
//          <col id="0">Johan</col>
//          <col id="1">Dahlin</col>
//          <col id="2">50</col>
//        </row>
//      </data>
//    </object>
type ListStore interface {
	gextras.Objector
	Buildable
	TreeDragDest
	TreeDragSource
	TreeModel
	TreeSortable

	// Append appends a new row to @list_store. @iter will be changed to point
	// to this new row. The row will be empty after this function is called. To
	// fill in values, you need to call gtk_list_store_set() or
	// gtk_list_store_set_value().
	Append() TreeIter
	// Clear removes all rows from the list store.
	Clear()
	// Insert creates a new row at @position. @iter will be changed to point to
	// this new row. If @position is -1 or is larger than the number of rows on
	// the list, then the new row will be appended to the list. The row will be
	// empty after this function is called. To fill in values, you need to call
	// gtk_list_store_set() or gtk_list_store_set_value().
	Insert(position int) TreeIter
	// InsertAfter inserts a new row after @sibling. If @sibling is nil, then
	// the row will be prepended to the beginning of the list. @iter will be
	// changed to point to this new row. The row will be empty after this
	// function is called. To fill in values, you need to call
	// gtk_list_store_set() or gtk_list_store_set_value().
	InsertAfter(sibling *TreeIter) TreeIter
	// InsertBefore inserts a new row before @sibling. If @sibling is nil, then
	// the row will be appended to the end of the list. @iter will be changed to
	// point to this new row. The row will be empty after this function is
	// called. To fill in values, you need to call gtk_list_store_set() or
	// gtk_list_store_set_value().
	InsertBefore(sibling *TreeIter) TreeIter
	// InsertWithValuesv: a variant of gtk_list_store_insert_with_values() which
	// takes the columns and values as two arrays, instead of varargs. This
	// function is mainly intended for language-bindings.
	InsertWithValuesv(position int, columns []int, values []*externglib.Value) TreeIter
	// IterIsValid: > This function is slow. Only use it for debugging and/or
	// testing > purposes.
	//
	// Checks if the given iter is a valid iter for this ListStore.
	IterIsValid(iter *TreeIter) bool
	// MoveAfter moves @iter in @store to the position after @position. Note
	// that this function only works with unsorted stores. If @position is nil,
	// @iter will be moved to the start of the list.
	MoveAfter(iter *TreeIter, position *TreeIter)
	// MoveBefore moves @iter in @store to the position before @position. Note
	// that this function only works with unsorted stores. If @position is nil,
	// @iter will be moved to the end of the list.
	MoveBefore(iter *TreeIter, position *TreeIter)
	// Prepend prepends a new row to @list_store. @iter will be changed to point
	// to this new row. The row will be empty after this function is called. To
	// fill in values, you need to call gtk_list_store_set() or
	// gtk_list_store_set_value().
	Prepend() TreeIter
	// Remove removes the given row from the list store. After being removed,
	// @iter is set to be the next valid row, or invalidated if it pointed to
	// the last row in @list_store.
	Remove(iter *TreeIter) bool
	// Reorder reorders @store to follow the order indicated by @new_order. Note
	// that this function only works with unsorted stores.
	Reorder(newOrder []int)
	// SetColumnTypes: this function is meant primarily for #GObjects that
	// inherit from ListStore, and should only be used when constructing a new
	// ListStore. It will not function after a row has been added, or a method
	// on the TreeModel interface is called.
	SetColumnTypes(nColumns int, types []externglib.Type)
	// SetValue sets the data in the cell specified by @iter and @column. The
	// type of @value must be convertible to the type of the column.
	SetValue(iter *TreeIter, column int, value *externglib.Value)
	// SetValuesv: a variant of gtk_list_store_set_valist() which takes the
	// columns and values as two arrays, instead of varargs. This function is
	// mainly intended for language-bindings and in case the number of columns
	// to change is not known until run-time.
	SetValuesv(iter *TreeIter, columns []int, values []*externglib.Value)
	// Swap swaps @a and @b in @store. Note that this function only works with
	// unsorted stores.
	Swap(a *TreeIter, b *TreeIter)
}

// listStore implements the ListStore interface.
type listStore struct {
	gextras.Objector
	Buildable
	TreeDragDest
	TreeDragSource
	TreeModel
	TreeSortable
}

var _ ListStore = (*listStore)(nil)

// WrapListStore wraps a GObject to the right type. It is
// primarily used internally.
func WrapListStore(obj *externglib.Object) ListStore {
	return ListStore{
		Objector:       obj,
		Buildable:      WrapBuildable(obj),
		TreeDragDest:   WrapTreeDragDest(obj),
		TreeDragSource: WrapTreeDragSource(obj),
		TreeModel:      WrapTreeModel(obj),
		TreeSortable:   WrapTreeSortable(obj),
	}
}

func marshalListStore(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapListStore(obj), nil
}

// NewListStoreV constructs a class ListStore.
func NewListStoreV(nColumns int, types []externglib.Type) ListStore {
	var arg1 C.gint
	var arg2 *C.GType

	{
		var dst []C.GType
		ptr := C.malloc(C.sizeof_GType * len(types))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(types)
		sliceHeader.Cap = len(types)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(types); i++ {
			src := types[i]
			dst[i] = C.GType(src)
		}

		arg2 = (*C.GType)(unsafe.Pointer(ptr))
		arg1 = len(types)
	}

	ret := C.gtk_list_store_newv(arg1, arg2)

	var ret0 ListStore

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(ListStore)

	return ret0
}

// Append appends a new row to @list_store. @iter will be changed to point
// to this new row. The row will be empty after this function is called. To
// fill in values, you need to call gtk_list_store_set() or
// gtk_list_store_set_value().
func (listStore listStore) Append() TreeIter {
	var arg0 *C.GtkListStore
	var arg1 *C.GtkTreeIter // out

	arg0 = (*C.GtkListStore)(listStore.Native())

	C.gtk_list_store_append(arg0, &arg1)

	var ret0 *TreeIter

	{
		ret0 = WrapTreeIter(unsafe.Pointer(arg1))
	}

	return ret0
}

// Clear removes all rows from the list store.
func (listStore listStore) Clear() {
	var arg0 *C.GtkListStore

	arg0 = (*C.GtkListStore)(listStore.Native())

	C.gtk_list_store_clear(arg0)
}

// Insert creates a new row at @position. @iter will be changed to point to
// this new row. If @position is -1 or is larger than the number of rows on
// the list, then the new row will be appended to the list. The row will be
// empty after this function is called. To fill in values, you need to call
// gtk_list_store_set() or gtk_list_store_set_value().
func (listStore listStore) Insert(position int) TreeIter {
	var arg0 *C.GtkListStore
	var arg1 *C.GtkTreeIter // out
	var arg2 C.gint

	arg0 = (*C.GtkListStore)(listStore.Native())
	arg2 = C.gint(position)

	C.gtk_list_store_insert(arg0, &arg1, arg2)

	var ret0 *TreeIter

	{
		ret0 = WrapTreeIter(unsafe.Pointer(arg1))
	}

	return ret0
}

// InsertAfter inserts a new row after @sibling. If @sibling is nil, then
// the row will be prepended to the beginning of the list. @iter will be
// changed to point to this new row. The row will be empty after this
// function is called. To fill in values, you need to call
// gtk_list_store_set() or gtk_list_store_set_value().
func (listStore listStore) InsertAfter(sibling *TreeIter) TreeIter {
	var arg0 *C.GtkListStore
	var arg1 *C.GtkTreeIter // out
	var arg2 *C.GtkTreeIter

	arg0 = (*C.GtkListStore)(listStore.Native())
	arg2 = (*C.GtkTreeIter)(sibling.Native())

	C.gtk_list_store_insert_after(arg0, &arg1, arg2)

	var ret0 *TreeIter

	{
		ret0 = WrapTreeIter(unsafe.Pointer(arg1))
	}

	return ret0
}

// InsertBefore inserts a new row before @sibling. If @sibling is nil, then
// the row will be appended to the end of the list. @iter will be changed to
// point to this new row. The row will be empty after this function is
// called. To fill in values, you need to call gtk_list_store_set() or
// gtk_list_store_set_value().
func (listStore listStore) InsertBefore(sibling *TreeIter) TreeIter {
	var arg0 *C.GtkListStore
	var arg1 *C.GtkTreeIter // out
	var arg2 *C.GtkTreeIter

	arg0 = (*C.GtkListStore)(listStore.Native())
	arg2 = (*C.GtkTreeIter)(sibling.Native())

	C.gtk_list_store_insert_before(arg0, &arg1, arg2)

	var ret0 *TreeIter

	{
		ret0 = WrapTreeIter(unsafe.Pointer(arg1))
	}

	return ret0
}

// InsertWithValuesv: a variant of gtk_list_store_insert_with_values() which
// takes the columns and values as two arrays, instead of varargs. This
// function is mainly intended for language-bindings.
func (listStore listStore) InsertWithValuesv(position int, columns []int, values []*externglib.Value) TreeIter {
	var arg0 *C.GtkListStore
	var arg1 *C.GtkTreeIter // out
	var arg2 C.gint
	var arg3 *C.gint
	var arg4 *C.GValue
	var arg5 C.gint

	arg0 = (*C.GtkListStore)(listStore.Native())
	arg2 = C.gint(position)
	arg3 = (*C.gint)(unsafe.Pointer(&columns[0]))
	arg5 = len(columns)
	defer runtime.KeepAlive(columns)
	{
		var dst []C.GValue
		ptr := C.malloc(C.sizeof_GValue * len(values))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(values)
		sliceHeader.Cap = len(values)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(values); i++ {
			src := values[i]
			dst[i] = (*C.GValue)(src.GValue)
		}

		arg4 = (*C.GValue)(unsafe.Pointer(ptr))
		arg5 = len(values)
	}

	C.gtk_list_store_insert_with_valuesv(arg0, &arg1, arg2, arg3, arg4, arg5)

	var ret0 *TreeIter

	{
		ret0 = WrapTreeIter(unsafe.Pointer(arg1))
	}

	return ret0
}

// IterIsValid: > This function is slow. Only use it for debugging and/or
// testing > purposes.
//
// Checks if the given iter is a valid iter for this ListStore.
func (listStore listStore) IterIsValid(iter *TreeIter) bool {
	var arg0 *C.GtkListStore
	var arg1 *C.GtkTreeIter

	arg0 = (*C.GtkListStore)(listStore.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())

	ret := C.gtk_list_store_iter_is_valid(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// MoveAfter moves @iter in @store to the position after @position. Note
// that this function only works with unsorted stores. If @position is nil,
// @iter will be moved to the start of the list.
func (store listStore) MoveAfter(iter *TreeIter, position *TreeIter) {
	var arg0 *C.GtkListStore
	var arg1 *C.GtkTreeIter
	var arg2 *C.GtkTreeIter

	arg0 = (*C.GtkListStore)(store.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())
	arg2 = (*C.GtkTreeIter)(position.Native())

	C.gtk_list_store_move_after(arg0, arg1, arg2)
}

// MoveBefore moves @iter in @store to the position before @position. Note
// that this function only works with unsorted stores. If @position is nil,
// @iter will be moved to the end of the list.
func (store listStore) MoveBefore(iter *TreeIter, position *TreeIter) {
	var arg0 *C.GtkListStore
	var arg1 *C.GtkTreeIter
	var arg2 *C.GtkTreeIter

	arg0 = (*C.GtkListStore)(store.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())
	arg2 = (*C.GtkTreeIter)(position.Native())

	C.gtk_list_store_move_before(arg0, arg1, arg2)
}

// Prepend prepends a new row to @list_store. @iter will be changed to point
// to this new row. The row will be empty after this function is called. To
// fill in values, you need to call gtk_list_store_set() or
// gtk_list_store_set_value().
func (listStore listStore) Prepend() TreeIter {
	var arg0 *C.GtkListStore
	var arg1 *C.GtkTreeIter // out

	arg0 = (*C.GtkListStore)(listStore.Native())

	C.gtk_list_store_prepend(arg0, &arg1)

	var ret0 *TreeIter

	{
		ret0 = WrapTreeIter(unsafe.Pointer(arg1))
	}

	return ret0
}

// Remove removes the given row from the list store. After being removed,
// @iter is set to be the next valid row, or invalidated if it pointed to
// the last row in @list_store.
func (listStore listStore) Remove(iter *TreeIter) bool {
	var arg0 *C.GtkListStore
	var arg1 *C.GtkTreeIter

	arg0 = (*C.GtkListStore)(listStore.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())

	ret := C.gtk_list_store_remove(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Reorder reorders @store to follow the order indicated by @new_order. Note
// that this function only works with unsorted stores.
func (store listStore) Reorder(newOrder []int) {
	var arg0 *C.GtkListStore
	var arg1 *C.gint

	arg0 = (*C.GtkListStore)(store.Native())
	{
		var dst []C.gint
		ptr := C.malloc(C.sizeof_gint * (len(newOrder) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(newOrder)
		sliceHeader.Cap = len(newOrder)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(newOrder); i++ {
			src := newOrder[i]
			dst[i] = C.gint(src)
		}

		arg1 = (*C.gint)(unsafe.Pointer(ptr))
	}

	C.gtk_list_store_reorder(arg0, arg1)
}

// SetColumnTypes: this function is meant primarily for #GObjects that
// inherit from ListStore, and should only be used when constructing a new
// ListStore. It will not function after a row has been added, or a method
// on the TreeModel interface is called.
func (listStore listStore) SetColumnTypes(nColumns int, types []externglib.Type) {
	var arg0 *C.GtkListStore
	var arg1 C.gint
	var arg2 *C.GType

	arg0 = (*C.GtkListStore)(listStore.Native())
	{
		var dst []C.GType
		ptr := C.malloc(C.sizeof_GType * len(types))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(types)
		sliceHeader.Cap = len(types)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(types); i++ {
			src := types[i]
			dst[i] = C.GType(src)
		}

		arg2 = (*C.GType)(unsafe.Pointer(ptr))
		arg1 = len(types)
	}

	C.gtk_list_store_set_column_types(arg0, arg1, arg2)
}

// SetValue sets the data in the cell specified by @iter and @column. The
// type of @value must be convertible to the type of the column.
func (listStore listStore) SetValue(iter *TreeIter, column int, value *externglib.Value) {
	var arg0 *C.GtkListStore
	var arg1 *C.GtkTreeIter
	var arg2 C.gint
	var arg3 *C.GValue

	arg0 = (*C.GtkListStore)(listStore.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())
	arg2 = C.gint(column)
	arg3 = (*C.GValue)(value.GValue)

	C.gtk_list_store_set_value(arg0, arg1, arg2, arg3)
}

// SetValuesv: a variant of gtk_list_store_set_valist() which takes the
// columns and values as two arrays, instead of varargs. This function is
// mainly intended for language-bindings and in case the number of columns
// to change is not known until run-time.
func (listStore listStore) SetValuesv(iter *TreeIter, columns []int, values []*externglib.Value) {
	var arg0 *C.GtkListStore
	var arg1 *C.GtkTreeIter
	var arg2 *C.gint
	var arg3 *C.GValue
	var arg4 C.gint

	arg0 = (*C.GtkListStore)(listStore.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())
	arg2 = (*C.gint)(unsafe.Pointer(&columns[0]))
	arg4 = len(columns)
	defer runtime.KeepAlive(columns)
	{
		var dst []C.GValue
		ptr := C.malloc(C.sizeof_GValue * len(values))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(values)
		sliceHeader.Cap = len(values)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(values); i++ {
			src := values[i]
			dst[i] = (*C.GValue)(src.GValue)
		}

		arg3 = (*C.GValue)(unsafe.Pointer(ptr))
		arg4 = len(values)
	}

	C.gtk_list_store_set_valuesv(arg0, arg1, arg2, arg3, arg4)
}

// Swap swaps @a and @b in @store. Note that this function only works with
// unsorted stores.
func (store listStore) Swap(a *TreeIter, b *TreeIter) {
	var arg0 *C.GtkListStore
	var arg1 *C.GtkTreeIter
	var arg2 *C.GtkTreeIter

	arg0 = (*C.GtkListStore)(store.Native())
	arg1 = (*C.GtkTreeIter)(a.Native())
	arg2 = (*C.GtkTreeIter)(b.Native())

	C.gtk_list_store_swap(arg0, arg1, arg2)
}

// MountOperation: this should not be accessed directly. Use the accessor
// functions below.
type MountOperation interface {
	gio.MountOperation

	// Parent gets the transient parent used by the MountOperation
	Parent() Window
	// Screen gets the screen on which windows of the MountOperation will be
	// shown.
	Screen() gdk.Screen
	// IsShowing returns whether the MountOperation is currently displaying a
	// window.
	IsShowing() bool
	// SetParent sets the transient parent for windows shown by the
	// MountOperation.
	SetParent(parent Window)
	// SetScreen sets the screen to show windows of the MountOperation on.
	SetScreen(screen gdk.Screen)
}

// mountOperation implements the MountOperation interface.
type mountOperation struct {
	gio.MountOperation
}

var _ MountOperation = (*mountOperation)(nil)

// WrapMountOperation wraps a GObject to the right type. It is
// primarily used internally.
func WrapMountOperation(obj *externglib.Object) MountOperation {
	return MountOperation{
		gio.MountOperation: gio.WrapMountOperation(obj),
	}
}

func marshalMountOperation(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMountOperation(obj), nil
}

// NewMountOperation constructs a class MountOperation.
func NewMountOperation(parent Window) MountOperation {
	var arg1 *C.GtkWindow

	arg1 = (*C.GtkWindow)(parent.Native())

	ret := C.gtk_mount_operation_new(arg1)

	var ret0 MountOperation

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(MountOperation)

	return ret0
}

// Parent gets the transient parent used by the MountOperation
func (op mountOperation) Parent() Window {
	var arg0 *C.GtkMountOperation

	arg0 = (*C.GtkMountOperation)(op.Native())

	ret := C.gtk_mount_operation_get_parent(arg0)

	var ret0 Window

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Window)

	return ret0
}

// Screen gets the screen on which windows of the MountOperation will be
// shown.
func (op mountOperation) Screen() gdk.Screen {
	var arg0 *C.GtkMountOperation

	arg0 = (*C.GtkMountOperation)(op.Native())

	ret := C.gtk_mount_operation_get_screen(arg0)

	var ret0 gdk.Screen

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gdk.Screen)

	return ret0
}

// IsShowing returns whether the MountOperation is currently displaying a
// window.
func (op mountOperation) IsShowing() bool {
	var arg0 *C.GtkMountOperation

	arg0 = (*C.GtkMountOperation)(op.Native())

	ret := C.gtk_mount_operation_is_showing(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SetParent sets the transient parent for windows shown by the
// MountOperation.
func (op mountOperation) SetParent(parent Window) {
	var arg0 *C.GtkMountOperation
	var arg1 *C.GtkWindow

	arg0 = (*C.GtkMountOperation)(op.Native())
	arg1 = (*C.GtkWindow)(parent.Native())

	C.gtk_mount_operation_set_parent(arg0, arg1)
}

// SetScreen sets the screen to show windows of the MountOperation on.
func (op mountOperation) SetScreen(screen gdk.Screen) {
	var arg0 *C.GtkMountOperation
	var arg1 *C.GdkScreen

	arg0 = (*C.GtkMountOperation)(op.Native())
	arg1 = (*C.GdkScreen)(screen.Native())

	C.gtk_mount_operation_set_screen(arg0, arg1)
}

// NativeDialog: native dialogs are platform dialogs that don't use Dialog or
// Window. They are used in order to integrate better with a platform, by
// looking the same as other native applications and supporting platform
// specific features.
//
// The Dialog functions cannot be used on such objects, but we need a similar
// API in order to drive them. The NativeDialog object is an API that allows you
// to do this. It allows you to set various common properties on the dialog, as
// well as show and hide it and get a NativeDialog::response signal when the
// user finished with the dialog.
//
// There is also a gtk_native_dialog_run() helper that makes it easy to run any
// native dialog in a modal way with a recursive mainloop, similar to
// gtk_dialog_run().
type NativeDialog interface {
	gextras.Objector

	// Destroy destroys a dialog.
	//
	// When a dialog is destroyed, it will break any references it holds to
	// other objects. If it is visible it will be hidden and any underlying
	// window system resources will be destroyed.
	//
	// Note that this does not release any reference to the object (as opposed
	// to destroying a GtkWindow) because there is no reference from the
	// windowing system to the NativeDialog.
	Destroy()
	// Modal returns whether the dialog is modal. See
	// gtk_native_dialog_set_modal().
	Modal() bool
	// Title gets the title of the NativeDialog.
	Title() string
	// TransientFor fetches the transient parent for this window. See
	// gtk_native_dialog_set_transient_for().
	TransientFor() Window
	// Visible determines whether the dialog is visible.
	Visible() bool
	// Hide hides the dialog if it is visilbe, aborting any interaction. Once
	// this is called the NativeDialog::response signal will not be emitted
	// until after the next call to gtk_native_dialog_show().
	//
	// If the dialog is not visible this does nothing.
	Hide()
	// Run blocks in a recursive main loop until @self emits the
	// NativeDialog::response signal. It then returns the response ID from the
	// ::response signal emission.
	//
	// Before entering the recursive main loop, gtk_native_dialog_run() calls
	// gtk_native_dialog_show() on the dialog for you.
	//
	// After gtk_native_dialog_run() returns, then dialog will be hidden.
	//
	// Typical usage of this function might be:
	//
	//    gint result = gtk_native_dialog_run (GTK_NATIVE_DIALOG (dialog));
	//    switch (result)
	//      {
	//        case GTK_RESPONSE_ACCEPT:
	//           do_application_specific_something ();
	//           break;
	//        default:
	//           do_nothing_since_dialog_was_cancelled ();
	//           break;
	//      }
	//    g_object_unref (dialog);
	//
	// Note that even though the recursive main loop gives the effect of a modal
	// dialog (it prevents the user from interacting with other windows in the
	// same window group while the dialog is run), callbacks such as timeouts,
	// IO channel watches, DND drops, etc, will be triggered during a
	// gtk_native_dialog_run() call.
	Run() int
	// SetModal sets a dialog modal or non-modal. Modal dialogs prevent
	// interaction with other windows in the same application. To keep modal
	// dialogs on top of main application windows, use
	// gtk_native_dialog_set_transient_for() to make the dialog transient for
	// the parent; most [window managers][gtk-X11-arch] will then disallow
	// lowering the dialog below the parent.
	SetModal(modal bool)
	// SetTitle sets the title of the NativeDialog.
	SetTitle(title string)
	// SetTransientFor: dialog windows should be set transient for the main
	// application window they were spawned from. This allows [window
	// managers][gtk-X11-arch] to e.g. keep the dialog on top of the main
	// window, or center the dialog over the main window.
	//
	// Passing nil for @parent unsets the current transient window.
	SetTransientFor(parent Window)
	// Show shows the dialog on the display, allowing the user to interact with
	// it. When the user accepts the state of the dialog the dialog will be
	// automatically hidden and the NativeDialog::response signal will be
	// emitted.
	//
	// Multiple calls while the dialog is visible will be ignored.
	Show()
}

// nativeDialog implements the NativeDialog interface.
type nativeDialog struct {
	gextras.Objector
}

var _ NativeDialog = (*nativeDialog)(nil)

// WrapNativeDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapNativeDialog(obj *externglib.Object) NativeDialog {
	return NativeDialog{
		Objector: obj,
	}
}

func marshalNativeDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNativeDialog(obj), nil
}

// Destroy destroys a dialog.
//
// When a dialog is destroyed, it will break any references it holds to
// other objects. If it is visible it will be hidden and any underlying
// window system resources will be destroyed.
//
// Note that this does not release any reference to the object (as opposed
// to destroying a GtkWindow) because there is no reference from the
// windowing system to the NativeDialog.
func (self nativeDialog) Destroy() {
	var arg0 *C.GtkNativeDialog

	arg0 = (*C.GtkNativeDialog)(self.Native())

	C.gtk_native_dialog_destroy(arg0)
}

// Modal returns whether the dialog is modal. See
// gtk_native_dialog_set_modal().
func (self nativeDialog) Modal() bool {
	var arg0 *C.GtkNativeDialog

	arg0 = (*C.GtkNativeDialog)(self.Native())

	ret := C.gtk_native_dialog_get_modal(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Title gets the title of the NativeDialog.
func (self nativeDialog) Title() string {
	var arg0 *C.GtkNativeDialog

	arg0 = (*C.GtkNativeDialog)(self.Native())

	ret := C.gtk_native_dialog_get_title(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// TransientFor fetches the transient parent for this window. See
// gtk_native_dialog_set_transient_for().
func (self nativeDialog) TransientFor() Window {
	var arg0 *C.GtkNativeDialog

	arg0 = (*C.GtkNativeDialog)(self.Native())

	ret := C.gtk_native_dialog_get_transient_for(arg0)

	var ret0 Window

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Window)

	return ret0
}

// Visible determines whether the dialog is visible.
func (self nativeDialog) Visible() bool {
	var arg0 *C.GtkNativeDialog

	arg0 = (*C.GtkNativeDialog)(self.Native())

	ret := C.gtk_native_dialog_get_visible(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Hide hides the dialog if it is visilbe, aborting any interaction. Once
// this is called the NativeDialog::response signal will not be emitted
// until after the next call to gtk_native_dialog_show().
//
// If the dialog is not visible this does nothing.
func (self nativeDialog) Hide() {
	var arg0 *C.GtkNativeDialog

	arg0 = (*C.GtkNativeDialog)(self.Native())

	C.gtk_native_dialog_hide(arg0)
}

// Run blocks in a recursive main loop until @self emits the
// NativeDialog::response signal. It then returns the response ID from the
// ::response signal emission.
//
// Before entering the recursive main loop, gtk_native_dialog_run() calls
// gtk_native_dialog_show() on the dialog for you.
//
// After gtk_native_dialog_run() returns, then dialog will be hidden.
//
// Typical usage of this function might be:
//
//    gint result = gtk_native_dialog_run (GTK_NATIVE_DIALOG (dialog));
//    switch (result)
//      {
//        case GTK_RESPONSE_ACCEPT:
//           do_application_specific_something ();
//           break;
//        default:
//           do_nothing_since_dialog_was_cancelled ();
//           break;
//      }
//    g_object_unref (dialog);
//
// Note that even though the recursive main loop gives the effect of a modal
// dialog (it prevents the user from interacting with other windows in the
// same window group while the dialog is run), callbacks such as timeouts,
// IO channel watches, DND drops, etc, will be triggered during a
// gtk_native_dialog_run() call.
func (self nativeDialog) Run() int {
	var arg0 *C.GtkNativeDialog

	arg0 = (*C.GtkNativeDialog)(self.Native())

	ret := C.gtk_native_dialog_run(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// SetModal sets a dialog modal or non-modal. Modal dialogs prevent
// interaction with other windows in the same application. To keep modal
// dialogs on top of main application windows, use
// gtk_native_dialog_set_transient_for() to make the dialog transient for
// the parent; most [window managers][gtk-X11-arch] will then disallow
// lowering the dialog below the parent.
func (self nativeDialog) SetModal(modal bool) {
	var arg0 *C.GtkNativeDialog
	var arg1 C.gboolean

	arg0 = (*C.GtkNativeDialog)(self.Native())
	if modal {
		arg1 = C.TRUE
	}

	C.gtk_native_dialog_set_modal(arg0, arg1)
}

// SetTitle sets the title of the NativeDialog.
func (self nativeDialog) SetTitle(title string) {
	var arg0 *C.GtkNativeDialog
	var arg1 *C.char

	arg0 = (*C.GtkNativeDialog)(self.Native())
	arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_native_dialog_set_title(arg0, arg1)
}

// SetTransientFor: dialog windows should be set transient for the main
// application window they were spawned from. This allows [window
// managers][gtk-X11-arch] to e.g. keep the dialog on top of the main
// window, or center the dialog over the main window.
//
// Passing nil for @parent unsets the current transient window.
func (self nativeDialog) SetTransientFor(parent Window) {
	var arg0 *C.GtkNativeDialog
	var arg1 *C.GtkWindow

	arg0 = (*C.GtkNativeDialog)(self.Native())
	arg1 = (*C.GtkWindow)(parent.Native())

	C.gtk_native_dialog_set_transient_for(arg0, arg1)
}

// Show shows the dialog on the display, allowing the user to interact with
// it. When the user accepts the state of the dialog the dialog will be
// automatically hidden and the NativeDialog::response signal will be
// emitted.
//
// Multiple calls while the dialog is visible will be ignored.
func (self nativeDialog) Show() {
	var arg0 *C.GtkNativeDialog

	arg0 = (*C.GtkNativeDialog)(self.Native())

	C.gtk_native_dialog_show(arg0)
}

// PadController is an event controller for the pads found in drawing tablets
// (The collection of buttons and tactile sensors often found around the
// stylus-sensitive area).
//
// These buttons and sensors have no implicit meaning, and by default they
// perform no action, this event controller is provided to map those to #GAction
// objects, thus letting the application give those a more semantic meaning.
//
// Buttons and sensors are not constrained to triggering a single action, some
// GDK_SOURCE_TABLET_PAD devices feature multiple "modes", all these input
// elements have one current mode, which may determine the final action being
// triggered. Pad devices often divide buttons and sensors into groups, all
// elements in a group share the same current mode, but different groups may
// have different modes. See gdk_device_pad_get_n_groups() and
// gdk_device_pad_get_group_n_modes().
//
// Each of the actions that a given button/strip/ring performs for a given mode
// is defined by PadActionEntry, it contains an action name that will be looked
// up in the given Group and activated whenever the specified input element and
// mode are triggered.
//
// A simple example of PadController usage, assigning button 1 in all modes and
// pad devices to an "invert-selection" action:
//
//      GtkPadActionEntry *pad_actions[] = {
//        { GTK_PAD_ACTION_BUTTON, 1, -1, "Invert selection", "pad-actions.invert-selection" },
//        …
//      };
//
//      …
//      action_group = g_simple_action_group_new ();
//      action = g_simple_action_new ("pad-actions.invert-selection", NULL);
//      g_signal_connect (action, "activate", on_invert_selection_activated, NULL);
//      g_action_map_add_action (G_ACTION_MAP (action_group), action);
//      …
//      pad_controller = gtk_pad_controller_new (window, action_group, NULL);
//
// The actions belonging to rings/strips will be activated with a parameter of
// type G_VARIANT_TYPE_DOUBLE bearing the value of the given axis, it is
// required that those are made stateful and accepting this Type.
type PadController interface {
	EventController

	// SetAction adds an individual action to @controller. This action will only
	// be activated if the given button/ring/strip number in @index is
	// interacted while the current mode is @mode. -1 may be used for simple
	// cases, so the action is triggered on all modes.
	//
	// The given @label should be considered user-visible, so
	// internationalization rules apply. Some windowing systems may be able to
	// use those for user feedback.
	SetAction(typ PadActionType, index int, mode int, label string, actionName string)
	// SetActionEntries: this is a convenience function to add a group of action
	// entries on @controller. See PadActionEntry and
	// gtk_pad_controller_set_action().
	SetActionEntries(entries []PadActionEntry)
}

// padController implements the PadController interface.
type padController struct {
	EventController
}

var _ PadController = (*padController)(nil)

// WrapPadController wraps a GObject to the right type. It is
// primarily used internally.
func WrapPadController(obj *externglib.Object) PadController {
	return PadController{
		EventController: WrapEventController(obj),
	}
}

func marshalPadController(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPadController(obj), nil
}

// NewPadController constructs a class PadController.
func NewPadController(window Window, group gio.ActionGroup, pad gdk.Device) PadController {
	var arg1 *C.GtkWindow
	var arg2 *C.GActionGroup
	var arg3 *C.GdkDevice

	arg1 = (*C.GtkWindow)(window.Native())
	arg2 = (*C.GActionGroup)(group.Native())
	arg3 = (*C.GdkDevice)(pad.Native())

	ret := C.gtk_pad_controller_new(arg1, arg2, arg3)

	var ret0 PadController

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(PadController)

	return ret0
}

// SetAction adds an individual action to @controller. This action will only
// be activated if the given button/ring/strip number in @index is
// interacted while the current mode is @mode. -1 may be used for simple
// cases, so the action is triggered on all modes.
//
// The given @label should be considered user-visible, so
// internationalization rules apply. Some windowing systems may be able to
// use those for user feedback.
func (controller padController) SetAction(typ PadActionType, index int, mode int, label string, actionName string) {
	var arg0 *C.GtkPadController
	var arg1 C.GtkPadActionType
	var arg2 C.gint
	var arg3 C.gint
	var arg4 *C.gchar
	var arg5 *C.gchar

	arg0 = (*C.GtkPadController)(controller.Native())
	arg1 = (C.GtkPadActionType)(typ)
	arg2 = C.gint(index)
	arg3 = C.gint(mode)
	arg4 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(arg5))

	C.gtk_pad_controller_set_action(arg0, arg1, arg2, arg3, arg4, arg5)
}

// SetActionEntries: this is a convenience function to add a group of action
// entries on @controller. See PadActionEntry and
// gtk_pad_controller_set_action().
func (controller padController) SetActionEntries(entries []PadActionEntry) {
	var arg0 *C.GtkPadController
	var arg1 *C.GtkPadActionEntry
	var arg2 C.gint

	arg0 = (*C.GtkPadController)(controller.Native())
	{
		var dst []C.GtkPadActionEntry
		ptr := C.malloc(C.sizeof_GtkPadActionEntry * len(entries))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(entries)
		sliceHeader.Cap = len(entries)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(entries); i++ {
			src := entries[i]
			dst[i] = (C.GtkPadActionEntry)(src.Native())
		}

		arg1 = (*C.GtkPadActionEntry)(unsafe.Pointer(ptr))
		arg2 = len(entries)
	}

	C.gtk_pad_controller_set_action_entries(arg0, arg1, arg2)
}

// PageSetup: a GtkPageSetup object stores the page size, orientation and
// margins. The idea is that you can get one of these from the page setup dialog
// and then pass it to the PrintOperation when printing. The benefit of
// splitting this out of the PrintSettings is that these affect the actual
// layout of the page, and thus need to be set long before user prints.
//
//
// Margins
//
// The margins specified in this object are the “print margins”, i.e. the parts
// of the page that the printer cannot print on. These are different from the
// layout margins that a word processor uses; they are typically used to
// determine the minimal size for the layout margins.
//
// To obtain a PageSetup use gtk_page_setup_new() to get the defaults, or use
// gtk_print_run_page_setup_dialog() to show the page setup dialog and receive
// the resulting page setup.
//
// A page setup dialog
//
//    static GtkPrintSettings *settings = NULL;
//    static GtkPageSetup *page_setup = NULL;
//
//    static void
//    do_page_setup (void)
//    {
//      GtkPageSetup *new_page_setup;
//
//      if (settings == NULL)
//        settings = gtk_print_settings_new ();
//
//      new_page_setup = gtk_print_run_page_setup_dialog (GTK_WINDOW (main_window),
//                                                        page_setup, settings);
//
//      if (page_setup)
//        g_object_unref (page_setup);
//
//      page_setup = new_page_setup;
//    }
//
// Printing support was added in GTK+ 2.10.
type PageSetup interface {
	gextras.Objector

	// Copy copies a PageSetup.
	Copy() PageSetup
	// BottomMargin gets the bottom margin in units of @unit.
	BottomMargin(unit Unit) float64
	// LeftMargin gets the left margin in units of @unit.
	LeftMargin(unit Unit) float64
	// Orientation gets the page orientation of the PageSetup.
	Orientation() PageOrientation
	// PageHeight returns the page height in units of @unit.
	//
	// Note that this function takes orientation and margins into consideration.
	// See gtk_page_setup_get_paper_height().
	PageHeight(unit Unit) float64
	// PageWidth returns the page width in units of @unit.
	//
	// Note that this function takes orientation and margins into consideration.
	// See gtk_page_setup_get_paper_width().
	PageWidth(unit Unit) float64
	// PaperHeight returns the paper height in units of @unit.
	//
	// Note that this function takes orientation, but not margins into
	// consideration. See gtk_page_setup_get_page_height().
	PaperHeight(unit Unit) float64
	// PaperSize gets the paper size of the PageSetup.
	PaperSize() *PaperSize
	// PaperWidth returns the paper width in units of @unit.
	//
	// Note that this function takes orientation, but not margins into
	// consideration. See gtk_page_setup_get_page_width().
	PaperWidth(unit Unit) float64
	// RightMargin gets the right margin in units of @unit.
	RightMargin(unit Unit) float64
	// TopMargin gets the top margin in units of @unit.
	TopMargin(unit Unit) float64
	// LoadFile reads the page setup from the file @file_name. See
	// gtk_page_setup_to_file().
	LoadFile(fileName string) error
	// LoadKeyFile reads the page setup from the group @group_name in the key
	// file @key_file.
	LoadKeyFile(keyFile *glib.KeyFile, groupName string) error
	// SetBottomMargin sets the bottom margin of the PageSetup.
	SetBottomMargin(margin float64, unit Unit)
	// SetLeftMargin sets the left margin of the PageSetup.
	SetLeftMargin(margin float64, unit Unit)
	// SetOrientation sets the page orientation of the PageSetup.
	SetOrientation(orientation PageOrientation)
	// SetPaperSize sets the paper size of the PageSetup without changing the
	// margins. See gtk_page_setup_set_paper_size_and_default_margins().
	SetPaperSize(size *PaperSize)
	// SetPaperSizeAndDefaultMargins sets the paper size of the PageSetup and
	// modifies the margins according to the new paper size.
	SetPaperSizeAndDefaultMargins(size *PaperSize)
	// SetRightMargin sets the right margin of the PageSetup.
	SetRightMargin(margin float64, unit Unit)
	// SetTopMargin sets the top margin of the PageSetup.
	SetTopMargin(margin float64, unit Unit)
	// ToFile: this function saves the information from @setup to @file_name.
	ToFile(fileName string) error
	// ToGVariant: serialize page setup to an a{sv} variant.
	ToGVariant() *glib.Variant
	// ToKeyFile: this function adds the page setup from @setup to @key_file.
	ToKeyFile(keyFile *glib.KeyFile, groupName string)
}

// pageSetup implements the PageSetup interface.
type pageSetup struct {
	gextras.Objector
}

var _ PageSetup = (*pageSetup)(nil)

// WrapPageSetup wraps a GObject to the right type. It is
// primarily used internally.
func WrapPageSetup(obj *externglib.Object) PageSetup {
	return PageSetup{
		Objector: obj,
	}
}

func marshalPageSetup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPageSetup(obj), nil
}

// NewPageSetup constructs a class PageSetup.
func NewPageSetup() PageSetup {

	ret := C.gtk_page_setup_new()

	var ret0 PageSetup

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(PageSetup)

	return ret0
}

// NewPageSetupFromFile constructs a class PageSetup.
func NewPageSetupFromFile(fileName string) (pageSetup PageSetup, err error) {
	var arg1 *C.gchar
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_page_setup_new_from_file(arg1, &gError)

	var ret0 PageSetup
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(PageSetup)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// NewPageSetupFromGVariant constructs a class PageSetup.
func NewPageSetupFromGVariant(variant *glib.Variant) PageSetup {
	var arg1 *C.GVariant

	arg1 = (*C.GVariant)(variant.Native())

	ret := C.gtk_page_setup_new_from_gvariant(arg1)

	var ret0 PageSetup

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(PageSetup)

	return ret0
}

// NewPageSetupFromKeyFile constructs a class PageSetup.
func NewPageSetupFromKeyFile(keyFile *glib.KeyFile, groupName string) (pageSetup PageSetup, err error) {
	var arg1 *C.GKeyFile
	var arg2 *C.gchar
	var gError *C.GError

	arg1 = (*C.GKeyFile)(keyFile.Native())
	arg2 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_page_setup_new_from_key_file(arg1, arg2, &gError)

	var ret0 PageSetup
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(PageSetup)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Copy copies a PageSetup.
func (other pageSetup) Copy() PageSetup {
	var arg0 *C.GtkPageSetup

	arg0 = (*C.GtkPageSetup)(other.Native())

	ret := C.gtk_page_setup_copy(arg0)

	var ret0 PageSetup

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(PageSetup)

	return ret0
}

// BottomMargin gets the bottom margin in units of @unit.
func (setup pageSetup) BottomMargin(unit Unit) float64 {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = (C.GtkUnit)(unit)

	ret := C.gtk_page_setup_get_bottom_margin(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// LeftMargin gets the left margin in units of @unit.
func (setup pageSetup) LeftMargin(unit Unit) float64 {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = (C.GtkUnit)(unit)

	ret := C.gtk_page_setup_get_left_margin(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// Orientation gets the page orientation of the PageSetup.
func (setup pageSetup) Orientation() PageOrientation {
	var arg0 *C.GtkPageSetup

	arg0 = (*C.GtkPageSetup)(setup.Native())

	ret := C.gtk_page_setup_get_orientation(arg0)

	var ret0 PageOrientation

	ret0 = PageOrientation(ret)

	return ret0
}

// PageHeight returns the page height in units of @unit.
//
// Note that this function takes orientation and margins into consideration.
// See gtk_page_setup_get_paper_height().
func (setup pageSetup) PageHeight(unit Unit) float64 {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = (C.GtkUnit)(unit)

	ret := C.gtk_page_setup_get_page_height(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// PageWidth returns the page width in units of @unit.
//
// Note that this function takes orientation and margins into consideration.
// See gtk_page_setup_get_paper_width().
func (setup pageSetup) PageWidth(unit Unit) float64 {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = (C.GtkUnit)(unit)

	ret := C.gtk_page_setup_get_page_width(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// PaperHeight returns the paper height in units of @unit.
//
// Note that this function takes orientation, but not margins into
// consideration. See gtk_page_setup_get_page_height().
func (setup pageSetup) PaperHeight(unit Unit) float64 {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = (C.GtkUnit)(unit)

	ret := C.gtk_page_setup_get_paper_height(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// PaperSize gets the paper size of the PageSetup.
func (setup pageSetup) PaperSize() *PaperSize {
	var arg0 *C.GtkPageSetup

	arg0 = (*C.GtkPageSetup)(setup.Native())

	ret := C.gtk_page_setup_get_paper_size(arg0)

	var ret0 *PaperSize

	{
		ret0 = WrapPaperSize(unsafe.Pointer(ret))
	}

	return ret0
}

// PaperWidth returns the paper width in units of @unit.
//
// Note that this function takes orientation, but not margins into
// consideration. See gtk_page_setup_get_page_width().
func (setup pageSetup) PaperWidth(unit Unit) float64 {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = (C.GtkUnit)(unit)

	ret := C.gtk_page_setup_get_paper_width(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// RightMargin gets the right margin in units of @unit.
func (setup pageSetup) RightMargin(unit Unit) float64 {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = (C.GtkUnit)(unit)

	ret := C.gtk_page_setup_get_right_margin(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// TopMargin gets the top margin in units of @unit.
func (setup pageSetup) TopMargin(unit Unit) float64 {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = (C.GtkUnit)(unit)

	ret := C.gtk_page_setup_get_top_margin(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// LoadFile reads the page setup from the file @file_name. See
// gtk_page_setup_to_file().
func (setup pageSetup) LoadFile(fileName string) error {
	var arg0 *C.GtkPageSetup
	var arg1 *C.char
	var gError *C.GError

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_page_setup_load_file(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// LoadKeyFile reads the page setup from the group @group_name in the key
// file @key_file.
func (setup pageSetup) LoadKeyFile(keyFile *glib.KeyFile, groupName string) error {
	var arg0 *C.GtkPageSetup
	var arg1 *C.GKeyFile
	var arg2 *C.gchar
	var gError *C.GError

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = (*C.GKeyFile)(keyFile.Native())
	arg2 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_page_setup_load_key_file(arg0, arg1, arg2, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SetBottomMargin sets the bottom margin of the PageSetup.
func (setup pageSetup) SetBottomMargin(margin float64, unit Unit) {
	var arg0 *C.GtkPageSetup
	var arg1 C.gdouble
	var arg2 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = C.gdouble(margin)
	arg2 = (C.GtkUnit)(unit)

	C.gtk_page_setup_set_bottom_margin(arg0, arg1, arg2)
}

// SetLeftMargin sets the left margin of the PageSetup.
func (setup pageSetup) SetLeftMargin(margin float64, unit Unit) {
	var arg0 *C.GtkPageSetup
	var arg1 C.gdouble
	var arg2 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = C.gdouble(margin)
	arg2 = (C.GtkUnit)(unit)

	C.gtk_page_setup_set_left_margin(arg0, arg1, arg2)
}

// SetOrientation sets the page orientation of the PageSetup.
func (setup pageSetup) SetOrientation(orientation PageOrientation) {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkPageOrientation

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = (C.GtkPageOrientation)(orientation)

	C.gtk_page_setup_set_orientation(arg0, arg1)
}

// SetPaperSize sets the paper size of the PageSetup without changing the
// margins. See gtk_page_setup_set_paper_size_and_default_margins().
func (setup pageSetup) SetPaperSize(size *PaperSize) {
	var arg0 *C.GtkPageSetup
	var arg1 *C.GtkPaperSize

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = (*C.GtkPaperSize)(size.Native())

	C.gtk_page_setup_set_paper_size(arg0, arg1)
}

// SetPaperSizeAndDefaultMargins sets the paper size of the PageSetup and
// modifies the margins according to the new paper size.
func (setup pageSetup) SetPaperSizeAndDefaultMargins(size *PaperSize) {
	var arg0 *C.GtkPageSetup
	var arg1 *C.GtkPaperSize

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = (*C.GtkPaperSize)(size.Native())

	C.gtk_page_setup_set_paper_size_and_default_margins(arg0, arg1)
}

// SetRightMargin sets the right margin of the PageSetup.
func (setup pageSetup) SetRightMargin(margin float64, unit Unit) {
	var arg0 *C.GtkPageSetup
	var arg1 C.gdouble
	var arg2 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = C.gdouble(margin)
	arg2 = (C.GtkUnit)(unit)

	C.gtk_page_setup_set_right_margin(arg0, arg1, arg2)
}

// SetTopMargin sets the top margin of the PageSetup.
func (setup pageSetup) SetTopMargin(margin float64, unit Unit) {
	var arg0 *C.GtkPageSetup
	var arg1 C.gdouble
	var arg2 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = C.gdouble(margin)
	arg2 = (C.GtkUnit)(unit)

	C.gtk_page_setup_set_top_margin(arg0, arg1, arg2)
}

// ToFile: this function saves the information from @setup to @file_name.
func (setup pageSetup) ToFile(fileName string) error {
	var arg0 *C.GtkPageSetup
	var arg1 *C.char
	var gError *C.GError

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_page_setup_to_file(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// ToGVariant: serialize page setup to an a{sv} variant.
func (setup pageSetup) ToGVariant() *glib.Variant {
	var arg0 *C.GtkPageSetup

	arg0 = (*C.GtkPageSetup)(setup.Native())

	ret := C.gtk_page_setup_to_gvariant(arg0)

	var ret0 *glib.Variant

	{
		ret0 = glib.WrapVariant(unsafe.Pointer(ret))
	}

	return ret0
}

// ToKeyFile: this function adds the page setup from @setup to @key_file.
func (setup pageSetup) ToKeyFile(keyFile *glib.KeyFile, groupName string) {
	var arg0 *C.GtkPageSetup
	var arg1 *C.GKeyFile
	var arg2 *C.gchar

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = (*C.GKeyFile)(keyFile.Native())
	arg2 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_page_setup_to_key_file(arg0, arg1, arg2)
}

// PrintContext: a GtkPrintContext encapsulates context information that is
// required when drawing pages for printing, such as the cairo context and
// important parameters like page size and resolution. It also lets you easily
// create Layout and Context objects that match the font metrics of the cairo
// surface.
//
// GtkPrintContext objects gets passed to the PrintOperation::begin-print,
// PrintOperation::end-print, PrintOperation::request-page-setup and
// PrintOperation::draw-page signals on the PrintOperation.
//
// Using GtkPrintContext in a PrintOperation::draw-page callback
//
//    static void
//    draw_page (GtkPrintOperation *operation,
//    	   GtkPrintContext   *context,
//    	   int                page_nr)
//    {
//      cairo_t *cr;
//      PangoLayout *layout;
//      PangoFontDescription *desc;
//
//      cr = gtk_print_context_get_cairo_context (context);
//
//      // Draw a red rectangle, as wide as the paper (inside the margins)
//      cairo_set_source_rgb (cr, 1.0, 0, 0);
//      cairo_rectangle (cr, 0, 0, gtk_print_context_get_width (context), 50);
//
//      cairo_fill (cr);
//
//      // Draw some lines
//      cairo_move_to (cr, 20, 10);
//      cairo_line_to (cr, 40, 20);
//      cairo_arc (cr, 60, 60, 20, 0, M_PI);
//      cairo_line_to (cr, 80, 20);
//
//      cairo_set_source_rgb (cr, 0, 0, 0);
//      cairo_set_line_width (cr, 5);
//      cairo_set_line_cap (cr, CAIRO_LINE_CAP_ROUND);
//      cairo_set_line_join (cr, CAIRO_LINE_JOIN_ROUND);
//
//      cairo_stroke (cr);
//
//      // Draw some text
//      layout = gtk_print_context_create_pango_layout (context);
//      pango_layout_set_text (layout, "Hello World! Printing is easy", -1);
//      desc = pango_font_description_from_string ("sans 28");
//      pango_layout_set_font_description (layout, desc);
//      pango_font_description_free (desc);
//
//      cairo_move_to (cr, 30, 20);
//      pango_cairo_layout_path (cr, layout);
//
//      // Font Outline
//      cairo_set_source_rgb (cr, 0.93, 1.0, 0.47);
//      cairo_set_line_width (cr, 0.5);
//      cairo_stroke_preserve (cr);
//
//      // Font Fill
//      cairo_set_source_rgb (cr, 0, 0.0, 1.0);
//      cairo_fill (cr);
//
//      g_object_unref (layout);
//    }
//
// Printing support was added in GTK+ 2.10.
type PrintContext interface {
	gextras.Objector

	// CreatePangoContext creates a new Context that can be used with the
	// PrintContext.
	CreatePangoContext() pango.Context
	// CreatePangoLayout creates a new Layout that is suitable for use with the
	// PrintContext.
	CreatePangoLayout() pango.Layout
	// CairoContext obtains the cairo context that is associated with the
	// PrintContext.
	CairoContext() *cairo.Context
	// DPIX obtains the horizontal resolution of the PrintContext, in dots per
	// inch.
	DPIX() float64
	// DPIY obtains the vertical resolution of the PrintContext, in dots per
	// inch.
	DPIY() float64
	// HardMargins obtains the hardware printer margins of the PrintContext, in
	// units.
	HardMargins() (top float64, bottom float64, left float64, right float64, ok bool)
	// Height obtains the height of the PrintContext, in pixels.
	Height() float64
	// PageSetup obtains the PageSetup that determines the page dimensions of
	// the PrintContext.
	PageSetup() PageSetup
	// PangoFontmap returns a FontMap that is suitable for use with the
	// PrintContext.
	PangoFontmap() pango.FontMap
	// Width obtains the width of the PrintContext, in pixels.
	Width() float64
	// SetCairoContext sets a new cairo context on a print context.
	//
	// This function is intended to be used when implementing an internal print
	// preview, it is not needed for printing, since GTK+ itself creates a
	// suitable cairo context in that case.
	SetCairoContext(cr *cairo.Context, dpiX float64, dpiY float64)
}

// printContext implements the PrintContext interface.
type printContext struct {
	gextras.Objector
}

var _ PrintContext = (*printContext)(nil)

// WrapPrintContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapPrintContext(obj *externglib.Object) PrintContext {
	return PrintContext{
		Objector: obj,
	}
}

func marshalPrintContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPrintContext(obj), nil
}

// CreatePangoContext creates a new Context that can be used with the
// PrintContext.
func (context printContext) CreatePangoContext() pango.Context {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(context.Native())

	ret := C.gtk_print_context_create_pango_context(arg0)

	var ret0 pango.Context

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(pango.Context)

	return ret0
}

// CreatePangoLayout creates a new Layout that is suitable for use with the
// PrintContext.
func (context printContext) CreatePangoLayout() pango.Layout {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(context.Native())

	ret := C.gtk_print_context_create_pango_layout(arg0)

	var ret0 pango.Layout

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(pango.Layout)

	return ret0
}

// CairoContext obtains the cairo context that is associated with the
// PrintContext.
func (context printContext) CairoContext() *cairo.Context {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(context.Native())

	ret := C.gtk_print_context_get_cairo_context(arg0)

	var ret0 *cairo.Context

	{
		ret0 = cairo.WrapContext(unsafe.Pointer(ret))
	}

	return ret0
}

// DPIX obtains the horizontal resolution of the PrintContext, in dots per
// inch.
func (context printContext) DPIX() float64 {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(context.Native())

	ret := C.gtk_print_context_get_dpi_x(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// DPIY obtains the vertical resolution of the PrintContext, in dots per
// inch.
func (context printContext) DPIY() float64 {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(context.Native())

	ret := C.gtk_print_context_get_dpi_y(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// HardMargins obtains the hardware printer margins of the PrintContext, in
// units.
func (context printContext) HardMargins() (top float64, bottom float64, left float64, right float64, ok bool) {
	var arg0 *C.GtkPrintContext
	var arg1 *C.gdouble // out
	var arg2 *C.gdouble // out
	var arg3 *C.gdouble // out
	var arg4 *C.gdouble // out

	arg0 = (*C.GtkPrintContext)(context.Native())

	ret := C.gtk_print_context_get_hard_margins(arg0, &arg1, &arg2, &arg3, &arg4)

	var ret0 float64
	var ret1 float64
	var ret2 float64
	var ret3 float64
	var ret4 bool

	ret0 = float64(arg1)

	ret1 = float64(arg2)

	ret2 = float64(arg3)

	ret3 = float64(arg4)

	ret4 = C.BOOL(ret) != 0

	return ret0, ret1, ret2, ret3, ret4
}

// Height obtains the height of the PrintContext, in pixels.
func (context printContext) Height() float64 {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(context.Native())

	ret := C.gtk_print_context_get_height(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// PageSetup obtains the PageSetup that determines the page dimensions of
// the PrintContext.
func (context printContext) PageSetup() PageSetup {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(context.Native())

	ret := C.gtk_print_context_get_page_setup(arg0)

	var ret0 PageSetup

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(PageSetup)

	return ret0
}

// PangoFontmap returns a FontMap that is suitable for use with the
// PrintContext.
func (context printContext) PangoFontmap() pango.FontMap {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(context.Native())

	ret := C.gtk_print_context_get_pango_fontmap(arg0)

	var ret0 pango.FontMap

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(pango.FontMap)

	return ret0
}

// Width obtains the width of the PrintContext, in pixels.
func (context printContext) Width() float64 {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(context.Native())

	ret := C.gtk_print_context_get_width(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// SetCairoContext sets a new cairo context on a print context.
//
// This function is intended to be used when implementing an internal print
// preview, it is not needed for printing, since GTK+ itself creates a
// suitable cairo context in that case.
func (context printContext) SetCairoContext(cr *cairo.Context, dpiX float64, dpiY float64) {
	var arg0 *C.GtkPrintContext
	var arg1 *C.cairo_t
	var arg2 C.double
	var arg3 C.double

	arg0 = (*C.GtkPrintContext)(context.Native())
	arg1 = (*C.cairo_t)(cr.Native())
	arg2 = C.double(dpiX)
	arg3 = C.double(dpiY)

	C.gtk_print_context_set_cairo_context(arg0, arg1, arg2, arg3)
}

// PrintOperation: gtkPrintOperation is the high-level, portable printing API.
// It looks a bit different than other GTK+ dialogs such as the FileChooser,
// since some platforms don’t expose enough infrastructure to implement a good
// print dialog. On such platforms, GtkPrintOperation uses the native print
// dialog. On platforms which do not provide a native print dialog, GTK+ uses
// its own, see PrintUnixDialog.
//
// The typical way to use the high-level printing API is to create a
// GtkPrintOperation object with gtk_print_operation_new() when the user selects
// to print. Then you set some properties on it, e.g. the page size, any
// PrintSettings from previous print operations, the number of pages, the
// current page, etc.
//
// Then you start the print operation by calling gtk_print_operation_run(). It
// will then show a dialog, let the user select a printer and options. When the
// user finished the dialog various signals will be emitted on the
// PrintOperation, the main one being PrintOperation::draw-page, which you are
// supposed to catch and render the page on the provided PrintContext using
// Cairo.
//
// The high-level printing API
//
//    static GtkPrintSettings *settings = NULL;
//
//    static void
//    do_print (void)
//    {
//      GtkPrintOperation *print;
//      GtkPrintOperationResult res;
//
//      print = gtk_print_operation_new ();
//
//      if (settings != NULL)
//        gtk_print_operation_set_print_settings (print, settings);
//
//      g_signal_connect (print, "begin_print", G_CALLBACK (begin_print), NULL);
//      g_signal_connect (print, "draw_page", G_CALLBACK (draw_page), NULL);
//
//      res = gtk_print_operation_run (print, GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG,
//                                     GTK_WINDOW (main_window), NULL);
//
//      if (res == GTK_PRINT_OPERATION_RESULT_APPLY)
//        {
//          if (settings != NULL)
//            g_object_unref (settings);
//          settings = g_object_ref (gtk_print_operation_get_print_settings (print));
//        }
//
//      g_object_unref (print);
//    }
//
// By default GtkPrintOperation uses an external application to do print
// preview. To implement a custom print preview, an application must connect to
// the preview signal. The functions gtk_print_operation_preview_render_page(),
// gtk_print_operation_preview_end_preview() and
// gtk_print_operation_preview_is_selected() are useful when implementing a
// print preview.
type PrintOperation interface {
	gextras.Objector
	PrintOperationPreview

	// Cancel cancels a running print operation. This function may be called
	// from a PrintOperation::begin-print, PrintOperation::paginate or
	// PrintOperation::draw-page signal handler to stop the currently running
	// print operation.
	Cancel()
	// DrawPageFinish: signalize that drawing of particular page is complete.
	//
	// It is called after completion of page drawing (e.g. drawing in another
	// thread). If gtk_print_operation_set_defer_drawing() was called before,
	// then this function has to be called by application. In another case it is
	// called by the library itself.
	DrawPageFinish()
	// DefaultPageSetup returns the default page setup, see
	// gtk_print_operation_set_default_page_setup().
	DefaultPageSetup() PageSetup
	// EmbedPageSetup gets the value of PrintOperation:embed-page-setup
	// property.
	EmbedPageSetup() bool
	// Error: call this when the result of a print operation is
	// GTK_PRINT_OPERATION_RESULT_ERROR, either as returned by
	// gtk_print_operation_run(), or in the PrintOperation::done signal handler.
	// The returned #GError will contain more details on what went wrong.
	Error() error
	// HasSelection gets the value of PrintOperation:has-selection property.
	HasSelection() bool
	// NPagesToPrint returns the number of pages that will be printed.
	//
	// Note that this value is set during print preparation phase
	// (GTK_PRINT_STATUS_PREPARING), so this function should never be called
	// before the data generation phase (GTK_PRINT_STATUS_GENERATING_DATA). You
	// can connect to the PrintOperation::status-changed signal and call
	// gtk_print_operation_get_n_pages_to_print() when print status is
	// GTK_PRINT_STATUS_GENERATING_DATA. This is typically used to track the
	// progress of print operation.
	NPagesToPrint() int
	// PrintSettings returns the current print settings.
	//
	// Note that the return value is nil until either
	// gtk_print_operation_set_print_settings() or gtk_print_operation_run()
	// have been called.
	PrintSettings() PrintSettings
	// Status returns the status of the print operation. Also see
	// gtk_print_operation_get_status_string().
	Status() PrintStatus
	// StatusString returns a string representation of the status of the print
	// operation. The string is translated and suitable for displaying the print
	// status e.g. in a Statusbar.
	//
	// Use gtk_print_operation_get_status() to obtain a status value that is
	// suitable for programmatic use.
	StatusString() string
	// SupportSelection gets the value of PrintOperation:support-selection
	// property.
	SupportSelection() bool
	// IsFinished: a convenience function to find out if the print operation is
	// finished, either successfully (GTK_PRINT_STATUS_FINISHED) or
	// unsuccessfully (GTK_PRINT_STATUS_FINISHED_ABORTED).
	//
	// Note: when you enable print status tracking the print operation can be in
	// a non-finished state even after done has been called, as the operation
	// status then tracks the print job status on the printer.
	IsFinished() bool
	// Run runs the print operation, by first letting the user modify print
	// settings in the print dialog, and then print the document.
	//
	// Normally that this function does not return until the rendering of all
	// pages is complete. You can connect to the PrintOperation::status-changed
	// signal on @op to obtain some information about the progress of the print
	// operation. Furthermore, it may use a recursive mainloop to show the print
	// dialog.
	//
	// If you call gtk_print_operation_set_allow_async() or set the
	// PrintOperation:allow-async property the operation will run asynchronously
	// if this is supported on the platform. The PrintOperation::done signal
	// will be emitted with the result of the operation when the it is done
	// (i.e. when the dialog is canceled, or when the print succeeds or fails).
	//
	//    if (settings != NULL)
	//      gtk_print_operation_set_print_settings (print, settings);
	//
	//    if (page_setup != NULL)
	//      gtk_print_operation_set_default_page_setup (print, page_setup);
	//
	//    g_signal_connect (print, "begin-print",
	//                      G_CALLBACK (begin_print), &data);
	//    g_signal_connect (print, "draw-page",
	//                      G_CALLBACK (draw_page), &data);
	//
	//    res = gtk_print_operation_run (print,
	//                                   GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG,
	//                                   parent,
	//                                   &error);
	//
	//    if (res == GTK_PRINT_OPERATION_RESULT_ERROR)
	//     {
	//       error_dialog = gtk_message_dialog_new (GTK_WINDOW (parent),
	//      			                     GTK_DIALOG_DESTROY_WITH_PARENT,
	//    					     GTK_MESSAGE_ERROR,
	//    					     GTK_BUTTONS_CLOSE,
	//    					     "Error printing file:\ns",
	//    					     error->message);
	//       g_signal_connect (error_dialog, "response",
	//                         G_CALLBACK (gtk_widget_destroy), NULL);
	//       gtk_widget_show (error_dialog);
	//       g_error_free (error);
	//     }
	//    else if (res == GTK_PRINT_OPERATION_RESULT_APPLY)
	//     {
	//       if (settings != NULL)
	//    g_object_unref (settings);
	//       settings = g_object_ref (gtk_print_operation_get_print_settings (print));
	//     }
	//
	// Note that gtk_print_operation_run() can only be called once on a given
	// PrintOperation.
	Run(action PrintOperationAction, parent Window) (printOperationResult PrintOperationResult, err error)
	// SetAllowAsync sets whether the gtk_print_operation_run() may return
	// before the print operation is completed. Note that some platforms may not
	// allow asynchronous operation.
	SetAllowAsync(allowAsync bool)
	// SetCurrentPage sets the current page.
	//
	// If this is called before gtk_print_operation_run(), the user will be able
	// to select to print only the current page.
	//
	// Note that this only makes sense for pre-paginated documents.
	SetCurrentPage(currentPage int)
	// SetCustomTabLabel sets the label for the tab holding custom widgets.
	SetCustomTabLabel(label string)
	// SetDefaultPageSetup makes @default_page_setup the default page setup for
	// @op.
	//
	// This page setup will be used by gtk_print_operation_run(), but it can be
	// overridden on a per-page basis by connecting to the
	// PrintOperation::request-page-setup signal.
	SetDefaultPageSetup(defaultPageSetup PageSetup)
	// SetDeferDrawing sets up the PrintOperation to wait for calling of
	// gtk_print_operation_draw_page_finish() from application. It can be used
	// for drawing page in another thread.
	//
	// This function must be called in the callback of “draw-page” signal.
	SetDeferDrawing()
	// SetEmbedPageSetup: embed page size combo box and orientation combo box
	// into page setup page. Selected page setup is stored as default page setup
	// in PrintOperation.
	SetEmbedPageSetup(embed bool)
	// SetExportFilename sets up the PrintOperation to generate a file instead
	// of showing the print dialog. The indended use of this function is for
	// implementing “Export to PDF” actions. Currently, PDF is the only
	// supported format.
	//
	// “Print to PDF” support is independent of this and is done by letting the
	// user pick the “Print to PDF” item from the list of printers in the print
	// dialog.
	SetExportFilename(filename string)
	// SetHasSelection sets whether there is a selection to print.
	//
	// Application has to set number of pages to which the selection will draw
	// by gtk_print_operation_set_n_pages() in a callback of
	// PrintOperation::begin-print.
	SetHasSelection(hasSelection bool)
	// SetJobName sets the name of the print job. The name is used to identify
	// the job (e.g. in monitoring applications like eggcups).
	//
	// If you don’t set a job name, GTK+ picks a default one by numbering
	// successive print jobs.
	SetJobName(jobName string)
	// SetNPages sets the number of pages in the document.
	//
	// This must be set to a positive number before the rendering starts. It may
	// be set in a PrintOperation::begin-print signal hander.
	//
	// Note that the page numbers passed to the
	// PrintOperation::request-page-setup and PrintOperation::draw-page signals
	// are 0-based, i.e. if the user chooses to print all pages, the last
	// ::draw-page signal will be for page @n_pages - 1.
	SetNPages(nPages int)
	// SetPrintSettings sets the print settings for @op. This is typically used
	// to re-establish print settings from a previous print operation, see
	// gtk_print_operation_run().
	SetPrintSettings(printSettings PrintSettings)
	// SetShowProgress: if @show_progress is true, the print operation will show
	// a progress dialog during the print operation.
	SetShowProgress(showProgress bool)
	// SetSupportSelection sets whether selection is supported by
	// PrintOperation.
	SetSupportSelection(supportSelection bool)
	// SetTrackPrintStatus: if track_status is true, the print operation will
	// try to continue report on the status of the print job in the printer
	// queues and printer. This can allow your application to show things like
	// “out of paper” issues, and when the print job actually reaches the
	// printer.
	//
	// This function is often implemented using some form of polling, so it
	// should not be enabled unless needed.
	SetTrackPrintStatus(trackStatus bool)
	// SetUnit sets up the transformation for the cairo context obtained from
	// PrintContext in such a way that distances are measured in units of @unit.
	SetUnit(unit Unit)
	// SetUseFullPage: if @full_page is true, the transformation for the cairo
	// context obtained from PrintContext puts the origin at the top left corner
	// of the page (which may not be the top left corner of the sheet, depending
	// on page orientation and the number of pages per sheet). Otherwise, the
	// origin is at the top left corner of the imageable area (i.e. inside the
	// margins).
	SetUseFullPage(fullPage bool)
}

// printOperation implements the PrintOperation interface.
type printOperation struct {
	gextras.Objector
	PrintOperationPreview
}

var _ PrintOperation = (*printOperation)(nil)

// WrapPrintOperation wraps a GObject to the right type. It is
// primarily used internally.
func WrapPrintOperation(obj *externglib.Object) PrintOperation {
	return PrintOperation{
		Objector:              obj,
		PrintOperationPreview: WrapPrintOperationPreview(obj),
	}
}

func marshalPrintOperation(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPrintOperation(obj), nil
}

// NewPrintOperation constructs a class PrintOperation.
func NewPrintOperation() PrintOperation {

	ret := C.gtk_print_operation_new()

	var ret0 PrintOperation

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(PrintOperation)

	return ret0
}

// Cancel cancels a running print operation. This function may be called
// from a PrintOperation::begin-print, PrintOperation::paginate or
// PrintOperation::draw-page signal handler to stop the currently running
// print operation.
func (op printOperation) Cancel() {
	var arg0 *C.GtkPrintOperation

	arg0 = (*C.GtkPrintOperation)(op.Native())

	C.gtk_print_operation_cancel(arg0)
}

// DrawPageFinish: signalize that drawing of particular page is complete.
//
// It is called after completion of page drawing (e.g. drawing in another
// thread). If gtk_print_operation_set_defer_drawing() was called before,
// then this function has to be called by application. In another case it is
// called by the library itself.
func (op printOperation) DrawPageFinish() {
	var arg0 *C.GtkPrintOperation

	arg0 = (*C.GtkPrintOperation)(op.Native())

	C.gtk_print_operation_draw_page_finish(arg0)
}

// DefaultPageSetup returns the default page setup, see
// gtk_print_operation_set_default_page_setup().
func (op printOperation) DefaultPageSetup() PageSetup {
	var arg0 *C.GtkPrintOperation

	arg0 = (*C.GtkPrintOperation)(op.Native())

	ret := C.gtk_print_operation_get_default_page_setup(arg0)

	var ret0 PageSetup

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(PageSetup)

	return ret0
}

// EmbedPageSetup gets the value of PrintOperation:embed-page-setup
// property.
func (op printOperation) EmbedPageSetup() bool {
	var arg0 *C.GtkPrintOperation

	arg0 = (*C.GtkPrintOperation)(op.Native())

	ret := C.gtk_print_operation_get_embed_page_setup(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Error: call this when the result of a print operation is
// GTK_PRINT_OPERATION_RESULT_ERROR, either as returned by
// gtk_print_operation_run(), or in the PrintOperation::done signal handler.
// The returned #GError will contain more details on what went wrong.
func (op printOperation) Error() error {
	var arg0 *C.GtkPrintOperation
	var gError *C.GError

	arg0 = (*C.GtkPrintOperation)(op.Native())

	C.gtk_print_operation_get_error(arg0, &gError)
}

// HasSelection gets the value of PrintOperation:has-selection property.
func (op printOperation) HasSelection() bool {
	var arg0 *C.GtkPrintOperation

	arg0 = (*C.GtkPrintOperation)(op.Native())

	ret := C.gtk_print_operation_get_has_selection(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// NPagesToPrint returns the number of pages that will be printed.
//
// Note that this value is set during print preparation phase
// (GTK_PRINT_STATUS_PREPARING), so this function should never be called
// before the data generation phase (GTK_PRINT_STATUS_GENERATING_DATA). You
// can connect to the PrintOperation::status-changed signal and call
// gtk_print_operation_get_n_pages_to_print() when print status is
// GTK_PRINT_STATUS_GENERATING_DATA. This is typically used to track the
// progress of print operation.
func (op printOperation) NPagesToPrint() int {
	var arg0 *C.GtkPrintOperation

	arg0 = (*C.GtkPrintOperation)(op.Native())

	ret := C.gtk_print_operation_get_n_pages_to_print(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// PrintSettings returns the current print settings.
//
// Note that the return value is nil until either
// gtk_print_operation_set_print_settings() or gtk_print_operation_run()
// have been called.
func (op printOperation) PrintSettings() PrintSettings {
	var arg0 *C.GtkPrintOperation

	arg0 = (*C.GtkPrintOperation)(op.Native())

	ret := C.gtk_print_operation_get_print_settings(arg0)

	var ret0 PrintSettings

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(PrintSettings)

	return ret0
}

// Status returns the status of the print operation. Also see
// gtk_print_operation_get_status_string().
func (op printOperation) Status() PrintStatus {
	var arg0 *C.GtkPrintOperation

	arg0 = (*C.GtkPrintOperation)(op.Native())

	ret := C.gtk_print_operation_get_status(arg0)

	var ret0 PrintStatus

	ret0 = PrintStatus(ret)

	return ret0
}

// StatusString returns a string representation of the status of the print
// operation. The string is translated and suitable for displaying the print
// status e.g. in a Statusbar.
//
// Use gtk_print_operation_get_status() to obtain a status value that is
// suitable for programmatic use.
func (op printOperation) StatusString() string {
	var arg0 *C.GtkPrintOperation

	arg0 = (*C.GtkPrintOperation)(op.Native())

	ret := C.gtk_print_operation_get_status_string(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// SupportSelection gets the value of PrintOperation:support-selection
// property.
func (op printOperation) SupportSelection() bool {
	var arg0 *C.GtkPrintOperation

	arg0 = (*C.GtkPrintOperation)(op.Native())

	ret := C.gtk_print_operation_get_support_selection(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IsFinished: a convenience function to find out if the print operation is
// finished, either successfully (GTK_PRINT_STATUS_FINISHED) or
// unsuccessfully (GTK_PRINT_STATUS_FINISHED_ABORTED).
//
// Note: when you enable print status tracking the print operation can be in
// a non-finished state even after done has been called, as the operation
// status then tracks the print job status on the printer.
func (op printOperation) IsFinished() bool {
	var arg0 *C.GtkPrintOperation

	arg0 = (*C.GtkPrintOperation)(op.Native())

	ret := C.gtk_print_operation_is_finished(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Run runs the print operation, by first letting the user modify print
// settings in the print dialog, and then print the document.
//
// Normally that this function does not return until the rendering of all
// pages is complete. You can connect to the PrintOperation::status-changed
// signal on @op to obtain some information about the progress of the print
// operation. Furthermore, it may use a recursive mainloop to show the print
// dialog.
//
// If you call gtk_print_operation_set_allow_async() or set the
// PrintOperation:allow-async property the operation will run asynchronously
// if this is supported on the platform. The PrintOperation::done signal
// will be emitted with the result of the operation when the it is done
// (i.e. when the dialog is canceled, or when the print succeeds or fails).
//
//    if (settings != NULL)
//      gtk_print_operation_set_print_settings (print, settings);
//
//    if (page_setup != NULL)
//      gtk_print_operation_set_default_page_setup (print, page_setup);
//
//    g_signal_connect (print, "begin-print",
//                      G_CALLBACK (begin_print), &data);
//    g_signal_connect (print, "draw-page",
//                      G_CALLBACK (draw_page), &data);
//
//    res = gtk_print_operation_run (print,
//                                   GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG,
//                                   parent,
//                                   &error);
//
//    if (res == GTK_PRINT_OPERATION_RESULT_ERROR)
//     {
//       error_dialog = gtk_message_dialog_new (GTK_WINDOW (parent),
//      			                     GTK_DIALOG_DESTROY_WITH_PARENT,
//    					     GTK_MESSAGE_ERROR,
//    					     GTK_BUTTONS_CLOSE,
//    					     "Error printing file:\ns",
//    					     error->message);
//       g_signal_connect (error_dialog, "response",
//                         G_CALLBACK (gtk_widget_destroy), NULL);
//       gtk_widget_show (error_dialog);
//       g_error_free (error);
//     }
//    else if (res == GTK_PRINT_OPERATION_RESULT_APPLY)
//     {
//       if (settings != NULL)
//    g_object_unref (settings);
//       settings = g_object_ref (gtk_print_operation_get_print_settings (print));
//     }
//
// Note that gtk_print_operation_run() can only be called once on a given
// PrintOperation.
func (op printOperation) Run(action PrintOperationAction, parent Window) (printOperationResult PrintOperationResult, err error) {
	var arg0 *C.GtkPrintOperation
	var arg1 C.GtkPrintOperationAction
	var arg2 *C.GtkWindow
	var gError *C.GError

	arg0 = (*C.GtkPrintOperation)(op.Native())
	arg1 = (C.GtkPrintOperationAction)(action)
	arg2 = (*C.GtkWindow)(parent.Native())

	ret := C.gtk_print_operation_run(arg0, arg1, arg2, &gError)

	var ret0 PrintOperationResult
	var goError error

	ret0 = PrintOperationResult(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// SetAllowAsync sets whether the gtk_print_operation_run() may return
// before the print operation is completed. Note that some platforms may not
// allow asynchronous operation.
func (op printOperation) SetAllowAsync(allowAsync bool) {
	var arg0 *C.GtkPrintOperation
	var arg1 C.gboolean

	arg0 = (*C.GtkPrintOperation)(op.Native())
	if allowAsync {
		arg1 = C.TRUE
	}

	C.gtk_print_operation_set_allow_async(arg0, arg1)
}

// SetCurrentPage sets the current page.
//
// If this is called before gtk_print_operation_run(), the user will be able
// to select to print only the current page.
//
// Note that this only makes sense for pre-paginated documents.
func (op printOperation) SetCurrentPage(currentPage int) {
	var arg0 *C.GtkPrintOperation
	var arg1 C.gint

	arg0 = (*C.GtkPrintOperation)(op.Native())
	arg1 = C.gint(currentPage)

	C.gtk_print_operation_set_current_page(arg0, arg1)
}

// SetCustomTabLabel sets the label for the tab holding custom widgets.
func (op printOperation) SetCustomTabLabel(label string) {
	var arg0 *C.GtkPrintOperation
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintOperation)(op.Native())
	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_operation_set_custom_tab_label(arg0, arg1)
}

// SetDefaultPageSetup makes @default_page_setup the default page setup for
// @op.
//
// This page setup will be used by gtk_print_operation_run(), but it can be
// overridden on a per-page basis by connecting to the
// PrintOperation::request-page-setup signal.
func (op printOperation) SetDefaultPageSetup(defaultPageSetup PageSetup) {
	var arg0 *C.GtkPrintOperation
	var arg1 *C.GtkPageSetup

	arg0 = (*C.GtkPrintOperation)(op.Native())
	arg1 = (*C.GtkPageSetup)(defaultPageSetup.Native())

	C.gtk_print_operation_set_default_page_setup(arg0, arg1)
}

// SetDeferDrawing sets up the PrintOperation to wait for calling of
// gtk_print_operation_draw_page_finish() from application. It can be used
// for drawing page in another thread.
//
// This function must be called in the callback of “draw-page” signal.
func (op printOperation) SetDeferDrawing() {
	var arg0 *C.GtkPrintOperation

	arg0 = (*C.GtkPrintOperation)(op.Native())

	C.gtk_print_operation_set_defer_drawing(arg0)
}

// SetEmbedPageSetup: embed page size combo box and orientation combo box
// into page setup page. Selected page setup is stored as default page setup
// in PrintOperation.
func (op printOperation) SetEmbedPageSetup(embed bool) {
	var arg0 *C.GtkPrintOperation
	var arg1 C.gboolean

	arg0 = (*C.GtkPrintOperation)(op.Native())
	if embed {
		arg1 = C.TRUE
	}

	C.gtk_print_operation_set_embed_page_setup(arg0, arg1)
}

// SetExportFilename sets up the PrintOperation to generate a file instead
// of showing the print dialog. The indended use of this function is for
// implementing “Export to PDF” actions. Currently, PDF is the only
// supported format.
//
// “Print to PDF” support is independent of this and is done by letting the
// user pick the “Print to PDF” item from the list of printers in the print
// dialog.
func (op printOperation) SetExportFilename(filename string) {
	var arg0 *C.GtkPrintOperation
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintOperation)(op.Native())
	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_operation_set_export_filename(arg0, arg1)
}

// SetHasSelection sets whether there is a selection to print.
//
// Application has to set number of pages to which the selection will draw
// by gtk_print_operation_set_n_pages() in a callback of
// PrintOperation::begin-print.
func (op printOperation) SetHasSelection(hasSelection bool) {
	var arg0 *C.GtkPrintOperation
	var arg1 C.gboolean

	arg0 = (*C.GtkPrintOperation)(op.Native())
	if hasSelection {
		arg1 = C.TRUE
	}

	C.gtk_print_operation_set_has_selection(arg0, arg1)
}

// SetJobName sets the name of the print job. The name is used to identify
// the job (e.g. in monitoring applications like eggcups).
//
// If you don’t set a job name, GTK+ picks a default one by numbering
// successive print jobs.
func (op printOperation) SetJobName(jobName string) {
	var arg0 *C.GtkPrintOperation
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintOperation)(op.Native())
	arg1 = (*C.gchar)(C.CString(jobName))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_operation_set_job_name(arg0, arg1)
}

// SetNPages sets the number of pages in the document.
//
// This must be set to a positive number before the rendering starts. It may
// be set in a PrintOperation::begin-print signal hander.
//
// Note that the page numbers passed to the
// PrintOperation::request-page-setup and PrintOperation::draw-page signals
// are 0-based, i.e. if the user chooses to print all pages, the last
// ::draw-page signal will be for page @n_pages - 1.
func (op printOperation) SetNPages(nPages int) {
	var arg0 *C.GtkPrintOperation
	var arg1 C.gint

	arg0 = (*C.GtkPrintOperation)(op.Native())
	arg1 = C.gint(nPages)

	C.gtk_print_operation_set_n_pages(arg0, arg1)
}

// SetPrintSettings sets the print settings for @op. This is typically used
// to re-establish print settings from a previous print operation, see
// gtk_print_operation_run().
func (op printOperation) SetPrintSettings(printSettings PrintSettings) {
	var arg0 *C.GtkPrintOperation
	var arg1 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintOperation)(op.Native())
	arg1 = (*C.GtkPrintSettings)(printSettings.Native())

	C.gtk_print_operation_set_print_settings(arg0, arg1)
}

// SetShowProgress: if @show_progress is true, the print operation will show
// a progress dialog during the print operation.
func (op printOperation) SetShowProgress(showProgress bool) {
	var arg0 *C.GtkPrintOperation
	var arg1 C.gboolean

	arg0 = (*C.GtkPrintOperation)(op.Native())
	if showProgress {
		arg1 = C.TRUE
	}

	C.gtk_print_operation_set_show_progress(arg0, arg1)
}

// SetSupportSelection sets whether selection is supported by
// PrintOperation.
func (op printOperation) SetSupportSelection(supportSelection bool) {
	var arg0 *C.GtkPrintOperation
	var arg1 C.gboolean

	arg0 = (*C.GtkPrintOperation)(op.Native())
	if supportSelection {
		arg1 = C.TRUE
	}

	C.gtk_print_operation_set_support_selection(arg0, arg1)
}

// SetTrackPrintStatus: if track_status is true, the print operation will
// try to continue report on the status of the print job in the printer
// queues and printer. This can allow your application to show things like
// “out of paper” issues, and when the print job actually reaches the
// printer.
//
// This function is often implemented using some form of polling, so it
// should not be enabled unless needed.
func (op printOperation) SetTrackPrintStatus(trackStatus bool) {
	var arg0 *C.GtkPrintOperation
	var arg1 C.gboolean

	arg0 = (*C.GtkPrintOperation)(op.Native())
	if trackStatus {
		arg1 = C.TRUE
	}

	C.gtk_print_operation_set_track_print_status(arg0, arg1)
}

// SetUnit sets up the transformation for the cairo context obtained from
// PrintContext in such a way that distances are measured in units of @unit.
func (op printOperation) SetUnit(unit Unit) {
	var arg0 *C.GtkPrintOperation
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPrintOperation)(op.Native())
	arg1 = (C.GtkUnit)(unit)

	C.gtk_print_operation_set_unit(arg0, arg1)
}

// SetUseFullPage: if @full_page is true, the transformation for the cairo
// context obtained from PrintContext puts the origin at the top left corner
// of the page (which may not be the top left corner of the sheet, depending
// on page orientation and the number of pages per sheet). Otherwise, the
// origin is at the top left corner of the imageable area (i.e. inside the
// margins).
func (op printOperation) SetUseFullPage(fullPage bool) {
	var arg0 *C.GtkPrintOperation
	var arg1 C.gboolean

	arg0 = (*C.GtkPrintOperation)(op.Native())
	if fullPage {
		arg1 = C.TRUE
	}

	C.gtk_print_operation_set_use_full_page(arg0, arg1)
}

// PrintSettings: a GtkPrintSettings object represents the settings of a print
// dialog in a system-independent way. The main use for this object is that once
// you’ve printed you can get a settings object that represents the settings the
// user chose, and the next time you print you can pass that object in so that
// the user doesn’t have to re-set all his settings.
//
// Its also possible to enumerate the settings so that you can easily save the
// settings for the next time your app runs, or even store them in a document.
// The predefined keys try to use shared values as much as possible so that
// moving such a document between systems still works.
//
// Printing support was added in GTK+ 2.10.
type PrintSettings interface {
	gextras.Objector

	// Copy copies a PrintSettings object.
	Copy() PrintSettings
	// Foreach calls @func for each key-value pair of @settings.
	Foreach(fn PrintSettingsFunc)
	// Get looks up the string value associated with @key.
	Get(key string) string
	// Bool returns the boolean represented by the value that is associated with
	// @key.
	//
	// The string “true” represents true, any other string false.
	Bool(key string) bool
	// Collate gets the value of GTK_PRINT_SETTINGS_COLLATE.
	Collate() bool
	// DefaultSource gets the value of GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
	DefaultSource() string
	// Dither gets the value of GTK_PRINT_SETTINGS_DITHER.
	Dither() string
	// Double returns the double value associated with @key, or 0.
	Double(key string) float64
	// DoubleWithDefault returns the floating point number represented by the
	// value that is associated with @key, or @default_val if the value does not
	// represent a floating point number.
	//
	// Floating point numbers are parsed with g_ascii_strtod().
	DoubleWithDefault(key string, def float64) float64
	// Duplex gets the value of GTK_PRINT_SETTINGS_DUPLEX.
	Duplex() PrintDuplex
	// Finishings gets the value of GTK_PRINT_SETTINGS_FINISHINGS.
	Finishings() string
	// Int returns the integer value of @key, or 0.
	Int(key string) int
	// IntWithDefault returns the value of @key, interpreted as an integer, or
	// the default value.
	IntWithDefault(key string, def int) int
	// Length returns the value associated with @key, interpreted as a length.
	// The returned value is converted to @units.
	Length(key string, unit Unit) float64
	// MediaType gets the value of GTK_PRINT_SETTINGS_MEDIA_TYPE.
	//
	// The set of media types is defined in PWG 5101.1-2002 PWG.
	MediaType() string
	// NCopies gets the value of GTK_PRINT_SETTINGS_N_COPIES.
	NCopies() int
	// NumberUp gets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
	NumberUp() int
	// NumberUpLayout gets the value of GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT.
	NumberUpLayout() NumberUpLayout
	// Orientation: get the value of GTK_PRINT_SETTINGS_ORIENTATION, converted
	// to a PageOrientation.
	Orientation() PageOrientation
	// OutputBin gets the value of GTK_PRINT_SETTINGS_OUTPUT_BIN.
	OutputBin() string
	// PageRanges gets the value of GTK_PRINT_SETTINGS_PAGE_RANGES.
	PageRanges() (numRanges int, pageRanges []PageRange)
	// PageSet gets the value of GTK_PRINT_SETTINGS_PAGE_SET.
	PageSet() PageSet
	// PaperHeight gets the value of GTK_PRINT_SETTINGS_PAPER_HEIGHT, converted
	// to @unit.
	PaperHeight(unit Unit) float64
	// PaperSize gets the value of GTK_PRINT_SETTINGS_PAPER_FORMAT, converted to
	// a PaperSize.
	PaperSize() *PaperSize
	// PaperWidth gets the value of GTK_PRINT_SETTINGS_PAPER_WIDTH, converted to
	// @unit.
	PaperWidth(unit Unit) float64
	// PrintPages gets the value of GTK_PRINT_SETTINGS_PRINT_PAGES.
	PrintPages() PrintPages
	// Printer: convenience function to obtain the value of
	// GTK_PRINT_SETTINGS_PRINTER.
	Printer() string
	// PrinterLpi gets the value of GTK_PRINT_SETTINGS_PRINTER_LPI.
	PrinterLpi() float64
	// Quality gets the value of GTK_PRINT_SETTINGS_QUALITY.
	Quality() PrintQuality
	// Resolution gets the value of GTK_PRINT_SETTINGS_RESOLUTION.
	Resolution() int
	// ResolutionX gets the value of GTK_PRINT_SETTINGS_RESOLUTION_X.
	ResolutionX() int
	// ResolutionY gets the value of GTK_PRINT_SETTINGS_RESOLUTION_Y.
	ResolutionY() int
	// Reverse gets the value of GTK_PRINT_SETTINGS_REVERSE.
	Reverse() bool
	// Scale gets the value of GTK_PRINT_SETTINGS_SCALE.
	Scale() float64
	// UseColor gets the value of GTK_PRINT_SETTINGS_USE_COLOR.
	UseColor() bool
	// HasKey returns true, if a value is associated with @key.
	HasKey(key string) bool
	// LoadFile reads the print settings from @file_name. If the file could not
	// be loaded then error is set to either a Error or FileError. See
	// gtk_print_settings_to_file().
	LoadFile(fileName string) error
	// LoadKeyFile reads the print settings from the group @group_name in
	// @key_file. If the file could not be loaded then error is set to either a
	// Error or FileError.
	LoadKeyFile(keyFile *glib.KeyFile, groupName string) error
	// Set associates @value with @key.
	Set(key string, value string)
	// SetBool sets @key to a boolean value.
	SetBool(key string, value bool)
	// SetCollate sets the value of GTK_PRINT_SETTINGS_COLLATE.
	SetCollate(collate bool)
	// SetDefaultSource sets the value of GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
	SetDefaultSource(defaultSource string)
	// SetDither sets the value of GTK_PRINT_SETTINGS_DITHER.
	SetDither(dither string)
	// SetDouble sets @key to a double value.
	SetDouble(key string, value float64)
	// SetDuplex sets the value of GTK_PRINT_SETTINGS_DUPLEX.
	SetDuplex(duplex PrintDuplex)
	// SetFinishings sets the value of GTK_PRINT_SETTINGS_FINISHINGS.
	SetFinishings(finishings string)
	// SetInt sets @key to an integer value.
	SetInt(key string, value int)
	// SetLength associates a length in units of @unit with @key.
	SetLength(key string, value float64, unit Unit)
	// SetMediaType sets the value of GTK_PRINT_SETTINGS_MEDIA_TYPE.
	//
	// The set of media types is defined in PWG 5101.1-2002 PWG.
	SetMediaType(mediaType string)
	// SetNCopies sets the value of GTK_PRINT_SETTINGS_N_COPIES.
	SetNCopies(numCopies int)
	// SetNumberUp sets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
	SetNumberUp(numberUp int)
	// SetNumberUpLayout sets the value of GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT.
	SetNumberUpLayout(numberUpLayout NumberUpLayout)
	// SetOrientation sets the value of GTK_PRINT_SETTINGS_ORIENTATION.
	SetOrientation(orientation PageOrientation)
	// SetOutputBin sets the value of GTK_PRINT_SETTINGS_OUTPUT_BIN.
	SetOutputBin(outputBin string)
	// SetPageRanges sets the value of GTK_PRINT_SETTINGS_PAGE_RANGES.
	SetPageRanges(pageRanges []PageRange)
	// SetPageSet sets the value of GTK_PRINT_SETTINGS_PAGE_SET.
	SetPageSet(pageSet PageSet)
	// SetPaperHeight sets the value of GTK_PRINT_SETTINGS_PAPER_HEIGHT.
	SetPaperHeight(height float64, unit Unit)
	// SetPaperSize sets the value of GTK_PRINT_SETTINGS_PAPER_FORMAT,
	// GTK_PRINT_SETTINGS_PAPER_WIDTH and GTK_PRINT_SETTINGS_PAPER_HEIGHT.
	SetPaperSize(paperSize *PaperSize)
	// SetPaperWidth sets the value of GTK_PRINT_SETTINGS_PAPER_WIDTH.
	SetPaperWidth(width float64, unit Unit)
	// SetPrintPages sets the value of GTK_PRINT_SETTINGS_PRINT_PAGES.
	SetPrintPages(pages PrintPages)
	// SetPrinter: convenience function to set GTK_PRINT_SETTINGS_PRINTER to
	// @printer.
	SetPrinter(printer string)
	// SetPrinterLpi sets the value of GTK_PRINT_SETTINGS_PRINTER_LPI.
	SetPrinterLpi(lpi float64)
	// SetQuality sets the value of GTK_PRINT_SETTINGS_QUALITY.
	SetQuality(quality PrintQuality)
	// SetResolution sets the values of GTK_PRINT_SETTINGS_RESOLUTION,
	// GTK_PRINT_SETTINGS_RESOLUTION_X and GTK_PRINT_SETTINGS_RESOLUTION_Y.
	SetResolution(resolution int)
	// SetResolutionXY sets the values of GTK_PRINT_SETTINGS_RESOLUTION,
	// GTK_PRINT_SETTINGS_RESOLUTION_X and GTK_PRINT_SETTINGS_RESOLUTION_Y.
	SetResolutionXY(resolutionX int, resolutionY int)
	// SetReverse sets the value of GTK_PRINT_SETTINGS_REVERSE.
	SetReverse(reverse bool)
	// SetScale sets the value of GTK_PRINT_SETTINGS_SCALE.
	SetScale(scale float64)
	// SetUseColor sets the value of GTK_PRINT_SETTINGS_USE_COLOR.
	SetUseColor(useColor bool)
	// ToFile: this function saves the print settings from @settings to
	// @file_name. If the file could not be loaded then error is set to either a
	// Error or FileError.
	ToFile(fileName string) error
	// ToGVariant: serialize print settings to an a{sv} variant.
	ToGVariant() *glib.Variant
	// ToKeyFile: this function adds the print settings from @settings to
	// @key_file.
	ToKeyFile(keyFile *glib.KeyFile, groupName string)
	// Unset removes any value associated with @key. This has the same effect as
	// setting the value to nil.
	Unset(key string)
}

// printSettings implements the PrintSettings interface.
type printSettings struct {
	gextras.Objector
}

var _ PrintSettings = (*printSettings)(nil)

// WrapPrintSettings wraps a GObject to the right type. It is
// primarily used internally.
func WrapPrintSettings(obj *externglib.Object) PrintSettings {
	return PrintSettings{
		Objector: obj,
	}
}

func marshalPrintSettings(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPrintSettings(obj), nil
}

// NewPrintSettings constructs a class PrintSettings.
func NewPrintSettings() PrintSettings {

	ret := C.gtk_print_settings_new()

	var ret0 PrintSettings

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(PrintSettings)

	return ret0
}

// NewPrintSettingsFromFile constructs a class PrintSettings.
func NewPrintSettingsFromFile(fileName string) (printSettings PrintSettings, err error) {
	var arg1 *C.gchar
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_print_settings_new_from_file(arg1, &gError)

	var ret0 PrintSettings
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(PrintSettings)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// NewPrintSettingsFromGVariant constructs a class PrintSettings.
func NewPrintSettingsFromGVariant(variant *glib.Variant) PrintSettings {
	var arg1 *C.GVariant

	arg1 = (*C.GVariant)(variant.Native())

	ret := C.gtk_print_settings_new_from_gvariant(arg1)

	var ret0 PrintSettings

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(PrintSettings)

	return ret0
}

// NewPrintSettingsFromKeyFile constructs a class PrintSettings.
func NewPrintSettingsFromKeyFile(keyFile *glib.KeyFile, groupName string) (printSettings PrintSettings, err error) {
	var arg1 *C.GKeyFile
	var arg2 *C.gchar
	var gError *C.GError

	arg1 = (*C.GKeyFile)(keyFile.Native())
	arg2 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_print_settings_new_from_key_file(arg1, arg2, &gError)

	var ret0 PrintSettings
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(PrintSettings)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Copy copies a PrintSettings object.
func (other printSettings) Copy() PrintSettings {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(other.Native())

	ret := C.gtk_print_settings_copy(arg0)

	var ret0 PrintSettings

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(PrintSettings)

	return ret0
}

// Foreach calls @func for each key-value pair of @settings.
func (settings printSettings) Foreach(fn PrintSettingsFunc) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkPrintSettingsFunc
	var arg2 C.gpointer

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*[0]byte)(C.gotk4_PrintSettingsFunc)
	arg2 = C.gpointer(box.Assign(fn))

	C.gtk_print_settings_foreach(arg0, arg1, arg2)
}

// Get looks up the string value associated with @key.
func (settings printSettings) Get(key string) string {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_print_settings_get(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Bool returns the boolean represented by the value that is associated with
// @key.
//
// The string “true” represents true, any other string false.
func (settings printSettings) Bool(key string) bool {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_print_settings_get_bool(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Collate gets the value of GTK_PRINT_SETTINGS_COLLATE.
func (settings printSettings) Collate() bool {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_collate(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// DefaultSource gets the value of GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
func (settings printSettings) DefaultSource() string {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_default_source(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Dither gets the value of GTK_PRINT_SETTINGS_DITHER.
func (settings printSettings) Dither() string {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_dither(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Double returns the double value associated with @key, or 0.
func (settings printSettings) Double(key string) float64 {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_print_settings_get_double(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// DoubleWithDefault returns the floating point number represented by the
// value that is associated with @key, or @default_val if the value does not
// represent a floating point number.
//
// Floating point numbers are parsed with g_ascii_strtod().
func (settings printSettings) DoubleWithDefault(key string, def float64) float64 {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar
	var arg2 C.gdouble

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gdouble(def)

	ret := C.gtk_print_settings_get_double_with_default(arg0, arg1, arg2)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// Duplex gets the value of GTK_PRINT_SETTINGS_DUPLEX.
func (settings printSettings) Duplex() PrintDuplex {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_duplex(arg0)

	var ret0 PrintDuplex

	ret0 = PrintDuplex(ret)

	return ret0
}

// Finishings gets the value of GTK_PRINT_SETTINGS_FINISHINGS.
func (settings printSettings) Finishings() string {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_finishings(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Int returns the integer value of @key, or 0.
func (settings printSettings) Int(key string) int {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_print_settings_get_int(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// IntWithDefault returns the value of @key, interpreted as an integer, or
// the default value.
func (settings printSettings) IntWithDefault(key string, def int) int {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar
	var arg2 C.gint

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(def)

	ret := C.gtk_print_settings_get_int_with_default(arg0, arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Length returns the value associated with @key, interpreted as a length.
// The returned value is converted to @units.
func (settings printSettings) Length(key string, unit Unit) float64 {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar
	var arg2 C.GtkUnit

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GtkUnit)(unit)

	ret := C.gtk_print_settings_get_length(arg0, arg1, arg2)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// MediaType gets the value of GTK_PRINT_SETTINGS_MEDIA_TYPE.
//
// The set of media types is defined in PWG 5101.1-2002 PWG.
func (settings printSettings) MediaType() string {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_media_type(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// NCopies gets the value of GTK_PRINT_SETTINGS_N_COPIES.
func (settings printSettings) NCopies() int {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_n_copies(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// NumberUp gets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
func (settings printSettings) NumberUp() int {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_number_up(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// NumberUpLayout gets the value of GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT.
func (settings printSettings) NumberUpLayout() NumberUpLayout {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_number_up_layout(arg0)

	var ret0 NumberUpLayout

	ret0 = NumberUpLayout(ret)

	return ret0
}

// Orientation: get the value of GTK_PRINT_SETTINGS_ORIENTATION, converted
// to a PageOrientation.
func (settings printSettings) Orientation() PageOrientation {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_orientation(arg0)

	var ret0 PageOrientation

	ret0 = PageOrientation(ret)

	return ret0
}

// OutputBin gets the value of GTK_PRINT_SETTINGS_OUTPUT_BIN.
func (settings printSettings) OutputBin() string {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_output_bin(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// PageRanges gets the value of GTK_PRINT_SETTINGS_PAGE_RANGES.
func (settings printSettings) PageRanges() (numRanges int, pageRanges []PageRange) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gint // out

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_page_ranges(arg0, &arg1)

	var ret0 int
	var ret1 []PageRange

	ret0 = int(arg1)

	{
		ret1 = make([]PageRange, arg1)
		for i := 0; i < uintptr(arg1); i++ {
			src := (C.GtkPageRange)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			{
				ret1[i] = WrapPageRange(unsafe.Pointer(src))
				runtime.SetFinalizer(&ret1[i], func(v *PageRange) {
					C.free(unsafe.Pointer(v.Native()))
				})
			}
		}
	}

	return ret0, ret1
}

// PageSet gets the value of GTK_PRINT_SETTINGS_PAGE_SET.
func (settings printSettings) PageSet() PageSet {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_page_set(arg0)

	var ret0 PageSet

	ret0 = PageSet(ret)

	return ret0
}

// PaperHeight gets the value of GTK_PRINT_SETTINGS_PAPER_HEIGHT, converted
// to @unit.
func (settings printSettings) PaperHeight(unit Unit) float64 {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (C.GtkUnit)(unit)

	ret := C.gtk_print_settings_get_paper_height(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// PaperSize gets the value of GTK_PRINT_SETTINGS_PAPER_FORMAT, converted to
// a PaperSize.
func (settings printSettings) PaperSize() *PaperSize {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_paper_size(arg0)

	var ret0 *PaperSize

	{
		ret0 = WrapPaperSize(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *PaperSize) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// PaperWidth gets the value of GTK_PRINT_SETTINGS_PAPER_WIDTH, converted to
// @unit.
func (settings printSettings) PaperWidth(unit Unit) float64 {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (C.GtkUnit)(unit)

	ret := C.gtk_print_settings_get_paper_width(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// PrintPages gets the value of GTK_PRINT_SETTINGS_PRINT_PAGES.
func (settings printSettings) PrintPages() PrintPages {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_print_pages(arg0)

	var ret0 PrintPages

	ret0 = PrintPages(ret)

	return ret0
}

// Printer: convenience function to obtain the value of
// GTK_PRINT_SETTINGS_PRINTER.
func (settings printSettings) Printer() string {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_printer(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// PrinterLpi gets the value of GTK_PRINT_SETTINGS_PRINTER_LPI.
func (settings printSettings) PrinterLpi() float64 {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_printer_lpi(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// Quality gets the value of GTK_PRINT_SETTINGS_QUALITY.
func (settings printSettings) Quality() PrintQuality {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_quality(arg0)

	var ret0 PrintQuality

	ret0 = PrintQuality(ret)

	return ret0
}

// Resolution gets the value of GTK_PRINT_SETTINGS_RESOLUTION.
func (settings printSettings) Resolution() int {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_resolution(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ResolutionX gets the value of GTK_PRINT_SETTINGS_RESOLUTION_X.
func (settings printSettings) ResolutionX() int {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_resolution_x(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ResolutionY gets the value of GTK_PRINT_SETTINGS_RESOLUTION_Y.
func (settings printSettings) ResolutionY() int {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_resolution_y(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Reverse gets the value of GTK_PRINT_SETTINGS_REVERSE.
func (settings printSettings) Reverse() bool {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_reverse(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Scale gets the value of GTK_PRINT_SETTINGS_SCALE.
func (settings printSettings) Scale() float64 {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_scale(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// UseColor gets the value of GTK_PRINT_SETTINGS_USE_COLOR.
func (settings printSettings) UseColor() bool {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_use_color(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// HasKey returns true, if a value is associated with @key.
func (settings printSettings) HasKey(key string) bool {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_print_settings_has_key(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// LoadFile reads the print settings from @file_name. If the file could not
// be loaded then error is set to either a Error or FileError. See
// gtk_print_settings_to_file().
func (settings printSettings) LoadFile(fileName string) error {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_print_settings_load_file(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// LoadKeyFile reads the print settings from the group @group_name in
// @key_file. If the file could not be loaded then error is set to either a
// Error or FileError.
func (settings printSettings) LoadKeyFile(keyFile *glib.KeyFile, groupName string) error {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.GKeyFile
	var arg2 *C.gchar
	var gError *C.GError

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.GKeyFile)(keyFile.Native())
	arg2 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_print_settings_load_key_file(arg0, arg1, arg2, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// Set associates @value with @key.
func (settings printSettings) Set(key string, value string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_print_settings_set(arg0, arg1, arg2)
}

// SetBool sets @key to a boolean value.
func (settings printSettings) SetBool(key string, value bool) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar
	var arg2 C.gboolean

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	if value {
		arg2 = C.TRUE
	}

	C.gtk_print_settings_set_bool(arg0, arg1, arg2)
}

// SetCollate sets the value of GTK_PRINT_SETTINGS_COLLATE.
func (settings printSettings) SetCollate(collate bool) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gboolean

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	if collate {
		arg1 = C.TRUE
	}

	C.gtk_print_settings_set_collate(arg0, arg1)
}

// SetDefaultSource sets the value of GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
func (settings printSettings) SetDefaultSource(defaultSource string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(defaultSource))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_set_default_source(arg0, arg1)
}

// SetDither sets the value of GTK_PRINT_SETTINGS_DITHER.
func (settings printSettings) SetDither(dither string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(dither))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_set_dither(arg0, arg1)
}

// SetDouble sets @key to a double value.
func (settings printSettings) SetDouble(key string, value float64) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar
	var arg2 C.gdouble

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gdouble(value)

	C.gtk_print_settings_set_double(arg0, arg1, arg2)
}

// SetDuplex sets the value of GTK_PRINT_SETTINGS_DUPLEX.
func (settings printSettings) SetDuplex(duplex PrintDuplex) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkPrintDuplex

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (C.GtkPrintDuplex)(duplex)

	C.gtk_print_settings_set_duplex(arg0, arg1)
}

// SetFinishings sets the value of GTK_PRINT_SETTINGS_FINISHINGS.
func (settings printSettings) SetFinishings(finishings string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(finishings))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_set_finishings(arg0, arg1)
}

// SetInt sets @key to an integer value.
func (settings printSettings) SetInt(key string, value int) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar
	var arg2 C.gint

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(value)

	C.gtk_print_settings_set_int(arg0, arg1, arg2)
}

// SetLength associates a length in units of @unit with @key.
func (settings printSettings) SetLength(key string, value float64, unit Unit) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar
	var arg2 C.gdouble
	var arg3 C.GtkUnit

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gdouble(value)
	arg3 = (C.GtkUnit)(unit)

	C.gtk_print_settings_set_length(arg0, arg1, arg2, arg3)
}

// SetMediaType sets the value of GTK_PRINT_SETTINGS_MEDIA_TYPE.
//
// The set of media types is defined in PWG 5101.1-2002 PWG.
func (settings printSettings) SetMediaType(mediaType string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(mediaType))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_set_media_type(arg0, arg1)
}

// SetNCopies sets the value of GTK_PRINT_SETTINGS_N_COPIES.
func (settings printSettings) SetNCopies(numCopies int) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gint

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = C.gint(numCopies)

	C.gtk_print_settings_set_n_copies(arg0, arg1)
}

// SetNumberUp sets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
func (settings printSettings) SetNumberUp(numberUp int) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gint

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = C.gint(numberUp)

	C.gtk_print_settings_set_number_up(arg0, arg1)
}

// SetNumberUpLayout sets the value of GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT.
func (settings printSettings) SetNumberUpLayout(numberUpLayout NumberUpLayout) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkNumberUpLayout

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (C.GtkNumberUpLayout)(numberUpLayout)

	C.gtk_print_settings_set_number_up_layout(arg0, arg1)
}

// SetOrientation sets the value of GTK_PRINT_SETTINGS_ORIENTATION.
func (settings printSettings) SetOrientation(orientation PageOrientation) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkPageOrientation

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (C.GtkPageOrientation)(orientation)

	C.gtk_print_settings_set_orientation(arg0, arg1)
}

// SetOutputBin sets the value of GTK_PRINT_SETTINGS_OUTPUT_BIN.
func (settings printSettings) SetOutputBin(outputBin string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(outputBin))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_set_output_bin(arg0, arg1)
}

// SetPageRanges sets the value of GTK_PRINT_SETTINGS_PAGE_RANGES.
func (settings printSettings) SetPageRanges(pageRanges []PageRange) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.GtkPageRange
	var arg2 C.gint

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.GtkPageRange)(unsafe.Pointer(&pageRanges[0]))
	arg2 = len(pageRanges)
	defer runtime.KeepAlive(pageRanges)

	C.gtk_print_settings_set_page_ranges(arg0, arg1, arg2)
}

// SetPageSet sets the value of GTK_PRINT_SETTINGS_PAGE_SET.
func (settings printSettings) SetPageSet(pageSet PageSet) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkPageSet

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (C.GtkPageSet)(pageSet)

	C.gtk_print_settings_set_page_set(arg0, arg1)
}

// SetPaperHeight sets the value of GTK_PRINT_SETTINGS_PAPER_HEIGHT.
func (settings printSettings) SetPaperHeight(height float64, unit Unit) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gdouble
	var arg2 C.GtkUnit

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = C.gdouble(height)
	arg2 = (C.GtkUnit)(unit)

	C.gtk_print_settings_set_paper_height(arg0, arg1, arg2)
}

// SetPaperSize sets the value of GTK_PRINT_SETTINGS_PAPER_FORMAT,
// GTK_PRINT_SETTINGS_PAPER_WIDTH and GTK_PRINT_SETTINGS_PAPER_HEIGHT.
func (settings printSettings) SetPaperSize(paperSize *PaperSize) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.GtkPaperSize

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.GtkPaperSize)(paperSize.Native())

	C.gtk_print_settings_set_paper_size(arg0, arg1)
}

// SetPaperWidth sets the value of GTK_PRINT_SETTINGS_PAPER_WIDTH.
func (settings printSettings) SetPaperWidth(width float64, unit Unit) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gdouble
	var arg2 C.GtkUnit

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = C.gdouble(width)
	arg2 = (C.GtkUnit)(unit)

	C.gtk_print_settings_set_paper_width(arg0, arg1, arg2)
}

// SetPrintPages sets the value of GTK_PRINT_SETTINGS_PRINT_PAGES.
func (settings printSettings) SetPrintPages(pages PrintPages) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkPrintPages

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (C.GtkPrintPages)(pages)

	C.gtk_print_settings_set_print_pages(arg0, arg1)
}

// SetPrinter: convenience function to set GTK_PRINT_SETTINGS_PRINTER to
// @printer.
func (settings printSettings) SetPrinter(printer string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(printer))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_set_printer(arg0, arg1)
}

// SetPrinterLpi sets the value of GTK_PRINT_SETTINGS_PRINTER_LPI.
func (settings printSettings) SetPrinterLpi(lpi float64) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gdouble

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = C.gdouble(lpi)

	C.gtk_print_settings_set_printer_lpi(arg0, arg1)
}

// SetQuality sets the value of GTK_PRINT_SETTINGS_QUALITY.
func (settings printSettings) SetQuality(quality PrintQuality) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkPrintQuality

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (C.GtkPrintQuality)(quality)

	C.gtk_print_settings_set_quality(arg0, arg1)
}

// SetResolution sets the values of GTK_PRINT_SETTINGS_RESOLUTION,
// GTK_PRINT_SETTINGS_RESOLUTION_X and GTK_PRINT_SETTINGS_RESOLUTION_Y.
func (settings printSettings) SetResolution(resolution int) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gint

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = C.gint(resolution)

	C.gtk_print_settings_set_resolution(arg0, arg1)
}

// SetResolutionXY sets the values of GTK_PRINT_SETTINGS_RESOLUTION,
// GTK_PRINT_SETTINGS_RESOLUTION_X and GTK_PRINT_SETTINGS_RESOLUTION_Y.
func (settings printSettings) SetResolutionXY(resolutionX int, resolutionY int) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gint
	var arg2 C.gint

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = C.gint(resolutionX)
	arg2 = C.gint(resolutionY)

	C.gtk_print_settings_set_resolution_xy(arg0, arg1, arg2)
}

// SetReverse sets the value of GTK_PRINT_SETTINGS_REVERSE.
func (settings printSettings) SetReverse(reverse bool) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gboolean

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	if reverse {
		arg1 = C.TRUE
	}

	C.gtk_print_settings_set_reverse(arg0, arg1)
}

// SetScale sets the value of GTK_PRINT_SETTINGS_SCALE.
func (settings printSettings) SetScale(scale float64) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gdouble

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = C.gdouble(scale)

	C.gtk_print_settings_set_scale(arg0, arg1)
}

// SetUseColor sets the value of GTK_PRINT_SETTINGS_USE_COLOR.
func (settings printSettings) SetUseColor(useColor bool) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gboolean

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	if useColor {
		arg1 = C.TRUE
	}

	C.gtk_print_settings_set_use_color(arg0, arg1)
}

// ToFile: this function saves the print settings from @settings to
// @file_name. If the file could not be loaded then error is set to either a
// Error or FileError.
func (settings printSettings) ToFile(fileName string) error {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_print_settings_to_file(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// ToGVariant: serialize print settings to an a{sv} variant.
func (settings printSettings) ToGVariant() *glib.Variant {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_to_gvariant(arg0)

	var ret0 *glib.Variant

	{
		ret0 = glib.WrapVariant(unsafe.Pointer(ret))
	}

	return ret0
}

// ToKeyFile: this function adds the print settings from @settings to
// @key_file.
func (settings printSettings) ToKeyFile(keyFile *glib.KeyFile, groupName string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.GKeyFile
	var arg2 *C.gchar

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.GKeyFile)(keyFile.Native())
	arg2 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_print_settings_to_key_file(arg0, arg1, arg2)
}

// Unset removes any value associated with @key. This has the same effect as
// setting the value to nil.
func (settings printSettings) Unset(key string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_unset(arg0, arg1)
}

// RadioAction: a RadioAction is similar to RadioMenuItem. A number of radio
// actions can be linked together so that only one may be active at any one
// time.
type RadioAction interface {
	ToggleAction
	Buildable

	// CurrentValue obtains the value property of the currently active member of
	// the group to which @action belongs.
	CurrentValue() int
	// Group returns the list representing the radio group for this object. Note
	// that the returned list is only valid until the next change to the group.
	//
	// A common way to set up a group of radio group is the following:
	//
	//     GSList *group = NULL;
	//     GtkRadioAction *action;
	//
	//     while ( ...more actions to add... /)
	//       {
	//          action = gtk_radio_action_new (...);
	//
	//          gtk_radio_action_set_group (action, group);
	//          group = gtk_radio_action_get_group (action);
	//       }
	Group() *glib.SList
	// JoinGroup joins a radio action object to the group of another radio
	// action object.
	//
	// Use this in language bindings instead of the gtk_radio_action_get_group()
	// and gtk_radio_action_set_group() methods
	//
	// A common way to set up a group of radio actions is the following:
	//
	//     GtkRadioAction *action;
	//     GtkRadioAction *last_action;
	//
	//     while ( ...more actions to add... /)
	//       {
	//          action = gtk_radio_action_new (...);
	//
	//          gtk_radio_action_join_group (action, last_action);
	//          last_action = action;
	//       }
	JoinGroup(groupSource RadioAction)
	// SetCurrentValue sets the currently active group member to the member with
	// value property @current_value.
	SetCurrentValue(currentValue int)
	// SetGroup sets the radio group for the radio action object.
	SetGroup(group *glib.SList)
}

// radioAction implements the RadioAction interface.
type radioAction struct {
	ToggleAction
	Buildable
}

var _ RadioAction = (*radioAction)(nil)

// WrapRadioAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapRadioAction(obj *externglib.Object) RadioAction {
	return RadioAction{
		ToggleAction: WrapToggleAction(obj),
		Buildable:    WrapBuildable(obj),
	}
}

func marshalRadioAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRadioAction(obj), nil
}

// NewRadioAction constructs a class RadioAction.
func NewRadioAction(name string, label string, tooltip string, stockID string, value int) RadioAction {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 *C.gchar
	var arg5 C.gint

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(tooltip))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gchar)(C.CString(stockID))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = C.gint(value)

	ret := C.gtk_radio_action_new(arg1, arg2, arg3, arg4, arg5)

	var ret0 RadioAction

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(RadioAction)

	return ret0
}

// CurrentValue obtains the value property of the currently active member of
// the group to which @action belongs.
func (action radioAction) CurrentValue() int {
	var arg0 *C.GtkRadioAction

	arg0 = (*C.GtkRadioAction)(action.Native())

	ret := C.gtk_radio_action_get_current_value(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Group returns the list representing the radio group for this object. Note
// that the returned list is only valid until the next change to the group.
//
// A common way to set up a group of radio group is the following:
//
//     GSList *group = NULL;
//     GtkRadioAction *action;
//
//     while ( ...more actions to add... /)
//       {
//          action = gtk_radio_action_new (...);
//
//          gtk_radio_action_set_group (action, group);
//          group = gtk_radio_action_get_group (action);
//       }
func (action radioAction) Group() *glib.SList {
	var arg0 *C.GtkRadioAction

	arg0 = (*C.GtkRadioAction)(action.Native())

	ret := C.gtk_radio_action_get_group(arg0)

	var ret0 *glib.SList

	{
		ret0 = glib.WrapSList(unsafe.Pointer(ret))
	}

	return ret0
}

// JoinGroup joins a radio action object to the group of another radio
// action object.
//
// Use this in language bindings instead of the gtk_radio_action_get_group()
// and gtk_radio_action_set_group() methods
//
// A common way to set up a group of radio actions is the following:
//
//     GtkRadioAction *action;
//     GtkRadioAction *last_action;
//
//     while ( ...more actions to add... /)
//       {
//          action = gtk_radio_action_new (...);
//
//          gtk_radio_action_join_group (action, last_action);
//          last_action = action;
//       }
func (action radioAction) JoinGroup(groupSource RadioAction) {
	var arg0 *C.GtkRadioAction
	var arg1 *C.GtkRadioAction

	arg0 = (*C.GtkRadioAction)(action.Native())
	arg1 = (*C.GtkRadioAction)(groupSource.Native())

	C.gtk_radio_action_join_group(arg0, arg1)
}

// SetCurrentValue sets the currently active group member to the member with
// value property @current_value.
func (action radioAction) SetCurrentValue(currentValue int) {
	var arg0 *C.GtkRadioAction
	var arg1 C.gint

	arg0 = (*C.GtkRadioAction)(action.Native())
	arg1 = C.gint(currentValue)

	C.gtk_radio_action_set_current_value(arg0, arg1)
}

// SetGroup sets the radio group for the radio action object.
func (action radioAction) SetGroup(group *glib.SList) {
	var arg0 *C.GtkRadioAction
	var arg1 *C.GSList

	arg0 = (*C.GtkRadioAction)(action.Native())
	arg1 = (*C.GSList)(group.Native())

	C.gtk_radio_action_set_group(arg0, arg1)
}

// RCStyle: the RcStyle-struct is used to represent a set of information about
// the appearance of a widget. This can later be composited together with other
// RcStyle-struct<!-- -->s to form a Style.
type RCStyle interface {
	gextras.Objector

	// Copy makes a copy of the specified RcStyle. This function will correctly
	// copy an RC style that is a member of a class derived from RcStyle.
	Copy() RCStyle
}

// rcStyle implements the RCStyle interface.
type rcStyle struct {
	gextras.Objector
}

var _ RCStyle = (*rcStyle)(nil)

// WrapRCStyle wraps a GObject to the right type. It is
// primarily used internally.
func WrapRCStyle(obj *externglib.Object) RCStyle {
	return RCStyle{
		Objector: obj,
	}
}

func marshalRCStyle(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRCStyle(obj), nil
}

// NewRCStyle constructs a class RCStyle.
func NewRCStyle() RCStyle {

	ret := C.gtk_rc_style_new()

	var ret0 RCStyle

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(RCStyle)

	return ret0
}

// Copy makes a copy of the specified RcStyle. This function will correctly
// copy an RC style that is a member of a class derived from RcStyle.
func (orig rcStyle) Copy() RCStyle {
	var arg0 *C.GtkRcStyle

	arg0 = (*C.GtkRcStyle)(orig.Native())

	ret := C.gtk_rc_style_copy(arg0)

	var ret0 RCStyle

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(RCStyle)

	return ret0
}

// RecentAction: a RecentAction represents a list of recently used files, which
// can be shown by widgets such as RecentChooserDialog or RecentChooserMenu.
//
// To construct a submenu showing recently used files, use a RecentAction as the
// action for a <menuitem>. To construct a menu toolbutton showing the recently
// used files in the popup menu, use a RecentAction as the action for a
// <toolitem> element.
type RecentAction interface {
	Action
	Buildable
	RecentChooser

	// ShowNumbers returns the value set by
	// gtk_recent_chooser_menu_set_show_numbers().
	ShowNumbers() bool
	// SetShowNumbers sets whether a number should be added to the items shown
	// by the widgets representing @action. The numbers are shown to provide a
	// unique character for a mnemonic to be used inside the menu item's label.
	// Only the first ten items get a number to avoid clashes.
	SetShowNumbers(showNumbers bool)
}

// recentAction implements the RecentAction interface.
type recentAction struct {
	Action
	Buildable
	RecentChooser
}

var _ RecentAction = (*recentAction)(nil)

// WrapRecentAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapRecentAction(obj *externglib.Object) RecentAction {
	return RecentAction{
		Action:        WrapAction(obj),
		Buildable:     WrapBuildable(obj),
		RecentChooser: WrapRecentChooser(obj),
	}
}

func marshalRecentAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRecentAction(obj), nil
}

// NewRecentAction constructs a class RecentAction.
func NewRecentAction(name string, label string, tooltip string, stockID string) RecentAction {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 *C.gchar

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(tooltip))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gchar)(C.CString(stockID))
	defer C.free(unsafe.Pointer(arg4))

	ret := C.gtk_recent_action_new(arg1, arg2, arg3, arg4)

	var ret0 RecentAction

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(RecentAction)

	return ret0
}

// NewRecentActionForManager constructs a class RecentAction.
func NewRecentActionForManager(name string, label string, tooltip string, stockID string, manager RecentManager) RecentAction {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 *C.gchar
	var arg5 *C.GtkRecentManager

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(tooltip))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gchar)(C.CString(stockID))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.GtkRecentManager)(manager.Native())

	ret := C.gtk_recent_action_new_for_manager(arg1, arg2, arg3, arg4, arg5)

	var ret0 RecentAction

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(RecentAction)

	return ret0
}

// ShowNumbers returns the value set by
// gtk_recent_chooser_menu_set_show_numbers().
func (action recentAction) ShowNumbers() bool {
	var arg0 *C.GtkRecentAction

	arg0 = (*C.GtkRecentAction)(action.Native())

	ret := C.gtk_recent_action_get_show_numbers(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SetShowNumbers sets whether a number should be added to the items shown
// by the widgets representing @action. The numbers are shown to provide a
// unique character for a mnemonic to be used inside the menu item's label.
// Only the first ten items get a number to avoid clashes.
func (action recentAction) SetShowNumbers(showNumbers bool) {
	var arg0 *C.GtkRecentAction
	var arg1 C.gboolean

	arg0 = (*C.GtkRecentAction)(action.Native())
	if showNumbers {
		arg1 = C.TRUE
	}

	C.gtk_recent_action_set_show_numbers(arg0, arg1)
}

// RecentFilter: a RecentFilter can be used to restrict the files being shown in
// a RecentChooser. Files can be filtered based on their name (with
// gtk_recent_filter_add_pattern()), on their mime type (with
// gtk_file_filter_add_mime_type()), on the application that has registered them
// (with gtk_recent_filter_add_application()), or by a custom filter function
// (with gtk_recent_filter_add_custom()).
//
// Filtering by mime type handles aliasing and subclassing of mime types; e.g. a
// filter for text/plain also matches a file with mime type application/rtf,
// since application/rtf is a subclass of text/plain. Note that RecentFilter
// allows wildcards for the subtype of a mime type, so you can e.g. filter for
// image/\*.
//
// Normally, filters are used by adding them to a RecentChooser, see
// gtk_recent_chooser_add_filter(), but it is also possible to manually use a
// filter on a file with gtk_recent_filter_filter().
//
// Recently used files are supported since GTK+ 2.10.
//
//
// GtkRecentFilter as GtkBuildable
//
// The GtkRecentFilter implementation of the GtkBuildable interface supports
// adding rules using the <mime-types>, <patterns> and <applications> elements
// and listing the rules within. Specifying a <mime-type>, <pattern> or
// <application> has the same effect as calling
// gtk_recent_filter_add_mime_type(), gtk_recent_filter_add_pattern() or
// gtk_recent_filter_add_application().
//
// An example of a UI definition fragment specifying GtkRecentFilter rules:
//
//    <object class="GtkRecentFilter">
//      <mime-types>
//        <mime-type>text/plain</mime-type>
//        <mime-type>image/png</mime-type>
//      </mime-types>
//      <patterns>
//        <pattern>*.txt</pattern>
//        <pattern>*.png</pattern>
//      </patterns>
//      <applications>
//        <application>gimp</application>
//        <application>gedit</application>
//        <application>glade</application>
//      </applications>
//    </object>
type RecentFilter interface {
	gextras.Objector
	Buildable

	// AddAge adds a rule that allows resources based on their age - that is,
	// the number of days elapsed since they were last modified.
	AddAge(days int)
	// AddApplication adds a rule that allows resources based on the name of the
	// application that has registered them.
	AddApplication(application string)
	// AddCustom adds a rule to a filter that allows resources based on a custom
	// callback function. The bitfield @needed which is passed in provides
	// information about what sorts of information that the filter function
	// needs; this allows GTK+ to avoid retrieving expensive information when it
	// isn’t needed by the filter.
	AddCustom(needed RecentFilterFlags, fn RecentFilterFunc)
	// AddGroup adds a rule that allows resources based on the name of the group
	// to which they belong
	AddGroup(group string)
	// AddMIMEType adds a rule that allows resources based on their registered
	// MIME type.
	AddMIMEType(mimeType string)
	// AddPattern adds a rule that allows resources based on a pattern matching
	// their display name.
	AddPattern(pattern string)
	// AddPixbufFormats adds a rule allowing image files in the formats
	// supported by GdkPixbuf.
	AddPixbufFormats()
	// Filter tests whether a file should be displayed according to @filter. The
	// RecentFilterInfo @filter_info should include the fields returned from
	// gtk_recent_filter_get_needed(), and must set the
	// RecentFilterInfo.contains field of @filter_info to indicate which fields
	// have been set.
	//
	// This function will not typically be used by applications; it is intended
	// principally for use in the implementation of RecentChooser.
	Filter(filterInfo *RecentFilterInfo) bool
	// Name gets the human-readable name for the filter. See
	// gtk_recent_filter_set_name().
	Name() string
	// Needed gets the fields that need to be filled in for the RecentFilterInfo
	// passed to gtk_recent_filter_filter()
	//
	// This function will not typically be used by applications; it is intended
	// principally for use in the implementation of RecentChooser.
	Needed() RecentFilterFlags
	// SetName sets the human-readable name of the filter; this is the string
	// that will be displayed in the recently used resources selector user
	// interface if there is a selectable list of filters.
	SetName(name string)
}

// recentFilter implements the RecentFilter interface.
type recentFilter struct {
	gextras.Objector
	Buildable
}

var _ RecentFilter = (*recentFilter)(nil)

// WrapRecentFilter wraps a GObject to the right type. It is
// primarily used internally.
func WrapRecentFilter(obj *externglib.Object) RecentFilter {
	return RecentFilter{
		Objector:  obj,
		Buildable: WrapBuildable(obj),
	}
}

func marshalRecentFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRecentFilter(obj), nil
}

// NewRecentFilter constructs a class RecentFilter.
func NewRecentFilter() RecentFilter {

	ret := C.gtk_recent_filter_new()

	var ret0 RecentFilter

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(RecentFilter)

	return ret0
}

// AddAge adds a rule that allows resources based on their age - that is,
// the number of days elapsed since they were last modified.
func (filter recentFilter) AddAge(days int) {
	var arg0 *C.GtkRecentFilter
	var arg1 C.gint

	arg0 = (*C.GtkRecentFilter)(filter.Native())
	arg1 = C.gint(days)

	C.gtk_recent_filter_add_age(arg0, arg1)
}

// AddApplication adds a rule that allows resources based on the name of the
// application that has registered them.
func (filter recentFilter) AddApplication(application string) {
	var arg0 *C.GtkRecentFilter
	var arg1 *C.gchar

	arg0 = (*C.GtkRecentFilter)(filter.Native())
	arg1 = (*C.gchar)(C.CString(application))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_recent_filter_add_application(arg0, arg1)
}

// AddCustom adds a rule to a filter that allows resources based on a custom
// callback function. The bitfield @needed which is passed in provides
// information about what sorts of information that the filter function
// needs; this allows GTK+ to avoid retrieving expensive information when it
// isn’t needed by the filter.
func (filter recentFilter) AddCustom(needed RecentFilterFlags, fn RecentFilterFunc) {
	var arg0 *C.GtkRecentFilter
	var arg1 C.GtkRecentFilterFlags
	var arg2 C.GtkRecentFilterFunc
	var arg3 C.gpointer
	var arg4 C.GDestroyNotify

	arg0 = (*C.GtkRecentFilter)(filter.Native())
	arg1 = (C.GtkRecentFilterFlags)(needed)
	arg2 = (*[0]byte)(C.gotk4_RecentFilterFunc)
	arg3 = C.gpointer(box.Assign(fn))
	arg4 = (*[0]byte)(C.callbackDelete)

	C.gtk_recent_filter_add_custom(arg0, arg1, arg2, arg3, arg4)
}

// AddGroup adds a rule that allows resources based on the name of the group
// to which they belong
func (filter recentFilter) AddGroup(group string) {
	var arg0 *C.GtkRecentFilter
	var arg1 *C.gchar

	arg0 = (*C.GtkRecentFilter)(filter.Native())
	arg1 = (*C.gchar)(C.CString(group))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_recent_filter_add_group(arg0, arg1)
}

// AddMIMEType adds a rule that allows resources based on their registered
// MIME type.
func (filter recentFilter) AddMIMEType(mimeType string) {
	var arg0 *C.GtkRecentFilter
	var arg1 *C.gchar

	arg0 = (*C.GtkRecentFilter)(filter.Native())
	arg1 = (*C.gchar)(C.CString(mimeType))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_recent_filter_add_mime_type(arg0, arg1)
}

// AddPattern adds a rule that allows resources based on a pattern matching
// their display name.
func (filter recentFilter) AddPattern(pattern string) {
	var arg0 *C.GtkRecentFilter
	var arg1 *C.gchar

	arg0 = (*C.GtkRecentFilter)(filter.Native())
	arg1 = (*C.gchar)(C.CString(pattern))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_recent_filter_add_pattern(arg0, arg1)
}

// AddPixbufFormats adds a rule allowing image files in the formats
// supported by GdkPixbuf.
func (filter recentFilter) AddPixbufFormats() {
	var arg0 *C.GtkRecentFilter

	arg0 = (*C.GtkRecentFilter)(filter.Native())

	C.gtk_recent_filter_add_pixbuf_formats(arg0)
}

// Filter tests whether a file should be displayed according to @filter. The
// RecentFilterInfo @filter_info should include the fields returned from
// gtk_recent_filter_get_needed(), and must set the
// RecentFilterInfo.contains field of @filter_info to indicate which fields
// have been set.
//
// This function will not typically be used by applications; it is intended
// principally for use in the implementation of RecentChooser.
func (filter recentFilter) Filter(filterInfo *RecentFilterInfo) bool {
	var arg0 *C.GtkRecentFilter
	var arg1 *C.GtkRecentFilterInfo

	arg0 = (*C.GtkRecentFilter)(filter.Native())
	arg1 = (*C.GtkRecentFilterInfo)(filterInfo.Native())

	ret := C.gtk_recent_filter_filter(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Name gets the human-readable name for the filter. See
// gtk_recent_filter_set_name().
func (filter recentFilter) Name() string {
	var arg0 *C.GtkRecentFilter

	arg0 = (*C.GtkRecentFilter)(filter.Native())

	ret := C.gtk_recent_filter_get_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Needed gets the fields that need to be filled in for the RecentFilterInfo
// passed to gtk_recent_filter_filter()
//
// This function will not typically be used by applications; it is intended
// principally for use in the implementation of RecentChooser.
func (filter recentFilter) Needed() RecentFilterFlags {
	var arg0 *C.GtkRecentFilter

	arg0 = (*C.GtkRecentFilter)(filter.Native())

	ret := C.gtk_recent_filter_get_needed(arg0)

	var ret0 RecentFilterFlags

	ret0 = RecentFilterFlags(ret)

	return ret0
}

// SetName sets the human-readable name of the filter; this is the string
// that will be displayed in the recently used resources selector user
// interface if there is a selectable list of filters.
func (filter recentFilter) SetName(name string) {
	var arg0 *C.GtkRecentFilter
	var arg1 *C.gchar

	arg0 = (*C.GtkRecentFilter)(filter.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_recent_filter_set_name(arg0, arg1)
}

// RecentManager provides a facility for adding, removing and looking up
// recently used files. Each recently used file is identified by its URI, and
// has meta-data associated to it, like the names and command lines of the
// applications that have registered it, the number of time each application has
// registered the same file, the mime type of the file and whether the file
// should be displayed only by the applications that have registered it.
//
// The recently used files list is per user.
//
// The RecentManager acts like a database of all the recently used files. You
// can create new RecentManager objects, but it is more efficient to use the
// default manager created by GTK+.
//
// Adding a new recently used file is as simple as:
//
//    GtkRecentManager *manager;
//    GtkRecentInfo *info;
//    GError *error = NULL;
//
//    manager = gtk_recent_manager_get_default ();
//    info = gtk_recent_manager_lookup_item (manager, file_uri, &error);
//    if (error)
//      {
//        g_warning ("Could not find the file: s", error->message);
//        g_error_free (error);
//      }
//    else
//     {
//       // Use the info object
//       gtk_recent_info_unref (info);
//     }
//
// In order to retrieve the list of recently used files, you can use
// gtk_recent_manager_get_items(), which returns a list of RecentInfo-structs.
//
// A RecentManager is the model used to populate the contents of one, or more
// RecentChooser implementations.
//
// Note that the maximum age of the recently used files list is controllable
// through the Settings:gtk-recent-files-max-age property.
//
// Recently used files are supported since GTK+ 2.10.
type RecentManager interface {
	gextras.Objector

	// AddFull adds a new resource, pointed by @uri, into the recently used
	// resources list, using the metadata specified inside the RecentData-struct
	// passed in @recent_data.
	//
	// The passed URI will be used to identify this resource inside the list.
	//
	// In order to register the new recently used resource, metadata about the
	// resource must be passed as well as the URI; the metadata is stored in a
	// RecentData-struct, which must contain the MIME type of the resource
	// pointed by the URI; the name of the application that is registering the
	// item, and a command line to be used when launching the item.
	//
	// Optionally, a RecentData-struct might contain a UTF-8 string to be used
	// when viewing the item instead of the last component of the URI; a short
	// description of the item; whether the item should be considered private -
	// that is, should be displayed only by the applications that have
	// registered it.
	AddFull(uri string, recentData *RecentData) bool
	// AddItem adds a new resource, pointed by @uri, into the recently used
	// resources list.
	//
	// This function automatically retrieves some of the needed metadata and
	// setting other metadata to common default values; it then feeds the data
	// to gtk_recent_manager_add_full().
	//
	// See gtk_recent_manager_add_full() if you want to explicitly define the
	// metadata for the resource pointed by @uri.
	AddItem(uri string) bool
	// Items gets the list of recently used resources.
	Items() *glib.List
	// HasItem checks whether there is a recently used resource registered with
	// @uri inside the recent manager.
	HasItem(uri string) bool
	// LookupItem searches for a URI inside the recently used resources list,
	// and returns a RecentInfo-struct containing informations about the
	// resource like its MIME type, or its display name.
	LookupItem(uri string) (recentInfo *RecentInfo, err error)
	// MoveItem changes the location of a recently used resource from @uri to
	// @new_uri.
	//
	// Please note that this function will not affect the resource pointed by
	// the URIs, but only the URI used in the recently used resources list.
	MoveItem(uri string, newURI string) error
	// PurgeItems purges every item from the recently used resources list.
	PurgeItems() (gint int, err error)
	// RemoveItem removes a resource pointed by @uri from the recently used
	// resources list handled by a recent manager.
	RemoveItem(uri string) error
}

// recentManager implements the RecentManager interface.
type recentManager struct {
	gextras.Objector
}

var _ RecentManager = (*recentManager)(nil)

// WrapRecentManager wraps a GObject to the right type. It is
// primarily used internally.
func WrapRecentManager(obj *externglib.Object) RecentManager {
	return RecentManager{
		Objector: obj,
	}
}

func marshalRecentManager(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRecentManager(obj), nil
}

// NewRecentManager constructs a class RecentManager.
func NewRecentManager() RecentManager {

	ret := C.gtk_recent_manager_new()

	var ret0 RecentManager

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(RecentManager)

	return ret0
}

// AddFull adds a new resource, pointed by @uri, into the recently used
// resources list, using the metadata specified inside the RecentData-struct
// passed in @recent_data.
//
// The passed URI will be used to identify this resource inside the list.
//
// In order to register the new recently used resource, metadata about the
// resource must be passed as well as the URI; the metadata is stored in a
// RecentData-struct, which must contain the MIME type of the resource
// pointed by the URI; the name of the application that is registering the
// item, and a command line to be used when launching the item.
//
// Optionally, a RecentData-struct might contain a UTF-8 string to be used
// when viewing the item instead of the last component of the URI; a short
// description of the item; whether the item should be considered private -
// that is, should be displayed only by the applications that have
// registered it.
func (manager recentManager) AddFull(uri string, recentData *RecentData) bool {
	var arg0 *C.GtkRecentManager
	var arg1 *C.gchar
	var arg2 *C.GtkRecentData

	arg0 = (*C.GtkRecentManager)(manager.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GtkRecentData)(recentData.Native())

	ret := C.gtk_recent_manager_add_full(arg0, arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// AddItem adds a new resource, pointed by @uri, into the recently used
// resources list.
//
// This function automatically retrieves some of the needed metadata and
// setting other metadata to common default values; it then feeds the data
// to gtk_recent_manager_add_full().
//
// See gtk_recent_manager_add_full() if you want to explicitly define the
// metadata for the resource pointed by @uri.
func (manager recentManager) AddItem(uri string) bool {
	var arg0 *C.GtkRecentManager
	var arg1 *C.gchar

	arg0 = (*C.GtkRecentManager)(manager.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_recent_manager_add_item(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Items gets the list of recently used resources.
func (manager recentManager) Items() *glib.List {
	var arg0 *C.GtkRecentManager

	arg0 = (*C.GtkRecentManager)(manager.Native())

	ret := C.gtk_recent_manager_get_items(arg0)

	var ret0 *glib.List

	{
		ret0 = glib.WrapList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.List) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// HasItem checks whether there is a recently used resource registered with
// @uri inside the recent manager.
func (manager recentManager) HasItem(uri string) bool {
	var arg0 *C.GtkRecentManager
	var arg1 *C.gchar

	arg0 = (*C.GtkRecentManager)(manager.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_recent_manager_has_item(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// LookupItem searches for a URI inside the recently used resources list,
// and returns a RecentInfo-struct containing informations about the
// resource like its MIME type, or its display name.
func (manager recentManager) LookupItem(uri string) (recentInfo *RecentInfo, err error) {
	var arg0 *C.GtkRecentManager
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GtkRecentManager)(manager.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_recent_manager_lookup_item(arg0, arg1, &gError)

	var ret0 *RecentInfo
	var goError error

	{
		ret0 = WrapRecentInfo(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *RecentInfo) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// MoveItem changes the location of a recently used resource from @uri to
// @new_uri.
//
// Please note that this function will not affect the resource pointed by
// the URIs, but only the URI used in the recently used resources list.
func (manager recentManager) MoveItem(uri string, newURI string) error {
	var arg0 *C.GtkRecentManager
	var arg1 *C.gchar
	var arg2 *C.gchar
	var gError *C.GError

	arg0 = (*C.GtkRecentManager)(manager.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(newURI))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_recent_manager_move_item(arg0, arg1, arg2, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// PurgeItems purges every item from the recently used resources list.
func (manager recentManager) PurgeItems() (gint int, err error) {
	var arg0 *C.GtkRecentManager
	var gError *C.GError

	arg0 = (*C.GtkRecentManager)(manager.Native())

	ret := C.gtk_recent_manager_purge_items(arg0, &gError)

	var ret0 int
	var goError error

	ret0 = int(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// RemoveItem removes a resource pointed by @uri from the recently used
// resources list handled by a recent manager.
func (manager recentManager) RemoveItem(uri string) error {
	var arg0 *C.GtkRecentManager
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GtkRecentManager)(manager.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_recent_manager_remove_item(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// Settings gtkSettings provide a mechanism to share global settings between
// applications.
//
// On the X window system, this sharing is realized by an XSettings
// (http://www.freedesktop.org/wiki/Specifications/xsettings-spec) manager that
// is usually part of the desktop environment, along with utilities that let the
// user change these settings. In the absence of an Xsettings manager, GTK+
// reads default values for settings from `settings.ini` files in
// `/etc/gtk-3.0`, `$XDG_CONFIG_DIRS/gtk-3.0` and `$XDG_CONFIG_HOME/gtk-3.0`.
// These files must be valid key files (see File), and have a section called
// Settings. Themes can also provide default values for settings by installing a
// `settings.ini` file next to their `gtk.css` file.
//
// Applications can override system-wide settings by setting the property of the
// GtkSettings object with g_object_set(). This should be restricted to special
// cases though; GtkSettings are not meant as an application configuration
// facility. When doing so, you need to be aware that settings that are specific
// to individual widgets may not be available before the widget type has been
// realized at least once. The following example demonstrates a way to do this:
//
//      gtk_init (&argc, &argv);
//
//      // make sure the type is realized
//      g_type_class_unref (g_type_class_ref (GTK_TYPE_IMAGE_MENU_ITEM));
//
//      g_object_set (gtk_settings_get_default (), "gtk-enable-animations", FALSE, NULL);
//
// There is one GtkSettings instance per screen. It can be obtained with
// gtk_settings_get_for_screen(), but in many cases, it is more convenient to
// use gtk_widget_get_settings(). gtk_settings_get_default() returns the
// GtkSettings instance for the default screen.
type Settings interface {
	gextras.Objector
	StyleProvider

	// ResetProperty undoes the effect of calling g_object_set() to install an
	// application-specific value for a setting. After this call, the setting
	// will again follow the session-wide value for this setting.
	ResetProperty(name string)

	SetDoubleProperty(name string, vDouble float64, origin string)

	SetLongProperty(name string, vLong int32, origin string)

	SetPropertyValue(name string, svalue *SettingsValue)

	SetStringProperty(name string, vString string, origin string)
}

// settings implements the Settings interface.
type settings struct {
	gextras.Objector
	StyleProvider
}

var _ Settings = (*settings)(nil)

// WrapSettings wraps a GObject to the right type. It is
// primarily used internally.
func WrapSettings(obj *externglib.Object) Settings {
	return Settings{
		Objector:      obj,
		StyleProvider: WrapStyleProvider(obj),
	}
}

func marshalSettings(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSettings(obj), nil
}

// ResetProperty undoes the effect of calling g_object_set() to install an
// application-specific value for a setting. After this call, the setting
// will again follow the session-wide value for this setting.
func (settings settings) ResetProperty(name string) {
	var arg0 *C.GtkSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_settings_reset_property(arg0, arg1)
}

func (settings settings) SetDoubleProperty(name string, vDouble float64, origin string) {
	var arg0 *C.GtkSettings
	var arg1 *C.gchar
	var arg2 C.gdouble
	var arg3 *C.gchar

	arg0 = (*C.GtkSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gdouble(vDouble)
	arg3 = (*C.gchar)(C.CString(origin))
	defer C.free(unsafe.Pointer(arg3))

	C.gtk_settings_set_double_property(arg0, arg1, arg2, arg3)
}

func (settings settings) SetLongProperty(name string, vLong int32, origin string) {
	var arg0 *C.GtkSettings
	var arg1 *C.gchar
	var arg2 C.glong
	var arg3 *C.gchar

	arg0 = (*C.GtkSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.glong(vLong)
	arg3 = (*C.gchar)(C.CString(origin))
	defer C.free(unsafe.Pointer(arg3))

	C.gtk_settings_set_long_property(arg0, arg1, arg2, arg3)
}

func (settings settings) SetPropertyValue(name string, svalue *SettingsValue) {
	var arg0 *C.GtkSettings
	var arg1 *C.gchar
	var arg2 *C.GtkSettingsValue

	arg0 = (*C.GtkSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GtkSettingsValue)(svalue.Native())

	C.gtk_settings_set_property_value(arg0, arg1, arg2)
}

func (settings settings) SetStringProperty(name string, vString string, origin string) {
	var arg0 *C.GtkSettings
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar

	arg0 = (*C.GtkSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(vString))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(origin))
	defer C.free(unsafe.Pointer(arg3))

	C.gtk_settings_set_string_property(arg0, arg1, arg2, arg3)
}

// SizeGroup provides a mechanism for grouping a number of widgets together so
// they all request the same amount of space. This is typically useful when you
// want a column of widgets to have the same size, but you can’t use a Grid
// widget.
//
// In detail, the size requested for each widget in a SizeGroup is the maximum
// of the sizes that would have been requested for each widget in the size group
// if they were not in the size group. The mode of the size group (see
// gtk_size_group_set_mode()) determines whether this applies to the horizontal
// size, the vertical size, or both sizes.
//
// Note that size groups only affect the amount of space requested, not the size
// that the widgets finally receive. If you want the widgets in a SizeGroup to
// actually be the same size, you need to pack them in such a way that they get
// the size they request and not more. For example, if you are packing your
// widgets into a table, you would not include the GTK_FILL flag.
//
// SizeGroup objects are referenced by each widget in the size group, so once
// you have added all widgets to a SizeGroup, you can drop the initial reference
// to the size group with g_object_unref(). If the widgets in the size group are
// subsequently destroyed, then they will be removed from the size group and
// drop their references on the size group; when all widgets have been removed,
// the size group will be freed.
//
// Widgets can be part of multiple size groups; GTK+ will compute the horizontal
// size of a widget from the horizontal requisition of all widgets that can be
// reached from the widget by a chain of size groups of type
// GTK_SIZE_GROUP_HORIZONTAL or GTK_SIZE_GROUP_BOTH, and the vertical size from
// the vertical requisition of all widgets that can be reached from the widget
// by a chain of size groups of type GTK_SIZE_GROUP_VERTICAL or
// GTK_SIZE_GROUP_BOTH.
//
// Note that only non-contextual sizes of every widget are ever consulted by
// size groups (since size groups have no knowledge of what size a widget will
// be allocated in one dimension, it cannot derive how much height a widget will
// receive for a given width). When grouping widgets that trade height for width
// in mode GTK_SIZE_GROUP_VERTICAL or GTK_SIZE_GROUP_BOTH: the height for the
// minimum width will be the requested height for all widgets in the group. The
// same is of course true when horizontally grouping width for height widgets.
//
// Widgets that trade height-for-width should set a reasonably large minimum
// width by way of Label:width-chars for instance. Widgets with static sizes as
// well as widgets that grow (such as ellipsizing text) need no such
// considerations.
//
//
// GtkSizeGroup as GtkBuildable
//
// Size groups can be specified in a UI definition by placing an <object>
// element with `class="GtkSizeGroup"` somewhere in the UI definition. The
// widgets that belong to the size group are specified by a <widgets> element
// that may contain multiple <widget> elements, one for each member of the size
// group. The ”name” attribute gives the id of the widget.
//
// An example of a UI definition fragment with GtkSizeGroup:
//
//    <object class="GtkSizeGroup">
//      <property name="mode">GTK_SIZE_GROUP_HORIZONTAL</property>
//      <widgets>
//        <widget name="radio1"/>
//        <widget name="radio2"/>
//      </widgets>
//    </object>
type SizeGroup interface {
	gextras.Objector
	Buildable

	// AddWidget adds a widget to a SizeGroup. In the future, the requisition of
	// the widget will be determined as the maximum of its requisition and the
	// requisition of the other widgets in the size group. Whether this applies
	// horizontally, vertically, or in both directions depends on the mode of
	// the size group. See gtk_size_group_set_mode().
	//
	// When the widget is destroyed or no longer referenced elsewhere, it will
	// be removed from the size group.
	AddWidget(widget Widget)
	// IgnoreHidden returns if invisible widgets are ignored when calculating
	// the size.
	IgnoreHidden() bool
	// Mode gets the current mode of the size group. See
	// gtk_size_group_set_mode().
	Mode() SizeGroupMode
	// Widgets returns the list of widgets associated with @size_group.
	Widgets() *glib.SList
	// RemoveWidget removes a widget from a SizeGroup.
	RemoveWidget(widget Widget)
	// SetIgnoreHidden sets whether unmapped widgets should be ignored when
	// calculating the size.
	SetIgnoreHidden(ignoreHidden bool)
	// SetMode sets the SizeGroupMode of the size group. The mode of the size
	// group determines whether the widgets in the size group should all have
	// the same horizontal requisition (GTK_SIZE_GROUP_HORIZONTAL) all have the
	// same vertical requisition (GTK_SIZE_GROUP_VERTICAL), or should all have
	// the same requisition in both directions (GTK_SIZE_GROUP_BOTH).
	SetMode(mode SizeGroupMode)
}

// sizeGroup implements the SizeGroup interface.
type sizeGroup struct {
	gextras.Objector
	Buildable
}

var _ SizeGroup = (*sizeGroup)(nil)

// WrapSizeGroup wraps a GObject to the right type. It is
// primarily used internally.
func WrapSizeGroup(obj *externglib.Object) SizeGroup {
	return SizeGroup{
		Objector:  obj,
		Buildable: WrapBuildable(obj),
	}
}

func marshalSizeGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSizeGroup(obj), nil
}

// NewSizeGroup constructs a class SizeGroup.
func NewSizeGroup(mode SizeGroupMode) SizeGroup {
	var arg1 C.GtkSizeGroupMode

	arg1 = (C.GtkSizeGroupMode)(mode)

	ret := C.gtk_size_group_new(arg1)

	var ret0 SizeGroup

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(SizeGroup)

	return ret0
}

// AddWidget adds a widget to a SizeGroup. In the future, the requisition of
// the widget will be determined as the maximum of its requisition and the
// requisition of the other widgets in the size group. Whether this applies
// horizontally, vertically, or in both directions depends on the mode of
// the size group. See gtk_size_group_set_mode().
//
// When the widget is destroyed or no longer referenced elsewhere, it will
// be removed from the size group.
func (sizeGroup sizeGroup) AddWidget(widget Widget) {
	var arg0 *C.GtkSizeGroup
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkSizeGroup)(sizeGroup.Native())
	arg1 = (*C.GtkWidget)(widget.Native())

	C.gtk_size_group_add_widget(arg0, arg1)
}

// IgnoreHidden returns if invisible widgets are ignored when calculating
// the size.
func (sizeGroup sizeGroup) IgnoreHidden() bool {
	var arg0 *C.GtkSizeGroup

	arg0 = (*C.GtkSizeGroup)(sizeGroup.Native())

	ret := C.gtk_size_group_get_ignore_hidden(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Mode gets the current mode of the size group. See
// gtk_size_group_set_mode().
func (sizeGroup sizeGroup) Mode() SizeGroupMode {
	var arg0 *C.GtkSizeGroup

	arg0 = (*C.GtkSizeGroup)(sizeGroup.Native())

	ret := C.gtk_size_group_get_mode(arg0)

	var ret0 SizeGroupMode

	ret0 = SizeGroupMode(ret)

	return ret0
}

// Widgets returns the list of widgets associated with @size_group.
func (sizeGroup sizeGroup) Widgets() *glib.SList {
	var arg0 *C.GtkSizeGroup

	arg0 = (*C.GtkSizeGroup)(sizeGroup.Native())

	ret := C.gtk_size_group_get_widgets(arg0)

	var ret0 *glib.SList

	{
		ret0 = glib.WrapSList(unsafe.Pointer(ret))
	}

	return ret0
}

// RemoveWidget removes a widget from a SizeGroup.
func (sizeGroup sizeGroup) RemoveWidget(widget Widget) {
	var arg0 *C.GtkSizeGroup
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkSizeGroup)(sizeGroup.Native())
	arg1 = (*C.GtkWidget)(widget.Native())

	C.gtk_size_group_remove_widget(arg0, arg1)
}

// SetIgnoreHidden sets whether unmapped widgets should be ignored when
// calculating the size.
func (sizeGroup sizeGroup) SetIgnoreHidden(ignoreHidden bool) {
	var arg0 *C.GtkSizeGroup
	var arg1 C.gboolean

	arg0 = (*C.GtkSizeGroup)(sizeGroup.Native())
	if ignoreHidden {
		arg1 = C.TRUE
	}

	C.gtk_size_group_set_ignore_hidden(arg0, arg1)
}

// SetMode sets the SizeGroupMode of the size group. The mode of the size
// group determines whether the widgets in the size group should all have
// the same horizontal requisition (GTK_SIZE_GROUP_HORIZONTAL) all have the
// same vertical requisition (GTK_SIZE_GROUP_VERTICAL), or should all have
// the same requisition in both directions (GTK_SIZE_GROUP_BOTH).
func (sizeGroup sizeGroup) SetMode(mode SizeGroupMode) {
	var arg0 *C.GtkSizeGroup
	var arg1 C.GtkSizeGroupMode

	arg0 = (*C.GtkSizeGroup)(sizeGroup.Native())
	arg1 = (C.GtkSizeGroupMode)(mode)

	C.gtk_size_group_set_mode(arg0, arg1)
}

// StatusIcon: the “system tray” or notification area is normally used for
// transient icons that indicate some special state. For example, a system tray
// icon might appear to tell the user that they have new mail, or have an
// incoming instant message, or something along those lines. The basic idea is
// that creating an icon in the notification area is less annoying than popping
// up a dialog.
//
// A StatusIcon object can be used to display an icon in a “system tray”. The
// icon can have a tooltip, and the user can interact with it by activating it
// or popping up a context menu.
//
// It is very important to notice that status icons depend on the existence of a
// notification area being available to the user; you should not use status
// icons as the only way to convey critical information regarding your
// application, as the notification area may not exist on the user's
// environment, or may have been removed. You should always check that a status
// icon has been embedded into a notification area by using
// gtk_status_icon_is_embedded(), and gracefully recover if the function returns
// false.
//
// On X11, the implementation follows the FreeDesktop System Tray Specification
// (http://www.freedesktop.org/wiki/Specifications/systemtray-spec).
// Implementations of the “tray” side of this specification can be found e.g. in
// the GNOME 2 and KDE panel applications.
//
// Note that a GtkStatusIcon is not a widget, but just a #GObject. Making it a
// widget would be impractical, since the system tray on Windows doesn’t allow
// to embed arbitrary widgets.
//
// GtkStatusIcon has been deprecated in 3.14. You should consider using
// notifications or more modern platform-specific APIs instead. GLib provides
// the #GNotification API which works well with Application on multiple
// platforms and environments, and should be the preferred mechanism to notify
// the users of transient status updates. See this HowDoI
// (https://wiki.gnome.org/HowDoI/GNotification) for code examples.
type StatusIcon interface {
	gextras.Objector

	// Geometry obtains information about the location of the status icon on
	// screen. This information can be used to e.g. position popups like
	// notification bubbles.
	//
	// See gtk_status_icon_position_menu() for a more convenient alternative for
	// positioning menus.
	//
	// Note that some platforms do not allow GTK+ to provide this information,
	// and even on platforms that do allow it, the information is not reliable
	// unless the status icon is embedded in a notification area, see
	// gtk_status_icon_is_embedded().
	Geometry() (screen gdk.Screen, area gdk.Rectangle, orientation Orientation, ok bool)
	// GIcon retrieves the #GIcon being displayed by the StatusIcon. The storage
	// type of the status icon must be GTK_IMAGE_EMPTY or GTK_IMAGE_GICON (see
	// gtk_status_icon_get_storage_type()). The caller of this function does not
	// own a reference to the returned #GIcon.
	//
	// If this function fails, @icon is left unchanged;
	GIcon() gio.Icon
	// HasTooltip returns the current value of the has-tooltip property. See
	// StatusIcon:has-tooltip for more information.
	HasTooltip() bool
	// IconName gets the name of the icon being displayed by the StatusIcon. The
	// storage type of the status icon must be GTK_IMAGE_EMPTY or
	// GTK_IMAGE_ICON_NAME (see gtk_status_icon_get_storage_type()). The
	// returned string is owned by the StatusIcon and should not be freed or
	// modified.
	IconName() string
	// Pixbuf gets the Pixbuf being displayed by the StatusIcon. The storage
	// type of the status icon must be GTK_IMAGE_EMPTY or GTK_IMAGE_PIXBUF (see
	// gtk_status_icon_get_storage_type()). The caller of this function does not
	// own a reference to the returned pixbuf.
	Pixbuf() gdkpixbuf.Pixbuf
	// Screen returns the Screen associated with @status_icon.
	Screen() gdk.Screen
	// Size gets the size in pixels that is available for the image. Stock icons
	// and named icons adapt their size automatically if the size of the
	// notification area changes. For other storage types, the size-changed
	// signal can be used to react to size changes.
	//
	// Note that the returned size is only meaningful while the status icon is
	// embedded (see gtk_status_icon_is_embedded()).
	Size() int
	// Stock gets the id of the stock icon being displayed by the StatusIcon.
	// The storage type of the status icon must be GTK_IMAGE_EMPTY or
	// GTK_IMAGE_STOCK (see gtk_status_icon_get_storage_type()). The returned
	// string is owned by the StatusIcon and should not be freed or modified.
	Stock() string
	// StorageType gets the type of representation being used by the StatusIcon
	// to store image data. If the StatusIcon has no image data, the return
	// value will be GTK_IMAGE_EMPTY.
	StorageType() ImageType
	// Title gets the title of this tray icon. See gtk_status_icon_set_title().
	Title() string
	// TooltipMarkup gets the contents of the tooltip for @status_icon.
	TooltipMarkup() string
	// TooltipText gets the contents of the tooltip for @status_icon.
	TooltipText() string
	// Visible returns whether the status icon is visible or not. Note that
	// being visible does not guarantee that the user can actually see the icon,
	// see also gtk_status_icon_is_embedded().
	Visible() bool
	// X11WindowID: this function is only useful on the X11/freedesktop.org
	// platform.
	//
	// It returns a window ID for the widget in the underlying status icon
	// implementation. This is useful for the Galago notification service, which
	// can send a window ID in the protocol in order for the server to position
	// notification windows pointing to a status icon reliably.
	//
	// This function is not intended for other use cases which are more likely
	// to be met by one of the non-X11 specific methods, such as
	// gtk_status_icon_position_menu().
	X11WindowID() uint32
	// IsEmbedded returns whether the status icon is embedded in a notification
	// area.
	IsEmbedded() bool
	// SetFromFile makes @status_icon display the file @filename. See
	// gtk_status_icon_new_from_file() for details.
	SetFromFile(filename string)
	// SetFromGIcon makes @status_icon display the #GIcon. See
	// gtk_status_icon_new_from_gicon() for details.
	SetFromGIcon(icon gio.Icon)
	// SetFromIconName makes @status_icon display the icon named @icon_name from
	// the current icon theme. See gtk_status_icon_new_from_icon_name() for
	// details.
	SetFromIconName(iconName string)
	// SetFromPixbuf makes @status_icon display @pixbuf. See
	// gtk_status_icon_new_from_pixbuf() for details.
	SetFromPixbuf(pixbuf gdkpixbuf.Pixbuf)
	// SetFromStock makes @status_icon display the stock icon with the id
	// @stock_id. See gtk_status_icon_new_from_stock() for details.
	SetFromStock(stockID string)
	// SetHasTooltip sets the has-tooltip property on @status_icon to
	// @has_tooltip. See StatusIcon:has-tooltip for more information.
	SetHasTooltip(hasTooltip bool)
	// SetName sets the name of this tray icon. This should be a string
	// identifying this icon. It is may be used for sorting the icons in the
	// tray and will not be shown to the user.
	SetName(name string)
	// SetScreen sets the Screen where @status_icon is displayed; if the icon is
	// already mapped, it will be unmapped, and then remapped on the new screen.
	SetScreen(screen gdk.Screen)
	// SetTitle sets the title of this tray icon. This should be a short,
	// human-readable, localized string describing the tray icon. It may be used
	// by tools like screen readers to render the tray icon.
	SetTitle(title string)
	// SetTooltipMarkup sets @markup as the contents of the tooltip, which is
	// marked up with the [Pango text markup language][PangoMarkupFormat].
	//
	// This function will take care of setting StatusIcon:has-tooltip to true
	// and of the default handler for the StatusIcon::query-tooltip signal.
	//
	// See also the StatusIcon:tooltip-markup property and
	// gtk_tooltip_set_markup().
	SetTooltipMarkup(markup string)
	// SetTooltipText sets @text as the contents of the tooltip.
	//
	// This function will take care of setting StatusIcon:has-tooltip to true
	// and of the default handler for the StatusIcon::query-tooltip signal.
	//
	// See also the StatusIcon:tooltip-text property and gtk_tooltip_set_text().
	SetTooltipText(text string)
	// SetVisible shows or hides a status icon.
	SetVisible(visible bool)
}

// statusIcon implements the StatusIcon interface.
type statusIcon struct {
	gextras.Objector
}

var _ StatusIcon = (*statusIcon)(nil)

// WrapStatusIcon wraps a GObject to the right type. It is
// primarily used internally.
func WrapStatusIcon(obj *externglib.Object) StatusIcon {
	return StatusIcon{
		Objector: obj,
	}
}

func marshalStatusIcon(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStatusIcon(obj), nil
}

// NewStatusIcon constructs a class StatusIcon.
func NewStatusIcon() StatusIcon {

	ret := C.gtk_status_icon_new()

	var ret0 StatusIcon

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(StatusIcon)

	return ret0
}

// NewStatusIconFromFile constructs a class StatusIcon.
func NewStatusIconFromFile(filename string) StatusIcon {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_status_icon_new_from_file(arg1)

	var ret0 StatusIcon

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(StatusIcon)

	return ret0
}

// NewStatusIconFromGIcon constructs a class StatusIcon.
func NewStatusIconFromGIcon(icon gio.Icon) StatusIcon {
	var arg1 *C.GIcon

	arg1 = (*C.GIcon)(icon.Native())

	ret := C.gtk_status_icon_new_from_gicon(arg1)

	var ret0 StatusIcon

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(StatusIcon)

	return ret0
}

// NewStatusIconFromIconName constructs a class StatusIcon.
func NewStatusIconFromIconName(iconName string) StatusIcon {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_status_icon_new_from_icon_name(arg1)

	var ret0 StatusIcon

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(StatusIcon)

	return ret0
}

// NewStatusIconFromPixbuf constructs a class StatusIcon.
func NewStatusIconFromPixbuf(pixbuf gdkpixbuf.Pixbuf) StatusIcon {
	var arg1 *C.GdkPixbuf

	arg1 = (*C.GdkPixbuf)(pixbuf.Native())

	ret := C.gtk_status_icon_new_from_pixbuf(arg1)

	var ret0 StatusIcon

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(StatusIcon)

	return ret0
}

// NewStatusIconFromStock constructs a class StatusIcon.
func NewStatusIconFromStock(stockID string) StatusIcon {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(stockID))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_status_icon_new_from_stock(arg1)

	var ret0 StatusIcon

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(StatusIcon)

	return ret0
}

// Geometry obtains information about the location of the status icon on
// screen. This information can be used to e.g. position popups like
// notification bubbles.
//
// See gtk_status_icon_position_menu() for a more convenient alternative for
// positioning menus.
//
// Note that some platforms do not allow GTK+ to provide this information,
// and even on platforms that do allow it, the information is not reliable
// unless the status icon is embedded in a notification area, see
// gtk_status_icon_is_embedded().
func (statusIcon statusIcon) Geometry() (screen gdk.Screen, area gdk.Rectangle, orientation Orientation, ok bool) {
	var arg0 *C.GtkStatusIcon
	var arg1 **C.GdkScreen     // out
	var arg2 *C.GdkRectangle   // out
	var arg3 *C.GtkOrientation // out

	arg0 = (*C.GtkStatusIcon)(statusIcon.Native())

	ret := C.gtk_status_icon_get_geometry(arg0, &arg1, &arg2, &arg3)

	var ret0 gdk.Screen
	var ret1 *gdk.Rectangle
	var ret2 *Orientation
	var ret3 bool

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(arg1.Native()))).(gdk.Screen)

	{
		ret1 = gdk.WrapRectangle(unsafe.Pointer(arg2))
	}

	ret2 = (*Orientation)(arg3)

	ret3 = C.BOOL(ret) != 0

	return ret0, ret1, ret2, ret3
}

// GIcon retrieves the #GIcon being displayed by the StatusIcon. The storage
// type of the status icon must be GTK_IMAGE_EMPTY or GTK_IMAGE_GICON (see
// gtk_status_icon_get_storage_type()). The caller of this function does not
// own a reference to the returned #GIcon.
//
// If this function fails, @icon is left unchanged;
func (statusIcon statusIcon) GIcon() gio.Icon {
	var arg0 *C.GtkStatusIcon

	arg0 = (*C.GtkStatusIcon)(statusIcon.Native())

	ret := C.gtk_status_icon_get_gicon(arg0)

	var ret0 gio.Icon

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gio.Icon)

	return ret0
}

// HasTooltip returns the current value of the has-tooltip property. See
// StatusIcon:has-tooltip for more information.
func (statusIcon statusIcon) HasTooltip() bool {
	var arg0 *C.GtkStatusIcon

	arg0 = (*C.GtkStatusIcon)(statusIcon.Native())

	ret := C.gtk_status_icon_get_has_tooltip(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IconName gets the name of the icon being displayed by the StatusIcon. The
// storage type of the status icon must be GTK_IMAGE_EMPTY or
// GTK_IMAGE_ICON_NAME (see gtk_status_icon_get_storage_type()). The
// returned string is owned by the StatusIcon and should not be freed or
// modified.
func (statusIcon statusIcon) IconName() string {
	var arg0 *C.GtkStatusIcon

	arg0 = (*C.GtkStatusIcon)(statusIcon.Native())

	ret := C.gtk_status_icon_get_icon_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Pixbuf gets the Pixbuf being displayed by the StatusIcon. The storage
// type of the status icon must be GTK_IMAGE_EMPTY or GTK_IMAGE_PIXBUF (see
// gtk_status_icon_get_storage_type()). The caller of this function does not
// own a reference to the returned pixbuf.
func (statusIcon statusIcon) Pixbuf() gdkpixbuf.Pixbuf {
	var arg0 *C.GtkStatusIcon

	arg0 = (*C.GtkStatusIcon)(statusIcon.Native())

	ret := C.gtk_status_icon_get_pixbuf(arg0)

	var ret0 gdkpixbuf.Pixbuf

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gdkpixbuf.Pixbuf)

	return ret0
}

// Screen returns the Screen associated with @status_icon.
func (statusIcon statusIcon) Screen() gdk.Screen {
	var arg0 *C.GtkStatusIcon

	arg0 = (*C.GtkStatusIcon)(statusIcon.Native())

	ret := C.gtk_status_icon_get_screen(arg0)

	var ret0 gdk.Screen

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gdk.Screen)

	return ret0
}

// Size gets the size in pixels that is available for the image. Stock icons
// and named icons adapt their size automatically if the size of the
// notification area changes. For other storage types, the size-changed
// signal can be used to react to size changes.
//
// Note that the returned size is only meaningful while the status icon is
// embedded (see gtk_status_icon_is_embedded()).
func (statusIcon statusIcon) Size() int {
	var arg0 *C.GtkStatusIcon

	arg0 = (*C.GtkStatusIcon)(statusIcon.Native())

	ret := C.gtk_status_icon_get_size(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Stock gets the id of the stock icon being displayed by the StatusIcon.
// The storage type of the status icon must be GTK_IMAGE_EMPTY or
// GTK_IMAGE_STOCK (see gtk_status_icon_get_storage_type()). The returned
// string is owned by the StatusIcon and should not be freed or modified.
func (statusIcon statusIcon) Stock() string {
	var arg0 *C.GtkStatusIcon

	arg0 = (*C.GtkStatusIcon)(statusIcon.Native())

	ret := C.gtk_status_icon_get_stock(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// StorageType gets the type of representation being used by the StatusIcon
// to store image data. If the StatusIcon has no image data, the return
// value will be GTK_IMAGE_EMPTY.
func (statusIcon statusIcon) StorageType() ImageType {
	var arg0 *C.GtkStatusIcon

	arg0 = (*C.GtkStatusIcon)(statusIcon.Native())

	ret := C.gtk_status_icon_get_storage_type(arg0)

	var ret0 ImageType

	ret0 = ImageType(ret)

	return ret0
}

// Title gets the title of this tray icon. See gtk_status_icon_set_title().
func (statusIcon statusIcon) Title() string {
	var arg0 *C.GtkStatusIcon

	arg0 = (*C.GtkStatusIcon)(statusIcon.Native())

	ret := C.gtk_status_icon_get_title(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// TooltipMarkup gets the contents of the tooltip for @status_icon.
func (statusIcon statusIcon) TooltipMarkup() string {
	var arg0 *C.GtkStatusIcon

	arg0 = (*C.GtkStatusIcon)(statusIcon.Native())

	ret := C.gtk_status_icon_get_tooltip_markup(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// TooltipText gets the contents of the tooltip for @status_icon.
func (statusIcon statusIcon) TooltipText() string {
	var arg0 *C.GtkStatusIcon

	arg0 = (*C.GtkStatusIcon)(statusIcon.Native())

	ret := C.gtk_status_icon_get_tooltip_text(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Visible returns whether the status icon is visible or not. Note that
// being visible does not guarantee that the user can actually see the icon,
// see also gtk_status_icon_is_embedded().
func (statusIcon statusIcon) Visible() bool {
	var arg0 *C.GtkStatusIcon

	arg0 = (*C.GtkStatusIcon)(statusIcon.Native())

	ret := C.gtk_status_icon_get_visible(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// X11WindowID: this function is only useful on the X11/freedesktop.org
// platform.
//
// It returns a window ID for the widget in the underlying status icon
// implementation. This is useful for the Galago notification service, which
// can send a window ID in the protocol in order for the server to position
// notification windows pointing to a status icon reliably.
//
// This function is not intended for other use cases which are more likely
// to be met by one of the non-X11 specific methods, such as
// gtk_status_icon_position_menu().
func (statusIcon statusIcon) X11WindowID() uint32 {
	var arg0 *C.GtkStatusIcon

	arg0 = (*C.GtkStatusIcon)(statusIcon.Native())

	ret := C.gtk_status_icon_get_x11_window_id(arg0)

	var ret0 uint32

	ret0 = uint32(ret)

	return ret0
}

// IsEmbedded returns whether the status icon is embedded in a notification
// area.
func (statusIcon statusIcon) IsEmbedded() bool {
	var arg0 *C.GtkStatusIcon

	arg0 = (*C.GtkStatusIcon)(statusIcon.Native())

	ret := C.gtk_status_icon_is_embedded(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SetFromFile makes @status_icon display the file @filename. See
// gtk_status_icon_new_from_file() for details.
func (statusIcon statusIcon) SetFromFile(filename string) {
	var arg0 *C.GtkStatusIcon
	var arg1 *C.gchar

	arg0 = (*C.GtkStatusIcon)(statusIcon.Native())
	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_status_icon_set_from_file(arg0, arg1)
}

// SetFromGIcon makes @status_icon display the #GIcon. See
// gtk_status_icon_new_from_gicon() for details.
func (statusIcon statusIcon) SetFromGIcon(icon gio.Icon) {
	var arg0 *C.GtkStatusIcon
	var arg1 *C.GIcon

	arg0 = (*C.GtkStatusIcon)(statusIcon.Native())
	arg1 = (*C.GIcon)(icon.Native())

	C.gtk_status_icon_set_from_gicon(arg0, arg1)
}

// SetFromIconName makes @status_icon display the icon named @icon_name from
// the current icon theme. See gtk_status_icon_new_from_icon_name() for
// details.
func (statusIcon statusIcon) SetFromIconName(iconName string) {
	var arg0 *C.GtkStatusIcon
	var arg1 *C.gchar

	arg0 = (*C.GtkStatusIcon)(statusIcon.Native())
	arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_status_icon_set_from_icon_name(arg0, arg1)
}

// SetFromPixbuf makes @status_icon display @pixbuf. See
// gtk_status_icon_new_from_pixbuf() for details.
func (statusIcon statusIcon) SetFromPixbuf(pixbuf gdkpixbuf.Pixbuf) {
	var arg0 *C.GtkStatusIcon
	var arg1 *C.GdkPixbuf

	arg0 = (*C.GtkStatusIcon)(statusIcon.Native())
	arg1 = (*C.GdkPixbuf)(pixbuf.Native())

	C.gtk_status_icon_set_from_pixbuf(arg0, arg1)
}

// SetFromStock makes @status_icon display the stock icon with the id
// @stock_id. See gtk_status_icon_new_from_stock() for details.
func (statusIcon statusIcon) SetFromStock(stockID string) {
	var arg0 *C.GtkStatusIcon
	var arg1 *C.gchar

	arg0 = (*C.GtkStatusIcon)(statusIcon.Native())
	arg1 = (*C.gchar)(C.CString(stockID))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_status_icon_set_from_stock(arg0, arg1)
}

// SetHasTooltip sets the has-tooltip property on @status_icon to
// @has_tooltip. See StatusIcon:has-tooltip for more information.
func (statusIcon statusIcon) SetHasTooltip(hasTooltip bool) {
	var arg0 *C.GtkStatusIcon
	var arg1 C.gboolean

	arg0 = (*C.GtkStatusIcon)(statusIcon.Native())
	if hasTooltip {
		arg1 = C.TRUE
	}

	C.gtk_status_icon_set_has_tooltip(arg0, arg1)
}

// SetName sets the name of this tray icon. This should be a string
// identifying this icon. It is may be used for sorting the icons in the
// tray and will not be shown to the user.
func (statusIcon statusIcon) SetName(name string) {
	var arg0 *C.GtkStatusIcon
	var arg1 *C.gchar

	arg0 = (*C.GtkStatusIcon)(statusIcon.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_status_icon_set_name(arg0, arg1)
}

// SetScreen sets the Screen where @status_icon is displayed; if the icon is
// already mapped, it will be unmapped, and then remapped on the new screen.
func (statusIcon statusIcon) SetScreen(screen gdk.Screen) {
	var arg0 *C.GtkStatusIcon
	var arg1 *C.GdkScreen

	arg0 = (*C.GtkStatusIcon)(statusIcon.Native())
	arg1 = (*C.GdkScreen)(screen.Native())

	C.gtk_status_icon_set_screen(arg0, arg1)
}

// SetTitle sets the title of this tray icon. This should be a short,
// human-readable, localized string describing the tray icon. It may be used
// by tools like screen readers to render the tray icon.
func (statusIcon statusIcon) SetTitle(title string) {
	var arg0 *C.GtkStatusIcon
	var arg1 *C.gchar

	arg0 = (*C.GtkStatusIcon)(statusIcon.Native())
	arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_status_icon_set_title(arg0, arg1)
}

// SetTooltipMarkup sets @markup as the contents of the tooltip, which is
// marked up with the [Pango text markup language][PangoMarkupFormat].
//
// This function will take care of setting StatusIcon:has-tooltip to true
// and of the default handler for the StatusIcon::query-tooltip signal.
//
// See also the StatusIcon:tooltip-markup property and
// gtk_tooltip_set_markup().
func (statusIcon statusIcon) SetTooltipMarkup(markup string) {
	var arg0 *C.GtkStatusIcon
	var arg1 *C.gchar

	arg0 = (*C.GtkStatusIcon)(statusIcon.Native())
	arg1 = (*C.gchar)(C.CString(markup))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_status_icon_set_tooltip_markup(arg0, arg1)
}

// SetTooltipText sets @text as the contents of the tooltip.
//
// This function will take care of setting StatusIcon:has-tooltip to true
// and of the default handler for the StatusIcon::query-tooltip signal.
//
// See also the StatusIcon:tooltip-text property and gtk_tooltip_set_text().
func (statusIcon statusIcon) SetTooltipText(text string) {
	var arg0 *C.GtkStatusIcon
	var arg1 *C.gchar

	arg0 = (*C.GtkStatusIcon)(statusIcon.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_status_icon_set_tooltip_text(arg0, arg1)
}

// SetVisible shows or hides a status icon.
func (statusIcon statusIcon) SetVisible(visible bool) {
	var arg0 *C.GtkStatusIcon
	var arg1 C.gboolean

	arg0 = (*C.GtkStatusIcon)(statusIcon.Native())
	if visible {
		arg1 = C.TRUE
	}

	C.gtk_status_icon_set_visible(arg0, arg1)
}

// Style: a Style object encapsulates the information that provides the look and
// feel for a widget.
//
// > In GTK+ 3.0, GtkStyle has been deprecated and replaced by > StyleContext.
//
// Each Widget has an associated Style object that is used when rendering that
// widget. Also, a Style holds information for the five possible widget states
// though not every widget supports all five states; see StateType.
//
// Usually the Style for a widget is the same as the default style that is set
// by GTK+ and modified the theme engine.
//
// Usually applications should not need to use or modify the Style of their
// widgets.
type Style interface {
	gextras.Objector

	ApplyDefaultBackground(cr *cairo.Context, window gdk.Window, stateType StateType, x int, y int, width int, height int)
	// Attach attaches a style to a window; this process allocates the colors
	// and creates the GC’s for the style - it specializes it to a particular
	// visual. The process may involve the creation of a new style if the style
	// has already been attached to a window with a different style and visual.
	//
	// Since this function may return a new object, you have to use it in the
	// following way: `style = gtk_style_attach (style, window)`
	Attach(window gdk.Window) Style
	// Copy creates a copy of the passed in Style object.
	Copy() Style
	// Detach detaches a style from a window. If the style is not attached to
	// any windows anymore, it is unrealized. See gtk_style_attach().
	Detach()
	// StyleProperty queries the value of a style property corresponding to a
	// widget class is in the given style.
	StyleProperty(widgetType externglib.Type, propertyName string) externglib.Value
	// HasContext returns whether @style has an associated StyleContext.
	HasContext() bool
	// LookupColor looks up @color_name in the style’s logical color mappings,
	// filling in @color and returning true if found, otherwise returning false.
	// Do not cache the found mapping, because it depends on the Style and might
	// change when a theme switch occurs.
	LookupColor(colorName string) (color gdk.Color, ok bool)
	// LookupIconSet looks up @stock_id in the icon factories associated with
	// @style and the default icon factory, returning an icon set if found,
	// otherwise nil.
	LookupIconSet(stockID string) *IconSet
	// RenderIcon renders the icon specified by @source at the given @size
	// according to the given parameters and returns the result in a pixbuf.
	RenderIcon(source *IconSource, direction TextDirection, state StateType, size int, widget Widget, detail string) gdkpixbuf.Pixbuf
	// SetBackground sets the background of @window to the background color or
	// pixmap specified by @style for the given state.
	SetBackground(window gdk.Window, stateType StateType)
}

// style implements the Style interface.
type style struct {
	gextras.Objector
}

var _ Style = (*style)(nil)

// WrapStyle wraps a GObject to the right type. It is
// primarily used internally.
func WrapStyle(obj *externglib.Object) Style {
	return Style{
		Objector: obj,
	}
}

func marshalStyle(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStyle(obj), nil
}

// NewStyle constructs a class Style.
func NewStyle() Style {

	ret := C.gtk_style_new()

	var ret0 Style

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(Style)

	return ret0
}

func (style style) ApplyDefaultBackground(cr *cairo.Context, window gdk.Window, stateType StateType, x int, y int, width int, height int) {
	var arg0 *C.GtkStyle
	var arg1 *C.cairo_t
	var arg2 *C.GdkWindow
	var arg3 C.GtkStateType
	var arg4 C.gint
	var arg5 C.gint
	var arg6 C.gint
	var arg7 C.gint

	arg0 = (*C.GtkStyle)(style.Native())
	arg1 = (*C.cairo_t)(cr.Native())
	arg2 = (*C.GdkWindow)(window.Native())
	arg3 = (C.GtkStateType)(stateType)
	arg4 = C.gint(x)
	arg5 = C.gint(y)
	arg6 = C.gint(width)
	arg7 = C.gint(height)

	C.gtk_style_apply_default_background(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
}

// Attach attaches a style to a window; this process allocates the colors
// and creates the GC’s for the style - it specializes it to a particular
// visual. The process may involve the creation of a new style if the style
// has already been attached to a window with a different style and visual.
//
// Since this function may return a new object, you have to use it in the
// following way: `style = gtk_style_attach (style, window)`
func (style style) Attach(window gdk.Window) Style {
	var arg0 *C.GtkStyle
	var arg1 *C.GdkWindow

	arg0 = (*C.GtkStyle)(style.Native())
	arg1 = (*C.GdkWindow)(window.Native())

	ret := C.gtk_style_attach(arg0, arg1)

	var ret0 Style

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Style)

	return ret0
}

// Copy creates a copy of the passed in Style object.
func (style style) Copy() Style {
	var arg0 *C.GtkStyle

	arg0 = (*C.GtkStyle)(style.Native())

	ret := C.gtk_style_copy(arg0)

	var ret0 Style

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(Style)

	return ret0
}

// Detach detaches a style from a window. If the style is not attached to
// any windows anymore, it is unrealized. See gtk_style_attach().
func (style style) Detach() {
	var arg0 *C.GtkStyle

	arg0 = (*C.GtkStyle)(style.Native())

	C.gtk_style_detach(arg0)
}

// StyleProperty queries the value of a style property corresponding to a
// widget class is in the given style.
func (style style) StyleProperty(widgetType externglib.Type, propertyName string) externglib.Value {
	var arg0 *C.GtkStyle
	var arg1 C.GType
	var arg2 *C.gchar
	var arg3 *C.GValue // out

	arg0 = (*C.GtkStyle)(style.Native())
	arg1 = C.GType(widgetType)
	arg2 = (*C.gchar)(C.CString(propertyName))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_style_get_style_property(arg0, arg1, arg2, &arg3)

	var ret0 *externglib.Value

	ret0 = externglib.ValueFromNative(unsafe.Pointer(arg3))

	return ret0
}

// HasContext returns whether @style has an associated StyleContext.
func (style style) HasContext() bool {
	var arg0 *C.GtkStyle

	arg0 = (*C.GtkStyle)(style.Native())

	ret := C.gtk_style_has_context(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// LookupColor looks up @color_name in the style’s logical color mappings,
// filling in @color and returning true if found, otherwise returning false.
// Do not cache the found mapping, because it depends on the Style and might
// change when a theme switch occurs.
func (style style) LookupColor(colorName string) (color gdk.Color, ok bool) {
	var arg0 *C.GtkStyle
	var arg1 *C.gchar
	var arg2 *C.GdkColor // out

	arg0 = (*C.GtkStyle)(style.Native())
	arg1 = (*C.gchar)(C.CString(colorName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_style_lookup_color(arg0, arg1, &arg2)

	var ret0 *gdk.Color
	var ret1 bool

	{
		ret0 = gdk.WrapColor(unsafe.Pointer(arg2))
	}

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// LookupIconSet looks up @stock_id in the icon factories associated with
// @style and the default icon factory, returning an icon set if found,
// otherwise nil.
func (style style) LookupIconSet(stockID string) *IconSet {
	var arg0 *C.GtkStyle
	var arg1 *C.gchar

	arg0 = (*C.GtkStyle)(style.Native())
	arg1 = (*C.gchar)(C.CString(stockID))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_style_lookup_icon_set(arg0, arg1)

	var ret0 *IconSet

	{
		ret0 = WrapIconSet(unsafe.Pointer(ret))
	}

	return ret0
}

// RenderIcon renders the icon specified by @source at the given @size
// according to the given parameters and returns the result in a pixbuf.
func (style style) RenderIcon(source *IconSource, direction TextDirection, state StateType, size int, widget Widget, detail string) gdkpixbuf.Pixbuf {
	var arg0 *C.GtkStyle
	var arg1 *C.GtkIconSource
	var arg2 C.GtkTextDirection
	var arg3 C.GtkStateType
	var arg4 C.GtkIconSize
	var arg5 *C.GtkWidget
	var arg6 *C.gchar

	arg0 = (*C.GtkStyle)(style.Native())
	arg1 = (*C.GtkIconSource)(source.Native())
	arg2 = (C.GtkTextDirection)(direction)
	arg3 = (C.GtkStateType)(state)
	arg4 = C.GtkIconSize(size)
	arg5 = (*C.GtkWidget)(widget.Native())
	arg6 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(arg6))

	ret := C.gtk_style_render_icon(arg0, arg1, arg2, arg3, arg4, arg5, arg6)

	var ret0 gdkpixbuf.Pixbuf

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gdkpixbuf.Pixbuf)

	return ret0
}

// SetBackground sets the background of @window to the background color or
// pixmap specified by @style for the given state.
func (style style) SetBackground(window gdk.Window, stateType StateType) {
	var arg0 *C.GtkStyle
	var arg1 *C.GdkWindow
	var arg2 C.GtkStateType

	arg0 = (*C.GtkStyle)(style.Native())
	arg1 = (*C.GdkWindow)(window.Native())
	arg2 = (C.GtkStateType)(stateType)

	C.gtk_style_set_background(arg0, arg1, arg2)
}

// StyleContext is an object that stores styling information affecting a widget
// defined by WidgetPath.
//
// In order to construct the final style information, StyleContext queries
// information from all attached StyleProviders. Style providers can be either
// attached explicitly to the context through gtk_style_context_add_provider(),
// or to the screen through gtk_style_context_add_provider_for_screen(). The
// resulting style is a combination of all providers’ information in priority
// order.
//
// For GTK+ widgets, any StyleContext returned by gtk_widget_get_style_context()
// will already have a WidgetPath, a Screen and RTL/LTR information set. The
// style context will also be updated automatically if any of these settings
// change on the widget.
//
// If you are using the theming layer standalone, you will need to set a widget
// path and a screen yourself to the created style context through
// gtk_style_context_set_path() and possibly gtk_style_context_set_screen(). See
// the “Foreign drawing“ example in gtk3-demo.
//
//
// Style Classes
//
// Widgets can add style classes to their context, which can be used to
// associate different styles by class. The documentation for individual widgets
// lists which style classes it uses itself, and which style classes may be
// added by applications to affect their appearance.
//
// GTK+ defines macros for a number of style classes.
//
//
// Style Regions
//
// Widgets can also add regions with flags to their context. This feature is
// deprecated and will be removed in a future GTK+ update. Please use style
// classes instead.
//
// GTK+ defines macros for a number of style regions.
//
//
// Custom styling in UI libraries and applications
//
// If you are developing a library with custom Widgets that render differently
// than standard components, you may need to add a StyleProvider yourself with
// the GTK_STYLE_PROVIDER_PRIORITY_FALLBACK priority, either a CssProvider or a
// custom object implementing the StyleProvider interface. This way themes may
// still attempt to style your UI elements in a different way if needed so.
//
// If you are using custom styling on an applications, you probably want then to
// make your style information prevail to the theme’s, so you must use a
// StyleProvider with the GTK_STYLE_PROVIDER_PRIORITY_APPLICATION priority, keep
// in mind that the user settings in `XDG_CONFIG_HOME/gtk-3.0/gtk.css` will
// still take precedence over your changes, as it uses the
// GTK_STYLE_PROVIDER_PRIORITY_USER priority.
type StyleContext interface {
	gextras.Objector

	// AddClass adds a style class to @context, so posterior calls to
	// gtk_style_context_get() or any of the gtk_render_*() functions will make
	// use of this new class for styling.
	//
	// In the CSS file format, a Entry defining a “search” class, would be
	// matched by:
	//
	// |[ <!-- language="CSS" --> entry.search { ... } ]|
	//
	// While any widget defining a “search” class would be matched by: |[ <!--
	// language="CSS" --> .search { ... } ]|
	AddClass(className string)
	// AddProvider adds a style provider to @context, to be used in style
	// construction. Note that a style provider added by this function only
	// affects the style of the widget to which @context belongs. If you want to
	// affect the style of all widgets, use
	// gtk_style_context_add_provider_for_screen().
	//
	// Note: If both priorities are the same, a StyleProvider added through this
	// function takes precedence over another added through
	// gtk_style_context_add_provider_for_screen().
	AddProvider(provider StyleProvider, priority uint)
	// AddRegion adds a region to @context, so posterior calls to
	// gtk_style_context_get() or any of the gtk_render_*() functions will make
	// use of this new region for styling.
	//
	// In the CSS file format, a TreeView defining a “row” region, would be
	// matched by:
	//
	// |[ <!-- language="CSS" --> treeview row { ... } ]|
	//
	// Pseudo-classes are used for matching @flags, so the two following rules:
	// |[ <!-- language="CSS" --> treeview row:nth-child(even) { ... } treeview
	// row:nth-child(odd) { ... } ]|
	//
	// would apply to even and odd rows, respectively.
	//
	// Region names must only contain lowercase letters and “-”, starting always
	// with a lowercase letter.
	AddRegion(regionName string, flags RegionFlags)
	// CancelAnimations stops all running animations for @region_id and all
	// animatable regions underneath.
	//
	// A nil @region_id will stop all ongoing animations in @context, when
	// dealing with a StyleContext obtained through
	// gtk_widget_get_style_context(), this is normally done for you in all
	// circumstances you would expect all widget to be stopped, so this should
	// be only used in complex widgets with different animatable regions.
	CancelAnimations(regionID interface{})
	// BackgroundColor gets the background color for a given state.
	//
	// This function is far less useful than it seems, and it should not be used
	// in newly written code. CSS has no concept of "background color", as a
	// background can be an image, or a gradient, or any other pattern including
	// solid colors.
	//
	// The only reason why you would call
	// gtk_style_context_get_background_color() is to use the returned value to
	// draw the background with it; the correct way to achieve this result is to
	// use gtk_render_background() instead, along with CSS style classes to
	// modify the color to be rendered.
	BackgroundColor(state StateFlags) gdk.RGBA
	// Border gets the border for a given state as a Border.
	//
	// See gtk_style_context_get_property() and K_STYLE_PROPERTY_BORDER_WIDTH
	// for details.
	Border(state StateFlags) Border
	// BorderColor gets the border color for a given state.
	BorderColor(state StateFlags) gdk.RGBA
	// Color gets the foreground color for a given state.
	//
	// See gtk_style_context_get_property() and K_STYLE_PROPERTY_COLOR for
	// details.
	Color(state StateFlags) gdk.RGBA
	// Direction returns the widget direction used for rendering.
	Direction() TextDirection
	// Font returns the font description for a given state. The returned object
	// is const and will remain valid until the StyleContext::changed signal
	// happens.
	Font(state StateFlags) *pango.FontDescription
	// FrameClock returns the FrameClock to which @context is attached.
	FrameClock() gdk.FrameClock
	// JunctionSides returns the sides where rendered elements connect visually
	// with others.
	JunctionSides() JunctionSides
	// Margin gets the margin for a given state as a Border. See
	// gtk_style_property_get() and K_STYLE_PROPERTY_MARGIN for details.
	Margin(state StateFlags) Border
	// Padding gets the padding for a given state as a Border. See
	// gtk_style_context_get() and K_STYLE_PROPERTY_PADDING for details.
	Padding(state StateFlags) Border
	// Parent gets the parent context set via gtk_style_context_set_parent().
	// See that function for details.
	Parent() StyleContext
	// Path returns the widget path used for style matching.
	Path() *WidgetPath
	// Property gets a style property from @context for the given state.
	//
	// Note that not all CSS properties that are supported by GTK+ can be
	// retrieved in this way, since they may not be representable as #GValue.
	// GTK+ defines macros for a number of properties that can be used with this
	// function.
	//
	// Note that passing a state other than the current state of @context is not
	// recommended unless the style context has been saved with
	// gtk_style_context_save().
	//
	// When @value is no longer needed, g_value_unset() must be called to free
	// any allocated memory.
	Property(property string, state StateFlags) externglib.Value
	// Scale returns the scale used for assets.
	Scale() int
	// Screen returns the Screen to which @context is attached.
	Screen() gdk.Screen
	// Section queries the location in the CSS where @property was defined for
	// the current @context. Note that the state to be queried is taken from
	// gtk_style_context_get_state().
	//
	// If the location is not available, nil will be returned. The location
	// might not be available for various reasons, such as the property being
	// overridden, @property not naming a supported CSS property or tracking of
	// definitions being disabled for performance reasons.
	//
	// Shorthand CSS properties cannot be queried for a location and will always
	// return nil.
	Section(property string) *CSSSection
	// State returns the state used for style matching.
	//
	// This method should only be used to retrieve the StateFlags to pass to
	// StyleContext methods, like gtk_style_context_get_padding(). If you need
	// to retrieve the current state of a Widget, use
	// gtk_widget_get_state_flags().
	State() StateFlags
	// StyleProperty gets the value for a widget style property.
	//
	// When @value is no longer needed, g_value_unset() must be called to free
	// any allocated memory.
	StyleProperty(propertyName string, value *externglib.Value)
	// HasClass returns true if @context currently has defined the given class
	// name.
	HasClass(className string) bool
	// HasRegion returns true if @context has the region defined. If
	// @flags_return is not nil, it is set to the flags affecting the region.
	HasRegion(regionName string) (flagsReturn RegionFlags, ok bool)
	// Invalidate invalidates @context style information, so it will be
	// reconstructed again. It is useful if you modify the @context and need the
	// new information immediately.
	Invalidate()
	// ListClasses returns the list of classes currently defined in @context.
	ListClasses() *glib.List
	// ListRegions returns the list of regions currently defined in @context.
	ListRegions() *glib.List
	// LookupColor looks up and resolves a color name in the @context color map.
	LookupColor(colorName string) (color gdk.RGBA, ok bool)
	// LookupIconSet looks up @stock_id in the icon factories associated to
	// @context and the default icon factory, returning an icon set if found,
	// otherwise nil.
	LookupIconSet(stockID string) *IconSet
	// NotifyStateChange notifies a state change on @context, so if the current
	// style makes use of transition animations, one will be started so all
	// rendered elements under @region_id are animated for state @state being
	// set to value @state_value.
	//
	// The @window parameter is used in order to invalidate the rendered area as
	// the animation runs, so make sure it is the same window that is being
	// rendered on by the gtk_render_*() functions.
	//
	// If @region_id is nil, all rendered elements using @context will be
	// affected by this state transition.
	//
	// As a practical example, a Button notifying a state transition on the
	// prelight state: |[ <!-- language="C" -->
	// gtk_style_context_notify_state_change (context, gtk_widget_get_window
	// (widget), NULL, GTK_STATE_PRELIGHT, button->in_button); ]|
	//
	// Can be handled in the CSS file like this: |[ <!-- language="CSS" -->
	// button { background-color: #f00 }
	//
	// button:hover { background-color: #fff; transition: 200ms linear } ]|
	//
	// This combination will animate the button background from red to white if
	// a pointer enters the button, and back to red if the pointer leaves the
	// button.
	//
	// Note that @state is used when finding the transition parameters, which is
	// why the style places the transition under the :hover pseudo-class.
	NotifyStateChange(window gdk.Window, regionID interface{}, state StateType, stateValue bool)
	// PopAnimatableRegion pops an animatable region from @context. See
	// gtk_style_context_push_animatable_region().
	PopAnimatableRegion()
	// PushAnimatableRegion pushes an animatable region, so all further
	// gtk_render_*() calls between this call and the following
	// gtk_style_context_pop_animatable_region() will potentially show
	// transition animations for this region if
	// gtk_style_context_notify_state_change() is called for a given state, and
	// the current theme/style defines transition animations for state changes.
	//
	// The @region_id used must be unique in @context so the themes can uniquely
	// identify rendered elements subject to a state transition.
	PushAnimatableRegion(regionID interface{})
	// RemoveClass removes @class_name from @context.
	RemoveClass(className string)
	// RemoveProvider removes @provider from the style providers list in
	// @context.
	RemoveProvider(provider StyleProvider)
	// RemoveRegion removes a region from @context.
	RemoveRegion(regionName string)
	// Restore restores @context state to a previous stage. See
	// gtk_style_context_save().
	Restore()
	// Save saves the @context state, so temporary modifications done through
	// gtk_style_context_add_class(), gtk_style_context_remove_class(),
	// gtk_style_context_set_state(), etc. can quickly be reverted in one go
	// through gtk_style_context_restore().
	//
	// The matching call to gtk_style_context_restore() must be done before GTK
	// returns to the main loop.
	Save()
	// ScrollAnimations: this function is analogous to gdk_window_scroll(), and
	// should be called together with it so the invalidation areas for any
	// ongoing animation are scrolled together with it.
	ScrollAnimations(window gdk.Window, dx int, dy int)
	// SetBackground sets the background of @window to the background pattern or
	// color specified in @context for its current state.
	SetBackground(window gdk.Window)
	// SetDirection sets the reading direction for rendering purposes.
	//
	// If you are using a StyleContext returned from
	// gtk_widget_get_style_context(), you do not need to call this yourself.
	SetDirection(direction TextDirection)
	// SetFrameClock attaches @context to the given frame clock.
	//
	// The frame clock is used for the timing of animations.
	//
	// If you are using a StyleContext returned from
	// gtk_widget_get_style_context(), you do not need to call this yourself.
	SetFrameClock(frameClock gdk.FrameClock)
	// SetJunctionSides sets the sides where rendered elements (mostly through
	// gtk_render_frame()) will visually connect with other visual elements.
	//
	// This is merely a hint that may or may not be honored by themes.
	//
	// Container widgets are expected to set junction hints as appropriate for
	// their children, so it should not normally be necessary to call this
	// function manually.
	SetJunctionSides(sides JunctionSides)
	// SetParent sets the parent style context for @context. The parent style
	// context is used to implement inheritance
	// (http://www.w3.org/TR/css3-cascade/#inheritance) of properties.
	//
	// If you are using a StyleContext returned from
	// gtk_widget_get_style_context(), the parent will be set for you.
	SetParent(parent StyleContext)
	// SetPath sets the WidgetPath used for style matching. As a consequence,
	// the style will be regenerated to match the new given path.
	//
	// If you are using a StyleContext returned from
	// gtk_widget_get_style_context(), you do not need to call this yourself.
	SetPath(path *WidgetPath)
	// SetScale sets the scale to use when getting image assets for the style.
	SetScale(scale int)
	// SetScreen attaches @context to the given screen.
	//
	// The screen is used to add style information from “global” style
	// providers, such as the screen’s Settings instance.
	//
	// If you are using a StyleContext returned from
	// gtk_widget_get_style_context(), you do not need to call this yourself.
	SetScreen(screen gdk.Screen)
	// SetState sets the state to be used for style matching.
	SetState(flags StateFlags)
	// StateIsRunning returns true if there is a transition animation running
	// for the current region (see gtk_style_context_push_animatable_region()).
	//
	// If @progress is not nil, the animation progress will be returned there,
	// 0.0 means the state is closest to being unset, while 1.0 means it’s
	// closest to being set. This means transition animation will run from 0 to
	// 1 when @state is being set and from 1 to 0 when it’s being unset.
	StateIsRunning(state StateType) (progress float64, ok bool)
	// String converts the style context into a string representation.
	//
	// The string representation always includes information about the name,
	// state, id, visibility and style classes of the CSS node that is backing
	// @context. Depending on the flags, more information may be included.
	//
	// This function is intended for testing and debugging of the CSS
	// implementation in GTK+. There are no guarantees about the format of the
	// returned string, it may change.
	String(flags StyleContextPrintFlags) string
}

// styleContext implements the StyleContext interface.
type styleContext struct {
	gextras.Objector
}

var _ StyleContext = (*styleContext)(nil)

// WrapStyleContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapStyleContext(obj *externglib.Object) StyleContext {
	return StyleContext{
		Objector: obj,
	}
}

func marshalStyleContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStyleContext(obj), nil
}

// NewStyleContext constructs a class StyleContext.
func NewStyleContext() StyleContext {

	ret := C.gtk_style_context_new()

	var ret0 StyleContext

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(StyleContext)

	return ret0
}

// AddClass adds a style class to @context, so posterior calls to
// gtk_style_context_get() or any of the gtk_render_*() functions will make
// use of this new class for styling.
//
// In the CSS file format, a Entry defining a “search” class, would be
// matched by:
//
// |[ <!-- language="CSS" --> entry.search { ... } ]|
//
// While any widget defining a “search” class would be matched by: |[ <!--
// language="CSS" --> .search { ... } ]|
func (context styleContext) AddClass(className string) {
	var arg0 *C.GtkStyleContext
	var arg1 *C.gchar

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (*C.gchar)(C.CString(className))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_style_context_add_class(arg0, arg1)
}

// AddProvider adds a style provider to @context, to be used in style
// construction. Note that a style provider added by this function only
// affects the style of the widget to which @context belongs. If you want to
// affect the style of all widgets, use
// gtk_style_context_add_provider_for_screen().
//
// Note: If both priorities are the same, a StyleProvider added through this
// function takes precedence over another added through
// gtk_style_context_add_provider_for_screen().
func (context styleContext) AddProvider(provider StyleProvider, priority uint) {
	var arg0 *C.GtkStyleContext
	var arg1 *C.GtkStyleProvider
	var arg2 C.guint

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (*C.GtkStyleProvider)(provider.Native())
	arg2 = C.guint(priority)

	C.gtk_style_context_add_provider(arg0, arg1, arg2)
}

// AddRegion adds a region to @context, so posterior calls to
// gtk_style_context_get() or any of the gtk_render_*() functions will make
// use of this new region for styling.
//
// In the CSS file format, a TreeView defining a “row” region, would be
// matched by:
//
// |[ <!-- language="CSS" --> treeview row { ... } ]|
//
// Pseudo-classes are used for matching @flags, so the two following rules:
// |[ <!-- language="CSS" --> treeview row:nth-child(even) { ... } treeview
// row:nth-child(odd) { ... } ]|
//
// would apply to even and odd rows, respectively.
//
// Region names must only contain lowercase letters and “-”, starting always
// with a lowercase letter.
func (context styleContext) AddRegion(regionName string, flags RegionFlags) {
	var arg0 *C.GtkStyleContext
	var arg1 *C.gchar
	var arg2 C.GtkRegionFlags

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (*C.gchar)(C.CString(regionName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GtkRegionFlags)(flags)

	C.gtk_style_context_add_region(arg0, arg1, arg2)
}

// CancelAnimations stops all running animations for @region_id and all
// animatable regions underneath.
//
// A nil @region_id will stop all ongoing animations in @context, when
// dealing with a StyleContext obtained through
// gtk_widget_get_style_context(), this is normally done for you in all
// circumstances you would expect all widget to be stopped, so this should
// be only used in complex widgets with different animatable regions.
func (context styleContext) CancelAnimations(regionID interface{}) {
	var arg0 *C.GtkStyleContext
	var arg1 C.gpointer

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = C.gpointer(box.Assign(regionID))

	C.gtk_style_context_cancel_animations(arg0, arg1)
}

// BackgroundColor gets the background color for a given state.
//
// This function is far less useful than it seems, and it should not be used
// in newly written code. CSS has no concept of "background color", as a
// background can be an image, or a gradient, or any other pattern including
// solid colors.
//
// The only reason why you would call
// gtk_style_context_get_background_color() is to use the returned value to
// draw the background with it; the correct way to achieve this result is to
// use gtk_render_background() instead, along with CSS style classes to
// modify the color to be rendered.
func (context styleContext) BackgroundColor(state StateFlags) gdk.RGBA {
	var arg0 *C.GtkStyleContext
	var arg1 C.GtkStateFlags
	var arg2 *C.GdkRGBA // out

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (C.GtkStateFlags)(state)

	C.gtk_style_context_get_background_color(arg0, arg1, &arg2)

	var ret0 *gdk.RGBA

	{
		ret0 = gdk.WrapRGBA(unsafe.Pointer(arg2))
	}

	return ret0
}

// Border gets the border for a given state as a Border.
//
// See gtk_style_context_get_property() and K_STYLE_PROPERTY_BORDER_WIDTH
// for details.
func (context styleContext) Border(state StateFlags) Border {
	var arg0 *C.GtkStyleContext
	var arg1 C.GtkStateFlags
	var arg2 *C.GtkBorder // out

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (C.GtkStateFlags)(state)

	C.gtk_style_context_get_border(arg0, arg1, &arg2)

	var ret0 *Border

	{
		ret0 = WrapBorder(unsafe.Pointer(arg2))
	}

	return ret0
}

// BorderColor gets the border color for a given state.
func (context styleContext) BorderColor(state StateFlags) gdk.RGBA {
	var arg0 *C.GtkStyleContext
	var arg1 C.GtkStateFlags
	var arg2 *C.GdkRGBA // out

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (C.GtkStateFlags)(state)

	C.gtk_style_context_get_border_color(arg0, arg1, &arg2)

	var ret0 *gdk.RGBA

	{
		ret0 = gdk.WrapRGBA(unsafe.Pointer(arg2))
	}

	return ret0
}

// Color gets the foreground color for a given state.
//
// See gtk_style_context_get_property() and K_STYLE_PROPERTY_COLOR for
// details.
func (context styleContext) Color(state StateFlags) gdk.RGBA {
	var arg0 *C.GtkStyleContext
	var arg1 C.GtkStateFlags
	var arg2 *C.GdkRGBA // out

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (C.GtkStateFlags)(state)

	C.gtk_style_context_get_color(arg0, arg1, &arg2)

	var ret0 *gdk.RGBA

	{
		ret0 = gdk.WrapRGBA(unsafe.Pointer(arg2))
	}

	return ret0
}

// Direction returns the widget direction used for rendering.
func (context styleContext) Direction() TextDirection {
	var arg0 *C.GtkStyleContext

	arg0 = (*C.GtkStyleContext)(context.Native())

	ret := C.gtk_style_context_get_direction(arg0)

	var ret0 TextDirection

	ret0 = TextDirection(ret)

	return ret0
}

// Font returns the font description for a given state. The returned object
// is const and will remain valid until the StyleContext::changed signal
// happens.
func (context styleContext) Font(state StateFlags) *pango.FontDescription {
	var arg0 *C.GtkStyleContext
	var arg1 C.GtkStateFlags

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (C.GtkStateFlags)(state)

	ret := C.gtk_style_context_get_font(arg0, arg1)

	var ret0 *pango.FontDescription

	{
		ret0 = pango.WrapFontDescription(unsafe.Pointer(ret))
	}

	return ret0
}

// FrameClock returns the FrameClock to which @context is attached.
func (context styleContext) FrameClock() gdk.FrameClock {
	var arg0 *C.GtkStyleContext

	arg0 = (*C.GtkStyleContext)(context.Native())

	ret := C.gtk_style_context_get_frame_clock(arg0)

	var ret0 gdk.FrameClock

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gdk.FrameClock)

	return ret0
}

// JunctionSides returns the sides where rendered elements connect visually
// with others.
func (context styleContext) JunctionSides() JunctionSides {
	var arg0 *C.GtkStyleContext

	arg0 = (*C.GtkStyleContext)(context.Native())

	ret := C.gtk_style_context_get_junction_sides(arg0)

	var ret0 JunctionSides

	ret0 = JunctionSides(ret)

	return ret0
}

// Margin gets the margin for a given state as a Border. See
// gtk_style_property_get() and K_STYLE_PROPERTY_MARGIN for details.
func (context styleContext) Margin(state StateFlags) Border {
	var arg0 *C.GtkStyleContext
	var arg1 C.GtkStateFlags
	var arg2 *C.GtkBorder // out

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (C.GtkStateFlags)(state)

	C.gtk_style_context_get_margin(arg0, arg1, &arg2)

	var ret0 *Border

	{
		ret0 = WrapBorder(unsafe.Pointer(arg2))
	}

	return ret0
}

// Padding gets the padding for a given state as a Border. See
// gtk_style_context_get() and K_STYLE_PROPERTY_PADDING for details.
func (context styleContext) Padding(state StateFlags) Border {
	var arg0 *C.GtkStyleContext
	var arg1 C.GtkStateFlags
	var arg2 *C.GtkBorder // out

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (C.GtkStateFlags)(state)

	C.gtk_style_context_get_padding(arg0, arg1, &arg2)

	var ret0 *Border

	{
		ret0 = WrapBorder(unsafe.Pointer(arg2))
	}

	return ret0
}

// Parent gets the parent context set via gtk_style_context_set_parent().
// See that function for details.
func (context styleContext) Parent() StyleContext {
	var arg0 *C.GtkStyleContext

	arg0 = (*C.GtkStyleContext)(context.Native())

	ret := C.gtk_style_context_get_parent(arg0)

	var ret0 StyleContext

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(StyleContext)

	return ret0
}

// Path returns the widget path used for style matching.
func (context styleContext) Path() *WidgetPath {
	var arg0 *C.GtkStyleContext

	arg0 = (*C.GtkStyleContext)(context.Native())

	ret := C.gtk_style_context_get_path(arg0)

	var ret0 *WidgetPath

	{
		ret0 = WrapWidgetPath(unsafe.Pointer(ret))
	}

	return ret0
}

// Property gets a style property from @context for the given state.
//
// Note that not all CSS properties that are supported by GTK+ can be
// retrieved in this way, since they may not be representable as #GValue.
// GTK+ defines macros for a number of properties that can be used with this
// function.
//
// Note that passing a state other than the current state of @context is not
// recommended unless the style context has been saved with
// gtk_style_context_save().
//
// When @value is no longer needed, g_value_unset() must be called to free
// any allocated memory.
func (context styleContext) Property(property string, state StateFlags) externglib.Value {
	var arg0 *C.GtkStyleContext
	var arg1 *C.gchar
	var arg2 C.GtkStateFlags
	var arg3 *C.GValue // out

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (*C.gchar)(C.CString(property))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GtkStateFlags)(state)

	C.gtk_style_context_get_property(arg0, arg1, arg2, &arg3)

	var ret0 *externglib.Value

	ret0 = externglib.ValueFromNative(unsafe.Pointer(arg3))
	runtime.SetFinalizer(ret0, func(v *externglib.Value) {
		C.g_value_unset((*C.GValue)(v.GValue))
	})

	return ret0
}

// Scale returns the scale used for assets.
func (context styleContext) Scale() int {
	var arg0 *C.GtkStyleContext

	arg0 = (*C.GtkStyleContext)(context.Native())

	ret := C.gtk_style_context_get_scale(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Screen returns the Screen to which @context is attached.
func (context styleContext) Screen() gdk.Screen {
	var arg0 *C.GtkStyleContext

	arg0 = (*C.GtkStyleContext)(context.Native())

	ret := C.gtk_style_context_get_screen(arg0)

	var ret0 gdk.Screen

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gdk.Screen)

	return ret0
}

// Section queries the location in the CSS where @property was defined for
// the current @context. Note that the state to be queried is taken from
// gtk_style_context_get_state().
//
// If the location is not available, nil will be returned. The location
// might not be available for various reasons, such as the property being
// overridden, @property not naming a supported CSS property or tracking of
// definitions being disabled for performance reasons.
//
// Shorthand CSS properties cannot be queried for a location and will always
// return nil.
func (context styleContext) Section(property string) *CSSSection {
	var arg0 *C.GtkStyleContext
	var arg1 *C.gchar

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (*C.gchar)(C.CString(property))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_style_context_get_section(arg0, arg1)

	var ret0 *CSSSection

	{
		ret0 = WrapCSSSection(unsafe.Pointer(ret))
	}

	return ret0
}

// State returns the state used for style matching.
//
// This method should only be used to retrieve the StateFlags to pass to
// StyleContext methods, like gtk_style_context_get_padding(). If you need
// to retrieve the current state of a Widget, use
// gtk_widget_get_state_flags().
func (context styleContext) State() StateFlags {
	var arg0 *C.GtkStyleContext

	arg0 = (*C.GtkStyleContext)(context.Native())

	ret := C.gtk_style_context_get_state(arg0)

	var ret0 StateFlags

	ret0 = StateFlags(ret)

	return ret0
}

// StyleProperty gets the value for a widget style property.
//
// When @value is no longer needed, g_value_unset() must be called to free
// any allocated memory.
func (context styleContext) StyleProperty(propertyName string, value *externglib.Value) {
	var arg0 *C.GtkStyleContext
	var arg1 *C.gchar
	var arg2 *C.GValue

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (*C.gchar)(C.CString(propertyName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GValue)(value.GValue)

	C.gtk_style_context_get_style_property(arg0, arg1, arg2)
}

// HasClass returns true if @context currently has defined the given class
// name.
func (context styleContext) HasClass(className string) bool {
	var arg0 *C.GtkStyleContext
	var arg1 *C.gchar

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (*C.gchar)(C.CString(className))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_style_context_has_class(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// HasRegion returns true if @context has the region defined. If
// @flags_return is not nil, it is set to the flags affecting the region.
func (context styleContext) HasRegion(regionName string) (flagsReturn RegionFlags, ok bool) {
	var arg0 *C.GtkStyleContext
	var arg1 *C.gchar
	var arg2 *C.GtkRegionFlags // out

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (*C.gchar)(C.CString(regionName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_style_context_has_region(arg0, arg1, &arg2)

	var ret0 *RegionFlags
	var ret1 bool

	ret0 = (*RegionFlags)(arg2)

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// Invalidate invalidates @context style information, so it will be
// reconstructed again. It is useful if you modify the @context and need the
// new information immediately.
func (context styleContext) Invalidate() {
	var arg0 *C.GtkStyleContext

	arg0 = (*C.GtkStyleContext)(context.Native())

	C.gtk_style_context_invalidate(arg0)
}

// ListClasses returns the list of classes currently defined in @context.
func (context styleContext) ListClasses() *glib.List {
	var arg0 *C.GtkStyleContext

	arg0 = (*C.GtkStyleContext)(context.Native())

	ret := C.gtk_style_context_list_classes(arg0)

	var ret0 *glib.List

	{
		ret0 = glib.WrapList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.List) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// ListRegions returns the list of regions currently defined in @context.
func (context styleContext) ListRegions() *glib.List {
	var arg0 *C.GtkStyleContext

	arg0 = (*C.GtkStyleContext)(context.Native())

	ret := C.gtk_style_context_list_regions(arg0)

	var ret0 *glib.List

	{
		ret0 = glib.WrapList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.List) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// LookupColor looks up and resolves a color name in the @context color map.
func (context styleContext) LookupColor(colorName string) (color gdk.RGBA, ok bool) {
	var arg0 *C.GtkStyleContext
	var arg1 *C.gchar
	var arg2 *C.GdkRGBA // out

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (*C.gchar)(C.CString(colorName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_style_context_lookup_color(arg0, arg1, &arg2)

	var ret0 *gdk.RGBA
	var ret1 bool

	{
		ret0 = gdk.WrapRGBA(unsafe.Pointer(arg2))
	}

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// LookupIconSet looks up @stock_id in the icon factories associated to
// @context and the default icon factory, returning an icon set if found,
// otherwise nil.
func (context styleContext) LookupIconSet(stockID string) *IconSet {
	var arg0 *C.GtkStyleContext
	var arg1 *C.gchar

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (*C.gchar)(C.CString(stockID))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_style_context_lookup_icon_set(arg0, arg1)

	var ret0 *IconSet

	{
		ret0 = WrapIconSet(unsafe.Pointer(ret))
	}

	return ret0
}

// NotifyStateChange notifies a state change on @context, so if the current
// style makes use of transition animations, one will be started so all
// rendered elements under @region_id are animated for state @state being
// set to value @state_value.
//
// The @window parameter is used in order to invalidate the rendered area as
// the animation runs, so make sure it is the same window that is being
// rendered on by the gtk_render_*() functions.
//
// If @region_id is nil, all rendered elements using @context will be
// affected by this state transition.
//
// As a practical example, a Button notifying a state transition on the
// prelight state: |[ <!-- language="C" -->
// gtk_style_context_notify_state_change (context, gtk_widget_get_window
// (widget), NULL, GTK_STATE_PRELIGHT, button->in_button); ]|
//
// Can be handled in the CSS file like this: |[ <!-- language="CSS" -->
// button { background-color: #f00 }
//
// button:hover { background-color: #fff; transition: 200ms linear } ]|
//
// This combination will animate the button background from red to white if
// a pointer enters the button, and back to red if the pointer leaves the
// button.
//
// Note that @state is used when finding the transition parameters, which is
// why the style places the transition under the :hover pseudo-class.
func (context styleContext) NotifyStateChange(window gdk.Window, regionID interface{}, state StateType, stateValue bool) {
	var arg0 *C.GtkStyleContext
	var arg1 *C.GdkWindow
	var arg2 C.gpointer
	var arg3 C.GtkStateType
	var arg4 C.gboolean

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (*C.GdkWindow)(window.Native())
	arg2 = C.gpointer(box.Assign(regionID))
	arg3 = (C.GtkStateType)(state)
	if stateValue {
		arg4 = C.TRUE
	}

	C.gtk_style_context_notify_state_change(arg0, arg1, arg2, arg3, arg4)
}

// PopAnimatableRegion pops an animatable region from @context. See
// gtk_style_context_push_animatable_region().
func (context styleContext) PopAnimatableRegion() {
	var arg0 *C.GtkStyleContext

	arg0 = (*C.GtkStyleContext)(context.Native())

	C.gtk_style_context_pop_animatable_region(arg0)
}

// PushAnimatableRegion pushes an animatable region, so all further
// gtk_render_*() calls between this call and the following
// gtk_style_context_pop_animatable_region() will potentially show
// transition animations for this region if
// gtk_style_context_notify_state_change() is called for a given state, and
// the current theme/style defines transition animations for state changes.
//
// The @region_id used must be unique in @context so the themes can uniquely
// identify rendered elements subject to a state transition.
func (context styleContext) PushAnimatableRegion(regionID interface{}) {
	var arg0 *C.GtkStyleContext
	var arg1 C.gpointer

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = C.gpointer(box.Assign(regionID))

	C.gtk_style_context_push_animatable_region(arg0, arg1)
}

// RemoveClass removes @class_name from @context.
func (context styleContext) RemoveClass(className string) {
	var arg0 *C.GtkStyleContext
	var arg1 *C.gchar

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (*C.gchar)(C.CString(className))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_style_context_remove_class(arg0, arg1)
}

// RemoveProvider removes @provider from the style providers list in
// @context.
func (context styleContext) RemoveProvider(provider StyleProvider) {
	var arg0 *C.GtkStyleContext
	var arg1 *C.GtkStyleProvider

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (*C.GtkStyleProvider)(provider.Native())

	C.gtk_style_context_remove_provider(arg0, arg1)
}

// RemoveRegion removes a region from @context.
func (context styleContext) RemoveRegion(regionName string) {
	var arg0 *C.GtkStyleContext
	var arg1 *C.gchar

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (*C.gchar)(C.CString(regionName))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_style_context_remove_region(arg0, arg1)
}

// Restore restores @context state to a previous stage. See
// gtk_style_context_save().
func (context styleContext) Restore() {
	var arg0 *C.GtkStyleContext

	arg0 = (*C.GtkStyleContext)(context.Native())

	C.gtk_style_context_restore(arg0)
}

// Save saves the @context state, so temporary modifications done through
// gtk_style_context_add_class(), gtk_style_context_remove_class(),
// gtk_style_context_set_state(), etc. can quickly be reverted in one go
// through gtk_style_context_restore().
//
// The matching call to gtk_style_context_restore() must be done before GTK
// returns to the main loop.
func (context styleContext) Save() {
	var arg0 *C.GtkStyleContext

	arg0 = (*C.GtkStyleContext)(context.Native())

	C.gtk_style_context_save(arg0)
}

// ScrollAnimations: this function is analogous to gdk_window_scroll(), and
// should be called together with it so the invalidation areas for any
// ongoing animation are scrolled together with it.
func (context styleContext) ScrollAnimations(window gdk.Window, dx int, dy int) {
	var arg0 *C.GtkStyleContext
	var arg1 *C.GdkWindow
	var arg2 C.gint
	var arg3 C.gint

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (*C.GdkWindow)(window.Native())
	arg2 = C.gint(dx)
	arg3 = C.gint(dy)

	C.gtk_style_context_scroll_animations(arg0, arg1, arg2, arg3)
}

// SetBackground sets the background of @window to the background pattern or
// color specified in @context for its current state.
func (context styleContext) SetBackground(window gdk.Window) {
	var arg0 *C.GtkStyleContext
	var arg1 *C.GdkWindow

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (*C.GdkWindow)(window.Native())

	C.gtk_style_context_set_background(arg0, arg1)
}

// SetDirection sets the reading direction for rendering purposes.
//
// If you are using a StyleContext returned from
// gtk_widget_get_style_context(), you do not need to call this yourself.
func (context styleContext) SetDirection(direction TextDirection) {
	var arg0 *C.GtkStyleContext
	var arg1 C.GtkTextDirection

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (C.GtkTextDirection)(direction)

	C.gtk_style_context_set_direction(arg0, arg1)
}

// SetFrameClock attaches @context to the given frame clock.
//
// The frame clock is used for the timing of animations.
//
// If you are using a StyleContext returned from
// gtk_widget_get_style_context(), you do not need to call this yourself.
func (context styleContext) SetFrameClock(frameClock gdk.FrameClock) {
	var arg0 *C.GtkStyleContext
	var arg1 *C.GdkFrameClock

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (*C.GdkFrameClock)(frameClock.Native())

	C.gtk_style_context_set_frame_clock(arg0, arg1)
}

// SetJunctionSides sets the sides where rendered elements (mostly through
// gtk_render_frame()) will visually connect with other visual elements.
//
// This is merely a hint that may or may not be honored by themes.
//
// Container widgets are expected to set junction hints as appropriate for
// their children, so it should not normally be necessary to call this
// function manually.
func (context styleContext) SetJunctionSides(sides JunctionSides) {
	var arg0 *C.GtkStyleContext
	var arg1 C.GtkJunctionSides

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (C.GtkJunctionSides)(sides)

	C.gtk_style_context_set_junction_sides(arg0, arg1)
}

// SetParent sets the parent style context for @context. The parent style
// context is used to implement inheritance
// (http://www.w3.org/TR/css3-cascade/#inheritance) of properties.
//
// If you are using a StyleContext returned from
// gtk_widget_get_style_context(), the parent will be set for you.
func (context styleContext) SetParent(parent StyleContext) {
	var arg0 *C.GtkStyleContext
	var arg1 *C.GtkStyleContext

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (*C.GtkStyleContext)(parent.Native())

	C.gtk_style_context_set_parent(arg0, arg1)
}

// SetPath sets the WidgetPath used for style matching. As a consequence,
// the style will be regenerated to match the new given path.
//
// If you are using a StyleContext returned from
// gtk_widget_get_style_context(), you do not need to call this yourself.
func (context styleContext) SetPath(path *WidgetPath) {
	var arg0 *C.GtkStyleContext
	var arg1 *C.GtkWidgetPath

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (*C.GtkWidgetPath)(path.Native())

	C.gtk_style_context_set_path(arg0, arg1)
}

// SetScale sets the scale to use when getting image assets for the style.
func (context styleContext) SetScale(scale int) {
	var arg0 *C.GtkStyleContext
	var arg1 C.gint

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = C.gint(scale)

	C.gtk_style_context_set_scale(arg0, arg1)
}

// SetScreen attaches @context to the given screen.
//
// The screen is used to add style information from “global” style
// providers, such as the screen’s Settings instance.
//
// If you are using a StyleContext returned from
// gtk_widget_get_style_context(), you do not need to call this yourself.
func (context styleContext) SetScreen(screen gdk.Screen) {
	var arg0 *C.GtkStyleContext
	var arg1 *C.GdkScreen

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (*C.GdkScreen)(screen.Native())

	C.gtk_style_context_set_screen(arg0, arg1)
}

// SetState sets the state to be used for style matching.
func (context styleContext) SetState(flags StateFlags) {
	var arg0 *C.GtkStyleContext
	var arg1 C.GtkStateFlags

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (C.GtkStateFlags)(flags)

	C.gtk_style_context_set_state(arg0, arg1)
}

// StateIsRunning returns true if there is a transition animation running
// for the current region (see gtk_style_context_push_animatable_region()).
//
// If @progress is not nil, the animation progress will be returned there,
// 0.0 means the state is closest to being unset, while 1.0 means it’s
// closest to being set. This means transition animation will run from 0 to
// 1 when @state is being set and from 1 to 0 when it’s being unset.
func (context styleContext) StateIsRunning(state StateType) (progress float64, ok bool) {
	var arg0 *C.GtkStyleContext
	var arg1 C.GtkStateType
	var arg2 *C.gdouble // out

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (C.GtkStateType)(state)

	ret := C.gtk_style_context_state_is_running(arg0, arg1, &arg2)

	var ret0 float64
	var ret1 bool

	ret0 = float64(arg2)

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// String converts the style context into a string representation.
//
// The string representation always includes information about the name,
// state, id, visibility and style classes of the CSS node that is backing
// @context. Depending on the flags, more information may be included.
//
// This function is intended for testing and debugging of the CSS
// implementation in GTK+. There are no guarantees about the format of the
// returned string, it may change.
func (context styleContext) String(flags StyleContextPrintFlags) string {
	var arg0 *C.GtkStyleContext
	var arg1 C.GtkStyleContextPrintFlags

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (C.GtkStyleContextPrintFlags)(flags)

	ret := C.gtk_style_context_to_string(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// StyleProperties gtkStyleProperties provides the storage for style information
// that is used by StyleContext and other StyleProvider implementations.
//
// Before style properties can be stored in GtkStyleProperties, they must be
// registered with gtk_style_properties_register_property().
//
// Unless you are writing a StyleProvider implementation, you are unlikely to
// use this API directly, as gtk_style_context_get() and its variants are the
// preferred way to access styling information from widget implementations and
// theming engine implementations should use the APIs provided by ThemingEngine
// instead.
//
// StyleProperties has been deprecated in GTK 3.16. The CSS machinery does not
// use it anymore and all users of this object have been deprecated.
type StyleProperties interface {
	gextras.Objector
	StyleProvider

	// Clear clears all style information from @props.
	Clear()
	// Property gets a style property from @props for the given state. When done
	// with @value, g_value_unset() needs to be called to free any allocated
	// memory.
	Property(property string, state StateFlags) (value externglib.Value, ok bool)
	// LookupColor returns the symbolic color that is mapped to @name.
	LookupColor(name string) *SymbolicColor
	// MapColor maps @color so it can be referenced by @name. See
	// gtk_style_properties_lookup_color()
	MapColor(name string, color *SymbolicColor)
	// Merge merges into @props all the style information contained in
	// @props_to_merge. If @replace is true, the values will be overwritten, if
	// it is false, the older values will prevail.
	Merge(propsToMerge StyleProperties, replace bool)
	// SetProperty sets a styling property in @props.
	SetProperty(property string, state StateFlags, value *externglib.Value)
	// UnsetProperty unsets a style property in @props.
	UnsetProperty(property string, state StateFlags)
}

// styleProperties implements the StyleProperties interface.
type styleProperties struct {
	gextras.Objector
	StyleProvider
}

var _ StyleProperties = (*styleProperties)(nil)

// WrapStyleProperties wraps a GObject to the right type. It is
// primarily used internally.
func WrapStyleProperties(obj *externglib.Object) StyleProperties {
	return StyleProperties{
		Objector:      obj,
		StyleProvider: WrapStyleProvider(obj),
	}
}

func marshalStyleProperties(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStyleProperties(obj), nil
}

// NewStyleProperties constructs a class StyleProperties.
func NewStyleProperties() StyleProperties {

	ret := C.gtk_style_properties_new()

	var ret0 StyleProperties

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(StyleProperties)

	return ret0
}

// Clear clears all style information from @props.
func (props styleProperties) Clear() {
	var arg0 *C.GtkStyleProperties

	arg0 = (*C.GtkStyleProperties)(props.Native())

	C.gtk_style_properties_clear(arg0)
}

// Property gets a style property from @props for the given state. When done
// with @value, g_value_unset() needs to be called to free any allocated
// memory.
func (props styleProperties) Property(property string, state StateFlags) (value externglib.Value, ok bool) {
	var arg0 *C.GtkStyleProperties
	var arg1 *C.gchar
	var arg2 C.GtkStateFlags
	var arg3 *C.GValue // out

	arg0 = (*C.GtkStyleProperties)(props.Native())
	arg1 = (*C.gchar)(C.CString(property))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GtkStateFlags)(state)

	ret := C.gtk_style_properties_get_property(arg0, arg1, arg2, &arg3)

	var ret0 *externglib.Value
	var ret1 bool

	ret0 = externglib.ValueFromNative(unsafe.Pointer(arg3))
	runtime.SetFinalizer(ret0, func(v *externglib.Value) {
		C.g_value_unset((*C.GValue)(v.GValue))
	})

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// LookupColor returns the symbolic color that is mapped to @name.
func (props styleProperties) LookupColor(name string) *SymbolicColor {
	var arg0 *C.GtkStyleProperties
	var arg1 *C.gchar

	arg0 = (*C.GtkStyleProperties)(props.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_style_properties_lookup_color(arg0, arg1)

	var ret0 *SymbolicColor

	{
		ret0 = WrapSymbolicColor(unsafe.Pointer(ret))
	}

	return ret0
}

// MapColor maps @color so it can be referenced by @name. See
// gtk_style_properties_lookup_color()
func (props styleProperties) MapColor(name string, color *SymbolicColor) {
	var arg0 *C.GtkStyleProperties
	var arg1 *C.gchar
	var arg2 *C.GtkSymbolicColor

	arg0 = (*C.GtkStyleProperties)(props.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GtkSymbolicColor)(color.Native())

	C.gtk_style_properties_map_color(arg0, arg1, arg2)
}

// Merge merges into @props all the style information contained in
// @props_to_merge. If @replace is true, the values will be overwritten, if
// it is false, the older values will prevail.
func (props styleProperties) Merge(propsToMerge StyleProperties, replace bool) {
	var arg0 *C.GtkStyleProperties
	var arg1 *C.GtkStyleProperties
	var arg2 C.gboolean

	arg0 = (*C.GtkStyleProperties)(props.Native())
	arg1 = (*C.GtkStyleProperties)(propsToMerge.Native())
	if replace {
		arg2 = C.TRUE
	}

	C.gtk_style_properties_merge(arg0, arg1, arg2)
}

// SetProperty sets a styling property in @props.
func (props styleProperties) SetProperty(property string, state StateFlags, value *externglib.Value) {
	var arg0 *C.GtkStyleProperties
	var arg1 *C.gchar
	var arg2 C.GtkStateFlags
	var arg3 *C.GValue

	arg0 = (*C.GtkStyleProperties)(props.Native())
	arg1 = (*C.gchar)(C.CString(property))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GtkStateFlags)(state)
	arg3 = (*C.GValue)(value.GValue)

	C.gtk_style_properties_set_property(arg0, arg1, arg2, arg3)
}

// UnsetProperty unsets a style property in @props.
func (props styleProperties) UnsetProperty(property string, state StateFlags) {
	var arg0 *C.GtkStyleProperties
	var arg1 *C.gchar
	var arg2 C.GtkStateFlags

	arg0 = (*C.GtkStyleProperties)(props.Native())
	arg1 = (*C.gchar)(C.CString(property))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GtkStateFlags)(state)

	C.gtk_style_properties_unset_property(arg0, arg1, arg2)
}

// TextBuffer: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
type TextBuffer interface {
	gextras.Objector

	// AddMark adds the mark at position @where. The mark must not be added to
	// another buffer, and if its name is not nil then there must not be another
	// mark in the buffer with the same name.
	//
	// Emits the TextBuffer::mark-set signal as notification of the mark's
	// initial placement.
	AddMark(mark TextMark, where *TextIter)
	// AddSelectionClipboard adds @clipboard to the list of clipboards in which
	// the selection contents of @buffer are available. In most cases,
	// @clipboard will be the Clipboard of type GDK_SELECTION_PRIMARY for a view
	// of @buffer.
	AddSelectionClipboard(clipboard Clipboard)
	// ApplyTag emits the “apply-tag” signal on @buffer. The default handler for
	// the signal applies @tag to the given range. @start and @end do not have
	// to be in order.
	ApplyTag(tag TextTag, start *TextIter, end *TextIter)
	// ApplyTagByName calls gtk_text_tag_table_lookup() on the buffer’s tag
	// table to get a TextTag, then calls gtk_text_buffer_apply_tag().
	ApplyTagByName(name string, start *TextIter, end *TextIter)
	// Backspace performs the appropriate action as if the user hit the delete
	// key with the cursor at the position specified by @iter. In the normal
	// case a single character will be deleted, but when combining accents are
	// involved, more than one character can be deleted, and when precomposed
	// character and accent combinations are involved, less than one character
	// will be deleted.
	//
	// Because the buffer is modified, all outstanding iterators become invalid
	// after calling this function; however, the @iter will be re-initialized to
	// point to the location where text was deleted.
	Backspace(iter *TextIter, interactive bool, defaultEditable bool) bool
	// BeginUserAction: called to indicate that the buffer operations between
	// here and a call to gtk_text_buffer_end_user_action() are part of a single
	// user-visible operation. The operations between
	// gtk_text_buffer_begin_user_action() and gtk_text_buffer_end_user_action()
	// can then be grouped when creating an undo stack. TextBuffer maintains a
	// count of calls to gtk_text_buffer_begin_user_action() that have not been
	// closed with a call to gtk_text_buffer_end_user_action(), and emits the
	// “begin-user-action” and “end-user-action” signals only for the outermost
	// pair of calls. This allows you to build user actions from other user
	// actions.
	//
	// The “interactive” buffer mutation functions, such as
	// gtk_text_buffer_insert_interactive(), automatically call begin/end user
	// action around the buffer operations they perform, so there's no need to
	// add extra calls if you user action consists solely of a single call to
	// one of those functions.
	BeginUserAction()
	// CopyClipboard copies the currently-selected text to a clipboard.
	CopyClipboard(clipboard Clipboard)
	// CreateChildAnchor: this is a convenience function which simply creates a
	// child anchor with gtk_text_child_anchor_new() and inserts it into the
	// buffer with gtk_text_buffer_insert_child_anchor(). The new anchor is
	// owned by the buffer; no reference count is returned to the caller of
	// gtk_text_buffer_create_child_anchor().
	CreateChildAnchor(iter *TextIter) TextChildAnchor
	// CreateMark creates a mark at position @where. If @mark_name is nil, the
	// mark is anonymous; otherwise, the mark can be retrieved by name using
	// gtk_text_buffer_get_mark(). If a mark has left gravity, and text is
	// inserted at the mark’s current location, the mark will be moved to the
	// left of the newly-inserted text. If the mark has right gravity
	// (@left_gravity = false), the mark will end up on the right of
	// newly-inserted text. The standard left-to-right cursor is a mark with
	// right gravity (when you type, the cursor stays on the right side of the
	// text you’re typing).
	//
	// The caller of this function does not own a reference to the returned
	// TextMark, so you can ignore the return value if you like. Marks are owned
	// by the buffer and go away when the buffer does.
	//
	// Emits the TextBuffer::mark-set signal as notification of the mark's
	// initial placement.
	CreateMark(markName string, where *TextIter, leftGravity bool) TextMark
	// CutClipboard copies the currently-selected text to a clipboard, then
	// deletes said text if it’s editable.
	CutClipboard(clipboard Clipboard, defaultEditable bool)
	// Delete deletes text between @start and @end. The order of @start and @end
	// is not actually relevant; gtk_text_buffer_delete() will reorder them.
	// This function actually emits the “delete-range” signal, and the default
	// handler of that signal deletes the text. Because the buffer is modified,
	// all outstanding iterators become invalid after calling this function;
	// however, the @start and @end will be re-initialized to point to the
	// location where text was deleted.
	Delete(start *TextIter, end *TextIter)
	// DeleteInteractive deletes all editable text in the given range. Calls
	// gtk_text_buffer_delete() for each editable sub-range of [@start,@end).
	// @start and @end are revalidated to point to the location of the last
	// deleted range, or left untouched if no text was deleted.
	DeleteInteractive(startIter *TextIter, endIter *TextIter, defaultEditable bool) bool
	// DeleteMark deletes @mark, so that it’s no longer located anywhere in the
	// buffer. Removes the reference the buffer holds to the mark, so if you
	// haven’t called g_object_ref() on the mark, it will be freed. Even if the
	// mark isn’t freed, most operations on @mark become invalid, until it gets
	// added to a buffer again with gtk_text_buffer_add_mark(). Use
	// gtk_text_mark_get_deleted() to find out if a mark has been removed from
	// its buffer. The TextBuffer::mark-deleted signal will be emitted as
	// notification after the mark is deleted.
	DeleteMark(mark TextMark)
	// DeleteMarkByName deletes the mark named @name; the mark must exist. See
	// gtk_text_buffer_delete_mark() for details.
	DeleteMarkByName(name string)
	// DeleteSelection deletes the range between the “insert” and
	// “selection_bound” marks, that is, the currently-selected text. If
	// @interactive is true, the editability of the selection will be considered
	// (users can’t delete uneditable text).
	DeleteSelection(interactive bool, defaultEditable bool) bool
	// Deserialize: this function deserializes rich text in format @format and
	// inserts it at @iter.
	//
	// @formats to be used must be registered using
	// gtk_text_buffer_register_deserialize_format() or
	// gtk_text_buffer_register_deserialize_tagset() beforehand.
	Deserialize(contentBuffer TextBuffer, format gdk.Atom, iter *TextIter, data []byte) error
	// DeserializeGetCanCreateTags: this functions returns the value set with
	// gtk_text_buffer_deserialize_set_can_create_tags()
	DeserializeGetCanCreateTags(format gdk.Atom) bool
	// DeserializeSetCanCreateTags: use this function to allow a rich text
	// deserialization function to create new tags in the receiving buffer. Note
	// that using this function is almost always a bad idea, because the rich
	// text functions you register should know how to map the rich text format
	// they handler to your text buffers set of tags.
	//
	// The ability of creating new (arbitrary!) tags in the receiving buffer is
	// meant for special rich text formats like the internal one that is
	// registered using gtk_text_buffer_register_deserialize_tagset(), because
	// that format is essentially a dump of the internal structure of the source
	// buffer, including its tag names.
	//
	// You should allow creation of tags only if you know what you are doing,
	// e.g. if you defined a tagset name for your application suite’s text
	// buffers and you know that it’s fine to receive new tags from these
	// buffers, because you know that your application can handle the newly
	// created tags.
	DeserializeSetCanCreateTags(format gdk.Atom, canCreateTags bool)
	// EndUserAction: should be paired with a call to
	// gtk_text_buffer_begin_user_action(). See that function for a full
	// explanation.
	EndUserAction()
	// Bounds retrieves the first and last iterators in the buffer, i.e. the
	// entire buffer lies within the range [@start,@end).
	Bounds() (start TextIter, end TextIter)
	// CharCount gets the number of characters in the buffer; note that
	// characters and bytes are not the same, you can’t e.g. expect the contents
	// of the buffer in string form to be this many bytes long. The character
	// count is cached, so this function is very fast.
	CharCount() int
	// CopyTargetList: this function returns the list of targets this text
	// buffer can provide for copying and as DND source. The targets in the list
	// are added with @info values from the TextBufferTargetInfo enum, using
	// gtk_target_list_add_rich_text_targets() and
	// gtk_target_list_add_text_targets().
	CopyTargetList() *TargetList
	// DeserializeFormats: this function returns the rich text deserialize
	// formats registered with @buffer using
	// gtk_text_buffer_register_deserialize_format() or
	// gtk_text_buffer_register_deserialize_tagset()
	DeserializeFormats() (nFormats int, atoms []gdk.Atom)
	// EndIter initializes @iter with the “end iterator,” one past the last
	// valid character in the text buffer. If dereferenced with
	// gtk_text_iter_get_char(), the end iterator has a character value of 0.
	// The entire buffer lies in the range from the first position in the buffer
	// (call gtk_text_buffer_get_start_iter() to get character position 0) to
	// the end iterator.
	EndIter() TextIter
	// HasSelection indicates whether the buffer has some text currently
	// selected.
	HasSelection() bool
	// GetInsert returns the mark that represents the cursor (insertion point).
	// Equivalent to calling gtk_text_buffer_get_mark() to get the mark named
	// “insert”, but very slightly more efficient, and involves less typing.
	GetInsert() TextMark
	// IterAtChildAnchor obtains the location of @anchor within @buffer.
	IterAtChildAnchor(anchor TextChildAnchor) TextIter
	// IterAtLine initializes @iter to the start of the given line. If
	// @line_number is greater than the number of lines in the @buffer, the end
	// iterator is returned.
	IterAtLine(lineNumber int) TextIter
	// IterAtLineIndex obtains an iterator pointing to @byte_index within the
	// given line. @byte_index must be the start of a UTF-8 character. Note
	// bytes, not characters; UTF-8 may encode one character as multiple bytes.
	//
	// Before the 3.20 version, it was not allowed to pass an invalid location.
	//
	// Since the 3.20 version, if @line_number is greater than the number of
	// lines in the @buffer, the end iterator is returned. And if @byte_index is
	// off the end of the line, the iterator at the end of the line is returned.
	IterAtLineIndex(lineNumber int, byteIndex int) TextIter
	// IterAtLineOffset obtains an iterator pointing to @char_offset within the
	// given line. Note characters, not bytes; UTF-8 may encode one character as
	// multiple bytes.
	//
	// Before the 3.20 version, it was not allowed to pass an invalid location.
	//
	// Since the 3.20 version, if @line_number is greater than the number of
	// lines in the @buffer, the end iterator is returned. And if @char_offset
	// is off the end of the line, the iterator at the end of the line is
	// returned.
	IterAtLineOffset(lineNumber int, charOffset int) TextIter
	// IterAtMark initializes @iter with the current position of @mark.
	IterAtMark(mark TextMark) TextIter
	// IterAtOffset initializes @iter to a position @char_offset chars from the
	// start of the entire buffer. If @char_offset is -1 or greater than the
	// number of characters in the buffer, @iter is initialized to the end
	// iterator, the iterator one past the last valid character in the buffer.
	IterAtOffset(charOffset int) TextIter
	// LineCount obtains the number of lines in the buffer. This value is
	// cached, so the function is very fast.
	LineCount() int
	// Mark returns the mark named @name in buffer @buffer, or nil if no such
	// mark exists in the buffer.
	Mark(name string) TextMark
	// Modified indicates whether the buffer has been modified since the last
	// call to gtk_text_buffer_set_modified() set the modification flag to
	// false. Used for example to enable a “save” function in a text editor.
	Modified() bool
	// PasteTargetList: this function returns the list of targets this text
	// buffer supports for pasting and as DND destination. The targets in the
	// list are added with @info values from the TextBufferTargetInfo enum,
	// using gtk_target_list_add_rich_text_targets() and
	// gtk_target_list_add_text_targets().
	PasteTargetList() *TargetList
	// SelectionBound returns the mark that represents the selection bound.
	// Equivalent to calling gtk_text_buffer_get_mark() to get the mark named
	// “selection_bound”, but very slightly more efficient, and involves less
	// typing.
	//
	// The currently-selected text in @buffer is the region between the
	// “selection_bound” and “insert” marks. If “selection_bound” and “insert”
	// are in the same place, then there is no current selection.
	// gtk_text_buffer_get_selection_bounds() is another convenient function for
	// handling the selection, if you just want to know whether there’s a
	// selection and what its bounds are.
	SelectionBound() TextMark
	// SelectionBounds returns true if some text is selected; places the bounds
	// of the selection in @start and @end (if the selection has length 0, then
	// @start and @end are filled in with the same value). @start and @end will
	// be in ascending order. If @start and @end are NULL, then they are not
	// filled in, but the return value still indicates whether text is selected.
	SelectionBounds() (start TextIter, end TextIter, ok bool)
	// SerializeFormats: this function returns the rich text serialize formats
	// registered with @buffer using gtk_text_buffer_register_serialize_format()
	// or gtk_text_buffer_register_serialize_tagset()
	SerializeFormats() (nFormats int, atoms []gdk.Atom)
	// Slice returns the text in the range [@start,@end). Excludes undisplayed
	// text (text marked with tags that set the invisibility attribute) if
	// @include_hidden_chars is false. The returned string includes a 0xFFFC
	// character whenever the buffer contains embedded images, so byte and
	// character indexes into the returned string do correspond to byte and
	// character indexes into the buffer. Contrast with
	// gtk_text_buffer_get_text(). Note that 0xFFFC can occur in normal text as
	// well, so it is not a reliable indicator that a pixbuf or widget is in the
	// buffer.
	Slice(start *TextIter, end *TextIter, includeHiddenChars bool) string
	// StartIter: initialized @iter with the first position in the text buffer.
	// This is the same as using gtk_text_buffer_get_iter_at_offset() to get the
	// iter at character offset 0.
	StartIter() TextIter
	// TagTable: get the TextTagTable associated with this buffer.
	TagTable() TextTagTable
	// Text returns the text in the range [@start,@end). Excludes undisplayed
	// text (text marked with tags that set the invisibility attribute) if
	// @include_hidden_chars is false. Does not include characters representing
	// embedded images, so byte and character indexes into the returned string
	// do not correspond to byte and character indexes into the buffer. Contrast
	// with gtk_text_buffer_get_slice().
	Text(start *TextIter, end *TextIter, includeHiddenChars bool) string
	// Insert inserts @len bytes of @text at position @iter. If @len is -1,
	// @text must be nul-terminated and will be inserted in its entirety. Emits
	// the “insert-text” signal; insertion actually occurs in the default
	// handler for the signal. @iter is invalidated when insertion occurs
	// (because the buffer contents change), but the default signal handler
	// revalidates it to point to the end of the inserted text.
	Insert(iter *TextIter, text string, len int)
	// InsertAtCursor: simply calls gtk_text_buffer_insert(), using the current
	// cursor position as the insertion point.
	InsertAtCursor(text string, len int)
	// InsertChildAnchor inserts a child widget anchor into the text buffer at
	// @iter. The anchor will be counted as one character in character counts,
	// and when obtaining the buffer contents as a string, will be represented
	// by the Unicode “object replacement character” 0xFFFC. Note that the
	// “slice” variants for obtaining portions of the buffer as a string include
	// this character for child anchors, but the “text” variants do not. E.g.
	// see gtk_text_buffer_get_slice() and gtk_text_buffer_get_text(). Consider
	// gtk_text_buffer_create_child_anchor() as a more convenient alternative to
	// this function. The buffer will add a reference to the anchor, so you can
	// unref it after insertion.
	InsertChildAnchor(iter *TextIter, anchor TextChildAnchor)
	// InsertInteractive: like gtk_text_buffer_insert(), but the insertion will
	// not occur if @iter is at a non-editable location in the buffer. Usually
	// you want to prevent insertions at ineditable locations if the insertion
	// results from a user action (is interactive).
	//
	// @default_editable indicates the editability of text that doesn't have a
	// tag affecting editability applied to it. Typically the result of
	// gtk_text_view_get_editable() is appropriate here.
	InsertInteractive(iter *TextIter, text string, len int, defaultEditable bool) bool
	// InsertInteractiveAtCursor calls gtk_text_buffer_insert_interactive() at
	// the cursor position.
	//
	// @default_editable indicates the editability of text that doesn't have a
	// tag affecting editability applied to it. Typically the result of
	// gtk_text_view_get_editable() is appropriate here.
	InsertInteractiveAtCursor(text string, len int, defaultEditable bool) bool
	// InsertMarkup inserts the text in @markup at position @iter. @markup will
	// be inserted in its entirety and must be nul-terminated and valid UTF-8.
	// Emits the TextBuffer::insert-text signal, possibly multiple times;
	// insertion actually occurs in the default handler for the signal. @iter
	// will point to the end of the inserted text on return.
	InsertMarkup(iter *TextIter, markup string, len int)
	// InsertPixbuf inserts an image into the text buffer at @iter. The image
	// will be counted as one character in character counts, and when obtaining
	// the buffer contents as a string, will be represented by the Unicode
	// “object replacement character” 0xFFFC. Note that the “slice” variants for
	// obtaining portions of the buffer as a string include this character for
	// pixbufs, but the “text” variants do not. e.g. see
	// gtk_text_buffer_get_slice() and gtk_text_buffer_get_text().
	InsertPixbuf(iter *TextIter, pixbuf gdkpixbuf.Pixbuf)
	// InsertRange copies text, tags, and pixbufs between @start and @end (the
	// order of @start and @end doesn’t matter) and inserts the copy at @iter.
	// Used instead of simply getting/inserting text because it preserves images
	// and tags. If @start and @end are in a different buffer from @buffer, the
	// two buffers must share the same tag table.
	//
	// Implemented via emissions of the insert_text and apply_tag signals, so
	// expect those.
	InsertRange(iter *TextIter, start *TextIter, end *TextIter)
	// InsertRangeInteractive: same as gtk_text_buffer_insert_range(), but does
	// nothing if the insertion point isn’t editable. The @default_editable
	// parameter indicates whether the text is editable at @iter if no tags
	// enclosing @iter affect editability. Typically the result of
	// gtk_text_view_get_editable() is appropriate here.
	InsertRangeInteractive(iter *TextIter, start *TextIter, end *TextIter, defaultEditable bool) bool
	// MoveMark moves @mark to the new location @where. Emits the
	// TextBuffer::mark-set signal as notification of the move.
	MoveMark(mark TextMark, where *TextIter)
	// MoveMarkByName moves the mark named @name (which must exist) to location
	// @where. See gtk_text_buffer_move_mark() for details.
	MoveMarkByName(name string, where *TextIter)
	// PasteClipboard pastes the contents of a clipboard. If @override_location
	// is nil, the pasted text will be inserted at the cursor position, or the
	// buffer selection will be replaced if the selection is non-empty.
	//
	// Note: pasting is asynchronous, that is, we’ll ask for the paste data and
	// return, and at some point later after the main loop runs, the paste data
	// will be inserted.
	PasteClipboard(clipboard Clipboard, overrideLocation *TextIter, defaultEditable bool)
	// PlaceCursor: this function moves the “insert” and “selection_bound” marks
	// simultaneously. If you move them to the same place in two steps with
	// gtk_text_buffer_move_mark(), you will temporarily select a region in
	// between their old and new locations, which can be pretty inefficient
	// since the temporarily-selected region will force stuff to be
	// recalculated. This function moves them as a unit, which can be optimized.
	PlaceCursor(where *TextIter)
	// RegisterDeserializeFormat: this function registers a rich text
	// deserialization @function along with its @mime_type with the passed
	// @buffer.
	RegisterDeserializeFormat(mimeType string, function TextBufferDeserializeFunc) gdk.Atom
	// RegisterDeserializeTagset: this function registers GTK+’s internal rich
	// text serialization format with the passed @buffer. See
	// gtk_text_buffer_register_serialize_tagset() for details.
	RegisterDeserializeTagset(tagsetName string) gdk.Atom
	// RegisterSerializeFormat: this function registers a rich text
	// serialization @function along with its @mime_type with the passed
	// @buffer.
	RegisterSerializeFormat(mimeType string, function TextBufferSerializeFunc) gdk.Atom
	// RegisterSerializeTagset: this function registers GTK+’s internal rich
	// text serialization format with the passed @buffer. The internal format
	// does not comply to any standard rich text format and only works between
	// TextBuffer instances. It is capable of serializing all of a text buffer’s
	// tags and embedded pixbufs.
	//
	// This function is just a wrapper around
	// gtk_text_buffer_register_serialize_format(). The mime type used for
	// registering is “application/x-gtk-text-buffer-rich-text”, or
	// “application/x-gtk-text-buffer-rich-text;format=@tagset_name” if a
	// @tagset_name was passed.
	//
	// The @tagset_name can be used to restrict the transfer of rich text to
	// buffers with compatible sets of tags, in order to avoid unknown tags from
	// being pasted. It is probably the common case to pass an identifier != nil
	// here, since the nil tagset requires the receiving buffer to deal with
	// with pasting of arbitrary tags.
	RegisterSerializeTagset(tagsetName string) gdk.Atom
	// RemoveAllTags removes all tags in the range between @start and @end. Be
	// careful with this function; it could remove tags added in code unrelated
	// to the code you’re currently writing. That is, using this function is
	// probably a bad idea if you have two or more unrelated code sections that
	// add tags.
	RemoveAllTags(start *TextIter, end *TextIter)
	// RemoveSelectionClipboard removes a Clipboard added with
	// gtk_text_buffer_add_selection_clipboard().
	RemoveSelectionClipboard(clipboard Clipboard)
	// RemoveTag emits the “remove-tag” signal. The default handler for the
	// signal removes all occurrences of @tag from the given range. @start and
	// @end don’t have to be in order.
	RemoveTag(tag TextTag, start *TextIter, end *TextIter)
	// RemoveTagByName calls gtk_text_tag_table_lookup() on the buffer’s tag
	// table to get a TextTag, then calls gtk_text_buffer_remove_tag().
	RemoveTagByName(name string, start *TextIter, end *TextIter)
	// SelectRange: this function moves the “insert” and “selection_bound” marks
	// simultaneously. If you move them in two steps with
	// gtk_text_buffer_move_mark(), you will temporarily select a region in
	// between their old and new locations, which can be pretty inefficient
	// since the temporarily-selected region will force stuff to be
	// recalculated. This function moves them as a unit, which can be optimized.
	SelectRange(ins *TextIter, bound *TextIter)
	// Serialize: this function serializes the portion of text between @start
	// and @end in the rich text format represented by @format.
	//
	// @formats to be used must be registered using
	// gtk_text_buffer_register_serialize_format() or
	// gtk_text_buffer_register_serialize_tagset() beforehand.
	Serialize(contentBuffer TextBuffer, format gdk.Atom, start *TextIter, end *TextIter) (length uint, guint8s []byte)
	// SetModified: used to keep track of whether the buffer has been modified
	// since the last time it was saved. Whenever the buffer is saved to disk,
	// call gtk_text_buffer_set_modified (@buffer, FALSE). When the buffer is
	// modified, it will automatically toggled on the modified bit again. When
	// the modified bit flips, the buffer emits the TextBuffer::modified-changed
	// signal.
	SetModified(setting bool)
	// SetText deletes current contents of @buffer, and inserts @text instead.
	// If @len is -1, @text must be nul-terminated. @text must be valid UTF-8.
	SetText(text string, len int)
	// UnregisterDeserializeFormat: this function unregisters a rich text format
	// that was previously registered using
	// gtk_text_buffer_register_deserialize_format() or
	// gtk_text_buffer_register_deserialize_tagset().
	UnregisterDeserializeFormat(format gdk.Atom)
	// UnregisterSerializeFormat: this function unregisters a rich text format
	// that was previously registered using
	// gtk_text_buffer_register_serialize_format() or
	// gtk_text_buffer_register_serialize_tagset()
	UnregisterSerializeFormat(format gdk.Atom)
}

// textBuffer implements the TextBuffer interface.
type textBuffer struct {
	gextras.Objector
}

var _ TextBuffer = (*textBuffer)(nil)

// WrapTextBuffer wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextBuffer(obj *externglib.Object) TextBuffer {
	return TextBuffer{
		Objector: obj,
	}
}

func marshalTextBuffer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextBuffer(obj), nil
}

// NewTextBuffer constructs a class TextBuffer.
func NewTextBuffer(table TextTagTable) TextBuffer {
	var arg1 *C.GtkTextTagTable

	arg1 = (*C.GtkTextTagTable)(table.Native())

	ret := C.gtk_text_buffer_new(arg1)

	var ret0 TextBuffer

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(TextBuffer)

	return ret0
}

// AddMark adds the mark at position @where. The mark must not be added to
// another buffer, and if its name is not nil then there must not be another
// mark in the buffer with the same name.
//
// Emits the TextBuffer::mark-set signal as notification of the mark's
// initial placement.
func (buffer textBuffer) AddMark(mark TextMark, where *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextMark
	var arg2 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextMark)(mark.Native())
	arg2 = (*C.GtkTextIter)(where.Native())

	C.gtk_text_buffer_add_mark(arg0, arg1, arg2)
}

// AddSelectionClipboard adds @clipboard to the list of clipboards in which
// the selection contents of @buffer are available. In most cases,
// @clipboard will be the Clipboard of type GDK_SELECTION_PRIMARY for a view
// of @buffer.
func (buffer textBuffer) AddSelectionClipboard(clipboard Clipboard) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkClipboard

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkClipboard)(clipboard.Native())

	C.gtk_text_buffer_add_selection_clipboard(arg0, arg1)
}

// ApplyTag emits the “apply-tag” signal on @buffer. The default handler for
// the signal applies @tag to the given range. @start and @end do not have
// to be in order.
func (buffer textBuffer) ApplyTag(tag TextTag, start *TextIter, end *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextTag
	var arg2 *C.GtkTextIter
	var arg3 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextTag)(tag.Native())
	arg2 = (*C.GtkTextIter)(start.Native())
	arg3 = (*C.GtkTextIter)(end.Native())

	C.gtk_text_buffer_apply_tag(arg0, arg1, arg2, arg3)
}

// ApplyTagByName calls gtk_text_tag_table_lookup() on the buffer’s tag
// table to get a TextTag, then calls gtk_text_buffer_apply_tag().
func (buffer textBuffer) ApplyTagByName(name string, start *TextIter, end *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.gchar
	var arg2 *C.GtkTextIter
	var arg3 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GtkTextIter)(start.Native())
	arg3 = (*C.GtkTextIter)(end.Native())

	C.gtk_text_buffer_apply_tag_by_name(arg0, arg1, arg2, arg3)
}

// Backspace performs the appropriate action as if the user hit the delete
// key with the cursor at the position specified by @iter. In the normal
// case a single character will be deleted, but when combining accents are
// involved, more than one character can be deleted, and when precomposed
// character and accent combinations are involved, less than one character
// will be deleted.
//
// Because the buffer is modified, all outstanding iterators become invalid
// after calling this function; however, the @iter will be re-initialized to
// point to the location where text was deleted.
func (buffer textBuffer) Backspace(iter *TextIter, interactive bool, defaultEditable bool) bool {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 C.gboolean
	var arg3 C.gboolean

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextIter)(iter.Native())
	if interactive {
		arg2 = C.TRUE
	}
	if defaultEditable {
		arg3 = C.TRUE
	}

	ret := C.gtk_text_buffer_backspace(arg0, arg1, arg2, arg3)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// BeginUserAction: called to indicate that the buffer operations between
// here and a call to gtk_text_buffer_end_user_action() are part of a single
// user-visible operation. The operations between
// gtk_text_buffer_begin_user_action() and gtk_text_buffer_end_user_action()
// can then be grouped when creating an undo stack. TextBuffer maintains a
// count of calls to gtk_text_buffer_begin_user_action() that have not been
// closed with a call to gtk_text_buffer_end_user_action(), and emits the
// “begin-user-action” and “end-user-action” signals only for the outermost
// pair of calls. This allows you to build user actions from other user
// actions.
//
// The “interactive” buffer mutation functions, such as
// gtk_text_buffer_insert_interactive(), automatically call begin/end user
// action around the buffer operations they perform, so there's no need to
// add extra calls if you user action consists solely of a single call to
// one of those functions.
func (buffer textBuffer) BeginUserAction() {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	C.gtk_text_buffer_begin_user_action(arg0)
}

// CopyClipboard copies the currently-selected text to a clipboard.
func (buffer textBuffer) CopyClipboard(clipboard Clipboard) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkClipboard

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkClipboard)(clipboard.Native())

	C.gtk_text_buffer_copy_clipboard(arg0, arg1)
}

// CreateChildAnchor: this is a convenience function which simply creates a
// child anchor with gtk_text_child_anchor_new() and inserts it into the
// buffer with gtk_text_buffer_insert_child_anchor(). The new anchor is
// owned by the buffer; no reference count is returned to the caller of
// gtk_text_buffer_create_child_anchor().
func (buffer textBuffer) CreateChildAnchor(iter *TextIter) TextChildAnchor {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_buffer_create_child_anchor(arg0, arg1)

	var ret0 TextChildAnchor

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(TextChildAnchor)

	return ret0
}

// CreateMark creates a mark at position @where. If @mark_name is nil, the
// mark is anonymous; otherwise, the mark can be retrieved by name using
// gtk_text_buffer_get_mark(). If a mark has left gravity, and text is
// inserted at the mark’s current location, the mark will be moved to the
// left of the newly-inserted text. If the mark has right gravity
// (@left_gravity = false), the mark will end up on the right of
// newly-inserted text. The standard left-to-right cursor is a mark with
// right gravity (when you type, the cursor stays on the right side of the
// text you’re typing).
//
// The caller of this function does not own a reference to the returned
// TextMark, so you can ignore the return value if you like. Marks are owned
// by the buffer and go away when the buffer does.
//
// Emits the TextBuffer::mark-set signal as notification of the mark's
// initial placement.
func (buffer textBuffer) CreateMark(markName string, where *TextIter, leftGravity bool) TextMark {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.gchar
	var arg2 *C.GtkTextIter
	var arg3 C.gboolean

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.gchar)(C.CString(markName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GtkTextIter)(where.Native())
	if leftGravity {
		arg3 = C.TRUE
	}

	ret := C.gtk_text_buffer_create_mark(arg0, arg1, arg2, arg3)

	var ret0 TextMark

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(TextMark)

	return ret0
}

// CutClipboard copies the currently-selected text to a clipboard, then
// deletes said text if it’s editable.
func (buffer textBuffer) CutClipboard(clipboard Clipboard, defaultEditable bool) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkClipboard
	var arg2 C.gboolean

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkClipboard)(clipboard.Native())
	if defaultEditable {
		arg2 = C.TRUE
	}

	C.gtk_text_buffer_cut_clipboard(arg0, arg1, arg2)
}

// Delete deletes text between @start and @end. The order of @start and @end
// is not actually relevant; gtk_text_buffer_delete() will reorder them.
// This function actually emits the “delete-range” signal, and the default
// handler of that signal deletes the text. Because the buffer is modified,
// all outstanding iterators become invalid after calling this function;
// however, the @start and @end will be re-initialized to point to the
// location where text was deleted.
func (buffer textBuffer) Delete(start *TextIter, end *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextIter)(start.Native())
	arg2 = (*C.GtkTextIter)(end.Native())

	C.gtk_text_buffer_delete(arg0, arg1, arg2)
}

// DeleteInteractive deletes all editable text in the given range. Calls
// gtk_text_buffer_delete() for each editable sub-range of [@start,@end).
// @start and @end are revalidated to point to the location of the last
// deleted range, or left untouched if no text was deleted.
func (buffer textBuffer) DeleteInteractive(startIter *TextIter, endIter *TextIter, defaultEditable bool) bool {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextIter
	var arg3 C.gboolean

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextIter)(startIter.Native())
	arg2 = (*C.GtkTextIter)(endIter.Native())
	if defaultEditable {
		arg3 = C.TRUE
	}

	ret := C.gtk_text_buffer_delete_interactive(arg0, arg1, arg2, arg3)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// DeleteMark deletes @mark, so that it’s no longer located anywhere in the
// buffer. Removes the reference the buffer holds to the mark, so if you
// haven’t called g_object_ref() on the mark, it will be freed. Even if the
// mark isn’t freed, most operations on @mark become invalid, until it gets
// added to a buffer again with gtk_text_buffer_add_mark(). Use
// gtk_text_mark_get_deleted() to find out if a mark has been removed from
// its buffer. The TextBuffer::mark-deleted signal will be emitted as
// notification after the mark is deleted.
func (buffer textBuffer) DeleteMark(mark TextMark) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextMark

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextMark)(mark.Native())

	C.gtk_text_buffer_delete_mark(arg0, arg1)
}

// DeleteMarkByName deletes the mark named @name; the mark must exist. See
// gtk_text_buffer_delete_mark() for details.
func (buffer textBuffer) DeleteMarkByName(name string) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.gchar

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_text_buffer_delete_mark_by_name(arg0, arg1)
}

// DeleteSelection deletes the range between the “insert” and
// “selection_bound” marks, that is, the currently-selected text. If
// @interactive is true, the editability of the selection will be considered
// (users can’t delete uneditable text).
func (buffer textBuffer) DeleteSelection(interactive bool, defaultEditable bool) bool {
	var arg0 *C.GtkTextBuffer
	var arg1 C.gboolean
	var arg2 C.gboolean

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	if interactive {
		arg1 = C.TRUE
	}
	if defaultEditable {
		arg2 = C.TRUE
	}

	ret := C.gtk_text_buffer_delete_selection(arg0, arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Deserialize: this function deserializes rich text in format @format and
// inserts it at @iter.
//
// @formats to be used must be registered using
// gtk_text_buffer_register_deserialize_format() or
// gtk_text_buffer_register_deserialize_tagset() beforehand.
func (registerBuffer textBuffer) Deserialize(contentBuffer TextBuffer, format gdk.Atom, iter *TextIter, data []byte) error {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextBuffer
	var arg2 C.GdkAtom
	var arg3 *C.GtkTextIter
	var arg4 *C.guint8
	var arg5 C.gsize
	var gError *C.GError

	arg0 = (*C.GtkTextBuffer)(registerBuffer.Native())
	arg1 = (*C.GtkTextBuffer)(contentBuffer.Native())
	arg2 = (C.GdkAtom)(format.Native())
	arg3 = (*C.GtkTextIter)(iter.Native())
	arg4 = (*C.guint8)(unsafe.Pointer(&data[0]))
	arg5 = len(data)
	defer runtime.KeepAlive(data)

	ret := C.gtk_text_buffer_deserialize(arg0, arg1, arg2, arg3, arg4, arg5, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// DeserializeGetCanCreateTags: this functions returns the value set with
// gtk_text_buffer_deserialize_set_can_create_tags()
func (buffer textBuffer) DeserializeGetCanCreateTags(format gdk.Atom) bool {
	var arg0 *C.GtkTextBuffer
	var arg1 C.GdkAtom

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (C.GdkAtom)(format.Native())

	ret := C.gtk_text_buffer_deserialize_get_can_create_tags(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// DeserializeSetCanCreateTags: use this function to allow a rich text
// deserialization function to create new tags in the receiving buffer. Note
// that using this function is almost always a bad idea, because the rich
// text functions you register should know how to map the rich text format
// they handler to your text buffers set of tags.
//
// The ability of creating new (arbitrary!) tags in the receiving buffer is
// meant for special rich text formats like the internal one that is
// registered using gtk_text_buffer_register_deserialize_tagset(), because
// that format is essentially a dump of the internal structure of the source
// buffer, including its tag names.
//
// You should allow creation of tags only if you know what you are doing,
// e.g. if you defined a tagset name for your application suite’s text
// buffers and you know that it’s fine to receive new tags from these
// buffers, because you know that your application can handle the newly
// created tags.
func (buffer textBuffer) DeserializeSetCanCreateTags(format gdk.Atom, canCreateTags bool) {
	var arg0 *C.GtkTextBuffer
	var arg1 C.GdkAtom
	var arg2 C.gboolean

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (C.GdkAtom)(format.Native())
	if canCreateTags {
		arg2 = C.TRUE
	}

	C.gtk_text_buffer_deserialize_set_can_create_tags(arg0, arg1, arg2)
}

// EndUserAction: should be paired with a call to
// gtk_text_buffer_begin_user_action(). See that function for a full
// explanation.
func (buffer textBuffer) EndUserAction() {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	C.gtk_text_buffer_end_user_action(arg0)
}

// Bounds retrieves the first and last iterators in the buffer, i.e. the
// entire buffer lies within the range [@start,@end).
func (buffer textBuffer) Bounds() (start TextIter, end TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter // out
	var arg2 *C.GtkTextIter // out

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	C.gtk_text_buffer_get_bounds(arg0, &arg1, &arg2)

	var ret0 *TextIter
	var ret1 *TextIter

	{
		ret0 = WrapTextIter(unsafe.Pointer(arg1))
	}

	{
		ret1 = WrapTextIter(unsafe.Pointer(arg2))
	}

	return ret0, ret1
}

// CharCount gets the number of characters in the buffer; note that
// characters and bytes are not the same, you can’t e.g. expect the contents
// of the buffer in string form to be this many bytes long. The character
// count is cached, so this function is very fast.
func (buffer textBuffer) CharCount() int {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	ret := C.gtk_text_buffer_get_char_count(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// CopyTargetList: this function returns the list of targets this text
// buffer can provide for copying and as DND source. The targets in the list
// are added with @info values from the TextBufferTargetInfo enum, using
// gtk_target_list_add_rich_text_targets() and
// gtk_target_list_add_text_targets().
func (buffer textBuffer) CopyTargetList() *TargetList {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	ret := C.gtk_text_buffer_get_copy_target_list(arg0)

	var ret0 *TargetList

	{
		ret0 = WrapTargetList(unsafe.Pointer(ret))
	}

	return ret0
}

// DeserializeFormats: this function returns the rich text deserialize
// formats registered with @buffer using
// gtk_text_buffer_register_deserialize_format() or
// gtk_text_buffer_register_deserialize_tagset()
func (buffer textBuffer) DeserializeFormats() (nFormats int, atoms []gdk.Atom) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.gint // out

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	ret := C.gtk_text_buffer_get_deserialize_formats(arg0, &arg1)

	var ret0 int
	var ret1 []gdk.Atom

	ret0 = int(arg1)

	{
		ret1 = make([]gdk.Atom, arg1)
		for i := 0; i < uintptr(arg1); i++ {
			src := (C.GdkAtom)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			{
				ret1[i] = gdk.WrapAtom(unsafe.Pointer(src))
			}
		}
	}

	return ret0, ret1
}

// EndIter initializes @iter with the “end iterator,” one past the last
// valid character in the text buffer. If dereferenced with
// gtk_text_iter_get_char(), the end iterator has a character value of 0.
// The entire buffer lies in the range from the first position in the buffer
// (call gtk_text_buffer_get_start_iter() to get character position 0) to
// the end iterator.
func (buffer textBuffer) EndIter() TextIter {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter // out

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	C.gtk_text_buffer_get_end_iter(arg0, &arg1)

	var ret0 *TextIter

	{
		ret0 = WrapTextIter(unsafe.Pointer(arg1))
	}

	return ret0
}

// HasSelection indicates whether the buffer has some text currently
// selected.
func (buffer textBuffer) HasSelection() bool {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	ret := C.gtk_text_buffer_get_has_selection(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// GetInsert returns the mark that represents the cursor (insertion point).
// Equivalent to calling gtk_text_buffer_get_mark() to get the mark named
// “insert”, but very slightly more efficient, and involves less typing.
func (buffer textBuffer) GetInsert() TextMark {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	ret := C.gtk_text_buffer_get_insert(arg0)

	var ret0 TextMark

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(TextMark)

	return ret0
}

// IterAtChildAnchor obtains the location of @anchor within @buffer.
func (buffer textBuffer) IterAtChildAnchor(anchor TextChildAnchor) TextIter {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter // out
	var arg2 *C.GtkTextChildAnchor

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg2 = (*C.GtkTextChildAnchor)(anchor.Native())

	C.gtk_text_buffer_get_iter_at_child_anchor(arg0, &arg1, arg2)

	var ret0 *TextIter

	{
		ret0 = WrapTextIter(unsafe.Pointer(arg1))
	}

	return ret0
}

// IterAtLine initializes @iter to the start of the given line. If
// @line_number is greater than the number of lines in the @buffer, the end
// iterator is returned.
func (buffer textBuffer) IterAtLine(lineNumber int) TextIter {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter // out
	var arg2 C.gint

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg2 = C.gint(lineNumber)

	C.gtk_text_buffer_get_iter_at_line(arg0, &arg1, arg2)

	var ret0 *TextIter

	{
		ret0 = WrapTextIter(unsafe.Pointer(arg1))
	}

	return ret0
}

// IterAtLineIndex obtains an iterator pointing to @byte_index within the
// given line. @byte_index must be the start of a UTF-8 character. Note
// bytes, not characters; UTF-8 may encode one character as multiple bytes.
//
// Before the 3.20 version, it was not allowed to pass an invalid location.
//
// Since the 3.20 version, if @line_number is greater than the number of
// lines in the @buffer, the end iterator is returned. And if @byte_index is
// off the end of the line, the iterator at the end of the line is returned.
func (buffer textBuffer) IterAtLineIndex(lineNumber int, byteIndex int) TextIter {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter // out
	var arg2 C.gint
	var arg3 C.gint

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg2 = C.gint(lineNumber)
	arg3 = C.gint(byteIndex)

	C.gtk_text_buffer_get_iter_at_line_index(arg0, &arg1, arg2, arg3)

	var ret0 *TextIter

	{
		ret0 = WrapTextIter(unsafe.Pointer(arg1))
	}

	return ret0
}

// IterAtLineOffset obtains an iterator pointing to @char_offset within the
// given line. Note characters, not bytes; UTF-8 may encode one character as
// multiple bytes.
//
// Before the 3.20 version, it was not allowed to pass an invalid location.
//
// Since the 3.20 version, if @line_number is greater than the number of
// lines in the @buffer, the end iterator is returned. And if @char_offset
// is off the end of the line, the iterator at the end of the line is
// returned.
func (buffer textBuffer) IterAtLineOffset(lineNumber int, charOffset int) TextIter {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter // out
	var arg2 C.gint
	var arg3 C.gint

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg2 = C.gint(lineNumber)
	arg3 = C.gint(charOffset)

	C.gtk_text_buffer_get_iter_at_line_offset(arg0, &arg1, arg2, arg3)

	var ret0 *TextIter

	{
		ret0 = WrapTextIter(unsafe.Pointer(arg1))
	}

	return ret0
}

// IterAtMark initializes @iter with the current position of @mark.
func (buffer textBuffer) IterAtMark(mark TextMark) TextIter {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter // out
	var arg2 *C.GtkTextMark

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg2 = (*C.GtkTextMark)(mark.Native())

	C.gtk_text_buffer_get_iter_at_mark(arg0, &arg1, arg2)

	var ret0 *TextIter

	{
		ret0 = WrapTextIter(unsafe.Pointer(arg1))
	}

	return ret0
}

// IterAtOffset initializes @iter to a position @char_offset chars from the
// start of the entire buffer. If @char_offset is -1 or greater than the
// number of characters in the buffer, @iter is initialized to the end
// iterator, the iterator one past the last valid character in the buffer.
func (buffer textBuffer) IterAtOffset(charOffset int) TextIter {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter // out
	var arg2 C.gint

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg2 = C.gint(charOffset)

	C.gtk_text_buffer_get_iter_at_offset(arg0, &arg1, arg2)

	var ret0 *TextIter

	{
		ret0 = WrapTextIter(unsafe.Pointer(arg1))
	}

	return ret0
}

// LineCount obtains the number of lines in the buffer. This value is
// cached, so the function is very fast.
func (buffer textBuffer) LineCount() int {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	ret := C.gtk_text_buffer_get_line_count(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Mark returns the mark named @name in buffer @buffer, or nil if no such
// mark exists in the buffer.
func (buffer textBuffer) Mark(name string) TextMark {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.gchar

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_text_buffer_get_mark(arg0, arg1)

	var ret0 TextMark

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(TextMark)

	return ret0
}

// Modified indicates whether the buffer has been modified since the last
// call to gtk_text_buffer_set_modified() set the modification flag to
// false. Used for example to enable a “save” function in a text editor.
func (buffer textBuffer) Modified() bool {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	ret := C.gtk_text_buffer_get_modified(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// PasteTargetList: this function returns the list of targets this text
// buffer supports for pasting and as DND destination. The targets in the
// list are added with @info values from the TextBufferTargetInfo enum,
// using gtk_target_list_add_rich_text_targets() and
// gtk_target_list_add_text_targets().
func (buffer textBuffer) PasteTargetList() *TargetList {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	ret := C.gtk_text_buffer_get_paste_target_list(arg0)

	var ret0 *TargetList

	{
		ret0 = WrapTargetList(unsafe.Pointer(ret))
	}

	return ret0
}

// SelectionBound returns the mark that represents the selection bound.
// Equivalent to calling gtk_text_buffer_get_mark() to get the mark named
// “selection_bound”, but very slightly more efficient, and involves less
// typing.
//
// The currently-selected text in @buffer is the region between the
// “selection_bound” and “insert” marks. If “selection_bound” and “insert”
// are in the same place, then there is no current selection.
// gtk_text_buffer_get_selection_bounds() is another convenient function for
// handling the selection, if you just want to know whether there’s a
// selection and what its bounds are.
func (buffer textBuffer) SelectionBound() TextMark {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	ret := C.gtk_text_buffer_get_selection_bound(arg0)

	var ret0 TextMark

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(TextMark)

	return ret0
}

// SelectionBounds returns true if some text is selected; places the bounds
// of the selection in @start and @end (if the selection has length 0, then
// @start and @end are filled in with the same value). @start and @end will
// be in ascending order. If @start and @end are NULL, then they are not
// filled in, but the return value still indicates whether text is selected.
func (buffer textBuffer) SelectionBounds() (start TextIter, end TextIter, ok bool) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter // out
	var arg2 *C.GtkTextIter // out

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	ret := C.gtk_text_buffer_get_selection_bounds(arg0, &arg1, &arg2)

	var ret0 *TextIter
	var ret1 *TextIter
	var ret2 bool

	{
		ret0 = WrapTextIter(unsafe.Pointer(arg1))
	}

	{
		ret1 = WrapTextIter(unsafe.Pointer(arg2))
	}

	ret2 = C.BOOL(ret) != 0

	return ret0, ret1, ret2
}

// SerializeFormats: this function returns the rich text serialize formats
// registered with @buffer using gtk_text_buffer_register_serialize_format()
// or gtk_text_buffer_register_serialize_tagset()
func (buffer textBuffer) SerializeFormats() (nFormats int, atoms []gdk.Atom) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.gint // out

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	ret := C.gtk_text_buffer_get_serialize_formats(arg0, &arg1)

	var ret0 int
	var ret1 []gdk.Atom

	ret0 = int(arg1)

	{
		ret1 = make([]gdk.Atom, arg1)
		for i := 0; i < uintptr(arg1); i++ {
			src := (C.GdkAtom)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			{
				ret1[i] = gdk.WrapAtom(unsafe.Pointer(src))
			}
		}
	}

	return ret0, ret1
}

// Slice returns the text in the range [@start,@end). Excludes undisplayed
// text (text marked with tags that set the invisibility attribute) if
// @include_hidden_chars is false. The returned string includes a 0xFFFC
// character whenever the buffer contains embedded images, so byte and
// character indexes into the returned string do correspond to byte and
// character indexes into the buffer. Contrast with
// gtk_text_buffer_get_text(). Note that 0xFFFC can occur in normal text as
// well, so it is not a reliable indicator that a pixbuf or widget is in the
// buffer.
func (buffer textBuffer) Slice(start *TextIter, end *TextIter, includeHiddenChars bool) string {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextIter
	var arg3 C.gboolean

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextIter)(start.Native())
	arg2 = (*C.GtkTextIter)(end.Native())
	if includeHiddenChars {
		arg3 = C.TRUE
	}

	ret := C.gtk_text_buffer_get_slice(arg0, arg1, arg2, arg3)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// StartIter: initialized @iter with the first position in the text buffer.
// This is the same as using gtk_text_buffer_get_iter_at_offset() to get the
// iter at character offset 0.
func (buffer textBuffer) StartIter() TextIter {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter // out

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	C.gtk_text_buffer_get_start_iter(arg0, &arg1)

	var ret0 *TextIter

	{
		ret0 = WrapTextIter(unsafe.Pointer(arg1))
	}

	return ret0
}

// TagTable: get the TextTagTable associated with this buffer.
func (buffer textBuffer) TagTable() TextTagTable {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	ret := C.gtk_text_buffer_get_tag_table(arg0)

	var ret0 TextTagTable

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(TextTagTable)

	return ret0
}

// Text returns the text in the range [@start,@end). Excludes undisplayed
// text (text marked with tags that set the invisibility attribute) if
// @include_hidden_chars is false. Does not include characters representing
// embedded images, so byte and character indexes into the returned string
// do not correspond to byte and character indexes into the buffer. Contrast
// with gtk_text_buffer_get_slice().
func (buffer textBuffer) Text(start *TextIter, end *TextIter, includeHiddenChars bool) string {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextIter
	var arg3 C.gboolean

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextIter)(start.Native())
	arg2 = (*C.GtkTextIter)(end.Native())
	if includeHiddenChars {
		arg3 = C.TRUE
	}

	ret := C.gtk_text_buffer_get_text(arg0, arg1, arg2, arg3)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Insert inserts @len bytes of @text at position @iter. If @len is -1,
// @text must be nul-terminated and will be inserted in its entirety. Emits
// the “insert-text” signal; insertion actually occurs in the default
// handler for the signal. @iter is invalidated when insertion occurs
// (because the buffer contents change), but the default signal handler
// revalidates it to point to the end of the inserted text.
func (buffer textBuffer) Insert(iter *TextIter, text string, len int) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.gchar
	var arg3 C.gint

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextIter)(iter.Native())
	arg2 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.gint(len)

	C.gtk_text_buffer_insert(arg0, arg1, arg2, arg3)
}

// InsertAtCursor: simply calls gtk_text_buffer_insert(), using the current
// cursor position as the insertion point.
func (buffer textBuffer) InsertAtCursor(text string, len int) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.gchar
	var arg2 C.gint

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(len)

	C.gtk_text_buffer_insert_at_cursor(arg0, arg1, arg2)
}

// InsertChildAnchor inserts a child widget anchor into the text buffer at
// @iter. The anchor will be counted as one character in character counts,
// and when obtaining the buffer contents as a string, will be represented
// by the Unicode “object replacement character” 0xFFFC. Note that the
// “slice” variants for obtaining portions of the buffer as a string include
// this character for child anchors, but the “text” variants do not. E.g.
// see gtk_text_buffer_get_slice() and gtk_text_buffer_get_text(). Consider
// gtk_text_buffer_create_child_anchor() as a more convenient alternative to
// this function. The buffer will add a reference to the anchor, so you can
// unref it after insertion.
func (buffer textBuffer) InsertChildAnchor(iter *TextIter, anchor TextChildAnchor) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextChildAnchor

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextIter)(iter.Native())
	arg2 = (*C.GtkTextChildAnchor)(anchor.Native())

	C.gtk_text_buffer_insert_child_anchor(arg0, arg1, arg2)
}

// InsertInteractive: like gtk_text_buffer_insert(), but the insertion will
// not occur if @iter is at a non-editable location in the buffer. Usually
// you want to prevent insertions at ineditable locations if the insertion
// results from a user action (is interactive).
//
// @default_editable indicates the editability of text that doesn't have a
// tag affecting editability applied to it. Typically the result of
// gtk_text_view_get_editable() is appropriate here.
func (buffer textBuffer) InsertInteractive(iter *TextIter, text string, len int, defaultEditable bool) bool {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.gchar
	var arg3 C.gint
	var arg4 C.gboolean

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextIter)(iter.Native())
	arg2 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.gint(len)
	if defaultEditable {
		arg4 = C.TRUE
	}

	ret := C.gtk_text_buffer_insert_interactive(arg0, arg1, arg2, arg3, arg4)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// InsertInteractiveAtCursor calls gtk_text_buffer_insert_interactive() at
// the cursor position.
//
// @default_editable indicates the editability of text that doesn't have a
// tag affecting editability applied to it. Typically the result of
// gtk_text_view_get_editable() is appropriate here.
func (buffer textBuffer) InsertInteractiveAtCursor(text string, len int, defaultEditable bool) bool {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.gchar
	var arg2 C.gint
	var arg3 C.gboolean

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(len)
	if defaultEditable {
		arg3 = C.TRUE
	}

	ret := C.gtk_text_buffer_insert_interactive_at_cursor(arg0, arg1, arg2, arg3)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// InsertMarkup inserts the text in @markup at position @iter. @markup will
// be inserted in its entirety and must be nul-terminated and valid UTF-8.
// Emits the TextBuffer::insert-text signal, possibly multiple times;
// insertion actually occurs in the default handler for the signal. @iter
// will point to the end of the inserted text on return.
func (buffer textBuffer) InsertMarkup(iter *TextIter, markup string, len int) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.gchar
	var arg3 C.gint

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextIter)(iter.Native())
	arg2 = (*C.gchar)(C.CString(markup))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.gint(len)

	C.gtk_text_buffer_insert_markup(arg0, arg1, arg2, arg3)
}

// InsertPixbuf inserts an image into the text buffer at @iter. The image
// will be counted as one character in character counts, and when obtaining
// the buffer contents as a string, will be represented by the Unicode
// “object replacement character” 0xFFFC. Note that the “slice” variants for
// obtaining portions of the buffer as a string include this character for
// pixbufs, but the “text” variants do not. e.g. see
// gtk_text_buffer_get_slice() and gtk_text_buffer_get_text().
func (buffer textBuffer) InsertPixbuf(iter *TextIter, pixbuf gdkpixbuf.Pixbuf) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GdkPixbuf

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextIter)(iter.Native())
	arg2 = (*C.GdkPixbuf)(pixbuf.Native())

	C.gtk_text_buffer_insert_pixbuf(arg0, arg1, arg2)
}

// InsertRange copies text, tags, and pixbufs between @start and @end (the
// order of @start and @end doesn’t matter) and inserts the copy at @iter.
// Used instead of simply getting/inserting text because it preserves images
// and tags. If @start and @end are in a different buffer from @buffer, the
// two buffers must share the same tag table.
//
// Implemented via emissions of the insert_text and apply_tag signals, so
// expect those.
func (buffer textBuffer) InsertRange(iter *TextIter, start *TextIter, end *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextIter
	var arg3 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextIter)(iter.Native())
	arg2 = (*C.GtkTextIter)(start.Native())
	arg3 = (*C.GtkTextIter)(end.Native())

	C.gtk_text_buffer_insert_range(arg0, arg1, arg2, arg3)
}

// InsertRangeInteractive: same as gtk_text_buffer_insert_range(), but does
// nothing if the insertion point isn’t editable. The @default_editable
// parameter indicates whether the text is editable at @iter if no tags
// enclosing @iter affect editability. Typically the result of
// gtk_text_view_get_editable() is appropriate here.
func (buffer textBuffer) InsertRangeInteractive(iter *TextIter, start *TextIter, end *TextIter, defaultEditable bool) bool {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextIter
	var arg3 *C.GtkTextIter
	var arg4 C.gboolean

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextIter)(iter.Native())
	arg2 = (*C.GtkTextIter)(start.Native())
	arg3 = (*C.GtkTextIter)(end.Native())
	if defaultEditable {
		arg4 = C.TRUE
	}

	ret := C.gtk_text_buffer_insert_range_interactive(arg0, arg1, arg2, arg3, arg4)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// MoveMark moves @mark to the new location @where. Emits the
// TextBuffer::mark-set signal as notification of the move.
func (buffer textBuffer) MoveMark(mark TextMark, where *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextMark
	var arg2 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextMark)(mark.Native())
	arg2 = (*C.GtkTextIter)(where.Native())

	C.gtk_text_buffer_move_mark(arg0, arg1, arg2)
}

// MoveMarkByName moves the mark named @name (which must exist) to location
// @where. See gtk_text_buffer_move_mark() for details.
func (buffer textBuffer) MoveMarkByName(name string, where *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.gchar
	var arg2 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GtkTextIter)(where.Native())

	C.gtk_text_buffer_move_mark_by_name(arg0, arg1, arg2)
}

// PasteClipboard pastes the contents of a clipboard. If @override_location
// is nil, the pasted text will be inserted at the cursor position, or the
// buffer selection will be replaced if the selection is non-empty.
//
// Note: pasting is asynchronous, that is, we’ll ask for the paste data and
// return, and at some point later after the main loop runs, the paste data
// will be inserted.
func (buffer textBuffer) PasteClipboard(clipboard Clipboard, overrideLocation *TextIter, defaultEditable bool) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkClipboard
	var arg2 *C.GtkTextIter
	var arg3 C.gboolean

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkClipboard)(clipboard.Native())
	arg2 = (*C.GtkTextIter)(overrideLocation.Native())
	if defaultEditable {
		arg3 = C.TRUE
	}

	C.gtk_text_buffer_paste_clipboard(arg0, arg1, arg2, arg3)
}

// PlaceCursor: this function moves the “insert” and “selection_bound” marks
// simultaneously. If you move them to the same place in two steps with
// gtk_text_buffer_move_mark(), you will temporarily select a region in
// between their old and new locations, which can be pretty inefficient
// since the temporarily-selected region will force stuff to be
// recalculated. This function moves them as a unit, which can be optimized.
func (buffer textBuffer) PlaceCursor(where *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextIter)(where.Native())

	C.gtk_text_buffer_place_cursor(arg0, arg1)
}

// RegisterDeserializeFormat: this function registers a rich text
// deserialization @function along with its @mime_type with the passed
// @buffer.
func (buffer textBuffer) RegisterDeserializeFormat(mimeType string, function TextBufferDeserializeFunc) gdk.Atom {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.gchar
	var arg2 C.GtkTextBufferDeserializeFunc
	var arg3 C.gpointer
	var arg4 C.GDestroyNotify

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.gchar)(C.CString(mimeType))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*[0]byte)(C.gotk4_TextBufferDeserializeFunc)
	arg3 = C.gpointer(box.Assign(function))
	arg4 = (*[0]byte)(C.callbackDelete)

	ret := C.gtk_text_buffer_register_deserialize_format(arg0, arg1, arg2, arg3, arg4)

	var ret0 gdk.Atom

	{
		ret0 = gdk.WrapAtom(unsafe.Pointer(ret))
	}

	return ret0
}

// RegisterDeserializeTagset: this function registers GTK+’s internal rich
// text serialization format with the passed @buffer. See
// gtk_text_buffer_register_serialize_tagset() for details.
func (buffer textBuffer) RegisterDeserializeTagset(tagsetName string) gdk.Atom {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.gchar

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.gchar)(C.CString(tagsetName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_text_buffer_register_deserialize_tagset(arg0, arg1)

	var ret0 gdk.Atom

	{
		ret0 = gdk.WrapAtom(unsafe.Pointer(ret))
	}

	return ret0
}

// RegisterSerializeFormat: this function registers a rich text
// serialization @function along with its @mime_type with the passed
// @buffer.
func (buffer textBuffer) RegisterSerializeFormat(mimeType string, function TextBufferSerializeFunc) gdk.Atom {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.gchar
	var arg2 C.GtkTextBufferSerializeFunc
	var arg3 C.gpointer
	var arg4 C.GDestroyNotify

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.gchar)(C.CString(mimeType))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*[0]byte)(C.gotk4_TextBufferSerializeFunc)
	arg3 = C.gpointer(box.Assign(function))
	arg4 = (*[0]byte)(C.callbackDelete)

	ret := C.gtk_text_buffer_register_serialize_format(arg0, arg1, arg2, arg3, arg4)

	var ret0 gdk.Atom

	{
		ret0 = gdk.WrapAtom(unsafe.Pointer(ret))
	}

	return ret0
}

// RegisterSerializeTagset: this function registers GTK+’s internal rich
// text serialization format with the passed @buffer. The internal format
// does not comply to any standard rich text format and only works between
// TextBuffer instances. It is capable of serializing all of a text buffer’s
// tags and embedded pixbufs.
//
// This function is just a wrapper around
// gtk_text_buffer_register_serialize_format(). The mime type used for
// registering is “application/x-gtk-text-buffer-rich-text”, or
// “application/x-gtk-text-buffer-rich-text;format=@tagset_name” if a
// @tagset_name was passed.
//
// The @tagset_name can be used to restrict the transfer of rich text to
// buffers with compatible sets of tags, in order to avoid unknown tags from
// being pasted. It is probably the common case to pass an identifier != nil
// here, since the nil tagset requires the receiving buffer to deal with
// with pasting of arbitrary tags.
func (buffer textBuffer) RegisterSerializeTagset(tagsetName string) gdk.Atom {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.gchar

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.gchar)(C.CString(tagsetName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_text_buffer_register_serialize_tagset(arg0, arg1)

	var ret0 gdk.Atom

	{
		ret0 = gdk.WrapAtom(unsafe.Pointer(ret))
	}

	return ret0
}

// RemoveAllTags removes all tags in the range between @start and @end. Be
// careful with this function; it could remove tags added in code unrelated
// to the code you’re currently writing. That is, using this function is
// probably a bad idea if you have two or more unrelated code sections that
// add tags.
func (buffer textBuffer) RemoveAllTags(start *TextIter, end *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextIter)(start.Native())
	arg2 = (*C.GtkTextIter)(end.Native())

	C.gtk_text_buffer_remove_all_tags(arg0, arg1, arg2)
}

// RemoveSelectionClipboard removes a Clipboard added with
// gtk_text_buffer_add_selection_clipboard().
func (buffer textBuffer) RemoveSelectionClipboard(clipboard Clipboard) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkClipboard

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkClipboard)(clipboard.Native())

	C.gtk_text_buffer_remove_selection_clipboard(arg0, arg1)
}

// RemoveTag emits the “remove-tag” signal. The default handler for the
// signal removes all occurrences of @tag from the given range. @start and
// @end don’t have to be in order.
func (buffer textBuffer) RemoveTag(tag TextTag, start *TextIter, end *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextTag
	var arg2 *C.GtkTextIter
	var arg3 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextTag)(tag.Native())
	arg2 = (*C.GtkTextIter)(start.Native())
	arg3 = (*C.GtkTextIter)(end.Native())

	C.gtk_text_buffer_remove_tag(arg0, arg1, arg2, arg3)
}

// RemoveTagByName calls gtk_text_tag_table_lookup() on the buffer’s tag
// table to get a TextTag, then calls gtk_text_buffer_remove_tag().
func (buffer textBuffer) RemoveTagByName(name string, start *TextIter, end *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.gchar
	var arg2 *C.GtkTextIter
	var arg3 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GtkTextIter)(start.Native())
	arg3 = (*C.GtkTextIter)(end.Native())

	C.gtk_text_buffer_remove_tag_by_name(arg0, arg1, arg2, arg3)
}

// SelectRange: this function moves the “insert” and “selection_bound” marks
// simultaneously. If you move them in two steps with
// gtk_text_buffer_move_mark(), you will temporarily select a region in
// between their old and new locations, which can be pretty inefficient
// since the temporarily-selected region will force stuff to be
// recalculated. This function moves them as a unit, which can be optimized.
func (buffer textBuffer) SelectRange(ins *TextIter, bound *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextIter)(ins.Native())
	arg2 = (*C.GtkTextIter)(bound.Native())

	C.gtk_text_buffer_select_range(arg0, arg1, arg2)
}

// Serialize: this function serializes the portion of text between @start
// and @end in the rich text format represented by @format.
//
// @formats to be used must be registered using
// gtk_text_buffer_register_serialize_format() or
// gtk_text_buffer_register_serialize_tagset() beforehand.
func (registerBuffer textBuffer) Serialize(contentBuffer TextBuffer, format gdk.Atom, start *TextIter, end *TextIter) (length uint, guint8s []byte) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextBuffer
	var arg2 C.GdkAtom
	var arg3 *C.GtkTextIter
	var arg4 *C.GtkTextIter
	var arg5 *C.gsize // out

	arg0 = (*C.GtkTextBuffer)(registerBuffer.Native())
	arg1 = (*C.GtkTextBuffer)(contentBuffer.Native())
	arg2 = (C.GdkAtom)(format.Native())
	arg3 = (*C.GtkTextIter)(start.Native())
	arg4 = (*C.GtkTextIter)(end.Native())

	ret := C.gtk_text_buffer_serialize(arg0, arg1, arg2, arg3, arg4, &arg5)

	var ret0 uint
	var ret1 []byte

	ret0 = uint(arg5)

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret1))
		sliceHeader.Data = uintptr(unsafe.Pointer(ret))
		sliceHeader.Len = arg5
		sliceHeader.Cap = arg5
		runtime.SetFinalizer(&ret, func() {
			C.free(unsafe.Pointer(ret))
		})
		defer runtime.KeepAlive(ret)
	}

	return ret0, ret1
}

// SetModified: used to keep track of whether the buffer has been modified
// since the last time it was saved. Whenever the buffer is saved to disk,
// call gtk_text_buffer_set_modified (@buffer, FALSE). When the buffer is
// modified, it will automatically toggled on the modified bit again. When
// the modified bit flips, the buffer emits the TextBuffer::modified-changed
// signal.
func (buffer textBuffer) SetModified(setting bool) {
	var arg0 *C.GtkTextBuffer
	var arg1 C.gboolean

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	if setting {
		arg1 = C.TRUE
	}

	C.gtk_text_buffer_set_modified(arg0, arg1)
}

// SetText deletes current contents of @buffer, and inserts @text instead.
// If @len is -1, @text must be nul-terminated. @text must be valid UTF-8.
func (buffer textBuffer) SetText(text string, len int) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.gchar
	var arg2 C.gint

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(len)

	C.gtk_text_buffer_set_text(arg0, arg1, arg2)
}

// UnregisterDeserializeFormat: this function unregisters a rich text format
// that was previously registered using
// gtk_text_buffer_register_deserialize_format() or
// gtk_text_buffer_register_deserialize_tagset().
func (buffer textBuffer) UnregisterDeserializeFormat(format gdk.Atom) {
	var arg0 *C.GtkTextBuffer
	var arg1 C.GdkAtom

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (C.GdkAtom)(format.Native())

	C.gtk_text_buffer_unregister_deserialize_format(arg0, arg1)
}

// UnregisterSerializeFormat: this function unregisters a rich text format
// that was previously registered using
// gtk_text_buffer_register_serialize_format() or
// gtk_text_buffer_register_serialize_tagset()
func (buffer textBuffer) UnregisterSerializeFormat(format gdk.Atom) {
	var arg0 *C.GtkTextBuffer
	var arg1 C.GdkAtom

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (C.GdkAtom)(format.Native())

	C.gtk_text_buffer_unregister_serialize_format(arg0, arg1)
}

// TextChildAnchor: a TextChildAnchor is a spot in the buffer where child
// widgets can be “anchored” (inserted inline, as if they were characters). The
// anchor can have multiple widgets anchored, to allow for multiple views.
type TextChildAnchor interface {
	gextras.Objector

	// Deleted determines whether a child anchor has been deleted from the
	// buffer. Keep in mind that the child anchor will be unreferenced when
	// removed from the buffer, so you need to hold your own reference (with
	// g_object_ref()) if you plan to use this function — otherwise all deleted
	// child anchors will also be finalized.
	Deleted() bool
	// Widgets gets a list of all widgets anchored at this child anchor. The
	// returned list should be freed with g_list_free().
	Widgets() *glib.List
}

// textChildAnchor implements the TextChildAnchor interface.
type textChildAnchor struct {
	gextras.Objector
}

var _ TextChildAnchor = (*textChildAnchor)(nil)

// WrapTextChildAnchor wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextChildAnchor(obj *externglib.Object) TextChildAnchor {
	return TextChildAnchor{
		Objector: obj,
	}
}

func marshalTextChildAnchor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextChildAnchor(obj), nil
}

// NewTextChildAnchor constructs a class TextChildAnchor.
func NewTextChildAnchor() TextChildAnchor {

	ret := C.gtk_text_child_anchor_new()

	var ret0 TextChildAnchor

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(TextChildAnchor)

	return ret0
}

// Deleted determines whether a child anchor has been deleted from the
// buffer. Keep in mind that the child anchor will be unreferenced when
// removed from the buffer, so you need to hold your own reference (with
// g_object_ref()) if you plan to use this function — otherwise all deleted
// child anchors will also be finalized.
func (anchor textChildAnchor) Deleted() bool {
	var arg0 *C.GtkTextChildAnchor

	arg0 = (*C.GtkTextChildAnchor)(anchor.Native())

	ret := C.gtk_text_child_anchor_get_deleted(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Widgets gets a list of all widgets anchored at this child anchor. The
// returned list should be freed with g_list_free().
func (anchor textChildAnchor) Widgets() *glib.List {
	var arg0 *C.GtkTextChildAnchor

	arg0 = (*C.GtkTextChildAnchor)(anchor.Native())

	ret := C.gtk_text_child_anchor_get_widgets(arg0)

	var ret0 *glib.List

	{
		ret0 = glib.WrapList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.List) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// TextMark: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
//
// A TextMark is like a bookmark in a text buffer; it preserves a position in
// the text. You can convert the mark to an iterator using
// gtk_text_buffer_get_iter_at_mark(). Unlike iterators, marks remain valid
// across buffer mutations, because their behavior is defined when text is
// inserted or deleted. When text containing a mark is deleted, the mark remains
// in the position originally occupied by the deleted text. When text is
// inserted at a mark, a mark with “left gravity” will be moved to the beginning
// of the newly-inserted text, and a mark with “right gravity” will be moved to
// the end.
//
// Note that “left” and “right” here refer to logical direction (left is the
// toward the start of the buffer); in some languages such as Hebrew the
// logically-leftmost text is not actually on the left when displayed.
//
// Marks are reference counted, but the reference count only controls the
// validity of the memory; marks can be deleted from the buffer at any time with
// gtk_text_buffer_delete_mark(). Once deleted from the buffer, a mark is
// essentially useless.
//
// Marks optionally have names; these can be convenient to avoid passing the
// TextMark object around.
//
// Marks are typically created using the gtk_text_buffer_create_mark() function.
type TextMark interface {
	gextras.Objector

	// Buffer gets the buffer this mark is located inside, or nil if the mark is
	// deleted.
	Buffer() TextBuffer
	// Deleted returns true if the mark has been removed from its buffer with
	// gtk_text_buffer_delete_mark(). See gtk_text_buffer_add_mark() for a way
	// to add it to a buffer again.
	Deleted() bool
	// LeftGravity determines whether the mark has left gravity.
	LeftGravity() bool
	// Name returns the mark name; returns NULL for anonymous marks.
	Name() string
	// Visible returns true if the mark is visible (i.e. a cursor is displayed
	// for it).
	Visible() bool
	// SetVisible sets the visibility of @mark; the insertion point is normally
	// visible, i.e. you can see it as a vertical bar. Also, the text widget
	// uses a visible mark to indicate where a drop will occur when
	// dragging-and-dropping text. Most other marks are not visible. Marks are
	// not visible by default.
	SetVisible(setting bool)
}

// textMark implements the TextMark interface.
type textMark struct {
	gextras.Objector
}

var _ TextMark = (*textMark)(nil)

// WrapTextMark wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextMark(obj *externglib.Object) TextMark {
	return TextMark{
		Objector: obj,
	}
}

func marshalTextMark(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextMark(obj), nil
}

// NewTextMark constructs a class TextMark.
func NewTextMark(name string, leftGravity bool) TextMark {
	var arg1 *C.gchar
	var arg2 C.gboolean

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	if leftGravity {
		arg2 = C.TRUE
	}

	ret := C.gtk_text_mark_new(arg1, arg2)

	var ret0 TextMark

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(TextMark)

	return ret0
}

// Buffer gets the buffer this mark is located inside, or nil if the mark is
// deleted.
func (mark textMark) Buffer() TextBuffer {
	var arg0 *C.GtkTextMark

	arg0 = (*C.GtkTextMark)(mark.Native())

	ret := C.gtk_text_mark_get_buffer(arg0)

	var ret0 TextBuffer

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(TextBuffer)

	return ret0
}

// Deleted returns true if the mark has been removed from its buffer with
// gtk_text_buffer_delete_mark(). See gtk_text_buffer_add_mark() for a way
// to add it to a buffer again.
func (mark textMark) Deleted() bool {
	var arg0 *C.GtkTextMark

	arg0 = (*C.GtkTextMark)(mark.Native())

	ret := C.gtk_text_mark_get_deleted(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// LeftGravity determines whether the mark has left gravity.
func (mark textMark) LeftGravity() bool {
	var arg0 *C.GtkTextMark

	arg0 = (*C.GtkTextMark)(mark.Native())

	ret := C.gtk_text_mark_get_left_gravity(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Name returns the mark name; returns NULL for anonymous marks.
func (mark textMark) Name() string {
	var arg0 *C.GtkTextMark

	arg0 = (*C.GtkTextMark)(mark.Native())

	ret := C.gtk_text_mark_get_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Visible returns true if the mark is visible (i.e. a cursor is displayed
// for it).
func (mark textMark) Visible() bool {
	var arg0 *C.GtkTextMark

	arg0 = (*C.GtkTextMark)(mark.Native())

	ret := C.gtk_text_mark_get_visible(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SetVisible sets the visibility of @mark; the insertion point is normally
// visible, i.e. you can see it as a vertical bar. Also, the text widget
// uses a visible mark to indicate where a drop will occur when
// dragging-and-dropping text. Most other marks are not visible. Marks are
// not visible by default.
func (mark textMark) SetVisible(setting bool) {
	var arg0 *C.GtkTextMark
	var arg1 C.gboolean

	arg0 = (*C.GtkTextMark)(mark.Native())
	if setting {
		arg1 = C.TRUE
	}

	C.gtk_text_mark_set_visible(arg0, arg1)
}

// TextTag: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
//
// Tags should be in the TextTagTable for a given TextBuffer before using them
// with that buffer.
//
// gtk_text_buffer_create_tag() is the best way to create tags. See “gtk3-demo”
// for numerous examples.
//
// For each property of TextTag, there is a “set” property, e.g. “font-set”
// corresponds to “font”. These “set” properties reflect whether a property has
// been set or not. They are maintained by GTK+ and you should not set them
// independently.
type TextTag interface {
	gextras.Objector

	// Changed emits the TextTagTable::tag-changed signal on the TextTagTable
	// where the tag is included.
	//
	// The signal is already emitted when setting a TextTag property. This
	// function is useful for a TextTag subclass.
	Changed(sizeChanged bool)
	// Priority: get the tag priority.
	Priority() int
	// SetPriority sets the priority of a TextTag. Valid priorities start at 0
	// and go to one less than gtk_text_tag_table_get_size(). Each tag in a
	// table has a unique priority; setting the priority of one tag shifts the
	// priorities of all the other tags in the table to maintain a unique
	// priority for each tag. Higher priority tags “win” if two tags both set
	// the same text attribute. When adding a tag to a tag table, it will be
	// assigned the highest priority in the table by default; so normally the
	// precedence of a set of tags is the order in which they were added to the
	// table, or created with gtk_text_buffer_create_tag(), which adds the tag
	// to the buffer’s table automatically.
	SetPriority(priority int)
}

// textTag implements the TextTag interface.
type textTag struct {
	gextras.Objector
}

var _ TextTag = (*textTag)(nil)

// WrapTextTag wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextTag(obj *externglib.Object) TextTag {
	return TextTag{
		Objector: obj,
	}
}

func marshalTextTag(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextTag(obj), nil
}

// NewTextTag constructs a class TextTag.
func NewTextTag(name string) TextTag {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_text_tag_new(arg1)

	var ret0 TextTag

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(TextTag)

	return ret0
}

// Changed emits the TextTagTable::tag-changed signal on the TextTagTable
// where the tag is included.
//
// The signal is already emitted when setting a TextTag property. This
// function is useful for a TextTag subclass.
func (tag textTag) Changed(sizeChanged bool) {
	var arg0 *C.GtkTextTag
	var arg1 C.gboolean

	arg0 = (*C.GtkTextTag)(tag.Native())
	if sizeChanged {
		arg1 = C.TRUE
	}

	C.gtk_text_tag_changed(arg0, arg1)
}

// Priority: get the tag priority.
func (tag textTag) Priority() int {
	var arg0 *C.GtkTextTag

	arg0 = (*C.GtkTextTag)(tag.Native())

	ret := C.gtk_text_tag_get_priority(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// SetPriority sets the priority of a TextTag. Valid priorities start at 0
// and go to one less than gtk_text_tag_table_get_size(). Each tag in a
// table has a unique priority; setting the priority of one tag shifts the
// priorities of all the other tags in the table to maintain a unique
// priority for each tag. Higher priority tags “win” if two tags both set
// the same text attribute. When adding a tag to a tag table, it will be
// assigned the highest priority in the table by default; so normally the
// precedence of a set of tags is the order in which they were added to the
// table, or created with gtk_text_buffer_create_tag(), which adds the tag
// to the buffer’s table automatically.
func (tag textTag) SetPriority(priority int) {
	var arg0 *C.GtkTextTag
	var arg1 C.gint

	arg0 = (*C.GtkTextTag)(tag.Native())
	arg1 = C.gint(priority)

	C.gtk_text_tag_set_priority(arg0, arg1)
}

// TextTagTable: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
//
//
// GtkTextTagTables as GtkBuildable
//
// The GtkTextTagTable implementation of the GtkBuildable interface supports
// adding tags by specifying “tag” as the “type” attribute of a <child> element.
//
// An example of a UI definition fragment specifying tags:
//
//    <object class="GtkTextTagTable">
//     <child type="tag">
//       <object class="GtkTextTag"/>
//     </child>
//    </object>
type TextTagTable interface {
	gextras.Objector
	Buildable

	// Add: add a tag to the table. The tag is assigned the highest priority in
	// the table.
	//
	// @tag must not be in a tag table already, and may not have the same name
	// as an already-added tag.
	Add(tag TextTag) bool
	// Foreach calls @func on each tag in @table, with user data @data. Note
	// that the table may not be modified while iterating over it (you can’t
	// add/remove tags).
	Foreach(fn TextTagTableForeach)
	// Size returns the size of the table (number of tags)
	Size() int
	// Lookup: look up a named tag.
	Lookup(name string) TextTag
	// Remove: remove a tag from the table. If a TextBuffer has @table as its
	// tag table, the tag is removed from the buffer. The table’s reference to
	// the tag is removed, so the tag will end up destroyed if you don’t have a
	// reference to it.
	Remove(tag TextTag)
}

// textTagTable implements the TextTagTable interface.
type textTagTable struct {
	gextras.Objector
	Buildable
}

var _ TextTagTable = (*textTagTable)(nil)

// WrapTextTagTable wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextTagTable(obj *externglib.Object) TextTagTable {
	return TextTagTable{
		Objector:  obj,
		Buildable: WrapBuildable(obj),
	}
}

func marshalTextTagTable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextTagTable(obj), nil
}

// NewTextTagTable constructs a class TextTagTable.
func NewTextTagTable() TextTagTable {

	ret := C.gtk_text_tag_table_new()

	var ret0 TextTagTable

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(TextTagTable)

	return ret0
}

// Add: add a tag to the table. The tag is assigned the highest priority in
// the table.
//
// @tag must not be in a tag table already, and may not have the same name
// as an already-added tag.
func (table textTagTable) Add(tag TextTag) bool {
	var arg0 *C.GtkTextTagTable
	var arg1 *C.GtkTextTag

	arg0 = (*C.GtkTextTagTable)(table.Native())
	arg1 = (*C.GtkTextTag)(tag.Native())

	ret := C.gtk_text_tag_table_add(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Foreach calls @func on each tag in @table, with user data @data. Note
// that the table may not be modified while iterating over it (you can’t
// add/remove tags).
func (table textTagTable) Foreach(fn TextTagTableForeach) {
	var arg0 *C.GtkTextTagTable
	var arg1 C.GtkTextTagTableForeach
	var arg2 C.gpointer

	arg0 = (*C.GtkTextTagTable)(table.Native())
	arg1 = (*[0]byte)(C.gotk4_TextTagTableForeach)
	arg2 = C.gpointer(box.Assign(fn))

	C.gtk_text_tag_table_foreach(arg0, arg1, arg2)
}

// Size returns the size of the table (number of tags)
func (table textTagTable) Size() int {
	var arg0 *C.GtkTextTagTable

	arg0 = (*C.GtkTextTagTable)(table.Native())

	ret := C.gtk_text_tag_table_get_size(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Lookup: look up a named tag.
func (table textTagTable) Lookup(name string) TextTag {
	var arg0 *C.GtkTextTagTable
	var arg1 *C.gchar

	arg0 = (*C.GtkTextTagTable)(table.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_text_tag_table_lookup(arg0, arg1)

	var ret0 TextTag

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(TextTag)

	return ret0
}

// Remove: remove a tag from the table. If a TextBuffer has @table as its
// tag table, the tag is removed from the buffer. The table’s reference to
// the tag is removed, so the tag will end up destroyed if you don’t have a
// reference to it.
func (table textTagTable) Remove(tag TextTag) {
	var arg0 *C.GtkTextTagTable
	var arg1 *C.GtkTextTag

	arg0 = (*C.GtkTextTagTable)(table.Native())
	arg1 = (*C.GtkTextTag)(tag.Native())

	C.gtk_text_tag_table_remove(arg0, arg1)
}

// ThemingEngine was the object used for rendering themed content in GTK+
// widgets. It used to allow overriding GTK+'s default implementation of
// rendering functions by allowing engines to be loaded as modules.
//
// ThemingEngine has been deprecated in GTK+ 3.14 and will be ignored for
// rendering. The advancements in CSS theming are good enough to allow themers
// to achieve their goals without the need to modify source code.
type ThemingEngine interface {
	gextras.Objector

	// BackgroundColor gets the background color for a given state.
	BackgroundColor(state StateFlags) gdk.RGBA
	// Border gets the border for a given state as a Border.
	Border(state StateFlags) Border
	// BorderColor gets the border color for a given state.
	BorderColor(state StateFlags) gdk.RGBA
	// Color gets the foreground color for a given state.
	Color(state StateFlags) gdk.RGBA
	// Direction returns the widget direction used for rendering.
	Direction() TextDirection
	// Font returns the font description for a given state.
	Font(state StateFlags) *pango.FontDescription
	// JunctionSides returns the widget direction used for rendering.
	JunctionSides() JunctionSides
	// Margin gets the margin for a given state as a Border.
	Margin(state StateFlags) Border
	// Padding gets the padding for a given state as a Border.
	Padding(state StateFlags) Border
	// Path returns the widget path used for style matching.
	Path() *WidgetPath
	// Property gets a property value as retrieved from the style settings that
	// apply to the currently rendered element.
	Property(property string, state StateFlags) externglib.Value
	// Screen returns the Screen to which @engine currently rendering to.
	Screen() gdk.Screen
	// State returns the state used when rendering.
	State() StateFlags
	// StyleProperty gets the value for a widget style property.
	StyleProperty(propertyName string) externglib.Value
	// HasClass returns true if the currently rendered contents have defined the
	// given class name.
	HasClass(styleClass string) bool
	// HasRegion returns true if the currently rendered contents have the region
	// defined. If @flags_return is not nil, it is set to the flags affecting
	// the region.
	HasRegion(styleRegion string) (flags RegionFlags, ok bool)
	// LookupColor looks up and resolves a color name in the current style’s
	// color map.
	LookupColor(colorName string) (color gdk.RGBA, ok bool)
	// StateIsRunning returns true if there is a transition animation running
	// for the current region (see gtk_style_context_push_animatable_region()).
	//
	// If @progress is not nil, the animation progress will be returned there,
	// 0.0 means the state is closest to being false, while 1.0 means it’s
	// closest to being true. This means transition animations will run from 0
	// to 1 when @state is being set to true and from 1 to 0 when it’s being set
	// to false.
	StateIsRunning(state StateType) (progress float64, ok bool)
}

// themingEngine implements the ThemingEngine interface.
type themingEngine struct {
	gextras.Objector
}

var _ ThemingEngine = (*themingEngine)(nil)

// WrapThemingEngine wraps a GObject to the right type. It is
// primarily used internally.
func WrapThemingEngine(obj *externglib.Object) ThemingEngine {
	return ThemingEngine{
		Objector: obj,
	}
}

func marshalThemingEngine(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapThemingEngine(obj), nil
}

// BackgroundColor gets the background color for a given state.
func (engine themingEngine) BackgroundColor(state StateFlags) gdk.RGBA {
	var arg0 *C.GtkThemingEngine
	var arg1 C.GtkStateFlags
	var arg2 *C.GdkRGBA // out

	arg0 = (*C.GtkThemingEngine)(engine.Native())
	arg1 = (C.GtkStateFlags)(state)

	C.gtk_theming_engine_get_background_color(arg0, arg1, &arg2)

	var ret0 *gdk.RGBA

	{
		ret0 = gdk.WrapRGBA(unsafe.Pointer(arg2))
	}

	return ret0
}

// Border gets the border for a given state as a Border.
func (engine themingEngine) Border(state StateFlags) Border {
	var arg0 *C.GtkThemingEngine
	var arg1 C.GtkStateFlags
	var arg2 *C.GtkBorder // out

	arg0 = (*C.GtkThemingEngine)(engine.Native())
	arg1 = (C.GtkStateFlags)(state)

	C.gtk_theming_engine_get_border(arg0, arg1, &arg2)

	var ret0 *Border

	{
		ret0 = WrapBorder(unsafe.Pointer(arg2))
	}

	return ret0
}

// BorderColor gets the border color for a given state.
func (engine themingEngine) BorderColor(state StateFlags) gdk.RGBA {
	var arg0 *C.GtkThemingEngine
	var arg1 C.GtkStateFlags
	var arg2 *C.GdkRGBA // out

	arg0 = (*C.GtkThemingEngine)(engine.Native())
	arg1 = (C.GtkStateFlags)(state)

	C.gtk_theming_engine_get_border_color(arg0, arg1, &arg2)

	var ret0 *gdk.RGBA

	{
		ret0 = gdk.WrapRGBA(unsafe.Pointer(arg2))
	}

	return ret0
}

// Color gets the foreground color for a given state.
func (engine themingEngine) Color(state StateFlags) gdk.RGBA {
	var arg0 *C.GtkThemingEngine
	var arg1 C.GtkStateFlags
	var arg2 *C.GdkRGBA // out

	arg0 = (*C.GtkThemingEngine)(engine.Native())
	arg1 = (C.GtkStateFlags)(state)

	C.gtk_theming_engine_get_color(arg0, arg1, &arg2)

	var ret0 *gdk.RGBA

	{
		ret0 = gdk.WrapRGBA(unsafe.Pointer(arg2))
	}

	return ret0
}

// Direction returns the widget direction used for rendering.
func (engine themingEngine) Direction() TextDirection {
	var arg0 *C.GtkThemingEngine

	arg0 = (*C.GtkThemingEngine)(engine.Native())

	ret := C.gtk_theming_engine_get_direction(arg0)

	var ret0 TextDirection

	ret0 = TextDirection(ret)

	return ret0
}

// Font returns the font description for a given state.
func (engine themingEngine) Font(state StateFlags) *pango.FontDescription {
	var arg0 *C.GtkThemingEngine
	var arg1 C.GtkStateFlags

	arg0 = (*C.GtkThemingEngine)(engine.Native())
	arg1 = (C.GtkStateFlags)(state)

	ret := C.gtk_theming_engine_get_font(arg0, arg1)

	var ret0 *pango.FontDescription

	{
		ret0 = pango.WrapFontDescription(unsafe.Pointer(ret))
	}

	return ret0
}

// JunctionSides returns the widget direction used for rendering.
func (engine themingEngine) JunctionSides() JunctionSides {
	var arg0 *C.GtkThemingEngine

	arg0 = (*C.GtkThemingEngine)(engine.Native())

	ret := C.gtk_theming_engine_get_junction_sides(arg0)

	var ret0 JunctionSides

	ret0 = JunctionSides(ret)

	return ret0
}

// Margin gets the margin for a given state as a Border.
func (engine themingEngine) Margin(state StateFlags) Border {
	var arg0 *C.GtkThemingEngine
	var arg1 C.GtkStateFlags
	var arg2 *C.GtkBorder // out

	arg0 = (*C.GtkThemingEngine)(engine.Native())
	arg1 = (C.GtkStateFlags)(state)

	C.gtk_theming_engine_get_margin(arg0, arg1, &arg2)

	var ret0 *Border

	{
		ret0 = WrapBorder(unsafe.Pointer(arg2))
	}

	return ret0
}

// Padding gets the padding for a given state as a Border.
func (engine themingEngine) Padding(state StateFlags) Border {
	var arg0 *C.GtkThemingEngine
	var arg1 C.GtkStateFlags
	var arg2 *C.GtkBorder // out

	arg0 = (*C.GtkThemingEngine)(engine.Native())
	arg1 = (C.GtkStateFlags)(state)

	C.gtk_theming_engine_get_padding(arg0, arg1, &arg2)

	var ret0 *Border

	{
		ret0 = WrapBorder(unsafe.Pointer(arg2))
	}

	return ret0
}

// Path returns the widget path used for style matching.
func (engine themingEngine) Path() *WidgetPath {
	var arg0 *C.GtkThemingEngine

	arg0 = (*C.GtkThemingEngine)(engine.Native())

	ret := C.gtk_theming_engine_get_path(arg0)

	var ret0 *WidgetPath

	{
		ret0 = WrapWidgetPath(unsafe.Pointer(ret))
	}

	return ret0
}

// Property gets a property value as retrieved from the style settings that
// apply to the currently rendered element.
func (engine themingEngine) Property(property string, state StateFlags) externglib.Value {
	var arg0 *C.GtkThemingEngine
	var arg1 *C.gchar
	var arg2 C.GtkStateFlags
	var arg3 *C.GValue // out

	arg0 = (*C.GtkThemingEngine)(engine.Native())
	arg1 = (*C.gchar)(C.CString(property))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GtkStateFlags)(state)

	C.gtk_theming_engine_get_property(arg0, arg1, arg2, &arg3)

	var ret0 *externglib.Value

	ret0 = externglib.ValueFromNative(unsafe.Pointer(arg3))
	runtime.SetFinalizer(ret0, func(v *externglib.Value) {
		C.g_value_unset((*C.GValue)(v.GValue))
	})

	return ret0
}

// Screen returns the Screen to which @engine currently rendering to.
func (engine themingEngine) Screen() gdk.Screen {
	var arg0 *C.GtkThemingEngine

	arg0 = (*C.GtkThemingEngine)(engine.Native())

	ret := C.gtk_theming_engine_get_screen(arg0)

	var ret0 gdk.Screen

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gdk.Screen)

	return ret0
}

// State returns the state used when rendering.
func (engine themingEngine) State() StateFlags {
	var arg0 *C.GtkThemingEngine

	arg0 = (*C.GtkThemingEngine)(engine.Native())

	ret := C.gtk_theming_engine_get_state(arg0)

	var ret0 StateFlags

	ret0 = StateFlags(ret)

	return ret0
}

// StyleProperty gets the value for a widget style property.
func (engine themingEngine) StyleProperty(propertyName string) externglib.Value {
	var arg0 *C.GtkThemingEngine
	var arg1 *C.gchar
	var arg2 *C.GValue // out

	arg0 = (*C.GtkThemingEngine)(engine.Native())
	arg1 = (*C.gchar)(C.CString(propertyName))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_theming_engine_get_style_property(arg0, arg1, &arg2)

	var ret0 *externglib.Value

	ret0 = externglib.ValueFromNative(unsafe.Pointer(arg2))

	return ret0
}

// HasClass returns true if the currently rendered contents have defined the
// given class name.
func (engine themingEngine) HasClass(styleClass string) bool {
	var arg0 *C.GtkThemingEngine
	var arg1 *C.gchar

	arg0 = (*C.GtkThemingEngine)(engine.Native())
	arg1 = (*C.gchar)(C.CString(styleClass))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_theming_engine_has_class(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// HasRegion returns true if the currently rendered contents have the region
// defined. If @flags_return is not nil, it is set to the flags affecting
// the region.
func (engine themingEngine) HasRegion(styleRegion string) (flags RegionFlags, ok bool) {
	var arg0 *C.GtkThemingEngine
	var arg1 *C.gchar
	var arg2 *C.GtkRegionFlags // out

	arg0 = (*C.GtkThemingEngine)(engine.Native())
	arg1 = (*C.gchar)(C.CString(styleRegion))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_theming_engine_has_region(arg0, arg1, &arg2)

	var ret0 *RegionFlags
	var ret1 bool

	ret0 = (*RegionFlags)(arg2)

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// LookupColor looks up and resolves a color name in the current style’s
// color map.
func (engine themingEngine) LookupColor(colorName string) (color gdk.RGBA, ok bool) {
	var arg0 *C.GtkThemingEngine
	var arg1 *C.gchar
	var arg2 *C.GdkRGBA // out

	arg0 = (*C.GtkThemingEngine)(engine.Native())
	arg1 = (*C.gchar)(C.CString(colorName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_theming_engine_lookup_color(arg0, arg1, &arg2)

	var ret0 *gdk.RGBA
	var ret1 bool

	{
		ret0 = gdk.WrapRGBA(unsafe.Pointer(arg2))
	}

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// StateIsRunning returns true if there is a transition animation running
// for the current region (see gtk_style_context_push_animatable_region()).
//
// If @progress is not nil, the animation progress will be returned there,
// 0.0 means the state is closest to being false, while 1.0 means it’s
// closest to being true. This means transition animations will run from 0
// to 1 when @state is being set to true and from 1 to 0 when it’s being set
// to false.
func (engine themingEngine) StateIsRunning(state StateType) (progress float64, ok bool) {
	var arg0 *C.GtkThemingEngine
	var arg1 C.GtkStateType
	var arg2 *C.gdouble // out

	arg0 = (*C.GtkThemingEngine)(engine.Native())
	arg1 = (C.GtkStateType)(state)

	ret := C.gtk_theming_engine_state_is_running(arg0, arg1, &arg2)

	var ret0 float64
	var ret1 bool

	ret0 = float64(arg2)

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// ToggleAction: a ToggleAction corresponds roughly to a CheckMenuItem. It has
// an “active” state specifying whether the action has been checked or not.
type ToggleAction interface {
	Action
	Buildable

	// Active returns the checked state of the toggle action.
	Active() bool
	// DrawAsRadio returns whether the action should have proxies like a radio
	// action.
	DrawAsRadio() bool
	// SetActive sets the checked state on the toggle action.
	SetActive(isActive bool)
	// SetDrawAsRadio sets whether the action should have proxies like a radio
	// action.
	SetDrawAsRadio(drawAsRadio bool)
	// Toggled emits the “toggled” signal on the toggle action.
	Toggled()
}

// toggleAction implements the ToggleAction interface.
type toggleAction struct {
	Action
	Buildable
}

var _ ToggleAction = (*toggleAction)(nil)

// WrapToggleAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapToggleAction(obj *externglib.Object) ToggleAction {
	return ToggleAction{
		Action:    WrapAction(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalToggleAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapToggleAction(obj), nil
}

// NewToggleAction constructs a class ToggleAction.
func NewToggleAction(name string, label string, tooltip string, stockID string) ToggleAction {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 *C.gchar

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(tooltip))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gchar)(C.CString(stockID))
	defer C.free(unsafe.Pointer(arg4))

	ret := C.gtk_toggle_action_new(arg1, arg2, arg3, arg4)

	var ret0 ToggleAction

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(ToggleAction)

	return ret0
}

// Active returns the checked state of the toggle action.
func (action toggleAction) Active() bool {
	var arg0 *C.GtkToggleAction

	arg0 = (*C.GtkToggleAction)(action.Native())

	ret := C.gtk_toggle_action_get_active(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// DrawAsRadio returns whether the action should have proxies like a radio
// action.
func (action toggleAction) DrawAsRadio() bool {
	var arg0 *C.GtkToggleAction

	arg0 = (*C.GtkToggleAction)(action.Native())

	ret := C.gtk_toggle_action_get_draw_as_radio(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SetActive sets the checked state on the toggle action.
func (action toggleAction) SetActive(isActive bool) {
	var arg0 *C.GtkToggleAction
	var arg1 C.gboolean

	arg0 = (*C.GtkToggleAction)(action.Native())
	if isActive {
		arg1 = C.TRUE
	}

	C.gtk_toggle_action_set_active(arg0, arg1)
}

// SetDrawAsRadio sets whether the action should have proxies like a radio
// action.
func (action toggleAction) SetDrawAsRadio(drawAsRadio bool) {
	var arg0 *C.GtkToggleAction
	var arg1 C.gboolean

	arg0 = (*C.GtkToggleAction)(action.Native())
	if drawAsRadio {
		arg1 = C.TRUE
	}

	C.gtk_toggle_action_set_draw_as_radio(arg0, arg1)
}

// Toggled emits the “toggled” signal on the toggle action.
func (action toggleAction) Toggled() {
	var arg0 *C.GtkToggleAction

	arg0 = (*C.GtkToggleAction)(action.Native())

	C.gtk_toggle_action_toggled(arg0)
}

// Tooltip: basic tooltips can be realized simply by using
// gtk_widget_set_tooltip_text() or gtk_widget_set_tooltip_markup() without any
// explicit tooltip object.
//
// When you need a tooltip with a little more fancy contents, like adding an
// image, or you want the tooltip to have different contents per TreeView row or
// cell, you will have to do a little more work:
//
// - Set the Widget:has-tooltip property to true, this will make GTK+ monitor
// the widget for motion and related events which are needed to determine when
// and where to show a tooltip.
//
// - Connect to the Widget::query-tooltip signal. This signal will be emitted
// when a tooltip is supposed to be shown. One of the arguments passed to the
// signal handler is a GtkTooltip object. This is the object that we are about
// to display as a tooltip, and can be manipulated in your callback using
// functions like gtk_tooltip_set_icon(). There are functions for setting the
// tooltip’s markup, setting an image from a named icon, or even putting in a
// custom widget.
//
//    Return true from your query-tooltip handler. This causes the tooltip to be
//    show. If you return false, it will not be shown.
//
// In the probably rare case where you want to have even more control over the
// tooltip that is about to be shown, you can set your own Window which will be
// used as tooltip window. This works as follows:
//
// - Set Widget:has-tooltip and connect to Widget::query-tooltip as before. Use
// gtk_widget_set_tooltip_window() to set a Window created by you as tooltip
// window.
//
// - In the Widget::query-tooltip callback you can access your window using
// gtk_widget_get_tooltip_window() and manipulate as you wish. The semantics of
// the return value are exactly as before, return true to show the window, false
// to not show it.
type Tooltip interface {
	gextras.Objector

	// SetCustom replaces the widget packed into the tooltip with
	// @custom_widget. @custom_widget does not get destroyed when the tooltip
	// goes away. By default a box with a Image and Label is embedded in the
	// tooltip, which can be configured using gtk_tooltip_set_markup() and
	// gtk_tooltip_set_icon().
	SetCustom(customWidget Widget)
	// SetIcon sets the icon of the tooltip (which is in front of the text) to
	// be @pixbuf. If @pixbuf is nil, the image will be hidden.
	SetIcon(pixbuf gdkpixbuf.Pixbuf)
	// SetIconFromGIcon sets the icon of the tooltip (which is in front of the
	// text) to be the icon indicated by @gicon with the size indicated by
	// @size. If @gicon is nil, the image will be hidden.
	SetIconFromGIcon(gicon gio.Icon, size int)
	// SetIconFromIconName sets the icon of the tooltip (which is in front of
	// the text) to be the icon indicated by @icon_name with the size indicated
	// by @size. If @icon_name is nil, the image will be hidden.
	SetIconFromIconName(iconName string, size int)
	// SetIconFromStock sets the icon of the tooltip (which is in front of the
	// text) to be the stock item indicated by @stock_id with the size indicated
	// by @size. If @stock_id is nil, the image will be hidden.
	SetIconFromStock(stockID string, size int)
	// SetMarkup sets the text of the tooltip to be @markup, which is marked up
	// with the [Pango text markup language][PangoMarkupFormat]. If @markup is
	// nil, the label will be hidden.
	SetMarkup(markup string)
	// SetText sets the text of the tooltip to be @text. If @text is nil, the
	// label will be hidden. See also gtk_tooltip_set_markup().
	SetText(text string)
	// SetTipArea sets the area of the widget, where the contents of this
	// tooltip apply, to be @rect (in widget coordinates). This is especially
	// useful for properly setting tooltips on TreeView rows and cells,
	// IconViews, etc.
	//
	// For setting tooltips on TreeView, please refer to the convenience
	// functions for this: gtk_tree_view_set_tooltip_row() and
	// gtk_tree_view_set_tooltip_cell().
	SetTipArea(rect *gdk.Rectangle)
}

// tooltip implements the Tooltip interface.
type tooltip struct {
	gextras.Objector
}

var _ Tooltip = (*tooltip)(nil)

// WrapTooltip wraps a GObject to the right type. It is
// primarily used internally.
func WrapTooltip(obj *externglib.Object) Tooltip {
	return Tooltip{
		Objector: obj,
	}
}

func marshalTooltip(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTooltip(obj), nil
}

// SetCustom replaces the widget packed into the tooltip with
// @custom_widget. @custom_widget does not get destroyed when the tooltip
// goes away. By default a box with a Image and Label is embedded in the
// tooltip, which can be configured using gtk_tooltip_set_markup() and
// gtk_tooltip_set_icon().
func (tooltip tooltip) SetCustom(customWidget Widget) {
	var arg0 *C.GtkTooltip
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkTooltip)(tooltip.Native())
	arg1 = (*C.GtkWidget)(customWidget.Native())

	C.gtk_tooltip_set_custom(arg0, arg1)
}

// SetIcon sets the icon of the tooltip (which is in front of the text) to
// be @pixbuf. If @pixbuf is nil, the image will be hidden.
func (tooltip tooltip) SetIcon(pixbuf gdkpixbuf.Pixbuf) {
	var arg0 *C.GtkTooltip
	var arg1 *C.GdkPixbuf

	arg0 = (*C.GtkTooltip)(tooltip.Native())
	arg1 = (*C.GdkPixbuf)(pixbuf.Native())

	C.gtk_tooltip_set_icon(arg0, arg1)
}

// SetIconFromGIcon sets the icon of the tooltip (which is in front of the
// text) to be the icon indicated by @gicon with the size indicated by
// @size. If @gicon is nil, the image will be hidden.
func (tooltip tooltip) SetIconFromGIcon(gicon gio.Icon, size int) {
	var arg0 *C.GtkTooltip
	var arg1 *C.GIcon
	var arg2 C.GtkIconSize

	arg0 = (*C.GtkTooltip)(tooltip.Native())
	arg1 = (*C.GIcon)(gicon.Native())
	arg2 = C.GtkIconSize(size)

	C.gtk_tooltip_set_icon_from_gicon(arg0, arg1, arg2)
}

// SetIconFromIconName sets the icon of the tooltip (which is in front of
// the text) to be the icon indicated by @icon_name with the size indicated
// by @size. If @icon_name is nil, the image will be hidden.
func (tooltip tooltip) SetIconFromIconName(iconName string, size int) {
	var arg0 *C.GtkTooltip
	var arg1 *C.gchar
	var arg2 C.GtkIconSize

	arg0 = (*C.GtkTooltip)(tooltip.Native())
	arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.GtkIconSize(size)

	C.gtk_tooltip_set_icon_from_icon_name(arg0, arg1, arg2)
}

// SetIconFromStock sets the icon of the tooltip (which is in front of the
// text) to be the stock item indicated by @stock_id with the size indicated
// by @size. If @stock_id is nil, the image will be hidden.
func (tooltip tooltip) SetIconFromStock(stockID string, size int) {
	var arg0 *C.GtkTooltip
	var arg1 *C.gchar
	var arg2 C.GtkIconSize

	arg0 = (*C.GtkTooltip)(tooltip.Native())
	arg1 = (*C.gchar)(C.CString(stockID))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.GtkIconSize(size)

	C.gtk_tooltip_set_icon_from_stock(arg0, arg1, arg2)
}

// SetMarkup sets the text of the tooltip to be @markup, which is marked up
// with the [Pango text markup language][PangoMarkupFormat]. If @markup is
// nil, the label will be hidden.
func (tooltip tooltip) SetMarkup(markup string) {
	var arg0 *C.GtkTooltip
	var arg1 *C.gchar

	arg0 = (*C.GtkTooltip)(tooltip.Native())
	arg1 = (*C.gchar)(C.CString(markup))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_tooltip_set_markup(arg0, arg1)
}

// SetText sets the text of the tooltip to be @text. If @text is nil, the
// label will be hidden. See also gtk_tooltip_set_markup().
func (tooltip tooltip) SetText(text string) {
	var arg0 *C.GtkTooltip
	var arg1 *C.gchar

	arg0 = (*C.GtkTooltip)(tooltip.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_tooltip_set_text(arg0, arg1)
}

// SetTipArea sets the area of the widget, where the contents of this
// tooltip apply, to be @rect (in widget coordinates). This is especially
// useful for properly setting tooltips on TreeView rows and cells,
// IconViews, etc.
//
// For setting tooltips on TreeView, please refer to the convenience
// functions for this: gtk_tree_view_set_tooltip_row() and
// gtk_tree_view_set_tooltip_cell().
func (tooltip tooltip) SetTipArea(rect *gdk.Rectangle) {
	var arg0 *C.GtkTooltip
	var arg1 *C.GdkRectangle

	arg0 = (*C.GtkTooltip)(tooltip.Native())
	arg1 = (*C.GdkRectangle)(rect.Native())

	C.gtk_tooltip_set_tip_area(arg0, arg1)
}

// TreeModelFilter: a TreeModelFilter is a tree model which wraps another tree
// model, and can do the following things:
//
// - Filter specific rows, based on data from a “visible column”, a column
// storing booleans indicating whether the row should be filtered or not, or
// based on the return value of a “visible function”, which gets a model, iter
// and user_data and returns a boolean indicating whether the row should be
// filtered or not.
//
// - Modify the “appearance” of the model, using a modify function. This is
// extremely powerful and allows for just changing some values and also for
// creating a completely different model based on the given child model.
//
// - Set a different root node, also known as a “virtual root”. You can pass in
// a TreePath indicating the root node for the filter at construction time.
//
// The basic API is similar to TreeModelSort. For an example on its usage, see
// the section on TreeModelSort.
//
// When using TreeModelFilter, it is important to realize that TreeModelFilter
// maintains an internal cache of all nodes which are visible in its clients.
// The cache is likely to be a subtree of the tree exposed by the child model.
// TreeModelFilter will not cache the entire child model when unnecessary to not
// compromise the caching mechanism that is exposed by the reference counting
// scheme. If the child model implements reference counting, unnecessary signals
// may not be emitted because of reference counting rule 3, see the TreeModel
// documentation. (Note that e.g. TreeStore does not implement reference
// counting and will always emit all signals, even when the receiving node is
// not visible).
//
// Because of this, limitations for possible visible functions do apply. In
// general, visible functions should only use data or properties from the node
// for which the visibility state must be determined, its siblings or its
// parents. Usually, having a dependency on the state of any child node is not
// possible, unless references are taken on these explicitly. When no such
// reference exists, no signals may be received for these child nodes (see
// reference couting rule number 3 in the TreeModel section).
//
// Determining the visibility state of a given node based on the state of its
// child nodes is a frequently occurring use case. Therefore, TreeModelFilter
// explicitly supports this. For example, when a node does not have any
// children, you might not want the node to be visible. As soon as the first row
// is added to the node’s child level (or the last row removed), the node’s
// visibility should be updated.
//
// This introduces a dependency from the node on its child nodes. In order to
// accommodate this, TreeModelFilter must make sure the necessary signals are
// received from the child model. This is achieved by building, for all nodes
// which are exposed as visible nodes to TreeModelFilter's clients, the child
// level (if any) and take a reference on the first node in this level.
// Furthermore, for every row-inserted, row-changed or row-deleted signal (also
// these which were not handled because the node was not cached),
// TreeModelFilter will check if the visibility state of any parent node has
// changed.
//
// Beware, however, that this explicit support is limited to these two cases.
// For example, if you want a node to be visible only if two nodes in a child’s
// child level (2 levels deeper) are visible, you are on your own. In this case,
// either rely on TreeStore to emit all signals because it does not implement
// reference counting, or for models that do implement reference counting,
// obtain references on these child levels yourself.
type TreeModelFilter interface {
	gextras.Objector
	TreeDragSource
	TreeModel

	// ClearCache: this function should almost never be called. It clears the
	// @filter of any cached iterators that haven’t been reffed with
	// gtk_tree_model_ref_node(). This might be useful if the child model being
	// filtered is static (and doesn’t change often) and there has been a lot of
	// unreffed access to nodes. As a side effect of this function, all unreffed
	// iters will be invalid.
	ClearCache()
	// ConvertChildIterToIter sets @filter_iter to point to the row in @filter
	// that corresponds to the row pointed at by @child_iter. If @filter_iter
	// was not set, false is returned.
	ConvertChildIterToIter(childIter *TreeIter) (filterIter TreeIter, ok bool)
	// ConvertChildPathToPath converts @child_path to a path relative to
	// @filter. That is, @child_path points to a path in the child model. The
	// rerturned path will point to the same row in the filtered model. If
	// @child_path isn’t a valid path on the child model or points to a row
	// which is not visible in @filter, then nil is returned.
	ConvertChildPathToPath(childPath *TreePath) *TreePath
	// ConvertIterToChildIter sets @child_iter to point to the row pointed to by
	// @filter_iter.
	ConvertIterToChildIter(filterIter *TreeIter) TreeIter
	// ConvertPathToChildPath converts @filter_path to a path on the child model
	// of @filter. That is, @filter_path points to a location in @filter. The
	// returned path will point to the same location in the model not being
	// filtered. If @filter_path does not point to a location in the child
	// model, nil is returned.
	ConvertPathToChildPath(filterPath *TreePath) *TreePath
	// Model returns a pointer to the child model of @filter.
	Model() TreeModel
	// Refilter emits ::row_changed for each row in the child model, which
	// causes the filter to re-evaluate whether a row is visible or not.
	Refilter()
	// SetModifyFunc: with the @n_columns and @types parameters, you give an
	// array of column types for this model (which will be exposed to the parent
	// model/view). The @func, @data and @destroy parameters are for specifying
	// the modify function. The modify function will get called for each data
	// access, the goal of the modify function is to return the data which
	// should be displayed at the location specified using the parameters of the
	// modify function.
	//
	// Note that gtk_tree_model_filter_set_modify_func() can only be called once
	// for a given filter model.
	SetModifyFunc(nColumns int, types []externglib.Type, fn TreeModelFilterModifyFunc)
	// SetVisibleColumn sets @column of the child_model to be the column where
	// @filter should look for visibility information. @columns should be a
	// column of type G_TYPE_BOOLEAN, where true means that a row is visible,
	// and false if not.
	//
	// Note that gtk_tree_model_filter_set_visible_func() or
	// gtk_tree_model_filter_set_visible_column() can only be called once for a
	// given filter model.
	SetVisibleColumn(column int)
	// SetVisibleFunc sets the visible function used when filtering the @filter
	// to be @func. The function should return true if the given row should be
	// visible and false otherwise.
	//
	// If the condition calculated by the function changes over time (e.g.
	// because it depends on some global parameters), you must call
	// gtk_tree_model_filter_refilter() to keep the visibility information of
	// the model up-to-date.
	//
	// Note that @func is called whenever a row is inserted, when it may still
	// be empty. The visible function should therefore take special care of
	// empty rows, like in the example below.
	//
	//    static gboolean
	//    visible_func (GtkTreeModel *model,
	//                  GtkTreeIter  *iter,
	//                  gpointer      data)
	//    {
	//      // Visible if row is non-empty and first column is “HI”
	//      gchar *str;
	//      gboolean visible = FALSE;
	//
	//      gtk_tree_model_get (model, iter, 0, &str, -1);
	//      if (str && strcmp (str, "HI") == 0)
	//        visible = TRUE;
	//      g_free (str);
	//
	//      return visible;
	//    }
	//
	// Note that gtk_tree_model_filter_set_visible_func() or
	// gtk_tree_model_filter_set_visible_column() can only be called once for a
	// given filter model.
	SetVisibleFunc(fn TreeModelFilterVisibleFunc)
}

// treeModelFilter implements the TreeModelFilter interface.
type treeModelFilter struct {
	gextras.Objector
	TreeDragSource
	TreeModel
}

var _ TreeModelFilter = (*treeModelFilter)(nil)

// WrapTreeModelFilter wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeModelFilter(obj *externglib.Object) TreeModelFilter {
	return TreeModelFilter{
		Objector:       obj,
		TreeDragSource: WrapTreeDragSource(obj),
		TreeModel:      WrapTreeModel(obj),
	}
}

func marshalTreeModelFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeModelFilter(obj), nil
}

// ClearCache: this function should almost never be called. It clears the
// @filter of any cached iterators that haven’t been reffed with
// gtk_tree_model_ref_node(). This might be useful if the child model being
// filtered is static (and doesn’t change often) and there has been a lot of
// unreffed access to nodes. As a side effect of this function, all unreffed
// iters will be invalid.
func (filter treeModelFilter) ClearCache() {
	var arg0 *C.GtkTreeModelFilter

	arg0 = (*C.GtkTreeModelFilter)(filter.Native())

	C.gtk_tree_model_filter_clear_cache(arg0)
}

// ConvertChildIterToIter sets @filter_iter to point to the row in @filter
// that corresponds to the row pointed at by @child_iter. If @filter_iter
// was not set, false is returned.
func (filter treeModelFilter) ConvertChildIterToIter(childIter *TreeIter) (filterIter TreeIter, ok bool) {
	var arg0 *C.GtkTreeModelFilter
	var arg1 *C.GtkTreeIter // out
	var arg2 *C.GtkTreeIter

	arg0 = (*C.GtkTreeModelFilter)(filter.Native())
	arg2 = (*C.GtkTreeIter)(childIter.Native())

	ret := C.gtk_tree_model_filter_convert_child_iter_to_iter(arg0, &arg1, arg2)

	var ret0 *TreeIter
	var ret1 bool

	{
		ret0 = WrapTreeIter(unsafe.Pointer(arg1))
	}

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// ConvertChildPathToPath converts @child_path to a path relative to
// @filter. That is, @child_path points to a path in the child model. The
// rerturned path will point to the same row in the filtered model. If
// @child_path isn’t a valid path on the child model or points to a row
// which is not visible in @filter, then nil is returned.
func (filter treeModelFilter) ConvertChildPathToPath(childPath *TreePath) *TreePath {
	var arg0 *C.GtkTreeModelFilter
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkTreeModelFilter)(filter.Native())
	arg1 = (*C.GtkTreePath)(childPath.Native())

	ret := C.gtk_tree_model_filter_convert_child_path_to_path(arg0, arg1)

	var ret0 *TreePath

	{
		ret0 = WrapTreePath(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *TreePath) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// ConvertIterToChildIter sets @child_iter to point to the row pointed to by
// @filter_iter.
func (filter treeModelFilter) ConvertIterToChildIter(filterIter *TreeIter) TreeIter {
	var arg0 *C.GtkTreeModelFilter
	var arg1 *C.GtkTreeIter // out
	var arg2 *C.GtkTreeIter

	arg0 = (*C.GtkTreeModelFilter)(filter.Native())
	arg2 = (*C.GtkTreeIter)(filterIter.Native())

	C.gtk_tree_model_filter_convert_iter_to_child_iter(arg0, &arg1, arg2)

	var ret0 *TreeIter

	{
		ret0 = WrapTreeIter(unsafe.Pointer(arg1))
	}

	return ret0
}

// ConvertPathToChildPath converts @filter_path to a path on the child model
// of @filter. That is, @filter_path points to a location in @filter. The
// returned path will point to the same location in the model not being
// filtered. If @filter_path does not point to a location in the child
// model, nil is returned.
func (filter treeModelFilter) ConvertPathToChildPath(filterPath *TreePath) *TreePath {
	var arg0 *C.GtkTreeModelFilter
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkTreeModelFilter)(filter.Native())
	arg1 = (*C.GtkTreePath)(filterPath.Native())

	ret := C.gtk_tree_model_filter_convert_path_to_child_path(arg0, arg1)

	var ret0 *TreePath

	{
		ret0 = WrapTreePath(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *TreePath) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Model returns a pointer to the child model of @filter.
func (filter treeModelFilter) Model() TreeModel {
	var arg0 *C.GtkTreeModelFilter

	arg0 = (*C.GtkTreeModelFilter)(filter.Native())

	ret := C.gtk_tree_model_filter_get_model(arg0)

	var ret0 TreeModel

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(TreeModel)

	return ret0
}

// Refilter emits ::row_changed for each row in the child model, which
// causes the filter to re-evaluate whether a row is visible or not.
func (filter treeModelFilter) Refilter() {
	var arg0 *C.GtkTreeModelFilter

	arg0 = (*C.GtkTreeModelFilter)(filter.Native())

	C.gtk_tree_model_filter_refilter(arg0)
}

// SetModifyFunc: with the @n_columns and @types parameters, you give an
// array of column types for this model (which will be exposed to the parent
// model/view). The @func, @data and @destroy parameters are for specifying
// the modify function. The modify function will get called for each data
// access, the goal of the modify function is to return the data which
// should be displayed at the location specified using the parameters of the
// modify function.
//
// Note that gtk_tree_model_filter_set_modify_func() can only be called once
// for a given filter model.
func (filter treeModelFilter) SetModifyFunc(nColumns int, types []externglib.Type, fn TreeModelFilterModifyFunc) {
	var arg0 *C.GtkTreeModelFilter
	var arg1 C.gint
	var arg2 *C.GType
	var arg3 C.GtkTreeModelFilterModifyFunc
	var arg4 C.gpointer
	var arg5 C.GDestroyNotify

	arg0 = (*C.GtkTreeModelFilter)(filter.Native())
	{
		var dst []C.GType
		ptr := C.malloc(C.sizeof_GType * len(types))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(types)
		sliceHeader.Cap = len(types)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(types); i++ {
			src := types[i]
			dst[i] = C.GType(src)
		}

		arg2 = (*C.GType)(unsafe.Pointer(ptr))
		arg1 = len(types)
	}
	arg3 = (*[0]byte)(C.gotk4_TreeModelFilterModifyFunc)
	arg4 = C.gpointer(box.Assign(fn))
	arg5 = (*[0]byte)(C.callbackDelete)

	C.gtk_tree_model_filter_set_modify_func(arg0, arg1, arg2, arg3, arg4, arg5)
}

// SetVisibleColumn sets @column of the child_model to be the column where
// @filter should look for visibility information. @columns should be a
// column of type G_TYPE_BOOLEAN, where true means that a row is visible,
// and false if not.
//
// Note that gtk_tree_model_filter_set_visible_func() or
// gtk_tree_model_filter_set_visible_column() can only be called once for a
// given filter model.
func (filter treeModelFilter) SetVisibleColumn(column int) {
	var arg0 *C.GtkTreeModelFilter
	var arg1 C.gint

	arg0 = (*C.GtkTreeModelFilter)(filter.Native())
	arg1 = C.gint(column)

	C.gtk_tree_model_filter_set_visible_column(arg0, arg1)
}

// SetVisibleFunc sets the visible function used when filtering the @filter
// to be @func. The function should return true if the given row should be
// visible and false otherwise.
//
// If the condition calculated by the function changes over time (e.g.
// because it depends on some global parameters), you must call
// gtk_tree_model_filter_refilter() to keep the visibility information of
// the model up-to-date.
//
// Note that @func is called whenever a row is inserted, when it may still
// be empty. The visible function should therefore take special care of
// empty rows, like in the example below.
//
//    static gboolean
//    visible_func (GtkTreeModel *model,
//                  GtkTreeIter  *iter,
//                  gpointer      data)
//    {
//      // Visible if row is non-empty and first column is “HI”
//      gchar *str;
//      gboolean visible = FALSE;
//
//      gtk_tree_model_get (model, iter, 0, &str, -1);
//      if (str && strcmp (str, "HI") == 0)
//        visible = TRUE;
//      g_free (str);
//
//      return visible;
//    }
//
// Note that gtk_tree_model_filter_set_visible_func() or
// gtk_tree_model_filter_set_visible_column() can only be called once for a
// given filter model.
func (filter treeModelFilter) SetVisibleFunc(fn TreeModelFilterVisibleFunc) {
	var arg0 *C.GtkTreeModelFilter
	var arg1 C.GtkTreeModelFilterVisibleFunc
	var arg2 C.gpointer
	var arg3 C.GDestroyNotify

	arg0 = (*C.GtkTreeModelFilter)(filter.Native())
	arg1 = (*[0]byte)(C.gotk4_TreeModelFilterVisibleFunc)
	arg2 = C.gpointer(box.Assign(fn))
	arg3 = (*[0]byte)(C.callbackDelete)

	C.gtk_tree_model_filter_set_visible_func(arg0, arg1, arg2, arg3)
}

// TreeModelSort: the TreeModelSort is a model which implements the TreeSortable
// interface. It does not hold any data itself, but rather is created with a
// child model and proxies its data. It has identical column types to this child
// model, and the changes in the child are propagated. The primary purpose of
// this model is to provide a way to sort a different model without modifying
// it. Note that the sort function used by TreeModelSort is not guaranteed to be
// stable.
//
// The use of this is best demonstrated through an example. In the following
// sample code we create two TreeView widgets each with a view of the same data.
// As the model is wrapped here by a TreeModelSort, the two TreeViews can each
// sort their view of the data without affecting the other. By contrast, if we
// simply put the same model in each widget, then sorting the first would sort
// the second.
//
// Using a TreeModelSort
//
//    void
//    selection_changed (GtkTreeSelection *selection, gpointer data)
//    {
//      GtkTreeModel *sort_model = NULL;
//      GtkTreeModel *child_model;
//      GtkTreeIter sort_iter;
//      GtkTreeIter child_iter;
//      char *some_data = NULL;
//      char *modified_data;
//
//      // Get the current selected row and the model.
//      if (! gtk_tree_selection_get_selected (selection,
//                                             &sort_model,
//                                             &sort_iter))
//        return;
//
//      // Look up the current value on the selected row and get
//      // a new value to change it to.
//      gtk_tree_model_get (GTK_TREE_MODEL (sort_model), &sort_iter,
//                          COLUMN_1, &some_data,
//                          -1);
//
//      modified_data = change_the_data (some_data);
//      g_free (some_data);
//
//      // Get an iterator on the child model, instead of the sort model.
//      gtk_tree_model_sort_convert_iter_to_child_iter (GTK_TREE_MODEL_SORT (sort_model),
//                                                      &child_iter,
//                                                      &sort_iter);
//
//      // Get the child model and change the value of the row. In this
//      // example, the child model is a GtkListStore. It could be any other
//      // type of model, though.
//      child_model = gtk_tree_model_sort_get_model (GTK_TREE_MODEL_SORT (sort_model));
//      gtk_list_store_set (GTK_LIST_STORE (child_model), &child_iter,
//                          COLUMN_1, &modified_data,
//                          -1);
//      g_free (modified_data);
//    }
type TreeModelSort interface {
	gextras.Objector
	TreeDragSource
	TreeModel
	TreeSortable

	// ClearCache: this function should almost never be called. It clears the
	// @tree_model_sort of any cached iterators that haven’t been reffed with
	// gtk_tree_model_ref_node(). This might be useful if the child model being
	// sorted is static (and doesn’t change often) and there has been a lot of
	// unreffed access to nodes. As a side effect of this function, all unreffed
	// iters will be invalid.
	ClearCache()
	// ConvertChildIterToIter sets @sort_iter to point to the row in
	// @tree_model_sort that corresponds to the row pointed at by @child_iter.
	// If @sort_iter was not set, false is returned. Note: a boolean is only
	// returned since 2.14.
	ConvertChildIterToIter(childIter *TreeIter) (sortIter TreeIter, ok bool)
	// ConvertChildPathToPath converts @child_path to a path relative to
	// @tree_model_sort. That is, @child_path points to a path in the child
	// model. The returned path will point to the same row in the sorted model.
	// If @child_path isn’t a valid path on the child model, then nil is
	// returned.
	ConvertChildPathToPath(childPath *TreePath) *TreePath
	// ConvertIterToChildIter sets @child_iter to point to the row pointed to by
	// @sorted_iter.
	ConvertIterToChildIter(sortedIter *TreeIter) TreeIter
	// ConvertPathToChildPath converts @sorted_path to a path on the child model
	// of @tree_model_sort. That is, @sorted_path points to a location in
	// @tree_model_sort. The returned path will point to the same location in
	// the model not being sorted. If @sorted_path does not point to a location
	// in the child model, nil is returned.
	ConvertPathToChildPath(sortedPath *TreePath) *TreePath
	// Model returns the model the TreeModelSort is sorting.
	Model() TreeModel
	// IterIsValid: > This function is slow. Only use it for debugging and/or
	// testing > purposes.
	//
	// Checks if the given iter is a valid iter for this TreeModelSort.
	IterIsValid(iter *TreeIter) bool
	// ResetDefaultSortFunc: this resets the default sort function to be in the
	// “unsorted” state. That is, it is in the same order as the child model. It
	// will re-sort the model to be in the same order as the child model only if
	// the TreeModelSort is in “unsorted” state.
	ResetDefaultSortFunc()
}

// treeModelSort implements the TreeModelSort interface.
type treeModelSort struct {
	gextras.Objector
	TreeDragSource
	TreeModel
	TreeSortable
}

var _ TreeModelSort = (*treeModelSort)(nil)

// WrapTreeModelSort wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeModelSort(obj *externglib.Object) TreeModelSort {
	return TreeModelSort{
		Objector:       obj,
		TreeDragSource: WrapTreeDragSource(obj),
		TreeModel:      WrapTreeModel(obj),
		TreeSortable:   WrapTreeSortable(obj),
	}
}

func marshalTreeModelSort(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeModelSort(obj), nil
}

// NewTreeModelSortWithModel constructs a class TreeModelSort.
func NewTreeModelSortWithModel(childModel TreeModel) TreeModelSort {
	var arg1 *C.GtkTreeModel

	arg1 = (*C.GtkTreeModel)(childModel.Native())

	ret := C.gtk_tree_model_sort_new_with_model(arg1)

	var ret0 TreeModelSort

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(TreeModelSort)

	return ret0
}

// ClearCache: this function should almost never be called. It clears the
// @tree_model_sort of any cached iterators that haven’t been reffed with
// gtk_tree_model_ref_node(). This might be useful if the child model being
// sorted is static (and doesn’t change often) and there has been a lot of
// unreffed access to nodes. As a side effect of this function, all unreffed
// iters will be invalid.
func (treeModelSort treeModelSort) ClearCache() {
	var arg0 *C.GtkTreeModelSort

	arg0 = (*C.GtkTreeModelSort)(treeModelSort.Native())

	C.gtk_tree_model_sort_clear_cache(arg0)
}

// ConvertChildIterToIter sets @sort_iter to point to the row in
// @tree_model_sort that corresponds to the row pointed at by @child_iter.
// If @sort_iter was not set, false is returned. Note: a boolean is only
// returned since 2.14.
func (treeModelSort treeModelSort) ConvertChildIterToIter(childIter *TreeIter) (sortIter TreeIter, ok bool) {
	var arg0 *C.GtkTreeModelSort
	var arg1 *C.GtkTreeIter // out
	var arg2 *C.GtkTreeIter

	arg0 = (*C.GtkTreeModelSort)(treeModelSort.Native())
	arg2 = (*C.GtkTreeIter)(childIter.Native())

	ret := C.gtk_tree_model_sort_convert_child_iter_to_iter(arg0, &arg1, arg2)

	var ret0 *TreeIter
	var ret1 bool

	{
		ret0 = WrapTreeIter(unsafe.Pointer(arg1))
	}

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// ConvertChildPathToPath converts @child_path to a path relative to
// @tree_model_sort. That is, @child_path points to a path in the child
// model. The returned path will point to the same row in the sorted model.
// If @child_path isn’t a valid path on the child model, then nil is
// returned.
func (treeModelSort treeModelSort) ConvertChildPathToPath(childPath *TreePath) *TreePath {
	var arg0 *C.GtkTreeModelSort
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkTreeModelSort)(treeModelSort.Native())
	arg1 = (*C.GtkTreePath)(childPath.Native())

	ret := C.gtk_tree_model_sort_convert_child_path_to_path(arg0, arg1)

	var ret0 *TreePath

	{
		ret0 = WrapTreePath(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *TreePath) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// ConvertIterToChildIter sets @child_iter to point to the row pointed to by
// @sorted_iter.
func (treeModelSort treeModelSort) ConvertIterToChildIter(sortedIter *TreeIter) TreeIter {
	var arg0 *C.GtkTreeModelSort
	var arg1 *C.GtkTreeIter // out
	var arg2 *C.GtkTreeIter

	arg0 = (*C.GtkTreeModelSort)(treeModelSort.Native())
	arg2 = (*C.GtkTreeIter)(sortedIter.Native())

	C.gtk_tree_model_sort_convert_iter_to_child_iter(arg0, &arg1, arg2)

	var ret0 *TreeIter

	{
		ret0 = WrapTreeIter(unsafe.Pointer(arg1))
	}

	return ret0
}

// ConvertPathToChildPath converts @sorted_path to a path on the child model
// of @tree_model_sort. That is, @sorted_path points to a location in
// @tree_model_sort. The returned path will point to the same location in
// the model not being sorted. If @sorted_path does not point to a location
// in the child model, nil is returned.
func (treeModelSort treeModelSort) ConvertPathToChildPath(sortedPath *TreePath) *TreePath {
	var arg0 *C.GtkTreeModelSort
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkTreeModelSort)(treeModelSort.Native())
	arg1 = (*C.GtkTreePath)(sortedPath.Native())

	ret := C.gtk_tree_model_sort_convert_path_to_child_path(arg0, arg1)

	var ret0 *TreePath

	{
		ret0 = WrapTreePath(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *TreePath) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Model returns the model the TreeModelSort is sorting.
func (treeModel treeModelSort) Model() TreeModel {
	var arg0 *C.GtkTreeModelSort

	arg0 = (*C.GtkTreeModelSort)(treeModel.Native())

	ret := C.gtk_tree_model_sort_get_model(arg0)

	var ret0 TreeModel

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(TreeModel)

	return ret0
}

// IterIsValid: > This function is slow. Only use it for debugging and/or
// testing > purposes.
//
// Checks if the given iter is a valid iter for this TreeModelSort.
func (treeModelSort treeModelSort) IterIsValid(iter *TreeIter) bool {
	var arg0 *C.GtkTreeModelSort
	var arg1 *C.GtkTreeIter

	arg0 = (*C.GtkTreeModelSort)(treeModelSort.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())

	ret := C.gtk_tree_model_sort_iter_is_valid(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ResetDefaultSortFunc: this resets the default sort function to be in the
// “unsorted” state. That is, it is in the same order as the child model. It
// will re-sort the model to be in the same order as the child model only if
// the TreeModelSort is in “unsorted” state.
func (treeModelSort treeModelSort) ResetDefaultSortFunc() {
	var arg0 *C.GtkTreeModelSort

	arg0 = (*C.GtkTreeModelSort)(treeModelSort.Native())

	C.gtk_tree_model_sort_reset_default_sort_func(arg0)
}

// TreeSelection: the TreeSelection object is a helper object to manage the
// selection for a TreeView widget. The TreeSelection object is automatically
// created when a new TreeView widget is created, and cannot exist independently
// of this widget. The primary reason the TreeSelection objects exists is for
// cleanliness of code and API. That is, there is no conceptual reason all these
// functions could not be methods on the TreeView widget instead of a separate
// function.
//
// The TreeSelection object is gotten from a TreeView by calling
// gtk_tree_view_get_selection(). It can be manipulated to check the selection
// status of the tree, as well as select and deselect individual rows. Selection
// is done completely view side. As a result, multiple views of the same model
// can have completely different selections. Additionally, you cannot change the
// selection of a row on the model that is not currently displayed by the view
// without expanding its parents first.
//
// One of the important things to remember when monitoring the selection of a
// view is that the TreeSelection::changed signal is mostly a hint. That is, it
// may only emit one signal when a range of rows is selected. Additionally, it
// may on occasion emit a TreeSelection::changed signal when nothing has
// happened (mostly as a result of programmers calling select_row on an already
// selected row).
type TreeSelection interface {
	gextras.Objector

	// CountSelectedRows returns the number of rows that have been selected in
	// @tree.
	CountSelectedRows() int
	// Mode gets the selection mode for @selection. See
	// gtk_tree_selection_set_mode().
	Mode() SelectionMode
	// Selected sets @iter to the currently selected node if @selection is set
	// to K_SELECTION_SINGLE or K_SELECTION_BROWSE. @iter may be NULL if you
	// just want to test if @selection has any selected nodes. @model is filled
	// with the current model as a convenience. This function will not work if
	// you use @selection is K_SELECTION_MULTIPLE.
	Selected() (model TreeModel, iter TreeIter, ok bool)
	// SelectedRows creates a list of path of all selected rows. Additionally,
	// if you are planning on modifying the model after calling this function,
	// you may want to convert the returned list into a list of
	// TreeRowReferences. To do this, you can use gtk_tree_row_reference_new().
	//
	// To free the return value, use:
	//
	//    g_list_free_full (list, (GDestroyNotify) gtk_tree_path_free);
	SelectedRows() (model TreeModel, list *glib.List)
	// TreeView returns the tree view associated with @selection.
	TreeView() TreeView
	// UserData returns the user data for the selection function.
	UserData() interface{}
	// IterIsSelected returns true if the row at @iter is currently selected.
	IterIsSelected(iter *TreeIter) bool
	// PathIsSelected returns true if the row pointed to by @path is currently
	// selected. If @path does not point to a valid location, false is returned
	PathIsSelected(path *TreePath) bool
	// SelectAll selects all the nodes. @selection must be set to
	// K_SELECTION_MULTIPLE mode.
	SelectAll()
	// SelectIter selects the specified iterator.
	SelectIter(iter *TreeIter)
	// SelectPath: select the row at @path.
	SelectPath(path *TreePath)
	// SelectRange selects a range of nodes, determined by @start_path and
	// @end_path inclusive. @selection must be set to K_SELECTION_MULTIPLE mode.
	SelectRange(startPath *TreePath, endPath *TreePath)
	// SelectedForeach calls a function for each selected node. Note that you
	// cannot modify the tree or selection from within this function. As a
	// result, gtk_tree_selection_get_selected_rows() might be more useful.
	SelectedForeach(fn TreeSelectionForeachFunc)
	// SetMode sets the selection mode of the @selection. If the previous type
	// was K_SELECTION_MULTIPLE, then the anchor is kept selected, if it was
	// previously selected.
	SetMode(typ SelectionMode)
	// SetSelectFunction sets the selection function.
	//
	// If set, this function is called before any node is selected or
	// unselected, giving some control over which nodes are selected. The select
	// function should return true if the state of the node may be toggled, and
	// false if the state of the node should be left unchanged.
	SetSelectFunction(fn TreeSelectionFunc)
	// UnselectAll unselects all the nodes.
	UnselectAll()
	// UnselectIter unselects the specified iterator.
	UnselectIter(iter *TreeIter)
	// UnselectPath unselects the row at @path.
	UnselectPath(path *TreePath)
	// UnselectRange unselects a range of nodes, determined by @start_path and
	// @end_path inclusive.
	UnselectRange(startPath *TreePath, endPath *TreePath)
}

// treeSelection implements the TreeSelection interface.
type treeSelection struct {
	gextras.Objector
}

var _ TreeSelection = (*treeSelection)(nil)

// WrapTreeSelection wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeSelection(obj *externglib.Object) TreeSelection {
	return TreeSelection{
		Objector: obj,
	}
}

func marshalTreeSelection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeSelection(obj), nil
}

// CountSelectedRows returns the number of rows that have been selected in
// @tree.
func (selection treeSelection) CountSelectedRows() int {
	var arg0 *C.GtkTreeSelection

	arg0 = (*C.GtkTreeSelection)(selection.Native())

	ret := C.gtk_tree_selection_count_selected_rows(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Mode gets the selection mode for @selection. See
// gtk_tree_selection_set_mode().
func (selection treeSelection) Mode() SelectionMode {
	var arg0 *C.GtkTreeSelection

	arg0 = (*C.GtkTreeSelection)(selection.Native())

	ret := C.gtk_tree_selection_get_mode(arg0)

	var ret0 SelectionMode

	ret0 = SelectionMode(ret)

	return ret0
}

// Selected sets @iter to the currently selected node if @selection is set
// to K_SELECTION_SINGLE or K_SELECTION_BROWSE. @iter may be NULL if you
// just want to test if @selection has any selected nodes. @model is filled
// with the current model as a convenience. This function will not work if
// you use @selection is K_SELECTION_MULTIPLE.
func (selection treeSelection) Selected() (model TreeModel, iter TreeIter, ok bool) {
	var arg0 *C.GtkTreeSelection
	var arg1 **C.GtkTreeModel // out
	var arg2 *C.GtkTreeIter   // out

	arg0 = (*C.GtkTreeSelection)(selection.Native())

	ret := C.gtk_tree_selection_get_selected(arg0, &arg1, &arg2)

	var ret0 *TreeModel
	var ret1 *TreeIter
	var ret2 bool

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(arg1.Native()))).(*TreeModel)

	{
		ret1 = WrapTreeIter(unsafe.Pointer(arg2))
	}

	ret2 = C.BOOL(ret) != 0

	return ret0, ret1, ret2
}

// SelectedRows creates a list of path of all selected rows. Additionally,
// if you are planning on modifying the model after calling this function,
// you may want to convert the returned list into a list of
// TreeRowReferences. To do this, you can use gtk_tree_row_reference_new().
//
// To free the return value, use:
//
//    g_list_free_full (list, (GDestroyNotify) gtk_tree_path_free);
func (selection treeSelection) SelectedRows() (model TreeModel, list *glib.List) {
	var arg0 *C.GtkTreeSelection
	var arg1 **C.GtkTreeModel // out

	arg0 = (*C.GtkTreeSelection)(selection.Native())

	ret := C.gtk_tree_selection_get_selected_rows(arg0, &arg1)

	var ret0 *TreeModel
	var ret1 *glib.List

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(arg1.Native()))).(*TreeModel)

	{
		ret1 = glib.WrapList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret1, func(v *glib.List) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0, ret1
}

// TreeView returns the tree view associated with @selection.
func (selection treeSelection) TreeView() TreeView {
	var arg0 *C.GtkTreeSelection

	arg0 = (*C.GtkTreeSelection)(selection.Native())

	ret := C.gtk_tree_selection_get_tree_view(arg0)

	var ret0 TreeView

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(TreeView)

	return ret0
}

// UserData returns the user data for the selection function.
func (selection treeSelection) UserData() interface{} {
	var arg0 *C.GtkTreeSelection

	arg0 = (*C.GtkTreeSelection)(selection.Native())

	ret := C.gtk_tree_selection_get_user_data(arg0)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// IterIsSelected returns true if the row at @iter is currently selected.
func (selection treeSelection) IterIsSelected(iter *TreeIter) bool {
	var arg0 *C.GtkTreeSelection
	var arg1 *C.GtkTreeIter

	arg0 = (*C.GtkTreeSelection)(selection.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())

	ret := C.gtk_tree_selection_iter_is_selected(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// PathIsSelected returns true if the row pointed to by @path is currently
// selected. If @path does not point to a valid location, false is returned
func (selection treeSelection) PathIsSelected(path *TreePath) bool {
	var arg0 *C.GtkTreeSelection
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkTreeSelection)(selection.Native())
	arg1 = (*C.GtkTreePath)(path.Native())

	ret := C.gtk_tree_selection_path_is_selected(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SelectAll selects all the nodes. @selection must be set to
// K_SELECTION_MULTIPLE mode.
func (selection treeSelection) SelectAll() {
	var arg0 *C.GtkTreeSelection

	arg0 = (*C.GtkTreeSelection)(selection.Native())

	C.gtk_tree_selection_select_all(arg0)
}

// SelectIter selects the specified iterator.
func (selection treeSelection) SelectIter(iter *TreeIter) {
	var arg0 *C.GtkTreeSelection
	var arg1 *C.GtkTreeIter

	arg0 = (*C.GtkTreeSelection)(selection.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())

	C.gtk_tree_selection_select_iter(arg0, arg1)
}

// SelectPath: select the row at @path.
func (selection treeSelection) SelectPath(path *TreePath) {
	var arg0 *C.GtkTreeSelection
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkTreeSelection)(selection.Native())
	arg1 = (*C.GtkTreePath)(path.Native())

	C.gtk_tree_selection_select_path(arg0, arg1)
}

// SelectRange selects a range of nodes, determined by @start_path and
// @end_path inclusive. @selection must be set to K_SELECTION_MULTIPLE mode.
func (selection treeSelection) SelectRange(startPath *TreePath, endPath *TreePath) {
	var arg0 *C.GtkTreeSelection
	var arg1 *C.GtkTreePath
	var arg2 *C.GtkTreePath

	arg0 = (*C.GtkTreeSelection)(selection.Native())
	arg1 = (*C.GtkTreePath)(startPath.Native())
	arg2 = (*C.GtkTreePath)(endPath.Native())

	C.gtk_tree_selection_select_range(arg0, arg1, arg2)
}

// SelectedForeach calls a function for each selected node. Note that you
// cannot modify the tree or selection from within this function. As a
// result, gtk_tree_selection_get_selected_rows() might be more useful.
func (selection treeSelection) SelectedForeach(fn TreeSelectionForeachFunc) {
	var arg0 *C.GtkTreeSelection
	var arg1 C.GtkTreeSelectionForeachFunc
	var arg2 C.gpointer

	arg0 = (*C.GtkTreeSelection)(selection.Native())
	arg1 = (*[0]byte)(C.gotk4_TreeSelectionForeachFunc)
	arg2 = C.gpointer(box.Assign(fn))

	C.gtk_tree_selection_selected_foreach(arg0, arg1, arg2)
}

// SetMode sets the selection mode of the @selection. If the previous type
// was K_SELECTION_MULTIPLE, then the anchor is kept selected, if it was
// previously selected.
func (selection treeSelection) SetMode(typ SelectionMode) {
	var arg0 *C.GtkTreeSelection
	var arg1 C.GtkSelectionMode

	arg0 = (*C.GtkTreeSelection)(selection.Native())
	arg1 = (C.GtkSelectionMode)(typ)

	C.gtk_tree_selection_set_mode(arg0, arg1)
}

// SetSelectFunction sets the selection function.
//
// If set, this function is called before any node is selected or
// unselected, giving some control over which nodes are selected. The select
// function should return true if the state of the node may be toggled, and
// false if the state of the node should be left unchanged.
func (selection treeSelection) SetSelectFunction(fn TreeSelectionFunc) {
	var arg0 *C.GtkTreeSelection
	var arg1 C.GtkTreeSelectionFunc
	var arg2 C.gpointer
	var arg3 C.GDestroyNotify

	arg0 = (*C.GtkTreeSelection)(selection.Native())
	arg1 = (*[0]byte)(C.gotk4_TreeSelectionFunc)
	arg2 = C.gpointer(box.Assign(fn))
	arg3 = (*[0]byte)(C.callbackDelete)

	C.gtk_tree_selection_set_select_function(arg0, arg1, arg2, arg3)
}

// UnselectAll unselects all the nodes.
func (selection treeSelection) UnselectAll() {
	var arg0 *C.GtkTreeSelection

	arg0 = (*C.GtkTreeSelection)(selection.Native())

	C.gtk_tree_selection_unselect_all(arg0)
}

// UnselectIter unselects the specified iterator.
func (selection treeSelection) UnselectIter(iter *TreeIter) {
	var arg0 *C.GtkTreeSelection
	var arg1 *C.GtkTreeIter

	arg0 = (*C.GtkTreeSelection)(selection.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())

	C.gtk_tree_selection_unselect_iter(arg0, arg1)
}

// UnselectPath unselects the row at @path.
func (selection treeSelection) UnselectPath(path *TreePath) {
	var arg0 *C.GtkTreeSelection
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkTreeSelection)(selection.Native())
	arg1 = (*C.GtkTreePath)(path.Native())

	C.gtk_tree_selection_unselect_path(arg0, arg1)
}

// UnselectRange unselects a range of nodes, determined by @start_path and
// @end_path inclusive.
func (selection treeSelection) UnselectRange(startPath *TreePath, endPath *TreePath) {
	var arg0 *C.GtkTreeSelection
	var arg1 *C.GtkTreePath
	var arg2 *C.GtkTreePath

	arg0 = (*C.GtkTreeSelection)(selection.Native())
	arg1 = (*C.GtkTreePath)(startPath.Native())
	arg2 = (*C.GtkTreePath)(endPath.Native())

	C.gtk_tree_selection_unselect_range(arg0, arg1, arg2)
}

// TreeStore: the TreeStore object is a list model for use with a TreeView
// widget. It implements the TreeModel interface, and consequentially, can use
// all of the methods available there. It also implements the TreeSortable
// interface so it can be sorted by the view. Finally, it also implements the
// tree [drag and drop][gtk3-GtkTreeView-drag-and-drop] interfaces.
//
//
// GtkTreeStore as GtkBuildable
//
// The GtkTreeStore implementation of the Buildable interface allows to specify
// the model columns with a <columns> element that may contain multiple <column>
// elements, each specifying one model column. The “type” attribute specifies
// the data type for the column.
//
// An example of a UI Definition fragment for a tree store:
//
//    <object class="GtkTreeStore">
//      <columns>
//        <column type="gchararray"/>
//        <column type="gchararray"/>
//        <column type="gint"/>
//      </columns>
//    </object>
type TreeStore interface {
	gextras.Objector
	Buildable
	TreeDragDest
	TreeDragSource
	TreeModel
	TreeSortable

	// Append appends a new row to @tree_store. If @parent is non-nil, then it
	// will append the new row after the last child of @parent, otherwise it
	// will append a row to the top level. @iter will be changed to point to
	// this new row. The row will be empty after this function is called. To
	// fill in values, you need to call gtk_tree_store_set() or
	// gtk_tree_store_set_value().
	Append(parent *TreeIter) TreeIter
	// Clear removes all rows from @tree_store
	Clear()
	// Insert creates a new row at @position. If parent is non-nil, then the row
	// will be made a child of @parent. Otherwise, the row will be created at
	// the toplevel. If @position is -1 or is larger than the number of rows at
	// that level, then the new row will be inserted to the end of the list.
	// @iter will be changed to point to this new row. The row will be empty
	// after this function is called. To fill in values, you need to call
	// gtk_tree_store_set() or gtk_tree_store_set_value().
	Insert(parent *TreeIter, position int) TreeIter
	// InsertAfter inserts a new row after @sibling. If @sibling is nil, then
	// the row will be prepended to @parent ’s children. If @parent and @sibling
	// are nil, then the row will be prepended to the toplevel. If both @sibling
	// and @parent are set, then @parent must be the parent of @sibling. When
	// @sibling is set, @parent is optional.
	//
	// @iter will be changed to point to this new row. The row will be empty
	// after this function is called. To fill in values, you need to call
	// gtk_tree_store_set() or gtk_tree_store_set_value().
	InsertAfter(parent *TreeIter, sibling *TreeIter) TreeIter
	// InsertBefore inserts a new row before @sibling. If @sibling is nil, then
	// the row will be appended to @parent ’s children. If @parent and @sibling
	// are nil, then the row will be appended to the toplevel. If both @sibling
	// and @parent are set, then @parent must be the parent of @sibling. When
	// @sibling is set, @parent is optional.
	//
	// @iter will be changed to point to this new row. The row will be empty
	// after this function is called. To fill in values, you need to call
	// gtk_tree_store_set() or gtk_tree_store_set_value().
	InsertBefore(parent *TreeIter, sibling *TreeIter) TreeIter
	// InsertWithValuesv: a variant of gtk_tree_store_insert_with_values() which
	// takes the columns and values as two arrays, instead of varargs. This
	// function is mainly intended for language bindings.
	InsertWithValuesv(parent *TreeIter, position int, columns []int, values []*externglib.Value) TreeIter
	// IsAncestor returns true if @iter is an ancestor of @descendant. That is,
	// @iter is the parent (or grandparent or great-grandparent) of @descendant.
	IsAncestor(iter *TreeIter, descendant *TreeIter) bool
	// IterDepth returns the depth of @iter. This will be 0 for anything on the
	// root level, 1 for anything down a level, etc.
	IterDepth(iter *TreeIter) int
	// IterIsValid: WARNING: This function is slow. Only use it for debugging
	// and/or testing purposes.
	//
	// Checks if the given iter is a valid iter for this TreeStore.
	IterIsValid(iter *TreeIter) bool
	// MoveAfter moves @iter in @tree_store to the position after @position.
	// @iter and @position should be in the same level. Note that this function
	// only works with unsorted stores. If @position is nil, @iter will be moved
	// to the start of the level.
	MoveAfter(iter *TreeIter, position *TreeIter)
	// MoveBefore moves @iter in @tree_store to the position before @position.
	// @iter and @position should be in the same level. Note that this function
	// only works with unsorted stores. If @position is nil, @iter will be moved
	// to the end of the level.
	MoveBefore(iter *TreeIter, position *TreeIter)
	// Prepend prepends a new row to @tree_store. If @parent is non-nil, then it
	// will prepend the new row before the first child of @parent, otherwise it
	// will prepend a row to the top level. @iter will be changed to point to
	// this new row. The row will be empty after this function is called. To
	// fill in values, you need to call gtk_tree_store_set() or
	// gtk_tree_store_set_value().
	Prepend(parent *TreeIter) TreeIter
	// Remove removes @iter from @tree_store. After being removed, @iter is set
	// to the next valid row at that level, or invalidated if it previously
	// pointed to the last one.
	Remove(iter *TreeIter) bool
	// SetColumnTypes: this function is meant primarily for #GObjects that
	// inherit from TreeStore, and should only be used when constructing a new
	// TreeStore. It will not function after a row has been added, or a method
	// on the TreeModel interface is called.
	SetColumnTypes(nColumns int, types []externglib.Type)
	// SetValue sets the data in the cell specified by @iter and @column. The
	// type of @value must be convertible to the type of the column.
	SetValue(iter *TreeIter, column int, value *externglib.Value)
	// SetValuesv: a variant of gtk_tree_store_set_valist() which takes the
	// columns and values as two arrays, instead of varargs. This function is
	// mainly intended for language bindings or in case the number of columns to
	// change is not known until run-time.
	SetValuesv(iter *TreeIter, columns []int, values []*externglib.Value)
	// Swap swaps @a and @b in the same level of @tree_store. Note that this
	// function only works with unsorted stores.
	Swap(a *TreeIter, b *TreeIter)
}

// treeStore implements the TreeStore interface.
type treeStore struct {
	gextras.Objector
	Buildable
	TreeDragDest
	TreeDragSource
	TreeModel
	TreeSortable
}

var _ TreeStore = (*treeStore)(nil)

// WrapTreeStore wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeStore(obj *externglib.Object) TreeStore {
	return TreeStore{
		Objector:       obj,
		Buildable:      WrapBuildable(obj),
		TreeDragDest:   WrapTreeDragDest(obj),
		TreeDragSource: WrapTreeDragSource(obj),
		TreeModel:      WrapTreeModel(obj),
		TreeSortable:   WrapTreeSortable(obj),
	}
}

func marshalTreeStore(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeStore(obj), nil
}

// NewTreeStoreV constructs a class TreeStore.
func NewTreeStoreV(nColumns int, types []externglib.Type) TreeStore {
	var arg1 C.gint
	var arg2 *C.GType

	{
		var dst []C.GType
		ptr := C.malloc(C.sizeof_GType * len(types))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(types)
		sliceHeader.Cap = len(types)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(types); i++ {
			src := types[i]
			dst[i] = C.GType(src)
		}

		arg2 = (*C.GType)(unsafe.Pointer(ptr))
		arg1 = len(types)
	}

	ret := C.gtk_tree_store_newv(arg1, arg2)

	var ret0 TreeStore

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(TreeStore)

	return ret0
}

// Append appends a new row to @tree_store. If @parent is non-nil, then it
// will append the new row after the last child of @parent, otherwise it
// will append a row to the top level. @iter will be changed to point to
// this new row. The row will be empty after this function is called. To
// fill in values, you need to call gtk_tree_store_set() or
// gtk_tree_store_set_value().
func (treeStore treeStore) Append(parent *TreeIter) TreeIter {
	var arg0 *C.GtkTreeStore
	var arg1 *C.GtkTreeIter // out
	var arg2 *C.GtkTreeIter

	arg0 = (*C.GtkTreeStore)(treeStore.Native())
	arg2 = (*C.GtkTreeIter)(parent.Native())

	C.gtk_tree_store_append(arg0, &arg1, arg2)

	var ret0 *TreeIter

	{
		ret0 = WrapTreeIter(unsafe.Pointer(arg1))
	}

	return ret0
}

// Clear removes all rows from @tree_store
func (treeStore treeStore) Clear() {
	var arg0 *C.GtkTreeStore

	arg0 = (*C.GtkTreeStore)(treeStore.Native())

	C.gtk_tree_store_clear(arg0)
}

// Insert creates a new row at @position. If parent is non-nil, then the row
// will be made a child of @parent. Otherwise, the row will be created at
// the toplevel. If @position is -1 or is larger than the number of rows at
// that level, then the new row will be inserted to the end of the list.
// @iter will be changed to point to this new row. The row will be empty
// after this function is called. To fill in values, you need to call
// gtk_tree_store_set() or gtk_tree_store_set_value().
func (treeStore treeStore) Insert(parent *TreeIter, position int) TreeIter {
	var arg0 *C.GtkTreeStore
	var arg1 *C.GtkTreeIter // out
	var arg2 *C.GtkTreeIter
	var arg3 C.gint

	arg0 = (*C.GtkTreeStore)(treeStore.Native())
	arg2 = (*C.GtkTreeIter)(parent.Native())
	arg3 = C.gint(position)

	C.gtk_tree_store_insert(arg0, &arg1, arg2, arg3)

	var ret0 *TreeIter

	{
		ret0 = WrapTreeIter(unsafe.Pointer(arg1))
	}

	return ret0
}

// InsertAfter inserts a new row after @sibling. If @sibling is nil, then
// the row will be prepended to @parent ’s children. If @parent and @sibling
// are nil, then the row will be prepended to the toplevel. If both @sibling
// and @parent are set, then @parent must be the parent of @sibling. When
// @sibling is set, @parent is optional.
//
// @iter will be changed to point to this new row. The row will be empty
// after this function is called. To fill in values, you need to call
// gtk_tree_store_set() or gtk_tree_store_set_value().
func (treeStore treeStore) InsertAfter(parent *TreeIter, sibling *TreeIter) TreeIter {
	var arg0 *C.GtkTreeStore
	var arg1 *C.GtkTreeIter // out
	var arg2 *C.GtkTreeIter
	var arg3 *C.GtkTreeIter

	arg0 = (*C.GtkTreeStore)(treeStore.Native())
	arg2 = (*C.GtkTreeIter)(parent.Native())
	arg3 = (*C.GtkTreeIter)(sibling.Native())

	C.gtk_tree_store_insert_after(arg0, &arg1, arg2, arg3)

	var ret0 *TreeIter

	{
		ret0 = WrapTreeIter(unsafe.Pointer(arg1))
	}

	return ret0
}

// InsertBefore inserts a new row before @sibling. If @sibling is nil, then
// the row will be appended to @parent ’s children. If @parent and @sibling
// are nil, then the row will be appended to the toplevel. If both @sibling
// and @parent are set, then @parent must be the parent of @sibling. When
// @sibling is set, @parent is optional.
//
// @iter will be changed to point to this new row. The row will be empty
// after this function is called. To fill in values, you need to call
// gtk_tree_store_set() or gtk_tree_store_set_value().
func (treeStore treeStore) InsertBefore(parent *TreeIter, sibling *TreeIter) TreeIter {
	var arg0 *C.GtkTreeStore
	var arg1 *C.GtkTreeIter // out
	var arg2 *C.GtkTreeIter
	var arg3 *C.GtkTreeIter

	arg0 = (*C.GtkTreeStore)(treeStore.Native())
	arg2 = (*C.GtkTreeIter)(parent.Native())
	arg3 = (*C.GtkTreeIter)(sibling.Native())

	C.gtk_tree_store_insert_before(arg0, &arg1, arg2, arg3)

	var ret0 *TreeIter

	{
		ret0 = WrapTreeIter(unsafe.Pointer(arg1))
	}

	return ret0
}

// InsertWithValuesv: a variant of gtk_tree_store_insert_with_values() which
// takes the columns and values as two arrays, instead of varargs. This
// function is mainly intended for language bindings.
func (treeStore treeStore) InsertWithValuesv(parent *TreeIter, position int, columns []int, values []*externglib.Value) TreeIter {
	var arg0 *C.GtkTreeStore
	var arg1 *C.GtkTreeIter // out
	var arg2 *C.GtkTreeIter
	var arg3 C.gint
	var arg4 *C.gint
	var arg5 *C.GValue
	var arg6 C.gint

	arg0 = (*C.GtkTreeStore)(treeStore.Native())
	arg2 = (*C.GtkTreeIter)(parent.Native())
	arg3 = C.gint(position)
	arg4 = (*C.gint)(unsafe.Pointer(&columns[0]))
	arg6 = len(columns)
	defer runtime.KeepAlive(columns)
	{
		var dst []C.GValue
		ptr := C.malloc(C.sizeof_GValue * len(values))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(values)
		sliceHeader.Cap = len(values)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(values); i++ {
			src := values[i]
			dst[i] = (*C.GValue)(src.GValue)
		}

		arg5 = (*C.GValue)(unsafe.Pointer(ptr))
		arg6 = len(values)
	}

	C.gtk_tree_store_insert_with_valuesv(arg0, &arg1, arg2, arg3, arg4, arg5, arg6)

	var ret0 *TreeIter

	{
		ret0 = WrapTreeIter(unsafe.Pointer(arg1))
	}

	return ret0
}

// IsAncestor returns true if @iter is an ancestor of @descendant. That is,
// @iter is the parent (or grandparent or great-grandparent) of @descendant.
func (treeStore treeStore) IsAncestor(iter *TreeIter, descendant *TreeIter) bool {
	var arg0 *C.GtkTreeStore
	var arg1 *C.GtkTreeIter
	var arg2 *C.GtkTreeIter

	arg0 = (*C.GtkTreeStore)(treeStore.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())
	arg2 = (*C.GtkTreeIter)(descendant.Native())

	ret := C.gtk_tree_store_is_ancestor(arg0, arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IterDepth returns the depth of @iter. This will be 0 for anything on the
// root level, 1 for anything down a level, etc.
func (treeStore treeStore) IterDepth(iter *TreeIter) int {
	var arg0 *C.GtkTreeStore
	var arg1 *C.GtkTreeIter

	arg0 = (*C.GtkTreeStore)(treeStore.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())

	ret := C.gtk_tree_store_iter_depth(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// IterIsValid: WARNING: This function is slow. Only use it for debugging
// and/or testing purposes.
//
// Checks if the given iter is a valid iter for this TreeStore.
func (treeStore treeStore) IterIsValid(iter *TreeIter) bool {
	var arg0 *C.GtkTreeStore
	var arg1 *C.GtkTreeIter

	arg0 = (*C.GtkTreeStore)(treeStore.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())

	ret := C.gtk_tree_store_iter_is_valid(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// MoveAfter moves @iter in @tree_store to the position after @position.
// @iter and @position should be in the same level. Note that this function
// only works with unsorted stores. If @position is nil, @iter will be moved
// to the start of the level.
func (treeStore treeStore) MoveAfter(iter *TreeIter, position *TreeIter) {
	var arg0 *C.GtkTreeStore
	var arg1 *C.GtkTreeIter
	var arg2 *C.GtkTreeIter

	arg0 = (*C.GtkTreeStore)(treeStore.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())
	arg2 = (*C.GtkTreeIter)(position.Native())

	C.gtk_tree_store_move_after(arg0, arg1, arg2)
}

// MoveBefore moves @iter in @tree_store to the position before @position.
// @iter and @position should be in the same level. Note that this function
// only works with unsorted stores. If @position is nil, @iter will be moved
// to the end of the level.
func (treeStore treeStore) MoveBefore(iter *TreeIter, position *TreeIter) {
	var arg0 *C.GtkTreeStore
	var arg1 *C.GtkTreeIter
	var arg2 *C.GtkTreeIter

	arg0 = (*C.GtkTreeStore)(treeStore.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())
	arg2 = (*C.GtkTreeIter)(position.Native())

	C.gtk_tree_store_move_before(arg0, arg1, arg2)
}

// Prepend prepends a new row to @tree_store. If @parent is non-nil, then it
// will prepend the new row before the first child of @parent, otherwise it
// will prepend a row to the top level. @iter will be changed to point to
// this new row. The row will be empty after this function is called. To
// fill in values, you need to call gtk_tree_store_set() or
// gtk_tree_store_set_value().
func (treeStore treeStore) Prepend(parent *TreeIter) TreeIter {
	var arg0 *C.GtkTreeStore
	var arg1 *C.GtkTreeIter // out
	var arg2 *C.GtkTreeIter

	arg0 = (*C.GtkTreeStore)(treeStore.Native())
	arg2 = (*C.GtkTreeIter)(parent.Native())

	C.gtk_tree_store_prepend(arg0, &arg1, arg2)

	var ret0 *TreeIter

	{
		ret0 = WrapTreeIter(unsafe.Pointer(arg1))
	}

	return ret0
}

// Remove removes @iter from @tree_store. After being removed, @iter is set
// to the next valid row at that level, or invalidated if it previously
// pointed to the last one.
func (treeStore treeStore) Remove(iter *TreeIter) bool {
	var arg0 *C.GtkTreeStore
	var arg1 *C.GtkTreeIter

	arg0 = (*C.GtkTreeStore)(treeStore.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())

	ret := C.gtk_tree_store_remove(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SetColumnTypes: this function is meant primarily for #GObjects that
// inherit from TreeStore, and should only be used when constructing a new
// TreeStore. It will not function after a row has been added, or a method
// on the TreeModel interface is called.
func (treeStore treeStore) SetColumnTypes(nColumns int, types []externglib.Type) {
	var arg0 *C.GtkTreeStore
	var arg1 C.gint
	var arg2 *C.GType

	arg0 = (*C.GtkTreeStore)(treeStore.Native())
	{
		var dst []C.GType
		ptr := C.malloc(C.sizeof_GType * len(types))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(types)
		sliceHeader.Cap = len(types)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(types); i++ {
			src := types[i]
			dst[i] = C.GType(src)
		}

		arg2 = (*C.GType)(unsafe.Pointer(ptr))
		arg1 = len(types)
	}

	C.gtk_tree_store_set_column_types(arg0, arg1, arg2)
}

// SetValue sets the data in the cell specified by @iter and @column. The
// type of @value must be convertible to the type of the column.
func (treeStore treeStore) SetValue(iter *TreeIter, column int, value *externglib.Value) {
	var arg0 *C.GtkTreeStore
	var arg1 *C.GtkTreeIter
	var arg2 C.gint
	var arg3 *C.GValue

	arg0 = (*C.GtkTreeStore)(treeStore.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())
	arg2 = C.gint(column)
	arg3 = (*C.GValue)(value.GValue)

	C.gtk_tree_store_set_value(arg0, arg1, arg2, arg3)
}

// SetValuesv: a variant of gtk_tree_store_set_valist() which takes the
// columns and values as two arrays, instead of varargs. This function is
// mainly intended for language bindings or in case the number of columns to
// change is not known until run-time.
func (treeStore treeStore) SetValuesv(iter *TreeIter, columns []int, values []*externglib.Value) {
	var arg0 *C.GtkTreeStore
	var arg1 *C.GtkTreeIter
	var arg2 *C.gint
	var arg3 *C.GValue
	var arg4 C.gint

	arg0 = (*C.GtkTreeStore)(treeStore.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())
	arg2 = (*C.gint)(unsafe.Pointer(&columns[0]))
	arg4 = len(columns)
	defer runtime.KeepAlive(columns)
	{
		var dst []C.GValue
		ptr := C.malloc(C.sizeof_GValue * len(values))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(values)
		sliceHeader.Cap = len(values)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(values); i++ {
			src := values[i]
			dst[i] = (*C.GValue)(src.GValue)
		}

		arg3 = (*C.GValue)(unsafe.Pointer(ptr))
		arg4 = len(values)
	}

	C.gtk_tree_store_set_valuesv(arg0, arg1, arg2, arg3, arg4)
}

// Swap swaps @a and @b in the same level of @tree_store. Note that this
// function only works with unsorted stores.
func (treeStore treeStore) Swap(a *TreeIter, b *TreeIter) {
	var arg0 *C.GtkTreeStore
	var arg1 *C.GtkTreeIter
	var arg2 *C.GtkTreeIter

	arg0 = (*C.GtkTreeStore)(treeStore.Native())
	arg1 = (*C.GtkTreeIter)(a.Native())
	arg2 = (*C.GtkTreeIter)(b.Native())

	C.gtk_tree_store_swap(arg0, arg1, arg2)
}

// TreeViewColumn: the GtkTreeViewColumn object represents a visible column in a
// TreeView widget. It allows to set properties of the column header, and
// functions as a holding pen for the cell renderers which determine how the
// data in the column is displayed.
//
// Please refer to the [tree widget conceptual overview][TreeWidget] for an
// overview of all the objects and data types related to the tree widget and how
// they work together.
type TreeViewColumn interface {
	gextras.Objector
	Buildable
	CellLayout

	// AddAttribute adds an attribute mapping to the list in @tree_column. The
	// @column is the column of the model to get a value from, and the
	// @attribute is the parameter on @cell_renderer to be set from the value.
	// So for example if column 2 of the model contains strings, you could have
	// the “text” attribute of a CellRendererText get its values from column 2.
	AddAttribute(cellRenderer CellRenderer, attribute string, column int)
	// CellGetPosition obtains the horizontal position and size of a cell in a
	// column. If the cell is not found in the column, @start_pos and @width are
	// not changed and false is returned.
	CellGetPosition(cellRenderer CellRenderer) (xOffset int, width int, ok bool)
	// CellGetSize obtains the width and height needed to render the column.
	// This is used primarily by the TreeView.
	CellGetSize(cellArea *gdk.Rectangle) (xOffset int, yOffset int, width int, height int)
	// CellIsVisible returns true if any of the cells packed into the
	// @tree_column are visible. For this to be meaningful, you must first
	// initialize the cells with gtk_tree_view_column_cell_set_cell_data()
	CellIsVisible() bool
	// CellSetCellData sets the cell renderer based on the @tree_model and
	// @iter. That is, for every attribute mapping in @tree_column, it will get
	// a value from the set column on the @iter, and use that value to set the
	// attribute on the cell renderer. This is used primarily by the TreeView.
	CellSetCellData(treeModel TreeModel, iter *TreeIter, isExpander bool, isExpanded bool)
	// Clear unsets all the mappings on all renderers on the @tree_column.
	Clear()
	// ClearAttributes clears all existing attributes previously set with
	// gtk_tree_view_column_set_attributes().
	ClearAttributes(cellRenderer CellRenderer)
	// Clicked emits the “clicked” signal on the column. This function will only
	// work if @tree_column is clickable.
	Clicked()
	// FocusCell sets the current keyboard focus to be at @cell, if the column
	// contains 2 or more editable and activatable cells.
	FocusCell(cell CellRenderer)
	// Alignment returns the current x alignment of @tree_column. This value can
	// range between 0.0 and 1.0.
	Alignment() float32
	// Button returns the button used in the treeview column header
	Button() Widget
	// Clickable returns true if the user can click on the header for the
	// column.
	Clickable() bool
	// Expand returns true if the column expands to fill available space.
	Expand() bool
	// FixedWidth gets the fixed width of the column. This may not be the actual
	// displayed width of the column; for that, use
	// gtk_tree_view_column_get_width().
	FixedWidth() int
	// MaxWidth returns the maximum width in pixels of the @tree_column, or -1
	// if no maximum width is set.
	MaxWidth() int
	// MinWidth returns the minimum width in pixels of the @tree_column, or -1
	// if no minimum width is set.
	MinWidth() int
	// Reorderable returns true if the @tree_column can be reordered by the
	// user.
	Reorderable() bool
	// Resizable returns true if the @tree_column can be resized by the end
	// user.
	Resizable() bool
	// Sizing returns the current type of @tree_column.
	Sizing() TreeViewColumnSizing
	// SortColumnID gets the logical @sort_column_id that the model sorts on
	// when this column is selected for sorting. See
	// gtk_tree_view_column_set_sort_column_id().
	SortColumnID() int
	// SortIndicator gets the value set by
	// gtk_tree_view_column_set_sort_indicator().
	SortIndicator() bool
	// SortOrder gets the value set by gtk_tree_view_column_set_sort_order().
	SortOrder() SortType
	// Spacing returns the spacing of @tree_column.
	Spacing() int
	// Title returns the title of the widget.
	Title() string
	// TreeView returns the TreeView wherein @tree_column has been inserted. If
	// @column is currently not inserted in any tree view, nil is returned.
	TreeView() Widget
	// Visible returns true if @tree_column is visible.
	Visible() bool
	// Widget returns the Widget in the button on the column header. If a custom
	// widget has not been set then nil is returned.
	Widget() Widget
	// Width returns the current size of @tree_column in pixels.
	Width() int
	// XOffset returns the current X offset of @tree_column in pixels.
	XOffset() int
	// PackEnd adds the @cell to end of the column. If @expand is false, then
	// the @cell is allocated no more space than it needs. Any unused space is
	// divided evenly between cells for which @expand is true.
	PackEnd(cell CellRenderer, expand bool)
	// PackStart packs the @cell into the beginning of the column. If @expand is
	// false, then the @cell is allocated no more space than it needs. Any
	// unused space is divided evenly between cells for which @expand is true.
	PackStart(cell CellRenderer, expand bool)
	// QueueResize flags the column, and the cell renderers added to this
	// column, to have their sizes renegotiated.
	QueueResize()
	// SetAlignment sets the alignment of the title or custom widget inside the
	// column header. The alignment determines its location inside the button --
	// 0.0 for left, 0.5 for center, 1.0 for right.
	SetAlignment(xalign float32)
	// SetCellDataFunc sets the TreeCellDataFunc to use for the column. This
	// function is used instead of the standard attributes mapping for setting
	// the column value, and should set the value of @tree_column's cell
	// renderer as appropriate. @func may be nil to remove an older one.
	SetCellDataFunc(cellRenderer CellRenderer, fn TreeCellDataFunc)
	// SetClickable sets the header to be active if @clickable is true. When the
	// header is active, then it can take keyboard focus, and can be clicked.
	SetClickable(clickable bool)
	// SetExpand sets the column to take available extra space. This space is
	// shared equally amongst all columns that have the expand set to true. If
	// no column has this option set, then the last column gets all extra space.
	// By default, every column is created with this false.
	//
	// Along with “fixed-width”, the “expand” property changes when the column
	// is resized by the user.
	SetExpand(expand bool)
	// SetFixedWidth: if @fixed_width is not -1, sets the fixed width of
	// @tree_column; otherwise unsets it. The effective value of @fixed_width is
	// clamped between the minimum and maximum width of the column; however, the
	// value stored in the “fixed-width” property is not clamped. If the column
	// sizing is K_TREE_VIEW_COLUMN_GROW_ONLY or K_TREE_VIEW_COLUMN_AUTOSIZE,
	// setting a fixed width overrides the automatically calculated width. Note
	// that @fixed_width is only a hint to GTK+; the width actually allocated to
	// the column may be greater or less than requested.
	//
	// Along with “expand”, the “fixed-width” property changes when the column
	// is resized by the user.
	SetFixedWidth(fixedWidth int)
	// SetMaxWidth sets the maximum width of the @tree_column. If @max_width is
	// -1, then the maximum width is unset. Note, the column can actually be
	// wider than max width if it’s the last column in a view. In this case, the
	// column expands to fill any extra space.
	SetMaxWidth(maxWidth int)
	// SetMinWidth sets the minimum width of the @tree_column. If @min_width is
	// -1, then the minimum width is unset.
	SetMinWidth(minWidth int)
	// SetReorderable: if @reorderable is true, then the column can be reordered
	// by the end user dragging the header.
	SetReorderable(reorderable bool)
	// SetResizable: if @resizable is true, then the user can explicitly resize
	// the column by grabbing the outer edge of the column button. If resizable
	// is true and sizing mode of the column is K_TREE_VIEW_COLUMN_AUTOSIZE,
	// then the sizing mode is changed to K_TREE_VIEW_COLUMN_GROW_ONLY.
	SetResizable(resizable bool)
	// SetSizing sets the growth behavior of @tree_column to @type.
	SetSizing(typ TreeViewColumnSizing)
	// SetSortColumnID sets the logical @sort_column_id that this column sorts
	// on when this column is selected for sorting. Doing so makes the column
	// header clickable.
	SetSortColumnID(sortColumnID int)
	// SetSortIndicator: call this function with a @setting of true to display
	// an arrow in the header button indicating the column is sorted. Call
	// gtk_tree_view_column_set_sort_order() to change the direction of the
	// arrow.
	SetSortIndicator(setting bool)
	// SetSortOrder changes the appearance of the sort indicator.
	//
	// This does not actually sort the model. Use
	// gtk_tree_view_column_set_sort_column_id() if you want automatic sorting
	// support. This function is primarily for custom sorting behavior, and
	// should be used in conjunction with gtk_tree_sortable_set_sort_column_id()
	// to do that. For custom models, the mechanism will vary.
	//
	// The sort indicator changes direction to indicate normal sort or reverse
	// sort. Note that you must have the sort indicator enabled to see anything
	// when calling this function; see
	// gtk_tree_view_column_set_sort_indicator().
	SetSortOrder(order SortType)
	// SetSpacing sets the spacing field of @tree_column, which is the number of
	// pixels to place between cell renderers packed into it.
	SetSpacing(spacing int)
	// SetTitle sets the title of the @tree_column. If a custom widget has been
	// set, then this value is ignored.
	SetTitle(title string)
	// SetVisible sets the visibility of @tree_column.
	SetVisible(visible bool)
	// SetWidget sets the widget in the header to be @widget. If widget is nil,
	// then the header button is set with a Label set to the title of
	// @tree_column.
	SetWidget(widget Widget)
}

// treeViewColumn implements the TreeViewColumn interface.
type treeViewColumn struct {
	gextras.Objector
	Buildable
	CellLayout
}

var _ TreeViewColumn = (*treeViewColumn)(nil)

// WrapTreeViewColumn wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeViewColumn(obj *externglib.Object) TreeViewColumn {
	return TreeViewColumn{
		Objector:   obj,
		Buildable:  WrapBuildable(obj),
		CellLayout: WrapCellLayout(obj),
	}
}

func marshalTreeViewColumn(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeViewColumn(obj), nil
}

// NewTreeViewColumn constructs a class TreeViewColumn.
func NewTreeViewColumn() TreeViewColumn {

	ret := C.gtk_tree_view_column_new()

	var ret0 TreeViewColumn

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(TreeViewColumn)

	return ret0
}

// NewTreeViewColumnWithArea constructs a class TreeViewColumn.
func NewTreeViewColumnWithArea(area CellArea) TreeViewColumn {
	var arg1 *C.GtkCellArea

	arg1 = (*C.GtkCellArea)(area.Native())

	ret := C.gtk_tree_view_column_new_with_area(arg1)

	var ret0 TreeViewColumn

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(TreeViewColumn)

	return ret0
}

// AddAttribute adds an attribute mapping to the list in @tree_column. The
// @column is the column of the model to get a value from, and the
// @attribute is the parameter on @cell_renderer to be set from the value.
// So for example if column 2 of the model contains strings, you could have
// the “text” attribute of a CellRendererText get its values from column 2.
func (treeColumn treeViewColumn) AddAttribute(cellRenderer CellRenderer, attribute string, column int) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 *C.GtkCellRenderer
	var arg2 *C.gchar
	var arg3 C.gint

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = (*C.GtkCellRenderer)(cellRenderer.Native())
	arg2 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.gint(column)

	C.gtk_tree_view_column_add_attribute(arg0, arg1, arg2, arg3)
}

// CellGetPosition obtains the horizontal position and size of a cell in a
// column. If the cell is not found in the column, @start_pos and @width are
// not changed and false is returned.
func (treeColumn treeViewColumn) CellGetPosition(cellRenderer CellRenderer) (xOffset int, width int, ok bool) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 *C.GtkCellRenderer
	var arg2 *C.gint // out
	var arg3 *C.gint // out

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = (*C.GtkCellRenderer)(cellRenderer.Native())

	ret := C.gtk_tree_view_column_cell_get_position(arg0, arg1, &arg2, &arg3)

	var ret0 int
	var ret1 int
	var ret2 bool

	ret0 = int(arg2)

	ret1 = int(arg3)

	ret2 = C.BOOL(ret) != 0

	return ret0, ret1, ret2
}

// CellGetSize obtains the width and height needed to render the column.
// This is used primarily by the TreeView.
func (treeColumn treeViewColumn) CellGetSize(cellArea *gdk.Rectangle) (xOffset int, yOffset int, width int, height int) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 *C.GdkRectangle
	var arg2 *C.gint // out
	var arg3 *C.gint // out
	var arg4 *C.gint // out
	var arg5 *C.gint // out

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = (*C.GdkRectangle)(cellArea.Native())

	C.gtk_tree_view_column_cell_get_size(arg0, arg1, &arg2, &arg3, &arg4, &arg5)

	var ret0 int
	var ret1 int
	var ret2 int
	var ret3 int

	ret0 = int(arg2)

	ret1 = int(arg3)

	ret2 = int(arg4)

	ret3 = int(arg5)

	return ret0, ret1, ret2, ret3
}

// CellIsVisible returns true if any of the cells packed into the
// @tree_column are visible. For this to be meaningful, you must first
// initialize the cells with gtk_tree_view_column_cell_set_cell_data()
func (treeColumn treeViewColumn) CellIsVisible() bool {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_cell_is_visible(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// CellSetCellData sets the cell renderer based on the @tree_model and
// @iter. That is, for every attribute mapping in @tree_column, it will get
// a value from the set column on the @iter, and use that value to set the
// attribute on the cell renderer. This is used primarily by the TreeView.
func (treeColumn treeViewColumn) CellSetCellData(treeModel TreeModel, iter *TreeIter, isExpander bool, isExpanded bool) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 *C.GtkTreeModel
	var arg2 *C.GtkTreeIter
	var arg3 C.gboolean
	var arg4 C.gboolean

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = (*C.GtkTreeModel)(treeModel.Native())
	arg2 = (*C.GtkTreeIter)(iter.Native())
	if isExpander {
		arg3 = C.TRUE
	}
	if isExpanded {
		arg4 = C.TRUE
	}

	C.gtk_tree_view_column_cell_set_cell_data(arg0, arg1, arg2, arg3, arg4)
}

// Clear unsets all the mappings on all renderers on the @tree_column.
func (treeColumn treeViewColumn) Clear() {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	C.gtk_tree_view_column_clear(arg0)
}

// ClearAttributes clears all existing attributes previously set with
// gtk_tree_view_column_set_attributes().
func (treeColumn treeViewColumn) ClearAttributes(cellRenderer CellRenderer) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 *C.GtkCellRenderer

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = (*C.GtkCellRenderer)(cellRenderer.Native())

	C.gtk_tree_view_column_clear_attributes(arg0, arg1)
}

// Clicked emits the “clicked” signal on the column. This function will only
// work if @tree_column is clickable.
func (treeColumn treeViewColumn) Clicked() {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	C.gtk_tree_view_column_clicked(arg0)
}

// FocusCell sets the current keyboard focus to be at @cell, if the column
// contains 2 or more editable and activatable cells.
func (treeColumn treeViewColumn) FocusCell(cell CellRenderer) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 *C.GtkCellRenderer

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = (*C.GtkCellRenderer)(cell.Native())

	C.gtk_tree_view_column_focus_cell(arg0, arg1)
}

// Alignment returns the current x alignment of @tree_column. This value can
// range between 0.0 and 1.0.
func (treeColumn treeViewColumn) Alignment() float32 {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_alignment(arg0)

	var ret0 float32

	ret0 = float32(ret)

	return ret0
}

// Button returns the button used in the treeview column header
func (treeColumn treeViewColumn) Button() Widget {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_button(arg0)

	var ret0 Widget

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Widget)

	return ret0
}

// Clickable returns true if the user can click on the header for the
// column.
func (treeColumn treeViewColumn) Clickable() bool {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_clickable(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Expand returns true if the column expands to fill available space.
func (treeColumn treeViewColumn) Expand() bool {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_expand(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// FixedWidth gets the fixed width of the column. This may not be the actual
// displayed width of the column; for that, use
// gtk_tree_view_column_get_width().
func (treeColumn treeViewColumn) FixedWidth() int {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_fixed_width(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// MaxWidth returns the maximum width in pixels of the @tree_column, or -1
// if no maximum width is set.
func (treeColumn treeViewColumn) MaxWidth() int {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_max_width(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// MinWidth returns the minimum width in pixels of the @tree_column, or -1
// if no minimum width is set.
func (treeColumn treeViewColumn) MinWidth() int {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_min_width(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Reorderable returns true if the @tree_column can be reordered by the
// user.
func (treeColumn treeViewColumn) Reorderable() bool {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_reorderable(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Resizable returns true if the @tree_column can be resized by the end
// user.
func (treeColumn treeViewColumn) Resizable() bool {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_resizable(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Sizing returns the current type of @tree_column.
func (treeColumn treeViewColumn) Sizing() TreeViewColumnSizing {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_sizing(arg0)

	var ret0 TreeViewColumnSizing

	ret0 = TreeViewColumnSizing(ret)

	return ret0
}

// SortColumnID gets the logical @sort_column_id that the model sorts on
// when this column is selected for sorting. See
// gtk_tree_view_column_set_sort_column_id().
func (treeColumn treeViewColumn) SortColumnID() int {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_sort_column_id(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// SortIndicator gets the value set by
// gtk_tree_view_column_set_sort_indicator().
func (treeColumn treeViewColumn) SortIndicator() bool {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_sort_indicator(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SortOrder gets the value set by gtk_tree_view_column_set_sort_order().
func (treeColumn treeViewColumn) SortOrder() SortType {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_sort_order(arg0)

	var ret0 SortType

	ret0 = SortType(ret)

	return ret0
}

// Spacing returns the spacing of @tree_column.
func (treeColumn treeViewColumn) Spacing() int {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_spacing(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Title returns the title of the widget.
func (treeColumn treeViewColumn) Title() string {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_title(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// TreeView returns the TreeView wherein @tree_column has been inserted. If
// @column is currently not inserted in any tree view, nil is returned.
func (treeColumn treeViewColumn) TreeView() Widget {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_tree_view(arg0)

	var ret0 Widget

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Widget)

	return ret0
}

// Visible returns true if @tree_column is visible.
func (treeColumn treeViewColumn) Visible() bool {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_visible(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Widget returns the Widget in the button on the column header. If a custom
// widget has not been set then nil is returned.
func (treeColumn treeViewColumn) Widget() Widget {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_widget(arg0)

	var ret0 Widget

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Widget)

	return ret0
}

// Width returns the current size of @tree_column in pixels.
func (treeColumn treeViewColumn) Width() int {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_width(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// XOffset returns the current X offset of @tree_column in pixels.
func (treeColumn treeViewColumn) XOffset() int {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_x_offset(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// PackEnd adds the @cell to end of the column. If @expand is false, then
// the @cell is allocated no more space than it needs. Any unused space is
// divided evenly between cells for which @expand is true.
func (treeColumn treeViewColumn) PackEnd(cell CellRenderer, expand bool) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 *C.GtkCellRenderer
	var arg2 C.gboolean

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = (*C.GtkCellRenderer)(cell.Native())
	if expand {
		arg2 = C.TRUE
	}

	C.gtk_tree_view_column_pack_end(arg0, arg1, arg2)
}

// PackStart packs the @cell into the beginning of the column. If @expand is
// false, then the @cell is allocated no more space than it needs. Any
// unused space is divided evenly between cells for which @expand is true.
func (treeColumn treeViewColumn) PackStart(cell CellRenderer, expand bool) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 *C.GtkCellRenderer
	var arg2 C.gboolean

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = (*C.GtkCellRenderer)(cell.Native())
	if expand {
		arg2 = C.TRUE
	}

	C.gtk_tree_view_column_pack_start(arg0, arg1, arg2)
}

// QueueResize flags the column, and the cell renderers added to this
// column, to have their sizes renegotiated.
func (treeColumn treeViewColumn) QueueResize() {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	C.gtk_tree_view_column_queue_resize(arg0)
}

// SetAlignment sets the alignment of the title or custom widget inside the
// column header. The alignment determines its location inside the button --
// 0.0 for left, 0.5 for center, 1.0 for right.
func (treeColumn treeViewColumn) SetAlignment(xalign float32) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.gfloat

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = C.gfloat(xalign)

	C.gtk_tree_view_column_set_alignment(arg0, arg1)
}

// SetCellDataFunc sets the TreeCellDataFunc to use for the column. This
// function is used instead of the standard attributes mapping for setting
// the column value, and should set the value of @tree_column's cell
// renderer as appropriate. @func may be nil to remove an older one.
func (treeColumn treeViewColumn) SetCellDataFunc(cellRenderer CellRenderer, fn TreeCellDataFunc) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 *C.GtkCellRenderer
	var arg2 C.GtkTreeCellDataFunc
	var arg3 C.gpointer
	var arg4 C.GDestroyNotify

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = (*C.GtkCellRenderer)(cellRenderer.Native())
	arg2 = (*[0]byte)(C.gotk4_TreeCellDataFunc)
	arg3 = C.gpointer(box.Assign(fn))
	arg4 = (*[0]byte)(C.callbackDelete)

	C.gtk_tree_view_column_set_cell_data_func(arg0, arg1, arg2, arg3, arg4)
}

// SetClickable sets the header to be active if @clickable is true. When the
// header is active, then it can take keyboard focus, and can be clicked.
func (treeColumn treeViewColumn) SetClickable(clickable bool) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	if clickable {
		arg1 = C.TRUE
	}

	C.gtk_tree_view_column_set_clickable(arg0, arg1)
}

// SetExpand sets the column to take available extra space. This space is
// shared equally amongst all columns that have the expand set to true. If
// no column has this option set, then the last column gets all extra space.
// By default, every column is created with this false.
//
// Along with “fixed-width”, the “expand” property changes when the column
// is resized by the user.
func (treeColumn treeViewColumn) SetExpand(expand bool) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	if expand {
		arg1 = C.TRUE
	}

	C.gtk_tree_view_column_set_expand(arg0, arg1)
}

// SetFixedWidth: if @fixed_width is not -1, sets the fixed width of
// @tree_column; otherwise unsets it. The effective value of @fixed_width is
// clamped between the minimum and maximum width of the column; however, the
// value stored in the “fixed-width” property is not clamped. If the column
// sizing is K_TREE_VIEW_COLUMN_GROW_ONLY or K_TREE_VIEW_COLUMN_AUTOSIZE,
// setting a fixed width overrides the automatically calculated width. Note
// that @fixed_width is only a hint to GTK+; the width actually allocated to
// the column may be greater or less than requested.
//
// Along with “expand”, the “fixed-width” property changes when the column
// is resized by the user.
func (treeColumn treeViewColumn) SetFixedWidth(fixedWidth int) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.gint

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = C.gint(fixedWidth)

	C.gtk_tree_view_column_set_fixed_width(arg0, arg1)
}

// SetMaxWidth sets the maximum width of the @tree_column. If @max_width is
// -1, then the maximum width is unset. Note, the column can actually be
// wider than max width if it’s the last column in a view. In this case, the
// column expands to fill any extra space.
func (treeColumn treeViewColumn) SetMaxWidth(maxWidth int) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.gint

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = C.gint(maxWidth)

	C.gtk_tree_view_column_set_max_width(arg0, arg1)
}

// SetMinWidth sets the minimum width of the @tree_column. If @min_width is
// -1, then the minimum width is unset.
func (treeColumn treeViewColumn) SetMinWidth(minWidth int) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.gint

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = C.gint(minWidth)

	C.gtk_tree_view_column_set_min_width(arg0, arg1)
}

// SetReorderable: if @reorderable is true, then the column can be reordered
// by the end user dragging the header.
func (treeColumn treeViewColumn) SetReorderable(reorderable bool) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	if reorderable {
		arg1 = C.TRUE
	}

	C.gtk_tree_view_column_set_reorderable(arg0, arg1)
}

// SetResizable: if @resizable is true, then the user can explicitly resize
// the column by grabbing the outer edge of the column button. If resizable
// is true and sizing mode of the column is K_TREE_VIEW_COLUMN_AUTOSIZE,
// then the sizing mode is changed to K_TREE_VIEW_COLUMN_GROW_ONLY.
func (treeColumn treeViewColumn) SetResizable(resizable bool) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	if resizable {
		arg1 = C.TRUE
	}

	C.gtk_tree_view_column_set_resizable(arg0, arg1)
}

// SetSizing sets the growth behavior of @tree_column to @type.
func (treeColumn treeViewColumn) SetSizing(typ TreeViewColumnSizing) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.GtkTreeViewColumnSizing

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = (C.GtkTreeViewColumnSizing)(typ)

	C.gtk_tree_view_column_set_sizing(arg0, arg1)
}

// SetSortColumnID sets the logical @sort_column_id that this column sorts
// on when this column is selected for sorting. Doing so makes the column
// header clickable.
func (treeColumn treeViewColumn) SetSortColumnID(sortColumnID int) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.gint

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = C.gint(sortColumnID)

	C.gtk_tree_view_column_set_sort_column_id(arg0, arg1)
}

// SetSortIndicator: call this function with a @setting of true to display
// an arrow in the header button indicating the column is sorted. Call
// gtk_tree_view_column_set_sort_order() to change the direction of the
// arrow.
func (treeColumn treeViewColumn) SetSortIndicator(setting bool) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	if setting {
		arg1 = C.TRUE
	}

	C.gtk_tree_view_column_set_sort_indicator(arg0, arg1)
}

// SetSortOrder changes the appearance of the sort indicator.
//
// This does not actually sort the model. Use
// gtk_tree_view_column_set_sort_column_id() if you want automatic sorting
// support. This function is primarily for custom sorting behavior, and
// should be used in conjunction with gtk_tree_sortable_set_sort_column_id()
// to do that. For custom models, the mechanism will vary.
//
// The sort indicator changes direction to indicate normal sort or reverse
// sort. Note that you must have the sort indicator enabled to see anything
// when calling this function; see
// gtk_tree_view_column_set_sort_indicator().
func (treeColumn treeViewColumn) SetSortOrder(order SortType) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.GtkSortType

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = (C.GtkSortType)(order)

	C.gtk_tree_view_column_set_sort_order(arg0, arg1)
}

// SetSpacing sets the spacing field of @tree_column, which is the number of
// pixels to place between cell renderers packed into it.
func (treeColumn treeViewColumn) SetSpacing(spacing int) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.gint

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = C.gint(spacing)

	C.gtk_tree_view_column_set_spacing(arg0, arg1)
}

// SetTitle sets the title of the @tree_column. If a custom widget has been
// set, then this value is ignored.
func (treeColumn treeViewColumn) SetTitle(title string) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 *C.gchar

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_tree_view_column_set_title(arg0, arg1)
}

// SetVisible sets the visibility of @tree_column.
func (treeColumn treeViewColumn) SetVisible(visible bool) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	if visible {
		arg1 = C.TRUE
	}

	C.gtk_tree_view_column_set_visible(arg0, arg1)
}

// SetWidget sets the widget in the header to be @widget. If widget is nil,
// then the header button is set with a Label set to the title of
// @tree_column.
func (treeColumn treeViewColumn) SetWidget(widget Widget) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = (*C.GtkWidget)(widget.Native())

	C.gtk_tree_view_column_set_widget(arg0, arg1)
}

// UIManager: > GtkUIManager is deprecated since GTK+ 3.10. To construct user
// interfaces > from XML definitions, you should use Builder, Model, et al. To >
// work with actions, use #GAction, Actionable et al. These newer classes >
// support richer functionality and integration with various desktop shells. >
// It should be possible to migrate most/all functionality from GtkUIManager.
//
// A UIManager constructs a user interface (menus and toolbars) from one or more
// UI definitions, which reference actions from one or more action groups.
//
//
// UI Definitions
//
// The UI definitions are specified in an XML format which can be roughly
// described by the following DTD.
//
// > Do not confuse the GtkUIManager UI Definitions described here with > the
// similarly named [GtkBuilder UI Definitions][BUILDER-UI].
//
//    <!ELEMENT ui          (menubar|toolbar|popup|accelerator)* >
//    <!ELEMENT menubar     (menuitem|separator|placeholder|menu)* >
//    <!ELEMENT menu        (menuitem|separator|placeholder|menu)* >
//    <!ELEMENT popup       (menuitem|separator|placeholder|menu)* >
//    <!ELEMENT toolbar     (toolitem|separator|placeholder)* >
//    <!ELEMENT placeholder (menuitem|toolitem|separator|placeholder|menu)* >
//    <!ELEMENT menuitem     EMPTY >
//    <!ELEMENT toolitem     (menu?) >
//    <!ELEMENT separator    EMPTY >
//    <!ELEMENT accelerator  EMPTY >
//    <!ATTLIST menubar      name                      PLIED
//                           action                    PLIED >
//    <!ATTLIST toolbar      name                      PLIED
//                           action                    PLIED >
//    <!ATTLIST popup        name                      PLIED
//                           action                    PLIED
//                           accelerators (true|false) PLIED >
//    <!ATTLIST placeholder  name                      PLIED
//                           action                    PLIED >
//    <!ATTLIST separator    name                      PLIED
//                           action                    PLIED
//                           expand       (true|false) PLIED >
//    <!ATTLIST menu         name                      PLIED
//                           action                    QUIRED
//                           position     (top|bot)    PLIED >
//    <!ATTLIST menuitem     name                      PLIED
//                           action                    QUIRED
//                           position     (top|bot)    PLIED
//                           always-show-image (true|false) PLIED >
//    <!ATTLIST toolitem     name                      PLIED
//                           action                    QUIRED
//                           position     (top|bot)    PLIED >
//    <!ATTLIST accelerator  name                      PLIED
//                           action                    QUIRED >
//
// There are some additional restrictions beyond those specified in the DTD,
// e.g. every toolitem must have a toolbar in its anchestry and every menuitem
// must have a menubar or popup in its anchestry. Since a Parser is used to
// parse the UI description, it must not only be valid XML, but valid markup.
//
// If a name is not specified, it defaults to the action. If an action is not
// specified either, the element name is used. The name and action attributes
// must not contain “/” characters after parsing (since that would mess up path
// lookup) and must be usable as XML attributes when enclosed in doublequotes,
// thus they must not “"” characters or references to the &quot; entity.
//
// A UI definition #
//
//    <ui>
//      <menubar>
//        <menu name="FileMenu" action="FileMenuAction">
//          <menuitem name="New" action="New2Action" />
//          <placeholder name="FileMenuAdditions" />
//        </menu>
//        <menu name="JustifyMenu" action="JustifyMenuAction">
//          <menuitem name="Left" action="justify-left"/>
//          <menuitem name="Centre" action="justify-center"/>
//          <menuitem name="Right" action="justify-right"/>
//          <menuitem name="Fill" action="justify-fill"/>
//        </menu>
//      </menubar>
//      <toolbar action="toolbar1">
//        <placeholder name="JustifyToolItems">
//          <separator/>
//          <toolitem name="Left" action="justify-left"/>
//          <toolitem name="Centre" action="justify-center"/>
//          <toolitem name="Right" action="justify-right"/>
//          <toolitem name="Fill" action="justify-fill"/>
//          <separator/>
//        </placeholder>
//      </toolbar>
//    </ui>
//
// The constructed widget hierarchy is very similar to the element tree of the
// XML, with the exception that placeholders are merged into their parents. The
// correspondence of XML elements to widgets should be almost obvious:
//
// - menubar
//
//    a MenuBar
//
// - toolbar
//
//    a Toolbar
//
// - popup
//
//    a toplevel Menu
//
// - menu
//
//    a Menu attached to a menuitem
//
// - menuitem
//
//    a MenuItem subclass, the exact type depends on the action
//
// - toolitem
//
//    a ToolItem subclass, the exact type depends on the
//    action. Note that toolitem elements may contain a menu element,
//    but only if their associated action specifies a
//    MenuToolButton as proxy.
//
// - separator
//
//    a SeparatorMenuItem or SeparatorToolItem
//
// - accelerator
//
//    a keyboard accelerator
//
// The “position” attribute determines where a constructed widget is positioned
// wrt. to its siblings in the partially constructed tree. If it is “top”, the
// widget is prepended, otherwise it is appended.
//
//
// UI Merging
//
// The most remarkable feature of UIManager is that it can overlay a set of
// menuitems and toolitems over another one, and demerge them later.
//
// Merging is done based on the names of the XML elements. Each element is
// identified by a path which consists of the names of its anchestors, separated
// by slashes. For example, the menuitem named “Left” in the example above has
// the path `/ui/menubar/JustifyMenu/Left` and the toolitem with the same name
// has path `/ui/toolbar1/JustifyToolItems/Left`.
//
// Accelerators #
//
// Every action has an accelerator path. Accelerators are installed together
// with menuitem proxies, but they can also be explicitly added with
// <accelerator> elements in the UI definition. This makes it possible to have
// accelerators for actions even if they have no visible proxies.
//
//
// Smart Separators
//
// The separators created by UIManager are “smart”, i.e. they do not show up in
// the UI unless they end up between two visible menu or tool items. Separators
// which are located at the very beginning or end of the menu or toolbar
// containing them, or multiple separators next to each other, are hidden. This
// is a useful feature, since the merging of UI elements from multiple sources
// can make it hard or impossible to determine in advance whether a separator
// will end up in such an unfortunate position.
//
// For separators in toolbars, you can set `expand="true"` to turn them from a
// small, visible separator to an expanding, invisible one. Toolitems following
// an expanding separator are effectively right-aligned.
//
//
// Empty Menus
//
// Submenus pose similar problems to separators inconnection with merging. It is
// impossible to know in advance whether they will end up empty after merging.
// UIManager offers two ways to treat empty submenus:
//
// - make them disappear by hiding the menu item they’re attached to
//
// - add an insensitive “Empty” item
//
// The behaviour is chosen based on the “hide_if_empty” property of the action
// to which the submenu is associated.
//
//
// GtkUIManager as GtkBuildable
//
// The GtkUIManager implementation of the GtkBuildable interface accepts
// GtkActionGroup objects as <child> elements in UI definitions.
//
// A GtkUIManager UI definition as described above can be embedded in an
// GtkUIManager <object> element in a GtkBuilder UI definition.
//
// The widgets that are constructed by a GtkUIManager can be embedded in other
// parts of the constructed user interface with the help of the “constructor”
// attribute. See the example below.
//
// An embedded GtkUIManager UI definition
//
//    <object class="GtkUIManager" id="uiman">
//      <child>
//        <object class="GtkActionGroup" id="actiongroup">
//          <child>
//            <object class="GtkAction" id="file">
//              <property name="label">_File</property>
//            </object>
//          </child>
//        </object>
//      </child>
//      <ui>
//        <menubar name="menubar1">
//          <menu action="file">
//          </menu>
//        </menubar>
//      </ui>
//    </object>
//    <object class="GtkWindow" id="main-window">
//      <child>
//        <object class="GtkMenuBar" id="menubar1" constructor="uiman"/>
//      </child>
//    </object>
type UIManager interface {
	gextras.Objector
	Buildable

	// AddUi adds a UI element to the current contents of @manager.
	//
	// If @type is GTK_UI_MANAGER_AUTO, GTK+ inserts a menuitem, toolitem or
	// separator if such an element can be inserted at the place determined by
	// @path. Otherwise @type must indicate an element that can be inserted at
	// the place determined by @path.
	//
	// If @path points to a menuitem or toolitem, the new element will be
	// inserted before or after this item, depending on @top.
	AddUi(mergeID uint, path string, name string, action string, typ UIManagerItemType, top bool)
	// AddUiFromFile parses a file containing a [UI definition][XML-UI] and
	// merges it with the current contents of @manager.
	AddUiFromFile(filename string) (guint uint, err error)
	// AddUiFromResource parses a resource file containing a [UI
	// definition][XML-UI] and merges it with the current contents of @manager.
	AddUiFromResource(resourcePath string) (guint uint, err error)
	// AddUiFromString parses a string containing a [UI definition][XML-UI] and
	// merges it with the current contents of @manager. An enclosing <ui>
	// element is added if it is missing.
	AddUiFromString(buffer string, length int) (guint uint, err error)
	// EnsureUpdate makes sure that all pending updates to the UI have been
	// completed.
	//
	// This may occasionally be necessary, since UIManager updates the UI in an
	// idle function. A typical example where this function is useful is to
	// enforce that the menubar and toolbar have been added to the main window
	// before showing it:
	//
	//    gtk_container_add (GTK_CONTAINER (window), vbox);
	//    g_signal_connect (merge, "add-widget",
	//                      G_CALLBACK (add_widget), vbox);
	//    gtk_ui_manager_add_ui_from_file (merge, "my-menus");
	//    gtk_ui_manager_add_ui_from_file (merge, "my-toolbars");
	//    gtk_ui_manager_ensure_update (merge);
	//    gtk_widget_show (window);
	EnsureUpdate()
	// AccelGroup returns the AccelGroup associated with @manager.
	AccelGroup() AccelGroup
	// Action looks up an action by following a path. See
	// gtk_ui_manager_get_widget() for more information about paths.
	Action(path string) Action
	// ActionGroups returns the list of action groups associated with @manager.
	ActionGroups() *glib.List
	// AddTearoffs returns whether menus generated by this UIManager will have
	// tearoff menu items.
	AddTearoffs() bool
	// Toplevels obtains a list of all toplevel widgets of the requested types.
	Toplevels(types UIManagerItemType) *glib.SList
	// Ui creates a [UI definition][XML-UI] of the merged UI.
	Ui() string
	// Widget looks up a widget by following a path. The path consists of the
	// names specified in the XML description of the UI. separated by “/”.
	// Elements which don’t have a name or action attribute in the XML (e.g.
	// <popup>) can be addressed by their XML element name (e.g. "popup"). The
	// root element ("/ui") can be omitted in the path.
	//
	// Note that the widget found by following a path that ends in a <menu>;
	// element is the menuitem to which the menu is attached, not the menu it
	// manages.
	//
	// Also note that the widgets constructed by a ui manager are not tied to
	// the lifecycle of the ui manager. If you add the widgets returned by this
	// function to some container or explicitly ref them, they will survive the
	// destruction of the ui manager.
	Widget(path string) Widget
	// InsertActionGroup inserts an action group into the list of action groups
	// associated with @manager. Actions in earlier groups hide actions with the
	// same name in later groups.
	//
	// If @pos is larger than the number of action groups in @manager, or
	// negative, @action_group will be inserted at the end of the internal list.
	InsertActionGroup(actionGroup ActionGroup, pos int)
	// NewMergeID returns an unused merge id, suitable for use with
	// gtk_ui_manager_add_ui().
	NewMergeID() uint
	// RemoveActionGroup removes an action group from the list of action groups
	// associated with @manager.
	RemoveActionGroup(actionGroup ActionGroup)
	// RemoveUi unmerges the part of @manager's content identified by @merge_id.
	RemoveUi(mergeID uint)
	// SetAddTearoffs sets the “add_tearoffs” property, which controls whether
	// menus generated by this UIManager will have tearoff menu items.
	//
	// Note that this only affects regular menus. Generated popup menus never
	// have tearoff menu items.
	SetAddTearoffs(addTearoffs bool)
}

// uiManager implements the UIManager interface.
type uiManager struct {
	gextras.Objector
	Buildable
}

var _ UIManager = (*uiManager)(nil)

// WrapUIManager wraps a GObject to the right type. It is
// primarily used internally.
func WrapUIManager(obj *externglib.Object) UIManager {
	return UIManager{
		Objector:  obj,
		Buildable: WrapBuildable(obj),
	}
}

func marshalUIManager(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapUIManager(obj), nil
}

// NewUIManager constructs a class UIManager.
func NewUIManager() UIManager {

	ret := C.gtk_ui_manager_new()

	var ret0 UIManager

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(UIManager)

	return ret0
}

// AddUi adds a UI element to the current contents of @manager.
//
// If @type is GTK_UI_MANAGER_AUTO, GTK+ inserts a menuitem, toolitem or
// separator if such an element can be inserted at the place determined by
// @path. Otherwise @type must indicate an element that can be inserted at
// the place determined by @path.
//
// If @path points to a menuitem or toolitem, the new element will be
// inserted before or after this item, depending on @top.
func (manager uiManager) AddUi(mergeID uint, path string, name string, action string, typ UIManagerItemType, top bool) {
	var arg0 *C.GtkUIManager
	var arg1 C.guint
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 *C.gchar
	var arg5 C.GtkUIManagerItemType
	var arg6 C.gboolean

	arg0 = (*C.GtkUIManager)(manager.Native())
	arg1 = C.guint(mergeID)
	arg2 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gchar)(C.CString(action))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (C.GtkUIManagerItemType)(typ)
	if top {
		arg6 = C.TRUE
	}

	C.gtk_ui_manager_add_ui(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
}

// AddUiFromFile parses a file containing a [UI definition][XML-UI] and
// merges it with the current contents of @manager.
func (manager uiManager) AddUiFromFile(filename string) (guint uint, err error) {
	var arg0 *C.GtkUIManager
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GtkUIManager)(manager.Native())
	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_ui_manager_add_ui_from_file(arg0, arg1, &gError)

	var ret0 uint
	var goError error

	ret0 = uint(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// AddUiFromResource parses a resource file containing a [UI
// definition][XML-UI] and merges it with the current contents of @manager.
func (manager uiManager) AddUiFromResource(resourcePath string) (guint uint, err error) {
	var arg0 *C.GtkUIManager
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GtkUIManager)(manager.Native())
	arg1 = (*C.gchar)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_ui_manager_add_ui_from_resource(arg0, arg1, &gError)

	var ret0 uint
	var goError error

	ret0 = uint(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// AddUiFromString parses a string containing a [UI definition][XML-UI] and
// merges it with the current contents of @manager. An enclosing <ui>
// element is added if it is missing.
func (manager uiManager) AddUiFromString(buffer string, length int) (guint uint, err error) {
	var arg0 *C.GtkUIManager
	var arg1 *C.gchar
	var arg2 C.gssize
	var gError *C.GError

	arg0 = (*C.GtkUIManager)(manager.Native())
	arg1 = (*C.gchar)(C.CString(buffer))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(length)

	ret := C.gtk_ui_manager_add_ui_from_string(arg0, arg1, arg2, &gError)

	var ret0 uint
	var goError error

	ret0 = uint(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// EnsureUpdate makes sure that all pending updates to the UI have been
// completed.
//
// This may occasionally be necessary, since UIManager updates the UI in an
// idle function. A typical example where this function is useful is to
// enforce that the menubar and toolbar have been added to the main window
// before showing it:
//
//    gtk_container_add (GTK_CONTAINER (window), vbox);
//    g_signal_connect (merge, "add-widget",
//                      G_CALLBACK (add_widget), vbox);
//    gtk_ui_manager_add_ui_from_file (merge, "my-menus");
//    gtk_ui_manager_add_ui_from_file (merge, "my-toolbars");
//    gtk_ui_manager_ensure_update (merge);
//    gtk_widget_show (window);
func (manager uiManager) EnsureUpdate() {
	var arg0 *C.GtkUIManager

	arg0 = (*C.GtkUIManager)(manager.Native())

	C.gtk_ui_manager_ensure_update(arg0)
}

// AccelGroup returns the AccelGroup associated with @manager.
func (manager uiManager) AccelGroup() AccelGroup {
	var arg0 *C.GtkUIManager

	arg0 = (*C.GtkUIManager)(manager.Native())

	ret := C.gtk_ui_manager_get_accel_group(arg0)

	var ret0 AccelGroup

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(AccelGroup)

	return ret0
}

// Action looks up an action by following a path. See
// gtk_ui_manager_get_widget() for more information about paths.
func (manager uiManager) Action(path string) Action {
	var arg0 *C.GtkUIManager
	var arg1 *C.gchar

	arg0 = (*C.GtkUIManager)(manager.Native())
	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_ui_manager_get_action(arg0, arg1)

	var ret0 Action

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Action)

	return ret0
}

// ActionGroups returns the list of action groups associated with @manager.
func (manager uiManager) ActionGroups() *glib.List {
	var arg0 *C.GtkUIManager

	arg0 = (*C.GtkUIManager)(manager.Native())

	ret := C.gtk_ui_manager_get_action_groups(arg0)

	var ret0 *glib.List

	{
		ret0 = glib.WrapList(unsafe.Pointer(ret))
	}

	return ret0
}

// AddTearoffs returns whether menus generated by this UIManager will have
// tearoff menu items.
func (manager uiManager) AddTearoffs() bool {
	var arg0 *C.GtkUIManager

	arg0 = (*C.GtkUIManager)(manager.Native())

	ret := C.gtk_ui_manager_get_add_tearoffs(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Toplevels obtains a list of all toplevel widgets of the requested types.
func (manager uiManager) Toplevels(types UIManagerItemType) *glib.SList {
	var arg0 *C.GtkUIManager
	var arg1 C.GtkUIManagerItemType

	arg0 = (*C.GtkUIManager)(manager.Native())
	arg1 = (C.GtkUIManagerItemType)(types)

	ret := C.gtk_ui_manager_get_toplevels(arg0, arg1)

	var ret0 *glib.SList

	{
		ret0 = glib.WrapSList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.SList) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Ui creates a [UI definition][XML-UI] of the merged UI.
func (manager uiManager) Ui() string {
	var arg0 *C.GtkUIManager

	arg0 = (*C.GtkUIManager)(manager.Native())

	ret := C.gtk_ui_manager_get_ui(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Widget looks up a widget by following a path. The path consists of the
// names specified in the XML description of the UI. separated by “/”.
// Elements which don’t have a name or action attribute in the XML (e.g.
// <popup>) can be addressed by their XML element name (e.g. "popup"). The
// root element ("/ui") can be omitted in the path.
//
// Note that the widget found by following a path that ends in a <menu>;
// element is the menuitem to which the menu is attached, not the menu it
// manages.
//
// Also note that the widgets constructed by a ui manager are not tied to
// the lifecycle of the ui manager. If you add the widgets returned by this
// function to some container or explicitly ref them, they will survive the
// destruction of the ui manager.
func (manager uiManager) Widget(path string) Widget {
	var arg0 *C.GtkUIManager
	var arg1 *C.gchar

	arg0 = (*C.GtkUIManager)(manager.Native())
	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_ui_manager_get_widget(arg0, arg1)

	var ret0 Widget

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Widget)

	return ret0
}

// InsertActionGroup inserts an action group into the list of action groups
// associated with @manager. Actions in earlier groups hide actions with the
// same name in later groups.
//
// If @pos is larger than the number of action groups in @manager, or
// negative, @action_group will be inserted at the end of the internal list.
func (manager uiManager) InsertActionGroup(actionGroup ActionGroup, pos int) {
	var arg0 *C.GtkUIManager
	var arg1 *C.GtkActionGroup
	var arg2 C.gint

	arg0 = (*C.GtkUIManager)(manager.Native())
	arg1 = (*C.GtkActionGroup)(actionGroup.Native())
	arg2 = C.gint(pos)

	C.gtk_ui_manager_insert_action_group(arg0, arg1, arg2)
}

// NewMergeID returns an unused merge id, suitable for use with
// gtk_ui_manager_add_ui().
func (manager uiManager) NewMergeID() uint {
	var arg0 *C.GtkUIManager

	arg0 = (*C.GtkUIManager)(manager.Native())

	ret := C.gtk_ui_manager_new_merge_id(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// RemoveActionGroup removes an action group from the list of action groups
// associated with @manager.
func (manager uiManager) RemoveActionGroup(actionGroup ActionGroup) {
	var arg0 *C.GtkUIManager
	var arg1 *C.GtkActionGroup

	arg0 = (*C.GtkUIManager)(manager.Native())
	arg1 = (*C.GtkActionGroup)(actionGroup.Native())

	C.gtk_ui_manager_remove_action_group(arg0, arg1)
}

// RemoveUi unmerges the part of @manager's content identified by @merge_id.
func (manager uiManager) RemoveUi(mergeID uint) {
	var arg0 *C.GtkUIManager
	var arg1 C.guint

	arg0 = (*C.GtkUIManager)(manager.Native())
	arg1 = C.guint(mergeID)

	C.gtk_ui_manager_remove_ui(arg0, arg1)
}

// SetAddTearoffs sets the “add_tearoffs” property, which controls whether
// menus generated by this UIManager will have tearoff menu items.
//
// Note that this only affects regular menus. Generated popup menus never
// have tearoff menu items.
func (manager uiManager) SetAddTearoffs(addTearoffs bool) {
	var arg0 *C.GtkUIManager
	var arg1 C.gboolean

	arg0 = (*C.GtkUIManager)(manager.Native())
	if addTearoffs {
		arg1 = C.TRUE
	}

	C.gtk_ui_manager_set_add_tearoffs(arg0, arg1)
}

// WindowGroup: a WindowGroup restricts the effect of grabs to windows in the
// same group, thereby making window groups almost behave like separate
// applications.
//
// A window can be a member in at most one window group at a time. Windows that
// have not been explicitly assigned to a group are implicitly treated like
// windows of the default window group.
//
// GtkWindowGroup objects are referenced by each window in the group, so once
// you have added all windows to a GtkWindowGroup, you can drop the initial
// reference to the window group with g_object_unref(). If the windows in the
// window group are subsequently destroyed, then they will be removed from the
// window group and drop their references on the window group; when all window
// have been removed, the window group will be freed.
type WindowGroup interface {
	gextras.Objector

	// AddWindow adds a window to a WindowGroup.
	AddWindow(window Window)
	// CurrentDeviceGrab returns the current grab widget for @device, or nil if
	// none.
	CurrentDeviceGrab(device gdk.Device) Widget
	// CurrentGrab gets the current grab widget of the given group, see
	// gtk_grab_add().
	CurrentGrab() Widget
	// ListWindows returns a list of the Windows that belong to @window_group.
	ListWindows() *glib.List
	// RemoveWindow removes a window from a WindowGroup.
	RemoveWindow(window Window)
}

// windowGroup implements the WindowGroup interface.
type windowGroup struct {
	gextras.Objector
}

var _ WindowGroup = (*windowGroup)(nil)

// WrapWindowGroup wraps a GObject to the right type. It is
// primarily used internally.
func WrapWindowGroup(obj *externglib.Object) WindowGroup {
	return WindowGroup{
		Objector: obj,
	}
}

func marshalWindowGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapWindowGroup(obj), nil
}

// NewWindowGroup constructs a class WindowGroup.
func NewWindowGroup() WindowGroup {

	ret := C.gtk_window_group_new()

	var ret0 WindowGroup

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(WindowGroup)

	return ret0
}

// AddWindow adds a window to a WindowGroup.
func (windowGroup windowGroup) AddWindow(window Window) {
	var arg0 *C.GtkWindowGroup
	var arg1 *C.GtkWindow

	arg0 = (*C.GtkWindowGroup)(windowGroup.Native())
	arg1 = (*C.GtkWindow)(window.Native())

	C.gtk_window_group_add_window(arg0, arg1)
}

// CurrentDeviceGrab returns the current grab widget for @device, or nil if
// none.
func (windowGroup windowGroup) CurrentDeviceGrab(device gdk.Device) Widget {
	var arg0 *C.GtkWindowGroup
	var arg1 *C.GdkDevice

	arg0 = (*C.GtkWindowGroup)(windowGroup.Native())
	arg1 = (*C.GdkDevice)(device.Native())

	ret := C.gtk_window_group_get_current_device_grab(arg0, arg1)

	var ret0 Widget

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Widget)

	return ret0
}

// CurrentGrab gets the current grab widget of the given group, see
// gtk_grab_add().
func (windowGroup windowGroup) CurrentGrab() Widget {
	var arg0 *C.GtkWindowGroup

	arg0 = (*C.GtkWindowGroup)(windowGroup.Native())

	ret := C.gtk_window_group_get_current_grab(arg0)

	var ret0 Widget

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Widget)

	return ret0
}

// ListWindows returns a list of the Windows that belong to @window_group.
func (windowGroup windowGroup) ListWindows() *glib.List {
	var arg0 *C.GtkWindowGroup

	arg0 = (*C.GtkWindowGroup)(windowGroup.Native())

	ret := C.gtk_window_group_list_windows(arg0)

	var ret0 *glib.List

	{
		ret0 = glib.WrapList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.List) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// RemoveWindow removes a window from a WindowGroup.
func (windowGroup windowGroup) RemoveWindow(window Window) {
	var arg0 *C.GtkWindowGroup
	var arg1 *C.GtkWindow

	arg0 = (*C.GtkWindowGroup)(windowGroup.Native())
	arg1 = (*C.GtkWindow)(window.Native())

	C.gtk_window_group_remove_window(arg0, arg1)
}
