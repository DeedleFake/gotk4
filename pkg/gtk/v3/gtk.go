// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gerror"
	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	"github.com/diamondburned/gotk4/pkg/pango"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk+-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_align_get_type()), F: marshalAlign},
		{T: externglib.Type(C.gtk_arrow_placement_get_type()), F: marshalArrowPlacement},
		{T: externglib.Type(C.gtk_arrow_type_get_type()), F: marshalArrowType},
		{T: externglib.Type(C.gtk_assistant_page_type_get_type()), F: marshalAssistantPageType},
		{T: externglib.Type(C.gtk_baseline_position_get_type()), F: marshalBaselinePosition},
		{T: externglib.Type(C.gtk_border_style_get_type()), F: marshalBorderStyle},
		{T: externglib.Type(C.gtk_builder_error_get_type()), F: marshalBuilderError},
		{T: externglib.Type(C.gtk_button_box_style_get_type()), F: marshalButtonBoxStyle},
		{T: externglib.Type(C.gtk_button_role_get_type()), F: marshalButtonRole},
		{T: externglib.Type(C.gtk_buttons_type_get_type()), F: marshalButtonsType},
		{T: externglib.Type(C.gtk_cell_renderer_accel_mode_get_type()), F: marshalCellRendererAccelMode},
		{T: externglib.Type(C.gtk_cell_renderer_mode_get_type()), F: marshalCellRendererMode},
		{T: externglib.Type(C.gtk_corner_type_get_type()), F: marshalCornerType},
		{T: externglib.Type(C.gtk_css_provider_error_get_type()), F: marshalCSSProviderError},
		{T: externglib.Type(C.gtk_css_section_type_get_type()), F: marshalCSSSectionType},
		{T: externglib.Type(C.gtk_delete_type_get_type()), F: marshalDeleteType},
		{T: externglib.Type(C.gtk_direction_type_get_type()), F: marshalDirectionType},
		{T: externglib.Type(C.gtk_drag_result_get_type()), F: marshalDragResult},
		{T: externglib.Type(C.gtk_entry_icon_position_get_type()), F: marshalEntryIconPosition},
		{T: externglib.Type(C.gtk_event_sequence_state_get_type()), F: marshalEventSequenceState},
		{T: externglib.Type(C.gtk_expander_style_get_type()), F: marshalExpanderStyle},
		{T: externglib.Type(C.gtk_file_chooser_action_get_type()), F: marshalFileChooserAction},
		{T: externglib.Type(C.gtk_file_chooser_confirmation_get_type()), F: marshalFileChooserConfirmation},
		{T: externglib.Type(C.gtk_file_chooser_error_get_type()), F: marshalFileChooserError},
		{T: externglib.Type(C.gtk_im_preedit_style_get_type()), F: marshalIMPreeditStyle},
		{T: externglib.Type(C.gtk_im_status_style_get_type()), F: marshalIMStatusStyle},
		{T: externglib.Type(C.gtk_icon_size_get_type()), F: marshalIconSize},
		{T: externglib.Type(C.gtk_icon_theme_error_get_type()), F: marshalIconThemeError},
		{T: externglib.Type(C.gtk_icon_view_drop_position_get_type()), F: marshalIconViewDropPosition},
		{T: externglib.Type(C.gtk_image_type_get_type()), F: marshalImageType},
		{T: externglib.Type(C.gtk_input_purpose_get_type()), F: marshalInputPurpose},
		{T: externglib.Type(C.gtk_justification_get_type()), F: marshalJustification},
		{T: externglib.Type(C.gtk_level_bar_mode_get_type()), F: marshalLevelBarMode},
		{T: externglib.Type(C.gtk_license_get_type()), F: marshalLicense},
		{T: externglib.Type(C.gtk_menu_direction_type_get_type()), F: marshalMenuDirectionType},
		{T: externglib.Type(C.gtk_message_type_get_type()), F: marshalMessageType},
		{T: externglib.Type(C.gtk_movement_step_get_type()), F: marshalMovementStep},
		{T: externglib.Type(C.gtk_notebook_tab_get_type()), F: marshalNotebookTab},
		{T: externglib.Type(C.gtk_number_up_layout_get_type()), F: marshalNumberUpLayout},
		{T: externglib.Type(C.gtk_orientation_get_type()), F: marshalOrientation},
		{T: externglib.Type(C.gtk_pack_direction_get_type()), F: marshalPackDirection},
		{T: externglib.Type(C.gtk_pack_type_get_type()), F: marshalPackType},
		{T: externglib.Type(C.gtk_pad_action_type_get_type()), F: marshalPadActionType},
		{T: externglib.Type(C.gtk_page_orientation_get_type()), F: marshalPageOrientation},
		{T: externglib.Type(C.gtk_page_set_get_type()), F: marshalPageSet},
		{T: externglib.Type(C.gtk_pan_direction_get_type()), F: marshalPanDirection},
		{T: externglib.Type(C.gtk_path_priority_type_get_type()), F: marshalPathPriorityType},
		{T: externglib.Type(C.gtk_path_type_get_type()), F: marshalPathType},
		{T: externglib.Type(C.gtk_policy_type_get_type()), F: marshalPolicyType},
		{T: externglib.Type(C.gtk_popover_constraint_get_type()), F: marshalPopoverConstraint},
		{T: externglib.Type(C.gtk_position_type_get_type()), F: marshalPositionType},
		{T: externglib.Type(C.gtk_print_duplex_get_type()), F: marshalPrintDuplex},
		{T: externglib.Type(C.gtk_print_error_get_type()), F: marshalPrintError},
		{T: externglib.Type(C.gtk_print_operation_action_get_type()), F: marshalPrintOperationAction},
		{T: externglib.Type(C.gtk_print_operation_result_get_type()), F: marshalPrintOperationResult},
		{T: externglib.Type(C.gtk_print_pages_get_type()), F: marshalPrintPages},
		{T: externglib.Type(C.gtk_print_quality_get_type()), F: marshalPrintQuality},
		{T: externglib.Type(C.gtk_print_status_get_type()), F: marshalPrintStatus},
		{T: externglib.Type(C.gtk_propagation_phase_get_type()), F: marshalPropagationPhase},
		{T: externglib.Type(C.gtk_rc_token_type_get_type()), F: marshalRCTokenType},
		{T: externglib.Type(C.gtk_recent_chooser_error_get_type()), F: marshalRecentChooserError},
		{T: externglib.Type(C.gtk_recent_manager_error_get_type()), F: marshalRecentManagerError},
		{T: externglib.Type(C.gtk_recent_sort_type_get_type()), F: marshalRecentSortType},
		{T: externglib.Type(C.gtk_relief_style_get_type()), F: marshalReliefStyle},
		{T: externglib.Type(C.gtk_resize_mode_get_type()), F: marshalResizeMode},
		{T: externglib.Type(C.gtk_response_type_get_type()), F: marshalResponseType},
		{T: externglib.Type(C.gtk_revealer_transition_type_get_type()), F: marshalRevealerTransitionType},
		{T: externglib.Type(C.gtk_scroll_step_get_type()), F: marshalScrollStep},
		{T: externglib.Type(C.gtk_scroll_type_get_type()), F: marshalScrollType},
		{T: externglib.Type(C.gtk_scrollable_policy_get_type()), F: marshalScrollablePolicy},
		{T: externglib.Type(C.gtk_selection_mode_get_type()), F: marshalSelectionMode},
		{T: externglib.Type(C.gtk_sensitivity_type_get_type()), F: marshalSensitivityType},
		{T: externglib.Type(C.gtk_shadow_type_get_type()), F: marshalShadowType},
		{T: externglib.Type(C.gtk_shortcut_type_get_type()), F: marshalShortcutType},
		{T: externglib.Type(C.gtk_size_group_mode_get_type()), F: marshalSizeGroupMode},
		{T: externglib.Type(C.gtk_size_request_mode_get_type()), F: marshalSizeRequestMode},
		{T: externglib.Type(C.gtk_sort_type_get_type()), F: marshalSortType},
		{T: externglib.Type(C.gtk_spin_button_update_policy_get_type()), F: marshalSpinButtonUpdatePolicy},
		{T: externglib.Type(C.gtk_spin_type_get_type()), F: marshalSpinType},
		{T: externglib.Type(C.gtk_stack_transition_type_get_type()), F: marshalStackTransitionType},
		{T: externglib.Type(C.gtk_state_type_get_type()), F: marshalStateType},
		{T: externglib.Type(C.gtk_text_buffer_target_info_get_type()), F: marshalTextBufferTargetInfo},
		{T: externglib.Type(C.gtk_text_direction_get_type()), F: marshalTextDirection},
		{T: externglib.Type(C.gtk_text_extend_selection_get_type()), F: marshalTextExtendSelection},
		{T: externglib.Type(C.gtk_text_view_layer_get_type()), F: marshalTextViewLayer},
		{T: externglib.Type(C.gtk_text_window_type_get_type()), F: marshalTextWindowType},
		{T: externglib.Type(C.gtk_toolbar_space_style_get_type()), F: marshalToolbarSpaceStyle},
		{T: externglib.Type(C.gtk_toolbar_style_get_type()), F: marshalToolbarStyle},
		{T: externglib.Type(C.gtk_tree_view_column_sizing_get_type()), F: marshalTreeViewColumnSizing},
		{T: externglib.Type(C.gtk_tree_view_drop_position_get_type()), F: marshalTreeViewDropPosition},
		{T: externglib.Type(C.gtk_tree_view_grid_lines_get_type()), F: marshalTreeViewGridLines},
		{T: externglib.Type(C.gtk_unit_get_type()), F: marshalUnit},
		{T: externglib.Type(C.gtk_widget_help_type_get_type()), F: marshalWidgetHelpType},
		{T: externglib.Type(C.gtk_window_position_get_type()), F: marshalWindowPosition},
		{T: externglib.Type(C.gtk_window_type_get_type()), F: marshalWindowType},
		{T: externglib.Type(C.gtk_wrap_mode_get_type()), F: marshalWrapMode},
		{T: externglib.Type(C.gtk_accel_flags_get_type()), F: marshalAccelFlags},
		{T: externglib.Type(C.gtk_application_inhibit_flags_get_type()), F: marshalApplicationInhibitFlags},
		{T: externglib.Type(C.gtk_attach_options_get_type()), F: marshalAttachOptions},
		{T: externglib.Type(C.gtk_calendar_display_options_get_type()), F: marshalCalendarDisplayOptions},
		{T: externglib.Type(C.gtk_cell_renderer_state_get_type()), F: marshalCellRendererState},
		{T: externglib.Type(C.gtk_debug_flag_get_type()), F: marshalDebugFlag},
		{T: externglib.Type(C.gtk_dest_defaults_get_type()), F: marshalDestDefaults},
		{T: externglib.Type(C.gtk_dialog_flags_get_type()), F: marshalDialogFlags},
		{T: externglib.Type(C.gtk_event_controller_scroll_flags_get_type()), F: marshalEventControllerScrollFlags},
		{T: externglib.Type(C.gtk_file_filter_flags_get_type()), F: marshalFileFilterFlags},
		{T: externglib.Type(C.gtk_font_chooser_level_get_type()), F: marshalFontChooserLevel},
		{T: externglib.Type(C.gtk_icon_lookup_flags_get_type()), F: marshalIconLookupFlags},
		{T: externglib.Type(C.gtk_input_hints_get_type()), F: marshalInputHints},
		{T: externglib.Type(C.gtk_junction_sides_get_type()), F: marshalJunctionSides},
		{T: externglib.Type(C.gtk_places_open_flags_get_type()), F: marshalPlacesOpenFlags},
		{T: externglib.Type(C.gtk_rc_flags_get_type()), F: marshalRCFlags},
		{T: externglib.Type(C.gtk_recent_filter_flags_get_type()), F: marshalRecentFilterFlags},
		{T: externglib.Type(C.gtk_region_flags_get_type()), F: marshalRegionFlags},
		{T: externglib.Type(C.gtk_state_flags_get_type()), F: marshalStateFlags},
		{T: externglib.Type(C.gtk_style_context_print_flags_get_type()), F: marshalStyleContextPrintFlags},
		{T: externglib.Type(C.gtk_target_flags_get_type()), F: marshalTargetFlags},
		{T: externglib.Type(C.gtk_text_search_flags_get_type()), F: marshalTextSearchFlags},
		{T: externglib.Type(C.gtk_tool_palette_drag_targets_get_type()), F: marshalToolPaletteDragTargets},
		{T: externglib.Type(C.gtk_tree_model_flags_get_type()), F: marshalTreeModelFlags},
		{T: externglib.Type(C.gtk_ui_manager_item_type_get_type()), F: marshalUIManagerItemType},
		{T: externglib.Type(C.gtk_actionable_get_type()), F: marshalActionable},
		{T: externglib.Type(C.gtk_activatable_get_type()), F: marshalActivatable},
		{T: externglib.Type(C.gtk_app_chooser_get_type()), F: marshalAppChooser},
		{T: externglib.Type(C.gtk_buildable_get_type()), F: marshalBuildable},
		{T: externglib.Type(C.gtk_cell_accessible_parent_get_type()), F: marshalCellAccessibleParent},
		{T: externglib.Type(C.gtk_cell_editable_get_type()), F: marshalCellEditable},
		{T: externglib.Type(C.gtk_cell_layout_get_type()), F: marshalCellLayout},
		{T: externglib.Type(C.gtk_color_chooser_get_type()), F: marshalColorChooser},
		{T: externglib.Type(C.gtk_editable_get_type()), F: marshalEditable},
		{T: externglib.Type(C.gtk_file_chooser_get_type()), F: marshalFileChooser},
		{T: externglib.Type(C.gtk_font_chooser_get_type()), F: marshalFontChooser},
		{T: externglib.Type(C.gtk_orientable_get_type()), F: marshalOrientable},
		{T: externglib.Type(C.gtk_print_operation_preview_get_type()), F: marshalPrintOperationPreview},
		{T: externglib.Type(C.gtk_recent_chooser_get_type()), F: marshalRecentChooser},
		{T: externglib.Type(C.gtk_scrollable_get_type()), F: marshalScrollable},
		{T: externglib.Type(C.gtk_style_provider_get_type()), F: marshalStyleProvider},
		{T: externglib.Type(C.gtk_tool_shell_get_type()), F: marshalToolShell},
		{T: externglib.Type(C.gtk_tree_drag_dest_get_type()), F: marshalTreeDragDest},
		{T: externglib.Type(C.gtk_tree_drag_source_get_type()), F: marshalTreeDragSource},
		{T: externglib.Type(C.gtk_tree_model_get_type()), F: marshalTreeModel},
		{T: externglib.Type(C.gtk_tree_sortable_get_type()), F: marshalTreeSortable},
		{T: externglib.Type(C.gtk_about_dialog_get_type()), F: marshalAboutDialog},
		{T: externglib.Type(C.gtk_accel_group_get_type()), F: marshalAccelGroup},
		{T: externglib.Type(C.gtk_accel_label_get_type()), F: marshalAccelLabel},
		{T: externglib.Type(C.gtk_accel_map_get_type()), F: marshalAccelMap},
		{T: externglib.Type(C.gtk_action_get_type()), F: marshalAction},
		{T: externglib.Type(C.gtk_action_bar_get_type()), F: marshalActionBar},
		{T: externglib.Type(C.gtk_action_group_get_type()), F: marshalActionGroup},
		{T: externglib.Type(C.gtk_adjustment_get_type()), F: marshalAdjustment},
		{T: externglib.Type(C.gtk_alignment_get_type()), F: marshalAlignment},
		{T: externglib.Type(C.gtk_app_chooser_button_get_type()), F: marshalAppChooserButton},
		{T: externglib.Type(C.gtk_app_chooser_dialog_get_type()), F: marshalAppChooserDialog},
		{T: externglib.Type(C.gtk_app_chooser_widget_get_type()), F: marshalAppChooserWidget},
		{T: externglib.Type(C.gtk_application_get_type()), F: marshalApplication},
		{T: externglib.Type(C.gtk_application_window_get_type()), F: marshalApplicationWindow},
		{T: externglib.Type(C.gtk_arrow_get_type()), F: marshalArrow},
		{T: externglib.Type(C.gtk_arrow_accessible_get_type()), F: marshalArrowAccessible},
		{T: externglib.Type(C.gtk_aspect_frame_get_type()), F: marshalAspectFrame},
		{T: externglib.Type(C.gtk_assistant_get_type()), F: marshalAssistant},
		{T: externglib.Type(C.gtk_bin_get_type()), F: marshalBin},
		{T: externglib.Type(C.gtk_boolean_cell_accessible_get_type()), F: marshalBooleanCellAccessible},
		{T: externglib.Type(C.gtk_box_get_type()), F: marshalBox},
		{T: externglib.Type(C.gtk_builder_get_type()), F: marshalBuilder},
		{T: externglib.Type(C.gtk_button_get_type()), F: marshalButton},
		{T: externglib.Type(C.gtk_button_accessible_get_type()), F: marshalButtonAccessible},
		{T: externglib.Type(C.gtk_button_box_get_type()), F: marshalButtonBox},
		{T: externglib.Type(C.gtk_calendar_get_type()), F: marshalCalendar},
		{T: externglib.Type(C.gtk_cell_area_get_type()), F: marshalCellArea},
		{T: externglib.Type(C.gtk_cell_area_box_get_type()), F: marshalCellAreaBox},
		{T: externglib.Type(C.gtk_cell_area_context_get_type()), F: marshalCellAreaContext},
		{T: externglib.Type(C.gtk_cell_renderer_get_type()), F: marshalCellRenderer},
		{T: externglib.Type(C.gtk_cell_renderer_accel_get_type()), F: marshalCellRendererAccel},
		{T: externglib.Type(C.gtk_cell_renderer_combo_get_type()), F: marshalCellRendererCombo},
		{T: externglib.Type(C.gtk_cell_renderer_pixbuf_get_type()), F: marshalCellRendererPixbuf},
		{T: externglib.Type(C.gtk_cell_renderer_progress_get_type()), F: marshalCellRendererProgress},
		{T: externglib.Type(C.gtk_cell_renderer_spin_get_type()), F: marshalCellRendererSpin},
		{T: externglib.Type(C.gtk_cell_renderer_spinner_get_type()), F: marshalCellRendererSpinner},
		{T: externglib.Type(C.gtk_cell_renderer_text_get_type()), F: marshalCellRendererText},
		{T: externglib.Type(C.gtk_cell_renderer_toggle_get_type()), F: marshalCellRendererToggle},
		{T: externglib.Type(C.gtk_cell_view_get_type()), F: marshalCellView},
		{T: externglib.Type(C.gtk_check_button_get_type()), F: marshalCheckButton},
		{T: externglib.Type(C.gtk_check_menu_item_get_type()), F: marshalCheckMenuItem},
		{T: externglib.Type(C.gtk_check_menu_item_accessible_get_type()), F: marshalCheckMenuItemAccessible},
		{T: externglib.Type(C.gtk_clipboard_get_type()), F: marshalClipboard},
		{T: externglib.Type(C.gtk_color_button_get_type()), F: marshalColorButton},
		{T: externglib.Type(C.gtk_color_chooser_dialog_get_type()), F: marshalColorChooserDialog},
		{T: externglib.Type(C.gtk_color_chooser_widget_get_type()), F: marshalColorChooserWidget},
		{T: externglib.Type(C.gtk_color_selection_get_type()), F: marshalColorSelection},
		{T: externglib.Type(C.gtk_color_selection_dialog_get_type()), F: marshalColorSelectionDialog},
		{T: externglib.Type(C.gtk_combo_box_get_type()), F: marshalComboBox},
		{T: externglib.Type(C.gtk_combo_box_accessible_get_type()), F: marshalComboBoxAccessible},
		{T: externglib.Type(C.gtk_combo_box_text_get_type()), F: marshalComboBoxText},
		{T: externglib.Type(C.gtk_container_get_type()), F: marshalContainer},
		{T: externglib.Type(C.gtk_container_accessible_get_type()), F: marshalContainerAccessible},
		{T: externglib.Type(C.gtk_container_cell_accessible_get_type()), F: marshalContainerCellAccessible},
		{T: externglib.Type(C.gtk_css_provider_get_type()), F: marshalCSSProvider},
		{T: externglib.Type(C.gtk_dialog_get_type()), F: marshalDialog},
		{T: externglib.Type(C.gtk_drawing_area_get_type()), F: marshalDrawingArea},
		{T: externglib.Type(C.gtk_entry_get_type()), F: marshalEntry},
		{T: externglib.Type(C.gtk_entry_accessible_get_type()), F: marshalEntryAccessible},
		{T: externglib.Type(C.gtk_entry_buffer_get_type()), F: marshalEntryBuffer},
		{T: externglib.Type(C.gtk_entry_completion_get_type()), F: marshalEntryCompletion},
		{T: externglib.Type(C.gtk_event_box_get_type()), F: marshalEventBox},
		{T: externglib.Type(C.gtk_event_controller_get_type()), F: marshalEventController},
		{T: externglib.Type(C.gtk_event_controller_key_get_type()), F: marshalEventControllerKey},
		{T: externglib.Type(C.gtk_event_controller_motion_get_type()), F: marshalEventControllerMotion},
		{T: externglib.Type(C.gtk_event_controller_scroll_get_type()), F: marshalEventControllerScroll},
		{T: externglib.Type(C.gtk_expander_get_type()), F: marshalExpander},
		{T: externglib.Type(C.gtk_expander_accessible_get_type()), F: marshalExpanderAccessible},
		{T: externglib.Type(C.gtk_file_chooser_button_get_type()), F: marshalFileChooserButton},
		{T: externglib.Type(C.gtk_file_chooser_dialog_get_type()), F: marshalFileChooserDialog},
		{T: externglib.Type(C.gtk_file_chooser_native_get_type()), F: marshalFileChooserNative},
		{T: externglib.Type(C.gtk_file_chooser_widget_get_type()), F: marshalFileChooserWidget},
		{T: externglib.Type(C.gtk_file_filter_get_type()), F: marshalFileFilter},
		{T: externglib.Type(C.gtk_fixed_get_type()), F: marshalFixed},
		{T: externglib.Type(C.gtk_flow_box_get_type()), F: marshalFlowBox},
		{T: externglib.Type(C.gtk_flow_box_accessible_get_type()), F: marshalFlowBoxAccessible},
		{T: externglib.Type(C.gtk_flow_box_child_get_type()), F: marshalFlowBoxChild},
		{T: externglib.Type(C.gtk_flow_box_child_accessible_get_type()), F: marshalFlowBoxChildAccessible},
		{T: externglib.Type(C.gtk_font_button_get_type()), F: marshalFontButton},
		{T: externglib.Type(C.gtk_font_chooser_dialog_get_type()), F: marshalFontChooserDialog},
		{T: externglib.Type(C.gtk_font_chooser_widget_get_type()), F: marshalFontChooserWidget},
		{T: externglib.Type(C.gtk_font_selection_get_type()), F: marshalFontSelection},
		{T: externglib.Type(C.gtk_font_selection_dialog_get_type()), F: marshalFontSelectionDialog},
		{T: externglib.Type(C.gtk_frame_get_type()), F: marshalFrame},
		{T: externglib.Type(C.gtk_frame_accessible_get_type()), F: marshalFrameAccessible},
		{T: externglib.Type(C.gtk_gl_area_get_type()), F: marshalGLArea},
		{T: externglib.Type(C.gtk_gesture_get_type()), F: marshalGesture},
		{T: externglib.Type(C.gtk_gesture_drag_get_type()), F: marshalGestureDrag},
		{T: externglib.Type(C.gtk_gesture_long_press_get_type()), F: marshalGestureLongPress},
		{T: externglib.Type(C.gtk_gesture_multi_press_get_type()), F: marshalGestureMultiPress},
		{T: externglib.Type(C.gtk_gesture_pan_get_type()), F: marshalGesturePan},
		{T: externglib.Type(C.gtk_gesture_rotate_get_type()), F: marshalGestureRotate},
		{T: externglib.Type(C.gtk_gesture_single_get_type()), F: marshalGestureSingle},
		{T: externglib.Type(C.gtk_gesture_stylus_get_type()), F: marshalGestureStylus},
		{T: externglib.Type(C.gtk_gesture_swipe_get_type()), F: marshalGestureSwipe},
		{T: externglib.Type(C.gtk_gesture_zoom_get_type()), F: marshalGestureZoom},
		{T: externglib.Type(C.gtk_grid_get_type()), F: marshalGrid},
		{T: externglib.Type(C.gtk_hbox_get_type()), F: marshalHBox},
		{T: externglib.Type(C.gtk_hbutton_box_get_type()), F: marshalHButtonBox},
		{T: externglib.Type(C.gtk_hpaned_get_type()), F: marshalHPaned},
		{T: externglib.Type(C.gtk_hsv_get_type()), F: marshalHSV},
		{T: externglib.Type(C.gtk_hscale_get_type()), F: marshalHScale},
		{T: externglib.Type(C.gtk_hscrollbar_get_type()), F: marshalHScrollbar},
		{T: externglib.Type(C.gtk_hseparator_get_type()), F: marshalHSeparator},
		{T: externglib.Type(C.gtk_handle_box_get_type()), F: marshalHandleBox},
		{T: externglib.Type(C.gtk_header_bar_get_type()), F: marshalHeaderBar},
		{T: externglib.Type(C.gtk_header_bar_accessible_get_type()), F: marshalHeaderBarAccessible},
		{T: externglib.Type(C.gtk_im_context_get_type()), F: marshalIMContext},
		{T: externglib.Type(C.gtk_im_context_simple_get_type()), F: marshalIMContextSimple},
		{T: externglib.Type(C.gtk_im_multicontext_get_type()), F: marshalIMMulticontext},
		{T: externglib.Type(C.gtk_icon_factory_get_type()), F: marshalIconFactory},
		{T: externglib.Type(C.gtk_icon_info_get_type()), F: marshalIconInfo},
		{T: externglib.Type(C.gtk_icon_theme_get_type()), F: marshalIconTheme},
		{T: externglib.Type(C.gtk_icon_view_get_type()), F: marshalIconView},
		{T: externglib.Type(C.gtk_icon_view_accessible_get_type()), F: marshalIconViewAccessible},
		{T: externglib.Type(C.gtk_image_get_type()), F: marshalImage},
		{T: externglib.Type(C.gtk_image_accessible_get_type()), F: marshalImageAccessible},
		{T: externglib.Type(C.gtk_image_cell_accessible_get_type()), F: marshalImageCellAccessible},
		{T: externglib.Type(C.gtk_image_menu_item_get_type()), F: marshalImageMenuItem},
		{T: externglib.Type(C.gtk_info_bar_get_type()), F: marshalInfoBar},
		{T: externglib.Type(C.gtk_invisible_get_type()), F: marshalInvisible},
		{T: externglib.Type(C.gtk_label_get_type()), F: marshalLabel},
		{T: externglib.Type(C.gtk_label_accessible_get_type()), F: marshalLabelAccessible},
		{T: externglib.Type(C.gtk_layout_get_type()), F: marshalLayout},
		{T: externglib.Type(C.gtk_level_bar_get_type()), F: marshalLevelBar},
		{T: externglib.Type(C.gtk_level_bar_accessible_get_type()), F: marshalLevelBarAccessible},
		{T: externglib.Type(C.gtk_link_button_get_type()), F: marshalLinkButton},
		{T: externglib.Type(C.gtk_link_button_accessible_get_type()), F: marshalLinkButtonAccessible},
		{T: externglib.Type(C.gtk_list_box_get_type()), F: marshalListBox},
		{T: externglib.Type(C.gtk_list_box_accessible_get_type()), F: marshalListBoxAccessible},
		{T: externglib.Type(C.gtk_list_box_row_get_type()), F: marshalListBoxRow},
		{T: externglib.Type(C.gtk_list_box_row_accessible_get_type()), F: marshalListBoxRowAccessible},
		{T: externglib.Type(C.gtk_list_store_get_type()), F: marshalListStore},
		{T: externglib.Type(C.gtk_lock_button_get_type()), F: marshalLockButton},
		{T: externglib.Type(C.gtk_lock_button_accessible_get_type()), F: marshalLockButtonAccessible},
		{T: externglib.Type(C.gtk_menu_get_type()), F: marshalMenu},
		{T: externglib.Type(C.gtk_menu_accessible_get_type()), F: marshalMenuAccessible},
		{T: externglib.Type(C.gtk_menu_bar_get_type()), F: marshalMenuBar},
		{T: externglib.Type(C.gtk_menu_button_get_type()), F: marshalMenuButton},
		{T: externglib.Type(C.gtk_menu_button_accessible_get_type()), F: marshalMenuButtonAccessible},
		{T: externglib.Type(C.gtk_menu_item_get_type()), F: marshalMenuItem},
		{T: externglib.Type(C.gtk_menu_item_accessible_get_type()), F: marshalMenuItemAccessible},
		{T: externglib.Type(C.gtk_menu_shell_get_type()), F: marshalMenuShell},
		{T: externglib.Type(C.gtk_menu_shell_accessible_get_type()), F: marshalMenuShellAccessible},
		{T: externglib.Type(C.gtk_menu_tool_button_get_type()), F: marshalMenuToolButton},
		{T: externglib.Type(C.gtk_message_dialog_get_type()), F: marshalMessageDialog},
		{T: externglib.Type(C.gtk_misc_get_type()), F: marshalMisc},
		{T: externglib.Type(C.gtk_model_button_get_type()), F: marshalModelButton},
		{T: externglib.Type(C.gtk_mount_operation_get_type()), F: marshalMountOperation},
		{T: externglib.Type(C.gtk_native_dialog_get_type()), F: marshalNativeDialog},
		{T: externglib.Type(C.gtk_notebook_get_type()), F: marshalNotebook},
		{T: externglib.Type(C.gtk_notebook_accessible_get_type()), F: marshalNotebookAccessible},
		{T: externglib.Type(C.gtk_numerable_icon_get_type()), F: marshalNumerableIcon},
		{T: externglib.Type(C.gtk_offscreen_window_get_type()), F: marshalOffscreenWindow},
		{T: externglib.Type(C.gtk_overlay_get_type()), F: marshalOverlay},
		{T: externglib.Type(C.gtk_pad_controller_get_type()), F: marshalPadController},
		{T: externglib.Type(C.gtk_page_setup_get_type()), F: marshalPageSetup},
		{T: externglib.Type(C.gtk_paned_get_type()), F: marshalPaned},
		{T: externglib.Type(C.gtk_paned_accessible_get_type()), F: marshalPanedAccessible},
		{T: externglib.Type(C.gtk_places_sidebar_get_type()), F: marshalPlacesSidebar},
		{T: externglib.Type(C.gtk_plug_get_type()), F: marshalPlug},
		{T: externglib.Type(C.gtk_plug_accessible_get_type()), F: marshalPlugAccessible},
		{T: externglib.Type(C.gtk_popover_get_type()), F: marshalPopover},
		{T: externglib.Type(C.gtk_popover_accessible_get_type()), F: marshalPopoverAccessible},
		{T: externglib.Type(C.gtk_popover_menu_get_type()), F: marshalPopoverMenu},
		{T: externglib.Type(C.gtk_print_context_get_type()), F: marshalPrintContext},
		{T: externglib.Type(C.gtk_print_operation_get_type()), F: marshalPrintOperation},
		{T: externglib.Type(C.gtk_print_settings_get_type()), F: marshalPrintSettings},
		{T: externglib.Type(C.gtk_progress_bar_get_type()), F: marshalProgressBar},
		{T: externglib.Type(C.gtk_progress_bar_accessible_get_type()), F: marshalProgressBarAccessible},
		{T: externglib.Type(C.gtk_radio_action_get_type()), F: marshalRadioAction},
		{T: externglib.Type(C.gtk_radio_button_get_type()), F: marshalRadioButton},
		{T: externglib.Type(C.gtk_radio_button_accessible_get_type()), F: marshalRadioButtonAccessible},
		{T: externglib.Type(C.gtk_radio_menu_item_get_type()), F: marshalRadioMenuItem},
		{T: externglib.Type(C.gtk_radio_menu_item_accessible_get_type()), F: marshalRadioMenuItemAccessible},
		{T: externglib.Type(C.gtk_radio_tool_button_get_type()), F: marshalRadioToolButton},
		{T: externglib.Type(C.gtk_range_get_type()), F: marshalRange},
		{T: externglib.Type(C.gtk_range_accessible_get_type()), F: marshalRangeAccessible},
		{T: externglib.Type(C.gtk_rc_style_get_type()), F: marshalRCStyle},
		{T: externglib.Type(C.gtk_recent_action_get_type()), F: marshalRecentAction},
		{T: externglib.Type(C.gtk_recent_chooser_dialog_get_type()), F: marshalRecentChooserDialog},
		{T: externglib.Type(C.gtk_recent_chooser_menu_get_type()), F: marshalRecentChooserMenu},
		{T: externglib.Type(C.gtk_recent_chooser_widget_get_type()), F: marshalRecentChooserWidget},
		{T: externglib.Type(C.gtk_recent_filter_get_type()), F: marshalRecentFilter},
		{T: externglib.Type(C.gtk_recent_manager_get_type()), F: marshalRecentManager},
		{T: externglib.Type(C.gtk_renderer_cell_accessible_get_type()), F: marshalRendererCellAccessible},
		{T: externglib.Type(C.gtk_revealer_get_type()), F: marshalRevealer},
		{T: externglib.Type(C.gtk_scale_get_type()), F: marshalScale},
		{T: externglib.Type(C.gtk_scale_accessible_get_type()), F: marshalScaleAccessible},
		{T: externglib.Type(C.gtk_scale_button_get_type()), F: marshalScaleButton},
		{T: externglib.Type(C.gtk_scale_button_accessible_get_type()), F: marshalScaleButtonAccessible},
		{T: externglib.Type(C.gtk_scrollbar_get_type()), F: marshalScrollbar},
		{T: externglib.Type(C.gtk_scrolled_window_get_type()), F: marshalScrolledWindow},
		{T: externglib.Type(C.gtk_scrolled_window_accessible_get_type()), F: marshalScrolledWindowAccessible},
		{T: externglib.Type(C.gtk_search_bar_get_type()), F: marshalSearchBar},
		{T: externglib.Type(C.gtk_search_entry_get_type()), F: marshalSearchEntry},
		{T: externglib.Type(C.gtk_separator_get_type()), F: marshalSeparator},
		{T: externglib.Type(C.gtk_separator_menu_item_get_type()), F: marshalSeparatorMenuItem},
		{T: externglib.Type(C.gtk_separator_tool_item_get_type()), F: marshalSeparatorToolItem},
		{T: externglib.Type(C.gtk_settings_get_type()), F: marshalSettings},
		{T: externglib.Type(C.gtk_shortcut_label_get_type()), F: marshalShortcutLabel},
		{T: externglib.Type(C.gtk_shortcuts_group_get_type()), F: marshalShortcutsGroup},
		{T: externglib.Type(C.gtk_shortcuts_section_get_type()), F: marshalShortcutsSection},
		{T: externglib.Type(C.gtk_shortcuts_shortcut_get_type()), F: marshalShortcutsShortcut},
		{T: externglib.Type(C.gtk_shortcuts_window_get_type()), F: marshalShortcutsWindow},
		{T: externglib.Type(C.gtk_size_group_get_type()), F: marshalSizeGroup},
		{T: externglib.Type(C.gtk_socket_get_type()), F: marshalSocket},
		{T: externglib.Type(C.gtk_socket_accessible_get_type()), F: marshalSocketAccessible},
		{T: externglib.Type(C.gtk_spin_button_get_type()), F: marshalSpinButton},
		{T: externglib.Type(C.gtk_spin_button_accessible_get_type()), F: marshalSpinButtonAccessible},
		{T: externglib.Type(C.gtk_spinner_get_type()), F: marshalSpinner},
		{T: externglib.Type(C.gtk_spinner_accessible_get_type()), F: marshalSpinnerAccessible},
		{T: externglib.Type(C.gtk_stack_get_type()), F: marshalStack},
		{T: externglib.Type(C.gtk_stack_accessible_get_type()), F: marshalStackAccessible},
		{T: externglib.Type(C.gtk_stack_sidebar_get_type()), F: marshalStackSidebar},
		{T: externglib.Type(C.gtk_stack_switcher_get_type()), F: marshalStackSwitcher},
		{T: externglib.Type(C.gtk_status_icon_get_type()), F: marshalStatusIcon},
		{T: externglib.Type(C.gtk_statusbar_get_type()), F: marshalStatusbar},
		{T: externglib.Type(C.gtk_statusbar_accessible_get_type()), F: marshalStatusbarAccessible},
		{T: externglib.Type(C.gtk_style_get_type()), F: marshalStyle},
		{T: externglib.Type(C.gtk_style_context_get_type()), F: marshalStyleContext},
		{T: externglib.Type(C.gtk_style_properties_get_type()), F: marshalStyleProperties},
		{T: externglib.Type(C.gtk_switch_get_type()), F: marshalSwitch},
		{T: externglib.Type(C.gtk_switch_accessible_get_type()), F: marshalSwitchAccessible},
		{T: externglib.Type(C.gtk_table_get_type()), F: marshalTable},
		{T: externglib.Type(C.gtk_tearoff_menu_item_get_type()), F: marshalTearoffMenuItem},
		{T: externglib.Type(C.gtk_text_buffer_get_type()), F: marshalTextBuffer},
		{T: externglib.Type(C.gtk_text_cell_accessible_get_type()), F: marshalTextCellAccessible},
		{T: externglib.Type(C.gtk_text_child_anchor_get_type()), F: marshalTextChildAnchor},
		{T: externglib.Type(C.gtk_text_mark_get_type()), F: marshalTextMark},
		{T: externglib.Type(C.gtk_text_tag_get_type()), F: marshalTextTag},
		{T: externglib.Type(C.gtk_text_tag_table_get_type()), F: marshalTextTagTable},
		{T: externglib.Type(C.gtk_text_view_get_type()), F: marshalTextView},
		{T: externglib.Type(C.gtk_text_view_accessible_get_type()), F: marshalTextViewAccessible},
		{T: externglib.Type(C.gtk_theming_engine_get_type()), F: marshalThemingEngine},
		{T: externglib.Type(C.gtk_toggle_action_get_type()), F: marshalToggleAction},
		{T: externglib.Type(C.gtk_toggle_button_get_type()), F: marshalToggleButton},
		{T: externglib.Type(C.gtk_toggle_button_accessible_get_type()), F: marshalToggleButtonAccessible},
		{T: externglib.Type(C.gtk_toggle_tool_button_get_type()), F: marshalToggleToolButton},
		{T: externglib.Type(C.gtk_tool_button_get_type()), F: marshalToolButton},
		{T: externglib.Type(C.gtk_tool_item_get_type()), F: marshalToolItem},
		{T: externglib.Type(C.gtk_tool_item_group_get_type()), F: marshalToolItemGroup},
		{T: externglib.Type(C.gtk_tool_palette_get_type()), F: marshalToolPalette},
		{T: externglib.Type(C.gtk_toolbar_get_type()), F: marshalToolbar},
		{T: externglib.Type(C.gtk_tooltip_get_type()), F: marshalTooltip},
		{T: externglib.Type(C.gtk_tree_model_filter_get_type()), F: marshalTreeModelFilter},
		{T: externglib.Type(C.gtk_tree_model_sort_get_type()), F: marshalTreeModelSort},
		{T: externglib.Type(C.gtk_tree_selection_get_type()), F: marshalTreeSelection},
		{T: externglib.Type(C.gtk_tree_store_get_type()), F: marshalTreeStore},
		{T: externglib.Type(C.gtk_tree_view_get_type()), F: marshalTreeView},
		{T: externglib.Type(C.gtk_tree_view_accessible_get_type()), F: marshalTreeViewAccessible},
		{T: externglib.Type(C.gtk_tree_view_column_get_type()), F: marshalTreeViewColumn},
		{T: externglib.Type(C.gtk_ui_manager_get_type()), F: marshalUIManager},
		{T: externglib.Type(C.gtk_vbox_get_type()), F: marshalVBox},
		{T: externglib.Type(C.gtk_vbutton_box_get_type()), F: marshalVButtonBox},
		{T: externglib.Type(C.gtk_vpaned_get_type()), F: marshalVPaned},
		{T: externglib.Type(C.gtk_vscale_get_type()), F: marshalVScale},
		{T: externglib.Type(C.gtk_vscrollbar_get_type()), F: marshalVScrollbar},
		{T: externglib.Type(C.gtk_vseparator_get_type()), F: marshalVSeparator},
		{T: externglib.Type(C.gtk_viewport_get_type()), F: marshalViewport},
		{T: externglib.Type(C.gtk_volume_button_get_type()), F: marshalVolumeButton},
		{T: externglib.Type(C.gtk_widget_get_type()), F: marshalWidget},
		{T: externglib.Type(C.gtk_window_get_type()), F: marshalWindow},
		{T: externglib.Type(C.gtk_window_accessible_get_type()), F: marshalWindowAccessible},
		{T: externglib.Type(C.gtk_window_group_get_type()), F: marshalWindowGroup},
		{T: externglib.Type(C.gtk_border_get_type()), F: marshalBorder},
		{T: externglib.Type(C.gtk_css_section_get_type()), F: marshalCSSSection},
		{T: externglib.Type(C.gtk_gradient_get_type()), F: marshalGradient},
		{T: externglib.Type(C.gtk_icon_set_get_type()), F: marshalIconSet},
		{T: externglib.Type(C.gtk_icon_source_get_type()), F: marshalIconSource},
		{T: externglib.Type(C.gtk_paper_size_get_type()), F: marshalPaperSize},
		{T: externglib.Type(C.gtk_recent_info_get_type()), F: marshalRecentInfo},
		{T: externglib.Type(C.gtk_requisition_get_type()), F: marshalRequisition},
		{T: externglib.Type(C.gtk_selection_data_get_type()), F: marshalSelectionData},
		{T: externglib.Type(C.gtk_symbolic_color_get_type()), F: marshalSymbolicColor},
		{T: externglib.Type(C.gtk_target_entry_get_type()), F: marshalTargetEntry},
		{T: externglib.Type(C.gtk_target_list_get_type()), F: marshalTargetList},
		{T: externglib.Type(C.gtk_text_attributes_get_type()), F: marshalTextAttributes},
		{T: externglib.Type(C.gtk_text_iter_get_type()), F: marshalTextIter},
		{T: externglib.Type(C.gtk_tree_iter_get_type()), F: marshalTreeIter},
		{T: externglib.Type(C.gtk_tree_path_get_type()), F: marshalTreePath},
		{T: externglib.Type(C.gtk_tree_row_reference_get_type()), F: marshalTreeRowReference},
		{T: externglib.Type(C.gtk_widget_path_get_type()), F: marshalWidgetPath},
	})
}

// Allocation: a Allocation-struct of a widget represents region which has been
// allocated to the widget by its parent. It is a subregion of its parents
// allocation. See [GtkWidget’s geometry management
// section][geometry-management] for more information.
type Allocation = gdk.Rectangle

type Stock = string

// Align controls how a widget deals with extra space in a single (x or y)
// dimension.
//
// Alignment only matters if the widget receives a “too large” allocation, for
// example if you packed the widget with the Widget:expand flag inside a Box,
// then the widget might get extra space. If you have for example a 16x16 icon
// inside a 32x32 space, the icon could be scaled and stretched, it could be
// centered, or it could be positioned to one side of the space.
//
// Note that in horizontal context @GTK_ALIGN_START and @GTK_ALIGN_END are
// interpreted relative to text direction.
//
// GTK_ALIGN_BASELINE support for it is optional for containers and widgets, and
// it is only supported for vertical alignment. When its not supported by a
// child or a container it is treated as @GTK_ALIGN_FILL.
type Align int

const (
	// AlignFill: stretch to fill all space if possible, center if no meaningful
	// way to stretch
	AlignFill Align = 0
	// AlignStart: snap to left or top side, leaving space on right or bottom
	AlignStart Align = 1
	// AlignEnd: snap to right or bottom side, leaving space on left or top
	AlignEnd Align = 2
	// AlignCenter: center natural width of widget inside the allocation
	AlignCenter Align = 3
	// AlignBaseline: align the widget according to the baseline. Since 3.10.
	AlignBaseline Align = 4
)

func marshalAlign(p uintptr) (interface{}, error) {
	return Align(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ArrowPlacement: used to specify the placement of scroll arrows in scrolling
// menus.
type ArrowPlacement int

const (
	// ArrowPlacementBoth: place one arrow on each end of the menu.
	ArrowPlacementBoth ArrowPlacement = 0
	// ArrowPlacementStart: place both arrows at the top of the menu.
	ArrowPlacementStart ArrowPlacement = 1
	// ArrowPlacementEnd: place both arrows at the bottom of the menu.
	ArrowPlacementEnd ArrowPlacement = 2
)

func marshalArrowPlacement(p uintptr) (interface{}, error) {
	return ArrowPlacement(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ArrowType: used to indicate the direction in which an arrow should point.
type ArrowType int

const (
	// ArrowTypeUp represents an upward pointing arrow.
	ArrowTypeUp ArrowType = 0
	// ArrowTypeDown represents a downward pointing arrow.
	ArrowTypeDown ArrowType = 1
	// ArrowTypeLeft represents a left pointing arrow.
	ArrowTypeLeft ArrowType = 2
	// ArrowTypeRight represents a right pointing arrow.
	ArrowTypeRight ArrowType = 3
	// ArrowTypeNone: no arrow. Since 2.10.
	ArrowTypeNone ArrowType = 4
)

func marshalArrowType(p uintptr) (interface{}, error) {
	return ArrowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AssistantPageType: an enum for determining the page role inside the
// Assistant. It's used to handle buttons sensitivity and visibility.
//
// Note that an assistant needs to end its page flow with a page of type
// GTK_ASSISTANT_PAGE_CONFIRM, GTK_ASSISTANT_PAGE_SUMMARY or
// GTK_ASSISTANT_PAGE_PROGRESS to be correct.
//
// The Cancel button will only be shown if the page isn’t “committed”. See
// gtk_assistant_commit() for details.
type AssistantPageType int

const (
	// AssistantPageTypeContent: the page has regular contents. Both the Back
	// and forward buttons will be shown.
	AssistantPageTypeContent AssistantPageType = 0
	// AssistantPageTypeIntro: the page contains an introduction to the
	// assistant task. Only the Forward button will be shown if there is a next
	// page.
	AssistantPageTypeIntro AssistantPageType = 1
	// AssistantPageTypeConfirm: the page lets the user confirm or deny the
	// changes. The Back and Apply buttons will be shown.
	AssistantPageTypeConfirm AssistantPageType = 2
	// AssistantPageTypeSummary: the page informs the user of the changes done.
	// Only the Close button will be shown.
	AssistantPageTypeSummary AssistantPageType = 3
	// AssistantPageTypeProgress: used for tasks that take a long time to
	// complete, blocks the assistant until the page is marked as complete. Only
	// the back button will be shown.
	AssistantPageTypeProgress AssistantPageType = 4
	// AssistantPageTypeCustom: used for when other page types are not
	// appropriate. No buttons will be shown, and the application must add its
	// own buttons through gtk_assistant_add_action_widget().
	AssistantPageTypeCustom AssistantPageType = 5
)

func marshalAssistantPageType(p uintptr) (interface{}, error) {
	return AssistantPageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BaselinePosition: whenever a container has some form of natural row it may
// align children in that row along a common typographical baseline. If the
// amount of verical space in the row is taller than the total requested height
// of the baseline-aligned children then it can use a BaselinePosition to select
// where to put the baseline inside the extra availible space.
type BaselinePosition int

const (
	// BaselinePositionTop: align the baseline at the top
	BaselinePositionTop BaselinePosition = 0
	// BaselinePositionCenter: center the baseline
	BaselinePositionCenter BaselinePosition = 1
	// BaselinePositionBottom: align the baseline at the bottom
	BaselinePositionBottom BaselinePosition = 2
)

func marshalBaselinePosition(p uintptr) (interface{}, error) {
	return BaselinePosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BorderStyle describes how the border of a UI element should be rendered.
type BorderStyle int

const (
	// BorderStyleNone: no visible border
	BorderStyleNone BorderStyle = 0
	// BorderStyleSolid: a single line segment
	BorderStyleSolid BorderStyle = 1
	// BorderStyleInset looks as if the content is sunken into the canvas
	BorderStyleInset BorderStyle = 2
	// BorderStyleOutset looks as if the content is coming out of the canvas
	BorderStyleOutset BorderStyle = 3
	// BorderStyleHidden: same as @GTK_BORDER_STYLE_NONE
	BorderStyleHidden BorderStyle = 4
	// BorderStyleDotted: a series of round dots
	BorderStyleDotted BorderStyle = 5
	// BorderStyleDashed: a series of square-ended dashes
	BorderStyleDashed BorderStyle = 6
	// BorderStyleDouble: two parallel lines with some space between them
	BorderStyleDouble BorderStyle = 7
	// BorderStyleGroove looks as if it were carved in the canvas
	BorderStyleGroove BorderStyle = 8
	// BorderStyleRidge looks as if it were coming out of the canvas
	BorderStyleRidge BorderStyle = 9
)

func marshalBorderStyle(p uintptr) (interface{}, error) {
	return BorderStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BuilderError: error codes that identify various errors that can occur while
// using Builder.
type BuilderError int

const (
	// BuilderErrorInvalidTypeFunction: a type-func attribute didn’t name a
	// function that returns a #GType.
	BuilderErrorInvalidTypeFunction BuilderError = 0
	// BuilderErrorUnhandledTag: the input contained a tag that Builder can’t
	// handle.
	BuilderErrorUnhandledTag BuilderError = 1
	// BuilderErrorMissingAttribute: an attribute that is required by Builder
	// was missing.
	BuilderErrorMissingAttribute BuilderError = 2
	// BuilderErrorInvalidAttribute: Builder found an attribute that it doesn’t
	// understand.
	BuilderErrorInvalidAttribute BuilderError = 3
	// BuilderErrorInvalidTag: Builder found a tag that it doesn’t understand.
	BuilderErrorInvalidTag BuilderError = 4
	// BuilderErrorMissingPropertyValue: a required property value was missing.
	BuilderErrorMissingPropertyValue BuilderError = 5
	// BuilderErrorInvalidValue: Builder couldn’t parse some attribute value.
	BuilderErrorInvalidValue BuilderError = 6
	// BuilderErrorVersionMismatch: the input file requires a newer version of
	// GTK+.
	BuilderErrorVersionMismatch BuilderError = 7
	// BuilderErrorDuplicateID: an object id occurred twice.
	BuilderErrorDuplicateID BuilderError = 8
	// BuilderErrorObjectTypeRefused: a specified object type is of the same
	// type or derived from the type of the composite class being extended with
	// builder XML.
	BuilderErrorObjectTypeRefused BuilderError = 9
	// BuilderErrorTemplateMismatch: the wrong type was specified in a composite
	// class’s template XML
	BuilderErrorTemplateMismatch BuilderError = 10
	// BuilderErrorInvalidProperty: the specified property is unknown for the
	// object class.
	BuilderErrorInvalidProperty BuilderError = 11
	// BuilderErrorInvalidSignal: the specified signal is unknown for the object
	// class.
	BuilderErrorInvalidSignal BuilderError = 12
	// BuilderErrorInvalidID: an object id is unknown
	BuilderErrorInvalidID BuilderError = 13
)

func marshalBuilderError(p uintptr) (interface{}, error) {
	return BuilderError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ButtonBoxStyle: used to dictate the style that a ButtonBox uses to layout the
// buttons it contains.
type ButtonBoxStyle int

const (
	// ButtonBoxStyleSpread buttons are evenly spread across the box.
	ButtonBoxStyleSpread ButtonBoxStyle = 1
	// ButtonBoxStyleEdge buttons are placed at the edges of the box.
	ButtonBoxStyleEdge ButtonBoxStyle = 2
	// ButtonBoxStyleStart buttons are grouped towards the start of the box, (on
	// the left for a HBox, or the top for a VBox).
	ButtonBoxStyleStart ButtonBoxStyle = 3
	// ButtonBoxStyleEnd buttons are grouped towards the end of the box, (on the
	// right for a HBox, or the bottom for a VBox).
	ButtonBoxStyleEnd ButtonBoxStyle = 4
	// ButtonBoxStyleCenter buttons are centered in the box. Since 2.12.
	ButtonBoxStyleCenter ButtonBoxStyle = 5
	// ButtonBoxStyleExpand buttons expand to fill the box. This entails giving
	// buttons a "linked" appearance, making button sizes homogeneous, and
	// setting spacing to 0 (same as calling gtk_box_set_homogeneous() and
	// gtk_box_set_spacing() manually). Since 3.12.
	ButtonBoxStyleExpand ButtonBoxStyle = 6
)

func marshalButtonBoxStyle(p uintptr) (interface{}, error) {
	return ButtonBoxStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ButtonRole: the role specifies the desired appearance of a ModelButton.
type ButtonRole int

const (
	// ButtonRoleNormal: a plain button
	ButtonRoleNormal ButtonRole = 0
	// ButtonRoleCheck: a check button
	ButtonRoleCheck ButtonRole = 1
	// ButtonRoleRadio: a radio button
	ButtonRoleRadio ButtonRole = 2
)

func marshalButtonRole(p uintptr) (interface{}, error) {
	return ButtonRole(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ButtonsType: prebuilt sets of buttons for the dialog. If none of these
// choices are appropriate, simply use GTK_BUTTONS_NONE then call
// gtk_dialog_add_buttons().
//
// > Please note that GTK_BUTTONS_OK, GTK_BUTTONS_YES_NO > and
// GTK_BUTTONS_OK_CANCEL are discouraged by the > GNOME Human Interface
// Guidelines (http://library.gnome.org/devel/hig-book/stable/).
type ButtonsType int

const (
	// ButtonsTypeNone: no buttons at all
	ButtonsTypeNone ButtonsType = 0
	// ButtonsTypeOk: an OK button
	ButtonsTypeOk ButtonsType = 1
	// ButtonsTypeClose: a Close button
	ButtonsTypeClose ButtonsType = 2
	// ButtonsTypeCancel: a Cancel button
	ButtonsTypeCancel ButtonsType = 3
	// ButtonsTypeYesNo yes and No buttons
	ButtonsTypeYesNo ButtonsType = 4
	// ButtonsTypeOkCancel: OK and Cancel buttons
	ButtonsTypeOkCancel ButtonsType = 5
)

func marshalButtonsType(p uintptr) (interface{}, error) {
	return ButtonsType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CellRendererAccelMode determines if the edited accelerators are GTK+
// accelerators. If they are, consumed modifiers are suppressed, only
// accelerators accepted by GTK+ are allowed, and the accelerators are rendered
// in the same way as they are in menus.
type CellRendererAccelMode int

const (
	// CellRendererAccelModeGTK: GTK+ accelerators mode
	CellRendererAccelModeGTK CellRendererAccelMode = 0
	// CellRendererAccelModeOther: other accelerator mode
	CellRendererAccelModeOther CellRendererAccelMode = 1
)

func marshalCellRendererAccelMode(p uintptr) (interface{}, error) {
	return CellRendererAccelMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CellRendererMode identifies how the user can interact with a particular cell.
type CellRendererMode int

const (
	// CellRendererModeInert: the cell is just for display and cannot be
	// interacted with. Note that this doesn’t mean that eg. the row being drawn
	// can’t be selected -- just that a particular element of it cannot be
	// individually modified.
	CellRendererModeInert CellRendererMode = 0
	// CellRendererModeActivatable: the cell can be clicked.
	CellRendererModeActivatable CellRendererMode = 1
	// CellRendererModeEditable: the cell can be edited or otherwise modified.
	CellRendererModeEditable CellRendererMode = 2
)

func marshalCellRendererMode(p uintptr) (interface{}, error) {
	return CellRendererMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CornerType specifies which corner a child widget should be placed in when
// packed into a ScrolledWindow. This is effectively the opposite of where the
// scroll bars are placed.
type CornerType int

const (
	// CornerTypeTopLeft: place the scrollbars on the right and bottom of the
	// widget (default behaviour).
	CornerTypeTopLeft CornerType = 0
	// CornerTypeBottomLeft: place the scrollbars on the top and right of the
	// widget.
	CornerTypeBottomLeft CornerType = 1
	// CornerTypeTopRight: place the scrollbars on the left and bottom of the
	// widget.
	CornerTypeTopRight CornerType = 2
	// CornerTypeBottomRight: place the scrollbars on the top and left of the
	// widget.
	CornerTypeBottomRight CornerType = 3
)

func marshalCornerType(p uintptr) (interface{}, error) {
	return CornerType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CSSProviderError: error codes for GTK_CSS_PROVIDER_ERROR.
type CSSProviderError int

const (
	// CSSProviderErrorFailed: failed.
	CSSProviderErrorFailed CSSProviderError = 0
	// CSSProviderErrorSyntax: syntax error.
	CSSProviderErrorSyntax CSSProviderError = 1
	// CSSProviderErrorImport: import error.
	CSSProviderErrorImport CSSProviderError = 2
	// CSSProviderErrorName: name error.
	CSSProviderErrorName CSSProviderError = 3
	// CSSProviderErrorDeprecated: deprecation error.
	CSSProviderErrorDeprecated CSSProviderError = 4
	// CSSProviderErrorUnknownValue: unknown value.
	CSSProviderErrorUnknownValue CSSProviderError = 5
)

func marshalCSSProviderError(p uintptr) (interface{}, error) {
	return CSSProviderError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CSSSectionType: the different types of sections indicate parts of a CSS
// document as parsed by GTK’s CSS parser. They are oriented towards the CSS
// Grammar (http://www.w3.org/TR/CSS21/grammar.html), but may contain
// extensions.
//
// More types might be added in the future as the parser incorporates more
// features.
type CSSSectionType int

const (
	// CSSSectionTypeDocument: the section describes a complete document. This
	// section time is the only one where gtk_css_section_get_parent() might
	// return nil.
	CSSSectionTypeDocument CSSSectionType = 0
	// CSSSectionTypeImport: the section defines an import rule.
	CSSSectionTypeImport CSSSectionType = 1
	// CSSSectionTypeColorDefinition: the section defines a color. This is a GTK
	// extension to CSS.
	CSSSectionTypeColorDefinition CSSSectionType = 2
	// CSSSectionTypeBindingSet: the section defines a binding set. This is a
	// GTK extension to CSS.
	CSSSectionTypeBindingSet CSSSectionType = 3
	// CSSSectionTypeRuleset: the section defines a CSS ruleset.
	CSSSectionTypeRuleset CSSSectionType = 4
	// CSSSectionTypeSelector: the section defines a CSS selector.
	CSSSectionTypeSelector CSSSectionType = 5
	// CSSSectionTypeDeclaration: the section defines the declaration of a CSS
	// variable.
	CSSSectionTypeDeclaration CSSSectionType = 6
	// CSSSectionTypeValue: the section defines the value of a CSS declaration.
	CSSSectionTypeValue CSSSectionType = 7
	// CSSSectionTypeKeyframes: the section defines keyframes. See [CSS
	// Animations](http://dev.w3.org/csswg/css3-animations/#keyframes) for
	// details. Since 3.6
	CSSSectionTypeKeyframes CSSSectionType = 8
)

func marshalCSSSectionType(p uintptr) (interface{}, error) {
	return CSSSectionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DeleteType: see also: Entry::delete-from-cursor.
type DeleteType int

const (
	// DeleteTypeChars: delete characters.
	DeleteTypeChars DeleteType = 0
	// DeleteTypeWordEnds: delete only the portion of the word to the left/right
	// of cursor if we’re in the middle of a word.
	DeleteTypeWordEnds DeleteType = 1
	// DeleteTypeWords: delete words.
	DeleteTypeWords DeleteType = 2
	// DeleteTypeDisplayLines: delete display-lines. Display-lines refers to the
	// visible lines, with respect to to the current line breaks. As opposed to
	// paragraphs, which are defined by line breaks in the input.
	DeleteTypeDisplayLines DeleteType = 3
	// DeleteTypeDisplayLineEnds: delete only the portion of the display-line to
	// the left/right of cursor.
	DeleteTypeDisplayLineEnds DeleteType = 4
	// DeleteTypeParagraphEnds: delete to the end of the paragraph. Like C-k in
	// Emacs (or its reverse).
	DeleteTypeParagraphEnds DeleteType = 5
	// DeleteTypeParagraphs: delete entire line. Like C-k in pico.
	DeleteTypeParagraphs DeleteType = 6
	// DeleteTypeWhitespace: delete only whitespace. Like M-\ in Emacs.
	DeleteTypeWhitespace DeleteType = 7
)

func marshalDeleteType(p uintptr) (interface{}, error) {
	return DeleteType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DirectionType focus movement types.
type DirectionType int

const (
	// DirectionTypeTabForward: move forward.
	DirectionTypeTabForward DirectionType = 0
	// DirectionTypeTabBackward: move backward.
	DirectionTypeTabBackward DirectionType = 1
	// DirectionTypeUp: move up.
	DirectionTypeUp DirectionType = 2
	// DirectionTypeDown: move down.
	DirectionTypeDown DirectionType = 3
	// DirectionTypeLeft: move left.
	DirectionTypeLeft DirectionType = 4
	// DirectionTypeRight: move right.
	DirectionTypeRight DirectionType = 5
)

func marshalDirectionType(p uintptr) (interface{}, error) {
	return DirectionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DragResult gives an indication why a drag operation failed. The value can by
// obtained by connecting to the Widget::drag-failed signal.
type DragResult int

const (
	// DragResultSuccess: the drag operation was successful.
	DragResultSuccess DragResult = 0
	// DragResultNoTarget: no suitable drag target.
	DragResultNoTarget DragResult = 1
	// DragResultUserCancelled: the user cancelled the drag operation.
	DragResultUserCancelled DragResult = 2
	// DragResultTimeoutExpired: the drag operation timed out.
	DragResultTimeoutExpired DragResult = 3
	// DragResultGrabBroken: the pointer or keyboard grab used for the drag
	// operation was broken.
	DragResultGrabBroken DragResult = 4
	// DragResultError: the drag operation failed due to some unspecified error.
	DragResultError DragResult = 5
)

func marshalDragResult(p uintptr) (interface{}, error) {
	return DragResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EntryIconPosition specifies the side of the entry at which an icon is placed.
type EntryIconPosition int

const (
	// EntryIconPositionPrimary: at the beginning of the entry (depending on the
	// text direction).
	EntryIconPositionPrimary EntryIconPosition = 0
	// EntryIconPositionSecondary: at the end of the entry (depending on the
	// text direction).
	EntryIconPositionSecondary EntryIconPosition = 1
)

func marshalEntryIconPosition(p uintptr) (interface{}, error) {
	return EntryIconPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EventSequenceState describes the state of a EventSequence in a Gesture.
type EventSequenceState int

const (
	// EventSequenceStateNone: the sequence is handled, but not grabbed.
	EventSequenceStateNone EventSequenceState = 0
	// EventSequenceStateClaimed: the sequence is handled and grabbed.
	EventSequenceStateClaimed EventSequenceState = 1
	// EventSequenceStateDenied: the sequence is denied.
	EventSequenceStateDenied EventSequenceState = 2
)

func marshalEventSequenceState(p uintptr) (interface{}, error) {
	return EventSequenceState(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ExpanderStyle: used to specify the style of the expanders drawn by a
// TreeView.
type ExpanderStyle int

const (
	// ExpanderStyleCollapsed: the style used for a collapsed subtree.
	ExpanderStyleCollapsed ExpanderStyle = 0
	// ExpanderStyleSemiCollapsed: intermediate style used during animation.
	ExpanderStyleSemiCollapsed ExpanderStyle = 1
	// ExpanderStyleSemiExpanded: intermediate style used during animation.
	ExpanderStyleSemiExpanded ExpanderStyle = 2
	// ExpanderStyleExpanded: the style used for an expanded subtree.
	ExpanderStyleExpanded ExpanderStyle = 3
)

func marshalExpanderStyle(p uintptr) (interface{}, error) {
	return ExpanderStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileChooserAction describes whether a FileChooser is being used to open
// existing files or to save to a possibly new file.
type FileChooserAction int

const (
	// FileChooserActionOpen indicates open mode. The file chooser will only let
	// the user pick an existing file.
	FileChooserActionOpen FileChooserAction = 0
	// FileChooserActionSave indicates save mode. The file chooser will let the
	// user pick an existing file, or type in a new filename.
	FileChooserActionSave FileChooserAction = 1
	// FileChooserActionSelectFolder indicates an Open mode for selecting
	// folders. The file chooser will let the user pick an existing folder.
	FileChooserActionSelectFolder FileChooserAction = 2
	// FileChooserActionCreateFolder indicates a mode for creating a new folder.
	// The file chooser will let the user name an existing or new folder.
	FileChooserActionCreateFolder FileChooserAction = 3
)

func marshalFileChooserAction(p uintptr) (interface{}, error) {
	return FileChooserAction(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileChooserConfirmation: used as a return value of handlers for the
// FileChooser::confirm-overwrite signal of a FileChooser. This value determines
// whether the file chooser will present the stock confirmation dialog, accept
// the user’s choice of a filename, or let the user choose another filename.
type FileChooserConfirmation int

const (
	// FileChooserConfirmationConfirm: the file chooser will present its stock
	// dialog to confirm about overwriting an existing file.
	FileChooserConfirmationConfirm FileChooserConfirmation = 0
	// FileChooserConfirmationAcceptFilename: the file chooser will terminate
	// and accept the user’s choice of a file name.
	FileChooserConfirmationAcceptFilename FileChooserConfirmation = 1
	// FileChooserConfirmationSelectAgain: the file chooser will continue
	// running, so as to let the user select another file name.
	FileChooserConfirmationSelectAgain FileChooserConfirmation = 2
)

func marshalFileChooserConfirmation(p uintptr) (interface{}, error) {
	return FileChooserConfirmation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileChooserError: these identify the various errors that can occur while
// calling FileChooser functions.
type FileChooserError int

const (
	// FileChooserErrorNonexistent indicates that a file does not exist.
	FileChooserErrorNonexistent FileChooserError = 0
	// FileChooserErrorBadFilename indicates a malformed filename.
	FileChooserErrorBadFilename FileChooserError = 1
	// FileChooserErrorAlreadyExists indicates a duplicate path (e.g. when
	// adding a bookmark).
	FileChooserErrorAlreadyExists FileChooserError = 2
	// FileChooserErrorIncompleteHostname indicates an incomplete hostname (e.g.
	// "http://foo" without a slash after that).
	FileChooserErrorIncompleteHostname FileChooserError = 3
)

func marshalFileChooserError(p uintptr) (interface{}, error) {
	return FileChooserError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IMPreeditStyle: style for input method preedit. See also
// Settings:gtk-im-preedit-style
type IMPreeditStyle int

const (
	// IMPreeditStyleNothing: deprecated
	IMPreeditStyleNothing IMPreeditStyle = 0
	// IMPreeditStyleCallback: deprecated
	IMPreeditStyleCallback IMPreeditStyle = 1
	// IMPreeditStyleNone: deprecated
	IMPreeditStyleNone IMPreeditStyle = 2
)

func marshalIMPreeditStyle(p uintptr) (interface{}, error) {
	return IMPreeditStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IMStatusStyle: style for input method status. See also
// Settings:gtk-im-status-style
type IMStatusStyle int

const (
	// IMStatusStyleNothing: deprecated
	IMStatusStyleNothing IMStatusStyle = 0
	// IMStatusStyleCallback: deprecated
	IMStatusStyleCallback IMStatusStyle = 1
	// IMStatusStyleNone: deprecated
	IMStatusStyleNone IMStatusStyle = 2
)

func marshalIMStatusStyle(p uintptr) (interface{}, error) {
	return IMStatusStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconSize: built-in stock icon sizes.
type IconSize int

const (
	// IconSizeInvalid: invalid size.
	IconSizeInvalid IconSize = 0
	// IconSizeMenu: size appropriate for menus (16px).
	IconSizeMenu IconSize = 1
	// IconSizeSmallToolbar: size appropriate for small toolbars (16px).
	IconSizeSmallToolbar IconSize = 2
	// IconSizeLargeToolbar: size appropriate for large toolbars (24px)
	IconSizeLargeToolbar IconSize = 3
	// IconSizeButton: size appropriate for buttons (16px)
	IconSizeButton IconSize = 4
	// IconSizeDnd: size appropriate for drag and drop (32px)
	IconSizeDnd IconSize = 5
	// IconSizeDialog: size appropriate for dialogs (48px)
	IconSizeDialog IconSize = 6
)

func marshalIconSize(p uintptr) (interface{}, error) {
	return IconSize(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconThemeError: error codes for GtkIconTheme operations.
type IconThemeError int

const (
	// IconThemeErrorNotFound: the icon specified does not exist in the theme
	IconThemeErrorNotFound IconThemeError = 0
	// IconThemeErrorFailed: an unspecified error occurred.
	IconThemeErrorFailed IconThemeError = 1
)

func marshalIconThemeError(p uintptr) (interface{}, error) {
	return IconThemeError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconViewDropPosition: an enum for determining where a dropped item goes.
type IconViewDropPosition int

const (
	// IconViewDropPositionNoDrop: no drop possible
	IconViewDropPositionNoDrop IconViewDropPosition = 0
	// IconViewDropPositionDropInto: dropped item replaces the item
	IconViewDropPositionDropInto IconViewDropPosition = 1
	// IconViewDropPositionDropLeft: droppped item is inserted to the left
	IconViewDropPositionDropLeft IconViewDropPosition = 2
	// IconViewDropPositionDropRight: dropped item is inserted to the right
	IconViewDropPositionDropRight IconViewDropPosition = 3
	// IconViewDropPositionDropAbove: dropped item is inserted above
	IconViewDropPositionDropAbove IconViewDropPosition = 4
	// IconViewDropPositionDropBelow: dropped item is inserted below
	IconViewDropPositionDropBelow IconViewDropPosition = 5
)

func marshalIconViewDropPosition(p uintptr) (interface{}, error) {
	return IconViewDropPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ImageType describes the image data representation used by a Image. If you
// want to get the image from the widget, you can only get the currently-stored
// representation. e.g. if the gtk_image_get_storage_type() returns
// K_IMAGE_PIXBUF, then you can call gtk_image_get_pixbuf() but not
// gtk_image_get_stock(). For empty images, you can request any storage type
// (call any of the "get" functions), but they will all return nil values.
type ImageType int

const (
	// ImageTypeEmpty: there is no image displayed by the widget
	ImageTypeEmpty ImageType = 0
	// ImageTypePixbuf: the widget contains a Pixbuf
	ImageTypePixbuf ImageType = 1
	// ImageTypeStock: the widget contains a [stock item name][gtkstock]
	ImageTypeStock ImageType = 2
	// ImageTypeIconSet: the widget contains a IconSet
	ImageTypeIconSet ImageType = 3
	// ImageTypeAnimation: the widget contains a PixbufAnimation
	ImageTypeAnimation ImageType = 4
	// ImageTypeIconName: the widget contains a named icon. This image type was
	// added in GTK+ 2.6
	ImageTypeIconName ImageType = 5
	// ImageTypeGIcon: the widget contains a #GIcon. This image type was added
	// in GTK+ 2.14
	ImageTypeGIcon ImageType = 6
	// ImageTypeSurface: the widget contains a #cairo_surface_t. This image type
	// was added in GTK+ 3.10
	ImageTypeSurface ImageType = 7
)

func marshalImageType(p uintptr) (interface{}, error) {
	return ImageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// InputPurpose describes primary purpose of the input widget. This information
// is useful for on-screen keyboards and similar input methods to decide which
// keys should be presented to the user.
//
// Note that the purpose is not meant to impose a totally strict rule about
// allowed characters, and does not replace input validation. It is fine for an
// on-screen keyboard to let the user override the character set restriction
// that is expressed by the purpose. The application is expected to validate the
// entry contents, even if it specified a purpose.
//
// The difference between @GTK_INPUT_PURPOSE_DIGITS and
// @GTK_INPUT_PURPOSE_NUMBER is that the former accepts only digits while the
// latter also some punctuation (like commas or points, plus, minus) and “e” or
// “E” as in 3.14E+000.
//
// This enumeration may be extended in the future; input methods should
// interpret unknown values as “free form”.
type InputPurpose int

const (
	// InputPurposeFreeForm: allow any character
	InputPurposeFreeForm InputPurpose = 0
	// InputPurposeAlpha: allow only alphabetic characters
	InputPurposeAlpha InputPurpose = 1
	// InputPurposeDigits: allow only digits
	InputPurposeDigits InputPurpose = 2
	// InputPurposeNumber: edited field expects numbers
	InputPurposeNumber InputPurpose = 3
	// InputPurposePhone: edited field expects phone number
	InputPurposePhone InputPurpose = 4
	// InputPurposeURL: edited field expects URL
	InputPurposeURL InputPurpose = 5
	// InputPurposeEmail: edited field expects email address
	InputPurposeEmail InputPurpose = 6
	// InputPurposeName: edited field expects the name of a person
	InputPurposeName InputPurpose = 7
	// InputPurposePassword: like @GTK_INPUT_PURPOSE_FREE_FORM, but characters
	// are hidden
	InputPurposePassword InputPurpose = 8
	// InputPurposePin: like @GTK_INPUT_PURPOSE_DIGITS, but characters are
	// hidden
	InputPurposePin InputPurpose = 9
	// InputPurposeTerminal: allow any character, in addition to control codes
	InputPurposeTerminal InputPurpose = 10
)

func marshalInputPurpose(p uintptr) (interface{}, error) {
	return InputPurpose(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Justification: used for justifying the text inside a Label widget. (See also
// Alignment).
type Justification int

const (
	// JustificationLeft: the text is placed at the left edge of the label.
	JustificationLeft Justification = 0
	// JustificationRight: the text is placed at the right edge of the label.
	JustificationRight Justification = 1
	// JustificationCenter: the text is placed in the center of the label.
	JustificationCenter Justification = 2
	// JustificationFill: the text is placed is distributed across the label.
	JustificationFill Justification = 3
)

func marshalJustification(p uintptr) (interface{}, error) {
	return Justification(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// LevelBarMode describes how LevelBar contents should be rendered. Note that
// this enumeration could be extended with additional modes in the future.
type LevelBarMode int

const (
	// LevelBarModeContinuous: the bar has a continuous mode
	LevelBarModeContinuous LevelBarMode = 0
	// LevelBarModeDiscrete: the bar has a discrete mode
	LevelBarModeDiscrete LevelBarMode = 1
)

func marshalLevelBarMode(p uintptr) (interface{}, error) {
	return LevelBarMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// License: the type of license for an application.
//
// This enumeration can be expanded at later date.
type License int

const (
	// LicenseUnknown: no license specified
	LicenseUnknown License = 0
	// LicenseCustom: a license text is going to be specified by the developer
	LicenseCustom License = 1
	// LicenseGPL20: the GNU General Public License, version 2.0 or later
	LicenseGPL20 License = 2
	// LicenseGPL30: the GNU General Public License, version 3.0 or later
	LicenseGPL30 License = 3
	// LicenseLGPL21: the GNU Lesser General Public License, version 2.1 or
	// later
	LicenseLGPL21 License = 4
	// LicenseLGPL30: the GNU Lesser General Public License, version 3.0 or
	// later
	LicenseLGPL30 License = 5
	// LicenseBSD: the BSD standard license
	LicenseBSD License = 6
	// LicenseMITX11: the MIT/X11 standard license
	LicenseMITX11 License = 7
	// LicenseArtistic: the Artistic License, version 2.0
	LicenseArtistic License = 8
	// LicenseGPL20Only: the GNU General Public License, version 2.0 only. Since
	// 3.12.
	LicenseGPL20Only License = 9
	// LicenseGPL30Only: the GNU General Public License, version 3.0 only. Since
	// 3.12.
	LicenseGPL30Only License = 10
	// LicenseLGPL21Only: the GNU Lesser General Public License, version 2.1
	// only. Since 3.12.
	LicenseLGPL21Only License = 11
	// LicenseLGPL30Only: the GNU Lesser General Public License, version 3.0
	// only. Since 3.12.
	LicenseLGPL30Only License = 12
	// LicenseAGPL30: the GNU Affero General Public License, version 3.0 or
	// later. Since: 3.22.
	LicenseAGPL30 License = 13
	// LicenseAGPL30Only: the GNU Affero General Public License, version 3.0
	// only. Since: 3.22.27.
	LicenseAGPL30Only License = 14
	// LicenseBSD3: the 3-clause BSD licence. Since: 3.24.20.
	LicenseBSD3 License = 15
	// LicenseApache20: the Apache License, version 2.0. Since: 3.24.20.
	LicenseApache20 License = 16
	// LicenseMPL20: the Mozilla Public License, version 2.0. Since: 3.24.20.
	LicenseMPL20 License = 17
)

func marshalLicense(p uintptr) (interface{}, error) {
	return License(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MenuDirectionType: an enumeration representing directional movements within a
// menu.
type MenuDirectionType int

const (
	// MenuDirectionTypeParent: to the parent menu shell
	MenuDirectionTypeParent MenuDirectionType = 0
	// MenuDirectionTypeChild: to the submenu, if any, associated with the item
	MenuDirectionTypeChild MenuDirectionType = 1
	// MenuDirectionTypeNext: to the next menu item
	MenuDirectionTypeNext MenuDirectionType = 2
	// MenuDirectionTypePrev: to the previous menu item
	MenuDirectionTypePrev MenuDirectionType = 3
)

func marshalMenuDirectionType(p uintptr) (interface{}, error) {
	return MenuDirectionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MessageType: the type of message being displayed in the dialog.
type MessageType int

const (
	// MessageTypeInfo: informational message
	MessageTypeInfo MessageType = 0
	// MessageTypeWarning: non-fatal warning message
	MessageTypeWarning MessageType = 1
	// MessageTypeQuestion: question requiring a choice
	MessageTypeQuestion MessageType = 2
	// MessageTypeError: fatal error message
	MessageTypeError MessageType = 3
	// MessageTypeOther: none of the above
	MessageTypeOther MessageType = 4
)

func marshalMessageType(p uintptr) (interface{}, error) {
	return MessageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

type MovementStep int

const (
	// MovementStepLogicalPositions: move forward or back by graphemes
	MovementStepLogicalPositions MovementStep = 0
	// MovementStepVisualPositions: move left or right by graphemes
	MovementStepVisualPositions MovementStep = 1
	// MovementStepWords: move forward or back by words
	MovementStepWords MovementStep = 2
	// MovementStepDisplayLines: move up or down lines (wrapped lines)
	MovementStepDisplayLines MovementStep = 3
	// MovementStepDisplayLineEnds: move to either end of a line
	MovementStepDisplayLineEnds MovementStep = 4
	// MovementStepParagraphs: move up or down paragraphs (newline-ended lines)
	MovementStepParagraphs MovementStep = 5
	// MovementStepParagraphEnds: move to either end of a paragraph
	MovementStepParagraphEnds MovementStep = 6
	// MovementStepPages: move by pages
	MovementStepPages MovementStep = 7
	// MovementStepBufferEnds: move to ends of the buffer
	MovementStepBufferEnds MovementStep = 8
	// MovementStepHorizontalPages: move horizontally by pages
	MovementStepHorizontalPages MovementStep = 9
)

func marshalMovementStep(p uintptr) (interface{}, error) {
	return MovementStep(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

type NotebookTab int

const (
	NotebookTabFirst NotebookTab = 0
	NotebookTabLast  NotebookTab = 1
)

func marshalNotebookTab(p uintptr) (interface{}, error) {
	return NotebookTab(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// NumberUpLayout: used to determine the layout of pages on a sheet when
// printing multiple pages per sheet.
type NumberUpLayout int

const (
	// NumberUpLayoutLrtb: ! (layout-lrtb.png)
	NumberUpLayoutLrtb NumberUpLayout = 0
	// NumberUpLayoutLrbt: ! (layout-lrbt.png)
	NumberUpLayoutLrbt NumberUpLayout = 1
	// NumberUpLayoutRltb: ! (layout-rltb.png)
	NumberUpLayoutRltb NumberUpLayout = 2
	// NumberUpLayoutRlbt: ! (layout-rlbt.png)
	NumberUpLayoutRlbt NumberUpLayout = 3
	// NumberUpLayoutTblr: ! (layout-tblr.png)
	NumberUpLayoutTblr NumberUpLayout = 4
	// NumberUpLayoutTbrl: ! (layout-tbrl.png)
	NumberUpLayoutTbrl NumberUpLayout = 5
	// NumberUpLayoutBtlr: ! (layout-btlr.png)
	NumberUpLayoutBtlr NumberUpLayout = 6
	// NumberUpLayoutBtrl: ! (layout-btrl.png)
	NumberUpLayoutBtrl NumberUpLayout = 7
)

func marshalNumberUpLayout(p uintptr) (interface{}, error) {
	return NumberUpLayout(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Orientation represents the orientation of widgets and other objects which can
// be switched between horizontal and vertical orientation on the fly, like
// Toolbar or GesturePan.
type Orientation int

const (
	// OrientationHorizontal: the element is in horizontal orientation.
	OrientationHorizontal Orientation = 0
	// OrientationVertical: the element is in vertical orientation.
	OrientationVertical Orientation = 1
)

func marshalOrientation(p uintptr) (interface{}, error) {
	return Orientation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PackDirection determines how widgets should be packed inside menubars and
// menuitems contained in menubars.
type PackDirection int

const (
	// PackDirectionLTR widgets are packed left-to-right
	PackDirectionLTR PackDirection = 0
	// PackDirectionRTL widgets are packed right-to-left
	PackDirectionRTL PackDirection = 1
	// PackDirectionTtb widgets are packed top-to-bottom
	PackDirectionTtb PackDirection = 2
	// PackDirectionBtt widgets are packed bottom-to-top
	PackDirectionBtt PackDirection = 3
)

func marshalPackDirection(p uintptr) (interface{}, error) {
	return PackDirection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PackType represents the packing location Box children. (See: VBox, HBox, and
// ButtonBox).
type PackType int

const (
	// PackTypeStart: the child is packed into the start of the box
	PackTypeStart PackType = 0
	// PackTypeEnd: the child is packed into the end of the box
	PackTypeEnd PackType = 1
)

func marshalPackType(p uintptr) (interface{}, error) {
	return PackType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PadActionType: the type of a pad action.
type PadActionType int

const (
	// PadActionTypeButton: action is triggered by a pad button
	PadActionTypeButton PadActionType = 0
	// PadActionTypeRing: action is triggered by a pad ring
	PadActionTypeRing PadActionType = 1
	// PadActionTypeStrip: action is triggered by a pad strip
	PadActionTypeStrip PadActionType = 2
)

func marshalPadActionType(p uintptr) (interface{}, error) {
	return PadActionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PageOrientation: see also gtk_print_settings_set_orientation().
type PageOrientation int

const (
	// PageOrientationPortrait: portrait mode.
	PageOrientationPortrait PageOrientation = 0
	// PageOrientationLandscape: landscape mode.
	PageOrientationLandscape PageOrientation = 1
	// PageOrientationReversePortrait: reverse portrait mode.
	PageOrientationReversePortrait PageOrientation = 2
	// PageOrientationReverseLandscape: reverse landscape mode.
	PageOrientationReverseLandscape PageOrientation = 3
)

func marshalPageOrientation(p uintptr) (interface{}, error) {
	return PageOrientation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PageSet: see also gtk_print_job_set_page_set().
type PageSet int

const (
	// PageSetAll: all pages.
	PageSetAll PageSet = 0
	// PageSetEven: even pages.
	PageSetEven PageSet = 1
	// PageSetOdd: odd pages.
	PageSetOdd PageSet = 2
)

func marshalPageSet(p uintptr) (interface{}, error) {
	return PageSet(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PanDirection describes the panning direction of a GesturePan
type PanDirection int

const (
	// PanDirectionLeft: panned towards the left
	PanDirectionLeft PanDirection = 0
	// PanDirectionRight: panned towards the right
	PanDirectionRight PanDirection = 1
	// PanDirectionUp: panned upwards
	PanDirectionUp PanDirection = 2
	// PanDirectionDown: panned downwards
	PanDirectionDown PanDirection = 3
)

func marshalPanDirection(p uintptr) (interface{}, error) {
	return PanDirection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PathPriorityType priorities for path lookups. See also
// gtk_binding_set_add_path().
type PathPriorityType int

const (
	// PathPriorityTypeLowest: deprecated
	PathPriorityTypeLowest PathPriorityType = 0
	// PathPriorityTypeGTK: deprecated
	PathPriorityTypeGTK PathPriorityType = 4
	// PathPriorityTypeApplication: deprecated
	PathPriorityTypeApplication PathPriorityType = 8
	// PathPriorityTypeTheme: deprecated
	PathPriorityTypeTheme PathPriorityType = 10
	// PathPriorityTypeRC: deprecated
	PathPriorityTypeRC PathPriorityType = 12
	// PathPriorityTypeHighest: deprecated
	PathPriorityTypeHighest PathPriorityType = 15
)

func marshalPathPriorityType(p uintptr) (interface{}, error) {
	return PathPriorityType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PathType: widget path types. See also gtk_binding_set_add_path().
type PathType int

const (
	// PathTypeWidget: deprecated
	PathTypeWidget PathType = 0
	// PathTypeWidgetClass: deprecated
	PathTypeWidgetClass PathType = 1
	// PathTypeClass: deprecated
	PathTypeClass PathType = 2
)

func marshalPathType(p uintptr) (interface{}, error) {
	return PathType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PolicyType determines how the size should be computed to achieve the one of
// the visibility mode for the scrollbars.
type PolicyType int

const (
	// PolicyTypeAlways: the scrollbar is always visible. The view size is
	// independent of the content.
	PolicyTypeAlways PolicyType = 0
	// PolicyTypeAutomatic: the scrollbar will appear and disappear as
	// necessary. For example, when all of a TreeView can not be seen.
	PolicyTypeAutomatic PolicyType = 1
	// PolicyTypeNever: the scrollbar should never appear. In this mode the
	// content determines the size.
	PolicyTypeNever PolicyType = 2
	// PolicyTypeExternal: don't show a scrollbar, but don't force the size to
	// follow the content. This can be used e.g. to make multiple scrolled
	// windows share a scrollbar. Since: 3.16
	PolicyTypeExternal PolicyType = 3
)

func marshalPolicyType(p uintptr) (interface{}, error) {
	return PolicyType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PopoverConstraint describes constraints to positioning of popovers. More
// values may be added to this enumeration in the future.
type PopoverConstraint int

const (
	// PopoverConstraintNone: don't constrain the popover position beyond what
	// is imposed by the implementation
	PopoverConstraintNone PopoverConstraint = 0
	// PopoverConstraintWindow: constrain the popover to the boundaries of the
	// window that it is attached to
	PopoverConstraintWindow PopoverConstraint = 1
)

func marshalPopoverConstraint(p uintptr) (interface{}, error) {
	return PopoverConstraint(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PositionType describes which edge of a widget a certain feature is positioned
// at, e.g. the tabs of a Notebook, the handle of a HandleBox or the label of a
// Scale.
type PositionType int

const (
	// PositionTypeLeft: the feature is at the left edge.
	PositionTypeLeft PositionType = 0
	// PositionTypeRight: the feature is at the right edge.
	PositionTypeRight PositionType = 1
	// PositionTypeTop: the feature is at the top edge.
	PositionTypeTop PositionType = 2
	// PositionTypeBottom: the feature is at the bottom edge.
	PositionTypeBottom PositionType = 3
)

func marshalPositionType(p uintptr) (interface{}, error) {
	return PositionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintDuplex: see also gtk_print_settings_set_duplex().
type PrintDuplex int

const (
	// PrintDuplexSimplex: no duplex.
	PrintDuplexSimplex PrintDuplex = 0
	// PrintDuplexHorizontal: horizontal duplex.
	PrintDuplexHorizontal PrintDuplex = 1
	// PrintDuplexVertical: vertical duplex.
	PrintDuplexVertical PrintDuplex = 2
)

func marshalPrintDuplex(p uintptr) (interface{}, error) {
	return PrintDuplex(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintError: error codes that identify various errors that can occur while
// using the GTK+ printing support.
type PrintError int

const (
	// PrintErrorGeneral: an unspecified error occurred.
	PrintErrorGeneral PrintError = 0
	// PrintErrorInternalError: an internal error occurred.
	PrintErrorInternalError PrintError = 1
	// PrintErrorNOMEM: a memory allocation failed.
	PrintErrorNOMEM PrintError = 2
	// PrintErrorInvalidFile: an error occurred while loading a page setup or
	// paper size from a key file.
	PrintErrorInvalidFile PrintError = 3
)

func marshalPrintError(p uintptr) (interface{}, error) {
	return PrintError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintOperationAction: the @action parameter to gtk_print_operation_run()
// determines what action the print operation should perform.
type PrintOperationAction int

const (
	// PrintOperationActionPrintDialog: show the print dialog.
	PrintOperationActionPrintDialog PrintOperationAction = 0
	// PrintOperationActionPrint: start to print without showing the print
	// dialog, based on the current print settings.
	PrintOperationActionPrint PrintOperationAction = 1
	// PrintOperationActionPreview: show the print preview.
	PrintOperationActionPreview PrintOperationAction = 2
	// PrintOperationActionExport: export to a file. This requires the
	// export-filename property to be set.
	PrintOperationActionExport PrintOperationAction = 3
)

func marshalPrintOperationAction(p uintptr) (interface{}, error) {
	return PrintOperationAction(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintOperationResult: a value of this type is returned by
// gtk_print_operation_run().
type PrintOperationResult int

const (
	// PrintOperationResultError: an error has occurred.
	PrintOperationResultError PrintOperationResult = 0
	// PrintOperationResultApply: the print settings should be stored.
	PrintOperationResultApply PrintOperationResult = 1
	// PrintOperationResultCancel: the print operation has been canceled, the
	// print settings should not be stored.
	PrintOperationResultCancel PrintOperationResult = 2
	// PrintOperationResultInProgress: the print operation is not complete yet.
	// This value will only be returned when running asynchronously.
	PrintOperationResultInProgress PrintOperationResult = 3
)

func marshalPrintOperationResult(p uintptr) (interface{}, error) {
	return PrintOperationResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintPages: see also gtk_print_job_set_pages()
type PrintPages int

const (
	// PrintPagesAll: all pages.
	PrintPagesAll PrintPages = 0
	// PrintPagesCurrent: current page.
	PrintPagesCurrent PrintPages = 1
	// PrintPagesRanges: range of pages.
	PrintPagesRanges PrintPages = 2
	// PrintPagesSelection: selected pages.
	PrintPagesSelection PrintPages = 3
)

func marshalPrintPages(p uintptr) (interface{}, error) {
	return PrintPages(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintQuality: see also gtk_print_settings_set_quality().
type PrintQuality int

const (
	// PrintQualityLow: low quality.
	PrintQualityLow PrintQuality = 0
	// PrintQualityNormal: normal quality.
	PrintQualityNormal PrintQuality = 1
	// PrintQualityHigh: high quality.
	PrintQualityHigh PrintQuality = 2
	// PrintQualityDraft: draft quality.
	PrintQualityDraft PrintQuality = 3
)

func marshalPrintQuality(p uintptr) (interface{}, error) {
	return PrintQuality(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintStatus: the status gives a rough indication of the completion of a
// running print operation.
type PrintStatus int

const (
	// PrintStatusInitial: the printing has not started yet; this status is set
	// initially, and while the print dialog is shown.
	PrintStatusInitial PrintStatus = 0
	// PrintStatusPreparing: this status is set while the begin-print signal is
	// emitted and during pagination.
	PrintStatusPreparing PrintStatus = 1
	// PrintStatusGeneratingData: this status is set while the pages are being
	// rendered.
	PrintStatusGeneratingData PrintStatus = 2
	// PrintStatusSendingData: the print job is being sent off to the printer.
	PrintStatusSendingData PrintStatus = 3
	// PrintStatusPending: the print job has been sent to the printer, but is
	// not printed for some reason, e.g. the printer may be stopped.
	PrintStatusPending PrintStatus = 4
	// PrintStatusPendingIssue: some problem has occurred during printing, e.g.
	// a paper jam.
	PrintStatusPendingIssue PrintStatus = 5
	// PrintStatusPrinting: the printer is processing the print job.
	PrintStatusPrinting PrintStatus = 6
	// PrintStatusFinished: the printing has been completed successfully.
	PrintStatusFinished PrintStatus = 7
	// PrintStatusFinishedAborted: the printing has been aborted.
	PrintStatusFinishedAborted PrintStatus = 8
)

func marshalPrintStatus(p uintptr) (interface{}, error) {
	return PrintStatus(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PropagationPhase describes the stage at which events are fed into a
// EventController.
type PropagationPhase int

const (
	// PropagationPhaseNone events are not delivered automatically. Those can be
	// manually fed through gtk_event_controller_handle_event(). This should
	// only be used when full control about when, or whether the controller
	// handles the event is needed.
	PropagationPhaseNone PropagationPhase = 0
	// PropagationPhaseCapture events are delivered in the capture phase. The
	// capture phase happens before the bubble phase, runs from the toplevel
	// down to the event widget. This option should only be used on containers
	// that might possibly handle events before their children do.
	PropagationPhaseCapture PropagationPhase = 1
	// PropagationPhaseBubble events are delivered in the bubble phase. The
	// bubble phase happens after the capture phase, and before the default
	// handlers are run. This phase runs from the event widget, up to the
	// toplevel.
	PropagationPhaseBubble PropagationPhase = 2
	// PropagationPhaseTarget events are delivered in the default widget event
	// handlers, note that widget implementations must chain up on button,
	// motion, touch and grab broken handlers for controllers in this phase to
	// be run.
	PropagationPhaseTarget PropagationPhase = 3
)

func marshalPropagationPhase(p uintptr) (interface{}, error) {
	return PropagationPhase(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RCTokenType: the RcTokenType enumeration represents the tokens in the RC
// file. It is exposed so that theme engines can reuse these tokens when parsing
// the theme-engine specific portions of a RC file.
type RCTokenType int

const (
	// RCTokenTypeInvalid: deprecated
	RCTokenTypeInvalid RCTokenType = 270
	// RCTokenTypeInclude: deprecated
	RCTokenTypeInclude RCTokenType = 271
	// RCTokenTypeNormal: deprecated
	RCTokenTypeNormal RCTokenType = 272
	// RCTokenTypeActive: deprecated
	RCTokenTypeActive RCTokenType = 273
	// RCTokenTypePrelight: deprecated
	RCTokenTypePrelight RCTokenType = 274
	// RCTokenTypeSelected: deprecated
	RCTokenTypeSelected RCTokenType = 275
	// RCTokenTypeInsensitive: deprecated
	RCTokenTypeInsensitive RCTokenType = 276
	// RCTokenTypeFg: deprecated
	RCTokenTypeFg RCTokenType = 277
	// RCTokenTypeBg: deprecated
	RCTokenTypeBg RCTokenType = 278
	// RCTokenTypeText: deprecated
	RCTokenTypeText RCTokenType = 279
	// RCTokenTypeBase: deprecated
	RCTokenTypeBase RCTokenType = 280
	// RCTokenTypeXthickness: deprecated
	RCTokenTypeXthickness RCTokenType = 281
	// RCTokenTypeYthickness: deprecated
	RCTokenTypeYthickness RCTokenType = 282
	// RCTokenTypeFont: deprecated
	RCTokenTypeFont RCTokenType = 283
	// RCTokenTypeFontset: deprecated
	RCTokenTypeFontset RCTokenType = 284
	// RCTokenTypeFontName: deprecated
	RCTokenTypeFontName RCTokenType = 285
	// RCTokenTypeBgPixmap: deprecated
	RCTokenTypeBgPixmap RCTokenType = 286
	// RCTokenTypePixmapPath: deprecated
	RCTokenTypePixmapPath RCTokenType = 287
	// RCTokenTypeStyle: deprecated
	RCTokenTypeStyle RCTokenType = 288
	// RCTokenTypeBinding: deprecated
	RCTokenTypeBinding RCTokenType = 289
	// RCTokenTypeBind: deprecated
	RCTokenTypeBind RCTokenType = 290
	// RCTokenTypeWidget: deprecated
	RCTokenTypeWidget RCTokenType = 291
	// RCTokenTypeWidgetClass: deprecated
	RCTokenTypeWidgetClass RCTokenType = 292
	// RCTokenTypeClass: deprecated
	RCTokenTypeClass RCTokenType = 293
	// RCTokenTypeLowest: deprecated
	RCTokenTypeLowest RCTokenType = 294
	// RCTokenTypeGTK: deprecated
	RCTokenTypeGTK RCTokenType = 295
	// RCTokenTypeApplication: deprecated
	RCTokenTypeApplication RCTokenType = 296
	// RCTokenTypeTheme: deprecated
	RCTokenTypeTheme RCTokenType = 297
	// RCTokenTypeRC: deprecated
	RCTokenTypeRC RCTokenType = 298
	// RCTokenTypeHighest: deprecated
	RCTokenTypeHighest RCTokenType = 299
	// RCTokenTypeEngine: deprecated
	RCTokenTypeEngine RCTokenType = 300
	// RCTokenTypeModulePath: deprecated
	RCTokenTypeModulePath RCTokenType = 301
	// RCTokenTypeImModulePath: deprecated
	RCTokenTypeImModulePath RCTokenType = 302
	// RCTokenTypeImModuleFile: deprecated
	RCTokenTypeImModuleFile RCTokenType = 303
	// RCTokenTypeStock: deprecated
	RCTokenTypeStock RCTokenType = 304
	// RCTokenTypeLTR: deprecated
	RCTokenTypeLTR RCTokenType = 305
	// RCTokenTypeRTL: deprecated
	RCTokenTypeRTL RCTokenType = 306
	// RCTokenTypeColor: deprecated
	RCTokenTypeColor RCTokenType = 307
	// RCTokenTypeUnbind: deprecated
	RCTokenTypeUnbind RCTokenType = 308
	// RCTokenTypeLast: deprecated
	RCTokenTypeLast RCTokenType = 309
)

func marshalRCTokenType(p uintptr) (interface{}, error) {
	return RCTokenType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RecentChooserError: these identify the various errors that can occur while
// calling RecentChooser functions.
type RecentChooserError int

const (
	// RecentChooserErrorNotFound indicates that a file does not exist
	RecentChooserErrorNotFound RecentChooserError = 0
	// RecentChooserErrorInvalidURI indicates a malformed URI
	RecentChooserErrorInvalidURI RecentChooserError = 1
)

func marshalRecentChooserError(p uintptr) (interface{}, error) {
	return RecentChooserError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RecentManagerError: error codes for RecentManager operations
type RecentManagerError int

const (
	// RecentManagerErrorNotFound: the URI specified does not exists in the
	// recently used resources list.
	RecentManagerErrorNotFound RecentManagerError = 0
	// RecentManagerErrorInvalidURI: the URI specified is not valid.
	RecentManagerErrorInvalidURI RecentManagerError = 1
	// RecentManagerErrorInvalidEncoding: the supplied string is not UTF-8
	// encoded.
	RecentManagerErrorInvalidEncoding RecentManagerError = 2
	// RecentManagerErrorNotRegistered: no application has registered the
	// specified item.
	RecentManagerErrorNotRegistered RecentManagerError = 3
	// RecentManagerErrorRead: failure while reading the recently used resources
	// file.
	RecentManagerErrorRead RecentManagerError = 4
	// RecentManagerErrorWrite: failure while writing the recently used
	// resources file.
	RecentManagerErrorWrite RecentManagerError = 5
	// RecentManagerErrorUnknown: unspecified error.
	RecentManagerErrorUnknown RecentManagerError = 6
)

func marshalRecentManagerError(p uintptr) (interface{}, error) {
	return RecentManagerError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RecentSortType: used to specify the sorting method to be applyed to the
// recently used resource list.
type RecentSortType int

const (
	// RecentSortTypeNone: do not sort the returned list of recently used
	// resources.
	RecentSortTypeNone RecentSortType = 0
	// RecentSortTypeMru: sort the returned list with the most recently used
	// items first.
	RecentSortTypeMru RecentSortType = 1
	// RecentSortTypeLru: sort the returned list with the least recently used
	// items first.
	RecentSortTypeLru RecentSortType = 2
	// RecentSortTypeCustom: sort the returned list using a custom sorting
	// function passed using gtk_recent_chooser_set_sort_func().
	RecentSortTypeCustom RecentSortType = 3
)

func marshalRecentSortType(p uintptr) (interface{}, error) {
	return RecentSortType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ReliefStyle: indicated the relief to be drawn around a Button.
type ReliefStyle int

const (
	// ReliefStyleNormal: draw a normal relief.
	ReliefStyleNormal ReliefStyle = 0
	// ReliefStyleHalf: a half relief. Deprecated in 3.14, does the same as
	// @GTK_RELIEF_NORMAL
	ReliefStyleHalf ReliefStyle = 1
	// ReliefStyleNone: no relief.
	ReliefStyleNone ReliefStyle = 2
)

func marshalReliefStyle(p uintptr) (interface{}, error) {
	return ReliefStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

type ResizeMode int

const (
	// ResizeModeParent pass resize request to the parent
	ResizeModeParent ResizeMode = 0
	// ResizeModeQueue: queue resizes on this widget
	ResizeModeQueue ResizeMode = 1
	// ResizeModeImmediate: resize immediately. Deprecated.
	ResizeModeImmediate ResizeMode = 2
)

func marshalResizeMode(p uintptr) (interface{}, error) {
	return ResizeMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResponseType: predefined values for use as response ids in
// gtk_dialog_add_button(). All predefined values are negative; GTK+ leaves
// values of 0 or greater for application-defined response ids.
type ResponseType int

const (
	// ResponseTypeNone: returned if an action widget has no response id, or if
	// the dialog gets programmatically hidden or destroyed
	ResponseTypeNone ResponseType = -1
	// ResponseTypeReject: generic response id, not used by GTK+ dialogs
	ResponseTypeReject ResponseType = -2
	// ResponseTypeAccept: generic response id, not used by GTK+ dialogs
	ResponseTypeAccept ResponseType = -3
	// ResponseTypeDeleteEvent: returned if the dialog is deleted
	ResponseTypeDeleteEvent ResponseType = -4
	// ResponseTypeOk: returned by OK buttons in GTK+ dialogs
	ResponseTypeOk ResponseType = -5
	// ResponseTypeCancel: returned by Cancel buttons in GTK+ dialogs
	ResponseTypeCancel ResponseType = -6
	// ResponseTypeClose: returned by Close buttons in GTK+ dialogs
	ResponseTypeClose ResponseType = -7
	// ResponseTypeYes: returned by Yes buttons in GTK+ dialogs
	ResponseTypeYes ResponseType = -8
	// ResponseTypeNo: returned by No buttons in GTK+ dialogs
	ResponseTypeNo ResponseType = -9
	// ResponseTypeApply: returned by Apply buttons in GTK+ dialogs
	ResponseTypeApply ResponseType = -10
	// ResponseTypeHelp: returned by Help buttons in GTK+ dialogs
	ResponseTypeHelp ResponseType = -11
)

func marshalResponseType(p uintptr) (interface{}, error) {
	return ResponseType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RevealerTransitionType: these enumeration values describe the possible
// transitions when the child of a Revealer widget is shown or hidden.
type RevealerTransitionType int

const (
	// RevealerTransitionTypeNone: no transition
	RevealerTransitionTypeNone RevealerTransitionType = 0
	// RevealerTransitionTypeCrossfade: fade in
	RevealerTransitionTypeCrossfade RevealerTransitionType = 1
	// RevealerTransitionTypeSlideRight: slide in from the left
	RevealerTransitionTypeSlideRight RevealerTransitionType = 2
	// RevealerTransitionTypeSlideLeft: slide in from the right
	RevealerTransitionTypeSlideLeft RevealerTransitionType = 3
	// RevealerTransitionTypeSlideUp: slide in from the bottom
	RevealerTransitionTypeSlideUp RevealerTransitionType = 4
	// RevealerTransitionTypeSlideDown: slide in from the top
	RevealerTransitionTypeSlideDown RevealerTransitionType = 5
)

func marshalRevealerTransitionType(p uintptr) (interface{}, error) {
	return RevealerTransitionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

type ScrollStep int

const (
	// ScrollStepSteps: scroll in steps.
	ScrollStepSteps ScrollStep = 0
	// ScrollStepPages: scroll by pages.
	ScrollStepPages ScrollStep = 1
	// ScrollStepEnds: scroll to ends.
	ScrollStepEnds ScrollStep = 2
	// ScrollStepHorizontalSteps: scroll in horizontal steps.
	ScrollStepHorizontalSteps ScrollStep = 3
	// ScrollStepHorizontalPages: scroll by horizontal pages.
	ScrollStepHorizontalPages ScrollStep = 4
	// ScrollStepHorizontalEnds: scroll to the horizontal ends.
	ScrollStepHorizontalEnds ScrollStep = 5
)

func marshalScrollStep(p uintptr) (interface{}, error) {
	return ScrollStep(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ScrollType: scrolling types.
type ScrollType int

const (
	// ScrollTypeNone: no scrolling.
	ScrollTypeNone ScrollType = 0
	// ScrollTypeJump: jump to new location.
	ScrollTypeJump ScrollType = 1
	// ScrollTypeStepBackward: step backward.
	ScrollTypeStepBackward ScrollType = 2
	// ScrollTypeStepForward: step forward.
	ScrollTypeStepForward ScrollType = 3
	// ScrollTypePageBackward: page backward.
	ScrollTypePageBackward ScrollType = 4
	// ScrollTypePageForward: page forward.
	ScrollTypePageForward ScrollType = 5
	// ScrollTypeStepUp: step up.
	ScrollTypeStepUp ScrollType = 6
	// ScrollTypeStepDown: step down.
	ScrollTypeStepDown ScrollType = 7
	// ScrollTypePageUp: page up.
	ScrollTypePageUp ScrollType = 8
	// ScrollTypePageDown: page down.
	ScrollTypePageDown ScrollType = 9
	// ScrollTypeStepLeft: step to the left.
	ScrollTypeStepLeft ScrollType = 10
	// ScrollTypeStepRight: step to the right.
	ScrollTypeStepRight ScrollType = 11
	// ScrollTypePageLeft: page to the left.
	ScrollTypePageLeft ScrollType = 12
	// ScrollTypePageRight: page to the right.
	ScrollTypePageRight ScrollType = 13
	// ScrollTypeStart: scroll to start.
	ScrollTypeStart ScrollType = 14
	// ScrollTypeEnd: scroll to end.
	ScrollTypeEnd ScrollType = 15
)

func marshalScrollType(p uintptr) (interface{}, error) {
	return ScrollType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ScrollablePolicy defines the policy to be used in a scrollable widget when
// updating the scrolled window adjustments in a given orientation.
type ScrollablePolicy int

const (
	// ScrollablePolicyMinimum: scrollable adjustments are based on the minimum
	// size
	ScrollablePolicyMinimum ScrollablePolicy = 0
	// ScrollablePolicyNatural: scrollable adjustments are based on the natural
	// size
	ScrollablePolicyNatural ScrollablePolicy = 1
)

func marshalScrollablePolicy(p uintptr) (interface{}, error) {
	return ScrollablePolicy(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SelectionMode: used to control what selections users are allowed to make.
type SelectionMode int

const (
	// SelectionModeNone: no selection is possible.
	SelectionModeNone SelectionMode = 0
	// SelectionModeSingle: zero or one element may be selected.
	SelectionModeSingle SelectionMode = 1
	// SelectionModeBrowse: exactly one element is selected. In some
	// circumstances, such as initially or during a search operation, it’s
	// possible for no element to be selected with GTK_SELECTION_BROWSE. What is
	// really enforced is that the user can’t deselect a currently selected
	// element except by selecting another element.
	SelectionModeBrowse SelectionMode = 2
	// SelectionModeMultiple: any number of elements may be selected. The Ctrl
	// key may be used to enlarge the selection, and Shift key to select between
	// the focus and the child pointed to. Some widgets may also allow
	// Click-drag to select a range of elements.
	SelectionModeMultiple SelectionMode = 3
)

func marshalSelectionMode(p uintptr) (interface{}, error) {
	return SelectionMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SensitivityType determines how GTK+ handles the sensitivity of stepper arrows
// at the end of range widgets.
type SensitivityType int

const (
	// SensitivityTypeAuto: the arrow is made insensitive if the thumb is at the
	// end
	SensitivityTypeAuto SensitivityType = 0
	// SensitivityTypeOn: the arrow is always sensitive
	SensitivityTypeOn SensitivityType = 1
	// SensitivityTypeOff: the arrow is always insensitive
	SensitivityTypeOff SensitivityType = 2
)

func marshalSensitivityType(p uintptr) (interface{}, error) {
	return SensitivityType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ShadowType: used to change the appearance of an outline typically provided by
// a Frame.
//
// Note that many themes do not differentiate the appearance of the various
// shadow types: Either their is no visible shadow (@GTK_SHADOW_NONE), or there
// is (any other value).
type ShadowType int

const (
	// ShadowTypeNone: no outline.
	ShadowTypeNone ShadowType = 0
	// ShadowTypeIn: the outline is bevelled inwards.
	ShadowTypeIn ShadowType = 1
	// ShadowTypeOut: the outline is bevelled outwards like a button.
	ShadowTypeOut ShadowType = 2
	// ShadowTypeEtchedIn: the outline has a sunken 3d appearance.
	ShadowTypeEtchedIn ShadowType = 3
	// ShadowTypeEtchedOut: the outline has a raised 3d appearance.
	ShadowTypeEtchedOut ShadowType = 4
)

func marshalShadowType(p uintptr) (interface{}, error) {
	return ShadowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ShortcutType: gtkShortcutType specifies the kind of shortcut that is being
// described. More values may be added to this enumeration over time.
type ShortcutType int

const (
	// ShortcutTypeAccelerator: the shortcut is a keyboard accelerator. The
	// ShortcutsShortcut:accelerator property will be used.
	ShortcutTypeAccelerator ShortcutType = 0
	// ShortcutTypeGesturePinch: the shortcut is a pinch gesture. GTK+ provides
	// an icon and subtitle.
	ShortcutTypeGesturePinch ShortcutType = 1
	// ShortcutTypeGestureStretch: the shortcut is a stretch gesture. GTK+
	// provides an icon and subtitle.
	ShortcutTypeGestureStretch ShortcutType = 2
	// ShortcutTypeGestureRotateClockwise: the shortcut is a clockwise rotation
	// gesture. GTK+ provides an icon and subtitle.
	ShortcutTypeGestureRotateClockwise ShortcutType = 3
	// ShortcutTypeGestureRotateCounterclockwise: the shortcut is a
	// counterclockwise rotation gesture. GTK+ provides an icon and subtitle.
	ShortcutTypeGestureRotateCounterclockwise ShortcutType = 4
	// ShortcutTypeGestureTwoFingerSwipeLeft: the shortcut is a two-finger swipe
	// gesture. GTK+ provides an icon and subtitle.
	ShortcutTypeGestureTwoFingerSwipeLeft ShortcutType = 5
	// ShortcutTypeGestureTwoFingerSwipeRight: the shortcut is a two-finger
	// swipe gesture. GTK+ provides an icon and subtitle.
	ShortcutTypeGestureTwoFingerSwipeRight ShortcutType = 6
	// ShortcutTypeGesture: the shortcut is a gesture. The
	// ShortcutsShortcut:icon property will be used.
	ShortcutTypeGesture ShortcutType = 7
)

func marshalShortcutType(p uintptr) (interface{}, error) {
	return ShortcutType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SizeGroupMode: the mode of the size group determines the directions in which
// the size group affects the requested sizes of its component widgets.
type SizeGroupMode int

const (
	// SizeGroupModeNone: group has no effect
	SizeGroupModeNone SizeGroupMode = 0
	// SizeGroupModeHorizontal: group affects horizontal requisition
	SizeGroupModeHorizontal SizeGroupMode = 1
	// SizeGroupModeVertical: group affects vertical requisition
	SizeGroupModeVertical SizeGroupMode = 2
	// SizeGroupModeBoth: group affects both horizontal and vertical requisition
	SizeGroupModeBoth SizeGroupMode = 3
)

func marshalSizeGroupMode(p uintptr) (interface{}, error) {
	return SizeGroupMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SizeRequestMode specifies a preference for height-for-width or
// width-for-height geometry management.
type SizeRequestMode int

const (
	// SizeRequestModeHeightForWidth: prefer height-for-width geometry
	// management
	SizeRequestModeHeightForWidth SizeRequestMode = 0
	// SizeRequestModeWidthForHeight: prefer width-for-height geometry
	// management
	SizeRequestModeWidthForHeight SizeRequestMode = 1
	// SizeRequestModeConstantSize: don’t trade height-for-width or
	// width-for-height
	SizeRequestModeConstantSize SizeRequestMode = 2
)

func marshalSizeRequestMode(p uintptr) (interface{}, error) {
	return SizeRequestMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SortType determines the direction of a sort.
type SortType int

const (
	// SortTypeAscending: sorting is in ascending order.
	SortTypeAscending SortType = 0
	// SortTypeDescending: sorting is in descending order.
	SortTypeDescending SortType = 1
)

func marshalSortType(p uintptr) (interface{}, error) {
	return SortType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SpinButtonUpdatePolicy: the spin button update policy determines whether the
// spin button displays values even if they are outside the bounds of its
// adjustment. See gtk_spin_button_set_update_policy().
type SpinButtonUpdatePolicy int

const (
	// SpinButtonUpdatePolicyAlways: when refreshing your SpinButton, the value
	// is always displayed
	SpinButtonUpdatePolicyAlways SpinButtonUpdatePolicy = 0
	// SpinButtonUpdatePolicyIfValid: when refreshing your SpinButton, the value
	// is only displayed if it is valid within the bounds of the spin button's
	// adjustment
	SpinButtonUpdatePolicyIfValid SpinButtonUpdatePolicy = 1
)

func marshalSpinButtonUpdatePolicy(p uintptr) (interface{}, error) {
	return SpinButtonUpdatePolicy(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SpinType: the values of the GtkSpinType enumeration are used to specify the
// change to make in gtk_spin_button_spin().
type SpinType int

const (
	// SpinTypeStepForward: increment by the adjustments step increment.
	SpinTypeStepForward SpinType = 0
	// SpinTypeStepBackward: decrement by the adjustments step increment.
	SpinTypeStepBackward SpinType = 1
	// SpinTypePageForward: increment by the adjustments page increment.
	SpinTypePageForward SpinType = 2
	// SpinTypePageBackward: decrement by the adjustments page increment.
	SpinTypePageBackward SpinType = 3
	// SpinTypeHome: go to the adjustments lower bound.
	SpinTypeHome SpinType = 4
	// SpinTypeEnd: go to the adjustments upper bound.
	SpinTypeEnd SpinType = 5
	// SpinTypeUserDefined: change by a specified amount.
	SpinTypeUserDefined SpinType = 6
)

func marshalSpinType(p uintptr) (interface{}, error) {
	return SpinType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// StackTransitionType: these enumeration values describe the possible
// transitions between pages in a Stack widget.
//
// New values may be added to this enumeration over time.
type StackTransitionType int

const (
	// StackTransitionTypeNone: no transition
	StackTransitionTypeNone StackTransitionType = 0
	// StackTransitionTypeCrossfade: a cross-fade
	StackTransitionTypeCrossfade StackTransitionType = 1
	// StackTransitionTypeSlideRight: slide from left to right
	StackTransitionTypeSlideRight StackTransitionType = 2
	// StackTransitionTypeSlideLeft: slide from right to left
	StackTransitionTypeSlideLeft StackTransitionType = 3
	// StackTransitionTypeSlideUp: slide from bottom up
	StackTransitionTypeSlideUp StackTransitionType = 4
	// StackTransitionTypeSlideDown: slide from top down
	StackTransitionTypeSlideDown StackTransitionType = 5
	// StackTransitionTypeSlideLeftRight: slide from left or right according to
	// the children order
	StackTransitionTypeSlideLeftRight StackTransitionType = 6
	// StackTransitionTypeSlideUpDown: slide from top down or bottom up
	// according to the order
	StackTransitionTypeSlideUpDown StackTransitionType = 7
	// StackTransitionTypeOverUp: cover the old page by sliding up. Since 3.12
	StackTransitionTypeOverUp StackTransitionType = 8
	// StackTransitionTypeOverDown: cover the old page by sliding down. Since:
	// 3.12
	StackTransitionTypeOverDown StackTransitionType = 9
	// StackTransitionTypeOverLeft: cover the old page by sliding to the left.
	// Since: 3.12
	StackTransitionTypeOverLeft StackTransitionType = 10
	// StackTransitionTypeOverRight: cover the old page by sliding to the right.
	// Since: 3.12
	StackTransitionTypeOverRight StackTransitionType = 11
	// StackTransitionTypeUnderUp: uncover the new page by sliding up. Since
	// 3.12
	StackTransitionTypeUnderUp StackTransitionType = 12
	// StackTransitionTypeUnderDown: uncover the new page by sliding down.
	// Since: 3.12
	StackTransitionTypeUnderDown StackTransitionType = 13
	// StackTransitionTypeUnderLeft: uncover the new page by sliding to the
	// left. Since: 3.12
	StackTransitionTypeUnderLeft StackTransitionType = 14
	// StackTransitionTypeUnderRight: uncover the new page by sliding to the
	// right. Since: 3.12
	StackTransitionTypeUnderRight StackTransitionType = 15
	// StackTransitionTypeOverUpDown: cover the old page sliding up or uncover
	// the new page sliding down, according to order. Since: 3.12
	StackTransitionTypeOverUpDown StackTransitionType = 16
	// StackTransitionTypeOverDownUp: cover the old page sliding down or uncover
	// the new page sliding up, according to order. Since: 3.14
	StackTransitionTypeOverDownUp StackTransitionType = 17
	// StackTransitionTypeOverLeftRight: cover the old page sliding left or
	// uncover the new page sliding right, according to order. Since: 3.14
	StackTransitionTypeOverLeftRight StackTransitionType = 18
	// StackTransitionTypeOverRightLeft: cover the old page sliding right or
	// uncover the new page sliding left, according to order. Since: 3.14
	StackTransitionTypeOverRightLeft StackTransitionType = 19
)

func marshalStackTransitionType(p uintptr) (interface{}, error) {
	return StackTransitionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// StateType: this type indicates the current state of a widget; the state
// determines how the widget is drawn. The StateType enumeration is also used to
// identify different colors in a Style for drawing, so states can be used for
// subparts of a widget as well as entire widgets.
type StateType int

const (
	// StateTypeNormal: state during normal operation.
	StateTypeNormal StateType = 0
	// StateTypeActive: state of a currently active widget, such as a depressed
	// button.
	StateTypeActive StateType = 1
	// StateTypePrelight: state indicating that the mouse pointer is over the
	// widget and the widget will respond to mouse clicks.
	StateTypePrelight StateType = 2
	// StateTypeSelected: state of a selected item, such the selected row in a
	// list.
	StateTypeSelected StateType = 3
	// StateTypeInsensitive: state indicating that the widget is unresponsive to
	// user actions.
	StateTypeInsensitive StateType = 4
	// StateTypeInconsistent: the widget is inconsistent, such as checkbuttons
	// or radiobuttons that aren’t either set to true nor false, or buttons
	// requiring the user attention.
	StateTypeInconsistent StateType = 5
	// StateTypeFocused: the widget has the keyboard focus.
	StateTypeFocused StateType = 6
)

func marshalStateType(p uintptr) (interface{}, error) {
	return StateType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextBufferTargetInfo: these values are used as “info” for the targets
// contained in the lists returned by gtk_text_buffer_get_copy_target_list() and
// gtk_text_buffer_get_paste_target_list().
//
// The values counts down from `-1` to avoid clashes with application added drag
// destinations which usually start at 0.
type TextBufferTargetInfo int

const (
	// TextBufferTargetInfoBufferContents: buffer contents
	TextBufferTargetInfoBufferContents TextBufferTargetInfo = -1
	// TextBufferTargetInfoRichText: rich text
	TextBufferTargetInfoRichText TextBufferTargetInfo = -2
	// TextBufferTargetInfoText: text
	TextBufferTargetInfoText TextBufferTargetInfo = -3
)

func marshalTextBufferTargetInfo(p uintptr) (interface{}, error) {
	return TextBufferTargetInfo(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextDirection: reading directions for text.
type TextDirection int

const (
	// TextDirectionNone: no direction.
	TextDirectionNone TextDirection = 0
	// TextDirectionLTR: left to right text direction.
	TextDirectionLTR TextDirection = 1
	// TextDirectionRTL: right to left text direction.
	TextDirectionRTL TextDirection = 2
)

func marshalTextDirection(p uintptr) (interface{}, error) {
	return TextDirection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextExtendSelection: granularity types that extend the text selection. Use
// the TextView::extend-selection signal to customize the selection.
type TextExtendSelection int

const (
	// TextExtendSelectionWord selects the current word. It is triggered by a
	// double-click for example.
	TextExtendSelectionWord TextExtendSelection = 0
	// TextExtendSelectionLine selects the current line. It is triggered by a
	// triple-click for example.
	TextExtendSelectionLine TextExtendSelection = 1
)

func marshalTextExtendSelection(p uintptr) (interface{}, error) {
	return TextExtendSelection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextViewLayer: used to reference the layers of TextView for the purpose of
// customized drawing with the ::draw_layer vfunc.
type TextViewLayer int

const (
	// TextViewLayerBelow: old deprecated layer, use
	// GTK_TEXT_VIEW_LAYER_BELOW_TEXT instead
	TextViewLayerBelow TextViewLayer = 0
	// TextViewLayerAbove: old deprecated layer, use
	// GTK_TEXT_VIEW_LAYER_ABOVE_TEXT instead
	TextViewLayerAbove TextViewLayer = 1
	// TextViewLayerBelowText: the layer rendered below the text (but above the
	// background). Since: 3.20
	TextViewLayerBelowText TextViewLayer = 2
	// TextViewLayerAboveText: the layer rendered above the text. Since: 3.20
	TextViewLayerAboveText TextViewLayer = 3
)

func marshalTextViewLayer(p uintptr) (interface{}, error) {
	return TextViewLayer(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextWindowType: used to reference the parts of TextView.
type TextWindowType int

const (
	// TextWindowTypePrivate: invalid value, used as a marker
	TextWindowTypePrivate TextWindowType = 0
	// TextWindowTypeWidget: window that floats over scrolling areas.
	TextWindowTypeWidget TextWindowType = 1
	// TextWindowTypeText: scrollable text window.
	TextWindowTypeText TextWindowType = 2
	// TextWindowTypeLeft: left side border window.
	TextWindowTypeLeft TextWindowType = 3
	// TextWindowTypeRight: right side border window.
	TextWindowTypeRight TextWindowType = 4
	// TextWindowTypeTop: top border window.
	TextWindowTypeTop TextWindowType = 5
	// TextWindowTypeBottom: bottom border window.
	TextWindowTypeBottom TextWindowType = 6
)

func marshalTextWindowType(p uintptr) (interface{}, error) {
	return TextWindowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ToolbarSpaceStyle: whether spacers are vertical lines or just blank.
type ToolbarSpaceStyle int

const (
	// ToolbarSpaceStyleEmpty: use blank spacers.
	ToolbarSpaceStyleEmpty ToolbarSpaceStyle = 0
	// ToolbarSpaceStyleLine: use vertical lines for spacers.
	ToolbarSpaceStyleLine ToolbarSpaceStyle = 1
)

func marshalToolbarSpaceStyle(p uintptr) (interface{}, error) {
	return ToolbarSpaceStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ToolbarStyle: used to customize the appearance of a Toolbar. Note that
// setting the toolbar style overrides the user’s preferences for the default
// toolbar style. Note that if the button has only a label set and
// GTK_TOOLBAR_ICONS is used, the label will be visible, and vice versa.
type ToolbarStyle int

const (
	// ToolbarStyleIcons buttons display only icons in the toolbar.
	ToolbarStyleIcons ToolbarStyle = 0
	// ToolbarStyleText buttons display only text labels in the toolbar.
	ToolbarStyleText ToolbarStyle = 1
	// ToolbarStyleBoth buttons display text and icons in the toolbar.
	ToolbarStyleBoth ToolbarStyle = 2
	// ToolbarStyleBothHoriz buttons display icons and text alongside each
	// other, rather than vertically stacked
	ToolbarStyleBothHoriz ToolbarStyle = 3
)

func marshalToolbarStyle(p uintptr) (interface{}, error) {
	return ToolbarStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TreeViewColumnSizing: the sizing method the column uses to determine its
// width. Please note that @GTK_TREE_VIEW_COLUMN_AUTOSIZE are inefficient for
// large views, and can make columns appear choppy.
type TreeViewColumnSizing int

const (
	// TreeViewColumnSizingGrowOnly columns only get bigger in reaction to
	// changes in the model
	TreeViewColumnSizingGrowOnly TreeViewColumnSizing = 0
	// TreeViewColumnSizingAutosize columns resize to be the optimal size
	// everytime the model changes.
	TreeViewColumnSizingAutosize TreeViewColumnSizing = 1
	// TreeViewColumnSizingFixed columns are a fixed numbers of pixels wide.
	TreeViewColumnSizingFixed TreeViewColumnSizing = 2
)

func marshalTreeViewColumnSizing(p uintptr) (interface{}, error) {
	return TreeViewColumnSizing(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TreeViewDropPosition: an enum for determining where a dropped row goes.
type TreeViewDropPosition int

const (
	// TreeViewDropPositionBefore: dropped row is inserted before
	TreeViewDropPositionBefore TreeViewDropPosition = 0
	// TreeViewDropPositionAfter: dropped row is inserted after
	TreeViewDropPositionAfter TreeViewDropPosition = 1
	// TreeViewDropPositionIntoOrBefore: dropped row becomes a child or is
	// inserted before
	TreeViewDropPositionIntoOrBefore TreeViewDropPosition = 2
	// TreeViewDropPositionIntoOrAfter: dropped row becomes a child or is
	// inserted after
	TreeViewDropPositionIntoOrAfter TreeViewDropPosition = 3
)

func marshalTreeViewDropPosition(p uintptr) (interface{}, error) {
	return TreeViewDropPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TreeViewGridLines: used to indicate which grid lines to draw in a tree view.
type TreeViewGridLines int

const (
	// TreeViewGridLinesNone: no grid lines.
	TreeViewGridLinesNone TreeViewGridLines = 0
	// TreeViewGridLinesHorizontal: horizontal grid lines.
	TreeViewGridLinesHorizontal TreeViewGridLines = 1
	// TreeViewGridLinesVertical: vertical grid lines.
	TreeViewGridLinesVertical TreeViewGridLines = 2
	// TreeViewGridLinesBoth: horizontal and vertical grid lines.
	TreeViewGridLinesBoth TreeViewGridLines = 3
)

func marshalTreeViewGridLines(p uintptr) (interface{}, error) {
	return TreeViewGridLines(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Unit: see also gtk_print_settings_set_paper_width().
type Unit int

const (
	// UnitNone: no units.
	UnitNone Unit = 0
	// UnitPoints dimensions in points.
	UnitPoints Unit = 1
	// UnitInch dimensions in inches.
	UnitInch Unit = 2
	// UnitMm dimensions in millimeters
	UnitMm Unit = 3
)

func marshalUnit(p uintptr) (interface{}, error) {
	return Unit(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// WidgetHelpType kinds of widget-specific help. Used by the ::show-help signal.
type WidgetHelpType int

const (
	// WidgetHelpTypeTooltip: tooltip.
	WidgetHelpTypeTooltip WidgetHelpType = 0
	// WidgetHelpTypeWhatsThis what’s this.
	WidgetHelpTypeWhatsThis WidgetHelpType = 1
)

func marshalWidgetHelpType(p uintptr) (interface{}, error) {
	return WidgetHelpType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// WindowPosition: window placement can be influenced using this enumeration.
// Note that using K_WIN_POS_CENTER_ALWAYS is almost always a bad idea. It won’t
// necessarily work well with all window managers or on all windowing systems.
type WindowPosition int

const (
	// WindowPositionNone: no influence is made on placement.
	WindowPositionNone WindowPosition = 0
	// WindowPositionCenter windows should be placed in the center of the
	// screen.
	WindowPositionCenter WindowPosition = 1
	// WindowPositionMouse windows should be placed at the current mouse
	// position.
	WindowPositionMouse WindowPosition = 2
	// WindowPositionCenterAlways: keep window centered as it changes size, etc.
	WindowPositionCenterAlways WindowPosition = 3
	// WindowPositionCenterOnParent: center the window on its transient parent
	// (see gtk_window_set_transient_for()).
	WindowPositionCenterOnParent WindowPosition = 4
)

func marshalWindowPosition(p uintptr) (interface{}, error) {
	return WindowPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// WindowType: a Window can be one of these types. Most things you’d consider a
// “window” should have type K_WINDOW_TOPLEVEL; windows with this type are
// managed by the window manager and have a frame by default (call
// gtk_window_set_decorated() to toggle the frame). Windows with type
// K_WINDOW_POPUP are ignored by the window manager; window manager keybindings
// won’t work on them, the window manager won’t decorate the window with a
// frame, many GTK+ features that rely on the window manager will not work (e.g.
// resize grips and maximization/minimization). K_WINDOW_POPUP is used to
// implement widgets such as Menu or tooltips that you normally don’t think of
// as windows per se. Nearly all windows should be K_WINDOW_TOPLEVEL. In
// particular, do not use K_WINDOW_POPUP just to turn off the window borders;
// use gtk_window_set_decorated() for that.
type WindowType int

const (
	// WindowTypeToplevel: a regular window, such as a dialog.
	WindowTypeToplevel WindowType = 0
	// WindowTypePopup: a special window such as a tooltip.
	WindowTypePopup WindowType = 1
)

func marshalWindowType(p uintptr) (interface{}, error) {
	return WindowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// WrapMode describes a type of line wrapping.
type WrapMode int

const (
	// WrapModeNone: do not wrap lines; just make the text area wider
	WrapModeNone WrapMode = 0
	// WrapModeChar: wrap text, breaking lines anywhere the cursor can appear
	// (between characters, usually - if you want to be technical, between
	// graphemes, see pango_get_log_attrs())
	WrapModeChar WrapMode = 1
	// WrapModeWord: wrap text, breaking lines in between words
	WrapModeWord WrapMode = 2
	// WrapModeWordChar: wrap text, breaking lines in between words, or if that
	// is not enough, also between graphemes
	WrapModeWordChar WrapMode = 3
)

func marshalWrapMode(p uintptr) (interface{}, error) {
	return WrapMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccelFlags: accelerator flags used with gtk_accel_group_connect().
type AccelFlags int

const (
	// AccelFlagsVisible: accelerator is visible
	AccelFlagsVisible AccelFlags = 1
	// AccelFlagsLocked: accelerator not removable
	AccelFlagsLocked AccelFlags = 2
	// AccelFlagsMask: mask
	AccelFlagsMask AccelFlags = 7
)

func marshalAccelFlags(p uintptr) (interface{}, error) {
	return AccelFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ApplicationInhibitFlags types of user actions that may be blocked by
// gtk_application_inhibit().
type ApplicationInhibitFlags int

const (
	// ApplicationInhibitFlagsLogout: inhibit ending the user session by logging
	// out or by shutting down the computer
	ApplicationInhibitFlagsLogout ApplicationInhibitFlags = 1
	// ApplicationInhibitFlagsSwitch: inhibit user switching
	ApplicationInhibitFlagsSwitch ApplicationInhibitFlags = 2
	// ApplicationInhibitFlagsSuspend: inhibit suspending the session or
	// computer
	ApplicationInhibitFlagsSuspend ApplicationInhibitFlags = 4
	// ApplicationInhibitFlagsIdle: inhibit the session being marked as idle
	// (and possibly locked)
	ApplicationInhibitFlagsIdle ApplicationInhibitFlags = 8
)

func marshalApplicationInhibitFlags(p uintptr) (interface{}, error) {
	return ApplicationInhibitFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AttachOptions denotes the expansion properties that a widget will have when
// it (or its parent) is resized.
type AttachOptions int

const (
	// AttachOptionsExpand: the widget should expand to take up any extra space
	// in its container that has been allocated.
	AttachOptionsExpand AttachOptions = 1
	// AttachOptionsShrink: the widget should shrink as and when possible.
	AttachOptionsShrink AttachOptions = 2
	// AttachOptionsFill: the widget should fill the space allocated to it.
	AttachOptionsFill AttachOptions = 4
)

func marshalAttachOptions(p uintptr) (interface{}, error) {
	return AttachOptions(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CalendarDisplayOptions: these options can be used to influence the display
// and behaviour of a Calendar.
type CalendarDisplayOptions int

const (
	// CalendarDisplayOptionsShowHeading specifies that the month and year
	// should be displayed.
	CalendarDisplayOptionsShowHeading CalendarDisplayOptions = 1
	// CalendarDisplayOptionsShowDayNames specifies that three letter day
	// descriptions should be present.
	CalendarDisplayOptionsShowDayNames CalendarDisplayOptions = 2
	// CalendarDisplayOptionsNoMonthChange prevents the user from switching
	// months with the calendar.
	CalendarDisplayOptionsNoMonthChange CalendarDisplayOptions = 4
	// CalendarDisplayOptionsShowWeekNumbers displays each week numbers of the
	// current year, down the left side of the calendar.
	CalendarDisplayOptionsShowWeekNumbers CalendarDisplayOptions = 8
	// CalendarDisplayOptionsShowDetails: just show an indicator, not the full
	// details text when details are provided. See
	// gtk_calendar_set_detail_func().
	CalendarDisplayOptionsShowDetails CalendarDisplayOptions = 32
)

func marshalCalendarDisplayOptions(p uintptr) (interface{}, error) {
	return CalendarDisplayOptions(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CellRendererState tells how a cell is to be rendered.
type CellRendererState int

const (
	// CellRendererStateSelected: the cell is currently selected, and probably
	// has a selection colored background to render to.
	CellRendererStateSelected CellRendererState = 1
	// CellRendererStatePrelit: the mouse is hovering over the cell.
	CellRendererStatePrelit CellRendererState = 2
	// CellRendererStateInsensitive: the cell is drawn in an insensitive manner
	CellRendererStateInsensitive CellRendererState = 4
	// CellRendererStateSorted: the cell is in a sorted row
	CellRendererStateSorted CellRendererState = 8
	// CellRendererStateFocused: the cell is in the focus row.
	CellRendererStateFocused CellRendererState = 16
	// CellRendererStateExpandable: the cell is in a row that can be expanded.
	// Since 3.4
	CellRendererStateExpandable CellRendererState = 32
	// CellRendererStateExpanded: the cell is in a row that is expanded. Since
	// 3.4
	CellRendererStateExpanded CellRendererState = 64
)

func marshalCellRendererState(p uintptr) (interface{}, error) {
	return CellRendererState(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

type DebugFlag int

const (
	DebugFlagMisc         DebugFlag = 1
	DebugFlagPlugsocket   DebugFlag = 2
	DebugFlagText         DebugFlag = 4
	DebugFlagTree         DebugFlag = 8
	DebugFlagUpdates      DebugFlag = 16
	DebugFlagKeybindings  DebugFlag = 32
	DebugFlagMultihead    DebugFlag = 64
	DebugFlagModules      DebugFlag = 128
	DebugFlagGeometry     DebugFlag = 256
	DebugFlagIcontheme    DebugFlag = 512
	DebugFlagPrinting     DebugFlag = 1024
	DebugFlagBuilder      DebugFlag = 2048
	DebugFlagSizeRequest  DebugFlag = 4096
	DebugFlagNoCSSCache   DebugFlag = 8192
	DebugFlagBaselines    DebugFlag = 16384
	DebugFlagPixelCache   DebugFlag = 32768
	DebugFlagNoPixelCache DebugFlag = 65536
	DebugFlagInteractive  DebugFlag = 131072
	DebugFlagTouchscreen  DebugFlag = 262144
	DebugFlagActions      DebugFlag = 524288
	DebugFlagResize       DebugFlag = 1048576
	DebugFlagLayout       DebugFlag = 2097152
)

func marshalDebugFlag(p uintptr) (interface{}, error) {
	return DebugFlag(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DestDefaults: the DestDefaults enumeration specifies the various types of
// action that will be taken on behalf of the user for a drag destination site.
type DestDefaults int

const (
	// DestDefaultsMotion: if set for a widget, GTK+, during a drag over this
	// widget will check if the drag matches this widget’s list of possible
	// targets and actions. GTK+ will then call gdk_drag_status() as
	// appropriate.
	DestDefaultsMotion DestDefaults = 1
	// DestDefaultsHighlight: if set for a widget, GTK+ will draw a highlight on
	// this widget as long as a drag is over this widget and the widget drag
	// format and action are acceptable.
	DestDefaultsHighlight DestDefaults = 2
	// DestDefaultsDrop: if set for a widget, when a drop occurs, GTK+ will will
	// check if the drag matches this widget’s list of possible targets and
	// actions. If so, GTK+ will call gtk_drag_get_data() on behalf of the
	// widget. Whether or not the drop is successful, GTK+ will call
	// gtk_drag_finish(). If the action was a move, then if the drag was
	// successful, then true will be passed for the @delete parameter to
	// gtk_drag_finish().
	DestDefaultsDrop DestDefaults = 4
	// DestDefaultsAll: if set, specifies that all default actions should be
	// taken.
	DestDefaultsAll DestDefaults = 7
)

func marshalDestDefaults(p uintptr) (interface{}, error) {
	return DestDefaults(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DialogFlags flags used to influence dialog construction.
type DialogFlags int

const (
	// DialogFlagsModal: make the constructed dialog modal, see
	// gtk_window_set_modal()
	DialogFlagsModal DialogFlags = 1
	// DialogFlagsDestroyWithParent: destroy the dialog when its parent is
	// destroyed, see gtk_window_set_destroy_with_parent()
	DialogFlagsDestroyWithParent DialogFlags = 2
	// DialogFlagsUseHeaderBar: create dialog with actions in header bar instead
	// of action area. Since 3.12.
	DialogFlagsUseHeaderBar DialogFlags = 4
)

func marshalDialogFlags(p uintptr) (interface{}, error) {
	return DialogFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EventControllerScrollFlags describes the behavior of a EventControllerScroll.
type EventControllerScrollFlags int

const (
	// EventControllerScrollFlagsNone: don't emit scroll.
	EventControllerScrollFlagsNone EventControllerScrollFlags = 0
	// EventControllerScrollFlagsVertical: emit scroll with vertical deltas.
	EventControllerScrollFlagsVertical EventControllerScrollFlags = 1
	// EventControllerScrollFlagsHorizontal: emit scroll with horizontal deltas.
	EventControllerScrollFlagsHorizontal EventControllerScrollFlags = 2
	// EventControllerScrollFlagsDiscrete: only emit deltas that are multiples
	// of 1.
	EventControllerScrollFlagsDiscrete EventControllerScrollFlags = 4
	// EventControllerScrollFlagsKinetic: emit EventControllerScroll::decelerate
	// after continuous scroll finishes.
	EventControllerScrollFlagsKinetic EventControllerScrollFlags = 8
	// EventControllerScrollFlagsBothAxes: emit scroll on both axes.
	EventControllerScrollFlagsBothAxes EventControllerScrollFlags = 3
)

func marshalEventControllerScrollFlags(p uintptr) (interface{}, error) {
	return EventControllerScrollFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileFilterFlags: these flags indicate what parts of a FileFilterInfo struct
// are filled or need to be filled.
type FileFilterFlags int

const (
	// FileFilterFlagsFilename: the filename of the file being tested
	FileFilterFlagsFilename FileFilterFlags = 1
	// FileFilterFlagsURI: the URI for the file being tested
	FileFilterFlagsURI FileFilterFlags = 2
	// FileFilterFlagsDisplayName: the string that will be used to display the
	// file in the file chooser
	FileFilterFlagsDisplayName FileFilterFlags = 4
	// FileFilterFlagsMIMEType: the mime type of the file
	FileFilterFlagsMIMEType FileFilterFlags = 8
)

func marshalFileFilterFlags(p uintptr) (interface{}, error) {
	return FileFilterFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FontChooserLevel: this enumeration specifies the granularity of font
// selection that is desired in a font chooser.
//
// This enumeration may be extended in the future; applications should ignore
// unknown values.
type FontChooserLevel int

const (
	// FontChooserLevelFamily: allow selecting a font family
	FontChooserLevelFamily FontChooserLevel = 0
	// FontChooserLevelStyle: allow selecting a specific font face
	FontChooserLevelStyle FontChooserLevel = 1
	// FontChooserLevelSize: allow selecting a specific font size
	FontChooserLevelSize       FontChooserLevel = 2
	FontChooserLevelVariations FontChooserLevel = 4
	// FontChooserLevelFeatures: allow selecting specific OpenType font features
	FontChooserLevelFeatures FontChooserLevel = 8
)

func marshalFontChooserLevel(p uintptr) (interface{}, error) {
	return FontChooserLevel(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconLookupFlags: used to specify options for gtk_icon_theme_lookup_icon()
type IconLookupFlags int

const (
	// IconLookupFlagsNoSvg: never get SVG icons, even if gdk-pixbuf supports
	// them. Cannot be used together with GTK_ICON_LOOKUP_FORCE_SVG.
	IconLookupFlagsNoSvg IconLookupFlags = 1
	// IconLookupFlagsForceSvg: get SVG icons, even if gdk-pixbuf doesn’t
	// support them. Cannot be used together with GTK_ICON_LOOKUP_NO_SVG.
	IconLookupFlagsForceSvg IconLookupFlags = 2
	// IconLookupFlagsUseBuiltin: when passed to gtk_icon_theme_lookup_icon()
	// includes builtin icons as well as files. For a builtin icon,
	// gtk_icon_info_get_filename() is nil and you need to call
	// gtk_icon_info_get_builtin_pixbuf().
	IconLookupFlagsUseBuiltin IconLookupFlags = 4
	// IconLookupFlagsGenericFallback: try to shorten icon name at '-'
	// characters before looking at inherited themes. This flag is only
	// supported in functions that take a single icon name. For more general
	// fallback, see gtk_icon_theme_choose_icon(). Since 2.12.
	IconLookupFlagsGenericFallback IconLookupFlags = 8
	// IconLookupFlagsForceSize always get the icon scaled to the requested
	// size. Since 2.14.
	IconLookupFlagsForceSize IconLookupFlags = 16
	// IconLookupFlagsForceRegular: try to always load regular icons, even when
	// symbolic icon names are given. Since 3.14.
	IconLookupFlagsForceRegular IconLookupFlags = 32
	// IconLookupFlagsForceSymbolic: try to always load symbolic icons, even
	// when regular icon names are given. Since 3.14.
	IconLookupFlagsForceSymbolic IconLookupFlags = 64
	// IconLookupFlagsDirLTR: try to load a variant of the icon for
	// left-to-right text direction. Since 3.14.
	IconLookupFlagsDirLTR IconLookupFlags = 128
	// IconLookupFlagsDirRTL: try to load a variant of the icon for
	// right-to-left text direction. Since 3.14.
	IconLookupFlagsDirRTL IconLookupFlags = 256
)

func marshalIconLookupFlags(p uintptr) (interface{}, error) {
	return IconLookupFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// InputHints describes hints that might be taken into account by input methods
// or applications. Note that input methods may already tailor their behaviour
// according to the InputPurpose of the entry.
//
// Some common sense is expected when using these flags - mixing
// @GTK_INPUT_HINT_LOWERCASE with any of the uppercase hints makes no sense.
//
// This enumeration may be extended in the future; input methods should ignore
// unknown values.
type InputHints int

const (
	// InputHintsNone: no special behaviour suggested
	InputHintsNone InputHints = 0
	// InputHintsSpellcheck: suggest checking for typos
	InputHintsSpellcheck InputHints = 1
	// InputHintsNoSpellcheck: suggest not checking for typos
	InputHintsNoSpellcheck InputHints = 2
	// InputHintsWordCompletion: suggest word completion
	InputHintsWordCompletion InputHints = 4
	// InputHintsLowercase: suggest to convert all text to lowercase
	InputHintsLowercase InputHints = 8
	// InputHintsUppercaseChars: suggest to capitalize all text
	InputHintsUppercaseChars InputHints = 16
	// InputHintsUppercaseWords: suggest to capitalize the first character of
	// each word
	InputHintsUppercaseWords InputHints = 32
	// InputHintsUppercaseSentences: suggest to capitalize the first word of
	// each sentence
	InputHintsUppercaseSentences InputHints = 64
	// InputHintsInhibitOsk: suggest to not show an onscreen keyboard (e.g for a
	// calculator that already has all the keys).
	InputHintsInhibitOsk InputHints = 128
	// InputHintsVerticalWriting: the text is vertical. Since 3.18
	InputHintsVerticalWriting InputHints = 256
	// InputHintsEmoji: suggest offering Emoji support. Since 3.22.20
	InputHintsEmoji InputHints = 512
	// InputHintsNoEmoji: suggest not offering Emoji support. Since 3.22.20
	InputHintsNoEmoji InputHints = 1024
)

func marshalInputHints(p uintptr) (interface{}, error) {
	return InputHints(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// JunctionSides describes how a rendered element connects to adjacent elements.
type JunctionSides int

const (
	// JunctionSidesNone: no junctions.
	JunctionSidesNone JunctionSides = 0
	// JunctionSidesCornerTopleft: element connects on the top-left corner.
	JunctionSidesCornerTopleft JunctionSides = 1
	// JunctionSidesCornerTopright: element connects on the top-right corner.
	JunctionSidesCornerTopright JunctionSides = 2
	// JunctionSidesCornerBottomleft: element connects on the bottom-left
	// corner.
	JunctionSidesCornerBottomleft JunctionSides = 4
	// JunctionSidesCornerBottomright: element connects on the bottom-right
	// corner.
	JunctionSidesCornerBottomright JunctionSides = 8
	// JunctionSidesTop: element connects on the top side.
	JunctionSidesTop JunctionSides = 3
	// JunctionSidesBottom: element connects on the bottom side.
	JunctionSidesBottom JunctionSides = 12
	// JunctionSidesLeft: element connects on the left side.
	JunctionSidesLeft JunctionSides = 5
	// JunctionSidesRight: element connects on the right side.
	JunctionSidesRight JunctionSides = 10
)

func marshalJunctionSides(p uintptr) (interface{}, error) {
	return JunctionSides(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PlacesOpenFlags: these flags serve two purposes. First, the application can
// call gtk_places_sidebar_set_open_flags() using these flags as a bitmask. This
// tells the sidebar that the application is able to open folders selected from
// the sidebar in various ways, for example, in new tabs or in new windows in
// addition to the normal mode.
//
// Second, when one of these values gets passed back to the application in the
// PlacesSidebar::open-location signal, it means that the application should
// open the selected location in the normal way, in a new tab, or in a new
// window. The sidebar takes care of determining the desired way to open the
// location, based on the modifier keys that the user is pressing at the time
// the selection is made.
//
// If the application never calls gtk_places_sidebar_set_open_flags(), then the
// sidebar will only use K_PLACES_OPEN_NORMAL in the
// PlacesSidebar::open-location signal. This is the default mode of operation.
type PlacesOpenFlags int

const (
	// PlacesOpenFlagsNormal: this is the default mode that PlacesSidebar uses
	// if no other flags are specified. It indicates that the calling
	// application should open the selected location in the normal way, for
	// example, in the folder view beside the sidebar.
	PlacesOpenFlagsNormal PlacesOpenFlags = 1
	// PlacesOpenFlagsNewTab: when passed to
	// gtk_places_sidebar_set_open_flags(), this indicates that the application
	// can open folders selected from the sidebar in new tabs. This value will
	// be passed to the PlacesSidebar::open-location signal when the user
	// selects that a location be opened in a new tab instead of in the standard
	// fashion.
	PlacesOpenFlagsNewTab PlacesOpenFlags = 2
	// PlacesOpenFlagsNewWindow: similar to @GTK_PLACES_OPEN_NEW_TAB, but
	// indicates that the application can open folders in new windows.
	PlacesOpenFlagsNewWindow PlacesOpenFlags = 4
)

func marshalPlacesOpenFlags(p uintptr) (interface{}, error) {
	return PlacesOpenFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RCFlags: deprecated
type RCFlags int

const (
	// RCFlagsFg: deprecated
	RCFlagsFg RCFlags = 1
	// RCFlagsBg: deprecated
	RCFlagsBg RCFlags = 2
	// RCFlagsText: deprecated
	RCFlagsText RCFlags = 4
	// RCFlagsBase: deprecated
	RCFlagsBase RCFlags = 8
)

func marshalRCFlags(p uintptr) (interface{}, error) {
	return RCFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RecentFilterFlags: these flags indicate what parts of a RecentFilterInfo
// struct are filled or need to be filled.
type RecentFilterFlags int

const (
	// RecentFilterFlagsURI: the URI of the file being tested
	RecentFilterFlagsURI RecentFilterFlags = 1
	// RecentFilterFlagsDisplayName: the string that will be used to display the
	// file in the recent chooser
	RecentFilterFlagsDisplayName RecentFilterFlags = 2
	// RecentFilterFlagsMIMEType: the mime type of the file
	RecentFilterFlagsMIMEType RecentFilterFlags = 4
	// RecentFilterFlagsApplication: the list of applications that have
	// registered the file
	RecentFilterFlagsApplication RecentFilterFlags = 8
	// RecentFilterFlagsGroup: the groups to which the file belongs to
	RecentFilterFlagsGroup RecentFilterFlags = 16
	// RecentFilterFlagsAge: the number of days elapsed since the file has been
	// registered
	RecentFilterFlagsAge RecentFilterFlags = 32
)

func marshalRecentFilterFlags(p uintptr) (interface{}, error) {
	return RecentFilterFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RegionFlags describes a region within a widget.
type RegionFlags int

const (
	// RegionFlagsEven: region has an even number within a set.
	RegionFlagsEven RegionFlags = 1
	// RegionFlagsOdd: region has an odd number within a set.
	RegionFlagsOdd RegionFlags = 2
	// RegionFlagsFirst: region is the first one within a set.
	RegionFlagsFirst RegionFlags = 4
	// RegionFlagsLast: region is the last one within a set.
	RegionFlagsLast RegionFlags = 8
	// RegionFlagsOnly: region is the only one within a set.
	RegionFlagsOnly RegionFlags = 16
	// RegionFlagsSorted: region is part of a sorted area.
	RegionFlagsSorted RegionFlags = 32
)

func marshalRegionFlags(p uintptr) (interface{}, error) {
	return RegionFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// StateFlags describes a widget state. Widget states are used to match the
// widget against CSS pseudo-classes. Note that GTK extends the regular CSS
// classes and sometimes uses different names.
type StateFlags int

const (
	// StateFlagsNormal: state during normal operation.
	StateFlagsNormal StateFlags = 0
	// StateFlagsActive: widget is active.
	StateFlagsActive StateFlags = 1
	// StateFlagsPrelight: widget has a mouse pointer over it.
	StateFlagsPrelight StateFlags = 2
	// StateFlagsSelected: widget is selected.
	StateFlagsSelected StateFlags = 4
	// StateFlagsInsensitive: widget is insensitive.
	StateFlagsInsensitive StateFlags = 8
	// StateFlagsInconsistent: widget is inconsistent.
	StateFlagsInconsistent StateFlags = 16
	// StateFlagsFocused: widget has the keyboard focus.
	StateFlagsFocused StateFlags = 32
	// StateFlagsBackdrop: widget is in a background toplevel window.
	StateFlagsBackdrop StateFlags = 64
	// StateFlagsDirLTR: widget is in left-to-right text direction. Since 3.8
	StateFlagsDirLTR StateFlags = 128
	// StateFlagsDirRTL: widget is in right-to-left text direction. Since 3.8
	StateFlagsDirRTL StateFlags = 256
	// StateFlagsLink: widget is a link. Since 3.12
	StateFlagsLink StateFlags = 512
	// StateFlagsVisited: the location the widget points to has already been
	// visited. Since 3.12
	StateFlagsVisited StateFlags = 1024
	// StateFlagsChecked: widget is checked. Since 3.14
	StateFlagsChecked StateFlags = 2048
	// StateFlagsDropActive: widget is highlighted as a drop target for DND.
	// Since 3.20
	StateFlagsDropActive StateFlags = 4096
)

func marshalStateFlags(p uintptr) (interface{}, error) {
	return StateFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// StyleContextPrintFlags flags that modify the behavior of
// gtk_style_context_to_string(). New values may be added to this enumeration.
type StyleContextPrintFlags int

const (
	StyleContextPrintFlagsNone StyleContextPrintFlags = 0
	// StyleContextPrintFlagsRecurse: print the entire tree of CSS nodes
	// starting at the style context's node
	StyleContextPrintFlagsRecurse StyleContextPrintFlags = 1
	// StyleContextPrintFlagsShowStyle: show the values of the CSS properties
	// for each node
	StyleContextPrintFlagsShowStyle StyleContextPrintFlags = 2
)

func marshalStyleContextPrintFlags(p uintptr) (interface{}, error) {
	return StyleContextPrintFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TargetFlags: the TargetFlags enumeration is used to specify constraints on a
// TargetEntry.
type TargetFlags int

const (
	// TargetFlagsSameApp: if this is set, the target will only be selected for
	// drags within a single application.
	TargetFlagsSameApp TargetFlags = 1
	// TargetFlagsSameWidget: if this is set, the target will only be selected
	// for drags within a single widget.
	TargetFlagsSameWidget TargetFlags = 2
	// TargetFlagsOtherApp: if this is set, the target will not be selected for
	// drags within a single application.
	TargetFlagsOtherApp TargetFlags = 4
	// TargetFlagsOtherWidget: if this is set, the target will not be selected
	// for drags withing a single widget.
	TargetFlagsOtherWidget TargetFlags = 8
)

func marshalTargetFlags(p uintptr) (interface{}, error) {
	return TargetFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextSearchFlags flags affecting how a search is done.
//
// If neither K_TEXT_SEARCH_VISIBLE_ONLY nor K_TEXT_SEARCH_TEXT_ONLY are
// enabled, the match must be exact; the special 0xFFFC character will match
// embedded pixbufs or child widgets.
type TextSearchFlags int

const (
	// TextSearchFlagsVisibleOnly: search only visible data. A search match may
	// have invisible text interspersed.
	TextSearchFlagsVisibleOnly TextSearchFlags = 1
	// TextSearchFlagsTextOnly: search only text. A match may have pixbufs or
	// child widgets mixed inside the matched range.
	TextSearchFlagsTextOnly TextSearchFlags = 2
	// TextSearchFlagsCaseInsensitive: the text will be matched regardless of
	// what case it is in.
	TextSearchFlagsCaseInsensitive TextSearchFlags = 4
)

func marshalTextSearchFlags(p uintptr) (interface{}, error) {
	return TextSearchFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ToolPaletteDragTargets flags used to specify the supported drag targets.
type ToolPaletteDragTargets int

const (
	// ToolPaletteDragTargetsItems: support drag of items.
	ToolPaletteDragTargetsItems ToolPaletteDragTargets = 1
	// ToolPaletteDragTargetsGroups: support drag of groups.
	ToolPaletteDragTargetsGroups ToolPaletteDragTargets = 2
)

func marshalToolPaletteDragTargets(p uintptr) (interface{}, error) {
	return ToolPaletteDragTargets(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TreeModelFlags: these flags indicate various properties of a TreeModel.
//
// They are returned by gtk_tree_model_get_flags(), and must be static for the
// lifetime of the object. A more complete description of
// K_TREE_MODEL_ITERS_PERSIST can be found in the overview of this section.
type TreeModelFlags int

const (
	// TreeModelFlagsItersPersist iterators survive all signals emitted by the
	// tree
	TreeModelFlagsItersPersist TreeModelFlags = 1
	// TreeModelFlagsListOnly: the model is a list only, and never has children
	TreeModelFlagsListOnly TreeModelFlags = 2
)

func marshalTreeModelFlags(p uintptr) (interface{}, error) {
	return TreeModelFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// UIManagerItemType: these enumeration values are used by
// gtk_ui_manager_add_ui() to determine what UI element to create.
type UIManagerItemType int

const (
	// UIManagerItemTypeAuto: pick the type of the UI element according to
	// context.
	UIManagerItemTypeAuto UIManagerItemType = 0
	// UIManagerItemTypeMenubar: create a menubar.
	UIManagerItemTypeMenubar UIManagerItemType = 1
	// UIManagerItemTypeMenu: create a menu.
	UIManagerItemTypeMenu UIManagerItemType = 2
	// UIManagerItemTypeToolbar: create a toolbar.
	UIManagerItemTypeToolbar UIManagerItemType = 4
	// UIManagerItemTypePlaceholder: insert a placeholder.
	UIManagerItemTypePlaceholder UIManagerItemType = 8
	// UIManagerItemTypePopup: create a popup menu.
	UIManagerItemTypePopup UIManagerItemType = 16
	// UIManagerItemTypeMenuitem: create a menuitem.
	UIManagerItemTypeMenuitem UIManagerItemType = 32
	// UIManagerItemTypeToolitem: create a toolitem.
	UIManagerItemTypeToolitem UIManagerItemType = 64
	// UIManagerItemTypeSeparator: create a separator.
	UIManagerItemTypeSeparator UIManagerItemType = 128
	// UIManagerItemTypeAccelerator: install an accelerator.
	UIManagerItemTypeAccelerator UIManagerItemType = 256
	// UIManagerItemTypePopupWithAccels: same as GTK_UI_MANAGER_POPUP, but the
	// actions’ accelerators are shown.
	UIManagerItemTypePopupWithAccels UIManagerItemType = 512
)

func marshalUIManagerItemType(p uintptr) (interface{}, error) {
	return UIManagerItemType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccelGroupsActivate finds the first accelerator in any AccelGroup attached to
// @object that matches @accel_key and @accel_mods, and activates that
// accelerator.
func AccelGroupsActivate(object gextras.Objector, accelKey uint, accelMods gdk.ModifierType) bool {
	var _arg1 *C.GObject        // out
	var _arg2 C.guint           // out
	var _arg3 C.GdkModifierType // out
	var _cret C.gboolean        // in

	_arg1 = (*C.GObject)(unsafe.Pointer(object.Native()))
	_arg2 = (C.guint)(accelKey)
	_arg3 = (C.GdkModifierType)(accelMods)

	_cret = C.gtk_accel_groups_activate(_arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AcceleratorGetDefaultModMask gets the modifier mask.
//
// The modifier mask determines which modifiers are considered significant for
// keyboard accelerators. See gtk_accelerator_set_default_mod_mask().
func AcceleratorGetDefaultModMask() gdk.ModifierType {
	var _cret C.GdkModifierType // in

	_cret = C.gtk_accelerator_get_default_mod_mask()

	var _modifierType gdk.ModifierType // out

	_modifierType = gdk.ModifierType(_cret)

	return _modifierType
}

// AcceleratorGetLabel converts an accelerator keyval and modifier mask into a
// string which can be used to represent the accelerator to the user.
func AcceleratorGetLabel(acceleratorKey uint, acceleratorMods gdk.ModifierType) string {
	var _arg1 C.guint           // out
	var _arg2 C.GdkModifierType // out
	var _cret *C.gchar          // in

	_arg1 = (C.guint)(acceleratorKey)
	_arg2 = (C.GdkModifierType)(acceleratorMods)

	_cret = C.gtk_accelerator_get_label(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// AcceleratorGetLabelWithKeycode converts an accelerator keyval and modifier
// mask into a (possibly translated) string that can be displayed to a user,
// similarly to gtk_accelerator_get_label(), but handling keycodes.
//
// This is only useful for system-level components, applications should use
// gtk_accelerator_parse() instead.
func AcceleratorGetLabelWithKeycode(display gdk.Display, acceleratorKey uint, keycode uint, acceleratorMods gdk.ModifierType) string {
	var _arg1 *C.GdkDisplay     // out
	var _arg2 C.guint           // out
	var _arg3 C.guint           // out
	var _arg4 C.GdkModifierType // out
	var _cret *C.gchar          // in

	_arg1 = (*C.GdkDisplay)(unsafe.Pointer(display.Native()))
	_arg2 = (C.guint)(acceleratorKey)
	_arg3 = (C.guint)(keycode)
	_arg4 = (C.GdkModifierType)(acceleratorMods)

	_cret = C.gtk_accelerator_get_label_with_keycode(_arg1, _arg2, _arg3, _arg4)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// AcceleratorName converts an accelerator keyval and modifier mask into a
// string parseable by gtk_accelerator_parse(). For example, if you pass in
// K_KEY_q and K_CONTROL_MASK, this function returns “<Control>q”.
//
// If you need to display accelerators in the user interface, see
// gtk_accelerator_get_label().
func AcceleratorName(acceleratorKey uint, acceleratorMods gdk.ModifierType) string {
	var _arg1 C.guint           // out
	var _arg2 C.GdkModifierType // out
	var _cret *C.gchar          // in

	_arg1 = (C.guint)(acceleratorKey)
	_arg2 = (C.GdkModifierType)(acceleratorMods)

	_cret = C.gtk_accelerator_name(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// AcceleratorNameWithKeycode converts an accelerator keyval and modifier mask
// into a string parseable by gtk_accelerator_parse_with_keycode(), similarly to
// gtk_accelerator_name() but handling keycodes. This is only useful for
// system-level components, applications should use gtk_accelerator_parse()
// instead.
func AcceleratorNameWithKeycode(display gdk.Display, acceleratorKey uint, keycode uint, acceleratorMods gdk.ModifierType) string {
	var _arg1 *C.GdkDisplay     // out
	var _arg2 C.guint           // out
	var _arg3 C.guint           // out
	var _arg4 C.GdkModifierType // out
	var _cret *C.gchar          // in

	_arg1 = (*C.GdkDisplay)(unsafe.Pointer(display.Native()))
	_arg2 = (C.guint)(acceleratorKey)
	_arg3 = (C.guint)(keycode)
	_arg4 = (C.GdkModifierType)(acceleratorMods)

	_cret = C.gtk_accelerator_name_with_keycode(_arg1, _arg2, _arg3, _arg4)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// AcceleratorParse parses a string representing an accelerator. The format
// looks like “<Control>a” or “<Shift><Alt>F1” or “<Release>z” (the last one is
// for key release).
//
// The parser is fairly liberal and allows lower or upper case, and also
// abbreviations such as “<Ctl>” and “<Ctrl>”. Key names are parsed using
// gdk_keyval_from_name(). For character keys the name is not the symbol, but
// the lowercase name, e.g. one would use “<Ctrl>minus” instead of “<Ctrl>-”.
//
// If the parse fails, @accelerator_key and @accelerator_mods will be set to 0
// (zero).
func AcceleratorParse(accelerator string) (uint, gdk.ModifierType) {
	var _arg1 *C.gchar          // out
	var _arg2 C.guint           // in
	var _arg3 C.GdkModifierType // in

	_arg1 = (*C.gchar)(C.CString(accelerator))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_accelerator_parse(_arg1, &_arg2, &_arg3)

	var _acceleratorKey uint              // out
	var _acceleratorMods gdk.ModifierType // out

	_acceleratorKey = (uint)(_arg2)
	_acceleratorMods = gdk.ModifierType(_arg3)

	return _acceleratorKey, _acceleratorMods
}

// AcceleratorParseWithKeycode parses a string representing an accelerator,
// similarly to gtk_accelerator_parse() but handles keycodes as well. This is
// only useful for system-level components, applications should use
// gtk_accelerator_parse() instead.
//
// If @accelerator_codes is given and the result stored in it is non-nil, the
// result must be freed with g_free().
//
// If a keycode is present in the accelerator and no @accelerator_codes is
// given, the parse will fail.
//
// If the parse fails, @accelerator_key, @accelerator_mods and
// @accelerator_codes will be set to 0 (zero).
func AcceleratorParseWithKeycode(accelerator string) (uint, []uint, gdk.ModifierType) {
	var _arg1 *C.gchar // out
	var _arg2 C.guint  // in
	var _arg3 *C.guint
	var _arg4 C.GdkModifierType // in

	_arg1 = (*C.gchar)(C.CString(accelerator))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_accelerator_parse_with_keycode(_arg1, &_arg2, &_arg3, &_arg4)

	var _acceleratorKey uint // out
	var _acceleratorCodes []uint
	var _acceleratorMods gdk.ModifierType // out

	_acceleratorKey = (uint)(_arg2)
	{
		var i int
		var z C.guint
		for p := _arg3; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_arg3, i)
		_acceleratorCodes = make([]uint, i)
		for i := range src {
			_acceleratorCodes[i] = (uint)(src[i])
		}
	}
	_acceleratorMods = gdk.ModifierType(_arg4)

	return _acceleratorKey, _acceleratorCodes, _acceleratorMods
}

// AcceleratorSetDefaultModMask sets the modifiers that will be considered
// significant for keyboard accelerators. The default mod mask depends on the
// GDK backend in use, but will typically include K_CONTROL_MASK | K_SHIFT_MASK
// | K_MOD1_MASK | K_SUPER_MASK | K_HYPER_MASK | K_META_MASK. In other words,
// Control, Shift, Alt, Super, Hyper and Meta. Other modifiers will by default
// be ignored by AccelGroup.
//
// You must include at least the three modifiers Control, Shift and Alt in any
// value you pass to this function.
//
// The default mod mask should be changed on application startup, before using
// any accelerator groups.
func AcceleratorSetDefaultModMask(defaultModMask gdk.ModifierType) {
	var _arg1 C.GdkModifierType // out

	_arg1 = (C.GdkModifierType)(defaultModMask)

	C.gtk_accelerator_set_default_mod_mask(_arg1)
}

// AcceleratorValid determines whether a given keyval and modifier mask
// constitute a valid keyboard accelerator. For example, the K_KEY_a keyval plus
// K_CONTROL_MASK is valid - this is a “Ctrl+a” accelerator. But, you can't, for
// instance, use the K_KEY_Control_L keyval as an accelerator.
func AcceleratorValid(keyval uint, modifiers gdk.ModifierType) bool {
	var _arg1 C.guint           // out
	var _arg2 C.GdkModifierType // out
	var _cret C.gboolean        // in

	_arg1 = (C.guint)(keyval)
	_arg2 = (C.GdkModifierType)(modifiers)

	_cret = C.gtk_accelerator_valid(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AlternativeDialogButtonOrder returns true if dialogs are expected to use an
// alternative button order on the screen @screen. See
// gtk_dialog_set_alternative_button_order() for more details about alternative
// button order.
//
// If you need to use this function, you should probably connect to the
// ::notify:gtk-alternative-button-order signal on the Settings object
// associated to @screen, in order to be notified if the button order setting
// changes.
func AlternativeDialogButtonOrder(screen gdk.Screen) bool {
	var _arg1 *C.GdkScreen // out
	var _cret C.gboolean   // in

	_arg1 = (*C.GdkScreen)(unsafe.Pointer(screen.Native()))

	_cret = C.gtk_alternative_dialog_button_order(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BindingsActivate: find a key binding matching @keyval and @modifiers and
// activate the binding on @object.
func BindingsActivate(object gextras.Objector, keyval uint, modifiers gdk.ModifierType) bool {
	var _arg1 *C.GObject        // out
	var _arg2 C.guint           // out
	var _arg3 C.GdkModifierType // out
	var _cret C.gboolean        // in

	_arg1 = (*C.GObject)(unsafe.Pointer(object.Native()))
	_arg2 = (C.guint)(keyval)
	_arg3 = (C.GdkModifierType)(modifiers)

	_cret = C.gtk_bindings_activate(_arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BindingsActivateEvent looks up key bindings for @object to find one matching
// @event, and if one was found, activate it.
func BindingsActivateEvent(object gextras.Objector, event *gdk.EventKey) bool {
	var _arg1 *C.GObject     // out
	var _arg2 *C.GdkEventKey // out
	var _cret C.gboolean     // in

	_arg1 = (*C.GObject)(unsafe.Pointer(object.Native()))
	_arg2 = (*C.GdkEventKey)(unsafe.Pointer(event.Native()))

	_cret = C.gtk_bindings_activate_event(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CairoShouldDrawWindow: this function is supposed to be called in Widget::draw
// implementations for widgets that support multiple windows. @cr must be
// untransformed from invoking of the draw function. This function will return
// true if the contents of the given @window are supposed to be drawn and false
// otherwise. Note that when the drawing was not initiated by the windowing
// system this function will return true for all windows, so you need to draw
// the bottommost window first. Also, do not use “else if” statements to check
// which window should be drawn.
func CairoShouldDrawWindow(cr *cairo.Context, window gdk.Window) bool {
	var _arg1 *C.cairo_t   // out
	var _arg2 *C.GdkWindow // out
	var _cret C.gboolean   // in

	_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg2 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_cairo_should_draw_window(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CairoTransformToWindow transforms the given cairo context @cr that from
// @widget-relative coordinates to @window-relative coordinates. If the
// @widget’s window is not an ancestor of @window, no modification will be
// applied.
//
// This is the inverse to the transformation GTK applies when preparing an
// expose event to be emitted with the Widget::draw signal. It is intended to
// help porting multiwindow widgets from GTK+ 2 to the rendering architecture of
// GTK+ 3.
func CairoTransformToWindow(cr *cairo.Context, widget Widget, window gdk.Window) {
	var _arg1 *C.cairo_t   // out
	var _arg2 *C.GtkWidget // out
	var _arg3 *C.GdkWindow // out

	_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg3 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_cairo_transform_to_window(_arg1, _arg2, _arg3)
}

// CheckVersion checks that the GTK+ library in use is compatible with the given
// version. Generally you would pass in the constants K_MAJOR_VERSION,
// K_MINOR_VERSION, K_MICRO_VERSION as the three arguments to this function;
// that produces a check that the library in use is compatible with the version
// of GTK+ the application or module was compiled against.
//
// Compatibility is defined by two things: first the version of the running
// library is newer than the version
// @required_major.required_minor.@required_micro. Second the running library
// must be binary compatible with the version
// @required_major.required_minor.@required_micro (same major version.)
//
// This function is primarily for GTK+ modules; the module can call this
// function to check that it wasn’t loaded into an incompatible version of GTK+.
// However, such a check isn’t completely reliable, since the module may be
// linked against an old version of GTK+ and calling the old version of
// gtk_check_version(), but still get loaded into an application using a newer
// version of GTK+.
func CheckVersion(requiredMajor uint, requiredMinor uint, requiredMicro uint) string {
	var _arg1 C.guint  // out
	var _arg2 C.guint  // out
	var _arg3 C.guint  // out
	var _cret *C.gchar // in

	_arg1 = (C.guint)(requiredMajor)
	_arg2 = (C.guint)(requiredMinor)
	_arg3 = (C.guint)(requiredMicro)

	_cret = C.gtk_check_version(_arg1, _arg2, _arg3)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// DeviceGrabAdd adds a GTK+ grab on @device, so all the events on @device and
// its associated pointer or keyboard (if any) are delivered to @widget. If the
// @block_others parameter is true, any other devices will be unable to interact
// with @widget during the grab.
func DeviceGrabAdd(widget Widget, device gdk.Device, blockOthers bool) {
	var _arg1 *C.GtkWidget // out
	var _arg2 *C.GdkDevice // out
	var _arg3 C.gboolean   // out

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))
	if blockOthers {
		_arg3 = C.TRUE
	}

	C.gtk_device_grab_add(_arg1, _arg2, _arg3)
}

// DeviceGrabRemove removes a device grab from the given widget.
//
// You have to pair calls to gtk_device_grab_add() and gtk_device_grab_remove().
func DeviceGrabRemove(widget Widget, device gdk.Device) {
	var _arg1 *C.GtkWidget // out
	var _arg2 *C.GdkDevice // out

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))

	C.gtk_device_grab_remove(_arg1, _arg2)
}

// DisableSetlocale prevents gtk_init(), gtk_init_check(), gtk_init_with_args()
// and gtk_parse_args() from automatically calling `setlocale (LC_ALL, "")`. You
// would want to use this function if you wanted to set the locale for your
// program to something other than the user’s locale, or if you wanted to set
// different values for different locale categories.
//
// Most programs should not need to call this function.
func DisableSetlocale() {
	C.gtk_disable_setlocale()
}

// DistributeNaturalAllocation distributes @extra_space to child @sizes by
// bringing smaller children up to natural size first.
//
// The remaining space will be added to the @minimum_size member of the
// GtkRequestedSize struct. If all sizes reach their natural size then the
// remaining space is returned.
func DistributeNaturalAllocation(extraSpace int, nRequestedSizes uint, sizes *RequestedSize) int {
	var _arg1 C.gint              // out
	var _arg2 C.guint             // out
	var _arg3 *C.GtkRequestedSize // out
	var _cret C.gint              // in

	_arg1 = (C.gint)(extraSpace)
	_arg2 = (C.guint)(nRequestedSizes)
	_arg3 = (*C.GtkRequestedSize)(unsafe.Pointer(sizes.Native()))

	_cret = C.gtk_distribute_natural_allocation(_arg1, _arg2, _arg3)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// DragCancel cancels an ongoing drag operation on the source side.
//
// If you want to be able to cancel a drag operation in this way, you need to
// keep a pointer to the drag context, either from an explicit call to
// gtk_drag_begin_with_coordinates(), or by connecting to Widget::drag-begin.
//
// If @context does not refer to an ongoing drag operation, this function does
// nothing.
//
// If a drag is cancelled in this way, the @result argument of
// Widget::drag-failed is set to @GTK_DRAG_RESULT_ERROR.
func DragCancel(context gdk.DragContext) {
	var _arg1 *C.GdkDragContext // out

	_arg1 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))

	C.gtk_drag_cancel(_arg1)
}

// DragFinish informs the drag source that the drop is finished, and that the
// data of the drag will no longer be required.
func DragFinish(context gdk.DragContext, success bool, del bool, time_ uint32) {
	var _arg1 *C.GdkDragContext // out
	var _arg2 C.gboolean        // out
	var _arg3 C.gboolean        // out
	var _arg4 C.guint32         // out

	_arg1 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))
	if success {
		_arg2 = C.TRUE
	}
	if del {
		_arg3 = C.TRUE
	}
	_arg4 = (C.guint32)(time_)

	C.gtk_drag_finish(_arg1, _arg2, _arg3, _arg4)
}

// DragGetSourceWidget determines the source widget for a drag.
func DragGetSourceWidget(context gdk.DragContext) Widget {
	var _arg1 *C.GdkDragContext // out
	var _cret *C.GtkWidget      // in

	_arg1 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))

	_cret = C.gtk_drag_get_source_widget(_arg1)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// DragSetIconDefault sets the icon for a particular drag to the default icon.
func DragSetIconDefault(context gdk.DragContext) {
	var _arg1 *C.GdkDragContext // out

	_arg1 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))

	C.gtk_drag_set_icon_default(_arg1)
}

// DragSetIconGIcon sets the icon for a given drag from the given @icon. See the
// documentation for gtk_drag_set_icon_name() for more details about using icons
// in drag and drop.
func DragSetIconGIcon(context gdk.DragContext, icon gio.Icon, hotX int, hotY int) {
	var _arg1 *C.GdkDragContext // out
	var _arg2 *C.GIcon          // out
	var _arg3 C.gint            // out
	var _arg4 C.gint            // out

	_arg1 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.GIcon)(unsafe.Pointer(icon.Native()))
	_arg3 = (C.gint)(hotX)
	_arg4 = (C.gint)(hotY)

	C.gtk_drag_set_icon_gicon(_arg1, _arg2, _arg3, _arg4)
}

// DragSetIconName sets the icon for a given drag from a named themed icon. See
// the docs for IconTheme for more details. Note that the size of the icon
// depends on the icon theme (the icon is loaded at the symbolic size
// K_ICON_SIZE_DND), thus @hot_x and @hot_y have to be used with care.
func DragSetIconName(context gdk.DragContext, iconName string, hotX int, hotY int) {
	var _arg1 *C.GdkDragContext // out
	var _arg2 *C.gchar          // out
	var _arg3 C.gint            // out
	var _arg4 C.gint            // out

	_arg1 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.gint)(hotX)
	_arg4 = (C.gint)(hotY)

	C.gtk_drag_set_icon_name(_arg1, _arg2, _arg3, _arg4)
}

// DragSetIconPixbuf sets @pixbuf as the icon for a given drag.
func DragSetIconPixbuf(context gdk.DragContext, pixbuf gdkpixbuf.Pixbuf, hotX int, hotY int) {
	var _arg1 *C.GdkDragContext // out
	var _arg2 *C.GdkPixbuf      // out
	var _arg3 C.gint            // out
	var _arg4 C.gint            // out

	_arg1 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))
	_arg3 = (C.gint)(hotX)
	_arg4 = (C.gint)(hotY)

	C.gtk_drag_set_icon_pixbuf(_arg1, _arg2, _arg3, _arg4)
}

// DragSetIconStock sets the icon for a given drag from a stock ID.
func DragSetIconStock(context gdk.DragContext, stockId string, hotX int, hotY int) {
	var _arg1 *C.GdkDragContext // out
	var _arg2 *C.gchar          // out
	var _arg3 C.gint            // out
	var _arg4 C.gint            // out

	_arg1 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.gchar)(C.CString(stockId))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.gint)(hotX)
	_arg4 = (C.gint)(hotY)

	C.gtk_drag_set_icon_stock(_arg1, _arg2, _arg3, _arg4)
}

// DragSetIconSurface sets @surface as the icon for a given drag. GTK+ retains
// references for the arguments, and will release them when they are no longer
// needed.
//
// To position the surface relative to the mouse, use
// cairo_surface_set_device_offset() on @surface. The mouse cursor will be
// positioned at the (0,0) coordinate of the surface.
func DragSetIconSurface(context gdk.DragContext, surface *cairo.Surface) {
	var _arg1 *C.GdkDragContext  // out
	var _arg2 *C.cairo_surface_t // out

	_arg1 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.cairo_surface_t)(unsafe.Pointer(surface.Native()))

	C.gtk_drag_set_icon_surface(_arg1, _arg2)
}

// DragSetIconWidget changes the icon for drag operation to a given widget. GTK+
// will not destroy the widget, so if you don’t want it to persist, you should
// connect to the “drag-end” signal and destroy it yourself.
func DragSetIconWidget(context gdk.DragContext, widget Widget, hotX int, hotY int) {
	var _arg1 *C.GdkDragContext // out
	var _arg2 *C.GtkWidget      // out
	var _arg3 C.gint            // out
	var _arg4 C.gint            // out

	_arg1 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg3 = (C.gint)(hotX)
	_arg4 = (C.gint)(hotY)

	C.gtk_drag_set_icon_widget(_arg1, _arg2, _arg3, _arg4)
}

// DrawInsertionCursor draws a text caret on @cr at @location. This is not a
// style function but merely a convenience function for drawing the standard
// cursor shape.
func DrawInsertionCursor(widget Widget, cr *cairo.Context, location *gdk.Rectangle, isPrimary bool, direction TextDirection, drawArrow bool) {
	var _arg1 *C.GtkWidget       // out
	var _arg2 *C.cairo_t         // out
	var _arg3 *C.GdkRectangle    // out
	var _arg4 C.gboolean         // out
	var _arg5 C.GtkTextDirection // out
	var _arg6 C.gboolean         // out

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (*C.GdkRectangle)(unsafe.Pointer(location.Native()))
	if isPrimary {
		_arg4 = C.TRUE
	}
	_arg5 = (C.GtkTextDirection)(direction)
	if drawArrow {
		_arg6 = C.TRUE
	}

	C.gtk_draw_insertion_cursor(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}

// EventsPending checks if any events are pending.
//
// This can be used to update the UI and invoke timeouts etc. while doing some
// time intensive computation.
//
// Updating the UI during a long computation
//
//     // computation going on...
//
//     while (gtk_events_pending ())
//       gtk_main_iteration ();
//
//     // ...computation continued
func EventsPending() bool {
	var _cret C.gboolean // in

	_cret = C.gtk_events_pending()

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// False: analogical to gtk_true(), this function does nothing but always
// returns false.
func False() bool {
	var _cret C.gboolean // in

	_cret = C.gtk_false()

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// GetBinaryAge returns the binary age as passed to `libtool` when building the
// GTK+ library the process is running against. If `libtool` means nothing to
// you, don't worry about it.
func GetBinaryAge() uint {
	var _cret C.guint // in

	_cret = C.gtk_get_binary_age()

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// GetCurrentEventDevice: if there is a current event and it has a device,
// return that device, otherwise return nil.
func GetCurrentEventDevice() gdk.Device {
	var _cret *C.GdkDevice // in

	_cret = C.gtk_get_current_event_device()

	var _device gdk.Device // out

	_device = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Device)

	return _device
}

// GetCurrentEventState: if there is a current event and it has a state field,
// place that state field in @state and return true, otherwise return false.
func GetCurrentEventState() (gdk.ModifierType, bool) {
	var _arg1 C.GdkModifierType // in
	var _cret C.gboolean        // in

	_cret = C.gtk_get_current_event_state(&_arg1)

	var _state gdk.ModifierType // out
	var _ok bool                // out

	_state = gdk.ModifierType(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _state, _ok
}

// GetCurrentEventTime: if there is a current event and it has a timestamp,
// return that timestamp, otherwise return GDK_CURRENT_TIME.
func GetCurrentEventTime() uint32 {
	var _cret C.guint32 // in

	_cret = C.gtk_get_current_event_time()

	var _guint32 uint32 // out

	_guint32 = (uint32)(_cret)

	return _guint32
}

// GetDebugFlags returns the GTK+ debug flags.
//
// This function is intended for GTK+ modules that want to adjust their debug
// output based on GTK+ debug flags.
func GetDebugFlags() uint {
	var _cret C.guint // in

	_cret = C.gtk_get_debug_flags()

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// GetDefaultLanguage returns the Language for the default language currently in
// effect. (Note that this can change over the life of an application.) The
// default language is derived from the current locale. It determines, for
// example, whether GTK+ uses the right-to-left or left-to-right text direction.
//
// This function is equivalent to pango_language_get_default(). See that
// function for details.
func GetDefaultLanguage() *pango.Language {
	var _cret *C.PangoLanguage // in

	_cret = C.gtk_get_default_language()

	var _language *pango.Language // out

	_language = pango.WrapLanguage(unsafe.Pointer(_cret))

	return _language
}

// GetInterfaceAge returns the interface age as passed to `libtool` when
// building the GTK+ library the process is running against. If `libtool` means
// nothing to you, don't worry about it.
func GetInterfaceAge() uint {
	var _cret C.guint // in

	_cret = C.gtk_get_interface_age()

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// GetLocaleDirection: get the direction of the current locale. This is the
// expected reading direction for text and UI.
//
// This function depends on the current locale being set with setlocale() and
// will default to setting the GTK_TEXT_DIR_LTR direction otherwise.
// GTK_TEXT_DIR_NONE will never be returned.
//
// GTK+ sets the default text direction according to the locale during
// gtk_init(), and you should normally use gtk_widget_get_direction() or
// gtk_widget_get_default_direction() to obtain the current direcion.
//
// This function is only needed rare cases when the locale is changed after GTK+
// has already been initialized. In this case, you can use it to update the
// default text direction as follows:
//
//    setlocale (LC_ALL, new_locale);
//    direction = gtk_get_locale_direction ();
//    gtk_widget_set_default_direction (direction);
func GetLocaleDirection() TextDirection {
	var _cret C.GtkTextDirection // in

	_cret = C.gtk_get_locale_direction()

	var _textDirection TextDirection // out

	_textDirection = TextDirection(_cret)

	return _textDirection
}

// GetMajorVersion returns the major version number of the GTK+ library. (e.g.
// in GTK+ version 3.1.5 this is 3.)
//
// This function is in the library, so it represents the GTK+ library your code
// is running against. Contrast with the K_MAJOR_VERSION macro, which represents
// the major version of the GTK+ headers you have included when compiling your
// code.
func GetMajorVersion() uint {
	var _cret C.guint // in

	_cret = C.gtk_get_major_version()

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// GetMicroVersion returns the micro version number of the GTK+ library. (e.g.
// in GTK+ version 3.1.5 this is 5.)
//
// This function is in the library, so it represents the GTK+ library your code
// is are running against. Contrast with the K_MICRO_VERSION macro, which
// represents the micro version of the GTK+ headers you have included when
// compiling your code.
func GetMicroVersion() uint {
	var _cret C.guint // in

	_cret = C.gtk_get_micro_version()

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// GetMinorVersion returns the minor version number of the GTK+ library. (e.g.
// in GTK+ version 3.1.5 this is 1.)
//
// This function is in the library, so it represents the GTK+ library your code
// is are running against. Contrast with the K_MINOR_VERSION macro, which
// represents the minor version of the GTK+ headers you have included when
// compiling your code.
func GetMinorVersion() uint {
	var _cret C.guint // in

	_cret = C.gtk_get_minor_version()

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// GetOptionGroup returns a Group for the commandline arguments recognized by
// GTK+ and GDK.
//
// You should add this group to your Context with g_option_context_add_group(),
// if you are using g_option_context_parse() to parse your commandline
// arguments.
func GetOptionGroup(openDefaultDisplay bool) *glib.OptionGroup {
	var _arg1 C.gboolean      // out
	var _cret *C.GOptionGroup // in

	if openDefaultDisplay {
		_arg1 = C.TRUE
	}

	_cret = C.gtk_get_option_group(_arg1)

	var _optionGroup *glib.OptionGroup // out

	_optionGroup = glib.WrapOptionGroup(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_optionGroup, func(v *glib.OptionGroup) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _optionGroup
}

// GrabGetCurrent queries the current grab of the default window group.
func GrabGetCurrent() Widget {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_grab_get_current()

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// KeySnooperRemove removes the key snooper function with the given id.
func KeySnooperRemove(snooperHandlerId uint) {
	var _arg1 C.guint // out

	_arg1 = (C.guint)(snooperHandlerId)

	C.gtk_key_snooper_remove(_arg1)
}

// Main runs the main loop until gtk_main_quit() is called.
//
// You can nest calls to gtk_main(). In that case gtk_main_quit() will make the
// innermost invocation of the main loop return.
func Main() {
	C.gtk_main()
}

// MainIteration runs a single iteration of the mainloop.
//
// If no events are waiting to be processed GTK+ will block until the next event
// is noticed. If you don’t want to block look at gtk_main_iteration_do() or
// check if any events are pending with gtk_events_pending() first.
func MainIteration() bool {
	var _cret C.gboolean // in

	_cret = C.gtk_main_iteration()

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MainIterationDo runs a single iteration of the mainloop. If no events are
// available either return or block depending on the value of @blocking.
func MainIterationDo(blocking bool) bool {
	var _arg1 C.gboolean // out
	var _cret C.gboolean // in

	if blocking {
		_arg1 = C.TRUE
	}

	_cret = C.gtk_main_iteration_do(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MainLevel asks for the current nesting level of the main loop.
func MainLevel() uint {
	var _cret C.guint // in

	_cret = C.gtk_main_level()

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// MainQuit makes the innermost invocation of the main loop return when it
// regains control.
func MainQuit() {
	C.gtk_main_quit()
}

// PaintArrow draws an arrow in the given rectangle on @cr using the given
// parameters. @arrow_type determines the direction of the arrow.
func PaintArrow(style Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget Widget, detail string, arrowType ArrowType, fill bool, x int, y int, width int, height int) {
	var _arg1 *C.GtkStyle     // out
	var _arg2 *C.cairo_t      // out
	var _arg3 C.GtkStateType  // out
	var _arg4 C.GtkShadowType // out
	var _arg5 *C.GtkWidget    // out
	var _arg6 *C.gchar        // out
	var _arg7 C.GtkArrowType  // out
	var _arg8 C.gboolean      // out
	var _arg9 C.gint          // out
	var _arg10 C.gint         // out
	var _arg11 C.gint         // out
	var _arg12 C.gint         // out

	_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.GtkStateType)(stateType)
	_arg4 = (C.GtkShadowType)(shadowType)
	_arg5 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg6 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(_arg6))
	_arg7 = (C.GtkArrowType)(arrowType)
	if fill {
		_arg8 = C.TRUE
	}
	_arg9 = (C.gint)(x)
	_arg10 = (C.gint)(y)
	_arg11 = (C.gint)(width)
	_arg12 = (C.gint)(height)

	C.gtk_paint_arrow(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11, _arg12)
}

// PaintBox draws a box on @cr with the given parameters.
func PaintBox(style Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget Widget, detail string, x int, y int, width int, height int) {
	var _arg1 *C.GtkStyle     // out
	var _arg2 *C.cairo_t      // out
	var _arg3 C.GtkStateType  // out
	var _arg4 C.GtkShadowType // out
	var _arg5 *C.GtkWidget    // out
	var _arg6 *C.gchar        // out
	var _arg7 C.gint          // out
	var _arg8 C.gint          // out
	var _arg9 C.gint          // out
	var _arg10 C.gint         // out

	_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.GtkStateType)(stateType)
	_arg4 = (C.GtkShadowType)(shadowType)
	_arg5 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg6 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(_arg6))
	_arg7 = (C.gint)(x)
	_arg8 = (C.gint)(y)
	_arg9 = (C.gint)(width)
	_arg10 = (C.gint)(height)

	C.gtk_paint_box(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10)
}

// PaintBoxGap draws a box in @cr using the given style and state and shadow
// type, leaving a gap in one side.
func PaintBoxGap(style Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget Widget, detail string, x int, y int, width int, height int, gapSide PositionType, gapX int, gapWidth int) {
	var _arg1 *C.GtkStyle        // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.GtkStateType     // out
	var _arg4 C.GtkShadowType    // out
	var _arg5 *C.GtkWidget       // out
	var _arg6 *C.gchar           // out
	var _arg7 C.gint             // out
	var _arg8 C.gint             // out
	var _arg9 C.gint             // out
	var _arg10 C.gint            // out
	var _arg11 C.GtkPositionType // out
	var _arg12 C.gint            // out
	var _arg13 C.gint            // out

	_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.GtkStateType)(stateType)
	_arg4 = (C.GtkShadowType)(shadowType)
	_arg5 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg6 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(_arg6))
	_arg7 = (C.gint)(x)
	_arg8 = (C.gint)(y)
	_arg9 = (C.gint)(width)
	_arg10 = (C.gint)(height)
	_arg11 = (C.GtkPositionType)(gapSide)
	_arg12 = (C.gint)(gapX)
	_arg13 = (C.gint)(gapWidth)

	C.gtk_paint_box_gap(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11, _arg12, _arg13)
}

// PaintCheck draws a check button indicator in the given rectangle on @cr with
// the given parameters.
func PaintCheck(style Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget Widget, detail string, x int, y int, width int, height int) {
	var _arg1 *C.GtkStyle     // out
	var _arg2 *C.cairo_t      // out
	var _arg3 C.GtkStateType  // out
	var _arg4 C.GtkShadowType // out
	var _arg5 *C.GtkWidget    // out
	var _arg6 *C.gchar        // out
	var _arg7 C.gint          // out
	var _arg8 C.gint          // out
	var _arg9 C.gint          // out
	var _arg10 C.gint         // out

	_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.GtkStateType)(stateType)
	_arg4 = (C.GtkShadowType)(shadowType)
	_arg5 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg6 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(_arg6))
	_arg7 = (C.gint)(x)
	_arg8 = (C.gint)(y)
	_arg9 = (C.gint)(width)
	_arg10 = (C.gint)(height)

	C.gtk_paint_check(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10)
}

// PaintDiamond draws a diamond in the given rectangle on @window using the
// given parameters.
func PaintDiamond(style Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget Widget, detail string, x int, y int, width int, height int) {
	var _arg1 *C.GtkStyle     // out
	var _arg2 *C.cairo_t      // out
	var _arg3 C.GtkStateType  // out
	var _arg4 C.GtkShadowType // out
	var _arg5 *C.GtkWidget    // out
	var _arg6 *C.gchar        // out
	var _arg7 C.gint          // out
	var _arg8 C.gint          // out
	var _arg9 C.gint          // out
	var _arg10 C.gint         // out

	_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.GtkStateType)(stateType)
	_arg4 = (C.GtkShadowType)(shadowType)
	_arg5 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg6 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(_arg6))
	_arg7 = (C.gint)(x)
	_arg8 = (C.gint)(y)
	_arg9 = (C.gint)(width)
	_arg10 = (C.gint)(height)

	C.gtk_paint_diamond(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10)
}

// PaintExpander draws an expander as used in TreeView. @x and @y specify the
// center the expander. The size of the expander is determined by the
// “expander-size” style property of @widget. (If widget is not specified or
// doesn’t have an “expander-size” property, an unspecified default size will be
// used, since the caller doesn't have sufficient information to position the
// expander, this is likely not useful.) The expander is expander_size pixels
// tall in the collapsed position and expander_size pixels wide in the expanded
// position.
func PaintExpander(style Style, cr *cairo.Context, stateType StateType, widget Widget, detail string, x int, y int, expanderStyle ExpanderStyle) {
	var _arg1 *C.GtkStyle        // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.GtkStateType     // out
	var _arg4 *C.GtkWidget       // out
	var _arg5 *C.gchar           // out
	var _arg6 C.gint             // out
	var _arg7 C.gint             // out
	var _arg8 C.GtkExpanderStyle // out

	_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.GtkStateType)(stateType)
	_arg4 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg5 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(_arg5))
	_arg6 = (C.gint)(x)
	_arg7 = (C.gint)(y)
	_arg8 = (C.GtkExpanderStyle)(expanderStyle)

	C.gtk_paint_expander(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
}

// PaintExtension draws an extension, i.e. a notebook tab.
func PaintExtension(style Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget Widget, detail string, x int, y int, width int, height int, gapSide PositionType) {
	var _arg1 *C.GtkStyle        // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.GtkStateType     // out
	var _arg4 C.GtkShadowType    // out
	var _arg5 *C.GtkWidget       // out
	var _arg6 *C.gchar           // out
	var _arg7 C.gint             // out
	var _arg8 C.gint             // out
	var _arg9 C.gint             // out
	var _arg10 C.gint            // out
	var _arg11 C.GtkPositionType // out

	_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.GtkStateType)(stateType)
	_arg4 = (C.GtkShadowType)(shadowType)
	_arg5 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg6 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(_arg6))
	_arg7 = (C.gint)(x)
	_arg8 = (C.gint)(y)
	_arg9 = (C.gint)(width)
	_arg10 = (C.gint)(height)
	_arg11 = (C.GtkPositionType)(gapSide)

	C.gtk_paint_extension(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11)
}

// PaintFlatBox draws a flat box on @cr with the given parameters.
func PaintFlatBox(style Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget Widget, detail string, x int, y int, width int, height int) {
	var _arg1 *C.GtkStyle     // out
	var _arg2 *C.cairo_t      // out
	var _arg3 C.GtkStateType  // out
	var _arg4 C.GtkShadowType // out
	var _arg5 *C.GtkWidget    // out
	var _arg6 *C.gchar        // out
	var _arg7 C.gint          // out
	var _arg8 C.gint          // out
	var _arg9 C.gint          // out
	var _arg10 C.gint         // out

	_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.GtkStateType)(stateType)
	_arg4 = (C.GtkShadowType)(shadowType)
	_arg5 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg6 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(_arg6))
	_arg7 = (C.gint)(x)
	_arg8 = (C.gint)(y)
	_arg9 = (C.gint)(width)
	_arg10 = (C.gint)(height)

	C.gtk_paint_flat_box(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10)
}

// PaintFocus draws a focus indicator around the given rectangle on @cr using
// the given style.
func PaintFocus(style Style, cr *cairo.Context, stateType StateType, widget Widget, detail string, x int, y int, width int, height int) {
	var _arg1 *C.GtkStyle    // out
	var _arg2 *C.cairo_t     // out
	var _arg3 C.GtkStateType // out
	var _arg4 *C.GtkWidget   // out
	var _arg5 *C.gchar       // out
	var _arg6 C.gint         // out
	var _arg7 C.gint         // out
	var _arg8 C.gint         // out
	var _arg9 C.gint         // out

	_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.GtkStateType)(stateType)
	_arg4 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg5 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(_arg5))
	_arg6 = (C.gint)(x)
	_arg7 = (C.gint)(y)
	_arg8 = (C.gint)(width)
	_arg9 = (C.gint)(height)

	C.gtk_paint_focus(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9)
}

// PaintHandle draws a handle as used in HandleBox and Paned.
func PaintHandle(style Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget Widget, detail string, x int, y int, width int, height int, orientation Orientation) {
	var _arg1 *C.GtkStyle       // out
	var _arg2 *C.cairo_t        // out
	var _arg3 C.GtkStateType    // out
	var _arg4 C.GtkShadowType   // out
	var _arg5 *C.GtkWidget      // out
	var _arg6 *C.gchar          // out
	var _arg7 C.gint            // out
	var _arg8 C.gint            // out
	var _arg9 C.gint            // out
	var _arg10 C.gint           // out
	var _arg11 C.GtkOrientation // out

	_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.GtkStateType)(stateType)
	_arg4 = (C.GtkShadowType)(shadowType)
	_arg5 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg6 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(_arg6))
	_arg7 = (C.gint)(x)
	_arg8 = (C.gint)(y)
	_arg9 = (C.gint)(width)
	_arg10 = (C.gint)(height)
	_arg11 = (C.GtkOrientation)(orientation)

	C.gtk_paint_handle(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11)
}

// PaintHline draws a horizontal line from (@x1, @y) to (@x2, @y) in @cr using
// the given style and state.
func PaintHline(style Style, cr *cairo.Context, stateType StateType, widget Widget, detail string, x1 int, x2 int, y int) {
	var _arg1 *C.GtkStyle    // out
	var _arg2 *C.cairo_t     // out
	var _arg3 C.GtkStateType // out
	var _arg4 *C.GtkWidget   // out
	var _arg5 *C.gchar       // out
	var _arg6 C.gint         // out
	var _arg7 C.gint         // out
	var _arg8 C.gint         // out

	_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.GtkStateType)(stateType)
	_arg4 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg5 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(_arg5))
	_arg6 = (C.gint)(x1)
	_arg7 = (C.gint)(x2)
	_arg8 = (C.gint)(y)

	C.gtk_paint_hline(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
}

// PaintLayout draws a layout on @cr using the given parameters.
func PaintLayout(style Style, cr *cairo.Context, stateType StateType, useText bool, widget Widget, detail string, x int, y int, layout pango.Layout) {
	var _arg1 *C.GtkStyle    // out
	var _arg2 *C.cairo_t     // out
	var _arg3 C.GtkStateType // out
	var _arg4 C.gboolean     // out
	var _arg5 *C.GtkWidget   // out
	var _arg6 *C.gchar       // out
	var _arg7 C.gint         // out
	var _arg8 C.gint         // out
	var _arg9 *C.PangoLayout // out

	_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.GtkStateType)(stateType)
	if useText {
		_arg4 = C.TRUE
	}
	_arg5 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg6 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(_arg6))
	_arg7 = (C.gint)(x)
	_arg8 = (C.gint)(y)
	_arg9 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	C.gtk_paint_layout(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9)
}

// PaintOption draws a radio button indicator in the given rectangle on @cr with
// the given parameters.
func PaintOption(style Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget Widget, detail string, x int, y int, width int, height int) {
	var _arg1 *C.GtkStyle     // out
	var _arg2 *C.cairo_t      // out
	var _arg3 C.GtkStateType  // out
	var _arg4 C.GtkShadowType // out
	var _arg5 *C.GtkWidget    // out
	var _arg6 *C.gchar        // out
	var _arg7 C.gint          // out
	var _arg8 C.gint          // out
	var _arg9 C.gint          // out
	var _arg10 C.gint         // out

	_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.GtkStateType)(stateType)
	_arg4 = (C.GtkShadowType)(shadowType)
	_arg5 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg6 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(_arg6))
	_arg7 = (C.gint)(x)
	_arg8 = (C.gint)(y)
	_arg9 = (C.gint)(width)
	_arg10 = (C.gint)(height)

	C.gtk_paint_option(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10)
}

// PaintResizeGrip draws a resize grip in the given rectangle on @cr using the
// given parameters.
func PaintResizeGrip(style Style, cr *cairo.Context, stateType StateType, widget Widget, detail string, edge gdk.WindowEdge, x int, y int, width int, height int) {
	var _arg1 *C.GtkStyle     // out
	var _arg2 *C.cairo_t      // out
	var _arg3 C.GtkStateType  // out
	var _arg4 *C.GtkWidget    // out
	var _arg5 *C.gchar        // out
	var _arg6 C.GdkWindowEdge // out
	var _arg7 C.gint          // out
	var _arg8 C.gint          // out
	var _arg9 C.gint          // out
	var _arg10 C.gint         // out

	_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.GtkStateType)(stateType)
	_arg4 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg5 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(_arg5))
	_arg6 = (C.GdkWindowEdge)(edge)
	_arg7 = (C.gint)(x)
	_arg8 = (C.gint)(y)
	_arg9 = (C.gint)(width)
	_arg10 = (C.gint)(height)

	C.gtk_paint_resize_grip(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10)
}

// PaintShadow draws a shadow around the given rectangle in @cr using the given
// style and state and shadow type.
func PaintShadow(style Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget Widget, detail string, x int, y int, width int, height int) {
	var _arg1 *C.GtkStyle     // out
	var _arg2 *C.cairo_t      // out
	var _arg3 C.GtkStateType  // out
	var _arg4 C.GtkShadowType // out
	var _arg5 *C.GtkWidget    // out
	var _arg6 *C.gchar        // out
	var _arg7 C.gint          // out
	var _arg8 C.gint          // out
	var _arg9 C.gint          // out
	var _arg10 C.gint         // out

	_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.GtkStateType)(stateType)
	_arg4 = (C.GtkShadowType)(shadowType)
	_arg5 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg6 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(_arg6))
	_arg7 = (C.gint)(x)
	_arg8 = (C.gint)(y)
	_arg9 = (C.gint)(width)
	_arg10 = (C.gint)(height)

	C.gtk_paint_shadow(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10)
}

// PaintShadowGap draws a shadow around the given rectangle in @cr using the
// given style and state and shadow type, leaving a gap in one side.
func PaintShadowGap(style Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget Widget, detail string, x int, y int, width int, height int, gapSide PositionType, gapX int, gapWidth int) {
	var _arg1 *C.GtkStyle        // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.GtkStateType     // out
	var _arg4 C.GtkShadowType    // out
	var _arg5 *C.GtkWidget       // out
	var _arg6 *C.gchar           // out
	var _arg7 C.gint             // out
	var _arg8 C.gint             // out
	var _arg9 C.gint             // out
	var _arg10 C.gint            // out
	var _arg11 C.GtkPositionType // out
	var _arg12 C.gint            // out
	var _arg13 C.gint            // out

	_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.GtkStateType)(stateType)
	_arg4 = (C.GtkShadowType)(shadowType)
	_arg5 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg6 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(_arg6))
	_arg7 = (C.gint)(x)
	_arg8 = (C.gint)(y)
	_arg9 = (C.gint)(width)
	_arg10 = (C.gint)(height)
	_arg11 = (C.GtkPositionType)(gapSide)
	_arg12 = (C.gint)(gapX)
	_arg13 = (C.gint)(gapWidth)

	C.gtk_paint_shadow_gap(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11, _arg12, _arg13)
}

// PaintSlider draws a slider in the given rectangle on @cr using the given
// style and orientation.
func PaintSlider(style Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget Widget, detail string, x int, y int, width int, height int, orientation Orientation) {
	var _arg1 *C.GtkStyle       // out
	var _arg2 *C.cairo_t        // out
	var _arg3 C.GtkStateType    // out
	var _arg4 C.GtkShadowType   // out
	var _arg5 *C.GtkWidget      // out
	var _arg6 *C.gchar          // out
	var _arg7 C.gint            // out
	var _arg8 C.gint            // out
	var _arg9 C.gint            // out
	var _arg10 C.gint           // out
	var _arg11 C.GtkOrientation // out

	_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.GtkStateType)(stateType)
	_arg4 = (C.GtkShadowType)(shadowType)
	_arg5 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg6 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(_arg6))
	_arg7 = (C.gint)(x)
	_arg8 = (C.gint)(y)
	_arg9 = (C.gint)(width)
	_arg10 = (C.gint)(height)
	_arg11 = (C.GtkOrientation)(orientation)

	C.gtk_paint_slider(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11)
}

// PaintSpinner draws a spinner on @window using the given parameters.
func PaintSpinner(style Style, cr *cairo.Context, stateType StateType, widget Widget, detail string, step uint, x int, y int, width int, height int) {
	var _arg1 *C.GtkStyle    // out
	var _arg2 *C.cairo_t     // out
	var _arg3 C.GtkStateType // out
	var _arg4 *C.GtkWidget   // out
	var _arg5 *C.gchar       // out
	var _arg6 C.guint        // out
	var _arg7 C.gint         // out
	var _arg8 C.gint         // out
	var _arg9 C.gint         // out
	var _arg10 C.gint        // out

	_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.GtkStateType)(stateType)
	_arg4 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg5 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(_arg5))
	_arg6 = (C.guint)(step)
	_arg7 = (C.gint)(x)
	_arg8 = (C.gint)(y)
	_arg9 = (C.gint)(width)
	_arg10 = (C.gint)(height)

	C.gtk_paint_spinner(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10)
}

// PaintTab draws an option menu tab (i.e. the up and down pointing arrows) in
// the given rectangle on @cr using the given parameters.
func PaintTab(style Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget Widget, detail string, x int, y int, width int, height int) {
	var _arg1 *C.GtkStyle     // out
	var _arg2 *C.cairo_t      // out
	var _arg3 C.GtkStateType  // out
	var _arg4 C.GtkShadowType // out
	var _arg5 *C.GtkWidget    // out
	var _arg6 *C.gchar        // out
	var _arg7 C.gint          // out
	var _arg8 C.gint          // out
	var _arg9 C.gint          // out
	var _arg10 C.gint         // out

	_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.GtkStateType)(stateType)
	_arg4 = (C.GtkShadowType)(shadowType)
	_arg5 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg6 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(_arg6))
	_arg7 = (C.gint)(x)
	_arg8 = (C.gint)(y)
	_arg9 = (C.gint)(width)
	_arg10 = (C.gint)(height)

	C.gtk_paint_tab(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10)
}

// PaintVline draws a vertical line from (@x, @y1_) to (@x, @y2_) in @cr using
// the given style and state.
func PaintVline(style Style, cr *cairo.Context, stateType StateType, widget Widget, detail string, y1 int, y2 int, x int) {
	var _arg1 *C.GtkStyle    // out
	var _arg2 *C.cairo_t     // out
	var _arg3 C.GtkStateType // out
	var _arg4 *C.GtkWidget   // out
	var _arg5 *C.gchar       // out
	var _arg6 C.gint         // out
	var _arg7 C.gint         // out
	var _arg8 C.gint         // out

	_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.GtkStateType)(stateType)
	_arg4 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg5 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(_arg5))
	_arg6 = (C.gint)(y1)
	_arg7 = (C.gint)(y2)
	_arg8 = (C.gint)(x)

	C.gtk_paint_vline(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
}

// PrintRunPageSetupDialog runs a page setup dialog, letting the user modify the
// values from @page_setup. If the user cancels the dialog, the returned
// PageSetup is identical to the passed in @page_setup, otherwise it contains
// the modifications done in the dialog.
//
// Note that this function may use a recursive mainloop to show the page setup
// dialog. See gtk_print_run_page_setup_dialog_async() if this is a problem.
func PrintRunPageSetupDialog(parent Window, pageSetup PageSetup, settings PrintSettings) PageSetup {
	var _arg1 *C.GtkWindow        // out
	var _arg2 *C.GtkPageSetup     // out
	var _arg3 *C.GtkPrintSettings // out
	var _cret *C.GtkPageSetup     // in

	_arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))
	_arg2 = (*C.GtkPageSetup)(unsafe.Pointer(pageSetup.Native()))
	_arg3 = (*C.GtkPrintSettings)(unsafe.Pointer(settings.Native()))

	_cret = C.gtk_print_run_page_setup_dialog(_arg1, _arg2, _arg3)

	var _pageSetup PageSetup // out

	_pageSetup = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(PageSetup)

	return _pageSetup
}

// RCAddDefaultFile adds a file to the list of files to be parsed at the end of
// gtk_init().
func RCAddDefaultFile(filename string) {
	var _arg1 *C.gchar // out

	_arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_rc_add_default_file(_arg1)
}

// RCFindModuleInPath searches for a theme engine in the GTK+ search path. This
// function is not useful for applications and should not be used.
func RCFindModuleInPath(moduleFile string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(C.CString(moduleFile))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_rc_find_module_in_path(_arg1)

	var _filename string // out

	_filename = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _filename
}

// RCFindPixmapInPath looks up a file in pixmap path for the specified Settings.
// If the file is not found, it outputs a warning message using g_warning() and
// returns nil.
func RCFindPixmapInPath(settings Settings, scanner *glib.Scanner, pixmapFile string) string {
	var _arg1 *C.GtkSettings // out
	var _arg2 *C.GScanner    // out
	var _arg3 *C.gchar       // out
	var _cret *C.gchar       // in

	_arg1 = (*C.GtkSettings)(unsafe.Pointer(settings.Native()))
	_arg2 = (*C.GScanner)(unsafe.Pointer(scanner.Native()))
	_arg3 = (*C.gchar)(C.CString(pixmapFile))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.gtk_rc_find_pixmap_in_path(_arg1, _arg2, _arg3)

	var _filename string // out

	_filename = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _filename
}

// RCGetDefaultFiles retrieves the current list of RC files that will be parsed
// at the end of gtk_init().
func RCGetDefaultFiles() []string {
	var _cret **C.gchar

	_cret = C.gtk_rc_get_default_files()

	var _filenames []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_filenames = make([]string, i)
		for i := range src {
			_filenames[i] = C.GoString(src[i])
		}
	}

	return _filenames
}

// RCGetImModuleFile obtains the path to the IM modules file. See the
// documentation of the `GTK_IM_MODULE_FILE` environment variable for more
// details.
func RCGetImModuleFile() string {
	var _cret *C.gchar // in

	_cret = C.gtk_rc_get_im_module_file()

	var _filename string // out

	_filename = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _filename
}

// RCGetImModulePath obtains the path in which to look for IM modules. See the
// documentation of the `GTK_PATH` environment variable for more details about
// looking up modules. This function is useful solely for utilities supplied
// with GTK+ and should not be used by applications under normal circumstances.
func RCGetImModulePath() string {
	var _cret *C.gchar // in

	_cret = C.gtk_rc_get_im_module_path()

	var _filename string // out

	_filename = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _filename
}

// RCGetModuleDir returns a directory in which GTK+ looks for theme engines. For
// full information about the search for theme engines, see the docs for
// `GTK_PATH` in [Running GTK+ Applications][gtk-running].
func RCGetModuleDir() string {
	var _cret *C.gchar // in

	_cret = C.gtk_rc_get_module_dir()

	var _filename string // out

	_filename = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _filename
}

// RCGetStyle finds all matching RC styles for a given widget, composites them
// together, and then creates a Style representing the composite appearance.
// (GTK+ actually keeps a cache of previously created styles, so a new style may
// not be created.)
func RCGetStyle(widget Widget) Style {
	var _arg1 *C.GtkWidget // out
	var _cret *C.GtkStyle  // in

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	_cret = C.gtk_rc_get_style(_arg1)

	var _style Style // out

	_style = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Style)

	return _style
}

// RCGetStyleByPaths creates up a Style from styles defined in a RC file by
// providing the raw components used in matching. This function may be useful
// when creating pseudo-widgets that should be themed like widgets but don’t
// actually have corresponding GTK+ widgets. An example of this would be items
// inside a GNOME canvas widget.
//
// The action of gtk_rc_get_style() is similar to:
//
//    gtk_widget_path (widget, NULL, &path, NULL);
//    gtk_widget_class_path (widget, NULL, &class_path, NULL);
//    gtk_rc_get_style_by_paths (gtk_widget_get_settings (widget),
//                               path, class_path,
//                               G_OBJECT_TYPE (widget));
func RCGetStyleByPaths(settings Settings, widgetPath string, classPath string, typ externglib.Type) Style {
	var _arg1 *C.GtkSettings // out
	var _arg2 *C.char        // out
	var _arg3 *C.char        // out
	var _arg4 C.GType        // out
	var _cret *C.GtkStyle    // in

	_arg1 = (*C.GtkSettings)(unsafe.Pointer(settings.Native()))
	_arg2 = (*C.char)(C.CString(widgetPath))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.char)(C.CString(classPath))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = C.GType(typ)

	_cret = C.gtk_rc_get_style_by_paths(_arg1, _arg2, _arg3, _arg4)

	var _style Style // out

	_style = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Style)

	return _style
}

// RCGetThemeDir returns the standard directory in which themes should be
// installed. (GTK+ does not actually use this directory itself.)
func RCGetThemeDir() string {
	var _cret *C.gchar // in

	_cret = C.gtk_rc_get_theme_dir()

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// RCParse parses a given resource file.
func RCParse(filename string) {
	var _arg1 *C.gchar // out

	_arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_rc_parse(_arg1)
}

// RCParseColor parses a color in the format expected in a RC file.
//
// Note that theme engines should use gtk_rc_parse_color_full() in order to
// support symbolic colors.
func RCParseColor(scanner *glib.Scanner) (gdk.Color, uint) {
	var _arg1 *C.GScanner // out
	var _color gdk.Color
	var _cret C.guint // in

	_arg1 = (*C.GScanner)(unsafe.Pointer(scanner.Native()))

	_cret = C.gtk_rc_parse_color(_arg1, (*C.GdkColor)(unsafe.Pointer(&_color)))

	var _guint uint // out

	_guint = (uint)(_cret)

	return _color, _guint
}

// RCParseColorFull parses a color in the format expected in a RC file. If
// @style is not nil, it will be consulted to resolve references to symbolic
// colors.
func RCParseColorFull(scanner *glib.Scanner, style RCStyle) (gdk.Color, uint) {
	var _arg1 *C.GScanner   // out
	var _arg2 *C.GtkRcStyle // out
	var _color gdk.Color
	var _cret C.guint // in

	_arg1 = (*C.GScanner)(unsafe.Pointer(scanner.Native()))
	_arg2 = (*C.GtkRcStyle)(unsafe.Pointer(style.Native()))

	_cret = C.gtk_rc_parse_color_full(_arg1, _arg2, (*C.GdkColor)(unsafe.Pointer(&_color)))

	var _guint uint // out

	_guint = (uint)(_cret)

	return _color, _guint
}

// RCParsePriority parses a PathPriorityType variable from the format expected
// in a RC file.
func RCParsePriority(scanner *glib.Scanner, priority *PathPriorityType) uint {
	var _arg1 *C.GScanner            // out
	var _arg2 *C.GtkPathPriorityType // out
	var _cret C.guint                // in

	_arg1 = (*C.GScanner)(unsafe.Pointer(scanner.Native()))
	_arg2 = (*C.GtkPathPriorityType)(unsafe.Pointer(priority))

	_cret = C.gtk_rc_parse_priority(_arg1, _arg2)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// RCParseState parses a StateType variable from the format expected in a RC
// file.
func RCParseState(scanner *glib.Scanner) (StateType, uint) {
	var _arg1 *C.GScanner    // out
	var _arg2 C.GtkStateType // in
	var _cret C.guint        // in

	_arg1 = (*C.GScanner)(unsafe.Pointer(scanner.Native()))

	_cret = C.gtk_rc_parse_state(_arg1, &_arg2)

	var _state StateType // out
	var _guint uint      // out

	_state = StateType(_arg2)
	_guint = (uint)(_cret)

	return _state, _guint
}

// RCParseString parses resource information directly from a string.
func RCParseString(rcString string) {
	var _arg1 *C.gchar // out

	_arg1 = (*C.gchar)(C.CString(rcString))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_rc_parse_string(_arg1)
}

// RCReparseAll: if the modification time on any previously read file for the
// default Settings has changed, discard all style information and then reread
// all previously read RC files.
func RCReparseAll() bool {
	var _cret C.gboolean // in

	_cret = C.gtk_rc_reparse_all()

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RCReparseAllForSettings: if the modification time on any previously read file
// for the given Settings has changed, discard all style information and then
// reread all previously read RC files.
func RCReparseAllForSettings(settings Settings, forceLoad bool) bool {
	var _arg1 *C.GtkSettings // out
	var _arg2 C.gboolean     // out
	var _cret C.gboolean     // in

	_arg1 = (*C.GtkSettings)(unsafe.Pointer(settings.Native()))
	if forceLoad {
		_arg2 = C.TRUE
	}

	_cret = C.gtk_rc_reparse_all_for_settings(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RCResetStyles: this function recomputes the styles for all widgets that use a
// particular Settings object. (There is one Settings object per Screen, see
// gtk_settings_get_for_screen()); It is useful when some global parameter has
// changed that affects the appearance of all widgets, because when a widget
// gets a new style, it will both redraw and recompute any cached information
// about its appearance. As an example, it is used when the default font size
// set by the operating system changes. Note that this function doesn’t affect
// widgets that have a style set explicitly on them with gtk_widget_set_style().
func RCResetStyles(settings Settings) {
	var _arg1 *C.GtkSettings // out

	_arg1 = (*C.GtkSettings)(unsafe.Pointer(settings.Native()))

	C.gtk_rc_reset_styles(_arg1)
}

// RCSetDefaultFiles sets the list of files that GTK+ will read at the end of
// gtk_init().
func RCSetDefaultFiles(filenames []string) {
	var _arg1 **C.gchar

	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(filenames)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(filenames))
		for i := range filenames {
			out[i] = (*C.gchar)(C.CString(filenames[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.gtk_rc_set_default_files(_arg1)
}

// RenderActivity renders an activity indicator (such as in Spinner). The state
// GTK_STATE_FLAG_CHECKED determines whether there is activity going on.
func RenderActivity(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.gdouble          // out
	var _arg4 C.gdouble          // out
	var _arg5 C.gdouble          // out
	var _arg6 C.gdouble          // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.gdouble)(x)
	_arg4 = (C.gdouble)(y)
	_arg5 = (C.gdouble)(width)
	_arg6 = (C.gdouble)(height)

	C.gtk_render_activity(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}

// RenderArrow renders an arrow pointing to @angle.
//
// Typical arrow rendering at 0, 1⁄2 π;, π; and 3⁄2 π:
//
// ! (arrows.png)
func RenderArrow(context StyleContext, cr *cairo.Context, angle float64, x float64, y float64, size float64) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.gdouble          // out
	var _arg4 C.gdouble          // out
	var _arg5 C.gdouble          // out
	var _arg6 C.gdouble          // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.gdouble)(angle)
	_arg4 = (C.gdouble)(x)
	_arg5 = (C.gdouble)(y)
	_arg6 = (C.gdouble)(size)

	C.gtk_render_arrow(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}

// RenderBackground renders the background of an element.
//
// Typical background rendering, showing the effect of `background-image`,
// `border-width` and `border-radius`:
//
// ! (background.png)
func RenderBackground(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.gdouble          // out
	var _arg4 C.gdouble          // out
	var _arg5 C.gdouble          // out
	var _arg6 C.gdouble          // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.gdouble)(x)
	_arg4 = (C.gdouble)(y)
	_arg5 = (C.gdouble)(width)
	_arg6 = (C.gdouble)(height)

	C.gtk_render_background(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}

// RenderBackgroundGetClip returns the area that will be affected (i.e. drawn
// to) when calling gtk_render_background() for the given @context and
// rectangle.
func RenderBackgroundGetClip(context StyleContext, x float64, y float64, width float64, height float64) gdk.Rectangle {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 C.gdouble          // out
	var _arg3 C.gdouble          // out
	var _arg4 C.gdouble          // out
	var _arg5 C.gdouble          // out
	var _outClip gdk.Rectangle

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (C.gdouble)(x)
	_arg3 = (C.gdouble)(y)
	_arg4 = (C.gdouble)(width)
	_arg5 = (C.gdouble)(height)

	C.gtk_render_background_get_clip(_arg1, _arg2, _arg3, _arg4, _arg5, (*C.GdkRectangle)(unsafe.Pointer(&_outClip)))

	return _outClip
}

// RenderCheck renders a checkmark (as in a CheckButton).
//
// The GTK_STATE_FLAG_CHECKED state determines whether the check is on or off,
// and GTK_STATE_FLAG_INCONSISTENT determines whether it should be marked as
// undefined.
//
// Typical checkmark rendering:
//
// ! (checks.png)
func RenderCheck(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.gdouble          // out
	var _arg4 C.gdouble          // out
	var _arg5 C.gdouble          // out
	var _arg6 C.gdouble          // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.gdouble)(x)
	_arg4 = (C.gdouble)(y)
	_arg5 = (C.gdouble)(width)
	_arg6 = (C.gdouble)(height)

	C.gtk_render_check(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}

// RenderExpander renders an expander (as used in TreeView and Expander) in the
// area defined by @x, @y, @width, @height. The state GTK_STATE_FLAG_CHECKED
// determines whether the expander is collapsed or expanded.
//
// Typical expander rendering:
//
// ! (expanders.png)
func RenderExpander(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.gdouble          // out
	var _arg4 C.gdouble          // out
	var _arg5 C.gdouble          // out
	var _arg6 C.gdouble          // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.gdouble)(x)
	_arg4 = (C.gdouble)(y)
	_arg5 = (C.gdouble)(width)
	_arg6 = (C.gdouble)(height)

	C.gtk_render_expander(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}

// RenderExtension renders a extension (as in a Notebook tab) in the rectangle
// defined by @x, @y, @width, @height. The side where the extension connects to
// is defined by @gap_side.
//
// Typical extension rendering:
//
// ! (extensions.png)
func RenderExtension(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64, gapSide PositionType) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.gdouble          // out
	var _arg4 C.gdouble          // out
	var _arg5 C.gdouble          // out
	var _arg6 C.gdouble          // out
	var _arg7 C.GtkPositionType  // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.gdouble)(x)
	_arg4 = (C.gdouble)(y)
	_arg5 = (C.gdouble)(width)
	_arg6 = (C.gdouble)(height)
	_arg7 = (C.GtkPositionType)(gapSide)

	C.gtk_render_extension(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
}

// RenderFocus renders a focus indicator on the rectangle determined by @x, @y,
// @width, @height.
//
// Typical focus rendering:
//
// ! (focus.png)
func RenderFocus(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.gdouble          // out
	var _arg4 C.gdouble          // out
	var _arg5 C.gdouble          // out
	var _arg6 C.gdouble          // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.gdouble)(x)
	_arg4 = (C.gdouble)(y)
	_arg5 = (C.gdouble)(width)
	_arg6 = (C.gdouble)(height)

	C.gtk_render_focus(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}

// RenderFrame renders a frame around the rectangle defined by @x, @y, @width,
// @height.
//
// Examples of frame rendering, showing the effect of `border-image`,
// `border-color`, `border-width`, `border-radius` and junctions:
//
// ! (frames.png)
func RenderFrame(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.gdouble          // out
	var _arg4 C.gdouble          // out
	var _arg5 C.gdouble          // out
	var _arg6 C.gdouble          // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.gdouble)(x)
	_arg4 = (C.gdouble)(y)
	_arg5 = (C.gdouble)(width)
	_arg6 = (C.gdouble)(height)

	C.gtk_render_frame(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}

// RenderFrameGap renders a frame around the rectangle defined by (@x, @y,
// @width, @height), leaving a gap on one side. @xy0_gap and @xy1_gap will mean
// X coordinates for GTK_POS_TOP and GTK_POS_BOTTOM gap sides, and Y coordinates
// for GTK_POS_LEFT and GTK_POS_RIGHT.
//
// Typical rendering of a frame with a gap:
//
// ! (frame-gap.png)
func RenderFrameGap(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64, gapSide PositionType, xy0Gap float64, xy1Gap float64) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.gdouble          // out
	var _arg4 C.gdouble          // out
	var _arg5 C.gdouble          // out
	var _arg6 C.gdouble          // out
	var _arg7 C.GtkPositionType  // out
	var _arg8 C.gdouble          // out
	var _arg9 C.gdouble          // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.gdouble)(x)
	_arg4 = (C.gdouble)(y)
	_arg5 = (C.gdouble)(width)
	_arg6 = (C.gdouble)(height)
	_arg7 = (C.GtkPositionType)(gapSide)
	_arg8 = (C.gdouble)(xy0Gap)
	_arg9 = (C.gdouble)(xy1Gap)

	C.gtk_render_frame_gap(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9)
}

// RenderHandle renders a handle (as in HandleBox, Paned and Window’s resize
// grip), in the rectangle determined by @x, @y, @width, @height.
//
// Handles rendered for the paned and grip classes:
//
// ! (handles.png)
func RenderHandle(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.gdouble          // out
	var _arg4 C.gdouble          // out
	var _arg5 C.gdouble          // out
	var _arg6 C.gdouble          // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.gdouble)(x)
	_arg4 = (C.gdouble)(y)
	_arg5 = (C.gdouble)(width)
	_arg6 = (C.gdouble)(height)

	C.gtk_render_handle(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}

// RenderIcon renders the icon in @pixbuf at the specified @x and @y
// coordinates.
//
// This function will render the icon in @pixbuf at exactly its size, regardless
// of scaling factors, which may not be appropriate when drawing on displays
// with high pixel densities.
//
// You probably want to use gtk_render_icon_surface() instead, if you already
// have a Cairo surface.
func RenderIcon(context StyleContext, cr *cairo.Context, pixbuf gdkpixbuf.Pixbuf, x float64, y float64) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 *C.GdkPixbuf       // out
	var _arg4 C.gdouble          // out
	var _arg5 C.gdouble          // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))
	_arg4 = (C.gdouble)(x)
	_arg5 = (C.gdouble)(y)

	C.gtk_render_icon(_arg1, _arg2, _arg3, _arg4, _arg5)
}

// RenderIconPixbuf renders the icon specified by @source at the given @size,
// returning the result in a pixbuf.
func RenderIconPixbuf(context StyleContext, source *IconSource, size int) gdkpixbuf.Pixbuf {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.GtkIconSource   // out
	var _arg3 C.GtkIconSize      // out
	var _cret *C.GdkPixbuf       // in

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.GtkIconSource)(unsafe.Pointer(source.Native()))
	_arg3 = (C.GtkIconSize)(size)

	_cret = C.gtk_render_icon_pixbuf(_arg1, _arg2, _arg3)

	var _pixbuf gdkpixbuf.Pixbuf // out

	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

	return _pixbuf
}

// RenderIconSurface renders the icon in @surface at the specified @x and @y
// coordinates.
func RenderIconSurface(context StyleContext, cr *cairo.Context, surface *cairo.Surface, x float64, y float64) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 *C.cairo_surface_t // out
	var _arg4 C.gdouble          // out
	var _arg5 C.gdouble          // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (*C.cairo_surface_t)(unsafe.Pointer(surface.Native()))
	_arg4 = (C.gdouble)(x)
	_arg5 = (C.gdouble)(y)

	C.gtk_render_icon_surface(_arg1, _arg2, _arg3, _arg4, _arg5)
}

// RenderInsertionCursor draws a text caret on @cr at the specified index of
// @layout.
func RenderInsertionCursor(context StyleContext, cr *cairo.Context, x float64, y float64, layout pango.Layout, index int, direction pango.Direction) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.gdouble          // out
	var _arg4 C.gdouble          // out
	var _arg5 *C.PangoLayout     // out
	var _arg6 C.int              // out
	var _arg7 C.PangoDirection   // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.gdouble)(x)
	_arg4 = (C.gdouble)(y)
	_arg5 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))
	_arg6 = (C.int)(index)
	_arg7 = (C.PangoDirection)(direction)

	C.gtk_render_insertion_cursor(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
}

// RenderLayout renders @layout on the coordinates @x, @y
func RenderLayout(context StyleContext, cr *cairo.Context, x float64, y float64, layout pango.Layout) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.gdouble          // out
	var _arg4 C.gdouble          // out
	var _arg5 *C.PangoLayout     // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.gdouble)(x)
	_arg4 = (C.gdouble)(y)
	_arg5 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	C.gtk_render_layout(_arg1, _arg2, _arg3, _arg4, _arg5)
}

// RenderLine renders a line from (x0, y0) to (x1, y1).
func RenderLine(context StyleContext, cr *cairo.Context, x0 float64, y0 float64, x1 float64, y1 float64) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.gdouble          // out
	var _arg4 C.gdouble          // out
	var _arg5 C.gdouble          // out
	var _arg6 C.gdouble          // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.gdouble)(x0)
	_arg4 = (C.gdouble)(y0)
	_arg5 = (C.gdouble)(x1)
	_arg6 = (C.gdouble)(y1)

	C.gtk_render_line(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}

// RenderOption renders an option mark (as in a RadioButton), the
// GTK_STATE_FLAG_CHECKED state will determine whether the option is on or off,
// and GTK_STATE_FLAG_INCONSISTENT whether it should be marked as undefined.
//
// Typical option mark rendering:
//
// ! (options.png)
func RenderOption(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.gdouble          // out
	var _arg4 C.gdouble          // out
	var _arg5 C.gdouble          // out
	var _arg6 C.gdouble          // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.gdouble)(x)
	_arg4 = (C.gdouble)(y)
	_arg5 = (C.gdouble)(width)
	_arg6 = (C.gdouble)(height)

	C.gtk_render_option(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}

// RenderSlider renders a slider (as in Scale) in the rectangle defined by @x,
// @y, @width, @height. @orientation defines whether the slider is vertical or
// horizontal.
//
// Typical slider rendering:
//
// ! (sliders.png)
func RenderSlider(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64, orientation Orientation) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.gdouble          // out
	var _arg4 C.gdouble          // out
	var _arg5 C.gdouble          // out
	var _arg6 C.gdouble          // out
	var _arg7 C.GtkOrientation   // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (C.gdouble)(x)
	_arg4 = (C.gdouble)(y)
	_arg5 = (C.gdouble)(width)
	_arg6 = (C.gdouble)(height)
	_arg7 = (C.GtkOrientation)(orientation)

	C.gtk_render_slider(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
}

// RGBToHSV converts a color from RGB space to HSV.
//
// Input values must be in the [0.0, 1.0] range; output values will be in the
// same range.
func RGBToHSV(r float64, g float64, b float64) (h float64, s float64, v float64) {
	var _arg1 C.gdouble // out
	var _arg2 C.gdouble // out
	var _arg3 C.gdouble // out
	var _arg4 C.gdouble // in
	var _arg5 C.gdouble // in
	var _arg6 C.gdouble // in

	_arg1 = (C.gdouble)(r)
	_arg2 = (C.gdouble)(g)
	_arg3 = (C.gdouble)(b)

	C.gtk_rgb_to_hsv(_arg1, _arg2, _arg3, &_arg4, &_arg5, &_arg6)

	var _h float64 // out
	var _s float64 // out
	var _v float64 // out

	_h = (float64)(_arg4)
	_s = (float64)(_arg5)
	_v = (float64)(_arg6)

	return _h, _s, _v
}

// SelectionAddTarget appends a specified target to the list of supported
// targets for a given widget and selection.
func SelectionAddTarget(widget Widget, selection *gdk.Atom, target *gdk.Atom, info uint) {
	var _arg1 *C.GtkWidget // out
	var _arg2 C.GdkAtom    // out
	var _arg3 C.GdkAtom    // out
	var _arg4 C.guint      // out

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (C.GdkAtom)(unsafe.Pointer(selection.Native()))
	_arg3 = (C.GdkAtom)(unsafe.Pointer(target.Native()))
	_arg4 = (C.guint)(info)

	C.gtk_selection_add_target(_arg1, _arg2, _arg3, _arg4)
}

// SelectionAddTargets prepends a table of targets to the list of supported
// targets for a given widget and selection.
func SelectionAddTargets(widget Widget, selection *gdk.Atom, targets []TargetEntry) {
	var _arg1 *C.GtkWidget // out
	var _arg2 C.GdkAtom    // out
	var _arg3 *C.GtkTargetEntry
	var _arg4 C.guint

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (C.GdkAtom)(unsafe.Pointer(selection.Native()))
	_arg4 = C.guint(len(targets))
	_arg3 = (*C.GtkTargetEntry)(unsafe.Pointer(&targets[0]))

	C.gtk_selection_add_targets(_arg1, _arg2, _arg3, _arg4)
}

// SelectionClearTargets: remove all targets registered for the given selection
// for the widget.
func SelectionClearTargets(widget Widget, selection *gdk.Atom) {
	var _arg1 *C.GtkWidget // out
	var _arg2 C.GdkAtom    // out

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (C.GdkAtom)(unsafe.Pointer(selection.Native()))

	C.gtk_selection_clear_targets(_arg1, _arg2)
}

// SelectionConvert requests the contents of a selection. When received, a
// “selection-received” signal will be generated.
func SelectionConvert(widget Widget, selection *gdk.Atom, target *gdk.Atom, time_ uint32) bool {
	var _arg1 *C.GtkWidget // out
	var _arg2 C.GdkAtom    // out
	var _arg3 C.GdkAtom    // out
	var _arg4 C.guint32    // out
	var _cret C.gboolean   // in

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (C.GdkAtom)(unsafe.Pointer(selection.Native()))
	_arg3 = (C.GdkAtom)(unsafe.Pointer(target.Native()))
	_arg4 = (C.guint32)(time_)

	_cret = C.gtk_selection_convert(_arg1, _arg2, _arg3, _arg4)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SelectionOwnerSet claims ownership of a given selection for a particular
// widget, or, if @widget is nil, release ownership of the selection.
func SelectionOwnerSet(widget Widget, selection *gdk.Atom, time_ uint32) bool {
	var _arg1 *C.GtkWidget // out
	var _arg2 C.GdkAtom    // out
	var _arg3 C.guint32    // out
	var _cret C.gboolean   // in

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (C.GdkAtom)(unsafe.Pointer(selection.Native()))
	_arg3 = (C.guint32)(time_)

	_cret = C.gtk_selection_owner_set(_arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SelectionOwnerSetForDisplay: claim ownership of a given selection for a
// particular widget, or, if @widget is nil, release ownership of the selection.
func SelectionOwnerSetForDisplay(display gdk.Display, widget Widget, selection *gdk.Atom, time_ uint32) bool {
	var _arg1 *C.GdkDisplay // out
	var _arg2 *C.GtkWidget  // out
	var _arg3 C.GdkAtom     // out
	var _arg4 C.guint32     // out
	var _cret C.gboolean    // in

	_arg1 = (*C.GdkDisplay)(unsafe.Pointer(display.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg3 = (C.GdkAtom)(unsafe.Pointer(selection.Native()))
	_arg4 = (C.guint32)(time_)

	_cret = C.gtk_selection_owner_set_for_display(_arg1, _arg2, _arg3, _arg4)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SelectionRemoveAll removes all handlers and unsets ownership of all
// selections for a widget. Called when widget is being destroyed. This function
// will not generally be called by applications.
func SelectionRemoveAll(widget Widget) {
	var _arg1 *C.GtkWidget // out

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_selection_remove_all(_arg1)
}

// SetDebugFlags sets the GTK+ debug flags.
func SetDebugFlags(flags uint) {
	var _arg1 C.guint // out

	_arg1 = (C.guint)(flags)

	C.gtk_set_debug_flags(_arg1)
}

// ShowURI: a convenience function for launching the default application to show
// the uri. Like gtk_show_uri_on_window(), but takes a screen as transient
// parent instead of a window.
//
// Note that this function is deprecated as it does not pass the necessary
// information for helpers to parent their dialog properly, when run from
// sandboxed applications for example.
func ShowURI(screen gdk.Screen, uri string, timestamp uint32) error {
	var _arg1 *C.GdkScreen // out
	var _arg2 *C.gchar     // out
	var _arg3 C.guint32    // out
	var _cerr *C.GError    // in

	_arg1 = (*C.GdkScreen)(unsafe.Pointer(screen.Native()))
	_arg2 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.guint32)(timestamp)

	C.gtk_show_uri(_arg1, _arg2, _arg3, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// ShowURIOnWindow: this is a convenience function for launching the default
// application to show the uri. The uri must be of a form understood by GIO
// (i.e. you need to install gvfs to get support for uri schemes such as http://
// or ftp://, as only local files are handled by GIO itself). Typical examples
// are - `file:///home/gnome/pict.jpg` - `http://www.gnome.org` -
// `mailto:me@gnome.org`
//
// Ideally the timestamp is taken from the event triggering the gtk_show_uri()
// call. If timestamp is not known you can take GDK_CURRENT_TIME.
//
// This is the recommended call to be used as it passes information necessary
// for sandbox helpers to parent their dialogs properly.
func ShowURIOnWindow(parent Window, uri string, timestamp uint32) error {
	var _arg1 *C.GtkWindow // out
	var _arg2 *C.char      // out
	var _arg3 C.guint32    // out
	var _cerr *C.GError    // in

	_arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))
	_arg2 = (*C.char)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.guint32)(timestamp)

	C.gtk_show_uri_on_window(_arg1, _arg2, _arg3, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// StockAdd registers each of the stock items in @items. If an item already
// exists with the same stock ID as one of the @items, the old item gets
// replaced. The stock items are copied, so GTK+ does not hold any pointer into
// @items and @items can be freed. Use gtk_stock_add_static() if @items is
// persistent and GTK+ need not copy the array.
func StockAdd(items []StockItem) {
	var _arg1 *C.GtkStockItem
	var _arg2 C.guint

	_arg2 = C.guint(len(items))
	_arg1 = (*C.GtkStockItem)(unsafe.Pointer(&items[0]))

	C.gtk_stock_add(_arg1, _arg2)
}

// StockAddStatic: same as gtk_stock_add(), but doesn’t copy @items, so @items
// must persist until application exit.
func StockAddStatic(items []StockItem) {
	var _arg1 *C.GtkStockItem
	var _arg2 C.guint

	_arg2 = C.guint(len(items))
	_arg1 = (*C.GtkStockItem)(unsafe.Pointer(&items[0]))

	C.gtk_stock_add_static(_arg1, _arg2)
}

// StockLookup fills @item with the registered values for @stock_id, returning
// true if @stock_id was known.
func StockLookup(stockId string) (StockItem, bool) {
	var _arg1 *C.gchar // out
	var _item StockItem
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(C.CString(stockId))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_stock_lookup(_arg1, (*C.GtkStockItem)(unsafe.Pointer(&_item)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _item, _ok
}

// TargetTableFree: this function frees a target table as returned by
// gtk_target_table_new_from_list()
func TargetTableFree(targets []TargetEntry) {
	var _arg1 *C.GtkTargetEntry
	var _arg2 C.gint

	_arg2 = C.gint(len(targets))
	_arg1 = (*C.GtkTargetEntry)(unsafe.Pointer(&targets[0]))

	C.gtk_target_table_free(_arg1, _arg2)
}

// TargetsIncludeImage determines if any of the targets in @targets can be used
// to provide a Pixbuf.
func TargetsIncludeImage(targets []*gdk.Atom, writable bool) bool {
	var _arg1 *C.GdkAtom
	var _arg2 C.gint
	var _arg3 C.gboolean // out
	var _cret C.gboolean // in

	_arg2 = C.gint(len(targets))
	_arg1 = (*C.GdkAtom)(unsafe.Pointer(&targets[0]))
	if writable {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_targets_include_image(_arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TargetsIncludeRichText determines if any of the targets in @targets can be
// used to provide rich text.
func TargetsIncludeRichText(targets []*gdk.Atom, buffer TextBuffer) bool {
	var _arg1 *C.GdkAtom
	var _arg2 C.gint
	var _arg3 *C.GtkTextBuffer // out
	var _cret C.gboolean       // in

	_arg2 = C.gint(len(targets))
	_arg1 = (*C.GdkAtom)(unsafe.Pointer(&targets[0]))
	_arg3 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_targets_include_rich_text(_arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TargetsIncludeText determines if any of the targets in @targets can be used
// to provide text.
func TargetsIncludeText(targets []*gdk.Atom) bool {
	var _arg1 *C.GdkAtom
	var _arg2 C.gint
	var _cret C.gboolean // in

	_arg2 = C.gint(len(targets))
	_arg1 = (*C.GdkAtom)(unsafe.Pointer(&targets[0]))

	_cret = C.gtk_targets_include_text(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TargetsIncludeURI determines if any of the targets in @targets can be used to
// provide an uri list.
func TargetsIncludeURI(targets []*gdk.Atom) bool {
	var _arg1 *C.GdkAtom
	var _arg2 C.gint
	var _cret C.gboolean // in

	_arg2 = C.gint(len(targets))
	_arg1 = (*C.GdkAtom)(unsafe.Pointer(&targets[0]))

	_cret = C.gtk_targets_include_uri(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TestCreateSimpleWindow: create a simple window with window title
// @window_title and text contents @dialog_text. The window will quit any
// running gtk_main()-loop when destroyed, and it will automatically be
// destroyed upon test function teardown.
func TestCreateSimpleWindow(windowTitle string, dialogText string) Widget {
	var _arg1 *C.gchar     // out
	var _arg2 *C.gchar     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.gchar)(C.CString(windowTitle))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(dialogText))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_test_create_simple_window(_arg1, _arg2)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// TestFindLabel: this function will search @widget and all its descendants for
// a GtkLabel widget with a text string matching @label_pattern. The
// @label_pattern may contain asterisks “*” and question marks “?” as
// placeholders, g_pattern_match() is used for the matching. Note that locales
// other than "C“ tend to alter (translate” label strings, so this function is
// genrally only useful in test programs with predetermined locales, see
// gtk_test_init() for more details.
func TestFindLabel(widget Widget, labelPattern string) Widget {
	var _arg1 *C.GtkWidget // out
	var _arg2 *C.gchar     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (*C.gchar)(C.CString(labelPattern))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_test_find_label(_arg1, _arg2)

	var _ret Widget // out

	_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _ret
}

// TestFindSibling: this function will search siblings of @base_widget and
// siblings of its ancestors for all widgets matching @widget_type. Of the
// matching widgets, the one that is geometrically closest to @base_widget will
// be returned. The general purpose of this function is to find the most likely
// “action” widget, relative to another labeling widget. Such as finding a
// button or text entry widget, given its corresponding label widget.
func TestFindSibling(baseWidget Widget, widgetType externglib.Type) Widget {
	var _arg1 *C.GtkWidget // out
	var _arg2 C.GType      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(baseWidget.Native()))
	_arg2 = C.GType(widgetType)

	_cret = C.gtk_test_find_sibling(_arg1, _arg2)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// TestFindWidget: this function will search the descendants of @widget for a
// widget of type @widget_type that has a label matching @label_pattern next to
// it. This is most useful for automated GUI testing, e.g. to find the “OK”
// button in a dialog and synthesize clicks on it. However see
// gtk_test_find_label(), gtk_test_find_sibling() and gtk_test_widget_click()
// for possible caveats involving the search of such widgets and synthesizing
// widget events.
func TestFindWidget(widget Widget, labelPattern string, widgetType externglib.Type) Widget {
	var _arg1 *C.GtkWidget // out
	var _arg2 *C.gchar     // out
	var _arg3 C.GType      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (*C.gchar)(C.CString(labelPattern))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.GType(widgetType)

	_cret = C.gtk_test_find_widget(_arg1, _arg2, _arg3)

	var _ret Widget // out

	_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _ret
}

// TestRegisterAllTypes: force registration of all core Gtk+ and Gdk object
// types. This allowes to refer to any of those object types via
// g_type_from_name() after calling this function.
func TestRegisterAllTypes() {
	C.gtk_test_register_all_types()
}

// TestSliderGetValue: retrive the literal adjustment value for GtkRange based
// widgets and spin buttons. Note that the value returned by this function is
// anything between the lower and upper bounds of the adjustment belonging to
// @widget, and is not a percentage as passed in to gtk_test_slider_set_perc().
func TestSliderGetValue(widget Widget) float64 {
	var _arg1 *C.GtkWidget // out
	var _cret C.double     // in

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	_cret = C.gtk_test_slider_get_value(_arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// TestSliderSetPerc: this function will adjust the slider position of all
// GtkRange based widgets, such as scrollbars or scales, it’ll also adjust spin
// buttons. The adjustment value of these widgets is set to a value between the
// lower and upper limits, according to the @percentage argument.
func TestSliderSetPerc(widget Widget, percentage float64) {
	var _arg1 *C.GtkWidget // out
	var _arg2 C.double     // out

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (C.double)(percentage)

	C.gtk_test_slider_set_perc(_arg1, _arg2)
}

// TestSpinButtonClick: this function will generate a @button click in the
// upwards or downwards spin button arrow areas, usually leading to an increase
// or decrease of spin button’s value.
func TestSpinButtonClick(spinner SpinButton, button uint, upwards bool) bool {
	var _arg1 *C.GtkSpinButton // out
	var _arg2 C.guint          // out
	var _arg3 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg1 = (*C.GtkSpinButton)(unsafe.Pointer(spinner.Native()))
	_arg2 = (C.guint)(button)
	if upwards {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_test_spin_button_click(_arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TestTextGet: retrive the text string of @widget if it is a GtkLabel,
// GtkEditable (entry and text widgets) or GtkTextView.
func TestTextGet(widget Widget) string {
	var _arg1 *C.GtkWidget // out
	var _cret *C.gchar     // in

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	_cret = C.gtk_test_text_get(_arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// TestTextSet: set the text string of @widget to @string if it is a GtkLabel,
// GtkEditable (entry and text widgets) or GtkTextView.
func TestTextSet(widget Widget, _string string) {
	var _arg1 *C.GtkWidget // out
	var _arg2 *C.gchar     // out

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (*C.gchar)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_test_text_set(_arg1, _arg2)
}

// TestWidgetClick: this function will generate a @button click (button press
// and button release event) in the middle of the first GdkWindow found that
// belongs to @widget. For windowless widgets like Button (which returns false
// from gtk_widget_get_has_window()), this will often be an input-only event
// window. For other widgets, this is usually widget->window. Certain caveats
// should be considered when using this function, in particular because the
// mouse pointer is warped to the button click location, see
// gdk_test_simulate_button() for details.
func TestWidgetClick(widget Widget, button uint, modifiers gdk.ModifierType) bool {
	var _arg1 *C.GtkWidget      // out
	var _arg2 C.guint           // out
	var _arg3 C.GdkModifierType // out
	var _cret C.gboolean        // in

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (C.guint)(button)
	_arg3 = (C.GdkModifierType)(modifiers)

	_cret = C.gtk_test_widget_click(_arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TestWidgetSendKey: this function will generate keyboard press and release
// events in the middle of the first GdkWindow found that belongs to @widget.
// For windowless widgets like Button (which returns false from
// gtk_widget_get_has_window()), this will often be an input-only event window.
// For other widgets, this is usually widget->window. Certain caveats should be
// considered when using this function, in particular because the mouse pointer
// is warped to the key press location, see gdk_test_simulate_key() for details.
func TestWidgetSendKey(widget Widget, keyval uint, modifiers gdk.ModifierType) bool {
	var _arg1 *C.GtkWidget      // out
	var _arg2 C.guint           // out
	var _arg3 C.GdkModifierType // out
	var _cret C.gboolean        // in

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (C.guint)(keyval)
	_arg3 = (C.GdkModifierType)(modifiers)

	_cret = C.gtk_test_widget_send_key(_arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TestWidgetWaitForDraw enters the main loop and waits for @widget to be
// “drawn”. In this context that means it waits for the frame clock of @widget
// to have run a full styling, layout and drawing cycle.
//
// This function is intended to be used for syncing with actions that depend on
// @widget relayouting or on interaction with the display server.
func TestWidgetWaitForDraw(widget Widget) {
	var _arg1 *C.GtkWidget // out

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_test_widget_wait_for_draw(_arg1)
}

// TreeGetRowDragData obtains a @tree_model and @path from selection data of
// target type GTK_TREE_MODEL_ROW. Normally called from a drag_data_received
// handler. This function can only be used if @selection_data originates from
// the same process that’s calling this function, because a pointer to the tree
// model is being passed around. If you aren’t in the same process, then you'll
// get memory corruption. In the TreeDragDest drag_data_received handler, you
// can assume that selection data of type GTK_TREE_MODEL_ROW is in from the
// current process. The returned path must be freed with gtk_tree_path_free().
func TreeGetRowDragData(selectionData *SelectionData) (TreeModel, *TreePath, bool) {
	var _arg1 *C.GtkSelectionData // out
	var _arg2 *C.GtkTreeModel     // in
	var _path *TreePath
	var _cret C.gboolean // in

	_arg1 = (*C.GtkSelectionData)(unsafe.Pointer(selectionData.Native()))

	_cret = C.gtk_tree_get_row_drag_data(_arg1, &_arg2, (**C.GtkTreePath)(unsafe.Pointer(&_path)))

	var _treeModel TreeModel // out

	var _ok bool // out

	_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg2))).(TreeModel)

	if _cret != 0 {
		_ok = true
	}

	return _treeModel, _path, _ok
}

// TreeSetRowDragData sets selection data of target type GTK_TREE_MODEL_ROW.
// Normally used in a drag_data_get handler.
func TreeSetRowDragData(selectionData *SelectionData, treeModel TreeModel, path *TreePath) bool {
	var _arg1 *C.GtkSelectionData // out
	var _arg2 *C.GtkTreeModel     // out
	var _arg3 *C.GtkTreePath      // out
	var _cret C.gboolean          // in

	_arg1 = (*C.GtkSelectionData)(unsafe.Pointer(selectionData.Native()))
	_arg2 = (*C.GtkTreeModel)(unsafe.Pointer(treeModel.Native()))
	_arg3 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	_cret = C.gtk_tree_set_row_drag_data(_arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// True: all this function does it to return true.
//
// This can be useful for example if you want to inhibit the deletion of a
// window. Of course you should not do this as the user expects a reaction from
// clicking the close icon of the window...
//
// A persistent window
//
//    #include <gtk/gtk.h>
//
//    int
//    main (int argc, char **argv)
//    {
//      GtkWidget *win, *but;
//      const char *text = "Close yourself. I mean it!";
//
//      gtk_init (&argc, &argv);
//
//      win = gtk_window_new (GTK_WINDOW_TOPLEVEL);
//      g_signal_connect (win,
//                        "delete-event",
//                        G_CALLBACK (gtk_true),
//                        NULL);
//      g_signal_connect (win, "destroy",
//                        G_CALLBACK (gtk_main_quit),
//                        NULL);
//
//      but = gtk_button_new_with_label (text);
//      g_signal_connect_swapped (but, "clicked",
//                                G_CALLBACK (gtk_object_destroy),
//                                win);
//      gtk_container_add (GTK_CONTAINER (win), but);
//
//      gtk_widget_show_all (win);
//
//      gtk_main ();
//
//      return 0;
//    }
func True() bool {
	var _cret C.gboolean // in

	_cret = C.gtk_true()

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ActionableOverrider contains methods that are overridable. This
// interface is a subset of the interface Actionable.
type ActionableOverrider interface {
	// ActionName gets the action name for @actionable.
	//
	// See gtk_actionable_set_action_name() for more information.
	ActionName() string
	// ActionTargetValue gets the current target value of @actionable.
	//
	// See gtk_actionable_set_action_target_value() for more information.
	ActionTargetValue() *glib.Variant
	// SetActionName specifies the name of the action with which this widget
	// should be associated. If @action_name is nil then the widget will be
	// unassociated from any previous action.
	//
	// Usually this function is used when the widget is located (or will be
	// located) within the hierarchy of a ApplicationWindow.
	//
	// Names are of the form “win.save” or “app.quit” for actions on the
	// containing ApplicationWindow or its associated Application, respectively.
	// This is the same form used for actions in the #GMenu associated with the
	// window.
	SetActionName(actionName string)
	// SetActionTargetValue sets the target value of an actionable widget.
	//
	// If @target_value is nil then the target value is unset.
	//
	// The target value has two purposes. First, it is used as the parameter to
	// activation of the action associated with the Actionable widget. Second,
	// it is used to determine if the widget should be rendered as “active” —
	// the widget is active if the state is equal to the given target.
	//
	// Consider the example of associating a set of buttons with a #GAction with
	// string state in a typical “radio button” situation. Each button will be
	// associated with the same action, but with a different target value for
	// that action. Clicking on a particular button will activate the action
	// with the target of that button, which will typically cause the action’s
	// state to change to that value. Since the action’s state is now equal to
	// the target value of the button, the button will now be rendered as active
	// (and the other buttons, with different targets, rendered inactive).
	SetActionTargetValue(targetValue *glib.Variant)
}

// Actionable: this interface provides a convenient way of associating widgets
// with actions on a ApplicationWindow or Application.
//
// It primarily consists of two properties: Actionable:action-name and
// Actionable:action-target. There are also some convenience APIs for setting
// these properties.
//
// The action will be looked up in action groups that are found among the
// widgets ancestors. Most commonly, these will be the actions with the “win.”
// or “app.” prefix that are associated with the ApplicationWindow or
// Application, but other action groups that are added with
// gtk_widget_insert_action_group() will be consulted as well.
type Actionable interface {
	Widget
	ActionableOverrider

	// SetDetailedActionName sets the action-name and associated string target
	// value of an actionable widget.
	//
	// @detailed_action_name is a string in the format accepted by
	// g_action_parse_detailed_name().
	//
	// (Note that prior to version 3.22.25, this function is only usable for
	// actions with a simple "s" target, and @detailed_action_name must be of
	// the form `"action::target"` where `action` is the action name and
	// `target` is the string to use as the target.)
	SetDetailedActionName(detailedActionName string)
}

// actionable implements the Actionable interface.
type actionable struct {
	Widget
}

var _ Actionable = (*actionable)(nil)

// WrapActionable wraps a GObject to a type that implements interface
// Actionable. It is primarily used internally.
func WrapActionable(obj *externglib.Object) Actionable {
	return actionable{
		Widget: WrapWidget(obj),
	}
}

func marshalActionable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapActionable(obj), nil
}

// ActionName gets the action name for @actionable.
//
// See gtk_actionable_set_action_name() for more information.
func (a actionable) ActionName() string {
	var _arg0 *C.GtkActionable // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GtkActionable)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_actionable_get_action_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// ActionTargetValue gets the current target value of @actionable.
//
// See gtk_actionable_set_action_target_value() for more information.
func (a actionable) ActionTargetValue() *glib.Variant {
	var _arg0 *C.GtkActionable // out
	var _cret *C.GVariant      // in

	_arg0 = (*C.GtkActionable)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_actionable_get_action_target_value(_arg0)

	var _variant *glib.Variant // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// SetActionName specifies the name of the action with which this widget should
// be associated. If @action_name is nil then the widget will be unassociated
// from any previous action.
//
// Usually this function is used when the widget is located (or will be located)
// within the hierarchy of a ApplicationWindow.
//
// Names are of the form “win.save” or “app.quit” for actions on the containing
// ApplicationWindow or its associated Application, respectively. This is the
// same form used for actions in the #GMenu associated with the window.
func (a actionable) SetActionName(actionName string) {
	var _arg0 *C.GtkActionable // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GtkActionable)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_actionable_set_action_name(_arg0, _arg1)
}

// SetActionTargetValue sets the target value of an actionable widget.
//
// If @target_value is nil then the target value is unset.
//
// The target value has two purposes. First, it is used as the parameter to
// activation of the action associated with the Actionable widget. Second, it is
// used to determine if the widget should be rendered as “active” — the widget
// is active if the state is equal to the given target.
//
// Consider the example of associating a set of buttons with a #GAction with
// string state in a typical “radio button” situation. Each button will be
// associated with the same action, but with a different target value for that
// action. Clicking on a particular button will activate the action with the
// target of that button, which will typically cause the action’s state to
// change to that value. Since the action’s state is now equal to the target
// value of the button, the button will now be rendered as active (and the other
// buttons, with different targets, rendered inactive).
func (a actionable) SetActionTargetValue(targetValue *glib.Variant) {
	var _arg0 *C.GtkActionable // out
	var _arg1 *C.GVariant      // out

	_arg0 = (*C.GtkActionable)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GVariant)(unsafe.Pointer(targetValue.Native()))

	C.gtk_actionable_set_action_target_value(_arg0, _arg1)
}

// SetDetailedActionName sets the action-name and associated string target value
// of an actionable widget.
//
// @detailed_action_name is a string in the format accepted by
// g_action_parse_detailed_name().
//
// (Note that prior to version 3.22.25, this function is only usable for actions
// with a simple "s" target, and @detailed_action_name must be of the form
// `"action::target"` where `action` is the action name and `target` is the
// string to use as the target.)
func (a actionable) SetDetailedActionName(detailedActionName string) {
	var _arg0 *C.GtkActionable // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GtkActionable)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(detailedActionName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_actionable_set_detailed_action_name(_arg0, _arg1)
}

// ActivatableOverrider contains methods that are overridable. This
// interface is a subset of the interface Activatable.
type ActivatableOverrider interface {
	// SyncActionProperties: this is called to update the activatable
	// completely, this is called internally when the Activatable:related-action
	// property is set or unset and by the implementing class when
	// Activatable:use-action-appearance changes.
	SyncActionProperties(action Action)

	Update(action Action, propertyName string)
}

// Activatable: activatable widgets can be connected to a Action and reflects
// the state of its action. A Activatable can also provide feedback through its
// action, as they are responsible for activating their related actions.
//
//
// Implementing GtkActivatable
//
// When extending a class that is already Activatable; it is only necessary to
// implement the Activatable->sync_action_properties() and Activatable->update()
// methods and chain up to the parent implementation, however when introducing a
// new Activatable class; the Activatable:related-action and
// Activatable:use-action-appearance properties need to be handled by the
// implementor. Handling these properties is mostly a matter of installing the
// action pointer and boolean flag on your instance, and calling
// gtk_activatable_do_set_related_action() and
// gtk_activatable_sync_action_properties() at the appropriate times.
//
// A class fragment implementing Activatable
//
//
//    enum {
//    ...
//
//    PROP_ACTIVATABLE_RELATED_ACTION,
//    PROP_ACTIVATABLE_USE_ACTION_APPEARANCE
//    }
//
//    struct _FooBarPrivate
//    {
//
//      ...
//
//      GtkAction      *action;
//      gboolean        use_action_appearance;
//    };
//
//    ...
//
//    static void foo_bar_activatable_interface_init         (GtkActivatableIface  *iface);
//    static void foo_bar_activatable_update                 (GtkActivatable       *activatable,
//    						           GtkAction            *action,
//    						           const gchar          *property_name);
//    static void foo_bar_activatable_sync_action_properties (GtkActivatable       *activatable,
//    						           GtkAction            *action);
//    ...
//
//
//    static void
//    foo_bar_class_init (FooBarClass *klass)
//    {
//
//      ...
//
//      g_object_class_override_property (gobject_class, PROP_ACTIVATABLE_RELATED_ACTION, "related-action");
//      g_object_class_override_property (gobject_class, PROP_ACTIVATABLE_USE_ACTION_APPEARANCE, "use-action-appearance");
//
//      ...
//    }
//
//
//    static void
//    foo_bar_activatable_interface_init (GtkActivatableIface  *iface)
//    {
//      iface->update = foo_bar_activatable_update;
//      iface->sync_action_properties = foo_bar_activatable_sync_action_properties;
//    }
//
//    ... Break the reference using gtk_activatable_do_set_related_action()...
//
//    static void
//    foo_bar_dispose (GObject *object)
//    {
//      FooBar *bar = FOO_BAR (object);
//      FooBarPrivate *priv = FOO_BAR_GET_PRIVATE (bar);
//
//      ...
//
//      if (priv->action)
//        {
//          gtk_activatable_do_set_related_action (GTK_ACTIVATABLE (bar), NULL);
//          priv->action = NULL;
//        }
//      G_OBJECT_CLASS (foo_bar_parent_class)->dispose (object);
//    }
//
//    ... Handle the “related-action” and “use-action-appearance” properties ...
//
//    static void
//    foo_bar_set_property (GObject         *object,
//                          guint            prop_id,
//                          const GValue    *value,
//                          GParamSpec      *pspec)
//    {
//      FooBar *bar = FOO_BAR (object);
//      FooBarPrivate *priv = FOO_BAR_GET_PRIVATE (bar);
//
//      switch (prop_id)
//        {
//
//          ...
//
//        case PROP_ACTIVATABLE_RELATED_ACTION:
//          foo_bar_set_related_action (bar, g_value_get_object (value));
//          break;
//        case PROP_ACTIVATABLE_USE_ACTION_APPEARANCE:
//          foo_bar_set_use_action_appearance (bar, g_value_get_boolean (value));
//          break;
//        default:
//          G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
//          break;
//        }
//    }
//
//    static void
//    foo_bar_get_property (GObject         *object,
//                             guint            prop_id,
//                             GValue          *value,
//                             GParamSpec      *pspec)
//    {
//      FooBar *bar = FOO_BAR (object);
//      FooBarPrivate *priv = FOO_BAR_GET_PRIVATE (bar);
//
//      switch (prop_id)
//        {
//
//          ...
//
//        case PROP_ACTIVATABLE_RELATED_ACTION:
//          g_value_set_object (value, priv->action);
//          break;
//        case PROP_ACTIVATABLE_USE_ACTION_APPEARANCE:
//          g_value_set_boolean (value, priv->use_action_appearance);
//          break;
//        default:
//          G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
//          break;
//        }
//    }
//
//
//    static void
//    foo_bar_set_use_action_appearance (FooBar   *bar,
//    				   gboolean  use_appearance)
//    {
//      FooBarPrivate *priv = FOO_BAR_GET_PRIVATE (bar);
//
//      if (priv->use_action_appearance != use_appearance)
//        {
//          priv->use_action_appearance = use_appearance;
//
//          gtk_activatable_sync_action_properties (GTK_ACTIVATABLE (bar), priv->action);
//        }
//    }
//
//    ... call gtk_activatable_do_set_related_action() and then assign the action pointer,
//    no need to reference the action here since gtk_activatable_do_set_related_action() already
//    holds a reference here for you...
//    static void
//    foo_bar_set_related_action (FooBar    *bar,
//    			    GtkAction *action)
//    {
//      FooBarPrivate *priv = FOO_BAR_GET_PRIVATE (bar);
//
//      if (priv->action == action)
//        return;
//
//      gtk_activatable_do_set_related_action (GTK_ACTIVATABLE (bar), action);
//
//      priv->action = action;
//    }
//
//    ... Selectively reset and update activatable depending on the use-action-appearance property ...
//    static void
//    gtk_button_activatable_sync_action_properties (GtkActivatable       *activatable,
//    		                                  GtkAction            *action)
//    {
//      GtkButtonPrivate *priv = GTK_BUTTON_GET_PRIVATE (activatable);
//
//      if (!action)
//        return;
//
//      if (gtk_action_is_visible (action))
//        gtk_widget_show (GTK_WIDGET (activatable));
//      else
//        gtk_widget_hide (GTK_WIDGET (activatable));
//
//      gtk_widget_set_sensitive (GTK_WIDGET (activatable), gtk_action_is_sensitive (action));
//
//      ...
//
//      if (priv->use_action_appearance)
//        {
//          if (gtk_action_get_stock_id (action))
//    	foo_bar_set_stock (button, gtk_action_get_stock_id (action));
//          else if (gtk_action_get_label (action))
//    	foo_bar_set_label (button, gtk_action_get_label (action));
//
//          ...
//
//        }
//    }
//
//    static void
//    foo_bar_activatable_update (GtkActivatable       *activatable,
//    			       GtkAction            *action,
//    			       const gchar          *property_name)
//    {
//      FooBarPrivate *priv = FOO_BAR_GET_PRIVATE (activatable);
//
//      if (strcmp (property_name, "visible") == 0)
//        {
//          if (gtk_action_is_visible (action))
//    	gtk_widget_show (GTK_WIDGET (activatable));
//          else
//    	gtk_widget_hide (GTK_WIDGET (activatable));
//        }
//      else if (strcmp (property_name, "sensitive") == 0)
//        gtk_widget_set_sensitive (GTK_WIDGET (activatable), gtk_action_is_sensitive (action));
//
//      ...
//
//      if (!priv->use_action_appearance)
//        return;
//
//      if (strcmp (property_name, "stock-id") == 0)
//        foo_bar_set_stock (button, gtk_action_get_stock_id (action));
//      else if (strcmp (property_name, "label") == 0)
//        foo_bar_set_label (button, gtk_action_get_label (action));
//
//      ...
//    }
type Activatable interface {
	gextras.Objector
	ActivatableOverrider

	// DoSetRelatedAction: this is a utility function for Activatable
	// implementors.
	//
	// When implementing Activatable you must call this when handling changes of
	// the Activatable:related-action, and you must also use this to break
	// references in #GObject->dispose().
	//
	// This function adds a reference to the currently set related action for
	// you, it also makes sure the Activatable->update() method is called when
	// the related Action properties change and registers to the action’s proxy
	// list.
	//
	// > Be careful to call this before setting the local > copy of the Action
	// property, since this function uses > gtk_activatable_get_related_action()
	// to retrieve the > previous action.
	DoSetRelatedAction(action Action)
	// RelatedAction gets the related Action for @activatable.
	RelatedAction() Action
	// UseActionAppearance gets whether this activatable should reset its layout
	// and appearance when setting the related action or when the action changes
	// appearance.
	UseActionAppearance() bool
	// SetRelatedAction sets the related action on the @activatable object.
	//
	// > Activatable implementors need to handle the Activatable:related-action
	// > property and call gtk_activatable_do_set_related_action() when it
	// changes.
	SetRelatedAction(action Action)
	// SetUseActionAppearance sets whether this activatable should reset its
	// layout and appearance when setting the related action or when the action
	// changes appearance
	//
	// > Activatable implementors need to handle the >
	// Activatable:use-action-appearance property and call >
	// gtk_activatable_sync_action_properties() to update @activatable > if
	// needed.
	SetUseActionAppearance(useAppearance bool)
}

// activatable implements the Activatable interface.
type activatable struct {
	gextras.Objector
}

var _ Activatable = (*activatable)(nil)

// WrapActivatable wraps a GObject to a type that implements interface
// Activatable. It is primarily used internally.
func WrapActivatable(obj *externglib.Object) Activatable {
	return activatable{
		Objector: obj,
	}
}

func marshalActivatable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapActivatable(obj), nil
}

// DoSetRelatedAction: this is a utility function for Activatable implementors.
//
// When implementing Activatable you must call this when handling changes of the
// Activatable:related-action, and you must also use this to break references in
// #GObject->dispose().
//
// This function adds a reference to the currently set related action for you,
// it also makes sure the Activatable->update() method is called when the
// related Action properties change and registers to the action’s proxy list.
//
// > Be careful to call this before setting the local > copy of the Action
// property, since this function uses > gtk_activatable_get_related_action() to
// retrieve the > previous action.
func (a activatable) DoSetRelatedAction(action Action) {
	var _arg0 *C.GtkActivatable // out
	var _arg1 *C.GtkAction      // out

	_arg0 = (*C.GtkActivatable)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkAction)(unsafe.Pointer(action.Native()))

	C.gtk_activatable_do_set_related_action(_arg0, _arg1)
}

// RelatedAction gets the related Action for @activatable.
func (a activatable) RelatedAction() Action {
	var _arg0 *C.GtkActivatable // out
	var _cret *C.GtkAction      // in

	_arg0 = (*C.GtkActivatable)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_activatable_get_related_action(_arg0)

	var _action Action // out

	_action = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Action)

	return _action
}

// UseActionAppearance gets whether this activatable should reset its layout and
// appearance when setting the related action or when the action changes
// appearance.
func (a activatable) UseActionAppearance() bool {
	var _arg0 *C.GtkActivatable // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkActivatable)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_activatable_get_use_action_appearance(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetRelatedAction sets the related action on the @activatable object.
//
// > Activatable implementors need to handle the Activatable:related-action >
// property and call gtk_activatable_do_set_related_action() when it changes.
func (a activatable) SetRelatedAction(action Action) {
	var _arg0 *C.GtkActivatable // out
	var _arg1 *C.GtkAction      // out

	_arg0 = (*C.GtkActivatable)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkAction)(unsafe.Pointer(action.Native()))

	C.gtk_activatable_set_related_action(_arg0, _arg1)
}

// SetUseActionAppearance sets whether this activatable should reset its layout
// and appearance when setting the related action or when the action changes
// appearance
//
// > Activatable implementors need to handle the >
// Activatable:use-action-appearance property and call >
// gtk_activatable_sync_action_properties() to update @activatable > if needed.
func (a activatable) SetUseActionAppearance(useAppearance bool) {
	var _arg0 *C.GtkActivatable // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkActivatable)(unsafe.Pointer(a.Native()))
	if useAppearance {
		_arg1 = C.TRUE
	}

	C.gtk_activatable_set_use_action_appearance(_arg0, _arg1)
}

// SyncActionProperties: this is called to update the activatable completely,
// this is called internally when the Activatable:related-action property is set
// or unset and by the implementing class when Activatable:use-action-appearance
// changes.
func (a activatable) SyncActionProperties(action Action) {
	var _arg0 *C.GtkActivatable // out
	var _arg1 *C.GtkAction      // out

	_arg0 = (*C.GtkActivatable)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkAction)(unsafe.Pointer(action.Native()))

	C.gtk_activatable_sync_action_properties(_arg0, _arg1)
}

// AppChooser is an interface that can be implemented by widgets which allow the
// user to choose an application (typically for the purpose of opening a file).
// The main objects that implement this interface are AppChooserWidget,
// AppChooserDialog and AppChooserButton.
//
// Applications are represented by GIO Info objects here. GIO has a concept of
// recommended and fallback applications for a given content type. Recommended
// applications are those that claim to handle the content type itself, while
// fallback also includes applications that handle a more generic content type.
// GIO also knows the default and last-used application for a given content
// type. The AppChooserWidget provides detailed control over whether the shown
// list of applications should include default, recommended or fallback
// applications.
//
// To obtain the application that has been selected in a AppChooser, use
// gtk_app_chooser_get_app_info().
type AppChooser interface {
	Widget

	// AppInfo returns the currently selected application.
	AppInfo() gio.AppInfo
	// ContentType returns the current value of the AppChooser:content-type
	// property.
	ContentType() string
	// Refresh reloads the list of applications.
	Refresh()
}

// appChooser implements the AppChooser interface.
type appChooser struct {
	Widget
}

var _ AppChooser = (*appChooser)(nil)

// WrapAppChooser wraps a GObject to a type that implements interface
// AppChooser. It is primarily used internally.
func WrapAppChooser(obj *externglib.Object) AppChooser {
	return appChooser{
		Widget: WrapWidget(obj),
	}
}

func marshalAppChooser(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAppChooser(obj), nil
}

// AppInfo returns the currently selected application.
func (s appChooser) AppInfo() gio.AppInfo {
	var _arg0 *C.GtkAppChooser // out
	var _cret *C.GAppInfo      // in

	_arg0 = (*C.GtkAppChooser)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_app_chooser_get_app_info(_arg0)

	var _appInfo gio.AppInfo // out

	_appInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.AppInfo)

	return _appInfo
}

// ContentType returns the current value of the AppChooser:content-type
// property.
func (s appChooser) ContentType() string {
	var _arg0 *C.GtkAppChooser // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GtkAppChooser)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_app_chooser_get_content_type(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Refresh reloads the list of applications.
func (s appChooser) Refresh() {
	var _arg0 *C.GtkAppChooser // out

	_arg0 = (*C.GtkAppChooser)(unsafe.Pointer(s.Native()))

	C.gtk_app_chooser_refresh(_arg0)
}

// BuildableOverrider contains methods that are overridable. This
// interface is a subset of the interface Buildable.
type BuildableOverrider interface {
	// AddChild adds a child to @buildable. @type is an optional string
	// describing how the child should be added.
	AddChild(builder Builder, child gextras.Objector, typ string)
	// ConstructChild constructs a child of @buildable with the name @name.
	//
	// Builder calls this function if a “constructor” has been specified in the
	// UI definition.
	ConstructChild(builder Builder, name string) gextras.Objector
	// InternalChild: get the internal child called @childname of the @buildable
	// object.
	InternalChild(builder Builder, childname string) gextras.Objector
	// Name gets the name of the @buildable object.
	//
	// Builder sets the name based on the [GtkBuilder UI definition][BUILDER-UI]
	// used to construct the @buildable.
	Name() string
	// ParserFinished: called when the builder finishes the parsing of a
	// [GtkBuilder UI definition][BUILDER-UI]. Note that this will be called
	// once for each time gtk_builder_add_from_file() or
	// gtk_builder_add_from_string() is called on a builder.
	ParserFinished(builder Builder)
	// SetBuildableProperty sets the property name @name to @value on the
	// @buildable object.
	SetBuildableProperty(builder Builder, name string, value **externglib.Value)
	// SetName sets the name of the @buildable object.
	SetName(name string)
}

// Buildable: gtkBuildable allows objects to extend and customize their
// deserialization from [GtkBuilder UI descriptions][BUILDER-UI]. The interface
// includes methods for setting names and properties of objects, parsing custom
// tags and constructing child objects.
//
// The GtkBuildable interface is implemented by all widgets and many of the
// non-widget objects that are provided by GTK+. The main user of this interface
// is Builder. There should be very little need for applications to call any of
// these functions directly.
//
// An object only needs to implement this interface if it needs to extend the
// Builder format or run any extra routines at deserialization time.
type Buildable interface {
	gextras.Objector
	BuildableOverrider
}

// buildable implements the Buildable interface.
type buildable struct {
	gextras.Objector
}

var _ Buildable = (*buildable)(nil)

// WrapBuildable wraps a GObject to a type that implements interface
// Buildable. It is primarily used internally.
func WrapBuildable(obj *externglib.Object) Buildable {
	return buildable{
		Objector: obj,
	}
}

func marshalBuildable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBuildable(obj), nil
}

// AddChild adds a child to @buildable. @type is an optional string describing
// how the child should be added.
func (b buildable) AddChild(builder Builder, child gextras.Objector, typ string) {
	var _arg0 *C.GtkBuildable // out
	var _arg1 *C.GtkBuilder   // out
	var _arg2 *C.GObject      // out
	var _arg3 *C.gchar        // out

	_arg0 = (*C.GtkBuildable)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkBuilder)(unsafe.Pointer(builder.Native()))
	_arg2 = (*C.GObject)(unsafe.Pointer(child.Native()))
	_arg3 = (*C.gchar)(C.CString(typ))
	defer C.free(unsafe.Pointer(_arg3))

	C.gtk_buildable_add_child(_arg0, _arg1, _arg2, _arg3)
}

// ConstructChild constructs a child of @buildable with the name @name.
//
// Builder calls this function if a “constructor” has been specified in the UI
// definition.
func (b buildable) ConstructChild(builder Builder, name string) gextras.Objector {
	var _arg0 *C.GtkBuildable // out
	var _arg1 *C.GtkBuilder   // out
	var _arg2 *C.gchar        // out
	var _cret *C.GObject      // in

	_arg0 = (*C.GtkBuildable)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkBuilder)(unsafe.Pointer(builder.Native()))
	_arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_buildable_construct_child(_arg0, _arg1, _arg2)

	var _object gextras.Objector // out

	_object = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gextras.Objector)

	return _object
}

// InternalChild: get the internal child called @childname of the @buildable
// object.
func (b buildable) InternalChild(builder Builder, childname string) gextras.Objector {
	var _arg0 *C.GtkBuildable // out
	var _arg1 *C.GtkBuilder   // out
	var _arg2 *C.gchar        // out
	var _cret *C.GObject      // in

	_arg0 = (*C.GtkBuildable)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkBuilder)(unsafe.Pointer(builder.Native()))
	_arg2 = (*C.gchar)(C.CString(childname))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_buildable_get_internal_child(_arg0, _arg1, _arg2)

	var _object gextras.Objector // out

	_object = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gextras.Objector)

	return _object
}

// Name gets the name of the @buildable object.
//
// Builder sets the name based on the [GtkBuilder UI definition][BUILDER-UI]
// used to construct the @buildable.
func (b buildable) Name() string {
	var _arg0 *C.GtkBuildable // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GtkBuildable)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_buildable_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// ParserFinished: called when the builder finishes the parsing of a [GtkBuilder
// UI definition][BUILDER-UI]. Note that this will be called once for each time
// gtk_builder_add_from_file() or gtk_builder_add_from_string() is called on a
// builder.
func (b buildable) ParserFinished(builder Builder) {
	var _arg0 *C.GtkBuildable // out
	var _arg1 *C.GtkBuilder   // out

	_arg0 = (*C.GtkBuildable)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkBuilder)(unsafe.Pointer(builder.Native()))

	C.gtk_buildable_parser_finished(_arg0, _arg1)
}

// SetBuildableProperty sets the property name @name to @value on the @buildable
// object.
func (b buildable) SetBuildableProperty(builder Builder, name string, value **externglib.Value) {
	var _arg0 *C.GtkBuildable // out
	var _arg1 *C.GtkBuilder   // out
	var _arg2 *C.gchar        // out
	var _arg3 *C.GValue       // out

	_arg0 = (*C.GtkBuildable)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkBuilder)(unsafe.Pointer(builder.Native()))
	_arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GValue)(value.GValue)

	C.gtk_buildable_set_buildable_property(_arg0, _arg1, _arg2, _arg3)
}

// SetName sets the name of the @buildable object.
func (b buildable) SetName(name string) {
	var _arg0 *C.GtkBuildable // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GtkBuildable)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_buildable_set_name(_arg0, _arg1)
}

// CellAccessibleParentOverrider contains methods that are overridable. This
// interface is a subset of the interface CellAccessibleParent.
type CellAccessibleParentOverrider interface {
	Activate(cell CellAccessible)

	Edit(cell CellAccessible)

	ExpandCollapse(cell CellAccessible)

	CellArea(cell CellAccessible) gdk.Rectangle

	CellPosition(cell CellAccessible) (row int, column int)

	ChildIndex(cell CellAccessible) int

	RendererState(cell CellAccessible) CellRendererState

	GrabFocus(cell CellAccessible) bool
}

type CellAccessibleParent interface {
	gextras.Objector
	CellAccessibleParentOverrider
}

// cellAccessibleParent implements the CellAccessibleParent interface.
type cellAccessibleParent struct {
	gextras.Objector
}

var _ CellAccessibleParent = (*cellAccessibleParent)(nil)

// WrapCellAccessibleParent wraps a GObject to a type that implements interface
// CellAccessibleParent. It is primarily used internally.
func WrapCellAccessibleParent(obj *externglib.Object) CellAccessibleParent {
	return cellAccessibleParent{
		Objector: obj,
	}
}

func marshalCellAccessibleParent(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellAccessibleParent(obj), nil
}

func (p cellAccessibleParent) Activate(cell CellAccessible) {
	var _arg0 *C.GtkCellAccessibleParent // out
	var _arg1 *C.GtkCellAccessible       // out

	_arg0 = (*C.GtkCellAccessibleParent)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkCellAccessible)(unsafe.Pointer(cell.Native()))

	C.gtk_cell_accessible_parent_activate(_arg0, _arg1)
}

func (p cellAccessibleParent) Edit(cell CellAccessible) {
	var _arg0 *C.GtkCellAccessibleParent // out
	var _arg1 *C.GtkCellAccessible       // out

	_arg0 = (*C.GtkCellAccessibleParent)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkCellAccessible)(unsafe.Pointer(cell.Native()))

	C.gtk_cell_accessible_parent_edit(_arg0, _arg1)
}

func (p cellAccessibleParent) ExpandCollapse(cell CellAccessible) {
	var _arg0 *C.GtkCellAccessibleParent // out
	var _arg1 *C.GtkCellAccessible       // out

	_arg0 = (*C.GtkCellAccessibleParent)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkCellAccessible)(unsafe.Pointer(cell.Native()))

	C.gtk_cell_accessible_parent_expand_collapse(_arg0, _arg1)
}

func (p cellAccessibleParent) CellArea(cell CellAccessible) gdk.Rectangle {
	var _arg0 *C.GtkCellAccessibleParent // out
	var _arg1 *C.GtkCellAccessible       // out
	var _cellRect gdk.Rectangle

	_arg0 = (*C.GtkCellAccessibleParent)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkCellAccessible)(unsafe.Pointer(cell.Native()))

	C.gtk_cell_accessible_parent_get_cell_area(_arg0, _arg1, (*C.GdkRectangle)(unsafe.Pointer(&_cellRect)))

	return _cellRect
}

func (p cellAccessibleParent) CellPosition(cell CellAccessible) (row int, column int) {
	var _arg0 *C.GtkCellAccessibleParent // out
	var _arg1 *C.GtkCellAccessible       // out
	var _arg2 C.gint                     // in
	var _arg3 C.gint                     // in

	_arg0 = (*C.GtkCellAccessibleParent)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkCellAccessible)(unsafe.Pointer(cell.Native()))

	C.gtk_cell_accessible_parent_get_cell_position(_arg0, _arg1, &_arg2, &_arg3)

	var _row int    // out
	var _column int // out

	_row = (int)(_arg2)
	_column = (int)(_arg3)

	return _row, _column
}

func (p cellAccessibleParent) ChildIndex(cell CellAccessible) int {
	var _arg0 *C.GtkCellAccessibleParent // out
	var _arg1 *C.GtkCellAccessible       // out
	var _cret C.int                      // in

	_arg0 = (*C.GtkCellAccessibleParent)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkCellAccessible)(unsafe.Pointer(cell.Native()))

	_cret = C.gtk_cell_accessible_parent_get_child_index(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (p cellAccessibleParent) RendererState(cell CellAccessible) CellRendererState {
	var _arg0 *C.GtkCellAccessibleParent // out
	var _arg1 *C.GtkCellAccessible       // out
	var _cret C.GtkCellRendererState     // in

	_arg0 = (*C.GtkCellAccessibleParent)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkCellAccessible)(unsafe.Pointer(cell.Native()))

	_cret = C.gtk_cell_accessible_parent_get_renderer_state(_arg0, _arg1)

	var _cellRendererState CellRendererState // out

	_cellRendererState = CellRendererState(_cret)

	return _cellRendererState
}

func (p cellAccessibleParent) GrabFocus(cell CellAccessible) bool {
	var _arg0 *C.GtkCellAccessibleParent // out
	var _arg1 *C.GtkCellAccessible       // out
	var _cret C.gboolean                 // in

	_arg0 = (*C.GtkCellAccessibleParent)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkCellAccessible)(unsafe.Pointer(cell.Native()))

	_cret = C.gtk_cell_accessible_parent_grab_focus(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CellEditableOverrider contains methods that are overridable. This
// interface is a subset of the interface CellEditable.
type CellEditableOverrider interface {
	// EditingDone emits the CellEditable::editing-done signal.
	EditingDone()
	// RemoveWidget emits the CellEditable::remove-widget signal.
	RemoveWidget()
}

// CellEditable: the CellEditable interface must be implemented for widgets to
// be usable to edit the contents of a TreeView cell. It provides a way to
// specify how temporary widgets should be configured for editing, get the new
// value, etc.
type CellEditable interface {
	Widget
	CellEditableOverrider
}

// cellEditable implements the CellEditable interface.
type cellEditable struct {
	Widget
}

var _ CellEditable = (*cellEditable)(nil)

// WrapCellEditable wraps a GObject to a type that implements interface
// CellEditable. It is primarily used internally.
func WrapCellEditable(obj *externglib.Object) CellEditable {
	return cellEditable{
		Widget: WrapWidget(obj),
	}
}

func marshalCellEditable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellEditable(obj), nil
}

// EditingDone emits the CellEditable::editing-done signal.
func (c cellEditable) EditingDone() {
	var _arg0 *C.GtkCellEditable // out

	_arg0 = (*C.GtkCellEditable)(unsafe.Pointer(c.Native()))

	C.gtk_cell_editable_editing_done(_arg0)
}

// RemoveWidget emits the CellEditable::remove-widget signal.
func (c cellEditable) RemoveWidget() {
	var _arg0 *C.GtkCellEditable // out

	_arg0 = (*C.GtkCellEditable)(unsafe.Pointer(c.Native()))

	C.gtk_cell_editable_remove_widget(_arg0)
}

// CellLayoutOverrider contains methods that are overridable. This
// interface is a subset of the interface CellLayout.
type CellLayoutOverrider interface {
	// AddAttribute adds an attribute mapping to the list in @cell_layout.
	//
	// The @column is the column of the model to get a value from, and the
	// @attribute is the parameter on @cell to be set from the value. So for
	// example if column 2 of the model contains strings, you could have the
	// “text” attribute of a CellRendererText get its values from column 2.
	AddAttribute(cell CellRenderer, attribute string, column int)
	// Clear unsets all the mappings on all renderers on @cell_layout and
	// removes all renderers from @cell_layout.
	Clear()
	// ClearAttributes clears all existing attributes previously set with
	// gtk_cell_layout_set_attributes().
	ClearAttributes(cell CellRenderer)
	// Area returns the underlying CellArea which might be @cell_layout if
	// called on a CellArea or might be nil if no CellArea is used by
	// @cell_layout.
	Area() CellArea
	// PackEnd adds the @cell to the end of @cell_layout. If @expand is false,
	// then the @cell is allocated no more space than it needs. Any unused space
	// is divided evenly between cells for which @expand is true.
	//
	// Note that reusing the same cell renderer is not supported.
	PackEnd(cell CellRenderer, expand bool)
	// PackStart packs the @cell into the beginning of @cell_layout. If @expand
	// is false, then the @cell is allocated no more space than it needs. Any
	// unused space is divided evenly between cells for which @expand is true.
	//
	// Note that reusing the same cell renderer is not supported.
	PackStart(cell CellRenderer, expand bool)
	// Reorder re-inserts @cell at @position.
	//
	// Note that @cell has already to be packed into @cell_layout for this to
	// function properly.
	Reorder(cell CellRenderer, position int)
}

// CellLayout is an interface to be implemented by all objects which want to
// provide a TreeViewColumn like API for packing cells, setting attributes and
// data funcs.
//
// One of the notable features provided by implementations of GtkCellLayout are
// attributes. Attributes let you set the properties in flexible ways. They can
// just be set to constant values like regular properties. But they can also be
// mapped to a column of the underlying tree model with
// gtk_cell_layout_set_attributes(), which means that the value of the attribute
// can change from cell to cell as they are rendered by the cell renderer.
// Finally, it is possible to specify a function with
// gtk_cell_layout_set_cell_data_func() that is called to determine the value of
// the attribute for each cell that is rendered.
//
//
// GtkCellLayouts as GtkBuildable
//
// Implementations of GtkCellLayout which also implement the GtkBuildable
// interface (CellView, IconView, ComboBox, EntryCompletion, TreeViewColumn)
// accept GtkCellRenderer objects as <child> elements in UI definitions. They
// support a custom <attributes> element for their children, which can contain
// multiple <attribute> elements. Each <attribute> element has a name attribute
// which specifies a property of the cell renderer; the content of the element
// is the attribute value.
//
// This is an example of a UI definition fragment specifying attributes:
//
//    <object class="GtkCellView">
//      <child>
//        <object class="GtkCellRendererText"/>
//        <attributes>
//          <attribute name="text">0</attribute>
//        </attributes>
//      </child>"
//    </object>
//
// Furthermore for implementations of GtkCellLayout that use a CellArea to lay
// out cells (all GtkCellLayouts in GTK+ use a GtkCellArea) [cell
// properties][cell-properties] can also be defined in the format by specifying
// the custom <cell-packing> attribute which can contain multiple <property>
// elements defined in the normal way.
//
// Here is a UI definition fragment specifying cell properties:
//
//    <object class="GtkTreeViewColumn">
//      <child>
//        <object class="GtkCellRendererText"/>
//        <cell-packing>
//          <property name="align">True</property>
//          <property name="expand">False</property>
//        </cell-packing>
//      </child>"
//    </object>
//
//
// Subclassing GtkCellLayout implementations
//
// When subclassing a widget that implements CellLayout like IconView or
// ComboBox, there are some considerations related to the fact that these
// widgets internally use a CellArea. The cell area is exposed as a
// construct-only property by these widgets. This means that it is possible to
// e.g. do
//
//    static void
//    my_combo_box_init (MyComboBox *b)
//    {
//      GtkCellRenderer *cell;
//
//      cell = gtk_cell_renderer_pixbuf_new ();
//      // The following call causes the default cell area for combo boxes,
//      // a GtkCellAreaBox, to be instantiated
//      gtk_cell_layout_pack_start (GTK_CELL_LAYOUT (b), cell, FALSE);
//      ...
//    }
//
//    GtkWidget *
//    my_combo_box_new (GtkCellArea *area)
//    {
//      // This call is going to cause a warning about area being ignored
//      return g_object_new (MY_TYPE_COMBO_BOX, "cell-area", area, NULL);
//    }
//
// If supporting alternative cell areas with your derived widget is not
// important, then this does not have to concern you. If you want to support
// alternative cell areas, you can do so by moving the problematic calls out of
// init() and into a constructor() for your class.
type CellLayout interface {
	gextras.Objector
	CellLayoutOverrider
}

// cellLayout implements the CellLayout interface.
type cellLayout struct {
	gextras.Objector
}

var _ CellLayout = (*cellLayout)(nil)

// WrapCellLayout wraps a GObject to a type that implements interface
// CellLayout. It is primarily used internally.
func WrapCellLayout(obj *externglib.Object) CellLayout {
	return cellLayout{
		Objector: obj,
	}
}

func marshalCellLayout(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellLayout(obj), nil
}

// AddAttribute adds an attribute mapping to the list in @cell_layout.
//
// The @column is the column of the model to get a value from, and the
// @attribute is the parameter on @cell to be set from the value. So for example
// if column 2 of the model contains strings, you could have the “text”
// attribute of a CellRendererText get its values from column 2.
func (c cellLayout) AddAttribute(cell CellRenderer, attribute string, column int) {
	var _arg0 *C.GtkCellLayout   // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 *C.gchar           // out
	var _arg3 C.gint             // out

	_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))
	_arg2 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.gint)(column)

	C.gtk_cell_layout_add_attribute(_arg0, _arg1, _arg2, _arg3)
}

// Clear unsets all the mappings on all renderers on @cell_layout and removes
// all renderers from @cell_layout.
func (c cellLayout) Clear() {
	var _arg0 *C.GtkCellLayout // out

	_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(c.Native()))

	C.gtk_cell_layout_clear(_arg0)
}

// ClearAttributes clears all existing attributes previously set with
// gtk_cell_layout_set_attributes().
func (c cellLayout) ClearAttributes(cell CellRenderer) {
	var _arg0 *C.GtkCellLayout   // out
	var _arg1 *C.GtkCellRenderer // out

	_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))

	C.gtk_cell_layout_clear_attributes(_arg0, _arg1)
}

// Area returns the underlying CellArea which might be @cell_layout if called on
// a CellArea or might be nil if no CellArea is used by @cell_layout.
func (c cellLayout) Area() CellArea {
	var _arg0 *C.GtkCellLayout // out
	var _cret *C.GtkCellArea   // in

	_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_cell_layout_get_area(_arg0)

	var _cellArea CellArea // out

	_cellArea = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(CellArea)

	return _cellArea
}

// PackEnd adds the @cell to the end of @cell_layout. If @expand is false, then
// the @cell is allocated no more space than it needs. Any unused space is
// divided evenly between cells for which @expand is true.
//
// Note that reusing the same cell renderer is not supported.
func (c cellLayout) PackEnd(cell CellRenderer, expand bool) {
	var _arg0 *C.GtkCellLayout   // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 C.gboolean         // out

	_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))
	if expand {
		_arg2 = C.TRUE
	}

	C.gtk_cell_layout_pack_end(_arg0, _arg1, _arg2)
}

// PackStart packs the @cell into the beginning of @cell_layout. If @expand is
// false, then the @cell is allocated no more space than it needs. Any unused
// space is divided evenly between cells for which @expand is true.
//
// Note that reusing the same cell renderer is not supported.
func (c cellLayout) PackStart(cell CellRenderer, expand bool) {
	var _arg0 *C.GtkCellLayout   // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 C.gboolean         // out

	_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))
	if expand {
		_arg2 = C.TRUE
	}

	C.gtk_cell_layout_pack_start(_arg0, _arg1, _arg2)
}

// Reorder re-inserts @cell at @position.
//
// Note that @cell has already to be packed into @cell_layout for this to
// function properly.
func (c cellLayout) Reorder(cell CellRenderer, position int) {
	var _arg0 *C.GtkCellLayout   // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 C.gint             // out

	_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))
	_arg2 = (C.gint)(position)

	C.gtk_cell_layout_reorder(_arg0, _arg1, _arg2)
}

// ColorChooserOverrider contains methods that are overridable. This
// interface is a subset of the interface ColorChooser.
type ColorChooserOverrider interface {
	// AddPalette adds a palette to the color chooser. If @orientation is
	// horizontal, the colors are grouped in rows, with @colors_per_line colors
	// in each row. If @horizontal is false, the colors are grouped in columns
	// instead.
	//
	// The default color palette of ColorChooserWidget has 27 colors, organized
	// in columns of 3 colors. The default gray palette has 9 grays in a single
	// row.
	//
	// The layout of the color chooser widget works best when the palettes have
	// 9-10 columns.
	//
	// Calling this function for the first time has the side effect of removing
	// the default color and gray palettes from the color chooser.
	//
	// If @colors is nil, removes all previously added palettes.
	AddPalette(orientation Orientation, colorsPerLine int, colors []gdk.RGBA)

	ColorActivated(color *gdk.RGBA)
	// RGBA gets the currently-selected color.
	RGBA() gdk.RGBA
	// SetRGBA sets the color.
	SetRGBA(color *gdk.RGBA)
}

// ColorChooser is an interface that is implemented by widgets for choosing
// colors. Depending on the situation, colors may be allowed to have alpha
// (translucency).
//
// In GTK+, the main widgets that implement this interface are
// ColorChooserWidget, ColorChooserDialog and ColorButton.
type ColorChooser interface {
	gextras.Objector
	ColorChooserOverrider

	// UseAlpha returns whether the color chooser shows the alpha channel.
	UseAlpha() bool
	// SetUseAlpha sets whether or not the color chooser should use the alpha
	// channel.
	SetUseAlpha(useAlpha bool)
}

// colorChooser implements the ColorChooser interface.
type colorChooser struct {
	gextras.Objector
}

var _ ColorChooser = (*colorChooser)(nil)

// WrapColorChooser wraps a GObject to a type that implements interface
// ColorChooser. It is primarily used internally.
func WrapColorChooser(obj *externglib.Object) ColorChooser {
	return colorChooser{
		Objector: obj,
	}
}

func marshalColorChooser(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapColorChooser(obj), nil
}

// AddPalette adds a palette to the color chooser. If @orientation is
// horizontal, the colors are grouped in rows, with @colors_per_line colors in
// each row. If @horizontal is false, the colors are grouped in columns instead.
//
// The default color palette of ColorChooserWidget has 27 colors, organized in
// columns of 3 colors. The default gray palette has 9 grays in a single row.
//
// The layout of the color chooser widget works best when the palettes have 9-10
// columns.
//
// Calling this function for the first time has the side effect of removing the
// default color and gray palettes from the color chooser.
//
// If @colors is nil, removes all previously added palettes.
func (c colorChooser) AddPalette(orientation Orientation, colorsPerLine int, colors []gdk.RGBA) {
	var _arg0 *C.GtkColorChooser // out
	var _arg1 C.GtkOrientation   // out
	var _arg2 C.gint             // out
	var _arg4 *C.GdkRGBA
	var _arg3 C.gint

	_arg0 = (*C.GtkColorChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GtkOrientation)(orientation)
	_arg2 = (C.gint)(colorsPerLine)
	_arg3 = C.gint(len(colors))
	_arg4 = (*C.GdkRGBA)(unsafe.Pointer(&colors[0]))

	C.gtk_color_chooser_add_palette(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// RGBA gets the currently-selected color.
func (c colorChooser) RGBA() gdk.RGBA {
	var _arg0 *C.GtkColorChooser // out
	var _color gdk.RGBA

	_arg0 = (*C.GtkColorChooser)(unsafe.Pointer(c.Native()))

	C.gtk_color_chooser_get_rgba(_arg0, (*C.GdkRGBA)(unsafe.Pointer(&_color)))

	return _color
}

// UseAlpha returns whether the color chooser shows the alpha channel.
func (c colorChooser) UseAlpha() bool {
	var _arg0 *C.GtkColorChooser // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkColorChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_color_chooser_get_use_alpha(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetRGBA sets the color.
func (c colorChooser) SetRGBA(color *gdk.RGBA) {
	var _arg0 *C.GtkColorChooser // out
	var _arg1 *C.GdkRGBA         // out

	_arg0 = (*C.GtkColorChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GdkRGBA)(unsafe.Pointer(color.Native()))

	C.gtk_color_chooser_set_rgba(_arg0, _arg1)
}

// SetUseAlpha sets whether or not the color chooser should use the alpha
// channel.
func (c colorChooser) SetUseAlpha(useAlpha bool) {
	var _arg0 *C.GtkColorChooser // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GtkColorChooser)(unsafe.Pointer(c.Native()))
	if useAlpha {
		_arg1 = C.TRUE
	}

	C.gtk_color_chooser_set_use_alpha(_arg0, _arg1)
}

// EditableOverrider contains methods that are overridable. This
// interface is a subset of the interface Editable.
type EditableOverrider interface {
	Changed()
	// DeleteText deletes a sequence of characters. The characters that are
	// deleted are those characters at positions from @start_pos up to, but not
	// including @end_pos. If @end_pos is negative, then the characters deleted
	// are those from @start_pos to the end of the text.
	//
	// Note that the positions are specified in characters, not bytes.
	DeleteText(startPos int, endPos int)
	// DoDeleteText deletes a sequence of characters. The characters that are
	// deleted are those characters at positions from @start_pos up to, but not
	// including @end_pos. If @end_pos is negative, then the characters deleted
	// are those from @start_pos to the end of the text.
	//
	// Note that the positions are specified in characters, not bytes.
	DoDeleteText(startPos int, endPos int)
	// Chars retrieves a sequence of characters. The characters that are
	// retrieved are those characters at positions from @start_pos up to, but
	// not including @end_pos. If @end_pos is negative, then the characters
	// retrieved are those characters from @start_pos to the end of the text.
	//
	// Note that positions are specified in characters, not bytes.
	Chars(startPos int, endPos int) string
	// Position retrieves the current position of the cursor relative to the
	// start of the content of the editable.
	//
	// Note that this position is in characters, not in bytes.
	Position() int
	// SelectionBounds retrieves the selection bound of the editable. start_pos
	// will be filled with the start of the selection and @end_pos with end. If
	// no text was selected both will be identical and false will be returned.
	//
	// Note that positions are specified in characters, not bytes.
	SelectionBounds() (startPos int, endPos int, ok bool)
	// SetPosition sets the cursor position in the editable to the given value.
	//
	// The cursor is displayed before the character with the given (base 0)
	// index in the contents of the editable. The value must be less than or
	// equal to the number of characters in the editable. A value of -1
	// indicates that the position should be set after the last character of the
	// editable. Note that @position is in characters, not in bytes.
	SetPosition(position int)
	// SetSelectionBounds selects a region of text. The characters that are
	// selected are those characters at positions from @start_pos up to, but not
	// including @end_pos. If @end_pos is negative, then the characters selected
	// are those characters from @start_pos to the end of the text.
	//
	// Note that positions are specified in characters, not bytes.
	SetSelectionBounds(startPos int, endPos int)
}

// Editable: the Editable interface is an interface which should be implemented
// by text editing widgets, such as Entry and SpinButton. It contains functions
// for generically manipulating an editable widget, a large number of action
// signals used for key bindings, and several signals that an application can
// connect to to modify the behavior of a widget.
//
// As an example of the latter usage, by connecting the following handler to
// Editable::insert-text, an application can convert all entry into a widget
// into uppercase.
//
// Forcing entry to uppercase.
//
//    #include <ctype.h>;
//
//    void
//    insert_text_handler (GtkEditable *editable,
//                         const gchar *text,
//                         gint         length,
//                         gint        *position,
//                         gpointer     data)
//    {
//      gchar *result = g_utf8_strup (text, length);
//
//      g_signal_handlers_block_by_func (editable,
//                                   (gpointer) insert_text_handler, data);
//      gtk_editable_insert_text (editable, result, length, position);
//      g_signal_handlers_unblock_by_func (editable,
//                                         (gpointer) insert_text_handler, data);
//
//      g_signal_stop_emission_by_name (editable, "insert_text");
//
//      g_free (result);
//    }
type Editable interface {
	gextras.Objector
	EditableOverrider

	// CopyClipboard copies the contents of the currently selected content in
	// the editable and puts it on the clipboard.
	CopyClipboard()
	// CutClipboard removes the contents of the currently selected content in
	// the editable and puts it on the clipboard.
	CutClipboard()
	// DeleteSelection deletes the currently selected text of the editable. This
	// call doesn’t do anything if there is no selected text.
	DeleteSelection()
	// Editable retrieves whether @editable is editable. See
	// gtk_editable_set_editable().
	Editable() bool
	// PasteClipboard pastes the content of the clipboard to the current
	// position of the cursor in the editable.
	PasteClipboard()
	// SelectRegion selects a region of text. The characters that are selected
	// are those characters at positions from @start_pos up to, but not
	// including @end_pos. If @end_pos is negative, then the characters selected
	// are those characters from @start_pos to the end of the text.
	//
	// Note that positions are specified in characters, not bytes.
	SelectRegion(startPos int, endPos int)
	// SetEditable determines if the user can edit the text in the editable
	// widget or not.
	SetEditable(isEditable bool)
}

// editable implements the Editable interface.
type editable struct {
	gextras.Objector
}

var _ Editable = (*editable)(nil)

// WrapEditable wraps a GObject to a type that implements interface
// Editable. It is primarily used internally.
func WrapEditable(obj *externglib.Object) Editable {
	return editable{
		Objector: obj,
	}
}

func marshalEditable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEditable(obj), nil
}

// CopyClipboard copies the contents of the currently selected content in the
// editable and puts it on the clipboard.
func (e editable) CopyClipboard() {
	var _arg0 *C.GtkEditable // out

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

	C.gtk_editable_copy_clipboard(_arg0)
}

// CutClipboard removes the contents of the currently selected content in the
// editable and puts it on the clipboard.
func (e editable) CutClipboard() {
	var _arg0 *C.GtkEditable // out

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

	C.gtk_editable_cut_clipboard(_arg0)
}

// DeleteSelection deletes the currently selected text of the editable. This
// call doesn’t do anything if there is no selected text.
func (e editable) DeleteSelection() {
	var _arg0 *C.GtkEditable // out

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

	C.gtk_editable_delete_selection(_arg0)
}

// DeleteText deletes a sequence of characters. The characters that are deleted
// are those characters at positions from @start_pos up to, but not including
// @end_pos. If @end_pos is negative, then the characters deleted are those from
// @start_pos to the end of the text.
//
// Note that the positions are specified in characters, not bytes.
func (e editable) DeleteText(startPos int, endPos int) {
	var _arg0 *C.GtkEditable // out
	var _arg1 C.gint         // out
	var _arg2 C.gint         // out

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))
	_arg1 = (C.gint)(startPos)
	_arg2 = (C.gint)(endPos)

	C.gtk_editable_delete_text(_arg0, _arg1, _arg2)
}

// Chars retrieves a sequence of characters. The characters that are retrieved
// are those characters at positions from @start_pos up to, but not including
// @end_pos. If @end_pos is negative, then the characters retrieved are those
// characters from @start_pos to the end of the text.
//
// Note that positions are specified in characters, not bytes.
func (e editable) Chars(startPos int, endPos int) string {
	var _arg0 *C.GtkEditable // out
	var _arg1 C.gint         // out
	var _arg2 C.gint         // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))
	_arg1 = (C.gint)(startPos)
	_arg2 = (C.gint)(endPos)

	_cret = C.gtk_editable_get_chars(_arg0, _arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Editable retrieves whether @editable is editable. See
// gtk_editable_set_editable().
func (e editable) Editable() bool {
	var _arg0 *C.GtkEditable // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_editable_get_editable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Position retrieves the current position of the cursor relative to the start
// of the content of the editable.
//
// Note that this position is in characters, not in bytes.
func (e editable) Position() int {
	var _arg0 *C.GtkEditable // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_editable_get_position(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// SelectionBounds retrieves the selection bound of the editable. start_pos will
// be filled with the start of the selection and @end_pos with end. If no text
// was selected both will be identical and false will be returned.
//
// Note that positions are specified in characters, not bytes.
func (e editable) SelectionBounds() (startPos int, endPos int, ok bool) {
	var _arg0 *C.GtkEditable // out
	var _arg1 C.gint         // in
	var _arg2 C.gint         // in
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_editable_get_selection_bounds(_arg0, &_arg1, &_arg2)

	var _startPos int // out
	var _endPos int   // out
	var _ok bool      // out

	_startPos = (int)(_arg1)
	_endPos = (int)(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _startPos, _endPos, _ok
}

// PasteClipboard pastes the content of the clipboard to the current position of
// the cursor in the editable.
func (e editable) PasteClipboard() {
	var _arg0 *C.GtkEditable // out

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

	C.gtk_editable_paste_clipboard(_arg0)
}

// SelectRegion selects a region of text. The characters that are selected are
// those characters at positions from @start_pos up to, but not including
// @end_pos. If @end_pos is negative, then the characters selected are those
// characters from @start_pos to the end of the text.
//
// Note that positions are specified in characters, not bytes.
func (e editable) SelectRegion(startPos int, endPos int) {
	var _arg0 *C.GtkEditable // out
	var _arg1 C.gint         // out
	var _arg2 C.gint         // out

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))
	_arg1 = (C.gint)(startPos)
	_arg2 = (C.gint)(endPos)

	C.gtk_editable_select_region(_arg0, _arg1, _arg2)
}

// SetEditable determines if the user can edit the text in the editable widget
// or not.
func (e editable) SetEditable(isEditable bool) {
	var _arg0 *C.GtkEditable // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))
	if isEditable {
		_arg1 = C.TRUE
	}

	C.gtk_editable_set_editable(_arg0, _arg1)
}

// SetPosition sets the cursor position in the editable to the given value.
//
// The cursor is displayed before the character with the given (base 0) index in
// the contents of the editable. The value must be less than or equal to the
// number of characters in the editable. A value of -1 indicates that the
// position should be set after the last character of the editable. Note that
// @position is in characters, not in bytes.
func (e editable) SetPosition(position int) {
	var _arg0 *C.GtkEditable // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))
	_arg1 = (C.gint)(position)

	C.gtk_editable_set_position(_arg0, _arg1)
}

// FileChooser is an interface that can be implemented by file selection
// widgets. In GTK+, the main objects that implement this interface are
// FileChooserWidget, FileChooserDialog, and FileChooserButton. You do not need
// to write an object that implements the FileChooser interface unless you are
// trying to adapt an existing file selector to expose a standard programming
// interface.
//
// FileChooser allows for shortcuts to various places in the filesystem. In the
// default implementation these are displayed in the left pane. It may be a bit
// confusing at first that these shortcuts come from various sources and in
// various flavours, so lets explain the terminology here:
//
// - Bookmarks: are created by the user, by dragging folders from the right pane
// to the left pane, or by using the “Add”. Bookmarks can be renamed and deleted
// by the user.
//
// - Shortcuts: can be provided by the application. For example, a Paint program
// may want to add a shortcut for a Clipart folder. Shortcuts cannot be modified
// by the user.
//
// - Volumes: are provided by the underlying filesystem abstraction. They are
// the “roots” of the filesystem.
//
//
// File Names and Encodings
//
// When the user is finished selecting files in a FileChooser, your program can
// get the selected names either as filenames or as URIs. For URIs, the normal
// escaping rules are applied if the URI contains non-ASCII characters. However,
// filenames are always returned in the character set specified by the
// `G_FILENAME_ENCODING` environment variable. Please see the GLib documentation
// for more details about this variable.
//
// This means that while you can pass the result of
// gtk_file_chooser_get_filename() to g_open() or g_fopen(), you may not be able
// to directly set it as the text of a Label widget unless you convert it first
// to UTF-8, which all GTK+ widgets expect. You should use g_filename_to_utf8()
// to convert filenames into strings that can be passed to GTK+ widgets.
//
//
// Adding a Preview Widget
//
// You can add a custom preview widget to a file chooser and then get
// notification about when the preview needs to be updated. To install a preview
// widget, use gtk_file_chooser_set_preview_widget(). Then, connect to the
// FileChooser::update-preview signal to get notified when you need to update
// the contents of the preview.
//
// Your callback should use gtk_file_chooser_get_preview_filename() to see what
// needs previewing. Once you have generated the preview for the corresponding
// file, you must call gtk_file_chooser_set_preview_widget_active() with a
// boolean flag that indicates whether your callback could successfully generate
// a preview.
//
// Example: Using a Preview Widget
//
//
//      GtkWidget *toggle;
//
//      ...
//
//      toggle = gtk_check_button_new_with_label ("Open file read-only");
//      gtk_widget_show (toggle);
//      gtk_file_chooser_set_extra_widget (my_file_chooser, toggle);
//    }
//
// If you want to set more than one extra widget in the file chooser, you can a
// container such as a Box or a Grid and include your widgets in it. Then, set
// the container as the whole extra widget.
type FileChooser interface {
	gextras.Objector

	// AddChoice adds a 'choice' to the file chooser. This is typically
	// implemented as a combobox or, for boolean choices, as a checkbutton. You
	// can select a value using gtk_file_chooser_set_choice() before the dialog
	// is shown, and you can obtain the user-selected value in the ::response
	// signal handler using gtk_file_chooser_get_choice().
	//
	// Compare gtk_file_chooser_set_extra_widget().
	AddChoice(id string, label string, options []string, optionLabels []string)
	// AddFilter adds @filter to the list of filters that the user can select
	// between. When a filter is selected, only files that are passed by that
	// filter are displayed.
	//
	// Note that the @chooser takes ownership of the filter, so you have to ref
	// and sink it if you want to keep a reference.
	AddFilter(filter FileFilter)
	// AddShortcutFolder adds a folder to be displayed with the shortcut folders
	// in a file chooser. Note that shortcut folders do not get saved, as they
	// are provided by the application. For example, you can use this to add a
	// “/usr/share/mydrawprogram/Clipart” folder to the volume list.
	AddShortcutFolder(folder string) error
	// AddShortcutFolderURI adds a folder URI to be displayed with the shortcut
	// folders in a file chooser. Note that shortcut folders do not get saved,
	// as they are provided by the application. For example, you can use this to
	// add a “file:///usr/share/mydrawprogram/Clipart” folder to the volume
	// list.
	AddShortcutFolderURI(uri string) error
	// Action gets the type of operation that the file chooser is performing;
	// see gtk_file_chooser_set_action().
	Action() FileChooserAction
	// Choice gets the currently selected option in the 'choice' with the given
	// ID.
	Choice(id string) string
	// CreateFolders gets whether file choser will offer to create new folders.
	// See gtk_file_chooser_set_create_folders().
	CreateFolders() bool
	// CurrentFolder gets the current folder of @chooser as a local filename.
	// See gtk_file_chooser_set_current_folder().
	//
	// Note that this is the folder that the file chooser is currently
	// displaying (e.g. "/home/username/Documents"), which is not the same as
	// the currently-selected folder if the chooser is in
	// GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER mode (e.g.
	// "/home/username/Documents/selected-folder/". To get the
	// currently-selected folder in that mode, use gtk_file_chooser_get_uri() as
	// the usual way to get the selection.
	CurrentFolder() string
	// CurrentFolderFile gets the current folder of @chooser as #GFile. See
	// gtk_file_chooser_get_current_folder_uri().
	CurrentFolderFile() gio.File
	// CurrentFolderURI gets the current folder of @chooser as an URI. See
	// gtk_file_chooser_set_current_folder_uri().
	//
	// Note that this is the folder that the file chooser is currently
	// displaying (e.g. "file:///home/username/Documents"), which is not the
	// same as the currently-selected folder if the chooser is in
	// GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER mode (e.g.
	// "file:///home/username/Documents/selected-folder/". To get the
	// currently-selected folder in that mode, use gtk_file_chooser_get_uri() as
	// the usual way to get the selection.
	CurrentFolderURI() string
	// CurrentName gets the current name in the file selector, as entered by the
	// user in the text entry for “Name”.
	//
	// This is meant to be used in save dialogs, to get the currently typed
	// filename when the file itself does not exist yet. For example, an
	// application that adds a custom extra widget to the file chooser for “file
	// format” may want to change the extension of the typed filename based on
	// the chosen format, say, from “.jpg” to “.png”.
	CurrentName() string
	// DoOverwriteConfirmation queries whether a file chooser is set to confirm
	// for overwriting when the user types a file name that already exists.
	DoOverwriteConfirmation() bool
	// ExtraWidget gets the current extra widget; see
	// gtk_file_chooser_set_extra_widget().
	ExtraWidget() Widget
	// File gets the #GFile for the currently selected file in the file
	// selector. If multiple files are selected, one of the files will be
	// returned at random.
	//
	// If the file chooser is in folder mode, this function returns the selected
	// folder.
	File() gio.File
	// Filename gets the filename for the currently selected file in the file
	// selector. The filename is returned as an absolute path. If multiple files
	// are selected, one of the filenames will be returned at random.
	//
	// If the file chooser is in folder mode, this function returns the selected
	// folder.
	Filename() string
	// Filter gets the current filter; see gtk_file_chooser_set_filter().
	Filter() FileFilter
	// LocalOnly gets whether only local files can be selected in the file
	// selector. See gtk_file_chooser_set_local_only()
	LocalOnly() bool
	// PreviewFile gets the #GFile that should be previewed in a custom preview
	// Internal function, see gtk_file_chooser_get_preview_uri().
	PreviewFile() gio.File
	// PreviewFilename gets the filename that should be previewed in a custom
	// preview widget. See gtk_file_chooser_set_preview_widget().
	PreviewFilename() string
	// PreviewURI gets the URI that should be previewed in a custom preview
	// widget. See gtk_file_chooser_set_preview_widget().
	PreviewURI() string
	// PreviewWidget gets the current preview widget; see
	// gtk_file_chooser_set_preview_widget().
	PreviewWidget() Widget
	// PreviewWidgetActive gets whether the preview widget set by
	// gtk_file_chooser_set_preview_widget() should be shown for the current
	// filename. See gtk_file_chooser_set_preview_widget_active().
	PreviewWidgetActive() bool
	// SelectMultiple gets whether multiple files can be selected in the file
	// selector. See gtk_file_chooser_set_select_multiple().
	SelectMultiple() bool
	// ShowHidden gets whether hidden files and folders are displayed in the
	// file selector. See gtk_file_chooser_set_show_hidden().
	ShowHidden() bool
	// URI gets the URI for the currently selected file in the file selector. If
	// multiple files are selected, one of the filenames will be returned at
	// random.
	//
	// If the file chooser is in folder mode, this function returns the selected
	// folder.
	URI() string
	// UsePreviewLabel gets whether a stock label should be drawn with the name
	// of the previewed file. See gtk_file_chooser_set_use_preview_label().
	UsePreviewLabel() bool
	// RemoveChoice removes a 'choice' that has been added with
	// gtk_file_chooser_add_choice().
	RemoveChoice(id string)
	// RemoveFilter removes @filter from the list of filters that the user can
	// select between.
	RemoveFilter(filter FileFilter)
	// RemoveShortcutFolder removes a folder from a file chooser’s list of
	// shortcut folders.
	RemoveShortcutFolder(folder string) error
	// RemoveShortcutFolderURI removes a folder URI from a file chooser’s list
	// of shortcut folders.
	RemoveShortcutFolderURI(uri string) error
	// SelectAll selects all the files in the current folder of a file chooser.
	SelectAll()
	// SelectFile selects the file referred to by @file. An internal function.
	// See _gtk_file_chooser_select_uri().
	SelectFile(file gio.File) error
	// SelectFilename selects a filename. If the file name isn’t in the current
	// folder of @chooser, then the current folder of @chooser will be changed
	// to the folder containing @filename.
	SelectFilename(filename string) bool
	// SelectURI selects the file to by @uri. If the URI doesn’t refer to a file
	// in the current folder of @chooser, then the current folder of @chooser
	// will be changed to the folder containing @filename.
	SelectURI(uri string) bool
	// SetAction sets the type of operation that the chooser is performing; the
	// user interface is adapted to suit the selected action. For example, an
	// option to create a new folder might be shown if the action is
	// GTK_FILE_CHOOSER_ACTION_SAVE but not if the action is
	// GTK_FILE_CHOOSER_ACTION_OPEN.
	SetAction(action FileChooserAction)
	// SetChoice selects an option in a 'choice' that has been added with
	// gtk_file_chooser_add_choice(). For a boolean choice, the possible options
	// are "true" and "false".
	SetChoice(id string, option string)
	// SetCreateFolders sets whether file choser will offer to create new
	// folders. This is only relevant if the action is not set to be
	// GTK_FILE_CHOOSER_ACTION_OPEN.
	SetCreateFolders(createFolders bool)
	// SetCurrentFolder sets the current folder for @chooser from a local
	// filename. The user will be shown the full contents of the current folder,
	// plus user interface elements for navigating to other folders.
	//
	// In general, you should not use this function. See the [section on setting
	// up a file chooser dialog][gtkfilechooserdialog-setting-up] for the
	// rationale behind this.
	SetCurrentFolder(filename string) bool
	// SetCurrentFolderFile sets the current folder for @chooser from a #GFile.
	// Internal function, see gtk_file_chooser_set_current_folder_uri().
	SetCurrentFolderFile(file gio.File) error
	// SetCurrentFolderURI sets the current folder for @chooser from an URI. The
	// user will be shown the full contents of the current folder, plus user
	// interface elements for navigating to other folders.
	//
	// In general, you should not use this function. See the [section on setting
	// up a file chooser dialog][gtkfilechooserdialog-setting-up] for the
	// rationale behind this.
	SetCurrentFolderURI(uri string) bool
	// SetCurrentName sets the current name in the file selector, as if entered
	// by the user. Note that the name passed in here is a UTF-8 string rather
	// than a filename. This function is meant for such uses as a suggested name
	// in a “Save As...” dialog. You can pass “Untitled.doc” or a similarly
	// suitable suggestion for the @name.
	//
	// If you want to preselect a particular existing file, you should use
	// gtk_file_chooser_set_filename() or gtk_file_chooser_set_uri() instead.
	// Please see the documentation for those functions for an example of using
	// gtk_file_chooser_set_current_name() as well.
	SetCurrentName(name string)
	// SetDoOverwriteConfirmation sets whether a file chooser in
	// GTK_FILE_CHOOSER_ACTION_SAVE mode will present a confirmation dialog if
	// the user types a file name that already exists. This is false by default.
	//
	// If set to true, the @chooser will emit the FileChooser::confirm-overwrite
	// signal when appropriate.
	//
	// If all you need is the stock confirmation dialog, set this property to
	// true. You can override the way confirmation is done by actually handling
	// the FileChooser::confirm-overwrite signal; please refer to its
	// documentation for the details.
	SetDoOverwriteConfirmation(doOverwriteConfirmation bool)
	// SetExtraWidget sets an application-supplied widget to provide extra
	// options to the user.
	SetExtraWidget(extraWidget Widget)
	// SetFile sets @file as the current filename for the file chooser, by
	// changing to the file’s parent folder and actually selecting the file in
	// list. If the @chooser is in GTK_FILE_CHOOSER_ACTION_SAVE mode, the file’s
	// base name will also appear in the dialog’s file name entry.
	//
	// If the file name isn’t in the current folder of @chooser, then the
	// current folder of @chooser will be changed to the folder containing
	// @filename. This is equivalent to a sequence of
	// gtk_file_chooser_unselect_all() followed by
	// gtk_file_chooser_select_filename().
	//
	// Note that the file must exist, or nothing will be done except for the
	// directory change.
	//
	// If you are implementing a save dialog, you should use this function if
	// you already have a file name to which the user may save; for example,
	// when the user opens an existing file and then does Save As... If you
	// don’t have a file name already — for example, if the user just created a
	// new file and is saving it for the first time, do not call this function.
	// Instead, use something similar to this:
	//
	//    if (document_is_new)
	//      {
	//        // the user just created a new document
	//        gtk_file_chooser_set_current_folder_file (chooser, default_file_for_saving);
	//        gtk_file_chooser_set_current_name (chooser, "Untitled document");
	//      }
	//    else
	//      {
	//        // the user edited an existing document
	//        gtk_file_chooser_set_file (chooser, existing_file);
	//      }
	SetFile(file gio.File) error
	// SetFilename sets @filename as the current filename for the file chooser,
	// by changing to the file’s parent folder and actually selecting the file
	// in list; all other files will be unselected. If the @chooser is in
	// GTK_FILE_CHOOSER_ACTION_SAVE mode, the file’s base name will also appear
	// in the dialog’s file name entry.
	//
	// Note that the file must exist, or nothing will be done except for the
	// directory change.
	//
	// You should use this function only when implementing a save dialog for
	// which you already have a file name to which the user may save. For
	// example, when the user opens an existing file and then does Save As... to
	// save a copy or a modified version. If you don’t have a file name already
	// — for example, if the user just created a new file and is saving it for
	// the first time, do not call this function. Instead, use something similar
	// to this:
	//
	//    if (document_is_new)
	//      {
	//        // the user just created a new document
	//        gtk_file_chooser_set_current_name (chooser, "Untitled document");
	//      }
	//    else
	//      {
	//        // the user edited an existing document
	//        gtk_file_chooser_set_filename (chooser, existing_filename);
	//      }
	//
	// In the first case, the file chooser will present the user with useful
	// suggestions as to where to save his new file. In the second case, the
	// file’s existing location is already known, so the file chooser will use
	// it.
	SetFilename(filename string) bool
	// SetFilter sets the current filter; only the files that pass the filter
	// will be displayed. If the user-selectable list of filters is non-empty,
	// then the filter should be one of the filters in that list. Setting the
	// current filter when the list of filters is empty is useful if you want to
	// restrict the displayed set of files without letting the user change it.
	SetFilter(filter FileFilter)
	// SetLocalOnly sets whether only local files can be selected in the file
	// selector. If @local_only is true (the default), then the selected file or
	// files are guaranteed to be accessible through the operating systems
	// native file system and therefore the application only needs to worry
	// about the filename functions in FileChooser, like
	// gtk_file_chooser_get_filename(), rather than the URI functions like
	// gtk_file_chooser_get_uri(),
	//
	// On some systems non-native files may still be available using the native
	// filesystem via a userspace filesystem (FUSE).
	SetLocalOnly(localOnly bool)
	// SetPreviewWidget sets an application-supplied widget to use to display a
	// custom preview of the currently selected file. To implement a preview,
	// after setting the preview widget, you connect to the
	// FileChooser::update-preview signal, and call
	// gtk_file_chooser_get_preview_filename() or
	// gtk_file_chooser_get_preview_uri() on each change. If you can display a
	// preview of the new file, update your widget and set the preview active
	// using gtk_file_chooser_set_preview_widget_active(). Otherwise, set the
	// preview inactive.
	//
	// When there is no application-supplied preview widget, or the
	// application-supplied preview widget is not active, the file chooser will
	// display no preview at all.
	SetPreviewWidget(previewWidget Widget)
	// SetPreviewWidgetActive sets whether the preview widget set by
	// gtk_file_chooser_set_preview_widget() should be shown for the current
	// filename. When @active is set to false, the file chooser may display an
	// internally generated preview of the current file or it may display no
	// preview at all. See gtk_file_chooser_set_preview_widget() for more
	// details.
	SetPreviewWidgetActive(active bool)
	// SetSelectMultiple sets whether multiple files can be selected in the file
	// selector. This is only relevant if the action is set to be
	// GTK_FILE_CHOOSER_ACTION_OPEN or GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER.
	SetSelectMultiple(selectMultiple bool)
	// SetShowHidden sets whether hidden files and folders are displayed in the
	// file selector.
	SetShowHidden(showHidden bool)
	// SetURI sets the file referred to by @uri as the current file for the file
	// chooser, by changing to the URI’s parent folder and actually selecting
	// the URI in the list. If the @chooser is GTK_FILE_CHOOSER_ACTION_SAVE
	// mode, the URI’s base name will also appear in the dialog’s file name
	// entry.
	//
	// Note that the URI must exist, or nothing will be done except for the
	// directory change.
	//
	// You should use this function only when implementing a save dialog for
	// which you already have a file name to which the user may save. For
	// example, when the user opens an existing file and then does Save As... to
	// save a copy or a modified version. If you don’t have a file name already
	// — for example, if the user just created a new file and is saving it for
	// the first time, do not call this function. Instead, use something similar
	// to this:
	//
	//    if (document_is_new)
	//      {
	//        // the user just created a new document
	//        gtk_file_chooser_set_current_name (chooser, "Untitled document");
	//      }
	//    else
	//      {
	//        // the user edited an existing document
	//        gtk_file_chooser_set_uri (chooser, existing_uri);
	//      }
	//
	// In the first case, the file chooser will present the user with useful
	// suggestions as to where to save his new file. In the second case, the
	// file’s existing location is already known, so the file chooser will use
	// it.
	SetURI(uri string) bool
	// SetUsePreviewLabel sets whether the file chooser should display a stock
	// label with the name of the file that is being previewed; the default is
	// true. Applications that want to draw the whole preview area themselves
	// should set this to false and display the name themselves in their preview
	// widget.
	//
	// See also: gtk_file_chooser_set_preview_widget()
	SetUsePreviewLabel(useLabel bool)
	// UnselectAll unselects all the files in the current folder of a file
	// chooser.
	UnselectAll()
	// UnselectFile unselects the file referred to by @file. If the file is not
	// in the current directory, does not exist, or is otherwise not currently
	// selected, does nothing.
	UnselectFile(file gio.File)
	// UnselectFilename unselects a currently selected filename. If the filename
	// is not in the current directory, does not exist, or is otherwise not
	// currently selected, does nothing.
	UnselectFilename(filename string)
	// UnselectURI unselects the file referred to by @uri. If the file is not in
	// the current directory, does not exist, or is otherwise not currently
	// selected, does nothing.
	UnselectURI(uri string)
}

// fileChooser implements the FileChooser interface.
type fileChooser struct {
	gextras.Objector
}

var _ FileChooser = (*fileChooser)(nil)

// WrapFileChooser wraps a GObject to a type that implements interface
// FileChooser. It is primarily used internally.
func WrapFileChooser(obj *externglib.Object) FileChooser {
	return fileChooser{
		Objector: obj,
	}
}

func marshalFileChooser(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileChooser(obj), nil
}

// AddChoice adds a 'choice' to the file chooser. This is typically implemented
// as a combobox or, for boolean choices, as a checkbutton. You can select a
// value using gtk_file_chooser_set_choice() before the dialog is shown, and you
// can obtain the user-selected value in the ::response signal handler using
// gtk_file_chooser_get_choice().
//
// Compare gtk_file_chooser_set_extra_widget().
func (c fileChooser) AddChoice(id string, label string, options []string, optionLabels []string) {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.char           // out
	var _arg2 *C.char           // out
	var _arg3 **C.char
	var _arg4 **C.char

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(id))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (**C.char)(C.malloc(C.ulong(len(options)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice(_arg3, len(options))
		for i := range options {
			out[i] = (*C.char)(C.CString(options[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}
	_arg4 = (**C.char)(C.malloc(C.ulong(len(optionLabels)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg4))
	{
		out := unsafe.Slice(_arg4, len(optionLabels))
		for i := range optionLabels {
			out[i] = (*C.char)(C.CString(optionLabels[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.gtk_file_chooser_add_choice(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// AddFilter adds @filter to the list of filters that the user can select
// between. When a filter is selected, only files that are passed by that filter
// are displayed.
//
// Note that the @chooser takes ownership of the filter, so you have to ref and
// sink it if you want to keep a reference.
func (c fileChooser) AddFilter(filter FileFilter) {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.GtkFileFilter  // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkFileFilter)(unsafe.Pointer(filter.Native()))

	C.gtk_file_chooser_add_filter(_arg0, _arg1)
}

// AddShortcutFolder adds a folder to be displayed with the shortcut folders in
// a file chooser. Note that shortcut folders do not get saved, as they are
// provided by the application. For example, you can use this to add a
// “/usr/share/mydrawprogram/Clipart” folder to the volume list.
func (c fileChooser) AddShortcutFolder(folder string) error {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.char           // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(folder))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_file_chooser_add_shortcut_folder(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// AddShortcutFolderURI adds a folder URI to be displayed with the shortcut
// folders in a file chooser. Note that shortcut folders do not get saved, as
// they are provided by the application. For example, you can use this to add a
// “file:///usr/share/mydrawprogram/Clipart” folder to the volume list.
func (c fileChooser) AddShortcutFolderURI(uri string) error {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.char           // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_file_chooser_add_shortcut_folder_uri(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// Action gets the type of operation that the file chooser is performing; see
// gtk_file_chooser_set_action().
func (c fileChooser) Action() FileChooserAction {
	var _arg0 *C.GtkFileChooser      // out
	var _cret C.GtkFileChooserAction // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_file_chooser_get_action(_arg0)

	var _fileChooserAction FileChooserAction // out

	_fileChooserAction = FileChooserAction(_cret)

	return _fileChooserAction
}

// Choice gets the currently selected option in the 'choice' with the given ID.
func (c fileChooser) Choice(id string) string {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.char           // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(id))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_file_chooser_get_choice(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// CreateFolders gets whether file choser will offer to create new folders. See
// gtk_file_chooser_set_create_folders().
func (c fileChooser) CreateFolders() bool {
	var _arg0 *C.GtkFileChooser // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_file_chooser_get_create_folders(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CurrentFolder gets the current folder of @chooser as a local filename. See
// gtk_file_chooser_set_current_folder().
//
// Note that this is the folder that the file chooser is currently displaying
// (e.g. "/home/username/Documents"), which is not the same as the
// currently-selected folder if the chooser is in
// GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER mode (e.g.
// "/home/username/Documents/selected-folder/". To get the currently-selected
// folder in that mode, use gtk_file_chooser_get_uri() as the usual way to get
// the selection.
func (c fileChooser) CurrentFolder() string {
	var _arg0 *C.GtkFileChooser // out
	var _cret *C.gchar          // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_file_chooser_get_current_folder(_arg0)

	var _filename string // out

	_filename = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _filename
}

// CurrentFolderFile gets the current folder of @chooser as #GFile. See
// gtk_file_chooser_get_current_folder_uri().
func (c fileChooser) CurrentFolderFile() gio.File {
	var _arg0 *C.GtkFileChooser // out
	var _cret *C.GFile          // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_file_chooser_get_current_folder_file(_arg0)

	var _file gio.File // out

	_file = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.File)

	return _file
}

// CurrentFolderURI gets the current folder of @chooser as an URI. See
// gtk_file_chooser_set_current_folder_uri().
//
// Note that this is the folder that the file chooser is currently displaying
// (e.g. "file:///home/username/Documents"), which is not the same as the
// currently-selected folder if the chooser is in
// GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER mode (e.g.
// "file:///home/username/Documents/selected-folder/". To get the
// currently-selected folder in that mode, use gtk_file_chooser_get_uri() as the
// usual way to get the selection.
func (c fileChooser) CurrentFolderURI() string {
	var _arg0 *C.GtkFileChooser // out
	var _cret *C.gchar          // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_file_chooser_get_current_folder_uri(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// CurrentName gets the current name in the file selector, as entered by the
// user in the text entry for “Name”.
//
// This is meant to be used in save dialogs, to get the currently typed filename
// when the file itself does not exist yet. For example, an application that
// adds a custom extra widget to the file chooser for “file format” may want to
// change the extension of the typed filename based on the chosen format, say,
// from “.jpg” to “.png”.
func (c fileChooser) CurrentName() string {
	var _arg0 *C.GtkFileChooser // out
	var _cret *C.gchar          // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_file_chooser_get_current_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// DoOverwriteConfirmation queries whether a file chooser is set to confirm for
// overwriting when the user types a file name that already exists.
func (c fileChooser) DoOverwriteConfirmation() bool {
	var _arg0 *C.GtkFileChooser // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_file_chooser_get_do_overwrite_confirmation(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ExtraWidget gets the current extra widget; see
// gtk_file_chooser_set_extra_widget().
func (c fileChooser) ExtraWidget() Widget {
	var _arg0 *C.GtkFileChooser // out
	var _cret *C.GtkWidget      // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_file_chooser_get_extra_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// File gets the #GFile for the currently selected file in the file selector. If
// multiple files are selected, one of the files will be returned at random.
//
// If the file chooser is in folder mode, this function returns the selected
// folder.
func (c fileChooser) File() gio.File {
	var _arg0 *C.GtkFileChooser // out
	var _cret *C.GFile          // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_file_chooser_get_file(_arg0)

	var _file gio.File // out

	_file = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.File)

	return _file
}

// Filename gets the filename for the currently selected file in the file
// selector. The filename is returned as an absolute path. If multiple files are
// selected, one of the filenames will be returned at random.
//
// If the file chooser is in folder mode, this function returns the selected
// folder.
func (c fileChooser) Filename() string {
	var _arg0 *C.GtkFileChooser // out
	var _cret *C.gchar          // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_file_chooser_get_filename(_arg0)

	var _filename string // out

	_filename = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _filename
}

// Filter gets the current filter; see gtk_file_chooser_set_filter().
func (c fileChooser) Filter() FileFilter {
	var _arg0 *C.GtkFileChooser // out
	var _cret *C.GtkFileFilter  // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_file_chooser_get_filter(_arg0)

	var _fileFilter FileFilter // out

	_fileFilter = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(FileFilter)

	return _fileFilter
}

// LocalOnly gets whether only local files can be selected in the file selector.
// See gtk_file_chooser_set_local_only()
func (c fileChooser) LocalOnly() bool {
	var _arg0 *C.GtkFileChooser // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_file_chooser_get_local_only(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PreviewFile gets the #GFile that should be previewed in a custom preview
// Internal function, see gtk_file_chooser_get_preview_uri().
func (c fileChooser) PreviewFile() gio.File {
	var _arg0 *C.GtkFileChooser // out
	var _cret *C.GFile          // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_file_chooser_get_preview_file(_arg0)

	var _file gio.File // out

	_file = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.File)

	return _file
}

// PreviewFilename gets the filename that should be previewed in a custom
// preview widget. See gtk_file_chooser_set_preview_widget().
func (c fileChooser) PreviewFilename() string {
	var _arg0 *C.GtkFileChooser // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_file_chooser_get_preview_filename(_arg0)

	var _filename string // out

	_filename = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _filename
}

// PreviewURI gets the URI that should be previewed in a custom preview widget.
// See gtk_file_chooser_set_preview_widget().
func (c fileChooser) PreviewURI() string {
	var _arg0 *C.GtkFileChooser // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_file_chooser_get_preview_uri(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// PreviewWidget gets the current preview widget; see
// gtk_file_chooser_set_preview_widget().
func (c fileChooser) PreviewWidget() Widget {
	var _arg0 *C.GtkFileChooser // out
	var _cret *C.GtkWidget      // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_file_chooser_get_preview_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// PreviewWidgetActive gets whether the preview widget set by
// gtk_file_chooser_set_preview_widget() should be shown for the current
// filename. See gtk_file_chooser_set_preview_widget_active().
func (c fileChooser) PreviewWidgetActive() bool {
	var _arg0 *C.GtkFileChooser // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_file_chooser_get_preview_widget_active(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SelectMultiple gets whether multiple files can be selected in the file
// selector. See gtk_file_chooser_set_select_multiple().
func (c fileChooser) SelectMultiple() bool {
	var _arg0 *C.GtkFileChooser // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_file_chooser_get_select_multiple(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowHidden gets whether hidden files and folders are displayed in the file
// selector. See gtk_file_chooser_set_show_hidden().
func (c fileChooser) ShowHidden() bool {
	var _arg0 *C.GtkFileChooser // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_file_chooser_get_show_hidden(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// URI gets the URI for the currently selected file in the file selector. If
// multiple files are selected, one of the filenames will be returned at random.
//
// If the file chooser is in folder mode, this function returns the selected
// folder.
func (c fileChooser) URI() string {
	var _arg0 *C.GtkFileChooser // out
	var _cret *C.gchar          // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_file_chooser_get_uri(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UsePreviewLabel gets whether a stock label should be drawn with the name of
// the previewed file. See gtk_file_chooser_set_use_preview_label().
func (c fileChooser) UsePreviewLabel() bool {
	var _arg0 *C.GtkFileChooser // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_file_chooser_get_use_preview_label(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveChoice removes a 'choice' that has been added with
// gtk_file_chooser_add_choice().
func (c fileChooser) RemoveChoice(id string) {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(id))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_file_chooser_remove_choice(_arg0, _arg1)
}

// RemoveFilter removes @filter from the list of filters that the user can
// select between.
func (c fileChooser) RemoveFilter(filter FileFilter) {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.GtkFileFilter  // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkFileFilter)(unsafe.Pointer(filter.Native()))

	C.gtk_file_chooser_remove_filter(_arg0, _arg1)
}

// RemoveShortcutFolder removes a folder from a file chooser’s list of shortcut
// folders.
func (c fileChooser) RemoveShortcutFolder(folder string) error {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.char           // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(folder))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_file_chooser_remove_shortcut_folder(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// RemoveShortcutFolderURI removes a folder URI from a file chooser’s list of
// shortcut folders.
func (c fileChooser) RemoveShortcutFolderURI(uri string) error {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.char           // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_file_chooser_remove_shortcut_folder_uri(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// SelectAll selects all the files in the current folder of a file chooser.
func (c fileChooser) SelectAll() {
	var _arg0 *C.GtkFileChooser // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	C.gtk_file_chooser_select_all(_arg0)
}

// SelectFile selects the file referred to by @file. An internal function. See
// _gtk_file_chooser_select_uri().
func (c fileChooser) SelectFile(file gio.File) error {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.GFile          // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

	C.gtk_file_chooser_select_file(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// SelectFilename selects a filename. If the file name isn’t in the current
// folder of @chooser, then the current folder of @chooser will be changed to
// the folder containing @filename.
func (c fileChooser) SelectFilename(filename string) bool {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.char           // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_file_chooser_select_filename(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SelectURI selects the file to by @uri. If the URI doesn’t refer to a file in
// the current folder of @chooser, then the current folder of @chooser will be
// changed to the folder containing @filename.
func (c fileChooser) SelectURI(uri string) bool {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.char           // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_file_chooser_select_uri(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetAction sets the type of operation that the chooser is performing; the user
// interface is adapted to suit the selected action. For example, an option to
// create a new folder might be shown if the action is
// GTK_FILE_CHOOSER_ACTION_SAVE but not if the action is
// GTK_FILE_CHOOSER_ACTION_OPEN.
func (c fileChooser) SetAction(action FileChooserAction) {
	var _arg0 *C.GtkFileChooser      // out
	var _arg1 C.GtkFileChooserAction // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GtkFileChooserAction)(action)

	C.gtk_file_chooser_set_action(_arg0, _arg1)
}

// SetChoice selects an option in a 'choice' that has been added with
// gtk_file_chooser_add_choice(). For a boolean choice, the possible options are
// "true" and "false".
func (c fileChooser) SetChoice(id string, option string) {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.char           // out
	var _arg2 *C.char           // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(id))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(C.CString(option))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_file_chooser_set_choice(_arg0, _arg1, _arg2)
}

// SetCreateFolders sets whether file choser will offer to create new folders.
// This is only relevant if the action is not set to be
// GTK_FILE_CHOOSER_ACTION_OPEN.
func (c fileChooser) SetCreateFolders(createFolders bool) {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	if createFolders {
		_arg1 = C.TRUE
	}

	C.gtk_file_chooser_set_create_folders(_arg0, _arg1)
}

// SetCurrentFolder sets the current folder for @chooser from a local filename.
// The user will be shown the full contents of the current folder, plus user
// interface elements for navigating to other folders.
//
// In general, you should not use this function. See the [section on setting up
// a file chooser dialog][gtkfilechooserdialog-setting-up] for the rationale
// behind this.
func (c fileChooser) SetCurrentFolder(filename string) bool {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.gchar          // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_file_chooser_set_current_folder(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetCurrentFolderFile sets the current folder for @chooser from a #GFile.
// Internal function, see gtk_file_chooser_set_current_folder_uri().
func (c fileChooser) SetCurrentFolderFile(file gio.File) error {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.GFile          // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

	C.gtk_file_chooser_set_current_folder_file(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// SetCurrentFolderURI sets the current folder for @chooser from an URI. The
// user will be shown the full contents of the current folder, plus user
// interface elements for navigating to other folders.
//
// In general, you should not use this function. See the [section on setting up
// a file chooser dialog][gtkfilechooserdialog-setting-up] for the rationale
// behind this.
func (c fileChooser) SetCurrentFolderURI(uri string) bool {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.gchar          // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_file_chooser_set_current_folder_uri(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetCurrentName sets the current name in the file selector, as if entered by
// the user. Note that the name passed in here is a UTF-8 string rather than a
// filename. This function is meant for such uses as a suggested name in a “Save
// As...” dialog. You can pass “Untitled.doc” or a similarly suitable suggestion
// for the @name.
//
// If you want to preselect a particular existing file, you should use
// gtk_file_chooser_set_filename() or gtk_file_chooser_set_uri() instead. Please
// see the documentation for those functions for an example of using
// gtk_file_chooser_set_current_name() as well.
func (c fileChooser) SetCurrentName(name string) {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.gchar          // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_file_chooser_set_current_name(_arg0, _arg1)
}

// SetDoOverwriteConfirmation sets whether a file chooser in
// GTK_FILE_CHOOSER_ACTION_SAVE mode will present a confirmation dialog if the
// user types a file name that already exists. This is false by default.
//
// If set to true, the @chooser will emit the FileChooser::confirm-overwrite
// signal when appropriate.
//
// If all you need is the stock confirmation dialog, set this property to true.
// You can override the way confirmation is done by actually handling the
// FileChooser::confirm-overwrite signal; please refer to its documentation for
// the details.
func (c fileChooser) SetDoOverwriteConfirmation(doOverwriteConfirmation bool) {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	if doOverwriteConfirmation {
		_arg1 = C.TRUE
	}

	C.gtk_file_chooser_set_do_overwrite_confirmation(_arg0, _arg1)
}

// SetExtraWidget sets an application-supplied widget to provide extra options
// to the user.
func (c fileChooser) SetExtraWidget(extraWidget Widget) {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.GtkWidget      // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(extraWidget.Native()))

	C.gtk_file_chooser_set_extra_widget(_arg0, _arg1)
}

// SetFile sets @file as the current filename for the file chooser, by changing
// to the file’s parent folder and actually selecting the file in list. If the
// @chooser is in GTK_FILE_CHOOSER_ACTION_SAVE mode, the file’s base name will
// also appear in the dialog’s file name entry.
//
// If the file name isn’t in the current folder of @chooser, then the current
// folder of @chooser will be changed to the folder containing @filename. This
// is equivalent to a sequence of gtk_file_chooser_unselect_all() followed by
// gtk_file_chooser_select_filename().
//
// Note that the file must exist, or nothing will be done except for the
// directory change.
//
// If you are implementing a save dialog, you should use this function if you
// already have a file name to which the user may save; for example, when the
// user opens an existing file and then does Save As... If you don’t have a file
// name already — for example, if the user just created a new file and is saving
// it for the first time, do not call this function. Instead, use something
// similar to this:
//
//    if (document_is_new)
//      {
//        // the user just created a new document
//        gtk_file_chooser_set_current_folder_file (chooser, default_file_for_saving);
//        gtk_file_chooser_set_current_name (chooser, "Untitled document");
//      }
//    else
//      {
//        // the user edited an existing document
//        gtk_file_chooser_set_file (chooser, existing_file);
//      }
func (c fileChooser) SetFile(file gio.File) error {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.GFile          // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

	C.gtk_file_chooser_set_file(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// SetFilename sets @filename as the current filename for the file chooser, by
// changing to the file’s parent folder and actually selecting the file in list;
// all other files will be unselected. If the @chooser is in
// GTK_FILE_CHOOSER_ACTION_SAVE mode, the file’s base name will also appear in
// the dialog’s file name entry.
//
// Note that the file must exist, or nothing will be done except for the
// directory change.
//
// You should use this function only when implementing a save dialog for which
// you already have a file name to which the user may save. For example, when
// the user opens an existing file and then does Save As... to save a copy or a
// modified version. If you don’t have a file name already — for example, if the
// user just created a new file and is saving it for the first time, do not call
// this function. Instead, use something similar to this:
//
//    if (document_is_new)
//      {
//        // the user just created a new document
//        gtk_file_chooser_set_current_name (chooser, "Untitled document");
//      }
//    else
//      {
//        // the user edited an existing document
//        gtk_file_chooser_set_filename (chooser, existing_filename);
//      }
//
// In the first case, the file chooser will present the user with useful
// suggestions as to where to save his new file. In the second case, the file’s
// existing location is already known, so the file chooser will use it.
func (c fileChooser) SetFilename(filename string) bool {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.char           // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_file_chooser_set_filename(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetFilter sets the current filter; only the files that pass the filter will
// be displayed. If the user-selectable list of filters is non-empty, then the
// filter should be one of the filters in that list. Setting the current filter
// when the list of filters is empty is useful if you want to restrict the
// displayed set of files without letting the user change it.
func (c fileChooser) SetFilter(filter FileFilter) {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.GtkFileFilter  // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkFileFilter)(unsafe.Pointer(filter.Native()))

	C.gtk_file_chooser_set_filter(_arg0, _arg1)
}

// SetLocalOnly sets whether only local files can be selected in the file
// selector. If @local_only is true (the default), then the selected file or
// files are guaranteed to be accessible through the operating systems native
// file system and therefore the application only needs to worry about the
// filename functions in FileChooser, like gtk_file_chooser_get_filename(),
// rather than the URI functions like gtk_file_chooser_get_uri(),
//
// On some systems non-native files may still be available using the native
// filesystem via a userspace filesystem (FUSE).
func (c fileChooser) SetLocalOnly(localOnly bool) {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	if localOnly {
		_arg1 = C.TRUE
	}

	C.gtk_file_chooser_set_local_only(_arg0, _arg1)
}

// SetPreviewWidget sets an application-supplied widget to use to display a
// custom preview of the currently selected file. To implement a preview, after
// setting the preview widget, you connect to the FileChooser::update-preview
// signal, and call gtk_file_chooser_get_preview_filename() or
// gtk_file_chooser_get_preview_uri() on each change. If you can display a
// preview of the new file, update your widget and set the preview active using
// gtk_file_chooser_set_preview_widget_active(). Otherwise, set the preview
// inactive.
//
// When there is no application-supplied preview widget, or the
// application-supplied preview widget is not active, the file chooser will
// display no preview at all.
func (c fileChooser) SetPreviewWidget(previewWidget Widget) {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.GtkWidget      // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(previewWidget.Native()))

	C.gtk_file_chooser_set_preview_widget(_arg0, _arg1)
}

// SetPreviewWidgetActive sets whether the preview widget set by
// gtk_file_chooser_set_preview_widget() should be shown for the current
// filename. When @active is set to false, the file chooser may display an
// internally generated preview of the current file or it may display no preview
// at all. See gtk_file_chooser_set_preview_widget() for more details.
func (c fileChooser) SetPreviewWidgetActive(active bool) {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	if active {
		_arg1 = C.TRUE
	}

	C.gtk_file_chooser_set_preview_widget_active(_arg0, _arg1)
}

// SetSelectMultiple sets whether multiple files can be selected in the file
// selector. This is only relevant if the action is set to be
// GTK_FILE_CHOOSER_ACTION_OPEN or GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER.
func (c fileChooser) SetSelectMultiple(selectMultiple bool) {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	if selectMultiple {
		_arg1 = C.TRUE
	}

	C.gtk_file_chooser_set_select_multiple(_arg0, _arg1)
}

// SetShowHidden sets whether hidden files and folders are displayed in the file
// selector.
func (c fileChooser) SetShowHidden(showHidden bool) {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	if showHidden {
		_arg1 = C.TRUE
	}

	C.gtk_file_chooser_set_show_hidden(_arg0, _arg1)
}

// SetURI sets the file referred to by @uri as the current file for the file
// chooser, by changing to the URI’s parent folder and actually selecting the
// URI in the list. If the @chooser is GTK_FILE_CHOOSER_ACTION_SAVE mode, the
// URI’s base name will also appear in the dialog’s file name entry.
//
// Note that the URI must exist, or nothing will be done except for the
// directory change.
//
// You should use this function only when implementing a save dialog for which
// you already have a file name to which the user may save. For example, when
// the user opens an existing file and then does Save As... to save a copy or a
// modified version. If you don’t have a file name already — for example, if the
// user just created a new file and is saving it for the first time, do not call
// this function. Instead, use something similar to this:
//
//    if (document_is_new)
//      {
//        // the user just created a new document
//        gtk_file_chooser_set_current_name (chooser, "Untitled document");
//      }
//    else
//      {
//        // the user edited an existing document
//        gtk_file_chooser_set_uri (chooser, existing_uri);
//      }
//
// In the first case, the file chooser will present the user with useful
// suggestions as to where to save his new file. In the second case, the file’s
// existing location is already known, so the file chooser will use it.
func (c fileChooser) SetURI(uri string) bool {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.char           // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_file_chooser_set_uri(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetUsePreviewLabel sets whether the file chooser should display a stock label
// with the name of the file that is being previewed; the default is true.
// Applications that want to draw the whole preview area themselves should set
// this to false and display the name themselves in their preview widget.
//
// See also: gtk_file_chooser_set_preview_widget()
func (c fileChooser) SetUsePreviewLabel(useLabel bool) {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	if useLabel {
		_arg1 = C.TRUE
	}

	C.gtk_file_chooser_set_use_preview_label(_arg0, _arg1)
}

// UnselectAll unselects all the files in the current folder of a file chooser.
func (c fileChooser) UnselectAll() {
	var _arg0 *C.GtkFileChooser // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	C.gtk_file_chooser_unselect_all(_arg0)
}

// UnselectFile unselects the file referred to by @file. If the file is not in
// the current directory, does not exist, or is otherwise not currently
// selected, does nothing.
func (c fileChooser) UnselectFile(file gio.File) {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.GFile          // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

	C.gtk_file_chooser_unselect_file(_arg0, _arg1)
}

// UnselectFilename unselects a currently selected filename. If the filename is
// not in the current directory, does not exist, or is otherwise not currently
// selected, does nothing.
func (c fileChooser) UnselectFilename(filename string) {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_file_chooser_unselect_filename(_arg0, _arg1)
}

// UnselectURI unselects the file referred to by @uri. If the file is not in the
// current directory, does not exist, or is otherwise not currently selected,
// does nothing.
func (c fileChooser) UnselectURI(uri string) {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_file_chooser_unselect_uri(_arg0, _arg1)
}

// FontChooserOverrider contains methods that are overridable. This
// interface is a subset of the interface FontChooser.
type FontChooserOverrider interface {
	FontActivated(fontname string)
	// FontFace gets the FontFace representing the selected font group details
	// (i.e. family, slant, weight, width, etc).
	//
	// If the selected font is not installed, returns nil.
	FontFace() pango.FontFace
	// FontFamily gets the FontFamily representing the selected font family.
	// Font families are a collection of font faces.
	//
	// If the selected font is not installed, returns nil.
	FontFamily() pango.FontFamily
	// FontMap gets the custom font map of this font chooser widget, or nil if
	// it does not have one.
	FontMap() pango.FontMap
	// FontSize: the selected font size.
	FontSize() int
	// SetFontMap sets a custom font map to use for this font chooser widget. A
	// custom font map can be used to present application-specific fonts instead
	// of or in addition to the normal system fonts.
	//
	//    FcConfig *config;
	//    PangoFontMap *fontmap;
	//
	//    config = FcInitLoadConfigAndFonts ();
	//    FcConfigAppFontAddFile (config, my_app_font_file);
	//
	//    fontmap = pango_cairo_font_map_new_for_font_type (CAIRO_FONT_TYPE_FT);
	//    pango_fc_font_map_set_config (PANGO_FC_FONT_MAP (fontmap), config);
	//
	//    gtk_font_chooser_set_font_map (font_chooser, fontmap);
	//
	// Note that other GTK+ widgets will only be able to use the
	// application-specific font if it is present in the font map they use:
	//
	//    context = gtk_widget_get_pango_context (label);
	//    pango_context_set_font_map (context, fontmap);
	SetFontMap(fontmap pango.FontMap)
}

// FontChooser is an interface that can be implemented by widgets displaying the
// list of fonts. In GTK+, the main objects that implement this interface are
// FontChooserWidget, FontChooserDialog and FontButton. The GtkFontChooser
// interface has been introducted in GTK+ 3.2.
type FontChooser interface {
	gextras.Objector
	FontChooserOverrider

	// Font gets the currently-selected font name.
	//
	// Note that this can be a different string than what you set with
	// gtk_font_chooser_set_font(), as the font chooser widget may normalize
	// font names and thus return a string with a different structure. For
	// example, “Helvetica Italic Bold 12” could be normalized to “Helvetica
	// Bold Italic 12”.
	//
	// Use pango_font_description_equal() if you want to compare two font
	// descriptions.
	Font() string
	// FontDesc gets the currently-selected font.
	//
	// Note that this can be a different string than what you set with
	// gtk_font_chooser_set_font(), as the font chooser widget may normalize
	// font names and thus return a string with a different structure. For
	// example, “Helvetica Italic Bold 12” could be normalized to “Helvetica
	// Bold Italic 12”.
	//
	// Use pango_font_description_equal() if you want to compare two font
	// descriptions.
	FontDesc() *pango.FontDescription
	// FontFeatures gets the currently-selected font features.
	FontFeatures() string
	// Language gets the language that is used for font features.
	Language() string
	// Level returns the current level of granularity for selecting fonts.
	Level() FontChooserLevel
	// PreviewText gets the text displayed in the preview area.
	PreviewText() string
	// ShowPreviewEntry returns whether the preview entry is shown or not.
	ShowPreviewEntry() bool
	// SetFont sets the currently-selected font.
	SetFont(fontname string)
	// SetFontDesc sets the currently-selected font from @font_desc.
	SetFontDesc(fontDesc *pango.FontDescription)
	// SetLanguage sets the language to use for font features.
	SetLanguage(language string)
	// SetLevel sets the desired level of granularity for selecting fonts.
	SetLevel(level FontChooserLevel)
	// SetPreviewText sets the text displayed in the preview area. The @text is
	// used to show how the selected font looks.
	SetPreviewText(text string)
	// SetShowPreviewEntry shows or hides the editable preview entry.
	SetShowPreviewEntry(showPreviewEntry bool)
}

// fontChooser implements the FontChooser interface.
type fontChooser struct {
	gextras.Objector
}

var _ FontChooser = (*fontChooser)(nil)

// WrapFontChooser wraps a GObject to a type that implements interface
// FontChooser. It is primarily used internally.
func WrapFontChooser(obj *externglib.Object) FontChooser {
	return fontChooser{
		Objector: obj,
	}
}

func marshalFontChooser(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFontChooser(obj), nil
}

// Font gets the currently-selected font name.
//
// Note that this can be a different string than what you set with
// gtk_font_chooser_set_font(), as the font chooser widget may normalize font
// names and thus return a string with a different structure. For example,
// “Helvetica Italic Bold 12” could be normalized to “Helvetica Bold Italic 12”.
//
// Use pango_font_description_equal() if you want to compare two font
// descriptions.
func (f fontChooser) Font() string {
	var _arg0 *C.GtkFontChooser // out
	var _cret *C.gchar          // in

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_chooser_get_font(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// FontDesc gets the currently-selected font.
//
// Note that this can be a different string than what you set with
// gtk_font_chooser_set_font(), as the font chooser widget may normalize font
// names and thus return a string with a different structure. For example,
// “Helvetica Italic Bold 12” could be normalized to “Helvetica Bold Italic 12”.
//
// Use pango_font_description_equal() if you want to compare two font
// descriptions.
func (f fontChooser) FontDesc() *pango.FontDescription {
	var _arg0 *C.GtkFontChooser       // out
	var _cret *C.PangoFontDescription // in

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_chooser_get_font_desc(_arg0)

	var _fontDescription *pango.FontDescription // out

	_fontDescription = pango.WrapFontDescription(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_fontDescription, func(v *pango.FontDescription) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _fontDescription
}

// FontFace gets the FontFace representing the selected font group details (i.e.
// family, slant, weight, width, etc).
//
// If the selected font is not installed, returns nil.
func (f fontChooser) FontFace() pango.FontFace {
	var _arg0 *C.GtkFontChooser // out
	var _cret *C.PangoFontFace  // in

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_chooser_get_font_face(_arg0)

	var _fontFace pango.FontFace // out

	_fontFace = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(pango.FontFace)

	return _fontFace
}

// FontFamily gets the FontFamily representing the selected font family. Font
// families are a collection of font faces.
//
// If the selected font is not installed, returns nil.
func (f fontChooser) FontFamily() pango.FontFamily {
	var _arg0 *C.GtkFontChooser  // out
	var _cret *C.PangoFontFamily // in

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_chooser_get_font_family(_arg0)

	var _fontFamily pango.FontFamily // out

	_fontFamily = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(pango.FontFamily)

	return _fontFamily
}

// FontFeatures gets the currently-selected font features.
func (f fontChooser) FontFeatures() string {
	var _arg0 *C.GtkFontChooser // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_chooser_get_font_features(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// FontMap gets the custom font map of this font chooser widget, or nil if it
// does not have one.
func (f fontChooser) FontMap() pango.FontMap {
	var _arg0 *C.GtkFontChooser // out
	var _cret *C.PangoFontMap   // in

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_chooser_get_font_map(_arg0)

	var _fontMap pango.FontMap // out

	_fontMap = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(pango.FontMap)

	return _fontMap
}

// FontSize: the selected font size.
func (f fontChooser) FontSize() int {
	var _arg0 *C.GtkFontChooser // out
	var _cret C.gint            // in

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_chooser_get_font_size(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Language gets the language that is used for font features.
func (f fontChooser) Language() string {
	var _arg0 *C.GtkFontChooser // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_chooser_get_language(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Level returns the current level of granularity for selecting fonts.
func (f fontChooser) Level() FontChooserLevel {
	var _arg0 *C.GtkFontChooser     // out
	var _cret C.GtkFontChooserLevel // in

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_chooser_get_level(_arg0)

	var _fontChooserLevel FontChooserLevel // out

	_fontChooserLevel = FontChooserLevel(_cret)

	return _fontChooserLevel
}

// PreviewText gets the text displayed in the preview area.
func (f fontChooser) PreviewText() string {
	var _arg0 *C.GtkFontChooser // out
	var _cret *C.gchar          // in

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_chooser_get_preview_text(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ShowPreviewEntry returns whether the preview entry is shown or not.
func (f fontChooser) ShowPreviewEntry() bool {
	var _arg0 *C.GtkFontChooser // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_chooser_get_show_preview_entry(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetFont sets the currently-selected font.
func (f fontChooser) SetFont(fontname string) {
	var _arg0 *C.GtkFontChooser // out
	var _arg1 *C.gchar          // out

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.gchar)(C.CString(fontname))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_font_chooser_set_font(_arg0, _arg1)
}

// SetFontDesc sets the currently-selected font from @font_desc.
func (f fontChooser) SetFontDesc(fontDesc *pango.FontDescription) {
	var _arg0 *C.GtkFontChooser       // out
	var _arg1 *C.PangoFontDescription // out

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.PangoFontDescription)(unsafe.Pointer(fontDesc.Native()))

	C.gtk_font_chooser_set_font_desc(_arg0, _arg1)
}

// SetFontMap sets a custom font map to use for this font chooser widget. A
// custom font map can be used to present application-specific fonts instead of
// or in addition to the normal system fonts.
//
//    FcConfig *config;
//    PangoFontMap *fontmap;
//
//    config = FcInitLoadConfigAndFonts ();
//    FcConfigAppFontAddFile (config, my_app_font_file);
//
//    fontmap = pango_cairo_font_map_new_for_font_type (CAIRO_FONT_TYPE_FT);
//    pango_fc_font_map_set_config (PANGO_FC_FONT_MAP (fontmap), config);
//
//    gtk_font_chooser_set_font_map (font_chooser, fontmap);
//
// Note that other GTK+ widgets will only be able to use the
// application-specific font if it is present in the font map they use:
//
//    context = gtk_widget_get_pango_context (label);
//    pango_context_set_font_map (context, fontmap);
func (f fontChooser) SetFontMap(fontmap pango.FontMap) {
	var _arg0 *C.GtkFontChooser // out
	var _arg1 *C.PangoFontMap   // out

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.PangoFontMap)(unsafe.Pointer(fontmap.Native()))

	C.gtk_font_chooser_set_font_map(_arg0, _arg1)
}

// SetLanguage sets the language to use for font features.
func (f fontChooser) SetLanguage(language string) {
	var _arg0 *C.GtkFontChooser // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.char)(C.CString(language))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_font_chooser_set_language(_arg0, _arg1)
}

// SetLevel sets the desired level of granularity for selecting fonts.
func (f fontChooser) SetLevel(level FontChooserLevel) {
	var _arg0 *C.GtkFontChooser     // out
	var _arg1 C.GtkFontChooserLevel // out

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))
	_arg1 = (C.GtkFontChooserLevel)(level)

	C.gtk_font_chooser_set_level(_arg0, _arg1)
}

// SetPreviewText sets the text displayed in the preview area. The @text is used
// to show how the selected font looks.
func (f fontChooser) SetPreviewText(text string) {
	var _arg0 *C.GtkFontChooser // out
	var _arg1 *C.gchar          // out

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_font_chooser_set_preview_text(_arg0, _arg1)
}

// SetShowPreviewEntry shows or hides the editable preview entry.
func (f fontChooser) SetShowPreviewEntry(showPreviewEntry bool) {
	var _arg0 *C.GtkFontChooser // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))
	if showPreviewEntry {
		_arg1 = C.TRUE
	}

	C.gtk_font_chooser_set_show_preview_entry(_arg0, _arg1)
}

// Orientable: the Orientable interface is implemented by all widgets that can
// be oriented horizontally or vertically. Historically, such widgets have been
// realized as subclasses of a common base class (e.g Box/HBox/VBox or
// Scale/HScale/VScale). Orientable is more flexible in that it allows the
// orientation to be changed at runtime, allowing the widgets to “flip”.
//
// Orientable was introduced in GTK+ 2.16.
type Orientable interface {
	gextras.Objector

	// Orientation retrieves the orientation of the @orientable.
	Orientation() Orientation
	// SetOrientation sets the orientation of the @orientable.
	SetOrientation(orientation Orientation)
}

// orientable implements the Orientable interface.
type orientable struct {
	gextras.Objector
}

var _ Orientable = (*orientable)(nil)

// WrapOrientable wraps a GObject to a type that implements interface
// Orientable. It is primarily used internally.
func WrapOrientable(obj *externglib.Object) Orientable {
	return orientable{
		Objector: obj,
	}
}

func marshalOrientable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapOrientable(obj), nil
}

// Orientation retrieves the orientation of the @orientable.
func (o orientable) Orientation() Orientation {
	var _arg0 *C.GtkOrientable // out
	var _cret C.GtkOrientation // in

	_arg0 = (*C.GtkOrientable)(unsafe.Pointer(o.Native()))

	_cret = C.gtk_orientable_get_orientation(_arg0)

	var _orientation Orientation // out

	_orientation = Orientation(_cret)

	return _orientation
}

// SetOrientation sets the orientation of the @orientable.
func (o orientable) SetOrientation(orientation Orientation) {
	var _arg0 *C.GtkOrientable // out
	var _arg1 C.GtkOrientation // out

	_arg0 = (*C.GtkOrientable)(unsafe.Pointer(o.Native()))
	_arg1 = (C.GtkOrientation)(orientation)

	C.gtk_orientable_set_orientation(_arg0, _arg1)
}

// PrintOperationPreviewOverrider contains methods that are overridable. This
// interface is a subset of the interface PrintOperationPreview.
type PrintOperationPreviewOverrider interface {
	// EndPreview ends a preview.
	//
	// This function must be called to finish a custom print preview.
	EndPreview()

	GotPageSize(context PrintContext, pageSetup PageSetup)
	// IsSelected returns whether the given page is included in the set of pages
	// that have been selected for printing.
	IsSelected(pageNr int) bool

	Ready(context PrintContext)
	// RenderPage renders a page to the preview, using the print context that
	// was passed to the PrintOperation::preview handler together with @preview.
	//
	// A custom iprint preview should use this function in its ::expose handler
	// to render the currently selected page.
	//
	// Note that this function requires a suitable cairo context to be
	// associated with the print context.
	RenderPage(pageNr int)
}

type PrintOperationPreview interface {
	gextras.Objector
	PrintOperationPreviewOverrider
}

// printOperationPreview implements the PrintOperationPreview interface.
type printOperationPreview struct {
	gextras.Objector
}

var _ PrintOperationPreview = (*printOperationPreview)(nil)

// WrapPrintOperationPreview wraps a GObject to a type that implements interface
// PrintOperationPreview. It is primarily used internally.
func WrapPrintOperationPreview(obj *externglib.Object) PrintOperationPreview {
	return printOperationPreview{
		Objector: obj,
	}
}

func marshalPrintOperationPreview(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPrintOperationPreview(obj), nil
}

// EndPreview ends a preview.
//
// This function must be called to finish a custom print preview.
func (p printOperationPreview) EndPreview() {
	var _arg0 *C.GtkPrintOperationPreview // out

	_arg0 = (*C.GtkPrintOperationPreview)(unsafe.Pointer(p.Native()))

	C.gtk_print_operation_preview_end_preview(_arg0)
}

// IsSelected returns whether the given page is included in the set of pages
// that have been selected for printing.
func (p printOperationPreview) IsSelected(pageNr int) bool {
	var _arg0 *C.GtkPrintOperationPreview // out
	var _arg1 C.gint                      // out
	var _cret C.gboolean                  // in

	_arg0 = (*C.GtkPrintOperationPreview)(unsafe.Pointer(p.Native()))
	_arg1 = (C.gint)(pageNr)

	_cret = C.gtk_print_operation_preview_is_selected(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RenderPage renders a page to the preview, using the print context that was
// passed to the PrintOperation::preview handler together with @preview.
//
// A custom iprint preview should use this function in its ::expose handler to
// render the currently selected page.
//
// Note that this function requires a suitable cairo context to be associated
// with the print context.
func (p printOperationPreview) RenderPage(pageNr int) {
	var _arg0 *C.GtkPrintOperationPreview // out
	var _arg1 C.gint                      // out

	_arg0 = (*C.GtkPrintOperationPreview)(unsafe.Pointer(p.Native()))
	_arg1 = (C.gint)(pageNr)

	C.gtk_print_operation_preview_render_page(_arg0, _arg1)
}

// RecentChooserOverrider contains methods that are overridable. This
// interface is a subset of the interface RecentChooser.
type RecentChooserOverrider interface {
	// AddFilter adds @filter to the list of RecentFilter objects held by
	// @chooser.
	//
	// If no previous filter objects were defined, this function will call
	// gtk_recent_chooser_set_filter().
	AddFilter(filter RecentFilter)
	// CurrentURI gets the URI currently selected by @chooser.
	CurrentURI() string

	ItemActivated()
	// RemoveFilter removes @filter from the list of RecentFilter objects held
	// by @chooser.
	RemoveFilter(filter RecentFilter)
	// SelectAll selects all the items inside @chooser, if the @chooser supports
	// multiple selection.
	SelectAll()
	// SelectURI selects @uri inside @chooser.
	SelectURI(uri string) error

	SelectionChanged()
	// SetCurrentURI sets @uri as the current URI for @chooser.
	SetCurrentURI(uri string) error
	// UnselectAll unselects all the items inside @chooser.
	UnselectAll()
	// UnselectURI unselects @uri inside @chooser.
	UnselectURI(uri string)
}

// RecentChooser is an interface that can be implemented by widgets displaying
// the list of recently used files. In GTK+, the main objects that implement
// this interface are RecentChooserWidget, RecentChooserDialog and
// RecentChooserMenu.
//
// Recently used files are supported since GTK+ 2.10.
type RecentChooser interface {
	gextras.Objector
	RecentChooserOverrider

	// CurrentItem gets the RecentInfo currently selected by @chooser.
	CurrentItem() *RecentInfo
	// Filter gets the RecentFilter object currently used by @chooser to affect
	// the display of the recently used resources.
	Filter() RecentFilter
	// Limit gets the number of items returned by gtk_recent_chooser_get_items()
	// and gtk_recent_chooser_get_uris().
	Limit() int
	// LocalOnly gets whether only local resources should be shown in the
	// recently used resources selector. See gtk_recent_chooser_set_local_only()
	LocalOnly() bool
	// SelectMultiple gets whether @chooser can select multiple items.
	SelectMultiple() bool
	// ShowIcons retrieves whether @chooser should show an icon near the
	// resource.
	ShowIcons() bool
	// ShowNotFound retrieves whether @chooser should show the recently used
	// resources that were not found.
	ShowNotFound() bool
	// ShowPrivate returns whether @chooser should display recently used
	// resources registered as private.
	ShowPrivate() bool
	// ShowTips gets whether @chooser should display tooltips containing the
	// full path of a recently user resource.
	ShowTips() bool
	// SortType gets the value set by gtk_recent_chooser_set_sort_type().
	SortType() RecentSortType
	// SetFilter sets @filter as the current RecentFilter object used by
	// @chooser to affect the displayed recently used resources.
	SetFilter(filter RecentFilter)
	// SetLimit sets the number of items that should be returned by
	// gtk_recent_chooser_get_items() and gtk_recent_chooser_get_uris().
	SetLimit(limit int)
	// SetLocalOnly sets whether only local resources, that is resources using
	// the file:// URI scheme, should be shown in the recently used resources
	// selector. If @local_only is true (the default) then the shown resources
	// are guaranteed to be accessible through the operating system native file
	// system.
	SetLocalOnly(localOnly bool)
	// SetSelectMultiple sets whether @chooser can select multiple items.
	SetSelectMultiple(selectMultiple bool)
	// SetShowIcons sets whether @chooser should show an icon near the resource
	// when displaying it.
	SetShowIcons(showIcons bool)
	// SetShowNotFound sets whether @chooser should display the recently used
	// resources that it didn’t find. This only applies to local resources.
	SetShowNotFound(showNotFound bool)
	// SetShowPrivate: whether to show recently used resources marked registered
	// as private.
	SetShowPrivate(showPrivate bool)
	// SetShowTips sets whether to show a tooltips containing the full path of
	// each recently used resource in a RecentChooser widget.
	SetShowTips(showTips bool)
	// SetSortType changes the sorting order of the recently used resources list
	// displayed by @chooser.
	SetSortType(sortType RecentSortType)
}

// recentChooser implements the RecentChooser interface.
type recentChooser struct {
	gextras.Objector
}

var _ RecentChooser = (*recentChooser)(nil)

// WrapRecentChooser wraps a GObject to a type that implements interface
// RecentChooser. It is primarily used internally.
func WrapRecentChooser(obj *externglib.Object) RecentChooser {
	return recentChooser{
		Objector: obj,
	}
}

func marshalRecentChooser(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRecentChooser(obj), nil
}

// AddFilter adds @filter to the list of RecentFilter objects held by @chooser.
//
// If no previous filter objects were defined, this function will call
// gtk_recent_chooser_set_filter().
func (c recentChooser) AddFilter(filter RecentFilter) {
	var _arg0 *C.GtkRecentChooser // out
	var _arg1 *C.GtkRecentFilter  // out

	_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkRecentFilter)(unsafe.Pointer(filter.Native()))

	C.gtk_recent_chooser_add_filter(_arg0, _arg1)
}

// CurrentItem gets the RecentInfo currently selected by @chooser.
func (c recentChooser) CurrentItem() *RecentInfo {
	var _arg0 *C.GtkRecentChooser // out
	var _cret *C.GtkRecentInfo    // in

	_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_recent_chooser_get_current_item(_arg0)

	var _recentInfo *RecentInfo // out

	_recentInfo = WrapRecentInfo(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_recentInfo, func(v *RecentInfo) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _recentInfo
}

// CurrentURI gets the URI currently selected by @chooser.
func (c recentChooser) CurrentURI() string {
	var _arg0 *C.GtkRecentChooser // out
	var _cret *C.gchar            // in

	_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_recent_chooser_get_current_uri(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Filter gets the RecentFilter object currently used by @chooser to affect the
// display of the recently used resources.
func (c recentChooser) Filter() RecentFilter {
	var _arg0 *C.GtkRecentChooser // out
	var _cret *C.GtkRecentFilter  // in

	_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_recent_chooser_get_filter(_arg0)

	var _recentFilter RecentFilter // out

	_recentFilter = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RecentFilter)

	return _recentFilter
}

// Limit gets the number of items returned by gtk_recent_chooser_get_items() and
// gtk_recent_chooser_get_uris().
func (c recentChooser) Limit() int {
	var _arg0 *C.GtkRecentChooser // out
	var _cret C.gint              // in

	_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_recent_chooser_get_limit(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// LocalOnly gets whether only local resources should be shown in the recently
// used resources selector. See gtk_recent_chooser_set_local_only()
func (c recentChooser) LocalOnly() bool {
	var _arg0 *C.GtkRecentChooser // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_recent_chooser_get_local_only(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SelectMultiple gets whether @chooser can select multiple items.
func (c recentChooser) SelectMultiple() bool {
	var _arg0 *C.GtkRecentChooser // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_recent_chooser_get_select_multiple(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowIcons retrieves whether @chooser should show an icon near the resource.
func (c recentChooser) ShowIcons() bool {
	var _arg0 *C.GtkRecentChooser // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_recent_chooser_get_show_icons(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowNotFound retrieves whether @chooser should show the recently used
// resources that were not found.
func (c recentChooser) ShowNotFound() bool {
	var _arg0 *C.GtkRecentChooser // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_recent_chooser_get_show_not_found(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowPrivate returns whether @chooser should display recently used resources
// registered as private.
func (c recentChooser) ShowPrivate() bool {
	var _arg0 *C.GtkRecentChooser // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_recent_chooser_get_show_private(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowTips gets whether @chooser should display tooltips containing the full
// path of a recently user resource.
func (c recentChooser) ShowTips() bool {
	var _arg0 *C.GtkRecentChooser // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_recent_chooser_get_show_tips(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SortType gets the value set by gtk_recent_chooser_set_sort_type().
func (c recentChooser) SortType() RecentSortType {
	var _arg0 *C.GtkRecentChooser // out
	var _cret C.GtkRecentSortType // in

	_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_recent_chooser_get_sort_type(_arg0)

	var _recentSortType RecentSortType // out

	_recentSortType = RecentSortType(_cret)

	return _recentSortType
}

// RemoveFilter removes @filter from the list of RecentFilter objects held by
// @chooser.
func (c recentChooser) RemoveFilter(filter RecentFilter) {
	var _arg0 *C.GtkRecentChooser // out
	var _arg1 *C.GtkRecentFilter  // out

	_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkRecentFilter)(unsafe.Pointer(filter.Native()))

	C.gtk_recent_chooser_remove_filter(_arg0, _arg1)
}

// SelectAll selects all the items inside @chooser, if the @chooser supports
// multiple selection.
func (c recentChooser) SelectAll() {
	var _arg0 *C.GtkRecentChooser // out

	_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))

	C.gtk_recent_chooser_select_all(_arg0)
}

// SelectURI selects @uri inside @chooser.
func (c recentChooser) SelectURI(uri string) error {
	var _arg0 *C.GtkRecentChooser // out
	var _arg1 *C.gchar            // out
	var _cerr *C.GError           // in

	_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_recent_chooser_select_uri(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// SetCurrentURI sets @uri as the current URI for @chooser.
func (c recentChooser) SetCurrentURI(uri string) error {
	var _arg0 *C.GtkRecentChooser // out
	var _arg1 *C.gchar            // out
	var _cerr *C.GError           // in

	_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_recent_chooser_set_current_uri(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// SetFilter sets @filter as the current RecentFilter object used by @chooser to
// affect the displayed recently used resources.
func (c recentChooser) SetFilter(filter RecentFilter) {
	var _arg0 *C.GtkRecentChooser // out
	var _arg1 *C.GtkRecentFilter  // out

	_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkRecentFilter)(unsafe.Pointer(filter.Native()))

	C.gtk_recent_chooser_set_filter(_arg0, _arg1)
}

// SetLimit sets the number of items that should be returned by
// gtk_recent_chooser_get_items() and gtk_recent_chooser_get_uris().
func (c recentChooser) SetLimit(limit int) {
	var _arg0 *C.GtkRecentChooser // out
	var _arg1 C.gint              // out

	_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (C.gint)(limit)

	C.gtk_recent_chooser_set_limit(_arg0, _arg1)
}

// SetLocalOnly sets whether only local resources, that is resources using the
// file:// URI scheme, should be shown in the recently used resources selector.
// If @local_only is true (the default) then the shown resources are guaranteed
// to be accessible through the operating system native file system.
func (c recentChooser) SetLocalOnly(localOnly bool) {
	var _arg0 *C.GtkRecentChooser // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))
	if localOnly {
		_arg1 = C.TRUE
	}

	C.gtk_recent_chooser_set_local_only(_arg0, _arg1)
}

// SetSelectMultiple sets whether @chooser can select multiple items.
func (c recentChooser) SetSelectMultiple(selectMultiple bool) {
	var _arg0 *C.GtkRecentChooser // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))
	if selectMultiple {
		_arg1 = C.TRUE
	}

	C.gtk_recent_chooser_set_select_multiple(_arg0, _arg1)
}

// SetShowIcons sets whether @chooser should show an icon near the resource when
// displaying it.
func (c recentChooser) SetShowIcons(showIcons bool) {
	var _arg0 *C.GtkRecentChooser // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))
	if showIcons {
		_arg1 = C.TRUE
	}

	C.gtk_recent_chooser_set_show_icons(_arg0, _arg1)
}

// SetShowNotFound sets whether @chooser should display the recently used
// resources that it didn’t find. This only applies to local resources.
func (c recentChooser) SetShowNotFound(showNotFound bool) {
	var _arg0 *C.GtkRecentChooser // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))
	if showNotFound {
		_arg1 = C.TRUE
	}

	C.gtk_recent_chooser_set_show_not_found(_arg0, _arg1)
}

// SetShowPrivate: whether to show recently used resources marked registered as
// private.
func (c recentChooser) SetShowPrivate(showPrivate bool) {
	var _arg0 *C.GtkRecentChooser // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))
	if showPrivate {
		_arg1 = C.TRUE
	}

	C.gtk_recent_chooser_set_show_private(_arg0, _arg1)
}

// SetShowTips sets whether to show a tooltips containing the full path of each
// recently used resource in a RecentChooser widget.
func (c recentChooser) SetShowTips(showTips bool) {
	var _arg0 *C.GtkRecentChooser // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))
	if showTips {
		_arg1 = C.TRUE
	}

	C.gtk_recent_chooser_set_show_tips(_arg0, _arg1)
}

// SetSortType changes the sorting order of the recently used resources list
// displayed by @chooser.
func (c recentChooser) SetSortType(sortType RecentSortType) {
	var _arg0 *C.GtkRecentChooser // out
	var _arg1 C.GtkRecentSortType // out

	_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GtkRecentSortType)(sortType)

	C.gtk_recent_chooser_set_sort_type(_arg0, _arg1)
}

// UnselectAll unselects all the items inside @chooser.
func (c recentChooser) UnselectAll() {
	var _arg0 *C.GtkRecentChooser // out

	_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))

	C.gtk_recent_chooser_unselect_all(_arg0)
}

// UnselectURI unselects @uri inside @chooser.
func (c recentChooser) UnselectURI(uri string) {
	var _arg0 *C.GtkRecentChooser // out
	var _arg1 *C.gchar            // out

	_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_recent_chooser_unselect_uri(_arg0, _arg1)
}

// ScrollableOverrider contains methods that are overridable. This
// interface is a subset of the interface Scrollable.
type ScrollableOverrider interface {
	// Border returns the size of a non-scrolling border around the outside of
	// the scrollable. An example for this would be treeview headers. GTK+ can
	// use this information to display overlayed graphics, like the overshoot
	// indication, at the right position.
	Border() (Border, bool)
}

// Scrollable is an interface that is implemented by widgets with native
// scrolling ability.
//
// To implement this interface you should override the Scrollable:hadjustment
// and Scrollable:vadjustment properties.
//
//
// Creating a scrollable widget
//
// All scrollable widgets should do the following.
//
// - When a parent widget sets the scrollable child widget’s adjustments, the
// widget should populate the adjustments’ Adjustment:lower, Adjustment:upper,
// Adjustment:step-increment, Adjustment:page-increment and Adjustment:page-size
// properties and connect to the Adjustment::value-changed signal.
//
// - Because its preferred size is the size for a fully expanded widget, the
// scrollable widget must be able to cope with underallocations. This means that
// it must accept any value passed to its WidgetClass.size_allocate() function.
//
// - When the parent allocates space to the scrollable child widget, the widget
// should update the adjustments’ properties with new values.
//
// - When any of the adjustments emits the Adjustment::value-changed signal, the
// scrollable widget should scroll its contents.
type Scrollable interface {
	gextras.Objector
	ScrollableOverrider

	// HAdjustment retrieves the Adjustment used for horizontal scrolling.
	HAdjustment() Adjustment
	// HScrollPolicy gets the horizontal ScrollablePolicy.
	HScrollPolicy() ScrollablePolicy
	// VAdjustment retrieves the Adjustment used for vertical scrolling.
	VAdjustment() Adjustment
	// VScrollPolicy gets the vertical ScrollablePolicy.
	VScrollPolicy() ScrollablePolicy
	// SetHAdjustment sets the horizontal adjustment of the Scrollable.
	SetHAdjustment(hadjustment Adjustment)
	// SetHScrollPolicy sets the ScrollablePolicy to determine whether
	// horizontal scrolling should start below the minimum width or below the
	// natural width.
	SetHScrollPolicy(policy ScrollablePolicy)
	// SetVAdjustment sets the vertical adjustment of the Scrollable.
	SetVAdjustment(vadjustment Adjustment)
	// SetVScrollPolicy sets the ScrollablePolicy to determine whether vertical
	// scrolling should start below the minimum height or below the natural
	// height.
	SetVScrollPolicy(policy ScrollablePolicy)
}

// scrollable implements the Scrollable interface.
type scrollable struct {
	gextras.Objector
}

var _ Scrollable = (*scrollable)(nil)

// WrapScrollable wraps a GObject to a type that implements interface
// Scrollable. It is primarily used internally.
func WrapScrollable(obj *externglib.Object) Scrollable {
	return scrollable{
		Objector: obj,
	}
}

func marshalScrollable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapScrollable(obj), nil
}

// Border returns the size of a non-scrolling border around the outside of the
// scrollable. An example for this would be treeview headers. GTK+ can use this
// information to display overlayed graphics, like the overshoot indication, at
// the right position.
func (s scrollable) Border() (Border, bool) {
	var _arg0 *C.GtkScrollable // out
	var _border Border
	var _cret C.gboolean // in

	_arg0 = (*C.GtkScrollable)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrollable_get_border(_arg0, (*C.GtkBorder)(unsafe.Pointer(&_border)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _border, _ok
}

// HAdjustment retrieves the Adjustment used for horizontal scrolling.
func (s scrollable) HAdjustment() Adjustment {
	var _arg0 *C.GtkScrollable // out
	var _cret *C.GtkAdjustment // in

	_arg0 = (*C.GtkScrollable)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrollable_get_hadjustment(_arg0)

	var _adjustment Adjustment // out

	_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

	return _adjustment
}

// HScrollPolicy gets the horizontal ScrollablePolicy.
func (s scrollable) HScrollPolicy() ScrollablePolicy {
	var _arg0 *C.GtkScrollable      // out
	var _cret C.GtkScrollablePolicy // in

	_arg0 = (*C.GtkScrollable)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrollable_get_hscroll_policy(_arg0)

	var _scrollablePolicy ScrollablePolicy // out

	_scrollablePolicy = ScrollablePolicy(_cret)

	return _scrollablePolicy
}

// VAdjustment retrieves the Adjustment used for vertical scrolling.
func (s scrollable) VAdjustment() Adjustment {
	var _arg0 *C.GtkScrollable // out
	var _cret *C.GtkAdjustment // in

	_arg0 = (*C.GtkScrollable)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrollable_get_vadjustment(_arg0)

	var _adjustment Adjustment // out

	_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

	return _adjustment
}

// VScrollPolicy gets the vertical ScrollablePolicy.
func (s scrollable) VScrollPolicy() ScrollablePolicy {
	var _arg0 *C.GtkScrollable      // out
	var _cret C.GtkScrollablePolicy // in

	_arg0 = (*C.GtkScrollable)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrollable_get_vscroll_policy(_arg0)

	var _scrollablePolicy ScrollablePolicy // out

	_scrollablePolicy = ScrollablePolicy(_cret)

	return _scrollablePolicy
}

// SetHAdjustment sets the horizontal adjustment of the Scrollable.
func (s scrollable) SetHAdjustment(hadjustment Adjustment) {
	var _arg0 *C.GtkScrollable // out
	var _arg1 *C.GtkAdjustment // out

	_arg0 = (*C.GtkScrollable)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(hadjustment.Native()))

	C.gtk_scrollable_set_hadjustment(_arg0, _arg1)
}

// SetHScrollPolicy sets the ScrollablePolicy to determine whether horizontal
// scrolling should start below the minimum width or below the natural width.
func (s scrollable) SetHScrollPolicy(policy ScrollablePolicy) {
	var _arg0 *C.GtkScrollable      // out
	var _arg1 C.GtkScrollablePolicy // out

	_arg0 = (*C.GtkScrollable)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkScrollablePolicy)(policy)

	C.gtk_scrollable_set_hscroll_policy(_arg0, _arg1)
}

// SetVAdjustment sets the vertical adjustment of the Scrollable.
func (s scrollable) SetVAdjustment(vadjustment Adjustment) {
	var _arg0 *C.GtkScrollable // out
	var _arg1 *C.GtkAdjustment // out

	_arg0 = (*C.GtkScrollable)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(vadjustment.Native()))

	C.gtk_scrollable_set_vadjustment(_arg0, _arg1)
}

// SetVScrollPolicy sets the ScrollablePolicy to determine whether vertical
// scrolling should start below the minimum height or below the natural height.
func (s scrollable) SetVScrollPolicy(policy ScrollablePolicy) {
	var _arg0 *C.GtkScrollable      // out
	var _arg1 C.GtkScrollablePolicy // out

	_arg0 = (*C.GtkScrollable)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkScrollablePolicy)(policy)

	C.gtk_scrollable_set_vscroll_policy(_arg0, _arg1)
}

// StyleProviderOverrider contains methods that are overridable. This
// interface is a subset of the interface StyleProvider.
type StyleProviderOverrider interface {
	// IconFactory returns the IconFactory defined to be in use for @path, or
	// nil if none is defined.
	IconFactory(path *WidgetPath) IconFactory
	// Style returns the style settings affecting a widget defined by @path, or
	// nil if @provider doesn’t contemplate styling @path.
	Style(path *WidgetPath) StyleProperties
}

// StyleProvider: gtkStyleProvider is an interface used to provide style
// information to a StyleContext. See gtk_style_context_add_provider() and
// gtk_style_context_add_provider_for_screen().
type StyleProvider interface {
	gextras.Objector
	StyleProviderOverrider
}

// styleProvider implements the StyleProvider interface.
type styleProvider struct {
	gextras.Objector
}

var _ StyleProvider = (*styleProvider)(nil)

// WrapStyleProvider wraps a GObject to a type that implements interface
// StyleProvider. It is primarily used internally.
func WrapStyleProvider(obj *externglib.Object) StyleProvider {
	return styleProvider{
		Objector: obj,
	}
}

func marshalStyleProvider(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStyleProvider(obj), nil
}

// IconFactory returns the IconFactory defined to be in use for @path, or nil if
// none is defined.
func (p styleProvider) IconFactory(path *WidgetPath) IconFactory {
	var _arg0 *C.GtkStyleProvider // out
	var _arg1 *C.GtkWidgetPath    // out
	var _cret *C.GtkIconFactory   // in

	_arg0 = (*C.GtkStyleProvider)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkWidgetPath)(unsafe.Pointer(path.Native()))

	_cret = C.gtk_style_provider_get_icon_factory(_arg0, _arg1)

	var _iconFactory IconFactory // out

	_iconFactory = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(IconFactory)

	return _iconFactory
}

// Style returns the style settings affecting a widget defined by @path, or nil
// if @provider doesn’t contemplate styling @path.
func (p styleProvider) Style(path *WidgetPath) StyleProperties {
	var _arg0 *C.GtkStyleProvider   // out
	var _arg1 *C.GtkWidgetPath      // out
	var _cret *C.GtkStyleProperties // in

	_arg0 = (*C.GtkStyleProvider)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkWidgetPath)(unsafe.Pointer(path.Native()))

	_cret = C.gtk_style_provider_get_style(_arg0, _arg1)

	var _styleProperties StyleProperties // out

	_styleProperties = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(StyleProperties)

	return _styleProperties
}

// ToolShellOverrider contains methods that are overridable. This
// interface is a subset of the interface ToolShell.
type ToolShellOverrider interface {
	// EllipsizeMode retrieves the current ellipsize mode for the tool shell.
	// Tool items must not call this function directly, but rely on
	// gtk_tool_item_get_ellipsize_mode() instead.
	EllipsizeMode() pango.EllipsizeMode

	IconSize() IconSize
	// Orientation retrieves the current orientation for the tool shell. Tool
	// items must not call this function directly, but rely on
	// gtk_tool_item_get_orientation() instead.
	Orientation() Orientation
	// ReliefStyle returns the relief style of buttons on @shell. Tool items
	// must not call this function directly, but rely on
	// gtk_tool_item_get_relief_style() instead.
	ReliefStyle() ReliefStyle
	// Style retrieves whether the tool shell has text, icons, or both. Tool
	// items must not call this function directly, but rely on
	// gtk_tool_item_get_toolbar_style() instead.
	Style() ToolbarStyle
	// TextAlignment retrieves the current text alignment for the tool shell.
	// Tool items must not call this function directly, but rely on
	// gtk_tool_item_get_text_alignment() instead.
	TextAlignment() float32
	// TextOrientation retrieves the current text orientation for the tool
	// shell. Tool items must not call this function directly, but rely on
	// gtk_tool_item_get_text_orientation() instead.
	TextOrientation() Orientation
	// TextSizeGroup retrieves the current text size group for the tool shell.
	// Tool items must not call this function directly, but rely on
	// gtk_tool_item_get_text_size_group() instead.
	TextSizeGroup() SizeGroup
	// RebuildMenu: calling this function signals the tool shell that the
	// overflow menu item for tool items have changed. If there is an overflow
	// menu and if it is visible when this function it called, the menu will be
	// rebuilt.
	//
	// Tool items must not call this function directly, but rely on
	// gtk_tool_item_rebuild_menu() instead.
	RebuildMenu()
}

// ToolShell: the ToolShell interface allows container widgets to provide
// additional information when embedding ToolItem widgets.
type ToolShell interface {
	Widget
	ToolShellOverrider
}

// toolShell implements the ToolShell interface.
type toolShell struct {
	Widget
}

var _ ToolShell = (*toolShell)(nil)

// WrapToolShell wraps a GObject to a type that implements interface
// ToolShell. It is primarily used internally.
func WrapToolShell(obj *externglib.Object) ToolShell {
	return toolShell{
		Widget: WrapWidget(obj),
	}
}

func marshalToolShell(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapToolShell(obj), nil
}

// EllipsizeMode retrieves the current ellipsize mode for the tool shell. Tool
// items must not call this function directly, but rely on
// gtk_tool_item_get_ellipsize_mode() instead.
func (s toolShell) EllipsizeMode() pango.EllipsizeMode {
	var _arg0 *C.GtkToolShell      // out
	var _cret C.PangoEllipsizeMode // in

	_arg0 = (*C.GtkToolShell)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_tool_shell_get_ellipsize_mode(_arg0)

	var _ellipsizeMode pango.EllipsizeMode // out

	_ellipsizeMode = pango.EllipsizeMode(_cret)

	return _ellipsizeMode
}

// IconSize retrieves the icon size for the tool shell. Tool items must not call
// this function directly, but rely on gtk_tool_item_get_icon_size() instead.
func (s toolShell) IconSize() int {
	var _arg0 *C.GtkToolShell // out
	var _cret C.GtkIconSize   // in

	_arg0 = (*C.GtkToolShell)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_tool_shell_get_icon_size(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Orientation retrieves the current orientation for the tool shell. Tool items
// must not call this function directly, but rely on
// gtk_tool_item_get_orientation() instead.
func (s toolShell) Orientation() Orientation {
	var _arg0 *C.GtkToolShell  // out
	var _cret C.GtkOrientation // in

	_arg0 = (*C.GtkToolShell)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_tool_shell_get_orientation(_arg0)

	var _orientation Orientation // out

	_orientation = Orientation(_cret)

	return _orientation
}

// ReliefStyle returns the relief style of buttons on @shell. Tool items must
// not call this function directly, but rely on gtk_tool_item_get_relief_style()
// instead.
func (s toolShell) ReliefStyle() ReliefStyle {
	var _arg0 *C.GtkToolShell  // out
	var _cret C.GtkReliefStyle // in

	_arg0 = (*C.GtkToolShell)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_tool_shell_get_relief_style(_arg0)

	var _reliefStyle ReliefStyle // out

	_reliefStyle = ReliefStyle(_cret)

	return _reliefStyle
}

// Style retrieves whether the tool shell has text, icons, or both. Tool items
// must not call this function directly, but rely on
// gtk_tool_item_get_toolbar_style() instead.
func (s toolShell) Style() ToolbarStyle {
	var _arg0 *C.GtkToolShell   // out
	var _cret C.GtkToolbarStyle // in

	_arg0 = (*C.GtkToolShell)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_tool_shell_get_style(_arg0)

	var _toolbarStyle ToolbarStyle // out

	_toolbarStyle = ToolbarStyle(_cret)

	return _toolbarStyle
}

// TextAlignment retrieves the current text alignment for the tool shell. Tool
// items must not call this function directly, but rely on
// gtk_tool_item_get_text_alignment() instead.
func (s toolShell) TextAlignment() float32 {
	var _arg0 *C.GtkToolShell // out
	var _cret C.gfloat        // in

	_arg0 = (*C.GtkToolShell)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_tool_shell_get_text_alignment(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// TextOrientation retrieves the current text orientation for the tool shell.
// Tool items must not call this function directly, but rely on
// gtk_tool_item_get_text_orientation() instead.
func (s toolShell) TextOrientation() Orientation {
	var _arg0 *C.GtkToolShell  // out
	var _cret C.GtkOrientation // in

	_arg0 = (*C.GtkToolShell)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_tool_shell_get_text_orientation(_arg0)

	var _orientation Orientation // out

	_orientation = Orientation(_cret)

	return _orientation
}

// TextSizeGroup retrieves the current text size group for the tool shell. Tool
// items must not call this function directly, but rely on
// gtk_tool_item_get_text_size_group() instead.
func (s toolShell) TextSizeGroup() SizeGroup {
	var _arg0 *C.GtkToolShell // out
	var _cret *C.GtkSizeGroup // in

	_arg0 = (*C.GtkToolShell)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_tool_shell_get_text_size_group(_arg0)

	var _sizeGroup SizeGroup // out

	_sizeGroup = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(SizeGroup)

	return _sizeGroup
}

// RebuildMenu: calling this function signals the tool shell that the overflow
// menu item for tool items have changed. If there is an overflow menu and if it
// is visible when this function it called, the menu will be rebuilt.
//
// Tool items must not call this function directly, but rely on
// gtk_tool_item_rebuild_menu() instead.
func (s toolShell) RebuildMenu() {
	var _arg0 *C.GtkToolShell // out

	_arg0 = (*C.GtkToolShell)(unsafe.Pointer(s.Native()))

	C.gtk_tool_shell_rebuild_menu(_arg0)
}

// TreeDragDestOverrider contains methods that are overridable. This
// interface is a subset of the interface TreeDragDest.
type TreeDragDestOverrider interface {
	// DragDataReceived asks the TreeDragDest to insert a row before the path
	// @dest, deriving the contents of the row from @selection_data. If @dest is
	// outside the tree so that inserting before it is impossible, false will be
	// returned. Also, false may be returned if the new row is not created for
	// some model-specific reason. Should robustly handle a @dest no longer
	// found in the model!
	DragDataReceived(dest *TreePath, selectionData *SelectionData) bool
	// RowDropPossible determines whether a drop is possible before the given
	// @dest_path, at the same depth as @dest_path. i.e., can we drop the data
	// in @selection_data at that location. @dest_path does not have to exist;
	// the return value will almost certainly be false if the parent of
	// @dest_path doesn’t exist, though.
	RowDropPossible(destPath *TreePath, selectionData *SelectionData) bool
}

type TreeDragDest interface {
	gextras.Objector
	TreeDragDestOverrider
}

// treeDragDest implements the TreeDragDest interface.
type treeDragDest struct {
	gextras.Objector
}

var _ TreeDragDest = (*treeDragDest)(nil)

// WrapTreeDragDest wraps a GObject to a type that implements interface
// TreeDragDest. It is primarily used internally.
func WrapTreeDragDest(obj *externglib.Object) TreeDragDest {
	return treeDragDest{
		Objector: obj,
	}
}

func marshalTreeDragDest(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeDragDest(obj), nil
}

// DragDataReceived asks the TreeDragDest to insert a row before the path @dest,
// deriving the contents of the row from @selection_data. If @dest is outside
// the tree so that inserting before it is impossible, false will be returned.
// Also, false may be returned if the new row is not created for some
// model-specific reason. Should robustly handle a @dest no longer found in the
// model!
func (d treeDragDest) DragDataReceived(dest *TreePath, selectionData *SelectionData) bool {
	var _arg0 *C.GtkTreeDragDest  // out
	var _arg1 *C.GtkTreePath      // out
	var _arg2 *C.GtkSelectionData // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkTreeDragDest)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(dest.Native()))
	_arg2 = (*C.GtkSelectionData)(unsafe.Pointer(selectionData.Native()))

	_cret = C.gtk_tree_drag_dest_drag_data_received(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RowDropPossible determines whether a drop is possible before the given
// @dest_path, at the same depth as @dest_path. i.e., can we drop the data in
// @selection_data at that location. @dest_path does not have to exist; the
// return value will almost certainly be false if the parent of @dest_path
// doesn’t exist, though.
func (d treeDragDest) RowDropPossible(destPath *TreePath, selectionData *SelectionData) bool {
	var _arg0 *C.GtkTreeDragDest  // out
	var _arg1 *C.GtkTreePath      // out
	var _arg2 *C.GtkSelectionData // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkTreeDragDest)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(destPath.Native()))
	_arg2 = (*C.GtkSelectionData)(unsafe.Pointer(selectionData.Native()))

	_cret = C.gtk_tree_drag_dest_row_drop_possible(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TreeDragSourceOverrider contains methods that are overridable. This
// interface is a subset of the interface TreeDragSource.
type TreeDragSourceOverrider interface {
	// DragDataDelete asks the TreeDragSource to delete the row at @path,
	// because it was moved somewhere else via drag-and-drop. Returns false if
	// the deletion fails because @path no longer exists, or for some
	// model-specific reason. Should robustly handle a @path no longer found in
	// the model!
	DragDataDelete(path *TreePath) bool
	// DragDataGet asks the TreeDragSource to fill in @selection_data with a
	// representation of the row at @path. @selection_data->target gives the
	// required type of the data. Should robustly handle a @path no longer found
	// in the model!
	DragDataGet(path *TreePath, selectionData *SelectionData) bool
	// RowDraggable asks the TreeDragSource whether a particular row can be used
	// as the source of a DND operation. If the source doesn’t implement this
	// interface, the row is assumed draggable.
	RowDraggable(path *TreePath) bool
}

type TreeDragSource interface {
	gextras.Objector
	TreeDragSourceOverrider
}

// treeDragSource implements the TreeDragSource interface.
type treeDragSource struct {
	gextras.Objector
}

var _ TreeDragSource = (*treeDragSource)(nil)

// WrapTreeDragSource wraps a GObject to a type that implements interface
// TreeDragSource. It is primarily used internally.
func WrapTreeDragSource(obj *externglib.Object) TreeDragSource {
	return treeDragSource{
		Objector: obj,
	}
}

func marshalTreeDragSource(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeDragSource(obj), nil
}

// DragDataDelete asks the TreeDragSource to delete the row at @path, because it
// was moved somewhere else via drag-and-drop. Returns false if the deletion
// fails because @path no longer exists, or for some model-specific reason.
// Should robustly handle a @path no longer found in the model!
func (d treeDragSource) DragDataDelete(path *TreePath) bool {
	var _arg0 *C.GtkTreeDragSource // out
	var _arg1 *C.GtkTreePath       // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeDragSource)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	_cret = C.gtk_tree_drag_source_drag_data_delete(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DragDataGet asks the TreeDragSource to fill in @selection_data with a
// representation of the row at @path. @selection_data->target gives the
// required type of the data. Should robustly handle a @path no longer found in
// the model!
func (d treeDragSource) DragDataGet(path *TreePath, selectionData *SelectionData) bool {
	var _arg0 *C.GtkTreeDragSource // out
	var _arg1 *C.GtkTreePath       // out
	var _arg2 *C.GtkSelectionData  // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeDragSource)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg2 = (*C.GtkSelectionData)(unsafe.Pointer(selectionData.Native()))

	_cret = C.gtk_tree_drag_source_drag_data_get(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RowDraggable asks the TreeDragSource whether a particular row can be used as
// the source of a DND operation. If the source doesn’t implement this
// interface, the row is assumed draggable.
func (d treeDragSource) RowDraggable(path *TreePath) bool {
	var _arg0 *C.GtkTreeDragSource // out
	var _arg1 *C.GtkTreePath       // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeDragSource)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	_cret = C.gtk_tree_drag_source_row_draggable(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TreeModelOverrider contains methods that are overridable. This
// interface is a subset of the interface TreeModel.
type TreeModelOverrider interface {
	// ColumnType returns the type of the column.
	ColumnType(index_ int) externglib.Type
	// Flags returns a set of flags supported by this interface.
	//
	// The flags are a bitwise combination of TreeModelFlags. The flags
	// supported should not change during the lifetime of the @tree_model.
	Flags() TreeModelFlags
	// Iter sets @iter to a valid iterator pointing to @path. If @path does not
	// exist, @iter is set to an invalid iterator and false is returned.
	Iter(path *TreePath) (TreeIter, bool)
	// NColumns returns the number of columns supported by @tree_model.
	NColumns() int
	// Path returns a newly-created TreePath-struct referenced by @iter.
	//
	// This path should be freed with gtk_tree_path_free().
	Path(iter *TreeIter) *TreePath
	// Value initializes and sets @value to that at @column.
	//
	// When done with @value, g_value_unset() needs to be called to free any
	// allocated memory.
	Value(iter *TreeIter, column int) *externglib.Value
	// IterChildren sets @iter to point to the first child of @parent.
	//
	// If @parent has no children, false is returned and @iter is set to be
	// invalid. @parent will remain a valid node after this function has been
	// called.
	//
	// If @parent is nil returns the first node, equivalent to
	// `gtk_tree_model_get_iter_first (tree_model, iter);`
	IterChildren(parent *TreeIter) (TreeIter, bool)
	// IterHasChild returns true if @iter has children, false otherwise.
	IterHasChild(iter *TreeIter) bool
	// IterNChildren returns the number of children that @iter has.
	//
	// As a special case, if @iter is nil, then the number of toplevel nodes is
	// returned.
	IterNChildren(iter *TreeIter) int
	// IterNext sets @iter to point to the node following it at the current
	// level.
	//
	// If there is no next @iter, false is returned and @iter is set to be
	// invalid.
	IterNext(iter *TreeIter) bool
	// IterNthChild sets @iter to be the child of @parent, using the given
	// index.
	//
	// The first index is 0. If @n is too big, or @parent has no children, @iter
	// is set to an invalid iterator and false is returned. @parent will remain
	// a valid node after this function has been called. As a special case, if
	// @parent is nil, then the @n-th root node is set.
	IterNthChild(parent *TreeIter, n int) (TreeIter, bool)
	// IterParent sets @iter to be the parent of @child.
	//
	// If @child is at the toplevel, and doesn’t have a parent, then @iter is
	// set to an invalid iterator and false is returned. @child will remain a
	// valid node after this function has been called.
	//
	// @iter will be initialized before the lookup is performed, so @child and
	// @iter cannot point to the same memory location.
	IterParent(child *TreeIter) (TreeIter, bool)
	// IterPrevious sets @iter to point to the previous node at the current
	// level.
	//
	// If there is no previous @iter, false is returned and @iter is set to be
	// invalid.
	IterPrevious(iter *TreeIter) bool
	// RefNode lets the tree ref the node.
	//
	// This is an optional method for models to implement. To be more specific,
	// models may ignore this call as it exists primarily for performance
	// reasons.
	//
	// This function is primarily meant as a way for views to let caching models
	// know when nodes are being displayed (and hence, whether or not to cache
	// that node). Being displayed means a node is in an expanded branch,
	// regardless of whether the node is currently visible in the viewport. For
	// example, a file-system based model would not want to keep the entire
	// file-hierarchy in memory, just the sections that are currently being
	// displayed by every current view.
	//
	// A model should be expected to be able to get an iter independent of its
	// reffed state.
	RefNode(iter *TreeIter)
	// RowChanged emits the TreeModel::row-changed signal on @tree_model.
	RowChanged(path *TreePath, iter *TreeIter)
	// RowDeleted emits the TreeModel::row-deleted signal on @tree_model.
	//
	// This should be called by models after a row has been removed. The
	// location pointed to by @path should be the location that the row
	// previously was at. It may not be a valid location anymore.
	//
	// Nodes that are deleted are not unreffed, this means that any outstanding
	// references on the deleted node should not be released.
	RowDeleted(path *TreePath)
	// RowHasChildToggled emits the TreeModel::row-has-child-toggled signal on
	// @tree_model. This should be called by models after the child state of a
	// node changes.
	RowHasChildToggled(path *TreePath, iter *TreeIter)
	// RowInserted emits the TreeModel::row-inserted signal on @tree_model.
	RowInserted(path *TreePath, iter *TreeIter)
	// UnrefNode lets the tree unref the node.
	//
	// This is an optional method for models to implement. To be more specific,
	// models may ignore this call as it exists primarily for performance
	// reasons. For more information on what this means, see
	// gtk_tree_model_ref_node().
	//
	// Please note that nodes that are deleted are not unreffed.
	UnrefNode(iter *TreeIter)
}

// TreeModel: the TreeModel interface defines a generic tree interface for use
// by the TreeView widget. It is an abstract interface, and is designed to be
// usable with any appropriate data structure. The programmer just has to
// implement this interface on their own data type for it to be viewable by a
// TreeView widget.
//
// The model is represented as a hierarchical tree of strongly-typed, columned
// data. In other words, the model can be seen as a tree where every node has
// different values depending on which column is being queried. The type of data
// found in a column is determined by using the GType system (ie. TYPE_INT,
// K_TYPE_BUTTON, TYPE_POINTER, etc). The types are homogeneous per column
// across all nodes. It is important to note that this interface only provides a
// way of examining a model and observing changes. The implementation of each
// individual model decides how and if changes are made.
//
// In order to make life simpler for programmers who do not need to write their
// own specialized model, two generic models are provided — the TreeStore and
// the ListStore. To use these, the developer simply pushes data into these
// models as necessary. These models provide the data structure as well as all
// appropriate tree interfaces. As a result, implementing drag and drop,
// sorting, and storing data is trivial. For the vast majority of trees and
// lists, these two models are sufficient.
//
// Models are accessed on a node/column level of granularity. One can query for
// the value of a model at a certain node and a certain column on that node.
// There are two structures used to reference a particular node in a model. They
// are the TreePath-struct and the TreeIter-struct (“iter” is short for
// iterator). Most of the interface consists of operations on a TreeIter-struct.
//
// A path is essentially a potential node. It is a location on a model that may
// or may not actually correspond to a node on a specific model. The
// TreePath-struct can be converted into either an array of unsigned integers or
// a string. The string form is a list of numbers separated by a colon. Each
// number refers to the offset at that level. Thus, the path `0` refers to the
// root node and the path `2:4` refers to the fifth child of the third node.
//
// By contrast, a TreeIter-struct is a reference to a specific node on a
// specific model. It is a generic struct with an integer and three generic
// pointers. These are filled in by the model in a model-specific way. One can
// convert a path to an iterator by calling gtk_tree_model_get_iter(). These
// iterators are the primary way of accessing a model and are similar to the
// iterators used by TextBuffer. They are generally statically allocated on the
// stack and only used for a short time. The model interface defines a set of
// operations using them for navigating the model.
//
// It is expected that models fill in the iterator with private data. For
// example, the ListStore model, which is internally a simple linked list,
// stores a list node in one of the pointers. The TreeModelSort stores an array
// and an offset in two of the pointers. Additionally, there is an integer
// field. This field is generally filled with a unique stamp per model. This
// stamp is for catching errors resulting from using invalid iterators with a
// model.
//
// The lifecycle of an iterator can be a little confusing at first. Iterators
// are expected to always be valid for as long as the model is unchanged (and
// doesn’t emit a signal). The model is considered to own all outstanding
// iterators and nothing needs to be done to free them from the user’s point of
// view. Additionally, some models guarantee that an iterator is valid for as
// long as the node it refers to is valid (most notably the TreeStore and
// ListStore). Although generally uninteresting, as one always has to allow for
// the case where iterators do not persist beyond a signal, some very important
// performance enhancements were made in the sort model. As a result, the
// K_TREE_MODEL_ITERS_PERSIST flag was added to indicate this behavior.
//
// To help show some common operation of a model, some examples are provided.
// The first example shows three ways of getting the iter at the location
// `3:2:5`. While the first method shown is easier, the second is much more
// common, as you often get paths from callbacks.
//
// Acquiring a TreeIter-struct
//
//    enum
//    {
//      STRING_COLUMN,
//      INT_COLUMN,
//      N_COLUMNS
//    };
//
//    ...
//
//    GtkTreeModel *list_store;
//    GtkTreeIter iter;
//    gboolean valid;
//    gint row_count = 0;
//
//    // make a new list_store
//    list_store = gtk_list_store_new (N_COLUMNS,
//                                     G_TYPE_STRING,
//                                     G_TYPE_INT);
//
//    // Fill the list store with data
//    populate_model (list_store);
//
//    // Get the first iter in the list, check it is valid and walk
//    // through the list, reading each row.
//
//    valid = gtk_tree_model_get_iter_first (list_store,
//                                           &iter);
//    while (valid)
//     {
//       gchar *str_data;
//       gint   int_data;
//
//       // Make sure you terminate calls to gtk_tree_model_get() with a “-1” value
//       gtk_tree_model_get (list_store, &iter,
//                           STRING_COLUMN, &str_data,
//                           INT_COLUMN, &int_data,
//                           -1);
//
//       // Do something with the data
//       g_print ("Row d: (s,d)\n",
//                row_count, str_data, int_data);
//       g_free (str_data);
//
//       valid = gtk_tree_model_iter_next (list_store,
//                                         &iter);
//       row_count++;
//     }
//
// The TreeModel interface contains two methods for reference counting:
// gtk_tree_model_ref_node() and gtk_tree_model_unref_node(). These two methods
// are optional to implement. The reference counting is meant as a way for views
// to let models know when nodes are being displayed. TreeView will take a
// reference on a node when it is visible, which means the node is either in the
// toplevel or expanded. Being displayed does not mean that the node is
// currently directly visible to the user in the viewport. Based on this
// reference counting scheme a caching model, for example, can decide whether or
// not to cache a node based on the reference count. A file-system based model
// would not want to keep the entire file hierarchy in memory, but just the
// folders that are currently expanded in every current view.
//
// When working with reference counting, the following rules must be taken into
// account:
//
// - Never take a reference on a node without owning a reference on its parent.
// This means that all parent nodes of a referenced node must be referenced as
// well.
//
// - Outstanding references on a deleted node are not released. This is not
// possible because the node has already been deleted by the time the
// row-deleted signal is received.
//
// - Models are not obligated to emit a signal on rows of which none of its
// siblings are referenced. To phrase this differently, signals are only
// required for levels in which nodes are referenced. For the root level
// however, signals must be emitted at all times (however the root level is
// always referenced when any view is attached).
type TreeModel interface {
	gextras.Objector
	TreeModelOverrider

	// NewFilter creates a new TreeModel, with @child_model as the child_model
	// and @root as the virtual root.
	NewFilter(root *TreePath) TreeModel
	// IterFirst initializes @iter with the first iterator in the tree (the one
	// at the path "0") and returns true. Returns false if the tree is empty.
	IterFirst() (TreeIter, bool)
	// IterFromString sets @iter to a valid iterator pointing to @path_string,
	// if it exists. Otherwise, @iter is left invalid and false is returned.
	IterFromString(pathString string) (TreeIter, bool)
	// StringFromIter generates a string representation of the iter.
	//
	// This string is a “:” separated list of numbers. For example, “4:10:0:3”
	// would be an acceptable return value for this string.
	StringFromIter(iter *TreeIter) string
	// RowsReorderedWithLength emits the TreeModel::rows-reordered signal on
	// @tree_model.
	//
	// This should be called by models when their rows have been reordered.
	RowsReorderedWithLength(path *TreePath, iter *TreeIter, newOrder []int)
}

// treeModel implements the TreeModel interface.
type treeModel struct {
	gextras.Objector
}

var _ TreeModel = (*treeModel)(nil)

// WrapTreeModel wraps a GObject to a type that implements interface
// TreeModel. It is primarily used internally.
func WrapTreeModel(obj *externglib.Object) TreeModel {
	return treeModel{
		Objector: obj,
	}
}

func marshalTreeModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeModel(obj), nil
}

// NewFilter creates a new TreeModel, with @child_model as the child_model and
// @root as the virtual root.
func (c treeModel) NewFilter(root *TreePath) TreeModel {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreePath  // out
	var _cret *C.GtkTreeModel // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(root.Native()))

	_cret = C.gtk_tree_model_filter_new(_arg0, _arg1)

	var _treeModel TreeModel // out

	_treeModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(TreeModel)

	return _treeModel
}

// ColumnType returns the type of the column.
func (t treeModel) ColumnType(index_ int) externglib.Type {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 C.gint          // out
	var _cret C.GType         // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(index_)

	_cret = C.gtk_tree_model_get_column_type(_arg0, _arg1)

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

// Flags returns a set of flags supported by this interface.
//
// The flags are a bitwise combination of TreeModelFlags. The flags supported
// should not change during the lifetime of the @tree_model.
func (t treeModel) Flags() TreeModelFlags {
	var _arg0 *C.GtkTreeModel     // out
	var _cret C.GtkTreeModelFlags // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_model_get_flags(_arg0)

	var _treeModelFlags TreeModelFlags // out

	_treeModelFlags = TreeModelFlags(_cret)

	return _treeModelFlags
}

// Iter sets @iter to a valid iterator pointing to @path. If @path does not
// exist, @iter is set to an invalid iterator and false is returned.
func (t treeModel) Iter(path *TreePath) (TreeIter, bool) {
	var _arg0 *C.GtkTreeModel // out
	var _iter TreeIter
	var _arg2 *C.GtkTreePath // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg2 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	_cret = C.gtk_tree_model_get_iter(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// IterFirst initializes @iter with the first iterator in the tree (the one at
// the path "0") and returns true. Returns false if the tree is empty.
func (t treeModel) IterFirst() (TreeIter, bool) {
	var _arg0 *C.GtkTreeModel // out
	var _iter TreeIter
	var _cret C.gboolean // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_model_get_iter_first(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// IterFromString sets @iter to a valid iterator pointing to @path_string, if it
// exists. Otherwise, @iter is left invalid and false is returned.
func (t treeModel) IterFromString(pathString string) (TreeIter, bool) {
	var _arg0 *C.GtkTreeModel // out
	var _iter TreeIter
	var _arg2 *C.gchar   // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg2 = (*C.gchar)(C.CString(pathString))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_tree_model_get_iter_from_string(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// NColumns returns the number of columns supported by @tree_model.
func (t treeModel) NColumns() int {
	var _arg0 *C.GtkTreeModel // out
	var _cret C.gint          // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_model_get_n_columns(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Path returns a newly-created TreePath-struct referenced by @iter.
//
// This path should be freed with gtk_tree_path_free().
func (t treeModel) Path(iter *TreeIter) *TreePath {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret *C.GtkTreePath  // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_tree_model_get_path(_arg0, _arg1)

	var _treePath *TreePath // out

	_treePath = WrapTreePath(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treePath, func(v *TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treePath
}

// StringFromIter generates a string representation of the iter.
//
// This string is a “:” separated list of numbers. For example, “4:10:0:3” would
// be an acceptable return value for this string.
func (t treeModel) StringFromIter(iter *TreeIter) string {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_tree_model_get_string_from_iter(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Value initializes and sets @value to that at @column.
//
// When done with @value, g_value_unset() needs to be called to free any
// allocated memory.
func (t treeModel) Value(iter *TreeIter, column int) *externglib.Value {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 C.gint          // out
	var _arg3 C.GValue        // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (C.gint)(column)

	C.gtk_tree_model_get_value(_arg0, _arg1, _arg2, &_arg3)

	var _value *externglib.Value // out

	_value = externglib.ValueFromNative(unsafe.Pointer(_arg3))

	return _value
}

// IterChildren sets @iter to point to the first child of @parent.
//
// If @parent has no children, false is returned and @iter is set to be invalid.
// @parent will remain a valid node after this function has been called.
//
// If @parent is nil returns the first node, equivalent to
// `gtk_tree_model_get_iter_first (tree_model, iter);`
func (t treeModel) IterChildren(parent *TreeIter) (TreeIter, bool) {
	var _arg0 *C.GtkTreeModel // out
	var _iter TreeIter
	var _arg2 *C.GtkTreeIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(parent.Native()))

	_cret = C.gtk_tree_model_iter_children(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// IterHasChild returns true if @iter has children, false otherwise.
func (t treeModel) IterHasChild(iter *TreeIter) bool {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_tree_model_iter_has_child(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IterNChildren returns the number of children that @iter has.
//
// As a special case, if @iter is nil, then the number of toplevel nodes is
// returned.
func (t treeModel) IterNChildren(iter *TreeIter) int {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret C.gint          // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_tree_model_iter_n_children(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// IterNext sets @iter to point to the node following it at the current level.
//
// If there is no next @iter, false is returned and @iter is set to be invalid.
func (t treeModel) IterNext(iter *TreeIter) bool {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_tree_model_iter_next(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IterNthChild sets @iter to be the child of @parent, using the given index.
//
// The first index is 0. If @n is too big, or @parent has no children, @iter is
// set to an invalid iterator and false is returned. @parent will remain a valid
// node after this function has been called. As a special case, if @parent is
// nil, then the @n-th root node is set.
func (t treeModel) IterNthChild(parent *TreeIter, n int) (TreeIter, bool) {
	var _arg0 *C.GtkTreeModel // out
	var _iter TreeIter
	var _arg2 *C.GtkTreeIter // out
	var _arg3 C.gint         // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(parent.Native()))
	_arg3 = (C.gint)(n)

	_cret = C.gtk_tree_model_iter_nth_child(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// IterParent sets @iter to be the parent of @child.
//
// If @child is at the toplevel, and doesn’t have a parent, then @iter is set to
// an invalid iterator and false is returned. @child will remain a valid node
// after this function has been called.
//
// @iter will be initialized before the lookup is performed, so @child and @iter
// cannot point to the same memory location.
func (t treeModel) IterParent(child *TreeIter) (TreeIter, bool) {
	var _arg0 *C.GtkTreeModel // out
	var _iter TreeIter
	var _arg2 *C.GtkTreeIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(child.Native()))

	_cret = C.gtk_tree_model_iter_parent(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// IterPrevious sets @iter to point to the previous node at the current level.
//
// If there is no previous @iter, false is returned and @iter is set to be
// invalid.
func (t treeModel) IterPrevious(iter *TreeIter) bool {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_tree_model_iter_previous(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RefNode lets the tree ref the node.
//
// This is an optional method for models to implement. To be more specific,
// models may ignore this call as it exists primarily for performance reasons.
//
// This function is primarily meant as a way for views to let caching models
// know when nodes are being displayed (and hence, whether or not to cache that
// node). Being displayed means a node is in an expanded branch, regardless of
// whether the node is currently visible in the viewport. For example, a
// file-system based model would not want to keep the entire file-hierarchy in
// memory, just the sections that are currently being displayed by every current
// view.
//
// A model should be expected to be able to get an iter independent of its
// reffed state.
func (t treeModel) RefNode(iter *TreeIter) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	C.gtk_tree_model_ref_node(_arg0, _arg1)
}

// RowChanged emits the TreeModel::row-changed signal on @tree_model.
func (t treeModel) RowChanged(path *TreePath, iter *TreeIter) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreePath  // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	C.gtk_tree_model_row_changed(_arg0, _arg1, _arg2)
}

// RowDeleted emits the TreeModel::row-deleted signal on @tree_model.
//
// This should be called by models after a row has been removed. The location
// pointed to by @path should be the location that the row previously was at. It
// may not be a valid location anymore.
//
// Nodes that are deleted are not unreffed, this means that any outstanding
// references on the deleted node should not be released.
func (t treeModel) RowDeleted(path *TreePath) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreePath  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_tree_model_row_deleted(_arg0, _arg1)
}

// RowHasChildToggled emits the TreeModel::row-has-child-toggled signal on
// @tree_model. This should be called by models after the child state of a node
// changes.
func (t treeModel) RowHasChildToggled(path *TreePath, iter *TreeIter) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreePath  // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	C.gtk_tree_model_row_has_child_toggled(_arg0, _arg1, _arg2)
}

// RowInserted emits the TreeModel::row-inserted signal on @tree_model.
func (t treeModel) RowInserted(path *TreePath, iter *TreeIter) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreePath  // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	C.gtk_tree_model_row_inserted(_arg0, _arg1, _arg2)
}

// RowsReorderedWithLength emits the TreeModel::rows-reordered signal on
// @tree_model.
//
// This should be called by models when their rows have been reordered.
func (t treeModel) RowsReorderedWithLength(path *TreePath, iter *TreeIter, newOrder []int) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreePath  // out
	var _arg2 *C.GtkTreeIter  // out
	var _arg3 *C.gint
	var _arg4 C.gint

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
	_arg4 = C.gint(len(newOrder))
	_arg3 = (*C.gint)(unsafe.Pointer(&newOrder[0]))

	C.gtk_tree_model_rows_reordered_with_length(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// UnrefNode lets the tree unref the node.
//
// This is an optional method for models to implement. To be more specific,
// models may ignore this call as it exists primarily for performance reasons.
// For more information on what this means, see gtk_tree_model_ref_node().
//
// Please note that nodes that are deleted are not unreffed.
func (t treeModel) UnrefNode(iter *TreeIter) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	C.gtk_tree_model_unref_node(_arg0, _arg1)
}

// TreeSortableOverrider contains methods that are overridable. This
// interface is a subset of the interface TreeSortable.
type TreeSortableOverrider interface {
	// SortColumnID fills in @sort_column_id and @order with the current sort
	// column and the order. It returns true unless the @sort_column_id is
	// GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID or
	// GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID.
	SortColumnID() (int, SortType, bool)
	// HasDefaultSortFunc returns true if the model has a default sort function.
	// This is used primarily by GtkTreeViewColumns in order to determine if a
	// model can go back to the default state, or not.
	HasDefaultSortFunc() bool
	// SetSortColumnID sets the current sort column to be @sort_column_id. The
	// @sortable will resort itself to reflect this change, after emitting a
	// TreeSortable::sort-column-changed signal. @sort_column_id may either be a
	// regular column id, or one of the following special values:
	//
	// - GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID: the default sort function
	// will be used, if it is set
	//
	// - GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID: no sorting will occur
	SetSortColumnID(sortColumnId int, order SortType)
	// SortColumnChanged emits a TreeSortable::sort-column-changed signal on
	// @sortable.
	SortColumnChanged()
}

// TreeSortable is an interface to be implemented by tree models which support
// sorting. The TreeView uses the methods provided by this interface to sort the
// model.
type TreeSortable interface {
	TreeModel
	TreeSortableOverrider
}

// treeSortable implements the TreeSortable interface.
type treeSortable struct {
	TreeModel
}

var _ TreeSortable = (*treeSortable)(nil)

// WrapTreeSortable wraps a GObject to a type that implements interface
// TreeSortable. It is primarily used internally.
func WrapTreeSortable(obj *externglib.Object) TreeSortable {
	return treeSortable{
		TreeModel: WrapTreeModel(obj),
	}
}

func marshalTreeSortable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeSortable(obj), nil
}

// SortColumnID fills in @sort_column_id and @order with the current sort column
// and the order. It returns true unless the @sort_column_id is
// GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID or
// GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID.
func (s treeSortable) SortColumnID() (int, SortType, bool) {
	var _arg0 *C.GtkTreeSortable // out
	var _arg1 C.gint             // in
	var _arg2 C.GtkSortType      // in
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkTreeSortable)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_tree_sortable_get_sort_column_id(_arg0, &_arg1, &_arg2)

	var _sortColumnId int // out
	var _order SortType   // out
	var _ok bool          // out

	_sortColumnId = (int)(_arg1)
	_order = SortType(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _sortColumnId, _order, _ok
}

// HasDefaultSortFunc returns true if the model has a default sort function.
// This is used primarily by GtkTreeViewColumns in order to determine if a model
// can go back to the default state, or not.
func (s treeSortable) HasDefaultSortFunc() bool {
	var _arg0 *C.GtkTreeSortable // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkTreeSortable)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_tree_sortable_has_default_sort_func(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetSortColumnID sets the current sort column to be @sort_column_id. The
// @sortable will resort itself to reflect this change, after emitting a
// TreeSortable::sort-column-changed signal. @sort_column_id may either be a
// regular column id, or one of the following special values:
//
// - GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID: the default sort function will be
// used, if it is set
//
// - GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID: no sorting will occur
func (s treeSortable) SetSortColumnID(sortColumnId int, order SortType) {
	var _arg0 *C.GtkTreeSortable // out
	var _arg1 C.gint             // out
	var _arg2 C.GtkSortType      // out

	_arg0 = (*C.GtkTreeSortable)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gint)(sortColumnId)
	_arg2 = (C.GtkSortType)(order)

	C.gtk_tree_sortable_set_sort_column_id(_arg0, _arg1, _arg2)
}

// SortColumnChanged emits a TreeSortable::sort-column-changed signal on
// @sortable.
func (s treeSortable) SortColumnChanged() {
	var _arg0 *C.GtkTreeSortable // out

	_arg0 = (*C.GtkTreeSortable)(unsafe.Pointer(s.Native()))

	C.gtk_tree_sortable_sort_column_changed(_arg0)
}

// AboutDialog: the GtkAboutDialog offers a simple way to display information
// about a program like its logo, name, copyright, website and license. It is
// also possible to give credits to the authors, documenters, translators and
// artists who have worked on the program. An about dialog is typically opened
// when the user selects the `About` option from the `Help` menu. All parts of
// the dialog are optional.
//
// About dialogs often contain links and email addresses. GtkAboutDialog
// displays these as clickable links. By default, it calls
// gtk_show_uri_on_window() when a user clicks one. The behaviour can be
// overridden with the AboutDialog::activate-link signal.
//
// To specify a person with an email address, use a string like "Edgar Allan Poe
// <edgar\@poe.com>". To specify a website with a title, use a string like "GTK+
// team http://www.gtk.org".
//
// To make constructing a GtkAboutDialog as convenient as possible, you can use
// the function gtk_show_about_dialog() which constructs and shows a dialog and
// keeps it around so that it can be shown again.
//
// Note that GTK+ sets a default title of `_("About s")` on the dialog window
// (where \s is replaced by the name of the application, but in order to ensure
// proper translation of the title, applications should set the title property
// explicitly when constructing a GtkAboutDialog, as shown in the following
// example:
//
//    GdkPixbuf *example_logo = gdk_pixbuf_new_from_file ("./logo.png", NULL);
//    gtk_show_about_dialog (NULL,
//                           "program-name", "ExampleCode",
//                           "logo", example_logo,
//                           "title", _("About ExampleCode"),
//                           NULL);
//
// It is also possible to show a AboutDialog like any other Dialog, e.g. using
// gtk_dialog_run(). In this case, you might need to know that the “Close”
// button returns the K_RESPONSE_CANCEL response id.
type AboutDialog interface {
	Dialog
	Buildable

	// AddCreditSection creates a new section in the Credits page.
	AddCreditSection(sectionName string, people []string)
	// Artists returns the string which are displayed in the artists tab of the
	// secondary credits dialog.
	Artists() []string
	// Authors returns the string which are displayed in the authors tab of the
	// secondary credits dialog.
	Authors() []string
	// Comments returns the comments string.
	Comments() string
	// Copyright returns the copyright string.
	Copyright() string
	// Documenters returns the string which are displayed in the documenters tab
	// of the secondary credits dialog.
	Documenters() []string
	// License returns the license information.
	License() string
	// LicenseType retrieves the license set using
	// gtk_about_dialog_set_license_type()
	LicenseType() License
	// Logo returns the pixbuf displayed as logo in the about dialog.
	Logo() gdkpixbuf.Pixbuf
	// LogoIconName returns the icon name displayed as logo in the about dialog.
	LogoIconName() string
	// ProgramName returns the program name displayed in the about dialog.
	ProgramName() string
	// TranslatorCredits returns the translator credits string which is
	// displayed in the translators tab of the secondary credits dialog.
	TranslatorCredits() string
	// Version returns the version string.
	Version() string
	// Website returns the website URL.
	Website() string
	// WebsiteLabel returns the label used for the website link.
	WebsiteLabel() string
	// WrapLicense returns whether the license text in @about is automatically
	// wrapped.
	WrapLicense() bool
	// SetArtists sets the strings which are displayed in the artists tab of the
	// secondary credits dialog.
	SetArtists(artists []string)
	// SetAuthors sets the strings which are displayed in the authors tab of the
	// secondary credits dialog.
	SetAuthors(authors []string)
	// SetComments sets the comments string to display in the about dialog. This
	// should be a short string of one or two lines.
	SetComments(comments string)
	// SetCopyright sets the copyright string to display in the about dialog.
	// This should be a short string of one or two lines.
	SetCopyright(copyright string)
	// SetDocumenters sets the strings which are displayed in the documenters
	// tab of the secondary credits dialog.
	SetDocumenters(documenters []string)
	// SetLicense sets the license information to be displayed in the secondary
	// license dialog. If @license is nil, the license button is hidden.
	SetLicense(license string)
	// SetLicenseType sets the license of the application showing the @about
	// dialog from a list of known licenses.
	//
	// This function overrides the license set using
	// gtk_about_dialog_set_license().
	SetLicenseType(licenseType License)
	// SetLogo sets the pixbuf to be displayed as logo in the about dialog. If
	// it is nil, the default window icon set with gtk_window_set_default_icon()
	// will be used.
	SetLogo(logo gdkpixbuf.Pixbuf)
	// SetLogoIconName sets the pixbuf to be displayed as logo in the about
	// dialog. If it is nil, the default window icon set with
	// gtk_window_set_default_icon() will be used.
	SetLogoIconName(iconName string)
	// SetProgramName sets the name to display in the about dialog. If this is
	// not set, it defaults to g_get_application_name().
	SetProgramName(name string)
	// SetTranslatorCredits sets the translator credits string which is
	// displayed in the translators tab of the secondary credits dialog.
	//
	// The intended use for this string is to display the translator of the
	// language which is currently used in the user interface. Using gettext(),
	// a simple way to achieve that is to mark the string for translation:
	//
	//    GtkWidget *about = gtk_about_dialog_new ();
	//    gtk_about_dialog_set_translator_credits (GTK_ABOUT_DIALOG (about),
	//                                             _("translator-credits"));
	//
	// It is a good idea to use the customary msgid “translator-credits” for
	// this purpose, since translators will already know the purpose of that
	// msgid, and since AboutDialog will detect if “translator-credits” is
	// untranslated and hide the tab.
	SetTranslatorCredits(translatorCredits string)
	// SetVersion sets the version string to display in the about dialog.
	SetVersion(version string)
	// SetWebsite sets the URL to use for the website link.
	SetWebsite(website string)
	// SetWebsiteLabel sets the label to be used for the website link.
	SetWebsiteLabel(websiteLabel string)
	// SetWrapLicense sets whether the license text in @about is automatically
	// wrapped.
	SetWrapLicense(wrapLicense bool)
}

// aboutDialog implements the AboutDialog class.
type aboutDialog struct {
	Dialog
	Buildable
}

var _ AboutDialog = (*aboutDialog)(nil)

// WrapAboutDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapAboutDialog(obj *externglib.Object) AboutDialog {
	return aboutDialog{
		Dialog:    WrapDialog(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalAboutDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAboutDialog(obj), nil
}

// NewAboutDialog creates a new AboutDialog.
func NewAboutDialog() AboutDialog {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_about_dialog_new()

	var _aboutDialog AboutDialog // out

	_aboutDialog = WrapAboutDialog(externglib.Take(unsafe.Pointer(_cret)))

	return _aboutDialog
}

// AddCreditSection creates a new section in the Credits page.
func (a aboutDialog) AddCreditSection(sectionName string, people []string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 *C.gchar          // out
	var _arg2 **C.gchar

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(sectionName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (**C.gchar)(C.malloc(C.ulong(len(people)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice(_arg2, len(people))
		for i := range people {
			out[i] = (*C.gchar)(C.CString(people[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.gtk_about_dialog_add_credit_section(_arg0, _arg1, _arg2)
}

// Artists returns the string which are displayed in the artists tab of the
// secondary credits dialog.
func (a aboutDialog) Artists() []string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret **C.gchar

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_about_dialog_get_artists(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
		}
	}

	return _utf8s
}

// Authors returns the string which are displayed in the authors tab of the
// secondary credits dialog.
func (a aboutDialog) Authors() []string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret **C.gchar

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_about_dialog_get_authors(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
		}
	}

	return _utf8s
}

// Comments returns the comments string.
func (a aboutDialog) Comments() string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret *C.gchar          // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_about_dialog_get_comments(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Copyright returns the copyright string.
func (a aboutDialog) Copyright() string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret *C.gchar          // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_about_dialog_get_copyright(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Documenters returns the string which are displayed in the documenters tab of
// the secondary credits dialog.
func (a aboutDialog) Documenters() []string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret **C.gchar

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_about_dialog_get_documenters(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
		}
	}

	return _utf8s
}

// License returns the license information.
func (a aboutDialog) License() string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret *C.gchar          // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_about_dialog_get_license(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// LicenseType retrieves the license set using
// gtk_about_dialog_set_license_type()
func (a aboutDialog) LicenseType() License {
	var _arg0 *C.GtkAboutDialog // out
	var _cret C.GtkLicense      // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_about_dialog_get_license_type(_arg0)

	var _license License // out

	_license = License(_cret)

	return _license
}

// Logo returns the pixbuf displayed as logo in the about dialog.
func (a aboutDialog) Logo() gdkpixbuf.Pixbuf {
	var _arg0 *C.GtkAboutDialog // out
	var _cret *C.GdkPixbuf      // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_about_dialog_get_logo(_arg0)

	var _pixbuf gdkpixbuf.Pixbuf // out

	_pixbuf = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

	return _pixbuf
}

// LogoIconName returns the icon name displayed as logo in the about dialog.
func (a aboutDialog) LogoIconName() string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret *C.gchar          // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_about_dialog_get_logo_icon_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// ProgramName returns the program name displayed in the about dialog.
func (a aboutDialog) ProgramName() string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret *C.gchar          // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_about_dialog_get_program_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// TranslatorCredits returns the translator credits string which is displayed in
// the translators tab of the secondary credits dialog.
func (a aboutDialog) TranslatorCredits() string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret *C.gchar          // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_about_dialog_get_translator_credits(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Version returns the version string.
func (a aboutDialog) Version() string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret *C.gchar          // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_about_dialog_get_version(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Website returns the website URL.
func (a aboutDialog) Website() string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret *C.gchar          // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_about_dialog_get_website(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// WebsiteLabel returns the label used for the website link.
func (a aboutDialog) WebsiteLabel() string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret *C.gchar          // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_about_dialog_get_website_label(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// WrapLicense returns whether the license text in @about is automatically
// wrapped.
func (a aboutDialog) WrapLicense() bool {
	var _arg0 *C.GtkAboutDialog // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_about_dialog_get_wrap_license(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetArtists sets the strings which are displayed in the artists tab of the
// secondary credits dialog.
func (a aboutDialog) SetArtists(artists []string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 **C.gchar

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(artists)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(artists))
		for i := range artists {
			out[i] = (*C.gchar)(C.CString(artists[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.gtk_about_dialog_set_artists(_arg0, _arg1)
}

// SetAuthors sets the strings which are displayed in the authors tab of the
// secondary credits dialog.
func (a aboutDialog) SetAuthors(authors []string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 **C.gchar

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(authors)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(authors))
		for i := range authors {
			out[i] = (*C.gchar)(C.CString(authors[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.gtk_about_dialog_set_authors(_arg0, _arg1)
}

// SetComments sets the comments string to display in the about dialog. This
// should be a short string of one or two lines.
func (a aboutDialog) SetComments(comments string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 *C.gchar          // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(comments))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_about_dialog_set_comments(_arg0, _arg1)
}

// SetCopyright sets the copyright string to display in the about dialog. This
// should be a short string of one or two lines.
func (a aboutDialog) SetCopyright(copyright string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 *C.gchar          // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(copyright))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_about_dialog_set_copyright(_arg0, _arg1)
}

// SetDocumenters sets the strings which are displayed in the documenters tab of
// the secondary credits dialog.
func (a aboutDialog) SetDocumenters(documenters []string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 **C.gchar

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(documenters)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(documenters))
		for i := range documenters {
			out[i] = (*C.gchar)(C.CString(documenters[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.gtk_about_dialog_set_documenters(_arg0, _arg1)
}

// SetLicense sets the license information to be displayed in the secondary
// license dialog. If @license is nil, the license button is hidden.
func (a aboutDialog) SetLicense(license string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 *C.gchar          // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(license))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_about_dialog_set_license(_arg0, _arg1)
}

// SetLicenseType sets the license of the application showing the @about dialog
// from a list of known licenses.
//
// This function overrides the license set using gtk_about_dialog_set_license().
func (a aboutDialog) SetLicenseType(licenseType License) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 C.GtkLicense      // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (C.GtkLicense)(licenseType)

	C.gtk_about_dialog_set_license_type(_arg0, _arg1)
}

// SetLogo sets the pixbuf to be displayed as logo in the about dialog. If it is
// nil, the default window icon set with gtk_window_set_default_icon() will be
// used.
func (a aboutDialog) SetLogo(logo gdkpixbuf.Pixbuf) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 *C.GdkPixbuf      // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(logo.Native()))

	C.gtk_about_dialog_set_logo(_arg0, _arg1)
}

// SetLogoIconName sets the pixbuf to be displayed as logo in the about dialog.
// If it is nil, the default window icon set with gtk_window_set_default_icon()
// will be used.
func (a aboutDialog) SetLogoIconName(iconName string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 *C.gchar          // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_about_dialog_set_logo_icon_name(_arg0, _arg1)
}

// SetProgramName sets the name to display in the about dialog. If this is not
// set, it defaults to g_get_application_name().
func (a aboutDialog) SetProgramName(name string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 *C.gchar          // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_about_dialog_set_program_name(_arg0, _arg1)
}

// SetTranslatorCredits sets the translator credits string which is displayed in
// the translators tab of the secondary credits dialog.
//
// The intended use for this string is to display the translator of the language
// which is currently used in the user interface. Using gettext(), a simple way
// to achieve that is to mark the string for translation:
//
//    GtkWidget *about = gtk_about_dialog_new ();
//    gtk_about_dialog_set_translator_credits (GTK_ABOUT_DIALOG (about),
//                                             _("translator-credits"));
//
// It is a good idea to use the customary msgid “translator-credits” for this
// purpose, since translators will already know the purpose of that msgid, and
// since AboutDialog will detect if “translator-credits” is untranslated and
// hide the tab.
func (a aboutDialog) SetTranslatorCredits(translatorCredits string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 *C.gchar          // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(translatorCredits))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_about_dialog_set_translator_credits(_arg0, _arg1)
}

// SetVersion sets the version string to display in the about dialog.
func (a aboutDialog) SetVersion(version string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 *C.gchar          // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(version))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_about_dialog_set_version(_arg0, _arg1)
}

// SetWebsite sets the URL to use for the website link.
func (a aboutDialog) SetWebsite(website string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 *C.gchar          // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(website))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_about_dialog_set_website(_arg0, _arg1)
}

// SetWebsiteLabel sets the label to be used for the website link.
func (a aboutDialog) SetWebsiteLabel(websiteLabel string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 *C.gchar          // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(websiteLabel))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_about_dialog_set_website_label(_arg0, _arg1)
}

// SetWrapLicense sets whether the license text in @about is automatically
// wrapped.
func (a aboutDialog) SetWrapLicense(wrapLicense bool) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	if wrapLicense {
		_arg1 = C.TRUE
	}

	C.gtk_about_dialog_set_wrap_license(_arg0, _arg1)
}

// AccelGroup: a AccelGroup represents a group of keyboard accelerators,
// typically attached to a toplevel Window (with gtk_window_add_accel_group()).
// Usually you won’t need to create a AccelGroup directly; instead, when using
// UIManager, GTK+ automatically sets up the accelerators for your menus in the
// ui manager’s AccelGroup.
//
// Note that “accelerators” are different from “mnemonics”. Accelerators are
// shortcuts for activating a menu item; they appear alongside the menu item
// they’re a shortcut for. For example “Ctrl+Q” might appear alongside the
// “Quit” menu item. Mnemonics are shortcuts for GUI elements such as text
// entries or buttons; they appear as underlined characters. See
// gtk_label_new_with_mnemonic(). Menu items can have both accelerators and
// mnemonics, of course.
type AccelGroup interface {
	gextras.Objector

	// DisconnectKey removes an accelerator previously installed through
	// gtk_accel_group_connect().
	DisconnectKey(accelKey uint, accelMods gdk.ModifierType) bool
	// IsLocked locks are added and removed using gtk_accel_group_lock() and
	// gtk_accel_group_unlock().
	IsLocked() bool
	// ModifierMask gets a ModifierType representing the mask for this
	// @accel_group. For example, K_CONTROL_MASK, K_SHIFT_MASK, etc.
	ModifierMask() gdk.ModifierType
	// Lock locks the given accelerator group.
	//
	// Locking an acelerator group prevents the accelerators contained within it
	// to be changed during runtime. Refer to gtk_accel_map_change_entry() about
	// runtime accelerator changes.
	//
	// If called more than once, @accel_group remains locked until
	// gtk_accel_group_unlock() has been called an equivalent number of times.
	Lock()
	// Unlock undoes the last call to gtk_accel_group_lock() on this
	// @accel_group.
	Unlock()
}

// accelGroup implements the AccelGroup class.
type accelGroup struct {
	gextras.Objector
}

var _ AccelGroup = (*accelGroup)(nil)

// WrapAccelGroup wraps a GObject to the right type. It is
// primarily used internally.
func WrapAccelGroup(obj *externglib.Object) AccelGroup {
	return accelGroup{
		Objector: obj,
	}
}

func marshalAccelGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAccelGroup(obj), nil
}

// NewAccelGroup creates a new AccelGroup.
func NewAccelGroup() AccelGroup {
	var _cret *C.GtkAccelGroup // in

	_cret = C.gtk_accel_group_new()

	var _accelGroup AccelGroup // out

	_accelGroup = WrapAccelGroup(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _accelGroup
}

// DisconnectKey removes an accelerator previously installed through
// gtk_accel_group_connect().
func (a accelGroup) DisconnectKey(accelKey uint, accelMods gdk.ModifierType) bool {
	var _arg0 *C.GtkAccelGroup  // out
	var _arg1 C.guint           // out
	var _arg2 C.GdkModifierType // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkAccelGroup)(unsafe.Pointer(a.Native()))
	_arg1 = (C.guint)(accelKey)
	_arg2 = (C.GdkModifierType)(accelMods)

	_cret = C.gtk_accel_group_disconnect_key(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsLocked locks are added and removed using gtk_accel_group_lock() and
// gtk_accel_group_unlock().
func (a accelGroup) IsLocked() bool {
	var _arg0 *C.GtkAccelGroup // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkAccelGroup)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_accel_group_get_is_locked(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ModifierMask gets a ModifierType representing the mask for this @accel_group.
// For example, K_CONTROL_MASK, K_SHIFT_MASK, etc.
func (a accelGroup) ModifierMask() gdk.ModifierType {
	var _arg0 *C.GtkAccelGroup  // out
	var _cret C.GdkModifierType // in

	_arg0 = (*C.GtkAccelGroup)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_accel_group_get_modifier_mask(_arg0)

	var _modifierType gdk.ModifierType // out

	_modifierType = gdk.ModifierType(_cret)

	return _modifierType
}

// Lock locks the given accelerator group.
//
// Locking an acelerator group prevents the accelerators contained within it to
// be changed during runtime. Refer to gtk_accel_map_change_entry() about
// runtime accelerator changes.
//
// If called more than once, @accel_group remains locked until
// gtk_accel_group_unlock() has been called an equivalent number of times.
func (a accelGroup) Lock() {
	var _arg0 *C.GtkAccelGroup // out

	_arg0 = (*C.GtkAccelGroup)(unsafe.Pointer(a.Native()))

	C.gtk_accel_group_lock(_arg0)
}

// Unlock undoes the last call to gtk_accel_group_lock() on this @accel_group.
func (a accelGroup) Unlock() {
	var _arg0 *C.GtkAccelGroup // out

	_arg0 = (*C.GtkAccelGroup)(unsafe.Pointer(a.Native()))

	C.gtk_accel_group_unlock(_arg0)
}

// AccelLabel: the AccelLabel widget is a subclass of Label that also displays
// an accelerator key on the right of the label text, e.g. “Ctrl+S”. It is
// commonly used in menus to show the keyboard short-cuts for commands.
//
// The accelerator key to display is typically not set explicitly (although it
// can be, with gtk_accel_label_set_accel()). Instead, the AccelLabel displays
// the accelerators which have been added to a particular widget. This widget is
// set by calling gtk_accel_label_set_accel_widget().
//
// For example, a MenuItem widget may have an accelerator added to emit the
// “activate” signal when the “Ctrl+S” key combination is pressed. A AccelLabel
// is created and added to the MenuItem, and gtk_accel_label_set_accel_widget()
// is called with the MenuItem as the second argument. The AccelLabel will now
// display “Ctrl+S” after its label.
//
// Note that creating a MenuItem with gtk_menu_item_new_with_label() (or one of
// the similar functions for CheckMenuItem and RadioMenuItem) automatically adds
// a AccelLabel to the MenuItem and calls gtk_accel_label_set_accel_widget() to
// set it up for you.
//
// A AccelLabel will only display accelerators which have GTK_ACCEL_VISIBLE set
// (see AccelFlags). A AccelLabel can display multiple accelerators and even
// signal names, though it is almost always used to display just one accelerator
// key.
//
// Creating a simple menu item with an accelerator key.
//
//    label
//    ╰── accelerator
//
// Like Label, GtkAccelLabel has a main CSS node with the name label. It adds a
// subnode with name accelerator.
type AccelLabel interface {
	Label
	Buildable

	// Accel gets the keyval and modifier mask set with
	// gtk_accel_label_set_accel().
	Accel() (uint, gdk.ModifierType)
	// AccelWidget fetches the widget monitored by this accelerator label. See
	// gtk_accel_label_set_accel_widget().
	AccelWidget() Widget
	// AccelWidth returns the width needed to display the accelerator key(s).
	// This is used by menus to align all of the MenuItem widgets, and shouldn't
	// be needed by applications.
	AccelWidth() uint
	// Refetch recreates the string representing the accelerator keys. This
	// should not be needed since the string is automatically updated whenever
	// accelerators are added or removed from the associated widget.
	Refetch() bool
	// SetAccel: manually sets a keyval and modifier mask as the accelerator
	// rendered by @accel_label.
	//
	// If a keyval and modifier are explicitly set then these values are used
	// regardless of any associated accel closure or widget.
	//
	// Providing an @accelerator_key of 0 removes the manual setting.
	SetAccel(acceleratorKey uint, acceleratorMods gdk.ModifierType)
	// SetAccelWidget sets the widget to be monitored by this accelerator label.
	// Passing nil for @accel_widget will dissociate @accel_label from its
	// current widget, if any.
	SetAccelWidget(accelWidget Widget)
}

// accelLabel implements the AccelLabel class.
type accelLabel struct {
	Label
	Buildable
}

var _ AccelLabel = (*accelLabel)(nil)

// WrapAccelLabel wraps a GObject to the right type. It is
// primarily used internally.
func WrapAccelLabel(obj *externglib.Object) AccelLabel {
	return accelLabel{
		Label:     WrapLabel(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalAccelLabel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAccelLabel(obj), nil
}

// NewAccelLabel creates a new AccelLabel.
func NewAccelLabel(_string string) AccelLabel {
	var _arg1 *C.gchar     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.gchar)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_accel_label_new(_arg1)

	var _accelLabel AccelLabel // out

	_accelLabel = WrapAccelLabel(externglib.Take(unsafe.Pointer(_cret)))

	return _accelLabel
}

// Accel gets the keyval and modifier mask set with gtk_accel_label_set_accel().
func (a accelLabel) Accel() (uint, gdk.ModifierType) {
	var _arg0 *C.GtkAccelLabel  // out
	var _arg1 C.guint           // in
	var _arg2 C.GdkModifierType // in

	_arg0 = (*C.GtkAccelLabel)(unsafe.Pointer(a.Native()))

	C.gtk_accel_label_get_accel(_arg0, &_arg1, &_arg2)

	var _acceleratorKey uint              // out
	var _acceleratorMods gdk.ModifierType // out

	_acceleratorKey = (uint)(_arg1)
	_acceleratorMods = gdk.ModifierType(_arg2)

	return _acceleratorKey, _acceleratorMods
}

// AccelWidget fetches the widget monitored by this accelerator label. See
// gtk_accel_label_set_accel_widget().
func (a accelLabel) AccelWidget() Widget {
	var _arg0 *C.GtkAccelLabel // out
	var _cret *C.GtkWidget     // in

	_arg0 = (*C.GtkAccelLabel)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_accel_label_get_accel_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// AccelWidth returns the width needed to display the accelerator key(s). This
// is used by menus to align all of the MenuItem widgets, and shouldn't be
// needed by applications.
func (a accelLabel) AccelWidth() uint {
	var _arg0 *C.GtkAccelLabel // out
	var _cret C.guint          // in

	_arg0 = (*C.GtkAccelLabel)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_accel_label_get_accel_width(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// Refetch recreates the string representing the accelerator keys. This should
// not be needed since the string is automatically updated whenever accelerators
// are added or removed from the associated widget.
func (a accelLabel) Refetch() bool {
	var _arg0 *C.GtkAccelLabel // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkAccelLabel)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_accel_label_refetch(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetAccel: manually sets a keyval and modifier mask as the accelerator
// rendered by @accel_label.
//
// If a keyval and modifier are explicitly set then these values are used
// regardless of any associated accel closure or widget.
//
// Providing an @accelerator_key of 0 removes the manual setting.
func (a accelLabel) SetAccel(acceleratorKey uint, acceleratorMods gdk.ModifierType) {
	var _arg0 *C.GtkAccelLabel  // out
	var _arg1 C.guint           // out
	var _arg2 C.GdkModifierType // out

	_arg0 = (*C.GtkAccelLabel)(unsafe.Pointer(a.Native()))
	_arg1 = (C.guint)(acceleratorKey)
	_arg2 = (C.GdkModifierType)(acceleratorMods)

	C.gtk_accel_label_set_accel(_arg0, _arg1, _arg2)
}

// SetAccelWidget sets the widget to be monitored by this accelerator label.
// Passing nil for @accel_widget will dissociate @accel_label from its current
// widget, if any.
func (a accelLabel) SetAccelWidget(accelWidget Widget) {
	var _arg0 *C.GtkAccelLabel // out
	var _arg1 *C.GtkWidget     // out

	_arg0 = (*C.GtkAccelLabel)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(accelWidget.Native()))

	C.gtk_accel_label_set_accel_widget(_arg0, _arg1)
}

// AccelMap: accelerator maps are used to define runtime configurable
// accelerators. Functions for manipulating them are are usually used by higher
// level convenience mechanisms like UIManager and are thus considered
// “low-level”. You’ll want to use them if you’re manually creating menus that
// should have user-configurable accelerators.
//
// An accelerator is uniquely defined by: - accelerator path - accelerator key -
// accelerator modifiers
//
// The accelerator path must consist of
// “<WINDOWTYPE>/Category1/Category2/.../Action”, where WINDOWTYPE should be a
// unique application-specific identifier that corresponds to the kind of window
// the accelerator is being used in, e.g. “Gimp-Image”, “Abiword-Document” or
// “Gnumeric-Settings”. The “Category1/.../Action” portion is most appropriately
// chosen by the action the accelerator triggers, i.e. for accelerators on menu
// items, choose the item’s menu path, e.g. “File/Save As”, “Image/View/Zoom” or
// “Edit/Select All”. So a full valid accelerator path may look like:
// “<Gimp-Toolbox>/File/Dialogs/Tool Options...”.
//
// All accelerators are stored inside one global AccelMap that can be obtained
// using gtk_accel_map_get(). See [Monitoring changes][monitoring-changes] for
// additional details.
//
//
// Manipulating accelerators
//
// New accelerators can be added using gtk_accel_map_add_entry(). To search for
// specific accelerator, use gtk_accel_map_lookup_entry(). Modifications of
// existing accelerators should be done using gtk_accel_map_change_entry().
//
// In order to avoid having some accelerators changed, they can be locked using
// gtk_accel_map_lock_path(). Unlocking is done using
// gtk_accel_map_unlock_path().
//
//
// Saving and loading accelerator maps
//
// Accelerator maps can be saved to and loaded from some external resource. For
// simple saving and loading from file, gtk_accel_map_save() and
// gtk_accel_map_load() are provided. Saving and loading can also be done by
// providing file descriptor to gtk_accel_map_save_fd() and
// gtk_accel_map_load_fd().
//
//
// Monitoring changes
//
// AccelMap object is only useful for monitoring changes of accelerators. By
// connecting to AccelMap::changed signal, one can monitor changes of all
// accelerators. It is also possible to monitor only single accelerator path by
// using it as a detail of the AccelMap::changed signal.
type AccelMap interface {
	gextras.Objector
}

// accelMap implements the AccelMap class.
type accelMap struct {
	gextras.Objector
}

var _ AccelMap = (*accelMap)(nil)

// WrapAccelMap wraps a GObject to the right type. It is
// primarily used internally.
func WrapAccelMap(obj *externglib.Object) AccelMap {
	return accelMap{
		Objector: obj,
	}
}

func marshalAccelMap(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAccelMap(obj), nil
}

// Action: > In GTK+ 3.10, GtkAction has been deprecated. Use #GAction >
// instead, and associate actions with Actionable widgets. Use > Model for
// creating menus with gtk_menu_new_from_model().
//
// Actions represent operations that the user can be perform, along with some
// information how it should be presented in the interface. Each action provides
// methods to create icons, menu items and toolbar items representing itself.
//
// As well as the callback that is called when the action gets activated, the
// following also gets associated with the action:
//
// - a name (not translated, for path lookup)
//
// - a label (translated, for display)
//
// - an accelerator
//
// - whether label indicates a stock id
//
// - a tooltip (optional, translated)
//
// - a toolbar label (optional, shorter than label)
//
//    The action will also have some state information:
//
// - visible (shown/hidden)
//
// - sensitive (enabled/disabled)
//
// Apart from regular actions, there are [toggle actions][GtkToggleAction],
// which can be toggled between two states and [radio actions][GtkRadioAction],
// of which only one in a group can be in the “active” state. Other actions can
// be implemented as Action subclasses.
//
// Each action can have one or more proxy widgets. To act as an action proxy,
// widget needs to implement Activatable interface. Proxies mirror the state of
// the action and should change when the action’s state changes. Properties that
// are always mirrored by proxies are Action:sensitive and Action:visible.
// Action:gicon, Action:icon-name, Action:label, Action:short-label and
// Action:stock-id properties are only mirorred if proxy widget has
// Activatable:use-action-appearance property set to true.
//
// When the proxy is activated, it should activate its action.
type Action interface {
	gextras.Objector
	Buildable

	// Activate emits the “activate” signal on the specified action, if it isn't
	// insensitive. This gets called by the proxy widgets when they get
	// activated.
	//
	// It can also be used to manually activate an action.
	Activate()
	// BlockActivate: disable activation signals from the action
	//
	// This is needed when updating the state of your proxy Activatable widget
	// could result in calling gtk_action_activate(), this is a convenience
	// function to avoid recursing in those cases (updating toggle state for
	// instance).
	BlockActivate()
	// ConnectAccelerator installs the accelerator for @action if @action has an
	// accel path and group. See gtk_action_set_accel_path() and
	// gtk_action_set_accel_group()
	//
	// Since multiple proxies may independently trigger the installation of the
	// accelerator, the @action counts the number of times this function has
	// been called and doesn’t remove the accelerator until
	// gtk_action_disconnect_accelerator() has been called as many times.
	ConnectAccelerator()
	// CreateIcon: this function is intended for use by action implementations
	// to create icons displayed in the proxy widgets.
	CreateIcon(iconSize int) Widget
	// CreateMenu: if @action provides a Menu widget as a submenu for the menu
	// item or the toolbar item it creates, this function returns an instance of
	// that menu.
	CreateMenu() Widget
	// CreateMenuItem creates a menu item widget that proxies for the given
	// action.
	CreateMenuItem() Widget
	// CreateToolItem creates a toolbar item widget that proxies for the given
	// action.
	CreateToolItem() Widget
	// DisconnectAccelerator undoes the effect of one call to
	// gtk_action_connect_accelerator().
	DisconnectAccelerator()
	// AccelPath returns the accel path for this action.
	AccelPath() string
	// AlwaysShowImage returns whether @action's menu item proxies will always
	// show their image, if available.
	AlwaysShowImage() bool
	// GIcon gets the gicon of @action.
	GIcon() gio.Icon
	// IconName gets the icon name of @action.
	IconName() string
	// IsImportant checks whether @action is important or not
	IsImportant() bool
	// Label gets the label text of @action.
	Label() string
	// Name returns the name of the action.
	Name() string
	// Sensitive returns whether the action itself is sensitive. Note that this
	// doesn’t necessarily mean effective sensitivity. See
	// gtk_action_is_sensitive() for that.
	Sensitive() bool
	// ShortLabel gets the short label text of @action.
	ShortLabel() string
	// StockID gets the stock id of @action.
	StockID() string
	// Tooltip gets the tooltip text of @action.
	Tooltip() string
	// Visible returns whether the action itself is visible. Note that this
	// doesn’t necessarily mean effective visibility. See
	// gtk_action_is_sensitive() for that.
	Visible() bool
	// VisibleHorizontal checks whether @action is visible when horizontal
	VisibleHorizontal() bool
	// VisibleVertical checks whether @action is visible when horizontal
	VisibleVertical() bool
	// IsSensitive returns whether the action is effectively sensitive.
	IsSensitive() bool
	// IsVisible returns whether the action is effectively visible.
	IsVisible() bool
	// SetAccelGroup sets the AccelGroup in which the accelerator for this
	// action will be installed.
	SetAccelGroup(accelGroup AccelGroup)
	// SetAccelPath sets the accel path for this action. All proxy widgets
	// associated with the action will have this accel path, so that their
	// accelerators are consistent.
	//
	// Note that @accel_path string will be stored in a #GQuark. Therefore, if
	// you pass a static string, you can save some memory by interning it first
	// with g_intern_static_string().
	SetAccelPath(accelPath string)
	// SetAlwaysShowImage sets whether @action's menu item proxies will ignore
	// the Settings:gtk-menu-images setting and always show their image, if
	// available.
	//
	// Use this if the menu item would be useless or hard to use without their
	// image.
	SetAlwaysShowImage(alwaysShow bool)
	// SetGIcon sets the icon of @action.
	SetGIcon(icon gio.Icon)
	// SetIconName sets the icon name on @action
	SetIconName(iconName string)
	// SetIsImportant sets whether the action is important, this attribute is
	// used primarily by toolbar items to decide whether to show a label or not.
	SetIsImportant(isImportant bool)
	// SetLabel sets the label of @action.
	SetLabel(label string)
	// SetSensitive sets the :sensitive property of the action to @sensitive.
	// Note that this doesn’t necessarily mean effective sensitivity. See
	// gtk_action_is_sensitive() for that.
	SetSensitive(sensitive bool)
	// SetShortLabel sets a shorter label text on @action.
	SetShortLabel(shortLabel string)
	// SetStockID sets the stock id on @action
	SetStockID(stockId string)
	// SetTooltip sets the tooltip text on @action
	SetTooltip(tooltip string)
	// SetVisible sets the :visible property of the action to @visible. Note
	// that this doesn’t necessarily mean effective visibility. See
	// gtk_action_is_visible() for that.
	SetVisible(visible bool)
	// SetVisibleHorizontal sets whether @action is visible when horizontal
	SetVisibleHorizontal(visibleHorizontal bool)
	// SetVisibleVertical sets whether @action is visible when vertical
	SetVisibleVertical(visibleVertical bool)
	// UnblockActivate: reenable activation signals from the action
	UnblockActivate()
}

// action implements the Action class.
type action struct {
	gextras.Objector
	Buildable
}

var _ Action = (*action)(nil)

// WrapAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapAction(obj *externglib.Object) Action {
	return action{
		Objector:  obj,
		Buildable: WrapBuildable(obj),
	}
}

func marshalAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAction(obj), nil
}

// NewAction creates a new Action object. To add the action to a ActionGroup and
// set the accelerator for the action, call
// gtk_action_group_add_action_with_accel(). See the [UI Definition
// section][XML-UI] for information on allowed action names.
func NewAction(name string, label string, tooltip string, stockId string) Action {
	var _arg1 *C.gchar     // out
	var _arg2 *C.gchar     // out
	var _arg3 *C.gchar     // out
	var _arg4 *C.gchar     // out
	var _cret *C.GtkAction // in

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(tooltip))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(C.CString(stockId))
	defer C.free(unsafe.Pointer(_arg4))

	_cret = C.gtk_action_new(_arg1, _arg2, _arg3, _arg4)

	var _action Action // out

	_action = WrapAction(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _action
}

// Activate emits the “activate” signal on the specified action, if it isn't
// insensitive. This gets called by the proxy widgets when they get activated.
//
// It can also be used to manually activate an action.
func (a action) Activate() {
	var _arg0 *C.GtkAction // out

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

	C.gtk_action_activate(_arg0)
}

// BlockActivate: disable activation signals from the action
//
// This is needed when updating the state of your proxy Activatable widget could
// result in calling gtk_action_activate(), this is a convenience function to
// avoid recursing in those cases (updating toggle state for instance).
func (a action) BlockActivate() {
	var _arg0 *C.GtkAction // out

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

	C.gtk_action_block_activate(_arg0)
}

// ConnectAccelerator installs the accelerator for @action if @action has an
// accel path and group. See gtk_action_set_accel_path() and
// gtk_action_set_accel_group()
//
// Since multiple proxies may independently trigger the installation of the
// accelerator, the @action counts the number of times this function has been
// called and doesn’t remove the accelerator until
// gtk_action_disconnect_accelerator() has been called as many times.
func (a action) ConnectAccelerator() {
	var _arg0 *C.GtkAction // out

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

	C.gtk_action_connect_accelerator(_arg0)
}

// CreateIcon: this function is intended for use by action implementations to
// create icons displayed in the proxy widgets.
func (a action) CreateIcon(iconSize int) Widget {
	var _arg0 *C.GtkAction  // out
	var _arg1 C.GtkIconSize // out
	var _cret *C.GtkWidget  // in

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))
	_arg1 = (C.GtkIconSize)(iconSize)

	_cret = C.gtk_action_create_icon(_arg0, _arg1)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// CreateMenu: if @action provides a Menu widget as a submenu for the menu item
// or the toolbar item it creates, this function returns an instance of that
// menu.
func (a action) CreateMenu() Widget {
	var _arg0 *C.GtkAction // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_action_create_menu(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// CreateMenuItem creates a menu item widget that proxies for the given action.
func (a action) CreateMenuItem() Widget {
	var _arg0 *C.GtkAction // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_action_create_menu_item(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// CreateToolItem creates a toolbar item widget that proxies for the given
// action.
func (a action) CreateToolItem() Widget {
	var _arg0 *C.GtkAction // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_action_create_tool_item(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// DisconnectAccelerator undoes the effect of one call to
// gtk_action_connect_accelerator().
func (a action) DisconnectAccelerator() {
	var _arg0 *C.GtkAction // out

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

	C.gtk_action_disconnect_accelerator(_arg0)
}

// AccelPath returns the accel path for this action.
func (a action) AccelPath() string {
	var _arg0 *C.GtkAction // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_action_get_accel_path(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// AlwaysShowImage returns whether @action's menu item proxies will always show
// their image, if available.
func (a action) AlwaysShowImage() bool {
	var _arg0 *C.GtkAction // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_action_get_always_show_image(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// GIcon gets the gicon of @action.
func (a action) GIcon() gio.Icon {
	var _arg0 *C.GtkAction // out
	var _cret *C.GIcon     // in

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_action_get_gicon(_arg0)

	var _icon gio.Icon // out

	_icon = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.Icon)

	return _icon
}

// IconName gets the icon name of @action.
func (a action) IconName() string {
	var _arg0 *C.GtkAction // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_action_get_icon_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// IsImportant checks whether @action is important or not
func (a action) IsImportant() bool {
	var _arg0 *C.GtkAction // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_action_get_is_important(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Label gets the label text of @action.
func (a action) Label() string {
	var _arg0 *C.GtkAction // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_action_get_label(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Name returns the name of the action.
func (a action) Name() string {
	var _arg0 *C.GtkAction // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_action_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Sensitive returns whether the action itself is sensitive. Note that this
// doesn’t necessarily mean effective sensitivity. See gtk_action_is_sensitive()
// for that.
func (a action) Sensitive() bool {
	var _arg0 *C.GtkAction // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_action_get_sensitive(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShortLabel gets the short label text of @action.
func (a action) ShortLabel() string {
	var _arg0 *C.GtkAction // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_action_get_short_label(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// StockID gets the stock id of @action.
func (a action) StockID() string {
	var _arg0 *C.GtkAction // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_action_get_stock_id(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Tooltip gets the tooltip text of @action.
func (a action) Tooltip() string {
	var _arg0 *C.GtkAction // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_action_get_tooltip(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Visible returns whether the action itself is visible. Note that this doesn’t
// necessarily mean effective visibility. See gtk_action_is_sensitive() for
// that.
func (a action) Visible() bool {
	var _arg0 *C.GtkAction // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_action_get_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// VisibleHorizontal checks whether @action is visible when horizontal
func (a action) VisibleHorizontal() bool {
	var _arg0 *C.GtkAction // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_action_get_visible_horizontal(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// VisibleVertical checks whether @action is visible when horizontal
func (a action) VisibleVertical() bool {
	var _arg0 *C.GtkAction // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_action_get_visible_vertical(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsSensitive returns whether the action is effectively sensitive.
func (a action) IsSensitive() bool {
	var _arg0 *C.GtkAction // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_action_is_sensitive(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsVisible returns whether the action is effectively visible.
func (a action) IsVisible() bool {
	var _arg0 *C.GtkAction // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_action_is_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetAccelGroup sets the AccelGroup in which the accelerator for this action
// will be installed.
func (a action) SetAccelGroup(accelGroup AccelGroup) {
	var _arg0 *C.GtkAction     // out
	var _arg1 *C.GtkAccelGroup // out

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkAccelGroup)(unsafe.Pointer(accelGroup.Native()))

	C.gtk_action_set_accel_group(_arg0, _arg1)
}

// SetAccelPath sets the accel path for this action. All proxy widgets
// associated with the action will have this accel path, so that their
// accelerators are consistent.
//
// Note that @accel_path string will be stored in a #GQuark. Therefore, if you
// pass a static string, you can save some memory by interning it first with
// g_intern_static_string().
func (a action) SetAccelPath(accelPath string) {
	var _arg0 *C.GtkAction // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(accelPath))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_action_set_accel_path(_arg0, _arg1)
}

// SetAlwaysShowImage sets whether @action's menu item proxies will ignore the
// Settings:gtk-menu-images setting and always show their image, if available.
//
// Use this if the menu item would be useless or hard to use without their
// image.
func (a action) SetAlwaysShowImage(alwaysShow bool) {
	var _arg0 *C.GtkAction // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))
	if alwaysShow {
		_arg1 = C.TRUE
	}

	C.gtk_action_set_always_show_image(_arg0, _arg1)
}

// SetGIcon sets the icon of @action.
func (a action) SetGIcon(icon gio.Icon) {
	var _arg0 *C.GtkAction // out
	var _arg1 *C.GIcon     // out

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

	C.gtk_action_set_gicon(_arg0, _arg1)
}

// SetIconName sets the icon name on @action
func (a action) SetIconName(iconName string) {
	var _arg0 *C.GtkAction // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_action_set_icon_name(_arg0, _arg1)
}

// SetIsImportant sets whether the action is important, this attribute is used
// primarily by toolbar items to decide whether to show a label or not.
func (a action) SetIsImportant(isImportant bool) {
	var _arg0 *C.GtkAction // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))
	if isImportant {
		_arg1 = C.TRUE
	}

	C.gtk_action_set_is_important(_arg0, _arg1)
}

// SetLabel sets the label of @action.
func (a action) SetLabel(label string) {
	var _arg0 *C.GtkAction // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_action_set_label(_arg0, _arg1)
}

// SetSensitive sets the :sensitive property of the action to @sensitive. Note
// that this doesn’t necessarily mean effective sensitivity. See
// gtk_action_is_sensitive() for that.
func (a action) SetSensitive(sensitive bool) {
	var _arg0 *C.GtkAction // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))
	if sensitive {
		_arg1 = C.TRUE
	}

	C.gtk_action_set_sensitive(_arg0, _arg1)
}

// SetShortLabel sets a shorter label text on @action.
func (a action) SetShortLabel(shortLabel string) {
	var _arg0 *C.GtkAction // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(shortLabel))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_action_set_short_label(_arg0, _arg1)
}

// SetStockID sets the stock id on @action
func (a action) SetStockID(stockId string) {
	var _arg0 *C.GtkAction // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(stockId))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_action_set_stock_id(_arg0, _arg1)
}

// SetTooltip sets the tooltip text on @action
func (a action) SetTooltip(tooltip string) {
	var _arg0 *C.GtkAction // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(tooltip))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_action_set_tooltip(_arg0, _arg1)
}

// SetVisible sets the :visible property of the action to @visible. Note that
// this doesn’t necessarily mean effective visibility. See
// gtk_action_is_visible() for that.
func (a action) SetVisible(visible bool) {
	var _arg0 *C.GtkAction // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))
	if visible {
		_arg1 = C.TRUE
	}

	C.gtk_action_set_visible(_arg0, _arg1)
}

// SetVisibleHorizontal sets whether @action is visible when horizontal
func (a action) SetVisibleHorizontal(visibleHorizontal bool) {
	var _arg0 *C.GtkAction // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))
	if visibleHorizontal {
		_arg1 = C.TRUE
	}

	C.gtk_action_set_visible_horizontal(_arg0, _arg1)
}

// SetVisibleVertical sets whether @action is visible when vertical
func (a action) SetVisibleVertical(visibleVertical bool) {
	var _arg0 *C.GtkAction // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))
	if visibleVertical {
		_arg1 = C.TRUE
	}

	C.gtk_action_set_visible_vertical(_arg0, _arg1)
}

// UnblockActivate: reenable activation signals from the action
func (a action) UnblockActivate() {
	var _arg0 *C.GtkAction // out

	_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

	C.gtk_action_unblock_activate(_arg0)
}

// ActionBar: gtkActionBar is designed to present contextual actions. It is
// expected to be displayed below the content and expand horizontally to fill
// the area.
//
// It allows placing children at the start or the end. In addition, it contains
// an internal centered box which is centered with respect to the full width of
// the box, even if the children at either side take up different amounts of
// space.
//
//
// CSS nodes
//
// GtkActionBar has a single CSS node with name actionbar.
type ActionBar interface {
	Bin
	Buildable

	// CenterWidget retrieves the center bar widget of the bar.
	CenterWidget() Widget
	// PackEnd adds @child to @action_bar, packed with reference to the end of
	// the @action_bar.
	PackEnd(child Widget)
	// PackStart adds @child to @action_bar, packed with reference to the start
	// of the @action_bar.
	PackStart(child Widget)
	// SetCenterWidget sets the center widget for the ActionBar.
	SetCenterWidget(centerWidget Widget)
}

// actionBar implements the ActionBar class.
type actionBar struct {
	Bin
	Buildable
}

var _ ActionBar = (*actionBar)(nil)

// WrapActionBar wraps a GObject to the right type. It is
// primarily used internally.
func WrapActionBar(obj *externglib.Object) ActionBar {
	return actionBar{
		Bin:       WrapBin(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalActionBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapActionBar(obj), nil
}

// NewActionBar creates a new ActionBar widget.
func NewActionBar() ActionBar {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_action_bar_new()

	var _actionBar ActionBar // out

	_actionBar = WrapActionBar(externglib.Take(unsafe.Pointer(_cret)))

	return _actionBar
}

// CenterWidget retrieves the center bar widget of the bar.
func (a actionBar) CenterWidget() Widget {
	var _arg0 *C.GtkActionBar // out
	var _cret *C.GtkWidget    // in

	_arg0 = (*C.GtkActionBar)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_action_bar_get_center_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// PackEnd adds @child to @action_bar, packed with reference to the end of the
// @action_bar.
func (a actionBar) PackEnd(child Widget) {
	var _arg0 *C.GtkActionBar // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkActionBar)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_action_bar_pack_end(_arg0, _arg1)
}

// PackStart adds @child to @action_bar, packed with reference to the start of
// the @action_bar.
func (a actionBar) PackStart(child Widget) {
	var _arg0 *C.GtkActionBar // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkActionBar)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_action_bar_pack_start(_arg0, _arg1)
}

// SetCenterWidget sets the center widget for the ActionBar.
func (a actionBar) SetCenterWidget(centerWidget Widget) {
	var _arg0 *C.GtkActionBar // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkActionBar)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(centerWidget.Native()))

	C.gtk_action_bar_set_center_widget(_arg0, _arg1)
}

// ActionGroup actions are organised into groups. An action group is essentially
// a map from names to Action objects.
//
// All actions that would make sense to use in a particular context should be in
// a single group. Multiple action groups may be used for a particular user
// interface. In fact, it is expected that most nontrivial applications will
// make use of multiple groups. For example, in an application that can edit
// multiple documents, one group holding global actions (e.g. quit, about, new),
// and one group per document holding actions that act on that document (eg.
// save, cut/copy/paste, etc). Each window’s menus would be constructed from a
// combination of two action groups.
//
//
// Accelerators
//
// Accelerators are handled by the GTK+ accelerator map. All actions are
// assigned an accelerator path (which normally has the form
// `<Actions>/group-name/action-name`) and a shortcut is associated with this
// accelerator path. All menuitems and toolitems take on this accelerator path.
// The GTK+ accelerator map code makes sure that the correct shortcut is
// displayed next to the menu item.
//
//
// GtkActionGroup as GtkBuildable
//
// The ActionGroup implementation of the Buildable interface accepts Action
// objects as <child> elements in UI definitions.
//
// Note that it is probably more common to define actions and action groups in
// the code, since they are directly related to what the code can do.
//
// The GtkActionGroup implementation of the GtkBuildable interface supports a
// custom <accelerator> element, which has attributes named “key“ and
// “modifiers“ and allows to specify accelerators. This is similar to the
// <accelerator> element of Widget, the main difference is that it doesn’t allow
// you to specify a signal.
//
// A Dialog UI definition fragment. ##
//
//    <object class="GtkActionGroup" id="actiongroup">
//      <child>
//          <object class="GtkAction" id="About">
//              <property name="name">About</property>
//              <property name="stock_id">gtk-about</property>
//              <signal handler="about_activate" name="activate"/>
//          </object>
//          <accelerator key="F1" modifiers="GDK_CONTROL_MASK | GDK_SHIFT_MASK"/>
//      </child>
//    </object>
type ActionGroup interface {
	gextras.Objector
	Buildable

	// AddAction adds an action object to the action group. Note that this
	// function does not set up the accel path of the action, which can lead to
	// problems if a user tries to modify the accelerator of a menuitem
	// associated with the action. Therefore you must either set the accel path
	// yourself with gtk_action_set_accel_path(), or use
	// `gtk_action_group_add_action_with_accel (..., NULL)`.
	AddAction(action Action)
	// AddActionWithAccel adds an action object to the action group and sets up
	// the accelerator.
	//
	// If @accelerator is nil, attempts to use the accelerator associated with
	// the stock_id of the action.
	//
	// Accel paths are set to `<Actions>/group-name/action-name`.
	AddActionWithAccel(action Action, accelerator string)
	// AccelGroup gets the accelerator group.
	AccelGroup() AccelGroup
	// Action looks up an action in the action group by name.
	Action(actionName string) Action
	// Name gets the name of the action group.
	Name() string
	// Sensitive returns true if the group is sensitive. The constituent actions
	// can only be logically sensitive (see gtk_action_is_sensitive()) if they
	// are sensitive (see gtk_action_get_sensitive()) and their group is
	// sensitive.
	Sensitive() bool
	// Visible returns true if the group is visible. The constituent actions can
	// only be logically visible (see gtk_action_is_visible()) if they are
	// visible (see gtk_action_get_visible()) and their group is visible.
	Visible() bool
	// RemoveAction removes an action object from the action group.
	RemoveAction(action Action)
	// SetAccelGroup sets the accelerator group to be used by every action in
	// this group.
	SetAccelGroup(accelGroup AccelGroup)
	// SetSensitive changes the sensitivity of @action_group
	SetSensitive(sensitive bool)
	// SetTranslationDomain sets the translation domain and uses g_dgettext()
	// for translating the @label and @tooltip of ActionEntrys added by
	// gtk_action_group_add_actions().
	//
	// If you’re not using gettext() for localization, see
	// gtk_action_group_set_translate_func().
	SetTranslationDomain(domain string)
	// SetVisible changes the visible of @action_group.
	SetVisible(visible bool)
	// TranslateString translates a string using the function set with
	// gtk_action_group_set_translate_func(). This is mainly intended for
	// language bindings.
	TranslateString(_string string) string
}

// actionGroup implements the ActionGroup class.
type actionGroup struct {
	gextras.Objector
	Buildable
}

var _ ActionGroup = (*actionGroup)(nil)

// WrapActionGroup wraps a GObject to the right type. It is
// primarily used internally.
func WrapActionGroup(obj *externglib.Object) ActionGroup {
	return actionGroup{
		Objector:  obj,
		Buildable: WrapBuildable(obj),
	}
}

func marshalActionGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapActionGroup(obj), nil
}

// NewActionGroup creates a new ActionGroup object. The name of the action group
// is used when associating [keybindings][Action-Accel] with the actions.
func NewActionGroup(name string) ActionGroup {
	var _arg1 *C.gchar          // out
	var _cret *C.GtkActionGroup // in

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_action_group_new(_arg1)

	var _actionGroup ActionGroup // out

	_actionGroup = WrapActionGroup(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _actionGroup
}

// AddAction adds an action object to the action group. Note that this function
// does not set up the accel path of the action, which can lead to problems if a
// user tries to modify the accelerator of a menuitem associated with the
// action. Therefore you must either set the accel path yourself with
// gtk_action_set_accel_path(), or use `gtk_action_group_add_action_with_accel
// (..., NULL)`.
func (a actionGroup) AddAction(action Action) {
	var _arg0 *C.GtkActionGroup // out
	var _arg1 *C.GtkAction      // out

	_arg0 = (*C.GtkActionGroup)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkAction)(unsafe.Pointer(action.Native()))

	C.gtk_action_group_add_action(_arg0, _arg1)
}

// AddActionWithAccel adds an action object to the action group and sets up the
// accelerator.
//
// If @accelerator is nil, attempts to use the accelerator associated with the
// stock_id of the action.
//
// Accel paths are set to `<Actions>/group-name/action-name`.
func (a actionGroup) AddActionWithAccel(action Action, accelerator string) {
	var _arg0 *C.GtkActionGroup // out
	var _arg1 *C.GtkAction      // out
	var _arg2 *C.gchar          // out

	_arg0 = (*C.GtkActionGroup)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkAction)(unsafe.Pointer(action.Native()))
	_arg2 = (*C.gchar)(C.CString(accelerator))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_action_group_add_action_with_accel(_arg0, _arg1, _arg2)
}

// AccelGroup gets the accelerator group.
func (a actionGroup) AccelGroup() AccelGroup {
	var _arg0 *C.GtkActionGroup // out
	var _cret *C.GtkAccelGroup  // in

	_arg0 = (*C.GtkActionGroup)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_action_group_get_accel_group(_arg0)

	var _accelGroup AccelGroup // out

	_accelGroup = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(AccelGroup)

	return _accelGroup
}

// Action looks up an action in the action group by name.
func (a actionGroup) Action(actionName string) Action {
	var _arg0 *C.GtkActionGroup // out
	var _arg1 *C.gchar          // out
	var _cret *C.GtkAction      // in

	_arg0 = (*C.GtkActionGroup)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_action_group_get_action(_arg0, _arg1)

	var _action Action // out

	_action = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Action)

	return _action
}

// Name gets the name of the action group.
func (a actionGroup) Name() string {
	var _arg0 *C.GtkActionGroup // out
	var _cret *C.gchar          // in

	_arg0 = (*C.GtkActionGroup)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_action_group_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Sensitive returns true if the group is sensitive. The constituent actions can
// only be logically sensitive (see gtk_action_is_sensitive()) if they are
// sensitive (see gtk_action_get_sensitive()) and their group is sensitive.
func (a actionGroup) Sensitive() bool {
	var _arg0 *C.GtkActionGroup // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkActionGroup)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_action_group_get_sensitive(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Visible returns true if the group is visible. The constituent actions can
// only be logically visible (see gtk_action_is_visible()) if they are visible
// (see gtk_action_get_visible()) and their group is visible.
func (a actionGroup) Visible() bool {
	var _arg0 *C.GtkActionGroup // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkActionGroup)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_action_group_get_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveAction removes an action object from the action group.
func (a actionGroup) RemoveAction(action Action) {
	var _arg0 *C.GtkActionGroup // out
	var _arg1 *C.GtkAction      // out

	_arg0 = (*C.GtkActionGroup)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkAction)(unsafe.Pointer(action.Native()))

	C.gtk_action_group_remove_action(_arg0, _arg1)
}

// SetAccelGroup sets the accelerator group to be used by every action in this
// group.
func (a actionGroup) SetAccelGroup(accelGroup AccelGroup) {
	var _arg0 *C.GtkActionGroup // out
	var _arg1 *C.GtkAccelGroup  // out

	_arg0 = (*C.GtkActionGroup)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkAccelGroup)(unsafe.Pointer(accelGroup.Native()))

	C.gtk_action_group_set_accel_group(_arg0, _arg1)
}

// SetSensitive changes the sensitivity of @action_group
func (a actionGroup) SetSensitive(sensitive bool) {
	var _arg0 *C.GtkActionGroup // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkActionGroup)(unsafe.Pointer(a.Native()))
	if sensitive {
		_arg1 = C.TRUE
	}

	C.gtk_action_group_set_sensitive(_arg0, _arg1)
}

// SetTranslationDomain sets the translation domain and uses g_dgettext() for
// translating the @label and @tooltip of ActionEntrys added by
// gtk_action_group_add_actions().
//
// If you’re not using gettext() for localization, see
// gtk_action_group_set_translate_func().
func (a actionGroup) SetTranslationDomain(domain string) {
	var _arg0 *C.GtkActionGroup // out
	var _arg1 *C.gchar          // out

	_arg0 = (*C.GtkActionGroup)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_action_group_set_translation_domain(_arg0, _arg1)
}

// SetVisible changes the visible of @action_group.
func (a actionGroup) SetVisible(visible bool) {
	var _arg0 *C.GtkActionGroup // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkActionGroup)(unsafe.Pointer(a.Native()))
	if visible {
		_arg1 = C.TRUE
	}

	C.gtk_action_group_set_visible(_arg0, _arg1)
}

// TranslateString translates a string using the function set with
// gtk_action_group_set_translate_func(). This is mainly intended for language
// bindings.
func (a actionGroup) TranslateString(_string string) string {
	var _arg0 *C.GtkActionGroup // out
	var _arg1 *C.gchar          // out
	var _cret *C.gchar          // in

	_arg0 = (*C.GtkActionGroup)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_action_group_translate_string(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Adjustment: the Adjustment object represents a value which has an associated
// lower and upper bound, together with step and page increments, and a page
// size. It is used within several GTK+ widgets, including SpinButton, Viewport,
// and Range (which is a base class for Scrollbar and Scale).
//
// The Adjustment object does not update the value itself. Instead it is left up
// to the owner of the Adjustment to control the value.
type Adjustment interface {
	gextras.Objector

	// Changed emits a Adjustment::changed signal from the Adjustment. This is
	// typically called by the owner of the Adjustment after it has changed any
	// of the Adjustment properties other than the value.
	Changed()
	// ClampPage updates the Adjustment:value property to ensure that the range
	// between @lower and @upper is in the current page (i.e. between
	// Adjustment:value and Adjustment:value + Adjustment:page-size). If the
	// range is larger than the page size, then only the start of it will be in
	// the current page.
	//
	// A Adjustment::value-changed signal will be emitted if the value is
	// changed.
	ClampPage(lower float64, upper float64)
	// Configure sets all properties of the adjustment at once.
	//
	// Use this function to avoid multiple emissions of the Adjustment::changed
	// signal. See gtk_adjustment_set_lower() for an alternative way of
	// compressing multiple emissions of Adjustment::changed into one.
	Configure(value float64, lower float64, upper float64, stepIncrement float64, pageIncrement float64, pageSize float64)
	// Lower retrieves the minimum value of the adjustment.
	Lower() float64
	// MinimumIncrement gets the smaller of step increment and page increment.
	MinimumIncrement() float64
	// PageIncrement retrieves the page increment of the adjustment.
	PageIncrement() float64
	// PageSize retrieves the page size of the adjustment.
	PageSize() float64
	// StepIncrement retrieves the step increment of the adjustment.
	StepIncrement() float64
	// Upper retrieves the maximum value of the adjustment.
	Upper() float64
	// Value gets the current value of the adjustment. See
	// gtk_adjustment_set_value().
	Value() float64
	// SetLower sets the minimum value of the adjustment.
	//
	// When setting multiple adjustment properties via their individual setters,
	// multiple Adjustment::changed signals will be emitted. However, since the
	// emission of the Adjustment::changed signal is tied to the emission of the
	// #GObject::notify signals of the changed properties, it’s possible to
	// compress the Adjustment::changed signals into one by calling
	// g_object_freeze_notify() and g_object_thaw_notify() around the calls to
	// the individual setters.
	//
	// Alternatively, using a single g_object_set() for all the properties to
	// change, or using gtk_adjustment_configure() has the same effect of
	// compressing Adjustment::changed emissions.
	SetLower(lower float64)
	// SetPageIncrement sets the page increment of the adjustment.
	//
	// See gtk_adjustment_set_lower() about how to compress multiple emissions
	// of the Adjustment::changed signal when setting multiple adjustment
	// properties.
	SetPageIncrement(pageIncrement float64)
	// SetPageSize sets the page size of the adjustment.
	//
	// See gtk_adjustment_set_lower() about how to compress multiple emissions
	// of the GtkAdjustment::changed signal when setting multiple adjustment
	// properties.
	SetPageSize(pageSize float64)
	// SetStepIncrement sets the step increment of the adjustment.
	//
	// See gtk_adjustment_set_lower() about how to compress multiple emissions
	// of the Adjustment::changed signal when setting multiple adjustment
	// properties.
	SetStepIncrement(stepIncrement float64)
	// SetUpper sets the maximum value of the adjustment.
	//
	// Note that values will be restricted by `upper - page-size` if the
	// page-size property is nonzero.
	//
	// See gtk_adjustment_set_lower() about how to compress multiple emissions
	// of the Adjustment::changed signal when setting multiple adjustment
	// properties.
	SetUpper(upper float64)
	// SetValue sets the Adjustment value. The value is clamped to lie between
	// Adjustment:lower and Adjustment:upper.
	//
	// Note that for adjustments which are used in a Scrollbar, the effective
	// range of allowed values goes from Adjustment:lower to Adjustment:upper -
	// Adjustment:page-size.
	SetValue(value float64)
	// ValueChanged emits a Adjustment::value-changed signal from the
	// Adjustment. This is typically called by the owner of the Adjustment after
	// it has changed the Adjustment:value property.
	ValueChanged()
}

// adjustment implements the Adjustment class.
type adjustment struct {
	gextras.Objector
}

var _ Adjustment = (*adjustment)(nil)

// WrapAdjustment wraps a GObject to the right type. It is
// primarily used internally.
func WrapAdjustment(obj *externglib.Object) Adjustment {
	return adjustment{
		Objector: obj,
	}
}

func marshalAdjustment(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAdjustment(obj), nil
}

// NewAdjustment creates a new Adjustment.
func NewAdjustment(value float64, lower float64, upper float64, stepIncrement float64, pageIncrement float64, pageSize float64) Adjustment {
	var _arg1 C.gdouble        // out
	var _arg2 C.gdouble        // out
	var _arg3 C.gdouble        // out
	var _arg4 C.gdouble        // out
	var _arg5 C.gdouble        // out
	var _arg6 C.gdouble        // out
	var _cret *C.GtkAdjustment // in

	_arg1 = (C.gdouble)(value)
	_arg2 = (C.gdouble)(lower)
	_arg3 = (C.gdouble)(upper)
	_arg4 = (C.gdouble)(stepIncrement)
	_arg5 = (C.gdouble)(pageIncrement)
	_arg6 = (C.gdouble)(pageSize)

	_cret = C.gtk_adjustment_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)

	var _adjustment Adjustment // out

	_adjustment = WrapAdjustment(externglib.Take(unsafe.Pointer(_cret)))

	return _adjustment
}

// Changed emits a Adjustment::changed signal from the Adjustment. This is
// typically called by the owner of the Adjustment after it has changed any of
// the Adjustment properties other than the value.
func (a adjustment) Changed() {
	var _arg0 *C.GtkAdjustment // out

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))

	C.gtk_adjustment_changed(_arg0)
}

// ClampPage updates the Adjustment:value property to ensure that the range
// between @lower and @upper is in the current page (i.e. between
// Adjustment:value and Adjustment:value + Adjustment:page-size). If the range
// is larger than the page size, then only the start of it will be in the
// current page.
//
// A Adjustment::value-changed signal will be emitted if the value is changed.
func (a adjustment) ClampPage(lower float64, upper float64) {
	var _arg0 *C.GtkAdjustment // out
	var _arg1 C.gdouble        // out
	var _arg2 C.gdouble        // out

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))
	_arg1 = (C.gdouble)(lower)
	_arg2 = (C.gdouble)(upper)

	C.gtk_adjustment_clamp_page(_arg0, _arg1, _arg2)
}

// Configure sets all properties of the adjustment at once.
//
// Use this function to avoid multiple emissions of the Adjustment::changed
// signal. See gtk_adjustment_set_lower() for an alternative way of compressing
// multiple emissions of Adjustment::changed into one.
func (a adjustment) Configure(value float64, lower float64, upper float64, stepIncrement float64, pageIncrement float64, pageSize float64) {
	var _arg0 *C.GtkAdjustment // out
	var _arg1 C.gdouble        // out
	var _arg2 C.gdouble        // out
	var _arg3 C.gdouble        // out
	var _arg4 C.gdouble        // out
	var _arg5 C.gdouble        // out
	var _arg6 C.gdouble        // out

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))
	_arg1 = (C.gdouble)(value)
	_arg2 = (C.gdouble)(lower)
	_arg3 = (C.gdouble)(upper)
	_arg4 = (C.gdouble)(stepIncrement)
	_arg5 = (C.gdouble)(pageIncrement)
	_arg6 = (C.gdouble)(pageSize)

	C.gtk_adjustment_configure(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}

// Lower retrieves the minimum value of the adjustment.
func (a adjustment) Lower() float64 {
	var _arg0 *C.GtkAdjustment // out
	var _cret C.gdouble        // in

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_adjustment_get_lower(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// MinimumIncrement gets the smaller of step increment and page increment.
func (a adjustment) MinimumIncrement() float64 {
	var _arg0 *C.GtkAdjustment // out
	var _cret C.gdouble        // in

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_adjustment_get_minimum_increment(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// PageIncrement retrieves the page increment of the adjustment.
func (a adjustment) PageIncrement() float64 {
	var _arg0 *C.GtkAdjustment // out
	var _cret C.gdouble        // in

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_adjustment_get_page_increment(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// PageSize retrieves the page size of the adjustment.
func (a adjustment) PageSize() float64 {
	var _arg0 *C.GtkAdjustment // out
	var _cret C.gdouble        // in

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_adjustment_get_page_size(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// StepIncrement retrieves the step increment of the adjustment.
func (a adjustment) StepIncrement() float64 {
	var _arg0 *C.GtkAdjustment // out
	var _cret C.gdouble        // in

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_adjustment_get_step_increment(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// Upper retrieves the maximum value of the adjustment.
func (a adjustment) Upper() float64 {
	var _arg0 *C.GtkAdjustment // out
	var _cret C.gdouble        // in

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_adjustment_get_upper(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// Value gets the current value of the adjustment. See
// gtk_adjustment_set_value().
func (a adjustment) Value() float64 {
	var _arg0 *C.GtkAdjustment // out
	var _cret C.gdouble        // in

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_adjustment_get_value(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// SetLower sets the minimum value of the adjustment.
//
// When setting multiple adjustment properties via their individual setters,
// multiple Adjustment::changed signals will be emitted. However, since the
// emission of the Adjustment::changed signal is tied to the emission of the
// #GObject::notify signals of the changed properties, it’s possible to compress
// the Adjustment::changed signals into one by calling g_object_freeze_notify()
// and g_object_thaw_notify() around the calls to the individual setters.
//
// Alternatively, using a single g_object_set() for all the properties to
// change, or using gtk_adjustment_configure() has the same effect of
// compressing Adjustment::changed emissions.
func (a adjustment) SetLower(lower float64) {
	var _arg0 *C.GtkAdjustment // out
	var _arg1 C.gdouble        // out

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))
	_arg1 = (C.gdouble)(lower)

	C.gtk_adjustment_set_lower(_arg0, _arg1)
}

// SetPageIncrement sets the page increment of the adjustment.
//
// See gtk_adjustment_set_lower() about how to compress multiple emissions of
// the Adjustment::changed signal when setting multiple adjustment properties.
func (a adjustment) SetPageIncrement(pageIncrement float64) {
	var _arg0 *C.GtkAdjustment // out
	var _arg1 C.gdouble        // out

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))
	_arg1 = (C.gdouble)(pageIncrement)

	C.gtk_adjustment_set_page_increment(_arg0, _arg1)
}

// SetPageSize sets the page size of the adjustment.
//
// See gtk_adjustment_set_lower() about how to compress multiple emissions of
// the GtkAdjustment::changed signal when setting multiple adjustment
// properties.
func (a adjustment) SetPageSize(pageSize float64) {
	var _arg0 *C.GtkAdjustment // out
	var _arg1 C.gdouble        // out

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))
	_arg1 = (C.gdouble)(pageSize)

	C.gtk_adjustment_set_page_size(_arg0, _arg1)
}

// SetStepIncrement sets the step increment of the adjustment.
//
// See gtk_adjustment_set_lower() about how to compress multiple emissions of
// the Adjustment::changed signal when setting multiple adjustment properties.
func (a adjustment) SetStepIncrement(stepIncrement float64) {
	var _arg0 *C.GtkAdjustment // out
	var _arg1 C.gdouble        // out

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))
	_arg1 = (C.gdouble)(stepIncrement)

	C.gtk_adjustment_set_step_increment(_arg0, _arg1)
}

// SetUpper sets the maximum value of the adjustment.
//
// Note that values will be restricted by `upper - page-size` if the page-size
// property is nonzero.
//
// See gtk_adjustment_set_lower() about how to compress multiple emissions of
// the Adjustment::changed signal when setting multiple adjustment properties.
func (a adjustment) SetUpper(upper float64) {
	var _arg0 *C.GtkAdjustment // out
	var _arg1 C.gdouble        // out

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))
	_arg1 = (C.gdouble)(upper)

	C.gtk_adjustment_set_upper(_arg0, _arg1)
}

// SetValue sets the Adjustment value. The value is clamped to lie between
// Adjustment:lower and Adjustment:upper.
//
// Note that for adjustments which are used in a Scrollbar, the effective range
// of allowed values goes from Adjustment:lower to Adjustment:upper -
// Adjustment:page-size.
func (a adjustment) SetValue(value float64) {
	var _arg0 *C.GtkAdjustment // out
	var _arg1 C.gdouble        // out

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))
	_arg1 = (C.gdouble)(value)

	C.gtk_adjustment_set_value(_arg0, _arg1)
}

// ValueChanged emits a Adjustment::value-changed signal from the Adjustment.
// This is typically called by the owner of the Adjustment after it has changed
// the Adjustment:value property.
func (a adjustment) ValueChanged() {
	var _arg0 *C.GtkAdjustment // out

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))

	C.gtk_adjustment_value_changed(_arg0)
}

// Alignment: the Alignment widget controls the alignment and size of its child
// widget. It has four settings: xscale, yscale, xalign, and yalign.
//
// The scale settings are used to specify how much the child widget should
// expand to fill the space allocated to the Alignment. The values can range
// from 0 (meaning the child doesn’t expand at all) to 1 (meaning the child
// expands to fill all of the available space).
//
// The align settings are used to place the child widget within the available
// area. The values range from 0 (top or left) to 1 (bottom or right). Of
// course, if the scale settings are both set to 1, the alignment settings have
// no effect.
//
// GtkAlignment has been deprecated in 3.14 and should not be used in
// newly-written code. The desired effect can be achieved by using the
// Widget:halign, Widget:valign and Widget:margin properties on the child
// widget.
type Alignment interface {
	Bin
	Buildable

	// Padding gets the padding on the different sides of the widget. See
	// gtk_alignment_set_padding ().
	Padding() (paddingTop uint, paddingBottom uint, paddingLeft uint, paddingRight uint)
	// Set sets the Alignment values.
	Set(xalign float32, yalign float32, xscale float32, yscale float32)
	// SetPadding sets the padding on the different sides of the widget. The
	// padding adds blank space to the sides of the widget. For instance, this
	// can be used to indent the child widget towards the right by adding
	// padding on the left.
	SetPadding(paddingTop uint, paddingBottom uint, paddingLeft uint, paddingRight uint)
}

// alignment implements the Alignment class.
type alignment struct {
	Bin
	Buildable
}

var _ Alignment = (*alignment)(nil)

// WrapAlignment wraps a GObject to the right type. It is
// primarily used internally.
func WrapAlignment(obj *externglib.Object) Alignment {
	return alignment{
		Bin:       WrapBin(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalAlignment(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAlignment(obj), nil
}

// NewAlignment creates a new Alignment.
func NewAlignment(xalign float32, yalign float32, xscale float32, yscale float32) Alignment {
	var _arg1 C.gfloat     // out
	var _arg2 C.gfloat     // out
	var _arg3 C.gfloat     // out
	var _arg4 C.gfloat     // out
	var _cret *C.GtkWidget // in

	_arg1 = (C.gfloat)(xalign)
	_arg2 = (C.gfloat)(yalign)
	_arg3 = (C.gfloat)(xscale)
	_arg4 = (C.gfloat)(yscale)

	_cret = C.gtk_alignment_new(_arg1, _arg2, _arg3, _arg4)

	var _alignment Alignment // out

	_alignment = WrapAlignment(externglib.Take(unsafe.Pointer(_cret)))

	return _alignment
}

// Padding gets the padding on the different sides of the widget. See
// gtk_alignment_set_padding ().
func (a alignment) Padding() (paddingTop uint, paddingBottom uint, paddingLeft uint, paddingRight uint) {
	var _arg0 *C.GtkAlignment // out
	var _arg1 C.guint         // in
	var _arg2 C.guint         // in
	var _arg3 C.guint         // in
	var _arg4 C.guint         // in

	_arg0 = (*C.GtkAlignment)(unsafe.Pointer(a.Native()))

	C.gtk_alignment_get_padding(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)

	var _paddingTop uint    // out
	var _paddingBottom uint // out
	var _paddingLeft uint   // out
	var _paddingRight uint  // out

	_paddingTop = (uint)(_arg1)
	_paddingBottom = (uint)(_arg2)
	_paddingLeft = (uint)(_arg3)
	_paddingRight = (uint)(_arg4)

	return _paddingTop, _paddingBottom, _paddingLeft, _paddingRight
}

// Set sets the Alignment values.
func (a alignment) Set(xalign float32, yalign float32, xscale float32, yscale float32) {
	var _arg0 *C.GtkAlignment // out
	var _arg1 C.gfloat        // out
	var _arg2 C.gfloat        // out
	var _arg3 C.gfloat        // out
	var _arg4 C.gfloat        // out

	_arg0 = (*C.GtkAlignment)(unsafe.Pointer(a.Native()))
	_arg1 = (C.gfloat)(xalign)
	_arg2 = (C.gfloat)(yalign)
	_arg3 = (C.gfloat)(xscale)
	_arg4 = (C.gfloat)(yscale)

	C.gtk_alignment_set(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// SetPadding sets the padding on the different sides of the widget. The padding
// adds blank space to the sides of the widget. For instance, this can be used
// to indent the child widget towards the right by adding padding on the left.
func (a alignment) SetPadding(paddingTop uint, paddingBottom uint, paddingLeft uint, paddingRight uint) {
	var _arg0 *C.GtkAlignment // out
	var _arg1 C.guint         // out
	var _arg2 C.guint         // out
	var _arg3 C.guint         // out
	var _arg4 C.guint         // out

	_arg0 = (*C.GtkAlignment)(unsafe.Pointer(a.Native()))
	_arg1 = (C.guint)(paddingTop)
	_arg2 = (C.guint)(paddingBottom)
	_arg3 = (C.guint)(paddingLeft)
	_arg4 = (C.guint)(paddingRight)

	C.gtk_alignment_set_padding(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// AppChooserButton: the AppChooserButton is a widget that lets the user select
// an application. It implements the AppChooser interface.
//
// Initially, a AppChooserButton selects the first application in its list,
// which will either be the most-recently used application or, if
// AppChooserButton:show-default-item is true, the default application.
//
// The list of applications shown in a AppChooserButton includes the recommended
// applications for the given content type. When
// AppChooserButton:show-default-item is set, the default application is also
// included. To let the user chooser other applications, you can set the
// AppChooserButton:show-dialog-item property, which allows to open a full
// AppChooserDialog.
//
// It is possible to add custom items to the list, using
// gtk_app_chooser_button_append_custom_item(). These items cause the
// AppChooserButton::custom-item-activated signal to be emitted when they are
// selected.
//
// To track changes in the selected application, use the ComboBox::changed
// signal.
type AppChooserButton interface {
	ComboBox
	AppChooser
	Buildable
	CellEditable
	CellLayout

	// AppendCustomItem appends a custom item to the list of applications that
	// is shown in the popup; the item name must be unique per-widget. Clients
	// can use the provided name as a detail for the
	// AppChooserButton::custom-item-activated signal, to add a callback for the
	// activation of a particular custom item in the list. See also
	// gtk_app_chooser_button_append_separator().
	AppendCustomItem(name string, label string, icon gio.Icon)
	// AppendSeparator appends a separator to the list of applications that is
	// shown in the popup.
	AppendSeparator()
	// Heading returns the text to display at the top of the dialog.
	Heading() string
	// ShowDefaultItem returns the current value of the
	// AppChooserButton:show-default-item property.
	ShowDefaultItem() bool
	// ShowDialogItem returns the current value of the
	// AppChooserButton:show-dialog-item property.
	ShowDialogItem() bool
	// SetActiveCustomItem selects a custom item previously added with
	// gtk_app_chooser_button_append_custom_item().
	//
	// Use gtk_app_chooser_refresh() to bring the selection to its initial
	// state.
	SetActiveCustomItem(name string)
	// SetHeading sets the text to display at the top of the dialog. If the
	// heading is not set, the dialog displays a default text.
	SetHeading(heading string)
	// SetShowDefaultItem sets whether the dropdown menu of this button should
	// show the default application for the given content type at top.
	SetShowDefaultItem(setting bool)
	// SetShowDialogItem sets whether the dropdown menu of this button should
	// show an entry to trigger a AppChooserDialog.
	SetShowDialogItem(setting bool)
}

// appChooserButton implements the AppChooserButton class.
type appChooserButton struct {
	ComboBox
	AppChooser
	Buildable
	CellEditable
	CellLayout
}

var _ AppChooserButton = (*appChooserButton)(nil)

// WrapAppChooserButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapAppChooserButton(obj *externglib.Object) AppChooserButton {
	return appChooserButton{
		ComboBox:     WrapComboBox(obj),
		AppChooser:   WrapAppChooser(obj),
		Buildable:    WrapBuildable(obj),
		CellEditable: WrapCellEditable(obj),
		CellLayout:   WrapCellLayout(obj),
	}
}

func marshalAppChooserButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAppChooserButton(obj), nil
}

// NewAppChooserButton creates a new AppChooserButton for applications that can
// handle content of the given type.
func NewAppChooserButton(contentType string) AppChooserButton {
	var _arg1 *C.gchar     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.gchar)(C.CString(contentType))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_app_chooser_button_new(_arg1)

	var _appChooserButton AppChooserButton // out

	_appChooserButton = WrapAppChooserButton(externglib.Take(unsafe.Pointer(_cret)))

	return _appChooserButton
}

// AppendCustomItem appends a custom item to the list of applications that is
// shown in the popup; the item name must be unique per-widget. Clients can use
// the provided name as a detail for the AppChooserButton::custom-item-activated
// signal, to add a callback for the activation of a particular custom item in
// the list. See also gtk_app_chooser_button_append_separator().
func (s appChooserButton) AppendCustomItem(name string, label string, icon gio.Icon) {
	var _arg0 *C.GtkAppChooserButton // out
	var _arg1 *C.gchar               // out
	var _arg2 *C.gchar               // out
	var _arg3 *C.GIcon               // out

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

	C.gtk_app_chooser_button_append_custom_item(_arg0, _arg1, _arg2, _arg3)
}

// AppendSeparator appends a separator to the list of applications that is shown
// in the popup.
func (s appChooserButton) AppendSeparator() {
	var _arg0 *C.GtkAppChooserButton // out

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))

	C.gtk_app_chooser_button_append_separator(_arg0)
}

// Heading returns the text to display at the top of the dialog.
func (s appChooserButton) Heading() string {
	var _arg0 *C.GtkAppChooserButton // out
	var _cret *C.gchar               // in

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_app_chooser_button_get_heading(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// ShowDefaultItem returns the current value of the
// AppChooserButton:show-default-item property.
func (s appChooserButton) ShowDefaultItem() bool {
	var _arg0 *C.GtkAppChooserButton // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_app_chooser_button_get_show_default_item(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowDialogItem returns the current value of the
// AppChooserButton:show-dialog-item property.
func (s appChooserButton) ShowDialogItem() bool {
	var _arg0 *C.GtkAppChooserButton // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_app_chooser_button_get_show_dialog_item(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetActiveCustomItem selects a custom item previously added with
// gtk_app_chooser_button_append_custom_item().
//
// Use gtk_app_chooser_refresh() to bring the selection to its initial state.
func (s appChooserButton) SetActiveCustomItem(name string) {
	var _arg0 *C.GtkAppChooserButton // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_app_chooser_button_set_active_custom_item(_arg0, _arg1)
}

// SetHeading sets the text to display at the top of the dialog. If the heading
// is not set, the dialog displays a default text.
func (s appChooserButton) SetHeading(heading string) {
	var _arg0 *C.GtkAppChooserButton // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(heading))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_app_chooser_button_set_heading(_arg0, _arg1)
}

// SetShowDefaultItem sets whether the dropdown menu of this button should show
// the default application for the given content type at top.
func (s appChooserButton) SetShowDefaultItem(setting bool) {
	var _arg0 *C.GtkAppChooserButton // out
	var _arg1 C.gboolean             // out

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_app_chooser_button_set_show_default_item(_arg0, _arg1)
}

// SetShowDialogItem sets whether the dropdown menu of this button should show
// an entry to trigger a AppChooserDialog.
func (s appChooserButton) SetShowDialogItem(setting bool) {
	var _arg0 *C.GtkAppChooserButton // out
	var _arg1 C.gboolean             // out

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_app_chooser_button_set_show_dialog_item(_arg0, _arg1)
}

// AppChooserDialog shows a AppChooserWidget inside a Dialog.
//
// Note that AppChooserDialog does not have any interesting methods of its own.
// Instead, you should get the embedded AppChooserWidget using
// gtk_app_chooser_dialog_get_widget() and call its methods if the generic
// AppChooser interface is not sufficient for your needs.
//
// To set the heading that is shown above the AppChooserWidget, use
// gtk_app_chooser_dialog_set_heading().
type AppChooserDialog interface {
	Dialog
	AppChooser
	Buildable

	// Heading returns the text to display at the top of the dialog.
	Heading() string
	// Widget returns the AppChooserWidget of this dialog.
	Widget() Widget
	// SetHeading sets the text to display at the top of the dialog. If the
	// heading is not set, the dialog displays a default text.
	SetHeading(heading string)
}

// appChooserDialog implements the AppChooserDialog class.
type appChooserDialog struct {
	Dialog
	AppChooser
	Buildable
}

var _ AppChooserDialog = (*appChooserDialog)(nil)

// WrapAppChooserDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapAppChooserDialog(obj *externglib.Object) AppChooserDialog {
	return appChooserDialog{
		Dialog:     WrapDialog(obj),
		AppChooser: WrapAppChooser(obj),
		Buildable:  WrapBuildable(obj),
	}
}

func marshalAppChooserDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAppChooserDialog(obj), nil
}

// NewAppChooserDialog creates a new AppChooserDialog for the provided #GFile,
// to allow the user to select an application for it.
func NewAppChooserDialog(parent Window, flags DialogFlags, file gio.File) AppChooserDialog {
	var _arg1 *C.GtkWindow     // out
	var _arg2 C.GtkDialogFlags // out
	var _arg3 *C.GFile         // out
	var _cret *C.GtkWidget     // in

	_arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))
	_arg2 = (C.GtkDialogFlags)(flags)
	_arg3 = (*C.GFile)(unsafe.Pointer(file.Native()))

	_cret = C.gtk_app_chooser_dialog_new(_arg1, _arg2, _arg3)

	var _appChooserDialog AppChooserDialog // out

	_appChooserDialog = WrapAppChooserDialog(externglib.Take(unsafe.Pointer(_cret)))

	return _appChooserDialog
}

// NewAppChooserDialogForContentType creates a new AppChooserDialog for the
// provided content type, to allow the user to select an application for it.
func NewAppChooserDialogForContentType(parent Window, flags DialogFlags, contentType string) AppChooserDialog {
	var _arg1 *C.GtkWindow     // out
	var _arg2 C.GtkDialogFlags // out
	var _arg3 *C.gchar         // out
	var _cret *C.GtkWidget     // in

	_arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))
	_arg2 = (C.GtkDialogFlags)(flags)
	_arg3 = (*C.gchar)(C.CString(contentType))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.gtk_app_chooser_dialog_new_for_content_type(_arg1, _arg2, _arg3)

	var _appChooserDialog AppChooserDialog // out

	_appChooserDialog = WrapAppChooserDialog(externglib.Take(unsafe.Pointer(_cret)))

	return _appChooserDialog
}

// Heading returns the text to display at the top of the dialog.
func (s appChooserDialog) Heading() string {
	var _arg0 *C.GtkAppChooserDialog // out
	var _cret *C.gchar               // in

	_arg0 = (*C.GtkAppChooserDialog)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_app_chooser_dialog_get_heading(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Widget returns the AppChooserWidget of this dialog.
func (s appChooserDialog) Widget() Widget {
	var _arg0 *C.GtkAppChooserDialog // out
	var _cret *C.GtkWidget           // in

	_arg0 = (*C.GtkAppChooserDialog)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_app_chooser_dialog_get_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// SetHeading sets the text to display at the top of the dialog. If the heading
// is not set, the dialog displays a default text.
func (s appChooserDialog) SetHeading(heading string) {
	var _arg0 *C.GtkAppChooserDialog // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GtkAppChooserDialog)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(heading))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_app_chooser_dialog_set_heading(_arg0, _arg1)
}

// AppChooserWidget is a widget for selecting applications. It is the main
// building block for AppChooserDialog. Most applications only need to use the
// latter; but you can use this widget as part of a larger widget if you have
// special needs.
//
// AppChooserWidget offers detailed control over what applications are shown,
// using the AppChooserWidget:show-default, AppChooserWidget:show-recommended,
// AppChooserWidget:show-fallback, AppChooserWidget:show-other and
// AppChooserWidget:show-all properties. See the AppChooser documentation for
// more information about these groups of applications.
//
// To keep track of the selected application, use the
// AppChooserWidget::application-selected and
// AppChooserWidget::application-activated signals.
//
//
// CSS nodes
//
// GtkAppChooserWidget has a single CSS node with name appchooser.
type AppChooserWidget interface {
	Box
	AppChooser
	Buildable
	Orientable

	// DefaultText returns the text that is shown if there are not applications
	// that can handle the content type.
	DefaultText() string
	// ShowAll returns the current value of the AppChooserWidget:show-all
	// property.
	ShowAll() bool
	// ShowDefault returns the current value of the
	// AppChooserWidget:show-default property.
	ShowDefault() bool
	// ShowFallback returns the current value of the
	// AppChooserWidget:show-fallback property.
	ShowFallback() bool
	// ShowOther returns the current value of the AppChooserWidget:show-other
	// property.
	ShowOther() bool
	// ShowRecommended returns the current value of the
	// AppChooserWidget:show-recommended property.
	ShowRecommended() bool
	// SetDefaultText sets the text that is shown if there are not applications
	// that can handle the content type.
	SetDefaultText(text string)
	// SetShowAll sets whether the app chooser should show all applications in a
	// flat list.
	SetShowAll(setting bool)
	// SetShowDefault sets whether the app chooser should show the default
	// handler for the content type in a separate section.
	SetShowDefault(setting bool)
	// SetShowFallback sets whether the app chooser should show related
	// applications for the content type in a separate section.
	SetShowFallback(setting bool)
	// SetShowOther sets whether the app chooser should show applications which
	// are unrelated to the content type.
	SetShowOther(setting bool)
	// SetShowRecommended sets whether the app chooser should show recommended
	// applications for the content type in a separate section.
	SetShowRecommended(setting bool)
}

// appChooserWidget implements the AppChooserWidget class.
type appChooserWidget struct {
	Box
	AppChooser
	Buildable
	Orientable
}

var _ AppChooserWidget = (*appChooserWidget)(nil)

// WrapAppChooserWidget wraps a GObject to the right type. It is
// primarily used internally.
func WrapAppChooserWidget(obj *externglib.Object) AppChooserWidget {
	return appChooserWidget{
		Box:        WrapBox(obj),
		AppChooser: WrapAppChooser(obj),
		Buildable:  WrapBuildable(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalAppChooserWidget(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAppChooserWidget(obj), nil
}

// NewAppChooserWidget creates a new AppChooserWidget for applications that can
// handle content of the given type.
func NewAppChooserWidget(contentType string) AppChooserWidget {
	var _arg1 *C.gchar     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.gchar)(C.CString(contentType))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_app_chooser_widget_new(_arg1)

	var _appChooserWidget AppChooserWidget // out

	_appChooserWidget = WrapAppChooserWidget(externglib.Take(unsafe.Pointer(_cret)))

	return _appChooserWidget
}

// DefaultText returns the text that is shown if there are not applications that
// can handle the content type.
func (s appChooserWidget) DefaultText() string {
	var _arg0 *C.GtkAppChooserWidget // out
	var _cret *C.gchar               // in

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_app_chooser_widget_get_default_text(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// ShowAll returns the current value of the AppChooserWidget:show-all property.
func (s appChooserWidget) ShowAll() bool {
	var _arg0 *C.GtkAppChooserWidget // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_app_chooser_widget_get_show_all(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowDefault returns the current value of the AppChooserWidget:show-default
// property.
func (s appChooserWidget) ShowDefault() bool {
	var _arg0 *C.GtkAppChooserWidget // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_app_chooser_widget_get_show_default(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowFallback returns the current value of the AppChooserWidget:show-fallback
// property.
func (s appChooserWidget) ShowFallback() bool {
	var _arg0 *C.GtkAppChooserWidget // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_app_chooser_widget_get_show_fallback(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowOther returns the current value of the AppChooserWidget:show-other
// property.
func (s appChooserWidget) ShowOther() bool {
	var _arg0 *C.GtkAppChooserWidget // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_app_chooser_widget_get_show_other(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowRecommended returns the current value of the
// AppChooserWidget:show-recommended property.
func (s appChooserWidget) ShowRecommended() bool {
	var _arg0 *C.GtkAppChooserWidget // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_app_chooser_widget_get_show_recommended(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetDefaultText sets the text that is shown if there are not applications that
// can handle the content type.
func (s appChooserWidget) SetDefaultText(text string) {
	var _arg0 *C.GtkAppChooserWidget // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_app_chooser_widget_set_default_text(_arg0, _arg1)
}

// SetShowAll sets whether the app chooser should show all applications in a
// flat list.
func (s appChooserWidget) SetShowAll(setting bool) {
	var _arg0 *C.GtkAppChooserWidget // out
	var _arg1 C.gboolean             // out

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_app_chooser_widget_set_show_all(_arg0, _arg1)
}

// SetShowDefault sets whether the app chooser should show the default handler
// for the content type in a separate section.
func (s appChooserWidget) SetShowDefault(setting bool) {
	var _arg0 *C.GtkAppChooserWidget // out
	var _arg1 C.gboolean             // out

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_app_chooser_widget_set_show_default(_arg0, _arg1)
}

// SetShowFallback sets whether the app chooser should show related applications
// for the content type in a separate section.
func (s appChooserWidget) SetShowFallback(setting bool) {
	var _arg0 *C.GtkAppChooserWidget // out
	var _arg1 C.gboolean             // out

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_app_chooser_widget_set_show_fallback(_arg0, _arg1)
}

// SetShowOther sets whether the app chooser should show applications which are
// unrelated to the content type.
func (s appChooserWidget) SetShowOther(setting bool) {
	var _arg0 *C.GtkAppChooserWidget // out
	var _arg1 C.gboolean             // out

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_app_chooser_widget_set_show_other(_arg0, _arg1)
}

// SetShowRecommended sets whether the app chooser should show recommended
// applications for the content type in a separate section.
func (s appChooserWidget) SetShowRecommended(setting bool) {
	var _arg0 *C.GtkAppChooserWidget // out
	var _arg1 C.gboolean             // out

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_app_chooser_widget_set_show_recommended(_arg0, _arg1)
}

// Application is a class that handles many important aspects of a GTK+
// application in a convenient fashion, without enforcing a one-size-fits-all
// application model.
//
// Currently, GtkApplication handles GTK+ initialization, application
// uniqueness, session management, provides some basic scriptability and desktop
// shell integration by exporting actions and menus and manages a list of
// toplevel windows whose life-cycle is automatically tied to the life-cycle of
// your application.
//
// While GtkApplication works fine with plain Windows, it is recommended to use
// it together with ApplicationWindow.
//
// When GDK threads are enabled, GtkApplication will acquire the GDK lock when
// invoking actions that arrive from other processes. The GDK lock is not
// touched for local action invocations. In order to have actions invoked in a
// predictable context it is therefore recommended that the GDK lock be held
// while invoking actions locally with g_action_group_activate_action(). The
// same applies to actions associated with ApplicationWindow and to the
// “activate” and “open” #GApplication methods.
//
//
// Automatic resources
//
// Application will automatically load menus from the Builder resource located
// at "gtk/menus.ui", relative to the application's resource base path (see
// g_application_set_resource_base_path()). The menu with the ID "app-menu" is
// taken as the application's app menu and the menu with the ID "menubar" is
// taken as the application's menubar. Additional menus (most interesting
// submenus) can be named and accessed via gtk_application_get_menu_by_id()
// which allows for dynamic population of a part of the menu structure.
//
// If the resources "gtk/menus-appmenu.ui" or "gtk/menus-traditional.ui" are
// present then these files will be used in preference, depending on the value
// of gtk_application_prefers_app_menu(). If the resource "gtk/menus-common.ui"
// is present it will be loaded as well. This is useful for storing items that
// are referenced from both "gtk/menus-appmenu.ui" and
// "gtk/menus-traditional.ui".
//
// It is also possible to provide the menus manually using
// gtk_application_set_app_menu() and gtk_application_set_menubar().
//
// Application will also automatically setup an icon search path for the default
// icon theme by appending "icons" to the resource base path. This allows your
// application to easily store its icons as resources. See
// gtk_icon_theme_add_resource_path() for more information.
//
// If there is a resource located at "gtk/help-overlay.ui" which defines a
// ShortcutsWindow with ID "help_overlay" then GtkApplication associates an
// instance of this shortcuts window with each ApplicationWindow and sets up
// keyboard accelerators (Control-F1 and Control-?) to open it. To create a menu
// item that displays the shortcuts window, associate the item with the action
// win.show-help-overlay.
//
//
// A simple application
//
// A simple example
// (https://git.gnome.org/browse/gtk+/tree/examples/bp/bloatpad.c)
//
// GtkApplication optionally registers with a session manager of the users
// session (if you set the Application:register-session property) and offers
// various functionality related to the session life-cycle.
//
// An application can block various ways to end the session with the
// gtk_application_inhibit() function. Typical use cases for this kind of
// inhibiting are long-running, uninterruptible operations, such as burning a CD
// or performing a disk backup. The session manager may not honor the inhibitor,
// but it can be expected to inform the user about the negative consequences of
// ending the session while inhibitors are present.
//
//
// See Also
//
// HowDoI: Using GtkApplication (https://wiki.gnome.org/HowDoI/GtkApplication),
// Getting Started with GTK+: Basics
// (https://developer.gnome.org/gtk3/stable/gtk-getting-started.html#id-1.2.3.3)
type Application interface {
	gio.Application
	gio.ActionGroup
	gio.ActionMap

	// AddAccelerator installs an accelerator that will cause the named action
	// to be activated when the key combination specificed by @accelerator is
	// pressed.
	//
	// @accelerator must be a string that can be parsed by
	// gtk_accelerator_parse(), e.g. "<Primary>q" or “<Control><Alt>p”.
	//
	// @action_name must be the name of an action as it would be used in the app
	// menu, i.e. actions that have been added to the application are referred
	// to with an “app.” prefix, and window-specific actions with a “win.”
	// prefix.
	//
	// GtkApplication also extracts accelerators out of “accel” attributes in
	// the Models passed to gtk_application_set_app_menu() and
	// gtk_application_set_menubar(), which is usually more convenient than
	// calling this function for each accelerator.
	AddAccelerator(accelerator string, actionName string, parameter *glib.Variant)
	// AddWindow adds a window to @application.
	//
	// This call can only happen after the @application has started; typically,
	// you should add new application windows in response to the emission of the
	// #GApplication::activate signal.
	//
	// This call is equivalent to setting the Window:application property of
	// @window to @application.
	//
	// Normally, the connection between the application and the window will
	// remain until the window is destroyed, but you can explicitly remove it
	// with gtk_application_remove_window().
	//
	// GTK+ will keep the @application running as long as it has any windows.
	AddWindow(window Window)
	// AccelsForAction gets the accelerators that are currently associated with
	// the given action.
	AccelsForAction(detailedActionName string) []string
	// ActionsForAccel returns the list of actions (possibly empty) that @accel
	// maps to. Each item in the list is a detailed action name in the usual
	// form.
	//
	// This might be useful to discover if an accel already exists in order to
	// prevent installation of a conflicting accelerator (from an accelerator
	// editor or a plugin system, for example). Note that having more than one
	// action per accelerator may not be a bad thing and might make sense in
	// cases where the actions never appear in the same context.
	//
	// In case there are no actions for a given accelerator, an empty array is
	// returned. nil is never returned.
	//
	// It is a programmer error to pass an invalid accelerator string. If you
	// are unsure, check it with gtk_accelerator_parse() first.
	ActionsForAccel(accel string) []string
	// ActiveWindow gets the “active” window for the application.
	//
	// The active window is the one that was most recently focused (within the
	// application). This window may not have the focus at the moment if another
	// application has it — this is just the most recently-focused window within
	// this application.
	ActiveWindow() Window
	// AppMenu returns the menu model that has been set with
	// gtk_application_set_app_menu().
	AppMenu() gio.MenuModel
	// MenuByID gets a menu from automatically loaded resources. See [Automatic
	// resources][automatic-resources] for more information.
	MenuByID(id string) gio.Menu
	// Menubar returns the menu model that has been set with
	// gtk_application_set_menubar().
	Menubar() gio.MenuModel
	// WindowByID returns the ApplicationWindow with the given ID.
	//
	// The ID of a ApplicationWindow can be retrieved with
	// gtk_application_window_get_id().
	WindowByID(id uint) Window
	// Inhibit: inform the session manager that certain types of actions should
	// be inhibited. This is not guaranteed to work on all platforms and for all
	// types of actions.
	//
	// Applications should invoke this method when they begin an operation that
	// should not be interrupted, such as creating a CD or DVD. The types of
	// actions that may be blocked are specified by the @flags parameter. When
	// the application completes the operation it should call
	// gtk_application_uninhibit() to remove the inhibitor. Note that an
	// application can have multiple inhibitors, and all of them must be
	// individually removed. Inhibitors are also cleared when the application
	// exits.
	//
	// Applications should not expect that they will always be able to block the
	// action. In most cases, users will be given the option to force the action
	// to take place.
	//
	// Reasons should be short and to the point.
	//
	// If @window is given, the session manager may point the user to this
	// window to find out more about why the action is inhibited.
	Inhibit(window Window, flags ApplicationInhibitFlags, reason string) uint
	// IsInhibited determines if any of the actions specified in @flags are
	// currently inhibited (possibly by another application).
	//
	// Note that this information may not be available (for example when the
	// application is running in a sandbox).
	IsInhibited(flags ApplicationInhibitFlags) bool
	// ListActionDescriptions lists the detailed action names which have
	// associated accelerators. See gtk_application_set_accels_for_action().
	ListActionDescriptions() []string
	// PrefersAppMenu determines if the desktop environment in which the
	// application is running would prefer an application menu be shown.
	//
	// If this function returns true then the application should call
	// gtk_application_set_app_menu() with the contents of an application menu,
	// which will be shown by the desktop environment. If it returns false then
	// you should consider using an alternate approach, such as a menubar.
	//
	// The value returned by this function is purely advisory and you are free
	// to ignore it. If you call gtk_application_set_app_menu() even if the
	// desktop environment doesn't support app menus, then a fallback will be
	// provided.
	//
	// Applications are similarly free not to set an app menu even if the
	// desktop environment wants to show one. In that case, a fallback will also
	// be created by the desktop environment (GNOME, for example, uses a menu
	// with only a "Quit" item in it).
	//
	// The value returned by this function never changes. Once it returns a
	// particular value, it is guaranteed to always return the same value.
	//
	// You may only call this function after the application has been registered
	// and after the base startup handler has run. You're most likely to want to
	// use this from your own startup handler. It may also make sense to consult
	// this function while constructing UI (in activate, open or an action
	// activation handler) in order to determine if you should show a gear menu
	// or not.
	//
	// This function will return false on Mac OS and a default app menu will be
	// created automatically with the "usual" contents of that menu typical to
	// most Mac OS applications. If you call gtk_application_set_app_menu()
	// anyway, then this menu will be replaced with your own.
	PrefersAppMenu() bool
	// RemoveAccelerator removes an accelerator that has been previously added
	// with gtk_application_add_accelerator().
	RemoveAccelerator(actionName string, parameter *glib.Variant)
	// RemoveWindow: remove a window from @application.
	//
	// If @window belongs to @application then this call is equivalent to
	// setting the Window:application property of @window to nil.
	//
	// The application may stop running as a result of a call to this function.
	RemoveWindow(window Window)
	// SetAccelsForAction sets zero or more keyboard accelerators that will
	// trigger the given action. The first item in @accels will be the primary
	// accelerator, which may be displayed in the UI.
	//
	// To remove all accelerators for an action, use an empty, zero-terminated
	// array for @accels.
	//
	// For the @detailed_action_name, see g_action_parse_detailed_name() and
	// g_action_print_detailed_name().
	SetAccelsForAction(detailedActionName string, accels []string)
	// SetAppMenu sets or unsets the application menu for @application.
	//
	// This can only be done in the primary instance of the application, after
	// it has been registered. #GApplication::startup is a good place to call
	// this.
	//
	// The application menu is a single menu containing items that typically
	// impact the application as a whole, rather than acting on a specific
	// window or document. For example, you would expect to see “Preferences” or
	// “Quit” in an application menu, but not “Save” or “Print”.
	//
	// If supported, the application menu will be rendered by the desktop
	// environment.
	//
	// Use the base Map interface to add actions, to respond to the user
	// selecting these menu items.
	SetAppMenu(appMenu gio.MenuModel)
	// SetMenubar sets or unsets the menubar for windows of @application.
	//
	// This is a menubar in the traditional sense.
	//
	// This can only be done in the primary instance of the application, after
	// it has been registered. #GApplication::startup is a good place to call
	// this.
	//
	// Depending on the desktop environment, this may appear at the top of each
	// window, or at the top of the screen. In some environments, if both the
	// application menu and the menubar are set, the application menu will be
	// presented as if it were the first item of the menubar. Other environments
	// treat the two as completely separate — for example, the application menu
	// may be rendered by the desktop shell while the menubar (if set) remains
	// in each individual window.
	//
	// Use the base Map interface to add actions, to respond to the user
	// selecting these menu items.
	SetMenubar(menubar gio.MenuModel)
	// Uninhibit removes an inhibitor that has been established with
	// gtk_application_inhibit(). Inhibitors are also cleared when the
	// application exits.
	Uninhibit(cookie uint)
}

// application implements the Application class.
type application struct {
	gio.Application
	gio.ActionGroup
	gio.ActionMap
}

var _ Application = (*application)(nil)

// WrapApplication wraps a GObject to the right type. It is
// primarily used internally.
func WrapApplication(obj *externglib.Object) Application {
	return application{
		Application: gio.WrapApplication(obj),
		ActionGroup: gio.WrapActionGroup(obj),
		ActionMap:   gio.WrapActionMap(obj),
	}
}

func marshalApplication(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapApplication(obj), nil
}

// NewApplication creates a new Application instance.
//
// When using Application, it is not necessary to call gtk_init() manually. It
// is called as soon as the application gets registered as the primary instance.
//
// Concretely, gtk_init() is called in the default handler for the
// #GApplication::startup signal. Therefore, Application subclasses should chain
// up in their #GApplication::startup handler before using any GTK+ API.
//
// Note that commandline arguments are not passed to gtk_init(). All GTK+
// functionality that is available via commandline arguments can also be
// achieved by setting suitable environment variables such as `G_DEBUG`, so this
// should not be a big problem. If you absolutely must support GTK+ commandline
// arguments, you can explicitly call gtk_init() before creating the application
// instance.
//
// If non-nil, the application ID must be valid. See
// g_application_id_is_valid().
//
// If no application ID is given then some features (most notably application
// uniqueness) will be disabled. A null application ID is only allowed with GTK+
// 3.6 or later.
func NewApplication(applicationId string, flags gio.ApplicationFlags) Application {
	var _arg1 *C.gchar            // out
	var _arg2 C.GApplicationFlags // out
	var _cret *C.GtkApplication   // in

	_arg1 = (*C.gchar)(C.CString(applicationId))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GApplicationFlags)(flags)

	_cret = C.gtk_application_new(_arg1, _arg2)

	var _application Application // out

	_application = WrapApplication(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _application
}

// AddAccelerator installs an accelerator that will cause the named action to be
// activated when the key combination specificed by @accelerator is pressed.
//
// @accelerator must be a string that can be parsed by gtk_accelerator_parse(),
// e.g. "<Primary>q" or “<Control><Alt>p”.
//
// @action_name must be the name of an action as it would be used in the app
// menu, i.e. actions that have been added to the application are referred to
// with an “app.” prefix, and window-specific actions with a “win.” prefix.
//
// GtkApplication also extracts accelerators out of “accel” attributes in the
// Models passed to gtk_application_set_app_menu() and
// gtk_application_set_menubar(), which is usually more convenient than calling
// this function for each accelerator.
func (a application) AddAccelerator(accelerator string, actionName string, parameter *glib.Variant) {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.gchar          // out
	var _arg2 *C.gchar          // out
	var _arg3 *C.GVariant       // out

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(accelerator))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GVariant)(unsafe.Pointer(parameter.Native()))

	C.gtk_application_add_accelerator(_arg0, _arg1, _arg2, _arg3)
}

// AddWindow adds a window to @application.
//
// This call can only happen after the @application has started; typically, you
// should add new application windows in response to the emission of the
// #GApplication::activate signal.
//
// This call is equivalent to setting the Window:application property of @window
// to @application.
//
// Normally, the connection between the application and the window will remain
// until the window is destroyed, but you can explicitly remove it with
// gtk_application_remove_window().
//
// GTK+ will keep the @application running as long as it has any windows.
func (a application) AddWindow(window Window) {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.GtkWindow      // out

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_application_add_window(_arg0, _arg1)
}

// AccelsForAction gets the accelerators that are currently associated with the
// given action.
func (a application) AccelsForAction(detailedActionName string) []string {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.gchar          // out
	var _cret **C.gchar

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(detailedActionName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_application_get_accels_for_action(_arg0, _arg1)

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// ActionsForAccel returns the list of actions (possibly empty) that @accel maps
// to. Each item in the list is a detailed action name in the usual form.
//
// This might be useful to discover if an accel already exists in order to
// prevent installation of a conflicting accelerator (from an accelerator editor
// or a plugin system, for example). Note that having more than one action per
// accelerator may not be a bad thing and might make sense in cases where the
// actions never appear in the same context.
//
// In case there are no actions for a given accelerator, an empty array is
// returned. nil is never returned.
//
// It is a programmer error to pass an invalid accelerator string. If you are
// unsure, check it with gtk_accelerator_parse() first.
func (a application) ActionsForAccel(accel string) []string {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.gchar          // out
	var _cret **C.gchar

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(accel))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_application_get_actions_for_accel(_arg0, _arg1)

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// ActiveWindow gets the “active” window for the application.
//
// The active window is the one that was most recently focused (within the
// application). This window may not have the focus at the moment if another
// application has it — this is just the most recently-focused window within
// this application.
func (a application) ActiveWindow() Window {
	var _arg0 *C.GtkApplication // out
	var _cret *C.GtkWindow      // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_application_get_active_window(_arg0)

	var _window Window // out

	_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Window)

	return _window
}

// AppMenu returns the menu model that has been set with
// gtk_application_set_app_menu().
func (a application) AppMenu() gio.MenuModel {
	var _arg0 *C.GtkApplication // out
	var _cret *C.GMenuModel     // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_application_get_app_menu(_arg0)

	var _menuModel gio.MenuModel // out

	_menuModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.MenuModel)

	return _menuModel
}

// MenuByID gets a menu from automatically loaded resources. See [Automatic
// resources][automatic-resources] for more information.
func (a application) MenuByID(id string) gio.Menu {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.gchar          // out
	var _cret *C.GMenu          // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(id))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_application_get_menu_by_id(_arg0, _arg1)

	var _menu gio.Menu // out

	_menu = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.Menu)

	return _menu
}

// Menubar returns the menu model that has been set with
// gtk_application_set_menubar().
func (a application) Menubar() gio.MenuModel {
	var _arg0 *C.GtkApplication // out
	var _cret *C.GMenuModel     // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_application_get_menubar(_arg0)

	var _menuModel gio.MenuModel // out

	_menuModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.MenuModel)

	return _menuModel
}

// WindowByID returns the ApplicationWindow with the given ID.
//
// The ID of a ApplicationWindow can be retrieved with
// gtk_application_window_get_id().
func (a application) WindowByID(id uint) Window {
	var _arg0 *C.GtkApplication // out
	var _arg1 C.guint           // out
	var _cret *C.GtkWindow      // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (C.guint)(id)

	_cret = C.gtk_application_get_window_by_id(_arg0, _arg1)

	var _window Window // out

	_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Window)

	return _window
}

// Inhibit: inform the session manager that certain types of actions should be
// inhibited. This is not guaranteed to work on all platforms and for all types
// of actions.
//
// Applications should invoke this method when they begin an operation that
// should not be interrupted, such as creating a CD or DVD. The types of actions
// that may be blocked are specified by the @flags parameter. When the
// application completes the operation it should call
// gtk_application_uninhibit() to remove the inhibitor. Note that an application
// can have multiple inhibitors, and all of them must be individually removed.
// Inhibitors are also cleared when the application exits.
//
// Applications should not expect that they will always be able to block the
// action. In most cases, users will be given the option to force the action to
// take place.
//
// Reasons should be short and to the point.
//
// If @window is given, the session manager may point the user to this window to
// find out more about why the action is inhibited.
func (a application) Inhibit(window Window, flags ApplicationInhibitFlags, reason string) uint {
	var _arg0 *C.GtkApplication            // out
	var _arg1 *C.GtkWindow                 // out
	var _arg2 C.GtkApplicationInhibitFlags // out
	var _arg3 *C.gchar                     // out
	var _cret C.guint                      // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg2 = (C.GtkApplicationInhibitFlags)(flags)
	_arg3 = (*C.gchar)(C.CString(reason))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.gtk_application_inhibit(_arg0, _arg1, _arg2, _arg3)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// IsInhibited determines if any of the actions specified in @flags are
// currently inhibited (possibly by another application).
//
// Note that this information may not be available (for example when the
// application is running in a sandbox).
func (a application) IsInhibited(flags ApplicationInhibitFlags) bool {
	var _arg0 *C.GtkApplication            // out
	var _arg1 C.GtkApplicationInhibitFlags // out
	var _cret C.gboolean                   // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (C.GtkApplicationInhibitFlags)(flags)

	_cret = C.gtk_application_is_inhibited(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ListActionDescriptions lists the detailed action names which have associated
// accelerators. See gtk_application_set_accels_for_action().
func (a application) ListActionDescriptions() []string {
	var _arg0 *C.GtkApplication // out
	var _cret **C.gchar

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_application_list_action_descriptions(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// PrefersAppMenu determines if the desktop environment in which the application
// is running would prefer an application menu be shown.
//
// If this function returns true then the application should call
// gtk_application_set_app_menu() with the contents of an application menu,
// which will be shown by the desktop environment. If it returns false then you
// should consider using an alternate approach, such as a menubar.
//
// The value returned by this function is purely advisory and you are free to
// ignore it. If you call gtk_application_set_app_menu() even if the desktop
// environment doesn't support app menus, then a fallback will be provided.
//
// Applications are similarly free not to set an app menu even if the desktop
// environment wants to show one. In that case, a fallback will also be created
// by the desktop environment (GNOME, for example, uses a menu with only a
// "Quit" item in it).
//
// The value returned by this function never changes. Once it returns a
// particular value, it is guaranteed to always return the same value.
//
// You may only call this function after the application has been registered and
// after the base startup handler has run. You're most likely to want to use
// this from your own startup handler. It may also make sense to consult this
// function while constructing UI (in activate, open or an action activation
// handler) in order to determine if you should show a gear menu or not.
//
// This function will return false on Mac OS and a default app menu will be
// created automatically with the "usual" contents of that menu typical to most
// Mac OS applications. If you call gtk_application_set_app_menu() anyway, then
// this menu will be replaced with your own.
func (a application) PrefersAppMenu() bool {
	var _arg0 *C.GtkApplication // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_application_prefers_app_menu(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveAccelerator removes an accelerator that has been previously added with
// gtk_application_add_accelerator().
func (a application) RemoveAccelerator(actionName string, parameter *glib.Variant) {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.gchar          // out
	var _arg2 *C.GVariant       // out

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(unsafe.Pointer(parameter.Native()))

	C.gtk_application_remove_accelerator(_arg0, _arg1, _arg2)
}

// RemoveWindow: remove a window from @application.
//
// If @window belongs to @application then this call is equivalent to setting
// the Window:application property of @window to nil.
//
// The application may stop running as a result of a call to this function.
func (a application) RemoveWindow(window Window) {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.GtkWindow      // out

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_application_remove_window(_arg0, _arg1)
}

// SetAccelsForAction sets zero or more keyboard accelerators that will trigger
// the given action. The first item in @accels will be the primary accelerator,
// which may be displayed in the UI.
//
// To remove all accelerators for an action, use an empty, zero-terminated array
// for @accels.
//
// For the @detailed_action_name, see g_action_parse_detailed_name() and
// g_action_print_detailed_name().
func (a application) SetAccelsForAction(detailedActionName string, accels []string) {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.gchar          // out
	var _arg2 **C.gchar

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(detailedActionName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (**C.gchar)(C.malloc(C.ulong(len(accels)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice(_arg2, len(accels))
		for i := range accels {
			out[i] = (*C.gchar)(C.CString(accels[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.gtk_application_set_accels_for_action(_arg0, _arg1, _arg2)
}

// SetAppMenu sets or unsets the application menu for @application.
//
// This can only be done in the primary instance of the application, after it
// has been registered. #GApplication::startup is a good place to call this.
//
// The application menu is a single menu containing items that typically impact
// the application as a whole, rather than acting on a specific window or
// document. For example, you would expect to see “Preferences” or “Quit” in an
// application menu, but not “Save” or “Print”.
//
// If supported, the application menu will be rendered by the desktop
// environment.
//
// Use the base Map interface to add actions, to respond to the user selecting
// these menu items.
func (a application) SetAppMenu(appMenu gio.MenuModel) {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.GMenuModel     // out

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GMenuModel)(unsafe.Pointer(appMenu.Native()))

	C.gtk_application_set_app_menu(_arg0, _arg1)
}

// SetMenubar sets or unsets the menubar for windows of @application.
//
// This is a menubar in the traditional sense.
//
// This can only be done in the primary instance of the application, after it
// has been registered. #GApplication::startup is a good place to call this.
//
// Depending on the desktop environment, this may appear at the top of each
// window, or at the top of the screen. In some environments, if both the
// application menu and the menubar are set, the application menu will be
// presented as if it were the first item of the menubar. Other environments
// treat the two as completely separate — for example, the application menu may
// be rendered by the desktop shell while the menubar (if set) remains in each
// individual window.
//
// Use the base Map interface to add actions, to respond to the user selecting
// these menu items.
func (a application) SetMenubar(menubar gio.MenuModel) {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.GMenuModel     // out

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GMenuModel)(unsafe.Pointer(menubar.Native()))

	C.gtk_application_set_menubar(_arg0, _arg1)
}

// Uninhibit removes an inhibitor that has been established with
// gtk_application_inhibit(). Inhibitors are also cleared when the application
// exits.
func (a application) Uninhibit(cookie uint) {
	var _arg0 *C.GtkApplication // out
	var _arg1 C.guint           // out

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (C.guint)(cookie)

	C.gtk_application_uninhibit(_arg0, _arg1)
}

// ApplicationWindow is a Window subclass that offers some extra functionality
// for better integration with Application features. Notably, it can handle both
// the application menu as well as the menubar. See
// gtk_application_set_app_menu() and gtk_application_set_menubar().
//
// This class implements the Group and Map interfaces, to let you add
// window-specific actions that will be exported by the associated Application,
// together with its application-wide actions. Window-specific actions are
// prefixed with the “win.” prefix and application-wide actions are prefixed
// with the “app.” prefix. Actions must be addressed with the prefixed name when
// referring to them from a Model.
//
// Note that widgets that are placed inside a ApplicationWindow can also
// activate these actions, if they implement the Actionable interface.
//
// As with Application, the GDK lock will be acquired when processing actions
// arriving from other processes and should therefore be held when activating
// actions locally (if GDK threads are enabled).
//
// The settings Settings:gtk-shell-shows-app-menu and
// Settings:gtk-shell-shows-menubar tell GTK+ whether the desktop environment is
// showing the application menu and menubar models outside the application as
// part of the desktop shell. For instance, on OS X, both menus will be
// displayed remotely; on Windows neither will be. gnome-shell (starting with
// version 3.4) will display the application menu, but not the menubar.
//
// If the desktop environment does not display the menubar, then
// ApplicationWindow will automatically show a MenuBar for it. This behaviour
// can be overridden with the ApplicationWindow:show-menubar property. If the
// desktop environment does not display the application menu, then it will
// automatically be included in the menubar or in the windows client-side
// decorations.
//
// A GtkApplicationWindow with a menubar
//
//    GtkApplication *app = gtk_application_new ("org.gtk.test", 0);
//
//    GtkBuilder *builder = gtk_builder_new_from_string (
//        "<interface>"
//        "  <menu id='menubar'>"
//        "    <submenu label='_Edit'>"
//        "      <item label='_Copy' action='win.copy'/>"
//        "      <item label='_Paste' action='win.paste'/>"
//        "    </submenu>"
//        "  </menu>"
//        "</interface>",
//        -1);
//
//    GMenuModel *menubar = G_MENU_MODEL (gtk_builder_get_object (builder,
//                                                                "menubar"));
//    gtk_application_set_menubar (GTK_APPLICATION (app), menubar);
//    g_object_unref (builder);
//
//    // ...
//
//    GtkWidget *window = gtk_application_window_new (app);
//
//
// Handling fallback yourself
//
// A simple example (https://git.gnome.org/browse/gtk+/tree/examples/sunny.c)
//
// The XML format understood by Builder for Model consists of a toplevel
// `<menu>` element, which contains one or more `<item>` elements. Each `<item>`
// element contains `<attribute>` and `<link>` elements with a mandatory name
// attribute. `<link>` elements have the same content model as `<menu>`. Instead
// of `<link name="submenu>` or `<link name="section">`, you can use `<submenu>`
// or `<section>` elements.
//
// Attribute values can be translated using gettext, like other Builder content.
// `<attribute>` elements can be marked for translation with a
// `translatable="yes"` attribute. It is also possible to specify message
// context and translator comments, using the context and comments attributes.
// To make use of this, the Builder must have been given the gettext domain to
// use.
//
// The following attributes are used when constructing menu items: - "label": a
// user-visible string to display - "action": the prefixed name of the action to
// trigger - "target": the parameter to use when activating the action - "icon"
// and "verb-icon": names of icons that may be displayed - "submenu-action":
// name of an action that may be used to determine if a submenu can be opened -
// "hidden-when": a string used to determine when the item will be hidden.
// Possible values include "action-disabled", "action-missing", "macos-menubar".
//
// The following attributes are used when constructing sections: - "label": a
// user-visible string to use as section heading - "display-hint": a string used
// to determine special formatting for the section. Possible values include
// "horizontal-buttons". - "text-direction": a string used to determine the
// TextDirection to use when "display-hint" is set to "horizontal-buttons".
// Possible values include "rtl", "ltr", and "none".
//
// The following attributes are used when constructing submenus: - "label": a
// user-visible string to display - "icon": icon name to display
type ApplicationWindow interface {
	Window
	gio.ActionGroup
	gio.ActionMap
	Buildable

	// HelpOverlay gets the ShortcutsWindow that has been set up with a prior
	// call to gtk_application_window_set_help_overlay().
	HelpOverlay() ShortcutsWindow
	// ID returns the unique ID of the window. If the window has not yet been
	// added to a Application, returns `0`.
	ID() uint
	// ShowMenubar returns whether the window will display a menubar for the app
	// menu and menubar as needed.
	ShowMenubar() bool
	// SetHelpOverlay associates a shortcuts window with the application window,
	// and sets up an action with the name win.show-help-overlay to present it.
	//
	// @window takes resposibility for destroying @help_overlay.
	SetHelpOverlay(helpOverlay ShortcutsWindow)
	// SetShowMenubar sets whether the window will display a menubar for the app
	// menu and menubar as needed.
	SetShowMenubar(showMenubar bool)
}

// applicationWindow implements the ApplicationWindow class.
type applicationWindow struct {
	Window
	gio.ActionGroup
	gio.ActionMap
	Buildable
}

var _ ApplicationWindow = (*applicationWindow)(nil)

// WrapApplicationWindow wraps a GObject to the right type. It is
// primarily used internally.
func WrapApplicationWindow(obj *externglib.Object) ApplicationWindow {
	return applicationWindow{
		Window:      WrapWindow(obj),
		ActionGroup: gio.WrapActionGroup(obj),
		ActionMap:   gio.WrapActionMap(obj),
		Buildable:   WrapBuildable(obj),
	}
}

func marshalApplicationWindow(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapApplicationWindow(obj), nil
}

// NewApplicationWindow creates a new ApplicationWindow.
func NewApplicationWindow(application Application) ApplicationWindow {
	var _arg1 *C.GtkApplication // out
	var _cret *C.GtkWidget      // in

	_arg1 = (*C.GtkApplication)(unsafe.Pointer(application.Native()))

	_cret = C.gtk_application_window_new(_arg1)

	var _applicationWindow ApplicationWindow // out

	_applicationWindow = WrapApplicationWindow(externglib.Take(unsafe.Pointer(_cret)))

	return _applicationWindow
}

// HelpOverlay gets the ShortcutsWindow that has been set up with a prior call
// to gtk_application_window_set_help_overlay().
func (w applicationWindow) HelpOverlay() ShortcutsWindow {
	var _arg0 *C.GtkApplicationWindow // out
	var _cret *C.GtkShortcutsWindow   // in

	_arg0 = (*C.GtkApplicationWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_application_window_get_help_overlay(_arg0)

	var _shortcutsWindow ShortcutsWindow // out

	_shortcutsWindow = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ShortcutsWindow)

	return _shortcutsWindow
}

// ID returns the unique ID of the window. If the window has not yet been added
// to a Application, returns `0`.
func (w applicationWindow) ID() uint {
	var _arg0 *C.GtkApplicationWindow // out
	var _cret C.guint                 // in

	_arg0 = (*C.GtkApplicationWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_application_window_get_id(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// ShowMenubar returns whether the window will display a menubar for the app
// menu and menubar as needed.
func (w applicationWindow) ShowMenubar() bool {
	var _arg0 *C.GtkApplicationWindow // out
	var _cret C.gboolean              // in

	_arg0 = (*C.GtkApplicationWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_application_window_get_show_menubar(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetHelpOverlay associates a shortcuts window with the application window, and
// sets up an action with the name win.show-help-overlay to present it.
//
// @window takes resposibility for destroying @help_overlay.
func (w applicationWindow) SetHelpOverlay(helpOverlay ShortcutsWindow) {
	var _arg0 *C.GtkApplicationWindow // out
	var _arg1 *C.GtkShortcutsWindow   // out

	_arg0 = (*C.GtkApplicationWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkShortcutsWindow)(unsafe.Pointer(helpOverlay.Native()))

	C.gtk_application_window_set_help_overlay(_arg0, _arg1)
}

// SetShowMenubar sets whether the window will display a menubar for the app
// menu and menubar as needed.
func (w applicationWindow) SetShowMenubar(showMenubar bool) {
	var _arg0 *C.GtkApplicationWindow // out
	var _arg1 C.gboolean              // out

	_arg0 = (*C.GtkApplicationWindow)(unsafe.Pointer(w.Native()))
	if showMenubar {
		_arg1 = C.TRUE
	}

	C.gtk_application_window_set_show_menubar(_arg0, _arg1)
}

// Arrow: gtkArrow should be used to draw simple arrows that need to point in
// one of the four cardinal directions (up, down, left, or right). The style of
// the arrow can be one of shadow in, shadow out, etched in, or etched out. Note
// that these directions and style types may be amended in versions of GTK+ to
// come.
//
// GtkArrow will fill any space alloted to it, but since it is inherited from
// Misc, it can be padded and/or aligned, to fill exactly the space the
// programmer desires.
//
// Arrows are created with a call to gtk_arrow_new(). The direction or style of
// an arrow can be changed after creation by using gtk_arrow_set().
//
// GtkArrow has been deprecated; you can simply use a Image with a suitable icon
// name, such as “pan-down-symbolic“. When replacing GtkArrow by an image, pay
// attention to the fact that GtkArrow is doing automatic flipping between
// K_ARROW_LEFT and K_ARROW_RIGHT, depending on the text direction. To get the
// same effect with an image, use the icon names “pan-start-symbolic“ and
// “pan-end-symbolic“, which react to the text direction.
type Arrow interface {
	Misc
	Buildable

	// Set sets the direction and style of the Arrow, @arrow.
	Set(arrowType ArrowType, shadowType ShadowType)
}

// arrow implements the Arrow class.
type arrow struct {
	Misc
	Buildable
}

var _ Arrow = (*arrow)(nil)

// WrapArrow wraps a GObject to the right type. It is
// primarily used internally.
func WrapArrow(obj *externglib.Object) Arrow {
	return arrow{
		Misc:      WrapMisc(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalArrow(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapArrow(obj), nil
}

// NewArrow creates a new Arrow widget.
func NewArrow(arrowType ArrowType, shadowType ShadowType) Arrow {
	var _arg1 C.GtkArrowType  // out
	var _arg2 C.GtkShadowType // out
	var _cret *C.GtkWidget    // in

	_arg1 = (C.GtkArrowType)(arrowType)
	_arg2 = (C.GtkShadowType)(shadowType)

	_cret = C.gtk_arrow_new(_arg1, _arg2)

	var _arrow Arrow // out

	_arrow = WrapArrow(externglib.Take(unsafe.Pointer(_cret)))

	return _arrow
}

// Set sets the direction and style of the Arrow, @arrow.
func (a arrow) Set(arrowType ArrowType, shadowType ShadowType) {
	var _arg0 *C.GtkArrow     // out
	var _arg1 C.GtkArrowType  // out
	var _arg2 C.GtkShadowType // out

	_arg0 = (*C.GtkArrow)(unsafe.Pointer(a.Native()))
	_arg1 = (C.GtkArrowType)(arrowType)
	_arg2 = (C.GtkShadowType)(shadowType)

	C.gtk_arrow_set(_arg0, _arg1, _arg2)
}

type ArrowAccessible interface {
	WidgetAccessible
}

// arrowAccessible implements the ArrowAccessible class.
type arrowAccessible struct {
	WidgetAccessible
}

var _ ArrowAccessible = (*arrowAccessible)(nil)

// WrapArrowAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapArrowAccessible(obj *externglib.Object) ArrowAccessible {
	return arrowAccessible{
		WidgetAccessible: WrapWidgetAccessible(obj),
	}
}

func marshalArrowAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapArrowAccessible(obj), nil
}

// AspectFrame: the AspectFrame is useful when you want pack a widget so that it
// can resize but always retains the same aspect ratio. For instance, one might
// be drawing a small preview of a larger image. AspectFrame derives from Frame,
// so it can draw a label and a frame around the child. The frame will be
// “shrink-wrapped” to the size of the child.
//
//
// CSS nodes
//
// GtkAspectFrame uses a CSS node with name frame.
type AspectFrame interface {
	Frame
	Buildable

	// Set: set parameters for an existing AspectFrame.
	Set(xalign float32, yalign float32, ratio float32, obeyChild bool)
}

// aspectFrame implements the AspectFrame class.
type aspectFrame struct {
	Frame
	Buildable
}

var _ AspectFrame = (*aspectFrame)(nil)

// WrapAspectFrame wraps a GObject to the right type. It is
// primarily used internally.
func WrapAspectFrame(obj *externglib.Object) AspectFrame {
	return aspectFrame{
		Frame:     WrapFrame(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalAspectFrame(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAspectFrame(obj), nil
}

// NewAspectFrame: create a new AspectFrame.
func NewAspectFrame(label string, xalign float32, yalign float32, ratio float32, obeyChild bool) AspectFrame {
	var _arg1 *C.gchar     // out
	var _arg2 C.gfloat     // out
	var _arg3 C.gfloat     // out
	var _arg4 C.gfloat     // out
	var _arg5 C.gboolean   // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gfloat)(xalign)
	_arg3 = (C.gfloat)(yalign)
	_arg4 = (C.gfloat)(ratio)
	if obeyChild {
		_arg5 = C.TRUE
	}

	_cret = C.gtk_aspect_frame_new(_arg1, _arg2, _arg3, _arg4, _arg5)

	var _aspectFrame AspectFrame // out

	_aspectFrame = WrapAspectFrame(externglib.Take(unsafe.Pointer(_cret)))

	return _aspectFrame
}

// Set: set parameters for an existing AspectFrame.
func (a aspectFrame) Set(xalign float32, yalign float32, ratio float32, obeyChild bool) {
	var _arg0 *C.GtkAspectFrame // out
	var _arg1 C.gfloat          // out
	var _arg2 C.gfloat          // out
	var _arg3 C.gfloat          // out
	var _arg4 C.gboolean        // out

	_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(a.Native()))
	_arg1 = (C.gfloat)(xalign)
	_arg2 = (C.gfloat)(yalign)
	_arg3 = (C.gfloat)(ratio)
	if obeyChild {
		_arg4 = C.TRUE
	}

	C.gtk_aspect_frame_set(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// Assistant: a Assistant is a widget used to represent a generally complex
// operation splitted in several steps, guiding the user through its pages and
// controlling the page flow to collect the necessary data.
//
// The design of GtkAssistant is that it controls what buttons to show and to
// make sensitive, based on what it knows about the page sequence and the
// [type][GtkAssistantPageType] of each page, in addition to state information
// like the page [completion][gtk-assistant-set-page-complete] and
// [committed][gtk-assistant-commit] status.
//
// If you have a case that doesn’t quite fit in Assistants way of handling
// buttons, you can use the K_ASSISTANT_PAGE_CUSTOM page type and handle buttons
// yourself.
//
//
// GtkAssistant as GtkBuildable
//
// The GtkAssistant implementation of the Buildable interface exposes the
// @action_area as internal children with the name “action_area”.
//
// To add pages to an assistant in Builder, simply add it as a child to the
// GtkAssistant object, and set its child properties as necessary.
//
//
// CSS nodes
//
// GtkAssistant has a single CSS node with the name assistant.
type Assistant interface {
	Window
	Buildable

	// AddActionWidget adds a widget to the action area of a Assistant.
	AddActionWidget(child Widget)
	// AppendPage appends a page to the @assistant.
	AppendPage(page Widget) int
	// Commit erases the visited page history so the back button is not shown on
	// the current page, and removes the cancel button from subsequent pages.
	//
	// Use this when the information provided up to the current page is
	// hereafter deemed permanent and cannot be modified or undone. For example,
	// showing a progress page to track a long-running, unreversible operation
	// after the user has clicked apply on a confirmation page.
	Commit()
	// CurrentPage returns the page number of the current page.
	CurrentPage() int
	// NPages returns the number of pages in the @assistant
	NPages() int
	// NthPage returns the child widget contained in page number @page_num.
	NthPage(pageNum int) Widget
	// PageComplete gets whether @page is complete.
	PageComplete(page Widget) bool
	// PageHasPadding gets whether page has padding.
	PageHasPadding(page Widget) bool
	// PageHeaderImage gets the header image for @page.
	PageHeaderImage(page Widget) gdkpixbuf.Pixbuf
	// PageSideImage gets the side image for @page.
	PageSideImage(page Widget) gdkpixbuf.Pixbuf
	// PageTitle gets the title for @page.
	PageTitle(page Widget) string
	// PageType gets the page type of @page.
	PageType(page Widget) AssistantPageType
	// InsertPage inserts a page in the @assistant at a given position.
	InsertPage(page Widget, position int) int
	// NextPage: navigate to the next page.
	//
	// It is a programming error to call this function when there is no next
	// page.
	//
	// This function is for use when creating pages of the
	// K_ASSISTANT_PAGE_CUSTOM type.
	NextPage()
	// PrependPage prepends a page to the @assistant.
	PrependPage(page Widget) int
	// PreviousPage: navigate to the previous visited page.
	//
	// It is a programming error to call this function when no previous page is
	// available.
	//
	// This function is for use when creating pages of the
	// K_ASSISTANT_PAGE_CUSTOM type.
	PreviousPage()
	// RemoveActionWidget removes a widget from the action area of a Assistant.
	RemoveActionWidget(child Widget)
	// RemovePage removes the @page_num’s page from @assistant.
	RemovePage(pageNum int)
	// SetCurrentPage switches the page to @page_num.
	//
	// Note that this will only be necessary in custom buttons, as the
	// @assistant flow can be set with gtk_assistant_set_forward_page_func().
	SetCurrentPage(pageNum int)
	// SetPageComplete sets whether @page contents are complete.
	//
	// This will make @assistant update the buttons state to be able to continue
	// the task.
	SetPageComplete(page Widget, complete bool)
	// SetPageHasPadding sets whether the assistant is adding padding around the
	// page.
	SetPageHasPadding(page Widget, hasPadding bool)
	// SetPageHeaderImage sets a header image for @page.
	SetPageHeaderImage(page Widget, pixbuf gdkpixbuf.Pixbuf)
	// SetPageSideImage sets a side image for @page.
	//
	// This image used to be displayed in the side area of the assistant when
	// @page is the current page.
	SetPageSideImage(page Widget, pixbuf gdkpixbuf.Pixbuf)
	// SetPageTitle sets a title for @page.
	//
	// The title is displayed in the header area of the assistant when @page is
	// the current page.
	SetPageTitle(page Widget, title string)
	// SetPageType sets the page type for @page.
	//
	// The page type determines the page behavior in the @assistant.
	SetPageType(page Widget, typ AssistantPageType)
	// UpdateButtonsState forces @assistant to recompute the buttons state.
	//
	// GTK+ automatically takes care of this in most situations, e.g. when the
	// user goes to a different page, or when the visibility or completeness of
	// a page changes.
	//
	// One situation where it can be necessary to call this function is when
	// changing a value on the current page affects the future page flow of the
	// assistant.
	UpdateButtonsState()
}

// assistant implements the Assistant class.
type assistant struct {
	Window
	Buildable
}

var _ Assistant = (*assistant)(nil)

// WrapAssistant wraps a GObject to the right type. It is
// primarily used internally.
func WrapAssistant(obj *externglib.Object) Assistant {
	return assistant{
		Window:    WrapWindow(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalAssistant(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAssistant(obj), nil
}

// NewAssistant creates a new Assistant.
func NewAssistant() Assistant {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_assistant_new()

	var _assistant Assistant // out

	_assistant = WrapAssistant(externglib.Take(unsafe.Pointer(_cret)))

	return _assistant
}

// AddActionWidget adds a widget to the action area of a Assistant.
func (a assistant) AddActionWidget(child Widget) {
	var _arg0 *C.GtkAssistant // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_assistant_add_action_widget(_arg0, _arg1)
}

// AppendPage appends a page to the @assistant.
func (a assistant) AppendPage(page Widget) int {
	var _arg0 *C.GtkAssistant // out
	var _arg1 *C.GtkWidget    // out
	var _cret C.gint          // in

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))

	_cret = C.gtk_assistant_append_page(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Commit erases the visited page history so the back button is not shown on the
// current page, and removes the cancel button from subsequent pages.
//
// Use this when the information provided up to the current page is hereafter
// deemed permanent and cannot be modified or undone. For example, showing a
// progress page to track a long-running, unreversible operation after the user
// has clicked apply on a confirmation page.
func (a assistant) Commit() {
	var _arg0 *C.GtkAssistant // out

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

	C.gtk_assistant_commit(_arg0)
}

// CurrentPage returns the page number of the current page.
func (a assistant) CurrentPage() int {
	var _arg0 *C.GtkAssistant // out
	var _cret C.gint          // in

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_assistant_get_current_page(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// NPages returns the number of pages in the @assistant
func (a assistant) NPages() int {
	var _arg0 *C.GtkAssistant // out
	var _cret C.gint          // in

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_assistant_get_n_pages(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// NthPage returns the child widget contained in page number @page_num.
func (a assistant) NthPage(pageNum int) Widget {
	var _arg0 *C.GtkAssistant // out
	var _arg1 C.gint          // out
	var _cret *C.GtkWidget    // in

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (C.gint)(pageNum)

	_cret = C.gtk_assistant_get_nth_page(_arg0, _arg1)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// PageComplete gets whether @page is complete.
func (a assistant) PageComplete(page Widget) bool {
	var _arg0 *C.GtkAssistant // out
	var _arg1 *C.GtkWidget    // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))

	_cret = C.gtk_assistant_get_page_complete(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PageHasPadding gets whether page has padding.
func (a assistant) PageHasPadding(page Widget) bool {
	var _arg0 *C.GtkAssistant // out
	var _arg1 *C.GtkWidget    // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))

	_cret = C.gtk_assistant_get_page_has_padding(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PageHeaderImage gets the header image for @page.
func (a assistant) PageHeaderImage(page Widget) gdkpixbuf.Pixbuf {
	var _arg0 *C.GtkAssistant // out
	var _arg1 *C.GtkWidget    // out
	var _cret *C.GdkPixbuf    // in

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))

	_cret = C.gtk_assistant_get_page_header_image(_arg0, _arg1)

	var _pixbuf gdkpixbuf.Pixbuf // out

	_pixbuf = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

	return _pixbuf
}

// PageSideImage gets the side image for @page.
func (a assistant) PageSideImage(page Widget) gdkpixbuf.Pixbuf {
	var _arg0 *C.GtkAssistant // out
	var _arg1 *C.GtkWidget    // out
	var _cret *C.GdkPixbuf    // in

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))

	_cret = C.gtk_assistant_get_page_side_image(_arg0, _arg1)

	var _pixbuf gdkpixbuf.Pixbuf // out

	_pixbuf = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

	return _pixbuf
}

// PageTitle gets the title for @page.
func (a assistant) PageTitle(page Widget) string {
	var _arg0 *C.GtkAssistant // out
	var _arg1 *C.GtkWidget    // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))

	_cret = C.gtk_assistant_get_page_title(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// PageType gets the page type of @page.
func (a assistant) PageType(page Widget) AssistantPageType {
	var _arg0 *C.GtkAssistant        // out
	var _arg1 *C.GtkWidget           // out
	var _cret C.GtkAssistantPageType // in

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))

	_cret = C.gtk_assistant_get_page_type(_arg0, _arg1)

	var _assistantPageType AssistantPageType // out

	_assistantPageType = AssistantPageType(_cret)

	return _assistantPageType
}

// InsertPage inserts a page in the @assistant at a given position.
func (a assistant) InsertPage(page Widget, position int) int {
	var _arg0 *C.GtkAssistant // out
	var _arg1 *C.GtkWidget    // out
	var _arg2 C.gint          // out
	var _cret C.gint          // in

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))
	_arg2 = (C.gint)(position)

	_cret = C.gtk_assistant_insert_page(_arg0, _arg1, _arg2)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// NextPage: navigate to the next page.
//
// It is a programming error to call this function when there is no next page.
//
// This function is for use when creating pages of the K_ASSISTANT_PAGE_CUSTOM
// type.
func (a assistant) NextPage() {
	var _arg0 *C.GtkAssistant // out

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

	C.gtk_assistant_next_page(_arg0)
}

// PrependPage prepends a page to the @assistant.
func (a assistant) PrependPage(page Widget) int {
	var _arg0 *C.GtkAssistant // out
	var _arg1 *C.GtkWidget    // out
	var _cret C.gint          // in

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))

	_cret = C.gtk_assistant_prepend_page(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// PreviousPage: navigate to the previous visited page.
//
// It is a programming error to call this function when no previous page is
// available.
//
// This function is for use when creating pages of the K_ASSISTANT_PAGE_CUSTOM
// type.
func (a assistant) PreviousPage() {
	var _arg0 *C.GtkAssistant // out

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

	C.gtk_assistant_previous_page(_arg0)
}

// RemoveActionWidget removes a widget from the action area of a Assistant.
func (a assistant) RemoveActionWidget(child Widget) {
	var _arg0 *C.GtkAssistant // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_assistant_remove_action_widget(_arg0, _arg1)
}

// RemovePage removes the @page_num’s page from @assistant.
func (a assistant) RemovePage(pageNum int) {
	var _arg0 *C.GtkAssistant // out
	var _arg1 C.gint          // out

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (C.gint)(pageNum)

	C.gtk_assistant_remove_page(_arg0, _arg1)
}

// SetCurrentPage switches the page to @page_num.
//
// Note that this will only be necessary in custom buttons, as the @assistant
// flow can be set with gtk_assistant_set_forward_page_func().
func (a assistant) SetCurrentPage(pageNum int) {
	var _arg0 *C.GtkAssistant // out
	var _arg1 C.gint          // out

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (C.gint)(pageNum)

	C.gtk_assistant_set_current_page(_arg0, _arg1)
}

// SetPageComplete sets whether @page contents are complete.
//
// This will make @assistant update the buttons state to be able to continue the
// task.
func (a assistant) SetPageComplete(page Widget, complete bool) {
	var _arg0 *C.GtkAssistant // out
	var _arg1 *C.GtkWidget    // out
	var _arg2 C.gboolean      // out

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))
	if complete {
		_arg2 = C.TRUE
	}

	C.gtk_assistant_set_page_complete(_arg0, _arg1, _arg2)
}

// SetPageHasPadding sets whether the assistant is adding padding around the
// page.
func (a assistant) SetPageHasPadding(page Widget, hasPadding bool) {
	var _arg0 *C.GtkAssistant // out
	var _arg1 *C.GtkWidget    // out
	var _arg2 C.gboolean      // out

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))
	if hasPadding {
		_arg2 = C.TRUE
	}

	C.gtk_assistant_set_page_has_padding(_arg0, _arg1, _arg2)
}

// SetPageHeaderImage sets a header image for @page.
func (a assistant) SetPageHeaderImage(page Widget, pixbuf gdkpixbuf.Pixbuf) {
	var _arg0 *C.GtkAssistant // out
	var _arg1 *C.GtkWidget    // out
	var _arg2 *C.GdkPixbuf    // out

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))
	_arg2 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	C.gtk_assistant_set_page_header_image(_arg0, _arg1, _arg2)
}

// SetPageSideImage sets a side image for @page.
//
// This image used to be displayed in the side area of the assistant when @page
// is the current page.
func (a assistant) SetPageSideImage(page Widget, pixbuf gdkpixbuf.Pixbuf) {
	var _arg0 *C.GtkAssistant // out
	var _arg1 *C.GtkWidget    // out
	var _arg2 *C.GdkPixbuf    // out

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))
	_arg2 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	C.gtk_assistant_set_page_side_image(_arg0, _arg1, _arg2)
}

// SetPageTitle sets a title for @page.
//
// The title is displayed in the header area of the assistant when @page is the
// current page.
func (a assistant) SetPageTitle(page Widget, title string) {
	var _arg0 *C.GtkAssistant // out
	var _arg1 *C.GtkWidget    // out
	var _arg2 *C.gchar        // out

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))
	_arg2 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_assistant_set_page_title(_arg0, _arg1, _arg2)
}

// SetPageType sets the page type for @page.
//
// The page type determines the page behavior in the @assistant.
func (a assistant) SetPageType(page Widget, typ AssistantPageType) {
	var _arg0 *C.GtkAssistant        // out
	var _arg1 *C.GtkWidget           // out
	var _arg2 C.GtkAssistantPageType // out

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))
	_arg2 = (C.GtkAssistantPageType)(typ)

	C.gtk_assistant_set_page_type(_arg0, _arg1, _arg2)
}

// UpdateButtonsState forces @assistant to recompute the buttons state.
//
// GTK+ automatically takes care of this in most situations, e.g. when the user
// goes to a different page, or when the visibility or completeness of a page
// changes.
//
// One situation where it can be necessary to call this function is when
// changing a value on the current page affects the future page flow of the
// assistant.
func (a assistant) UpdateButtonsState() {
	var _arg0 *C.GtkAssistant // out

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

	C.gtk_assistant_update_buttons_state(_arg0)
}

// Bin: the Bin widget is a container with just one child. It is not very useful
// itself, but it is useful for deriving subclasses, since it provides common
// code needed for handling a single child widget.
//
// Many GTK+ widgets are subclasses of Bin, including Window, Button, Frame,
// HandleBox or ScrolledWindow.
type Bin interface {
	Container
	Buildable

	// Child gets the child of the Bin, or nil if the bin contains no child
	// widget. The returned widget does not have a reference added, so you do
	// not need to unref it.
	Child() Widget
}

// bin implements the Bin class.
type bin struct {
	Container
	Buildable
}

var _ Bin = (*bin)(nil)

// WrapBin wraps a GObject to the right type. It is
// primarily used internally.
func WrapBin(obj *externglib.Object) Bin {
	return bin{
		Container: WrapContainer(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalBin(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBin(obj), nil
}

// Child gets the child of the Bin, or nil if the bin contains no child widget.
// The returned widget does not have a reference added, so you do not need to
// unref it.
func (b bin) Child() Widget {
	var _arg0 *C.GtkBin    // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkBin)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_bin_get_child(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

type BooleanCellAccessible interface {
	RendererCellAccessible
}

// booleanCellAccessible implements the BooleanCellAccessible class.
type booleanCellAccessible struct {
	RendererCellAccessible
}

var _ BooleanCellAccessible = (*booleanCellAccessible)(nil)

// WrapBooleanCellAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapBooleanCellAccessible(obj *externglib.Object) BooleanCellAccessible {
	return booleanCellAccessible{
		RendererCellAccessible: WrapRendererCellAccessible(obj),
	}
}

func marshalBooleanCellAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBooleanCellAccessible(obj), nil
}

// Box: the GtkBox widget arranges child widgets into a single row or column,
// depending upon the value of its Orientable:orientation property. Within the
// other dimension, all children are allocated the same size. Of course, the
// Widget:halign and Widget:valign properties can be used on the children to
// influence their allocation.
//
// GtkBox uses a notion of packing. Packing refers to adding widgets with
// reference to a particular position in a Container. For a GtkBox, there are
// two reference positions: the start and the end of the box. For a vertical
// Box, the start is defined as the top of the box and the end is defined as the
// bottom. For a horizontal Box the start is defined as the left side and the
// end is defined as the right side.
//
// Use repeated calls to gtk_box_pack_start() to pack widgets into a GtkBox from
// start to end. Use gtk_box_pack_end() to add widgets from end to start. You
// may intersperse these calls and add widgets from both ends of the same
// GtkBox.
//
// Because GtkBox is a Container, you may also use gtk_container_add() to insert
// widgets into the box, and they will be packed with the default values for
// expand and fill child properties. Use gtk_container_remove() to remove
// widgets from the GtkBox.
//
// Use gtk_box_set_homogeneous() to specify whether or not all children of the
// GtkBox are forced to get the same amount of space.
//
// Use gtk_box_set_spacing() to determine how much space will be minimally
// placed between all children in the GtkBox. Note that spacing is added between
// the children, while padding added by gtk_box_pack_start() or
// gtk_box_pack_end() is added on either side of the widget it belongs to.
//
// Use gtk_box_reorder_child() to move a GtkBox child to a different place in
// the box.
//
// Use gtk_box_set_child_packing() to reset the expand, fill and padding child
// properties. Use gtk_box_query_child_packing() to query these fields.
//
//
// CSS nodes
//
// GtkBox uses a single CSS node with name box.
//
// In horizontal orientation, the nodes of the children are always arranged from
// left to right. So :first-child will always select the leftmost child,
// regardless of text direction.
type Box interface {
	Container
	Buildable
	Orientable

	// BaselinePosition gets the value set by gtk_box_set_baseline_position().
	BaselinePosition() BaselinePosition
	// CenterWidget retrieves the center widget of the box.
	CenterWidget() Widget
	// Homogeneous returns whether the box is homogeneous (all children are the
	// same size). See gtk_box_set_homogeneous().
	Homogeneous() bool
	// Spacing gets the value set by gtk_box_set_spacing().
	Spacing() int
	// PackEnd adds @child to @box, packed with reference to the end of @box.
	// The @child is packed after (away from end of) any other child packed with
	// reference to the end of @box.
	PackEnd(child Widget, expand bool, fill bool, padding uint)
	// PackStart adds @child to @box, packed with reference to the start of
	// @box. The @child is packed after any other child packed with reference to
	// the start of @box.
	PackStart(child Widget, expand bool, fill bool, padding uint)
	// QueryChildPacking obtains information about how @child is packed into
	// @box.
	QueryChildPacking(child Widget) (expand bool, fill bool, padding uint, packType PackType)
	// ReorderChild moves @child to a new @position in the list of @box
	// children. The list contains widgets packed K_PACK_START as well as
	// widgets packed K_PACK_END, in the order that these widgets were added to
	// @box.
	//
	// A widget’s position in the @box children list determines where the widget
	// is packed into @box. A child widget at some position in the list will be
	// packed just after all other widgets of the same packing type that appear
	// earlier in the list.
	ReorderChild(child Widget, position int)
	// SetBaselinePosition sets the baseline position of a box. This affects
	// only horizontal boxes with at least one baseline aligned child. If there
	// is more vertical space available than requested, and the baseline is not
	// allocated by the parent then @position is used to allocate the baseline
	// wrt the extra space available.
	SetBaselinePosition(position BaselinePosition)
	// SetCenterWidget sets a center widget; that is a child widget that will be
	// centered with respect to the full width of the box, even if the children
	// at either side take up different amounts of space.
	SetCenterWidget(widget Widget)
	// SetChildPacking sets the way @child is packed into @box.
	SetChildPacking(child Widget, expand bool, fill bool, padding uint, packType PackType)
	// SetHomogeneous sets the Box:homogeneous property of @box, controlling
	// whether or not all children of @box are given equal space in the box.
	SetHomogeneous(homogeneous bool)
	// SetSpacing sets the Box:spacing property of @box, which is the number of
	// pixels to place between children of @box.
	SetSpacing(spacing int)
}

// box implements the Box class.
type box struct {
	Container
	Buildable
	Orientable
}

var _ Box = (*box)(nil)

// WrapBox wraps a GObject to the right type. It is
// primarily used internally.
func WrapBox(obj *externglib.Object) Box {
	return box{
		Container:  WrapContainer(obj),
		Buildable:  WrapBuildable(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalBox(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBox(obj), nil
}

// NewBox creates a new Box.
func NewBox(orientation Orientation, spacing int) Box {
	var _arg1 C.GtkOrientation // out
	var _arg2 C.gint           // out
	var _cret *C.GtkWidget     // in

	_arg1 = (C.GtkOrientation)(orientation)
	_arg2 = (C.gint)(spacing)

	_cret = C.gtk_box_new(_arg1, _arg2)

	var _box Box // out

	_box = WrapBox(externglib.Take(unsafe.Pointer(_cret)))

	return _box
}

// BaselinePosition gets the value set by gtk_box_set_baseline_position().
func (b box) BaselinePosition() BaselinePosition {
	var _arg0 *C.GtkBox             // out
	var _cret C.GtkBaselinePosition // in

	_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_box_get_baseline_position(_arg0)

	var _baselinePosition BaselinePosition // out

	_baselinePosition = BaselinePosition(_cret)

	return _baselinePosition
}

// CenterWidget retrieves the center widget of the box.
func (b box) CenterWidget() Widget {
	var _arg0 *C.GtkBox    // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_box_get_center_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// Homogeneous returns whether the box is homogeneous (all children are the same
// size). See gtk_box_set_homogeneous().
func (b box) Homogeneous() bool {
	var _arg0 *C.GtkBox  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_box_get_homogeneous(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Spacing gets the value set by gtk_box_set_spacing().
func (b box) Spacing() int {
	var _arg0 *C.GtkBox // out
	var _cret C.gint    // in

	_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_box_get_spacing(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// PackEnd adds @child to @box, packed with reference to the end of @box. The
// @child is packed after (away from end of) any other child packed with
// reference to the end of @box.
func (b box) PackEnd(child Widget, expand bool, fill bool, padding uint) {
	var _arg0 *C.GtkBox    // out
	var _arg1 *C.GtkWidget // out
	var _arg2 C.gboolean   // out
	var _arg3 C.gboolean   // out
	var _arg4 C.guint      // out

	_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	if expand {
		_arg2 = C.TRUE
	}
	if fill {
		_arg3 = C.TRUE
	}
	_arg4 = (C.guint)(padding)

	C.gtk_box_pack_end(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// PackStart adds @child to @box, packed with reference to the start of @box.
// The @child is packed after any other child packed with reference to the start
// of @box.
func (b box) PackStart(child Widget, expand bool, fill bool, padding uint) {
	var _arg0 *C.GtkBox    // out
	var _arg1 *C.GtkWidget // out
	var _arg2 C.gboolean   // out
	var _arg3 C.gboolean   // out
	var _arg4 C.guint      // out

	_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	if expand {
		_arg2 = C.TRUE
	}
	if fill {
		_arg3 = C.TRUE
	}
	_arg4 = (C.guint)(padding)

	C.gtk_box_pack_start(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// QueryChildPacking obtains information about how @child is packed into @box.
func (b box) QueryChildPacking(child Widget) (expand bool, fill bool, padding uint, packType PackType) {
	var _arg0 *C.GtkBox     // out
	var _arg1 *C.GtkWidget  // out
	var _arg2 C.gboolean    // in
	var _arg3 C.gboolean    // in
	var _arg4 C.guint       // in
	var _arg5 C.GtkPackType // in

	_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_box_query_child_packing(_arg0, _arg1, &_arg2, &_arg3, &_arg4, &_arg5)

	var _expand bool       // out
	var _fill bool         // out
	var _padding uint      // out
	var _packType PackType // out

	if _arg2 {
		_expand = true
	}
	if _arg3 {
		_fill = true
	}
	_padding = (uint)(_arg4)
	_packType = PackType(_arg5)

	return _expand, _fill, _padding, _packType
}

// ReorderChild moves @child to a new @position in the list of @box children.
// The list contains widgets packed K_PACK_START as well as widgets packed
// K_PACK_END, in the order that these widgets were added to @box.
//
// A widget’s position in the @box children list determines where the widget is
// packed into @box. A child widget at some position in the list will be packed
// just after all other widgets of the same packing type that appear earlier in
// the list.
func (b box) ReorderChild(child Widget, position int) {
	var _arg0 *C.GtkBox    // out
	var _arg1 *C.GtkWidget // out
	var _arg2 C.gint       // out

	_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (C.gint)(position)

	C.gtk_box_reorder_child(_arg0, _arg1, _arg2)
}

// SetBaselinePosition sets the baseline position of a box. This affects only
// horizontal boxes with at least one baseline aligned child. If there is more
// vertical space available than requested, and the baseline is not allocated by
// the parent then @position is used to allocate the baseline wrt the extra
// space available.
func (b box) SetBaselinePosition(position BaselinePosition) {
	var _arg0 *C.GtkBox             // out
	var _arg1 C.GtkBaselinePosition // out

	_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))
	_arg1 = (C.GtkBaselinePosition)(position)

	C.gtk_box_set_baseline_position(_arg0, _arg1)
}

// SetCenterWidget sets a center widget; that is a child widget that will be
// centered with respect to the full width of the box, even if the children at
// either side take up different amounts of space.
func (b box) SetCenterWidget(widget Widget) {
	var _arg0 *C.GtkBox    // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_box_set_center_widget(_arg0, _arg1)
}

// SetChildPacking sets the way @child is packed into @box.
func (b box) SetChildPacking(child Widget, expand bool, fill bool, padding uint, packType PackType) {
	var _arg0 *C.GtkBox     // out
	var _arg1 *C.GtkWidget  // out
	var _arg2 C.gboolean    // out
	var _arg3 C.gboolean    // out
	var _arg4 C.guint       // out
	var _arg5 C.GtkPackType // out

	_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	if expand {
		_arg2 = C.TRUE
	}
	if fill {
		_arg3 = C.TRUE
	}
	_arg4 = (C.guint)(padding)
	_arg5 = (C.GtkPackType)(packType)

	C.gtk_box_set_child_packing(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}

// SetHomogeneous sets the Box:homogeneous property of @box, controlling whether
// or not all children of @box are given equal space in the box.
func (b box) SetHomogeneous(homogeneous bool) {
	var _arg0 *C.GtkBox  // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))
	if homogeneous {
		_arg1 = C.TRUE
	}

	C.gtk_box_set_homogeneous(_arg0, _arg1)
}

// SetSpacing sets the Box:spacing property of @box, which is the number of
// pixels to place between children of @box.
func (b box) SetSpacing(spacing int) {
	var _arg0 *C.GtkBox // out
	var _arg1 C.gint    // out

	_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))
	_arg1 = (C.gint)(spacing)

	C.gtk_box_set_spacing(_arg0, _arg1)
}

// Builder: a GtkBuilder is an auxiliary object that reads textual descriptions
// of a user interface and instantiates the described objects. To create a
// GtkBuilder from a user interface description, call
// gtk_builder_new_from_file(), gtk_builder_new_from_resource() or
// gtk_builder_new_from_string().
//
// In the (unusual) case that you want to add user interface descriptions from
// multiple sources to the same GtkBuilder you can call gtk_builder_new() to get
// an empty builder and populate it by (multiple) calls to
// gtk_builder_add_from_file(), gtk_builder_add_from_resource() or
// gtk_builder_add_from_string().
//
// A GtkBuilder holds a reference to all objects that it has constructed and
// drops these references when it is finalized. This finalization can cause the
// destruction of non-widget objects or widgets which are not contained in a
// toplevel window. For toplevel windows constructed by a builder, it is the
// responsibility of the user to call gtk_widget_destroy() to get rid of them
// and all the widgets they contain.
//
// The functions gtk_builder_get_object() and gtk_builder_get_objects() can be
// used to access the widgets in the interface by the names assigned to them
// inside the UI description. Toplevel windows returned by these functions will
// stay around until the user explicitly destroys them with
// gtk_widget_destroy(). Other widgets will either be part of a larger hierarchy
// constructed by the builder (in which case you should not have to worry about
// their lifecycle), or without a parent, in which case they have to be added to
// some container to make use of them. Non-widget objects need to be reffed with
// g_object_ref() to keep them beyond the lifespan of the builder.
//
// The function gtk_builder_connect_signals() and variants thereof can be used
// to connect handlers to the named signals in the description.
//
//
// GtkBuilder UI Definitions
//
// GtkBuilder parses textual descriptions of user interfaces which are specified
// in an XML format which can be roughly described by the RELAX NG schema below.
// We refer to these descriptions as “GtkBuilder UI definitions” or just “UI
// definitions” if the context is clear. Do not confuse GtkBuilder UI
// Definitions with [GtkUIManager UI Definitions][XML-UI], which are more
// limited in scope. It is common to use `.ui` as the filename extension for
// files containing GtkBuilder UI definitions.
//
// RELAX NG Compact Syntax
// (https://gitlab.gnome.org/GNOME/gtk/-/blob/gtk-3-24/gtk/gtkbuilder.rnc)
//
// The toplevel element is <interface>. It optionally takes a “domain”
// attribute, which will make the builder look for translated strings using
// dgettext() in the domain specified. This can also be done by calling
// gtk_builder_set_translation_domain() on the builder. Objects are described by
// <object> elements, which can contain <property> elements to set properties,
// <signal> elements which connect signals to handlers, and <child> elements,
// which describe child objects (most often widgets inside a container, but also
// e.g. actions in an action group, or columns in a tree model). A <child>
// element contains an <object> element which describes the child object. The
// target toolkit version(s) are described by <requires> elements, the “lib”
// attribute specifies the widget library in question (currently the only
// supported value is “gtk+”) and the “version” attribute specifies the target
// version in the form “<major>.<minor>”. The builder will error out if the
// version requirements are not met.
//
// Typically, the specific kind of object represented by an <object> element is
// specified by the “class” attribute. If the type has not been loaded yet, GTK+
// tries to find the get_type() function from the class name by applying
// heuristics. This works in most cases, but if necessary, it is possible to
// specify the name of the get_type() function explictly with the "type-func"
// attribute. As a special case, GtkBuilder allows to use an object that has
// been constructed by a UIManager in another part of the UI definition by
// specifying the id of the UIManager in the “constructor” attribute and the
// name of the object in the “id” attribute.
//
// Objects may be given a name with the “id” attribute, which allows the
// application to retrieve them from the builder with gtk_builder_get_object().
// An id is also necessary to use the object as property value in other parts of
// the UI definition. GTK+ reserves ids starting and ending with ___ (3
// underscores) for its own purposes.
//
// Setting properties of objects is pretty straightforward with the <property>
// element: the “name” attribute specifies the name of the property, and the
// content of the element specifies the value. If the “translatable” attribute
// is set to a true value, GTK+ uses gettext() (or dgettext() if the builder has
// a translation domain set) to find a translation for the value. This happens
// before the value is parsed, so it can be used for properties of any type, but
// it is probably most useful for string properties. It is also possible to
// specify a context to disambiguate short strings, and comments which may help
// the translators.
//
// GtkBuilder can parse textual representations for the most common property
// types: characters, strings, integers, floating-point numbers, booleans
// (strings like “TRUE”, “t”, “yes”, “y”, “1” are interpreted as true, strings
// like “FALSE”, “f”, “no”, “n”, “0” are interpreted as false), enumerations
// (can be specified by their name, nick or integer value), flags (can be
// specified by their name, nick, integer value, optionally combined with “|”,
// e.g. “GTK_VISIBLE|GTK_REALIZED”) and colors (in a format understood by
// gdk_rgba_parse()).
//
// GVariants can be specified in the format understood by g_variant_parse(), and
// pixbufs can be specified as a filename of an image file to load.
//
// Objects can be referred to by their name and by default refer to objects
// declared in the local xml fragment and objects exposed via
// gtk_builder_expose_object(). In general, GtkBuilder allows forward references
// to objects — declared in the local xml; an object doesn’t have to be
// constructed before it can be referred to. The exception to this rule is that
// an object has to be constructed before it can be used as the value of a
// construct-only property.
//
// It is also possible to bind a property value to another object's property
// value using the attributes "bind-source" to specify the source object of the
// binding, "bind-property" to specify the source property and optionally
// "bind-flags" to specify the binding flags. Internally builder implements this
// using GBinding objects. For more information see g_object_bind_property()
//
// Signal handlers are set up with the <signal> element. The “name” attribute
// specifies the name of the signal, and the “handler” attribute specifies the
// function to connect to the signal. By default, GTK+ tries to find the handler
// using g_module_symbol(), but this can be changed by passing a custom
// BuilderConnectFunc to gtk_builder_connect_signals_full(). The remaining
// attributes, “after”, “swapped” and “object”, have the same meaning as the
// corresponding parameters of the g_signal_connect_object() or
// g_signal_connect_data() functions. A “last_modification_time” attribute is
// also allowed, but it does not have a meaning to the builder.
//
// Sometimes it is necessary to refer to widgets which have implicitly been
// constructed by GTK+ as part of a composite widget, to set properties on them
// or to add further children (e.g. the @vbox of a Dialog). This can be achieved
// by setting the “internal-child” property of the <child> element to a true
// value. Note that GtkBuilder still requires an <object> element for the
// internal child, even if it has already been constructed.
//
// A number of widgets have different places where a child can be added (e.g.
// tabs vs. page content in notebooks). This can be reflected in a UI definition
// by specifying the “type” attribute on a <child> The possible values for the
// “type” attribute are described in the sections describing the widget-specific
// portions of UI definitions.
//
// A GtkBuilder UI Definition
//
//    <interface>
//      <object class="GtkDialog" id="dialog1">
//        <child internal-child="vbox">
//          <object class="GtkBox" id="vbox1">
//            <property name="border-width">10</property>
//            <child internal-child="action_area">
//              <object class="GtkButtonBox" id="hbuttonbox1">
//                <property name="border-width">20</property>
//                <child>
//                  <object class="GtkButton" id="ok_button">
//                    <property name="label">gtk-ok</property>
//                    <property name="use-stock">TRUE</property>
//                    <signal name="clicked" handler="ok_button_clicked"/>
//                  </object>
//                </child>
//              </object>
//            </child>
//          </object>
//        </child>
//      </object>
//    </interface>
//
// Beyond this general structure, several object classes define their own XML
// DTD fragments for filling in the ANY placeholders in the DTD above. Note that
// a custom element in a <child> element gets parsed by the custom tag handler
// of the parent object, while a custom element in an <object> element gets
// parsed by the custom tag handler of the object.
//
// These XML fragments are explained in the documentation of the respective
// objects.
//
// Additionally, since 3.10 a special <template> tag has been added to the
// format allowing one to define a widget class’s components. See the [GtkWidget
// documentation][composite-templates] for details.
type Builder interface {
	gextras.Objector

	// AddFromFile parses a file containing a [GtkBuilder UI
	// definition][BUILDER-UI] and merges it with the current contents of
	// @builder.
	//
	// Most users will probably want to use gtk_builder_new_from_file().
	//
	// If an error occurs, 0 will be returned and @error will be assigned a
	// #GError from the K_BUILDER_ERROR, MARKUP_ERROR or FILE_ERROR domain.
	//
	// It’s not really reasonable to attempt to handle failures of this call.
	// You should not use this function with untrusted files (ie: files that are
	// not part of your application). Broken Builder files can easily crash your
	// program, and it’s possible that memory was leaked leading up to the
	// reported failure. The only reasonable thing to do when an error is
	// detected is to call g_error().
	AddFromFile(filename string) (uint, error)
	// AddFromResource parses a resource file containing a [GtkBuilder UI
	// definition][BUILDER-UI] and merges it with the current contents of
	// @builder.
	//
	// Most users will probably want to use gtk_builder_new_from_resource().
	//
	// If an error occurs, 0 will be returned and @error will be assigned a
	// #GError from the K_BUILDER_ERROR, MARKUP_ERROR or RESOURCE_ERROR domain.
	//
	// It’s not really reasonable to attempt to handle failures of this call.
	// The only reasonable thing to do when an error is detected is to call
	// g_error().
	AddFromResource(resourcePath string) (uint, error)
	// AddFromString parses a string containing a [GtkBuilder UI
	// definition][BUILDER-UI] and merges it with the current contents of
	// @builder.
	//
	// Most users will probably want to use gtk_builder_new_from_string().
	//
	// Upon errors 0 will be returned and @error will be assigned a #GError from
	// the K_BUILDER_ERROR, MARKUP_ERROR or VARIANT_PARSE_ERROR domain.
	//
	// It’s not really reasonable to attempt to handle failures of this call.
	// The only reasonable thing to do when an error is detected is to call
	// g_error().
	AddFromString(buffer string, length uint) (uint, error)
	// AddObjectsFromFile parses a file containing a [GtkBuilder UI
	// definition][BUILDER-UI] building only the requested objects and merges
	// them with the current contents of @builder.
	//
	// Upon errors 0 will be returned and @error will be assigned a #GError from
	// the K_BUILDER_ERROR, MARKUP_ERROR or FILE_ERROR domain.
	//
	// If you are adding an object that depends on an object that is not its
	// child (for instance a TreeView that depends on its TreeModel), you have
	// to explicitly list all of them in @object_ids.
	AddObjectsFromFile(filename string, objectIds []string) (uint, error)
	// AddObjectsFromResource parses a resource file containing a [GtkBuilder UI
	// definition][BUILDER-UI] building only the requested objects and merges
	// them with the current contents of @builder.
	//
	// Upon errors 0 will be returned and @error will be assigned a #GError from
	// the K_BUILDER_ERROR, MARKUP_ERROR or RESOURCE_ERROR domain.
	//
	// If you are adding an object that depends on an object that is not its
	// child (for instance a TreeView that depends on its TreeModel), you have
	// to explicitly list all of them in @object_ids.
	AddObjectsFromResource(resourcePath string, objectIds []string) (uint, error)
	// AddObjectsFromString parses a string containing a [GtkBuilder UI
	// definition][BUILDER-UI] building only the requested objects and merges
	// them with the current contents of @builder.
	//
	// Upon errors 0 will be returned and @error will be assigned a #GError from
	// the K_BUILDER_ERROR or MARKUP_ERROR domain.
	//
	// If you are adding an object that depends on an object that is not its
	// child (for instance a TreeView that depends on its TreeModel), you have
	// to explicitly list all of them in @object_ids.
	AddObjectsFromString(buffer string, length uint, objectIds []string) (uint, error)
	// ExposeObject: add @object to the @builder object pool so it can be
	// referenced just like any other object built by builder.
	ExposeObject(name string, object gextras.Objector)
	// ExtendWithTemplate: main private entry point for building composite
	// container components from template XML.
	//
	// This is exported purely to let gtk-builder-tool validate templates,
	// applications have no need to call this function.
	ExtendWithTemplate(widget Widget, templateType externglib.Type, buffer string, length uint) (uint, error)
	// Application gets the Application associated with the builder.
	//
	// The Application is used for creating action proxies as requested from XML
	// that the builder is loading.
	//
	// By default, the builder uses the default application: the one from
	// g_application_get_default(). If you want to use another application for
	// constructing proxies, use gtk_builder_set_application().
	Application() Application
	// Object gets the object named @name. Note that this function does not
	// increment the reference count of the returned object.
	Object(name string) gextras.Objector
	// TranslationDomain gets the translation domain of @builder.
	TranslationDomain() string
	// TypeFromName looks up a type by name, using the virtual function that
	// Builder has for that purpose. This is mainly used when implementing the
	// Buildable interface on a type.
	TypeFromName(typeName string) externglib.Type
	// SetApplication sets the application associated with @builder.
	//
	// You only need this function if there is more than one #GApplication in
	// your process. @application cannot be nil.
	SetApplication(application Application)
	// SetTranslationDomain sets the translation domain of @builder. See
	// Builder:translation-domain.
	SetTranslationDomain(domain string)
	// ValueFromStringType: like gtk_builder_value_from_string(), this function
	// demarshals a value from a string, but takes a #GType instead of Spec.
	// This function calls g_value_init() on the @value argument, so it need not
	// be initialised beforehand.
	//
	// Upon errors false will be returned and @error will be assigned a #GError
	// from the K_BUILDER_ERROR domain.
	ValueFromStringType(typ externglib.Type, _string string) (*externglib.Value, error)
}

// builder implements the Builder class.
type builder struct {
	gextras.Objector
}

var _ Builder = (*builder)(nil)

// WrapBuilder wraps a GObject to the right type. It is
// primarily used internally.
func WrapBuilder(obj *externglib.Object) Builder {
	return builder{
		Objector: obj,
	}
}

func marshalBuilder(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBuilder(obj), nil
}

// NewBuilder creates a new empty builder object.
//
// This function is only useful if you intend to make multiple calls to
// gtk_builder_add_from_file(), gtk_builder_add_from_resource() or
// gtk_builder_add_from_string() in order to merge multiple UI descriptions into
// a single builder.
//
// Most users will probably want to use gtk_builder_new_from_file(),
// gtk_builder_new_from_resource() or gtk_builder_new_from_string().
func NewBuilder() Builder {
	var _cret *C.GtkBuilder // in

	_cret = C.gtk_builder_new()

	var _builder Builder // out

	_builder = WrapBuilder(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _builder
}

// NewBuilderFromFile builds the [GtkBuilder UI definition][BUILDER-UI] in the
// file @filename.
//
// If there is an error opening the file or parsing the description then the
// program will be aborted. You should only ever attempt to parse user interface
// descriptions that are shipped as part of your program.
func NewBuilderFromFile(filename string) Builder {
	var _arg1 *C.gchar      // out
	var _cret *C.GtkBuilder // in

	_arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_builder_new_from_file(_arg1)

	var _builder Builder // out

	_builder = WrapBuilder(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _builder
}

// NewBuilderFromResource builds the [GtkBuilder UI definition][BUILDER-UI] at
// @resource_path.
//
// If there is an error locating the resource or parsing the description, then
// the program will be aborted.
func NewBuilderFromResource(resourcePath string) Builder {
	var _arg1 *C.gchar      // out
	var _cret *C.GtkBuilder // in

	_arg1 = (*C.gchar)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_builder_new_from_resource(_arg1)

	var _builder Builder // out

	_builder = WrapBuilder(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _builder
}

// NewBuilderFromString builds the user interface described by @string (in the
// [GtkBuilder UI definition][BUILDER-UI] format).
//
// If @string is nil-terminated, then @length should be -1. If @length is not
// -1, then it is the length of @string.
//
// If there is an error parsing @string then the program will be aborted. You
// should not attempt to parse user interface description from untrusted
// sources.
func NewBuilderFromString(_string string, length int) Builder {
	var _arg1 *C.gchar      // out
	var _arg2 C.gssize      // out
	var _cret *C.GtkBuilder // in

	_arg1 = (*C.gchar)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gssize)(length)

	_cret = C.gtk_builder_new_from_string(_arg1, _arg2)

	var _builder Builder // out

	_builder = WrapBuilder(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _builder
}

// AddFromFile parses a file containing a [GtkBuilder UI definition][BUILDER-UI]
// and merges it with the current contents of @builder.
//
// Most users will probably want to use gtk_builder_new_from_file().
//
// If an error occurs, 0 will be returned and @error will be assigned a #GError
// from the K_BUILDER_ERROR, MARKUP_ERROR or FILE_ERROR domain.
//
// It’s not really reasonable to attempt to handle failures of this call. You
// should not use this function with untrusted files (ie: files that are not
// part of your application). Broken Builder files can easily crash your
// program, and it’s possible that memory was leaked leading up to the reported
// failure. The only reasonable thing to do when an error is detected is to call
// g_error().
func (b builder) AddFromFile(filename string) (uint, error) {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.gchar      // out
	var _cret C.guint       // in
	var _cerr *C.GError     // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_builder_add_from_file(_arg0, _arg1, &_cerr)

	var _guint uint  // out
	var _goerr error // out

	_guint = (uint)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _guint, _goerr
}

// AddFromResource parses a resource file containing a [GtkBuilder UI
// definition][BUILDER-UI] and merges it with the current contents of @builder.
//
// Most users will probably want to use gtk_builder_new_from_resource().
//
// If an error occurs, 0 will be returned and @error will be assigned a #GError
// from the K_BUILDER_ERROR, MARKUP_ERROR or RESOURCE_ERROR domain.
//
// It’s not really reasonable to attempt to handle failures of this call. The
// only reasonable thing to do when an error is detected is to call g_error().
func (b builder) AddFromResource(resourcePath string) (uint, error) {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.gchar      // out
	var _cret C.guint       // in
	var _cerr *C.GError     // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_builder_add_from_resource(_arg0, _arg1, &_cerr)

	var _guint uint  // out
	var _goerr error // out

	_guint = (uint)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _guint, _goerr
}

// AddFromString parses a string containing a [GtkBuilder UI
// definition][BUILDER-UI] and merges it with the current contents of @builder.
//
// Most users will probably want to use gtk_builder_new_from_string().
//
// Upon errors 0 will be returned and @error will be assigned a #GError from the
// K_BUILDER_ERROR, MARKUP_ERROR or VARIANT_PARSE_ERROR domain.
//
// It’s not really reasonable to attempt to handle failures of this call. The
// only reasonable thing to do when an error is detected is to call g_error().
func (b builder) AddFromString(buffer string, length uint) (uint, error) {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.gchar      // out
	var _arg2 C.gsize       // out
	var _cret C.guint       // in
	var _cerr *C.GError     // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(buffer))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gsize)(length)

	_cret = C.gtk_builder_add_from_string(_arg0, _arg1, _arg2, &_cerr)

	var _guint uint  // out
	var _goerr error // out

	_guint = (uint)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _guint, _goerr
}

// AddObjectsFromFile parses a file containing a [GtkBuilder UI
// definition][BUILDER-UI] building only the requested objects and merges them
// with the current contents of @builder.
//
// Upon errors 0 will be returned and @error will be assigned a #GError from the
// K_BUILDER_ERROR, MARKUP_ERROR or FILE_ERROR domain.
//
// If you are adding an object that depends on an object that is not its child
// (for instance a TreeView that depends on its TreeModel), you have to
// explicitly list all of them in @object_ids.
func (b builder) AddObjectsFromFile(filename string, objectIds []string) (uint, error) {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.gchar      // out
	var _arg2 **C.gchar
	var _cret C.guint   // in
	var _cerr *C.GError // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (**C.gchar)(C.malloc(C.ulong(len(objectIds)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice(_arg2, len(objectIds))
		for i := range objectIds {
			out[i] = (*C.gchar)(C.CString(objectIds[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.gtk_builder_add_objects_from_file(_arg0, _arg1, _arg2, &_cerr)

	var _guint uint  // out
	var _goerr error // out

	_guint = (uint)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _guint, _goerr
}

// AddObjectsFromResource parses a resource file containing a [GtkBuilder UI
// definition][BUILDER-UI] building only the requested objects and merges them
// with the current contents of @builder.
//
// Upon errors 0 will be returned and @error will be assigned a #GError from the
// K_BUILDER_ERROR, MARKUP_ERROR or RESOURCE_ERROR domain.
//
// If you are adding an object that depends on an object that is not its child
// (for instance a TreeView that depends on its TreeModel), you have to
// explicitly list all of them in @object_ids.
func (b builder) AddObjectsFromResource(resourcePath string, objectIds []string) (uint, error) {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.gchar      // out
	var _arg2 **C.gchar
	var _cret C.guint   // in
	var _cerr *C.GError // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (**C.gchar)(C.malloc(C.ulong(len(objectIds)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice(_arg2, len(objectIds))
		for i := range objectIds {
			out[i] = (*C.gchar)(C.CString(objectIds[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.gtk_builder_add_objects_from_resource(_arg0, _arg1, _arg2, &_cerr)

	var _guint uint  // out
	var _goerr error // out

	_guint = (uint)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _guint, _goerr
}

// AddObjectsFromString parses a string containing a [GtkBuilder UI
// definition][BUILDER-UI] building only the requested objects and merges them
// with the current contents of @builder.
//
// Upon errors 0 will be returned and @error will be assigned a #GError from the
// K_BUILDER_ERROR or MARKUP_ERROR domain.
//
// If you are adding an object that depends on an object that is not its child
// (for instance a TreeView that depends on its TreeModel), you have to
// explicitly list all of them in @object_ids.
func (b builder) AddObjectsFromString(buffer string, length uint, objectIds []string) (uint, error) {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.gchar      // out
	var _arg2 C.gsize       // out
	var _arg3 **C.gchar
	var _cret C.guint   // in
	var _cerr *C.GError // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(buffer))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gsize)(length)
	_arg3 = (**C.gchar)(C.malloc(C.ulong(len(objectIds)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice(_arg3, len(objectIds))
		for i := range objectIds {
			out[i] = (*C.gchar)(C.CString(objectIds[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.gtk_builder_add_objects_from_string(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _guint uint  // out
	var _goerr error // out

	_guint = (uint)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _guint, _goerr
}

// ExposeObject: add @object to the @builder object pool so it can be referenced
// just like any other object built by builder.
func (b builder) ExposeObject(name string, object gextras.Objector) {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GObject    // out

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GObject)(unsafe.Pointer(object.Native()))

	C.gtk_builder_expose_object(_arg0, _arg1, _arg2)
}

// ExtendWithTemplate: main private entry point for building composite container
// components from template XML.
//
// This is exported purely to let gtk-builder-tool validate templates,
// applications have no need to call this function.
func (b builder) ExtendWithTemplate(widget Widget, templateType externglib.Type, buffer string, length uint) (uint, error) {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.GtkWidget  // out
	var _arg2 C.GType       // out
	var _arg3 *C.gchar      // out
	var _arg4 C.gsize       // out
	var _cret C.guint       // in
	var _cerr *C.GError     // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = C.GType(templateType)
	_arg3 = (*C.gchar)(C.CString(buffer))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (C.gsize)(length)

	_cret = C.gtk_builder_extend_with_template(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)

	var _guint uint  // out
	var _goerr error // out

	_guint = (uint)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _guint, _goerr
}

// Application gets the Application associated with the builder.
//
// The Application is used for creating action proxies as requested from XML
// that the builder is loading.
//
// By default, the builder uses the default application: the one from
// g_application_get_default(). If you want to use another application for
// constructing proxies, use gtk_builder_set_application().
func (b builder) Application() Application {
	var _arg0 *C.GtkBuilder     // out
	var _cret *C.GtkApplication // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_builder_get_application(_arg0)

	var _application Application // out

	_application = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Application)

	return _application
}

// Object gets the object named @name. Note that this function does not
// increment the reference count of the returned object.
func (b builder) Object(name string) gextras.Objector {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.gchar      // out
	var _cret *C.GObject    // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_builder_get_object(_arg0, _arg1)

	var _object gextras.Objector // out

	_object = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gextras.Objector)

	return _object
}

// TranslationDomain gets the translation domain of @builder.
func (b builder) TranslationDomain() string {
	var _arg0 *C.GtkBuilder // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_builder_get_translation_domain(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// TypeFromName looks up a type by name, using the virtual function that Builder
// has for that purpose. This is mainly used when implementing the Buildable
// interface on a type.
func (b builder) TypeFromName(typeName string) externglib.Type {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.char       // out
	var _cret C.GType       // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(typeName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_builder_get_type_from_name(_arg0, _arg1)

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

// SetApplication sets the application associated with @builder.
//
// You only need this function if there is more than one #GApplication in your
// process. @application cannot be nil.
func (b builder) SetApplication(application Application) {
	var _arg0 *C.GtkBuilder     // out
	var _arg1 *C.GtkApplication // out

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkApplication)(unsafe.Pointer(application.Native()))

	C.gtk_builder_set_application(_arg0, _arg1)
}

// SetTranslationDomain sets the translation domain of @builder. See
// Builder:translation-domain.
func (b builder) SetTranslationDomain(domain string) {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.gchar      // out

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_builder_set_translation_domain(_arg0, _arg1)
}

// ValueFromStringType: like gtk_builder_value_from_string(), this function
// demarshals a value from a string, but takes a #GType instead of Spec. This
// function calls g_value_init() on the @value argument, so it need not be
// initialised beforehand.
//
// Upon errors false will be returned and @error will be assigned a #GError from
// the K_BUILDER_ERROR domain.
func (b builder) ValueFromStringType(typ externglib.Type, _string string) (*externglib.Value, error) {
	var _arg0 *C.GtkBuilder // out
	var _arg1 C.GType       // out
	var _arg2 *C.gchar      // out
	var _arg3 C.GValue      // in
	var _cerr *C.GError     // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = C.GType(typ)
	_arg2 = (*C.gchar)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_builder_value_from_string_type(_arg0, _arg1, _arg2, &_arg3, &_cerr)

	var _value *externglib.Value // out
	var _goerr error             // out

	_value = externglib.ValueFromNative(unsafe.Pointer(_arg3))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _value, _goerr
}

// Button: the Button widget is generally used to trigger a callback function
// that is called when the button is pressed. The various signals and how to use
// them are outlined below.
//
// The Button widget can hold any valid child widget. That is, it can hold
// almost any other standard Widget. The most commonly used child is the Label.
//
//
// CSS nodes
//
// GtkButton has a single CSS node with name button. The node will get the style
// classes .image-button or .text-button, if the content is just an image or
// label, respectively. It may also receive the .flat style class.
//
// Other style classes that are commonly used with GtkButton include
// .suggested-action and .destructive-action. In special cases, buttons can be
// made round by adding the .circular style class.
//
// Button-like widgets like ToggleButton, MenuButton, VolumeButton, LockButton,
// ColorButton, FontButton or FileChooserButton use style classes such as
// .toggle, .popup, .scale, .lock, .color, .font, .file to differentiate
// themselves from a plain GtkButton.
type Button interface {
	Bin
	Actionable
	Activatable
	Buildable

	// Clicked emits a Button::clicked signal to the given Button.
	Clicked()
	// Enter emits a Button::enter signal to the given Button.
	Enter()
	// Alignment gets the alignment of the child in the button.
	Alignment() (xalign float32, yalign float32)
	// AlwaysShowImage returns whether the button will ignore the
	// Settings:gtk-button-images setting and always show the image, if
	// available.
	AlwaysShowImage() bool
	// EventWindow returns the button’s event window if it is realized, nil
	// otherwise. This function should be rarely needed.
	EventWindow() gdk.Window
	// FocusOnClick returns whether the button grabs focus when it is clicked
	// with the mouse. See gtk_button_set_focus_on_click().
	FocusOnClick() bool
	// Image gets the widget that is currenty set as the image of @button. This
	// may have been explicitly set by gtk_button_set_image() or constructed by
	// gtk_button_new_from_stock().
	Image() Widget
	// ImagePosition gets the position of the image relative to the text inside
	// the button.
	ImagePosition() PositionType
	// Label fetches the text from the label of the button, as set by
	// gtk_button_set_label(). If the label text has not been set the return
	// value will be nil. This will be the case if you create an empty button
	// with gtk_button_new() to use as a container.
	Label() string
	// Relief returns the current relief style of the given Button.
	Relief() ReliefStyle
	// UseStock returns whether the button label is a stock item.
	UseStock() bool
	// UseUnderline returns whether an embedded underline in the button label
	// indicates a mnemonic. See gtk_button_set_use_underline ().
	UseUnderline() bool
	// Leave emits a Button::leave signal to the given Button.
	Leave()
	// Pressed emits a Button::pressed signal to the given Button.
	Pressed()
	// Released emits a Button::released signal to the given Button.
	Released()
	// SetAlignment sets the alignment of the child. This property has no effect
	// unless the child is a Misc or a Alignment.
	SetAlignment(xalign float32, yalign float32)
	// SetAlwaysShowImage: if true, the button will ignore the
	// Settings:gtk-button-images setting and always show the image, if
	// available.
	//
	// Use this property if the button would be useless or hard to use without
	// the image.
	SetAlwaysShowImage(alwaysShow bool)
	// SetFocusOnClick sets whether the button will grab focus when it is
	// clicked with the mouse. Making mouse clicks not grab focus is useful in
	// places like toolbars where you don’t want the keyboard focus removed from
	// the main area of the application.
	SetFocusOnClick(focusOnClick bool)
	// SetImage: set the image of @button to the given widget. The image will be
	// displayed if the label text is nil or if Button:always-show-image is
	// true. You don’t have to call gtk_widget_show() on @image yourself.
	SetImage(image Widget)
	// SetImagePosition sets the position of the image relative to the text
	// inside the button.
	SetImagePosition(position PositionType)
	// SetLabel sets the text of the label of the button to @str. This text is
	// also used to select the stock item if gtk_button_set_use_stock() is used.
	//
	// This will also clear any previously set labels.
	SetLabel(label string)
	// SetRelief sets the relief style of the edges of the given Button widget.
	// Two styles exist, GTK_RELIEF_NORMAL and GTK_RELIEF_NONE. The default
	// style is, as one can guess, GTK_RELIEF_NORMAL. The deprecated value
	// GTK_RELIEF_HALF behaves the same as GTK_RELIEF_NORMAL.
	SetRelief(relief ReliefStyle)
	// SetUseStock: if true, the label set on the button is used as a stock id
	// to select the stock item for the button.
	SetUseStock(useStock bool)
	// SetUseUnderline: if true, an underline in the text of the button label
	// indicates the next character should be used for the mnemonic accelerator
	// key.
	SetUseUnderline(useUnderline bool)
}

// button implements the Button class.
type button struct {
	Bin
	Actionable
	Activatable
	Buildable
}

var _ Button = (*button)(nil)

// WrapButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapButton(obj *externglib.Object) Button {
	return button{
		Bin:         WrapBin(obj),
		Actionable:  WrapActionable(obj),
		Activatable: WrapActivatable(obj),
		Buildable:   WrapBuildable(obj),
	}
}

func marshalButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapButton(obj), nil
}

// NewButton creates a new Button widget. To add a child widget to the button,
// use gtk_container_add().
func NewButton() Button {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_button_new()

	var _button Button // out

	_button = WrapButton(externglib.Take(unsafe.Pointer(_cret)))

	return _button
}

// NewButtonFromIconName creates a new button containing an icon from the
// current icon theme.
//
// If the icon name isn’t known, a “broken image” icon will be displayed
// instead. If the current icon theme is changed, the icon will be updated
// appropriately.
//
// This function is a convenience wrapper around gtk_button_new() and
// gtk_button_set_image().
func NewButtonFromIconName(iconName string, size int) Button {
	var _arg1 *C.gchar      // out
	var _arg2 C.GtkIconSize // out
	var _cret *C.GtkWidget  // in

	_arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GtkIconSize)(size)

	_cret = C.gtk_button_new_from_icon_name(_arg1, _arg2)

	var _button Button // out

	_button = WrapButton(externglib.Take(unsafe.Pointer(_cret)))

	return _button
}

// NewButtonFromStock creates a new Button containing the image and text from a
// [stock item][gtkstock]. Some stock ids have preprocessor macros like
// K_STOCK_OK and K_STOCK_APPLY.
//
// If @stock_id is unknown, then it will be treated as a mnemonic label (as for
// gtk_button_new_with_mnemonic()).
func NewButtonFromStock(stockId string) Button {
	var _arg1 *C.gchar     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.gchar)(C.CString(stockId))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_button_new_from_stock(_arg1)

	var _button Button // out

	_button = WrapButton(externglib.Take(unsafe.Pointer(_cret)))

	return _button
}

// NewButtonWithLabel creates a Button widget with a Label child containing the
// given text.
func NewButtonWithLabel(label string) Button {
	var _arg1 *C.gchar     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_button_new_with_label(_arg1)

	var _button Button // out

	_button = WrapButton(externglib.Take(unsafe.Pointer(_cret)))

	return _button
}

// NewButtonWithMnemonic creates a new Button containing a label. If characters
// in @label are preceded by an underscore, they are underlined. If you need a
// literal underscore character in a label, use “__” (two underscores). The
// first underlined character represents a keyboard accelerator called a
// mnemonic. Pressing Alt and that key activates the button.
func NewButtonWithMnemonic(label string) Button {
	var _arg1 *C.gchar     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_button_new_with_mnemonic(_arg1)

	var _button Button // out

	_button = WrapButton(externglib.Take(unsafe.Pointer(_cret)))

	return _button
}

// Clicked emits a Button::clicked signal to the given Button.
func (b button) Clicked() {
	var _arg0 *C.GtkButton // out

	_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

	C.gtk_button_clicked(_arg0)
}

// Enter emits a Button::enter signal to the given Button.
func (b button) Enter() {
	var _arg0 *C.GtkButton // out

	_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

	C.gtk_button_enter(_arg0)
}

// Alignment gets the alignment of the child in the button.
func (b button) Alignment() (xalign float32, yalign float32) {
	var _arg0 *C.GtkButton // out
	var _arg1 C.gfloat     // in
	var _arg2 C.gfloat     // in

	_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

	C.gtk_button_get_alignment(_arg0, &_arg1, &_arg2)

	var _xalign float32 // out
	var _yalign float32 // out

	_xalign = (float32)(_arg1)
	_yalign = (float32)(_arg2)

	return _xalign, _yalign
}

// AlwaysShowImage returns whether the button will ignore the
// Settings:gtk-button-images setting and always show the image, if available.
func (b button) AlwaysShowImage() bool {
	var _arg0 *C.GtkButton // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_button_get_always_show_image(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EventWindow returns the button’s event window if it is realized, nil
// otherwise. This function should be rarely needed.
func (b button) EventWindow() gdk.Window {
	var _arg0 *C.GtkButton // out
	var _cret *C.GdkWindow // in

	_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_button_get_event_window(_arg0)

	var _window gdk.Window // out

	_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Window)

	return _window
}

// FocusOnClick returns whether the button grabs focus when it is clicked with
// the mouse. See gtk_button_set_focus_on_click().
func (b button) FocusOnClick() bool {
	var _arg0 *C.GtkButton // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_button_get_focus_on_click(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Image gets the widget that is currenty set as the image of @button. This may
// have been explicitly set by gtk_button_set_image() or constructed by
// gtk_button_new_from_stock().
func (b button) Image() Widget {
	var _arg0 *C.GtkButton // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_button_get_image(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// ImagePosition gets the position of the image relative to the text inside the
// button.
func (b button) ImagePosition() PositionType {
	var _arg0 *C.GtkButton      // out
	var _cret C.GtkPositionType // in

	_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_button_get_image_position(_arg0)

	var _positionType PositionType // out

	_positionType = PositionType(_cret)

	return _positionType
}

// Label fetches the text from the label of the button, as set by
// gtk_button_set_label(). If the label text has not been set the return value
// will be nil. This will be the case if you create an empty button with
// gtk_button_new() to use as a container.
func (b button) Label() string {
	var _arg0 *C.GtkButton // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_button_get_label(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Relief returns the current relief style of the given Button.
func (b button) Relief() ReliefStyle {
	var _arg0 *C.GtkButton     // out
	var _cret C.GtkReliefStyle // in

	_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_button_get_relief(_arg0)

	var _reliefStyle ReliefStyle // out

	_reliefStyle = ReliefStyle(_cret)

	return _reliefStyle
}

// UseStock returns whether the button label is a stock item.
func (b button) UseStock() bool {
	var _arg0 *C.GtkButton // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_button_get_use_stock(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UseUnderline returns whether an embedded underline in the button label
// indicates a mnemonic. See gtk_button_set_use_underline ().
func (b button) UseUnderline() bool {
	var _arg0 *C.GtkButton // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_button_get_use_underline(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Leave emits a Button::leave signal to the given Button.
func (b button) Leave() {
	var _arg0 *C.GtkButton // out

	_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

	C.gtk_button_leave(_arg0)
}

// Pressed emits a Button::pressed signal to the given Button.
func (b button) Pressed() {
	var _arg0 *C.GtkButton // out

	_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

	C.gtk_button_pressed(_arg0)
}

// Released emits a Button::released signal to the given Button.
func (b button) Released() {
	var _arg0 *C.GtkButton // out

	_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

	C.gtk_button_released(_arg0)
}

// SetAlignment sets the alignment of the child. This property has no effect
// unless the child is a Misc or a Alignment.
func (b button) SetAlignment(xalign float32, yalign float32) {
	var _arg0 *C.GtkButton // out
	var _arg1 C.gfloat     // out
	var _arg2 C.gfloat     // out

	_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))
	_arg1 = (C.gfloat)(xalign)
	_arg2 = (C.gfloat)(yalign)

	C.gtk_button_set_alignment(_arg0, _arg1, _arg2)
}

// SetAlwaysShowImage: if true, the button will ignore the
// Settings:gtk-button-images setting and always show the image, if available.
//
// Use this property if the button would be useless or hard to use without the
// image.
func (b button) SetAlwaysShowImage(alwaysShow bool) {
	var _arg0 *C.GtkButton // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))
	if alwaysShow {
		_arg1 = C.TRUE
	}

	C.gtk_button_set_always_show_image(_arg0, _arg1)
}

// SetFocusOnClick sets whether the button will grab focus when it is clicked
// with the mouse. Making mouse clicks not grab focus is useful in places like
// toolbars where you don’t want the keyboard focus removed from the main area
// of the application.
func (b button) SetFocusOnClick(focusOnClick bool) {
	var _arg0 *C.GtkButton // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))
	if focusOnClick {
		_arg1 = C.TRUE
	}

	C.gtk_button_set_focus_on_click(_arg0, _arg1)
}

// SetImage: set the image of @button to the given widget. The image will be
// displayed if the label text is nil or if Button:always-show-image is true.
// You don’t have to call gtk_widget_show() on @image yourself.
func (b button) SetImage(image Widget) {
	var _arg0 *C.GtkButton // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(image.Native()))

	C.gtk_button_set_image(_arg0, _arg1)
}

// SetImagePosition sets the position of the image relative to the text inside
// the button.
func (b button) SetImagePosition(position PositionType) {
	var _arg0 *C.GtkButton      // out
	var _arg1 C.GtkPositionType // out

	_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))
	_arg1 = (C.GtkPositionType)(position)

	C.gtk_button_set_image_position(_arg0, _arg1)
}

// SetLabel sets the text of the label of the button to @str. This text is also
// used to select the stock item if gtk_button_set_use_stock() is used.
//
// This will also clear any previously set labels.
func (b button) SetLabel(label string) {
	var _arg0 *C.GtkButton // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_button_set_label(_arg0, _arg1)
}

// SetRelief sets the relief style of the edges of the given Button widget. Two
// styles exist, GTK_RELIEF_NORMAL and GTK_RELIEF_NONE. The default style is, as
// one can guess, GTK_RELIEF_NORMAL. The deprecated value GTK_RELIEF_HALF
// behaves the same as GTK_RELIEF_NORMAL.
func (b button) SetRelief(relief ReliefStyle) {
	var _arg0 *C.GtkButton     // out
	var _arg1 C.GtkReliefStyle // out

	_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))
	_arg1 = (C.GtkReliefStyle)(relief)

	C.gtk_button_set_relief(_arg0, _arg1)
}

// SetUseStock: if true, the label set on the button is used as a stock id to
// select the stock item for the button.
func (b button) SetUseStock(useStock bool) {
	var _arg0 *C.GtkButton // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))
	if useStock {
		_arg1 = C.TRUE
	}

	C.gtk_button_set_use_stock(_arg0, _arg1)
}

// SetUseUnderline: if true, an underline in the text of the button label
// indicates the next character should be used for the mnemonic accelerator key.
func (b button) SetUseUnderline(useUnderline bool) {
	var _arg0 *C.GtkButton // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))
	if useUnderline {
		_arg1 = C.TRUE
	}

	C.gtk_button_set_use_underline(_arg0, _arg1)
}

type ButtonAccessible interface {
	ContainerAccessible
}

// buttonAccessible implements the ButtonAccessible class.
type buttonAccessible struct {
	ContainerAccessible
}

var _ ButtonAccessible = (*buttonAccessible)(nil)

// WrapButtonAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapButtonAccessible(obj *externglib.Object) ButtonAccessible {
	return buttonAccessible{
		ContainerAccessible: WrapContainerAccessible(obj),
	}
}

func marshalButtonAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapButtonAccessible(obj), nil
}

type ButtonBox interface {
	Box
	Buildable
	Orientable

	// ChildNonHomogeneous returns whether the child is exempted from homogenous
	// sizing.
	ChildNonHomogeneous(child Widget) bool
	// ChildSecondary returns whether @child should appear in a secondary group
	// of children.
	ChildSecondary(child Widget) bool
	// Layout retrieves the method being used to arrange the buttons in a button
	// box.
	Layout() ButtonBoxStyle
	// SetChildNonHomogeneous sets whether the child is exempted from homogeous
	// sizing.
	SetChildNonHomogeneous(child Widget, nonHomogeneous bool)
	// SetChildSecondary sets whether @child should appear in a secondary group
	// of children. A typical use of a secondary child is the help button in a
	// dialog.
	//
	// This group appears after the other children if the style is
	// GTK_BUTTONBOX_START, GTK_BUTTONBOX_SPREAD or GTK_BUTTONBOX_EDGE, and
	// before the other children if the style is GTK_BUTTONBOX_END. For
	// horizontal button boxes, the definition of before/after depends on
	// direction of the widget (see gtk_widget_set_direction()). If the style is
	// GTK_BUTTONBOX_START or GTK_BUTTONBOX_END, then the secondary children are
	// aligned at the other end of the button box from the main children. For
	// the other styles, they appear immediately next to the main children.
	SetChildSecondary(child Widget, isSecondary bool)
	// SetLayout changes the way buttons are arranged in their container.
	SetLayout(layoutStyle ButtonBoxStyle)
}

// buttonBox implements the ButtonBox class.
type buttonBox struct {
	Box
	Buildable
	Orientable
}

var _ ButtonBox = (*buttonBox)(nil)

// WrapButtonBox wraps a GObject to the right type. It is
// primarily used internally.
func WrapButtonBox(obj *externglib.Object) ButtonBox {
	return buttonBox{
		Box:        WrapBox(obj),
		Buildable:  WrapBuildable(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalButtonBox(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapButtonBox(obj), nil
}

// NewButtonBox creates a new ButtonBox.
func NewButtonBox(orientation Orientation) ButtonBox {
	var _arg1 C.GtkOrientation // out
	var _cret *C.GtkWidget     // in

	_arg1 = (C.GtkOrientation)(orientation)

	_cret = C.gtk_button_box_new(_arg1)

	var _buttonBox ButtonBox // out

	_buttonBox = WrapButtonBox(externglib.Take(unsafe.Pointer(_cret)))

	return _buttonBox
}

// ChildNonHomogeneous returns whether the child is exempted from homogenous
// sizing.
func (w buttonBox) ChildNonHomogeneous(child Widget) bool {
	var _arg0 *C.GtkButtonBox // out
	var _arg1 *C.GtkWidget    // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkButtonBox)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	_cret = C.gtk_button_box_get_child_non_homogeneous(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ChildSecondary returns whether @child should appear in a secondary group of
// children.
func (w buttonBox) ChildSecondary(child Widget) bool {
	var _arg0 *C.GtkButtonBox // out
	var _arg1 *C.GtkWidget    // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkButtonBox)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	_cret = C.gtk_button_box_get_child_secondary(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Layout retrieves the method being used to arrange the buttons in a button
// box.
func (w buttonBox) Layout() ButtonBoxStyle {
	var _arg0 *C.GtkButtonBox     // out
	var _cret C.GtkButtonBoxStyle // in

	_arg0 = (*C.GtkButtonBox)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_button_box_get_layout(_arg0)

	var _buttonBoxStyle ButtonBoxStyle // out

	_buttonBoxStyle = ButtonBoxStyle(_cret)

	return _buttonBoxStyle
}

// SetChildNonHomogeneous sets whether the child is exempted from homogeous
// sizing.
func (w buttonBox) SetChildNonHomogeneous(child Widget, nonHomogeneous bool) {
	var _arg0 *C.GtkButtonBox // out
	var _arg1 *C.GtkWidget    // out
	var _arg2 C.gboolean      // out

	_arg0 = (*C.GtkButtonBox)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	if nonHomogeneous {
		_arg2 = C.TRUE
	}

	C.gtk_button_box_set_child_non_homogeneous(_arg0, _arg1, _arg2)
}

// SetChildSecondary sets whether @child should appear in a secondary group of
// children. A typical use of a secondary child is the help button in a dialog.
//
// This group appears after the other children if the style is
// GTK_BUTTONBOX_START, GTK_BUTTONBOX_SPREAD or GTK_BUTTONBOX_EDGE, and before
// the other children if the style is GTK_BUTTONBOX_END. For horizontal button
// boxes, the definition of before/after depends on direction of the widget (see
// gtk_widget_set_direction()). If the style is GTK_BUTTONBOX_START or
// GTK_BUTTONBOX_END, then the secondary children are aligned at the other end
// of the button box from the main children. For the other styles, they appear
// immediately next to the main children.
func (w buttonBox) SetChildSecondary(child Widget, isSecondary bool) {
	var _arg0 *C.GtkButtonBox // out
	var _arg1 *C.GtkWidget    // out
	var _arg2 C.gboolean      // out

	_arg0 = (*C.GtkButtonBox)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	if isSecondary {
		_arg2 = C.TRUE
	}

	C.gtk_button_box_set_child_secondary(_arg0, _arg1, _arg2)
}

// SetLayout changes the way buttons are arranged in their container.
func (w buttonBox) SetLayout(layoutStyle ButtonBoxStyle) {
	var _arg0 *C.GtkButtonBox     // out
	var _arg1 C.GtkButtonBoxStyle // out

	_arg0 = (*C.GtkButtonBox)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GtkButtonBoxStyle)(layoutStyle)

	C.gtk_button_box_set_layout(_arg0, _arg1)
}

// Calendar is a widget that displays a Gregorian calendar, one month at a time.
// It can be created with gtk_calendar_new().
//
// The month and year currently displayed can be altered with
// gtk_calendar_select_month(). The exact day can be selected from the displayed
// month using gtk_calendar_select_day().
//
// To place a visual marker on a particular day, use gtk_calendar_mark_day() and
// to remove the marker, gtk_calendar_unmark_day(). Alternative, all marks can
// be cleared with gtk_calendar_clear_marks().
//
// The way in which the calendar itself is displayed can be altered using
// gtk_calendar_set_display_options().
//
// The selected date can be retrieved from a Calendar using
// gtk_calendar_get_date().
//
// Users should be aware that, although the Gregorian calendar is the legal
// calendar in most countries, it was adopted progressively between 1582 and
// 1929. Display before these dates is likely to be historically incorrect.
type Calendar interface {
	Widget
	Buildable

	// ClearMarks: remove all visual markers.
	ClearMarks()
	// Date obtains the selected date from a Calendar.
	Date() (year uint, month uint, day uint)
	// DayIsMarked returns if the @day of the @calendar is already marked.
	DayIsMarked(day uint) bool
	// DetailHeightRows queries the height of detail cells, in rows. See
	// Calendar:detail-width-chars.
	DetailHeightRows() int
	// DetailWidthChars queries the width of detail cells, in characters. See
	// Calendar:detail-width-chars.
	DetailWidthChars() int
	// DisplayOptions returns the current display options of @calendar.
	DisplayOptions() CalendarDisplayOptions
	// MarkDay places a visual marker on a particular day.
	MarkDay(day uint)
	// SelectDay selects a day from the current month.
	SelectDay(day uint)
	// SelectMonth shifts the calendar to a different month.
	SelectMonth(month uint, year uint)
	// SetDetailHeightRows updates the height of detail cells. See
	// Calendar:detail-height-rows.
	SetDetailHeightRows(rows int)
	// SetDetailWidthChars updates the width of detail cells. See
	// Calendar:detail-width-chars.
	SetDetailWidthChars(chars int)
	// SetDisplayOptions sets display options (whether to display the heading
	// and the month headings).
	SetDisplayOptions(flags CalendarDisplayOptions)
	// UnmarkDay removes the visual marker from a particular day.
	UnmarkDay(day uint)
}

// calendar implements the Calendar class.
type calendar struct {
	Widget
	Buildable
}

var _ Calendar = (*calendar)(nil)

// WrapCalendar wraps a GObject to the right type. It is
// primarily used internally.
func WrapCalendar(obj *externglib.Object) Calendar {
	return calendar{
		Widget:    WrapWidget(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalCalendar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCalendar(obj), nil
}

// NewCalendar creates a new calendar, with the current date being selected.
func NewCalendar() Calendar {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_calendar_new()

	var _calendar Calendar // out

	_calendar = WrapCalendar(externglib.Take(unsafe.Pointer(_cret)))

	return _calendar
}

// ClearMarks: remove all visual markers.
func (c calendar) ClearMarks() {
	var _arg0 *C.GtkCalendar // out

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))

	C.gtk_calendar_clear_marks(_arg0)
}

// Date obtains the selected date from a Calendar.
func (c calendar) Date() (year uint, month uint, day uint) {
	var _arg0 *C.GtkCalendar // out
	var _arg1 C.guint        // in
	var _arg2 C.guint        // in
	var _arg3 C.guint        // in

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))

	C.gtk_calendar_get_date(_arg0, &_arg1, &_arg2, &_arg3)

	var _year uint  // out
	var _month uint // out
	var _day uint   // out

	_year = (uint)(_arg1)
	_month = (uint)(_arg2)
	_day = (uint)(_arg3)

	return _year, _month, _day
}

// DayIsMarked returns if the @day of the @calendar is already marked.
func (c calendar) DayIsMarked(day uint) bool {
	var _arg0 *C.GtkCalendar // out
	var _arg1 C.guint        // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))
	_arg1 = (C.guint)(day)

	_cret = C.gtk_calendar_get_day_is_marked(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DetailHeightRows queries the height of detail cells, in rows. See
// Calendar:detail-width-chars.
func (c calendar) DetailHeightRows() int {
	var _arg0 *C.GtkCalendar // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_calendar_get_detail_height_rows(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// DetailWidthChars queries the width of detail cells, in characters. See
// Calendar:detail-width-chars.
func (c calendar) DetailWidthChars() int {
	var _arg0 *C.GtkCalendar // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_calendar_get_detail_width_chars(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// DisplayOptions returns the current display options of @calendar.
func (c calendar) DisplayOptions() CalendarDisplayOptions {
	var _arg0 *C.GtkCalendar              // out
	var _cret C.GtkCalendarDisplayOptions // in

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_calendar_get_display_options(_arg0)

	var _calendarDisplayOptions CalendarDisplayOptions // out

	_calendarDisplayOptions = CalendarDisplayOptions(_cret)

	return _calendarDisplayOptions
}

// MarkDay places a visual marker on a particular day.
func (c calendar) MarkDay(day uint) {
	var _arg0 *C.GtkCalendar // out
	var _arg1 C.guint        // out

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))
	_arg1 = (C.guint)(day)

	C.gtk_calendar_mark_day(_arg0, _arg1)
}

// SelectDay selects a day from the current month.
func (c calendar) SelectDay(day uint) {
	var _arg0 *C.GtkCalendar // out
	var _arg1 C.guint        // out

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))
	_arg1 = (C.guint)(day)

	C.gtk_calendar_select_day(_arg0, _arg1)
}

// SelectMonth shifts the calendar to a different month.
func (c calendar) SelectMonth(month uint, year uint) {
	var _arg0 *C.GtkCalendar // out
	var _arg1 C.guint        // out
	var _arg2 C.guint        // out

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))
	_arg1 = (C.guint)(month)
	_arg2 = (C.guint)(year)

	C.gtk_calendar_select_month(_arg0, _arg1, _arg2)
}

// SetDetailHeightRows updates the height of detail cells. See
// Calendar:detail-height-rows.
func (c calendar) SetDetailHeightRows(rows int) {
	var _arg0 *C.GtkCalendar // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))
	_arg1 = (C.gint)(rows)

	C.gtk_calendar_set_detail_height_rows(_arg0, _arg1)
}

// SetDetailWidthChars updates the width of detail cells. See
// Calendar:detail-width-chars.
func (c calendar) SetDetailWidthChars(chars int) {
	var _arg0 *C.GtkCalendar // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))
	_arg1 = (C.gint)(chars)

	C.gtk_calendar_set_detail_width_chars(_arg0, _arg1)
}

// SetDisplayOptions sets display options (whether to display the heading and
// the month headings).
func (c calendar) SetDisplayOptions(flags CalendarDisplayOptions) {
	var _arg0 *C.GtkCalendar              // out
	var _arg1 C.GtkCalendarDisplayOptions // out

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GtkCalendarDisplayOptions)(flags)

	C.gtk_calendar_set_display_options(_arg0, _arg1)
}

// UnmarkDay removes the visual marker from a particular day.
func (c calendar) UnmarkDay(day uint) {
	var _arg0 *C.GtkCalendar // out
	var _arg1 C.guint        // out

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))
	_arg1 = (C.guint)(day)

	C.gtk_calendar_unmark_day(_arg0, _arg1)
}

// CellArea: the CellArea is an abstract class for CellLayout widgets (also
// referred to as "layouting widgets") to interface with an arbitrary number of
// CellRenderers and interact with the user for a given TreeModel row.
//
// The cell area handles events, focus navigation, drawing and size requests and
// allocations for a given row of data.
//
// Usually users dont have to interact with the CellArea directly unless they
// are implementing a cell-layouting widget themselves.
//
//
// Requesting area sizes
//
// As outlined in [GtkWidget’s geometry management
// section][geometry-management], GTK+ uses a height-for-width geometry
// management system to compute the sizes of widgets and user interfaces.
// CellArea uses the same semantics to calculate the size of an area for an
// arbitrary number of TreeModel rows.
//
// When requesting the size of a cell area one needs to calculate the size for a
// handful of rows, and this will be done differently by different layouting
// widgets. For instance a TreeViewColumn always lines up the areas from top to
// bottom while a IconView on the other hand might enforce that all areas
// received the same width and wrap the areas around, requesting height for more
// cell areas when allocated less width.
//
// It’s also important for areas to maintain some cell alignments with areas
// rendered for adjacent rows (cells can appear “columnized” inside an area even
// when the size of cells are different in each row). For this reason the
// CellArea uses a CellAreaContext object to store the alignments and sizes
// along the way (as well as the overall largest minimum and natural size for
// all the rows which have been calculated with the said context).
//
// The CellAreaContext is an opaque object specific to the CellArea which
// created it (see gtk_cell_area_create_context()). The owning cell-layouting
// widget can create as many contexts as it wishes to calculate sizes of rows
// which should receive the same size in at least one orientation (horizontally
// or vertically), However, it’s important that the same CellAreaContext which
// was used to request the sizes for a given TreeModel row be used when
// rendering or processing events for that row.
//
// In order to request the width of all the rows at the root level of a
// TreeModel one would do the following:
//
//    static gboolean
//    foo_focus (GtkWidget       *widget,
//               GtkDirectionType direction)
//    {
//      Foo        *foo  = FOO (widget);
//      FooPrivate *priv = foo->priv;
//      gint        focus_row;
//      gboolean    have_focus = FALSE;
//
//      focus_row = priv->focus_row;
//
//      if (!gtk_widget_has_focus (widget))
//        gtk_widget_grab_focus (widget);
//
//      valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, priv->focus_row);
//      while (valid)
//        {
//          gtk_cell_area_apply_attributes (priv->area, priv->model, &iter, FALSE, FALSE);
//
//          if (gtk_cell_area_focus (priv->area, direction))
//            {
//               priv->focus_row = focus_row;
//               have_focus = TRUE;
//               break;
//            }
//          else
//            {
//              if (direction == GTK_DIR_RIGHT ||
//                  direction == GTK_DIR_LEFT)
//                break;
//              else if (direction == GTK_DIR_UP ||
//                       direction == GTK_DIR_TAB_BACKWARD)
//               {
//                  if (focus_row == 0)
//                    break;
//                  else
//                   {
//                      focus_row--;
//                      valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, focus_row);
//                   }
//                }
//              else
//                {
//                  if (focus_row == last_row)
//                    break;
//                  else
//                    {
//                      focus_row++;
//                      valid = gtk_tree_model_iter_next (priv->model, &iter);
//                    }
//                }
//            }
//        }
//        return have_focus;
//    }
//
// Note that the layouting widget is responsible for matching the
// GtkDirectionType values to the way it lays out its cells.
//
//
// Cell Properties
//
// The CellArea introduces cell properties for CellRenderers in very much the
// same way that Container introduces [child properties][child-properties] for
// Widgets. This provides some general interfaces for defining the relationship
// cell areas have with their cells. For instance in a CellAreaBox a cell might
// “expand” and receive extra space when the area is allocated more than its
// full natural request, or a cell might be configured to “align” with adjacent
// rows which were requested and rendered with the same CellAreaContext.
//
// Use gtk_cell_area_class_install_cell_property() to install cell properties
// for a cell area class and gtk_cell_area_class_find_cell_property() or
// gtk_cell_area_class_list_cell_properties() to get information about existing
// cell properties.
//
// To set the value of a cell property, use gtk_cell_area_cell_set_property(),
// gtk_cell_area_cell_set() or gtk_cell_area_cell_set_valist(). To obtain the
// value of a cell property, use gtk_cell_area_cell_get_property(),
// gtk_cell_area_cell_get() or gtk_cell_area_cell_get_valist().
type CellArea interface {
	gextras.Objector
	Buildable
	CellLayout

	// Activate activates @area, usually by activating the currently focused
	// cell, however some subclasses which embed widgets in the area can also
	// activate a widget if it currently has the focus.
	Activate(context CellAreaContext, widget Widget, cellArea *gdk.Rectangle, flags CellRendererState, editOnly bool) bool
	// Add adds @renderer to @area with the default child cell properties.
	Add(renderer CellRenderer)
	// AddFocusSibling adds @sibling to @renderer’s focusable area, focus will
	// be drawn around @renderer and all of its siblings if @renderer can focus
	// for a given row.
	//
	// Events handled by focus siblings can also activate the given focusable
	// @renderer.
	AddFocusSibling(renderer CellRenderer, sibling CellRenderer)
	// ApplyAttributes applies any connected attributes to the renderers in
	// @area by pulling the values from @tree_model.
	ApplyAttributes(treeModel TreeModel, iter *TreeIter, isExpander bool, isExpanded bool)
	// AttributeConnect connects an @attribute to apply values from @column for
	// the TreeModel in use.
	AttributeConnect(renderer CellRenderer, attribute string, column int)
	// AttributeDisconnect disconnects @attribute for the @renderer in @area so
	// that attribute will no longer be updated with values from the model.
	AttributeDisconnect(renderer CellRenderer, attribute string)
	// AttributeGetColumn returns the model column that an attribute has been
	// mapped to, or -1 if the attribute is not mapped.
	AttributeGetColumn(renderer CellRenderer, attribute string) int
	// CellGetProperty gets the value of a cell property for @renderer in @area.
	CellGetProperty(renderer CellRenderer, propertyName string, value **externglib.Value)
	// CellSetProperty sets a cell property for @renderer in @area.
	CellSetProperty(renderer CellRenderer, propertyName string, value **externglib.Value)
	// CopyContext: this is sometimes needed for cases where rows need to share
	// alignments in one orientation but may be separately grouped in the
	// opposing orientation.
	//
	// For instance, IconView creates all icons (rows) to have the same width
	// and the cells theirin to have the same horizontal alignments. However
	// each row of icons may have a separate collective height. IconView uses
	// this to request the heights of each row based on a context which was
	// already used to request all the row widths that are to be displayed.
	CopyContext(context CellAreaContext) CellAreaContext
	// CreateContext creates a CellAreaContext to be used with @area for all
	// purposes. CellAreaContext stores geometry information for rows for which
	// it was operated on, it is important to use the same context for the same
	// row of data at all times (i.e. one should render and handle events with
	// the same CellAreaContext which was used to request the size of those rows
	// of data).
	CreateContext() CellAreaContext
	// Focus: this should be called by the @area’s owning layout widget when
	// focus is to be passed to @area, or moved within @area for a given
	// @direction and row data.
	//
	// Implementing CellArea classes should implement this method to receive and
	// navigate focus in its own way particular to how it lays out cells.
	Focus(direction DirectionType) bool
	// CellAllocation derives the allocation of @renderer inside @area if @area
	// were to be renderered in @cell_area.
	CellAllocation(context CellAreaContext, widget Widget, renderer CellRenderer, cellArea *gdk.Rectangle) gdk.Rectangle
	// CellAtPosition gets the CellRenderer at @x and @y coordinates inside
	// @area and optionally returns the full cell allocation for it inside
	// @cell_area.
	CellAtPosition(context CellAreaContext, widget Widget, cellArea *gdk.Rectangle, x int, y int) (gdk.Rectangle, CellRenderer)
	// CurrentPathString gets the current TreePath string for the currently
	// applied TreeIter, this is implicitly updated when
	// gtk_cell_area_apply_attributes() is called and can be used to interact
	// with renderers from CellArea subclasses.
	CurrentPathString() string
	// EditWidget gets the CellEditable widget currently used to edit the
	// currently edited cell.
	EditWidget() CellEditable
	// EditedCell gets the CellRenderer in @area that is currently being edited.
	EditedCell() CellRenderer
	// FocusCell retrieves the currently focused cell for @area
	FocusCell() CellRenderer
	// FocusFromSibling gets the CellRenderer which is expected to be focusable
	// for which @renderer is, or may be a sibling.
	//
	// This is handy for CellArea subclasses when handling events, after
	// determining the renderer at the event location it can then chose to
	// activate the focus cell for which the event cell may have been a sibling.
	FocusFromSibling(renderer CellRenderer) CellRenderer
	// PreferredHeight retrieves a cell area’s initial minimum and natural
	// height.
	//
	// @area will store some geometrical information in @context along the way;
	// when requesting sizes over an arbitrary number of rows, it’s not
	// important to check the @minimum_height and @natural_height of this call
	// but rather to consult gtk_cell_area_context_get_preferred_height() after
	// a series of requests.
	PreferredHeight(context CellAreaContext, widget Widget) (minimumHeight int, naturalHeight int)
	// PreferredHeightForWidth retrieves a cell area’s minimum and natural
	// height if it would be given the specified @width.
	//
	// @area stores some geometrical information in @context along the way while
	// calling gtk_cell_area_get_preferred_width(). It’s important to perform a
	// series of gtk_cell_area_get_preferred_width() requests with @context
	// first and then call gtk_cell_area_get_preferred_height_for_width() on
	// each cell area individually to get the height for width of each fully
	// requested row.
	//
	// If at some point, the width of a single row changes, it should be
	// requested with gtk_cell_area_get_preferred_width() again and then the
	// full width of the requested rows checked again with
	// gtk_cell_area_context_get_preferred_width().
	PreferredHeightForWidth(context CellAreaContext, widget Widget, width int) (minimumHeight int, naturalHeight int)
	// PreferredWidth retrieves a cell area’s initial minimum and natural width.
	//
	// @area will store some geometrical information in @context along the way;
	// when requesting sizes over an arbitrary number of rows, it’s not
	// important to check the @minimum_width and @natural_width of this call but
	// rather to consult gtk_cell_area_context_get_preferred_width() after a
	// series of requests.
	PreferredWidth(context CellAreaContext, widget Widget) (minimumWidth int, naturalWidth int)
	// PreferredWidthForHeight retrieves a cell area’s minimum and natural width
	// if it would be given the specified @height.
	//
	// @area stores some geometrical information in @context along the way while
	// calling gtk_cell_area_get_preferred_height(). It’s important to perform a
	// series of gtk_cell_area_get_preferred_height() requests with @context
	// first and then call gtk_cell_area_get_preferred_width_for_height() on
	// each cell area individually to get the height for width of each fully
	// requested row.
	//
	// If at some point, the height of a single row changes, it should be
	// requested with gtk_cell_area_get_preferred_height() again and then the
	// full height of the requested rows checked again with
	// gtk_cell_area_context_get_preferred_height().
	PreferredWidthForHeight(context CellAreaContext, widget Widget, height int) (minimumWidth int, naturalWidth int)
	// RequestMode gets whether the area prefers a height-for-width layout or a
	// width-for-height layout.
	RequestMode() SizeRequestMode
	// HasRenderer checks if @area contains @renderer.
	HasRenderer(renderer CellRenderer) bool
	// InnerCellArea: this is a convenience function for CellArea
	// implementations to get the inner area where a given CellRenderer will be
	// rendered. It removes any padding previously added by
	// gtk_cell_area_request_renderer().
	InnerCellArea(widget Widget, cellArea *gdk.Rectangle) gdk.Rectangle
	// IsActivatable returns whether the area can do anything when activated,
	// after applying new attributes to @area.
	IsActivatable() bool
	// IsFocusSibling returns whether @sibling is one of @renderer’s focus
	// siblings (see gtk_cell_area_add_focus_sibling()).
	IsFocusSibling(renderer CellRenderer, sibling CellRenderer) bool
	// Remove removes @renderer from @area.
	Remove(renderer CellRenderer)
	// RemoveFocusSibling removes @sibling from @renderer’s focus sibling list
	// (see gtk_cell_area_add_focus_sibling()).
	RemoveFocusSibling(renderer CellRenderer, sibling CellRenderer)
	// Render renders @area’s cells according to @area’s layout onto @widget at
	// the given coordinates.
	Render(context CellAreaContext, widget Widget, cr *cairo.Context, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState, paintFocus bool)
	// RequestRenderer: this is a convenience function for CellArea
	// implementations to request size for cell renderers. It’s important to use
	// this function to request size and then use
	// gtk_cell_area_inner_cell_area() at render and event time since this
	// function will add padding around the cell for focus painting.
	RequestRenderer(renderer CellRenderer, orientation Orientation, widget Widget, forSize int) (minimumSize int, naturalSize int)
	// SetFocusCell: explicitly sets the currently focused cell to @renderer.
	//
	// This is generally called by implementations of CellAreaClass.focus() or
	// CellAreaClass.event(), however it can also be used to implement functions
	// such as gtk_tree_view_set_cursor_on_cell().
	SetFocusCell(renderer CellRenderer)
	// StopEditing: explicitly stops the editing of the currently edited cell.
	//
	// If @canceled is true, the currently edited cell renderer will emit the
	// ::editing-canceled signal, otherwise the the ::editing-done signal will
	// be emitted on the current edit widget.
	//
	// See gtk_cell_area_get_edited_cell() and gtk_cell_area_get_edit_widget().
	StopEditing(canceled bool)
}

// cellArea implements the CellArea class.
type cellArea struct {
	gextras.Objector
	Buildable
	CellLayout
}

var _ CellArea = (*cellArea)(nil)

// WrapCellArea wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellArea(obj *externglib.Object) CellArea {
	return cellArea{
		Objector:   obj,
		Buildable:  WrapBuildable(obj),
		CellLayout: WrapCellLayout(obj),
	}
}

func marshalCellArea(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellArea(obj), nil
}

// Activate activates @area, usually by activating the currently focused cell,
// however some subclasses which embed widgets in the area can also activate a
// widget if it currently has the focus.
func (a cellArea) Activate(context CellAreaContext, widget Widget, cellArea *gdk.Rectangle, flags CellRendererState, editOnly bool) bool {
	var _arg0 *C.GtkCellArea         // out
	var _arg1 *C.GtkCellAreaContext  // out
	var _arg2 *C.GtkWidget           // out
	var _arg3 *C.GdkRectangle        // out
	var _arg4 C.GtkCellRendererState // out
	var _arg5 C.gboolean             // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg3 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))
	_arg4 = (C.GtkCellRendererState)(flags)
	if editOnly {
		_arg5 = C.TRUE
	}

	_cret = C.gtk_cell_area_activate(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Add adds @renderer to @area with the default child cell properties.
func (a cellArea) Add(renderer CellRenderer) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))

	C.gtk_cell_area_add(_arg0, _arg1)
}

// AddFocusSibling adds @sibling to @renderer’s focusable area, focus will be
// drawn around @renderer and all of its siblings if @renderer can focus for a
// given row.
//
// Events handled by focus siblings can also activate the given focusable
// @renderer.
func (a cellArea) AddFocusSibling(renderer CellRenderer, sibling CellRenderer) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 *C.GtkCellRenderer // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	_arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(sibling.Native()))

	C.gtk_cell_area_add_focus_sibling(_arg0, _arg1, _arg2)
}

// ApplyAttributes applies any connected attributes to the renderers in @area by
// pulling the values from @tree_model.
func (a cellArea) ApplyAttributes(treeModel TreeModel, iter *TreeIter, isExpander bool, isExpanded bool) {
	var _arg0 *C.GtkCellArea  // out
	var _arg1 *C.GtkTreeModel // out
	var _arg2 *C.GtkTreeIter  // out
	var _arg3 C.gboolean      // out
	var _arg4 C.gboolean      // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(treeModel.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
	if isExpander {
		_arg3 = C.TRUE
	}
	if isExpanded {
		_arg4 = C.TRUE
	}

	C.gtk_cell_area_apply_attributes(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// AttributeConnect connects an @attribute to apply values from @column for the
// TreeModel in use.
func (a cellArea) AttributeConnect(renderer CellRenderer, attribute string, column int) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 *C.gchar           // out
	var _arg3 C.gint             // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	_arg2 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.gint)(column)

	C.gtk_cell_area_attribute_connect(_arg0, _arg1, _arg2, _arg3)
}

// AttributeDisconnect disconnects @attribute for the @renderer in @area so that
// attribute will no longer be updated with values from the model.
func (a cellArea) AttributeDisconnect(renderer CellRenderer, attribute string) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 *C.gchar           // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	_arg2 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_cell_area_attribute_disconnect(_arg0, _arg1, _arg2)
}

// AttributeGetColumn returns the model column that an attribute has been mapped
// to, or -1 if the attribute is not mapped.
func (a cellArea) AttributeGetColumn(renderer CellRenderer, attribute string) int {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 *C.gchar           // out
	var _cret C.gint             // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	_arg2 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_cell_area_attribute_get_column(_arg0, _arg1, _arg2)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// CellGetProperty gets the value of a cell property for @renderer in @area.
func (a cellArea) CellGetProperty(renderer CellRenderer, propertyName string, value **externglib.Value) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 *C.gchar           // out
	var _arg3 *C.GValue          // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	_arg2 = (*C.gchar)(C.CString(propertyName))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GValue)(value.GValue)

	C.gtk_cell_area_cell_get_property(_arg0, _arg1, _arg2, _arg3)
}

// CellSetProperty sets a cell property for @renderer in @area.
func (a cellArea) CellSetProperty(renderer CellRenderer, propertyName string, value **externglib.Value) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 *C.gchar           // out
	var _arg3 *C.GValue          // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	_arg2 = (*C.gchar)(C.CString(propertyName))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GValue)(value.GValue)

	C.gtk_cell_area_cell_set_property(_arg0, _arg1, _arg2, _arg3)
}

// CopyContext: this is sometimes needed for cases where rows need to share
// alignments in one orientation but may be separately grouped in the opposing
// orientation.
//
// For instance, IconView creates all icons (rows) to have the same width and
// the cells theirin to have the same horizontal alignments. However each row of
// icons may have a separate collective height. IconView uses this to request
// the heights of each row based on a context which was already used to request
// all the row widths that are to be displayed.
func (a cellArea) CopyContext(context CellAreaContext) CellAreaContext {
	var _arg0 *C.GtkCellArea        // out
	var _arg1 *C.GtkCellAreaContext // out
	var _cret *C.GtkCellAreaContext // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))

	_cret = C.gtk_cell_area_copy_context(_arg0, _arg1)

	var _cellAreaContext CellAreaContext // out

	_cellAreaContext = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(CellAreaContext)

	return _cellAreaContext
}

// CreateContext creates a CellAreaContext to be used with @area for all
// purposes. CellAreaContext stores geometry information for rows for which it
// was operated on, it is important to use the same context for the same row of
// data at all times (i.e. one should render and handle events with the same
// CellAreaContext which was used to request the size of those rows of data).
func (a cellArea) CreateContext() CellAreaContext {
	var _arg0 *C.GtkCellArea        // out
	var _cret *C.GtkCellAreaContext // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_cell_area_create_context(_arg0)

	var _cellAreaContext CellAreaContext // out

	_cellAreaContext = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(CellAreaContext)

	return _cellAreaContext
}

// Focus: this should be called by the @area’s owning layout widget when focus
// is to be passed to @area, or moved within @area for a given @direction and
// row data.
//
// Implementing CellArea classes should implement this method to receive and
// navigate focus in its own way particular to how it lays out cells.
func (a cellArea) Focus(direction DirectionType) bool {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 C.GtkDirectionType // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (C.GtkDirectionType)(direction)

	_cret = C.gtk_cell_area_focus(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CellAllocation derives the allocation of @renderer inside @area if @area were
// to be renderered in @cell_area.
func (a cellArea) CellAllocation(context CellAreaContext, widget Widget, renderer CellRenderer, cellArea *gdk.Rectangle) gdk.Rectangle {
	var _arg0 *C.GtkCellArea        // out
	var _arg1 *C.GtkCellAreaContext // out
	var _arg2 *C.GtkWidget          // out
	var _arg3 *C.GtkCellRenderer    // out
	var _arg4 *C.GdkRectangle       // out
	var _allocation gdk.Rectangle

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg3 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	_arg4 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))

	C.gtk_cell_area_get_cell_allocation(_arg0, _arg1, _arg2, _arg3, _arg4, (*C.GdkRectangle)(unsafe.Pointer(&_allocation)))

	return _allocation
}

// CellAtPosition gets the CellRenderer at @x and @y coordinates inside @area
// and optionally returns the full cell allocation for it inside @cell_area.
func (a cellArea) CellAtPosition(context CellAreaContext, widget Widget, cellArea *gdk.Rectangle, x int, y int) (gdk.Rectangle, CellRenderer) {
	var _arg0 *C.GtkCellArea        // out
	var _arg1 *C.GtkCellAreaContext // out
	var _arg2 *C.GtkWidget          // out
	var _arg3 *C.GdkRectangle       // out
	var _arg4 C.gint                // out
	var _arg5 C.gint                // out
	var _allocArea gdk.Rectangle
	var _cret *C.GtkCellRenderer // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg3 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))
	_arg4 = (C.gint)(x)
	_arg5 = (C.gint)(y)

	_cret = C.gtk_cell_area_get_cell_at_position(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, (*C.GdkRectangle)(unsafe.Pointer(&_allocArea)))

	var _cellRenderer CellRenderer // out

	_cellRenderer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(CellRenderer)

	return _allocArea, _cellRenderer
}

// CurrentPathString gets the current TreePath string for the currently applied
// TreeIter, this is implicitly updated when gtk_cell_area_apply_attributes() is
// called and can be used to interact with renderers from CellArea subclasses.
func (a cellArea) CurrentPathString() string {
	var _arg0 *C.GtkCellArea // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_cell_area_get_current_path_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// EditWidget gets the CellEditable widget currently used to edit the currently
// edited cell.
func (a cellArea) EditWidget() CellEditable {
	var _arg0 *C.GtkCellArea     // out
	var _cret *C.GtkCellEditable // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_cell_area_get_edit_widget(_arg0)

	var _cellEditable CellEditable // out

	_cellEditable = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(CellEditable)

	return _cellEditable
}

// EditedCell gets the CellRenderer in @area that is currently being edited.
func (a cellArea) EditedCell() CellRenderer {
	var _arg0 *C.GtkCellArea     // out
	var _cret *C.GtkCellRenderer // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_cell_area_get_edited_cell(_arg0)

	var _cellRenderer CellRenderer // out

	_cellRenderer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(CellRenderer)

	return _cellRenderer
}

// FocusCell retrieves the currently focused cell for @area
func (a cellArea) FocusCell() CellRenderer {
	var _arg0 *C.GtkCellArea     // out
	var _cret *C.GtkCellRenderer // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_cell_area_get_focus_cell(_arg0)

	var _cellRenderer CellRenderer // out

	_cellRenderer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(CellRenderer)

	return _cellRenderer
}

// FocusFromSibling gets the CellRenderer which is expected to be focusable for
// which @renderer is, or may be a sibling.
//
// This is handy for CellArea subclasses when handling events, after determining
// the renderer at the event location it can then chose to activate the focus
// cell for which the event cell may have been a sibling.
func (a cellArea) FocusFromSibling(renderer CellRenderer) CellRenderer {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _cret *C.GtkCellRenderer // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))

	_cret = C.gtk_cell_area_get_focus_from_sibling(_arg0, _arg1)

	var _cellRenderer CellRenderer // out

	_cellRenderer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(CellRenderer)

	return _cellRenderer
}

// PreferredHeight retrieves a cell area’s initial minimum and natural height.
//
// @area will store some geometrical information in @context along the way; when
// requesting sizes over an arbitrary number of rows, it’s not important to
// check the @minimum_height and @natural_height of this call but rather to
// consult gtk_cell_area_context_get_preferred_height() after a series of
// requests.
func (a cellArea) PreferredHeight(context CellAreaContext, widget Widget) (minimumHeight int, naturalHeight int) {
	var _arg0 *C.GtkCellArea        // out
	var _arg1 *C.GtkCellAreaContext // out
	var _arg2 *C.GtkWidget          // out
	var _arg3 C.gint                // in
	var _arg4 C.gint                // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_cell_area_get_preferred_height(_arg0, _arg1, _arg2, &_arg3, &_arg4)

	var _minimumHeight int // out
	var _naturalHeight int // out

	_minimumHeight = (int)(_arg3)
	_naturalHeight = (int)(_arg4)

	return _minimumHeight, _naturalHeight
}

// PreferredHeightForWidth retrieves a cell area’s minimum and natural height if
// it would be given the specified @width.
//
// @area stores some geometrical information in @context along the way while
// calling gtk_cell_area_get_preferred_width(). It’s important to perform a
// series of gtk_cell_area_get_preferred_width() requests with @context first
// and then call gtk_cell_area_get_preferred_height_for_width() on each cell
// area individually to get the height for width of each fully requested row.
//
// If at some point, the width of a single row changes, it should be requested
// with gtk_cell_area_get_preferred_width() again and then the full width of the
// requested rows checked again with
// gtk_cell_area_context_get_preferred_width().
func (a cellArea) PreferredHeightForWidth(context CellAreaContext, widget Widget, width int) (minimumHeight int, naturalHeight int) {
	var _arg0 *C.GtkCellArea        // out
	var _arg1 *C.GtkCellAreaContext // out
	var _arg2 *C.GtkWidget          // out
	var _arg3 C.gint                // out
	var _arg4 C.gint                // in
	var _arg5 C.gint                // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg3 = (C.gint)(width)

	C.gtk_cell_area_get_preferred_height_for_width(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)

	var _minimumHeight int // out
	var _naturalHeight int // out

	_minimumHeight = (int)(_arg4)
	_naturalHeight = (int)(_arg5)

	return _minimumHeight, _naturalHeight
}

// PreferredWidth retrieves a cell area’s initial minimum and natural width.
//
// @area will store some geometrical information in @context along the way; when
// requesting sizes over an arbitrary number of rows, it’s not important to
// check the @minimum_width and @natural_width of this call but rather to
// consult gtk_cell_area_context_get_preferred_width() after a series of
// requests.
func (a cellArea) PreferredWidth(context CellAreaContext, widget Widget) (minimumWidth int, naturalWidth int) {
	var _arg0 *C.GtkCellArea        // out
	var _arg1 *C.GtkCellAreaContext // out
	var _arg2 *C.GtkWidget          // out
	var _arg3 C.gint                // in
	var _arg4 C.gint                // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_cell_area_get_preferred_width(_arg0, _arg1, _arg2, &_arg3, &_arg4)

	var _minimumWidth int // out
	var _naturalWidth int // out

	_minimumWidth = (int)(_arg3)
	_naturalWidth = (int)(_arg4)

	return _minimumWidth, _naturalWidth
}

// PreferredWidthForHeight retrieves a cell area’s minimum and natural width if
// it would be given the specified @height.
//
// @area stores some geometrical information in @context along the way while
// calling gtk_cell_area_get_preferred_height(). It’s important to perform a
// series of gtk_cell_area_get_preferred_height() requests with @context first
// and then call gtk_cell_area_get_preferred_width_for_height() on each cell
// area individually to get the height for width of each fully requested row.
//
// If at some point, the height of a single row changes, it should be requested
// with gtk_cell_area_get_preferred_height() again and then the full height of
// the requested rows checked again with
// gtk_cell_area_context_get_preferred_height().
func (a cellArea) PreferredWidthForHeight(context CellAreaContext, widget Widget, height int) (minimumWidth int, naturalWidth int) {
	var _arg0 *C.GtkCellArea        // out
	var _arg1 *C.GtkCellAreaContext // out
	var _arg2 *C.GtkWidget          // out
	var _arg3 C.gint                // out
	var _arg4 C.gint                // in
	var _arg5 C.gint                // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg3 = (C.gint)(height)

	C.gtk_cell_area_get_preferred_width_for_height(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)

	var _minimumWidth int // out
	var _naturalWidth int // out

	_minimumWidth = (int)(_arg4)
	_naturalWidth = (int)(_arg5)

	return _minimumWidth, _naturalWidth
}

// RequestMode gets whether the area prefers a height-for-width layout or a
// width-for-height layout.
func (a cellArea) RequestMode() SizeRequestMode {
	var _arg0 *C.GtkCellArea       // out
	var _cret C.GtkSizeRequestMode // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_cell_area_get_request_mode(_arg0)

	var _sizeRequestMode SizeRequestMode // out

	_sizeRequestMode = SizeRequestMode(_cret)

	return _sizeRequestMode
}

// HasRenderer checks if @area contains @renderer.
func (a cellArea) HasRenderer(renderer CellRenderer) bool {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))

	_cret = C.gtk_cell_area_has_renderer(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InnerCellArea: this is a convenience function for CellArea implementations to
// get the inner area where a given CellRenderer will be rendered. It removes
// any padding previously added by gtk_cell_area_request_renderer().
func (a cellArea) InnerCellArea(widget Widget, cellArea *gdk.Rectangle) gdk.Rectangle {
	var _arg0 *C.GtkCellArea  // out
	var _arg1 *C.GtkWidget    // out
	var _arg2 *C.GdkRectangle // out
	var _innerArea gdk.Rectangle

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))

	C.gtk_cell_area_inner_cell_area(_arg0, _arg1, _arg2, (*C.GdkRectangle)(unsafe.Pointer(&_innerArea)))

	return _innerArea
}

// IsActivatable returns whether the area can do anything when activated, after
// applying new attributes to @area.
func (a cellArea) IsActivatable() bool {
	var _arg0 *C.GtkCellArea // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_cell_area_is_activatable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsFocusSibling returns whether @sibling is one of @renderer’s focus siblings
// (see gtk_cell_area_add_focus_sibling()).
func (a cellArea) IsFocusSibling(renderer CellRenderer, sibling CellRenderer) bool {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 *C.GtkCellRenderer // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	_arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(sibling.Native()))

	_cret = C.gtk_cell_area_is_focus_sibling(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Remove removes @renderer from @area.
func (a cellArea) Remove(renderer CellRenderer) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))

	C.gtk_cell_area_remove(_arg0, _arg1)
}

// RemoveFocusSibling removes @sibling from @renderer’s focus sibling list (see
// gtk_cell_area_add_focus_sibling()).
func (a cellArea) RemoveFocusSibling(renderer CellRenderer, sibling CellRenderer) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 *C.GtkCellRenderer // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	_arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(sibling.Native()))

	C.gtk_cell_area_remove_focus_sibling(_arg0, _arg1, _arg2)
}

// Render renders @area’s cells according to @area’s layout onto @widget at the
// given coordinates.
func (a cellArea) Render(context CellAreaContext, widget Widget, cr *cairo.Context, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState, paintFocus bool) {
	var _arg0 *C.GtkCellArea         // out
	var _arg1 *C.GtkCellAreaContext  // out
	var _arg2 *C.GtkWidget           // out
	var _arg3 *C.cairo_t             // out
	var _arg4 *C.GdkRectangle        // out
	var _arg5 *C.GdkRectangle        // out
	var _arg6 C.GtkCellRendererState // out
	var _arg7 C.gboolean             // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg3 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg4 = (*C.GdkRectangle)(unsafe.Pointer(backgroundArea.Native()))
	_arg5 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))
	_arg6 = (C.GtkCellRendererState)(flags)
	if paintFocus {
		_arg7 = C.TRUE
	}

	C.gtk_cell_area_render(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
}

// RequestRenderer: this is a convenience function for CellArea implementations
// to request size for cell renderers. It’s important to use this function to
// request size and then use gtk_cell_area_inner_cell_area() at render and event
// time since this function will add padding around the cell for focus painting.
func (a cellArea) RequestRenderer(renderer CellRenderer, orientation Orientation, widget Widget, forSize int) (minimumSize int, naturalSize int) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 C.GtkOrientation   // out
	var _arg3 *C.GtkWidget       // out
	var _arg4 C.gint             // out
	var _arg5 C.gint             // in
	var _arg6 C.gint             // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	_arg2 = (C.GtkOrientation)(orientation)
	_arg3 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg4 = (C.gint)(forSize)

	C.gtk_cell_area_request_renderer(_arg0, _arg1, _arg2, _arg3, _arg4, &_arg5, &_arg6)

	var _minimumSize int // out
	var _naturalSize int // out

	_minimumSize = (int)(_arg5)
	_naturalSize = (int)(_arg6)

	return _minimumSize, _naturalSize
}

// SetFocusCell: explicitly sets the currently focused cell to @renderer.
//
// This is generally called by implementations of CellAreaClass.focus() or
// CellAreaClass.event(), however it can also be used to implement functions
// such as gtk_tree_view_set_cursor_on_cell().
func (a cellArea) SetFocusCell(renderer CellRenderer) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))

	C.gtk_cell_area_set_focus_cell(_arg0, _arg1)
}

// StopEditing: explicitly stops the editing of the currently edited cell.
//
// If @canceled is true, the currently edited cell renderer will emit the
// ::editing-canceled signal, otherwise the the ::editing-done signal will be
// emitted on the current edit widget.
//
// See gtk_cell_area_get_edited_cell() and gtk_cell_area_get_edit_widget().
func (a cellArea) StopEditing(canceled bool) {
	var _arg0 *C.GtkCellArea // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	if canceled {
		_arg1 = C.TRUE
	}

	C.gtk_cell_area_stop_editing(_arg0, _arg1)
}

// CellAreaBox: the CellAreaBox renders cell renderers into a row or a column
// depending on its Orientation.
//
// GtkCellAreaBox uses a notion of packing. Packing refers to adding cell
// renderers with reference to a particular position in a CellAreaBox. There are
// two reference positions: the start and the end of the box. When the
// CellAreaBox is oriented in the GTK_ORIENTATION_VERTICAL orientation, the
// start is defined as the top of the box and the end is defined as the bottom.
// In the GTK_ORIENTATION_HORIZONTAL orientation start is defined as the left
// side and the end is defined as the right side.
//
// Alignments of CellRenderers rendered in adjacent rows can be configured by
// configuring the CellAreaBox align child cell property with
// gtk_cell_area_cell_set_property() or by specifying the "align" argument to
// gtk_cell_area_box_pack_start() and gtk_cell_area_box_pack_end().
type CellAreaBox interface {
	CellArea
	Buildable
	CellLayout
	Orientable

	// Spacing gets the spacing added between cell renderers.
	Spacing() int
	// PackEnd adds @renderer to @box, packed with reference to the end of @box.
	//
	// The @renderer is packed after (away from end of) any other CellRenderer
	// packed with reference to the end of @box.
	PackEnd(renderer CellRenderer, expand bool, align bool, fixed bool)
	// PackStart adds @renderer to @box, packed with reference to the start of
	// @box.
	//
	// The @renderer is packed after any other CellRenderer packed with
	// reference to the start of @box.
	PackStart(renderer CellRenderer, expand bool, align bool, fixed bool)
	// SetSpacing sets the spacing to add between cell renderers in @box.
	SetSpacing(spacing int)
}

// cellAreaBox implements the CellAreaBox class.
type cellAreaBox struct {
	CellArea
	Buildable
	CellLayout
	Orientable
}

var _ CellAreaBox = (*cellAreaBox)(nil)

// WrapCellAreaBox wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellAreaBox(obj *externglib.Object) CellAreaBox {
	return cellAreaBox{
		CellArea:   WrapCellArea(obj),
		Buildable:  WrapBuildable(obj),
		CellLayout: WrapCellLayout(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalCellAreaBox(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellAreaBox(obj), nil
}

// NewCellAreaBox creates a new CellAreaBox.
func NewCellAreaBox() CellAreaBox {
	var _cret *C.GtkCellArea // in

	_cret = C.gtk_cell_area_box_new()

	var _cellAreaBox CellAreaBox // out

	_cellAreaBox = WrapCellAreaBox(externglib.Take(unsafe.Pointer(_cret)))

	return _cellAreaBox
}

// Spacing gets the spacing added between cell renderers.
func (b cellAreaBox) Spacing() int {
	var _arg0 *C.GtkCellAreaBox // out
	var _cret C.gint            // in

	_arg0 = (*C.GtkCellAreaBox)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_cell_area_box_get_spacing(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// PackEnd adds @renderer to @box, packed with reference to the end of @box.
//
// The @renderer is packed after (away from end of) any other CellRenderer
// packed with reference to the end of @box.
func (b cellAreaBox) PackEnd(renderer CellRenderer, expand bool, align bool, fixed bool) {
	var _arg0 *C.GtkCellAreaBox  // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 C.gboolean         // out
	var _arg3 C.gboolean         // out
	var _arg4 C.gboolean         // out

	_arg0 = (*C.GtkCellAreaBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	if expand {
		_arg2 = C.TRUE
	}
	if align {
		_arg3 = C.TRUE
	}
	if fixed {
		_arg4 = C.TRUE
	}

	C.gtk_cell_area_box_pack_end(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// PackStart adds @renderer to @box, packed with reference to the start of @box.
//
// The @renderer is packed after any other CellRenderer packed with reference to
// the start of @box.
func (b cellAreaBox) PackStart(renderer CellRenderer, expand bool, align bool, fixed bool) {
	var _arg0 *C.GtkCellAreaBox  // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 C.gboolean         // out
	var _arg3 C.gboolean         // out
	var _arg4 C.gboolean         // out

	_arg0 = (*C.GtkCellAreaBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	if expand {
		_arg2 = C.TRUE
	}
	if align {
		_arg3 = C.TRUE
	}
	if fixed {
		_arg4 = C.TRUE
	}

	C.gtk_cell_area_box_pack_start(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// SetSpacing sets the spacing to add between cell renderers in @box.
func (b cellAreaBox) SetSpacing(spacing int) {
	var _arg0 *C.GtkCellAreaBox // out
	var _arg1 C.gint            // out

	_arg0 = (*C.GtkCellAreaBox)(unsafe.Pointer(b.Native()))
	_arg1 = (C.gint)(spacing)

	C.gtk_cell_area_box_set_spacing(_arg0, _arg1)
}

// CellAreaContext: the CellAreaContext object is created by a given CellArea
// implementation via its CellAreaClass.create_context() virtual method and is
// used to store cell sizes and alignments for a series of TreeModel rows that
// are requested and rendered in the same context.
//
// CellLayout widgets can create any number of contexts in which to request and
// render groups of data rows. However, it’s important that the same context
// which was used to request sizes for a given TreeModel row also be used for
// the same row when calling other CellArea APIs such as gtk_cell_area_render()
// and gtk_cell_area_event().
type CellAreaContext interface {
	gextras.Objector

	// Allocate allocates a width and/or a height for all rows which are to be
	// rendered with @context.
	//
	// Usually allocation is performed only horizontally or sometimes vertically
	// since a group of rows are usually rendered side by side vertically or
	// horizontally and share either the same width or the same height.
	// Sometimes they are allocated in both horizontal and vertical orientations
	// producing a homogeneous effect of the rows. This is generally the case
	// for TreeView when TreeView:fixed-height-mode is enabled.
	//
	// Since 3.0
	Allocate(width int, height int)
	// Allocation fetches the current allocation size for @context.
	//
	// If the context was not allocated in width or height, or if the context
	// was recently reset with gtk_cell_area_context_reset(), the returned value
	// will be -1.
	Allocation() (width int, height int)
	// Area fetches the CellArea this @context was created by.
	//
	// This is generally unneeded by layouting widgets; however, it is important
	// for the context implementation itself to fetch information about the area
	// it is being used for.
	//
	// For instance at CellAreaContextClass.allocate() time it’s important to
	// know details about any cell spacing that the CellArea is configured with
	// in order to compute a proper allocation.
	Area() CellArea
	// PreferredHeight gets the accumulative preferred height for all rows which
	// have been requested with this context.
	//
	// After gtk_cell_area_context_reset() is called and/or before ever
	// requesting the size of a CellArea, the returned values are 0.
	PreferredHeight() (minimumHeight int, naturalHeight int)
	// PreferredHeightForWidth gets the accumulative preferred height for @width
	// for all rows which have been requested for the same said @width with this
	// context.
	//
	// After gtk_cell_area_context_reset() is called and/or before ever
	// requesting the size of a CellArea, the returned values are -1.
	PreferredHeightForWidth(width int) (minimumHeight int, naturalHeight int)
	// PreferredWidth gets the accumulative preferred width for all rows which
	// have been requested with this context.
	//
	// After gtk_cell_area_context_reset() is called and/or before ever
	// requesting the size of a CellArea, the returned values are 0.
	PreferredWidth() (minimumWidth int, naturalWidth int)
	// PreferredWidthForHeight gets the accumulative preferred width for @height
	// for all rows which have been requested for the same said @height with
	// this context.
	//
	// After gtk_cell_area_context_reset() is called and/or before ever
	// requesting the size of a CellArea, the returned values are -1.
	PreferredWidthForHeight(height int) (minimumWidth int, naturalWidth int)
	// PushPreferredHeight causes the minimum and/or natural height to grow if
	// the new proposed sizes exceed the current minimum and natural height.
	//
	// This is used by CellAreaContext implementations during the request
	// process over a series of TreeModel rows to progressively push the
	// requested height over a series of gtk_cell_area_get_preferred_height()
	// requests.
	PushPreferredHeight(minimumHeight int, naturalHeight int)
	// PushPreferredWidth causes the minimum and/or natural width to grow if the
	// new proposed sizes exceed the current minimum and natural width.
	//
	// This is used by CellAreaContext implementations during the request
	// process over a series of TreeModel rows to progressively push the
	// requested width over a series of gtk_cell_area_get_preferred_width()
	// requests.
	PushPreferredWidth(minimumWidth int, naturalWidth int)
	// Reset resets any previously cached request and allocation data.
	//
	// When underlying TreeModel data changes its important to reset the context
	// if the content size is allowed to shrink. If the content size is only
	// allowed to grow (this is usually an option for views rendering large data
	// stores as a measure of optimization), then only the row that changed or
	// was inserted needs to be (re)requested with
	// gtk_cell_area_get_preferred_width().
	//
	// When the new overall size of the context requires that the allocated size
	// changes (or whenever this allocation changes at all), the variable row
	// sizes need to be re-requested for every row.
	//
	// For instance, if the rows are displayed all with the same width from top
	// to bottom then a change in the allocated width necessitates a
	// recalculation of all the displayed row heights using
	// gtk_cell_area_get_preferred_height_for_width().
	//
	// Since 3.0
	Reset()
}

// cellAreaContext implements the CellAreaContext class.
type cellAreaContext struct {
	gextras.Objector
}

var _ CellAreaContext = (*cellAreaContext)(nil)

// WrapCellAreaContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellAreaContext(obj *externglib.Object) CellAreaContext {
	return cellAreaContext{
		Objector: obj,
	}
}

func marshalCellAreaContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellAreaContext(obj), nil
}

// Allocate allocates a width and/or a height for all rows which are to be
// rendered with @context.
//
// Usually allocation is performed only horizontally or sometimes vertically
// since a group of rows are usually rendered side by side vertically or
// horizontally and share either the same width or the same height. Sometimes
// they are allocated in both horizontal and vertical orientations producing a
// homogeneous effect of the rows. This is generally the case for TreeView when
// TreeView:fixed-height-mode is enabled.
//
// Since 3.0
func (c cellAreaContext) Allocate(width int, height int) {
	var _arg0 *C.GtkCellAreaContext // out
	var _arg1 C.gint                // out
	var _arg2 C.gint                // out

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))
	_arg1 = (C.gint)(width)
	_arg2 = (C.gint)(height)

	C.gtk_cell_area_context_allocate(_arg0, _arg1, _arg2)
}

// Allocation fetches the current allocation size for @context.
//
// If the context was not allocated in width or height, or if the context was
// recently reset with gtk_cell_area_context_reset(), the returned value will be
// -1.
func (c cellAreaContext) Allocation() (width int, height int) {
	var _arg0 *C.GtkCellAreaContext // out
	var _arg1 C.gint                // in
	var _arg2 C.gint                // in

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))

	C.gtk_cell_area_context_get_allocation(_arg0, &_arg1, &_arg2)

	var _width int  // out
	var _height int // out

	_width = (int)(_arg1)
	_height = (int)(_arg2)

	return _width, _height
}

// Area fetches the CellArea this @context was created by.
//
// This is generally unneeded by layouting widgets; however, it is important for
// the context implementation itself to fetch information about the area it is
// being used for.
//
// For instance at CellAreaContextClass.allocate() time it’s important to know
// details about any cell spacing that the CellArea is configured with in order
// to compute a proper allocation.
func (c cellAreaContext) Area() CellArea {
	var _arg0 *C.GtkCellAreaContext // out
	var _cret *C.GtkCellArea        // in

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_cell_area_context_get_area(_arg0)

	var _cellArea CellArea // out

	_cellArea = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(CellArea)

	return _cellArea
}

// PreferredHeight gets the accumulative preferred height for all rows which
// have been requested with this context.
//
// After gtk_cell_area_context_reset() is called and/or before ever requesting
// the size of a CellArea, the returned values are 0.
func (c cellAreaContext) PreferredHeight() (minimumHeight int, naturalHeight int) {
	var _arg0 *C.GtkCellAreaContext // out
	var _arg1 C.gint                // in
	var _arg2 C.gint                // in

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))

	C.gtk_cell_area_context_get_preferred_height(_arg0, &_arg1, &_arg2)

	var _minimumHeight int // out
	var _naturalHeight int // out

	_minimumHeight = (int)(_arg1)
	_naturalHeight = (int)(_arg2)

	return _minimumHeight, _naturalHeight
}

// PreferredHeightForWidth gets the accumulative preferred height for @width for
// all rows which have been requested for the same said @width with this
// context.
//
// After gtk_cell_area_context_reset() is called and/or before ever requesting
// the size of a CellArea, the returned values are -1.
func (c cellAreaContext) PreferredHeightForWidth(width int) (minimumHeight int, naturalHeight int) {
	var _arg0 *C.GtkCellAreaContext // out
	var _arg1 C.gint                // out
	var _arg2 C.gint                // in
	var _arg3 C.gint                // in

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))
	_arg1 = (C.gint)(width)

	C.gtk_cell_area_context_get_preferred_height_for_width(_arg0, _arg1, &_arg2, &_arg3)

	var _minimumHeight int // out
	var _naturalHeight int // out

	_minimumHeight = (int)(_arg2)
	_naturalHeight = (int)(_arg3)

	return _minimumHeight, _naturalHeight
}

// PreferredWidth gets the accumulative preferred width for all rows which have
// been requested with this context.
//
// After gtk_cell_area_context_reset() is called and/or before ever requesting
// the size of a CellArea, the returned values are 0.
func (c cellAreaContext) PreferredWidth() (minimumWidth int, naturalWidth int) {
	var _arg0 *C.GtkCellAreaContext // out
	var _arg1 C.gint                // in
	var _arg2 C.gint                // in

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))

	C.gtk_cell_area_context_get_preferred_width(_arg0, &_arg1, &_arg2)

	var _minimumWidth int // out
	var _naturalWidth int // out

	_minimumWidth = (int)(_arg1)
	_naturalWidth = (int)(_arg2)

	return _minimumWidth, _naturalWidth
}

// PreferredWidthForHeight gets the accumulative preferred width for @height for
// all rows which have been requested for the same said @height with this
// context.
//
// After gtk_cell_area_context_reset() is called and/or before ever requesting
// the size of a CellArea, the returned values are -1.
func (c cellAreaContext) PreferredWidthForHeight(height int) (minimumWidth int, naturalWidth int) {
	var _arg0 *C.GtkCellAreaContext // out
	var _arg1 C.gint                // out
	var _arg2 C.gint                // in
	var _arg3 C.gint                // in

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))
	_arg1 = (C.gint)(height)

	C.gtk_cell_area_context_get_preferred_width_for_height(_arg0, _arg1, &_arg2, &_arg3)

	var _minimumWidth int // out
	var _naturalWidth int // out

	_minimumWidth = (int)(_arg2)
	_naturalWidth = (int)(_arg3)

	return _minimumWidth, _naturalWidth
}

// PushPreferredHeight causes the minimum and/or natural height to grow if the
// new proposed sizes exceed the current minimum and natural height.
//
// This is used by CellAreaContext implementations during the request process
// over a series of TreeModel rows to progressively push the requested height
// over a series of gtk_cell_area_get_preferred_height() requests.
func (c cellAreaContext) PushPreferredHeight(minimumHeight int, naturalHeight int) {
	var _arg0 *C.GtkCellAreaContext // out
	var _arg1 C.gint                // out
	var _arg2 C.gint                // out

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))
	_arg1 = (C.gint)(minimumHeight)
	_arg2 = (C.gint)(naturalHeight)

	C.gtk_cell_area_context_push_preferred_height(_arg0, _arg1, _arg2)
}

// PushPreferredWidth causes the minimum and/or natural width to grow if the new
// proposed sizes exceed the current minimum and natural width.
//
// This is used by CellAreaContext implementations during the request process
// over a series of TreeModel rows to progressively push the requested width
// over a series of gtk_cell_area_get_preferred_width() requests.
func (c cellAreaContext) PushPreferredWidth(minimumWidth int, naturalWidth int) {
	var _arg0 *C.GtkCellAreaContext // out
	var _arg1 C.gint                // out
	var _arg2 C.gint                // out

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))
	_arg1 = (C.gint)(minimumWidth)
	_arg2 = (C.gint)(naturalWidth)

	C.gtk_cell_area_context_push_preferred_width(_arg0, _arg1, _arg2)
}

// Reset resets any previously cached request and allocation data.
//
// When underlying TreeModel data changes its important to reset the context if
// the content size is allowed to shrink. If the content size is only allowed to
// grow (this is usually an option for views rendering large data stores as a
// measure of optimization), then only the row that changed or was inserted
// needs to be (re)requested with gtk_cell_area_get_preferred_width().
//
// When the new overall size of the context requires that the allocated size
// changes (or whenever this allocation changes at all), the variable row sizes
// need to be re-requested for every row.
//
// For instance, if the rows are displayed all with the same width from top to
// bottom then a change in the allocated width necessitates a recalculation of
// all the displayed row heights using
// gtk_cell_area_get_preferred_height_for_width().
//
// Since 3.0
func (c cellAreaContext) Reset() {
	var _arg0 *C.GtkCellAreaContext // out

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))

	C.gtk_cell_area_context_reset(_arg0)
}

// CellRenderer: the CellRenderer is a base class of a set of objects used for
// rendering a cell to a #cairo_t. These objects are used primarily by the
// TreeView widget, though they aren’t tied to them in any specific way. It is
// worth noting that CellRenderer is not a Widget and cannot be treated as such.
//
// The primary use of a CellRenderer is for drawing a certain graphical elements
// on a #cairo_t. Typically, one cell renderer is used to draw many cells on the
// screen. To this extent, it isn’t expected that a CellRenderer keep any
// permanent state around. Instead, any state is set just prior to use using
// #GObjects property system. Then, the cell is measured using
// gtk_cell_renderer_get_size(). Finally, the cell is rendered in the correct
// location using gtk_cell_renderer_render().
//
// There are a number of rules that must be followed when writing a new
// CellRenderer. First and foremost, it’s important that a certain set of
// properties will always yield a cell renderer of the same size, barring a
// Style change. The CellRenderer also has a number of generic properties that
// are expected to be honored by all children.
//
// Beyond merely rendering a cell, cell renderers can optionally provide active
// user interface elements. A cell renderer can be “activatable” like
// CellRendererToggle, which toggles when it gets activated by a mouse click, or
// it can be “editable” like CellRendererText, which allows the user to edit the
// text using a widget implementing the CellEditable interface, e.g. Entry. To
// make a cell renderer activatable or editable, you have to implement the
// CellRendererClass.activate or CellRendererClass.start_editing virtual
// functions, respectively.
//
// Many properties of CellRenderer and its subclasses have a corresponding “set”
// property, e.g. “cell-background-set” corresponds to “cell-background”. These
// “set” properties reflect whether a property has been set or not. You should
// not set them independently.
type CellRenderer interface {
	gextras.Objector

	// AlignedArea gets the aligned area used by @cell inside @cell_area. Used
	// for finding the appropriate edit and focus rectangle.
	AlignedArea(widget Widget, flags CellRendererState, cellArea *gdk.Rectangle) gdk.Rectangle
	// Alignment fills in @xalign and @yalign with the appropriate values of
	// @cell.
	Alignment() (xalign float32, yalign float32)
	// FixedSize fills in @width and @height with the appropriate size of @cell.
	FixedSize() (width int, height int)
	// Padding fills in @xpad and @ypad with the appropriate values of @cell.
	Padding() (xpad int, ypad int)
	// PreferredHeight retreives a renderer’s natural size when rendered to
	// @widget.
	PreferredHeight(widget Widget) (minimumSize int, naturalSize int)
	// PreferredHeightForWidth retreives a cell renderers’s minimum and natural
	// height if it were rendered to @widget with the specified @width.
	PreferredHeightForWidth(widget Widget, width int) (minimumHeight int, naturalHeight int)
	// PreferredSize retrieves the minimum and natural size of a cell taking
	// into account the widget’s preference for height-for-width management.
	PreferredSize(widget Widget) (minimumSize Requisition, naturalSize Requisition)
	// PreferredWidth retreives a renderer’s natural size when rendered to
	// @widget.
	PreferredWidth(widget Widget) (minimumSize int, naturalSize int)
	// PreferredWidthForHeight retreives a cell renderers’s minimum and natural
	// width if it were rendered to @widget with the specified @height.
	PreferredWidthForHeight(widget Widget, height int) (minimumWidth int, naturalWidth int)
	// RequestMode gets whether the cell renderer prefers a height-for-width
	// layout or a width-for-height layout.
	RequestMode() SizeRequestMode
	// Sensitive returns the cell renderer’s sensitivity.
	Sensitive() bool
	// Size obtains the width and height needed to render the cell. Used by view
	// widgets to determine the appropriate size for the cell_area passed to
	// gtk_cell_renderer_render(). If @cell_area is not nil, fills in the x and
	// y offsets (if set) of the cell relative to this location.
	//
	// Please note that the values set in @width and @height, as well as those
	// in @x_offset and @y_offset are inclusive of the xpad and ypad properties.
	Size(widget Widget, cellArea *gdk.Rectangle) (xOffset int, yOffset int, width int, height int)
	// State translates the cell renderer state to StateFlags, based on the cell
	// renderer and widget sensitivity, and the given CellRendererState.
	State(widget Widget, cellState CellRendererState) StateFlags
	// Visible returns the cell renderer’s visibility.
	Visible() bool
	// IsActivatable checks whether the cell renderer can do something when
	// activated.
	IsActivatable() bool
	// Render invokes the virtual render function of the CellRenderer. The three
	// passed-in rectangles are areas in @cr. Most renderers will draw within
	// @cell_area; the xalign, yalign, xpad, and ypad fields of the CellRenderer
	// should be honored with respect to @cell_area. @background_area includes
	// the blank space around the cell, and also the area containing the tree
	// expander; so the @background_area rectangles for all cells tile to cover
	// the entire @window.
	Render(cr *cairo.Context, widget Widget, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState)
	// SetAlignment sets the renderer’s alignment within its available space.
	SetAlignment(xalign float32, yalign float32)
	// SetFixedSize sets the renderer size to be explicit, independent of the
	// properties set.
	SetFixedSize(width int, height int)
	// SetPadding sets the renderer’s padding.
	SetPadding(xpad int, ypad int)
	// SetSensitive sets the cell renderer’s sensitivity.
	SetSensitive(sensitive bool)
	// SetVisible sets the cell renderer’s visibility.
	SetVisible(visible bool)
	// StopEditing informs the cell renderer that the editing is stopped. If
	// @canceled is true, the cell renderer will emit the
	// CellRenderer::editing-canceled signal.
	//
	// This function should be called by cell renderer implementations in
	// response to the CellEditable::editing-done signal of CellEditable.
	StopEditing(canceled bool)
}

// cellRenderer implements the CellRenderer class.
type cellRenderer struct {
	gextras.Objector
}

var _ CellRenderer = (*cellRenderer)(nil)

// WrapCellRenderer wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRenderer(obj *externglib.Object) CellRenderer {
	return cellRenderer{
		Objector: obj,
	}
}

func marshalCellRenderer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRenderer(obj), nil
}

// AlignedArea gets the aligned area used by @cell inside @cell_area. Used for
// finding the appropriate edit and focus rectangle.
func (c cellRenderer) AlignedArea(widget Widget, flags CellRendererState, cellArea *gdk.Rectangle) gdk.Rectangle {
	var _arg0 *C.GtkCellRenderer     // out
	var _arg1 *C.GtkWidget           // out
	var _arg2 C.GtkCellRendererState // out
	var _arg3 *C.GdkRectangle        // out
	var _alignedArea gdk.Rectangle

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (C.GtkCellRendererState)(flags)
	_arg3 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))

	C.gtk_cell_renderer_get_aligned_area(_arg0, _arg1, _arg2, _arg3, (*C.GdkRectangle)(unsafe.Pointer(&_alignedArea)))

	return _alignedArea
}

// Alignment fills in @xalign and @yalign with the appropriate values of @cell.
func (c cellRenderer) Alignment() (xalign float32, yalign float32) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 C.gfloat           // in
	var _arg2 C.gfloat           // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))

	C.gtk_cell_renderer_get_alignment(_arg0, &_arg1, &_arg2)

	var _xalign float32 // out
	var _yalign float32 // out

	_xalign = (float32)(_arg1)
	_yalign = (float32)(_arg2)

	return _xalign, _yalign
}

// FixedSize fills in @width and @height with the appropriate size of @cell.
func (c cellRenderer) FixedSize() (width int, height int) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 C.gint             // in
	var _arg2 C.gint             // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))

	C.gtk_cell_renderer_get_fixed_size(_arg0, &_arg1, &_arg2)

	var _width int  // out
	var _height int // out

	_width = (int)(_arg1)
	_height = (int)(_arg2)

	return _width, _height
}

// Padding fills in @xpad and @ypad with the appropriate values of @cell.
func (c cellRenderer) Padding() (xpad int, ypad int) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 C.gint             // in
	var _arg2 C.gint             // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))

	C.gtk_cell_renderer_get_padding(_arg0, &_arg1, &_arg2)

	var _xpad int // out
	var _ypad int // out

	_xpad = (int)(_arg1)
	_ypad = (int)(_arg2)

	return _xpad, _ypad
}

// PreferredHeight retreives a renderer’s natural size when rendered to @widget.
func (c cellRenderer) PreferredHeight(widget Widget) (minimumSize int, naturalSize int) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 *C.GtkWidget       // out
	var _arg2 C.gint             // in
	var _arg3 C.gint             // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_cell_renderer_get_preferred_height(_arg0, _arg1, &_arg2, &_arg3)

	var _minimumSize int // out
	var _naturalSize int // out

	_minimumSize = (int)(_arg2)
	_naturalSize = (int)(_arg3)

	return _minimumSize, _naturalSize
}

// PreferredHeightForWidth retreives a cell renderers’s minimum and natural
// height if it were rendered to @widget with the specified @width.
func (c cellRenderer) PreferredHeightForWidth(widget Widget, width int) (minimumHeight int, naturalHeight int) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 *C.GtkWidget       // out
	var _arg2 C.gint             // out
	var _arg3 C.gint             // in
	var _arg4 C.gint             // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (C.gint)(width)

	C.gtk_cell_renderer_get_preferred_height_for_width(_arg0, _arg1, _arg2, &_arg3, &_arg4)

	var _minimumHeight int // out
	var _naturalHeight int // out

	_minimumHeight = (int)(_arg3)
	_naturalHeight = (int)(_arg4)

	return _minimumHeight, _naturalHeight
}

// PreferredSize retrieves the minimum and natural size of a cell taking into
// account the widget’s preference for height-for-width management.
func (c cellRenderer) PreferredSize(widget Widget) (minimumSize Requisition, naturalSize Requisition) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 *C.GtkWidget       // out
	var _minimumSize Requisition
	var _naturalSize Requisition

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_cell_renderer_get_preferred_size(_arg0, _arg1, (*C.GtkRequisition)(unsafe.Pointer(&_minimumSize)), (*C.GtkRequisition)(unsafe.Pointer(&_naturalSize)))

	return _minimumSize, _naturalSize
}

// PreferredWidth retreives a renderer’s natural size when rendered to @widget.
func (c cellRenderer) PreferredWidth(widget Widget) (minimumSize int, naturalSize int) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 *C.GtkWidget       // out
	var _arg2 C.gint             // in
	var _arg3 C.gint             // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_cell_renderer_get_preferred_width(_arg0, _arg1, &_arg2, &_arg3)

	var _minimumSize int // out
	var _naturalSize int // out

	_minimumSize = (int)(_arg2)
	_naturalSize = (int)(_arg3)

	return _minimumSize, _naturalSize
}

// PreferredWidthForHeight retreives a cell renderers’s minimum and natural
// width if it were rendered to @widget with the specified @height.
func (c cellRenderer) PreferredWidthForHeight(widget Widget, height int) (minimumWidth int, naturalWidth int) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 *C.GtkWidget       // out
	var _arg2 C.gint             // out
	var _arg3 C.gint             // in
	var _arg4 C.gint             // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (C.gint)(height)

	C.gtk_cell_renderer_get_preferred_width_for_height(_arg0, _arg1, _arg2, &_arg3, &_arg4)

	var _minimumWidth int // out
	var _naturalWidth int // out

	_minimumWidth = (int)(_arg3)
	_naturalWidth = (int)(_arg4)

	return _minimumWidth, _naturalWidth
}

// RequestMode gets whether the cell renderer prefers a height-for-width layout
// or a width-for-height layout.
func (c cellRenderer) RequestMode() SizeRequestMode {
	var _arg0 *C.GtkCellRenderer   // out
	var _cret C.GtkSizeRequestMode // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_cell_renderer_get_request_mode(_arg0)

	var _sizeRequestMode SizeRequestMode // out

	_sizeRequestMode = SizeRequestMode(_cret)

	return _sizeRequestMode
}

// Sensitive returns the cell renderer’s sensitivity.
func (c cellRenderer) Sensitive() bool {
	var _arg0 *C.GtkCellRenderer // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_cell_renderer_get_sensitive(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Size obtains the width and height needed to render the cell. Used by view
// widgets to determine the appropriate size for the cell_area passed to
// gtk_cell_renderer_render(). If @cell_area is not nil, fills in the x and y
// offsets (if set) of the cell relative to this location.
//
// Please note that the values set in @width and @height, as well as those in
// @x_offset and @y_offset are inclusive of the xpad and ypad properties.
func (c cellRenderer) Size(widget Widget, cellArea *gdk.Rectangle) (xOffset int, yOffset int, width int, height int) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 *C.GtkWidget       // out
	var _arg2 *C.GdkRectangle    // out
	var _arg3 C.gint             // in
	var _arg4 C.gint             // in
	var _arg5 C.gint             // in
	var _arg6 C.gint             // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))

	C.gtk_cell_renderer_get_size(_arg0, _arg1, _arg2, &_arg3, &_arg4, &_arg5, &_arg6)

	var _xOffset int // out
	var _yOffset int // out
	var _width int   // out
	var _height int  // out

	_xOffset = (int)(_arg3)
	_yOffset = (int)(_arg4)
	_width = (int)(_arg5)
	_height = (int)(_arg6)

	return _xOffset, _yOffset, _width, _height
}

// State translates the cell renderer state to StateFlags, based on the cell
// renderer and widget sensitivity, and the given CellRendererState.
func (c cellRenderer) State(widget Widget, cellState CellRendererState) StateFlags {
	var _arg0 *C.GtkCellRenderer     // out
	var _arg1 *C.GtkWidget           // out
	var _arg2 C.GtkCellRendererState // out
	var _cret C.GtkStateFlags        // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (C.GtkCellRendererState)(cellState)

	_cret = C.gtk_cell_renderer_get_state(_arg0, _arg1, _arg2)

	var _stateFlags StateFlags // out

	_stateFlags = StateFlags(_cret)

	return _stateFlags
}

// Visible returns the cell renderer’s visibility.
func (c cellRenderer) Visible() bool {
	var _arg0 *C.GtkCellRenderer // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_cell_renderer_get_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsActivatable checks whether the cell renderer can do something when
// activated.
func (c cellRenderer) IsActivatable() bool {
	var _arg0 *C.GtkCellRenderer // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_cell_renderer_is_activatable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Render invokes the virtual render function of the CellRenderer. The three
// passed-in rectangles are areas in @cr. Most renderers will draw within
// @cell_area; the xalign, yalign, xpad, and ypad fields of the CellRenderer
// should be honored with respect to @cell_area. @background_area includes the
// blank space around the cell, and also the area containing the tree expander;
// so the @background_area rectangles for all cells tile to cover the entire
// @window.
func (c cellRenderer) Render(cr *cairo.Context, widget Widget, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState) {
	var _arg0 *C.GtkCellRenderer     // out
	var _arg1 *C.cairo_t             // out
	var _arg2 *C.GtkWidget           // out
	var _arg3 *C.GdkRectangle        // out
	var _arg4 *C.GdkRectangle        // out
	var _arg5 C.GtkCellRendererState // out

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg3 = (*C.GdkRectangle)(unsafe.Pointer(backgroundArea.Native()))
	_arg4 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))
	_arg5 = (C.GtkCellRendererState)(flags)

	C.gtk_cell_renderer_render(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}

// SetAlignment sets the renderer’s alignment within its available space.
func (c cellRenderer) SetAlignment(xalign float32, yalign float32) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 C.gfloat           // out
	var _arg2 C.gfloat           // out

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
	_arg1 = (C.gfloat)(xalign)
	_arg2 = (C.gfloat)(yalign)

	C.gtk_cell_renderer_set_alignment(_arg0, _arg1, _arg2)
}

// SetFixedSize sets the renderer size to be explicit, independent of the
// properties set.
func (c cellRenderer) SetFixedSize(width int, height int) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 C.gint             // out
	var _arg2 C.gint             // out

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
	_arg1 = (C.gint)(width)
	_arg2 = (C.gint)(height)

	C.gtk_cell_renderer_set_fixed_size(_arg0, _arg1, _arg2)
}

// SetPadding sets the renderer’s padding.
func (c cellRenderer) SetPadding(xpad int, ypad int) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 C.gint             // out
	var _arg2 C.gint             // out

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
	_arg1 = (C.gint)(xpad)
	_arg2 = (C.gint)(ypad)

	C.gtk_cell_renderer_set_padding(_arg0, _arg1, _arg2)
}

// SetSensitive sets the cell renderer’s sensitivity.
func (c cellRenderer) SetSensitive(sensitive bool) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
	if sensitive {
		_arg1 = C.TRUE
	}

	C.gtk_cell_renderer_set_sensitive(_arg0, _arg1)
}

// SetVisible sets the cell renderer’s visibility.
func (c cellRenderer) SetVisible(visible bool) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
	if visible {
		_arg1 = C.TRUE
	}

	C.gtk_cell_renderer_set_visible(_arg0, _arg1)
}

// StopEditing informs the cell renderer that the editing is stopped. If
// @canceled is true, the cell renderer will emit the
// CellRenderer::editing-canceled signal.
//
// This function should be called by cell renderer implementations in response
// to the CellEditable::editing-done signal of CellEditable.
func (c cellRenderer) StopEditing(canceled bool) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
	if canceled {
		_arg1 = C.TRUE
	}

	C.gtk_cell_renderer_stop_editing(_arg0, _arg1)
}

// CellRendererAccel displays a keyboard accelerator (i.e. a key combination
// like `Control + a`). If the cell renderer is editable, the accelerator can be
// changed by simply typing the new combination.
//
// The CellRendererAccel cell renderer was added in GTK+ 2.10.
type CellRendererAccel interface {
	CellRendererText
}

// cellRendererAccel implements the CellRendererAccel class.
type cellRendererAccel struct {
	CellRendererText
}

var _ CellRendererAccel = (*cellRendererAccel)(nil)

// WrapCellRendererAccel wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererAccel(obj *externglib.Object) CellRendererAccel {
	return cellRendererAccel{
		CellRendererText: WrapCellRendererText(obj),
	}
}

func marshalCellRendererAccel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererAccel(obj), nil
}

// NewCellRendererAccel creates a new CellRendererAccel.
func NewCellRendererAccel() CellRendererAccel {
	var _cret *C.GtkCellRenderer // in

	_cret = C.gtk_cell_renderer_accel_new()

	var _cellRendererAccel CellRendererAccel // out

	_cellRendererAccel = WrapCellRendererAccel(externglib.Take(unsafe.Pointer(_cret)))

	return _cellRendererAccel
}

// CellRendererCombo renders text in a cell like CellRendererText from which it
// is derived. But while CellRendererText offers a simple entry to edit the
// text, CellRendererCombo offers a ComboBox widget to edit the text. The values
// to display in the combo box are taken from the tree model specified in the
// CellRendererCombo:model property.
//
// The combo cell renderer takes care of adding a text cell renderer to the
// combo box and sets it to display the column specified by its
// CellRendererCombo:text-column property. Further properties of the combo box
// can be set in a handler for the CellRenderer::editing-started signal.
//
// The CellRendererCombo cell renderer was added in GTK+ 2.6.
type CellRendererCombo interface {
	CellRendererText
}

// cellRendererCombo implements the CellRendererCombo class.
type cellRendererCombo struct {
	CellRendererText
}

var _ CellRendererCombo = (*cellRendererCombo)(nil)

// WrapCellRendererCombo wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererCombo(obj *externglib.Object) CellRendererCombo {
	return cellRendererCombo{
		CellRendererText: WrapCellRendererText(obj),
	}
}

func marshalCellRendererCombo(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererCombo(obj), nil
}

// NewCellRendererCombo creates a new CellRendererCombo. Adjust how text is
// drawn using object properties. Object properties can be set globally (with
// g_object_set()). Also, with TreeViewColumn, you can bind a property to a
// value in a TreeModel. For example, you can bind the “text” property on the
// cell renderer to a string value in the model, thus rendering a different
// string in each row of the TreeView.
func NewCellRendererCombo() CellRendererCombo {
	var _cret *C.GtkCellRenderer // in

	_cret = C.gtk_cell_renderer_combo_new()

	var _cellRendererCombo CellRendererCombo // out

	_cellRendererCombo = WrapCellRendererCombo(externglib.Take(unsafe.Pointer(_cret)))

	return _cellRendererCombo
}

// CellRendererPixbuf: a CellRendererPixbuf can be used to render an image in a
// cell. It allows to render either a given Pixbuf (set via the
// CellRendererPixbuf:pixbuf property) or a named icon (set via the
// CellRendererPixbuf:icon-name property).
//
// To support the tree view, CellRendererPixbuf also supports rendering two
// alternative pixbufs, when the CellRenderer:is-expander property is true. If
// the CellRenderer:is-expanded property is true and the
// CellRendererPixbuf:pixbuf-expander-open property is set to a pixbuf, it
// renders that pixbuf, if the CellRenderer:is-expanded property is false and
// the CellRendererPixbuf:pixbuf-expander-closed property is set to a pixbuf, it
// renders that one.
type CellRendererPixbuf interface {
	CellRenderer
}

// cellRendererPixbuf implements the CellRendererPixbuf class.
type cellRendererPixbuf struct {
	CellRenderer
}

var _ CellRendererPixbuf = (*cellRendererPixbuf)(nil)

// WrapCellRendererPixbuf wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererPixbuf(obj *externglib.Object) CellRendererPixbuf {
	return cellRendererPixbuf{
		CellRenderer: WrapCellRenderer(obj),
	}
}

func marshalCellRendererPixbuf(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererPixbuf(obj), nil
}

// NewCellRendererPixbuf creates a new CellRendererPixbuf. Adjust rendering
// parameters using object properties. Object properties can be set globally
// (with g_object_set()). Also, with TreeViewColumn, you can bind a property to
// a value in a TreeModel. For example, you can bind the “pixbuf” property on
// the cell renderer to a pixbuf value in the model, thus rendering a different
// image in each row of the TreeView.
func NewCellRendererPixbuf() CellRendererPixbuf {
	var _cret *C.GtkCellRenderer // in

	_cret = C.gtk_cell_renderer_pixbuf_new()

	var _cellRendererPixbuf CellRendererPixbuf // out

	_cellRendererPixbuf = WrapCellRendererPixbuf(externglib.Take(unsafe.Pointer(_cret)))

	return _cellRendererPixbuf
}

// CellRendererProgress renders a numeric value as a progress par in a cell.
// Additionally, it can display a text on top of the progress bar.
//
// The CellRendererProgress cell renderer was added in GTK+ 2.6.
type CellRendererProgress interface {
	CellRenderer
	Orientable
}

// cellRendererProgress implements the CellRendererProgress class.
type cellRendererProgress struct {
	CellRenderer
	Orientable
}

var _ CellRendererProgress = (*cellRendererProgress)(nil)

// WrapCellRendererProgress wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererProgress(obj *externglib.Object) CellRendererProgress {
	return cellRendererProgress{
		CellRenderer: WrapCellRenderer(obj),
		Orientable:   WrapOrientable(obj),
	}
}

func marshalCellRendererProgress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererProgress(obj), nil
}

// NewCellRendererProgress creates a new CellRendererProgress.
func NewCellRendererProgress() CellRendererProgress {
	var _cret *C.GtkCellRenderer // in

	_cret = C.gtk_cell_renderer_progress_new()

	var _cellRendererProgress CellRendererProgress // out

	_cellRendererProgress = WrapCellRendererProgress(externglib.Take(unsafe.Pointer(_cret)))

	return _cellRendererProgress
}

// CellRendererSpin renders text in a cell like CellRendererText from which it
// is derived. But while CellRendererText offers a simple entry to edit the
// text, CellRendererSpin offers a SpinButton widget. Of course, that means that
// the text has to be parseable as a floating point number.
//
// The range of the spinbutton is taken from the adjustment property of the cell
// renderer, which can be set explicitly or mapped to a column in the tree
// model, like all properties of cell renders. CellRendererSpin also has
// properties for the CellRendererSpin:climb-rate and the number of
// CellRendererSpin:digits to display. Other SpinButton properties can be set in
// a handler for the CellRenderer::editing-started signal.
//
// The CellRendererSpin cell renderer was added in GTK+ 2.10.
type CellRendererSpin interface {
	CellRendererText
}

// cellRendererSpin implements the CellRendererSpin class.
type cellRendererSpin struct {
	CellRendererText
}

var _ CellRendererSpin = (*cellRendererSpin)(nil)

// WrapCellRendererSpin wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererSpin(obj *externglib.Object) CellRendererSpin {
	return cellRendererSpin{
		CellRendererText: WrapCellRendererText(obj),
	}
}

func marshalCellRendererSpin(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererSpin(obj), nil
}

// NewCellRendererSpin creates a new CellRendererSpin.
func NewCellRendererSpin() CellRendererSpin {
	var _cret *C.GtkCellRenderer // in

	_cret = C.gtk_cell_renderer_spin_new()

	var _cellRendererSpin CellRendererSpin // out

	_cellRendererSpin = WrapCellRendererSpin(externglib.Take(unsafe.Pointer(_cret)))

	return _cellRendererSpin
}

// CellRendererSpinner: gtkCellRendererSpinner renders a spinning animation in a
// cell, very similar to Spinner. It can often be used as an alternative to a
// CellRendererProgress for displaying indefinite activity, instead of actual
// progress.
//
// To start the animation in a cell, set the CellRendererSpinner:active property
// to true and increment the CellRendererSpinner:pulse property at regular
// intervals. The usual way to set the cell renderer properties for each cell is
// to bind them to columns in your tree model using e.g.
// gtk_tree_view_column_add_attribute().
type CellRendererSpinner interface {
	CellRenderer
}

// cellRendererSpinner implements the CellRendererSpinner class.
type cellRendererSpinner struct {
	CellRenderer
}

var _ CellRendererSpinner = (*cellRendererSpinner)(nil)

// WrapCellRendererSpinner wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererSpinner(obj *externglib.Object) CellRendererSpinner {
	return cellRendererSpinner{
		CellRenderer: WrapCellRenderer(obj),
	}
}

func marshalCellRendererSpinner(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererSpinner(obj), nil
}

// NewCellRendererSpinner returns a new cell renderer which will show a spinner
// to indicate activity.
func NewCellRendererSpinner() CellRendererSpinner {
	var _cret *C.GtkCellRenderer // in

	_cret = C.gtk_cell_renderer_spinner_new()

	var _cellRendererSpinner CellRendererSpinner // out

	_cellRendererSpinner = WrapCellRendererSpinner(externglib.Take(unsafe.Pointer(_cret)))

	return _cellRendererSpinner
}

// CellRendererText: a CellRendererText renders a given text in its cell, using
// the font, color and style information provided by its properties. The text
// will be ellipsized if it is too long and the CellRendererText:ellipsize
// property allows it.
//
// If the CellRenderer:mode is GTK_CELL_RENDERER_MODE_EDITABLE, the
// CellRendererText allows to edit its text using an entry.
type CellRendererText interface {
	CellRenderer

	// SetFixedHeightFromFont sets the height of a renderer to explicitly be
	// determined by the “font” and “y_pad” property set on it. Further changes
	// in these properties do not affect the height, so they must be accompanied
	// by a subsequent call to this function. Using this function is unflexible,
	// and should really only be used if calculating the size of a cell is too
	// slow (ie, a massive number of cells displayed). If @number_of_rows is -1,
	// then the fixed height is unset, and the height is determined by the
	// properties again.
	SetFixedHeightFromFont(numberOfRows int)
}

// cellRendererText implements the CellRendererText class.
type cellRendererText struct {
	CellRenderer
}

var _ CellRendererText = (*cellRendererText)(nil)

// WrapCellRendererText wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererText(obj *externglib.Object) CellRendererText {
	return cellRendererText{
		CellRenderer: WrapCellRenderer(obj),
	}
}

func marshalCellRendererText(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererText(obj), nil
}

// NewCellRendererText creates a new CellRendererText. Adjust how text is drawn
// using object properties. Object properties can be set globally (with
// g_object_set()). Also, with TreeViewColumn, you can bind a property to a
// value in a TreeModel. For example, you can bind the “text” property on the
// cell renderer to a string value in the model, thus rendering a different
// string in each row of the TreeView
func NewCellRendererText() CellRendererText {
	var _cret *C.GtkCellRenderer // in

	_cret = C.gtk_cell_renderer_text_new()

	var _cellRendererText CellRendererText // out

	_cellRendererText = WrapCellRendererText(externglib.Take(unsafe.Pointer(_cret)))

	return _cellRendererText
}

// SetFixedHeightFromFont sets the height of a renderer to explicitly be
// determined by the “font” and “y_pad” property set on it. Further changes in
// these properties do not affect the height, so they must be accompanied by a
// subsequent call to this function. Using this function is unflexible, and
// should really only be used if calculating the size of a cell is too slow (ie,
// a massive number of cells displayed). If @number_of_rows is -1, then the
// fixed height is unset, and the height is determined by the properties again.
func (r cellRendererText) SetFixedHeightFromFont(numberOfRows int) {
	var _arg0 *C.GtkCellRendererText // out
	var _arg1 C.gint                 // out

	_arg0 = (*C.GtkCellRendererText)(unsafe.Pointer(r.Native()))
	_arg1 = (C.gint)(numberOfRows)

	C.gtk_cell_renderer_text_set_fixed_height_from_font(_arg0, _arg1)
}

// CellRendererToggle renders a toggle button in a cell. The button is drawn as
// a radio or a checkbutton, depending on the CellRendererToggle:radio property.
// When activated, it emits the CellRendererToggle::toggled signal.
type CellRendererToggle interface {
	CellRenderer

	// Activatable returns whether the cell renderer is activatable. See
	// gtk_cell_renderer_toggle_set_activatable().
	Activatable() bool
	// Active returns whether the cell renderer is active. See
	// gtk_cell_renderer_toggle_set_active().
	Active() bool
	// Radio returns whether we’re rendering radio toggles rather than
	// checkboxes.
	Radio() bool
	// SetActivatable makes the cell renderer activatable.
	SetActivatable(setting bool)
	// SetActive activates or deactivates a cell renderer.
	SetActive(setting bool)
	// SetRadio: if @radio is true, the cell renderer renders a radio toggle
	// (i.e. a toggle in a group of mutually-exclusive toggles). If false, it
	// renders a check toggle (a standalone boolean option). This can be set
	// globally for the cell renderer, or changed just before rendering each
	// cell in the model (for TreeView, you set up a per-row setting using
	// TreeViewColumn to associate model columns with cell renderer properties).
	SetRadio(radio bool)
}

// cellRendererToggle implements the CellRendererToggle class.
type cellRendererToggle struct {
	CellRenderer
}

var _ CellRendererToggle = (*cellRendererToggle)(nil)

// WrapCellRendererToggle wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererToggle(obj *externglib.Object) CellRendererToggle {
	return cellRendererToggle{
		CellRenderer: WrapCellRenderer(obj),
	}
}

func marshalCellRendererToggle(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererToggle(obj), nil
}

// NewCellRendererToggle creates a new CellRendererToggle. Adjust rendering
// parameters using object properties. Object properties can be set globally
// (with g_object_set()). Also, with TreeViewColumn, you can bind a property to
// a value in a TreeModel. For example, you can bind the “active” property on
// the cell renderer to a boolean value in the model, thus causing the check
// button to reflect the state of the model.
func NewCellRendererToggle() CellRendererToggle {
	var _cret *C.GtkCellRenderer // in

	_cret = C.gtk_cell_renderer_toggle_new()

	var _cellRendererToggle CellRendererToggle // out

	_cellRendererToggle = WrapCellRendererToggle(externglib.Take(unsafe.Pointer(_cret)))

	return _cellRendererToggle
}

// Activatable returns whether the cell renderer is activatable. See
// gtk_cell_renderer_toggle_set_activatable().
func (t cellRendererToggle) Activatable() bool {
	var _arg0 *C.GtkCellRendererToggle // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_cell_renderer_toggle_get_activatable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Active returns whether the cell renderer is active. See
// gtk_cell_renderer_toggle_set_active().
func (t cellRendererToggle) Active() bool {
	var _arg0 *C.GtkCellRendererToggle // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_cell_renderer_toggle_get_active(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Radio returns whether we’re rendering radio toggles rather than checkboxes.
func (t cellRendererToggle) Radio() bool {
	var _arg0 *C.GtkCellRendererToggle // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_cell_renderer_toggle_get_radio(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetActivatable makes the cell renderer activatable.
func (t cellRendererToggle) SetActivatable(setting bool) {
	var _arg0 *C.GtkCellRendererToggle // out
	var _arg1 C.gboolean               // out

	_arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(t.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_cell_renderer_toggle_set_activatable(_arg0, _arg1)
}

// SetActive activates or deactivates a cell renderer.
func (t cellRendererToggle) SetActive(setting bool) {
	var _arg0 *C.GtkCellRendererToggle // out
	var _arg1 C.gboolean               // out

	_arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(t.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_cell_renderer_toggle_set_active(_arg0, _arg1)
}

// SetRadio: if @radio is true, the cell renderer renders a radio toggle (i.e. a
// toggle in a group of mutually-exclusive toggles). If false, it renders a
// check toggle (a standalone boolean option). This can be set globally for the
// cell renderer, or changed just before rendering each cell in the model (for
// TreeView, you set up a per-row setting using TreeViewColumn to associate
// model columns with cell renderer properties).
func (t cellRendererToggle) SetRadio(radio bool) {
	var _arg0 *C.GtkCellRendererToggle // out
	var _arg1 C.gboolean               // out

	_arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(t.Native()))
	if radio {
		_arg1 = C.TRUE
	}

	C.gtk_cell_renderer_toggle_set_radio(_arg0, _arg1)
}

// CellView: a CellView displays a single row of a TreeModel using a CellArea
// and CellAreaContext. A CellAreaContext can be provided to the CellView at
// construction time in order to keep the cellview in context of a group of cell
// views, this ensures that the renderers displayed will be properly aligned
// with eachother (like the aligned cells in the menus of ComboBox).
//
// CellView is Orientable in order to decide in which orientation the underlying
// CellAreaContext should be allocated. Taking the ComboBox menu as an example,
// cellviews should be oriented horizontally if the menus are listed
// top-to-bottom and thus all share the same width but may have separate
// individual heights (left-to-right menus should be allocated vertically since
// they all share the same height but may have variable widths).
//
//
// CSS nodes
//
// GtkCellView has a single CSS node with name cellview.
type CellView interface {
	Widget
	Buildable
	CellLayout
	Orientable

	// DisplayedRow returns a TreePath referring to the currently displayed row.
	// If no row is currently displayed, nil is returned.
	DisplayedRow() *TreePath
	// DrawSensitive gets whether @cell_view is configured to draw all of its
	// cells in a sensitive state.
	DrawSensitive() bool
	// FitModel gets whether @cell_view is configured to request space to fit
	// the entire TreeModel.
	FitModel() bool
	// Model returns the model for @cell_view. If no model is used nil is
	// returned.
	Model() TreeModel
	// SizeOfRow sets @requisition to the size needed by @cell_view to display
	// the model row pointed to by @path.
	SizeOfRow(path *TreePath) (Requisition, bool)
	// SetBackgroundColor sets the background color of @view.
	SetBackgroundColor(color *gdk.Color)
	// SetBackgroundRGBA sets the background color of @cell_view.
	SetBackgroundRGBA(rgba *gdk.RGBA)
	// SetDisplayedRow sets the row of the model that is currently displayed by
	// the CellView. If the path is unset, then the contents of the cellview
	// “stick” at their last value; this is not normally a desired result, but
	// may be a needed intermediate state if say, the model for the CellView
	// becomes temporarily empty.
	SetDisplayedRow(path *TreePath)
	// SetDrawSensitive sets whether @cell_view should draw all of its cells in
	// a sensitive state, this is used by ComboBox menus to ensure that rows
	// with insensitive cells that contain children appear sensitive in the
	// parent menu item.
	SetDrawSensitive(drawSensitive bool)
	// SetFitModel sets whether @cell_view should request space to fit the
	// entire TreeModel.
	//
	// This is used by ComboBox to ensure that the cell view displayed on the
	// combo box’s button always gets enough space and does not resize when
	// selection changes.
	SetFitModel(fitModel bool)
	// SetModel sets the model for @cell_view. If @cell_view already has a model
	// set, it will remove it before setting the new model. If @model is nil,
	// then it will unset the old model.
	SetModel(model TreeModel)
}

// cellView implements the CellView class.
type cellView struct {
	Widget
	Buildable
	CellLayout
	Orientable
}

var _ CellView = (*cellView)(nil)

// WrapCellView wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellView(obj *externglib.Object) CellView {
	return cellView{
		Widget:     WrapWidget(obj),
		Buildable:  WrapBuildable(obj),
		CellLayout: WrapCellLayout(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalCellView(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellView(obj), nil
}

// NewCellView creates a new CellView widget.
func NewCellView() CellView {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_cell_view_new()

	var _cellView CellView // out

	_cellView = WrapCellView(externglib.Take(unsafe.Pointer(_cret)))

	return _cellView
}

// NewCellViewWithContext creates a new CellView widget with a specific CellArea
// to layout cells and a specific CellAreaContext.
//
// Specifying the same context for a handfull of cells lets the underlying area
// synchronize the geometry for those cells, in this way alignments with
// cellviews for other rows are possible.
func NewCellViewWithContext(area CellArea, context CellAreaContext) CellView {
	var _arg1 *C.GtkCellArea        // out
	var _arg2 *C.GtkCellAreaContext // out
	var _cret *C.GtkWidget          // in

	_arg1 = (*C.GtkCellArea)(unsafe.Pointer(area.Native()))
	_arg2 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))

	_cret = C.gtk_cell_view_new_with_context(_arg1, _arg2)

	var _cellView CellView // out

	_cellView = WrapCellView(externglib.Take(unsafe.Pointer(_cret)))

	return _cellView
}

// NewCellViewWithMarkup creates a new CellView widget, adds a CellRendererText
// to it, and makes it show @markup. The text can be marked up with the [Pango
// text markup language][PangoMarkupFormat].
func NewCellViewWithMarkup(markup string) CellView {
	var _arg1 *C.gchar     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.gchar)(C.CString(markup))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_cell_view_new_with_markup(_arg1)

	var _cellView CellView // out

	_cellView = WrapCellView(externglib.Take(unsafe.Pointer(_cret)))

	return _cellView
}

// NewCellViewWithPixbuf creates a new CellView widget, adds a
// CellRendererPixbuf to it, and makes it show @pixbuf.
func NewCellViewWithPixbuf(pixbuf gdkpixbuf.Pixbuf) CellView {
	var _arg1 *C.GdkPixbuf // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	_cret = C.gtk_cell_view_new_with_pixbuf(_arg1)

	var _cellView CellView // out

	_cellView = WrapCellView(externglib.Take(unsafe.Pointer(_cret)))

	return _cellView
}

// NewCellViewWithText creates a new CellView widget, adds a CellRendererText to
// it, and makes it show @text.
func NewCellViewWithText(text string) CellView {
	var _arg1 *C.gchar     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_cell_view_new_with_text(_arg1)

	var _cellView CellView // out

	_cellView = WrapCellView(externglib.Take(unsafe.Pointer(_cret)))

	return _cellView
}

// DisplayedRow returns a TreePath referring to the currently displayed row. If
// no row is currently displayed, nil is returned.
func (c cellView) DisplayedRow() *TreePath {
	var _arg0 *C.GtkCellView // out
	var _cret *C.GtkTreePath // in

	_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_cell_view_get_displayed_row(_arg0)

	var _treePath *TreePath // out

	_treePath = WrapTreePath(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treePath, func(v *TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treePath
}

// DrawSensitive gets whether @cell_view is configured to draw all of its cells
// in a sensitive state.
func (c cellView) DrawSensitive() bool {
	var _arg0 *C.GtkCellView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_cell_view_get_draw_sensitive(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FitModel gets whether @cell_view is configured to request space to fit the
// entire TreeModel.
func (c cellView) FitModel() bool {
	var _arg0 *C.GtkCellView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_cell_view_get_fit_model(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Model returns the model for @cell_view. If no model is used nil is returned.
func (c cellView) Model() TreeModel {
	var _arg0 *C.GtkCellView  // out
	var _cret *C.GtkTreeModel // in

	_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_cell_view_get_model(_arg0)

	var _treeModel TreeModel // out

	_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeModel)

	return _treeModel
}

// SizeOfRow sets @requisition to the size needed by @cell_view to display the
// model row pointed to by @path.
func (c cellView) SizeOfRow(path *TreePath) (Requisition, bool) {
	var _arg0 *C.GtkCellView // out
	var _arg1 *C.GtkTreePath // out
	var _requisition Requisition
	var _cret C.gboolean // in

	_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	_cret = C.gtk_cell_view_get_size_of_row(_arg0, _arg1, (*C.GtkRequisition)(unsafe.Pointer(&_requisition)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _requisition, _ok
}

// SetBackgroundColor sets the background color of @view.
func (c cellView) SetBackgroundColor(color *gdk.Color) {
	var _arg0 *C.GtkCellView // out
	var _arg1 *C.GdkColor    // out

	_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GdkColor)(unsafe.Pointer(color.Native()))

	C.gtk_cell_view_set_background_color(_arg0, _arg1)
}

// SetBackgroundRGBA sets the background color of @cell_view.
func (c cellView) SetBackgroundRGBA(rgba *gdk.RGBA) {
	var _arg0 *C.GtkCellView // out
	var _arg1 *C.GdkRGBA     // out

	_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GdkRGBA)(unsafe.Pointer(rgba.Native()))

	C.gtk_cell_view_set_background_rgba(_arg0, _arg1)
}

// SetDisplayedRow sets the row of the model that is currently displayed by the
// CellView. If the path is unset, then the contents of the cellview “stick” at
// their last value; this is not normally a desired result, but may be a needed
// intermediate state if say, the model for the CellView becomes temporarily
// empty.
func (c cellView) SetDisplayedRow(path *TreePath) {
	var _arg0 *C.GtkCellView // out
	var _arg1 *C.GtkTreePath // out

	_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_cell_view_set_displayed_row(_arg0, _arg1)
}

// SetDrawSensitive sets whether @cell_view should draw all of its cells in a
// sensitive state, this is used by ComboBox menus to ensure that rows with
// insensitive cells that contain children appear sensitive in the parent menu
// item.
func (c cellView) SetDrawSensitive(drawSensitive bool) {
	var _arg0 *C.GtkCellView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))
	if drawSensitive {
		_arg1 = C.TRUE
	}

	C.gtk_cell_view_set_draw_sensitive(_arg0, _arg1)
}

// SetFitModel sets whether @cell_view should request space to fit the entire
// TreeModel.
//
// This is used by ComboBox to ensure that the cell view displayed on the combo
// box’s button always gets enough space and does not resize when selection
// changes.
func (c cellView) SetFitModel(fitModel bool) {
	var _arg0 *C.GtkCellView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))
	if fitModel {
		_arg1 = C.TRUE
	}

	C.gtk_cell_view_set_fit_model(_arg0, _arg1)
}

// SetModel sets the model for @cell_view. If @cell_view already has a model
// set, it will remove it before setting the new model. If @model is nil, then
// it will unset the old model.
func (c cellView) SetModel(model TreeModel) {
	var _arg0 *C.GtkCellView  // out
	var _arg1 *C.GtkTreeModel // out

	_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

	C.gtk_cell_view_set_model(_arg0, _arg1)
}

// CheckButton: a CheckButton places a discrete ToggleButton next to a widget,
// (usually a Label). See the section on ToggleButton widgets for more
// information about toggle/check buttons.
//
// The important signal ( ToggleButton::toggled ) is also inherited from
// ToggleButton.
//
// CSS nodes
//
//    button.check
//    ├── check
//    ╰── <child>
//
// A GtkCheckButton without indicator changes the name of its main node to
// button and adds a .check style class to it. The subnode is invisible in this
// case.
type CheckButton interface {
	ToggleButton
	Actionable
	Activatable
	Buildable
}

// checkButton implements the CheckButton class.
type checkButton struct {
	ToggleButton
	Actionable
	Activatable
	Buildable
}

var _ CheckButton = (*checkButton)(nil)

// WrapCheckButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapCheckButton(obj *externglib.Object) CheckButton {
	return checkButton{
		ToggleButton: WrapToggleButton(obj),
		Actionable:   WrapActionable(obj),
		Activatable:  WrapActivatable(obj),
		Buildable:    WrapBuildable(obj),
	}
}

func marshalCheckButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCheckButton(obj), nil
}

// NewCheckButton creates a new CheckButton.
func NewCheckButton() CheckButton {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_check_button_new()

	var _checkButton CheckButton // out

	_checkButton = WrapCheckButton(externglib.Take(unsafe.Pointer(_cret)))

	return _checkButton
}

// NewCheckButtonWithLabel creates a new CheckButton with a Label to the right
// of it.
func NewCheckButtonWithLabel(label string) CheckButton {
	var _arg1 *C.gchar     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_check_button_new_with_label(_arg1)

	var _checkButton CheckButton // out

	_checkButton = WrapCheckButton(externglib.Take(unsafe.Pointer(_cret)))

	return _checkButton
}

// NewCheckButtonWithMnemonic creates a new CheckButton containing a label. The
// label will be created using gtk_label_new_with_mnemonic(), so underscores in
// @label indicate the mnemonic for the check button.
func NewCheckButtonWithMnemonic(label string) CheckButton {
	var _arg1 *C.gchar     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_check_button_new_with_mnemonic(_arg1)

	var _checkButton CheckButton // out

	_checkButton = WrapCheckButton(externglib.Take(unsafe.Pointer(_cret)))

	return _checkButton
}

// CheckMenuItem: a CheckMenuItem is a menu item that maintains the state of a
// boolean value in addition to a MenuItem usual role in activating application
// code.
//
// A check box indicating the state of the boolean value is displayed at the
// left side of the MenuItem. Activating the MenuItem toggles the value.
//
// CSS nodes
//
//    menuitem
//    ├── check.left
//    ╰── <child>
//
// GtkCheckMenuItem has a main CSS node with name menuitem, and a subnode with
// name check, which gets the .left or .right style class.
type CheckMenuItem interface {
	MenuItem
	Actionable
	Activatable
	Buildable

	// Active returns whether the check menu item is active. See
	// gtk_check_menu_item_set_active ().
	Active() bool
	// DrawAsRadio returns whether @check_menu_item looks like a RadioMenuItem
	DrawAsRadio() bool
	// Inconsistent retrieves the value set by
	// gtk_check_menu_item_set_inconsistent().
	Inconsistent() bool
	// SetActive sets the active state of the menu item’s check box.
	SetActive(isActive bool)
	// SetDrawAsRadio sets whether @check_menu_item is drawn like a
	// RadioMenuItem
	SetDrawAsRadio(drawAsRadio bool)
	// SetInconsistent: if the user has selected a range of elements (such as
	// some text or spreadsheet cells) that are affected by a boolean setting,
	// and the current values in that range are inconsistent, you may want to
	// display the check in an “in between” state. This function turns on “in
	// between” display. Normally you would turn off the inconsistent state
	// again if the user explicitly selects a setting. This has to be done
	// manually, gtk_check_menu_item_set_inconsistent() only affects visual
	// appearance, it doesn’t affect the semantics of the widget.
	SetInconsistent(setting bool)
	// Toggled emits the CheckMenuItem::toggled signal.
	Toggled()
}

// checkMenuItem implements the CheckMenuItem class.
type checkMenuItem struct {
	MenuItem
	Actionable
	Activatable
	Buildable
}

var _ CheckMenuItem = (*checkMenuItem)(nil)

// WrapCheckMenuItem wraps a GObject to the right type. It is
// primarily used internally.
func WrapCheckMenuItem(obj *externglib.Object) CheckMenuItem {
	return checkMenuItem{
		MenuItem:    WrapMenuItem(obj),
		Actionable:  WrapActionable(obj),
		Activatable: WrapActivatable(obj),
		Buildable:   WrapBuildable(obj),
	}
}

func marshalCheckMenuItem(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCheckMenuItem(obj), nil
}

// NewCheckMenuItem creates a new CheckMenuItem.
func NewCheckMenuItem() CheckMenuItem {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_check_menu_item_new()

	var _checkMenuItem CheckMenuItem // out

	_checkMenuItem = WrapCheckMenuItem(externglib.Take(unsafe.Pointer(_cret)))

	return _checkMenuItem
}

// NewCheckMenuItemWithLabel creates a new CheckMenuItem with a label.
func NewCheckMenuItemWithLabel(label string) CheckMenuItem {
	var _arg1 *C.gchar     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_check_menu_item_new_with_label(_arg1)

	var _checkMenuItem CheckMenuItem // out

	_checkMenuItem = WrapCheckMenuItem(externglib.Take(unsafe.Pointer(_cret)))

	return _checkMenuItem
}

// NewCheckMenuItemWithMnemonic creates a new CheckMenuItem containing a label.
// The label will be created using gtk_label_new_with_mnemonic(), so underscores
// in @label indicate the mnemonic for the menu item.
func NewCheckMenuItemWithMnemonic(label string) CheckMenuItem {
	var _arg1 *C.gchar     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_check_menu_item_new_with_mnemonic(_arg1)

	var _checkMenuItem CheckMenuItem // out

	_checkMenuItem = WrapCheckMenuItem(externglib.Take(unsafe.Pointer(_cret)))

	return _checkMenuItem
}

// Active returns whether the check menu item is active. See
// gtk_check_menu_item_set_active ().
func (c checkMenuItem) Active() bool {
	var _arg0 *C.GtkCheckMenuItem // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkCheckMenuItem)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_check_menu_item_get_active(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DrawAsRadio returns whether @check_menu_item looks like a RadioMenuItem
func (c checkMenuItem) DrawAsRadio() bool {
	var _arg0 *C.GtkCheckMenuItem // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkCheckMenuItem)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_check_menu_item_get_draw_as_radio(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Inconsistent retrieves the value set by
// gtk_check_menu_item_set_inconsistent().
func (c checkMenuItem) Inconsistent() bool {
	var _arg0 *C.GtkCheckMenuItem // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkCheckMenuItem)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_check_menu_item_get_inconsistent(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetActive sets the active state of the menu item’s check box.
func (c checkMenuItem) SetActive(isActive bool) {
	var _arg0 *C.GtkCheckMenuItem // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkCheckMenuItem)(unsafe.Pointer(c.Native()))
	if isActive {
		_arg1 = C.TRUE
	}

	C.gtk_check_menu_item_set_active(_arg0, _arg1)
}

// SetDrawAsRadio sets whether @check_menu_item is drawn like a RadioMenuItem
func (c checkMenuItem) SetDrawAsRadio(drawAsRadio bool) {
	var _arg0 *C.GtkCheckMenuItem // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkCheckMenuItem)(unsafe.Pointer(c.Native()))
	if drawAsRadio {
		_arg1 = C.TRUE
	}

	C.gtk_check_menu_item_set_draw_as_radio(_arg0, _arg1)
}

// SetInconsistent: if the user has selected a range of elements (such as some
// text or spreadsheet cells) that are affected by a boolean setting, and the
// current values in that range are inconsistent, you may want to display the
// check in an “in between” state. This function turns on “in between” display.
// Normally you would turn off the inconsistent state again if the user
// explicitly selects a setting. This has to be done manually,
// gtk_check_menu_item_set_inconsistent() only affects visual appearance, it
// doesn’t affect the semantics of the widget.
func (c checkMenuItem) SetInconsistent(setting bool) {
	var _arg0 *C.GtkCheckMenuItem // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkCheckMenuItem)(unsafe.Pointer(c.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_check_menu_item_set_inconsistent(_arg0, _arg1)
}

// Toggled emits the CheckMenuItem::toggled signal.
func (c checkMenuItem) Toggled() {
	var _arg0 *C.GtkCheckMenuItem // out

	_arg0 = (*C.GtkCheckMenuItem)(unsafe.Pointer(c.Native()))

	C.gtk_check_menu_item_toggled(_arg0)
}

type CheckMenuItemAccessible interface {
	MenuItemAccessible
}

// checkMenuItemAccessible implements the CheckMenuItemAccessible class.
type checkMenuItemAccessible struct {
	MenuItemAccessible
}

var _ CheckMenuItemAccessible = (*checkMenuItemAccessible)(nil)

// WrapCheckMenuItemAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapCheckMenuItemAccessible(obj *externglib.Object) CheckMenuItemAccessible {
	return checkMenuItemAccessible{
		MenuItemAccessible: WrapMenuItemAccessible(obj),
	}
}

func marshalCheckMenuItemAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCheckMenuItemAccessible(obj), nil
}

// Clipboard: the Clipboard object represents a clipboard of data shared between
// different processes or between different widgets in the same process. Each
// clipboard is identified by a name encoded as a Atom. (Conversion to and from
// strings can be done with gdk_atom_intern() and gdk_atom_name().) The default
// clipboard corresponds to the “CLIPBOARD” atom; another commonly used
// clipboard is the “PRIMARY” clipboard, which, in X, traditionally contains the
// currently selected text.
//
// To support having a number of different formats on the clipboard at the same
// time, the clipboard mechanism allows providing callbacks instead of the
// actual data. When you set the contents of the clipboard, you can either
// supply the data directly (via functions like gtk_clipboard_set_text()), or
// you can supply a callback to be called at a later time when the data is
// needed (via gtk_clipboard_set_with_data() or gtk_clipboard_set_with_owner().)
// Providing a callback also avoids having to make copies of the data when it is
// not needed.
//
// gtk_clipboard_set_with_data() and gtk_clipboard_set_with_owner() are quite
// similar; the choice between the two depends mostly on which is more
// convenient in a particular situation. The former is most useful when you want
// to have a blob of data with callbacks to convert it into the various data
// types that you advertise. When the @clear_func you provided is called, you
// simply free the data blob. The latter is more useful when the contents of
// clipboard reflect the internal state of a #GObject (As an example, for the
// PRIMARY clipboard, when an entry widget provides the clipboard’s contents the
// contents are simply the text within the selected region.) If the contents
// change, the entry widget can call gtk_clipboard_set_with_owner() to update
// the timestamp for clipboard ownership, without having to worry about
// @clear_func being called.
//
// Requesting the data from the clipboard is essentially asynchronous. If the
// contents of the clipboard are provided within the same process, then a direct
// function call will be made to retrieve the data, but if they are provided by
// another process, then the data needs to be retrieved from the other process,
// which may take some time. To avoid blocking the user interface, the call to
// request the selection, gtk_clipboard_request_contents() takes a callback that
// will be called when the contents are received (or when the request fails.) If
// you don’t want to deal with providing a separate callback, you can also use
// gtk_clipboard_wait_for_contents(). What this does is run the GLib main loop
// recursively waiting for the contents. This can simplify the code flow, but
// you still have to be aware that other callbacks in your program can be called
// while this recursive mainloop is running.
//
// Along with the functions to get the clipboard contents as an arbitrary data
// chunk, there are also functions to retrieve it as text,
// gtk_clipboard_request_text() and gtk_clipboard_wait_for_text(). These
// functions take care of determining which formats are advertised by the
// clipboard provider, asking for the clipboard in the best available format and
// converting the results into the UTF-8 encoding. (The standard form for
// representing strings in GTK+.)
type Clipboard interface {
	gextras.Objector

	// Clear clears the contents of the clipboard. Generally this should only be
	// called between the time you call gtk_clipboard_set_with_owner() or
	// gtk_clipboard_set_with_data(), and when the @clear_func you supplied is
	// called. Otherwise, the clipboard may be owned by someone else.
	Clear()
	// Display gets the Display associated with @clipboard
	Display() gdk.Display
	// Owner: if the clipboard contents callbacks were set with
	// gtk_clipboard_set_with_owner(), and the gtk_clipboard_set_with_data() or
	// gtk_clipboard_clear() has not subsequently called, returns the owner set
	// by gtk_clipboard_set_with_owner().
	Owner() gextras.Objector
	// SetCanStore hints that the clipboard data should be stored somewhere when
	// the application exits or when gtk_clipboard_store () is called.
	//
	// This value is reset when the clipboard owner changes. Where the clipboard
	// data is stored is platform dependent, see gdk_display_store_clipboard ()
	// for more information.
	SetCanStore(targets []TargetEntry)
	// SetImage sets the contents of the clipboard to the given Pixbuf. GTK+
	// will take responsibility for responding for requests for the image, and
	// for converting the image into the requested format.
	SetImage(pixbuf gdkpixbuf.Pixbuf)
	// SetText sets the contents of the clipboard to the given UTF-8 string.
	// GTK+ will make a copy of the text and take responsibility for responding
	// for requests for the text, and for converting the text into the requested
	// format.
	SetText(text string, len int)
	// Store stores the current clipboard data somewhere so that it will stay
	// around after the application has quit.
	Store()
	// WaitForContents requests the contents of the clipboard using the given
	// target. This function waits for the data to be received using the main
	// loop, so events, timeouts, etc, may be dispatched during the wait.
	WaitForContents(target *gdk.Atom) *SelectionData
	// WaitForImage requests the contents of the clipboard as image and converts
	// the result to a Pixbuf. This function waits for the data to be received
	// using the main loop, so events, timeouts, etc, may be dispatched during
	// the wait.
	WaitForImage() gdkpixbuf.Pixbuf
	// WaitForTargets returns a list of targets that are present on the
	// clipboard, or nil if there aren’t any targets available. The returned
	// list must be freed with g_free(). This function waits for the data to be
	// received using the main loop, so events, timeouts, etc, may be dispatched
	// during the wait.
	WaitForTargets() ([]gdk.Atom, bool)
	// WaitForText requests the contents of the clipboard as text and converts
	// the result to UTF-8 if necessary. This function waits for the data to be
	// received using the main loop, so events, timeouts, etc, may be dispatched
	// during the wait.
	WaitForText() string
	// WaitForUris requests the contents of the clipboard as URIs. This function
	// waits for the data to be received using the main loop, so events,
	// timeouts, etc, may be dispatched during the wait.
	WaitForUris() []string
	// WaitIsImageAvailable: test to see if there is an image available to be
	// pasted This is done by requesting the TARGETS atom and checking if it
	// contains any of the supported image targets. This function waits for the
	// data to be received using the main loop, so events, timeouts, etc, may be
	// dispatched during the wait.
	//
	// This function is a little faster than calling
	// gtk_clipboard_wait_for_image() since it doesn’t need to retrieve the
	// actual image data.
	WaitIsImageAvailable() bool
	// WaitIsRichTextAvailable: test to see if there is rich text available to
	// be pasted This is done by requesting the TARGETS atom and checking if it
	// contains any of the supported rich text targets. This function waits for
	// the data to be received using the main loop, so events, timeouts, etc,
	// may be dispatched during the wait.
	//
	// This function is a little faster than calling
	// gtk_clipboard_wait_for_rich_text() since it doesn’t need to retrieve the
	// actual text.
	WaitIsRichTextAvailable(buffer TextBuffer) bool
	// WaitIsTargetAvailable checks if a clipboard supports pasting data of a
	// given type. This function can be used to determine if a “Paste” menu item
	// should be insensitive or not.
	//
	// If you want to see if there’s text available on the clipboard, use
	// gtk_clipboard_wait_is_text_available () instead.
	WaitIsTargetAvailable(target *gdk.Atom) bool
	// WaitIsTextAvailable: test to see if there is text available to be pasted
	// This is done by requesting the TARGETS atom and checking if it contains
	// any of the supported text targets. This function waits for the data to be
	// received using the main loop, so events, timeouts, etc, may be dispatched
	// during the wait.
	//
	// This function is a little faster than calling
	// gtk_clipboard_wait_for_text() since it doesn’t need to retrieve the
	// actual text.
	WaitIsTextAvailable() bool
	// WaitIsUrisAvailable: test to see if there is a list of URIs available to
	// be pasted This is done by requesting the TARGETS atom and checking if it
	// contains the URI targets. This function waits for the data to be received
	// using the main loop, so events, timeouts, etc, may be dispatched during
	// the wait.
	//
	// This function is a little faster than calling
	// gtk_clipboard_wait_for_uris() since it doesn’t need to retrieve the
	// actual URI data.
	WaitIsUrisAvailable() bool
}

// clipboard implements the Clipboard class.
type clipboard struct {
	gextras.Objector
}

var _ Clipboard = (*clipboard)(nil)

// WrapClipboard wraps a GObject to the right type. It is
// primarily used internally.
func WrapClipboard(obj *externglib.Object) Clipboard {
	return clipboard{
		Objector: obj,
	}
}

func marshalClipboard(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapClipboard(obj), nil
}

// Clear clears the contents of the clipboard. Generally this should only be
// called between the time you call gtk_clipboard_set_with_owner() or
// gtk_clipboard_set_with_data(), and when the @clear_func you supplied is
// called. Otherwise, the clipboard may be owned by someone else.
func (c clipboard) Clear() {
	var _arg0 *C.GtkClipboard // out

	_arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

	C.gtk_clipboard_clear(_arg0)
}

// Display gets the Display associated with @clipboard
func (c clipboard) Display() gdk.Display {
	var _arg0 *C.GtkClipboard // out
	var _cret *C.GdkDisplay   // in

	_arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_clipboard_get_display(_arg0)

	var _display gdk.Display // out

	_display = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Display)

	return _display
}

// Owner: if the clipboard contents callbacks were set with
// gtk_clipboard_set_with_owner(), and the gtk_clipboard_set_with_data() or
// gtk_clipboard_clear() has not subsequently called, returns the owner set by
// gtk_clipboard_set_with_owner().
func (c clipboard) Owner() gextras.Objector {
	var _arg0 *C.GtkClipboard // out
	var _cret *C.GObject      // in

	_arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_clipboard_get_owner(_arg0)

	var _object gextras.Objector // out

	_object = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gextras.Objector)

	return _object
}

// SetCanStore hints that the clipboard data should be stored somewhere when the
// application exits or when gtk_clipboard_store () is called.
//
// This value is reset when the clipboard owner changes. Where the clipboard
// data is stored is platform dependent, see gdk_display_store_clipboard () for
// more information.
func (c clipboard) SetCanStore(targets []TargetEntry) {
	var _arg0 *C.GtkClipboard // out
	var _arg1 *C.GtkTargetEntry
	var _arg2 C.gint

	_arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))
	_arg2 = C.gint(len(targets))
	_arg1 = (*C.GtkTargetEntry)(unsafe.Pointer(&targets[0]))

	C.gtk_clipboard_set_can_store(_arg0, _arg1, _arg2)
}

// SetImage sets the contents of the clipboard to the given Pixbuf. GTK+ will
// take responsibility for responding for requests for the image, and for
// converting the image into the requested format.
func (c clipboard) SetImage(pixbuf gdkpixbuf.Pixbuf) {
	var _arg0 *C.GtkClipboard // out
	var _arg1 *C.GdkPixbuf    // out

	_arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	C.gtk_clipboard_set_image(_arg0, _arg1)
}

// SetText sets the contents of the clipboard to the given UTF-8 string. GTK+
// will make a copy of the text and take responsibility for responding for
// requests for the text, and for converting the text into the requested format.
func (c clipboard) SetText(text string, len int) {
	var _arg0 *C.GtkClipboard // out
	var _arg1 *C.gchar        // out
	var _arg2 C.gint          // out

	_arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gint)(len)

	C.gtk_clipboard_set_text(_arg0, _arg1, _arg2)
}

// Store stores the current clipboard data somewhere so that it will stay around
// after the application has quit.
func (c clipboard) Store() {
	var _arg0 *C.GtkClipboard // out

	_arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

	C.gtk_clipboard_store(_arg0)
}

// WaitForContents requests the contents of the clipboard using the given
// target. This function waits for the data to be received using the main loop,
// so events, timeouts, etc, may be dispatched during the wait.
func (c clipboard) WaitForContents(target *gdk.Atom) *SelectionData {
	var _arg0 *C.GtkClipboard     // out
	var _arg1 C.GdkAtom           // out
	var _cret *C.GtkSelectionData // in

	_arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GdkAtom)(unsafe.Pointer(target.Native()))

	_cret = C.gtk_clipboard_wait_for_contents(_arg0, _arg1)

	var _selectionData *SelectionData // out

	_selectionData = WrapSelectionData(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_selectionData, func(v *SelectionData) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _selectionData
}

// WaitForImage requests the contents of the clipboard as image and converts the
// result to a Pixbuf. This function waits for the data to be received using the
// main loop, so events, timeouts, etc, may be dispatched during the wait.
func (c clipboard) WaitForImage() gdkpixbuf.Pixbuf {
	var _arg0 *C.GtkClipboard // out
	var _cret *C.GdkPixbuf    // in

	_arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_clipboard_wait_for_image(_arg0)

	var _pixbuf gdkpixbuf.Pixbuf // out

	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

	return _pixbuf
}

// WaitForTargets returns a list of targets that are present on the clipboard,
// or nil if there aren’t any targets available. The returned list must be freed
// with g_free(). This function waits for the data to be received using the main
// loop, so events, timeouts, etc, may be dispatched during the wait.
func (c clipboard) WaitForTargets() ([]gdk.Atom, bool) {
	var _arg0 *C.GtkClipboard // out
	var _arg1 *C.GdkAtom
	var _arg2 C.gint     // in
	var _cret C.gboolean // in

	_arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_clipboard_wait_for_targets(_arg0, &_arg1, &_arg2)

	var _targets []gdk.Atom
	var _ok bool // out

	_targets = unsafe.Slice((*gdk.Atom)(unsafe.Pointer(_arg1)), _arg2)
	runtime.SetFinalizer(&_targets, func(v *[]gdk.Atom) {
		C.free(unsafe.Pointer(&(*v)[0]))
	})
	if _cret != 0 {
		_ok = true
	}

	return _targets, _ok
}

// WaitForText requests the contents of the clipboard as text and converts the
// result to UTF-8 if necessary. This function waits for the data to be received
// using the main loop, so events, timeouts, etc, may be dispatched during the
// wait.
func (c clipboard) WaitForText() string {
	var _arg0 *C.GtkClipboard // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_clipboard_wait_for_text(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// WaitForUris requests the contents of the clipboard as URIs. This function
// waits for the data to be received using the main loop, so events, timeouts,
// etc, may be dispatched during the wait.
func (c clipboard) WaitForUris() []string {
	var _arg0 *C.GtkClipboard // out
	var _cret **C.gchar

	_arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_clipboard_wait_for_uris(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// WaitIsImageAvailable: test to see if there is an image available to be pasted
// This is done by requesting the TARGETS atom and checking if it contains any
// of the supported image targets. This function waits for the data to be
// received using the main loop, so events, timeouts, etc, may be dispatched
// during the wait.
//
// This function is a little faster than calling gtk_clipboard_wait_for_image()
// since it doesn’t need to retrieve the actual image data.
func (c clipboard) WaitIsImageAvailable() bool {
	var _arg0 *C.GtkClipboard // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_clipboard_wait_is_image_available(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// WaitIsRichTextAvailable: test to see if there is rich text available to be
// pasted This is done by requesting the TARGETS atom and checking if it
// contains any of the supported rich text targets. This function waits for the
// data to be received using the main loop, so events, timeouts, etc, may be
// dispatched during the wait.
//
// This function is a little faster than calling
// gtk_clipboard_wait_for_rich_text() since it doesn’t need to retrieve the
// actual text.
func (c clipboard) WaitIsRichTextAvailable(buffer TextBuffer) bool {
	var _arg0 *C.GtkClipboard  // out
	var _arg1 *C.GtkTextBuffer // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_clipboard_wait_is_rich_text_available(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// WaitIsTargetAvailable checks if a clipboard supports pasting data of a given
// type. This function can be used to determine if a “Paste” menu item should be
// insensitive or not.
//
// If you want to see if there’s text available on the clipboard, use
// gtk_clipboard_wait_is_text_available () instead.
func (c clipboard) WaitIsTargetAvailable(target *gdk.Atom) bool {
	var _arg0 *C.GtkClipboard // out
	var _arg1 C.GdkAtom       // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GdkAtom)(unsafe.Pointer(target.Native()))

	_cret = C.gtk_clipboard_wait_is_target_available(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// WaitIsTextAvailable: test to see if there is text available to be pasted This
// is done by requesting the TARGETS atom and checking if it contains any of the
// supported text targets. This function waits for the data to be received using
// the main loop, so events, timeouts, etc, may be dispatched during the wait.
//
// This function is a little faster than calling gtk_clipboard_wait_for_text()
// since it doesn’t need to retrieve the actual text.
func (c clipboard) WaitIsTextAvailable() bool {
	var _arg0 *C.GtkClipboard // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_clipboard_wait_is_text_available(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// WaitIsUrisAvailable: test to see if there is a list of URIs available to be
// pasted This is done by requesting the TARGETS atom and checking if it
// contains the URI targets. This function waits for the data to be received
// using the main loop, so events, timeouts, etc, may be dispatched during the
// wait.
//
// This function is a little faster than calling gtk_clipboard_wait_for_uris()
// since it doesn’t need to retrieve the actual URI data.
func (c clipboard) WaitIsUrisAvailable() bool {
	var _arg0 *C.GtkClipboard // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_clipboard_wait_is_uris_available(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ColorButton: the ColorButton is a button which displays the currently
// selected color and allows to open a color selection dialog to change the
// color. It is suitable widget for selecting a color in a preference dialog.
//
//
// CSS nodes
//
// GtkColorButton has a single CSS node with name button. To differentiate it
// from a plain Button, it gets the .color style class.
type ColorButton interface {
	Button
	Actionable
	Activatable
	Buildable
	ColorChooser

	// Alpha returns the current alpha value.
	Alpha() uint16
	// Color sets @color to be the current color in the ColorButton widget.
	Color() gdk.Color
	// Title gets the title of the color selection dialog.
	Title() string
	// UseAlpha does the color selection dialog use the alpha channel ?
	UseAlpha() bool
	// SetAlpha sets the current opacity to be @alpha.
	SetAlpha(alpha uint16)
	// SetColor sets the current color to be @color.
	SetColor(color *gdk.Color)
	// SetTitle sets the title for the color selection dialog.
	SetTitle(title string)
	// SetUseAlpha sets whether or not the color button should use the alpha
	// channel.
	SetUseAlpha(useAlpha bool)
}

// colorButton implements the ColorButton class.
type colorButton struct {
	Button
	Actionable
	Activatable
	Buildable
	ColorChooser
}

var _ ColorButton = (*colorButton)(nil)

// WrapColorButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapColorButton(obj *externglib.Object) ColorButton {
	return colorButton{
		Button:       WrapButton(obj),
		Actionable:   WrapActionable(obj),
		Activatable:  WrapActivatable(obj),
		Buildable:    WrapBuildable(obj),
		ColorChooser: WrapColorChooser(obj),
	}
}

func marshalColorButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapColorButton(obj), nil
}

// NewColorButton creates a new color button.
//
// This returns a widget in the form of a small button containing a swatch
// representing the current selected color. When the button is clicked, a
// color-selection dialog will open, allowing the user to select a color. The
// swatch will be updated to reflect the new color when the user finishes.
func NewColorButton() ColorButton {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_color_button_new()

	var _colorButton ColorButton // out

	_colorButton = WrapColorButton(externglib.Take(unsafe.Pointer(_cret)))

	return _colorButton
}

// NewColorButtonWithColor creates a new color button.
func NewColorButtonWithColor(color *gdk.Color) ColorButton {
	var _arg1 *C.GdkColor  // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.GdkColor)(unsafe.Pointer(color.Native()))

	_cret = C.gtk_color_button_new_with_color(_arg1)

	var _colorButton ColorButton // out

	_colorButton = WrapColorButton(externglib.Take(unsafe.Pointer(_cret)))

	return _colorButton
}

// NewColorButtonWithRGBA creates a new color button.
func NewColorButtonWithRGBA(rgba *gdk.RGBA) ColorButton {
	var _arg1 *C.GdkRGBA   // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.GdkRGBA)(unsafe.Pointer(rgba.Native()))

	_cret = C.gtk_color_button_new_with_rgba(_arg1)

	var _colorButton ColorButton // out

	_colorButton = WrapColorButton(externglib.Take(unsafe.Pointer(_cret)))

	return _colorButton
}

// Alpha returns the current alpha value.
func (b colorButton) Alpha() uint16 {
	var _arg0 *C.GtkColorButton // out
	var _cret C.guint16         // in

	_arg0 = (*C.GtkColorButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_color_button_get_alpha(_arg0)

	var _guint16 uint16 // out

	_guint16 = (uint16)(_cret)

	return _guint16
}

// Color sets @color to be the current color in the ColorButton widget.
func (b colorButton) Color() gdk.Color {
	var _arg0 *C.GtkColorButton // out
	var _color gdk.Color

	_arg0 = (*C.GtkColorButton)(unsafe.Pointer(b.Native()))

	C.gtk_color_button_get_color(_arg0, (*C.GdkColor)(unsafe.Pointer(&_color)))

	return _color
}

// Title gets the title of the color selection dialog.
func (b colorButton) Title() string {
	var _arg0 *C.GtkColorButton // out
	var _cret *C.gchar          // in

	_arg0 = (*C.GtkColorButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_color_button_get_title(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// UseAlpha does the color selection dialog use the alpha channel ?
func (b colorButton) UseAlpha() bool {
	var _arg0 *C.GtkColorButton // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkColorButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_color_button_get_use_alpha(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetAlpha sets the current opacity to be @alpha.
func (b colorButton) SetAlpha(alpha uint16) {
	var _arg0 *C.GtkColorButton // out
	var _arg1 C.guint16         // out

	_arg0 = (*C.GtkColorButton)(unsafe.Pointer(b.Native()))
	_arg1 = (C.guint16)(alpha)

	C.gtk_color_button_set_alpha(_arg0, _arg1)
}

// SetColor sets the current color to be @color.
func (b colorButton) SetColor(color *gdk.Color) {
	var _arg0 *C.GtkColorButton // out
	var _arg1 *C.GdkColor       // out

	_arg0 = (*C.GtkColorButton)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GdkColor)(unsafe.Pointer(color.Native()))

	C.gtk_color_button_set_color(_arg0, _arg1)
}

// SetTitle sets the title for the color selection dialog.
func (b colorButton) SetTitle(title string) {
	var _arg0 *C.GtkColorButton // out
	var _arg1 *C.gchar          // out

	_arg0 = (*C.GtkColorButton)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_color_button_set_title(_arg0, _arg1)
}

// SetUseAlpha sets whether or not the color button should use the alpha
// channel.
func (b colorButton) SetUseAlpha(useAlpha bool) {
	var _arg0 *C.GtkColorButton // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkColorButton)(unsafe.Pointer(b.Native()))
	if useAlpha {
		_arg1 = C.TRUE
	}

	C.gtk_color_button_set_use_alpha(_arg0, _arg1)
}

// ColorChooserDialog: the ColorChooserDialog widget is a dialog for choosing a
// color. It implements the ColorChooser interface.
type ColorChooserDialog interface {
	Dialog
	Buildable
	ColorChooser
}

// colorChooserDialog implements the ColorChooserDialog class.
type colorChooserDialog struct {
	Dialog
	Buildable
	ColorChooser
}

var _ ColorChooserDialog = (*colorChooserDialog)(nil)

// WrapColorChooserDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapColorChooserDialog(obj *externglib.Object) ColorChooserDialog {
	return colorChooserDialog{
		Dialog:       WrapDialog(obj),
		Buildable:    WrapBuildable(obj),
		ColorChooser: WrapColorChooser(obj),
	}
}

func marshalColorChooserDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapColorChooserDialog(obj), nil
}

// NewColorChooserDialog creates a new ColorChooserDialog.
func NewColorChooserDialog(title string, parent Window) ColorChooserDialog {
	var _arg1 *C.gchar     // out
	var _arg2 *C.GtkWindow // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))

	_cret = C.gtk_color_chooser_dialog_new(_arg1, _arg2)

	var _colorChooserDialog ColorChooserDialog // out

	_colorChooserDialog = WrapColorChooserDialog(externglib.Take(unsafe.Pointer(_cret)))

	return _colorChooserDialog
}

// ColorChooserWidget: the ColorChooserWidget widget lets the user select a
// color. By default, the chooser presents a predefined palette of colors, plus
// a small number of settable custom colors. It is also possible to select a
// different color with the single-color editor. To enter the single-color
// editing mode, use the context menu of any color of the palette, or use the
// '+' button to add a new custom color.
//
// The chooser automatically remembers the last selection, as well as custom
// colors.
//
// To change the initially selected color, use gtk_color_chooser_set_rgba(). To
// get the selected color use gtk_color_chooser_get_rgba().
//
// The ColorChooserWidget is used in the ColorChooserDialog to provide a dialog
// for selecting colors.
//
//
// CSS names
//
// GtkColorChooserWidget has a single CSS node with name colorchooser.
type ColorChooserWidget interface {
	Box
	Buildable
	ColorChooser
	Orientable
}

// colorChooserWidget implements the ColorChooserWidget class.
type colorChooserWidget struct {
	Box
	Buildable
	ColorChooser
	Orientable
}

var _ ColorChooserWidget = (*colorChooserWidget)(nil)

// WrapColorChooserWidget wraps a GObject to the right type. It is
// primarily used internally.
func WrapColorChooserWidget(obj *externglib.Object) ColorChooserWidget {
	return colorChooserWidget{
		Box:          WrapBox(obj),
		Buildable:    WrapBuildable(obj),
		ColorChooser: WrapColorChooser(obj),
		Orientable:   WrapOrientable(obj),
	}
}

func marshalColorChooserWidget(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapColorChooserWidget(obj), nil
}

// NewColorChooserWidget creates a new ColorChooserWidget.
func NewColorChooserWidget() ColorChooserWidget {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_color_chooser_widget_new()

	var _colorChooserWidget ColorChooserWidget // out

	_colorChooserWidget = WrapColorChooserWidget(externglib.Take(unsafe.Pointer(_cret)))

	return _colorChooserWidget
}

type ColorSelection interface {
	Box
	Buildable
	Orientable

	// CurrentAlpha returns the current alpha value.
	CurrentAlpha() uint16
	// CurrentColor sets @color to be the current color in the GtkColorSelection
	// widget.
	CurrentColor() gdk.Color
	// CurrentRGBA sets @rgba to be the current color in the GtkColorSelection
	// widget.
	CurrentRGBA() gdk.RGBA
	// HasOpacityControl determines whether the colorsel has an opacity control.
	HasOpacityControl() bool
	// HasPalette determines whether the color selector has a color palette.
	HasPalette() bool
	// PreviousAlpha returns the previous alpha value.
	PreviousAlpha() uint16
	// PreviousColor fills @color in with the original color value.
	PreviousColor() gdk.Color
	// PreviousRGBA fills @rgba in with the original color value.
	PreviousRGBA() gdk.RGBA
	// IsAdjusting gets the current state of the @colorsel.
	IsAdjusting() bool
	// SetCurrentAlpha sets the current opacity to be @alpha.
	//
	// The first time this is called, it will also set the original opacity to
	// be @alpha too.
	SetCurrentAlpha(alpha uint16)
	// SetCurrentColor sets the current color to be @color.
	//
	// The first time this is called, it will also set the original color to be
	// @color too.
	SetCurrentColor(color *gdk.Color)
	// SetCurrentRGBA sets the current color to be @rgba.
	//
	// The first time this is called, it will also set the original color to be
	// @rgba too.
	SetCurrentRGBA(rgba *gdk.RGBA)
	// SetHasOpacityControl sets the @colorsel to use or not use opacity.
	SetHasOpacityControl(hasOpacity bool)
	// SetHasPalette shows and hides the palette based upon the value of
	// @has_palette.
	SetHasPalette(hasPalette bool)
	// SetPreviousAlpha sets the “previous” alpha to be @alpha.
	//
	// This function should be called with some hesitations, as it might seem
	// confusing to have that alpha change.
	SetPreviousAlpha(alpha uint16)
	// SetPreviousColor sets the “previous” color to be @color.
	//
	// This function should be called with some hesitations, as it might seem
	// confusing to have that color change. Calling
	// gtk_color_selection_set_current_color() will also set this color the
	// first time it is called.
	SetPreviousColor(color *gdk.Color)
	// SetPreviousRGBA sets the “previous” color to be @rgba.
	//
	// This function should be called with some hesitations, as it might seem
	// confusing to have that color change. Calling
	// gtk_color_selection_set_current_rgba() will also set this color the first
	// time it is called.
	SetPreviousRGBA(rgba *gdk.RGBA)
}

// colorSelection implements the ColorSelection class.
type colorSelection struct {
	Box
	Buildable
	Orientable
}

var _ ColorSelection = (*colorSelection)(nil)

// WrapColorSelection wraps a GObject to the right type. It is
// primarily used internally.
func WrapColorSelection(obj *externglib.Object) ColorSelection {
	return colorSelection{
		Box:        WrapBox(obj),
		Buildable:  WrapBuildable(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalColorSelection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapColorSelection(obj), nil
}

// NewColorSelection creates a new GtkColorSelection.
func NewColorSelection() ColorSelection {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_color_selection_new()

	var _colorSelection ColorSelection // out

	_colorSelection = WrapColorSelection(externglib.Take(unsafe.Pointer(_cret)))

	return _colorSelection
}

// CurrentAlpha returns the current alpha value.
func (c colorSelection) CurrentAlpha() uint16 {
	var _arg0 *C.GtkColorSelection // out
	var _cret C.guint16            // in

	_arg0 = (*C.GtkColorSelection)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_color_selection_get_current_alpha(_arg0)

	var _guint16 uint16 // out

	_guint16 = (uint16)(_cret)

	return _guint16
}

// CurrentColor sets @color to be the current color in the GtkColorSelection
// widget.
func (c colorSelection) CurrentColor() gdk.Color {
	var _arg0 *C.GtkColorSelection // out
	var _color gdk.Color

	_arg0 = (*C.GtkColorSelection)(unsafe.Pointer(c.Native()))

	C.gtk_color_selection_get_current_color(_arg0, (*C.GdkColor)(unsafe.Pointer(&_color)))

	return _color
}

// CurrentRGBA sets @rgba to be the current color in the GtkColorSelection
// widget.
func (c colorSelection) CurrentRGBA() gdk.RGBA {
	var _arg0 *C.GtkColorSelection // out
	var _rgba gdk.RGBA

	_arg0 = (*C.GtkColorSelection)(unsafe.Pointer(c.Native()))

	C.gtk_color_selection_get_current_rgba(_arg0, (*C.GdkRGBA)(unsafe.Pointer(&_rgba)))

	return _rgba
}

// HasOpacityControl determines whether the colorsel has an opacity control.
func (c colorSelection) HasOpacityControl() bool {
	var _arg0 *C.GtkColorSelection // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkColorSelection)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_color_selection_get_has_opacity_control(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasPalette determines whether the color selector has a color palette.
func (c colorSelection) HasPalette() bool {
	var _arg0 *C.GtkColorSelection // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkColorSelection)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_color_selection_get_has_palette(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PreviousAlpha returns the previous alpha value.
func (c colorSelection) PreviousAlpha() uint16 {
	var _arg0 *C.GtkColorSelection // out
	var _cret C.guint16            // in

	_arg0 = (*C.GtkColorSelection)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_color_selection_get_previous_alpha(_arg0)

	var _guint16 uint16 // out

	_guint16 = (uint16)(_cret)

	return _guint16
}

// PreviousColor fills @color in with the original color value.
func (c colorSelection) PreviousColor() gdk.Color {
	var _arg0 *C.GtkColorSelection // out
	var _color gdk.Color

	_arg0 = (*C.GtkColorSelection)(unsafe.Pointer(c.Native()))

	C.gtk_color_selection_get_previous_color(_arg0, (*C.GdkColor)(unsafe.Pointer(&_color)))

	return _color
}

// PreviousRGBA fills @rgba in with the original color value.
func (c colorSelection) PreviousRGBA() gdk.RGBA {
	var _arg0 *C.GtkColorSelection // out
	var _rgba gdk.RGBA

	_arg0 = (*C.GtkColorSelection)(unsafe.Pointer(c.Native()))

	C.gtk_color_selection_get_previous_rgba(_arg0, (*C.GdkRGBA)(unsafe.Pointer(&_rgba)))

	return _rgba
}

// IsAdjusting gets the current state of the @colorsel.
func (c colorSelection) IsAdjusting() bool {
	var _arg0 *C.GtkColorSelection // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkColorSelection)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_color_selection_is_adjusting(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetCurrentAlpha sets the current opacity to be @alpha.
//
// The first time this is called, it will also set the original opacity to be
// @alpha too.
func (c colorSelection) SetCurrentAlpha(alpha uint16) {
	var _arg0 *C.GtkColorSelection // out
	var _arg1 C.guint16            // out

	_arg0 = (*C.GtkColorSelection)(unsafe.Pointer(c.Native()))
	_arg1 = (C.guint16)(alpha)

	C.gtk_color_selection_set_current_alpha(_arg0, _arg1)
}

// SetCurrentColor sets the current color to be @color.
//
// The first time this is called, it will also set the original color to be
// @color too.
func (c colorSelection) SetCurrentColor(color *gdk.Color) {
	var _arg0 *C.GtkColorSelection // out
	var _arg1 *C.GdkColor          // out

	_arg0 = (*C.GtkColorSelection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GdkColor)(unsafe.Pointer(color.Native()))

	C.gtk_color_selection_set_current_color(_arg0, _arg1)
}

// SetCurrentRGBA sets the current color to be @rgba.
//
// The first time this is called, it will also set the original color to be
// @rgba too.
func (c colorSelection) SetCurrentRGBA(rgba *gdk.RGBA) {
	var _arg0 *C.GtkColorSelection // out
	var _arg1 *C.GdkRGBA           // out

	_arg0 = (*C.GtkColorSelection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GdkRGBA)(unsafe.Pointer(rgba.Native()))

	C.gtk_color_selection_set_current_rgba(_arg0, _arg1)
}

// SetHasOpacityControl sets the @colorsel to use or not use opacity.
func (c colorSelection) SetHasOpacityControl(hasOpacity bool) {
	var _arg0 *C.GtkColorSelection // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkColorSelection)(unsafe.Pointer(c.Native()))
	if hasOpacity {
		_arg1 = C.TRUE
	}

	C.gtk_color_selection_set_has_opacity_control(_arg0, _arg1)
}

// SetHasPalette shows and hides the palette based upon the value of
// @has_palette.
func (c colorSelection) SetHasPalette(hasPalette bool) {
	var _arg0 *C.GtkColorSelection // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkColorSelection)(unsafe.Pointer(c.Native()))
	if hasPalette {
		_arg1 = C.TRUE
	}

	C.gtk_color_selection_set_has_palette(_arg0, _arg1)
}

// SetPreviousAlpha sets the “previous” alpha to be @alpha.
//
// This function should be called with some hesitations, as it might seem
// confusing to have that alpha change.
func (c colorSelection) SetPreviousAlpha(alpha uint16) {
	var _arg0 *C.GtkColorSelection // out
	var _arg1 C.guint16            // out

	_arg0 = (*C.GtkColorSelection)(unsafe.Pointer(c.Native()))
	_arg1 = (C.guint16)(alpha)

	C.gtk_color_selection_set_previous_alpha(_arg0, _arg1)
}

// SetPreviousColor sets the “previous” color to be @color.
//
// This function should be called with some hesitations, as it might seem
// confusing to have that color change. Calling
// gtk_color_selection_set_current_color() will also set this color the first
// time it is called.
func (c colorSelection) SetPreviousColor(color *gdk.Color) {
	var _arg0 *C.GtkColorSelection // out
	var _arg1 *C.GdkColor          // out

	_arg0 = (*C.GtkColorSelection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GdkColor)(unsafe.Pointer(color.Native()))

	C.gtk_color_selection_set_previous_color(_arg0, _arg1)
}

// SetPreviousRGBA sets the “previous” color to be @rgba.
//
// This function should be called with some hesitations, as it might seem
// confusing to have that color change. Calling
// gtk_color_selection_set_current_rgba() will also set this color the first
// time it is called.
func (c colorSelection) SetPreviousRGBA(rgba *gdk.RGBA) {
	var _arg0 *C.GtkColorSelection // out
	var _arg1 *C.GdkRGBA           // out

	_arg0 = (*C.GtkColorSelection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GdkRGBA)(unsafe.Pointer(rgba.Native()))

	C.gtk_color_selection_set_previous_rgba(_arg0, _arg1)
}

type ColorSelectionDialog interface {
	Dialog
	Buildable

	// ColorSelection retrieves the ColorSelection widget embedded in the
	// dialog.
	ColorSelection() Widget
}

// colorSelectionDialog implements the ColorSelectionDialog class.
type colorSelectionDialog struct {
	Dialog
	Buildable
}

var _ ColorSelectionDialog = (*colorSelectionDialog)(nil)

// WrapColorSelectionDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapColorSelectionDialog(obj *externglib.Object) ColorSelectionDialog {
	return colorSelectionDialog{
		Dialog:    WrapDialog(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalColorSelectionDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapColorSelectionDialog(obj), nil
}

// NewColorSelectionDialog creates a new ColorSelectionDialog.
func NewColorSelectionDialog(title string) ColorSelectionDialog {
	var _arg1 *C.gchar     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_color_selection_dialog_new(_arg1)

	var _colorSelectionDialog ColorSelectionDialog // out

	_colorSelectionDialog = WrapColorSelectionDialog(externglib.Take(unsafe.Pointer(_cret)))

	return _colorSelectionDialog
}

// ColorSelection retrieves the ColorSelection widget embedded in the dialog.
func (c colorSelectionDialog) ColorSelection() Widget {
	var _arg0 *C.GtkColorSelectionDialog // out
	var _cret *C.GtkWidget               // in

	_arg0 = (*C.GtkColorSelectionDialog)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_color_selection_dialog_get_color_selection(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// ComboBox: a GtkComboBox is a widget that allows the user to choose from a
// list of valid choices. The GtkComboBox displays the selected choice. When
// activated, the GtkComboBox displays a popup which allows the user to make a
// new choice. The style in which the selected value is displayed, and the style
// of the popup is determined by the current theme. It may be similar to a
// Windows-style combo box.
//
// The GtkComboBox uses the model-view pattern; the list of valid choices is
// specified in the form of a tree model, and the display of the choices can be
// adapted to the data in the model by using cell renderers, as you would in a
// tree view. This is possible since GtkComboBox implements the CellLayout
// interface. The tree model holding the valid choices is not restricted to a
// flat list, it can be a real tree, and the popup will reflect the tree
// structure.
//
// To allow the user to enter values not in the model, the “has-entry” property
// allows the GtkComboBox to contain a Entry. This entry can be accessed by
// calling gtk_bin_get_child() on the combo box.
//
// For a simple list of textual choices, the model-view API of GtkComboBox can
// be a bit overwhelming. In this case, ComboBoxText offers a simple
// alternative. Both GtkComboBox and ComboBoxText can contain an entry.
//
// CSS nodes
//
//    combobox
//    ├── box.linked
//    │   ├── entry.combo
//    │   ╰── button.combo
//    │       ╰── box
//    │           ╰── arrow
//    ╰── window.popup
//
// A GtkComboBox with an entry has a single CSS node with name combobox. It
// contains a box with the .linked class. That box contains an entry and a
// button, both with the .combo class added. The button also contains another
// node with name arrow.
type ComboBox interface {
	Bin
	Buildable
	CellEditable
	CellLayout

	// Active returns the index of the currently active item, or -1 if there’s
	// no active item. If the model is a non-flat treemodel, and the active item
	// is not an immediate child of the root of the tree, this function returns
	// `gtk_tree_path_get_indices (path)[0]`, where `path` is the TreePath of
	// the active item.
	Active() int
	// ActiveID returns the ID of the active row of @combo_box. This value is
	// taken from the active row and the column specified by the
	// ComboBox:id-column property of @combo_box (see
	// gtk_combo_box_set_id_column()).
	//
	// The returned value is an interned string which means that you can compare
	// the pointer by value to other interned strings and that you must not free
	// it.
	//
	// If the ComboBox:id-column property of @combo_box is not set, or if no row
	// is active, or if the active row has a nil ID value, then nil is returned.
	ActiveID() string
	// ActiveIter sets @iter to point to the currently active item, if any item
	// is active. Otherwise, @iter is left unchanged.
	ActiveIter() (TreeIter, bool)
	// AddTearoffs gets the current value of the :add-tearoffs property.
	AddTearoffs() bool
	// ButtonSensitivity returns whether the combo box sets the dropdown button
	// sensitive or not when there are no items in the model.
	ButtonSensitivity() SensitivityType
	// ColumnSpanColumn returns the column with column span information for
	// @combo_box.
	ColumnSpanColumn() int
	// EntryTextColumn returns the column which @combo_box is using to get the
	// strings from to display in the internal entry.
	EntryTextColumn() int
	// FocusOnClick returns whether the combo box grabs focus when it is clicked
	// with the mouse. See gtk_combo_box_set_focus_on_click().
	FocusOnClick() bool
	// HasEntry returns whether the combo box has an entry.
	HasEntry() bool
	// IDColumn returns the column which @combo_box is using to get string IDs
	// for values from.
	IDColumn() int
	// Model returns the TreeModel which is acting as data source for
	// @combo_box.
	Model() TreeModel
	// PopupFixedWidth gets whether the popup uses a fixed width matching the
	// allocated width of the combo box.
	PopupFixedWidth() bool
	// RowSpanColumn returns the column with row span information for
	// @combo_box.
	RowSpanColumn() int
	// Title gets the current title of the menu in tearoff mode. See
	// gtk_combo_box_set_add_tearoffs().
	Title() string
	// WrapWidth returns the wrap width which is used to determine the number of
	// columns for the popup menu. If the wrap width is larger than 1, the combo
	// box is in table mode.
	WrapWidth() int
	// Popdown hides the menu or dropdown list of @combo_box.
	//
	// This function is mostly intended for use by accessibility technologies;
	// applications should have little use for it.
	Popdown()
	// Popup pops up the menu or dropdown list of @combo_box.
	//
	// This function is mostly intended for use by accessibility technologies;
	// applications should have little use for it.
	//
	// Before calling this, @combo_box must be mapped, or nothing will happen.
	Popup()
	// PopupForDevice pops up the menu or dropdown list of @combo_box, the popup
	// window will be grabbed so only @device and its associated
	// pointer/keyboard are the only Devices able to send events to it.
	PopupForDevice(device gdk.Device)
	// SetActive sets the active item of @combo_box to be the item at @index.
	SetActive(index_ int)
	// SetActiveID changes the active row of @combo_box to the one that has an
	// ID equal to @active_id, or unsets the active row if @active_id is nil.
	// Rows having a nil ID string cannot be made active by this function.
	//
	// If the ComboBox:id-column property of @combo_box is unset or if no row
	// has the given ID then the function does nothing and returns false.
	SetActiveID(activeId string) bool
	// SetActiveIter sets the current active item to be the one referenced by
	// @iter, or unsets the active item if @iter is nil.
	SetActiveIter(iter *TreeIter)
	// SetAddTearoffs sets whether the popup menu should have a tearoff menu
	// item.
	SetAddTearoffs(addTearoffs bool)
	// SetButtonSensitivity sets whether the dropdown button of the combo box
	// should be always sensitive (GTK_SENSITIVITY_ON), never sensitive
	// (GTK_SENSITIVITY_OFF) or only if there is at least one item to display
	// (GTK_SENSITIVITY_AUTO).
	SetButtonSensitivity(sensitivity SensitivityType)
	// SetColumnSpanColumn sets the column with column span information for
	// @combo_box to be @column_span. The column span column contains integers
	// which indicate how many columns an item should span.
	SetColumnSpanColumn(columnSpan int)
	// SetEntryTextColumn sets the model column which @combo_box should use to
	// get strings from to be @text_column. The column @text_column in the model
	// of @combo_box must be of type G_TYPE_STRING.
	//
	// This is only relevant if @combo_box has been created with
	// ComboBox:has-entry as true.
	SetEntryTextColumn(textColumn int)
	// SetFocusOnClick sets whether the combo box will grab focus when it is
	// clicked with the mouse. Making mouse clicks not grab focus is useful in
	// places like toolbars where you don’t want the keyboard focus removed from
	// the main area of the application.
	SetFocusOnClick(focusOnClick bool)
	// SetIDColumn sets the model column which @combo_box should use to get
	// string IDs for values from. The column @id_column in the model of
	// @combo_box must be of type G_TYPE_STRING.
	SetIDColumn(idColumn int)
	// SetModel sets the model used by @combo_box to be @model. Will unset a
	// previously set model (if applicable). If model is nil, then it will unset
	// the model.
	//
	// Note that this function does not clear the cell renderers, you have to
	// call gtk_cell_layout_clear() yourself if you need to set up different
	// cell renderers for the new model.
	SetModel(model TreeModel)
	// SetPopupFixedWidth specifies whether the popup’s width should be a fixed
	// width matching the allocated width of the combo box.
	SetPopupFixedWidth(fixed bool)
	// SetRowSpanColumn sets the column with row span information for @combo_box
	// to be @row_span. The row span column contains integers which indicate how
	// many rows an item should span.
	SetRowSpanColumn(rowSpan int)
	// SetTitle sets the menu’s title in tearoff mode.
	SetTitle(title string)
	// SetWrapWidth sets the wrap width of @combo_box to be @width. The wrap
	// width is basically the preferred number of columns when you want the
	// popup to be layed out in a table.
	SetWrapWidth(width int)
}

// comboBox implements the ComboBox class.
type comboBox struct {
	Bin
	Buildable
	CellEditable
	CellLayout
}

var _ ComboBox = (*comboBox)(nil)

// WrapComboBox wraps a GObject to the right type. It is
// primarily used internally.
func WrapComboBox(obj *externglib.Object) ComboBox {
	return comboBox{
		Bin:          WrapBin(obj),
		Buildable:    WrapBuildable(obj),
		CellEditable: WrapCellEditable(obj),
		CellLayout:   WrapCellLayout(obj),
	}
}

func marshalComboBox(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapComboBox(obj), nil
}

// NewComboBox creates a new empty ComboBox.
func NewComboBox() ComboBox {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_combo_box_new()

	var _comboBox ComboBox // out

	_comboBox = WrapComboBox(externglib.Take(unsafe.Pointer(_cret)))

	return _comboBox
}

// NewComboBoxWithArea creates a new empty ComboBox using @area to layout cells.
func NewComboBoxWithArea(area CellArea) ComboBox {
	var _arg1 *C.GtkCellArea // out
	var _cret *C.GtkWidget   // in

	_arg1 = (*C.GtkCellArea)(unsafe.Pointer(area.Native()))

	_cret = C.gtk_combo_box_new_with_area(_arg1)

	var _comboBox ComboBox // out

	_comboBox = WrapComboBox(externglib.Take(unsafe.Pointer(_cret)))

	return _comboBox
}

// NewComboBoxWithAreaAndEntry creates a new empty ComboBox with an entry.
//
// The new combo box will use @area to layout cells.
func NewComboBoxWithAreaAndEntry(area CellArea) ComboBox {
	var _arg1 *C.GtkCellArea // out
	var _cret *C.GtkWidget   // in

	_arg1 = (*C.GtkCellArea)(unsafe.Pointer(area.Native()))

	_cret = C.gtk_combo_box_new_with_area_and_entry(_arg1)

	var _comboBox ComboBox // out

	_comboBox = WrapComboBox(externglib.Take(unsafe.Pointer(_cret)))

	return _comboBox
}

// NewComboBoxWithEntry creates a new empty ComboBox with an entry.
func NewComboBoxWithEntry() ComboBox {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_combo_box_new_with_entry()

	var _comboBox ComboBox // out

	_comboBox = WrapComboBox(externglib.Take(unsafe.Pointer(_cret)))

	return _comboBox
}

// NewComboBoxWithModel creates a new ComboBox with the model initialized to
// @model.
func NewComboBoxWithModel(model TreeModel) ComboBox {
	var _arg1 *C.GtkTreeModel // out
	var _cret *C.GtkWidget    // in

	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

	_cret = C.gtk_combo_box_new_with_model(_arg1)

	var _comboBox ComboBox // out

	_comboBox = WrapComboBox(externglib.Take(unsafe.Pointer(_cret)))

	return _comboBox
}

// NewComboBoxWithModelAndEntry creates a new empty ComboBox with an entry and
// with the model initialized to @model.
func NewComboBoxWithModelAndEntry(model TreeModel) ComboBox {
	var _arg1 *C.GtkTreeModel // out
	var _cret *C.GtkWidget    // in

	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

	_cret = C.gtk_combo_box_new_with_model_and_entry(_arg1)

	var _comboBox ComboBox // out

	_comboBox = WrapComboBox(externglib.Take(unsafe.Pointer(_cret)))

	return _comboBox
}

// Active returns the index of the currently active item, or -1 if there’s no
// active item. If the model is a non-flat treemodel, and the active item is not
// an immediate child of the root of the tree, this function returns
// `gtk_tree_path_get_indices (path)[0]`, where `path` is the TreePath of the
// active item.
func (c comboBox) Active() int {
	var _arg0 *C.GtkComboBox // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_combo_box_get_active(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// ActiveID returns the ID of the active row of @combo_box. This value is taken
// from the active row and the column specified by the ComboBox:id-column
// property of @combo_box (see gtk_combo_box_set_id_column()).
//
// The returned value is an interned string which means that you can compare the
// pointer by value to other interned strings and that you must not free it.
//
// If the ComboBox:id-column property of @combo_box is not set, or if no row is
// active, or if the active row has a nil ID value, then nil is returned.
func (c comboBox) ActiveID() string {
	var _arg0 *C.GtkComboBox // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_combo_box_get_active_id(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// ActiveIter sets @iter to point to the currently active item, if any item is
// active. Otherwise, @iter is left unchanged.
func (c comboBox) ActiveIter() (TreeIter, bool) {
	var _arg0 *C.GtkComboBox // out
	var _iter TreeIter
	var _cret C.gboolean // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_combo_box_get_active_iter(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// AddTearoffs gets the current value of the :add-tearoffs property.
func (c comboBox) AddTearoffs() bool {
	var _arg0 *C.GtkComboBox // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_combo_box_get_add_tearoffs(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ButtonSensitivity returns whether the combo box sets the dropdown button
// sensitive or not when there are no items in the model.
func (c comboBox) ButtonSensitivity() SensitivityType {
	var _arg0 *C.GtkComboBox       // out
	var _cret C.GtkSensitivityType // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_combo_box_get_button_sensitivity(_arg0)

	var _sensitivityType SensitivityType // out

	_sensitivityType = SensitivityType(_cret)

	return _sensitivityType
}

// ColumnSpanColumn returns the column with column span information for
// @combo_box.
func (c comboBox) ColumnSpanColumn() int {
	var _arg0 *C.GtkComboBox // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_combo_box_get_column_span_column(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// EntryTextColumn returns the column which @combo_box is using to get the
// strings from to display in the internal entry.
func (c comboBox) EntryTextColumn() int {
	var _arg0 *C.GtkComboBox // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_combo_box_get_entry_text_column(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// FocusOnClick returns whether the combo box grabs focus when it is clicked
// with the mouse. See gtk_combo_box_set_focus_on_click().
func (c comboBox) FocusOnClick() bool {
	var _arg0 *C.GtkComboBox // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_combo_box_get_focus_on_click(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasEntry returns whether the combo box has an entry.
func (c comboBox) HasEntry() bool {
	var _arg0 *C.GtkComboBox // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_combo_box_get_has_entry(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IDColumn returns the column which @combo_box is using to get string IDs for
// values from.
func (c comboBox) IDColumn() int {
	var _arg0 *C.GtkComboBox // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_combo_box_get_id_column(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Model returns the TreeModel which is acting as data source for @combo_box.
func (c comboBox) Model() TreeModel {
	var _arg0 *C.GtkComboBox  // out
	var _cret *C.GtkTreeModel // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_combo_box_get_model(_arg0)

	var _treeModel TreeModel // out

	_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeModel)

	return _treeModel
}

// PopupFixedWidth gets whether the popup uses a fixed width matching the
// allocated width of the combo box.
func (c comboBox) PopupFixedWidth() bool {
	var _arg0 *C.GtkComboBox // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_combo_box_get_popup_fixed_width(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RowSpanColumn returns the column with row span information for @combo_box.
func (c comboBox) RowSpanColumn() int {
	var _arg0 *C.GtkComboBox // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_combo_box_get_row_span_column(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Title gets the current title of the menu in tearoff mode. See
// gtk_combo_box_set_add_tearoffs().
func (c comboBox) Title() string {
	var _arg0 *C.GtkComboBox // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_combo_box_get_title(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// WrapWidth returns the wrap width which is used to determine the number of
// columns for the popup menu. If the wrap width is larger than 1, the combo box
// is in table mode.
func (c comboBox) WrapWidth() int {
	var _arg0 *C.GtkComboBox // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_combo_box_get_wrap_width(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Popdown hides the menu or dropdown list of @combo_box.
//
// This function is mostly intended for use by accessibility technologies;
// applications should have little use for it.
func (c comboBox) Popdown() {
	var _arg0 *C.GtkComboBox // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

	C.gtk_combo_box_popdown(_arg0)
}

// Popup pops up the menu or dropdown list of @combo_box.
//
// This function is mostly intended for use by accessibility technologies;
// applications should have little use for it.
//
// Before calling this, @combo_box must be mapped, or nothing will happen.
func (c comboBox) Popup() {
	var _arg0 *C.GtkComboBox // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

	C.gtk_combo_box_popup(_arg0)
}

// PopupForDevice pops up the menu or dropdown list of @combo_box, the popup
// window will be grabbed so only @device and its associated pointer/keyboard
// are the only Devices able to send events to it.
func (c comboBox) PopupForDevice(device gdk.Device) {
	var _arg0 *C.GtkComboBox // out
	var _arg1 *C.GdkDevice   // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))

	C.gtk_combo_box_popup_for_device(_arg0, _arg1)
}

// SetActive sets the active item of @combo_box to be the item at @index.
func (c comboBox) SetActive(index_ int) {
	var _arg0 *C.GtkComboBox // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
	_arg1 = (C.gint)(index_)

	C.gtk_combo_box_set_active(_arg0, _arg1)
}

// SetActiveID changes the active row of @combo_box to the one that has an ID
// equal to @active_id, or unsets the active row if @active_id is nil. Rows
// having a nil ID string cannot be made active by this function.
//
// If the ComboBox:id-column property of @combo_box is unset or if no row has
// the given ID then the function does nothing and returns false.
func (c comboBox) SetActiveID(activeId string) bool {
	var _arg0 *C.GtkComboBox // out
	var _arg1 *C.gchar       // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(activeId))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_combo_box_set_active_id(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetActiveIter sets the current active item to be the one referenced by @iter,
// or unsets the active item if @iter is nil.
func (c comboBox) SetActiveIter(iter *TreeIter) {
	var _arg0 *C.GtkComboBox // out
	var _arg1 *C.GtkTreeIter // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	C.gtk_combo_box_set_active_iter(_arg0, _arg1)
}

// SetAddTearoffs sets whether the popup menu should have a tearoff menu item.
func (c comboBox) SetAddTearoffs(addTearoffs bool) {
	var _arg0 *C.GtkComboBox // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
	if addTearoffs {
		_arg1 = C.TRUE
	}

	C.gtk_combo_box_set_add_tearoffs(_arg0, _arg1)
}

// SetButtonSensitivity sets whether the dropdown button of the combo box should
// be always sensitive (GTK_SENSITIVITY_ON), never sensitive
// (GTK_SENSITIVITY_OFF) or only if there is at least one item to display
// (GTK_SENSITIVITY_AUTO).
func (c comboBox) SetButtonSensitivity(sensitivity SensitivityType) {
	var _arg0 *C.GtkComboBox       // out
	var _arg1 C.GtkSensitivityType // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GtkSensitivityType)(sensitivity)

	C.gtk_combo_box_set_button_sensitivity(_arg0, _arg1)
}

// SetColumnSpanColumn sets the column with column span information for
// @combo_box to be @column_span. The column span column contains integers which
// indicate how many columns an item should span.
func (c comboBox) SetColumnSpanColumn(columnSpan int) {
	var _arg0 *C.GtkComboBox // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
	_arg1 = (C.gint)(columnSpan)

	C.gtk_combo_box_set_column_span_column(_arg0, _arg1)
}

// SetEntryTextColumn sets the model column which @combo_box should use to get
// strings from to be @text_column. The column @text_column in the model of
// @combo_box must be of type G_TYPE_STRING.
//
// This is only relevant if @combo_box has been created with ComboBox:has-entry
// as true.
func (c comboBox) SetEntryTextColumn(textColumn int) {
	var _arg0 *C.GtkComboBox // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
	_arg1 = (C.gint)(textColumn)

	C.gtk_combo_box_set_entry_text_column(_arg0, _arg1)
}

// SetFocusOnClick sets whether the combo box will grab focus when it is clicked
// with the mouse. Making mouse clicks not grab focus is useful in places like
// toolbars where you don’t want the keyboard focus removed from the main area
// of the application.
func (c comboBox) SetFocusOnClick(focusOnClick bool) {
	var _arg0 *C.GtkComboBox // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
	if focusOnClick {
		_arg1 = C.TRUE
	}

	C.gtk_combo_box_set_focus_on_click(_arg0, _arg1)
}

// SetIDColumn sets the model column which @combo_box should use to get string
// IDs for values from. The column @id_column in the model of @combo_box must be
// of type G_TYPE_STRING.
func (c comboBox) SetIDColumn(idColumn int) {
	var _arg0 *C.GtkComboBox // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
	_arg1 = (C.gint)(idColumn)

	C.gtk_combo_box_set_id_column(_arg0, _arg1)
}

// SetModel sets the model used by @combo_box to be @model. Will unset a
// previously set model (if applicable). If model is nil, then it will unset the
// model.
//
// Note that this function does not clear the cell renderers, you have to call
// gtk_cell_layout_clear() yourself if you need to set up different cell
// renderers for the new model.
func (c comboBox) SetModel(model TreeModel) {
	var _arg0 *C.GtkComboBox  // out
	var _arg1 *C.GtkTreeModel // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

	C.gtk_combo_box_set_model(_arg0, _arg1)
}

// SetPopupFixedWidth specifies whether the popup’s width should be a fixed
// width matching the allocated width of the combo box.
func (c comboBox) SetPopupFixedWidth(fixed bool) {
	var _arg0 *C.GtkComboBox // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
	if fixed {
		_arg1 = C.TRUE
	}

	C.gtk_combo_box_set_popup_fixed_width(_arg0, _arg1)
}

// SetRowSpanColumn sets the column with row span information for @combo_box to
// be @row_span. The row span column contains integers which indicate how many
// rows an item should span.
func (c comboBox) SetRowSpanColumn(rowSpan int) {
	var _arg0 *C.GtkComboBox // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
	_arg1 = (C.gint)(rowSpan)

	C.gtk_combo_box_set_row_span_column(_arg0, _arg1)
}

// SetTitle sets the menu’s title in tearoff mode.
func (c comboBox) SetTitle(title string) {
	var _arg0 *C.GtkComboBox // out
	var _arg1 *C.gchar       // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_combo_box_set_title(_arg0, _arg1)
}

// SetWrapWidth sets the wrap width of @combo_box to be @width. The wrap width
// is basically the preferred number of columns when you want the popup to be
// layed out in a table.
func (c comboBox) SetWrapWidth(width int) {
	var _arg0 *C.GtkComboBox // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
	_arg1 = (C.gint)(width)

	C.gtk_combo_box_set_wrap_width(_arg0, _arg1)
}

type ComboBoxAccessible interface {
	ContainerAccessible
}

// comboBoxAccessible implements the ComboBoxAccessible class.
type comboBoxAccessible struct {
	ContainerAccessible
}

var _ ComboBoxAccessible = (*comboBoxAccessible)(nil)

// WrapComboBoxAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapComboBoxAccessible(obj *externglib.Object) ComboBoxAccessible {
	return comboBoxAccessible{
		ContainerAccessible: WrapContainerAccessible(obj),
	}
}

func marshalComboBoxAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapComboBoxAccessible(obj), nil
}

// ComboBoxText: a GtkComboBoxText is a simple variant of ComboBox that hides
// the model-view complexity for simple text-only use cases.
//
// To create a GtkComboBoxText, use gtk_combo_box_text_new() or
// gtk_combo_box_text_new_with_entry().
//
// You can add items to a GtkComboBoxText with gtk_combo_box_text_append_text(),
// gtk_combo_box_text_insert_text() or gtk_combo_box_text_prepend_text() and
// remove options with gtk_combo_box_text_remove().
//
// If the GtkComboBoxText contains an entry (via the “has-entry” property), its
// contents can be retrieved using gtk_combo_box_text_get_active_text(). The
// entry itself can be accessed by calling gtk_bin_get_child() on the combo box.
//
// You should not call gtk_combo_box_set_model() or attempt to pack more cells
// into this combo box via its GtkCellLayout interface.
//
//
// GtkComboBoxText as GtkBuildable
//
// The GtkComboBoxText implementation of the GtkBuildable interface supports
// adding items directly using the <items> element and specifying <item>
// elements for each item. Each <item> element can specify the “id”
// corresponding to the appended text and also supports the regular translation
// attributes “translatable”, “context” and “comments”.
//
// Here is a UI definition fragment specifying GtkComboBoxText items:
//
//    <object class="GtkComboBoxText">
//      <items>
//        <item translatable="yes" id="factory">Factory</item>
//        <item translatable="yes" id="home">Home</item>
//        <item translatable="yes" id="subway">Subway</item>
//      </items>
//    </object>
//
// CSS nodes
//
//    combobox
//    ╰── box.linked
//        ├── entry.combo
//        ├── button.combo
//        ╰── window.popup
//
// GtkComboBoxText has a single CSS node with name combobox. It adds the style
// class .combo to the main CSS nodes of its entry and button children, and the
// .linked class to the node of its internal box.
type ComboBoxText interface {
	ComboBox
	Buildable
	CellEditable
	CellLayout

	// Append appends @text to the list of strings stored in @combo_box. If @id
	// is non-nil then it is used as the ID of the row.
	//
	// This is the same as calling gtk_combo_box_text_insert() with a position
	// of -1.
	Append(id string, text string)
	// AppendText appends @text to the list of strings stored in @combo_box.
	//
	// This is the same as calling gtk_combo_box_text_insert_text() with a
	// position of -1.
	AppendText(text string)
	// ActiveText returns the currently active string in @combo_box, or nil if
	// none is selected. If @combo_box contains an entry, this function will
	// return its contents (which will not necessarily be an item from the
	// list).
	ActiveText() string
	// Insert inserts @text at @position in the list of strings stored in
	// @combo_box. If @id is non-nil then it is used as the ID of the row. See
	// ComboBox:id-column.
	//
	// If @position is negative then @text is appended.
	Insert(position int, id string, text string)
	// InsertText inserts @text at @position in the list of strings stored in
	// @combo_box.
	//
	// If @position is negative then @text is appended.
	//
	// This is the same as calling gtk_combo_box_text_insert() with a nil ID
	// string.
	InsertText(position int, text string)
	// Prepend prepends @text to the list of strings stored in @combo_box. If
	// @id is non-nil then it is used as the ID of the row.
	//
	// This is the same as calling gtk_combo_box_text_insert() with a position
	// of 0.
	Prepend(id string, text string)
	// PrependText prepends @text to the list of strings stored in @combo_box.
	//
	// This is the same as calling gtk_combo_box_text_insert_text() with a
	// position of 0.
	PrependText(text string)
	// Remove removes the string at @position from @combo_box.
	Remove(position int)
	// RemoveAll removes all the text entries from the combo box.
	RemoveAll()
}

// comboBoxText implements the ComboBoxText class.
type comboBoxText struct {
	ComboBox
	Buildable
	CellEditable
	CellLayout
}

var _ ComboBoxText = (*comboBoxText)(nil)

// WrapComboBoxText wraps a GObject to the right type. It is
// primarily used internally.
func WrapComboBoxText(obj *externglib.Object) ComboBoxText {
	return comboBoxText{
		ComboBox:     WrapComboBox(obj),
		Buildable:    WrapBuildable(obj),
		CellEditable: WrapCellEditable(obj),
		CellLayout:   WrapCellLayout(obj),
	}
}

func marshalComboBoxText(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapComboBoxText(obj), nil
}

// NewComboBoxText creates a new ComboBoxText, which is a ComboBox just
// displaying strings.
func NewComboBoxText() ComboBoxText {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_combo_box_text_new()

	var _comboBoxText ComboBoxText // out

	_comboBoxText = WrapComboBoxText(externglib.Take(unsafe.Pointer(_cret)))

	return _comboBoxText
}

// NewComboBoxTextWithEntry creates a new ComboBoxText, which is a ComboBox just
// displaying strings. The combo box created by this function has an entry.
func NewComboBoxTextWithEntry() ComboBoxText {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_combo_box_text_new_with_entry()

	var _comboBoxText ComboBoxText // out

	_comboBoxText = WrapComboBoxText(externglib.Take(unsafe.Pointer(_cret)))

	return _comboBoxText
}

// Append appends @text to the list of strings stored in @combo_box. If @id is
// non-nil then it is used as the ID of the row.
//
// This is the same as calling gtk_combo_box_text_insert() with a position of
// -1.
func (c comboBoxText) Append(id string, text string) {
	var _arg0 *C.GtkComboBoxText // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.gchar           // out

	_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(id))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_combo_box_text_append(_arg0, _arg1, _arg2)
}

// AppendText appends @text to the list of strings stored in @combo_box.
//
// This is the same as calling gtk_combo_box_text_insert_text() with a position
// of -1.
func (c comboBoxText) AppendText(text string) {
	var _arg0 *C.GtkComboBoxText // out
	var _arg1 *C.gchar           // out

	_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_combo_box_text_append_text(_arg0, _arg1)
}

// ActiveText returns the currently active string in @combo_box, or nil if none
// is selected. If @combo_box contains an entry, this function will return its
// contents (which will not necessarily be an item from the list).
func (c comboBoxText) ActiveText() string {
	var _arg0 *C.GtkComboBoxText // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_combo_box_text_get_active_text(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Insert inserts @text at @position in the list of strings stored in
// @combo_box. If @id is non-nil then it is used as the ID of the row. See
// ComboBox:id-column.
//
// If @position is negative then @text is appended.
func (c comboBoxText) Insert(position int, id string, text string) {
	var _arg0 *C.GtkComboBoxText // out
	var _arg1 C.gint             // out
	var _arg2 *C.gchar           // out
	var _arg3 *C.gchar           // out

	_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
	_arg1 = (C.gint)(position)
	_arg2 = (*C.gchar)(C.CString(id))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg3))

	C.gtk_combo_box_text_insert(_arg0, _arg1, _arg2, _arg3)
}

// InsertText inserts @text at @position in the list of strings stored in
// @combo_box.
//
// If @position is negative then @text is appended.
//
// This is the same as calling gtk_combo_box_text_insert() with a nil ID string.
func (c comboBoxText) InsertText(position int, text string) {
	var _arg0 *C.GtkComboBoxText // out
	var _arg1 C.gint             // out
	var _arg2 *C.gchar           // out

	_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
	_arg1 = (C.gint)(position)
	_arg2 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_combo_box_text_insert_text(_arg0, _arg1, _arg2)
}

// Prepend prepends @text to the list of strings stored in @combo_box. If @id is
// non-nil then it is used as the ID of the row.
//
// This is the same as calling gtk_combo_box_text_insert() with a position of 0.
func (c comboBoxText) Prepend(id string, text string) {
	var _arg0 *C.GtkComboBoxText // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.gchar           // out

	_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(id))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_combo_box_text_prepend(_arg0, _arg1, _arg2)
}

// PrependText prepends @text to the list of strings stored in @combo_box.
//
// This is the same as calling gtk_combo_box_text_insert_text() with a position
// of 0.
func (c comboBoxText) PrependText(text string) {
	var _arg0 *C.GtkComboBoxText // out
	var _arg1 *C.gchar           // out

	_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_combo_box_text_prepend_text(_arg0, _arg1)
}

// Remove removes the string at @position from @combo_box.
func (c comboBoxText) Remove(position int) {
	var _arg0 *C.GtkComboBoxText // out
	var _arg1 C.gint             // out

	_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
	_arg1 = (C.gint)(position)

	C.gtk_combo_box_text_remove(_arg0, _arg1)
}

// RemoveAll removes all the text entries from the combo box.
func (c comboBoxText) RemoveAll() {
	var _arg0 *C.GtkComboBoxText // out

	_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))

	C.gtk_combo_box_text_remove_all(_arg0)
}

// Container: a GTK+ user interface is constructed by nesting widgets inside
// widgets. Container widgets are the inner nodes in the resulting tree of
// widgets: they contain other widgets. So, for example, you might have a Window
// containing a Frame containing a Label. If you wanted an image instead of a
// textual label inside the frame, you might replace the Label widget with a
// Image widget.
//
// There are two major kinds of container widgets in GTK+. Both are subclasses
// of the abstract GtkContainer base class.
//
// The first type of container widget has a single child widget and derives from
// Bin. These containers are decorators, which add some kind of functionality to
// the child. For example, a Button makes its child into a clickable button; a
// Frame draws a frame around its child and a Window places its child widget
// inside a top-level window.
//
// The second type of container can have more than one child; its purpose is to
// manage layout. This means that these containers assign sizes and positions to
// their children. For example, a HBox arranges its children in a horizontal
// row, and a Grid arranges the widgets it contains in a two-dimensional grid.
//
// For implementations of Container the virtual method ContainerClass.forall()
// is always required, since it's used for drawing and other internal operations
// on the children. If the Container implementation expect to have non internal
// children it's needed to implement both ContainerClass.add() and
// ContainerClass.remove(). If the GtkContainer implementation has internal
// children, they should be added with gtk_widget_set_parent() on init() and
// removed with gtk_widget_unparent() in the WidgetClass.destroy()
// implementation. See more about implementing custom widgets at
// https://wiki.gnome.org/HowDoI/CustomWidgets
//
//
// Height for width geometry management
//
// GTK+ uses a height-for-width (and width-for-height) geometry management
// system. Height-for-width means that a widget can change how much vertical
// space it needs, depending on the amount of horizontal space that it is given
// (and similar for width-for-height).
//
// There are some things to keep in mind when implementing container widgets
// that make use of GTK+’s height for width geometry management system. First,
// it’s important to note that a container must prioritize one of its
// dimensions, that is to say that a widget or container can only have a
// SizeRequestMode that is GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH or
// GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT. However, every widget and container must
// be able to respond to the APIs for both dimensions, i.e. even if a widget has
// a request mode that is height-for-width, it is possible that its parent will
// request its sizes using the width-for-height APIs.
//
// To ensure that everything works properly, here are some guidelines to follow
// when implementing height-for-width (or width-for-height) containers.
//
// Each request mode involves 2 virtual methods. Height-for-width apis run
// through gtk_widget_get_preferred_width() and then through
// gtk_widget_get_preferred_height_for_width(). When handling requests in the
// opposite SizeRequestMode it is important that every widget request at least
// enough space to display all of its content at all times.
//
// When gtk_widget_get_preferred_height() is called on a container that is
// height-for-width, the container must return the height for its minimum width.
// This is easily achieved by simply calling the reverse apis implemented for
// itself as follows:
//
//    static void
//    foo_container_get_preferred_width_for_height (GtkWidget *widget,
//                                                  gint for_height,
//                                                  gint *min_width,
//                                                  gint *nat_width)
//    {
//       if (i_am_in_height_for_width_mode)
//         {
//           GTK_WIDGET_GET_CLASS (widget)->get_preferred_width (widget,
//                                                               min_width,
//                                                               nat_width);
//         }
//       else
//         {
//           ... execute the real width-for-height request here based on
//           the required width of the children collectively if the
//           container were to be allocated the said height ...
//         }
//    }
//
// Height for width requests are generally implemented in terms of a virtual
// allocation of widgets in the input orientation. Assuming an height-for-width
// request mode, a container would implement the
// get_preferred_height_for_width() virtual function by first calling
// gtk_widget_get_preferred_width() for each of its children.
//
// For each potential group of children that are lined up horizontally, the
// values returned by gtk_widget_get_preferred_width() should be collected in an
// array of RequestedSize structures. Any child spacing should be removed from
// the input @for_width and then the collective size should be allocated using
// the gtk_distribute_natural_allocation() convenience function.
//
// The container will then move on to request the preferred height for each
// child by using gtk_widget_get_preferred_height_for_width() and using the
// sizes stored in the RequestedSize array.
//
// To allocate a height-for-width container, it’s again important to consider
// that a container must prioritize one dimension over the other. So if a
// container is a height-for-width container it must first allocate all widgets
// horizontally using a RequestedSize array and
// gtk_distribute_natural_allocation() and then add any extra space (if and
// where appropriate) for the widget to expand.
//
// After adding all the expand space, the container assumes it was allocated
// sufficient height to fit all of its content. At this time, the container must
// use the total horizontal sizes of each widget to request the height-for-width
// of each of its children and store the requests in a RequestedSize array for
// any widgets that stack vertically (for tabular containers this can be
// generalized into the heights and widths of rows and columns). The vertical
// space must then again be distributed using
// gtk_distribute_natural_allocation() while this time considering the allocated
// height of the widget minus any vertical spacing that the container adds. Then
// vertical expand space should be added where appropriate and available and the
// container should go on to actually allocating the child widgets.
//
// See [GtkWidget’s geometry management section][geometry-management] to learn
// more about implementing height-for-width geometry management for widgets.
//
//
// Child properties
//
// GtkContainer introduces child properties. These are object properties that
// are not specific to either the container or the contained widget, but rather
// to their relation. Typical examples of child properties are the position or
// pack-type of a widget which is contained in a Box.
//
// Use gtk_container_class_install_child_property() to install child properties
// for a container class and gtk_container_class_find_child_property() or
// gtk_container_class_list_child_properties() to get information about existing
// child properties.
//
// To set the value of a child property, use gtk_container_child_set_property(),
// gtk_container_child_set() or gtk_container_child_set_valist(). To obtain the
// value of a child property, use gtk_container_child_get_property(),
// gtk_container_child_get() or gtk_container_child_get_valist(). To emit
// notification about child property changes, use gtk_widget_child_notify().
//
//
// GtkContainer as GtkBuildable
//
// The GtkContainer implementation of the GtkBuildable interface supports a
// <packing> element for children, which can contain multiple <property>
// elements that specify child properties for the child.
//
// Since 2.16, child properties can also be marked as translatable using the
// same “translatable”, “comments” and “context” attributes that are used for
// regular properties.
//
// Since 3.16, containers can have a <focus-chain> element containing multiple
// <widget> elements, one for each child that should be added to the focus
// chain. The ”name” attribute gives the id of the widget.
//
// An example of these properties in UI definitions:
//
//    <object class="GtkBox">
//      <child>
//        <object class="GtkEntry" id="entry1"/>
//        <packing>
//          <property name="pack-type">start</property>
//        </packing>
//      </child>
//      <child>
//        <object class="GtkEntry" id="entry2"/>
//      </child>
//      <focus-chain>
//        <widget name="entry1"/>
//        <widget name="entry2"/>
//      </focus-chain>
//    </object>
type Container interface {
	Widget
	Buildable

	// Add adds @widget to @container. Typically used for simple containers such
	// as Window, Frame, or Button; for more complicated layout containers such
	// as Box or Grid, this function will pick default packing parameters that
	// may not be correct. So consider functions such as gtk_box_pack_start()
	// and gtk_grid_attach() as an alternative to gtk_container_add() in those
	// cases. A widget may be added to only one container at a time; you can’t
	// place the same widget inside two different containers.
	//
	// Note that some containers, such as ScrolledWindow or ListBox, may add
	// intermediate children between the added widget and the container.
	Add(widget Widget)

	CheckResize()
	// ChildGetProperty gets the value of a child property for @child and
	// @container.
	ChildGetProperty(child Widget, propertyName string, value **externglib.Value)
	// ChildNotify emits a Widget::child-notify signal for the [child
	// property][child-properties] @child_property on the child.
	//
	// This is an analogue of g_object_notify() for child properties.
	//
	// Also see gtk_widget_child_notify().
	ChildNotify(child Widget, childProperty string)
	// ChildSetProperty sets a child property for @child and @container.
	ChildSetProperty(child Widget, propertyName string, value **externglib.Value)
	// ChildType returns the type of the children supported by the container.
	//
	// Note that this may return G_TYPE_NONE to indicate that no more children
	// can be added, e.g. for a Paned which already has two children.
	ChildType() externglib.Type
	// BorderWidth retrieves the border width of the container. See
	// gtk_container_set_border_width().
	BorderWidth() uint
	// FocusChild returns the current focus child widget inside @container. This
	// is not the currently focused widget. That can be obtained by calling
	// gtk_window_get_focus().
	FocusChild() Widget
	// FocusHAdjustment retrieves the horizontal focus adjustment for the
	// container. See gtk_container_set_focus_hadjustment ().
	FocusHAdjustment() Adjustment
	// FocusVAdjustment retrieves the vertical focus adjustment for the
	// container. See gtk_container_set_focus_vadjustment().
	FocusVAdjustment() Adjustment
	// PathForChild returns a newly created widget path representing all the
	// widget hierarchy from the toplevel down to and including @child.
	PathForChild(child Widget) *WidgetPath
	// ResizeMode returns the resize mode for the container. See
	// gtk_container_set_resize_mode ().
	ResizeMode() ResizeMode
	// PropagateDraw: when a container receives a call to the draw function, it
	// must send synthetic Widget::draw calls to all children that don’t have
	// their own Windows. This function provides a convenient way of doing this.
	// A container, when it receives a call to its Widget::draw function, calls
	// gtk_container_propagate_draw() once for each child, passing in the @cr
	// the container received.
	//
	// gtk_container_propagate_draw() takes care of translating the origin of
	// @cr, and deciding whether the draw needs to be sent to the child. It is a
	// convenient and optimized way of getting the same effect as calling
	// gtk_widget_draw() on the child directly.
	//
	// In most cases, a container can simply either inherit the Widget::draw
	// implementation from Container, or do some drawing and then chain to the
	// ::draw implementation from Container.
	PropagateDraw(child Widget, cr *cairo.Context)
	// Remove removes @widget from @container. @widget must be inside
	// @container. Note that @container will own a reference to @widget, and
	// that this may be the last reference held; so removing a widget from its
	// container can destroy that widget. If you want to use @widget again, you
	// need to add a reference to it before removing it from a container, using
	// g_object_ref(). If you don’t want to use @widget again it’s usually more
	// efficient to simply destroy it directly using gtk_widget_destroy() since
	// this will remove it from the container and help break any circular
	// reference count cycles.
	Remove(widget Widget)

	ResizeChildren()
	// SetBorderWidth sets the border width of the container.
	//
	// The border width of a container is the amount of space to leave around
	// the outside of the container. The only exception to this is Window;
	// because toplevel windows can’t leave space outside, they leave the space
	// inside. The border is added on all sides of the container. To add space
	// to only one side, use a specific Widget:margin property on the child
	// widget, for example Widget:margin-top.
	SetBorderWidth(borderWidth uint)
	// SetFocusChild: sets, or unsets if @child is nil, the focused child of
	// @container.
	//
	// This function emits the GtkContainer::set_focus_child signal of
	// @container. Implementations of Container can override the default
	// behaviour by overriding the class closure of this signal.
	//
	// This is function is mostly meant to be used by widgets. Applications can
	// use gtk_widget_grab_focus() to manually set the focus to a specific
	// widget.
	SetFocusChild(child Widget)
	// SetFocusHAdjustment hooks up an adjustment to focus handling in a
	// container, so when a child of the container is focused, the adjustment is
	// scrolled to show that widget. This function sets the horizontal
	// alignment. See gtk_scrolled_window_get_hadjustment() for a typical way of
	// obtaining the adjustment and gtk_container_set_focus_vadjustment() for
	// setting the vertical adjustment.
	//
	// The adjustments have to be in pixel units and in the same coordinate
	// system as the allocation for immediate children of the container.
	SetFocusHAdjustment(adjustment Adjustment)
	// SetFocusVAdjustment hooks up an adjustment to focus handling in a
	// container, so when a child of the container is focused, the adjustment is
	// scrolled to show that widget. This function sets the vertical alignment.
	// See gtk_scrolled_window_get_vadjustment() for a typical way of obtaining
	// the adjustment and gtk_container_set_focus_hadjustment() for setting the
	// horizontal adjustment.
	//
	// The adjustments have to be in pixel units and in the same coordinate
	// system as the allocation for immediate children of the container.
	SetFocusVAdjustment(adjustment Adjustment)
	// SetReallocateRedraws sets the @reallocate_redraws flag of the container
	// to the given value.
	//
	// Containers requesting reallocation redraws get automatically redrawn if
	// any of their children changed allocation.
	SetReallocateRedraws(needsRedraws bool)
	// SetResizeMode sets the resize mode for the container.
	//
	// The resize mode of a container determines whether a resize request will
	// be passed to the container’s parent, queued for later execution or
	// executed immediately.
	SetResizeMode(resizeMode ResizeMode)
	// UnsetFocusChain removes a focus chain explicitly set with
	// gtk_container_set_focus_chain().
	UnsetFocusChain()
}

// container implements the Container class.
type container struct {
	Widget
	Buildable
}

var _ Container = (*container)(nil)

// WrapContainer wraps a GObject to the right type. It is
// primarily used internally.
func WrapContainer(obj *externglib.Object) Container {
	return container{
		Widget:    WrapWidget(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalContainer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapContainer(obj), nil
}

// Add adds @widget to @container. Typically used for simple containers such as
// Window, Frame, or Button; for more complicated layout containers such as Box
// or Grid, this function will pick default packing parameters that may not be
// correct. So consider functions such as gtk_box_pack_start() and
// gtk_grid_attach() as an alternative to gtk_container_add() in those cases. A
// widget may be added to only one container at a time; you can’t place the same
// widget inside two different containers.
//
// Note that some containers, such as ScrolledWindow or ListBox, may add
// intermediate children between the added widget and the container.
func (c container) Add(widget Widget) {
	var _arg0 *C.GtkContainer // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_container_add(_arg0, _arg1)
}

func (c container) CheckResize() {
	var _arg0 *C.GtkContainer // out

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))

	C.gtk_container_check_resize(_arg0)
}

// ChildGetProperty gets the value of a child property for @child and
// @container.
func (c container) ChildGetProperty(child Widget, propertyName string, value **externglib.Value) {
	var _arg0 *C.GtkContainer // out
	var _arg1 *C.GtkWidget    // out
	var _arg2 *C.gchar        // out
	var _arg3 *C.GValue       // out

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.gchar)(C.CString(propertyName))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GValue)(value.GValue)

	C.gtk_container_child_get_property(_arg0, _arg1, _arg2, _arg3)
}

// ChildNotify emits a Widget::child-notify signal for the [child
// property][child-properties] @child_property on the child.
//
// This is an analogue of g_object_notify() for child properties.
//
// Also see gtk_widget_child_notify().
func (c container) ChildNotify(child Widget, childProperty string) {
	var _arg0 *C.GtkContainer // out
	var _arg1 *C.GtkWidget    // out
	var _arg2 *C.gchar        // out

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.gchar)(C.CString(childProperty))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_container_child_notify(_arg0, _arg1, _arg2)
}

// ChildSetProperty sets a child property for @child and @container.
func (c container) ChildSetProperty(child Widget, propertyName string, value **externglib.Value) {
	var _arg0 *C.GtkContainer // out
	var _arg1 *C.GtkWidget    // out
	var _arg2 *C.gchar        // out
	var _arg3 *C.GValue       // out

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.gchar)(C.CString(propertyName))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GValue)(value.GValue)

	C.gtk_container_child_set_property(_arg0, _arg1, _arg2, _arg3)
}

// ChildType returns the type of the children supported by the container.
//
// Note that this may return G_TYPE_NONE to indicate that no more children can
// be added, e.g. for a Paned which already has two children.
func (c container) ChildType() externglib.Type {
	var _arg0 *C.GtkContainer // out
	var _cret C.GType         // in

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_container_child_type(_arg0)

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

// BorderWidth retrieves the border width of the container. See
// gtk_container_set_border_width().
func (c container) BorderWidth() uint {
	var _arg0 *C.GtkContainer // out
	var _cret C.guint         // in

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_container_get_border_width(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// FocusChild returns the current focus child widget inside @container. This is
// not the currently focused widget. That can be obtained by calling
// gtk_window_get_focus().
func (c container) FocusChild() Widget {
	var _arg0 *C.GtkContainer // out
	var _cret *C.GtkWidget    // in

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_container_get_focus_child(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// FocusHAdjustment retrieves the horizontal focus adjustment for the container.
// See gtk_container_set_focus_hadjustment ().
func (c container) FocusHAdjustment() Adjustment {
	var _arg0 *C.GtkContainer  // out
	var _cret *C.GtkAdjustment // in

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_container_get_focus_hadjustment(_arg0)

	var _adjustment Adjustment // out

	_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

	return _adjustment
}

// FocusVAdjustment retrieves the vertical focus adjustment for the container.
// See gtk_container_set_focus_vadjustment().
func (c container) FocusVAdjustment() Adjustment {
	var _arg0 *C.GtkContainer  // out
	var _cret *C.GtkAdjustment // in

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_container_get_focus_vadjustment(_arg0)

	var _adjustment Adjustment // out

	_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

	return _adjustment
}

// PathForChild returns a newly created widget path representing all the widget
// hierarchy from the toplevel down to and including @child.
func (c container) PathForChild(child Widget) *WidgetPath {
	var _arg0 *C.GtkContainer  // out
	var _arg1 *C.GtkWidget     // out
	var _cret *C.GtkWidgetPath // in

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	_cret = C.gtk_container_get_path_for_child(_arg0, _arg1)

	var _widgetPath *WidgetPath // out

	_widgetPath = WrapWidgetPath(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_widgetPath, func(v *WidgetPath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _widgetPath
}

// ResizeMode returns the resize mode for the container. See
// gtk_container_set_resize_mode ().
func (c container) ResizeMode() ResizeMode {
	var _arg0 *C.GtkContainer // out
	var _cret C.GtkResizeMode // in

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_container_get_resize_mode(_arg0)

	var _resizeMode ResizeMode // out

	_resizeMode = ResizeMode(_cret)

	return _resizeMode
}

// PropagateDraw: when a container receives a call to the draw function, it must
// send synthetic Widget::draw calls to all children that don’t have their own
// Windows. This function provides a convenient way of doing this. A container,
// when it receives a call to its Widget::draw function, calls
// gtk_container_propagate_draw() once for each child, passing in the @cr the
// container received.
//
// gtk_container_propagate_draw() takes care of translating the origin of @cr,
// and deciding whether the draw needs to be sent to the child. It is a
// convenient and optimized way of getting the same effect as calling
// gtk_widget_draw() on the child directly.
//
// In most cases, a container can simply either inherit the Widget::draw
// implementation from Container, or do some drawing and then chain to the
// ::draw implementation from Container.
func (c container) PropagateDraw(child Widget, cr *cairo.Context) {
	var _arg0 *C.GtkContainer // out
	var _arg1 *C.GtkWidget    // out
	var _arg2 *C.cairo_t      // out

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))

	C.gtk_container_propagate_draw(_arg0, _arg1, _arg2)
}

// Remove removes @widget from @container. @widget must be inside @container.
// Note that @container will own a reference to @widget, and that this may be
// the last reference held; so removing a widget from its container can destroy
// that widget. If you want to use @widget again, you need to add a reference to
// it before removing it from a container, using g_object_ref(). If you don’t
// want to use @widget again it’s usually more efficient to simply destroy it
// directly using gtk_widget_destroy() since this will remove it from the
// container and help break any circular reference count cycles.
func (c container) Remove(widget Widget) {
	var _arg0 *C.GtkContainer // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_container_remove(_arg0, _arg1)
}

func (c container) ResizeChildren() {
	var _arg0 *C.GtkContainer // out

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))

	C.gtk_container_resize_children(_arg0)
}

// SetBorderWidth sets the border width of the container.
//
// The border width of a container is the amount of space to leave around the
// outside of the container. The only exception to this is Window; because
// toplevel windows can’t leave space outside, they leave the space inside. The
// border is added on all sides of the container. To add space to only one side,
// use a specific Widget:margin property on the child widget, for example
// Widget:margin-top.
func (c container) SetBorderWidth(borderWidth uint) {
	var _arg0 *C.GtkContainer // out
	var _arg1 C.guint         // out

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
	_arg1 = (C.guint)(borderWidth)

	C.gtk_container_set_border_width(_arg0, _arg1)
}

// SetFocusChild: sets, or unsets if @child is nil, the focused child of
// @container.
//
// This function emits the GtkContainer::set_focus_child signal of @container.
// Implementations of Container can override the default behaviour by overriding
// the class closure of this signal.
//
// This is function is mostly meant to be used by widgets. Applications can use
// gtk_widget_grab_focus() to manually set the focus to a specific widget.
func (c container) SetFocusChild(child Widget) {
	var _arg0 *C.GtkContainer // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_container_set_focus_child(_arg0, _arg1)
}

// SetFocusHAdjustment hooks up an adjustment to focus handling in a container,
// so when a child of the container is focused, the adjustment is scrolled to
// show that widget. This function sets the horizontal alignment. See
// gtk_scrolled_window_get_hadjustment() for a typical way of obtaining the
// adjustment and gtk_container_set_focus_vadjustment() for setting the vertical
// adjustment.
//
// The adjustments have to be in pixel units and in the same coordinate system
// as the allocation for immediate children of the container.
func (c container) SetFocusHAdjustment(adjustment Adjustment) {
	var _arg0 *C.GtkContainer  // out
	var _arg1 *C.GtkAdjustment // out

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	C.gtk_container_set_focus_hadjustment(_arg0, _arg1)
}

// SetFocusVAdjustment hooks up an adjustment to focus handling in a container,
// so when a child of the container is focused, the adjustment is scrolled to
// show that widget. This function sets the vertical alignment. See
// gtk_scrolled_window_get_vadjustment() for a typical way of obtaining the
// adjustment and gtk_container_set_focus_hadjustment() for setting the
// horizontal adjustment.
//
// The adjustments have to be in pixel units and in the same coordinate system
// as the allocation for immediate children of the container.
func (c container) SetFocusVAdjustment(adjustment Adjustment) {
	var _arg0 *C.GtkContainer  // out
	var _arg1 *C.GtkAdjustment // out

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	C.gtk_container_set_focus_vadjustment(_arg0, _arg1)
}

// SetReallocateRedraws sets the @reallocate_redraws flag of the container to
// the given value.
//
// Containers requesting reallocation redraws get automatically redrawn if any
// of their children changed allocation.
func (c container) SetReallocateRedraws(needsRedraws bool) {
	var _arg0 *C.GtkContainer // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
	if needsRedraws {
		_arg1 = C.TRUE
	}

	C.gtk_container_set_reallocate_redraws(_arg0, _arg1)
}

// SetResizeMode sets the resize mode for the container.
//
// The resize mode of a container determines whether a resize request will be
// passed to the container’s parent, queued for later execution or executed
// immediately.
func (c container) SetResizeMode(resizeMode ResizeMode) {
	var _arg0 *C.GtkContainer // out
	var _arg1 C.GtkResizeMode // out

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GtkResizeMode)(resizeMode)

	C.gtk_container_set_resize_mode(_arg0, _arg1)
}

// UnsetFocusChain removes a focus chain explicitly set with
// gtk_container_set_focus_chain().
func (c container) UnsetFocusChain() {
	var _arg0 *C.GtkContainer // out

	_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))

	C.gtk_container_unset_focus_chain(_arg0)
}

type ContainerAccessible interface {
	WidgetAccessible
}

// containerAccessible implements the ContainerAccessible class.
type containerAccessible struct {
	WidgetAccessible
}

var _ ContainerAccessible = (*containerAccessible)(nil)

// WrapContainerAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapContainerAccessible(obj *externglib.Object) ContainerAccessible {
	return containerAccessible{
		WidgetAccessible: WrapWidgetAccessible(obj),
	}
}

func marshalContainerAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapContainerAccessible(obj), nil
}

type ContainerCellAccessible interface {
	CellAccessible

	AddChild(child CellAccessible)

	RemoveChild(child CellAccessible)
}

// containerCellAccessible implements the ContainerCellAccessible class.
type containerCellAccessible struct {
	CellAccessible
}

var _ ContainerCellAccessible = (*containerCellAccessible)(nil)

// WrapContainerCellAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapContainerCellAccessible(obj *externglib.Object) ContainerCellAccessible {
	return containerCellAccessible{
		CellAccessible: WrapCellAccessible(obj),
	}
}

func marshalContainerCellAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapContainerCellAccessible(obj), nil
}

func NewContainerCellAccessible() ContainerCellAccessible {
	var _cret *C.GtkContainerCellAccessible // in

	_cret = C.gtk_container_cell_accessible_new()

	var _containerCellAccessible ContainerCellAccessible // out

	_containerCellAccessible = WrapContainerCellAccessible(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _containerCellAccessible
}

func (c containerCellAccessible) AddChild(child CellAccessible) {
	var _arg0 *C.GtkContainerCellAccessible // out
	var _arg1 *C.GtkCellAccessible          // out

	_arg0 = (*C.GtkContainerCellAccessible)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkCellAccessible)(unsafe.Pointer(child.Native()))

	C.gtk_container_cell_accessible_add_child(_arg0, _arg1)
}

func (c containerCellAccessible) RemoveChild(child CellAccessible) {
	var _arg0 *C.GtkContainerCellAccessible // out
	var _arg1 *C.GtkCellAccessible          // out

	_arg0 = (*C.GtkContainerCellAccessible)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkCellAccessible)(unsafe.Pointer(child.Native()))

	C.gtk_container_cell_accessible_remove_child(_arg0, _arg1)
}

// CSSProvider: gtkCssProvider is an object implementing the StyleProvider
// interface. It is able to parse [CSS-like][css-overview] input in order to
// style widgets.
//
// An application can make GTK+ parse a specific CSS style sheet by calling
// gtk_css_provider_load_from_file() or gtk_css_provider_load_from_resource()
// and adding the provider with gtk_style_context_add_provider() or
// gtk_style_context_add_provider_for_screen().
//
// In addition, certain files will be read when GTK+ is initialized. First, the
// file `$XDG_CONFIG_HOME/gtk-3.0/gtk.css` is loaded if it exists. Then, GTK+
// loads the first existing file among
// `XDG_DATA_HOME/themes/THEME/gtk-VERSION/gtk.css`,
// `$HOME/.themes/THEME/gtk-VERSION/gtk.css`,
// `$XDG_DATA_DIRS/themes/THEME/gtk-VERSION/gtk.css` and
// `DATADIR/share/themes/THEME/gtk-VERSION/gtk.css`, where `THEME` is the name
// of the current theme (see the Settings:gtk-theme-name setting), `DATADIR` is
// the prefix configured when GTK+ was compiled (unless overridden by the
// `GTK_DATA_PREFIX` environment variable), and `VERSION` is the GTK+ version
// number. If no file is found for the current version, GTK+ tries older
// versions all the way back to 3.0.
//
// In the same way, GTK+ tries to load a gtk-keys.css file for the current key
// theme, as defined by Settings:gtk-key-theme-name.
type CSSProvider interface {
	gextras.Objector
	StyleProvider

	// LoadFromData loads @data into @css_provider, and by doing so clears any
	// previously loaded information.
	LoadFromData(data []byte) error
	// LoadFromFile loads the data contained in @file into @css_provider, making
	// it clear any previously loaded information.
	LoadFromFile(file gio.File) error
	// LoadFromPath loads the data contained in @path into @css_provider, making
	// it clear any previously loaded information.
	LoadFromPath(path string) error
	// LoadFromResource loads the data contained in the resource at
	// @resource_path into the CssProvider, clearing any previously loaded
	// information.
	//
	// To track errors while loading CSS, connect to the
	// CssProvider::parsing-error signal.
	LoadFromResource(resourcePath string)
	// String converts the @provider into a string representation in CSS format.
	//
	// Using gtk_css_provider_load_from_data() with the return value from this
	// function on a new provider created with gtk_css_provider_new() will
	// basically create a duplicate of this @provider.
	String() string
}

// cssProvider implements the CSSProvider class.
type cssProvider struct {
	gextras.Objector
	StyleProvider
}

var _ CSSProvider = (*cssProvider)(nil)

// WrapCSSProvider wraps a GObject to the right type. It is
// primarily used internally.
func WrapCSSProvider(obj *externglib.Object) CSSProvider {
	return cssProvider{
		Objector:      obj,
		StyleProvider: WrapStyleProvider(obj),
	}
}

func marshalCSSProvider(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCSSProvider(obj), nil
}

// NewCSSProvider returns a newly created CssProvider.
func NewCSSProvider() CSSProvider {
	var _cret *C.GtkCssProvider // in

	_cret = C.gtk_css_provider_new()

	var _cssProvider CSSProvider // out

	_cssProvider = WrapCSSProvider(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _cssProvider
}

// LoadFromData loads @data into @css_provider, and by doing so clears any
// previously loaded information.
func (c cssProvider) LoadFromData(data []byte) error {
	var _arg0 *C.GtkCssProvider // out
	var _arg1 *C.gchar
	var _arg2 C.gssize
	var _cerr *C.GError // in

	_arg0 = (*C.GtkCssProvider)(unsafe.Pointer(c.Native()))
	_arg2 = C.gssize(len(data))
	_arg1 = (*C.gchar)(unsafe.Pointer(&data[0]))

	C.gtk_css_provider_load_from_data(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// LoadFromFile loads the data contained in @file into @css_provider, making it
// clear any previously loaded information.
func (c cssProvider) LoadFromFile(file gio.File) error {
	var _arg0 *C.GtkCssProvider // out
	var _arg1 *C.GFile          // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GtkCssProvider)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

	C.gtk_css_provider_load_from_file(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// LoadFromPath loads the data contained in @path into @css_provider, making it
// clear any previously loaded information.
func (c cssProvider) LoadFromPath(path string) error {
	var _arg0 *C.GtkCssProvider // out
	var _arg1 *C.gchar          // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GtkCssProvider)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_css_provider_load_from_path(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// LoadFromResource loads the data contained in the resource at @resource_path
// into the CssProvider, clearing any previously loaded information.
//
// To track errors while loading CSS, connect to the CssProvider::parsing-error
// signal.
func (c cssProvider) LoadFromResource(resourcePath string) {
	var _arg0 *C.GtkCssProvider // out
	var _arg1 *C.gchar          // out

	_arg0 = (*C.GtkCssProvider)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_css_provider_load_from_resource(_arg0, _arg1)
}

// String converts the @provider into a string representation in CSS format.
//
// Using gtk_css_provider_load_from_data() with the return value from this
// function on a new provider created with gtk_css_provider_new() will basically
// create a duplicate of this @provider.
func (p cssProvider) String() string {
	var _arg0 *C.GtkCssProvider // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkCssProvider)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_css_provider_to_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Dialog: dialog boxes are a convenient way to prompt the user for a small
// amount of input, e.g. to display a message, ask a question, or anything else
// that does not require extensive effort on the user’s part.
//
// GTK+ treats a dialog as a window split vertically. The top section is a VBox,
// and is where widgets such as a Label or a Entry should be packed. The bottom
// area is known as the “action area”. This is generally used for packing
// buttons into the dialog which may perform functions such as cancel, ok, or
// apply.
//
// Dialog boxes are created with a call to gtk_dialog_new() or
// gtk_dialog_new_with_buttons(). gtk_dialog_new_with_buttons() is recommended;
// it allows you to set the dialog title, some convenient flags, and add simple
// buttons.
//
// If “dialog” is a newly created dialog, the two primary areas of the window
// can be accessed through gtk_dialog_get_content_area() and
// gtk_dialog_get_action_area(), as can be seen from the example below.
//
// A “modal” dialog (that is, one which freezes the rest of the application from
// user input), can be created by calling gtk_window_set_modal() on the dialog.
// Use the GTK_WINDOW() macro to cast the widget returned from gtk_dialog_new()
// into a Window. When using gtk_dialog_new_with_buttons() you can also pass the
// K_DIALOG_MODAL flag to make a dialog modal.
//
// If you add buttons to Dialog using gtk_dialog_new_with_buttons(),
// gtk_dialog_add_button(), gtk_dialog_add_buttons(), or
// gtk_dialog_add_action_widget(), clicking the button will emit a signal called
// Dialog::response with a response ID that you specified. GTK+ will never
// assign a meaning to positive response IDs; these are entirely user-defined.
// But for convenience, you can use the response IDs in the ResponseType
// enumeration (these all have values less than zero). If a dialog receives a
// delete event, the Dialog::response signal will be emitted with a response ID
// of K_RESPONSE_DELETE_EVENT.
//
// If you want to block waiting for a dialog to return before returning control
// flow to your code, you can call gtk_dialog_run(). This function enters a
// recursive main loop and waits for the user to respond to the dialog,
// returning the response ID corresponding to the button the user clicked.
//
// For the simple dialog in the following example, in reality you’d probably use
// MessageDialog to save yourself some effort. But you’d need to create the
// dialog contents manually if you had more than a simple message in the dialog.
//
// An example for simple GtkDialog usage:
//
//    // Function to open a dialog box with a message
//    void
//    quick_message (GtkWindow *parent, gchar *message)
//    {
//     GtkWidget *dialog, *label, *content_area;
//     GtkDialogFlags flags;
//
//     // Create the widgets
//     flags = GTK_DIALOG_DESTROY_WITH_PARENT;
//     dialog = gtk_dialog_new_with_buttons ("Message",
//                                           parent,
//                                           flags,
//                                           _("_OK"),
//                                           GTK_RESPONSE_NONE,
//                                           NULL);
//     content_area = gtk_dialog_get_content_area (GTK_DIALOG (dialog));
//     label = gtk_label_new (message);
//
//     // Ensure that the dialog box is destroyed when the user responds
//
//     g_signal_connect_swapped (dialog,
//                               "response",
//                               G_CALLBACK (gtk_widget_destroy),
//                               dialog);
//
//     // Add the label, and show everything we’ve added
//
//     gtk_container_add (GTK_CONTAINER (content_area), label);
//     gtk_widget_show_all (dialog);
//    }
//
//
// GtkDialog as GtkBuildable
//
// The GtkDialog implementation of the Buildable interface exposes the @vbox and
// @action_area as internal children with the names “vbox” and “action_area”.
//
// GtkDialog supports a custom <action-widgets> element, which can contain
// multiple <action-widget> elements. The “response” attribute specifies a
// numeric response, and the content of the element is the id of widget (which
// should be a child of the dialogs @action_area). To mark a response as
// default, set the “default“ attribute of the <action-widget> element to true.
//
// GtkDialog supports adding action widgets by specifying “action“ as the “type“
// attribute of a <child> element. The widget will be added either to the action
// area or the headerbar of the dialog, depending on the “use-header-bar“
// property. The response id has to be associated with the action widget using
// the <action-widgets> element.
//
// An example of a Dialog UI definition fragment:
//
//    <object class="GtkDialog" id="dialog1">
//      <child type="action">
//        <object class="GtkButton" id="button_cancel"/>
//      </child>
//      <child type="action">
//        <object class="GtkButton" id="button_ok">
//          <property name="can-default">True</property>
//        </object>
//      </child>
//      <action-widgets>
//        <action-widget response="cancel">button_cancel</action-widget>
//        <action-widget response="ok" default="true">button_ok</action-widget>
//      </action-widgets>
//    </object>
type Dialog interface {
	Window
	Buildable

	// AddActionWidget adds an activatable widget to the action area of a
	// Dialog, connecting a signal handler that will emit the Dialog::response
	// signal on the dialog when the widget is activated. The widget is appended
	// to the end of the dialog’s action area. If you want to add a
	// non-activatable widget, simply pack it into the @action_area field of the
	// Dialog struct.
	AddActionWidget(child Widget, responseId int)
	// AddButton adds a button with the given text and sets things up so that
	// clicking the button will emit the Dialog::response signal with the given
	// @response_id. The button is appended to the end of the dialog’s action
	// area. The button widget is returned, but usually you don’t need it.
	AddButton(buttonText string, responseId int) Widget
	// ActionArea returns the action area of @dialog.
	ActionArea() Box
	// ContentArea returns the content area of @dialog.
	ContentArea() Box
	// HeaderBar returns the header bar of @dialog. Note that the headerbar is
	// only used by the dialog if the Dialog:use-header-bar property is true.
	HeaderBar() HeaderBar
	// ResponseForWidget gets the response id of a widget in the action area of
	// a dialog.
	ResponseForWidget(widget Widget) int
	// WidgetForResponse gets the widget button that uses the given response ID
	// in the action area of a dialog.
	WidgetForResponse(responseId int) Widget
	// Response emits the Dialog::response signal with the given response ID.
	// Used to indicate that the user has responded to the dialog in some way;
	// typically either you or gtk_dialog_run() will be monitoring the
	// ::response signal and take appropriate action.
	Response(responseId int)
	// Run blocks in a recursive main loop until the @dialog either emits the
	// Dialog::response signal, or is destroyed. If the dialog is destroyed
	// during the call to gtk_dialog_run(), gtk_dialog_run() returns
	// K_RESPONSE_NONE. Otherwise, it returns the response ID from the
	// ::response signal emission.
	//
	// Before entering the recursive main loop, gtk_dialog_run() calls
	// gtk_widget_show() on the dialog for you. Note that you still need to show
	// any children of the dialog yourself.
	//
	// During gtk_dialog_run(), the default behavior of Widget::delete-event is
	// disabled; if the dialog receives ::delete_event, it will not be destroyed
	// as windows usually are, and gtk_dialog_run() will return
	// K_RESPONSE_DELETE_EVENT. Also, during gtk_dialog_run() the dialog will be
	// modal. You can force gtk_dialog_run() to return at any time by calling
	// gtk_dialog_response() to emit the ::response signal. Destroying the
	// dialog during gtk_dialog_run() is a very bad idea, because your post-run
	// code won’t know whether the dialog was destroyed or not.
	//
	// After gtk_dialog_run() returns, you are responsible for hiding or
	// destroying the dialog if you wish to do so.
	//
	// Typical usage of this function might be:
	//
	//      GtkWidget *dialog = gtk_dialog_new ();
	//      // Set up dialog...
	//
	//      int result = gtk_dialog_run (GTK_DIALOG (dialog));
	//      switch (result)
	//        {
	//          case GTK_RESPONSE_ACCEPT:
	//             // do_application_specific_something ();
	//             break;
	//          default:
	//             // do_nothing_since_dialog_was_cancelled ();
	//             break;
	//        }
	//      gtk_widget_destroy (dialog);
	//
	// Note that even though the recursive main loop gives the effect of a modal
	// dialog (it prevents the user from interacting with other windows in the
	// same window group while the dialog is run), callbacks such as timeouts,
	// IO channel watches, DND drops, etc, will be triggered during a
	// gtk_dialog_run() call.
	Run() int
	// SetAlternativeButtonOrderFromArray sets an alternative button order. If
	// the Settings:gtk-alternative-button-order setting is set to true, the
	// dialog buttons are reordered according to the order of the response ids
	// in @new_order.
	//
	// See gtk_dialog_set_alternative_button_order() for more information.
	//
	// This function is for use by language bindings.
	SetAlternativeButtonOrderFromArray(newOrder []int)
	// SetDefaultResponse sets the last widget in the dialog’s action area with
	// the given @response_id as the default widget for the dialog. Pressing
	// “Enter” normally activates the default widget.
	SetDefaultResponse(responseId int)
	// SetResponseSensitive calls `gtk_widget_set_sensitive (widget, @setting)`
	// for each widget in the dialog’s action area with the given @response_id.
	// A convenient way to sensitize/desensitize dialog buttons.
	SetResponseSensitive(responseId int, setting bool)
}

// dialog implements the Dialog class.
type dialog struct {
	Window
	Buildable
}

var _ Dialog = (*dialog)(nil)

// WrapDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapDialog(obj *externglib.Object) Dialog {
	return dialog{
		Window:    WrapWindow(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDialog(obj), nil
}

// NewDialog creates a new dialog box.
//
// Widgets should not be packed into this Window directly, but into the @vbox
// and @action_area, as described above.
func NewDialog() Dialog {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_dialog_new()

	var _dialog Dialog // out

	_dialog = WrapDialog(externglib.Take(unsafe.Pointer(_cret)))

	return _dialog
}

// AddActionWidget adds an activatable widget to the action area of a Dialog,
// connecting a signal handler that will emit the Dialog::response signal on the
// dialog when the widget is activated. The widget is appended to the end of the
// dialog’s action area. If you want to add a non-activatable widget, simply
// pack it into the @action_area field of the Dialog struct.
func (d dialog) AddActionWidget(child Widget, responseId int) {
	var _arg0 *C.GtkDialog // out
	var _arg1 *C.GtkWidget // out
	var _arg2 C.gint       // out

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (C.gint)(responseId)

	C.gtk_dialog_add_action_widget(_arg0, _arg1, _arg2)
}

// AddButton adds a button with the given text and sets things up so that
// clicking the button will emit the Dialog::response signal with the given
// @response_id. The button is appended to the end of the dialog’s action area.
// The button widget is returned, but usually you don’t need it.
func (d dialog) AddButton(buttonText string, responseId int) Widget {
	var _arg0 *C.GtkDialog // out
	var _arg1 *C.gchar     // out
	var _arg2 C.gint       // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.gchar)(C.CString(buttonText))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gint)(responseId)

	_cret = C.gtk_dialog_add_button(_arg0, _arg1, _arg2)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// ActionArea returns the action area of @dialog.
func (d dialog) ActionArea() Box {
	var _arg0 *C.GtkDialog // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))

	_cret = C.gtk_dialog_get_action_area(_arg0)

	var _box Box // out

	_box = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Box)

	return _box
}

// ContentArea returns the content area of @dialog.
func (d dialog) ContentArea() Box {
	var _arg0 *C.GtkDialog // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))

	_cret = C.gtk_dialog_get_content_area(_arg0)

	var _box Box // out

	_box = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Box)

	return _box
}

// HeaderBar returns the header bar of @dialog. Note that the headerbar is only
// used by the dialog if the Dialog:use-header-bar property is true.
func (d dialog) HeaderBar() HeaderBar {
	var _arg0 *C.GtkDialog // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))

	_cret = C.gtk_dialog_get_header_bar(_arg0)

	var _headerBar HeaderBar // out

	_headerBar = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(HeaderBar)

	return _headerBar
}

// ResponseForWidget gets the response id of a widget in the action area of a
// dialog.
func (d dialog) ResponseForWidget(widget Widget) int {
	var _arg0 *C.GtkDialog // out
	var _arg1 *C.GtkWidget // out
	var _cret C.gint       // in

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	_cret = C.gtk_dialog_get_response_for_widget(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// WidgetForResponse gets the widget button that uses the given response ID in
// the action area of a dialog.
func (d dialog) WidgetForResponse(responseId int) Widget {
	var _arg0 *C.GtkDialog // out
	var _arg1 C.gint       // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
	_arg1 = (C.gint)(responseId)

	_cret = C.gtk_dialog_get_widget_for_response(_arg0, _arg1)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// Response emits the Dialog::response signal with the given response ID. Used
// to indicate that the user has responded to the dialog in some way; typically
// either you or gtk_dialog_run() will be monitoring the ::response signal and
// take appropriate action.
func (d dialog) Response(responseId int) {
	var _arg0 *C.GtkDialog // out
	var _arg1 C.gint       // out

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
	_arg1 = (C.gint)(responseId)

	C.gtk_dialog_response(_arg0, _arg1)
}

// Run blocks in a recursive main loop until the @dialog either emits the
// Dialog::response signal, or is destroyed. If the dialog is destroyed during
// the call to gtk_dialog_run(), gtk_dialog_run() returns K_RESPONSE_NONE.
// Otherwise, it returns the response ID from the ::response signal emission.
//
// Before entering the recursive main loop, gtk_dialog_run() calls
// gtk_widget_show() on the dialog for you. Note that you still need to show any
// children of the dialog yourself.
//
// During gtk_dialog_run(), the default behavior of Widget::delete-event is
// disabled; if the dialog receives ::delete_event, it will not be destroyed as
// windows usually are, and gtk_dialog_run() will return
// K_RESPONSE_DELETE_EVENT. Also, during gtk_dialog_run() the dialog will be
// modal. You can force gtk_dialog_run() to return at any time by calling
// gtk_dialog_response() to emit the ::response signal. Destroying the dialog
// during gtk_dialog_run() is a very bad idea, because your post-run code won’t
// know whether the dialog was destroyed or not.
//
// After gtk_dialog_run() returns, you are responsible for hiding or destroying
// the dialog if you wish to do so.
//
// Typical usage of this function might be:
//
//      GtkWidget *dialog = gtk_dialog_new ();
//      // Set up dialog...
//
//      int result = gtk_dialog_run (GTK_DIALOG (dialog));
//      switch (result)
//        {
//          case GTK_RESPONSE_ACCEPT:
//             // do_application_specific_something ();
//             break;
//          default:
//             // do_nothing_since_dialog_was_cancelled ();
//             break;
//        }
//      gtk_widget_destroy (dialog);
//
// Note that even though the recursive main loop gives the effect of a modal
// dialog (it prevents the user from interacting with other windows in the same
// window group while the dialog is run), callbacks such as timeouts, IO channel
// watches, DND drops, etc, will be triggered during a gtk_dialog_run() call.
func (d dialog) Run() int {
	var _arg0 *C.GtkDialog // out
	var _cret C.gint       // in

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))

	_cret = C.gtk_dialog_run(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// SetAlternativeButtonOrderFromArray sets an alternative button order. If the
// Settings:gtk-alternative-button-order setting is set to true, the dialog
// buttons are reordered according to the order of the response ids in
// @new_order.
//
// See gtk_dialog_set_alternative_button_order() for more information.
//
// This function is for use by language bindings.
func (d dialog) SetAlternativeButtonOrderFromArray(newOrder []int) {
	var _arg0 *C.GtkDialog // out
	var _arg2 *C.gint
	var _arg1 C.gint

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
	_arg1 = C.gint(len(newOrder))
	_arg2 = (*C.gint)(unsafe.Pointer(&newOrder[0]))

	C.gtk_dialog_set_alternative_button_order_from_array(_arg0, _arg1, _arg2)
}

// SetDefaultResponse sets the last widget in the dialog’s action area with the
// given @response_id as the default widget for the dialog. Pressing “Enter”
// normally activates the default widget.
func (d dialog) SetDefaultResponse(responseId int) {
	var _arg0 *C.GtkDialog // out
	var _arg1 C.gint       // out

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
	_arg1 = (C.gint)(responseId)

	C.gtk_dialog_set_default_response(_arg0, _arg1)
}

// SetResponseSensitive calls `gtk_widget_set_sensitive (widget, @setting)` for
// each widget in the dialog’s action area with the given @response_id. A
// convenient way to sensitize/desensitize dialog buttons.
func (d dialog) SetResponseSensitive(responseId int, setting bool) {
	var _arg0 *C.GtkDialog // out
	var _arg1 C.gint       // out
	var _arg2 C.gboolean   // out

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
	_arg1 = (C.gint)(responseId)
	if setting {
		_arg2 = C.TRUE
	}

	C.gtk_dialog_set_response_sensitive(_arg0, _arg1, _arg2)
}

// DrawingArea: the DrawingArea widget is used for creating custom user
// interface elements. It’s essentially a blank widget; you can draw on it.
// After creating a drawing area, the application may want to connect to:
//
// - Mouse and button press signals to respond to input from the user. (Use
// gtk_widget_add_events() to enable events you wish to receive.)
//
// - The Widget::realize signal to take any necessary actions when the widget is
// instantiated on a particular display. (Create GDK resources in response to
// this signal.)
//
// - The Widget::size-allocate signal to take any necessary actions when the
// widget changes size.
//
// - The Widget::draw signal to handle redrawing the contents of the widget.
//
// The following code portion demonstrates using a drawing area to display a
// circle in the normal widget foreground color.
//
// Note that GDK automatically clears the exposed area before sending the expose
// event, and that drawing is implicitly clipped to the exposed area. If you
// want to have a theme-provided background, you need to call
// gtk_render_background() in your ::draw method.
//
// Simple GtkDrawingArea usage
//
//    gboolean
//    draw_callback (GtkWidget *widget, cairo_t *cr, gpointer data)
//    {
//      guint width, height;
//      GdkRGBA color;
//      GtkStyleContext *context;
//
//      context = gtk_widget_get_style_context (widget);
//
//      width = gtk_widget_get_allocated_width (widget);
//      height = gtk_widget_get_allocated_height (widget);
//
//      gtk_render_background (context, cr, 0, 0, width, height);
//
//      cairo_arc (cr,
//                 width / 2.0, height / 2.0,
//                 MIN (width, height) / 2.0,
//                 0, 2 * G_PI);
//
//      gtk_style_context_get_color (context,
//                                   gtk_style_context_get_state (context),
//                                   &color);
//      gdk_cairo_set_source_rgba (cr, &color);
//
//      cairo_fill (cr);
//
//     return FALSE;
//    }
//    [...]
//      GtkWidget *drawing_area = gtk_drawing_area_new ();
//      gtk_widget_set_size_request (drawing_area, 100, 100);
//      g_signal_connect (G_OBJECT (drawing_area), "draw",
//                        G_CALLBACK (draw_callback), NULL);
//
// Draw signals are normally delivered when a drawing area first comes onscreen,
// or when it’s covered by another window and then uncovered. You can also force
// an expose event by adding to the “damage region” of the drawing area’s
// window; gtk_widget_queue_draw_area() and gdk_window_invalidate_rect() are
// equally good ways to do this. You’ll then get a draw signal for the invalid
// region.
//
// The available routines for drawing are documented on the [GDK Drawing
// Primitives][gdk3-Cairo-Interaction] page and the cairo documentation.
//
// To receive mouse events on a drawing area, you will need to enable them with
// gtk_widget_add_events(). To receive keyboard events, you will need to set the
// “can-focus” property on the drawing area, and you should probably draw some
// user-visible indication that the drawing area is focused. Use
// gtk_widget_has_focus() in your expose event handler to decide whether to draw
// the focus indicator. See gtk_render_focus() for one way to draw focus.
type DrawingArea interface {
	Widget
	Buildable
}

// drawingArea implements the DrawingArea class.
type drawingArea struct {
	Widget
	Buildable
}

var _ DrawingArea = (*drawingArea)(nil)

// WrapDrawingArea wraps a GObject to the right type. It is
// primarily used internally.
func WrapDrawingArea(obj *externglib.Object) DrawingArea {
	return drawingArea{
		Widget:    WrapWidget(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalDrawingArea(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDrawingArea(obj), nil
}

// NewDrawingArea creates a new drawing area.
func NewDrawingArea() DrawingArea {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_drawing_area_new()

	var _drawingArea DrawingArea // out

	_drawingArea = WrapDrawingArea(externglib.Take(unsafe.Pointer(_cret)))

	return _drawingArea
}

// Entry: the Entry widget is a single line text entry widget. A fairly large
// set of key bindings are supported by default. If the entered text is longer
// than the allocation of the widget, the widget will scroll so that the cursor
// position is visible.
//
// When using an entry for passwords and other sensitive information, it can be
// put into “password mode” using gtk_entry_set_visibility(). In this mode,
// entered text is displayed using a “invisible” character. By default, GTK+
// picks the best invisible character that is available in the current font, but
// it can be changed with gtk_entry_set_invisible_char(). Since 2.16, GTK+
// displays a warning when Caps Lock or input methods might interfere with
// entering text in a password entry. The warning can be turned off with the
// Entry:caps-lock-warning property.
//
// Since 2.16, GtkEntry has the ability to display progress or activity
// information behind the text. To make an entry display such information, use
// gtk_entry_set_progress_fraction() or gtk_entry_set_progress_pulse_step().
//
// Additionally, GtkEntry can show icons at either side of the entry. These
// icons can be activatable by clicking, can be set up as drag source and can
// have tooltips. To add an icon, use gtk_entry_set_icon_from_gicon() or one of
// the various other functions that set an icon from a stock id, an icon name or
// a pixbuf. To trigger an action when the user clicks an icon, connect to the
// Entry::icon-press signal. To allow DND operations from an icon, use
// gtk_entry_set_icon_drag_source(). To set a tooltip on an icon, use
// gtk_entry_set_icon_tooltip_text() or the corresponding function for markup.
//
// Note that functionality or information that is only available by clicking on
// an icon in an entry may not be accessible at all to users which are not able
// to use a mouse or other pointing device. It is therefore recommended that any
// such functionality should also be available by other means, e.g. via the
// context menu of the entry.
//
// CSS nodes
//
//    entry[.read-only][.flat][.warning][.error]
//    ├── image.left
//    ├── image.right
//    ├── undershoot.left
//    ├── undershoot.right
//    ├── [selection]
//    ├── [progress[.pulse]]
//    ╰── [window.popup]
//
// GtkEntry has a main node with the name entry. Depending on the properties of
// the entry, the style classes .read-only and .flat may appear. The style
// classes .warning and .error may also be used with entries.
//
// When the entry shows icons, it adds subnodes with the name image and the
// style class .left or .right, depending on where the icon appears.
//
// When the entry has a selection, it adds a subnode with the name selection.
//
// When the entry shows progress, it adds a subnode with the name progress. The
// node has the style class .pulse when the shown progress is pulsing.
//
// The CSS node for a context menu is added as a subnode below entry as well.
//
// The undershoot nodes are used to draw the underflow indication when content
// is scrolled out of view. These nodes get the .left and .right style classes
// added depending on where the indication is drawn.
//
// When touch is used and touch selection handles are shown, they are using CSS
// nodes with name cursor-handle. They get the .top or .bottom style class
// depending on where they are shown in relation to the selection. If there is
// just a single handle for the text cursor, it gets the style class
// .insertion-cursor.
type Entry interface {
	Widget
	Buildable
	CellEditable
	Editable

	// ActivatesDefault retrieves the value set by
	// gtk_entry_set_activates_default().
	ActivatesDefault() bool
	// Alignment gets the value set by gtk_entry_set_alignment().
	Alignment() float32
	// Attributes gets the attribute list that was set on the entry using
	// gtk_entry_set_attributes(), if any.
	Attributes() *pango.AttrList
	// Buffer: get the EntryBuffer object which holds the text for this widget.
	Buffer() EntryBuffer
	// Completion returns the auxiliary completion object currently in use by
	// @entry.
	Completion() EntryCompletion
	// CurrentIconDragSource returns the index of the icon which is the source
	// of the current DND operation, or -1.
	//
	// This function is meant to be used in a Widget::drag-data-get callback.
	CurrentIconDragSource() int
	// CursorHAdjustment retrieves the horizontal cursor adjustment for the
	// entry. See gtk_entry_set_cursor_hadjustment().
	CursorHAdjustment() Adjustment
	// HasFrame gets the value set by gtk_entry_set_has_frame().
	HasFrame() bool
	// IconActivatable returns whether the icon is activatable.
	IconActivatable(iconPos EntryIconPosition) bool
	// IconArea gets the area where entry’s icon at @icon_pos is drawn. This
	// function is useful when drawing something to the entry in a draw
	// callback.
	//
	// If the entry is not realized or has no icon at the given position,
	// @icon_area is filled with zeros. Otherwise, @icon_area will be filled
	// with the icon’s allocation, relative to @entry’s allocation.
	//
	// See also gtk_entry_get_text_area()
	IconArea(iconPos EntryIconPosition) gdk.Rectangle
	// IconAtPos finds the icon at the given position and return its index. The
	// position’s coordinates are relative to the @entry’s top left corner. If
	// @x, @y doesn’t lie inside an icon, -1 is returned. This function is
	// intended for use in a Widget::query-tooltip signal handler.
	IconAtPos(x int, y int) int
	// IconGIcon retrieves the #GIcon used for the icon, or nil if there is no
	// icon or if the icon was set by some other method (e.g., by stock, pixbuf,
	// or icon name).
	IconGIcon(iconPos EntryIconPosition) gio.Icon
	// IconName retrieves the icon name used for the icon, or nil if there is no
	// icon or if the icon was set by some other method (e.g., by pixbuf, stock
	// or gicon).
	IconName(iconPos EntryIconPosition) string
	// IconPixbuf retrieves the image used for the icon.
	//
	// Unlike the other methods of setting and getting icon data, this method
	// will work regardless of whether the icon was set using a Pixbuf, a
	// #GIcon, a stock item, or an icon name.
	IconPixbuf(iconPos EntryIconPosition) gdkpixbuf.Pixbuf
	// IconSensitive returns whether the icon appears sensitive or insensitive.
	IconSensitive(iconPos EntryIconPosition) bool
	// IconStock retrieves the stock id used for the icon, or nil if there is no
	// icon or if the icon was set by some other method (e.g., by pixbuf, icon
	// name or gicon).
	IconStock(iconPos EntryIconPosition) string
	// IconStorageType gets the type of representation being used by the icon to
	// store image data. If the icon has no image data, the return value will be
	// GTK_IMAGE_EMPTY.
	IconStorageType(iconPos EntryIconPosition) ImageType
	// IconTooltipMarkup gets the contents of the tooltip on the icon at the
	// specified position in @entry.
	IconTooltipMarkup(iconPos EntryIconPosition) string
	// IconTooltipText gets the contents of the tooltip on the icon at the
	// specified position in @entry.
	IconTooltipText(iconPos EntryIconPosition) string
	// InnerBorder: this function returns the entry’s Entry:inner-border
	// property. See gtk_entry_set_inner_border() for more information.
	InnerBorder() *Border
	// InputHints gets the value of the Entry:input-hints property.
	InputHints() InputHints
	// InputPurpose gets the value of the Entry:input-purpose property.
	InputPurpose() InputPurpose
	// InvisibleChar retrieves the character displayed in place of the real
	// characters for entries with visibility set to false. See
	// gtk_entry_set_invisible_char().
	InvisibleChar() uint32
	// Layout gets the Layout used to display the entry. The layout is useful to
	// e.g. convert text positions to pixel positions, in combination with
	// gtk_entry_get_layout_offsets(). The returned layout is owned by the entry
	// and must not be modified or freed by the caller.
	//
	// Keep in mind that the layout text may contain a preedit string, so
	// gtk_entry_layout_index_to_text_index() and
	// gtk_entry_text_index_to_layout_index() are needed to convert byte indices
	// in the layout to byte indices in the entry contents.
	Layout() pango.Layout
	// LayoutOffsets obtains the position of the Layout used to render text in
	// the entry, in widget coordinates. Useful if you want to line up the text
	// in an entry with some other text, e.g. when using the entry to implement
	// editable cells in a sheet widget.
	//
	// Also useful to convert mouse events into coordinates inside the Layout,
	// e.g. to take some action if some part of the entry text is clicked.
	//
	// Note that as the user scrolls around in the entry the offsets will
	// change; you’ll need to connect to the “notify::scroll-offset” signal to
	// track this. Remember when using the Layout functions you need to convert
	// to and from pixels using PANGO_PIXELS() or NGO_SCALE.
	//
	// Keep in mind that the layout text may contain a preedit string, so
	// gtk_entry_layout_index_to_text_index() and
	// gtk_entry_text_index_to_layout_index() are needed to convert byte indices
	// in the layout to byte indices in the entry contents.
	LayoutOffsets() (x int, y int)
	// MaxLength retrieves the maximum allowed length of the text in @entry. See
	// gtk_entry_set_max_length().
	//
	// This is equivalent to getting @entry's EntryBuffer and calling
	// gtk_entry_buffer_get_max_length() on it.
	MaxLength() int
	// MaxWidthChars retrieves the desired maximum width of @entry, in
	// characters. See gtk_entry_set_max_width_chars().
	MaxWidthChars() int
	// OverwriteMode gets the value set by gtk_entry_set_overwrite_mode().
	OverwriteMode() bool
	// PlaceholderText retrieves the text that will be displayed when @entry is
	// empty and unfocused
	PlaceholderText() string
	// ProgressFraction returns the current fraction of the task that’s been
	// completed. See gtk_entry_set_progress_fraction().
	ProgressFraction() float64
	// ProgressPulseStep retrieves the pulse step set with
	// gtk_entry_set_progress_pulse_step().
	ProgressPulseStep() float64
	// Tabs gets the tabstops that were set on the entry using
	// gtk_entry_set_tabs(), if any.
	Tabs() *pango.TabArray
	// Text retrieves the contents of the entry widget. See also
	// gtk_editable_get_chars().
	//
	// This is equivalent to getting @entry's EntryBuffer and calling
	// gtk_entry_buffer_get_text() on it.
	Text() string
	// TextArea gets the area where the entry’s text is drawn. This function is
	// useful when drawing something to the entry in a draw callback.
	//
	// If the entry is not realized, @text_area is filled with zeros.
	//
	// See also gtk_entry_get_icon_area().
	TextArea() gdk.Rectangle
	// TextLength retrieves the current length of the text in @entry.
	//
	// This is equivalent to getting @entry's EntryBuffer and calling
	// gtk_entry_buffer_get_length() on it.
	TextLength() uint16
	// Visibility retrieves whether the text in @entry is visible. See
	// gtk_entry_set_visibility().
	Visibility() bool
	// WidthChars gets the value set by gtk_entry_set_width_chars().
	WidthChars() int
	// GrabFocusWithoutSelecting causes @entry to have keyboard focus.
	//
	// It behaves like gtk_widget_grab_focus(), except that it doesn't select
	// the contents of the entry. You only want to call this on some special
	// entries which the user usually doesn't want to replace all text in, such
	// as search-as-you-type entries.
	GrabFocusWithoutSelecting()
	// ImContextFilterKeypress: allow the Entry input method to internally
	// handle key press and release events. If this function returns true, then
	// no further processing should be done for this key event. See
	// gtk_im_context_filter_keypress().
	//
	// Note that you are expected to call this function from your handler when
	// overriding key event handling. This is needed in the case when you need
	// to insert your own key handling between the input method and the default
	// key event handling of the Entry. See gtk_text_view_reset_im_context() for
	// an example of use.
	ImContextFilterKeypress(event *gdk.EventKey) bool
	// LayoutIndexToTextIndex converts from a position in the entry’s Layout
	// (returned by gtk_entry_get_layout()) to a position in the entry contents
	// (returned by gtk_entry_get_text()).
	LayoutIndexToTextIndex(layoutIndex int) int
	// ProgressPulse indicates that some progress is made, but you don’t know
	// how much. Causes the entry’s progress indicator to enter “activity mode,”
	// where a block bounces back and forth. Each call to
	// gtk_entry_progress_pulse() causes the block to move by a little bit (the
	// amount of movement per pulse is determined by
	// gtk_entry_set_progress_pulse_step()).
	ProgressPulse()
	// ResetImContext: reset the input method context of the entry if needed.
	//
	// This can be necessary in the case where modifying the buffer would
	// confuse on-going input method behavior.
	ResetImContext()
	// SetActivatesDefault: if @setting is true, pressing Enter in the @entry
	// will activate the default widget for the window containing the entry.
	// This usually means that the dialog box containing the entry will be
	// closed, since the default widget is usually one of the dialog buttons.
	//
	// (For experts: if @setting is true, the entry calls
	// gtk_window_activate_default() on the window containing the entry, in the
	// default handler for the Entry::activate signal.)
	SetActivatesDefault(setting bool)
	// SetAlignment sets the alignment for the contents of the entry. This
	// controls the horizontal positioning of the contents when the displayed
	// text is shorter than the width of the entry.
	SetAlignment(xalign float32)
	// SetAttributes sets a AttrList; the attributes in the list are applied to
	// the entry text.
	SetAttributes(attrs *pango.AttrList)
	// SetBuffer: set the EntryBuffer object which holds the text for this
	// widget.
	SetBuffer(buffer EntryBuffer)
	// SetCompletion sets @completion to be the auxiliary completion object to
	// use with @entry. All further configuration of the completion mechanism is
	// done on @completion using the EntryCompletion API. Completion is disabled
	// if @completion is set to nil.
	SetCompletion(completion EntryCompletion)
	// SetCursorHAdjustment hooks up an adjustment to the cursor position in an
	// entry, so that when the cursor is moved, the adjustment is scrolled to
	// show that position. See gtk_scrolled_window_get_hadjustment() for a
	// typical way of obtaining the adjustment.
	//
	// The adjustment has to be in pixel units and in the same coordinate system
	// as the entry.
	SetCursorHAdjustment(adjustment Adjustment)
	// SetHasFrame sets whether the entry has a beveled frame around it.
	SetHasFrame(setting bool)
	// SetIconActivatable sets whether the icon is activatable.
	SetIconActivatable(iconPos EntryIconPosition, activatable bool)
	// SetIconDragSource sets up the icon at the given position so that GTK+
	// will start a drag operation when the user clicks and drags the icon.
	//
	// To handle the drag operation, you need to connect to the usual
	// Widget::drag-data-get (or possibly Widget::drag-data-delete) signal, and
	// use gtk_entry_get_current_icon_drag_source() in your signal handler to
	// find out if the drag was started from an icon.
	//
	// By default, GTK+ uses the icon as the drag icon. You can use the
	// Widget::drag-begin signal to set a different icon. Note that you have to
	// use g_signal_connect_after() to ensure that your signal handler gets
	// executed after the default handler.
	SetIconDragSource(iconPos EntryIconPosition, targetList *TargetList, actions gdk.DragAction)
	// SetIconFromGIcon sets the icon shown in the entry at the specified
	// position from the current icon theme. If the icon isn’t known, a “broken
	// image” icon will be displayed instead.
	//
	// If @icon is nil, no icon will be shown in the specified position.
	SetIconFromGIcon(iconPos EntryIconPosition, icon gio.Icon)
	// SetIconFromIconName sets the icon shown in the entry at the specified
	// position from the current icon theme.
	//
	// If the icon name isn’t known, a “broken image” icon will be displayed
	// instead.
	//
	// If @icon_name is nil, no icon will be shown in the specified position.
	SetIconFromIconName(iconPos EntryIconPosition, iconName string)
	// SetIconFromPixbuf sets the icon shown in the specified position using a
	// pixbuf.
	//
	// If @pixbuf is nil, no icon will be shown in the specified position.
	SetIconFromPixbuf(iconPos EntryIconPosition, pixbuf gdkpixbuf.Pixbuf)
	// SetIconFromStock sets the icon shown in the entry at the specified
	// position from a stock image.
	//
	// If @stock_id is nil, no icon will be shown in the specified position.
	SetIconFromStock(iconPos EntryIconPosition, stockId string)
	// SetIconSensitive sets the sensitivity for the specified icon.
	SetIconSensitive(iconPos EntryIconPosition, sensitive bool)
	// SetIconTooltipMarkup sets @tooltip as the contents of the tooltip for the
	// icon at the specified position. @tooltip is assumed to be marked up with
	// the [Pango text markup language][PangoMarkupFormat].
	//
	// Use nil for @tooltip to remove an existing tooltip.
	//
	// See also gtk_widget_set_tooltip_markup() and
	// gtk_entry_set_icon_tooltip_text().
	SetIconTooltipMarkup(iconPos EntryIconPosition, tooltip string)
	// SetIconTooltipText sets @tooltip as the contents of the tooltip for the
	// icon at the specified position.
	//
	// Use nil for @tooltip to remove an existing tooltip.
	//
	// See also gtk_widget_set_tooltip_text() and
	// gtk_entry_set_icon_tooltip_markup().
	//
	// If you unset the widget tooltip via gtk_widget_set_tooltip_text() or
	// gtk_widget_set_tooltip_markup(), this sets GtkWidget:has-tooltip to
	// false, which suppresses icon tooltips too. You can resolve this by then
	// calling gtk_widget_set_has_tooltip() to set GtkWidget:has-tooltip back to
	// true, or setting at least one non-empty tooltip on any icon achieves the
	// same result.
	SetIconTooltipText(iconPos EntryIconPosition, tooltip string)
	// SetInnerBorder sets entry’s inner-border property to @border, or clears
	// it if nil is passed. The inner-border is the area around the entry’s
	// text, but inside its frame.
	//
	// If set, this property overrides the inner-border style property.
	// Overriding the style-provided border is useful when you want to do
	// in-place editing of some text in a canvas or list widget, where
	// pixel-exact positioning of the entry is important.
	SetInnerBorder(border *Border)
	// SetInputHints sets the Entry:input-hints property, which allows input
	// methods to fine-tune their behaviour.
	SetInputHints(hints InputHints)
	// SetInputPurpose sets the Entry:input-purpose property which can be used
	// by on-screen keyboards and other input methods to adjust their behaviour.
	SetInputPurpose(purpose InputPurpose)
	// SetInvisibleChar sets the character to use in place of the actual text
	// when gtk_entry_set_visibility() has been called to set text visibility to
	// false. i.e. this is the character used in “password mode” to show the
	// user how many characters have been typed. By default, GTK+ picks the best
	// invisible char available in the current font. If you set the invisible
	// char to 0, then the user will get no feedback at all; there will be no
	// text on the screen as they type.
	SetInvisibleChar(ch uint32)
	// SetMaxLength sets the maximum allowed length of the contents of the
	// widget. If the current contents are longer than the given length, then
	// they will be truncated to fit.
	//
	// This is equivalent to getting @entry's EntryBuffer and calling
	// gtk_entry_buffer_set_max_length() on it. ]|
	SetMaxLength(max int)
	// SetMaxWidthChars sets the desired maximum width in characters of @entry.
	SetMaxWidthChars(nChars int)
	// SetOverwriteMode sets whether the text is overwritten when typing in the
	// Entry.
	SetOverwriteMode(overwrite bool)
	// SetPlaceholderText sets text to be displayed in @entry when it is empty
	// and unfocused. This can be used to give a visual hint of the expected
	// contents of the Entry.
	//
	// Note that since the placeholder text gets removed when the entry received
	// focus, using this feature is a bit problematic if the entry is given the
	// initial focus in a window. Sometimes this can be worked around by
	// delaying the initial focus setting until the first key event arrives.
	SetPlaceholderText(text string)
	// SetProgressFraction causes the entry’s progress indicator to “fill in”
	// the given fraction of the bar. The fraction should be between 0.0 and
	// 1.0, inclusive.
	SetProgressFraction(fraction float64)
	// SetProgressPulseStep sets the fraction of total entry width to move the
	// progress bouncing block for each call to gtk_entry_progress_pulse().
	SetProgressPulseStep(fraction float64)
	// SetTabs sets a TabArray; the tabstops in the array are applied to the
	// entry text.
	SetTabs(tabs *pango.TabArray)
	// SetText sets the text in the widget to the given value, replacing the
	// current contents.
	//
	// See gtk_entry_buffer_set_text().
	SetText(text string)
	// SetVisibility sets whether the contents of the entry are visible or not.
	// When visibility is set to false, characters are displayed as the
	// invisible char, and will also appear that way when the text in the entry
	// widget is copied elsewhere.
	//
	// By default, GTK+ picks the best invisible character available in the
	// current font, but it can be changed with gtk_entry_set_invisible_char().
	//
	// Note that you probably want to set Entry:input-purpose to
	// GTK_INPUT_PURPOSE_PASSWORD or GTK_INPUT_PURPOSE_PIN to inform input
	// methods about the purpose of this entry, in addition to setting
	// visibility to false.
	SetVisibility(visible bool)
	// SetWidthChars changes the size request of the entry to be about the right
	// size for @n_chars characters. Note that it changes the size request, the
	// size can still be affected by how you pack the widget into containers. If
	// @n_chars is -1, the size reverts to the default entry size.
	SetWidthChars(nChars int)
	// TextIndexToLayoutIndex converts from a position in the entry contents
	// (returned by gtk_entry_get_text()) to a position in the entry’s Layout
	// (returned by gtk_entry_get_layout(), with text retrieved via
	// pango_layout_get_text()).
	TextIndexToLayoutIndex(textIndex int) int
	// UnsetInvisibleChar unsets the invisible char previously set with
	// gtk_entry_set_invisible_char(). So that the default invisible char is
	// used again.
	UnsetInvisibleChar()
}

// entry implements the Entry class.
type entry struct {
	Widget
	Buildable
	CellEditable
	Editable
}

var _ Entry = (*entry)(nil)

// WrapEntry wraps a GObject to the right type. It is
// primarily used internally.
func WrapEntry(obj *externglib.Object) Entry {
	return entry{
		Widget:       WrapWidget(obj),
		Buildable:    WrapBuildable(obj),
		CellEditable: WrapCellEditable(obj),
		Editable:     WrapEditable(obj),
	}
}

func marshalEntry(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEntry(obj), nil
}

// NewEntry creates a new entry.
func NewEntry() Entry {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_entry_new()

	var _entry Entry // out

	_entry = WrapEntry(externglib.Take(unsafe.Pointer(_cret)))

	return _entry
}

// NewEntryWithBuffer creates a new entry with the specified text buffer.
func NewEntryWithBuffer(buffer EntryBuffer) Entry {
	var _arg1 *C.GtkEntryBuffer // out
	var _cret *C.GtkWidget      // in

	_arg1 = (*C.GtkEntryBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_entry_new_with_buffer(_arg1)

	var _entry Entry // out

	_entry = WrapEntry(externglib.Take(unsafe.Pointer(_cret)))

	return _entry
}

// ActivatesDefault retrieves the value set by
// gtk_entry_set_activates_default().
func (e entry) ActivatesDefault() bool {
	var _arg0 *C.GtkEntry // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_activates_default(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Alignment gets the value set by gtk_entry_set_alignment().
func (e entry) Alignment() float32 {
	var _arg0 *C.GtkEntry // out
	var _cret C.gfloat    // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_alignment(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Attributes gets the attribute list that was set on the entry using
// gtk_entry_set_attributes(), if any.
func (e entry) Attributes() *pango.AttrList {
	var _arg0 *C.GtkEntry      // out
	var _cret *C.PangoAttrList // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_attributes(_arg0)

	var _attrList *pango.AttrList // out

	_attrList = pango.WrapAttrList(unsafe.Pointer(_cret))

	return _attrList
}

// Buffer: get the EntryBuffer object which holds the text for this widget.
func (e entry) Buffer() EntryBuffer {
	var _arg0 *C.GtkEntry       // out
	var _cret *C.GtkEntryBuffer // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_buffer(_arg0)

	var _entryBuffer EntryBuffer // out

	_entryBuffer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(EntryBuffer)

	return _entryBuffer
}

// Completion returns the auxiliary completion object currently in use by
// @entry.
func (e entry) Completion() EntryCompletion {
	var _arg0 *C.GtkEntry           // out
	var _cret *C.GtkEntryCompletion // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_completion(_arg0)

	var _entryCompletion EntryCompletion // out

	_entryCompletion = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(EntryCompletion)

	return _entryCompletion
}

// CurrentIconDragSource returns the index of the icon which is the source of
// the current DND operation, or -1.
//
// This function is meant to be used in a Widget::drag-data-get callback.
func (e entry) CurrentIconDragSource() int {
	var _arg0 *C.GtkEntry // out
	var _cret C.gint      // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_current_icon_drag_source(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// CursorHAdjustment retrieves the horizontal cursor adjustment for the entry.
// See gtk_entry_set_cursor_hadjustment().
func (e entry) CursorHAdjustment() Adjustment {
	var _arg0 *C.GtkEntry      // out
	var _cret *C.GtkAdjustment // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_cursor_hadjustment(_arg0)

	var _adjustment Adjustment // out

	_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

	return _adjustment
}

// HasFrame gets the value set by gtk_entry_set_has_frame().
func (e entry) HasFrame() bool {
	var _arg0 *C.GtkEntry // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_has_frame(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IconActivatable returns whether the icon is activatable.
func (e entry) IconActivatable(iconPos EntryIconPosition) bool {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkEntryIconPosition)(iconPos)

	_cret = C.gtk_entry_get_icon_activatable(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IconArea gets the area where entry’s icon at @icon_pos is drawn. This
// function is useful when drawing something to the entry in a draw callback.
//
// If the entry is not realized or has no icon at the given position, @icon_area
// is filled with zeros. Otherwise, @icon_area will be filled with the icon’s
// allocation, relative to @entry’s allocation.
//
// See also gtk_entry_get_text_area()
func (e entry) IconArea(iconPos EntryIconPosition) gdk.Rectangle {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _iconArea gdk.Rectangle

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkEntryIconPosition)(iconPos)

	C.gtk_entry_get_icon_area(_arg0, _arg1, (*C.GdkRectangle)(unsafe.Pointer(&_iconArea)))

	return _iconArea
}

// IconAtPos finds the icon at the given position and return its index. The
// position’s coordinates are relative to the @entry’s top left corner. If @x,
// @y doesn’t lie inside an icon, -1 is returned. This function is intended for
// use in a Widget::query-tooltip signal handler.
func (e entry) IconAtPos(x int, y int) int {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.gint      // out
	var _arg2 C.gint      // out
	var _cret C.gint      // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.gint)(x)
	_arg2 = (C.gint)(y)

	_cret = C.gtk_entry_get_icon_at_pos(_arg0, _arg1, _arg2)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// IconGIcon retrieves the #GIcon used for the icon, or nil if there is no icon
// or if the icon was set by some other method (e.g., by stock, pixbuf, or icon
// name).
func (e entry) IconGIcon(iconPos EntryIconPosition) gio.Icon {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _cret *C.GIcon               // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkEntryIconPosition)(iconPos)

	_cret = C.gtk_entry_get_icon_gicon(_arg0, _arg1)

	var _icon gio.Icon // out

	_icon = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.Icon)

	return _icon
}

// IconName retrieves the icon name used for the icon, or nil if there is no
// icon or if the icon was set by some other method (e.g., by pixbuf, stock or
// gicon).
func (e entry) IconName(iconPos EntryIconPosition) string {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _cret *C.gchar               // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkEntryIconPosition)(iconPos)

	_cret = C.gtk_entry_get_icon_name(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// IconPixbuf retrieves the image used for the icon.
//
// Unlike the other methods of setting and getting icon data, this method will
// work regardless of whether the icon was set using a Pixbuf, a #GIcon, a stock
// item, or an icon name.
func (e entry) IconPixbuf(iconPos EntryIconPosition) gdkpixbuf.Pixbuf {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _cret *C.GdkPixbuf           // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkEntryIconPosition)(iconPos)

	_cret = C.gtk_entry_get_icon_pixbuf(_arg0, _arg1)

	var _pixbuf gdkpixbuf.Pixbuf // out

	_pixbuf = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

	return _pixbuf
}

// IconSensitive returns whether the icon appears sensitive or insensitive.
func (e entry) IconSensitive(iconPos EntryIconPosition) bool {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkEntryIconPosition)(iconPos)

	_cret = C.gtk_entry_get_icon_sensitive(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IconStock retrieves the stock id used for the icon, or nil if there is no
// icon or if the icon was set by some other method (e.g., by pixbuf, icon name
// or gicon).
func (e entry) IconStock(iconPos EntryIconPosition) string {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _cret *C.gchar               // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkEntryIconPosition)(iconPos)

	_cret = C.gtk_entry_get_icon_stock(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// IconStorageType gets the type of representation being used by the icon to
// store image data. If the icon has no image data, the return value will be
// GTK_IMAGE_EMPTY.
func (e entry) IconStorageType(iconPos EntryIconPosition) ImageType {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _cret C.GtkImageType         // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkEntryIconPosition)(iconPos)

	_cret = C.gtk_entry_get_icon_storage_type(_arg0, _arg1)

	var _imageType ImageType // out

	_imageType = ImageType(_cret)

	return _imageType
}

// IconTooltipMarkup gets the contents of the tooltip on the icon at the
// specified position in @entry.
func (e entry) IconTooltipMarkup(iconPos EntryIconPosition) string {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _cret *C.gchar               // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkEntryIconPosition)(iconPos)

	_cret = C.gtk_entry_get_icon_tooltip_markup(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// IconTooltipText gets the contents of the tooltip on the icon at the specified
// position in @entry.
func (e entry) IconTooltipText(iconPos EntryIconPosition) string {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _cret *C.gchar               // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkEntryIconPosition)(iconPos)

	_cret = C.gtk_entry_get_icon_tooltip_text(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// InnerBorder: this function returns the entry’s Entry:inner-border property.
// See gtk_entry_set_inner_border() for more information.
func (e entry) InnerBorder() *Border {
	var _arg0 *C.GtkEntry  // out
	var _cret *C.GtkBorder // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_inner_border(_arg0)

	var _border *Border // out

	_border = WrapBorder(unsafe.Pointer(_cret))

	return _border
}

// InputHints gets the value of the Entry:input-hints property.
func (e entry) InputHints() InputHints {
	var _arg0 *C.GtkEntry     // out
	var _cret C.GtkInputHints // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_input_hints(_arg0)

	var _inputHints InputHints // out

	_inputHints = InputHints(_cret)

	return _inputHints
}

// InputPurpose gets the value of the Entry:input-purpose property.
func (e entry) InputPurpose() InputPurpose {
	var _arg0 *C.GtkEntry       // out
	var _cret C.GtkInputPurpose // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_input_purpose(_arg0)

	var _inputPurpose InputPurpose // out

	_inputPurpose = InputPurpose(_cret)

	return _inputPurpose
}

// InvisibleChar retrieves the character displayed in place of the real
// characters for entries with visibility set to false. See
// gtk_entry_set_invisible_char().
func (e entry) InvisibleChar() uint32 {
	var _arg0 *C.GtkEntry // out
	var _cret C.gunichar  // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_invisible_char(_arg0)

	var _gunichar uint32 // out

	_gunichar = (uint32)(_cret)

	return _gunichar
}

// Layout gets the Layout used to display the entry. The layout is useful to
// e.g. convert text positions to pixel positions, in combination with
// gtk_entry_get_layout_offsets(). The returned layout is owned by the entry and
// must not be modified or freed by the caller.
//
// Keep in mind that the layout text may contain a preedit string, so
// gtk_entry_layout_index_to_text_index() and
// gtk_entry_text_index_to_layout_index() are needed to convert byte indices in
// the layout to byte indices in the entry contents.
func (e entry) Layout() pango.Layout {
	var _arg0 *C.GtkEntry    // out
	var _cret *C.PangoLayout // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_layout(_arg0)

	var _layout pango.Layout // out

	_layout = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(pango.Layout)

	return _layout
}

// LayoutOffsets obtains the position of the Layout used to render text in the
// entry, in widget coordinates. Useful if you want to line up the text in an
// entry with some other text, e.g. when using the entry to implement editable
// cells in a sheet widget.
//
// Also useful to convert mouse events into coordinates inside the Layout, e.g.
// to take some action if some part of the entry text is clicked.
//
// Note that as the user scrolls around in the entry the offsets will change;
// you’ll need to connect to the “notify::scroll-offset” signal to track this.
// Remember when using the Layout functions you need to convert to and from
// pixels using PANGO_PIXELS() or NGO_SCALE.
//
// Keep in mind that the layout text may contain a preedit string, so
// gtk_entry_layout_index_to_text_index() and
// gtk_entry_text_index_to_layout_index() are needed to convert byte indices in
// the layout to byte indices in the entry contents.
func (e entry) LayoutOffsets() (x int, y int) {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.gint      // in
	var _arg2 C.gint      // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	C.gtk_entry_get_layout_offsets(_arg0, &_arg1, &_arg2)

	var _x int // out
	var _y int // out

	_x = (int)(_arg1)
	_y = (int)(_arg2)

	return _x, _y
}

// MaxLength retrieves the maximum allowed length of the text in @entry. See
// gtk_entry_set_max_length().
//
// This is equivalent to getting @entry's EntryBuffer and calling
// gtk_entry_buffer_get_max_length() on it.
func (e entry) MaxLength() int {
	var _arg0 *C.GtkEntry // out
	var _cret C.gint      // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_max_length(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// MaxWidthChars retrieves the desired maximum width of @entry, in characters.
// See gtk_entry_set_max_width_chars().
func (e entry) MaxWidthChars() int {
	var _arg0 *C.GtkEntry // out
	var _cret C.gint      // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_max_width_chars(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// OverwriteMode gets the value set by gtk_entry_set_overwrite_mode().
func (e entry) OverwriteMode() bool {
	var _arg0 *C.GtkEntry // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_overwrite_mode(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PlaceholderText retrieves the text that will be displayed when @entry is
// empty and unfocused
func (e entry) PlaceholderText() string {
	var _arg0 *C.GtkEntry // out
	var _cret *C.gchar    // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_placeholder_text(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// ProgressFraction returns the current fraction of the task that’s been
// completed. See gtk_entry_set_progress_fraction().
func (e entry) ProgressFraction() float64 {
	var _arg0 *C.GtkEntry // out
	var _cret C.gdouble   // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_progress_fraction(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// ProgressPulseStep retrieves the pulse step set with
// gtk_entry_set_progress_pulse_step().
func (e entry) ProgressPulseStep() float64 {
	var _arg0 *C.GtkEntry // out
	var _cret C.gdouble   // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_progress_pulse_step(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// Tabs gets the tabstops that were set on the entry using gtk_entry_set_tabs(),
// if any.
func (e entry) Tabs() *pango.TabArray {
	var _arg0 *C.GtkEntry      // out
	var _cret *C.PangoTabArray // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_tabs(_arg0)

	var _tabArray *pango.TabArray // out

	_tabArray = pango.WrapTabArray(unsafe.Pointer(_cret))

	return _tabArray
}

// Text retrieves the contents of the entry widget. See also
// gtk_editable_get_chars().
//
// This is equivalent to getting @entry's EntryBuffer and calling
// gtk_entry_buffer_get_text() on it.
func (e entry) Text() string {
	var _arg0 *C.GtkEntry // out
	var _cret *C.gchar    // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_text(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// TextArea gets the area where the entry’s text is drawn. This function is
// useful when drawing something to the entry in a draw callback.
//
// If the entry is not realized, @text_area is filled with zeros.
//
// See also gtk_entry_get_icon_area().
func (e entry) TextArea() gdk.Rectangle {
	var _arg0 *C.GtkEntry // out
	var _textArea gdk.Rectangle

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	C.gtk_entry_get_text_area(_arg0, (*C.GdkRectangle)(unsafe.Pointer(&_textArea)))

	return _textArea
}

// TextLength retrieves the current length of the text in @entry.
//
// This is equivalent to getting @entry's EntryBuffer and calling
// gtk_entry_buffer_get_length() on it.
func (e entry) TextLength() uint16 {
	var _arg0 *C.GtkEntry // out
	var _cret C.guint16   // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_text_length(_arg0)

	var _guint16 uint16 // out

	_guint16 = (uint16)(_cret)

	return _guint16
}

// Visibility retrieves whether the text in @entry is visible. See
// gtk_entry_set_visibility().
func (e entry) Visibility() bool {
	var _arg0 *C.GtkEntry // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_visibility(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// WidthChars gets the value set by gtk_entry_set_width_chars().
func (e entry) WidthChars() int {
	var _arg0 *C.GtkEntry // out
	var _cret C.gint      // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_entry_get_width_chars(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// GrabFocusWithoutSelecting causes @entry to have keyboard focus.
//
// It behaves like gtk_widget_grab_focus(), except that it doesn't select the
// contents of the entry. You only want to call this on some special entries
// which the user usually doesn't want to replace all text in, such as
// search-as-you-type entries.
func (e entry) GrabFocusWithoutSelecting() {
	var _arg0 *C.GtkEntry // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	C.gtk_entry_grab_focus_without_selecting(_arg0)
}

// ImContextFilterKeypress: allow the Entry input method to internally handle
// key press and release events. If this function returns true, then no further
// processing should be done for this key event. See
// gtk_im_context_filter_keypress().
//
// Note that you are expected to call this function from your handler when
// overriding key event handling. This is needed in the case when you need to
// insert your own key handling between the input method and the default key
// event handling of the Entry. See gtk_text_view_reset_im_context() for an
// example of use.
func (e entry) ImContextFilterKeypress(event *gdk.EventKey) bool {
	var _arg0 *C.GtkEntry    // out
	var _arg1 *C.GdkEventKey // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.GdkEventKey)(unsafe.Pointer(event.Native()))

	_cret = C.gtk_entry_im_context_filter_keypress(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LayoutIndexToTextIndex converts from a position in the entry’s Layout
// (returned by gtk_entry_get_layout()) to a position in the entry contents
// (returned by gtk_entry_get_text()).
func (e entry) LayoutIndexToTextIndex(layoutIndex int) int {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.gint      // out
	var _cret C.gint      // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.gint)(layoutIndex)

	_cret = C.gtk_entry_layout_index_to_text_index(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// ProgressPulse indicates that some progress is made, but you don’t know how
// much. Causes the entry’s progress indicator to enter “activity mode,” where a
// block bounces back and forth. Each call to gtk_entry_progress_pulse() causes
// the block to move by a little bit (the amount of movement per pulse is
// determined by gtk_entry_set_progress_pulse_step()).
func (e entry) ProgressPulse() {
	var _arg0 *C.GtkEntry // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	C.gtk_entry_progress_pulse(_arg0)
}

// ResetImContext: reset the input method context of the entry if needed.
//
// This can be necessary in the case where modifying the buffer would confuse
// on-going input method behavior.
func (e entry) ResetImContext() {
	var _arg0 *C.GtkEntry // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	C.gtk_entry_reset_im_context(_arg0)
}

// SetActivatesDefault: if @setting is true, pressing Enter in the @entry will
// activate the default widget for the window containing the entry. This usually
// means that the dialog box containing the entry will be closed, since the
// default widget is usually one of the dialog buttons.
//
// (For experts: if @setting is true, the entry calls
// gtk_window_activate_default() on the window containing the entry, in the
// default handler for the Entry::activate signal.)
func (e entry) SetActivatesDefault(setting bool) {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_entry_set_activates_default(_arg0, _arg1)
}

// SetAlignment sets the alignment for the contents of the entry. This controls
// the horizontal positioning of the contents when the displayed text is shorter
// than the width of the entry.
func (e entry) SetAlignment(xalign float32) {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.gfloat    // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.gfloat)(xalign)

	C.gtk_entry_set_alignment(_arg0, _arg1)
}

// SetAttributes sets a AttrList; the attributes in the list are applied to the
// entry text.
func (e entry) SetAttributes(attrs *pango.AttrList) {
	var _arg0 *C.GtkEntry      // out
	var _arg1 *C.PangoAttrList // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.PangoAttrList)(unsafe.Pointer(attrs.Native()))

	C.gtk_entry_set_attributes(_arg0, _arg1)
}

// SetBuffer: set the EntryBuffer object which holds the text for this widget.
func (e entry) SetBuffer(buffer EntryBuffer) {
	var _arg0 *C.GtkEntry       // out
	var _arg1 *C.GtkEntryBuffer // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.GtkEntryBuffer)(unsafe.Pointer(buffer.Native()))

	C.gtk_entry_set_buffer(_arg0, _arg1)
}

// SetCompletion sets @completion to be the auxiliary completion object to use
// with @entry. All further configuration of the completion mechanism is done on
// @completion using the EntryCompletion API. Completion is disabled if
// @completion is set to nil.
func (e entry) SetCompletion(completion EntryCompletion) {
	var _arg0 *C.GtkEntry           // out
	var _arg1 *C.GtkEntryCompletion // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.GtkEntryCompletion)(unsafe.Pointer(completion.Native()))

	C.gtk_entry_set_completion(_arg0, _arg1)
}

// SetCursorHAdjustment hooks up an adjustment to the cursor position in an
// entry, so that when the cursor is moved, the adjustment is scrolled to show
// that position. See gtk_scrolled_window_get_hadjustment() for a typical way of
// obtaining the adjustment.
//
// The adjustment has to be in pixel units and in the same coordinate system as
// the entry.
func (e entry) SetCursorHAdjustment(adjustment Adjustment) {
	var _arg0 *C.GtkEntry      // out
	var _arg1 *C.GtkAdjustment // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	C.gtk_entry_set_cursor_hadjustment(_arg0, _arg1)
}

// SetHasFrame sets whether the entry has a beveled frame around it.
func (e entry) SetHasFrame(setting bool) {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_entry_set_has_frame(_arg0, _arg1)
}

// SetIconActivatable sets whether the icon is activatable.
func (e entry) SetIconActivatable(iconPos EntryIconPosition, activatable bool) {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _arg2 C.gboolean             // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkEntryIconPosition)(iconPos)
	if activatable {
		_arg2 = C.TRUE
	}

	C.gtk_entry_set_icon_activatable(_arg0, _arg1, _arg2)
}

// SetIconDragSource sets up the icon at the given position so that GTK+ will
// start a drag operation when the user clicks and drags the icon.
//
// To handle the drag operation, you need to connect to the usual
// Widget::drag-data-get (or possibly Widget::drag-data-delete) signal, and use
// gtk_entry_get_current_icon_drag_source() in your signal handler to find out
// if the drag was started from an icon.
//
// By default, GTK+ uses the icon as the drag icon. You can use the
// Widget::drag-begin signal to set a different icon. Note that you have to use
// g_signal_connect_after() to ensure that your signal handler gets executed
// after the default handler.
func (e entry) SetIconDragSource(iconPos EntryIconPosition, targetList *TargetList, actions gdk.DragAction) {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _arg2 *C.GtkTargetList       // out
	var _arg3 C.GdkDragAction        // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkEntryIconPosition)(iconPos)
	_arg2 = (*C.GtkTargetList)(unsafe.Pointer(targetList.Native()))
	_arg3 = (C.GdkDragAction)(actions)

	C.gtk_entry_set_icon_drag_source(_arg0, _arg1, _arg2, _arg3)
}

// SetIconFromGIcon sets the icon shown in the entry at the specified position
// from the current icon theme. If the icon isn’t known, a “broken image” icon
// will be displayed instead.
//
// If @icon is nil, no icon will be shown in the specified position.
func (e entry) SetIconFromGIcon(iconPos EntryIconPosition, icon gio.Icon) {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _arg2 *C.GIcon               // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkEntryIconPosition)(iconPos)
	_arg2 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

	C.gtk_entry_set_icon_from_gicon(_arg0, _arg1, _arg2)
}

// SetIconFromIconName sets the icon shown in the entry at the specified
// position from the current icon theme.
//
// If the icon name isn’t known, a “broken image” icon will be displayed
// instead.
//
// If @icon_name is nil, no icon will be shown in the specified position.
func (e entry) SetIconFromIconName(iconPos EntryIconPosition, iconName string) {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _arg2 *C.gchar               // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkEntryIconPosition)(iconPos)
	_arg2 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_entry_set_icon_from_icon_name(_arg0, _arg1, _arg2)
}

// SetIconFromPixbuf sets the icon shown in the specified position using a
// pixbuf.
//
// If @pixbuf is nil, no icon will be shown in the specified position.
func (e entry) SetIconFromPixbuf(iconPos EntryIconPosition, pixbuf gdkpixbuf.Pixbuf) {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _arg2 *C.GdkPixbuf           // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkEntryIconPosition)(iconPos)
	_arg2 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	C.gtk_entry_set_icon_from_pixbuf(_arg0, _arg1, _arg2)
}

// SetIconFromStock sets the icon shown in the entry at the specified position
// from a stock image.
//
// If @stock_id is nil, no icon will be shown in the specified position.
func (e entry) SetIconFromStock(iconPos EntryIconPosition, stockId string) {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _arg2 *C.gchar               // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkEntryIconPosition)(iconPos)
	_arg2 = (*C.gchar)(C.CString(stockId))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_entry_set_icon_from_stock(_arg0, _arg1, _arg2)
}

// SetIconSensitive sets the sensitivity for the specified icon.
func (e entry) SetIconSensitive(iconPos EntryIconPosition, sensitive bool) {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _arg2 C.gboolean             // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkEntryIconPosition)(iconPos)
	if sensitive {
		_arg2 = C.TRUE
	}

	C.gtk_entry_set_icon_sensitive(_arg0, _arg1, _arg2)
}

// SetIconTooltipMarkup sets @tooltip as the contents of the tooltip for the
// icon at the specified position. @tooltip is assumed to be marked up with the
// [Pango text markup language][PangoMarkupFormat].
//
// Use nil for @tooltip to remove an existing tooltip.
//
// See also gtk_widget_set_tooltip_markup() and
// gtk_entry_set_icon_tooltip_text().
func (e entry) SetIconTooltipMarkup(iconPos EntryIconPosition, tooltip string) {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _arg2 *C.gchar               // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkEntryIconPosition)(iconPos)
	_arg2 = (*C.gchar)(C.CString(tooltip))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_entry_set_icon_tooltip_markup(_arg0, _arg1, _arg2)
}

// SetIconTooltipText sets @tooltip as the contents of the tooltip for the icon
// at the specified position.
//
// Use nil for @tooltip to remove an existing tooltip.
//
// See also gtk_widget_set_tooltip_text() and
// gtk_entry_set_icon_tooltip_markup().
//
// If you unset the widget tooltip via gtk_widget_set_tooltip_text() or
// gtk_widget_set_tooltip_markup(), this sets GtkWidget:has-tooltip to false,
// which suppresses icon tooltips too. You can resolve this by then calling
// gtk_widget_set_has_tooltip() to set GtkWidget:has-tooltip back to true, or
// setting at least one non-empty tooltip on any icon achieves the same result.
func (e entry) SetIconTooltipText(iconPos EntryIconPosition, tooltip string) {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _arg2 *C.gchar               // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkEntryIconPosition)(iconPos)
	_arg2 = (*C.gchar)(C.CString(tooltip))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_entry_set_icon_tooltip_text(_arg0, _arg1, _arg2)
}

// SetInnerBorder sets entry’s inner-border property to @border, or clears it if
// nil is passed. The inner-border is the area around the entry’s text, but
// inside its frame.
//
// If set, this property overrides the inner-border style property. Overriding
// the style-provided border is useful when you want to do in-place editing of
// some text in a canvas or list widget, where pixel-exact positioning of the
// entry is important.
func (e entry) SetInnerBorder(border *Border) {
	var _arg0 *C.GtkEntry  // out
	var _arg1 *C.GtkBorder // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.GtkBorder)(unsafe.Pointer(border.Native()))

	C.gtk_entry_set_inner_border(_arg0, _arg1)
}

// SetInputHints sets the Entry:input-hints property, which allows input methods
// to fine-tune their behaviour.
func (e entry) SetInputHints(hints InputHints) {
	var _arg0 *C.GtkEntry     // out
	var _arg1 C.GtkInputHints // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkInputHints)(hints)

	C.gtk_entry_set_input_hints(_arg0, _arg1)
}

// SetInputPurpose sets the Entry:input-purpose property which can be used by
// on-screen keyboards and other input methods to adjust their behaviour.
func (e entry) SetInputPurpose(purpose InputPurpose) {
	var _arg0 *C.GtkEntry       // out
	var _arg1 C.GtkInputPurpose // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkInputPurpose)(purpose)

	C.gtk_entry_set_input_purpose(_arg0, _arg1)
}

// SetInvisibleChar sets the character to use in place of the actual text when
// gtk_entry_set_visibility() has been called to set text visibility to false.
// i.e. this is the character used in “password mode” to show the user how many
// characters have been typed. By default, GTK+ picks the best invisible char
// available in the current font. If you set the invisible char to 0, then the
// user will get no feedback at all; there will be no text on the screen as they
// type.
func (e entry) SetInvisibleChar(ch uint32) {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.gunichar  // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.gunichar)(ch)

	C.gtk_entry_set_invisible_char(_arg0, _arg1)
}

// SetMaxLength sets the maximum allowed length of the contents of the widget.
// If the current contents are longer than the given length, then they will be
// truncated to fit.
//
// This is equivalent to getting @entry's EntryBuffer and calling
// gtk_entry_buffer_set_max_length() on it. ]|
func (e entry) SetMaxLength(max int) {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.gint      // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.gint)(max)

	C.gtk_entry_set_max_length(_arg0, _arg1)
}

// SetMaxWidthChars sets the desired maximum width in characters of @entry.
func (e entry) SetMaxWidthChars(nChars int) {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.gint      // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.gint)(nChars)

	C.gtk_entry_set_max_width_chars(_arg0, _arg1)
}

// SetOverwriteMode sets whether the text is overwritten when typing in the
// Entry.
func (e entry) SetOverwriteMode(overwrite bool) {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	if overwrite {
		_arg1 = C.TRUE
	}

	C.gtk_entry_set_overwrite_mode(_arg0, _arg1)
}

// SetPlaceholderText sets text to be displayed in @entry when it is empty and
// unfocused. This can be used to give a visual hint of the expected contents of
// the Entry.
//
// Note that since the placeholder text gets removed when the entry received
// focus, using this feature is a bit problematic if the entry is given the
// initial focus in a window. Sometimes this can be worked around by delaying
// the initial focus setting until the first key event arrives.
func (e entry) SetPlaceholderText(text string) {
	var _arg0 *C.GtkEntry // out
	var _arg1 *C.gchar    // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_entry_set_placeholder_text(_arg0, _arg1)
}

// SetProgressFraction causes the entry’s progress indicator to “fill in” the
// given fraction of the bar. The fraction should be between 0.0 and 1.0,
// inclusive.
func (e entry) SetProgressFraction(fraction float64) {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.gdouble   // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.gdouble)(fraction)

	C.gtk_entry_set_progress_fraction(_arg0, _arg1)
}

// SetProgressPulseStep sets the fraction of total entry width to move the
// progress bouncing block for each call to gtk_entry_progress_pulse().
func (e entry) SetProgressPulseStep(fraction float64) {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.gdouble   // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.gdouble)(fraction)

	C.gtk_entry_set_progress_pulse_step(_arg0, _arg1)
}

// SetTabs sets a TabArray; the tabstops in the array are applied to the entry
// text.
func (e entry) SetTabs(tabs *pango.TabArray) {
	var _arg0 *C.GtkEntry      // out
	var _arg1 *C.PangoTabArray // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.PangoTabArray)(unsafe.Pointer(tabs.Native()))

	C.gtk_entry_set_tabs(_arg0, _arg1)
}

// SetText sets the text in the widget to the given value, replacing the current
// contents.
//
// See gtk_entry_buffer_set_text().
func (e entry) SetText(text string) {
	var _arg0 *C.GtkEntry // out
	var _arg1 *C.gchar    // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_entry_set_text(_arg0, _arg1)
}

// SetVisibility sets whether the contents of the entry are visible or not. When
// visibility is set to false, characters are displayed as the invisible char,
// and will also appear that way when the text in the entry widget is copied
// elsewhere.
//
// By default, GTK+ picks the best invisible character available in the current
// font, but it can be changed with gtk_entry_set_invisible_char().
//
// Note that you probably want to set Entry:input-purpose to
// GTK_INPUT_PURPOSE_PASSWORD or GTK_INPUT_PURPOSE_PIN to inform input methods
// about the purpose of this entry, in addition to setting visibility to false.
func (e entry) SetVisibility(visible bool) {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	if visible {
		_arg1 = C.TRUE
	}

	C.gtk_entry_set_visibility(_arg0, _arg1)
}

// SetWidthChars changes the size request of the entry to be about the right
// size for @n_chars characters. Note that it changes the size request, the size
// can still be affected by how you pack the widget into containers. If @n_chars
// is -1, the size reverts to the default entry size.
func (e entry) SetWidthChars(nChars int) {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.gint      // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.gint)(nChars)

	C.gtk_entry_set_width_chars(_arg0, _arg1)
}

// TextIndexToLayoutIndex converts from a position in the entry contents
// (returned by gtk_entry_get_text()) to a position in the entry’s Layout
// (returned by gtk_entry_get_layout(), with text retrieved via
// pango_layout_get_text()).
func (e entry) TextIndexToLayoutIndex(textIndex int) int {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.gint      // out
	var _cret C.gint      // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (C.gint)(textIndex)

	_cret = C.gtk_entry_text_index_to_layout_index(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// UnsetInvisibleChar unsets the invisible char previously set with
// gtk_entry_set_invisible_char(). So that the default invisible char is used
// again.
func (e entry) UnsetInvisibleChar() {
	var _arg0 *C.GtkEntry // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	C.gtk_entry_unset_invisible_char(_arg0)
}

type EntryAccessible interface {
	WidgetAccessible
}

// entryAccessible implements the EntryAccessible class.
type entryAccessible struct {
	WidgetAccessible
}

var _ EntryAccessible = (*entryAccessible)(nil)

// WrapEntryAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapEntryAccessible(obj *externglib.Object) EntryAccessible {
	return entryAccessible{
		WidgetAccessible: WrapWidgetAccessible(obj),
	}
}

func marshalEntryAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEntryAccessible(obj), nil
}

// EntryBuffer: the EntryBuffer class contains the actual text displayed in a
// Entry widget.
//
// A single EntryBuffer object can be shared by multiple Entry widgets which
// will then share the same text content, but not the cursor position,
// visibility attributes, icon etc.
//
// EntryBuffer may be derived from. Such a derived class might allow text to be
// stored in an alternate location, such as non-pageable memory, useful in the
// case of important passwords. Or a derived class could integrate with an
// application’s concept of undo/redo.
type EntryBuffer interface {
	gextras.Objector

	// DeleteText deletes a sequence of characters from the buffer. @n_chars
	// characters are deleted starting at @position. If @n_chars is negative,
	// then all characters until the end of the text are deleted.
	//
	// If @position or @n_chars are out of bounds, then they are coerced to sane
	// values.
	//
	// Note that the positions are specified in characters, not bytes.
	DeleteText(position uint, nChars int) uint
	// EmitDeletedText: used when subclassing EntryBuffer
	EmitDeletedText(position uint, nChars uint)
	// EmitInsertedText: used when subclassing EntryBuffer
	EmitInsertedText(position uint, chars string, nChars uint)
	// Bytes retrieves the length in bytes of the buffer. See
	// gtk_entry_buffer_get_length().
	Bytes() uint
	// Length retrieves the length in characters of the buffer.
	Length() uint
	// MaxLength retrieves the maximum allowed length of the text in @buffer.
	// See gtk_entry_buffer_set_max_length().
	MaxLength() int
	// Text retrieves the contents of the buffer.
	//
	// The memory pointer returned by this call will not change unless this
	// object emits a signal, or is finalized.
	Text() string
	// InsertText inserts @n_chars characters of @chars into the contents of the
	// buffer, at position @position.
	//
	// If @n_chars is negative, then characters from chars will be inserted
	// until a null-terminator is found. If @position or @n_chars are out of
	// bounds, or the maximum buffer text length is exceeded, then they are
	// coerced to sane values.
	//
	// Note that the position and length are in characters, not in bytes.
	InsertText(position uint, chars string, nChars int) uint
	// SetMaxLength sets the maximum allowed length of the contents of the
	// buffer. If the current contents are longer than the given length, then
	// they will be truncated to fit.
	SetMaxLength(maxLength int)
	// SetText sets the text in the buffer.
	//
	// This is roughly equivalent to calling gtk_entry_buffer_delete_text() and
	// gtk_entry_buffer_insert_text().
	//
	// Note that @n_chars is in characters, not in bytes.
	SetText(chars string, nChars int)
}

// entryBuffer implements the EntryBuffer class.
type entryBuffer struct {
	gextras.Objector
}

var _ EntryBuffer = (*entryBuffer)(nil)

// WrapEntryBuffer wraps a GObject to the right type. It is
// primarily used internally.
func WrapEntryBuffer(obj *externglib.Object) EntryBuffer {
	return entryBuffer{
		Objector: obj,
	}
}

func marshalEntryBuffer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEntryBuffer(obj), nil
}

// NewEntryBuffer: create a new GtkEntryBuffer object.
//
// Optionally, specify initial text to set in the buffer.
func NewEntryBuffer(initialChars string, nInitialChars int) EntryBuffer {
	var _arg1 *C.gchar          // out
	var _arg2 C.gint            // out
	var _cret *C.GtkEntryBuffer // in

	_arg1 = (*C.gchar)(C.CString(initialChars))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gint)(nInitialChars)

	_cret = C.gtk_entry_buffer_new(_arg1, _arg2)

	var _entryBuffer EntryBuffer // out

	_entryBuffer = WrapEntryBuffer(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _entryBuffer
}

// DeleteText deletes a sequence of characters from the buffer. @n_chars
// characters are deleted starting at @position. If @n_chars is negative, then
// all characters until the end of the text are deleted.
//
// If @position or @n_chars are out of bounds, then they are coerced to sane
// values.
//
// Note that the positions are specified in characters, not bytes.
func (b entryBuffer) DeleteText(position uint, nChars int) uint {
	var _arg0 *C.GtkEntryBuffer // out
	var _arg1 C.guint           // out
	var _arg2 C.gint            // out
	var _cret C.guint           // in

	_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (C.guint)(position)
	_arg2 = (C.gint)(nChars)

	_cret = C.gtk_entry_buffer_delete_text(_arg0, _arg1, _arg2)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// EmitDeletedText: used when subclassing EntryBuffer
func (b entryBuffer) EmitDeletedText(position uint, nChars uint) {
	var _arg0 *C.GtkEntryBuffer // out
	var _arg1 C.guint           // out
	var _arg2 C.guint           // out

	_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (C.guint)(position)
	_arg2 = (C.guint)(nChars)

	C.gtk_entry_buffer_emit_deleted_text(_arg0, _arg1, _arg2)
}

// EmitInsertedText: used when subclassing EntryBuffer
func (b entryBuffer) EmitInsertedText(position uint, chars string, nChars uint) {
	var _arg0 *C.GtkEntryBuffer // out
	var _arg1 C.guint           // out
	var _arg2 *C.gchar          // out
	var _arg3 C.guint           // out

	_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (C.guint)(position)
	_arg2 = (*C.gchar)(C.CString(chars))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.guint)(nChars)

	C.gtk_entry_buffer_emit_inserted_text(_arg0, _arg1, _arg2, _arg3)
}

// Bytes retrieves the length in bytes of the buffer. See
// gtk_entry_buffer_get_length().
func (b entryBuffer) Bytes() uint {
	var _arg0 *C.GtkEntryBuffer // out
	var _cret C.gsize           // in

	_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_entry_buffer_get_bytes(_arg0)

	var _gsize uint // out

	_gsize = (uint)(_cret)

	return _gsize
}

// Length retrieves the length in characters of the buffer.
func (b entryBuffer) Length() uint {
	var _arg0 *C.GtkEntryBuffer // out
	var _cret C.guint           // in

	_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_entry_buffer_get_length(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// MaxLength retrieves the maximum allowed length of the text in @buffer. See
// gtk_entry_buffer_set_max_length().
func (b entryBuffer) MaxLength() int {
	var _arg0 *C.GtkEntryBuffer // out
	var _cret C.gint            // in

	_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_entry_buffer_get_max_length(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Text retrieves the contents of the buffer.
//
// The memory pointer returned by this call will not change unless this object
// emits a signal, or is finalized.
func (b entryBuffer) Text() string {
	var _arg0 *C.GtkEntryBuffer // out
	var _cret *C.gchar          // in

	_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_entry_buffer_get_text(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// InsertText inserts @n_chars characters of @chars into the contents of the
// buffer, at position @position.
//
// If @n_chars is negative, then characters from chars will be inserted until a
// null-terminator is found. If @position or @n_chars are out of bounds, or the
// maximum buffer text length is exceeded, then they are coerced to sane values.
//
// Note that the position and length are in characters, not in bytes.
func (b entryBuffer) InsertText(position uint, chars string, nChars int) uint {
	var _arg0 *C.GtkEntryBuffer // out
	var _arg1 C.guint           // out
	var _arg2 *C.gchar          // out
	var _arg3 C.gint            // out
	var _cret C.guint           // in

	_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (C.guint)(position)
	_arg2 = (*C.gchar)(C.CString(chars))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.gint)(nChars)

	_cret = C.gtk_entry_buffer_insert_text(_arg0, _arg1, _arg2, _arg3)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// SetMaxLength sets the maximum allowed length of the contents of the buffer.
// If the current contents are longer than the given length, then they will be
// truncated to fit.
func (b entryBuffer) SetMaxLength(maxLength int) {
	var _arg0 *C.GtkEntryBuffer // out
	var _arg1 C.gint            // out

	_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (C.gint)(maxLength)

	C.gtk_entry_buffer_set_max_length(_arg0, _arg1)
}

// SetText sets the text in the buffer.
//
// This is roughly equivalent to calling gtk_entry_buffer_delete_text() and
// gtk_entry_buffer_insert_text().
//
// Note that @n_chars is in characters, not in bytes.
func (b entryBuffer) SetText(chars string, nChars int) {
	var _arg0 *C.GtkEntryBuffer // out
	var _arg1 *C.gchar          // out
	var _arg2 C.gint            // out

	_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(chars))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gint)(nChars)

	C.gtk_entry_buffer_set_text(_arg0, _arg1, _arg2)
}

// EntryCompletion is an auxiliary object to be used in conjunction with Entry
// to provide the completion functionality. It implements the CellLayout
// interface, to allow the user to add extra cells to the TreeView with
// completion matches.
//
// “Completion functionality” means that when the user modifies the text in the
// entry, EntryCompletion checks which rows in the model match the current
// content of the entry, and displays a list of matches. By default, the
// matching is done by comparing the entry text case-insensitively against the
// text column of the model (see gtk_entry_completion_set_text_column()), but
// this can be overridden with a custom match function (see
// gtk_entry_completion_set_match_func()).
//
// When the user selects a completion, the content of the entry is updated. By
// default, the content of the entry is replaced by the text column of the
// model, but this can be overridden by connecting to the
// EntryCompletion::match-selected signal and updating the entry in the signal
// handler. Note that you should return true from the signal handler to suppress
// the default behaviour.
//
// To add completion functionality to an entry, use gtk_entry_set_completion().
//
// In addition to regular completion matches, which will be inserted into the
// entry when they are selected, EntryCompletion also allows to display
// “actions” in the popup window. Their appearance is similar to menuitems, to
// differentiate them clearly from completion strings. When an action is
// selected, the EntryCompletion::action-activated signal is emitted.
//
// GtkEntryCompletion uses a TreeModelFilter model to represent the subset of
// the entire model that is currently matching. While the GtkEntryCompletion
// signals EntryCompletion::match-selected and EntryCompletion::cursor-on-match
// take the original model and an iter pointing to that model as arguments,
// other callbacks and signals (such as CellLayoutDataFuncs or
// CellArea::apply-attributes) will generally take the filter model as argument.
// As long as you are only calling gtk_tree_model_get(), this will make no
// difference to you. If for some reason, you need the original model, use
// gtk_tree_model_filter_get_model(). Don’t forget to use
// gtk_tree_model_filter_convert_iter_to_child_iter() to obtain a matching iter.
type EntryCompletion interface {
	gextras.Objector
	Buildable
	CellLayout

	// Complete requests a completion operation, or in other words a refiltering
	// of the current list with completions, using the current key. The
	// completion list view will be updated accordingly.
	Complete()
	// ComputePrefix computes the common prefix that is shared by all rows in
	// @completion that start with @key. If no row matches @key, nil will be
	// returned. Note that a text column must have been set for this function to
	// work, see gtk_entry_completion_set_text_column() for details.
	ComputePrefix(key string) string
	// DeleteAction deletes the action at @index_ from @completion’s action
	// list.
	//
	// Note that @index_ is a relative position and the position of an action
	// may have changed since it was inserted.
	DeleteAction(index_ int)
	// CompletionPrefix: get the original text entered by the user that
	// triggered the completion or nil if there’s no completion ongoing.
	CompletionPrefix() string
	// Entry gets the entry @completion has been attached to.
	Entry() Widget
	// InlineCompletion returns whether the common prefix of the possible
	// completions should be automatically inserted in the entry.
	InlineCompletion() bool
	// InlineSelection returns true if inline-selection mode is turned on.
	InlineSelection() bool
	// MinimumKeyLength returns the minimum key length as set for @completion.
	MinimumKeyLength() int
	// Model returns the model the EntryCompletion is using as data source.
	// Returns nil if the model is unset.
	Model() TreeModel
	// PopupCompletion returns whether the completions should be presented in a
	// popup window.
	PopupCompletion() bool
	// PopupSetWidth returns whether the completion popup window will be resized
	// to the width of the entry.
	PopupSetWidth() bool
	// PopupSingleMatch returns whether the completion popup window will appear
	// even if there is only a single match.
	PopupSingleMatch() bool
	// TextColumn returns the column in the model of @completion to get strings
	// from.
	TextColumn() int
	// InsertActionMarkup inserts an action in @completion’s action item list at
	// position @index_ with markup @markup.
	InsertActionMarkup(index_ int, markup string)
	// InsertActionText inserts an action in @completion’s action item list at
	// position @index_ with text @text. If you want the action item to have
	// markup, use gtk_entry_completion_insert_action_markup().
	//
	// Note that @index_ is a relative position in the list of actions and the
	// position of an action can change when deleting a different action.
	InsertActionText(index_ int, text string)
	// InsertPrefix requests a prefix insertion.
	InsertPrefix()
	// SetInlineCompletion sets whether the common prefix of the possible
	// completions should be automatically inserted in the entry.
	SetInlineCompletion(inlineCompletion bool)
	// SetInlineSelection sets whether it is possible to cycle through the
	// possible completions inside the entry.
	SetInlineSelection(inlineSelection bool)
	// SetMinimumKeyLength requires the length of the search key for @completion
	// to be at least @length. This is useful for long lists, where completing
	// using a small key takes a lot of time and will come up with meaningless
	// results anyway (ie, a too large dataset).
	SetMinimumKeyLength(length int)
	// SetModel sets the model for a EntryCompletion. If @completion already has
	// a model set, it will remove it before setting the new model. If model is
	// nil, then it will unset the model.
	SetModel(model TreeModel)
	// SetPopupCompletion sets whether the completions should be presented in a
	// popup window.
	SetPopupCompletion(popupCompletion bool)
	// SetPopupSetWidth sets whether the completion popup window will be resized
	// to be the same width as the entry.
	SetPopupSetWidth(popupSetWidth bool)
	// SetPopupSingleMatch sets whether the completion popup window will appear
	// even if there is only a single match. You may want to set this to false
	// if you are using [inline
	// completion][GtkEntryCompletion--inline-completion].
	SetPopupSingleMatch(popupSingleMatch bool)
	// SetTextColumn: convenience function for setting up the most used case of
	// this code: a completion list with just strings. This function will set up
	// @completion to have a list displaying all (and just) strings in the
	// completion list, and to get those strings from @column in the model of
	// @completion.
	//
	// This functions creates and adds a CellRendererText for the selected
	// column. If you need to set the text column, but don't want the cell
	// renderer, use g_object_set() to set the EntryCompletion:text-column
	// property directly.
	SetTextColumn(column int)
}

// entryCompletion implements the EntryCompletion class.
type entryCompletion struct {
	gextras.Objector
	Buildable
	CellLayout
}

var _ EntryCompletion = (*entryCompletion)(nil)

// WrapEntryCompletion wraps a GObject to the right type. It is
// primarily used internally.
func WrapEntryCompletion(obj *externglib.Object) EntryCompletion {
	return entryCompletion{
		Objector:   obj,
		Buildable:  WrapBuildable(obj),
		CellLayout: WrapCellLayout(obj),
	}
}

func marshalEntryCompletion(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEntryCompletion(obj), nil
}

// NewEntryCompletion creates a new EntryCompletion object.
func NewEntryCompletion() EntryCompletion {
	var _cret *C.GtkEntryCompletion // in

	_cret = C.gtk_entry_completion_new()

	var _entryCompletion EntryCompletion // out

	_entryCompletion = WrapEntryCompletion(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _entryCompletion
}

// NewEntryCompletionWithArea creates a new EntryCompletion object using the
// specified @area to layout cells in the underlying TreeViewColumn for the
// drop-down menu.
func NewEntryCompletionWithArea(area CellArea) EntryCompletion {
	var _arg1 *C.GtkCellArea        // out
	var _cret *C.GtkEntryCompletion // in

	_arg1 = (*C.GtkCellArea)(unsafe.Pointer(area.Native()))

	_cret = C.gtk_entry_completion_new_with_area(_arg1)

	var _entryCompletion EntryCompletion // out

	_entryCompletion = WrapEntryCompletion(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _entryCompletion
}

// Complete requests a completion operation, or in other words a refiltering of
// the current list with completions, using the current key. The completion list
// view will be updated accordingly.
func (c entryCompletion) Complete() {
	var _arg0 *C.GtkEntryCompletion // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	C.gtk_entry_completion_complete(_arg0)
}

// ComputePrefix computes the common prefix that is shared by all rows in
// @completion that start with @key. If no row matches @key, nil will be
// returned. Note that a text column must have been set for this function to
// work, see gtk_entry_completion_set_text_column() for details.
func (c entryCompletion) ComputePrefix(key string) string {
	var _arg0 *C.GtkEntryCompletion // out
	var _arg1 *C.char               // out
	var _cret *C.gchar              // in

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_entry_completion_compute_prefix(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// DeleteAction deletes the action at @index_ from @completion’s action list.
//
// Note that @index_ is a relative position and the position of an action may
// have changed since it was inserted.
func (c entryCompletion) DeleteAction(index_ int) {
	var _arg0 *C.GtkEntryCompletion // out
	var _arg1 C.gint                // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	_arg1 = (C.gint)(index_)

	C.gtk_entry_completion_delete_action(_arg0, _arg1)
}

// CompletionPrefix: get the original text entered by the user that triggered
// the completion or nil if there’s no completion ongoing.
func (c entryCompletion) CompletionPrefix() string {
	var _arg0 *C.GtkEntryCompletion // out
	var _cret *C.gchar              // in

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_entry_completion_get_completion_prefix(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Entry gets the entry @completion has been attached to.
func (c entryCompletion) Entry() Widget {
	var _arg0 *C.GtkEntryCompletion // out
	var _cret *C.GtkWidget          // in

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_entry_completion_get_entry(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// InlineCompletion returns whether the common prefix of the possible
// completions should be automatically inserted in the entry.
func (c entryCompletion) InlineCompletion() bool {
	var _arg0 *C.GtkEntryCompletion // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_entry_completion_get_inline_completion(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InlineSelection returns true if inline-selection mode is turned on.
func (c entryCompletion) InlineSelection() bool {
	var _arg0 *C.GtkEntryCompletion // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_entry_completion_get_inline_selection(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MinimumKeyLength returns the minimum key length as set for @completion.
func (c entryCompletion) MinimumKeyLength() int {
	var _arg0 *C.GtkEntryCompletion // out
	var _cret C.gint                // in

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_entry_completion_get_minimum_key_length(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Model returns the model the EntryCompletion is using as data source. Returns
// nil if the model is unset.
func (c entryCompletion) Model() TreeModel {
	var _arg0 *C.GtkEntryCompletion // out
	var _cret *C.GtkTreeModel       // in

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_entry_completion_get_model(_arg0)

	var _treeModel TreeModel // out

	_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeModel)

	return _treeModel
}

// PopupCompletion returns whether the completions should be presented in a
// popup window.
func (c entryCompletion) PopupCompletion() bool {
	var _arg0 *C.GtkEntryCompletion // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_entry_completion_get_popup_completion(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PopupSetWidth returns whether the completion popup window will be resized to
// the width of the entry.
func (c entryCompletion) PopupSetWidth() bool {
	var _arg0 *C.GtkEntryCompletion // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_entry_completion_get_popup_set_width(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PopupSingleMatch returns whether the completion popup window will appear even
// if there is only a single match.
func (c entryCompletion) PopupSingleMatch() bool {
	var _arg0 *C.GtkEntryCompletion // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_entry_completion_get_popup_single_match(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TextColumn returns the column in the model of @completion to get strings
// from.
func (c entryCompletion) TextColumn() int {
	var _arg0 *C.GtkEntryCompletion // out
	var _cret C.gint                // in

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_entry_completion_get_text_column(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// InsertActionMarkup inserts an action in @completion’s action item list at
// position @index_ with markup @markup.
func (c entryCompletion) InsertActionMarkup(index_ int, markup string) {
	var _arg0 *C.GtkEntryCompletion // out
	var _arg1 C.gint                // out
	var _arg2 *C.gchar              // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	_arg1 = (C.gint)(index_)
	_arg2 = (*C.gchar)(C.CString(markup))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_entry_completion_insert_action_markup(_arg0, _arg1, _arg2)
}

// InsertActionText inserts an action in @completion’s action item list at
// position @index_ with text @text. If you want the action item to have markup,
// use gtk_entry_completion_insert_action_markup().
//
// Note that @index_ is a relative position in the list of actions and the
// position of an action can change when deleting a different action.
func (c entryCompletion) InsertActionText(index_ int, text string) {
	var _arg0 *C.GtkEntryCompletion // out
	var _arg1 C.gint                // out
	var _arg2 *C.gchar              // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	_arg1 = (C.gint)(index_)
	_arg2 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_entry_completion_insert_action_text(_arg0, _arg1, _arg2)
}

// InsertPrefix requests a prefix insertion.
func (c entryCompletion) InsertPrefix() {
	var _arg0 *C.GtkEntryCompletion // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	C.gtk_entry_completion_insert_prefix(_arg0)
}

// SetInlineCompletion sets whether the common prefix of the possible
// completions should be automatically inserted in the entry.
func (c entryCompletion) SetInlineCompletion(inlineCompletion bool) {
	var _arg0 *C.GtkEntryCompletion // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	if inlineCompletion {
		_arg1 = C.TRUE
	}

	C.gtk_entry_completion_set_inline_completion(_arg0, _arg1)
}

// SetInlineSelection sets whether it is possible to cycle through the possible
// completions inside the entry.
func (c entryCompletion) SetInlineSelection(inlineSelection bool) {
	var _arg0 *C.GtkEntryCompletion // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	if inlineSelection {
		_arg1 = C.TRUE
	}

	C.gtk_entry_completion_set_inline_selection(_arg0, _arg1)
}

// SetMinimumKeyLength requires the length of the search key for @completion to
// be at least @length. This is useful for long lists, where completing using a
// small key takes a lot of time and will come up with meaningless results
// anyway (ie, a too large dataset).
func (c entryCompletion) SetMinimumKeyLength(length int) {
	var _arg0 *C.GtkEntryCompletion // out
	var _arg1 C.gint                // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	_arg1 = (C.gint)(length)

	C.gtk_entry_completion_set_minimum_key_length(_arg0, _arg1)
}

// SetModel sets the model for a EntryCompletion. If @completion already has a
// model set, it will remove it before setting the new model. If model is nil,
// then it will unset the model.
func (c entryCompletion) SetModel(model TreeModel) {
	var _arg0 *C.GtkEntryCompletion // out
	var _arg1 *C.GtkTreeModel       // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

	C.gtk_entry_completion_set_model(_arg0, _arg1)
}

// SetPopupCompletion sets whether the completions should be presented in a
// popup window.
func (c entryCompletion) SetPopupCompletion(popupCompletion bool) {
	var _arg0 *C.GtkEntryCompletion // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	if popupCompletion {
		_arg1 = C.TRUE
	}

	C.gtk_entry_completion_set_popup_completion(_arg0, _arg1)
}

// SetPopupSetWidth sets whether the completion popup window will be resized to
// be the same width as the entry.
func (c entryCompletion) SetPopupSetWidth(popupSetWidth bool) {
	var _arg0 *C.GtkEntryCompletion // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	if popupSetWidth {
		_arg1 = C.TRUE
	}

	C.gtk_entry_completion_set_popup_set_width(_arg0, _arg1)
}

// SetPopupSingleMatch sets whether the completion popup window will appear even
// if there is only a single match. You may want to set this to false if you are
// using [inline completion][GtkEntryCompletion--inline-completion].
func (c entryCompletion) SetPopupSingleMatch(popupSingleMatch bool) {
	var _arg0 *C.GtkEntryCompletion // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	if popupSingleMatch {
		_arg1 = C.TRUE
	}

	C.gtk_entry_completion_set_popup_single_match(_arg0, _arg1)
}

// SetTextColumn: convenience function for setting up the most used case of this
// code: a completion list with just strings. This function will set up
// @completion to have a list displaying all (and just) strings in the
// completion list, and to get those strings from @column in the model of
// @completion.
//
// This functions creates and adds a CellRendererText for the selected column.
// If you need to set the text column, but don't want the cell renderer, use
// g_object_set() to set the EntryCompletion:text-column property directly.
func (c entryCompletion) SetTextColumn(column int) {
	var _arg0 *C.GtkEntryCompletion // out
	var _arg1 C.gint                // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	_arg1 = (C.gint)(column)

	C.gtk_entry_completion_set_text_column(_arg0, _arg1)
}

// EventBox: the EventBox widget is a subclass of Bin which also has its own
// window. It is useful since it allows you to catch events for widgets which do
// not have their own window.
type EventBox interface {
	Bin
	Buildable

	// AboveChild returns whether the event box window is above or below the
	// windows of its child. See gtk_event_box_set_above_child() for details.
	AboveChild() bool
	// VisibleWindow returns whether the event box has a visible window. See
	// gtk_event_box_set_visible_window() for details.
	VisibleWindow() bool
	// SetAboveChild: set whether the event box window is positioned above the
	// windows of its child, as opposed to below it. If the window is above, all
	// events inside the event box will go to the event box. If the window is
	// below, events in windows of child widgets will first got to that widget,
	// and then to its parents.
	//
	// The default is to keep the window below the child.
	SetAboveChild(aboveChild bool)
	// SetVisibleWindow: set whether the event box uses a visible or invisible
	// child window. The default is to use visible windows.
	//
	// In an invisible window event box, the window that the event box creates
	// is a GDK_INPUT_ONLY window, which means that it is invisible and only
	// serves to receive events.
	//
	// A visible window event box creates a visible (GDK_INPUT_OUTPUT) window
	// that acts as the parent window for all the widgets contained in the event
	// box.
	//
	// You should generally make your event box invisible if you just want to
	// trap events. Creating a visible window may cause artifacts that are
	// visible to the user, especially if the user is using a theme with
	// gradients or pixmaps.
	//
	// The main reason to create a non input-only event box is if you want to
	// set the background to a different color or draw on it.
	//
	// There is one unexpected issue for an invisible event box that has its
	// window below the child. (See gtk_event_box_set_above_child().) Since the
	// input-only window is not an ancestor window of any windows that
	// descendent widgets of the event box create, events on these windows
	// aren’t propagated up by the windowing system, but only by GTK+. The
	// practical effect of this is if an event isn’t in the event mask for the
	// descendant window (see gtk_widget_add_events()), it won’t be received by
	// the event box.
	//
	// This problem doesn’t occur for visible event boxes, because in that case,
	// the event box window is actually the ancestor of the descendant windows,
	// not just at the same place on the screen.
	SetVisibleWindow(visibleWindow bool)
}

// eventBox implements the EventBox class.
type eventBox struct {
	Bin
	Buildable
}

var _ EventBox = (*eventBox)(nil)

// WrapEventBox wraps a GObject to the right type. It is
// primarily used internally.
func WrapEventBox(obj *externglib.Object) EventBox {
	return eventBox{
		Bin:       WrapBin(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalEventBox(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEventBox(obj), nil
}

// NewEventBox creates a new EventBox.
func NewEventBox() EventBox {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_event_box_new()

	var _eventBox EventBox // out

	_eventBox = WrapEventBox(externglib.Take(unsafe.Pointer(_cret)))

	return _eventBox
}

// AboveChild returns whether the event box window is above or below the windows
// of its child. See gtk_event_box_set_above_child() for details.
func (e eventBox) AboveChild() bool {
	var _arg0 *C.GtkEventBox // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkEventBox)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_event_box_get_above_child(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// VisibleWindow returns whether the event box has a visible window. See
// gtk_event_box_set_visible_window() for details.
func (e eventBox) VisibleWindow() bool {
	var _arg0 *C.GtkEventBox // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkEventBox)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_event_box_get_visible_window(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetAboveChild: set whether the event box window is positioned above the
// windows of its child, as opposed to below it. If the window is above, all
// events inside the event box will go to the event box. If the window is below,
// events in windows of child widgets will first got to that widget, and then to
// its parents.
//
// The default is to keep the window below the child.
func (e eventBox) SetAboveChild(aboveChild bool) {
	var _arg0 *C.GtkEventBox // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkEventBox)(unsafe.Pointer(e.Native()))
	if aboveChild {
		_arg1 = C.TRUE
	}

	C.gtk_event_box_set_above_child(_arg0, _arg1)
}

// SetVisibleWindow: set whether the event box uses a visible or invisible child
// window. The default is to use visible windows.
//
// In an invisible window event box, the window that the event box creates is a
// GDK_INPUT_ONLY window, which means that it is invisible and only serves to
// receive events.
//
// A visible window event box creates a visible (GDK_INPUT_OUTPUT) window that
// acts as the parent window for all the widgets contained in the event box.
//
// You should generally make your event box invisible if you just want to trap
// events. Creating a visible window may cause artifacts that are visible to the
// user, especially if the user is using a theme with gradients or pixmaps.
//
// The main reason to create a non input-only event box is if you want to set
// the background to a different color or draw on it.
//
// There is one unexpected issue for an invisible event box that has its window
// below the child. (See gtk_event_box_set_above_child().) Since the input-only
// window is not an ancestor window of any windows that descendent widgets of
// the event box create, events on these windows aren’t propagated up by the
// windowing system, but only by GTK+. The practical effect of this is if an
// event isn’t in the event mask for the descendant window (see
// gtk_widget_add_events()), it won’t be received by the event box.
//
// This problem doesn’t occur for visible event boxes, because in that case, the
// event box window is actually the ancestor of the descendant windows, not just
// at the same place on the screen.
func (e eventBox) SetVisibleWindow(visibleWindow bool) {
	var _arg0 *C.GtkEventBox // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkEventBox)(unsafe.Pointer(e.Native()))
	if visibleWindow {
		_arg1 = C.TRUE
	}

	C.gtk_event_box_set_visible_window(_arg0, _arg1)
}

// EventController is a base, low-level implementation for event controllers.
// Those react to a series of Events, and possibly trigger actions as a
// consequence of those.
type EventController interface {
	gextras.Objector

	// PropagationPhase gets the propagation phase at which @controller handles
	// events.
	PropagationPhase() PropagationPhase
	// Widget returns the Widget this controller relates to.
	Widget() Widget
	// Reset resets the @controller to a clean state. Every interaction the
	// controller did through EventController::handle-event will be dropped at
	// this point.
	Reset()
	// SetPropagationPhase sets the propagation phase at which a controller
	// handles events.
	//
	// If @phase is GTK_PHASE_NONE, no automatic event handling will be
	// performed, but other additional gesture maintenance will. In that phase,
	// the events can be managed by calling gtk_event_controller_handle_event().
	SetPropagationPhase(phase PropagationPhase)
}

// eventController implements the EventController class.
type eventController struct {
	gextras.Objector
}

var _ EventController = (*eventController)(nil)

// WrapEventController wraps a GObject to the right type. It is
// primarily used internally.
func WrapEventController(obj *externglib.Object) EventController {
	return eventController{
		Objector: obj,
	}
}

func marshalEventController(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEventController(obj), nil
}

// PropagationPhase gets the propagation phase at which @controller handles
// events.
func (c eventController) PropagationPhase() PropagationPhase {
	var _arg0 *C.GtkEventController // out
	var _cret C.GtkPropagationPhase // in

	_arg0 = (*C.GtkEventController)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_event_controller_get_propagation_phase(_arg0)

	var _propagationPhase PropagationPhase // out

	_propagationPhase = PropagationPhase(_cret)

	return _propagationPhase
}

// Widget returns the Widget this controller relates to.
func (c eventController) Widget() Widget {
	var _arg0 *C.GtkEventController // out
	var _cret *C.GtkWidget          // in

	_arg0 = (*C.GtkEventController)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_event_controller_get_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// Reset resets the @controller to a clean state. Every interaction the
// controller did through EventController::handle-event will be dropped at this
// point.
func (c eventController) Reset() {
	var _arg0 *C.GtkEventController // out

	_arg0 = (*C.GtkEventController)(unsafe.Pointer(c.Native()))

	C.gtk_event_controller_reset(_arg0)
}

// SetPropagationPhase sets the propagation phase at which a controller handles
// events.
//
// If @phase is GTK_PHASE_NONE, no automatic event handling will be performed,
// but other additional gesture maintenance will. In that phase, the events can
// be managed by calling gtk_event_controller_handle_event().
func (c eventController) SetPropagationPhase(phase PropagationPhase) {
	var _arg0 *C.GtkEventController // out
	var _arg1 C.GtkPropagationPhase // out

	_arg0 = (*C.GtkEventController)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GtkPropagationPhase)(phase)

	C.gtk_event_controller_set_propagation_phase(_arg0, _arg1)
}

// EventControllerKey is an event controller meant for situations where you need
// access to key events.
//
// This object was added in 3.24.
type EventControllerKey interface {
	EventController

	Forward(widget Widget) bool

	Group() uint
	// ImContext gets the IM context of a key controller.
	ImContext() IMContext

	SetImContext(imContext IMContext)
}

// eventControllerKey implements the EventControllerKey class.
type eventControllerKey struct {
	EventController
}

var _ EventControllerKey = (*eventControllerKey)(nil)

// WrapEventControllerKey wraps a GObject to the right type. It is
// primarily used internally.
func WrapEventControllerKey(obj *externglib.Object) EventControllerKey {
	return eventControllerKey{
		EventController: WrapEventController(obj),
	}
}

func marshalEventControllerKey(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEventControllerKey(obj), nil
}

func NewEventControllerKey(widget Widget) EventControllerKey {
	var _arg1 *C.GtkWidget          // out
	var _cret *C.GtkEventController // in

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	_cret = C.gtk_event_controller_key_new(_arg1)

	var _eventControllerKey EventControllerKey // out

	_eventControllerKey = WrapEventControllerKey(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _eventControllerKey
}

func (c eventControllerKey) Forward(widget Widget) bool {
	var _arg0 *C.GtkEventControllerKey // out
	var _arg1 *C.GtkWidget             // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GtkEventControllerKey)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	_cret = C.gtk_event_controller_key_forward(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c eventControllerKey) Group() uint {
	var _arg0 *C.GtkEventControllerKey // out
	var _cret C.guint                  // in

	_arg0 = (*C.GtkEventControllerKey)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_event_controller_key_get_group(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// ImContext gets the IM context of a key controller.
func (c eventControllerKey) ImContext() IMContext {
	var _arg0 *C.GtkEventControllerKey // out
	var _cret *C.GtkIMContext          // in

	_arg0 = (*C.GtkEventControllerKey)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_event_controller_key_get_im_context(_arg0)

	var _imContext IMContext // out

	_imContext = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(IMContext)

	return _imContext
}

func (c eventControllerKey) SetImContext(imContext IMContext) {
	var _arg0 *C.GtkEventControllerKey // out
	var _arg1 *C.GtkIMContext          // out

	_arg0 = (*C.GtkEventControllerKey)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkIMContext)(unsafe.Pointer(imContext.Native()))

	C.gtk_event_controller_key_set_im_context(_arg0, _arg1)
}

// EventControllerMotion is an event controller meant for situations where you
// need to track the position of the pointer.
//
// This object was added in 3.24.
type EventControllerMotion interface {
	EventController
}

// eventControllerMotion implements the EventControllerMotion class.
type eventControllerMotion struct {
	EventController
}

var _ EventControllerMotion = (*eventControllerMotion)(nil)

// WrapEventControllerMotion wraps a GObject to the right type. It is
// primarily used internally.
func WrapEventControllerMotion(obj *externglib.Object) EventControllerMotion {
	return eventControllerMotion{
		EventController: WrapEventController(obj),
	}
}

func marshalEventControllerMotion(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEventControllerMotion(obj), nil
}

// NewEventControllerMotion creates a new event controller that will handle
// motion events for the given @widget.
func NewEventControllerMotion(widget Widget) EventControllerMotion {
	var _arg1 *C.GtkWidget          // out
	var _cret *C.GtkEventController // in

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	_cret = C.gtk_event_controller_motion_new(_arg1)

	var _eventControllerMotion EventControllerMotion // out

	_eventControllerMotion = WrapEventControllerMotion(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _eventControllerMotion
}

// EventControllerScroll is an event controller meant to handle scroll events
// from mice and touchpads. It is capable of handling both discrete and
// continuous scroll events, abstracting them both on the
// EventControllerScroll::scroll signal (deltas in the discrete case are
// multiples of 1).
//
// In the case of continuous scroll events, EventControllerScroll encloses all
// EventControllerScroll::scroll events between two
// EventControllerScroll::scroll-begin and EventControllerScroll::scroll-end
// signals.
//
// The behavior of the event controller can be modified by the flags given at
// creation time, or modified at a later point through
// gtk_event_controller_scroll_set_flags() (e.g. because the scrolling
// conditions of the widget changed).
//
// The controller can be set up to emit motion for either/both vertical and
// horizontal scroll events through K_EVENT_CONTROLLER_SCROLL_VERTICAL,
// K_EVENT_CONTROLLER_SCROLL_HORIZONTAL and K_EVENT_CONTROLLER_SCROLL_BOTH. If
// any axis is disabled, the respective EventControllerScroll::scroll delta will
// be 0. Vertical scroll events will be translated to horizontal motion for the
// devices incapable of horizontal scrolling.
//
// The event controller can also be forced to emit discrete events on all
// devices through K_EVENT_CONTROLLER_SCROLL_DISCRETE. This can be used to
// implement discrete actions triggered through scroll events (e.g. switching
// across combobox options).
//
// The K_EVENT_CONTROLLER_SCROLL_KINETIC flag toggles the emission of the
// EventControllerScroll::decelerate signal, emitted at the end of scrolling
// with two X/Y velocity arguments that are consistent with the motion that was
// received.
//
// This object was added in 3.24.
type EventControllerScroll interface {
	EventController

	// Flags gets the flags conditioning the scroll controller behavior.
	Flags() EventControllerScrollFlags
	// SetFlags sets the flags conditioning scroll controller behavior.
	SetFlags(flags EventControllerScrollFlags)
}

// eventControllerScroll implements the EventControllerScroll class.
type eventControllerScroll struct {
	EventController
}

var _ EventControllerScroll = (*eventControllerScroll)(nil)

// WrapEventControllerScroll wraps a GObject to the right type. It is
// primarily used internally.
func WrapEventControllerScroll(obj *externglib.Object) EventControllerScroll {
	return eventControllerScroll{
		EventController: WrapEventController(obj),
	}
}

func marshalEventControllerScroll(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEventControllerScroll(obj), nil
}

// NewEventControllerScroll creates a new event controller that will handle
// scroll events for the given @widget.
func NewEventControllerScroll(widget Widget, flags EventControllerScrollFlags) EventControllerScroll {
	var _arg1 *C.GtkWidget                    // out
	var _arg2 C.GtkEventControllerScrollFlags // out
	var _cret *C.GtkEventController           // in

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (C.GtkEventControllerScrollFlags)(flags)

	_cret = C.gtk_event_controller_scroll_new(_arg1, _arg2)

	var _eventControllerScroll EventControllerScroll // out

	_eventControllerScroll = WrapEventControllerScroll(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _eventControllerScroll
}

// Flags gets the flags conditioning the scroll controller behavior.
func (c eventControllerScroll) Flags() EventControllerScrollFlags {
	var _arg0 *C.GtkEventControllerScroll     // out
	var _cret C.GtkEventControllerScrollFlags // in

	_arg0 = (*C.GtkEventControllerScroll)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_event_controller_scroll_get_flags(_arg0)

	var _eventControllerScrollFlags EventControllerScrollFlags // out

	_eventControllerScrollFlags = EventControllerScrollFlags(_cret)

	return _eventControllerScrollFlags
}

// SetFlags sets the flags conditioning scroll controller behavior.
func (c eventControllerScroll) SetFlags(flags EventControllerScrollFlags) {
	var _arg0 *C.GtkEventControllerScroll     // out
	var _arg1 C.GtkEventControllerScrollFlags // out

	_arg0 = (*C.GtkEventControllerScroll)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GtkEventControllerScrollFlags)(flags)

	C.gtk_event_controller_scroll_set_flags(_arg0, _arg1)
}

// Expander: a Expander allows the user to hide or show its child by clicking on
// an expander triangle similar to the triangles used in a TreeView.
//
// Normally you use an expander as you would use any other descendant of Bin;
// you create the child widget and use gtk_container_add() to add it to the
// expander. When the expander is toggled, it will take care of showing and
// hiding the child automatically.
//
//
// Special Usage
//
// There are situations in which you may prefer to show and hide the expanded
// widget yourself, such as when you want to actually create the widget at
// expansion time. In this case, create a Expander but do not add a child to it.
// The expander widget has an Expander:expanded property which can be used to
// monitor its expansion state. You should watch this property with a signal
// connection as follows:
//
//    expander
//    ├── title
//    │   ├── arrow
//    │   ╰── <label widget>
//    ╰── <child>
//
// GtkExpander has three CSS nodes, the main node with the name expander, a
// subnode with name title and node below it with name arrow. The arrow of an
// expander that is showing its child gets the :checked pseudoclass added to it.
type Expander interface {
	Bin
	Buildable

	// Expanded queries a Expander and returns its current state. Returns true
	// if the child widget is revealed.
	//
	// See gtk_expander_set_expanded().
	Expanded() bool
	// Label fetches the text from a label widget including any embedded
	// underlines indicating mnemonics and Pango markup, as set by
	// gtk_expander_set_label(). If the label text has not been set the return
	// value will be nil. This will be the case if you create an empty button
	// with gtk_button_new() to use as a container.
	//
	// Note that this function behaved differently in versions prior to 2.14 and
	// used to return the label text stripped of embedded underlines indicating
	// mnemonics and Pango markup. This problem can be avoided by fetching the
	// label text directly from the label widget.
	Label() string
	// LabelFill returns whether the label widget will fill all available
	// horizontal space allocated to @expander.
	LabelFill() bool
	// LabelWidget retrieves the label widget for the frame. See
	// gtk_expander_set_label_widget().
	LabelWidget() Widget
	// ResizeToplevel returns whether the expander will resize the toplevel
	// widget containing the expander upon resizing and collpasing.
	ResizeToplevel() bool
	// Spacing gets the value set by gtk_expander_set_spacing().
	Spacing() int
	// UseMarkup returns whether the label’s text is interpreted as marked up
	// with the [Pango text markup language][PangoMarkupFormat]. See
	// gtk_expander_set_use_markup().
	UseMarkup() bool
	// UseUnderline returns whether an embedded underline in the expander label
	// indicates a mnemonic. See gtk_expander_set_use_underline().
	UseUnderline() bool
	// SetExpanded sets the state of the expander. Set to true, if you want the
	// child widget to be revealed, and false if you want the child widget to be
	// hidden.
	SetExpanded(expanded bool)
	// SetLabel sets the text of the label of the expander to @label.
	//
	// This will also clear any previously set labels.
	SetLabel(label string)
	// SetLabelFill sets whether the label widget should fill all available
	// horizontal space allocated to @expander.
	//
	// Note that this function has no effect since 3.20.
	SetLabelFill(labelFill bool)
	// SetLabelWidget: set the label widget for the expander. This is the widget
	// that will appear embedded alongside the expander arrow.
	SetLabelWidget(labelWidget Widget)
	// SetResizeToplevel sets whether the expander will resize the toplevel
	// widget containing the expander upon resizing and collpasing.
	SetResizeToplevel(resizeToplevel bool)
	// SetSpacing sets the spacing field of @expander, which is the number of
	// pixels to place between expander and the child.
	SetSpacing(spacing int)
	// SetUseMarkup sets whether the text of the label contains markup in
	// [Pango’s text markup language][PangoMarkupFormat]. See
	// gtk_label_set_markup().
	SetUseMarkup(useMarkup bool)
	// SetUseUnderline: if true, an underline in the text of the expander label
	// indicates the next character should be used for the mnemonic accelerator
	// key.
	SetUseUnderline(useUnderline bool)
}

// expander implements the Expander class.
type expander struct {
	Bin
	Buildable
}

var _ Expander = (*expander)(nil)

// WrapExpander wraps a GObject to the right type. It is
// primarily used internally.
func WrapExpander(obj *externglib.Object) Expander {
	return expander{
		Bin:       WrapBin(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalExpander(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapExpander(obj), nil
}

// NewExpander creates a new expander using @label as the text of the label.
func NewExpander(label string) Expander {
	var _arg1 *C.gchar     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_expander_new(_arg1)

	var _expander Expander // out

	_expander = WrapExpander(externglib.Take(unsafe.Pointer(_cret)))

	return _expander
}

// NewExpanderWithMnemonic creates a new expander using @label as the text of
// the label. If characters in @label are preceded by an underscore, they are
// underlined. If you need a literal underscore character in a label, use “__”
// (two underscores). The first underlined character represents a keyboard
// accelerator called a mnemonic. Pressing Alt and that key activates the
// button.
func NewExpanderWithMnemonic(label string) Expander {
	var _arg1 *C.gchar     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_expander_new_with_mnemonic(_arg1)

	var _expander Expander // out

	_expander = WrapExpander(externglib.Take(unsafe.Pointer(_cret)))

	return _expander
}

// Expanded queries a Expander and returns its current state. Returns true if
// the child widget is revealed.
//
// See gtk_expander_set_expanded().
func (e expander) Expanded() bool {
	var _arg0 *C.GtkExpander // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_expander_get_expanded(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Label fetches the text from a label widget including any embedded underlines
// indicating mnemonics and Pango markup, as set by gtk_expander_set_label(). If
// the label text has not been set the return value will be nil. This will be
// the case if you create an empty button with gtk_button_new() to use as a
// container.
//
// Note that this function behaved differently in versions prior to 2.14 and
// used to return the label text stripped of embedded underlines indicating
// mnemonics and Pango markup. This problem can be avoided by fetching the label
// text directly from the label widget.
func (e expander) Label() string {
	var _arg0 *C.GtkExpander // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_expander_get_label(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// LabelFill returns whether the label widget will fill all available horizontal
// space allocated to @expander.
func (e expander) LabelFill() bool {
	var _arg0 *C.GtkExpander // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_expander_get_label_fill(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LabelWidget retrieves the label widget for the frame. See
// gtk_expander_set_label_widget().
func (e expander) LabelWidget() Widget {
	var _arg0 *C.GtkExpander // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_expander_get_label_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// ResizeToplevel returns whether the expander will resize the toplevel widget
// containing the expander upon resizing and collpasing.
func (e expander) ResizeToplevel() bool {
	var _arg0 *C.GtkExpander // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_expander_get_resize_toplevel(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Spacing gets the value set by gtk_expander_set_spacing().
func (e expander) Spacing() int {
	var _arg0 *C.GtkExpander // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_expander_get_spacing(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// UseMarkup returns whether the label’s text is interpreted as marked up with
// the [Pango text markup language][PangoMarkupFormat]. See
// gtk_expander_set_use_markup().
func (e expander) UseMarkup() bool {
	var _arg0 *C.GtkExpander // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_expander_get_use_markup(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UseUnderline returns whether an embedded underline in the expander label
// indicates a mnemonic. See gtk_expander_set_use_underline().
func (e expander) UseUnderline() bool {
	var _arg0 *C.GtkExpander // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_expander_get_use_underline(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetExpanded sets the state of the expander. Set to true, if you want the
// child widget to be revealed, and false if you want the child widget to be
// hidden.
func (e expander) SetExpanded(expanded bool) {
	var _arg0 *C.GtkExpander // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
	if expanded {
		_arg1 = C.TRUE
	}

	C.gtk_expander_set_expanded(_arg0, _arg1)
}

// SetLabel sets the text of the label of the expander to @label.
//
// This will also clear any previously set labels.
func (e expander) SetLabel(label string) {
	var _arg0 *C.GtkExpander // out
	var _arg1 *C.gchar       // out

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_expander_set_label(_arg0, _arg1)
}

// SetLabelFill sets whether the label widget should fill all available
// horizontal space allocated to @expander.
//
// Note that this function has no effect since 3.20.
func (e expander) SetLabelFill(labelFill bool) {
	var _arg0 *C.GtkExpander // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
	if labelFill {
		_arg1 = C.TRUE
	}

	C.gtk_expander_set_label_fill(_arg0, _arg1)
}

// SetLabelWidget: set the label widget for the expander. This is the widget
// that will appear embedded alongside the expander arrow.
func (e expander) SetLabelWidget(labelWidget Widget) {
	var _arg0 *C.GtkExpander // out
	var _arg1 *C.GtkWidget   // out

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(labelWidget.Native()))

	C.gtk_expander_set_label_widget(_arg0, _arg1)
}

// SetResizeToplevel sets whether the expander will resize the toplevel widget
// containing the expander upon resizing and collpasing.
func (e expander) SetResizeToplevel(resizeToplevel bool) {
	var _arg0 *C.GtkExpander // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
	if resizeToplevel {
		_arg1 = C.TRUE
	}

	C.gtk_expander_set_resize_toplevel(_arg0, _arg1)
}

// SetSpacing sets the spacing field of @expander, which is the number of pixels
// to place between expander and the child.
func (e expander) SetSpacing(spacing int) {
	var _arg0 *C.GtkExpander // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
	_arg1 = (C.gint)(spacing)

	C.gtk_expander_set_spacing(_arg0, _arg1)
}

// SetUseMarkup sets whether the text of the label contains markup in [Pango’s
// text markup language][PangoMarkupFormat]. See gtk_label_set_markup().
func (e expander) SetUseMarkup(useMarkup bool) {
	var _arg0 *C.GtkExpander // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
	if useMarkup {
		_arg1 = C.TRUE
	}

	C.gtk_expander_set_use_markup(_arg0, _arg1)
}

// SetUseUnderline: if true, an underline in the text of the expander label
// indicates the next character should be used for the mnemonic accelerator key.
func (e expander) SetUseUnderline(useUnderline bool) {
	var _arg0 *C.GtkExpander // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
	if useUnderline {
		_arg1 = C.TRUE
	}

	C.gtk_expander_set_use_underline(_arg0, _arg1)
}

type ExpanderAccessible interface {
	ContainerAccessible
}

// expanderAccessible implements the ExpanderAccessible class.
type expanderAccessible struct {
	ContainerAccessible
}

var _ ExpanderAccessible = (*expanderAccessible)(nil)

// WrapExpanderAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapExpanderAccessible(obj *externglib.Object) ExpanderAccessible {
	return expanderAccessible{
		ContainerAccessible: WrapContainerAccessible(obj),
	}
}

func marshalExpanderAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapExpanderAccessible(obj), nil
}

// FileChooserButton: the FileChooserButton is a widget that lets the user
// select a file. It implements the FileChooser interface. Visually, it is a
// file name with a button to bring up a FileChooserDialog. The user can then
// use that dialog to change the file associated with that button. This widget
// does not support setting the FileChooser:select-multiple property to true.
//
// Create a button to let the user select a file in /etc
//
//    {
//      GtkWidget *button;
//
//      button = gtk_file_chooser_button_new (_("Select a file"),
//                                            GTK_FILE_CHOOSER_ACTION_OPEN);
//      gtk_file_chooser_set_current_folder (GTK_FILE_CHOOSER (button),
//                                           "/etc");
//    }
//
// The FileChooserButton supports the FileChooserActions
// GTK_FILE_CHOOSER_ACTION_OPEN and GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER.
//
// > The FileChooserButton will ellipsize the label, and will thus > request
// little horizontal space. To give the button more space, > you should call
// gtk_widget_get_preferred_size(), > gtk_file_chooser_button_set_width_chars(),
// or pack the button in > such a way that other interface elements give space
// to the > widget.
//
//
// CSS nodes
//
// GtkFileChooserButton has a CSS node with name “filechooserbutton”, containing
// a subnode for the internal button with name “button” and style class “.file”.
type FileChooserButton interface {
	Box
	Buildable
	FileChooser
	Orientable

	// FocusOnClick returns whether the button grabs focus when it is clicked
	// with the mouse. See gtk_file_chooser_button_set_focus_on_click().
	FocusOnClick() bool
	// Title retrieves the title of the browse dialog used by @button. The
	// returned value should not be modified or freed.
	Title() string
	// WidthChars retrieves the width in characters of the @button widget’s
	// entry and/or label.
	WidthChars() int
	// SetFocusOnClick sets whether the button will grab focus when it is
	// clicked with the mouse. Making mouse clicks not grab focus is useful in
	// places like toolbars where you don’t want the keyboard focus removed from
	// the main area of the application.
	SetFocusOnClick(focusOnClick bool)
	// SetTitle modifies the @title of the browse dialog used by @button.
	SetTitle(title string)
	// SetWidthChars sets the width (in characters) that @button will use to
	// @n_chars.
	SetWidthChars(nChars int)
}

// fileChooserButton implements the FileChooserButton class.
type fileChooserButton struct {
	Box
	Buildable
	FileChooser
	Orientable
}

var _ FileChooserButton = (*fileChooserButton)(nil)

// WrapFileChooserButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileChooserButton(obj *externglib.Object) FileChooserButton {
	return fileChooserButton{
		Box:         WrapBox(obj),
		Buildable:   WrapBuildable(obj),
		FileChooser: WrapFileChooser(obj),
		Orientable:  WrapOrientable(obj),
	}
}

func marshalFileChooserButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileChooserButton(obj), nil
}

// NewFileChooserButton creates a new file-selecting button widget.
func NewFileChooserButton(title string, action FileChooserAction) FileChooserButton {
	var _arg1 *C.gchar               // out
	var _arg2 C.GtkFileChooserAction // out
	var _cret *C.GtkWidget           // in

	_arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GtkFileChooserAction)(action)

	_cret = C.gtk_file_chooser_button_new(_arg1, _arg2)

	var _fileChooserButton FileChooserButton // out

	_fileChooserButton = WrapFileChooserButton(externglib.Take(unsafe.Pointer(_cret)))

	return _fileChooserButton
}

// NewFileChooserButtonWithDialog creates a FileChooserButton widget which uses
// @dialog as its file-picking window.
//
// Note that @dialog must be a Dialog (or subclass) which implements the
// FileChooser interface and must not have GTK_DIALOG_DESTROY_WITH_PARENT set.
//
// Also note that the dialog needs to have its confirmative button added with
// response GTK_RESPONSE_ACCEPT or GTK_RESPONSE_OK in order for the button to
// take over the file selected in the dialog.
func NewFileChooserButtonWithDialog(dialog Dialog) FileChooserButton {
	var _arg1 *C.GtkWidget // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(dialog.Native()))

	_cret = C.gtk_file_chooser_button_new_with_dialog(_arg1)

	var _fileChooserButton FileChooserButton // out

	_fileChooserButton = WrapFileChooserButton(externglib.Take(unsafe.Pointer(_cret)))

	return _fileChooserButton
}

// FocusOnClick returns whether the button grabs focus when it is clicked with
// the mouse. See gtk_file_chooser_button_set_focus_on_click().
func (b fileChooserButton) FocusOnClick() bool {
	var _arg0 *C.GtkFileChooserButton // out
	var _cret C.gboolean              // in

	_arg0 = (*C.GtkFileChooserButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_file_chooser_button_get_focus_on_click(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Title retrieves the title of the browse dialog used by @button. The returned
// value should not be modified or freed.
func (b fileChooserButton) Title() string {
	var _arg0 *C.GtkFileChooserButton // out
	var _cret *C.gchar                // in

	_arg0 = (*C.GtkFileChooserButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_file_chooser_button_get_title(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// WidthChars retrieves the width in characters of the @button widget’s entry
// and/or label.
func (b fileChooserButton) WidthChars() int {
	var _arg0 *C.GtkFileChooserButton // out
	var _cret C.gint                  // in

	_arg0 = (*C.GtkFileChooserButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_file_chooser_button_get_width_chars(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// SetFocusOnClick sets whether the button will grab focus when it is clicked
// with the mouse. Making mouse clicks not grab focus is useful in places like
// toolbars where you don’t want the keyboard focus removed from the main area
// of the application.
func (b fileChooserButton) SetFocusOnClick(focusOnClick bool) {
	var _arg0 *C.GtkFileChooserButton // out
	var _arg1 C.gboolean              // out

	_arg0 = (*C.GtkFileChooserButton)(unsafe.Pointer(b.Native()))
	if focusOnClick {
		_arg1 = C.TRUE
	}

	C.gtk_file_chooser_button_set_focus_on_click(_arg0, _arg1)
}

// SetTitle modifies the @title of the browse dialog used by @button.
func (b fileChooserButton) SetTitle(title string) {
	var _arg0 *C.GtkFileChooserButton // out
	var _arg1 *C.gchar                // out

	_arg0 = (*C.GtkFileChooserButton)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_file_chooser_button_set_title(_arg0, _arg1)
}

// SetWidthChars sets the width (in characters) that @button will use to
// @n_chars.
func (b fileChooserButton) SetWidthChars(nChars int) {
	var _arg0 *C.GtkFileChooserButton // out
	var _arg1 C.gint                  // out

	_arg0 = (*C.GtkFileChooserButton)(unsafe.Pointer(b.Native()))
	_arg1 = (C.gint)(nChars)

	C.gtk_file_chooser_button_set_width_chars(_arg0, _arg1)
}

// FileChooserDialog is a dialog box suitable for use with “File/Open” or
// “File/Save as” commands. This widget works by putting a FileChooserWidget
// inside a Dialog. It exposes the FileChooser interface, so you can use all of
// the FileChooser functions on the file chooser dialog as well as those for
// Dialog.
//
// Note that FileChooserDialog does not have any methods of its own. Instead,
// you should use the functions that work on a FileChooser.
//
// If you want to integrate well with the platform you should use the
// FileChooserNative API, which will use a platform-specific dialog if available
// and fall back to GtkFileChooserDialog otherwise.
//
//
// Typical usage
//
// In the simplest of cases, you can the following code to use FileChooserDialog
// to select a file for opening:
//
//    GtkWidget *dialog;
//    GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
//    gint res;
//
//    dialog = gtk_file_chooser_dialog_new ("Open File",
//                                          parent_window,
//                                          action,
//                                          _("_Cancel"),
//                                          GTK_RESPONSE_CANCEL,
//                                          _("_Open"),
//                                          GTK_RESPONSE_ACCEPT,
//                                          NULL);
//
//    res = gtk_dialog_run (GTK_DIALOG (dialog));
//    if (res == GTK_RESPONSE_ACCEPT)
//      {
//        char *filename;
//        GtkFileChooser *chooser = GTK_FILE_CHOOSER (dialog);
//        filename = gtk_file_chooser_get_filename (chooser);
//        open_file (filename);
//        g_free (filename);
//      }
//
//    gtk_widget_destroy (dialog);
//
// To use a dialog for saving, you can use this:
//
//    GtkWidget *dialog;
//    GtkFileChooser *chooser;
//    GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_SAVE;
//    gint res;
//
//    dialog = gtk_file_chooser_dialog_new ("Save File",
//                                          parent_window,
//                                          action,
//                                          _("_Cancel"),
//                                          GTK_RESPONSE_CANCEL,
//                                          _("_Save"),
//                                          GTK_RESPONSE_ACCEPT,
//                                          NULL);
//    chooser = GTK_FILE_CHOOSER (dialog);
//
//    gtk_file_chooser_set_do_overwrite_confirmation (chooser, TRUE);
//
//    if (user_edited_a_new_document)
//      gtk_file_chooser_set_current_name (chooser,
//                                         _("Untitled document"));
//    else
//      gtk_file_chooser_set_filename (chooser,
//                                     existing_filename);
//
//    res = gtk_dialog_run (GTK_DIALOG (dialog));
//    if (res == GTK_RESPONSE_ACCEPT)
//      {
//        char *filename;
//
//        filename = gtk_file_chooser_get_filename (chooser);
//        save_to_file (filename);
//        g_free (filename);
//      }
//
//    gtk_widget_destroy (dialog);
//
//
// Setting up a file chooser dialog
//
// There are various cases in which you may need to use a FileChooserDialog:
//
// - To select a file for opening. Use K_FILE_CHOOSER_ACTION_OPEN.
//
// - To save a file for the first time. Use K_FILE_CHOOSER_ACTION_SAVE, and
// suggest a name such as “Untitled” with gtk_file_chooser_set_current_name().
//
// - To save a file under a different name. Use K_FILE_CHOOSER_ACTION_SAVE, and
// set the existing filename with gtk_file_chooser_set_filename().
//
// - To choose a folder instead of a file. Use
// K_FILE_CHOOSER_ACTION_SELECT_FOLDER.
//
// Note that old versions of the file chooser’s documentation suggested using
// gtk_file_chooser_set_current_folder() in various situations, with the
// intention of letting the application suggest a reasonable default folder.
// This is no longer considered to be a good policy, as now the file chooser is
// able to make good suggestions on its own. In general, you should only cause
// the file chooser to show a specific folder when it is appropriate to use
// gtk_file_chooser_set_filename(), i.e. when you are doing a Save As command
// and you already have a file saved somewhere.
//
//
// Response Codes
//
// FileChooserDialog inherits from Dialog, so buttons that go in its action area
// have response codes such as K_RESPONSE_ACCEPT and K_RESPONSE_CANCEL. For
// example, you could call gtk_file_chooser_dialog_new() as follows:
//
//    GtkWidget *dialog;
//    GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
//
//    dialog = gtk_file_chooser_dialog_new ("Open File",
//                                          parent_window,
//                                          action,
//                                          _("_Cancel"),
//                                          GTK_RESPONSE_CANCEL,
//                                          _("_Open"),
//                                          GTK_RESPONSE_ACCEPT,
//                                          NULL);
//
// This will create buttons for “Cancel” and “Open” that use stock response
// identifiers from ResponseType. For most dialog boxes you can use your own
// custom response codes rather than the ones in ResponseType, but
// FileChooserDialog assumes that its “accept”-type action, e.g. an “Open” or
// “Save” button, will have one of the following response codes:
//
// - K_RESPONSE_ACCEPT - K_RESPONSE_OK - K_RESPONSE_YES - K_RESPONSE_APPLY
//
// This is because FileChooserDialog must intercept responses and switch to
// folders if appropriate, rather than letting the dialog terminate — the
// implementation uses these known response codes to know which responses can be
// blocked if appropriate.
//
// To summarize, make sure you use a [stock response
// code][gtkfilechooserdialog-responses] when you use FileChooserDialog to
// ensure proper operation.
type FileChooserDialog interface {
	Dialog
	Buildable
	FileChooser
}

// fileChooserDialog implements the FileChooserDialog class.
type fileChooserDialog struct {
	Dialog
	Buildable
	FileChooser
}

var _ FileChooserDialog = (*fileChooserDialog)(nil)

// WrapFileChooserDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileChooserDialog(obj *externglib.Object) FileChooserDialog {
	return fileChooserDialog{
		Dialog:      WrapDialog(obj),
		Buildable:   WrapBuildable(obj),
		FileChooser: WrapFileChooser(obj),
	}
}

func marshalFileChooserDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileChooserDialog(obj), nil
}

// FileChooserNative is an abstraction of a dialog box suitable for use with
// “File/Open” or “File/Save as” commands. By default, this just uses a
// FileChooserDialog to implement the actual dialog. However, on certain
// platforms, such as Windows and macOS, the native platform file chooser is
// used instead. When the application is running in a sandboxed environment
// without direct filesystem access (such as Flatpak), FileChooserNative may
// call the proper APIs (portals) to let the user choose a file and make it
// available to the application.
//
// While the API of FileChooserNative closely mirrors FileChooserDialog, the
// main difference is that there is no access to any Window or Widget for the
// dialog. This is required, as there may not be one in the case of a platform
// native dialog. Showing, hiding and running the dialog is handled by the
// NativeDialog functions.
//
//
// Typical usage
//
// In the simplest of cases, you can the following code to use FileChooserDialog
// to select a file for opening:
//
//    GtkFileChooserNative *native;
//    GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
//    gint res;
//
//    native = gtk_file_chooser_native_new ("Open File",
//                                          parent_window,
//                                          action,
//                                          "_Open",
//                                          "_Cancel");
//
//    res = gtk_native_dialog_run (GTK_NATIVE_DIALOG (native));
//    if (res == GTK_RESPONSE_ACCEPT)
//      {
//        char *filename;
//        GtkFileChooser *chooser = GTK_FILE_CHOOSER (native);
//        filename = gtk_file_chooser_get_filename (chooser);
//        open_file (filename);
//        g_free (filename);
//      }
//
//    g_object_unref (native);
//
// To use a dialog for saving, you can use this:
//
//    GtkFileChooserNative *native;
//    GtkFileChooser *chooser;
//    GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_SAVE;
//    gint res;
//
//    native = gtk_file_chooser_native_new ("Save File",
//                                          parent_window,
//                                          action,
//                                          "_Save",
//                                          "_Cancel");
//    chooser = GTK_FILE_CHOOSER (native);
//
//    gtk_file_chooser_set_do_overwrite_confirmation (chooser, TRUE);
//
//    if (user_edited_a_new_document)
//      gtk_file_chooser_set_current_name (chooser,
//                                         _("Untitled document"));
//    else
//      gtk_file_chooser_set_filename (chooser,
//                                     existing_filename);
//
//    res = gtk_native_dialog_run (GTK_NATIVE_DIALOG (native));
//    if (res == GTK_RESPONSE_ACCEPT)
//      {
//        char *filename;
//
//        filename = gtk_file_chooser_get_filename (chooser);
//        save_to_file (filename);
//        g_free (filename);
//      }
//
//    g_object_unref (native);
//
// For more information on how to best set up a file dialog, see
// FileChooserDialog.
//
//
// Response Codes
//
// FileChooserNative inherits from NativeDialog, which means it will return
// K_RESPONSE_ACCEPT if the user accepted, and K_RESPONSE_CANCEL if he pressed
// cancel. It can also return K_RESPONSE_DELETE_EVENT if the window was
// unexpectedly closed.
//
// Differences from FileChooserDialog ##
// {#gtkfilechooserdialognative-differences}
//
// There are a few things in the GtkFileChooser API that are not possible to use
// with FileChooserNative, as such use would prohibit the use of a native
// dialog.
//
// There is no support for the signals that are emitted when the user navigates
// in the dialog, including: * FileChooser::current-folder-changed *
// FileChooser::selection-changed * FileChooser::file-activated *
// FileChooser::confirm-overwrite
//
// You can also not use the methods that directly control user navigation: *
// gtk_file_chooser_unselect_filename() * gtk_file_chooser_select_all() *
// gtk_file_chooser_unselect_all()
//
// If you need any of the above you will have to use FileChooserDialog directly.
//
// No operations that change the the dialog work while the dialog is visible.
// Set all the properties that are required before showing the dialog.
//
//
// Win32 details
//
// On windows the IFileDialog implementation (added in Windows Vista) is used.
// It supports many of the features that FileChooserDialog does, but there are
// some things it does not handle:
//
// * Extra widgets added with gtk_file_chooser_set_extra_widget().
//
// * Use of custom previews by connecting to FileChooser::update-preview.
//
// * Any FileFilter added using a mimetype or custom filter.
//
// If any of these features are used the regular FileChooserDialog will be used
// in place of the native one.
//
//
// Portal details
//
// When the org.freedesktop.portal.FileChooser portal is available on the
// session bus, it is used to bring up an out-of-process file chooser. Depending
// on the kind of session the application is running in, this may or may not be
// a GTK+ file chooser. In this situation, the following things are not
// supported and will be silently ignored:
//
// * Extra widgets added with gtk_file_chooser_set_extra_widget().
//
// * Use of custom previews by connecting to FileChooser::update-preview.
//
// * Any FileFilter added with a custom filter.
//
// macOS details
//
// On macOS the NSSavePanel and NSOpenPanel classes are used to provide native
// file chooser dialogs. Some features provided by FileChooserDialog are not
// supported:
//
// * Extra widgets added with gtk_file_chooser_set_extra_widget(), unless the
// widget is an instance of GtkLabel, in which case the label text will be used
// to set the NSSavePanel message instance property.
//
// * Use of custom previews by connecting to FileChooser::update-preview.
//
// * Any FileFilter added with a custom filter.
//
// * Shortcut folders.
type FileChooserNative interface {
	NativeDialog
	FileChooser

	// AcceptLabel retrieves the custom label text for the accept button.
	AcceptLabel() string
	// CancelLabel retrieves the custom label text for the cancel button.
	CancelLabel() string
	// SetAcceptLabel sets the custom label text for the accept button.
	//
	// If characters in @label are preceded by an underscore, they are
	// underlined. If you need a literal underscore character in a label, use
	// “__” (two underscores). The first underlined character represents a
	// keyboard accelerator called a mnemonic. Pressing Alt and that key
	// activates the button.
	SetAcceptLabel(acceptLabel string)
	// SetCancelLabel sets the custom label text for the cancel button.
	//
	// If characters in @label are preceded by an underscore, they are
	// underlined. If you need a literal underscore character in a label, use
	// “__” (two underscores). The first underlined character represents a
	// keyboard accelerator called a mnemonic. Pressing Alt and that key
	// activates the button.
	SetCancelLabel(cancelLabel string)
}

// fileChooserNative implements the FileChooserNative class.
type fileChooserNative struct {
	NativeDialog
	FileChooser
}

var _ FileChooserNative = (*fileChooserNative)(nil)

// WrapFileChooserNative wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileChooserNative(obj *externglib.Object) FileChooserNative {
	return fileChooserNative{
		NativeDialog: WrapNativeDialog(obj),
		FileChooser:  WrapFileChooser(obj),
	}
}

func marshalFileChooserNative(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileChooserNative(obj), nil
}

// NewFileChooserNative creates a new FileChooserNative.
func NewFileChooserNative(title string, parent Window, action FileChooserAction, acceptLabel string, cancelLabel string) FileChooserNative {
	var _arg1 *C.gchar                // out
	var _arg2 *C.GtkWindow            // out
	var _arg3 C.GtkFileChooserAction  // out
	var _arg4 *C.gchar                // out
	var _arg5 *C.gchar                // out
	var _cret *C.GtkFileChooserNative // in

	_arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))
	_arg3 = (C.GtkFileChooserAction)(action)
	_arg4 = (*C.gchar)(C.CString(acceptLabel))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.gchar)(C.CString(cancelLabel))
	defer C.free(unsafe.Pointer(_arg5))

	_cret = C.gtk_file_chooser_native_new(_arg1, _arg2, _arg3, _arg4, _arg5)

	var _fileChooserNative FileChooserNative // out

	_fileChooserNative = WrapFileChooserNative(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _fileChooserNative
}

// AcceptLabel retrieves the custom label text for the accept button.
func (s fileChooserNative) AcceptLabel() string {
	var _arg0 *C.GtkFileChooserNative // out
	var _cret *C.char                 // in

	_arg0 = (*C.GtkFileChooserNative)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_file_chooser_native_get_accept_label(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// CancelLabel retrieves the custom label text for the cancel button.
func (s fileChooserNative) CancelLabel() string {
	var _arg0 *C.GtkFileChooserNative // out
	var _cret *C.char                 // in

	_arg0 = (*C.GtkFileChooserNative)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_file_chooser_native_get_cancel_label(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// SetAcceptLabel sets the custom label text for the accept button.
//
// If characters in @label are preceded by an underscore, they are underlined.
// If you need a literal underscore character in a label, use “__” (two
// underscores). The first underlined character represents a keyboard
// accelerator called a mnemonic. Pressing Alt and that key activates the
// button.
func (s fileChooserNative) SetAcceptLabel(acceptLabel string) {
	var _arg0 *C.GtkFileChooserNative // out
	var _arg1 *C.char                 // out

	_arg0 = (*C.GtkFileChooserNative)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(acceptLabel))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_file_chooser_native_set_accept_label(_arg0, _arg1)
}

// SetCancelLabel sets the custom label text for the cancel button.
//
// If characters in @label are preceded by an underscore, they are underlined.
// If you need a literal underscore character in a label, use “__” (two
// underscores). The first underlined character represents a keyboard
// accelerator called a mnemonic. Pressing Alt and that key activates the
// button.
func (s fileChooserNative) SetCancelLabel(cancelLabel string) {
	var _arg0 *C.GtkFileChooserNative // out
	var _arg1 *C.char                 // out

	_arg0 = (*C.GtkFileChooserNative)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(cancelLabel))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_file_chooser_native_set_cancel_label(_arg0, _arg1)
}

// FileChooserWidget is a widget for choosing files. It exposes the FileChooser
// interface, and you should use the methods of this interface to interact with
// the widget.
//
//
// CSS nodes
//
// GtkFileChooserWidget has a single CSS node with name filechooser.
type FileChooserWidget interface {
	Box
	Buildable
	FileChooser
	Orientable
}

// fileChooserWidget implements the FileChooserWidget class.
type fileChooserWidget struct {
	Box
	Buildable
	FileChooser
	Orientable
}

var _ FileChooserWidget = (*fileChooserWidget)(nil)

// WrapFileChooserWidget wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileChooserWidget(obj *externglib.Object) FileChooserWidget {
	return fileChooserWidget{
		Box:         WrapBox(obj),
		Buildable:   WrapBuildable(obj),
		FileChooser: WrapFileChooser(obj),
		Orientable:  WrapOrientable(obj),
	}
}

func marshalFileChooserWidget(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileChooserWidget(obj), nil
}

// NewFileChooserWidget creates a new FileChooserWidget. This is a file chooser
// widget that can be embedded in custom windows, and it is the same widget that
// is used by FileChooserDialog.
func NewFileChooserWidget(action FileChooserAction) FileChooserWidget {
	var _arg1 C.GtkFileChooserAction // out
	var _cret *C.GtkWidget           // in

	_arg1 = (C.GtkFileChooserAction)(action)

	_cret = C.gtk_file_chooser_widget_new(_arg1)

	var _fileChooserWidget FileChooserWidget // out

	_fileChooserWidget = WrapFileChooserWidget(externglib.Take(unsafe.Pointer(_cret)))

	return _fileChooserWidget
}

// FileFilter: a GtkFileFilter can be used to restrict the files being shown in
// a FileChooser. Files can be filtered based on their name (with
// gtk_file_filter_add_pattern()), on their mime type (with
// gtk_file_filter_add_mime_type()), or by a custom filter function (with
// gtk_file_filter_add_custom()).
//
// Filtering by mime types handles aliasing and subclassing of mime types; e.g.
// a filter for text/plain also matches a file with mime type application/rtf,
// since application/rtf is a subclass of text/plain. Note that FileFilter
// allows wildcards for the subtype of a mime type, so you can e.g. filter for
// image/\*.
//
// Normally, filters are used by adding them to a FileChooser, see
// gtk_file_chooser_add_filter(), but it is also possible to manually use a
// filter on a file with gtk_file_filter_filter().
//
//
// GtkFileFilter as GtkBuildable
//
// The GtkFileFilter implementation of the GtkBuildable interface supports
// adding rules using the <mime-types>, <patterns> and <applications> elements
// and listing the rules within. Specifying a <mime-type> or <pattern> has the
// same effect as as calling gtk_file_filter_add_mime_type() or
// gtk_file_filter_add_pattern().
//
// An example of a UI definition fragment specifying GtkFileFilter rules:
//
//    <object class="GtkFileFilter">
//      <mime-types>
//        <mime-type>text/plain</mime-type>
//        <mime-type>image/ *</mime-type>
//      </mime-types>
//      <patterns>
//        <pattern>*.txt</pattern>
//        <pattern>*.png</pattern>
//      </patterns>
//    </object>
type FileFilter interface {
	gextras.Objector
	Buildable

	// AddMIMEType adds a rule allowing a given mime type to @filter.
	AddMIMEType(mimeType string)
	// AddPattern adds a rule allowing a shell style glob to a filter.
	AddPattern(pattern string)
	// AddPixbufFormats adds a rule allowing image files in the formats
	// supported by GdkPixbuf.
	AddPixbufFormats()
	// Filter tests whether a file should be displayed according to @filter. The
	// FileFilterInfo @filter_info should include the fields returned from
	// gtk_file_filter_get_needed().
	//
	// This function will not typically be used by applications; it is intended
	// principally for use in the implementation of FileChooser.
	Filter(filterInfo *FileFilterInfo) bool
	// Name gets the human-readable name for the filter. See
	// gtk_file_filter_set_name().
	Name() string
	// Needed gets the fields that need to be filled in for the FileFilterInfo
	// passed to gtk_file_filter_filter()
	//
	// This function will not typically be used by applications; it is intended
	// principally for use in the implementation of FileChooser.
	Needed() FileFilterFlags
	// SetName sets the human-readable name of the filter; this is the string
	// that will be displayed in the file selector user interface if there is a
	// selectable list of filters.
	SetName(name string)
	// ToGVariant: serialize a file filter to an a{sv} variant.
	ToGVariant() *glib.Variant
}

// fileFilter implements the FileFilter class.
type fileFilter struct {
	gextras.Objector
	Buildable
}

var _ FileFilter = (*fileFilter)(nil)

// WrapFileFilter wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileFilter(obj *externglib.Object) FileFilter {
	return fileFilter{
		Objector:  obj,
		Buildable: WrapBuildable(obj),
	}
}

func marshalFileFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileFilter(obj), nil
}

// NewFileFilter creates a new FileFilter with no rules added to it. Such a
// filter doesn’t accept any files, so is not particularly useful until you add
// rules with gtk_file_filter_add_mime_type(), gtk_file_filter_add_pattern(), or
// gtk_file_filter_add_custom(). To create a filter that accepts any file, use:
//
//    GtkFileFilter *filter = gtk_file_filter_new ();
//    gtk_file_filter_add_pattern (filter, "*");
func NewFileFilter() FileFilter {
	var _cret *C.GtkFileFilter // in

	_cret = C.gtk_file_filter_new()

	var _fileFilter FileFilter // out

	_fileFilter = WrapFileFilter(externglib.Take(unsafe.Pointer(_cret)))

	return _fileFilter
}

// NewFileFilterFromGVariant: deserialize a file filter from an a{sv} variant in
// the format produced by gtk_file_filter_to_gvariant().
func NewFileFilterFromGVariant(variant *glib.Variant) FileFilter {
	var _arg1 *C.GVariant      // out
	var _cret *C.GtkFileFilter // in

	_arg1 = (*C.GVariant)(unsafe.Pointer(variant.Native()))

	_cret = C.gtk_file_filter_new_from_gvariant(_arg1)

	var _fileFilter FileFilter // out

	_fileFilter = WrapFileFilter(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _fileFilter
}

// AddMIMEType adds a rule allowing a given mime type to @filter.
func (f fileFilter) AddMIMEType(mimeType string) {
	var _arg0 *C.GtkFileFilter // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.gchar)(C.CString(mimeType))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_file_filter_add_mime_type(_arg0, _arg1)
}

// AddPattern adds a rule allowing a shell style glob to a filter.
func (f fileFilter) AddPattern(pattern string) {
	var _arg0 *C.GtkFileFilter // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.gchar)(C.CString(pattern))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_file_filter_add_pattern(_arg0, _arg1)
}

// AddPixbufFormats adds a rule allowing image files in the formats supported by
// GdkPixbuf.
func (f fileFilter) AddPixbufFormats() {
	var _arg0 *C.GtkFileFilter // out

	_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))

	C.gtk_file_filter_add_pixbuf_formats(_arg0)
}

// Filter tests whether a file should be displayed according to @filter. The
// FileFilterInfo @filter_info should include the fields returned from
// gtk_file_filter_get_needed().
//
// This function will not typically be used by applications; it is intended
// principally for use in the implementation of FileChooser.
func (f fileFilter) Filter(filterInfo *FileFilterInfo) bool {
	var _arg0 *C.GtkFileFilter     // out
	var _arg1 *C.GtkFileFilterInfo // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GtkFileFilterInfo)(unsafe.Pointer(filterInfo.Native()))

	_cret = C.gtk_file_filter_filter(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Name gets the human-readable name for the filter. See
// gtk_file_filter_set_name().
func (f fileFilter) Name() string {
	var _arg0 *C.GtkFileFilter // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_file_filter_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Needed gets the fields that need to be filled in for the FileFilterInfo
// passed to gtk_file_filter_filter()
//
// This function will not typically be used by applications; it is intended
// principally for use in the implementation of FileChooser.
func (f fileFilter) Needed() FileFilterFlags {
	var _arg0 *C.GtkFileFilter     // out
	var _cret C.GtkFileFilterFlags // in

	_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_file_filter_get_needed(_arg0)

	var _fileFilterFlags FileFilterFlags // out

	_fileFilterFlags = FileFilterFlags(_cret)

	return _fileFilterFlags
}

// SetName sets the human-readable name of the filter; this is the string that
// will be displayed in the file selector user interface if there is a
// selectable list of filters.
func (f fileFilter) SetName(name string) {
	var _arg0 *C.GtkFileFilter // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_file_filter_set_name(_arg0, _arg1)
}

// ToGVariant: serialize a file filter to an a{sv} variant.
func (f fileFilter) ToGVariant() *glib.Variant {
	var _arg0 *C.GtkFileFilter // out
	var _cret *C.GVariant      // in

	_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_file_filter_to_gvariant(_arg0)

	var _variant *glib.Variant // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// Fixed: the Fixed widget is a container which can place child widgets at fixed
// positions and with fixed sizes, given in pixels. Fixed performs no automatic
// layout management.
//
// For most applications, you should not use this container! It keeps you from
// having to learn about the other GTK+ containers, but it results in broken
// applications. With Fixed, the following things will result in truncated text,
// overlapping widgets, and other display bugs:
//
// - Themes, which may change widget sizes.
//
// - Fonts other than the one you used to write the app will of course change
// the size of widgets containing text; keep in mind that users may use a larger
// font because of difficulty reading the default, or they may be using a
// different OS that provides different fonts.
//
// - Translation of text into other languages changes its size. Also, display of
// non-English text will use a different font in many cases.
//
// In addition, Fixed does not pay attention to text direction and thus may
// produce unwanted results if your app is run under right-to-left languages
// such as Hebrew or Arabic. That is: normally GTK+ will order containers
// appropriately for the text direction, e.g. to put labels to the right of the
// thing they label when using an RTL language, but it can’t do that with Fixed.
// So if you need to reorder widgets depending on the text direction, you would
// need to manually detect it and adjust child positions accordingly.
//
// Finally, fixed positioning makes it kind of annoying to add/remove GUI
// elements, since you have to reposition all the other elements. This is a
// long-term maintenance problem for your application.
//
// If you know none of these things are an issue for your application, and
// prefer the simplicity of Fixed, by all means use the widget. But you should
// be aware of the tradeoffs.
//
// See also Layout, which shares the ability to perform fixed positioning of
// child widgets and additionally adds custom drawing and scrollability.
type Fixed interface {
	Container
	Buildable

	// Move moves a child of a Fixed container to the given position.
	Move(widget Widget, x int, y int)
	// Put adds a widget to a Fixed container at the given position.
	Put(widget Widget, x int, y int)
}

// fixed implements the Fixed class.
type fixed struct {
	Container
	Buildable
}

var _ Fixed = (*fixed)(nil)

// WrapFixed wraps a GObject to the right type. It is
// primarily used internally.
func WrapFixed(obj *externglib.Object) Fixed {
	return fixed{
		Container: WrapContainer(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalFixed(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFixed(obj), nil
}

// NewFixed creates a new Fixed.
func NewFixed() Fixed {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_fixed_new()

	var _fixed Fixed // out

	_fixed = WrapFixed(externglib.Take(unsafe.Pointer(_cret)))

	return _fixed
}

// Move moves a child of a Fixed container to the given position.
func (f fixed) Move(widget Widget, x int, y int) {
	var _arg0 *C.GtkFixed  // out
	var _arg1 *C.GtkWidget // out
	var _arg2 C.gint       // out
	var _arg3 C.gint       // out

	_arg0 = (*C.GtkFixed)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (C.gint)(x)
	_arg3 = (C.gint)(y)

	C.gtk_fixed_move(_arg0, _arg1, _arg2, _arg3)
}

// Put adds a widget to a Fixed container at the given position.
func (f fixed) Put(widget Widget, x int, y int) {
	var _arg0 *C.GtkFixed  // out
	var _arg1 *C.GtkWidget // out
	var _arg2 C.gint       // out
	var _arg3 C.gint       // out

	_arg0 = (*C.GtkFixed)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (C.gint)(x)
	_arg3 = (C.gint)(y)

	C.gtk_fixed_put(_arg0, _arg1, _arg2, _arg3)
}

// FlowBox: a GtkFlowBox positions child widgets in sequence according to its
// orientation.
//
// For instance, with the horizontal orientation, the widgets will be arranged
// from left to right, starting a new row under the previous row when necessary.
// Reducing the width in this case will require more rows, so a larger height
// will be requested.
//
// Likewise, with the vertical orientation, the widgets will be arranged from
// top to bottom, starting a new column to the right when necessary. Reducing
// the height will require more columns, so a larger width will be requested.
//
// The size request of a GtkFlowBox alone may not be what you expect; if you
// need to be able to shrink it along both axes and dynamically reflow its
// children, you may have to wrap it in a ScrolledWindow to enable that.
//
// The children of a GtkFlowBox can be dynamically sorted and filtered.
//
// Although a GtkFlowBox must have only FlowBoxChild children, you can add any
// kind of widget to it via gtk_container_add(), and a GtkFlowBoxChild widget
// will automatically be inserted between the box and the widget.
//
// Also see ListBox.
//
// GtkFlowBox was added in GTK+ 3.12.
//
// CSS nodes
//
//    flowbox
//    ├── flowboxchild
//    │   ╰── <child>
//    ├── flowboxchild
//    │   ╰── <child>
//    ┊
//    ╰── [rubberband]
//
// GtkFlowBox uses a single CSS node with name flowbox. GtkFlowBoxChild uses a
// single CSS node with name flowboxchild. For rubberband selection, a subnode
// with name rubberband is used.
type FlowBox interface {
	Container
	Buildable
	Orientable

	// ActivateOnSingleClick returns whether children activate on single clicks.
	ActivateOnSingleClick() bool
	// ChildAtIndex gets the nth child in the @box.
	ChildAtIndex(idx int) FlowBoxChild
	// ChildAtPos gets the child in the (@x, @y) position.
	ChildAtPos(x int, y int) FlowBoxChild
	// ColumnSpacing gets the horizontal spacing.
	ColumnSpacing() uint
	// Homogeneous returns whether the box is homogeneous (all children are the
	// same size). See gtk_box_set_homogeneous().
	Homogeneous() bool
	// MaxChildrenPerLine gets the maximum number of children per line.
	MaxChildrenPerLine() uint
	// MinChildrenPerLine gets the minimum number of children per line.
	MinChildrenPerLine() uint
	// RowSpacing gets the vertical spacing.
	RowSpacing() uint
	// SelectionMode gets the selection mode of @box.
	SelectionMode() SelectionMode
	// Insert inserts the @widget into @box at @position.
	//
	// If a sort function is set, the widget will actually be inserted at the
	// calculated position and this function has the same effect as
	// gtk_container_add().
	//
	// If @position is -1, or larger than the total number of children in the
	// @box, then the @widget will be appended to the end.
	Insert(widget Widget, position int)
	// InvalidateFilter updates the filtering for all children.
	//
	// Call this function when the result of the filter function on the @box is
	// changed due ot an external factor. For instance, this would be used if
	// the filter function just looked for a specific search term, and the entry
	// with the string has changed.
	InvalidateFilter()
	// InvalidateSort updates the sorting for all children.
	//
	// Call this when the result of the sort function on @box is changed due to
	// an external factor.
	InvalidateSort()
	// SelectAll: select all children of @box, if the selection mode allows it.
	SelectAll()
	// SelectChild selects a single child of @box, if the selection mode allows
	// it.
	SelectChild(child FlowBoxChild)
	// SetActivateOnSingleClick: if @single is true, children will be activated
	// when you click on them, otherwise you need to double-click.
	SetActivateOnSingleClick(single bool)
	// SetColumnSpacing sets the horizontal space to add between children. See
	// the FlowBox:column-spacing property.
	SetColumnSpacing(spacing uint)
	// SetHAdjustment hooks up an adjustment to focus handling in @box. The
	// adjustment is also used for autoscrolling during rubberband selection.
	// See gtk_scrolled_window_get_hadjustment() for a typical way of obtaining
	// the adjustment, and gtk_flow_box_set_vadjustment()for setting the
	// vertical adjustment.
	//
	// The adjustments have to be in pixel units and in the same coordinate
	// system as the allocation for immediate children of the box.
	SetHAdjustment(adjustment Adjustment)
	// SetHomogeneous sets the FlowBox:homogeneous property of @box, controlling
	// whether or not all children of @box are given equal space in the box.
	SetHomogeneous(homogeneous bool)
	// SetMaxChildrenPerLine sets the maximum number of children to request and
	// allocate space for in @box’s orientation.
	//
	// Setting the maximum number of children per line limits the overall
	// natural size request to be no more than @n_children children long in the
	// given orientation.
	SetMaxChildrenPerLine(nChildren uint)
	// SetMinChildrenPerLine sets the minimum number of children to line up in
	// @box’s orientation before flowing.
	SetMinChildrenPerLine(nChildren uint)
	// SetRowSpacing sets the vertical space to add between children. See the
	// FlowBox:row-spacing property.
	SetRowSpacing(spacing uint)
	// SetSelectionMode sets how selection works in @box. See SelectionMode for
	// details.
	SetSelectionMode(mode SelectionMode)
	// SetVAdjustment hooks up an adjustment to focus handling in @box. The
	// adjustment is also used for autoscrolling during rubberband selection.
	// See gtk_scrolled_window_get_vadjustment() for a typical way of obtaining
	// the adjustment, and gtk_flow_box_set_hadjustment()for setting the
	// horizontal adjustment.
	//
	// The adjustments have to be in pixel units and in the same coordinate
	// system as the allocation for immediate children of the box.
	SetVAdjustment(adjustment Adjustment)
	// UnselectAll: unselect all children of @box, if the selection mode allows
	// it.
	UnselectAll()
	// UnselectChild unselects a single child of @box, if the selection mode
	// allows it.
	UnselectChild(child FlowBoxChild)
}

// flowBox implements the FlowBox class.
type flowBox struct {
	Container
	Buildable
	Orientable
}

var _ FlowBox = (*flowBox)(nil)

// WrapFlowBox wraps a GObject to the right type. It is
// primarily used internally.
func WrapFlowBox(obj *externglib.Object) FlowBox {
	return flowBox{
		Container:  WrapContainer(obj),
		Buildable:  WrapBuildable(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalFlowBox(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFlowBox(obj), nil
}

// NewFlowBox creates a GtkFlowBox.
func NewFlowBox() FlowBox {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_flow_box_new()

	var _flowBox FlowBox // out

	_flowBox = WrapFlowBox(externglib.Take(unsafe.Pointer(_cret)))

	return _flowBox
}

// ActivateOnSingleClick returns whether children activate on single clicks.
func (b flowBox) ActivateOnSingleClick() bool {
	var _arg0 *C.GtkFlowBox // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_flow_box_get_activate_on_single_click(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ChildAtIndex gets the nth child in the @box.
func (b flowBox) ChildAtIndex(idx int) FlowBoxChild {
	var _arg0 *C.GtkFlowBox      // out
	var _arg1 C.gint             // out
	var _cret *C.GtkFlowBoxChild // in

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	_arg1 = (C.gint)(idx)

	_cret = C.gtk_flow_box_get_child_at_index(_arg0, _arg1)

	var _flowBoxChild FlowBoxChild // out

	_flowBoxChild = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(FlowBoxChild)

	return _flowBoxChild
}

// ChildAtPos gets the child in the (@x, @y) position.
func (b flowBox) ChildAtPos(x int, y int) FlowBoxChild {
	var _arg0 *C.GtkFlowBox      // out
	var _arg1 C.gint             // out
	var _arg2 C.gint             // out
	var _cret *C.GtkFlowBoxChild // in

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	_arg1 = (C.gint)(x)
	_arg2 = (C.gint)(y)

	_cret = C.gtk_flow_box_get_child_at_pos(_arg0, _arg1, _arg2)

	var _flowBoxChild FlowBoxChild // out

	_flowBoxChild = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(FlowBoxChild)

	return _flowBoxChild
}

// ColumnSpacing gets the horizontal spacing.
func (b flowBox) ColumnSpacing() uint {
	var _arg0 *C.GtkFlowBox // out
	var _cret C.guint       // in

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_flow_box_get_column_spacing(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// Homogeneous returns whether the box is homogeneous (all children are the same
// size). See gtk_box_set_homogeneous().
func (b flowBox) Homogeneous() bool {
	var _arg0 *C.GtkFlowBox // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_flow_box_get_homogeneous(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MaxChildrenPerLine gets the maximum number of children per line.
func (b flowBox) MaxChildrenPerLine() uint {
	var _arg0 *C.GtkFlowBox // out
	var _cret C.guint       // in

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_flow_box_get_max_children_per_line(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// MinChildrenPerLine gets the minimum number of children per line.
func (b flowBox) MinChildrenPerLine() uint {
	var _arg0 *C.GtkFlowBox // out
	var _cret C.guint       // in

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_flow_box_get_min_children_per_line(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// RowSpacing gets the vertical spacing.
func (b flowBox) RowSpacing() uint {
	var _arg0 *C.GtkFlowBox // out
	var _cret C.guint       // in

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_flow_box_get_row_spacing(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// SelectionMode gets the selection mode of @box.
func (b flowBox) SelectionMode() SelectionMode {
	var _arg0 *C.GtkFlowBox      // out
	var _cret C.GtkSelectionMode // in

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_flow_box_get_selection_mode(_arg0)

	var _selectionMode SelectionMode // out

	_selectionMode = SelectionMode(_cret)

	return _selectionMode
}

// Insert inserts the @widget into @box at @position.
//
// If a sort function is set, the widget will actually be inserted at the
// calculated position and this function has the same effect as
// gtk_container_add().
//
// If @position is -1, or larger than the total number of children in the @box,
// then the @widget will be appended to the end.
func (b flowBox) Insert(widget Widget, position int) {
	var _arg0 *C.GtkFlowBox // out
	var _arg1 *C.GtkWidget  // out
	var _arg2 C.gint        // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (C.gint)(position)

	C.gtk_flow_box_insert(_arg0, _arg1, _arg2)
}

// InvalidateFilter updates the filtering for all children.
//
// Call this function when the result of the filter function on the @box is
// changed due ot an external factor. For instance, this would be used if the
// filter function just looked for a specific search term, and the entry with
// the string has changed.
func (b flowBox) InvalidateFilter() {
	var _arg0 *C.GtkFlowBox // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	C.gtk_flow_box_invalidate_filter(_arg0)
}

// InvalidateSort updates the sorting for all children.
//
// Call this when the result of the sort function on @box is changed due to an
// external factor.
func (b flowBox) InvalidateSort() {
	var _arg0 *C.GtkFlowBox // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	C.gtk_flow_box_invalidate_sort(_arg0)
}

// SelectAll: select all children of @box, if the selection mode allows it.
func (b flowBox) SelectAll() {
	var _arg0 *C.GtkFlowBox // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	C.gtk_flow_box_select_all(_arg0)
}

// SelectChild selects a single child of @box, if the selection mode allows it.
func (b flowBox) SelectChild(child FlowBoxChild) {
	var _arg0 *C.GtkFlowBox      // out
	var _arg1 *C.GtkFlowBoxChild // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkFlowBoxChild)(unsafe.Pointer(child.Native()))

	C.gtk_flow_box_select_child(_arg0, _arg1)
}

// SetActivateOnSingleClick: if @single is true, children will be activated when
// you click on them, otherwise you need to double-click.
func (b flowBox) SetActivateOnSingleClick(single bool) {
	var _arg0 *C.GtkFlowBox // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	if single {
		_arg1 = C.TRUE
	}

	C.gtk_flow_box_set_activate_on_single_click(_arg0, _arg1)
}

// SetColumnSpacing sets the horizontal space to add between children. See the
// FlowBox:column-spacing property.
func (b flowBox) SetColumnSpacing(spacing uint) {
	var _arg0 *C.GtkFlowBox // out
	var _arg1 C.guint       // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	_arg1 = (C.guint)(spacing)

	C.gtk_flow_box_set_column_spacing(_arg0, _arg1)
}

// SetHAdjustment hooks up an adjustment to focus handling in @box. The
// adjustment is also used for autoscrolling during rubberband selection. See
// gtk_scrolled_window_get_hadjustment() for a typical way of obtaining the
// adjustment, and gtk_flow_box_set_vadjustment()for setting the vertical
// adjustment.
//
// The adjustments have to be in pixel units and in the same coordinate system
// as the allocation for immediate children of the box.
func (b flowBox) SetHAdjustment(adjustment Adjustment) {
	var _arg0 *C.GtkFlowBox    // out
	var _arg1 *C.GtkAdjustment // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	C.gtk_flow_box_set_hadjustment(_arg0, _arg1)
}

// SetHomogeneous sets the FlowBox:homogeneous property of @box, controlling
// whether or not all children of @box are given equal space in the box.
func (b flowBox) SetHomogeneous(homogeneous bool) {
	var _arg0 *C.GtkFlowBox // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	if homogeneous {
		_arg1 = C.TRUE
	}

	C.gtk_flow_box_set_homogeneous(_arg0, _arg1)
}

// SetMaxChildrenPerLine sets the maximum number of children to request and
// allocate space for in @box’s orientation.
//
// Setting the maximum number of children per line limits the overall natural
// size request to be no more than @n_children children long in the given
// orientation.
func (b flowBox) SetMaxChildrenPerLine(nChildren uint) {
	var _arg0 *C.GtkFlowBox // out
	var _arg1 C.guint       // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	_arg1 = (C.guint)(nChildren)

	C.gtk_flow_box_set_max_children_per_line(_arg0, _arg1)
}

// SetMinChildrenPerLine sets the minimum number of children to line up in
// @box’s orientation before flowing.
func (b flowBox) SetMinChildrenPerLine(nChildren uint) {
	var _arg0 *C.GtkFlowBox // out
	var _arg1 C.guint       // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	_arg1 = (C.guint)(nChildren)

	C.gtk_flow_box_set_min_children_per_line(_arg0, _arg1)
}

// SetRowSpacing sets the vertical space to add between children. See the
// FlowBox:row-spacing property.
func (b flowBox) SetRowSpacing(spacing uint) {
	var _arg0 *C.GtkFlowBox // out
	var _arg1 C.guint       // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	_arg1 = (C.guint)(spacing)

	C.gtk_flow_box_set_row_spacing(_arg0, _arg1)
}

// SetSelectionMode sets how selection works in @box. See SelectionMode for
// details.
func (b flowBox) SetSelectionMode(mode SelectionMode) {
	var _arg0 *C.GtkFlowBox      // out
	var _arg1 C.GtkSelectionMode // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	_arg1 = (C.GtkSelectionMode)(mode)

	C.gtk_flow_box_set_selection_mode(_arg0, _arg1)
}

// SetVAdjustment hooks up an adjustment to focus handling in @box. The
// adjustment is also used for autoscrolling during rubberband selection. See
// gtk_scrolled_window_get_vadjustment() for a typical way of obtaining the
// adjustment, and gtk_flow_box_set_hadjustment()for setting the horizontal
// adjustment.
//
// The adjustments have to be in pixel units and in the same coordinate system
// as the allocation for immediate children of the box.
func (b flowBox) SetVAdjustment(adjustment Adjustment) {
	var _arg0 *C.GtkFlowBox    // out
	var _arg1 *C.GtkAdjustment // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	C.gtk_flow_box_set_vadjustment(_arg0, _arg1)
}

// UnselectAll: unselect all children of @box, if the selection mode allows it.
func (b flowBox) UnselectAll() {
	var _arg0 *C.GtkFlowBox // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	C.gtk_flow_box_unselect_all(_arg0)
}

// UnselectChild unselects a single child of @box, if the selection mode allows
// it.
func (b flowBox) UnselectChild(child FlowBoxChild) {
	var _arg0 *C.GtkFlowBox      // out
	var _arg1 *C.GtkFlowBoxChild // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkFlowBoxChild)(unsafe.Pointer(child.Native()))

	C.gtk_flow_box_unselect_child(_arg0, _arg1)
}

type FlowBoxAccessible interface {
	ContainerAccessible
}

// flowBoxAccessible implements the FlowBoxAccessible class.
type flowBoxAccessible struct {
	ContainerAccessible
}

var _ FlowBoxAccessible = (*flowBoxAccessible)(nil)

// WrapFlowBoxAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapFlowBoxAccessible(obj *externglib.Object) FlowBoxAccessible {
	return flowBoxAccessible{
		ContainerAccessible: WrapContainerAccessible(obj),
	}
}

func marshalFlowBoxAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFlowBoxAccessible(obj), nil
}

type FlowBoxChild interface {
	Bin
	Buildable

	// Changed marks @child as changed, causing any state that depends on this
	// to be updated. This affects sorting and filtering.
	//
	// Note that calls to this method must be in sync with the data used for the
	// sorting and filtering functions. For instance, if the list is mirroring
	// some external data set, and *two* children changed in the external data
	// set when you call gtk_flow_box_child_changed() on the first child, the
	// sort function must only read the new data for the first of the two
	// changed children, otherwise the resorting of the children will be wrong.
	//
	// This generally means that if you don’t fully control the data model, you
	// have to duplicate the data that affects the sorting and filtering
	// functions into the widgets themselves. Another alternative is to call
	// gtk_flow_box_invalidate_sort() on any model change, but that is more
	// expensive.
	Changed()
	// Index gets the current index of the @child in its FlowBox container.
	Index() int
	// IsSelected returns whether the @child is currently selected in its
	// FlowBox container.
	IsSelected() bool
}

// flowBoxChild implements the FlowBoxChild class.
type flowBoxChild struct {
	Bin
	Buildable
}

var _ FlowBoxChild = (*flowBoxChild)(nil)

// WrapFlowBoxChild wraps a GObject to the right type. It is
// primarily used internally.
func WrapFlowBoxChild(obj *externglib.Object) FlowBoxChild {
	return flowBoxChild{
		Bin:       WrapBin(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalFlowBoxChild(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFlowBoxChild(obj), nil
}

// NewFlowBoxChild creates a new FlowBoxChild, to be used as a child of a
// FlowBox.
func NewFlowBoxChild() FlowBoxChild {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_flow_box_child_new()

	var _flowBoxChild FlowBoxChild // out

	_flowBoxChild = WrapFlowBoxChild(externglib.Take(unsafe.Pointer(_cret)))

	return _flowBoxChild
}

// Changed marks @child as changed, causing any state that depends on this to be
// updated. This affects sorting and filtering.
//
// Note that calls to this method must be in sync with the data used for the
// sorting and filtering functions. For instance, if the list is mirroring some
// external data set, and *two* children changed in the external data set when
// you call gtk_flow_box_child_changed() on the first child, the sort function
// must only read the new data for the first of the two changed children,
// otherwise the resorting of the children will be wrong.
//
// This generally means that if you don’t fully control the data model, you have
// to duplicate the data that affects the sorting and filtering functions into
// the widgets themselves. Another alternative is to call
// gtk_flow_box_invalidate_sort() on any model change, but that is more
// expensive.
func (c flowBoxChild) Changed() {
	var _arg0 *C.GtkFlowBoxChild // out

	_arg0 = (*C.GtkFlowBoxChild)(unsafe.Pointer(c.Native()))

	C.gtk_flow_box_child_changed(_arg0)
}

// Index gets the current index of the @child in its FlowBox container.
func (c flowBoxChild) Index() int {
	var _arg0 *C.GtkFlowBoxChild // out
	var _cret C.gint             // in

	_arg0 = (*C.GtkFlowBoxChild)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_flow_box_child_get_index(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// IsSelected returns whether the @child is currently selected in its FlowBox
// container.
func (c flowBoxChild) IsSelected() bool {
	var _arg0 *C.GtkFlowBoxChild // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkFlowBoxChild)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_flow_box_child_is_selected(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

type FlowBoxChildAccessible interface {
	ContainerAccessible
}

// flowBoxChildAccessible implements the FlowBoxChildAccessible class.
type flowBoxChildAccessible struct {
	ContainerAccessible
}

var _ FlowBoxChildAccessible = (*flowBoxChildAccessible)(nil)

// WrapFlowBoxChildAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapFlowBoxChildAccessible(obj *externglib.Object) FlowBoxChildAccessible {
	return flowBoxChildAccessible{
		ContainerAccessible: WrapContainerAccessible(obj),
	}
}

func marshalFlowBoxChildAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFlowBoxChildAccessible(obj), nil
}

// FontButton: the FontButton is a button which displays the currently selected
// font an allows to open a font chooser dialog to change the font. It is
// suitable widget for selecting a font in a preference dialog.
//
//
// CSS nodes
//
// GtkFontButton has a single CSS node with name button and style class .font.
type FontButton interface {
	Button
	Actionable
	Activatable
	Buildable
	FontChooser

	// FontName retrieves the name of the currently selected font. This name
	// includes style and size information as well. If you want to render
	// something with the font, use this string with
	// pango_font_description_from_string() . If you’re interested in peeking
	// certain values (family name, style, size, weight) just query these
	// properties from the FontDescription object.
	FontName() string
	// ShowSize returns whether the font size will be shown in the label.
	ShowSize() bool
	// ShowStyle returns whether the name of the font style will be shown in the
	// label.
	ShowStyle() bool
	// Title retrieves the title of the font chooser dialog.
	Title() string
	// UseFont returns whether the selected font is used in the label.
	UseFont() bool
	// UseSize returns whether the selected size is used in the label.
	UseSize() bool
	// SetFontName sets or updates the currently-displayed font in font picker
	// dialog.
	SetFontName(fontname string) bool
	// SetShowSize: if @show_size is true, the font size will be displayed along
	// with the name of the selected font.
	SetShowSize(showSize bool)
	// SetShowStyle: if @show_style is true, the font style will be displayed
	// along with name of the selected font.
	SetShowStyle(showStyle bool)
	// SetTitle sets the title for the font chooser dialog.
	SetTitle(title string)
	// SetUseFont: if @use_font is true, the font name will be written using the
	// selected font.
	SetUseFont(useFont bool)
	// SetUseSize: if @use_size is true, the font name will be written using the
	// selected size.
	SetUseSize(useSize bool)
}

// fontButton implements the FontButton class.
type fontButton struct {
	Button
	Actionable
	Activatable
	Buildable
	FontChooser
}

var _ FontButton = (*fontButton)(nil)

// WrapFontButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapFontButton(obj *externglib.Object) FontButton {
	return fontButton{
		Button:      WrapButton(obj),
		Actionable:  WrapActionable(obj),
		Activatable: WrapActivatable(obj),
		Buildable:   WrapBuildable(obj),
		FontChooser: WrapFontChooser(obj),
	}
}

func marshalFontButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFontButton(obj), nil
}

// NewFontButton creates a new font picker widget.
func NewFontButton() FontButton {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_font_button_new()

	var _fontButton FontButton // out

	_fontButton = WrapFontButton(externglib.Take(unsafe.Pointer(_cret)))

	return _fontButton
}

// NewFontButtonWithFont creates a new font picker widget.
func NewFontButtonWithFont(fontname string) FontButton {
	var _arg1 *C.gchar     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.gchar)(C.CString(fontname))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_font_button_new_with_font(_arg1)

	var _fontButton FontButton // out

	_fontButton = WrapFontButton(externglib.Take(unsafe.Pointer(_cret)))

	return _fontButton
}

// FontName retrieves the name of the currently selected font. This name
// includes style and size information as well. If you want to render something
// with the font, use this string with pango_font_description_from_string() . If
// you’re interested in peeking certain values (family name, style, size,
// weight) just query these properties from the FontDescription object.
func (f fontButton) FontName() string {
	var _arg0 *C.GtkFontButton // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_button_get_font_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// ShowSize returns whether the font size will be shown in the label.
func (f fontButton) ShowSize() bool {
	var _arg0 *C.GtkFontButton // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_button_get_show_size(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowStyle returns whether the name of the font style will be shown in the
// label.
func (f fontButton) ShowStyle() bool {
	var _arg0 *C.GtkFontButton // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_button_get_show_style(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Title retrieves the title of the font chooser dialog.
func (f fontButton) Title() string {
	var _arg0 *C.GtkFontButton // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_button_get_title(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// UseFont returns whether the selected font is used in the label.
func (f fontButton) UseFont() bool {
	var _arg0 *C.GtkFontButton // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_button_get_use_font(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UseSize returns whether the selected size is used in the label.
func (f fontButton) UseSize() bool {
	var _arg0 *C.GtkFontButton // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_button_get_use_size(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetFontName sets or updates the currently-displayed font in font picker
// dialog.
func (f fontButton) SetFontName(fontname string) bool {
	var _arg0 *C.GtkFontButton // out
	var _arg1 *C.gchar         // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.gchar)(C.CString(fontname))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_font_button_set_font_name(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetShowSize: if @show_size is true, the font size will be displayed along
// with the name of the selected font.
func (f fontButton) SetShowSize(showSize bool) {
	var _arg0 *C.GtkFontButton // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))
	if showSize {
		_arg1 = C.TRUE
	}

	C.gtk_font_button_set_show_size(_arg0, _arg1)
}

// SetShowStyle: if @show_style is true, the font style will be displayed along
// with name of the selected font.
func (f fontButton) SetShowStyle(showStyle bool) {
	var _arg0 *C.GtkFontButton // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))
	if showStyle {
		_arg1 = C.TRUE
	}

	C.gtk_font_button_set_show_style(_arg0, _arg1)
}

// SetTitle sets the title for the font chooser dialog.
func (f fontButton) SetTitle(title string) {
	var _arg0 *C.GtkFontButton // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_font_button_set_title(_arg0, _arg1)
}

// SetUseFont: if @use_font is true, the font name will be written using the
// selected font.
func (f fontButton) SetUseFont(useFont bool) {
	var _arg0 *C.GtkFontButton // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))
	if useFont {
		_arg1 = C.TRUE
	}

	C.gtk_font_button_set_use_font(_arg0, _arg1)
}

// SetUseSize: if @use_size is true, the font name will be written using the
// selected size.
func (f fontButton) SetUseSize(useSize bool) {
	var _arg0 *C.GtkFontButton // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))
	if useSize {
		_arg1 = C.TRUE
	}

	C.gtk_font_button_set_use_size(_arg0, _arg1)
}

// FontChooserDialog: the FontChooserDialog widget is a dialog for selecting a
// font. It implements the FontChooser interface.
//
//
// GtkFontChooserDialog as GtkBuildable
//
// The GtkFontChooserDialog implementation of the Buildable interface exposes
// the buttons with the names “select_button” and “cancel_button”.
type FontChooserDialog interface {
	Dialog
	Buildable
	FontChooser
}

// fontChooserDialog implements the FontChooserDialog class.
type fontChooserDialog struct {
	Dialog
	Buildable
	FontChooser
}

var _ FontChooserDialog = (*fontChooserDialog)(nil)

// WrapFontChooserDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapFontChooserDialog(obj *externglib.Object) FontChooserDialog {
	return fontChooserDialog{
		Dialog:      WrapDialog(obj),
		Buildable:   WrapBuildable(obj),
		FontChooser: WrapFontChooser(obj),
	}
}

func marshalFontChooserDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFontChooserDialog(obj), nil
}

// NewFontChooserDialog creates a new FontChooserDialog.
func NewFontChooserDialog(title string, parent Window) FontChooserDialog {
	var _arg1 *C.gchar     // out
	var _arg2 *C.GtkWindow // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))

	_cret = C.gtk_font_chooser_dialog_new(_arg1, _arg2)

	var _fontChooserDialog FontChooserDialog // out

	_fontChooserDialog = WrapFontChooserDialog(externglib.Take(unsafe.Pointer(_cret)))

	return _fontChooserDialog
}

// FontChooserWidget: the FontChooserWidget widget lists the available fonts,
// styles and sizes, allowing the user to select a font. It is used in the
// FontChooserDialog widget to provide a dialog box for selecting fonts.
//
// To set the font which is initially selected, use gtk_font_chooser_set_font()
// or gtk_font_chooser_set_font_desc().
//
// To get the selected font use gtk_font_chooser_get_font() or
// gtk_font_chooser_get_font_desc().
//
// To change the text which is shown in the preview area, use
// gtk_font_chooser_set_preview_text().
//
//
// CSS nodes
//
// GtkFontChooserWidget has a single CSS node with name fontchooser.
type FontChooserWidget interface {
	Box
	Buildable
	FontChooser
	Orientable
}

// fontChooserWidget implements the FontChooserWidget class.
type fontChooserWidget struct {
	Box
	Buildable
	FontChooser
	Orientable
}

var _ FontChooserWidget = (*fontChooserWidget)(nil)

// WrapFontChooserWidget wraps a GObject to the right type. It is
// primarily used internally.
func WrapFontChooserWidget(obj *externglib.Object) FontChooserWidget {
	return fontChooserWidget{
		Box:         WrapBox(obj),
		Buildable:   WrapBuildable(obj),
		FontChooser: WrapFontChooser(obj),
		Orientable:  WrapOrientable(obj),
	}
}

func marshalFontChooserWidget(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFontChooserWidget(obj), nil
}

// NewFontChooserWidget creates a new FontChooserWidget.
func NewFontChooserWidget() FontChooserWidget {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_font_chooser_widget_new()

	var _fontChooserWidget FontChooserWidget // out

	_fontChooserWidget = WrapFontChooserWidget(externglib.Take(unsafe.Pointer(_cret)))

	return _fontChooserWidget
}

type FontSelection interface {
	Box
	Buildable
	Orientable

	// Face gets the FontFace representing the selected font group details (i.e.
	// family, slant, weight, width, etc).
	Face() pango.FontFace
	// FaceList: this returns the TreeView which lists all styles available for
	// the selected font. For example, “Regular”, “Bold”, etc.
	FaceList() Widget
	// Family gets the FontFamily representing the selected font family.
	Family() pango.FontFamily
	// FamilyList: this returns the TreeView that lists font families, for
	// example, “Sans”, “Serif”, etc.
	FamilyList() Widget
	// FontName gets the currently-selected font name.
	//
	// Note that this can be a different string than what you set with
	// gtk_font_selection_set_font_name(), as the font selection widget may
	// normalize font names and thus return a string with a different structure.
	// For example, “Helvetica Italic Bold 12” could be normalized to “Helvetica
	// Bold Italic 12”. Use pango_font_description_equal() if you want to
	// compare two font descriptions.
	FontName() string
	// PreviewEntry: this returns the Entry used to display the font as a
	// preview.
	PreviewEntry() Widget
	// PreviewText gets the text displayed in the preview area.
	PreviewText() string
	// Size: the selected font size.
	Size() int
	// SizeEntry: this returns the Entry used to allow the user to edit the font
	// number manually instead of selecting it from the list of font sizes.
	SizeEntry() Widget
	// SizeList: this returns the TreeView used to list font sizes.
	SizeList() Widget
	// SetFontName sets the currently-selected font.
	//
	// Note that the @fontsel needs to know the screen in which it will appear
	// for this to work; this can be guaranteed by simply making sure that the
	// @fontsel is inserted in a toplevel window before you call this function.
	SetFontName(fontname string) bool
	// SetPreviewText sets the text displayed in the preview area. The @text is
	// used to show how the selected font looks.
	SetPreviewText(text string)
}

// fontSelection implements the FontSelection class.
type fontSelection struct {
	Box
	Buildable
	Orientable
}

var _ FontSelection = (*fontSelection)(nil)

// WrapFontSelection wraps a GObject to the right type. It is
// primarily used internally.
func WrapFontSelection(obj *externglib.Object) FontSelection {
	return fontSelection{
		Box:        WrapBox(obj),
		Buildable:  WrapBuildable(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalFontSelection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFontSelection(obj), nil
}

// NewFontSelection creates a new FontSelection.
func NewFontSelection() FontSelection {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_font_selection_new()

	var _fontSelection FontSelection // out

	_fontSelection = WrapFontSelection(externglib.Take(unsafe.Pointer(_cret)))

	return _fontSelection
}

// Face gets the FontFace representing the selected font group details (i.e.
// family, slant, weight, width, etc).
func (f fontSelection) Face() pango.FontFace {
	var _arg0 *C.GtkFontSelection // out
	var _cret *C.PangoFontFace    // in

	_arg0 = (*C.GtkFontSelection)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_selection_get_face(_arg0)

	var _fontFace pango.FontFace // out

	_fontFace = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(pango.FontFace)

	return _fontFace
}

// FaceList: this returns the TreeView which lists all styles available for the
// selected font. For example, “Regular”, “Bold”, etc.
func (f fontSelection) FaceList() Widget {
	var _arg0 *C.GtkFontSelection // out
	var _cret *C.GtkWidget        // in

	_arg0 = (*C.GtkFontSelection)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_selection_get_face_list(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// Family gets the FontFamily representing the selected font family.
func (f fontSelection) Family() pango.FontFamily {
	var _arg0 *C.GtkFontSelection // out
	var _cret *C.PangoFontFamily  // in

	_arg0 = (*C.GtkFontSelection)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_selection_get_family(_arg0)

	var _fontFamily pango.FontFamily // out

	_fontFamily = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(pango.FontFamily)

	return _fontFamily
}

// FamilyList: this returns the TreeView that lists font families, for example,
// “Sans”, “Serif”, etc.
func (f fontSelection) FamilyList() Widget {
	var _arg0 *C.GtkFontSelection // out
	var _cret *C.GtkWidget        // in

	_arg0 = (*C.GtkFontSelection)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_selection_get_family_list(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// FontName gets the currently-selected font name.
//
// Note that this can be a different string than what you set with
// gtk_font_selection_set_font_name(), as the font selection widget may
// normalize font names and thus return a string with a different structure. For
// example, “Helvetica Italic Bold 12” could be normalized to “Helvetica Bold
// Italic 12”. Use pango_font_description_equal() if you want to compare two
// font descriptions.
func (f fontSelection) FontName() string {
	var _arg0 *C.GtkFontSelection // out
	var _cret *C.gchar            // in

	_arg0 = (*C.GtkFontSelection)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_selection_get_font_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// PreviewEntry: this returns the Entry used to display the font as a preview.
func (f fontSelection) PreviewEntry() Widget {
	var _arg0 *C.GtkFontSelection // out
	var _cret *C.GtkWidget        // in

	_arg0 = (*C.GtkFontSelection)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_selection_get_preview_entry(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// PreviewText gets the text displayed in the preview area.
func (f fontSelection) PreviewText() string {
	var _arg0 *C.GtkFontSelection // out
	var _cret *C.gchar            // in

	_arg0 = (*C.GtkFontSelection)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_selection_get_preview_text(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Size: the selected font size.
func (f fontSelection) Size() int {
	var _arg0 *C.GtkFontSelection // out
	var _cret C.gint              // in

	_arg0 = (*C.GtkFontSelection)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_selection_get_size(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// SizeEntry: this returns the Entry used to allow the user to edit the font
// number manually instead of selecting it from the list of font sizes.
func (f fontSelection) SizeEntry() Widget {
	var _arg0 *C.GtkFontSelection // out
	var _cret *C.GtkWidget        // in

	_arg0 = (*C.GtkFontSelection)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_selection_get_size_entry(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// SizeList: this returns the TreeView used to list font sizes.
func (f fontSelection) SizeList() Widget {
	var _arg0 *C.GtkFontSelection // out
	var _cret *C.GtkWidget        // in

	_arg0 = (*C.GtkFontSelection)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_selection_get_size_list(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// SetFontName sets the currently-selected font.
//
// Note that the @fontsel needs to know the screen in which it will appear for
// this to work; this can be guaranteed by simply making sure that the @fontsel
// is inserted in a toplevel window before you call this function.
func (f fontSelection) SetFontName(fontname string) bool {
	var _arg0 *C.GtkFontSelection // out
	var _arg1 *C.gchar            // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkFontSelection)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.gchar)(C.CString(fontname))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_font_selection_set_font_name(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetPreviewText sets the text displayed in the preview area. The @text is used
// to show how the selected font looks.
func (f fontSelection) SetPreviewText(text string) {
	var _arg0 *C.GtkFontSelection // out
	var _arg1 *C.gchar            // out

	_arg0 = (*C.GtkFontSelection)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_font_selection_set_preview_text(_arg0, _arg1)
}

type FontSelectionDialog interface {
	Dialog
	Buildable

	// CancelButton gets the “Cancel” button.
	CancelButton() Widget
	// FontName gets the currently-selected font name.
	//
	// Note that this can be a different string than what you set with
	// gtk_font_selection_dialog_set_font_name(), as the font selection widget
	// may normalize font names and thus return a string with a different
	// structure. For example, “Helvetica Italic Bold 12” could be normalized to
	// “Helvetica Bold Italic 12”. Use pango_font_description_equal() if you
	// want to compare two font descriptions.
	FontName() string
	// FontSelection retrieves the FontSelection widget embedded in the dialog.
	FontSelection() Widget
	// OkButton gets the “OK” button.
	OkButton() Widget
	// PreviewText gets the text displayed in the preview area.
	PreviewText() string
	// SetFontName sets the currently selected font.
	SetFontName(fontname string) bool
	// SetPreviewText sets the text displayed in the preview area.
	SetPreviewText(text string)
}

// fontSelectionDialog implements the FontSelectionDialog class.
type fontSelectionDialog struct {
	Dialog
	Buildable
}

var _ FontSelectionDialog = (*fontSelectionDialog)(nil)

// WrapFontSelectionDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapFontSelectionDialog(obj *externglib.Object) FontSelectionDialog {
	return fontSelectionDialog{
		Dialog:    WrapDialog(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalFontSelectionDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFontSelectionDialog(obj), nil
}

// NewFontSelectionDialog creates a new FontSelectionDialog.
func NewFontSelectionDialog(title string) FontSelectionDialog {
	var _arg1 *C.gchar     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_font_selection_dialog_new(_arg1)

	var _fontSelectionDialog FontSelectionDialog // out

	_fontSelectionDialog = WrapFontSelectionDialog(externglib.Take(unsafe.Pointer(_cret)))

	return _fontSelectionDialog
}

// CancelButton gets the “Cancel” button.
func (f fontSelectionDialog) CancelButton() Widget {
	var _arg0 *C.GtkFontSelectionDialog // out
	var _cret *C.GtkWidget              // in

	_arg0 = (*C.GtkFontSelectionDialog)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_selection_dialog_get_cancel_button(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// FontName gets the currently-selected font name.
//
// Note that this can be a different string than what you set with
// gtk_font_selection_dialog_set_font_name(), as the font selection widget may
// normalize font names and thus return a string with a different structure. For
// example, “Helvetica Italic Bold 12” could be normalized to “Helvetica Bold
// Italic 12”. Use pango_font_description_equal() if you want to compare two
// font descriptions.
func (f fontSelectionDialog) FontName() string {
	var _arg0 *C.GtkFontSelectionDialog // out
	var _cret *C.gchar                  // in

	_arg0 = (*C.GtkFontSelectionDialog)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_selection_dialog_get_font_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// FontSelection retrieves the FontSelection widget embedded in the dialog.
func (f fontSelectionDialog) FontSelection() Widget {
	var _arg0 *C.GtkFontSelectionDialog // out
	var _cret *C.GtkWidget              // in

	_arg0 = (*C.GtkFontSelectionDialog)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_selection_dialog_get_font_selection(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// OkButton gets the “OK” button.
func (f fontSelectionDialog) OkButton() Widget {
	var _arg0 *C.GtkFontSelectionDialog // out
	var _cret *C.GtkWidget              // in

	_arg0 = (*C.GtkFontSelectionDialog)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_selection_dialog_get_ok_button(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// PreviewText gets the text displayed in the preview area.
func (f fontSelectionDialog) PreviewText() string {
	var _arg0 *C.GtkFontSelectionDialog // out
	var _cret *C.gchar                  // in

	_arg0 = (*C.GtkFontSelectionDialog)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_font_selection_dialog_get_preview_text(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// SetFontName sets the currently selected font.
func (f fontSelectionDialog) SetFontName(fontname string) bool {
	var _arg0 *C.GtkFontSelectionDialog // out
	var _arg1 *C.gchar                  // out
	var _cret C.gboolean                // in

	_arg0 = (*C.GtkFontSelectionDialog)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.gchar)(C.CString(fontname))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_font_selection_dialog_set_font_name(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetPreviewText sets the text displayed in the preview area.
func (f fontSelectionDialog) SetPreviewText(text string) {
	var _arg0 *C.GtkFontSelectionDialog // out
	var _arg1 *C.gchar                  // out

	_arg0 = (*C.GtkFontSelectionDialog)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_font_selection_dialog_set_preview_text(_arg0, _arg1)
}

// Frame: the frame widget is a bin that surrounds its child with a decorative
// frame and an optional label. If present, the label is drawn in a gap in the
// top side of the frame. The position of the label can be controlled with
// gtk_frame_set_label_align().
//
//
// GtkFrame as GtkBuildable
//
// The GtkFrame implementation of the GtkBuildable interface supports placing a
// child in the label position by specifying “label” as the “type” attribute of
// a <child> element. A normal content child can be specified without specifying
// a <child> type attribute.
//
// An example of a UI definition fragment with GtkFrame:
//
//    <object class="GtkFrame">
//      <child type="label">
//        <object class="GtkLabel" id="frame-label"/>
//      </child>
//      <child>
//        <object class="GtkEntry" id="frame-content"/>
//      </child>
//    </object>
//
// CSS nodes
//
//    frame
//    ├── border[.flat]
//    ├── <label widget>
//    ╰── <child>
//
// GtkFrame has a main CSS node named “frame” and a subnode named “border”. The
// “border” node is used to draw the visible border. You can set the appearance
// of the border using CSS properties like “border-style” on the “border” node.
//
// The border node can be given the style class “.flat”, which is used by themes
// to disable drawing of the border. To do this from code, call
// gtk_frame_set_shadow_type() with GTK_SHADOW_NONE to add the “.flat” class or
// any other shadow type to remove it.
type Frame interface {
	Bin
	Buildable

	// Label: if the frame’s label widget is a Label, returns the text in the
	// label widget. (The frame will have a Label for the label widget if a
	// non-nil argument was passed to gtk_frame_new().)
	Label() string
	// LabelAlign retrieves the X and Y alignment of the frame’s label. See
	// gtk_frame_set_label_align().
	LabelAlign() (xalign float32, yalign float32)
	// LabelWidget retrieves the label widget for the frame. See
	// gtk_frame_set_label_widget().
	LabelWidget() Widget
	// ShadowType retrieves the shadow type of the frame. See
	// gtk_frame_set_shadow_type().
	ShadowType() ShadowType
	// SetLabel removes the current Frame:label-widget. If @label is not nil,
	// creates a new Label with that text and adds it as the Frame:label-widget.
	SetLabel(label string)
	// SetLabelAlign sets the alignment of the frame widget’s label. The default
	// values for a newly created frame are 0.0 and 0.5.
	SetLabelAlign(xalign float32, yalign float32)
	// SetLabelWidget sets the Frame:label-widget for the frame. This is the
	// widget that will appear embedded in the top edge of the frame as a title.
	SetLabelWidget(labelWidget Widget)
	// SetShadowType sets the Frame:shadow-type for @frame, i.e. whether it is
	// drawn without (GTK_SHADOW_NONE) or with (other values) a visible border.
	// Values other than GTK_SHADOW_NONE are treated identically by GtkFrame.
	// The chosen type is applied by removing or adding the .flat class to the
	// CSS node named border.
	SetShadowType(typ ShadowType)
}

// frame implements the Frame class.
type frame struct {
	Bin
	Buildable
}

var _ Frame = (*frame)(nil)

// WrapFrame wraps a GObject to the right type. It is
// primarily used internally.
func WrapFrame(obj *externglib.Object) Frame {
	return frame{
		Bin:       WrapBin(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalFrame(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFrame(obj), nil
}

// NewFrame creates a new Frame, with optional label @label. If @label is nil,
// the label is omitted.
func NewFrame(label string) Frame {
	var _arg1 *C.gchar     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_frame_new(_arg1)

	var _frame Frame // out

	_frame = WrapFrame(externglib.Take(unsafe.Pointer(_cret)))

	return _frame
}

// Label: if the frame’s label widget is a Label, returns the text in the label
// widget. (The frame will have a Label for the label widget if a non-nil
// argument was passed to gtk_frame_new().)
func (f frame) Label() string {
	var _arg0 *C.GtkFrame // out
	var _cret *C.gchar    // in

	_arg0 = (*C.GtkFrame)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_frame_get_label(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// LabelAlign retrieves the X and Y alignment of the frame’s label. See
// gtk_frame_set_label_align().
func (f frame) LabelAlign() (xalign float32, yalign float32) {
	var _arg0 *C.GtkFrame // out
	var _arg1 C.gfloat    // in
	var _arg2 C.gfloat    // in

	_arg0 = (*C.GtkFrame)(unsafe.Pointer(f.Native()))

	C.gtk_frame_get_label_align(_arg0, &_arg1, &_arg2)

	var _xalign float32 // out
	var _yalign float32 // out

	_xalign = (float32)(_arg1)
	_yalign = (float32)(_arg2)

	return _xalign, _yalign
}

// LabelWidget retrieves the label widget for the frame. See
// gtk_frame_set_label_widget().
func (f frame) LabelWidget() Widget {
	var _arg0 *C.GtkFrame  // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkFrame)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_frame_get_label_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// ShadowType retrieves the shadow type of the frame. See
// gtk_frame_set_shadow_type().
func (f frame) ShadowType() ShadowType {
	var _arg0 *C.GtkFrame     // out
	var _cret C.GtkShadowType // in

	_arg0 = (*C.GtkFrame)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_frame_get_shadow_type(_arg0)

	var _shadowType ShadowType // out

	_shadowType = ShadowType(_cret)

	return _shadowType
}

// SetLabel removes the current Frame:label-widget. If @label is not nil,
// creates a new Label with that text and adds it as the Frame:label-widget.
func (f frame) SetLabel(label string) {
	var _arg0 *C.GtkFrame // out
	var _arg1 *C.gchar    // out

	_arg0 = (*C.GtkFrame)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_frame_set_label(_arg0, _arg1)
}

// SetLabelAlign sets the alignment of the frame widget’s label. The default
// values for a newly created frame are 0.0 and 0.5.
func (f frame) SetLabelAlign(xalign float32, yalign float32) {
	var _arg0 *C.GtkFrame // out
	var _arg1 C.gfloat    // out
	var _arg2 C.gfloat    // out

	_arg0 = (*C.GtkFrame)(unsafe.Pointer(f.Native()))
	_arg1 = (C.gfloat)(xalign)
	_arg2 = (C.gfloat)(yalign)

	C.gtk_frame_set_label_align(_arg0, _arg1, _arg2)
}

// SetLabelWidget sets the Frame:label-widget for the frame. This is the widget
// that will appear embedded in the top edge of the frame as a title.
func (f frame) SetLabelWidget(labelWidget Widget) {
	var _arg0 *C.GtkFrame  // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkFrame)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(labelWidget.Native()))

	C.gtk_frame_set_label_widget(_arg0, _arg1)
}

// SetShadowType sets the Frame:shadow-type for @frame, i.e. whether it is drawn
// without (GTK_SHADOW_NONE) or with (other values) a visible border. Values
// other than GTK_SHADOW_NONE are treated identically by GtkFrame. The chosen
// type is applied by removing or adding the .flat class to the CSS node named
// border.
func (f frame) SetShadowType(typ ShadowType) {
	var _arg0 *C.GtkFrame     // out
	var _arg1 C.GtkShadowType // out

	_arg0 = (*C.GtkFrame)(unsafe.Pointer(f.Native()))
	_arg1 = (C.GtkShadowType)(typ)

	C.gtk_frame_set_shadow_type(_arg0, _arg1)
}

type FrameAccessible interface {
	ContainerAccessible
}

// frameAccessible implements the FrameAccessible class.
type frameAccessible struct {
	ContainerAccessible
}

var _ FrameAccessible = (*frameAccessible)(nil)

// WrapFrameAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapFrameAccessible(obj *externglib.Object) FrameAccessible {
	return frameAccessible{
		ContainerAccessible: WrapContainerAccessible(obj),
	}
}

func marshalFrameAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFrameAccessible(obj), nil
}

// GLArea is a widget that allows drawing with OpenGL.
//
// GLArea sets up its own GLContext for the window it creates, and creates a
// custom GL framebuffer that the widget will do GL rendering onto. It also
// ensures that this framebuffer is the default GL rendering target when
// rendering.
//
// In order to draw, you have to connect to the GLArea::render signal, or
// subclass GLArea and override the @GtkGLAreaClass.render() virtual function.
//
// The GLArea widget ensures that the GLContext is associated with the widget's
// drawing area, and it is kept updated when the size and position of the
// drawing area changes.
//
// Drawing with GtkGLArea ##
//
// The simplest way to draw using OpenGL commands in a GLArea is to create a
// widget instance and connect to the GLArea::render signal:
//
//      static void
//      on_realize (GtkGLarea *area)
//      {
//        // We need to make the context current if we want to
//        // call GL API
//        gtk_gl_area_make_current (area);
//
//        // If there were errors during the initialization or
//        // when trying to make the context current, this
//        // function will return a #GError for you to catch
//        if (gtk_gl_area_get_error (area) != NULL)
//          return;
//
//        // You can also use gtk_gl_area_set_error() in order
//        // to show eventual initialization errors on the
//        // GtkGLArea widget itself
//        GError *internal_error = NULL;
//        init_buffer_objects (&error);
//        if (error != NULL)
//          {
//            gtk_gl_area_set_error (area, error);
//            g_error_free (error);
//            return;
//          }
//
//        init_shaders (&error);
//        if (error != NULL)
//          {
//            gtk_gl_area_set_error (area, error);
//            g_error_free (error);
//            return;
//          }
//      }
//
// If you need to change the options for creating the GLContext you should use
// the GLArea::create-context signal.
type GLArea interface {
	Widget
	Buildable

	// AttachBuffers ensures that the @area framebuffer object is made the
	// current draw and read target, and that all the required buffers for the
	// @area are created and bound to the frambuffer.
	//
	// This function is automatically called before emitting the GLArea::render
	// signal, and doesn't normally need to be called by application code.
	AttachBuffers()
	// AutoRender returns whether the area is in auto render mode or not.
	AutoRender() bool
	// Context retrieves the GLContext used by @area.
	Context() gdk.GLContext
	// Error gets the current error set on the @area.
	Error() error
	// HasAlpha returns whether the area has an alpha component.
	HasAlpha() bool
	// HasDepthBuffer returns whether the area has a depth buffer.
	HasDepthBuffer() bool
	// HasStencilBuffer returns whether the area has a stencil buffer.
	HasStencilBuffer() bool
	// RequiredVersion retrieves the required version of OpenGL set using
	// gtk_gl_area_set_required_version().
	RequiredVersion() (major int, minor int)
	// UseES retrieves the value set by gtk_gl_area_set_use_es().
	UseES() bool
	// MakeCurrent ensures that the GLContext used by @area is associated with
	// the GLArea.
	//
	// This function is automatically called before emitting the GLArea::render
	// signal, and doesn't normally need to be called by application code.
	MakeCurrent()
	// QueueRender marks the currently rendered data (if any) as invalid, and
	// queues a redraw of the widget, ensuring that the GLArea::render signal is
	// emitted during the draw.
	//
	// This is only needed when the gtk_gl_area_set_auto_render() has been
	// called with a false value. The default behaviour is to emit
	// GLArea::render on each draw.
	QueueRender()
	// SetAutoRender: if @auto_render is true the GLArea::render signal will be
	// emitted every time the widget draws. This is the default and is useful if
	// drawing the widget is faster.
	//
	// If @auto_render is false the data from previous rendering is kept around
	// and will be used for drawing the widget the next time, unless the window
	// is resized. In order to force a rendering gtk_gl_area_queue_render() must
	// be called. This mode is useful when the scene changes seldomly, but takes
	// a long time to redraw.
	SetAutoRender(autoRender bool)
	// SetError sets an error on the area which will be shown instead of the GL
	// rendering. This is useful in the GLArea::create-context signal if GL
	// context creation fails.
	SetError(err error)
	// SetHasAlpha: if @has_alpha is true the buffer allocated by the widget
	// will have an alpha channel component, and when rendering to the window
	// the result will be composited over whatever is below the widget.
	//
	// If @has_alpha is false there will be no alpha channel, and the buffer
	// will fully replace anything below the widget.
	SetHasAlpha(hasAlpha bool)
	// SetHasDepthBuffer: if @has_depth_buffer is true the widget will allocate
	// and enable a depth buffer for the target framebuffer. Otherwise there
	// will be none.
	SetHasDepthBuffer(hasDepthBuffer bool)
	// SetHasStencilBuffer: if @has_stencil_buffer is true the widget will
	// allocate and enable a stencil buffer for the target framebuffer.
	// Otherwise there will be none.
	SetHasStencilBuffer(hasStencilBuffer bool)
	// SetRequiredVersion sets the required version of OpenGL to be used when
	// creating the context for the widget.
	//
	// This function must be called before the area has been realized.
	SetRequiredVersion(major int, minor int)
	// SetUseES sets whether the @area should create an OpenGL or an OpenGL ES
	// context.
	//
	// You should check the capabilities of the GLContext before drawing with
	// either API.
	SetUseES(useEs bool)
}

// glArea implements the GLArea class.
type glArea struct {
	Widget
	Buildable
}

var _ GLArea = (*glArea)(nil)

// WrapGLArea wraps a GObject to the right type. It is
// primarily used internally.
func WrapGLArea(obj *externglib.Object) GLArea {
	return glArea{
		Widget:    WrapWidget(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalGLArea(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGLArea(obj), nil
}

// NewGLArea creates a new GLArea widget.
func NewGLArea() GLArea {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_gl_area_new()

	var _glArea GLArea // out

	_glArea = WrapGLArea(externglib.Take(unsafe.Pointer(_cret)))

	return _glArea
}

// AttachBuffers ensures that the @area framebuffer object is made the current
// draw and read target, and that all the required buffers for the @area are
// created and bound to the frambuffer.
//
// This function is automatically called before emitting the GLArea::render
// signal, and doesn't normally need to be called by application code.
func (a glArea) AttachBuffers() {
	var _arg0 *C.GtkGLArea // out

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

	C.gtk_gl_area_attach_buffers(_arg0)
}

// AutoRender returns whether the area is in auto render mode or not.
func (a glArea) AutoRender() bool {
	var _arg0 *C.GtkGLArea // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_gl_area_get_auto_render(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Context retrieves the GLContext used by @area.
func (a glArea) Context() gdk.GLContext {
	var _arg0 *C.GtkGLArea    // out
	var _cret *C.GdkGLContext // in

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_gl_area_get_context(_arg0)

	var _glContext gdk.GLContext // out

	_glContext = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.GLContext)

	return _glContext
}

// Error gets the current error set on the @area.
func (a glArea) Error() error {
	var _arg0 *C.GtkGLArea // out
	var _cret *C.GError    // in

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_gl_area_get_error(_arg0)

	var _err error // out

	_err = gerror.Take(unsafe.Pointer(_cret))

	return _err
}

// HasAlpha returns whether the area has an alpha component.
func (a glArea) HasAlpha() bool {
	var _arg0 *C.GtkGLArea // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_gl_area_get_has_alpha(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasDepthBuffer returns whether the area has a depth buffer.
func (a glArea) HasDepthBuffer() bool {
	var _arg0 *C.GtkGLArea // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_gl_area_get_has_depth_buffer(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasStencilBuffer returns whether the area has a stencil buffer.
func (a glArea) HasStencilBuffer() bool {
	var _arg0 *C.GtkGLArea // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_gl_area_get_has_stencil_buffer(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RequiredVersion retrieves the required version of OpenGL set using
// gtk_gl_area_set_required_version().
func (a glArea) RequiredVersion() (major int, minor int) {
	var _arg0 *C.GtkGLArea // out
	var _arg1 C.gint       // in
	var _arg2 C.gint       // in

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

	C.gtk_gl_area_get_required_version(_arg0, &_arg1, &_arg2)

	var _major int // out
	var _minor int // out

	_major = (int)(_arg1)
	_minor = (int)(_arg2)

	return _major, _minor
}

// UseES retrieves the value set by gtk_gl_area_set_use_es().
func (a glArea) UseES() bool {
	var _arg0 *C.GtkGLArea // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_gl_area_get_use_es(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MakeCurrent ensures that the GLContext used by @area is associated with the
// GLArea.
//
// This function is automatically called before emitting the GLArea::render
// signal, and doesn't normally need to be called by application code.
func (a glArea) MakeCurrent() {
	var _arg0 *C.GtkGLArea // out

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

	C.gtk_gl_area_make_current(_arg0)
}

// QueueRender marks the currently rendered data (if any) as invalid, and queues
// a redraw of the widget, ensuring that the GLArea::render signal is emitted
// during the draw.
//
// This is only needed when the gtk_gl_area_set_auto_render() has been called
// with a false value. The default behaviour is to emit GLArea::render on each
// draw.
func (a glArea) QueueRender() {
	var _arg0 *C.GtkGLArea // out

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

	C.gtk_gl_area_queue_render(_arg0)
}

// SetAutoRender: if @auto_render is true the GLArea::render signal will be
// emitted every time the widget draws. This is the default and is useful if
// drawing the widget is faster.
//
// If @auto_render is false the data from previous rendering is kept around and
// will be used for drawing the widget the next time, unless the window is
// resized. In order to force a rendering gtk_gl_area_queue_render() must be
// called. This mode is useful when the scene changes seldomly, but takes a long
// time to redraw.
func (a glArea) SetAutoRender(autoRender bool) {
	var _arg0 *C.GtkGLArea // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))
	if autoRender {
		_arg1 = C.TRUE
	}

	C.gtk_gl_area_set_auto_render(_arg0, _arg1)
}

// SetError sets an error on the area which will be shown instead of the GL
// rendering. This is useful in the GLArea::create-context signal if GL context
// creation fails.
func (a glArea) SetError(err error) {
	var _arg0 *C.GtkGLArea // out
	var _arg1 *C.GError    // out

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GError)(gerror.New(unsafe.Pointer(err)))
	defer C.g_error_free(_arg1)

	C.gtk_gl_area_set_error(_arg0, _arg1)
}

// SetHasAlpha: if @has_alpha is true the buffer allocated by the widget will
// have an alpha channel component, and when rendering to the window the result
// will be composited over whatever is below the widget.
//
// If @has_alpha is false there will be no alpha channel, and the buffer will
// fully replace anything below the widget.
func (a glArea) SetHasAlpha(hasAlpha bool) {
	var _arg0 *C.GtkGLArea // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))
	if hasAlpha {
		_arg1 = C.TRUE
	}

	C.gtk_gl_area_set_has_alpha(_arg0, _arg1)
}

// SetHasDepthBuffer: if @has_depth_buffer is true the widget will allocate and
// enable a depth buffer for the target framebuffer. Otherwise there will be
// none.
func (a glArea) SetHasDepthBuffer(hasDepthBuffer bool) {
	var _arg0 *C.GtkGLArea // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))
	if hasDepthBuffer {
		_arg1 = C.TRUE
	}

	C.gtk_gl_area_set_has_depth_buffer(_arg0, _arg1)
}

// SetHasStencilBuffer: if @has_stencil_buffer is true the widget will allocate
// and enable a stencil buffer for the target framebuffer. Otherwise there will
// be none.
func (a glArea) SetHasStencilBuffer(hasStencilBuffer bool) {
	var _arg0 *C.GtkGLArea // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))
	if hasStencilBuffer {
		_arg1 = C.TRUE
	}

	C.gtk_gl_area_set_has_stencil_buffer(_arg0, _arg1)
}

// SetRequiredVersion sets the required version of OpenGL to be used when
// creating the context for the widget.
//
// This function must be called before the area has been realized.
func (a glArea) SetRequiredVersion(major int, minor int) {
	var _arg0 *C.GtkGLArea // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // out

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))
	_arg1 = (C.gint)(major)
	_arg2 = (C.gint)(minor)

	C.gtk_gl_area_set_required_version(_arg0, _arg1, _arg2)
}

// SetUseES sets whether the @area should create an OpenGL or an OpenGL ES
// context.
//
// You should check the capabilities of the GLContext before drawing with either
// API.
func (a glArea) SetUseES(useEs bool) {
	var _arg0 *C.GtkGLArea // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))
	if useEs {
		_arg1 = C.TRUE
	}

	C.gtk_gl_area_set_use_es(_arg0, _arg1)
}

// Gesture is the base object for gesture recognition, although this object is
// quite generalized to serve as a base for multi-touch gestures, it is suitable
// to implement single-touch and pointer-based gestures (using the special nil
// EventSequence value for these).
//
// The number of touches that a Gesture need to be recognized is controlled by
// the Gesture:n-points property, if a gesture is keeping track of less or more
// than that number of sequences, it won't check wether the gesture is
// recognized.
//
// As soon as the gesture has the expected number of touches, the gesture will
// run the Gesture::check signal regularly on input events until the gesture is
// recognized, the criteria to consider a gesture as "recognized" is left to
// Gesture subclasses.
//
// A recognized gesture will then emit the following signals: - Gesture::begin
// when the gesture is recognized. - A number of Gesture::update, whenever an
// input event is processed. - Gesture::end when the gesture is no longer
// recognized.
//
//
// Event propagation
//
// In order to receive events, a gesture needs to either set a propagation phase
// through gtk_event_controller_set_propagation_phase(), or feed those manually
// through gtk_event_controller_handle_event().
//
// In the capture phase, events are propagated from the toplevel down to the
// target widget, and gestures that are attached to containers above the widget
// get a chance to interact with the event before it reaches the target.
//
// After the capture phase, GTK+ emits the traditional
// Widget::button-press-event, Widget::button-release-event,
// Widget::touch-event, etc signals. Gestures with the GTK_PHASE_TARGET phase
// are fed events from the default Widget::event handlers.
//
// In the bubble phase, events are propagated up from the target widget to the
// toplevel, and gestures that are attached to containers above the widget get a
// chance to interact with events that have not been handled yet.
//
//
// States of a sequence
//
// Whenever input interaction happens, a single event may trigger a cascade of
// Gestures, both across the parents of the widget receiving the event and in
// parallel within an individual widget. It is a responsibility of the widgets
// using those gestures to set the state of touch sequences accordingly in order
// to enable cooperation of gestures around the EventSequences triggering those.
//
// Within a widget, gestures can be grouped through gtk_gesture_group(), grouped
// gestures synchronize the state of sequences, so calling
// gtk_gesture_set_sequence_state() on one will effectively propagate the state
// throughout the group.
//
// By default, all sequences start out in the K_EVENT_SEQUENCE_NONE state,
// sequences in this state trigger the gesture event handler, but event
// propagation will continue unstopped by gestures.
//
// If a sequence enters into the K_EVENT_SEQUENCE_DENIED state, the gesture
// group will effectively ignore the sequence, letting events go unstopped
// through the gesture, but the "slot" will still remain occupied while the
// touch is active.
//
// If a sequence enters in the K_EVENT_SEQUENCE_CLAIMED state, the gesture group
// will grab all interaction on the sequence, by: - Setting the same sequence to
// K_EVENT_SEQUENCE_DENIED on every other gesture group within the widget, and
// every gesture on parent widgets in the propagation chain. - calling
// Gesture::cancel on every gesture in widgets underneath in the propagation
// chain. - Stopping event propagation after the gesture group handles the
// event.
//
// Note: if a sequence is set early to K_EVENT_SEQUENCE_CLAIMED on
// K_TOUCH_BEGIN/K_BUTTON_PRESS (so those events are captured before reaching
// the event widget, this implies K_PHASE_CAPTURE), one similar event will
// emulated if the sequence changes to K_EVENT_SEQUENCE_DENIED. This way event
// coherence is preserved before event propagation is unstopped again.
//
// Sequence states can't be changed freely, see gtk_gesture_set_sequence_state()
// to know about the possible lifetimes of a EventSequence.
//
//
// Touchpad gestures
//
// On the platforms that support it, Gesture will handle transparently touchpad
// gesture events. The only precautions users of Gesture should do to enable
// this support are: - Enabling GDK_TOUCHPAD_GESTURE_MASK on their Windows - If
// the gesture has GTK_PHASE_NONE, ensuring events of type GDK_TOUCHPAD_SWIPE
// and GDK_TOUCHPAD_PINCH are handled by the Gesture
type Gesture interface {
	EventController

	// BoundingBox: if there are touch sequences being currently handled by
	// @gesture, this function returns true and fills in @rect with the bounding
	// box containing all active touches. Otherwise, false will be returned.
	//
	// Note: This function will yield unexpected results on touchpad gestures.
	// Since there is no correlation between physical and pixel distances, these
	// will look as if constrained in an infinitely small area, @rect width and
	// height will thus be 0 regardless of the number of touchpoints.
	BoundingBox() (gdk.Rectangle, bool)
	// BoundingBoxCenter: if there are touch sequences being currently handled
	// by @gesture, this function returns true and fills in @x and @y with the
	// center of the bounding box containing all active touches. Otherwise,
	// false will be returned.
	BoundingBoxCenter() (x float64, y float64, ok bool)
	// Device returns the master Device that is currently operating on @gesture,
	// or nil if the gesture is not being interacted.
	Device() gdk.Device
	// LastUpdatedSequence returns the EventSequence that was last updated on
	// @gesture.
	LastUpdatedSequence() *gdk.EventSequence
	// Point: if @sequence is currently being interpreted by @gesture, this
	// function returns true and fills in @x and @y with the last coordinates
	// stored for that event sequence. The coordinates are always relative to
	// the widget allocation.
	Point(sequence *gdk.EventSequence) (x float64, y float64, ok bool)
	// SequenceState returns the @sequence state, as seen by @gesture.
	SequenceState(sequence *gdk.EventSequence) EventSequenceState
	// Window returns the user-defined window that receives the events handled
	// by @gesture. See gtk_gesture_set_window() for more information.
	Window() gdk.Window
	// Group adds @gesture to the same group than @group_gesture. Gestures are
	// by default isolated in their own groups.
	//
	// When gestures are grouped, the state of EventSequences is kept in sync
	// for all of those, so calling gtk_gesture_set_sequence_state(), on one
	// will transfer the same value to the others.
	//
	// Groups also perform an "implicit grabbing" of sequences, if a
	// EventSequence state is set to K_EVENT_SEQUENCE_CLAIMED on one group,
	// every other gesture group attached to the same Widget will switch the
	// state for that sequence to K_EVENT_SEQUENCE_DENIED.
	Group(gesture Gesture)
	// HandlesSequence returns true if @gesture is currently handling events
	// corresponding to @sequence.
	HandlesSequence(sequence *gdk.EventSequence) bool
	// IsActive returns true if the gesture is currently active. A gesture is
	// active meanwhile there are touch sequences interacting with it.
	IsActive() bool
	// IsGroupedWith returns true if both gestures pertain to the same group.
	IsGroupedWith(other Gesture) bool
	// IsRecognized returns true if the gesture is currently recognized. A
	// gesture is recognized if there are as many interacting touch sequences as
	// required by @gesture, and Gesture::check returned true for the sequences
	// being currently interpreted.
	IsRecognized() bool
	// SetSequenceState sets the state of @sequence in @gesture. Sequences start
	// in state K_EVENT_SEQUENCE_NONE, and whenever they change state, they can
	// never go back to that state. Likewise, sequences in state
	// K_EVENT_SEQUENCE_DENIED cannot turn back to a not denied state. With
	// these rules, the lifetime of an event sequence is constrained to the next
	// four:
	//
	// * None * None → Denied * None → Claimed * None → Claimed → Denied
	//
	// Note: Due to event handling ordering, it may be unsafe to set the state
	// on another gesture within a Gesture::begin signal handler, as the
	// callback might be executed before the other gesture knows about the
	// sequence. A safe way to perform this could be:
	//
	//    static void
	//    first_gesture_begin_cb (GtkGesture       *first_gesture,
	//                            GdkEventSequence *sequence,
	//                            gpointer          user_data)
	//    {
	//      gtk_gesture_set_sequence_state (first_gesture, sequence, GTK_EVENT_SEQUENCE_CLAIMED);
	//      gtk_gesture_set_sequence_state (second_gesture, sequence, GTK_EVENT_SEQUENCE_DENIED);
	//    }
	//
	//    static void
	//    second_gesture_begin_cb (GtkGesture       *second_gesture,
	//                             GdkEventSequence *sequence,
	//                             gpointer          user_data)
	//    {
	//      if (gtk_gesture_get_sequence_state (first_gesture, sequence) == GTK_EVENT_SEQUENCE_CLAIMED)
	//        gtk_gesture_set_sequence_state (second_gesture, sequence, GTK_EVENT_SEQUENCE_DENIED);
	//    }
	//
	// If both gestures are in the same group, just set the state on the gesture
	// emitting the event, the sequence will be already be initialized to the
	// group's global state when the second gesture processes the event.
	SetSequenceState(sequence *gdk.EventSequence, state EventSequenceState) bool
	// SetState sets the state of all sequences that @gesture is currently
	// interacting with. See gtk_gesture_set_sequence_state() for more details
	// on sequence states.
	SetState(state EventSequenceState) bool
	// SetWindow sets a specific window to receive events about, so @gesture
	// will effectively handle only events targeting @window, or a child of it.
	// @window must pertain to gtk_event_controller_get_widget().
	SetWindow(window gdk.Window)
	// Ungroup separates @gesture into an isolated group.
	Ungroup()
}

// gesture implements the Gesture class.
type gesture struct {
	EventController
}

var _ Gesture = (*gesture)(nil)

// WrapGesture wraps a GObject to the right type. It is
// primarily used internally.
func WrapGesture(obj *externglib.Object) Gesture {
	return gesture{
		EventController: WrapEventController(obj),
	}
}

func marshalGesture(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGesture(obj), nil
}

// BoundingBox: if there are touch sequences being currently handled by
// @gesture, this function returns true and fills in @rect with the bounding box
// containing all active touches. Otherwise, false will be returned.
//
// Note: This function will yield unexpected results on touchpad gestures. Since
// there is no correlation between physical and pixel distances, these will look
// as if constrained in an infinitely small area, @rect width and height will
// thus be 0 regardless of the number of touchpoints.
func (g gesture) BoundingBox() (gdk.Rectangle, bool) {
	var _arg0 *C.GtkGesture // out
	var _rect gdk.Rectangle
	var _cret C.gboolean // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_get_bounding_box(_arg0, (*C.GdkRectangle)(unsafe.Pointer(&_rect)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _rect, _ok
}

// BoundingBoxCenter: if there are touch sequences being currently handled by
// @gesture, this function returns true and fills in @x and @y with the center
// of the bounding box containing all active touches. Otherwise, false will be
// returned.
func (g gesture) BoundingBoxCenter() (x float64, y float64, ok bool) {
	var _arg0 *C.GtkGesture // out
	var _arg1 C.gdouble     // in
	var _arg2 C.gdouble     // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_get_bounding_box_center(_arg0, &_arg1, &_arg2)

	var _x float64 // out
	var _y float64 // out
	var _ok bool   // out

	_x = (float64)(_arg1)
	_y = (float64)(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _x, _y, _ok
}

// Device returns the master Device that is currently operating on @gesture, or
// nil if the gesture is not being interacted.
func (g gesture) Device() gdk.Device {
	var _arg0 *C.GtkGesture // out
	var _cret *C.GdkDevice  // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_get_device(_arg0)

	var _device gdk.Device // out

	_device = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Device)

	return _device
}

// LastUpdatedSequence returns the EventSequence that was last updated on
// @gesture.
func (g gesture) LastUpdatedSequence() *gdk.EventSequence {
	var _arg0 *C.GtkGesture       // out
	var _cret *C.GdkEventSequence // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_get_last_updated_sequence(_arg0)

	var _eventSequence *gdk.EventSequence // out

	_eventSequence = gdk.WrapEventSequence(unsafe.Pointer(_cret))

	return _eventSequence
}

// Point: if @sequence is currently being interpreted by @gesture, this function
// returns true and fills in @x and @y with the last coordinates stored for that
// event sequence. The coordinates are always relative to the widget allocation.
func (g gesture) Point(sequence *gdk.EventSequence) (x float64, y float64, ok bool) {
	var _arg0 *C.GtkGesture       // out
	var _arg1 *C.GdkEventSequence // out
	var _arg2 C.gdouble           // in
	var _arg3 C.gdouble           // in
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.GdkEventSequence)(unsafe.Pointer(sequence.Native()))

	_cret = C.gtk_gesture_get_point(_arg0, _arg1, &_arg2, &_arg3)

	var _x float64 // out
	var _y float64 // out
	var _ok bool   // out

	_x = (float64)(_arg2)
	_y = (float64)(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _x, _y, _ok
}

// SequenceState returns the @sequence state, as seen by @gesture.
func (g gesture) SequenceState(sequence *gdk.EventSequence) EventSequenceState {
	var _arg0 *C.GtkGesture           // out
	var _arg1 *C.GdkEventSequence     // out
	var _cret C.GtkEventSequenceState // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.GdkEventSequence)(unsafe.Pointer(sequence.Native()))

	_cret = C.gtk_gesture_get_sequence_state(_arg0, _arg1)

	var _eventSequenceState EventSequenceState // out

	_eventSequenceState = EventSequenceState(_cret)

	return _eventSequenceState
}

// Window returns the user-defined window that receives the events handled by
// @gesture. See gtk_gesture_set_window() for more information.
func (g gesture) Window() gdk.Window {
	var _arg0 *C.GtkGesture // out
	var _cret *C.GdkWindow  // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_get_window(_arg0)

	var _window gdk.Window // out

	_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Window)

	return _window
}

// Group adds @gesture to the same group than @group_gesture. Gestures are by
// default isolated in their own groups.
//
// When gestures are grouped, the state of EventSequences is kept in sync for
// all of those, so calling gtk_gesture_set_sequence_state(), on one will
// transfer the same value to the others.
//
// Groups also perform an "implicit grabbing" of sequences, if a EventSequence
// state is set to K_EVENT_SEQUENCE_CLAIMED on one group, every other gesture
// group attached to the same Widget will switch the state for that sequence to
// K_EVENT_SEQUENCE_DENIED.
func (g gesture) Group(gesture Gesture) {
	var _arg0 *C.GtkGesture // out
	var _arg1 *C.GtkGesture // out

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.GtkGesture)(unsafe.Pointer(gesture.Native()))

	C.gtk_gesture_group(_arg0, _arg1)
}

// HandlesSequence returns true if @gesture is currently handling events
// corresponding to @sequence.
func (g gesture) HandlesSequence(sequence *gdk.EventSequence) bool {
	var _arg0 *C.GtkGesture       // out
	var _arg1 *C.GdkEventSequence // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.GdkEventSequence)(unsafe.Pointer(sequence.Native()))

	_cret = C.gtk_gesture_handles_sequence(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsActive returns true if the gesture is currently active. A gesture is active
// meanwhile there are touch sequences interacting with it.
func (g gesture) IsActive() bool {
	var _arg0 *C.GtkGesture // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_is_active(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsGroupedWith returns true if both gestures pertain to the same group.
func (g gesture) IsGroupedWith(other Gesture) bool {
	var _arg0 *C.GtkGesture // out
	var _arg1 *C.GtkGesture // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.GtkGesture)(unsafe.Pointer(other.Native()))

	_cret = C.gtk_gesture_is_grouped_with(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsRecognized returns true if the gesture is currently recognized. A gesture
// is recognized if there are as many interacting touch sequences as required by
// @gesture, and Gesture::check returned true for the sequences being currently
// interpreted.
func (g gesture) IsRecognized() bool {
	var _arg0 *C.GtkGesture // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_is_recognized(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetSequenceState sets the state of @sequence in @gesture. Sequences start in
// state K_EVENT_SEQUENCE_NONE, and whenever they change state, they can never
// go back to that state. Likewise, sequences in state K_EVENT_SEQUENCE_DENIED
// cannot turn back to a not denied state. With these rules, the lifetime of an
// event sequence is constrained to the next four:
//
// * None * None → Denied * None → Claimed * None → Claimed → Denied
//
// Note: Due to event handling ordering, it may be unsafe to set the state on
// another gesture within a Gesture::begin signal handler, as the callback might
// be executed before the other gesture knows about the sequence. A safe way to
// perform this could be:
//
//    static void
//    first_gesture_begin_cb (GtkGesture       *first_gesture,
//                            GdkEventSequence *sequence,
//                            gpointer          user_data)
//    {
//      gtk_gesture_set_sequence_state (first_gesture, sequence, GTK_EVENT_SEQUENCE_CLAIMED);
//      gtk_gesture_set_sequence_state (second_gesture, sequence, GTK_EVENT_SEQUENCE_DENIED);
//    }
//
//    static void
//    second_gesture_begin_cb (GtkGesture       *second_gesture,
//                             GdkEventSequence *sequence,
//                             gpointer          user_data)
//    {
//      if (gtk_gesture_get_sequence_state (first_gesture, sequence) == GTK_EVENT_SEQUENCE_CLAIMED)
//        gtk_gesture_set_sequence_state (second_gesture, sequence, GTK_EVENT_SEQUENCE_DENIED);
//    }
//
// If both gestures are in the same group, just set the state on the gesture
// emitting the event, the sequence will be already be initialized to the
// group's global state when the second gesture processes the event.
func (g gesture) SetSequenceState(sequence *gdk.EventSequence, state EventSequenceState) bool {
	var _arg0 *C.GtkGesture           // out
	var _arg1 *C.GdkEventSequence     // out
	var _arg2 C.GtkEventSequenceState // out
	var _cret C.gboolean              // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.GdkEventSequence)(unsafe.Pointer(sequence.Native()))
	_arg2 = (C.GtkEventSequenceState)(state)

	_cret = C.gtk_gesture_set_sequence_state(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetState sets the state of all sequences that @gesture is currently
// interacting with. See gtk_gesture_set_sequence_state() for more details on
// sequence states.
func (g gesture) SetState(state EventSequenceState) bool {
	var _arg0 *C.GtkGesture           // out
	var _arg1 C.GtkEventSequenceState // out
	var _cret C.gboolean              // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))
	_arg1 = (C.GtkEventSequenceState)(state)

	_cret = C.gtk_gesture_set_state(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetWindow sets a specific window to receive events about, so @gesture will
// effectively handle only events targeting @window, or a child of it. @window
// must pertain to gtk_event_controller_get_widget().
func (g gesture) SetWindow(window gdk.Window) {
	var _arg0 *C.GtkGesture // out
	var _arg1 *C.GdkWindow  // out

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_gesture_set_window(_arg0, _arg1)
}

// Ungroup separates @gesture into an isolated group.
func (g gesture) Ungroup() {
	var _arg0 *C.GtkGesture // out

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))

	C.gtk_gesture_ungroup(_arg0)
}

// GestureDrag is a Gesture implementation that recognizes drag operations. The
// drag operation itself can be tracked throught the GestureDrag::drag-begin,
// GestureDrag::drag-update and GestureDrag::drag-end signals, or the relevant
// coordinates be extracted through gtk_gesture_drag_get_offset() and
// gtk_gesture_drag_get_start_point().
type GestureDrag interface {
	GestureSingle

	// Offset: if the @gesture is active, this function returns true and fills
	// in @x and @y with the coordinates of the current point, as an offset to
	// the starting drag point.
	Offset() (x float64, y float64, ok bool)
	// StartPoint: if the @gesture is active, this function returns true and
	// fills in @x and @y with the drag start coordinates, in window-relative
	// coordinates.
	StartPoint() (x float64, y float64, ok bool)
}

// gestureDrag implements the GestureDrag class.
type gestureDrag struct {
	GestureSingle
}

var _ GestureDrag = (*gestureDrag)(nil)

// WrapGestureDrag wraps a GObject to the right type. It is
// primarily used internally.
func WrapGestureDrag(obj *externglib.Object) GestureDrag {
	return gestureDrag{
		GestureSingle: WrapGestureSingle(obj),
	}
}

func marshalGestureDrag(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGestureDrag(obj), nil
}

// NewGestureDrag returns a newly created Gesture that recognizes drags.
func NewGestureDrag(widget Widget) GestureDrag {
	var _arg1 *C.GtkWidget  // out
	var _cret *C.GtkGesture // in

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	_cret = C.gtk_gesture_drag_new(_arg1)

	var _gestureDrag GestureDrag // out

	_gestureDrag = WrapGestureDrag(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _gestureDrag
}

// Offset: if the @gesture is active, this function returns true and fills in @x
// and @y with the coordinates of the current point, as an offset to the
// starting drag point.
func (g gestureDrag) Offset() (x float64, y float64, ok bool) {
	var _arg0 *C.GtkGestureDrag // out
	var _arg1 C.gdouble         // in
	var _arg2 C.gdouble         // in
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkGestureDrag)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_drag_get_offset(_arg0, &_arg1, &_arg2)

	var _x float64 // out
	var _y float64 // out
	var _ok bool   // out

	_x = (float64)(_arg1)
	_y = (float64)(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _x, _y, _ok
}

// StartPoint: if the @gesture is active, this function returns true and fills
// in @x and @y with the drag start coordinates, in window-relative coordinates.
func (g gestureDrag) StartPoint() (x float64, y float64, ok bool) {
	var _arg0 *C.GtkGestureDrag // out
	var _arg1 C.gdouble         // in
	var _arg2 C.gdouble         // in
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkGestureDrag)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_drag_get_start_point(_arg0, &_arg1, &_arg2)

	var _x float64 // out
	var _y float64 // out
	var _ok bool   // out

	_x = (float64)(_arg1)
	_y = (float64)(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _x, _y, _ok
}

// GestureLongPress is a Gesture implementation able to recognize long presses,
// triggering the GestureLongPress::pressed after the timeout is exceeded.
//
// If the touchpoint is lifted before the timeout passes, or if it drifts too
// far of the initial press point, the GestureLongPress::cancelled signal will
// be emitted.
type GestureLongPress interface {
	GestureSingle
}

// gestureLongPress implements the GestureLongPress class.
type gestureLongPress struct {
	GestureSingle
}

var _ GestureLongPress = (*gestureLongPress)(nil)

// WrapGestureLongPress wraps a GObject to the right type. It is
// primarily used internally.
func WrapGestureLongPress(obj *externglib.Object) GestureLongPress {
	return gestureLongPress{
		GestureSingle: WrapGestureSingle(obj),
	}
}

func marshalGestureLongPress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGestureLongPress(obj), nil
}

// NewGestureLongPress returns a newly created Gesture that recognizes long
// presses.
func NewGestureLongPress(widget Widget) GestureLongPress {
	var _arg1 *C.GtkWidget  // out
	var _cret *C.GtkGesture // in

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	_cret = C.gtk_gesture_long_press_new(_arg1)

	var _gestureLongPress GestureLongPress // out

	_gestureLongPress = WrapGestureLongPress(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _gestureLongPress
}

// GestureMultiPress is a Gesture implementation able to recognize multiple
// clicks on a nearby zone, which can be listened for through the
// GestureMultiPress::pressed signal. Whenever time or distance between clicks
// exceed the GTK+ defaults, GestureMultiPress::stopped is emitted, and the
// click counter is reset.
//
// Callers may also restrict the area that is considered valid for a >1
// touch/button press through gtk_gesture_multi_press_set_area(), so any click
// happening outside that area is considered to be a first click of its own.
type GestureMultiPress interface {
	GestureSingle

	// Area: if an area was set through gtk_gesture_multi_press_set_area(), this
	// function will return true and fill in @rect with the press area. See
	// gtk_gesture_multi_press_set_area() for more details on what the press
	// area represents.
	Area() (gdk.Rectangle, bool)
	// SetArea: if @rect is non-nil, the press area will be checked to be
	// confined within the rectangle, otherwise the button count will be reset
	// so the press is seen as being the first one. If @rect is nil, the area
	// will be reset to an unrestricted state.
	//
	// Note: The rectangle is only used to determine whether any non-first click
	// falls within the expected area. This is not akin to an input shape.
	SetArea(rect *gdk.Rectangle)
}

// gestureMultiPress implements the GestureMultiPress class.
type gestureMultiPress struct {
	GestureSingle
}

var _ GestureMultiPress = (*gestureMultiPress)(nil)

// WrapGestureMultiPress wraps a GObject to the right type. It is
// primarily used internally.
func WrapGestureMultiPress(obj *externglib.Object) GestureMultiPress {
	return gestureMultiPress{
		GestureSingle: WrapGestureSingle(obj),
	}
}

func marshalGestureMultiPress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGestureMultiPress(obj), nil
}

// NewGestureMultiPress returns a newly created Gesture that recognizes single
// and multiple presses.
func NewGestureMultiPress(widget Widget) GestureMultiPress {
	var _arg1 *C.GtkWidget  // out
	var _cret *C.GtkGesture // in

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	_cret = C.gtk_gesture_multi_press_new(_arg1)

	var _gestureMultiPress GestureMultiPress // out

	_gestureMultiPress = WrapGestureMultiPress(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _gestureMultiPress
}

// Area: if an area was set through gtk_gesture_multi_press_set_area(), this
// function will return true and fill in @rect with the press area. See
// gtk_gesture_multi_press_set_area() for more details on what the press area
// represents.
func (g gestureMultiPress) Area() (gdk.Rectangle, bool) {
	var _arg0 *C.GtkGestureMultiPress // out
	var _rect gdk.Rectangle
	var _cret C.gboolean // in

	_arg0 = (*C.GtkGestureMultiPress)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_multi_press_get_area(_arg0, (*C.GdkRectangle)(unsafe.Pointer(&_rect)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _rect, _ok
}

// SetArea: if @rect is non-nil, the press area will be checked to be confined
// within the rectangle, otherwise the button count will be reset so the press
// is seen as being the first one. If @rect is nil, the area will be reset to an
// unrestricted state.
//
// Note: The rectangle is only used to determine whether any non-first click
// falls within the expected area. This is not akin to an input shape.
func (g gestureMultiPress) SetArea(rect *gdk.Rectangle) {
	var _arg0 *C.GtkGestureMultiPress // out
	var _arg1 *C.GdkRectangle         // out

	_arg0 = (*C.GtkGestureMultiPress)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.GdkRectangle)(unsafe.Pointer(rect.Native()))

	C.gtk_gesture_multi_press_set_area(_arg0, _arg1)
}

// GesturePan is a Gesture implementation able to recognize pan gestures, those
// are drags that are locked to happen along one axis. The axis that a
// GesturePan handles is defined at construct time, and can be changed through
// gtk_gesture_pan_set_orientation().
//
// When the gesture starts to be recognized, GesturePan will attempt to
// determine as early as possible whether the sequence is moving in the expected
// direction, and denying the sequence if this does not happen.
//
// Once a panning gesture along the expected axis is recognized, the
// GesturePan::pan signal will be emitted as input events are received,
// containing the offset in the given axis.
type GesturePan interface {
	GestureDrag

	// Orientation returns the orientation of the pan gestures that this
	// @gesture expects.
	Orientation() Orientation
	// SetOrientation sets the orientation to be expected on pan gestures.
	SetOrientation(orientation Orientation)
}

// gesturePan implements the GesturePan class.
type gesturePan struct {
	GestureDrag
}

var _ GesturePan = (*gesturePan)(nil)

// WrapGesturePan wraps a GObject to the right type. It is
// primarily used internally.
func WrapGesturePan(obj *externglib.Object) GesturePan {
	return gesturePan{
		GestureDrag: WrapGestureDrag(obj),
	}
}

func marshalGesturePan(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGesturePan(obj), nil
}

// NewGesturePan returns a newly created Gesture that recognizes pan gestures.
func NewGesturePan(widget Widget, orientation Orientation) GesturePan {
	var _arg1 *C.GtkWidget     // out
	var _arg2 C.GtkOrientation // out
	var _cret *C.GtkGesture    // in

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (C.GtkOrientation)(orientation)

	_cret = C.gtk_gesture_pan_new(_arg1, _arg2)

	var _gesturePan GesturePan // out

	_gesturePan = WrapGesturePan(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _gesturePan
}

// Orientation returns the orientation of the pan gestures that this @gesture
// expects.
func (g gesturePan) Orientation() Orientation {
	var _arg0 *C.GtkGesturePan // out
	var _cret C.GtkOrientation // in

	_arg0 = (*C.GtkGesturePan)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_pan_get_orientation(_arg0)

	var _orientation Orientation // out

	_orientation = Orientation(_cret)

	return _orientation
}

// SetOrientation sets the orientation to be expected on pan gestures.
func (g gesturePan) SetOrientation(orientation Orientation) {
	var _arg0 *C.GtkGesturePan // out
	var _arg1 C.GtkOrientation // out

	_arg0 = (*C.GtkGesturePan)(unsafe.Pointer(g.Native()))
	_arg1 = (C.GtkOrientation)(orientation)

	C.gtk_gesture_pan_set_orientation(_arg0, _arg1)
}

// GestureRotate is a Gesture implementation able to recognize 2-finger
// rotations, whenever the angle between both handled sequences changes, the
// GestureRotate::angle-changed signal is emitted.
type GestureRotate interface {
	Gesture

	// AngleDelta: if @gesture is active, this function returns the angle
	// difference in radians since the gesture was first recognized. If @gesture
	// is not active, 0 is returned.
	AngleDelta() float64
}

// gestureRotate implements the GestureRotate class.
type gestureRotate struct {
	Gesture
}

var _ GestureRotate = (*gestureRotate)(nil)

// WrapGestureRotate wraps a GObject to the right type. It is
// primarily used internally.
func WrapGestureRotate(obj *externglib.Object) GestureRotate {
	return gestureRotate{
		Gesture: WrapGesture(obj),
	}
}

func marshalGestureRotate(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGestureRotate(obj), nil
}

// NewGestureRotate returns a newly created Gesture that recognizes 2-touch
// rotation gestures.
func NewGestureRotate(widget Widget) GestureRotate {
	var _arg1 *C.GtkWidget  // out
	var _cret *C.GtkGesture // in

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	_cret = C.gtk_gesture_rotate_new(_arg1)

	var _gestureRotate GestureRotate // out

	_gestureRotate = WrapGestureRotate(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _gestureRotate
}

// AngleDelta: if @gesture is active, this function returns the angle difference
// in radians since the gesture was first recognized. If @gesture is not active,
// 0 is returned.
func (g gestureRotate) AngleDelta() float64 {
	var _arg0 *C.GtkGestureRotate // out
	var _cret C.gdouble           // in

	_arg0 = (*C.GtkGestureRotate)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_rotate_get_angle_delta(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// GestureSingle is a subclass of Gesture, optimized (although not restricted)
// for dealing with mouse and single-touch gestures. Under interaction, these
// gestures stick to the first interacting sequence, which is accessible through
// gtk_gesture_single_get_current_sequence() while the gesture is being
// interacted with.
//
// By default gestures react to both GDK_BUTTON_PRIMARY and touch events,
// gtk_gesture_single_set_touch_only() can be used to change the touch behavior.
// Callers may also specify a different mouse button number to interact with
// through gtk_gesture_single_set_button(), or react to any mouse button by
// setting 0. While the gesture is active, the button being currently pressed
// can be known through gtk_gesture_single_get_current_button().
type GestureSingle interface {
	Gesture

	// Button returns the button number @gesture listens for, or 0 if @gesture
	// reacts to any button press.
	Button() uint
	// CurrentButton returns the button number currently interacting with
	// @gesture, or 0 if there is none.
	CurrentButton() uint
	// CurrentSequence returns the event sequence currently interacting with
	// @gesture. This is only meaningful if gtk_gesture_is_active() returns
	// true.
	CurrentSequence() *gdk.EventSequence
	// Exclusive gets whether a gesture is exclusive. For more information, see
	// gtk_gesture_single_set_exclusive().
	Exclusive() bool
	// TouchOnly returns true if the gesture is only triggered by touch events.
	TouchOnly() bool
	// SetButton sets the button number @gesture listens to. If non-0, every
	// button press from a different button number will be ignored. Touch events
	// implicitly match with button 1.
	SetButton(button uint)
	// SetExclusive sets whether @gesture is exclusive. An exclusive gesture
	// will only handle pointer and "pointer emulated" touch events, so at any
	// given time, there is only one sequence able to interact with those.
	SetExclusive(exclusive bool)
	// SetTouchOnly: if @touch_only is true, @gesture will only handle events of
	// type K_TOUCH_BEGIN, K_TOUCH_UPDATE or K_TOUCH_END. If false, mouse events
	// will be handled too.
	SetTouchOnly(touchOnly bool)
}

// gestureSingle implements the GestureSingle class.
type gestureSingle struct {
	Gesture
}

var _ GestureSingle = (*gestureSingle)(nil)

// WrapGestureSingle wraps a GObject to the right type. It is
// primarily used internally.
func WrapGestureSingle(obj *externglib.Object) GestureSingle {
	return gestureSingle{
		Gesture: WrapGesture(obj),
	}
}

func marshalGestureSingle(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGestureSingle(obj), nil
}

// Button returns the button number @gesture listens for, or 0 if @gesture
// reacts to any button press.
func (g gestureSingle) Button() uint {
	var _arg0 *C.GtkGestureSingle // out
	var _cret C.guint             // in

	_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_single_get_button(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// CurrentButton returns the button number currently interacting with @gesture,
// or 0 if there is none.
func (g gestureSingle) CurrentButton() uint {
	var _arg0 *C.GtkGestureSingle // out
	var _cret C.guint             // in

	_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_single_get_current_button(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// CurrentSequence returns the event sequence currently interacting with
// @gesture. This is only meaningful if gtk_gesture_is_active() returns true.
func (g gestureSingle) CurrentSequence() *gdk.EventSequence {
	var _arg0 *C.GtkGestureSingle // out
	var _cret *C.GdkEventSequence // in

	_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_single_get_current_sequence(_arg0)

	var _eventSequence *gdk.EventSequence // out

	_eventSequence = gdk.WrapEventSequence(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_eventSequence, func(v *gdk.EventSequence) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _eventSequence
}

// Exclusive gets whether a gesture is exclusive. For more information, see
// gtk_gesture_single_set_exclusive().
func (g gestureSingle) Exclusive() bool {
	var _arg0 *C.GtkGestureSingle // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_single_get_exclusive(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TouchOnly returns true if the gesture is only triggered by touch events.
func (g gestureSingle) TouchOnly() bool {
	var _arg0 *C.GtkGestureSingle // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_single_get_touch_only(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetButton sets the button number @gesture listens to. If non-0, every button
// press from a different button number will be ignored. Touch events implicitly
// match with button 1.
func (g gestureSingle) SetButton(button uint) {
	var _arg0 *C.GtkGestureSingle // out
	var _arg1 C.guint             // out

	_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))
	_arg1 = (C.guint)(button)

	C.gtk_gesture_single_set_button(_arg0, _arg1)
}

// SetExclusive sets whether @gesture is exclusive. An exclusive gesture will
// only handle pointer and "pointer emulated" touch events, so at any given
// time, there is only one sequence able to interact with those.
func (g gestureSingle) SetExclusive(exclusive bool) {
	var _arg0 *C.GtkGestureSingle // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))
	if exclusive {
		_arg1 = C.TRUE
	}

	C.gtk_gesture_single_set_exclusive(_arg0, _arg1)
}

// SetTouchOnly: if @touch_only is true, @gesture will only handle events of
// type K_TOUCH_BEGIN, K_TOUCH_UPDATE or K_TOUCH_END. If false, mouse events
// will be handled too.
func (g gestureSingle) SetTouchOnly(touchOnly bool) {
	var _arg0 *C.GtkGestureSingle // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))
	if touchOnly {
		_arg1 = C.TRUE
	}

	C.gtk_gesture_single_set_touch_only(_arg0, _arg1)
}

// GestureStylus is a Gesture implementation specific to stylus input. The
// provided signals just provide the basic information
type GestureStylus interface {
	GestureSingle

	// Axis returns the current value for the requested @axis. This function
	// must be called from either the GestureStylus:down, GestureStylus:motion,
	// GestureStylus:up or GestureStylus:proximity signals.
	Axis(axis gdk.AxisUse) (float64, bool)
	// DeviceTool returns the DeviceTool currently driving input through this
	// gesture. This function must be called from either the
	// GestureStylus::down, GestureStylus::motion, GestureStylus::up or
	// GestureStylus::proximity signal handlers.
	DeviceTool() gdk.DeviceTool
}

// gestureStylus implements the GestureStylus class.
type gestureStylus struct {
	GestureSingle
}

var _ GestureStylus = (*gestureStylus)(nil)

// WrapGestureStylus wraps a GObject to the right type. It is
// primarily used internally.
func WrapGestureStylus(obj *externglib.Object) GestureStylus {
	return gestureStylus{
		GestureSingle: WrapGestureSingle(obj),
	}
}

func marshalGestureStylus(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGestureStylus(obj), nil
}

// NewGestureStylus creates a new GestureStylus.
func NewGestureStylus(widget Widget) GestureStylus {
	var _arg1 *C.GtkWidget  // out
	var _cret *C.GtkGesture // in

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	_cret = C.gtk_gesture_stylus_new(_arg1)

	var _gestureStylus GestureStylus // out

	_gestureStylus = WrapGestureStylus(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _gestureStylus
}

// Axis returns the current value for the requested @axis. This function must be
// called from either the GestureStylus:down, GestureStylus:motion,
// GestureStylus:up or GestureStylus:proximity signals.
func (g gestureStylus) Axis(axis gdk.AxisUse) (float64, bool) {
	var _arg0 *C.GtkGestureStylus // out
	var _arg1 C.GdkAxisUse        // out
	var _arg2 C.gdouble           // in
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkGestureStylus)(unsafe.Pointer(g.Native()))
	_arg1 = (C.GdkAxisUse)(axis)

	_cret = C.gtk_gesture_stylus_get_axis(_arg0, _arg1, &_arg2)

	var _value float64 // out
	var _ok bool       // out

	_value = (float64)(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// DeviceTool returns the DeviceTool currently driving input through this
// gesture. This function must be called from either the GestureStylus::down,
// GestureStylus::motion, GestureStylus::up or GestureStylus::proximity signal
// handlers.
func (g gestureStylus) DeviceTool() gdk.DeviceTool {
	var _arg0 *C.GtkGestureStylus // out
	var _cret *C.GdkDeviceTool    // in

	_arg0 = (*C.GtkGestureStylus)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_stylus_get_device_tool(_arg0)

	var _deviceTool gdk.DeviceTool // out

	_deviceTool = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.DeviceTool)

	return _deviceTool
}

// GestureSwipe is a Gesture implementation able to recognize swipes, after a
// press/move/.../move/release sequence happens, the GestureSwipe::swipe signal
// will be emitted, providing the velocity and directionality of the sequence at
// the time it was lifted.
//
// If the velocity is desired in intermediate points,
// gtk_gesture_swipe_get_velocity() can be called on eg. a Gesture::update
// handler.
//
// All velocities are reported in pixels/sec units.
type GestureSwipe interface {
	GestureSingle

	// Velocity: if the gesture is recognized, this function returns true and
	// fill in @velocity_x and @velocity_y with the recorded velocity, as per
	// the last event(s) processed.
	Velocity() (velocityX float64, velocityY float64, ok bool)
}

// gestureSwipe implements the GestureSwipe class.
type gestureSwipe struct {
	GestureSingle
}

var _ GestureSwipe = (*gestureSwipe)(nil)

// WrapGestureSwipe wraps a GObject to the right type. It is
// primarily used internally.
func WrapGestureSwipe(obj *externglib.Object) GestureSwipe {
	return gestureSwipe{
		GestureSingle: WrapGestureSingle(obj),
	}
}

func marshalGestureSwipe(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGestureSwipe(obj), nil
}

// NewGestureSwipe returns a newly created Gesture that recognizes swipes.
func NewGestureSwipe(widget Widget) GestureSwipe {
	var _arg1 *C.GtkWidget  // out
	var _cret *C.GtkGesture // in

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	_cret = C.gtk_gesture_swipe_new(_arg1)

	var _gestureSwipe GestureSwipe // out

	_gestureSwipe = WrapGestureSwipe(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _gestureSwipe
}

// Velocity: if the gesture is recognized, this function returns true and fill
// in @velocity_x and @velocity_y with the recorded velocity, as per the last
// event(s) processed.
func (g gestureSwipe) Velocity() (velocityX float64, velocityY float64, ok bool) {
	var _arg0 *C.GtkGestureSwipe // out
	var _arg1 C.gdouble          // in
	var _arg2 C.gdouble          // in
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkGestureSwipe)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_swipe_get_velocity(_arg0, &_arg1, &_arg2)

	var _velocityX float64 // out
	var _velocityY float64 // out
	var _ok bool           // out

	_velocityX = (float64)(_arg1)
	_velocityY = (float64)(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _velocityX, _velocityY, _ok
}

// GestureZoom is a Gesture implementation able to recognize pinch/zoom
// gestures, whenever the distance between both tracked sequences changes, the
// GestureZoom::scale-changed signal is emitted to report the scale factor.
type GestureZoom interface {
	Gesture

	// ScaleDelta: if @gesture is active, this function returns the zooming
	// difference since the gesture was recognized (hence the starting point is
	// considered 1:1). If @gesture is not active, 1 is returned.
	ScaleDelta() float64
}

// gestureZoom implements the GestureZoom class.
type gestureZoom struct {
	Gesture
}

var _ GestureZoom = (*gestureZoom)(nil)

// WrapGestureZoom wraps a GObject to the right type. It is
// primarily used internally.
func WrapGestureZoom(obj *externglib.Object) GestureZoom {
	return gestureZoom{
		Gesture: WrapGesture(obj),
	}
}

func marshalGestureZoom(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGestureZoom(obj), nil
}

// NewGestureZoom returns a newly created Gesture that recognizes zoom in/out
// gestures (usually known as pinch/zoom).
func NewGestureZoom(widget Widget) GestureZoom {
	var _arg1 *C.GtkWidget  // out
	var _cret *C.GtkGesture // in

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	_cret = C.gtk_gesture_zoom_new(_arg1)

	var _gestureZoom GestureZoom // out

	_gestureZoom = WrapGestureZoom(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _gestureZoom
}

// ScaleDelta: if @gesture is active, this function returns the zooming
// difference since the gesture was recognized (hence the starting point is
// considered 1:1). If @gesture is not active, 1 is returned.
func (g gestureZoom) ScaleDelta() float64 {
	var _arg0 *C.GtkGestureZoom // out
	var _cret C.gdouble         // in

	_arg0 = (*C.GtkGestureZoom)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gesture_zoom_get_scale_delta(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// Grid: gtkGrid is a container which arranges its child widgets in rows and
// columns, with arbitrary positions and horizontal/vertical spans.
//
// Children are added using gtk_grid_attach(). They can span multiple rows or
// columns. It is also possible to add a child next to an existing child, using
// gtk_grid_attach_next_to(). The behaviour of GtkGrid when several children
// occupy the same grid cell is undefined.
//
// GtkGrid can be used like a Box by just using gtk_container_add(), which will
// place children next to each other in the direction determined by the
// Orientable:orientation property. However, if all you want is a single row or
// column, then Box is the preferred widget.
//
//
// CSS nodes
//
// GtkGrid uses a single CSS node with name grid.
type Grid interface {
	Container
	Buildable
	Orientable

	// Attach adds a widget to the grid.
	//
	// The position of @child is determined by @left and @top. The number of
	// “cells” that @child will occupy is determined by @width and @height.
	Attach(child Widget, left int, top int, width int, height int)
	// AttachNextTo adds a widget to the grid.
	//
	// The widget is placed next to @sibling, on the side determined by @side.
	// When @sibling is nil, the widget is placed in row (for left or right
	// placement) or column 0 (for top or bottom placement), at the end
	// indicated by @side.
	//
	// Attaching widgets labeled [1], [2], [3] with @sibling == nil and @side ==
	// GTK_POS_LEFT yields a layout of [3][2][1].
	AttachNextTo(child Widget, sibling Widget, side PositionType, width int, height int)
	// BaselineRow returns which row defines the global baseline of @grid.
	BaselineRow() int
	// ChildAt gets the child of @grid whose area covers the grid cell whose
	// upper left corner is at @left, @top.
	ChildAt(left int, top int) Widget
	// ColumnHomogeneous returns whether all columns of @grid have the same
	// width.
	ColumnHomogeneous() bool
	// ColumnSpacing returns the amount of space between the columns of @grid.
	ColumnSpacing() uint
	// RowBaselinePosition returns the baseline position of @row as set by
	// gtk_grid_set_row_baseline_position() or the default value
	// GTK_BASELINE_POSITION_CENTER.
	RowBaselinePosition(row int) BaselinePosition
	// RowHomogeneous returns whether all rows of @grid have the same height.
	RowHomogeneous() bool
	// RowSpacing returns the amount of space between the rows of @grid.
	RowSpacing() uint
	// InsertColumn inserts a column at the specified position.
	//
	// Children which are attached at or to the right of this position are moved
	// one column to the right. Children which span across this position are
	// grown to span the new column.
	InsertColumn(position int)
	// InsertNextTo inserts a row or column at the specified position.
	//
	// The new row or column is placed next to @sibling, on the side determined
	// by @side. If @side is GTK_POS_TOP or GTK_POS_BOTTOM, a row is inserted.
	// If @side is GTK_POS_LEFT of GTK_POS_RIGHT, a column is inserted.
	InsertNextTo(sibling Widget, side PositionType)
	// InsertRow inserts a row at the specified position.
	//
	// Children which are attached at or below this position are moved one row
	// down. Children which span across this position are grown to span the new
	// row.
	InsertRow(position int)
	// RemoveColumn removes a column from the grid.
	//
	// Children that are placed in this column are removed, spanning children
	// that overlap this column have their width reduced by one, and children
	// after the column are moved to the left.
	RemoveColumn(position int)
	// RemoveRow removes a row from the grid.
	//
	// Children that are placed in this row are removed, spanning children that
	// overlap this row have their height reduced by one, and children below the
	// row are moved up.
	RemoveRow(position int)
	// SetBaselineRow sets which row defines the global baseline for the entire
	// grid. Each row in the grid can have its own local baseline, but only one
	// of those is global, meaning it will be the baseline in the parent of the
	// @grid.
	SetBaselineRow(row int)
	// SetColumnHomogeneous sets whether all columns of @grid will have the same
	// width.
	SetColumnHomogeneous(homogeneous bool)
	// SetColumnSpacing sets the amount of space between columns of @grid.
	SetColumnSpacing(spacing uint)
	// SetRowBaselinePosition sets how the baseline should be positioned on @row
	// of the grid, in case that row is assigned more space than is requested.
	SetRowBaselinePosition(row int, pos BaselinePosition)
	// SetRowHomogeneous sets whether all rows of @grid will have the same
	// height.
	SetRowHomogeneous(homogeneous bool)
	// SetRowSpacing sets the amount of space between rows of @grid.
	SetRowSpacing(spacing uint)
}

// grid implements the Grid class.
type grid struct {
	Container
	Buildable
	Orientable
}

var _ Grid = (*grid)(nil)

// WrapGrid wraps a GObject to the right type. It is
// primarily used internally.
func WrapGrid(obj *externglib.Object) Grid {
	return grid{
		Container:  WrapContainer(obj),
		Buildable:  WrapBuildable(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalGrid(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGrid(obj), nil
}

// NewGrid creates a new grid widget.
func NewGrid() Grid {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_grid_new()

	var _grid Grid // out

	_grid = WrapGrid(externglib.Take(unsafe.Pointer(_cret)))

	return _grid
}

// Attach adds a widget to the grid.
//
// The position of @child is determined by @left and @top. The number of “cells”
// that @child will occupy is determined by @width and @height.
func (g grid) Attach(child Widget, left int, top int, width int, height int) {
	var _arg0 *C.GtkGrid   // out
	var _arg1 *C.GtkWidget // out
	var _arg2 C.gint       // out
	var _arg3 C.gint       // out
	var _arg4 C.gint       // out
	var _arg5 C.gint       // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (C.gint)(left)
	_arg3 = (C.gint)(top)
	_arg4 = (C.gint)(width)
	_arg5 = (C.gint)(height)

	C.gtk_grid_attach(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}

// AttachNextTo adds a widget to the grid.
//
// The widget is placed next to @sibling, on the side determined by @side. When
// @sibling is nil, the widget is placed in row (for left or right placement) or
// column 0 (for top or bottom placement), at the end indicated by @side.
//
// Attaching widgets labeled [1], [2], [3] with @sibling == nil and @side ==
// GTK_POS_LEFT yields a layout of [3][2][1].
func (g grid) AttachNextTo(child Widget, sibling Widget, side PositionType, width int, height int) {
	var _arg0 *C.GtkGrid        // out
	var _arg1 *C.GtkWidget      // out
	var _arg2 *C.GtkWidget      // out
	var _arg3 C.GtkPositionType // out
	var _arg4 C.gint            // out
	var _arg5 C.gint            // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(sibling.Native()))
	_arg3 = (C.GtkPositionType)(side)
	_arg4 = (C.gint)(width)
	_arg5 = (C.gint)(height)

	C.gtk_grid_attach_next_to(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}

// BaselineRow returns which row defines the global baseline of @grid.
func (g grid) BaselineRow() int {
	var _arg0 *C.GtkGrid // out
	var _cret C.gint     // in

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_grid_get_baseline_row(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// ChildAt gets the child of @grid whose area covers the grid cell whose upper
// left corner is at @left, @top.
func (g grid) ChildAt(left int, top int) Widget {
	var _arg0 *C.GtkGrid   // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	_arg1 = (C.gint)(left)
	_arg2 = (C.gint)(top)

	_cret = C.gtk_grid_get_child_at(_arg0, _arg1, _arg2)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// ColumnHomogeneous returns whether all columns of @grid have the same width.
func (g grid) ColumnHomogeneous() bool {
	var _arg0 *C.GtkGrid // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_grid_get_column_homogeneous(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ColumnSpacing returns the amount of space between the columns of @grid.
func (g grid) ColumnSpacing() uint {
	var _arg0 *C.GtkGrid // out
	var _cret C.guint    // in

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_grid_get_column_spacing(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// RowBaselinePosition returns the baseline position of @row as set by
// gtk_grid_set_row_baseline_position() or the default value
// GTK_BASELINE_POSITION_CENTER.
func (g grid) RowBaselinePosition(row int) BaselinePosition {
	var _arg0 *C.GtkGrid            // out
	var _arg1 C.gint                // out
	var _cret C.GtkBaselinePosition // in

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	_arg1 = (C.gint)(row)

	_cret = C.gtk_grid_get_row_baseline_position(_arg0, _arg1)

	var _baselinePosition BaselinePosition // out

	_baselinePosition = BaselinePosition(_cret)

	return _baselinePosition
}

// RowHomogeneous returns whether all rows of @grid have the same height.
func (g grid) RowHomogeneous() bool {
	var _arg0 *C.GtkGrid // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_grid_get_row_homogeneous(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RowSpacing returns the amount of space between the rows of @grid.
func (g grid) RowSpacing() uint {
	var _arg0 *C.GtkGrid // out
	var _cret C.guint    // in

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_grid_get_row_spacing(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// InsertColumn inserts a column at the specified position.
//
// Children which are attached at or to the right of this position are moved one
// column to the right. Children which span across this position are grown to
// span the new column.
func (g grid) InsertColumn(position int) {
	var _arg0 *C.GtkGrid // out
	var _arg1 C.gint     // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	_arg1 = (C.gint)(position)

	C.gtk_grid_insert_column(_arg0, _arg1)
}

// InsertNextTo inserts a row or column at the specified position.
//
// The new row or column is placed next to @sibling, on the side determined by
// @side. If @side is GTK_POS_TOP or GTK_POS_BOTTOM, a row is inserted. If @side
// is GTK_POS_LEFT of GTK_POS_RIGHT, a column is inserted.
func (g grid) InsertNextTo(sibling Widget, side PositionType) {
	var _arg0 *C.GtkGrid        // out
	var _arg1 *C.GtkWidget      // out
	var _arg2 C.GtkPositionType // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(sibling.Native()))
	_arg2 = (C.GtkPositionType)(side)

	C.gtk_grid_insert_next_to(_arg0, _arg1, _arg2)
}

// InsertRow inserts a row at the specified position.
//
// Children which are attached at or below this position are moved one row down.
// Children which span across this position are grown to span the new row.
func (g grid) InsertRow(position int) {
	var _arg0 *C.GtkGrid // out
	var _arg1 C.gint     // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	_arg1 = (C.gint)(position)

	C.gtk_grid_insert_row(_arg0, _arg1)
}

// RemoveColumn removes a column from the grid.
//
// Children that are placed in this column are removed, spanning children that
// overlap this column have their width reduced by one, and children after the
// column are moved to the left.
func (g grid) RemoveColumn(position int) {
	var _arg0 *C.GtkGrid // out
	var _arg1 C.gint     // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	_arg1 = (C.gint)(position)

	C.gtk_grid_remove_column(_arg0, _arg1)
}

// RemoveRow removes a row from the grid.
//
// Children that are placed in this row are removed, spanning children that
// overlap this row have their height reduced by one, and children below the row
// are moved up.
func (g grid) RemoveRow(position int) {
	var _arg0 *C.GtkGrid // out
	var _arg1 C.gint     // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	_arg1 = (C.gint)(position)

	C.gtk_grid_remove_row(_arg0, _arg1)
}

// SetBaselineRow sets which row defines the global baseline for the entire
// grid. Each row in the grid can have its own local baseline, but only one of
// those is global, meaning it will be the baseline in the parent of the @grid.
func (g grid) SetBaselineRow(row int) {
	var _arg0 *C.GtkGrid // out
	var _arg1 C.gint     // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	_arg1 = (C.gint)(row)

	C.gtk_grid_set_baseline_row(_arg0, _arg1)
}

// SetColumnHomogeneous sets whether all columns of @grid will have the same
// width.
func (g grid) SetColumnHomogeneous(homogeneous bool) {
	var _arg0 *C.GtkGrid // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	if homogeneous {
		_arg1 = C.TRUE
	}

	C.gtk_grid_set_column_homogeneous(_arg0, _arg1)
}

// SetColumnSpacing sets the amount of space between columns of @grid.
func (g grid) SetColumnSpacing(spacing uint) {
	var _arg0 *C.GtkGrid // out
	var _arg1 C.guint    // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	_arg1 = (C.guint)(spacing)

	C.gtk_grid_set_column_spacing(_arg0, _arg1)
}

// SetRowBaselinePosition sets how the baseline should be positioned on @row of
// the grid, in case that row is assigned more space than is requested.
func (g grid) SetRowBaselinePosition(row int, pos BaselinePosition) {
	var _arg0 *C.GtkGrid            // out
	var _arg1 C.gint                // out
	var _arg2 C.GtkBaselinePosition // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	_arg1 = (C.gint)(row)
	_arg2 = (C.GtkBaselinePosition)(pos)

	C.gtk_grid_set_row_baseline_position(_arg0, _arg1, _arg2)
}

// SetRowHomogeneous sets whether all rows of @grid will have the same height.
func (g grid) SetRowHomogeneous(homogeneous bool) {
	var _arg0 *C.GtkGrid // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	if homogeneous {
		_arg1 = C.TRUE
	}

	C.gtk_grid_set_row_homogeneous(_arg0, _arg1)
}

// SetRowSpacing sets the amount of space between rows of @grid.
func (g grid) SetRowSpacing(spacing uint) {
	var _arg0 *C.GtkGrid // out
	var _arg1 C.guint    // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	_arg1 = (C.guint)(spacing)

	C.gtk_grid_set_row_spacing(_arg0, _arg1)
}

// HBox is a container that organizes child widgets into a single row.
//
// Use the Box packing interface to determine the arrangement, spacing, width,
// and alignment of HBox children.
//
// All children are allocated the same height.
//
// GtkHBox has been deprecated. You can use Box instead, which is a very quick
// and easy change. If you have derived your own classes from GtkHBox, you can
// simply change the inheritance to derive directly from Box. No further changes
// are needed, since the default value of the Orientable:orientation property is
// GTK_ORIENTATION_HORIZONTAL.
//
// If you have a grid-like layout composed of nested boxes, and you don’t need
// first-child or last-child styling, the recommendation is to switch to Grid.
// For more information about migrating to Grid, see [Migrating from other
// containers to GtkGrid][gtk-migrating-GtkGrid].
type HBox interface {
	Box
	Buildable
	Orientable
}

// hBox implements the HBox class.
type hBox struct {
	Box
	Buildable
	Orientable
}

var _ HBox = (*hBox)(nil)

// WrapHBox wraps a GObject to the right type. It is
// primarily used internally.
func WrapHBox(obj *externglib.Object) HBox {
	return hBox{
		Box:        WrapBox(obj),
		Buildable:  WrapBuildable(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalHBox(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapHBox(obj), nil
}

// NewHBox creates a new HBox.
func NewHBox(homogeneous bool, spacing int) HBox {
	var _arg1 C.gboolean   // out
	var _arg2 C.gint       // out
	var _cret *C.GtkWidget // in

	if homogeneous {
		_arg1 = C.TRUE
	}
	_arg2 = (C.gint)(spacing)

	_cret = C.gtk_hbox_new(_arg1, _arg2)

	var _hBox HBox // out

	_hBox = WrapHBox(externglib.Take(unsafe.Pointer(_cret)))

	return _hBox
}

type HButtonBox interface {
	ButtonBox
	Buildable
	Orientable
}

// hButtonBox implements the HButtonBox class.
type hButtonBox struct {
	ButtonBox
	Buildable
	Orientable
}

var _ HButtonBox = (*hButtonBox)(nil)

// WrapHButtonBox wraps a GObject to the right type. It is
// primarily used internally.
func WrapHButtonBox(obj *externglib.Object) HButtonBox {
	return hButtonBox{
		ButtonBox:  WrapButtonBox(obj),
		Buildable:  WrapBuildable(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalHButtonBox(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapHButtonBox(obj), nil
}

// NewHButtonBox creates a new horizontal button box.
func NewHButtonBox() HButtonBox {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_hbutton_box_new()

	var _hButtonBox HButtonBox // out

	_hButtonBox = WrapHButtonBox(externglib.Take(unsafe.Pointer(_cret)))

	return _hButtonBox
}

// HPaned: the HPaned widget is a container widget with two children arranged
// horizontally. The division between the two panes is adjustable by the user by
// dragging a handle. See Paned for details.
//
// GtkHPaned has been deprecated, use Paned instead.
type HPaned interface {
	Paned
	Buildable
	Orientable
}

// hPaned implements the HPaned class.
type hPaned struct {
	Paned
	Buildable
	Orientable
}

var _ HPaned = (*hPaned)(nil)

// WrapHPaned wraps a GObject to the right type. It is
// primarily used internally.
func WrapHPaned(obj *externglib.Object) HPaned {
	return hPaned{
		Paned:      WrapPaned(obj),
		Buildable:  WrapBuildable(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalHPaned(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapHPaned(obj), nil
}

// NewHPaned: create a new HPaned
func NewHPaned() HPaned {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_hpaned_new()

	var _hPaned HPaned // out

	_hPaned = WrapHPaned(externglib.Take(unsafe.Pointer(_cret)))

	return _hPaned
}

// HSV is the “color wheel” part of a complete color selector widget. It allows
// to select a color by determining its HSV components in an intuitive way.
// Moving the selection around the outer ring changes the hue, and moving the
// selection point inside the inner triangle changes value and saturation.
//
// HSV has been deprecated together with ColorSelection, where it was used.
type HSV interface {
	Widget
	Buildable

	// Color queries the current color in an HSV color selector. Returned values
	// will be in the [0.0, 1.0] range.
	Color() (h float64, s float64, v float64)
	// Metrics queries the size and ring width of an HSV color selector.
	Metrics() (size int, ringWidth int)
	// IsAdjusting: an HSV color selector can be said to be adjusting if
	// multiple rapid changes are being made to its value, for example, when the
	// user is adjusting the value with the mouse. This function queries whether
	// the HSV color selector is being adjusted or not.
	IsAdjusting() bool
	// SetColor sets the current color in an HSV color selector. Color component
	// values must be in the [0.0, 1.0] range.
	SetColor(h float64, s float64, v float64)
	// SetMetrics sets the size and ring width of an HSV color selector.
	SetMetrics(size int, ringWidth int)
}

// hsV implements the HSV class.
type hsV struct {
	Widget
	Buildable
}

var _ HSV = (*hsV)(nil)

// WrapHSV wraps a GObject to the right type. It is
// primarily used internally.
func WrapHSV(obj *externglib.Object) HSV {
	return hsV{
		Widget:    WrapWidget(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalHSV(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapHSV(obj), nil
}

// NewHSV creates a new HSV color selector.
func NewHSV() HSV {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_hsv_new()

	var _hsV HSV // out

	_hsV = WrapHSV(externglib.Take(unsafe.Pointer(_cret)))

	return _hsV
}

// Color queries the current color in an HSV color selector. Returned values
// will be in the [0.0, 1.0] range.
func (h hsV) Color() (h float64, s float64, v float64) {
	var _arg0 *C.GtkHSV // out
	var _arg1 C.gdouble // in
	var _arg2 C.gdouble // in
	var _arg3 C.gdouble // in

	_arg0 = (*C.GtkHSV)(unsafe.Pointer(h.Native()))

	C.gtk_hsv_get_color(_arg0, &_arg1, &_arg2, &_arg3)

	var _h float64 // out
	var _s float64 // out
	var _v float64 // out

	_h = (float64)(_arg1)
	_s = (float64)(_arg2)
	_v = (float64)(_arg3)

	return _h, _s, _v
}

// Metrics queries the size and ring width of an HSV color selector.
func (h hsV) Metrics() (size int, ringWidth int) {
	var _arg0 *C.GtkHSV // out
	var _arg1 C.gint    // in
	var _arg2 C.gint    // in

	_arg0 = (*C.GtkHSV)(unsafe.Pointer(h.Native()))

	C.gtk_hsv_get_metrics(_arg0, &_arg1, &_arg2)

	var _size int      // out
	var _ringWidth int // out

	_size = (int)(_arg1)
	_ringWidth = (int)(_arg2)

	return _size, _ringWidth
}

// IsAdjusting: an HSV color selector can be said to be adjusting if multiple
// rapid changes are being made to its value, for example, when the user is
// adjusting the value with the mouse. This function queries whether the HSV
// color selector is being adjusted or not.
func (h hsV) IsAdjusting() bool {
	var _arg0 *C.GtkHSV  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkHSV)(unsafe.Pointer(h.Native()))

	_cret = C.gtk_hsv_is_adjusting(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetColor sets the current color in an HSV color selector. Color component
// values must be in the [0.0, 1.0] range.
func (h hsV) SetColor(h float64, s float64, v float64) {
	var _arg0 *C.GtkHSV // out
	var _arg1 C.double  // out
	var _arg2 C.double  // out
	var _arg3 C.double  // out

	_arg0 = (*C.GtkHSV)(unsafe.Pointer(h.Native()))
	_arg1 = (C.double)(h)
	_arg2 = (C.double)(s)
	_arg3 = (C.double)(v)

	C.gtk_hsv_set_color(_arg0, _arg1, _arg2, _arg3)
}

// SetMetrics sets the size and ring width of an HSV color selector.
func (h hsV) SetMetrics(size int, ringWidth int) {
	var _arg0 *C.GtkHSV // out
	var _arg1 C.gint    // out
	var _arg2 C.gint    // out

	_arg0 = (*C.GtkHSV)(unsafe.Pointer(h.Native()))
	_arg1 = (C.gint)(size)
	_arg2 = (C.gint)(ringWidth)

	C.gtk_hsv_set_metrics(_arg0, _arg1, _arg2)
}

// HScale: the HScale widget is used to allow the user to select a value using a
// horizontal slider. To create one, use gtk_hscale_new_with_range().
//
// The position to show the current value, and the number of decimal places
// shown can be set using the parent Scale class’s functions.
//
// GtkHScale has been deprecated, use Scale instead.
type HScale interface {
	Scale
	Buildable
	Orientable
}

// hScale implements the HScale class.
type hScale struct {
	Scale
	Buildable
	Orientable
}

var _ HScale = (*hScale)(nil)

// WrapHScale wraps a GObject to the right type. It is
// primarily used internally.
func WrapHScale(obj *externglib.Object) HScale {
	return hScale{
		Scale:      WrapScale(obj),
		Buildable:  WrapBuildable(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalHScale(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapHScale(obj), nil
}

// NewHScale creates a new HScale.
func NewHScale(adjustment Adjustment) HScale {
	var _arg1 *C.GtkAdjustment // out
	var _cret *C.GtkWidget     // in

	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	_cret = C.gtk_hscale_new(_arg1)

	var _hScale HScale // out

	_hScale = WrapHScale(externglib.Take(unsafe.Pointer(_cret)))

	return _hScale
}

// NewHScaleWithRange creates a new horizontal scale widget that lets the user
// input a number between @min and @max (including @min and @max) with the
// increment @step. @step must be nonzero; it’s the distance the slider moves
// when using the arrow keys to adjust the scale value.
//
// Note that the way in which the precision is derived works best if @step is a
// power of ten. If the resulting precision is not suitable for your needs, use
// gtk_scale_set_digits() to correct it.
func NewHScaleWithRange(min float64, max float64, step float64) HScale {
	var _arg1 C.gdouble    // out
	var _arg2 C.gdouble    // out
	var _arg3 C.gdouble    // out
	var _cret *C.GtkWidget // in

	_arg1 = (C.gdouble)(min)
	_arg2 = (C.gdouble)(max)
	_arg3 = (C.gdouble)(step)

	_cret = C.gtk_hscale_new_with_range(_arg1, _arg2, _arg3)

	var _hScale HScale // out

	_hScale = WrapHScale(externglib.Take(unsafe.Pointer(_cret)))

	return _hScale
}

// HScrollbar: the HScrollbar widget is a widget arranged horizontally creating
// a scrollbar. See Scrollbar for details on scrollbars. Adjustment pointers may
// be added to handle the adjustment of the scrollbar or it may be left nil in
// which case one will be created for you. See Scrollbar for a description of
// what the fields in an adjustment represent for a scrollbar.
//
// GtkHScrollbar has been deprecated, use Scrollbar instead.
type HScrollbar interface {
	Scrollbar
	Buildable
	Orientable
}

// hScrollbar implements the HScrollbar class.
type hScrollbar struct {
	Scrollbar
	Buildable
	Orientable
}

var _ HScrollbar = (*hScrollbar)(nil)

// WrapHScrollbar wraps a GObject to the right type. It is
// primarily used internally.
func WrapHScrollbar(obj *externglib.Object) HScrollbar {
	return hScrollbar{
		Scrollbar:  WrapScrollbar(obj),
		Buildable:  WrapBuildable(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalHScrollbar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapHScrollbar(obj), nil
}

// NewHScrollbar creates a new horizontal scrollbar.
func NewHScrollbar(adjustment Adjustment) HScrollbar {
	var _arg1 *C.GtkAdjustment // out
	var _cret *C.GtkWidget     // in

	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	_cret = C.gtk_hscrollbar_new(_arg1)

	var _hScrollbar HScrollbar // out

	_hScrollbar = WrapHScrollbar(externglib.Take(unsafe.Pointer(_cret)))

	return _hScrollbar
}

// HSeparator: the HSeparator widget is a horizontal separator, used to group
// the widgets within a window. It displays a horizontal line with a shadow to
// make it appear sunken into the interface.
//
// > The HSeparator widget is not used as a separator within menus. > To create
// a separator in a menu create an empty SeparatorMenuItem > widget using
// gtk_separator_menu_item_new() and add it to the menu with >
// gtk_menu_shell_append().
//
// GtkHSeparator has been deprecated, use Separator instead.
type HSeparator interface {
	Separator
	Buildable
	Orientable
}

// hSeparator implements the HSeparator class.
type hSeparator struct {
	Separator
	Buildable
	Orientable
}

var _ HSeparator = (*hSeparator)(nil)

// WrapHSeparator wraps a GObject to the right type. It is
// primarily used internally.
func WrapHSeparator(obj *externglib.Object) HSeparator {
	return hSeparator{
		Separator:  WrapSeparator(obj),
		Buildable:  WrapBuildable(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalHSeparator(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapHSeparator(obj), nil
}

// NewHSeparator creates a new HSeparator.
func NewHSeparator() HSeparator {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_hseparator_new()

	var _hSeparator HSeparator // out

	_hSeparator = WrapHSeparator(externglib.Take(unsafe.Pointer(_cret)))

	return _hSeparator
}

// HandleBox: the HandleBox widget allows a portion of a window to be "torn
// off". It is a bin widget which displays its child and a handle that the user
// can drag to tear off a separate window (the “float window”) containing the
// child widget. A thin “ghost” is drawn in the original location of the
// handlebox. By dragging the separate window back to its original location, it
// can be reattached.
//
// When reattaching, the ghost and float window, must be aligned along one of
// the edges, the “snap edge”. This either can be specified by the application
// programmer explicitly, or GTK+ will pick a reasonable default based on the
// handle position.
//
// To make detaching and reattaching the handlebox as minimally confusing as
// possible to the user, it is important to set the snap edge so that the snap
// edge does not move when the handlebox is deattached. For instance, if the
// handlebox is packed at the bottom of a VBox, then when the handlebox is
// detached, the bottom edge of the handlebox's allocation will remain fixed as
// the height of the handlebox shrinks, so the snap edge should be set to
// GTK_POS_BOTTOM.
//
// > HandleBox has been deprecated. It is very specialized, lacks features > to
// make it useful and most importantly does not fit well into modern >
// application design. Do not use it. There is no replacement.
type HandleBox interface {
	Bin
	Buildable

	// ChildDetached: whether the handlebox’s child is currently detached.
	ChildDetached() bool
	// HandlePosition gets the handle position of the handle box. See
	// gtk_handle_box_set_handle_position().
	HandlePosition() PositionType
	// ShadowType gets the type of shadow drawn around the handle box. See
	// gtk_handle_box_set_shadow_type().
	ShadowType() ShadowType
	// SnapEdge gets the edge used for determining reattachment of the handle
	// box. See gtk_handle_box_set_snap_edge().
	SnapEdge() PositionType
	// SetHandlePosition sets the side of the handlebox where the handle is
	// drawn.
	SetHandlePosition(position PositionType)
	// SetShadowType sets the type of shadow to be drawn around the border of
	// the handle box.
	SetShadowType(typ ShadowType)
	// SetSnapEdge sets the snap edge of a handlebox. The snap edge is the edge
	// of the detached child that must be aligned with the corresponding edge of
	// the “ghost” left behind when the child was detached to reattach the
	// torn-off window. Usually, the snap edge should be chosen so that it stays
	// in the same place on the screen when the handlebox is torn off.
	//
	// If the snap edge is not set, then an appropriate value will be guessed
	// from the handle position. If the handle position is GTK_POS_RIGHT or
	// GTK_POS_LEFT, then the snap edge will be GTK_POS_TOP, otherwise it will
	// be GTK_POS_LEFT.
	SetSnapEdge(edge PositionType)
}

// handleBox implements the HandleBox class.
type handleBox struct {
	Bin
	Buildable
}

var _ HandleBox = (*handleBox)(nil)

// WrapHandleBox wraps a GObject to the right type. It is
// primarily used internally.
func WrapHandleBox(obj *externglib.Object) HandleBox {
	return handleBox{
		Bin:       WrapBin(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalHandleBox(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapHandleBox(obj), nil
}

// NewHandleBox: create a new handle box.
func NewHandleBox() HandleBox {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_handle_box_new()

	var _handleBox HandleBox // out

	_handleBox = WrapHandleBox(externglib.Take(unsafe.Pointer(_cret)))

	return _handleBox
}

// ChildDetached: whether the handlebox’s child is currently detached.
func (h handleBox) ChildDetached() bool {
	var _arg0 *C.GtkHandleBox // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkHandleBox)(unsafe.Pointer(h.Native()))

	_cret = C.gtk_handle_box_get_child_detached(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HandlePosition gets the handle position of the handle box. See
// gtk_handle_box_set_handle_position().
func (h handleBox) HandlePosition() PositionType {
	var _arg0 *C.GtkHandleBox   // out
	var _cret C.GtkPositionType // in

	_arg0 = (*C.GtkHandleBox)(unsafe.Pointer(h.Native()))

	_cret = C.gtk_handle_box_get_handle_position(_arg0)

	var _positionType PositionType // out

	_positionType = PositionType(_cret)

	return _positionType
}

// ShadowType gets the type of shadow drawn around the handle box. See
// gtk_handle_box_set_shadow_type().
func (h handleBox) ShadowType() ShadowType {
	var _arg0 *C.GtkHandleBox // out
	var _cret C.GtkShadowType // in

	_arg0 = (*C.GtkHandleBox)(unsafe.Pointer(h.Native()))

	_cret = C.gtk_handle_box_get_shadow_type(_arg0)

	var _shadowType ShadowType // out

	_shadowType = ShadowType(_cret)

	return _shadowType
}

// SnapEdge gets the edge used for determining reattachment of the handle box.
// See gtk_handle_box_set_snap_edge().
func (h handleBox) SnapEdge() PositionType {
	var _arg0 *C.GtkHandleBox   // out
	var _cret C.GtkPositionType // in

	_arg0 = (*C.GtkHandleBox)(unsafe.Pointer(h.Native()))

	_cret = C.gtk_handle_box_get_snap_edge(_arg0)

	var _positionType PositionType // out

	_positionType = PositionType(_cret)

	return _positionType
}

// SetHandlePosition sets the side of the handlebox where the handle is drawn.
func (h handleBox) SetHandlePosition(position PositionType) {
	var _arg0 *C.GtkHandleBox   // out
	var _arg1 C.GtkPositionType // out

	_arg0 = (*C.GtkHandleBox)(unsafe.Pointer(h.Native()))
	_arg1 = (C.GtkPositionType)(position)

	C.gtk_handle_box_set_handle_position(_arg0, _arg1)
}

// SetShadowType sets the type of shadow to be drawn around the border of the
// handle box.
func (h handleBox) SetShadowType(typ ShadowType) {
	var _arg0 *C.GtkHandleBox // out
	var _arg1 C.GtkShadowType // out

	_arg0 = (*C.GtkHandleBox)(unsafe.Pointer(h.Native()))
	_arg1 = (C.GtkShadowType)(typ)

	C.gtk_handle_box_set_shadow_type(_arg0, _arg1)
}

// SetSnapEdge sets the snap edge of a handlebox. The snap edge is the edge of
// the detached child that must be aligned with the corresponding edge of the
// “ghost” left behind when the child was detached to reattach the torn-off
// window. Usually, the snap edge should be chosen so that it stays in the same
// place on the screen when the handlebox is torn off.
//
// If the snap edge is not set, then an appropriate value will be guessed from
// the handle position. If the handle position is GTK_POS_RIGHT or GTK_POS_LEFT,
// then the snap edge will be GTK_POS_TOP, otherwise it will be GTK_POS_LEFT.
func (h handleBox) SetSnapEdge(edge PositionType) {
	var _arg0 *C.GtkHandleBox   // out
	var _arg1 C.GtkPositionType // out

	_arg0 = (*C.GtkHandleBox)(unsafe.Pointer(h.Native()))
	_arg1 = (C.GtkPositionType)(edge)

	C.gtk_handle_box_set_snap_edge(_arg0, _arg1)
}

// HeaderBar: gtkHeaderBar is similar to a horizontal Box. It allows children to
// be placed at the start or the end. In addition, it allows a title and
// subtitle to be displayed. The title will be centered with respect to the
// width of the box, even if the children at either side take up different
// amounts of space. The height of the titlebar will be set to provide
// sufficient space for the subtitle, even if none is currently set. If a
// subtitle is not needed, the space reservation can be turned off with
// gtk_header_bar_set_has_subtitle().
//
// GtkHeaderBar can add typical window frame controls, such as minimize,
// maximize and close buttons, or the window icon.
//
// For these reasons, GtkHeaderBar is the natural choice for use as the custom
// titlebar widget of a Window (see gtk_window_set_titlebar()), as it gives
// features typical of titlebars while allowing the addition of child widgets.
type HeaderBar interface {
	Container
	Buildable

	// CustomTitle retrieves the custom title widget of the header. See
	// gtk_header_bar_set_custom_title().
	CustomTitle() Widget
	// DecorationLayout gets the decoration layout set with
	// gtk_header_bar_set_decoration_layout().
	DecorationLayout() string
	// HasSubtitle retrieves whether the header bar reserves space for a
	// subtitle, regardless if one is currently set or not.
	HasSubtitle() bool
	// ShowCloseButton returns whether this header bar shows the standard window
	// decorations.
	ShowCloseButton() bool
	// Subtitle retrieves the subtitle of the header. See
	// gtk_header_bar_set_subtitle().
	Subtitle() string
	// Title retrieves the title of the header. See gtk_header_bar_set_title().
	Title() string
	// PackEnd adds @child to @bar, packed with reference to the end of the
	// @bar.
	PackEnd(child Widget)
	// PackStart adds @child to @bar, packed with reference to the start of the
	// @bar.
	PackStart(child Widget)
	// SetCustomTitle sets a custom title for the HeaderBar.
	//
	// The title should help a user identify the current view. This supersedes
	// any title set by gtk_header_bar_set_title() or
	// gtk_header_bar_set_subtitle(). To achieve the same style as the builtin
	// title and subtitle, use the “title” and “subtitle” style classes.
	//
	// You should set the custom title to nil, for the header title label to be
	// visible again.
	SetCustomTitle(titleWidget Widget)
	// SetDecorationLayout sets the decoration layout for this header bar,
	// overriding the Settings:gtk-decoration-layout setting.
	//
	// There can be valid reasons for overriding the setting, such as a header
	// bar design that does not allow for buttons to take room on the right, or
	// only offers room for a single close button. Split header bars are another
	// example for overriding the setting.
	//
	// The format of the string is button names, separated by commas. A colon
	// separates the buttons that should appear on the left from those on the
	// right. Recognized button names are minimize, maximize, close, icon (the
	// window icon) and menu (a menu button for the fallback app menu).
	//
	// For example, “menu:minimize,maximize,close” specifies a menu on the left,
	// and minimize, maximize and close buttons on the right.
	SetDecorationLayout(layout string)
	// SetHasSubtitle sets whether the header bar should reserve space for a
	// subtitle, even if none is currently set.
	SetHasSubtitle(setting bool)
	// SetShowCloseButton sets whether this header bar shows the standard window
	// decorations, including close, maximize, and minimize.
	SetShowCloseButton(setting bool)
	// SetSubtitle sets the subtitle of the HeaderBar. The title should give a
	// user an additional detail to help him identify the current view.
	//
	// Note that GtkHeaderBar by default reserves room for the subtitle, even if
	// none is currently set. If this is not desired, set the
	// HeaderBar:has-subtitle property to false.
	SetSubtitle(subtitle string)
	// SetTitle sets the title of the HeaderBar. The title should help a user
	// identify the current view. A good title should not include the
	// application name.
	SetTitle(title string)
}

// headerBar implements the HeaderBar class.
type headerBar struct {
	Container
	Buildable
}

var _ HeaderBar = (*headerBar)(nil)

// WrapHeaderBar wraps a GObject to the right type. It is
// primarily used internally.
func WrapHeaderBar(obj *externglib.Object) HeaderBar {
	return headerBar{
		Container: WrapContainer(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalHeaderBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapHeaderBar(obj), nil
}

// NewHeaderBar creates a new HeaderBar widget.
func NewHeaderBar() HeaderBar {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_header_bar_new()

	var _headerBar HeaderBar // out

	_headerBar = WrapHeaderBar(externglib.Take(unsafe.Pointer(_cret)))

	return _headerBar
}

// CustomTitle retrieves the custom title widget of the header. See
// gtk_header_bar_set_custom_title().
func (b headerBar) CustomTitle() Widget {
	var _arg0 *C.GtkHeaderBar // out
	var _cret *C.GtkWidget    // in

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_header_bar_get_custom_title(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// DecorationLayout gets the decoration layout set with
// gtk_header_bar_set_decoration_layout().
func (b headerBar) DecorationLayout() string {
	var _arg0 *C.GtkHeaderBar // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_header_bar_get_decoration_layout(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// HasSubtitle retrieves whether the header bar reserves space for a subtitle,
// regardless if one is currently set or not.
func (b headerBar) HasSubtitle() bool {
	var _arg0 *C.GtkHeaderBar // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_header_bar_get_has_subtitle(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowCloseButton returns whether this header bar shows the standard window
// decorations.
func (b headerBar) ShowCloseButton() bool {
	var _arg0 *C.GtkHeaderBar // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_header_bar_get_show_close_button(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Subtitle retrieves the subtitle of the header. See
// gtk_header_bar_set_subtitle().
func (b headerBar) Subtitle() string {
	var _arg0 *C.GtkHeaderBar // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_header_bar_get_subtitle(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Title retrieves the title of the header. See gtk_header_bar_set_title().
func (b headerBar) Title() string {
	var _arg0 *C.GtkHeaderBar // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_header_bar_get_title(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// PackEnd adds @child to @bar, packed with reference to the end of the @bar.
func (b headerBar) PackEnd(child Widget) {
	var _arg0 *C.GtkHeaderBar // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_header_bar_pack_end(_arg0, _arg1)
}

// PackStart adds @child to @bar, packed with reference to the start of the
// @bar.
func (b headerBar) PackStart(child Widget) {
	var _arg0 *C.GtkHeaderBar // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_header_bar_pack_start(_arg0, _arg1)
}

// SetCustomTitle sets a custom title for the HeaderBar.
//
// The title should help a user identify the current view. This supersedes any
// title set by gtk_header_bar_set_title() or gtk_header_bar_set_subtitle(). To
// achieve the same style as the builtin title and subtitle, use the “title” and
// “subtitle” style classes.
//
// You should set the custom title to nil, for the header title label to be
// visible again.
func (b headerBar) SetCustomTitle(titleWidget Widget) {
	var _arg0 *C.GtkHeaderBar // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(titleWidget.Native()))

	C.gtk_header_bar_set_custom_title(_arg0, _arg1)
}

// SetDecorationLayout sets the decoration layout for this header bar,
// overriding the Settings:gtk-decoration-layout setting.
//
// There can be valid reasons for overriding the setting, such as a header bar
// design that does not allow for buttons to take room on the right, or only
// offers room for a single close button. Split header bars are another example
// for overriding the setting.
//
// The format of the string is button names, separated by commas. A colon
// separates the buttons that should appear on the left from those on the right.
// Recognized button names are minimize, maximize, close, icon (the window icon)
// and menu (a menu button for the fallback app menu).
//
// For example, “menu:minimize,maximize,close” specifies a menu on the left, and
// minimize, maximize and close buttons on the right.
func (b headerBar) SetDecorationLayout(layout string) {
	var _arg0 *C.GtkHeaderBar // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(layout))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_header_bar_set_decoration_layout(_arg0, _arg1)
}

// SetHasSubtitle sets whether the header bar should reserve space for a
// subtitle, even if none is currently set.
func (b headerBar) SetHasSubtitle(setting bool) {
	var _arg0 *C.GtkHeaderBar // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_header_bar_set_has_subtitle(_arg0, _arg1)
}

// SetShowCloseButton sets whether this header bar shows the standard window
// decorations, including close, maximize, and minimize.
func (b headerBar) SetShowCloseButton(setting bool) {
	var _arg0 *C.GtkHeaderBar // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_header_bar_set_show_close_button(_arg0, _arg1)
}

// SetSubtitle sets the subtitle of the HeaderBar. The title should give a user
// an additional detail to help him identify the current view.
//
// Note that GtkHeaderBar by default reserves room for the subtitle, even if
// none is currently set. If this is not desired, set the HeaderBar:has-subtitle
// property to false.
func (b headerBar) SetSubtitle(subtitle string) {
	var _arg0 *C.GtkHeaderBar // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(subtitle))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_header_bar_set_subtitle(_arg0, _arg1)
}

// SetTitle sets the title of the HeaderBar. The title should help a user
// identify the current view. A good title should not include the application
// name.
func (b headerBar) SetTitle(title string) {
	var _arg0 *C.GtkHeaderBar // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_header_bar_set_title(_arg0, _arg1)
}

type HeaderBarAccessible interface {
	ContainerAccessible
}

// headerBarAccessible implements the HeaderBarAccessible class.
type headerBarAccessible struct {
	ContainerAccessible
}

var _ HeaderBarAccessible = (*headerBarAccessible)(nil)

// WrapHeaderBarAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapHeaderBarAccessible(obj *externglib.Object) HeaderBarAccessible {
	return headerBarAccessible{
		ContainerAccessible: WrapContainerAccessible(obj),
	}
}

func marshalHeaderBarAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapHeaderBarAccessible(obj), nil
}

// IMContext defines the interface for GTK+ input methods. An input method is
// used by GTK+ text input widgets like Entry to map from key events to Unicode
// character strings.
//
// The default input method can be set programmatically via the
// Settings:gtk-im-module GtkSettings property. Alternatively, you may set the
// GTK_IM_MODULE environment variable as documented in [Running GTK+
// Applications][gtk-running].
//
// The Entry Entry:im-module and TextView TextView:im-module properties may also
// be used to set input methods for specific widget instances. For instance, a
// certain entry widget might be expected to contain certain characters which
// would be easier to input with a certain input method.
//
// An input method may consume multiple key events in sequence and finally
// output the composed result. This is called preediting, and an input method
// may provide feedback about this process by displaying the intermediate
// composition states as preedit text. For instance, the default GTK+ input
// method implements the input of arbitrary Unicode code points by holding down
// the Control and Shift keys and then typing “U” followed by the hexadecimal
// digits of the code point. When releasing the Control and Shift keys,
// preediting ends and the character is inserted as text. Ctrl+Shift+u20AC for
// example results in the € sign.
//
// Additional input methods can be made available for use by GTK+ widgets as
// loadable modules. An input method module is a small shared library which
// implements a subclass of IMContext or IMContextSimple and exports these four
// functions:
//
//    GtkIMContext * im_module_create(const gchar *context_id);
//
// This function should return a pointer to a newly created instance of the
// IMContext subclass identified by @context_id. The context ID is the same as
// specified in the IMContextInfo array returned by im_module_list().
//
// After a new loadable input method module has been installed on the system,
// the configuration file `gtk.immodules` needs to be regenerated by
// [gtk-query-immodules-3.0][gtk-query-immodules-3.0], in order for the new
// input method to become available to GTK+ applications.
type IMContext interface {
	gextras.Objector

	// DeleteSurrounding asks the widget that the input context is attached to
	// to delete characters around the cursor position by emitting the
	// GtkIMContext::delete_surrounding signal. Note that @offset and @n_chars
	// are in characters not in bytes which differs from the usage other places
	// in IMContext.
	//
	// In order to use this function, you should first call
	// gtk_im_context_get_surrounding() to get the current context, and call
	// this function immediately afterwards to make sure that you know what you
	// are deleting. You should also account for the fact that even if the
	// signal was handled, the input context might not have deleted all the
	// characters that were requested to be deleted.
	//
	// This function is used by an input method that wants to make subsitutions
	// in the existing text in response to new input. It is not useful for
	// applications.
	DeleteSurrounding(offset int, nChars int) bool
	// FilterKeypress: allow an input method to internally handle key press and
	// release events. If this function returns true, then no further processing
	// should be done for this key event.
	FilterKeypress(event *gdk.EventKey) bool
	// FocusIn: notify the input method that the widget to which this input
	// context corresponds has gained focus. The input method may, for example,
	// change the displayed feedback to reflect this change.
	FocusIn()
	// FocusOut: notify the input method that the widget to which this input
	// context corresponds has lost focus. The input method may, for example,
	// change the displayed feedback or reset the contexts state to reflect this
	// change.
	FocusOut()
	// PreeditString: retrieve the current preedit string for the input context,
	// and a list of attributes to apply to the string. This string should be
	// displayed inserted at the insertion point.
	PreeditString() (string, *pango.AttrList, int)
	// Surrounding retrieves context around the insertion point. Input methods
	// typically want context in order to constrain input text based on existing
	// text; this is important for languages such as Thai where only some
	// sequences of characters are allowed.
	//
	// This function is implemented by emitting the
	// GtkIMContext::retrieve_surrounding signal on the input method; in
	// response to this signal, a widget should provide as much context as is
	// available, up to an entire paragraph, by calling
	// gtk_im_context_set_surrounding(). Note that there is no obligation for a
	// widget to respond to the ::retrieve_surrounding signal, so input methods
	// must be prepared to function without context.
	Surrounding() (string, int, bool)
	// Reset: notify the input method that a change such as a change in cursor
	// position has been made. This will typically cause the input method to
	// clear the preedit state.
	Reset()
	// SetClientWindow: set the client window for the input context; this is the
	// Window in which the input appears. This window is used in order to
	// correctly position status windows, and may also be used for purposes
	// internal to the input method.
	SetClientWindow(window gdk.Window)
	// SetCursorLocation: notify the input method that a change in cursor
	// position has been made. The location is relative to the client window.
	SetCursorLocation(area *gdk.Rectangle)
	// SetSurrounding sets surrounding context around the insertion point and
	// preedit string. This function is expected to be called in response to the
	// GtkIMContext::retrieve_surrounding signal, and will likely have no effect
	// if called at other times.
	SetSurrounding(text string, len int, cursorIndex int)
	// SetUsePreedit sets whether the IM context should use the preedit string
	// to display feedback. If @use_preedit is FALSE (default is TRUE), then the
	// IM context may use some other method to display feedback, such as
	// displaying it in a child of the root window.
	SetUsePreedit(usePreedit bool)
}

// imContext implements the IMContext class.
type imContext struct {
	gextras.Objector
}

var _ IMContext = (*imContext)(nil)

// WrapIMContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapIMContext(obj *externglib.Object) IMContext {
	return imContext{
		Objector: obj,
	}
}

func marshalIMContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIMContext(obj), nil
}

// DeleteSurrounding asks the widget that the input context is attached to to
// delete characters around the cursor position by emitting the
// GtkIMContext::delete_surrounding signal. Note that @offset and @n_chars are
// in characters not in bytes which differs from the usage other places in
// IMContext.
//
// In order to use this function, you should first call
// gtk_im_context_get_surrounding() to get the current context, and call this
// function immediately afterwards to make sure that you know what you are
// deleting. You should also account for the fact that even if the signal was
// handled, the input context might not have deleted all the characters that
// were requested to be deleted.
//
// This function is used by an input method that wants to make subsitutions in
// the existing text in response to new input. It is not useful for
// applications.
func (c imContext) DeleteSurrounding(offset int, nChars int) bool {
	var _arg0 *C.GtkIMContext // out
	var _arg1 C.gint          // out
	var _arg2 C.gint          // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))
	_arg1 = (C.gint)(offset)
	_arg2 = (C.gint)(nChars)

	_cret = C.gtk_im_context_delete_surrounding(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FilterKeypress: allow an input method to internally handle key press and
// release events. If this function returns true, then no further processing
// should be done for this key event.
func (c imContext) FilterKeypress(event *gdk.EventKey) bool {
	var _arg0 *C.GtkIMContext // out
	var _arg1 *C.GdkEventKey  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GdkEventKey)(unsafe.Pointer(event.Native()))

	_cret = C.gtk_im_context_filter_keypress(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FocusIn: notify the input method that the widget to which this input context
// corresponds has gained focus. The input method may, for example, change the
// displayed feedback to reflect this change.
func (c imContext) FocusIn() {
	var _arg0 *C.GtkIMContext // out

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))

	C.gtk_im_context_focus_in(_arg0)
}

// FocusOut: notify the input method that the widget to which this input context
// corresponds has lost focus. The input method may, for example, change the
// displayed feedback or reset the contexts state to reflect this change.
func (c imContext) FocusOut() {
	var _arg0 *C.GtkIMContext // out

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))

	C.gtk_im_context_focus_out(_arg0)
}

// PreeditString: retrieve the current preedit string for the input context, and
// a list of attributes to apply to the string. This string should be displayed
// inserted at the insertion point.
func (c imContext) PreeditString() (string, *pango.AttrList, int) {
	var _arg0 *C.GtkIMContext // out
	var _arg1 *C.gchar        // in
	var _attrs *pango.AttrList
	var _arg3 C.gint // in

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))

	C.gtk_im_context_get_preedit_string(_arg0, &_arg1, (**C.PangoAttrList)(unsafe.Pointer(&_attrs)), &_arg3)

	var _str string // out

	var _cursorPos int // out

	_str = C.GoString(_arg1)
	defer C.free(unsafe.Pointer(_arg1))

	_cursorPos = (int)(_arg3)

	return _str, _attrs, _cursorPos
}

// Surrounding retrieves context around the insertion point. Input methods
// typically want context in order to constrain input text based on existing
// text; this is important for languages such as Thai where only some sequences
// of characters are allowed.
//
// This function is implemented by emitting the
// GtkIMContext::retrieve_surrounding signal on the input method; in response to
// this signal, a widget should provide as much context as is available, up to
// an entire paragraph, by calling gtk_im_context_set_surrounding(). Note that
// there is no obligation for a widget to respond to the ::retrieve_surrounding
// signal, so input methods must be prepared to function without context.
func (c imContext) Surrounding() (string, int, bool) {
	var _arg0 *C.GtkIMContext // out
	var _arg1 *C.gchar        // in
	var _arg2 C.gint          // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_im_context_get_surrounding(_arg0, &_arg1, &_arg2)

	var _text string     // out
	var _cursorIndex int // out
	var _ok bool         // out

	_text = C.GoString(_arg1)
	defer C.free(unsafe.Pointer(_arg1))
	_cursorIndex = (int)(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _text, _cursorIndex, _ok
}

// Reset: notify the input method that a change such as a change in cursor
// position has been made. This will typically cause the input method to clear
// the preedit state.
func (c imContext) Reset() {
	var _arg0 *C.GtkIMContext // out

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))

	C.gtk_im_context_reset(_arg0)
}

// SetClientWindow: set the client window for the input context; this is the
// Window in which the input appears. This window is used in order to correctly
// position status windows, and may also be used for purposes internal to the
// input method.
func (c imContext) SetClientWindow(window gdk.Window) {
	var _arg0 *C.GtkIMContext // out
	var _arg1 *C.GdkWindow    // out

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_im_context_set_client_window(_arg0, _arg1)
}

// SetCursorLocation: notify the input method that a change in cursor position
// has been made. The location is relative to the client window.
func (c imContext) SetCursorLocation(area *gdk.Rectangle) {
	var _arg0 *C.GtkIMContext // out
	var _arg1 *C.GdkRectangle // out

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GdkRectangle)(unsafe.Pointer(area.Native()))

	C.gtk_im_context_set_cursor_location(_arg0, _arg1)
}

// SetSurrounding sets surrounding context around the insertion point and
// preedit string. This function is expected to be called in response to the
// GtkIMContext::retrieve_surrounding signal, and will likely have no effect if
// called at other times.
func (c imContext) SetSurrounding(text string, len int, cursorIndex int) {
	var _arg0 *C.GtkIMContext // out
	var _arg1 *C.gchar        // out
	var _arg2 C.gint          // out
	var _arg3 C.gint          // out

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gint)(len)
	_arg3 = (C.gint)(cursorIndex)

	C.gtk_im_context_set_surrounding(_arg0, _arg1, _arg2, _arg3)
}

// SetUsePreedit sets whether the IM context should use the preedit string to
// display feedback. If @use_preedit is FALSE (default is TRUE), then the IM
// context may use some other method to display feedback, such as displaying it
// in a child of the root window.
func (c imContext) SetUsePreedit(usePreedit bool) {
	var _arg0 *C.GtkIMContext // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))
	if usePreedit {
		_arg1 = C.TRUE
	}

	C.gtk_im_context_set_use_preedit(_arg0, _arg1)
}

// IMContextSimple: gtkIMContextSimple is a simple input method context
// supporting table-based input methods. It has a built-in table of compose
// sequences that is derived from the X11 Compose files.
//
// GtkIMContextSimple reads additional compose sequences from the first of the
// following files that is found: ~/.config/gtk-3.0/Compose, ~/.XCompose,
// /usr/share/X11/locale/$locale/Compose (for locales that have a nontrivial
// Compose file). The syntax of these files is described in the Compose(5)
// manual page.
//
//
// Unicode characters
//
// GtkIMContextSimple also supports numeric entry of Unicode characters by
// typing Ctrl-Shift-u, followed by a hexadecimal Unicode codepoint. For
// example, Ctrl-Shift-u 1 2 3 Enter yields U+0123 LATIN SMALL LETTER G WITH
// CEDILLA, i.e. ģ.
type IMContextSimple interface {
	IMContext

	// AddComposeFile adds an additional table from the X11 compose file.
	AddComposeFile(composeFile string)
}

// imContextSimple implements the IMContextSimple class.
type imContextSimple struct {
	IMContext
}

var _ IMContextSimple = (*imContextSimple)(nil)

// WrapIMContextSimple wraps a GObject to the right type. It is
// primarily used internally.
func WrapIMContextSimple(obj *externglib.Object) IMContextSimple {
	return imContextSimple{
		IMContext: WrapIMContext(obj),
	}
}

func marshalIMContextSimple(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIMContextSimple(obj), nil
}

// NewIMContextSimple creates a new IMContextSimple.
func NewIMContextSimple() IMContextSimple {
	var _cret *C.GtkIMContext // in

	_cret = C.gtk_im_context_simple_new()

	var _imContextSimple IMContextSimple // out

	_imContextSimple = WrapIMContextSimple(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _imContextSimple
}

// AddComposeFile adds an additional table from the X11 compose file.
func (c imContextSimple) AddComposeFile(composeFile string) {
	var _arg0 *C.GtkIMContextSimple // out
	var _arg1 *C.gchar              // out

	_arg0 = (*C.GtkIMContextSimple)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(composeFile))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_im_context_simple_add_compose_file(_arg0, _arg1)
}

type IMMulticontext interface {
	IMContext

	// AppendMenuitems: add menuitems for various available input methods to a
	// menu; the menuitems, when selected, will switch the input method for the
	// context and the global default input method.
	AppendMenuitems(menushell MenuShell)
	// ContextID gets the id of the currently active slave of the @context.
	ContextID() string
	// SetContextID sets the context id for @context.
	//
	// This causes the currently active slave of @context to be replaced by the
	// slave corresponding to the new context id.
	SetContextID(contextId string)
}

// imMulticontext implements the IMMulticontext class.
type imMulticontext struct {
	IMContext
}

var _ IMMulticontext = (*imMulticontext)(nil)

// WrapIMMulticontext wraps a GObject to the right type. It is
// primarily used internally.
func WrapIMMulticontext(obj *externglib.Object) IMMulticontext {
	return imMulticontext{
		IMContext: WrapIMContext(obj),
	}
}

func marshalIMMulticontext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIMMulticontext(obj), nil
}

// NewIMMulticontext creates a new IMMulticontext.
func NewIMMulticontext() IMMulticontext {
	var _cret *C.GtkIMContext // in

	_cret = C.gtk_im_multicontext_new()

	var _imMulticontext IMMulticontext // out

	_imMulticontext = WrapIMMulticontext(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _imMulticontext
}

// AppendMenuitems: add menuitems for various available input methods to a menu;
// the menuitems, when selected, will switch the input method for the context
// and the global default input method.
func (c imMulticontext) AppendMenuitems(menushell MenuShell) {
	var _arg0 *C.GtkIMMulticontext // out
	var _arg1 *C.GtkMenuShell      // out

	_arg0 = (*C.GtkIMMulticontext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkMenuShell)(unsafe.Pointer(menushell.Native()))

	C.gtk_im_multicontext_append_menuitems(_arg0, _arg1)
}

// ContextID gets the id of the currently active slave of the @context.
func (c imMulticontext) ContextID() string {
	var _arg0 *C.GtkIMMulticontext // out
	var _cret *C.char              // in

	_arg0 = (*C.GtkIMMulticontext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_im_multicontext_get_context_id(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// SetContextID sets the context id for @context.
//
// This causes the currently active slave of @context to be replaced by the
// slave corresponding to the new context id.
func (c imMulticontext) SetContextID(contextId string) {
	var _arg0 *C.GtkIMMulticontext // out
	var _arg1 *C.char              // out

	_arg0 = (*C.GtkIMMulticontext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(contextId))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_im_multicontext_set_context_id(_arg0, _arg1)
}

// IconFactory: an icon factory manages a collection of IconSet; a IconSet
// manages a set of variants of a particular icon (i.e. a IconSet contains
// variants for different sizes and widget states). Icons in an icon factory are
// named by a stock ID, which is a simple string identifying the icon. Each
// Style has a list of IconFactory derived from the current theme; those icon
// factories are consulted first when searching for an icon. If the theme
// doesn’t set a particular icon, GTK+ looks for the icon in a list of default
// icon factories, maintained by gtk_icon_factory_add_default() and
// gtk_icon_factory_remove_default(). Applications with icons should add a
// default icon factory with their icons, which will allow themes to override
// the icons for the application.
//
// To display an icon, always use gtk_style_lookup_icon_set() on the widget that
// will display the icon, or the convenience function gtk_widget_render_icon().
// These functions take the theme into account when looking up the icon to use
// for a given stock ID.
//
//
// GtkIconFactory as GtkBuildable
//
// GtkIconFactory supports a custom <sources> element, which can contain
// multiple <source> elements. The following attributes are allowed:
//
// - stock-id
//
//    The stock id of the source, a string. This attribute is
//    mandatory
//
// - filename
//
//    The filename of the source, a string.  This attribute is
//    optional
//
// - icon-name
//
//    The icon name for the source, a string.  This attribute is
//    optional.
//
// - size
//
//    Size of the icon, a IconSize enum value.  This attribute is
//    optional.
//
// - direction
//
//    Direction of the source, a TextDirection enum value.  This
//    attribute is optional.
//
// - state
//
//    State of the source, a StateType enum value.  This
//    attribute is optional.
//
// A IconFactory UI definition fragment. ##
//
//    <object class="GtkIconFactory" id="iconfactory1">
//      <sources>
//        <source stock-id="apple-red" filename="apple-red.png"/>
//      </sources>
//    </object>
//    <object class="GtkWindow" id="window1">
//      <child>
//        <object class="GtkButton" id="apple_button">
//          <property name="label">apple-red</property>
//          <property name="use-stock">True</property>
//        </object>
//      </child>
//    </object>
type IconFactory interface {
	gextras.Objector
	Buildable

	// Add adds the given @icon_set to the icon factory, under the name
	// @stock_id. @stock_id should be namespaced for your application, e.g.
	// “myapp-whatever-icon”. Normally applications create a IconFactory, then
	// add it to the list of default factories with
	// gtk_icon_factory_add_default(). Then they pass the @stock_id to widgets
	// such as Image to display the icon. Themes can provide an icon with the
	// same name (such as "myapp-whatever-icon") to override your application’s
	// default icons. If an icon already existed in @factory for @stock_id, it
	// is unreferenced and replaced with the new @icon_set.
	Add(stockId string, iconSet *IconSet)
	// AddDefault adds an icon factory to the list of icon factories searched by
	// gtk_style_lookup_icon_set(). This means that, for example,
	// gtk_image_new_from_stock() will be able to find icons in @factory. There
	// will normally be an icon factory added for each library or application
	// that comes with icons. The default icon factories can be overridden by
	// themes.
	AddDefault()
	// Lookup looks up @stock_id in the icon factory, returning an icon set if
	// found, otherwise nil. For display to the user, you should use
	// gtk_style_lookup_icon_set() on the Style for the widget that will display
	// the icon, instead of using this function directly, so that themes are
	// taken into account.
	Lookup(stockId string) *IconSet
	// RemoveDefault removes an icon factory from the list of default icon
	// factories. Not normally used; you might use it for a library that can be
	// unloaded or shut down.
	RemoveDefault()
}

// iconFactory implements the IconFactory class.
type iconFactory struct {
	gextras.Objector
	Buildable
}

var _ IconFactory = (*iconFactory)(nil)

// WrapIconFactory wraps a GObject to the right type. It is
// primarily used internally.
func WrapIconFactory(obj *externglib.Object) IconFactory {
	return iconFactory{
		Objector:  obj,
		Buildable: WrapBuildable(obj),
	}
}

func marshalIconFactory(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIconFactory(obj), nil
}

// NewIconFactory creates a new IconFactory. An icon factory manages a
// collection of IconSets; a IconSet manages a set of variants of a particular
// icon (i.e. a IconSet contains variants for different sizes and widget
// states). Icons in an icon factory are named by a stock ID, which is a simple
// string identifying the icon. Each Style has a list of IconFactorys derived
// from the current theme; those icon factories are consulted first when
// searching for an icon. If the theme doesn’t set a particular icon, GTK+ looks
// for the icon in a list of default icon factories, maintained by
// gtk_icon_factory_add_default() and gtk_icon_factory_remove_default().
// Applications with icons should add a default icon factory with their icons,
// which will allow themes to override the icons for the application.
func NewIconFactory() IconFactory {
	var _cret *C.GtkIconFactory // in

	_cret = C.gtk_icon_factory_new()

	var _iconFactory IconFactory // out

	_iconFactory = WrapIconFactory(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _iconFactory
}

// Add adds the given @icon_set to the icon factory, under the name @stock_id.
// @stock_id should be namespaced for your application, e.g.
// “myapp-whatever-icon”. Normally applications create a IconFactory, then add
// it to the list of default factories with gtk_icon_factory_add_default(). Then
// they pass the @stock_id to widgets such as Image to display the icon. Themes
// can provide an icon with the same name (such as "myapp-whatever-icon") to
// override your application’s default icons. If an icon already existed in
// @factory for @stock_id, it is unreferenced and replaced with the new
// @icon_set.
func (f iconFactory) Add(stockId string, iconSet *IconSet) {
	var _arg0 *C.GtkIconFactory // out
	var _arg1 *C.gchar          // out
	var _arg2 *C.GtkIconSet     // out

	_arg0 = (*C.GtkIconFactory)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.gchar)(C.CString(stockId))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkIconSet)(unsafe.Pointer(iconSet.Native()))

	C.gtk_icon_factory_add(_arg0, _arg1, _arg2)
}

// AddDefault adds an icon factory to the list of icon factories searched by
// gtk_style_lookup_icon_set(). This means that, for example,
// gtk_image_new_from_stock() will be able to find icons in @factory. There will
// normally be an icon factory added for each library or application that comes
// with icons. The default icon factories can be overridden by themes.
func (f iconFactory) AddDefault() {
	var _arg0 *C.GtkIconFactory // out

	_arg0 = (*C.GtkIconFactory)(unsafe.Pointer(f.Native()))

	C.gtk_icon_factory_add_default(_arg0)
}

// Lookup looks up @stock_id in the icon factory, returning an icon set if
// found, otherwise nil. For display to the user, you should use
// gtk_style_lookup_icon_set() on the Style for the widget that will display the
// icon, instead of using this function directly, so that themes are taken into
// account.
func (f iconFactory) Lookup(stockId string) *IconSet {
	var _arg0 *C.GtkIconFactory // out
	var _arg1 *C.gchar          // out
	var _cret *C.GtkIconSet     // in

	_arg0 = (*C.GtkIconFactory)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.gchar)(C.CString(stockId))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_icon_factory_lookup(_arg0, _arg1)

	var _iconSet *IconSet // out

	_iconSet = WrapIconSet(unsafe.Pointer(_cret))

	return _iconSet
}

// RemoveDefault removes an icon factory from the list of default icon
// factories. Not normally used; you might use it for a library that can be
// unloaded or shut down.
func (f iconFactory) RemoveDefault() {
	var _arg0 *C.GtkIconFactory // out

	_arg0 = (*C.GtkIconFactory)(unsafe.Pointer(f.Native()))

	C.gtk_icon_factory_remove_default(_arg0)
}

// IconInfo contains information found when looking up an icon in an icon theme.
type IconInfo interface {
	gextras.Objector

	// AttachPoints: this function is deprecated and always returns false.
	AttachPoints() ([]gdk.Point, bool)
	// BaseScale gets the base scale for the icon. The base scale is a scale for
	// the icon that was specified by the icon theme creator. For instance an
	// icon drawn for a high-dpi screen with window scale 2 for a base size of
	// 32 will be 64 pixels tall and have a base scale of 2.
	BaseScale() int
	// BaseSize gets the base size for the icon. The base size is a size for the
	// icon that was specified by the icon theme creator. This may be different
	// than the actual size of image; an example of this is small emblem icons
	// that can be attached to a larger icon. These icons will be given the same
	// base size as the larger icons to which they are attached.
	//
	// Note that for scaled icons the base size does not include the base scale.
	BaseSize() int
	// BuiltinPixbuf gets the built-in image for this icon, if any. To allow
	// GTK+ to use built in icon images, you must pass the
	// GTK_ICON_LOOKUP_USE_BUILTIN to gtk_icon_theme_lookup_icon().
	BuiltinPixbuf() gdkpixbuf.Pixbuf
	// DisplayName: this function is deprecated and always returns nil.
	DisplayName() string
	// EmbeddedRect: this function is deprecated and always returns false.
	EmbeddedRect() (gdk.Rectangle, bool)
	// Filename gets the filename for the icon. If the
	// GTK_ICON_LOOKUP_USE_BUILTIN flag was passed to
	// gtk_icon_theme_lookup_icon(), there may be no filename if a builtin icon
	// is returned; in this case, you should use
	// gtk_icon_info_get_builtin_pixbuf().
	Filename() string
	// IsSymbolic checks if the icon is symbolic or not. This currently uses
	// only the file name and not the file contents for determining this. This
	// behaviour may change in the future.
	IsSymbolic() bool
	// LoadIcon renders an icon previously looked up in an icon theme using
	// gtk_icon_theme_lookup_icon(); the size will be based on the size passed
	// to gtk_icon_theme_lookup_icon(). Note that the resulting pixbuf may not
	// be exactly this size; an icon theme may have icons that differ slightly
	// from their nominal sizes, and in addition GTK+ will avoid scaling icons
	// that it considers sufficiently close to the requested size or for which
	// the source image would have to be scaled up too far. (This maintains
	// sharpness.). This behaviour can be changed by passing the
	// GTK_ICON_LOOKUP_FORCE_SIZE flag when obtaining the IconInfo. If this flag
	// has been specified, the pixbuf returned by this function will be scaled
	// to the exact size.
	LoadIcon() (gdkpixbuf.Pixbuf, error)
	// LoadIconFinish finishes an async icon load, see
	// gtk_icon_info_load_icon_async().
	LoadIconFinish(res gio.AsyncResult) (gdkpixbuf.Pixbuf, error)
	// LoadSurface renders an icon previously looked up in an icon theme using
	// gtk_icon_theme_lookup_icon(); the size will be based on the size passed
	// to gtk_icon_theme_lookup_icon(). Note that the resulting surface may not
	// be exactly this size; an icon theme may have icons that differ slightly
	// from their nominal sizes, and in addition GTK+ will avoid scaling icons
	// that it considers sufficiently close to the requested size or for which
	// the source image would have to be scaled up too far. (This maintains
	// sharpness.). This behaviour can be changed by passing the
	// GTK_ICON_LOOKUP_FORCE_SIZE flag when obtaining the IconInfo. If this flag
	// has been specified, the pixbuf returned by this function will be scaled
	// to the exact size.
	LoadSurface(forWindow gdk.Window) (*cairo.Surface, error)
	// LoadSymbolic loads an icon, modifying it to match the system colours for
	// the foreground, success, warning and error colors provided. If the icon
	// is not a symbolic one, the function will return the result from
	// gtk_icon_info_load_icon().
	//
	// This allows loading symbolic icons that will match the system theme.
	//
	// Unless you are implementing a widget, you will want to use
	// g_themed_icon_new_with_default_fallbacks() to load the icon.
	//
	// As implementation details, the icon loaded needs to be of SVG type,
	// contain the “symbolic” term as the last component of the icon name, and
	// use the “fg”, “success”, “warning” and “error” CSS styles in the SVG file
	// itself.
	//
	// See the Symbolic Icons Specification
	// (http://www.freedesktop.org/wiki/SymbolicIcons) for more information
	// about symbolic icons.
	LoadSymbolic(fg *gdk.RGBA, successColor *gdk.RGBA, warningColor *gdk.RGBA, errorColor *gdk.RGBA) (bool, gdkpixbuf.Pixbuf, error)
	// LoadSymbolicFinish finishes an async icon load, see
	// gtk_icon_info_load_symbolic_async().
	LoadSymbolicFinish(res gio.AsyncResult) (bool, gdkpixbuf.Pixbuf, error)
	// LoadSymbolicForContext loads an icon, modifying it to match the system
	// colors for the foreground, success, warning and error colors provided. If
	// the icon is not a symbolic one, the function will return the result from
	// gtk_icon_info_load_icon(). This function uses the regular foreground
	// color and the symbolic colors with the names “success_color”,
	// “warning_color” and “error_color” from the context.
	//
	// This allows loading symbolic icons that will match the system theme.
	//
	// See gtk_icon_info_load_symbolic() for more details.
	LoadSymbolicForContext(context StyleContext) (bool, gdkpixbuf.Pixbuf, error)
	// LoadSymbolicForContextFinish finishes an async icon load, see
	// gtk_icon_info_load_symbolic_for_context_async().
	LoadSymbolicForContextFinish(res gio.AsyncResult) (bool, gdkpixbuf.Pixbuf, error)
	// LoadSymbolicForStyle loads an icon, modifying it to match the system
	// colours for the foreground, success, warning and error colors provided.
	// If the icon is not a symbolic one, the function will return the result
	// from gtk_icon_info_load_icon().
	//
	// This allows loading symbolic icons that will match the system theme.
	//
	// See gtk_icon_info_load_symbolic() for more details.
	LoadSymbolicForStyle(style Style, state StateType) (bool, gdkpixbuf.Pixbuf, error)
	// SetRawCoordinates sets whether the coordinates returned by
	// gtk_icon_info_get_embedded_rect() and gtk_icon_info_get_attach_points()
	// should be returned in their original form as specified in the icon theme,
	// instead of scaled appropriately for the pixbuf returned by
	// gtk_icon_info_load_icon().
	//
	// Raw coordinates are somewhat strange; they are specified to be with
	// respect to the unscaled pixmap for PNG and XPM icons, but for SVG icons,
	// they are in a 1000x1000 coordinate space that is scaled to the final size
	// of the icon. You can determine if the icon is an SVG icon by using
	// gtk_icon_info_get_filename(), and seeing if it is non-nil and ends in
	// “.svg”.
	//
	// This function is provided primarily to allow compatibility wrappers for
	// older API's, and is not expected to be useful for applications.
	SetRawCoordinates(rawCoordinates bool)
}

// iconInfo implements the IconInfo class.
type iconInfo struct {
	gextras.Objector
}

var _ IconInfo = (*iconInfo)(nil)

// WrapIconInfo wraps a GObject to the right type. It is
// primarily used internally.
func WrapIconInfo(obj *externglib.Object) IconInfo {
	return iconInfo{
		Objector: obj,
	}
}

func marshalIconInfo(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIconInfo(obj), nil
}

// NewIconInfoForPixbuf creates a IconInfo for a Pixbuf.
func NewIconInfoForPixbuf(iconTheme IconTheme, pixbuf gdkpixbuf.Pixbuf) IconInfo {
	var _arg1 *C.GtkIconTheme // out
	var _arg2 *C.GdkPixbuf    // out
	var _cret *C.GtkIconInfo  // in

	_arg1 = (*C.GtkIconTheme)(unsafe.Pointer(iconTheme.Native()))
	_arg2 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	_cret = C.gtk_icon_info_new_for_pixbuf(_arg1, _arg2)

	var _iconInfo IconInfo // out

	_iconInfo = WrapIconInfo(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _iconInfo
}

// AttachPoints: this function is deprecated and always returns false.
func (i iconInfo) AttachPoints() ([]gdk.Point, bool) {
	var _arg0 *C.GtkIconInfo // out
	var _arg1 *C.GdkPoint
	var _arg2 C.gint     // in
	var _cret C.gboolean // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_info_get_attach_points(_arg0, &_arg1, &_arg2)

	var _points []gdk.Point
	var _ok bool // out

	_points = unsafe.Slice((*gdk.Point)(unsafe.Pointer(_arg1)), _arg2)
	runtime.SetFinalizer(&_points, func(v *[]gdk.Point) {
		C.free(unsafe.Pointer(&(*v)[0]))
	})
	if _cret != 0 {
		_ok = true
	}

	return _points, _ok
}

// BaseScale gets the base scale for the icon. The base scale is a scale for the
// icon that was specified by the icon theme creator. For instance an icon drawn
// for a high-dpi screen with window scale 2 for a base size of 32 will be 64
// pixels tall and have a base scale of 2.
func (i iconInfo) BaseScale() int {
	var _arg0 *C.GtkIconInfo // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_info_get_base_scale(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// BaseSize gets the base size for the icon. The base size is a size for the
// icon that was specified by the icon theme creator. This may be different than
// the actual size of image; an example of this is small emblem icons that can
// be attached to a larger icon. These icons will be given the same base size as
// the larger icons to which they are attached.
//
// Note that for scaled icons the base size does not include the base scale.
func (i iconInfo) BaseSize() int {
	var _arg0 *C.GtkIconInfo // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_info_get_base_size(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// BuiltinPixbuf gets the built-in image for this icon, if any. To allow GTK+ to
// use built in icon images, you must pass the GTK_ICON_LOOKUP_USE_BUILTIN to
// gtk_icon_theme_lookup_icon().
func (i iconInfo) BuiltinPixbuf() gdkpixbuf.Pixbuf {
	var _arg0 *C.GtkIconInfo // out
	var _cret *C.GdkPixbuf   // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_info_get_builtin_pixbuf(_arg0)

	var _pixbuf gdkpixbuf.Pixbuf // out

	_pixbuf = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

	return _pixbuf
}

// DisplayName: this function is deprecated and always returns nil.
func (i iconInfo) DisplayName() string {
	var _arg0 *C.GtkIconInfo // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_info_get_display_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// EmbeddedRect: this function is deprecated and always returns false.
func (i iconInfo) EmbeddedRect() (gdk.Rectangle, bool) {
	var _arg0 *C.GtkIconInfo // out
	var _rectangle gdk.Rectangle
	var _cret C.gboolean // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_info_get_embedded_rect(_arg0, (*C.GdkRectangle)(unsafe.Pointer(&_rectangle)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _rectangle, _ok
}

// Filename gets the filename for the icon. If the GTK_ICON_LOOKUP_USE_BUILTIN
// flag was passed to gtk_icon_theme_lookup_icon(), there may be no filename if
// a builtin icon is returned; in this case, you should use
// gtk_icon_info_get_builtin_pixbuf().
func (i iconInfo) Filename() string {
	var _arg0 *C.GtkIconInfo // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_info_get_filename(_arg0)

	var _filename string // out

	_filename = C.GoString(_cret)

	return _filename
}

// IsSymbolic checks if the icon is symbolic or not. This currently uses only
// the file name and not the file contents for determining this. This behaviour
// may change in the future.
func (i iconInfo) IsSymbolic() bool {
	var _arg0 *C.GtkIconInfo // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_info_is_symbolic(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LoadIcon renders an icon previously looked up in an icon theme using
// gtk_icon_theme_lookup_icon(); the size will be based on the size passed to
// gtk_icon_theme_lookup_icon(). Note that the resulting pixbuf may not be
// exactly this size; an icon theme may have icons that differ slightly from
// their nominal sizes, and in addition GTK+ will avoid scaling icons that it
// considers sufficiently close to the requested size or for which the source
// image would have to be scaled up too far. (This maintains sharpness.). This
// behaviour can be changed by passing the GTK_ICON_LOOKUP_FORCE_SIZE flag when
// obtaining the IconInfo. If this flag has been specified, the pixbuf returned
// by this function will be scaled to the exact size.
func (i iconInfo) LoadIcon() (gdkpixbuf.Pixbuf, error) {
	var _arg0 *C.GtkIconInfo // out
	var _cret *C.GdkPixbuf   // in
	var _cerr *C.GError      // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_info_load_icon(_arg0, &_cerr)

	var _pixbuf gdkpixbuf.Pixbuf // out
	var _goerr error             // out

	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _pixbuf, _goerr
}

// LoadIconFinish finishes an async icon load, see
// gtk_icon_info_load_icon_async().
func (i iconInfo) LoadIconFinish(res gio.AsyncResult) (gdkpixbuf.Pixbuf, error) {
	var _arg0 *C.GtkIconInfo  // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GdkPixbuf    // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.gtk_icon_info_load_icon_finish(_arg0, _arg1, &_cerr)

	var _pixbuf gdkpixbuf.Pixbuf // out
	var _goerr error             // out

	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _pixbuf, _goerr
}

// LoadSurface renders an icon previously looked up in an icon theme using
// gtk_icon_theme_lookup_icon(); the size will be based on the size passed to
// gtk_icon_theme_lookup_icon(). Note that the resulting surface may not be
// exactly this size; an icon theme may have icons that differ slightly from
// their nominal sizes, and in addition GTK+ will avoid scaling icons that it
// considers sufficiently close to the requested size or for which the source
// image would have to be scaled up too far. (This maintains sharpness.). This
// behaviour can be changed by passing the GTK_ICON_LOOKUP_FORCE_SIZE flag when
// obtaining the IconInfo. If this flag has been specified, the pixbuf returned
// by this function will be scaled to the exact size.
func (i iconInfo) LoadSurface(forWindow gdk.Window) (*cairo.Surface, error) {
	var _arg0 *C.GtkIconInfo     // out
	var _arg1 *C.GdkWindow       // out
	var _cret *C.cairo_surface_t // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GdkWindow)(unsafe.Pointer(forWindow.Native()))

	_cret = C.gtk_icon_info_load_surface(_arg0, _arg1, &_cerr)

	var _surface *cairo.Surface // out
	var _goerr error            // out

	_surface = cairo.WrapSurface(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_surface, func(v *cairo.Surface) {
		C.free(unsafe.Pointer(v.Native()))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _surface, _goerr
}

// LoadSymbolic loads an icon, modifying it to match the system colours for the
// foreground, success, warning and error colors provided. If the icon is not a
// symbolic one, the function will return the result from
// gtk_icon_info_load_icon().
//
// This allows loading symbolic icons that will match the system theme.
//
// Unless you are implementing a widget, you will want to use
// g_themed_icon_new_with_default_fallbacks() to load the icon.
//
// As implementation details, the icon loaded needs to be of SVG type, contain
// the “symbolic” term as the last component of the icon name, and use the “fg”,
// “success”, “warning” and “error” CSS styles in the SVG file itself.
//
// See the Symbolic Icons Specification
// (http://www.freedesktop.org/wiki/SymbolicIcons) for more information about
// symbolic icons.
func (i iconInfo) LoadSymbolic(fg *gdk.RGBA, successColor *gdk.RGBA, warningColor *gdk.RGBA, errorColor *gdk.RGBA) (bool, gdkpixbuf.Pixbuf, error) {
	var _arg0 *C.GtkIconInfo // out
	var _arg1 *C.GdkRGBA     // out
	var _arg2 *C.GdkRGBA     // out
	var _arg3 *C.GdkRGBA     // out
	var _arg4 *C.GdkRGBA     // out
	var _arg5 C.gboolean     // in
	var _cret *C.GdkPixbuf   // in
	var _cerr *C.GError      // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GdkRGBA)(unsafe.Pointer(fg.Native()))
	_arg2 = (*C.GdkRGBA)(unsafe.Pointer(successColor.Native()))
	_arg3 = (*C.GdkRGBA)(unsafe.Pointer(warningColor.Native()))
	_arg4 = (*C.GdkRGBA)(unsafe.Pointer(errorColor.Native()))

	_cret = C.gtk_icon_info_load_symbolic(_arg0, _arg1, _arg2, _arg3, _arg4, &_arg5, &_cerr)

	var _wasSymbolic bool        // out
	var _pixbuf gdkpixbuf.Pixbuf // out
	var _goerr error             // out

	if _arg5 {
		_wasSymbolic = true
	}
	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _wasSymbolic, _pixbuf, _goerr
}

// LoadSymbolicFinish finishes an async icon load, see
// gtk_icon_info_load_symbolic_async().
func (i iconInfo) LoadSymbolicFinish(res gio.AsyncResult) (bool, gdkpixbuf.Pixbuf, error) {
	var _arg0 *C.GtkIconInfo  // out
	var _arg1 *C.GAsyncResult // out
	var _arg2 C.gboolean      // in
	var _cret *C.GdkPixbuf    // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.gtk_icon_info_load_symbolic_finish(_arg0, _arg1, &_arg2, &_cerr)

	var _wasSymbolic bool        // out
	var _pixbuf gdkpixbuf.Pixbuf // out
	var _goerr error             // out

	if _arg2 {
		_wasSymbolic = true
	}
	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _wasSymbolic, _pixbuf, _goerr
}

// LoadSymbolicForContext loads an icon, modifying it to match the system colors
// for the foreground, success, warning and error colors provided. If the icon
// is not a symbolic one, the function will return the result from
// gtk_icon_info_load_icon(). This function uses the regular foreground color
// and the symbolic colors with the names “success_color”, “warning_color” and
// “error_color” from the context.
//
// This allows loading symbolic icons that will match the system theme.
//
// See gtk_icon_info_load_symbolic() for more details.
func (i iconInfo) LoadSymbolicForContext(context StyleContext) (bool, gdkpixbuf.Pixbuf, error) {
	var _arg0 *C.GtkIconInfo     // out
	var _arg1 *C.GtkStyleContext // out
	var _arg2 C.gboolean         // in
	var _cret *C.GdkPixbuf       // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))

	_cret = C.gtk_icon_info_load_symbolic_for_context(_arg0, _arg1, &_arg2, &_cerr)

	var _wasSymbolic bool        // out
	var _pixbuf gdkpixbuf.Pixbuf // out
	var _goerr error             // out

	if _arg2 {
		_wasSymbolic = true
	}
	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _wasSymbolic, _pixbuf, _goerr
}

// LoadSymbolicForContextFinish finishes an async icon load, see
// gtk_icon_info_load_symbolic_for_context_async().
func (i iconInfo) LoadSymbolicForContextFinish(res gio.AsyncResult) (bool, gdkpixbuf.Pixbuf, error) {
	var _arg0 *C.GtkIconInfo  // out
	var _arg1 *C.GAsyncResult // out
	var _arg2 C.gboolean      // in
	var _cret *C.GdkPixbuf    // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.gtk_icon_info_load_symbolic_for_context_finish(_arg0, _arg1, &_arg2, &_cerr)

	var _wasSymbolic bool        // out
	var _pixbuf gdkpixbuf.Pixbuf // out
	var _goerr error             // out

	if _arg2 {
		_wasSymbolic = true
	}
	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _wasSymbolic, _pixbuf, _goerr
}

// LoadSymbolicForStyle loads an icon, modifying it to match the system colours
// for the foreground, success, warning and error colors provided. If the icon
// is not a symbolic one, the function will return the result from
// gtk_icon_info_load_icon().
//
// This allows loading symbolic icons that will match the system theme.
//
// See gtk_icon_info_load_symbolic() for more details.
func (i iconInfo) LoadSymbolicForStyle(style Style, state StateType) (bool, gdkpixbuf.Pixbuf, error) {
	var _arg0 *C.GtkIconInfo // out
	var _arg1 *C.GtkStyle    // out
	var _arg2 C.GtkStateType // out
	var _arg3 C.gboolean     // in
	var _cret *C.GdkPixbuf   // in
	var _cerr *C.GError      // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
	_arg2 = (C.GtkStateType)(state)

	_cret = C.gtk_icon_info_load_symbolic_for_style(_arg0, _arg1, _arg2, &_arg3, &_cerr)

	var _wasSymbolic bool        // out
	var _pixbuf gdkpixbuf.Pixbuf // out
	var _goerr error             // out

	if _arg3 {
		_wasSymbolic = true
	}
	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _wasSymbolic, _pixbuf, _goerr
}

// SetRawCoordinates sets whether the coordinates returned by
// gtk_icon_info_get_embedded_rect() and gtk_icon_info_get_attach_points()
// should be returned in their original form as specified in the icon theme,
// instead of scaled appropriately for the pixbuf returned by
// gtk_icon_info_load_icon().
//
// Raw coordinates are somewhat strange; they are specified to be with respect
// to the unscaled pixmap for PNG and XPM icons, but for SVG icons, they are in
// a 1000x1000 coordinate space that is scaled to the final size of the icon.
// You can determine if the icon is an SVG icon by using
// gtk_icon_info_get_filename(), and seeing if it is non-nil and ends in “.svg”.
//
// This function is provided primarily to allow compatibility wrappers for older
// API's, and is not expected to be useful for applications.
func (i iconInfo) SetRawCoordinates(rawCoordinates bool) {
	var _arg0 *C.GtkIconInfo // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))
	if rawCoordinates {
		_arg1 = C.TRUE
	}

	C.gtk_icon_info_set_raw_coordinates(_arg0, _arg1)
}

// IconTheme provides a facility for looking up icons by name and size. The main
// reason for using a name rather than simply providing a filename is to allow
// different icons to be used depending on what “icon theme” is selected by the
// user. The operation of icon themes on Linux and Unix follows the Icon Theme
// Specification (http://www.freedesktop.org/Standards/icon-theme-spec) There is
// a fallback icon theme, named `hicolor`, where applications should install
// their icons, but additional icon themes can be installed as operating system
// vendors and users choose.
//
// Named icons are similar to the deprecated [Stock Items][gtkstock], and the
// distinction between the two may be a bit confusing. A few things to keep in
// mind:
//
// - Stock images usually are used in conjunction with [Stock Items][gtkstock],
// such as GTK_STOCK_OK or GTK_STOCK_OPEN. Named icons are easier to set up and
// therefore are more useful for new icons that an application wants to add,
// such as application icons or window icons.
//
// - Stock images can only be loaded at the symbolic sizes defined by the
// IconSize enumeration, or by custom sizes defined by gtk_icon_size_register(),
// while named icons are more flexible and any pixel size can be specified.
//
// - Because stock images are closely tied to stock items, and thus to actions
// in the user interface, stock images may come in multiple variants for
// different widget states or writing directions.
//
// A good rule of thumb is that if there is a stock image for what you want to
// use, use it, otherwise use a named icon. It turns out that internally stock
// images are generally defined in terms of one or more named icons. (An example
// of the more than one case is icons that depend on writing direction;
// GTK_STOCK_GO_FORWARD uses the two themed icons “gtk-stock-go-forward-ltr” and
// “gtk-stock-go-forward-rtl”.)
//
// In many cases, named themes are used indirectly, via Image or stock items,
// rather than directly, but looking up icons directly is also simple. The
// IconTheme object acts as a database of all the icons in the current theme.
// You can create new IconTheme objects, but it’s much more efficient to use the
// standard icon theme for the Screen so that the icon information is shared
// with other people looking up icons.
//
//    GError *error = NULL;
//    GtkIconTheme *icon_theme;
//    GdkPixbuf *pixbuf;
//
//    icon_theme = gtk_icon_theme_get_default ();
//    pixbuf = gtk_icon_theme_load_icon (icon_theme,
//                                       "my-icon-name", // icon name
//                                       48, // icon size
//                                       0,  // flags
//                                       &error);
//    if (!pixbuf)
//      {
//        g_warning ("Couldn’t load icon: s", error->message);
//        g_error_free (error);
//      }
//    else
//      {
//        // Use the pixbuf
//        g_object_unref (pixbuf);
//      }
type IconTheme interface {
	gextras.Objector

	// AddResourcePath adds a resource path that will be looked at when looking
	// for icons, similar to search paths.
	//
	// This function should be used to make application-specific icons available
	// as part of the icon theme.
	//
	// The resources are considered as part of the hicolor icon theme and must
	// be located in subdirectories that are defined in the hicolor icon theme,
	// such as `@path/16x16/actions/run.png`. Icons that are directly placed in
	// the resource path instead of a subdirectory are also considered as
	// ultimate fallback.
	AddResourcePath(path string)
	// AppendSearchPath appends a directory to the search path. See
	// gtk_icon_theme_set_search_path().
	AppendSearchPath(path string)
	// ChooseIcon looks up a named icon and returns a IconInfo containing
	// information such as the filename of the icon. The icon can then be
	// rendered into a pixbuf using gtk_icon_info_load_icon().
	// (gtk_icon_theme_load_icon() combines these two steps if all you need is
	// the pixbuf.)
	//
	// If @icon_names contains more than one name, this function tries them all
	// in the given order before falling back to inherited icon themes.
	ChooseIcon(iconNames []string, size int, flags IconLookupFlags) IconInfo
	// ChooseIconForScale looks up a named icon for a particular window scale
	// and returns a IconInfo containing information such as the filename of the
	// icon. The icon can then be rendered into a pixbuf using
	// gtk_icon_info_load_icon(). (gtk_icon_theme_load_icon() combines these two
	// steps if all you need is the pixbuf.)
	//
	// If @icon_names contains more than one name, this function tries them all
	// in the given order before falling back to inherited icon themes.
	ChooseIconForScale(iconNames []string, size int, scale int, flags IconLookupFlags) IconInfo
	// ExampleIconName gets the name of an icon that is representative of the
	// current theme (for instance, to use when presenting a list of themes to
	// the user.)
	ExampleIconName() string
	// IconSizes returns an array of integers describing the sizes at which the
	// icon is available without scaling. A size of -1 means that the icon is
	// available in a scalable format. The array is zero-terminated.
	IconSizes(iconName string) []int
	// SearchPath gets the current search path. See
	// gtk_icon_theme_set_search_path().
	SearchPath() []string
	// HasIcon checks whether an icon theme includes an icon for a particular
	// name.
	HasIcon(iconName string) bool
	// LoadIcon looks up an icon in an icon theme, scales it to the given size
	// and renders it into a pixbuf. This is a convenience function; if more
	// details about the icon are needed, use gtk_icon_theme_lookup_icon()
	// followed by gtk_icon_info_load_icon().
	//
	// Note that you probably want to listen for icon theme changes and update
	// the icon. This is usually done by connecting to the GtkWidget::style-set
	// signal. If for some reason you do not want to update the icon when the
	// icon theme changes, you should consider using gdk_pixbuf_copy() to make a
	// private copy of the pixbuf returned by this function. Otherwise GTK+ may
	// need to keep the old icon theme loaded, which would be a waste of memory.
	LoadIcon(iconName string, size int, flags IconLookupFlags) (gdkpixbuf.Pixbuf, error)
	// LoadIconForScale looks up an icon in an icon theme for a particular
	// window scale, scales it to the given size and renders it into a pixbuf.
	// This is a convenience function; if more details about the icon are
	// needed, use gtk_icon_theme_lookup_icon() followed by
	// gtk_icon_info_load_icon().
	//
	// Note that you probably want to listen for icon theme changes and update
	// the icon. This is usually done by connecting to the GtkWidget::style-set
	// signal. If for some reason you do not want to update the icon when the
	// icon theme changes, you should consider using gdk_pixbuf_copy() to make a
	// private copy of the pixbuf returned by this function. Otherwise GTK+ may
	// need to keep the old icon theme loaded, which would be a waste of memory.
	LoadIconForScale(iconName string, size int, scale int, flags IconLookupFlags) (gdkpixbuf.Pixbuf, error)
	// LoadSurface looks up an icon in an icon theme for a particular window
	// scale, scales it to the given size and renders it into a cairo surface.
	// This is a convenience function; if more details about the icon are
	// needed, use gtk_icon_theme_lookup_icon() followed by
	// gtk_icon_info_load_surface().
	//
	// Note that you probably want to listen for icon theme changes and update
	// the icon. This is usually done by connecting to the GtkWidget::style-set
	// signal.
	LoadSurface(iconName string, size int, scale int, forWindow gdk.Window, flags IconLookupFlags) (*cairo.Surface, error)
	// LookupByGIcon looks up an icon and returns a IconInfo containing
	// information such as the filename of the icon. The icon can then be
	// rendered into a pixbuf using gtk_icon_info_load_icon().
	//
	// When rendering on displays with high pixel densities you should not use a
	// @size multiplied by the scaling factor returned by functions like
	// gdk_window_get_scale_factor(). Instead, you should use
	// gtk_icon_theme_lookup_by_gicon_for_scale(), as the assets loaded for a
	// given scaling factor may be different.
	LookupByGIcon(icon gio.Icon, size int, flags IconLookupFlags) IconInfo
	// LookupByGIconForScale looks up an icon and returns a IconInfo containing
	// information such as the filename of the icon. The icon can then be
	// rendered into a pixbuf using gtk_icon_info_load_icon().
	LookupByGIconForScale(icon gio.Icon, size int, scale int, flags IconLookupFlags) IconInfo
	// LookupIcon looks up a named icon and returns a IconInfo containing
	// information such as the filename of the icon. The icon can then be
	// rendered into a pixbuf using gtk_icon_info_load_icon().
	// (gtk_icon_theme_load_icon() combines these two steps if all you need is
	// the pixbuf.)
	//
	// When rendering on displays with high pixel densities you should not use a
	// @size multiplied by the scaling factor returned by functions like
	// gdk_window_get_scale_factor(). Instead, you should use
	// gtk_icon_theme_lookup_icon_for_scale(), as the assets loaded for a given
	// scaling factor may be different.
	LookupIcon(iconName string, size int, flags IconLookupFlags) IconInfo
	// LookupIconForScale looks up a named icon for a particular window scale
	// and returns a IconInfo containing information such as the filename of the
	// icon. The icon can then be rendered into a pixbuf using
	// gtk_icon_info_load_icon(). (gtk_icon_theme_load_icon() combines these two
	// steps if all you need is the pixbuf.)
	LookupIconForScale(iconName string, size int, scale int, flags IconLookupFlags) IconInfo
	// PrependSearchPath prepends a directory to the search path. See
	// gtk_icon_theme_set_search_path().
	PrependSearchPath(path string)
	// RescanIfNeeded checks to see if the icon theme has changed; if it has,
	// any currently cached information is discarded and will be reloaded next
	// time @icon_theme is accessed.
	RescanIfNeeded() bool
	// SetCustomTheme sets the name of the icon theme that the IconTheme object
	// uses overriding system configuration. This function cannot be called on
	// the icon theme objects returned from gtk_icon_theme_get_default() and
	// gtk_icon_theme_get_for_screen().
	SetCustomTheme(themeName string)
	// SetScreen sets the screen for an icon theme; the screen is used to track
	// the user’s currently configured icon theme, which might be different for
	// different screens.
	SetScreen(screen gdk.Screen)
	// SetSearchPath sets the search path for the icon theme object. When
	// looking for an icon theme, GTK+ will search for a subdirectory of one or
	// more of the directories in @path with the same name as the icon theme
	// containing an index.theme file. (Themes from multiple of the path
	// elements are combined to allow themes to be extended by adding icons in
	// the user’s home directory.)
	//
	// In addition if an icon found isn’t found either in the current icon theme
	// or the default icon theme, and an image file with the right name is found
	// directly in one of the elements of @path, then that image will be used
	// for the icon name. (This is legacy feature, and new icons should be put
	// into the fallback icon theme, which is called hicolor, rather than
	// directly on the icon path.)
	SetSearchPath(path []string)
}

// iconTheme implements the IconTheme class.
type iconTheme struct {
	gextras.Objector
}

var _ IconTheme = (*iconTheme)(nil)

// WrapIconTheme wraps a GObject to the right type. It is
// primarily used internally.
func WrapIconTheme(obj *externglib.Object) IconTheme {
	return iconTheme{
		Objector: obj,
	}
}

func marshalIconTheme(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIconTheme(obj), nil
}

// NewIconTheme creates a new icon theme object. Icon theme objects are used to
// lookup up an icon by name in a particular icon theme. Usually, you’ll want to
// use gtk_icon_theme_get_default() or gtk_icon_theme_get_for_screen() rather
// than creating a new icon theme object for scratch.
func NewIconTheme() IconTheme {
	var _cret *C.GtkIconTheme // in

	_cret = C.gtk_icon_theme_new()

	var _iconTheme IconTheme // out

	_iconTheme = WrapIconTheme(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _iconTheme
}

// AddResourcePath adds a resource path that will be looked at when looking for
// icons, similar to search paths.
//
// This function should be used to make application-specific icons available as
// part of the icon theme.
//
// The resources are considered as part of the hicolor icon theme and must be
// located in subdirectories that are defined in the hicolor icon theme, such as
// `@path/16x16/actions/run.png`. Icons that are directly placed in the resource
// path instead of a subdirectory are also considered as ultimate fallback.
func (i iconTheme) AddResourcePath(path string) {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_icon_theme_add_resource_path(_arg0, _arg1)
}

// AppendSearchPath appends a directory to the search path. See
// gtk_icon_theme_set_search_path().
func (i iconTheme) AppendSearchPath(path string) {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_icon_theme_append_search_path(_arg0, _arg1)
}

// ChooseIcon looks up a named icon and returns a IconInfo containing
// information such as the filename of the icon. The icon can then be rendered
// into a pixbuf using gtk_icon_info_load_icon(). (gtk_icon_theme_load_icon()
// combines these two steps if all you need is the pixbuf.)
//
// If @icon_names contains more than one name, this function tries them all in
// the given order before falling back to inherited icon themes.
func (i iconTheme) ChooseIcon(iconNames []string, size int, flags IconLookupFlags) IconInfo {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 **C.gchar
	var _arg2 C.gint               // out
	var _arg3 C.GtkIconLookupFlags // out
	var _cret *C.GtkIconInfo       // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(iconNames)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(iconNames))
		for i := range iconNames {
			out[i] = (*C.gchar)(C.CString(iconNames[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}
	_arg2 = (C.gint)(size)
	_arg3 = (C.GtkIconLookupFlags)(flags)

	_cret = C.gtk_icon_theme_choose_icon(_arg0, _arg1, _arg2, _arg3)

	var _iconInfo IconInfo // out

	_iconInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(IconInfo)

	return _iconInfo
}

// ChooseIconForScale looks up a named icon for a particular window scale and
// returns a IconInfo containing information such as the filename of the icon.
// The icon can then be rendered into a pixbuf using gtk_icon_info_load_icon().
// (gtk_icon_theme_load_icon() combines these two steps if all you need is the
// pixbuf.)
//
// If @icon_names contains more than one name, this function tries them all in
// the given order before falling back to inherited icon themes.
func (i iconTheme) ChooseIconForScale(iconNames []string, size int, scale int, flags IconLookupFlags) IconInfo {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 **C.gchar
	var _arg2 C.gint               // out
	var _arg3 C.gint               // out
	var _arg4 C.GtkIconLookupFlags // out
	var _cret *C.GtkIconInfo       // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(iconNames)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(iconNames))
		for i := range iconNames {
			out[i] = (*C.gchar)(C.CString(iconNames[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}
	_arg2 = (C.gint)(size)
	_arg3 = (C.gint)(scale)
	_arg4 = (C.GtkIconLookupFlags)(flags)

	_cret = C.gtk_icon_theme_choose_icon_for_scale(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _iconInfo IconInfo // out

	_iconInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(IconInfo)

	return _iconInfo
}

// ExampleIconName gets the name of an icon that is representative of the
// current theme (for instance, to use when presenting a list of themes to the
// user.)
func (i iconTheme) ExampleIconName() string {
	var _arg0 *C.GtkIconTheme // out
	var _cret *C.char         // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_theme_get_example_icon_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// IconSizes returns an array of integers describing the sizes at which the icon
// is available without scaling. A size of -1 means that the icon is available
// in a scalable format. The array is zero-terminated.
func (i iconTheme) IconSizes(iconName string) []int {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.gchar        // out
	var _cret *C.gint

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_icon_theme_get_icon_sizes(_arg0, _arg1)

	var _gints []int

	{
		var i int
		var z C.gint
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_gints = make([]int, i)
		for i := range src {
			_gints[i] = (int)(src[i])
		}
	}

	return _gints
}

// SearchPath gets the current search path. See
// gtk_icon_theme_set_search_path().
func (i iconTheme) SearchPath() []string {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 **C.gchar
	var _arg2 C.gint // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))

	C.gtk_icon_theme_get_search_path(_arg0, &_arg1, &_arg2)

	var _path []string

	{
		src := unsafe.Slice(_arg1, _arg2)
		defer C.free(unsafe.Pointer(_arg1))
		_path = make([]string, _arg2)
		for i := 0; i < int(_arg2); i++ {
			_path[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _path
}

// HasIcon checks whether an icon theme includes an icon for a particular name.
func (i iconTheme) HasIcon(iconName string) bool {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_icon_theme_has_icon(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LoadIcon looks up an icon in an icon theme, scales it to the given size and
// renders it into a pixbuf. This is a convenience function; if more details
// about the icon are needed, use gtk_icon_theme_lookup_icon() followed by
// gtk_icon_info_load_icon().
//
// Note that you probably want to listen for icon theme changes and update the
// icon. This is usually done by connecting to the GtkWidget::style-set signal.
// If for some reason you do not want to update the icon when the icon theme
// changes, you should consider using gdk_pixbuf_copy() to make a private copy
// of the pixbuf returned by this function. Otherwise GTK+ may need to keep the
// old icon theme loaded, which would be a waste of memory.
func (i iconTheme) LoadIcon(iconName string, size int, flags IconLookupFlags) (gdkpixbuf.Pixbuf, error) {
	var _arg0 *C.GtkIconTheme      // out
	var _arg1 *C.gchar             // out
	var _arg2 C.gint               // out
	var _arg3 C.GtkIconLookupFlags // out
	var _cret *C.GdkPixbuf         // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gint)(size)
	_arg3 = (C.GtkIconLookupFlags)(flags)

	_cret = C.gtk_icon_theme_load_icon(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _pixbuf gdkpixbuf.Pixbuf // out
	var _goerr error             // out

	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _pixbuf, _goerr
}

// LoadIconForScale looks up an icon in an icon theme for a particular window
// scale, scales it to the given size and renders it into a pixbuf. This is a
// convenience function; if more details about the icon are needed, use
// gtk_icon_theme_lookup_icon() followed by gtk_icon_info_load_icon().
//
// Note that you probably want to listen for icon theme changes and update the
// icon. This is usually done by connecting to the GtkWidget::style-set signal.
// If for some reason you do not want to update the icon when the icon theme
// changes, you should consider using gdk_pixbuf_copy() to make a private copy
// of the pixbuf returned by this function. Otherwise GTK+ may need to keep the
// old icon theme loaded, which would be a waste of memory.
func (i iconTheme) LoadIconForScale(iconName string, size int, scale int, flags IconLookupFlags) (gdkpixbuf.Pixbuf, error) {
	var _arg0 *C.GtkIconTheme      // out
	var _arg1 *C.gchar             // out
	var _arg2 C.gint               // out
	var _arg3 C.gint               // out
	var _arg4 C.GtkIconLookupFlags // out
	var _cret *C.GdkPixbuf         // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gint)(size)
	_arg3 = (C.gint)(scale)
	_arg4 = (C.GtkIconLookupFlags)(flags)

	_cret = C.gtk_icon_theme_load_icon_for_scale(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)

	var _pixbuf gdkpixbuf.Pixbuf // out
	var _goerr error             // out

	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _pixbuf, _goerr
}

// LoadSurface looks up an icon in an icon theme for a particular window scale,
// scales it to the given size and renders it into a cairo surface. This is a
// convenience function; if more details about the icon are needed, use
// gtk_icon_theme_lookup_icon() followed by gtk_icon_info_load_surface().
//
// Note that you probably want to listen for icon theme changes and update the
// icon. This is usually done by connecting to the GtkWidget::style-set signal.
func (i iconTheme) LoadSurface(iconName string, size int, scale int, forWindow gdk.Window, flags IconLookupFlags) (*cairo.Surface, error) {
	var _arg0 *C.GtkIconTheme      // out
	var _arg1 *C.gchar             // out
	var _arg2 C.gint               // out
	var _arg3 C.gint               // out
	var _arg4 *C.GdkWindow         // out
	var _arg5 C.GtkIconLookupFlags // out
	var _cret *C.cairo_surface_t   // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gint)(size)
	_arg3 = (C.gint)(scale)
	_arg4 = (*C.GdkWindow)(unsafe.Pointer(forWindow.Native()))
	_arg5 = (C.GtkIconLookupFlags)(flags)

	_cret = C.gtk_icon_theme_load_surface(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _surface *cairo.Surface // out
	var _goerr error            // out

	_surface = cairo.WrapSurface(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_surface, func(v *cairo.Surface) {
		C.free(unsafe.Pointer(v.Native()))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _surface, _goerr
}

// LookupByGIcon looks up an icon and returns a IconInfo containing information
// such as the filename of the icon. The icon can then be rendered into a pixbuf
// using gtk_icon_info_load_icon().
//
// When rendering on displays with high pixel densities you should not use a
// @size multiplied by the scaling factor returned by functions like
// gdk_window_get_scale_factor(). Instead, you should use
// gtk_icon_theme_lookup_by_gicon_for_scale(), as the assets loaded for a given
// scaling factor may be different.
func (i iconTheme) LookupByGIcon(icon gio.Icon, size int, flags IconLookupFlags) IconInfo {
	var _arg0 *C.GtkIconTheme      // out
	var _arg1 *C.GIcon             // out
	var _arg2 C.gint               // out
	var _arg3 C.GtkIconLookupFlags // out
	var _cret *C.GtkIconInfo       // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))
	_arg2 = (C.gint)(size)
	_arg3 = (C.GtkIconLookupFlags)(flags)

	_cret = C.gtk_icon_theme_lookup_by_gicon(_arg0, _arg1, _arg2, _arg3)

	var _iconInfo IconInfo // out

	_iconInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(IconInfo)

	return _iconInfo
}

// LookupByGIconForScale looks up an icon and returns a IconInfo containing
// information such as the filename of the icon. The icon can then be rendered
// into a pixbuf using gtk_icon_info_load_icon().
func (i iconTheme) LookupByGIconForScale(icon gio.Icon, size int, scale int, flags IconLookupFlags) IconInfo {
	var _arg0 *C.GtkIconTheme      // out
	var _arg1 *C.GIcon             // out
	var _arg2 C.gint               // out
	var _arg3 C.gint               // out
	var _arg4 C.GtkIconLookupFlags // out
	var _cret *C.GtkIconInfo       // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))
	_arg2 = (C.gint)(size)
	_arg3 = (C.gint)(scale)
	_arg4 = (C.GtkIconLookupFlags)(flags)

	_cret = C.gtk_icon_theme_lookup_by_gicon_for_scale(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _iconInfo IconInfo // out

	_iconInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(IconInfo)

	return _iconInfo
}

// LookupIcon looks up a named icon and returns a IconInfo containing
// information such as the filename of the icon. The icon can then be rendered
// into a pixbuf using gtk_icon_info_load_icon(). (gtk_icon_theme_load_icon()
// combines these two steps if all you need is the pixbuf.)
//
// When rendering on displays with high pixel densities you should not use a
// @size multiplied by the scaling factor returned by functions like
// gdk_window_get_scale_factor(). Instead, you should use
// gtk_icon_theme_lookup_icon_for_scale(), as the assets loaded for a given
// scaling factor may be different.
func (i iconTheme) LookupIcon(iconName string, size int, flags IconLookupFlags) IconInfo {
	var _arg0 *C.GtkIconTheme      // out
	var _arg1 *C.gchar             // out
	var _arg2 C.gint               // out
	var _arg3 C.GtkIconLookupFlags // out
	var _cret *C.GtkIconInfo       // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gint)(size)
	_arg3 = (C.GtkIconLookupFlags)(flags)

	_cret = C.gtk_icon_theme_lookup_icon(_arg0, _arg1, _arg2, _arg3)

	var _iconInfo IconInfo // out

	_iconInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(IconInfo)

	return _iconInfo
}

// LookupIconForScale looks up a named icon for a particular window scale and
// returns a IconInfo containing information such as the filename of the icon.
// The icon can then be rendered into a pixbuf using gtk_icon_info_load_icon().
// (gtk_icon_theme_load_icon() combines these two steps if all you need is the
// pixbuf.)
func (i iconTheme) LookupIconForScale(iconName string, size int, scale int, flags IconLookupFlags) IconInfo {
	var _arg0 *C.GtkIconTheme      // out
	var _arg1 *C.gchar             // out
	var _arg2 C.gint               // out
	var _arg3 C.gint               // out
	var _arg4 C.GtkIconLookupFlags // out
	var _cret *C.GtkIconInfo       // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gint)(size)
	_arg3 = (C.gint)(scale)
	_arg4 = (C.GtkIconLookupFlags)(flags)

	_cret = C.gtk_icon_theme_lookup_icon_for_scale(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _iconInfo IconInfo // out

	_iconInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(IconInfo)

	return _iconInfo
}

// PrependSearchPath prepends a directory to the search path. See
// gtk_icon_theme_set_search_path().
func (i iconTheme) PrependSearchPath(path string) {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_icon_theme_prepend_search_path(_arg0, _arg1)
}

// RescanIfNeeded checks to see if the icon theme has changed; if it has, any
// currently cached information is discarded and will be reloaded next time
// @icon_theme is accessed.
func (i iconTheme) RescanIfNeeded() bool {
	var _arg0 *C.GtkIconTheme // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_theme_rescan_if_needed(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetCustomTheme sets the name of the icon theme that the IconTheme object uses
// overriding system configuration. This function cannot be called on the icon
// theme objects returned from gtk_icon_theme_get_default() and
// gtk_icon_theme_get_for_screen().
func (i iconTheme) SetCustomTheme(themeName string) {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(themeName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_icon_theme_set_custom_theme(_arg0, _arg1)
}

// SetScreen sets the screen for an icon theme; the screen is used to track the
// user’s currently configured icon theme, which might be different for
// different screens.
func (i iconTheme) SetScreen(screen gdk.Screen) {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.GdkScreen    // out

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GdkScreen)(unsafe.Pointer(screen.Native()))

	C.gtk_icon_theme_set_screen(_arg0, _arg1)
}

// SetSearchPath sets the search path for the icon theme object. When looking
// for an icon theme, GTK+ will search for a subdirectory of one or more of the
// directories in @path with the same name as the icon theme containing an
// index.theme file. (Themes from multiple of the path elements are combined to
// allow themes to be extended by adding icons in the user’s home directory.)
//
// In addition if an icon found isn’t found either in the current icon theme or
// the default icon theme, and an image file with the right name is found
// directly in one of the elements of @path, then that image will be used for
// the icon name. (This is legacy feature, and new icons should be put into the
// fallback icon theme, which is called hicolor, rather than directly on the
// icon path.)
func (i iconTheme) SetSearchPath(path []string) {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 **C.gchar
	var _arg2 C.gint

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
	_arg2 = C.gint(len(path))
	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(path)) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(path))
		for i := range path {
			out[i] = (*C.gchar)(C.CString(path[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.gtk_icon_theme_set_search_path(_arg0, _arg1, _arg2)
}

// IconView provides an alternative view on a TreeModel. It displays the model
// as a grid of icons with labels. Like TreeView, it allows to select one or
// multiple items (depending on the selection mode, see
// gtk_icon_view_set_selection_mode()). In addition to selection with the arrow
// keys, IconView supports rubberband selection, which is controlled by dragging
// the pointer.
//
// Note that if the tree model is backed by an actual tree store (as opposed to
// a flat list where the mapping to icons is obvious), IconView will only
// display the first level of the tree and ignore the tree’s branches.
//
// CSS nodes
//
//    iconview.view
//    ╰── [rubberband]
//
// GtkIconView has a single CSS node with name iconview and style class .view.
// For rubberband selection, a subnode with name rubberband is used.
type IconView interface {
	Container
	Buildable
	CellLayout
	Scrollable

	// ConvertWidgetToBinWindowCoords converts widget coordinates to coordinates
	// for the bin_window, as expected by e.g. gtk_icon_view_get_path_at_pos().
	ConvertWidgetToBinWindowCoords(wx int, wy int) (bx int, by int)
	// CreateDragIcon creates a #cairo_surface_t representation of the item at
	// @path. This image is used for a drag icon.
	CreateDragIcon(path *TreePath) *cairo.Surface
	// EnableModelDragDest turns @icon_view into a drop destination for
	// automatic DND. Calling this method sets IconView:reorderable to false.
	EnableModelDragDest(targets []TargetEntry, actions gdk.DragAction)
	// EnableModelDragSource turns @icon_view into a drag source for automatic
	// DND. Calling this method sets IconView:reorderable to false.
	EnableModelDragSource(startButtonMask gdk.ModifierType, targets []TargetEntry, actions gdk.DragAction)
	// ActivateOnSingleClick gets the setting set by
	// gtk_icon_view_set_activate_on_single_click().
	ActivateOnSingleClick() bool
	// CellRect fills the bounding rectangle in widget coordinates for the cell
	// specified by @path and @cell. If @cell is nil the main cell area is used.
	//
	// This function is only valid if @icon_view is realized.
	CellRect(path *TreePath, cell CellRenderer) (gdk.Rectangle, bool)
	// ColumnSpacing returns the value of the ::column-spacing property.
	ColumnSpacing() int
	// Columns returns the value of the ::columns property.
	Columns() int
	// Cursor fills in @path and @cell with the current cursor path and cell. If
	// the cursor isn’t currently set, then *@path will be nil. If no cell
	// currently has focus, then *@cell will be nil.
	//
	// The returned TreePath must be freed with gtk_tree_path_free().
	Cursor() (*TreePath, CellRenderer, bool)
	// DestItemAtPos determines the destination item for a given position.
	DestItemAtPos(dragX int, dragY int) (*TreePath, IconViewDropPosition, bool)
	// DragDestItem gets information about the item that is highlighted for
	// feedback.
	DragDestItem() (*TreePath, IconViewDropPosition)
	// ItemAtPos finds the path at the point (@x, @y), relative to bin_window
	// coordinates. In contrast to gtk_icon_view_get_path_at_pos(), this
	// function also obtains the cell at the specified position. The returned
	// path should be freed with gtk_tree_path_free(). See
	// gtk_icon_view_convert_widget_to_bin_window_coords() for converting widget
	// coordinates to bin_window coordinates.
	ItemAtPos(x int, y int) (*TreePath, CellRenderer, bool)
	// ItemColumn gets the column in which the item @path is currently
	// displayed. Column numbers start at 0.
	ItemColumn(path *TreePath) int
	// ItemOrientation returns the value of the ::item-orientation property
	// which determines whether the labels are drawn beside the icons instead of
	// below.
	ItemOrientation() Orientation
	// ItemPadding returns the value of the ::item-padding property.
	ItemPadding() int
	// ItemRow gets the row in which the item @path is currently displayed. Row
	// numbers start at 0.
	ItemRow(path *TreePath) int
	// ItemWidth returns the value of the ::item-width property.
	ItemWidth() int
	// Margin returns the value of the ::margin property.
	Margin() int
	// MarkupColumn returns the column with markup text for @icon_view.
	MarkupColumn() int
	// Model returns the model the IconView is based on. Returns nil if the
	// model is unset.
	Model() TreeModel
	// PathAtPos finds the path at the point (@x, @y), relative to bin_window
	// coordinates. See gtk_icon_view_get_item_at_pos(), if you are also
	// interested in the cell at the specified position. See
	// gtk_icon_view_convert_widget_to_bin_window_coords() for converting widget
	// coordinates to bin_window coordinates.
	PathAtPos(x int, y int) *TreePath
	// PixbufColumn returns the column with pixbufs for @icon_view.
	PixbufColumn() int
	// Reorderable retrieves whether the user can reorder the list via
	// drag-and-drop. See gtk_icon_view_set_reorderable().
	Reorderable() bool
	// RowSpacing returns the value of the ::row-spacing property.
	RowSpacing() int
	// SelectionMode gets the selection mode of the @icon_view.
	SelectionMode() SelectionMode
	// Spacing returns the value of the ::spacing property.
	Spacing() int
	// TextColumn returns the column with text for @icon_view.
	TextColumn() int
	// TooltipColumn returns the column of @icon_view’s model which is being
	// used for displaying tooltips on @icon_view’s rows.
	TooltipColumn() int
	// VisibleRange sets @start_path and @end_path to be the first and last
	// visible path. Note that there may be invisible paths in between.
	//
	// Both paths should be freed with gtk_tree_path_free() after use.
	VisibleRange() (startPath *TreePath, endPath *TreePath, ok bool)
	// ItemActivated activates the item determined by @path.
	ItemActivated(path *TreePath)
	// PathIsSelected returns true if the icon pointed to by @path is currently
	// selected. If @path does not point to a valid location, false is returned.
	PathIsSelected(path *TreePath) bool
	// ScrollToPath moves the alignments of @icon_view to the position specified
	// by @path. @row_align determines where the row is placed, and @col_align
	// determines where @column is placed. Both are expected to be between 0.0
	// and 1.0. 0.0 means left/top alignment, 1.0 means right/bottom alignment,
	// 0.5 means center.
	//
	// If @use_align is false, then the alignment arguments are ignored, and the
	// tree does the minimum amount of work to scroll the item onto the screen.
	// This means that the item will be scrolled to the edge closest to its
	// current position. If the item is currently visible on the screen, nothing
	// is done.
	//
	// This function only works if the model is set, and @path is a valid row on
	// the model. If the model changes before the @icon_view is realized, the
	// centered path will be modified to reflect this change.
	ScrollToPath(path *TreePath, useAlign bool, rowAlign float32, colAlign float32)
	// SelectAll selects all the icons. @icon_view must has its selection mode
	// set to K_SELECTION_MULTIPLE.
	SelectAll()
	// SelectPath selects the row at @path.
	SelectPath(path *TreePath)
	// SetActivateOnSingleClick causes the IconView::item-activated signal to be
	// emitted on a single click instead of a double click.
	SetActivateOnSingleClick(single bool)
	// SetColumnSpacing sets the ::column-spacing property which specifies the
	// space which is inserted between the columns of the icon view.
	SetColumnSpacing(columnSpacing int)
	// SetColumns sets the ::columns property which determines in how many
	// columns the icons are arranged. If @columns is -1, the number of columns
	// will be chosen automatically to fill the available area.
	SetColumns(columns int)
	// SetCursor sets the current keyboard focus to be at @path, and selects it.
	// This is useful when you want to focus the user’s attention on a
	// particular item. If @cell is not nil, then focus is given to the cell
	// specified by it. Additionally, if @start_editing is true, then editing
	// should be started in the specified cell.
	//
	// This function is often followed by `gtk_widget_grab_focus (icon_view)` in
	// order to give keyboard focus to the widget. Please note that editing can
	// only happen when the widget is realized.
	SetCursor(path *TreePath, cell CellRenderer, startEditing bool)
	// SetDragDestItem sets the item that is highlighted for feedback.
	SetDragDestItem(path *TreePath, pos IconViewDropPosition)
	// SetItemOrientation sets the ::item-orientation property which determines
	// whether the labels are drawn beside the icons instead of below.
	SetItemOrientation(orientation Orientation)
	// SetItemPadding sets the IconView:item-padding property which specifies
	// the padding around each of the icon view’s items.
	SetItemPadding(itemPadding int)
	// SetItemWidth sets the ::item-width property which specifies the width to
	// use for each item. If it is set to -1, the icon view will automatically
	// determine a suitable item size.
	SetItemWidth(itemWidth int)
	// SetMargin sets the ::margin property which specifies the space which is
	// inserted at the top, bottom, left and right of the icon view.
	SetMargin(margin int)
	// SetMarkupColumn sets the column with markup information for @icon_view to
	// be @column. The markup column must be of type TYPE_STRING. If the markup
	// column is set to something, it overrides the text column set by
	// gtk_icon_view_set_text_column().
	SetMarkupColumn(column int)
	// SetModel sets the model for a IconView. If the @icon_view already has a
	// model set, it will remove it before setting the new model. If @model is
	// nil, then it will unset the old model.
	SetModel(model TreeModel)
	// SetPixbufColumn sets the column with pixbufs for @icon_view to be
	// @column. The pixbuf column must be of type K_TYPE_PIXBUF
	SetPixbufColumn(column int)
	// SetReorderable: this function is a convenience function to allow you to
	// reorder models that support the TreeDragSourceIface and the
	// TreeDragDestIface. Both TreeStore and ListStore support these. If
	// @reorderable is true, then the user can reorder the model by dragging and
	// dropping rows. The developer can listen to these changes by connecting to
	// the model's row_inserted and row_deleted signals. The reordering is
	// implemented by setting up the icon view as a drag source and destination.
	// Therefore, drag and drop can not be used in a reorderable view for any
	// other purpose.
	//
	// This function does not give you any degree of control over the order --
	// any reordering is allowed. If more control is needed, you should probably
	// handle drag and drop manually.
	SetReorderable(reorderable bool)
	// SetRowSpacing sets the ::row-spacing property which specifies the space
	// which is inserted between the rows of the icon view.
	SetRowSpacing(rowSpacing int)
	// SetSelectionMode sets the selection mode of the @icon_view.
	SetSelectionMode(mode SelectionMode)
	// SetSpacing sets the ::spacing property which specifies the space which is
	// inserted between the cells (i.e. the icon and the text) of an item.
	SetSpacing(spacing int)
	// SetTextColumn sets the column with text for @icon_view to be @column. The
	// text column must be of type TYPE_STRING.
	SetTextColumn(column int)
	// SetTooltipCell sets the tip area of @tooltip to the area which @cell
	// occupies in the item pointed to by @path. See also
	// gtk_tooltip_set_tip_area().
	//
	// See also gtk_icon_view_set_tooltip_column() for a simpler alternative.
	SetTooltipCell(tooltip Tooltip, path *TreePath, cell CellRenderer)
	// SetTooltipColumn: if you only plan to have simple (text-only) tooltips on
	// full items, you can use this function to have IconView handle these
	// automatically for you. @column should be set to the column in
	// @icon_view’s model containing the tooltip texts, or -1 to disable this
	// feature.
	//
	// When enabled, Widget:has-tooltip will be set to true and @icon_view will
	// connect a Widget::query-tooltip signal handler.
	//
	// Note that the signal handler sets the text with gtk_tooltip_set_markup(),
	// so &, <, etc have to be escaped in the text.
	SetTooltipColumn(column int)
	// SetTooltipItem sets the tip area of @tooltip to be the area covered by
	// the item at @path. See also gtk_icon_view_set_tooltip_column() for a
	// simpler alternative. See also gtk_tooltip_set_tip_area().
	SetTooltipItem(tooltip Tooltip, path *TreePath)
	// UnselectAll unselects all the icons.
	UnselectAll()
	// UnselectPath unselects the row at @path.
	UnselectPath(path *TreePath)
	// UnsetModelDragDest undoes the effect of
	// gtk_icon_view_enable_model_drag_dest(). Calling this method sets
	// IconView:reorderable to false.
	UnsetModelDragDest()
	// UnsetModelDragSource undoes the effect of
	// gtk_icon_view_enable_model_drag_source(). Calling this method sets
	// IconView:reorderable to false.
	UnsetModelDragSource()
}

// iconView implements the IconView class.
type iconView struct {
	Container
	Buildable
	CellLayout
	Scrollable
}

var _ IconView = (*iconView)(nil)

// WrapIconView wraps a GObject to the right type. It is
// primarily used internally.
func WrapIconView(obj *externglib.Object) IconView {
	return iconView{
		Container:  WrapContainer(obj),
		Buildable:  WrapBuildable(obj),
		CellLayout: WrapCellLayout(obj),
		Scrollable: WrapScrollable(obj),
	}
}

func marshalIconView(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIconView(obj), nil
}

// NewIconView creates a new IconView widget
func NewIconView() IconView {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_icon_view_new()

	var _iconView IconView // out

	_iconView = WrapIconView(externglib.Take(unsafe.Pointer(_cret)))

	return _iconView
}

// NewIconViewWithArea creates a new IconView widget using the specified @area
// to layout cells inside the icons.
func NewIconViewWithArea(area CellArea) IconView {
	var _arg1 *C.GtkCellArea // out
	var _cret *C.GtkWidget   // in

	_arg1 = (*C.GtkCellArea)(unsafe.Pointer(area.Native()))

	_cret = C.gtk_icon_view_new_with_area(_arg1)

	var _iconView IconView // out

	_iconView = WrapIconView(externglib.Take(unsafe.Pointer(_cret)))

	return _iconView
}

// NewIconViewWithModel creates a new IconView widget with the model @model.
func NewIconViewWithModel(model TreeModel) IconView {
	var _arg1 *C.GtkTreeModel // out
	var _cret *C.GtkWidget    // in

	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

	_cret = C.gtk_icon_view_new_with_model(_arg1)

	var _iconView IconView // out

	_iconView = WrapIconView(externglib.Take(unsafe.Pointer(_cret)))

	return _iconView
}

// ConvertWidgetToBinWindowCoords converts widget coordinates to coordinates for
// the bin_window, as expected by e.g. gtk_icon_view_get_path_at_pos().
func (i iconView) ConvertWidgetToBinWindowCoords(wx int, wy int) (bx int, by int) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.gint         // out
	var _arg2 C.gint         // out
	var _arg3 C.gint         // in
	var _arg4 C.gint         // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(wx)
	_arg2 = (C.gint)(wy)

	C.gtk_icon_view_convert_widget_to_bin_window_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)

	var _bx int // out
	var _by int // out

	_bx = (int)(_arg3)
	_by = (int)(_arg4)

	return _bx, _by
}

// CreateDragIcon creates a #cairo_surface_t representation of the item at
// @path. This image is used for a drag icon.
func (i iconView) CreateDragIcon(path *TreePath) *cairo.Surface {
	var _arg0 *C.GtkIconView     // out
	var _arg1 *C.GtkTreePath     // out
	var _cret *C.cairo_surface_t // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	_cret = C.gtk_icon_view_create_drag_icon(_arg0, _arg1)

	var _surface *cairo.Surface // out

	_surface = cairo.WrapSurface(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_surface, func(v *cairo.Surface) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _surface
}

// EnableModelDragDest turns @icon_view into a drop destination for automatic
// DND. Calling this method sets IconView:reorderable to false.
func (i iconView) EnableModelDragDest(targets []TargetEntry, actions gdk.DragAction) {
	var _arg0 *C.GtkIconView // out
	var _arg1 *C.GtkTargetEntry
	var _arg2 C.gint
	var _arg3 C.GdkDragAction // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg2 = C.gint(len(targets))
	_arg1 = (*C.GtkTargetEntry)(unsafe.Pointer(&targets[0]))
	_arg3 = (C.GdkDragAction)(actions)

	C.gtk_icon_view_enable_model_drag_dest(_arg0, _arg1, _arg2, _arg3)
}

// EnableModelDragSource turns @icon_view into a drag source for automatic DND.
// Calling this method sets IconView:reorderable to false.
func (i iconView) EnableModelDragSource(startButtonMask gdk.ModifierType, targets []TargetEntry, actions gdk.DragAction) {
	var _arg0 *C.GtkIconView    // out
	var _arg1 C.GdkModifierType // out
	var _arg2 *C.GtkTargetEntry
	var _arg3 C.gint
	var _arg4 C.GdkDragAction // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.GdkModifierType)(startButtonMask)
	_arg3 = C.gint(len(targets))
	_arg2 = (*C.GtkTargetEntry)(unsafe.Pointer(&targets[0]))
	_arg4 = (C.GdkDragAction)(actions)

	C.gtk_icon_view_enable_model_drag_source(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// ActivateOnSingleClick gets the setting set by
// gtk_icon_view_set_activate_on_single_click().
func (i iconView) ActivateOnSingleClick() bool {
	var _arg0 *C.GtkIconView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_view_get_activate_on_single_click(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CellRect fills the bounding rectangle in widget coordinates for the cell
// specified by @path and @cell. If @cell is nil the main cell area is used.
//
// This function is only valid if @icon_view is realized.
func (i iconView) CellRect(path *TreePath, cell CellRenderer) (gdk.Rectangle, bool) {
	var _arg0 *C.GtkIconView     // out
	var _arg1 *C.GtkTreePath     // out
	var _arg2 *C.GtkCellRenderer // out
	var _rect gdk.Rectangle
	var _cret C.gboolean // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))

	_cret = C.gtk_icon_view_get_cell_rect(_arg0, _arg1, _arg2, (*C.GdkRectangle)(unsafe.Pointer(&_rect)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _rect, _ok
}

// ColumnSpacing returns the value of the ::column-spacing property.
func (i iconView) ColumnSpacing() int {
	var _arg0 *C.GtkIconView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_view_get_column_spacing(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Columns returns the value of the ::columns property.
func (i iconView) Columns() int {
	var _arg0 *C.GtkIconView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_view_get_columns(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Cursor fills in @path and @cell with the current cursor path and cell. If the
// cursor isn’t currently set, then *@path will be nil. If no cell currently has
// focus, then *@cell will be nil.
//
// The returned TreePath must be freed with gtk_tree_path_free().
func (i iconView) Cursor() (*TreePath, CellRenderer, bool) {
	var _arg0 *C.GtkIconView // out
	var _path *TreePath
	var _arg2 *C.GtkCellRenderer // in
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_view_get_cursor(_arg0, (**C.GtkTreePath)(unsafe.Pointer(&_path)), &_arg2)

	var _cell CellRenderer // out
	var _ok bool           // out

	_cell = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg2))).(CellRenderer)
	if _cret != 0 {
		_ok = true
	}

	return _path, _cell, _ok
}

// DestItemAtPos determines the destination item for a given position.
func (i iconView) DestItemAtPos(dragX int, dragY int) (*TreePath, IconViewDropPosition, bool) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.gint         // out
	var _arg2 C.gint         // out
	var _path *TreePath
	var _arg4 C.GtkIconViewDropPosition // in
	var _cret C.gboolean                // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(dragX)
	_arg2 = (C.gint)(dragY)

	_cret = C.gtk_icon_view_get_dest_item_at_pos(_arg0, _arg1, _arg2, (**C.GtkTreePath)(unsafe.Pointer(&_path)), &_arg4)

	var _pos IconViewDropPosition // out
	var _ok bool                  // out

	_pos = IconViewDropPosition(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _path, _pos, _ok
}

// DragDestItem gets information about the item that is highlighted for
// feedback.
func (i iconView) DragDestItem() (*TreePath, IconViewDropPosition) {
	var _arg0 *C.GtkIconView // out
	var _path *TreePath
	var _arg2 C.GtkIconViewDropPosition // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	C.gtk_icon_view_get_drag_dest_item(_arg0, (**C.GtkTreePath)(unsafe.Pointer(&_path)), &_arg2)

	var _pos IconViewDropPosition // out

	_pos = IconViewDropPosition(_arg2)

	return _path, _pos
}

// ItemAtPos finds the path at the point (@x, @y), relative to bin_window
// coordinates. In contrast to gtk_icon_view_get_path_at_pos(), this function
// also obtains the cell at the specified position. The returned path should be
// freed with gtk_tree_path_free(). See
// gtk_icon_view_convert_widget_to_bin_window_coords() for converting widget
// coordinates to bin_window coordinates.
func (i iconView) ItemAtPos(x int, y int) (*TreePath, CellRenderer, bool) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.gint         // out
	var _arg2 C.gint         // out
	var _path *TreePath
	var _arg4 *C.GtkCellRenderer // in
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(x)
	_arg2 = (C.gint)(y)

	_cret = C.gtk_icon_view_get_item_at_pos(_arg0, _arg1, _arg2, (**C.GtkTreePath)(unsafe.Pointer(&_path)), &_arg4)

	var _cell CellRenderer // out
	var _ok bool           // out

	_cell = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg4))).(CellRenderer)
	if _cret != 0 {
		_ok = true
	}

	return _path, _cell, _ok
}

// ItemColumn gets the column in which the item @path is currently displayed.
// Column numbers start at 0.
func (i iconView) ItemColumn(path *TreePath) int {
	var _arg0 *C.GtkIconView // out
	var _arg1 *C.GtkTreePath // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	_cret = C.gtk_icon_view_get_item_column(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// ItemOrientation returns the value of the ::item-orientation property which
// determines whether the labels are drawn beside the icons instead of below.
func (i iconView) ItemOrientation() Orientation {
	var _arg0 *C.GtkIconView   // out
	var _cret C.GtkOrientation // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_view_get_item_orientation(_arg0)

	var _orientation Orientation // out

	_orientation = Orientation(_cret)

	return _orientation
}

// ItemPadding returns the value of the ::item-padding property.
func (i iconView) ItemPadding() int {
	var _arg0 *C.GtkIconView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_view_get_item_padding(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// ItemRow gets the row in which the item @path is currently displayed. Row
// numbers start at 0.
func (i iconView) ItemRow(path *TreePath) int {
	var _arg0 *C.GtkIconView // out
	var _arg1 *C.GtkTreePath // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	_cret = C.gtk_icon_view_get_item_row(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// ItemWidth returns the value of the ::item-width property.
func (i iconView) ItemWidth() int {
	var _arg0 *C.GtkIconView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_view_get_item_width(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Margin returns the value of the ::margin property.
func (i iconView) Margin() int {
	var _arg0 *C.GtkIconView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_view_get_margin(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// MarkupColumn returns the column with markup text for @icon_view.
func (i iconView) MarkupColumn() int {
	var _arg0 *C.GtkIconView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_view_get_markup_column(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Model returns the model the IconView is based on. Returns nil if the model is
// unset.
func (i iconView) Model() TreeModel {
	var _arg0 *C.GtkIconView  // out
	var _cret *C.GtkTreeModel // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_view_get_model(_arg0)

	var _treeModel TreeModel // out

	_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeModel)

	return _treeModel
}

// PathAtPos finds the path at the point (@x, @y), relative to bin_window
// coordinates. See gtk_icon_view_get_item_at_pos(), if you are also interested
// in the cell at the specified position. See
// gtk_icon_view_convert_widget_to_bin_window_coords() for converting widget
// coordinates to bin_window coordinates.
func (i iconView) PathAtPos(x int, y int) *TreePath {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.gint         // out
	var _arg2 C.gint         // out
	var _cret *C.GtkTreePath // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(x)
	_arg2 = (C.gint)(y)

	_cret = C.gtk_icon_view_get_path_at_pos(_arg0, _arg1, _arg2)

	var _treePath *TreePath // out

	_treePath = WrapTreePath(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treePath, func(v *TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treePath
}

// PixbufColumn returns the column with pixbufs for @icon_view.
func (i iconView) PixbufColumn() int {
	var _arg0 *C.GtkIconView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_view_get_pixbuf_column(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Reorderable retrieves whether the user can reorder the list via
// drag-and-drop. See gtk_icon_view_set_reorderable().
func (i iconView) Reorderable() bool {
	var _arg0 *C.GtkIconView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_view_get_reorderable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RowSpacing returns the value of the ::row-spacing property.
func (i iconView) RowSpacing() int {
	var _arg0 *C.GtkIconView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_view_get_row_spacing(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// SelectionMode gets the selection mode of the @icon_view.
func (i iconView) SelectionMode() SelectionMode {
	var _arg0 *C.GtkIconView     // out
	var _cret C.GtkSelectionMode // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_view_get_selection_mode(_arg0)

	var _selectionMode SelectionMode // out

	_selectionMode = SelectionMode(_cret)

	return _selectionMode
}

// Spacing returns the value of the ::spacing property.
func (i iconView) Spacing() int {
	var _arg0 *C.GtkIconView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_view_get_spacing(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// TextColumn returns the column with text for @icon_view.
func (i iconView) TextColumn() int {
	var _arg0 *C.GtkIconView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_view_get_text_column(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// TooltipColumn returns the column of @icon_view’s model which is being used
// for displaying tooltips on @icon_view’s rows.
func (i iconView) TooltipColumn() int {
	var _arg0 *C.GtkIconView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_view_get_tooltip_column(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// VisibleRange sets @start_path and @end_path to be the first and last visible
// path. Note that there may be invisible paths in between.
//
// Both paths should be freed with gtk_tree_path_free() after use.
func (i iconView) VisibleRange() (startPath *TreePath, endPath *TreePath, ok bool) {
	var _arg0 *C.GtkIconView // out
	var _startPath *TreePath
	var _endPath *TreePath
	var _cret C.gboolean // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_view_get_visible_range(_arg0, (**C.GtkTreePath)(unsafe.Pointer(&_startPath)), (**C.GtkTreePath)(unsafe.Pointer(&_endPath)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _startPath, _endPath, _ok
}

// ItemActivated activates the item determined by @path.
func (i iconView) ItemActivated(path *TreePath) {
	var _arg0 *C.GtkIconView // out
	var _arg1 *C.GtkTreePath // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_icon_view_item_activated(_arg0, _arg1)
}

// PathIsSelected returns true if the icon pointed to by @path is currently
// selected. If @path does not point to a valid location, false is returned.
func (i iconView) PathIsSelected(path *TreePath) bool {
	var _arg0 *C.GtkIconView // out
	var _arg1 *C.GtkTreePath // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	_cret = C.gtk_icon_view_path_is_selected(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ScrollToPath moves the alignments of @icon_view to the position specified by
// @path. @row_align determines where the row is placed, and @col_align
// determines where @column is placed. Both are expected to be between 0.0 and
// 1.0. 0.0 means left/top alignment, 1.0 means right/bottom alignment, 0.5
// means center.
//
// If @use_align is false, then the alignment arguments are ignored, and the
// tree does the minimum amount of work to scroll the item onto the screen. This
// means that the item will be scrolled to the edge closest to its current
// position. If the item is currently visible on the screen, nothing is done.
//
// This function only works if the model is set, and @path is a valid row on the
// model. If the model changes before the @icon_view is realized, the centered
// path will be modified to reflect this change.
func (i iconView) ScrollToPath(path *TreePath, useAlign bool, rowAlign float32, colAlign float32) {
	var _arg0 *C.GtkIconView // out
	var _arg1 *C.GtkTreePath // out
	var _arg2 C.gboolean     // out
	var _arg3 C.gfloat       // out
	var _arg4 C.gfloat       // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	if useAlign {
		_arg2 = C.TRUE
	}
	_arg3 = (C.gfloat)(rowAlign)
	_arg4 = (C.gfloat)(colAlign)

	C.gtk_icon_view_scroll_to_path(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// SelectAll selects all the icons. @icon_view must has its selection mode set
// to K_SELECTION_MULTIPLE.
func (i iconView) SelectAll() {
	var _arg0 *C.GtkIconView // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	C.gtk_icon_view_select_all(_arg0)
}

// SelectPath selects the row at @path.
func (i iconView) SelectPath(path *TreePath) {
	var _arg0 *C.GtkIconView // out
	var _arg1 *C.GtkTreePath // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_icon_view_select_path(_arg0, _arg1)
}

// SetActivateOnSingleClick causes the IconView::item-activated signal to be
// emitted on a single click instead of a double click.
func (i iconView) SetActivateOnSingleClick(single bool) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	if single {
		_arg1 = C.TRUE
	}

	C.gtk_icon_view_set_activate_on_single_click(_arg0, _arg1)
}

// SetColumnSpacing sets the ::column-spacing property which specifies the space
// which is inserted between the columns of the icon view.
func (i iconView) SetColumnSpacing(columnSpacing int) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(columnSpacing)

	C.gtk_icon_view_set_column_spacing(_arg0, _arg1)
}

// SetColumns sets the ::columns property which determines in how many columns
// the icons are arranged. If @columns is -1, the number of columns will be
// chosen automatically to fill the available area.
func (i iconView) SetColumns(columns int) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(columns)

	C.gtk_icon_view_set_columns(_arg0, _arg1)
}

// SetCursor sets the current keyboard focus to be at @path, and selects it.
// This is useful when you want to focus the user’s attention on a particular
// item. If @cell is not nil, then focus is given to the cell specified by it.
// Additionally, if @start_editing is true, then editing should be started in
// the specified cell.
//
// This function is often followed by `gtk_widget_grab_focus (icon_view)` in
// order to give keyboard focus to the widget. Please note that editing can only
// happen when the widget is realized.
func (i iconView) SetCursor(path *TreePath, cell CellRenderer, startEditing bool) {
	var _arg0 *C.GtkIconView     // out
	var _arg1 *C.GtkTreePath     // out
	var _arg2 *C.GtkCellRenderer // out
	var _arg3 C.gboolean         // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))
	if startEditing {
		_arg3 = C.TRUE
	}

	C.gtk_icon_view_set_cursor(_arg0, _arg1, _arg2, _arg3)
}

// SetDragDestItem sets the item that is highlighted for feedback.
func (i iconView) SetDragDestItem(path *TreePath, pos IconViewDropPosition) {
	var _arg0 *C.GtkIconView            // out
	var _arg1 *C.GtkTreePath            // out
	var _arg2 C.GtkIconViewDropPosition // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg2 = (C.GtkIconViewDropPosition)(pos)

	C.gtk_icon_view_set_drag_dest_item(_arg0, _arg1, _arg2)
}

// SetItemOrientation sets the ::item-orientation property which determines
// whether the labels are drawn beside the icons instead of below.
func (i iconView) SetItemOrientation(orientation Orientation) {
	var _arg0 *C.GtkIconView   // out
	var _arg1 C.GtkOrientation // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.GtkOrientation)(orientation)

	C.gtk_icon_view_set_item_orientation(_arg0, _arg1)
}

// SetItemPadding sets the IconView:item-padding property which specifies the
// padding around each of the icon view’s items.
func (i iconView) SetItemPadding(itemPadding int) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(itemPadding)

	C.gtk_icon_view_set_item_padding(_arg0, _arg1)
}

// SetItemWidth sets the ::item-width property which specifies the width to use
// for each item. If it is set to -1, the icon view will automatically determine
// a suitable item size.
func (i iconView) SetItemWidth(itemWidth int) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(itemWidth)

	C.gtk_icon_view_set_item_width(_arg0, _arg1)
}

// SetMargin sets the ::margin property which specifies the space which is
// inserted at the top, bottom, left and right of the icon view.
func (i iconView) SetMargin(margin int) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(margin)

	C.gtk_icon_view_set_margin(_arg0, _arg1)
}

// SetMarkupColumn sets the column with markup information for @icon_view to be
// @column. The markup column must be of type TYPE_STRING. If the markup column
// is set to something, it overrides the text column set by
// gtk_icon_view_set_text_column().
func (i iconView) SetMarkupColumn(column int) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(column)

	C.gtk_icon_view_set_markup_column(_arg0, _arg1)
}

// SetModel sets the model for a IconView. If the @icon_view already has a model
// set, it will remove it before setting the new model. If @model is nil, then
// it will unset the old model.
func (i iconView) SetModel(model TreeModel) {
	var _arg0 *C.GtkIconView  // out
	var _arg1 *C.GtkTreeModel // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

	C.gtk_icon_view_set_model(_arg0, _arg1)
}

// SetPixbufColumn sets the column with pixbufs for @icon_view to be @column.
// The pixbuf column must be of type K_TYPE_PIXBUF
func (i iconView) SetPixbufColumn(column int) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(column)

	C.gtk_icon_view_set_pixbuf_column(_arg0, _arg1)
}

// SetReorderable: this function is a convenience function to allow you to
// reorder models that support the TreeDragSourceIface and the
// TreeDragDestIface. Both TreeStore and ListStore support these. If
// @reorderable is true, then the user can reorder the model by dragging and
// dropping rows. The developer can listen to these changes by connecting to the
// model's row_inserted and row_deleted signals. The reordering is implemented
// by setting up the icon view as a drag source and destination. Therefore, drag
// and drop can not be used in a reorderable view for any other purpose.
//
// This function does not give you any degree of control over the order -- any
// reordering is allowed. If more control is needed, you should probably handle
// drag and drop manually.
func (i iconView) SetReorderable(reorderable bool) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	if reorderable {
		_arg1 = C.TRUE
	}

	C.gtk_icon_view_set_reorderable(_arg0, _arg1)
}

// SetRowSpacing sets the ::row-spacing property which specifies the space which
// is inserted between the rows of the icon view.
func (i iconView) SetRowSpacing(rowSpacing int) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(rowSpacing)

	C.gtk_icon_view_set_row_spacing(_arg0, _arg1)
}

// SetSelectionMode sets the selection mode of the @icon_view.
func (i iconView) SetSelectionMode(mode SelectionMode) {
	var _arg0 *C.GtkIconView     // out
	var _arg1 C.GtkSelectionMode // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.GtkSelectionMode)(mode)

	C.gtk_icon_view_set_selection_mode(_arg0, _arg1)
}

// SetSpacing sets the ::spacing property which specifies the space which is
// inserted between the cells (i.e. the icon and the text) of an item.
func (i iconView) SetSpacing(spacing int) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(spacing)

	C.gtk_icon_view_set_spacing(_arg0, _arg1)
}

// SetTextColumn sets the column with text for @icon_view to be @column. The
// text column must be of type TYPE_STRING.
func (i iconView) SetTextColumn(column int) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(column)

	C.gtk_icon_view_set_text_column(_arg0, _arg1)
}

// SetTooltipCell sets the tip area of @tooltip to the area which @cell occupies
// in the item pointed to by @path. See also gtk_tooltip_set_tip_area().
//
// See also gtk_icon_view_set_tooltip_column() for a simpler alternative.
func (i iconView) SetTooltipCell(tooltip Tooltip, path *TreePath, cell CellRenderer) {
	var _arg0 *C.GtkIconView     // out
	var _arg1 *C.GtkTooltip      // out
	var _arg2 *C.GtkTreePath     // out
	var _arg3 *C.GtkCellRenderer // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTooltip)(unsafe.Pointer(tooltip.Native()))
	_arg2 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg3 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))

	C.gtk_icon_view_set_tooltip_cell(_arg0, _arg1, _arg2, _arg3)
}

// SetTooltipColumn: if you only plan to have simple (text-only) tooltips on
// full items, you can use this function to have IconView handle these
// automatically for you. @column should be set to the column in @icon_view’s
// model containing the tooltip texts, or -1 to disable this feature.
//
// When enabled, Widget:has-tooltip will be set to true and @icon_view will
// connect a Widget::query-tooltip signal handler.
//
// Note that the signal handler sets the text with gtk_tooltip_set_markup(), so
// &, <, etc have to be escaped in the text.
func (i iconView) SetTooltipColumn(column int) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(column)

	C.gtk_icon_view_set_tooltip_column(_arg0, _arg1)
}

// SetTooltipItem sets the tip area of @tooltip to be the area covered by the
// item at @path. See also gtk_icon_view_set_tooltip_column() for a simpler
// alternative. See also gtk_tooltip_set_tip_area().
func (i iconView) SetTooltipItem(tooltip Tooltip, path *TreePath) {
	var _arg0 *C.GtkIconView // out
	var _arg1 *C.GtkTooltip  // out
	var _arg2 *C.GtkTreePath // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTooltip)(unsafe.Pointer(tooltip.Native()))
	_arg2 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_icon_view_set_tooltip_item(_arg0, _arg1, _arg2)
}

// UnselectAll unselects all the icons.
func (i iconView) UnselectAll() {
	var _arg0 *C.GtkIconView // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	C.gtk_icon_view_unselect_all(_arg0)
}

// UnselectPath unselects the row at @path.
func (i iconView) UnselectPath(path *TreePath) {
	var _arg0 *C.GtkIconView // out
	var _arg1 *C.GtkTreePath // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_icon_view_unselect_path(_arg0, _arg1)
}

// UnsetModelDragDest undoes the effect of
// gtk_icon_view_enable_model_drag_dest(). Calling this method sets
// IconView:reorderable to false.
func (i iconView) UnsetModelDragDest() {
	var _arg0 *C.GtkIconView // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	C.gtk_icon_view_unset_model_drag_dest(_arg0)
}

// UnsetModelDragSource undoes the effect of
// gtk_icon_view_enable_model_drag_source(). Calling this method sets
// IconView:reorderable to false.
func (i iconView) UnsetModelDragSource() {
	var _arg0 *C.GtkIconView // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	C.gtk_icon_view_unset_model_drag_source(_arg0)
}

type IconViewAccessible interface {
	ContainerAccessible
}

// iconViewAccessible implements the IconViewAccessible class.
type iconViewAccessible struct {
	ContainerAccessible
}

var _ IconViewAccessible = (*iconViewAccessible)(nil)

// WrapIconViewAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapIconViewAccessible(obj *externglib.Object) IconViewAccessible {
	return iconViewAccessible{
		ContainerAccessible: WrapContainerAccessible(obj),
	}
}

func marshalIconViewAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIconViewAccessible(obj), nil
}

// Image: the Image widget displays an image. Various kinds of object can be
// displayed as an image; most typically, you would load a Pixbuf ("pixel
// buffer") from a file, and then display that. There’s a convenience function
// to do this, gtk_image_new_from_file(), used as follows:
//
//      static gboolean
//      button_press_callback (GtkWidget      *event_box,
//                             GdkEventButton *event,
//                             gpointer        data)
//      {
//        g_print ("Event box clicked at coordinates f,f\n",
//                 event->x, event->y);
//
//        // Returning TRUE means we handled the event, so the signal
//        // emission should be stopped (don’t call any further callbacks
//        // that may be connected). Return FALSE to continue invoking callbacks.
//        return TRUE;
//      }
//
//      static GtkWidget*
//      create_image (void)
//      {
//        GtkWidget *image;
//        GtkWidget *event_box;
//
//        image = gtk_image_new_from_file ("myfile.png");
//
//        event_box = gtk_event_box_new ();
//
//        gtk_container_add (GTK_CONTAINER (event_box), image);
//
//        g_signal_connect (G_OBJECT (event_box),
//                          "button_press_event",
//                          G_CALLBACK (button_press_callback),
//                          image);
//
//        return image;
//      }
//
// When handling events on the event box, keep in mind that coordinates in the
// image may be different from event box coordinates due to the alignment and
// padding settings on the image (see Misc). The simplest way to solve this is
// to set the alignment to 0.0 (left/top), and set the padding to zero. Then the
// origin of the image will be the same as the origin of the event box.
//
// Sometimes an application will want to avoid depending on external data files,
// such as image files. GTK+ comes with a program to avoid this, called
// “gdk-pixbuf-csource”. This library allows you to convert an image into a C
// variable declaration, which can then be loaded into a Pixbuf using
// gdk_pixbuf_new_from_inline().
//
//
// CSS nodes
//
// GtkImage has a single CSS node with the name image. The style classes may
// appear on image CSS nodes: .icon-dropshadow, .lowres-icon.
type Image interface {
	Misc
	Buildable

	// Clear resets the image to be empty.
	Clear()
	// Animation gets the PixbufAnimation being displayed by the Image. The
	// storage type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_ANIMATION
	// (see gtk_image_get_storage_type()). The caller of this function does not
	// own a reference to the returned animation.
	Animation() gdkpixbuf.PixbufAnimation
	// GIcon gets the #GIcon and size being displayed by the Image. The storage
	// type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_GICON (see
	// gtk_image_get_storage_type()). The caller of this function does not own a
	// reference to the returned #GIcon.
	GIcon() (gio.Icon, int)
	// IconName gets the icon name and size being displayed by the Image. The
	// storage type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_ICON_NAME
	// (see gtk_image_get_storage_type()). The returned string is owned by the
	// Image and should not be freed.
	IconName() (string, int)
	// IconSet gets the icon set and size being displayed by the Image. The
	// storage type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_ICON_SET
	// (see gtk_image_get_storage_type()).
	IconSet() (*IconSet, int)
	// Pixbuf gets the Pixbuf being displayed by the Image. The storage type of
	// the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_PIXBUF (see
	// gtk_image_get_storage_type()). The caller of this function does not own a
	// reference to the returned pixbuf.
	Pixbuf() gdkpixbuf.Pixbuf
	// PixelSize gets the pixel size used for named icons.
	PixelSize() int
	// Stock gets the stock icon name and size being displayed by the Image. The
	// storage type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_STOCK (see
	// gtk_image_get_storage_type()). The returned string is owned by the Image
	// and should not be freed.
	Stock() (string, int)
	// StorageType gets the type of representation being used by the Image to
	// store image data. If the Image has no image data, the return value will
	// be GTK_IMAGE_EMPTY.
	StorageType() ImageType
	// SetFromAnimation causes the Image to display the given animation (or
	// display nothing, if you set the animation to nil).
	SetFromAnimation(animation gdkpixbuf.PixbufAnimation)
	// SetFromFile: see gtk_image_new_from_file() for details.
	SetFromFile(filename string)
	// SetFromGIcon: see gtk_image_new_from_gicon() for details.
	SetFromGIcon(icon gio.Icon, size int)
	// SetFromIconName: see gtk_image_new_from_icon_name() for details.
	SetFromIconName(iconName string, size int)
	// SetFromIconSet: see gtk_image_new_from_icon_set() for details.
	SetFromIconSet(iconSet *IconSet, size int)
	// SetFromPixbuf: see gtk_image_new_from_pixbuf() for details.
	SetFromPixbuf(pixbuf gdkpixbuf.Pixbuf)
	// SetFromResource: see gtk_image_new_from_resource() for details.
	SetFromResource(resourcePath string)
	// SetFromStock: see gtk_image_new_from_stock() for details.
	SetFromStock(stockId string, size int)
	// SetFromSurface: see gtk_image_new_from_surface() for details.
	SetFromSurface(surface *cairo.Surface)
	// SetPixelSize sets the pixel size to use for named icons. If the pixel
	// size is set to a value != -1, it is used instead of the icon size set by
	// gtk_image_set_from_icon_name().
	SetPixelSize(pixelSize int)
}

// image implements the Image class.
type image struct {
	Misc
	Buildable
}

var _ Image = (*image)(nil)

// WrapImage wraps a GObject to the right type. It is
// primarily used internally.
func WrapImage(obj *externglib.Object) Image {
	return image{
		Misc:      WrapMisc(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalImage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapImage(obj), nil
}

// NewImage creates a new empty Image widget.
func NewImage() Image {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_image_new()

	var _image Image // out

	_image = WrapImage(externglib.Take(unsafe.Pointer(_cret)))

	return _image
}

// NewImageFromAnimation creates a Image displaying the given animation. The
// Image does not assume a reference to the animation; you still need to unref
// it if you own references. Image will add its own reference rather than
// adopting yours.
//
// Note that the animation frames are shown using a timeout with
// PRIORITY_DEFAULT. When using animations to indicate busyness, keep in mind
// that the animation will only be shown if the main loop is not busy with
// something that has a higher priority.
func NewImageFromAnimation(animation gdkpixbuf.PixbufAnimation) Image {
	var _arg1 *C.GdkPixbufAnimation // out
	var _cret *C.GtkWidget          // in

	_arg1 = (*C.GdkPixbufAnimation)(unsafe.Pointer(animation.Native()))

	_cret = C.gtk_image_new_from_animation(_arg1)

	var _image Image // out

	_image = WrapImage(externglib.Take(unsafe.Pointer(_cret)))

	return _image
}

// NewImageFromFile creates a new Image displaying the file @filename. If the
// file isn’t found or can’t be loaded, the resulting Image will display a
// “broken image” icon. This function never returns nil, it always returns a
// valid Image widget.
//
// If the file contains an animation, the image will contain an animation.
//
// If you need to detect failures to load the file, use
// gdk_pixbuf_new_from_file() to load the file yourself, then create the Image
// from the pixbuf. (Or for animations, use
// gdk_pixbuf_animation_new_from_file()).
//
// The storage type (gtk_image_get_storage_type()) of the returned image is not
// defined, it will be whatever is appropriate for displaying the file.
func NewImageFromFile(filename string) Image {
	var _arg1 *C.gchar     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_image_new_from_file(_arg1)

	var _image Image // out

	_image = WrapImage(externglib.Take(unsafe.Pointer(_cret)))

	return _image
}

// NewImageFromGIcon creates a Image displaying an icon from the current icon
// theme. If the icon name isn’t known, a “broken image” icon will be displayed
// instead. If the current icon theme is changed, the icon will be updated
// appropriately.
func NewImageFromGIcon(icon gio.Icon, size int) Image {
	var _arg1 *C.GIcon      // out
	var _arg2 C.GtkIconSize // out
	var _cret *C.GtkWidget  // in

	_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))
	_arg2 = (C.GtkIconSize)(size)

	_cret = C.gtk_image_new_from_gicon(_arg1, _arg2)

	var _image Image // out

	_image = WrapImage(externglib.Take(unsafe.Pointer(_cret)))

	return _image
}

// NewImageFromIconName creates a Image displaying an icon from the current icon
// theme. If the icon name isn’t known, a “broken image” icon will be displayed
// instead. If the current icon theme is changed, the icon will be updated
// appropriately.
func NewImageFromIconName(iconName string, size int) Image {
	var _arg1 *C.gchar      // out
	var _arg2 C.GtkIconSize // out
	var _cret *C.GtkWidget  // in

	_arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GtkIconSize)(size)

	_cret = C.gtk_image_new_from_icon_name(_arg1, _arg2)

	var _image Image // out

	_image = WrapImage(externglib.Take(unsafe.Pointer(_cret)))

	return _image
}

// NewImageFromIconSet creates a Image displaying an icon set. Sample stock
// sizes are K_ICON_SIZE_MENU, K_ICON_SIZE_SMALL_TOOLBAR. Instead of using this
// function, usually it’s better to create a IconFactory, put your icon sets in
// the icon factory, add the icon factory to the list of default factories with
// gtk_icon_factory_add_default(), and then use gtk_image_new_from_stock(). This
// will allow themes to override the icon you ship with your application.
//
// The Image does not assume a reference to the icon set; you still need to
// unref it if you own references. Image will add its own reference rather than
// adopting yours.
func NewImageFromIconSet(iconSet *IconSet, size int) Image {
	var _arg1 *C.GtkIconSet // out
	var _arg2 C.GtkIconSize // out
	var _cret *C.GtkWidget  // in

	_arg1 = (*C.GtkIconSet)(unsafe.Pointer(iconSet.Native()))
	_arg2 = (C.GtkIconSize)(size)

	_cret = C.gtk_image_new_from_icon_set(_arg1, _arg2)

	var _image Image // out

	_image = WrapImage(externglib.Take(unsafe.Pointer(_cret)))

	return _image
}

// NewImageFromPixbuf creates a new Image displaying @pixbuf. The Image does not
// assume a reference to the pixbuf; you still need to unref it if you own
// references. Image will add its own reference rather than adopting yours.
//
// Note that this function just creates an Image from the pixbuf. The Image
// created will not react to state changes. Should you want that, you should use
// gtk_image_new_from_icon_name().
func NewImageFromPixbuf(pixbuf gdkpixbuf.Pixbuf) Image {
	var _arg1 *C.GdkPixbuf // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	_cret = C.gtk_image_new_from_pixbuf(_arg1)

	var _image Image // out

	_image = WrapImage(externglib.Take(unsafe.Pointer(_cret)))

	return _image
}

// NewImageFromResource creates a new Image displaying the resource file
// @resource_path. If the file isn’t found or can’t be loaded, the resulting
// Image will display a “broken image” icon. This function never returns nil, it
// always returns a valid Image widget.
//
// If the file contains an animation, the image will contain an animation.
//
// If you need to detect failures to load the file, use
// gdk_pixbuf_new_from_file() to load the file yourself, then create the Image
// from the pixbuf. (Or for animations, use
// gdk_pixbuf_animation_new_from_file()).
//
// The storage type (gtk_image_get_storage_type()) of the returned image is not
// defined, it will be whatever is appropriate for displaying the file.
func NewImageFromResource(resourcePath string) Image {
	var _arg1 *C.gchar     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.gchar)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_image_new_from_resource(_arg1)

	var _image Image // out

	_image = WrapImage(externglib.Take(unsafe.Pointer(_cret)))

	return _image
}

// NewImageFromStock creates a Image displaying a stock icon. Sample stock icon
// names are K_STOCK_OPEN, K_STOCK_QUIT. Sample stock sizes are
// K_ICON_SIZE_MENU, K_ICON_SIZE_SMALL_TOOLBAR. If the stock icon name isn’t
// known, the image will be empty. You can register your own stock icon names,
// see gtk_icon_factory_add_default() and gtk_icon_factory_add().
func NewImageFromStock(stockId string, size int) Image {
	var _arg1 *C.gchar      // out
	var _arg2 C.GtkIconSize // out
	var _cret *C.GtkWidget  // in

	_arg1 = (*C.gchar)(C.CString(stockId))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GtkIconSize)(size)

	_cret = C.gtk_image_new_from_stock(_arg1, _arg2)

	var _image Image // out

	_image = WrapImage(externglib.Take(unsafe.Pointer(_cret)))

	return _image
}

// NewImageFromSurface creates a new Image displaying @surface. The Image does
// not assume a reference to the surface; you still need to unref it if you own
// references. Image will add its own reference rather than adopting yours.
func NewImageFromSurface(surface *cairo.Surface) Image {
	var _arg1 *C.cairo_surface_t // out
	var _cret *C.GtkWidget       // in

	_arg1 = (*C.cairo_surface_t)(unsafe.Pointer(surface.Native()))

	_cret = C.gtk_image_new_from_surface(_arg1)

	var _image Image // out

	_image = WrapImage(externglib.Take(unsafe.Pointer(_cret)))

	return _image
}

// Clear resets the image to be empty.
func (i image) Clear() {
	var _arg0 *C.GtkImage // out

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

	C.gtk_image_clear(_arg0)
}

// Animation gets the PixbufAnimation being displayed by the Image. The storage
// type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_ANIMATION (see
// gtk_image_get_storage_type()). The caller of this function does not own a
// reference to the returned animation.
func (i image) Animation() gdkpixbuf.PixbufAnimation {
	var _arg0 *C.GtkImage           // out
	var _cret *C.GdkPixbufAnimation // in

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_image_get_animation(_arg0)

	var _pixbufAnimation gdkpixbuf.PixbufAnimation // out

	_pixbufAnimation = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdkpixbuf.PixbufAnimation)

	return _pixbufAnimation
}

// GIcon gets the #GIcon and size being displayed by the Image. The storage type
// of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_GICON (see
// gtk_image_get_storage_type()). The caller of this function does not own a
// reference to the returned #GIcon.
func (i image) GIcon() (gio.Icon, int) {
	var _arg0 *C.GtkImage   // out
	var _arg1 *C.GIcon      // in
	var _arg2 C.GtkIconSize // in

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

	C.gtk_image_get_gicon(_arg0, &_arg1, &_arg2)

	var _gicon gio.Icon // out
	var _size int       // out

	_gicon = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg1))).(gio.Icon)
	_size = (int)(_arg2)

	return _gicon, _size
}

// IconName gets the icon name and size being displayed by the Image. The
// storage type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_ICON_NAME (see
// gtk_image_get_storage_type()). The returned string is owned by the Image and
// should not be freed.
func (i image) IconName() (string, int) {
	var _arg0 *C.GtkImage   // out
	var _arg1 *C.gchar      // in
	var _arg2 C.GtkIconSize // in

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

	C.gtk_image_get_icon_name(_arg0, &_arg1, &_arg2)

	var _iconName string // out
	var _size int        // out

	_iconName = C.GoString(_arg1)
	_size = (int)(_arg2)

	return _iconName, _size
}

// IconSet gets the icon set and size being displayed by the Image. The storage
// type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_ICON_SET (see
// gtk_image_get_storage_type()).
func (i image) IconSet() (*IconSet, int) {
	var _arg0 *C.GtkImage   // out
	var _arg1 *C.GtkIconSet // in
	var _arg2 C.GtkIconSize // in

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

	C.gtk_image_get_icon_set(_arg0, &_arg1, &_arg2)

	var _iconSet *IconSet // out
	var _size int         // out

	_iconSet = WrapIconSet(unsafe.Pointer(_arg1))
	_size = (int)(_arg2)

	return _iconSet, _size
}

// Pixbuf gets the Pixbuf being displayed by the Image. The storage type of the
// image must be GTK_IMAGE_EMPTY or GTK_IMAGE_PIXBUF (see
// gtk_image_get_storage_type()). The caller of this function does not own a
// reference to the returned pixbuf.
func (i image) Pixbuf() gdkpixbuf.Pixbuf {
	var _arg0 *C.GtkImage  // out
	var _cret *C.GdkPixbuf // in

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_image_get_pixbuf(_arg0)

	var _pixbuf gdkpixbuf.Pixbuf // out

	_pixbuf = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

	return _pixbuf
}

// PixelSize gets the pixel size used for named icons.
func (i image) PixelSize() int {
	var _arg0 *C.GtkImage // out
	var _cret C.gint      // in

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_image_get_pixel_size(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Stock gets the stock icon name and size being displayed by the Image. The
// storage type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_STOCK (see
// gtk_image_get_storage_type()). The returned string is owned by the Image and
// should not be freed.
func (i image) Stock() (string, int) {
	var _arg0 *C.GtkImage   // out
	var _arg1 *C.gchar      // in
	var _arg2 C.GtkIconSize // in

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

	C.gtk_image_get_stock(_arg0, &_arg1, &_arg2)

	var _stockId string // out
	var _size int       // out

	_stockId = C.GoString(_arg1)
	_size = (int)(_arg2)

	return _stockId, _size
}

// StorageType gets the type of representation being used by the Image to store
// image data. If the Image has no image data, the return value will be
// GTK_IMAGE_EMPTY.
func (i image) StorageType() ImageType {
	var _arg0 *C.GtkImage    // out
	var _cret C.GtkImageType // in

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_image_get_storage_type(_arg0)

	var _imageType ImageType // out

	_imageType = ImageType(_cret)

	return _imageType
}

// SetFromAnimation causes the Image to display the given animation (or display
// nothing, if you set the animation to nil).
func (i image) SetFromAnimation(animation gdkpixbuf.PixbufAnimation) {
	var _arg0 *C.GtkImage           // out
	var _arg1 *C.GdkPixbufAnimation // out

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GdkPixbufAnimation)(unsafe.Pointer(animation.Native()))

	C.gtk_image_set_from_animation(_arg0, _arg1)
}

// SetFromFile: see gtk_image_new_from_file() for details.
func (i image) SetFromFile(filename string) {
	var _arg0 *C.GtkImage // out
	var _arg1 *C.gchar    // out

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_image_set_from_file(_arg0, _arg1)
}

// SetFromGIcon: see gtk_image_new_from_gicon() for details.
func (i image) SetFromGIcon(icon gio.Icon, size int) {
	var _arg0 *C.GtkImage   // out
	var _arg1 *C.GIcon      // out
	var _arg2 C.GtkIconSize // out

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))
	_arg2 = (C.GtkIconSize)(size)

	C.gtk_image_set_from_gicon(_arg0, _arg1, _arg2)
}

// SetFromIconName: see gtk_image_new_from_icon_name() for details.
func (i image) SetFromIconName(iconName string, size int) {
	var _arg0 *C.GtkImage   // out
	var _arg1 *C.gchar      // out
	var _arg2 C.GtkIconSize // out

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GtkIconSize)(size)

	C.gtk_image_set_from_icon_name(_arg0, _arg1, _arg2)
}

// SetFromIconSet: see gtk_image_new_from_icon_set() for details.
func (i image) SetFromIconSet(iconSet *IconSet, size int) {
	var _arg0 *C.GtkImage   // out
	var _arg1 *C.GtkIconSet // out
	var _arg2 C.GtkIconSize // out

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkIconSet)(unsafe.Pointer(iconSet.Native()))
	_arg2 = (C.GtkIconSize)(size)

	C.gtk_image_set_from_icon_set(_arg0, _arg1, _arg2)
}

// SetFromPixbuf: see gtk_image_new_from_pixbuf() for details.
func (i image) SetFromPixbuf(pixbuf gdkpixbuf.Pixbuf) {
	var _arg0 *C.GtkImage  // out
	var _arg1 *C.GdkPixbuf // out

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	C.gtk_image_set_from_pixbuf(_arg0, _arg1)
}

// SetFromResource: see gtk_image_new_from_resource() for details.
func (i image) SetFromResource(resourcePath string) {
	var _arg0 *C.GtkImage // out
	var _arg1 *C.gchar    // out

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_image_set_from_resource(_arg0, _arg1)
}

// SetFromStock: see gtk_image_new_from_stock() for details.
func (i image) SetFromStock(stockId string, size int) {
	var _arg0 *C.GtkImage   // out
	var _arg1 *C.gchar      // out
	var _arg2 C.GtkIconSize // out

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(stockId))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GtkIconSize)(size)

	C.gtk_image_set_from_stock(_arg0, _arg1, _arg2)
}

// SetFromSurface: see gtk_image_new_from_surface() for details.
func (i image) SetFromSurface(surface *cairo.Surface) {
	var _arg0 *C.GtkImage        // out
	var _arg1 *C.cairo_surface_t // out

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.cairo_surface_t)(unsafe.Pointer(surface.Native()))

	C.gtk_image_set_from_surface(_arg0, _arg1)
}

// SetPixelSize sets the pixel size to use for named icons. If the pixel size is
// set to a value != -1, it is used instead of the icon size set by
// gtk_image_set_from_icon_name().
func (i image) SetPixelSize(pixelSize int) {
	var _arg0 *C.GtkImage // out
	var _arg1 C.gint      // out

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(pixelSize)

	C.gtk_image_set_pixel_size(_arg0, _arg1)
}

type ImageAccessible interface {
	WidgetAccessible
}

// imageAccessible implements the ImageAccessible class.
type imageAccessible struct {
	WidgetAccessible
}

var _ ImageAccessible = (*imageAccessible)(nil)

// WrapImageAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapImageAccessible(obj *externglib.Object) ImageAccessible {
	return imageAccessible{
		WidgetAccessible: WrapWidgetAccessible(obj),
	}
}

func marshalImageAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapImageAccessible(obj), nil
}

type ImageCellAccessible interface {
	RendererCellAccessible
}

// imageCellAccessible implements the ImageCellAccessible class.
type imageCellAccessible struct {
	RendererCellAccessible
}

var _ ImageCellAccessible = (*imageCellAccessible)(nil)

// WrapImageCellAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapImageCellAccessible(obj *externglib.Object) ImageCellAccessible {
	return imageCellAccessible{
		RendererCellAccessible: WrapRendererCellAccessible(obj),
	}
}

func marshalImageCellAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapImageCellAccessible(obj), nil
}

// ImageMenuItem: a GtkImageMenuItem is a menu item which has an icon next to
// the text label.
//
// This is functionally equivalent to:
//
//      GtkWidget *box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 6);
//      GtkWidget *icon = gtk_image_new_from_icon_name ("folder-music-symbolic", GTK_ICON_SIZE_MENU);
//      GtkWidget *label = gtk_accel_label_new ("Music");
//      GtkWidget *menu_item = gtk_menu_item_new ();
//      GtkAccelGroup *accel_group = gtk_accel_group_new ();
//
//      gtk_container_add (GTK_CONTAINER (box), icon);
//
//      gtk_label_set_use_underline (GTK_LABEL (label), TRUE);
//      gtk_label_set_xalign (GTK_LABEL (label), 0.0);
//
//      gtk_widget_add_accelerator (menu_item, "activate", accel_group,
//                                  GDK_KEY_m, GDK_CONTROL_MASK, GTK_ACCEL_VISIBLE);
//      gtk_accel_label_set_accel_widget (GTK_ACCEL_LABEL (label), menu_item);
//
//      gtk_box_pack_end (GTK_BOX (box), label, TRUE, TRUE, 0);
//
//      gtk_container_add (GTK_CONTAINER (menu_item), box);
//
//      gtk_widget_show_all (menu_item);
type ImageMenuItem interface {
	MenuItem
	Actionable
	Activatable
	Buildable

	// AlwaysShowImage returns whether the menu item will ignore the
	// Settings:gtk-menu-images setting and always show the image, if available.
	AlwaysShowImage() bool
	// Image gets the widget that is currently set as the image of
	// @image_menu_item. See gtk_image_menu_item_set_image().
	Image() Widget
	// UseStock checks whether the label set in the menuitem is used as a stock
	// id to select the stock item for the item.
	UseStock() bool
	// SetAccelGroup specifies an @accel_group to add the menu items accelerator
	// to (this only applies to stock items so a stock item must already be set,
	// make sure to call gtk_image_menu_item_set_use_stock() and
	// gtk_menu_item_set_label() with a valid stock item first).
	//
	// If you want this menu item to have changeable accelerators then you
	// shouldnt need this (see gtk_image_menu_item_new_from_stock()).
	SetAccelGroup(accelGroup AccelGroup)
	// SetAlwaysShowImage: if true, the menu item will ignore the
	// Settings:gtk-menu-images setting and always show the image, if available.
	//
	// Use this property if the menuitem would be useless or hard to use without
	// the image.
	SetAlwaysShowImage(alwaysShow bool)
	// SetImage sets the image of @image_menu_item to the given widget. Note
	// that it depends on the show-menu-images setting whether the image will be
	// displayed or not.
	SetImage(image Widget)
	// SetUseStock: if true, the label set in the menuitem is used as a stock id
	// to select the stock item for the item.
	SetUseStock(useStock bool)
}

// imageMenuItem implements the ImageMenuItem class.
type imageMenuItem struct {
	MenuItem
	Actionable
	Activatable
	Buildable
}

var _ ImageMenuItem = (*imageMenuItem)(nil)

// WrapImageMenuItem wraps a GObject to the right type. It is
// primarily used internally.
func WrapImageMenuItem(obj *externglib.Object) ImageMenuItem {
	return imageMenuItem{
		MenuItem:    WrapMenuItem(obj),
		Actionable:  WrapActionable(obj),
		Activatable: WrapActivatable(obj),
		Buildable:   WrapBuildable(obj),
	}
}

func marshalImageMenuItem(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapImageMenuItem(obj), nil
}

// NewImageMenuItem creates a new ImageMenuItem with an empty label.
func NewImageMenuItem() ImageMenuItem {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_image_menu_item_new()

	var _imageMenuItem ImageMenuItem // out

	_imageMenuItem = WrapImageMenuItem(externglib.Take(unsafe.Pointer(_cret)))

	return _imageMenuItem
}

// NewImageMenuItemFromStock creates a new ImageMenuItem containing the image
// and text from a stock item. Some stock ids have preprocessor macros like
// K_STOCK_OK and K_STOCK_APPLY.
//
// If you want this menu item to have changeable accelerators, then pass in nil
// for accel_group. Next call gtk_menu_item_set_accel_path() with an appropriate
// path for the menu item, use gtk_stock_lookup() to look up the standard
// accelerator for the stock item, and if one is found, call
// gtk_accel_map_add_entry() to register it.
func NewImageMenuItemFromStock(stockId string, accelGroup AccelGroup) ImageMenuItem {
	var _arg1 *C.gchar         // out
	var _arg2 *C.GtkAccelGroup // out
	var _cret *C.GtkWidget     // in

	_arg1 = (*C.gchar)(C.CString(stockId))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkAccelGroup)(unsafe.Pointer(accelGroup.Native()))

	_cret = C.gtk_image_menu_item_new_from_stock(_arg1, _arg2)

	var _imageMenuItem ImageMenuItem // out

	_imageMenuItem = WrapImageMenuItem(externglib.Take(unsafe.Pointer(_cret)))

	return _imageMenuItem
}

// NewImageMenuItemWithLabel creates a new ImageMenuItem containing a label.
func NewImageMenuItemWithLabel(label string) ImageMenuItem {
	var _arg1 *C.gchar     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_image_menu_item_new_with_label(_arg1)

	var _imageMenuItem ImageMenuItem // out

	_imageMenuItem = WrapImageMenuItem(externglib.Take(unsafe.Pointer(_cret)))

	return _imageMenuItem
}

// NewImageMenuItemWithMnemonic creates a new ImageMenuItem containing a label.
// The label will be created using gtk_label_new_with_mnemonic(), so underscores
// in @label indicate the mnemonic for the menu item.
func NewImageMenuItemWithMnemonic(label string) ImageMenuItem {
	var _arg1 *C.gchar     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_image_menu_item_new_with_mnemonic(_arg1)

	var _imageMenuItem ImageMenuItem // out

	_imageMenuItem = WrapImageMenuItem(externglib.Take(unsafe.Pointer(_cret)))

	return _imageMenuItem
}

// AlwaysShowImage returns whether the menu item will ignore the
// Settings:gtk-menu-images setting and always show the image, if available.
func (i imageMenuItem) AlwaysShowImage() bool {
	var _arg0 *C.GtkImageMenuItem // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkImageMenuItem)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_image_menu_item_get_always_show_image(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Image gets the widget that is currently set as the image of @image_menu_item.
// See gtk_image_menu_item_set_image().
func (i imageMenuItem) Image() Widget {
	var _arg0 *C.GtkImageMenuItem // out
	var _cret *C.GtkWidget        // in

	_arg0 = (*C.GtkImageMenuItem)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_image_menu_item_get_image(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// UseStock checks whether the label set in the menuitem is used as a stock id
// to select the stock item for the item.
func (i imageMenuItem) UseStock() bool {
	var _arg0 *C.GtkImageMenuItem // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkImageMenuItem)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_image_menu_item_get_use_stock(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetAccelGroup specifies an @accel_group to add the menu items accelerator to
// (this only applies to stock items so a stock item must already be set, make
// sure to call gtk_image_menu_item_set_use_stock() and
// gtk_menu_item_set_label() with a valid stock item first).
//
// If you want this menu item to have changeable accelerators then you shouldnt
// need this (see gtk_image_menu_item_new_from_stock()).
func (i imageMenuItem) SetAccelGroup(accelGroup AccelGroup) {
	var _arg0 *C.GtkImageMenuItem // out
	var _arg1 *C.GtkAccelGroup    // out

	_arg0 = (*C.GtkImageMenuItem)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkAccelGroup)(unsafe.Pointer(accelGroup.Native()))

	C.gtk_image_menu_item_set_accel_group(_arg0, _arg1)
}

// SetAlwaysShowImage: if true, the menu item will ignore the
// Settings:gtk-menu-images setting and always show the image, if available.
//
// Use this property if the menuitem would be useless or hard to use without the
// image.
func (i imageMenuItem) SetAlwaysShowImage(alwaysShow bool) {
	var _arg0 *C.GtkImageMenuItem // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkImageMenuItem)(unsafe.Pointer(i.Native()))
	if alwaysShow {
		_arg1 = C.TRUE
	}

	C.gtk_image_menu_item_set_always_show_image(_arg0, _arg1)
}

// SetImage sets the image of @image_menu_item to the given widget. Note that it
// depends on the show-menu-images setting whether the image will be displayed
// or not.
func (i imageMenuItem) SetImage(image Widget) {
	var _arg0 *C.GtkImageMenuItem // out
	var _arg1 *C.GtkWidget        // out

	_arg0 = (*C.GtkImageMenuItem)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(image.Native()))

	C.gtk_image_menu_item_set_image(_arg0, _arg1)
}

// SetUseStock: if true, the label set in the menuitem is used as a stock id to
// select the stock item for the item.
func (i imageMenuItem) SetUseStock(useStock bool) {
	var _arg0 *C.GtkImageMenuItem // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkImageMenuItem)(unsafe.Pointer(i.Native()))
	if useStock {
		_arg1 = C.TRUE
	}

	C.gtk_image_menu_item_set_use_stock(_arg0, _arg1)
}

// InfoBar is a widget that can be used to show messages to the user without
// showing a dialog. It is often temporarily shown at the top or bottom of a
// document. In contrast to Dialog, which has a action area at the bottom,
// InfoBar has an action area at the side.
//
// The API of InfoBar is very similar to Dialog, allowing you to add buttons to
// the action area with gtk_info_bar_add_button() or
// gtk_info_bar_new_with_buttons(). The sensitivity of action widgets can be
// controlled with gtk_info_bar_set_response_sensitive(). To add widgets to the
// main content area of a InfoBar, use gtk_info_bar_get_content_area() and add
// your widgets to the container.
//
// Similar to MessageDialog, the contents of a InfoBar can by classified as
// error message, warning, informational message, etc, by using
// gtk_info_bar_set_message_type(). GTK+ may use the message type to determine
// how the message is displayed.
//
// A simple example for using a InfoBar:
//
//    GtkWidget *widget, *message_label, *content_area;
//    GtkWidget *grid;
//    GtkInfoBar *bar;
//
//    // set up info bar
//    widget = gtk_info_bar_new ();
//    bar = GTK_INFO_BAR (widget);
//    grid = gtk_grid_new ();
//
//    gtk_widget_set_no_show_all (widget, TRUE);
//    message_label = gtk_label_new ("");
//    content_area = gtk_info_bar_get_content_area (bar);
//    gtk_container_add (GTK_CONTAINER (content_area),
//                       message_label);
//    gtk_info_bar_add_button (bar,
//                             _("_OK"),
//                             GTK_RESPONSE_OK);
//    g_signal_connect (bar,
//                      "response",
//                      G_CALLBACK (gtk_widget_hide),
//                      NULL);
//    gtk_grid_attach (GTK_GRID (grid),
//                     widget,
//                     0, 2, 1, 1);
//
//    // ...
//
//    // show an error message
//    gtk_label_set_text (GTK_LABEL (message_label), "An error occurred!");
//    gtk_info_bar_set_message_type (bar,
//                                   GTK_MESSAGE_ERROR);
//    gtk_widget_show (bar);
//
//
// GtkInfoBar as GtkBuildable
//
// The GtkInfoBar implementation of the GtkBuildable interface exposes the
// content area and action area as internal children with the names
// “content_area” and “action_area”.
//
// GtkInfoBar supports a custom <action-widgets> element, which can contain
// multiple <action-widget> elements. The “response” attribute specifies a
// numeric response, and the content of the element is the id of widget (which
// should be a child of the dialogs @action_area).
//
//
// CSS nodes
//
// GtkInfoBar has a single CSS node with name infobar. The node may get one of
// the style classes .info, .warning, .error or .question, depending on the
// message type.
type InfoBar interface {
	Box
	Buildable
	Orientable

	// AddActionWidget: add an activatable widget to the action area of a
	// InfoBar, connecting a signal handler that will emit the InfoBar::response
	// signal on the message area when the widget is activated. The widget is
	// appended to the end of the message areas action area.
	AddActionWidget(child Widget, responseId int)
	// AddButton adds a button with the given text and sets things up so that
	// clicking the button will emit the “response” signal with the given
	// response_id. The button is appended to the end of the info bars's action
	// area. The button widget is returned, but usually you don't need it.
	AddButton(buttonText string, responseId int) Button
	// ActionArea returns the action area of @info_bar.
	ActionArea() Box
	// ContentArea returns the content area of @info_bar.
	ContentArea() Box
	// MessageType returns the message type of the message area.
	MessageType() MessageType

	Revealed() bool
	// ShowCloseButton returns whether the widget will display a standard close
	// button.
	ShowCloseButton() bool
	// Response emits the “response” signal with the given @response_id.
	Response(responseId int)
	// SetDefaultResponse sets the last widget in the info bar’s action area
	// with the given response_id as the default widget for the dialog. Pressing
	// “Enter” normally activates the default widget.
	//
	// Note that this function currently requires @info_bar to be added to a
	// widget hierarchy.
	SetDefaultResponse(responseId int)
	// SetMessageType sets the message type of the message area.
	//
	// GTK+ uses this type to determine how the message is displayed.
	SetMessageType(messageType MessageType)
	// SetResponseSensitive calls gtk_widget_set_sensitive (widget, setting) for
	// each widget in the info bars’s action area with the given response_id. A
	// convenient way to sensitize/desensitize dialog buttons.
	SetResponseSensitive(responseId int, setting bool)
	// SetRevealed sets the GtkInfoBar:revealed property to @revealed. This will
	// cause @info_bar to show up with a slide-in transition.
	//
	// Note that this property does not automatically show @info_bar and thus
	// won’t have any effect if it is invisible.
	SetRevealed(revealed bool)
	// SetShowCloseButton: if true, a standard close button is shown. When
	// clicked it emits the response GTK_RESPONSE_CLOSE.
	SetShowCloseButton(setting bool)
}

// infoBar implements the InfoBar class.
type infoBar struct {
	Box
	Buildable
	Orientable
}

var _ InfoBar = (*infoBar)(nil)

// WrapInfoBar wraps a GObject to the right type. It is
// primarily used internally.
func WrapInfoBar(obj *externglib.Object) InfoBar {
	return infoBar{
		Box:        WrapBox(obj),
		Buildable:  WrapBuildable(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalInfoBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapInfoBar(obj), nil
}

// NewInfoBar creates a new InfoBar object.
func NewInfoBar() InfoBar {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_info_bar_new()

	var _infoBar InfoBar // out

	_infoBar = WrapInfoBar(externglib.Take(unsafe.Pointer(_cret)))

	return _infoBar
}

// AddActionWidget: add an activatable widget to the action area of a InfoBar,
// connecting a signal handler that will emit the InfoBar::response signal on
// the message area when the widget is activated. The widget is appended to the
// end of the message areas action area.
func (i infoBar) AddActionWidget(child Widget, responseId int) {
	var _arg0 *C.GtkInfoBar // out
	var _arg1 *C.GtkWidget  // out
	var _arg2 C.gint        // out

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (C.gint)(responseId)

	C.gtk_info_bar_add_action_widget(_arg0, _arg1, _arg2)
}

// AddButton adds a button with the given text and sets things up so that
// clicking the button will emit the “response” signal with the given
// response_id. The button is appended to the end of the info bars's action
// area. The button widget is returned, but usually you don't need it.
func (i infoBar) AddButton(buttonText string, responseId int) Button {
	var _arg0 *C.GtkInfoBar // out
	var _arg1 *C.gchar      // out
	var _arg2 C.gint        // out
	var _cret *C.GtkWidget  // in

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(buttonText))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gint)(responseId)

	_cret = C.gtk_info_bar_add_button(_arg0, _arg1, _arg2)

	var _button Button // out

	_button = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Button)

	return _button
}

// ActionArea returns the action area of @info_bar.
func (i infoBar) ActionArea() Box {
	var _arg0 *C.GtkInfoBar // out
	var _cret *C.GtkWidget  // in

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_info_bar_get_action_area(_arg0)

	var _box Box // out

	_box = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Box)

	return _box
}

// ContentArea returns the content area of @info_bar.
func (i infoBar) ContentArea() Box {
	var _arg0 *C.GtkInfoBar // out
	var _cret *C.GtkWidget  // in

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_info_bar_get_content_area(_arg0)

	var _box Box // out

	_box = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Box)

	return _box
}

// MessageType returns the message type of the message area.
func (i infoBar) MessageType() MessageType {
	var _arg0 *C.GtkInfoBar    // out
	var _cret C.GtkMessageType // in

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_info_bar_get_message_type(_arg0)

	var _messageType MessageType // out

	_messageType = MessageType(_cret)

	return _messageType
}

func (i infoBar) Revealed() bool {
	var _arg0 *C.GtkInfoBar // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_info_bar_get_revealed(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowCloseButton returns whether the widget will display a standard close
// button.
func (i infoBar) ShowCloseButton() bool {
	var _arg0 *C.GtkInfoBar // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_info_bar_get_show_close_button(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Response emits the “response” signal with the given @response_id.
func (i infoBar) Response(responseId int) {
	var _arg0 *C.GtkInfoBar // out
	var _arg1 C.gint        // out

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(responseId)

	C.gtk_info_bar_response(_arg0, _arg1)
}

// SetDefaultResponse sets the last widget in the info bar’s action area with
// the given response_id as the default widget for the dialog. Pressing “Enter”
// normally activates the default widget.
//
// Note that this function currently requires @info_bar to be added to a widget
// hierarchy.
func (i infoBar) SetDefaultResponse(responseId int) {
	var _arg0 *C.GtkInfoBar // out
	var _arg1 C.gint        // out

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(responseId)

	C.gtk_info_bar_set_default_response(_arg0, _arg1)
}

// SetMessageType sets the message type of the message area.
//
// GTK+ uses this type to determine how the message is displayed.
func (i infoBar) SetMessageType(messageType MessageType) {
	var _arg0 *C.GtkInfoBar    // out
	var _arg1 C.GtkMessageType // out

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	_arg1 = (C.GtkMessageType)(messageType)

	C.gtk_info_bar_set_message_type(_arg0, _arg1)
}

// SetResponseSensitive calls gtk_widget_set_sensitive (widget, setting) for
// each widget in the info bars’s action area with the given response_id. A
// convenient way to sensitize/desensitize dialog buttons.
func (i infoBar) SetResponseSensitive(responseId int, setting bool) {
	var _arg0 *C.GtkInfoBar // out
	var _arg1 C.gint        // out
	var _arg2 C.gboolean    // out

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(responseId)
	if setting {
		_arg2 = C.TRUE
	}

	C.gtk_info_bar_set_response_sensitive(_arg0, _arg1, _arg2)
}

// SetRevealed sets the GtkInfoBar:revealed property to @revealed. This will
// cause @info_bar to show up with a slide-in transition.
//
// Note that this property does not automatically show @info_bar and thus won’t
// have any effect if it is invisible.
func (i infoBar) SetRevealed(revealed bool) {
	var _arg0 *C.GtkInfoBar // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	if revealed {
		_arg1 = C.TRUE
	}

	C.gtk_info_bar_set_revealed(_arg0, _arg1)
}

// SetShowCloseButton: if true, a standard close button is shown. When clicked
// it emits the response GTK_RESPONSE_CLOSE.
func (i infoBar) SetShowCloseButton(setting bool) {
	var _arg0 *C.GtkInfoBar // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_info_bar_set_show_close_button(_arg0, _arg1)
}

// Invisible: the Invisible widget is used internally in GTK+, and is probably
// not very useful for application developers.
//
// It is used for reliable pointer grabs and selection handling in the code for
// drag-and-drop.
type Invisible interface {
	Widget
	Buildable

	// Screen returns the Screen object associated with @invisible
	Screen() gdk.Screen
	// SetScreen sets the Screen where the Invisible object will be displayed.
	SetScreen(screen gdk.Screen)
}

// invisible implements the Invisible class.
type invisible struct {
	Widget
	Buildable
}

var _ Invisible = (*invisible)(nil)

// WrapInvisible wraps a GObject to the right type. It is
// primarily used internally.
func WrapInvisible(obj *externglib.Object) Invisible {
	return invisible{
		Widget:    WrapWidget(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalInvisible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapInvisible(obj), nil
}

// NewInvisible creates a new Invisible.
func NewInvisible() Invisible {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_invisible_new()

	var _invisible Invisible // out

	_invisible = WrapInvisible(externglib.Take(unsafe.Pointer(_cret)))

	return _invisible
}

// NewInvisibleForScreen creates a new Invisible object for a specified screen
func NewInvisibleForScreen(screen gdk.Screen) Invisible {
	var _arg1 *C.GdkScreen // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.GdkScreen)(unsafe.Pointer(screen.Native()))

	_cret = C.gtk_invisible_new_for_screen(_arg1)

	var _invisible Invisible // out

	_invisible = WrapInvisible(externglib.Take(unsafe.Pointer(_cret)))

	return _invisible
}

// Screen returns the Screen object associated with @invisible
func (i invisible) Screen() gdk.Screen {
	var _arg0 *C.GtkInvisible // out
	var _cret *C.GdkScreen    // in

	_arg0 = (*C.GtkInvisible)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_invisible_get_screen(_arg0)

	var _screen gdk.Screen // out

	_screen = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Screen)

	return _screen
}

// SetScreen sets the Screen where the Invisible object will be displayed.
func (i invisible) SetScreen(screen gdk.Screen) {
	var _arg0 *C.GtkInvisible // out
	var _arg1 *C.GdkScreen    // out

	_arg0 = (*C.GtkInvisible)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GdkScreen)(unsafe.Pointer(screen.Native()))

	C.gtk_invisible_set_screen(_arg0, _arg1)
}

// Label: the Label widget displays a small amount of text. As the name implies,
// most labels are used to label another widget such as a Button, a MenuItem, or
// a ComboBox.
//
// CSS nodes
//
//    const gchar *text =
//    "Go to the"
//    "<a href=\"http://www.gtk.org title=\"&lt;i&gt;Our&lt;/i&gt; website\">"
//    "GTK+ website</a> for more...";
//    GtkWidget *label = gtk_label_new (NULL);
//    gtk_label_set_markup (GTK_LABEL (label), text);
//
// It is possible to implement custom handling for links and their tooltips with
// the Label::activate-link signal and the gtk_label_get_current_uri() function.
type Label interface {
	Misc
	Buildable

	// Angle gets the angle of rotation for the label. See
	// gtk_label_set_angle().
	Angle() float64
	// Attributes gets the attribute list that was set on the label using
	// gtk_label_set_attributes(), if any. This function does not reflect
	// attributes that come from the labels markup (see gtk_label_set_markup()).
	// If you want to get the effective attributes for the label, use
	// pango_layout_get_attribute (gtk_label_get_layout (label)).
	Attributes() *pango.AttrList
	// CurrentURI returns the URI for the currently active link in the label.
	// The active link is the one under the mouse pointer or, in a selectable
	// label, the link in which the text cursor is currently positioned.
	//
	// This function is intended for use in a Label::activate-link handler or
	// for use in a Widget::query-tooltip handler.
	CurrentURI() string
	// Ellipsize returns the ellipsizing position of the label. See
	// gtk_label_set_ellipsize().
	Ellipsize() pango.EllipsizeMode
	// Justify returns the justification of the label. See
	// gtk_label_set_justify().
	Justify() Justification
	// Label fetches the text from a label widget including any embedded
	// underlines indicating mnemonics and Pango markup. (See
	// gtk_label_get_text()).
	Label() string
	// Layout gets the Layout used to display the label. The layout is useful to
	// e.g. convert text positions to pixel positions, in combination with
	// gtk_label_get_layout_offsets(). The returned layout is owned by the
	// @label so need not be freed by the caller. The @label is free to recreate
	// its layout at any time, so it should be considered read-only.
	Layout() pango.Layout
	// LayoutOffsets obtains the coordinates where the label will draw the
	// Layout representing the text in the label; useful to convert mouse events
	// into coordinates inside the Layout, e.g. to take some action if some part
	// of the label is clicked. Of course you will need to create a EventBox to
	// receive the events, and pack the label inside it, since labels are
	// windowless (they return false from gtk_widget_get_has_window()). Remember
	// when using the Layout functions you need to convert to and from pixels
	// using PANGO_PIXELS() or NGO_SCALE.
	LayoutOffsets() (x int, y int)
	// LineWrap returns whether lines in the label are automatically wrapped.
	// See gtk_label_set_line_wrap().
	LineWrap() bool
	// LineWrapMode returns line wrap mode used by the label. See
	// gtk_label_set_line_wrap_mode().
	LineWrapMode() pango.WrapMode
	// Lines gets the number of lines to which an ellipsized, wrapping label
	// should be limited. See gtk_label_set_lines().
	Lines() int
	// MaxWidthChars retrieves the desired maximum width of @label, in
	// characters. See gtk_label_set_width_chars().
	MaxWidthChars() int
	// MnemonicKeyval: if the label has been set so that it has an mnemonic key
	// this function returns the keyval used for the mnemonic accelerator. If
	// there is no mnemonic set up it returns K_KEY_VoidSymbol.
	MnemonicKeyval() uint
	// MnemonicWidget retrieves the target of the mnemonic (keyboard shortcut)
	// of this label. See gtk_label_set_mnemonic_widget().
	MnemonicWidget() Widget
	// Selectable gets the value set by gtk_label_set_selectable().
	Selectable() bool
	// SelectionBounds gets the selected range of characters in the label,
	// returning true if there’s a selection.
	SelectionBounds() (start int, end int, ok bool)
	// SingleLineMode returns whether the label is in single line mode.
	SingleLineMode() bool
	// Text fetches the text from a label widget, as displayed on the screen.
	// This does not include any embedded underlines indicating mnemonics or
	// Pango markup. (See gtk_label_get_label())
	Text() string
	// TrackVisitedLinks returns whether the label is currently keeping track of
	// clicked links.
	TrackVisitedLinks() bool
	// UseMarkup returns whether the label’s text is interpreted as marked up
	// with the [Pango text markup language][PangoMarkupFormat]. See
	// gtk_label_set_use_markup ().
	UseMarkup() bool
	// UseUnderline returns whether an embedded underline in the label indicates
	// a mnemonic. See gtk_label_set_use_underline().
	UseUnderline() bool
	// WidthChars retrieves the desired width of @label, in characters. See
	// gtk_label_set_width_chars().
	WidthChars() int
	// Xalign gets the Label:xalign property for @label.
	Xalign() float32
	// Yalign gets the Label:yalign property for @label.
	Yalign() float32
	// SelectRegion selects a range of characters in the label, if the label is
	// selectable. See gtk_label_set_selectable(). If the label is not
	// selectable, this function has no effect. If @start_offset or @end_offset
	// are -1, then the end of the label will be substituted.
	SelectRegion(startOffset int, endOffset int)
	// SetAngle sets the angle of rotation for the label. An angle of 90 reads
	// from from bottom to top, an angle of 270, from top to bottom. The angle
	// setting for the label is ignored if the label is selectable, wrapped, or
	// ellipsized.
	SetAngle(angle float64)
	// SetAttributes sets a AttrList; the attributes in the list are applied to
	// the label text.
	//
	// The attributes set with this function will be applied and merged with any
	// other attributes previously effected by way of the Label:use-underline or
	// Label:use-markup properties. While it is not recommended to mix markup
	// strings with manually set attributes, if you must; know that the
	// attributes will be applied to the label after the markup string is
	// parsed.
	SetAttributes(attrs *pango.AttrList)
	// SetEllipsize sets the mode used to ellipsize (add an ellipsis: "...") to
	// the text if there is not enough space to render the entire string.
	SetEllipsize(mode pango.EllipsizeMode)
	// SetJustify sets the alignment of the lines in the text of the label
	// relative to each other. GTK_JUSTIFY_LEFT is the default value when the
	// widget is first created with gtk_label_new(). If you instead want to set
	// the alignment of the label as a whole, use gtk_widget_set_halign()
	// instead. gtk_label_set_justify() has no effect on labels containing only
	// a single line.
	SetJustify(jtype Justification)
	// SetLabel sets the text of the label. The label is interpreted as
	// including embedded underlines and/or Pango markup depending on the values
	// of the Label:use-underline and Label:use-markup properties.
	SetLabel(str string)
	// SetLineWrap toggles line wrapping within the Label widget. true makes it
	// break lines if text exceeds the widget’s size. false lets the text get
	// cut off by the edge of the widget if it exceeds the widget size.
	//
	// Note that setting line wrapping to true does not make the label wrap at
	// its parent container’s width, because GTK+ widgets conceptually can’t
	// make their requisition depend on the parent container’s size. For a label
	// that wraps at a specific position, set the label’s width using
	// gtk_widget_set_size_request().
	SetLineWrap(wrap bool)
	// SetLineWrapMode: if line wrapping is on (see gtk_label_set_line_wrap())
	// this controls how the line wrapping is done. The default is
	// PANGO_WRAP_WORD which means wrap on word boundaries.
	SetLineWrapMode(wrapMode pango.WrapMode)
	// SetLines sets the number of lines to which an ellipsized, wrapping label
	// should be limited. This has no effect if the label is not wrapping or
	// ellipsized. Set this to -1 if you don’t want to limit the number of
	// lines.
	SetLines(lines int)
	// SetMarkup parses @str which is marked up with the [Pango text markup
	// language][PangoMarkupFormat], setting the label’s text and attribute list
	// based on the parse results.
	//
	// If the @str is external data, you may need to escape it with
	// g_markup_escape_text() or g_markup_printf_escaped():
	//
	//    GtkWidget *label = gtk_label_new (NULL);
	//    const char *str = "some text";
	//    const char *format = "<span style=\"italic\">\s</span>";
	//    char *markup;
	//
	//    markup = g_markup_printf_escaped (format, str);
	//    gtk_label_set_markup (GTK_LABEL (label), markup);
	//    g_free (markup);
	//
	// This function will set the Label:use-markup property to true as a side
	// effect.
	//
	// If you set the label contents using the Label:label property you should
	// also ensure that you set the Label:use-markup property accordingly.
	//
	// See also: gtk_label_set_text()
	SetMarkup(str string)
	// SetMarkupWithMnemonic parses @str which is marked up with the [Pango text
	// markup language][PangoMarkupFormat], setting the label’s text and
	// attribute list based on the parse results. If characters in @str are
	// preceded by an underscore, they are underlined indicating that they
	// represent a keyboard accelerator called a mnemonic.
	//
	// The mnemonic key can be used to activate another widget, chosen
	// automatically, or explicitly using gtk_label_set_mnemonic_widget().
	SetMarkupWithMnemonic(str string)
	// SetMaxWidthChars sets the desired maximum width in characters of @label
	// to @n_chars.
	SetMaxWidthChars(nChars int)
	// SetMnemonicWidget: if the label has been set so that it has an mnemonic
	// key (using i.e. gtk_label_set_markup_with_mnemonic(),
	// gtk_label_set_text_with_mnemonic(), gtk_label_new_with_mnemonic() or the
	// “use_underline” property) the label can be associated with a widget that
	// is the target of the mnemonic. When the label is inside a widget (like a
	// Button or a Notebook tab) it is automatically associated with the correct
	// widget, but sometimes (i.e. when the target is a Entry next to the label)
	// you need to set it explicitly using this function.
	//
	// The target widget will be accelerated by emitting the
	// GtkWidget::mnemonic-activate signal on it. The default handler for this
	// signal will activate the widget if there are no mnemonic collisions and
	// toggle focus between the colliding widgets otherwise.
	SetMnemonicWidget(widget Widget)
	// SetPattern: the pattern of underlines you want under the existing text
	// within the Label widget. For example if the current text of the label
	// says “FooBarBaz” passing a pattern of “___ ___” will underline “Foo” and
	// “Baz” but not “Bar”.
	SetPattern(pattern string)
	// SetSelectable: selectable labels allow the user to select text from the
	// label, for copy-and-paste.
	SetSelectable(setting bool)
	// SetSingleLineMode sets whether the label is in single line mode.
	SetSingleLineMode(singleLineMode bool)
	// SetText sets the text within the Label widget. It overwrites any text
	// that was there before.
	//
	// This function will clear any previously set mnemonic accelerators, and
	// set the Label:use-underline property to false as a side effect.
	//
	// This function will set the Label:use-markup property to false as a side
	// effect.
	//
	// See also: gtk_label_set_markup()
	SetText(str string)
	// SetTextWithMnemonic sets the label’s text from the string @str. If
	// characters in @str are preceded by an underscore, they are underlined
	// indicating that they represent a keyboard accelerator called a mnemonic.
	// The mnemonic key can be used to activate another widget, chosen
	// automatically, or explicitly using gtk_label_set_mnemonic_widget().
	SetTextWithMnemonic(str string)
	// SetTrackVisitedLinks sets whether the label should keep track of clicked
	// links (and use a different color for them).
	SetTrackVisitedLinks(trackLinks bool)
	// SetUseMarkup sets whether the text of the label contains markup in
	// [Pango’s text markup language][PangoMarkupFormat]. See
	// gtk_label_set_markup().
	SetUseMarkup(setting bool)
	// SetUseUnderline: if true, an underline in the text indicates the next
	// character should be used for the mnemonic accelerator key.
	SetUseUnderline(setting bool)
	// SetWidthChars sets the desired width in characters of @label to @n_chars.
	SetWidthChars(nChars int)
	// SetXalign sets the Label:xalign property for @label.
	SetXalign(xalign float32)
	// SetYalign sets the Label:yalign property for @label.
	SetYalign(yalign float32)
}

// label implements the Label class.
type label struct {
	Misc
	Buildable
}

var _ Label = (*label)(nil)

// WrapLabel wraps a GObject to the right type. It is
// primarily used internally.
func WrapLabel(obj *externglib.Object) Label {
	return label{
		Misc:      WrapMisc(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalLabel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLabel(obj), nil
}

// NewLabel creates a new label with the given text inside it. You can pass nil
// to get an empty label widget.
func NewLabel(str string) Label {
	var _arg1 *C.gchar     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_label_new(_arg1)

	var _label Label // out

	_label = WrapLabel(externglib.Take(unsafe.Pointer(_cret)))

	return _label
}

// NewLabelWithMnemonic creates a new Label, containing the text in @str.
//
// If characters in @str are preceded by an underscore, they are underlined. If
// you need a literal underscore character in a label, use '__' (two
// underscores). The first underlined character represents a keyboard
// accelerator called a mnemonic. The mnemonic key can be used to activate
// another widget, chosen automatically, or explicitly using
// gtk_label_set_mnemonic_widget().
//
// If gtk_label_set_mnemonic_widget() is not called, then the first activatable
// ancestor of the Label will be chosen as the mnemonic widget. For instance, if
// the label is inside a button or menu item, the button or menu item will
// automatically become the mnemonic widget and be activated by the mnemonic.
func NewLabelWithMnemonic(str string) Label {
	var _arg1 *C.gchar     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_label_new_with_mnemonic(_arg1)

	var _label Label // out

	_label = WrapLabel(externglib.Take(unsafe.Pointer(_cret)))

	return _label
}

// Angle gets the angle of rotation for the label. See gtk_label_set_angle().
func (l label) Angle() float64 {
	var _arg0 *C.GtkLabel // out
	var _cret C.gdouble   // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	_cret = C.gtk_label_get_angle(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// Attributes gets the attribute list that was set on the label using
// gtk_label_set_attributes(), if any. This function does not reflect attributes
// that come from the labels markup (see gtk_label_set_markup()). If you want to
// get the effective attributes for the label, use pango_layout_get_attribute
// (gtk_label_get_layout (label)).
func (l label) Attributes() *pango.AttrList {
	var _arg0 *C.GtkLabel      // out
	var _cret *C.PangoAttrList // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	_cret = C.gtk_label_get_attributes(_arg0)

	var _attrList *pango.AttrList // out

	_attrList = pango.WrapAttrList(unsafe.Pointer(_cret))

	return _attrList
}

// CurrentURI returns the URI for the currently active link in the label. The
// active link is the one under the mouse pointer or, in a selectable label, the
// link in which the text cursor is currently positioned.
//
// This function is intended for use in a Label::activate-link handler or for
// use in a Widget::query-tooltip handler.
func (l label) CurrentURI() string {
	var _arg0 *C.GtkLabel // out
	var _cret *C.gchar    // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	_cret = C.gtk_label_get_current_uri(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Ellipsize returns the ellipsizing position of the label. See
// gtk_label_set_ellipsize().
func (l label) Ellipsize() pango.EllipsizeMode {
	var _arg0 *C.GtkLabel          // out
	var _cret C.PangoEllipsizeMode // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	_cret = C.gtk_label_get_ellipsize(_arg0)

	var _ellipsizeMode pango.EllipsizeMode // out

	_ellipsizeMode = pango.EllipsizeMode(_cret)

	return _ellipsizeMode
}

// Justify returns the justification of the label. See gtk_label_set_justify().
func (l label) Justify() Justification {
	var _arg0 *C.GtkLabel        // out
	var _cret C.GtkJustification // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	_cret = C.gtk_label_get_justify(_arg0)

	var _justification Justification // out

	_justification = Justification(_cret)

	return _justification
}

// Label fetches the text from a label widget including any embedded underlines
// indicating mnemonics and Pango markup. (See gtk_label_get_text()).
func (l label) Label() string {
	var _arg0 *C.GtkLabel // out
	var _cret *C.gchar    // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	_cret = C.gtk_label_get_label(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Layout gets the Layout used to display the label. The layout is useful to
// e.g. convert text positions to pixel positions, in combination with
// gtk_label_get_layout_offsets(). The returned layout is owned by the @label so
// need not be freed by the caller. The @label is free to recreate its layout at
// any time, so it should be considered read-only.
func (l label) Layout() pango.Layout {
	var _arg0 *C.GtkLabel    // out
	var _cret *C.PangoLayout // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	_cret = C.gtk_label_get_layout(_arg0)

	var _layout pango.Layout // out

	_layout = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(pango.Layout)

	return _layout
}

// LayoutOffsets obtains the coordinates where the label will draw the Layout
// representing the text in the label; useful to convert mouse events into
// coordinates inside the Layout, e.g. to take some action if some part of the
// label is clicked. Of course you will need to create a EventBox to receive the
// events, and pack the label inside it, since labels are windowless (they
// return false from gtk_widget_get_has_window()). Remember when using the
// Layout functions you need to convert to and from pixels using PANGO_PIXELS()
// or NGO_SCALE.
func (l label) LayoutOffsets() (x int, y int) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.gint      // in
	var _arg2 C.gint      // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	C.gtk_label_get_layout_offsets(_arg0, &_arg1, &_arg2)

	var _x int // out
	var _y int // out

	_x = (int)(_arg1)
	_y = (int)(_arg2)

	return _x, _y
}

// LineWrap returns whether lines in the label are automatically wrapped. See
// gtk_label_set_line_wrap().
func (l label) LineWrap() bool {
	var _arg0 *C.GtkLabel // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	_cret = C.gtk_label_get_line_wrap(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LineWrapMode returns line wrap mode used by the label. See
// gtk_label_set_line_wrap_mode().
func (l label) LineWrapMode() pango.WrapMode {
	var _arg0 *C.GtkLabel     // out
	var _cret C.PangoWrapMode // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	_cret = C.gtk_label_get_line_wrap_mode(_arg0)

	var _wrapMode pango.WrapMode // out

	_wrapMode = pango.WrapMode(_cret)

	return _wrapMode
}

// Lines gets the number of lines to which an ellipsized, wrapping label should
// be limited. See gtk_label_set_lines().
func (l label) Lines() int {
	var _arg0 *C.GtkLabel // out
	var _cret C.gint      // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	_cret = C.gtk_label_get_lines(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// MaxWidthChars retrieves the desired maximum width of @label, in characters.
// See gtk_label_set_width_chars().
func (l label) MaxWidthChars() int {
	var _arg0 *C.GtkLabel // out
	var _cret C.gint      // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	_cret = C.gtk_label_get_max_width_chars(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// MnemonicKeyval: if the label has been set so that it has an mnemonic key this
// function returns the keyval used for the mnemonic accelerator. If there is no
// mnemonic set up it returns K_KEY_VoidSymbol.
func (l label) MnemonicKeyval() uint {
	var _arg0 *C.GtkLabel // out
	var _cret C.guint     // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	_cret = C.gtk_label_get_mnemonic_keyval(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// MnemonicWidget retrieves the target of the mnemonic (keyboard shortcut) of
// this label. See gtk_label_set_mnemonic_widget().
func (l label) MnemonicWidget() Widget {
	var _arg0 *C.GtkLabel  // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	_cret = C.gtk_label_get_mnemonic_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// Selectable gets the value set by gtk_label_set_selectable().
func (l label) Selectable() bool {
	var _arg0 *C.GtkLabel // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	_cret = C.gtk_label_get_selectable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SelectionBounds gets the selected range of characters in the label, returning
// true if there’s a selection.
func (l label) SelectionBounds() (start int, end int, ok bool) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.gint      // in
	var _arg2 C.gint      // in
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	_cret = C.gtk_label_get_selection_bounds(_arg0, &_arg1, &_arg2)

	var _start int // out
	var _end int   // out
	var _ok bool   // out

	_start = (int)(_arg1)
	_end = (int)(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _start, _end, _ok
}

// SingleLineMode returns whether the label is in single line mode.
func (l label) SingleLineMode() bool {
	var _arg0 *C.GtkLabel // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	_cret = C.gtk_label_get_single_line_mode(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Text fetches the text from a label widget, as displayed on the screen. This
// does not include any embedded underlines indicating mnemonics or Pango
// markup. (See gtk_label_get_label())
func (l label) Text() string {
	var _arg0 *C.GtkLabel // out
	var _cret *C.gchar    // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	_cret = C.gtk_label_get_text(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// TrackVisitedLinks returns whether the label is currently keeping track of
// clicked links.
func (l label) TrackVisitedLinks() bool {
	var _arg0 *C.GtkLabel // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	_cret = C.gtk_label_get_track_visited_links(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UseMarkup returns whether the label’s text is interpreted as marked up with
// the [Pango text markup language][PangoMarkupFormat]. See
// gtk_label_set_use_markup ().
func (l label) UseMarkup() bool {
	var _arg0 *C.GtkLabel // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	_cret = C.gtk_label_get_use_markup(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UseUnderline returns whether an embedded underline in the label indicates a
// mnemonic. See gtk_label_set_use_underline().
func (l label) UseUnderline() bool {
	var _arg0 *C.GtkLabel // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	_cret = C.gtk_label_get_use_underline(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// WidthChars retrieves the desired width of @label, in characters. See
// gtk_label_set_width_chars().
func (l label) WidthChars() int {
	var _arg0 *C.GtkLabel // out
	var _cret C.gint      // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	_cret = C.gtk_label_get_width_chars(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Xalign gets the Label:xalign property for @label.
func (l label) Xalign() float32 {
	var _arg0 *C.GtkLabel // out
	var _cret C.gfloat    // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	_cret = C.gtk_label_get_xalign(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Yalign gets the Label:yalign property for @label.
func (l label) Yalign() float32 {
	var _arg0 *C.GtkLabel // out
	var _cret C.gfloat    // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

	_cret = C.gtk_label_get_yalign(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// SelectRegion selects a range of characters in the label, if the label is
// selectable. See gtk_label_set_selectable(). If the label is not selectable,
// this function has no effect. If @start_offset or @end_offset are -1, then the
// end of the label will be substituted.
func (l label) SelectRegion(startOffset int, endOffset int) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.gint      // out
	var _arg2 C.gint      // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	_arg1 = (C.gint)(startOffset)
	_arg2 = (C.gint)(endOffset)

	C.gtk_label_select_region(_arg0, _arg1, _arg2)
}

// SetAngle sets the angle of rotation for the label. An angle of 90 reads from
// from bottom to top, an angle of 270, from top to bottom. The angle setting
// for the label is ignored if the label is selectable, wrapped, or ellipsized.
func (l label) SetAngle(angle float64) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.gdouble   // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	_arg1 = (C.gdouble)(angle)

	C.gtk_label_set_angle(_arg0, _arg1)
}

// SetAttributes sets a AttrList; the attributes in the list are applied to the
// label text.
//
// The attributes set with this function will be applied and merged with any
// other attributes previously effected by way of the Label:use-underline or
// Label:use-markup properties. While it is not recommended to mix markup
// strings with manually set attributes, if you must; know that the attributes
// will be applied to the label after the markup string is parsed.
func (l label) SetAttributes(attrs *pango.AttrList) {
	var _arg0 *C.GtkLabel      // out
	var _arg1 *C.PangoAttrList // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.PangoAttrList)(unsafe.Pointer(attrs.Native()))

	C.gtk_label_set_attributes(_arg0, _arg1)
}

// SetEllipsize sets the mode used to ellipsize (add an ellipsis: "...") to the
// text if there is not enough space to render the entire string.
func (l label) SetEllipsize(mode pango.EllipsizeMode) {
	var _arg0 *C.GtkLabel          // out
	var _arg1 C.PangoEllipsizeMode // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	_arg1 = (C.PangoEllipsizeMode)(mode)

	C.gtk_label_set_ellipsize(_arg0, _arg1)
}

// SetJustify sets the alignment of the lines in the text of the label relative
// to each other. GTK_JUSTIFY_LEFT is the default value when the widget is first
// created with gtk_label_new(). If you instead want to set the alignment of the
// label as a whole, use gtk_widget_set_halign() instead.
// gtk_label_set_justify() has no effect on labels containing only a single
// line.
func (l label) SetJustify(jtype Justification) {
	var _arg0 *C.GtkLabel        // out
	var _arg1 C.GtkJustification // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	_arg1 = (C.GtkJustification)(jtype)

	C.gtk_label_set_justify(_arg0, _arg1)
}

// SetLabel sets the text of the label. The label is interpreted as including
// embedded underlines and/or Pango markup depending on the values of the
// Label:use-underline and Label:use-markup properties.
func (l label) SetLabel(str string) {
	var _arg0 *C.GtkLabel // out
	var _arg1 *C.gchar    // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_label_set_label(_arg0, _arg1)
}

// SetLineWrap toggles line wrapping within the Label widget. true makes it
// break lines if text exceeds the widget’s size. false lets the text get cut
// off by the edge of the widget if it exceeds the widget size.
//
// Note that setting line wrapping to true does not make the label wrap at its
// parent container’s width, because GTK+ widgets conceptually can’t make their
// requisition depend on the parent container’s size. For a label that wraps at
// a specific position, set the label’s width using
// gtk_widget_set_size_request().
func (l label) SetLineWrap(wrap bool) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	if wrap {
		_arg1 = C.TRUE
	}

	C.gtk_label_set_line_wrap(_arg0, _arg1)
}

// SetLineWrapMode: if line wrapping is on (see gtk_label_set_line_wrap()) this
// controls how the line wrapping is done. The default is PANGO_WRAP_WORD which
// means wrap on word boundaries.
func (l label) SetLineWrapMode(wrapMode pango.WrapMode) {
	var _arg0 *C.GtkLabel     // out
	var _arg1 C.PangoWrapMode // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	_arg1 = (C.PangoWrapMode)(wrapMode)

	C.gtk_label_set_line_wrap_mode(_arg0, _arg1)
}

// SetLines sets the number of lines to which an ellipsized, wrapping label
// should be limited. This has no effect if the label is not wrapping or
// ellipsized. Set this to -1 if you don’t want to limit the number of lines.
func (l label) SetLines(lines int) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.gint      // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	_arg1 = (C.gint)(lines)

	C.gtk_label_set_lines(_arg0, _arg1)
}

// SetMarkup parses @str which is marked up with the [Pango text markup
// language][PangoMarkupFormat], setting the label’s text and attribute list
// based on the parse results.
//
// If the @str is external data, you may need to escape it with
// g_markup_escape_text() or g_markup_printf_escaped():
//
//    GtkWidget *label = gtk_label_new (NULL);
//    const char *str = "some text";
//    const char *format = "<span style=\"italic\">\s</span>";
//    char *markup;
//
//    markup = g_markup_printf_escaped (format, str);
//    gtk_label_set_markup (GTK_LABEL (label), markup);
//    g_free (markup);
//
// This function will set the Label:use-markup property to true as a side
// effect.
//
// If you set the label contents using the Label:label property you should also
// ensure that you set the Label:use-markup property accordingly.
//
// See also: gtk_label_set_text()
func (l label) SetMarkup(str string) {
	var _arg0 *C.GtkLabel // out
	var _arg1 *C.gchar    // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_label_set_markup(_arg0, _arg1)
}

// SetMarkupWithMnemonic parses @str which is marked up with the [Pango text
// markup language][PangoMarkupFormat], setting the label’s text and attribute
// list based on the parse results. If characters in @str are preceded by an
// underscore, they are underlined indicating that they represent a keyboard
// accelerator called a mnemonic.
//
// The mnemonic key can be used to activate another widget, chosen
// automatically, or explicitly using gtk_label_set_mnemonic_widget().
func (l label) SetMarkupWithMnemonic(str string) {
	var _arg0 *C.GtkLabel // out
	var _arg1 *C.gchar    // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_label_set_markup_with_mnemonic(_arg0, _arg1)
}

// SetMaxWidthChars sets the desired maximum width in characters of @label to
// @n_chars.
func (l label) SetMaxWidthChars(nChars int) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.gint      // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	_arg1 = (C.gint)(nChars)

	C.gtk_label_set_max_width_chars(_arg0, _arg1)
}

// SetMnemonicWidget: if the label has been set so that it has an mnemonic key
// (using i.e. gtk_label_set_markup_with_mnemonic(),
// gtk_label_set_text_with_mnemonic(), gtk_label_new_with_mnemonic() or the
// “use_underline” property) the label can be associated with a widget that is
// the target of the mnemonic. When the label is inside a widget (like a Button
// or a Notebook tab) it is automatically associated with the correct widget,
// but sometimes (i.e. when the target is a Entry next to the label) you need to
// set it explicitly using this function.
//
// The target widget will be accelerated by emitting the
// GtkWidget::mnemonic-activate signal on it. The default handler for this
// signal will activate the widget if there are no mnemonic collisions and
// toggle focus between the colliding widgets otherwise.
func (l label) SetMnemonicWidget(widget Widget) {
	var _arg0 *C.GtkLabel  // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_label_set_mnemonic_widget(_arg0, _arg1)
}

// SetPattern: the pattern of underlines you want under the existing text within
// the Label widget. For example if the current text of the label says
// “FooBarBaz” passing a pattern of “___ ___” will underline “Foo” and “Baz” but
// not “Bar”.
func (l label) SetPattern(pattern string) {
	var _arg0 *C.GtkLabel // out
	var _arg1 *C.gchar    // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.gchar)(C.CString(pattern))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_label_set_pattern(_arg0, _arg1)
}

// SetSelectable: selectable labels allow the user to select text from the
// label, for copy-and-paste.
func (l label) SetSelectable(setting bool) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_label_set_selectable(_arg0, _arg1)
}

// SetSingleLineMode sets whether the label is in single line mode.
func (l label) SetSingleLineMode(singleLineMode bool) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	if singleLineMode {
		_arg1 = C.TRUE
	}

	C.gtk_label_set_single_line_mode(_arg0, _arg1)
}

// SetText sets the text within the Label widget. It overwrites any text that
// was there before.
//
// This function will clear any previously set mnemonic accelerators, and set
// the Label:use-underline property to false as a side effect.
//
// This function will set the Label:use-markup property to false as a side
// effect.
//
// See also: gtk_label_set_markup()
func (l label) SetText(str string) {
	var _arg0 *C.GtkLabel // out
	var _arg1 *C.gchar    // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_label_set_text(_arg0, _arg1)
}

// SetTextWithMnemonic sets the label’s text from the string @str. If characters
// in @str are preceded by an underscore, they are underlined indicating that
// they represent a keyboard accelerator called a mnemonic. The mnemonic key can
// be used to activate another widget, chosen automatically, or explicitly using
// gtk_label_set_mnemonic_widget().
func (l label) SetTextWithMnemonic(str string) {
	var _arg0 *C.GtkLabel // out
	var _arg1 *C.gchar    // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_label_set_text_with_mnemonic(_arg0, _arg1)
}

// SetTrackVisitedLinks sets whether the label should keep track of clicked
// links (and use a different color for them).
func (l label) SetTrackVisitedLinks(trackLinks bool) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	if trackLinks {
		_arg1 = C.TRUE
	}

	C.gtk_label_set_track_visited_links(_arg0, _arg1)
}

// SetUseMarkup sets whether the text of the label contains markup in [Pango’s
// text markup language][PangoMarkupFormat]. See gtk_label_set_markup().
func (l label) SetUseMarkup(setting bool) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_label_set_use_markup(_arg0, _arg1)
}

// SetUseUnderline: if true, an underline in the text indicates the next
// character should be used for the mnemonic accelerator key.
func (l label) SetUseUnderline(setting bool) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_label_set_use_underline(_arg0, _arg1)
}

// SetWidthChars sets the desired width in characters of @label to @n_chars.
func (l label) SetWidthChars(nChars int) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.gint      // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	_arg1 = (C.gint)(nChars)

	C.gtk_label_set_width_chars(_arg0, _arg1)
}

// SetXalign sets the Label:xalign property for @label.
func (l label) SetXalign(xalign float32) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.gfloat    // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	_arg1 = (C.gfloat)(xalign)

	C.gtk_label_set_xalign(_arg0, _arg1)
}

// SetYalign sets the Label:yalign property for @label.
func (l label) SetYalign(yalign float32) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.gfloat    // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
	_arg1 = (C.gfloat)(yalign)

	C.gtk_label_set_yalign(_arg0, _arg1)
}

type LabelAccessible interface {
	WidgetAccessible
}

// labelAccessible implements the LabelAccessible class.
type labelAccessible struct {
	WidgetAccessible
}

var _ LabelAccessible = (*labelAccessible)(nil)

// WrapLabelAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapLabelAccessible(obj *externglib.Object) LabelAccessible {
	return labelAccessible{
		WidgetAccessible: WrapWidgetAccessible(obj),
	}
}

func marshalLabelAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLabelAccessible(obj), nil
}

// Layout is similar to DrawingArea in that it’s a “blank slate” and doesn’t do
// anything except paint a blank background by default. It’s different in that
// it supports scrolling natively due to implementing Scrollable, and can
// contain child widgets since it’s a Container.
//
// If you just want to draw, a DrawingArea is a better choice since it has lower
// overhead. If you just need to position child widgets at specific points, then
// Fixed provides that functionality on its own.
//
// When handling expose events on a Layout, you must draw to the Window returned
// by gtk_layout_get_bin_window(), rather than to the one returned by
// gtk_widget_get_window() as you would for a DrawingArea.
type Layout interface {
	Container
	Buildable
	Scrollable

	// BinWindow: retrieve the bin window of the layout used for drawing
	// operations.
	BinWindow() gdk.Window
	// HAdjustment: this function should only be called after the layout has
	// been placed in a ScrolledWindow or otherwise configured for scrolling. It
	// returns the Adjustment used for communication between the horizontal
	// scrollbar and @layout.
	//
	// See ScrolledWindow, Scrollbar, Adjustment for details.
	HAdjustment() Adjustment
	// Size gets the size that has been set on the layout, and that determines
	// the total extents of the layout’s scrollbar area. See gtk_layout_set_size
	// ().
	Size() (width uint, height uint)
	// VAdjustment: this function should only be called after the layout has
	// been placed in a ScrolledWindow or otherwise configured for scrolling. It
	// returns the Adjustment used for communication between the vertical
	// scrollbar and @layout.
	//
	// See ScrolledWindow, Scrollbar, Adjustment for details.
	VAdjustment() Adjustment
	// Move moves a current child of @layout to a new position.
	Move(childWidget Widget, x int, y int)
	// Put adds @child_widget to @layout, at position (@x,@y). @layout becomes
	// the new parent container of @child_widget.
	Put(childWidget Widget, x int, y int)
	// SetHAdjustment sets the horizontal scroll adjustment for the layout.
	//
	// See ScrolledWindow, Scrollbar, Adjustment for details.
	SetHAdjustment(adjustment Adjustment)
	// SetSize sets the size of the scrollable area of the layout.
	SetSize(width uint, height uint)
	// SetVAdjustment sets the vertical scroll adjustment for the layout.
	//
	// See ScrolledWindow, Scrollbar, Adjustment for details.
	SetVAdjustment(adjustment Adjustment)
}

// layout implements the Layout class.
type layout struct {
	Container
	Buildable
	Scrollable
}

var _ Layout = (*layout)(nil)

// WrapLayout wraps a GObject to the right type. It is
// primarily used internally.
func WrapLayout(obj *externglib.Object) Layout {
	return layout{
		Container:  WrapContainer(obj),
		Buildable:  WrapBuildable(obj),
		Scrollable: WrapScrollable(obj),
	}
}

func marshalLayout(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLayout(obj), nil
}

// NewLayout creates a new Layout. Unless you have a specific adjustment you’d
// like the layout to use for scrolling, pass nil for @hadjustment and
// @vadjustment.
func NewLayout(hadjustment Adjustment, vadjustment Adjustment) Layout {
	var _arg1 *C.GtkAdjustment // out
	var _arg2 *C.GtkAdjustment // out
	var _cret *C.GtkWidget     // in

	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(hadjustment.Native()))
	_arg2 = (*C.GtkAdjustment)(unsafe.Pointer(vadjustment.Native()))

	_cret = C.gtk_layout_new(_arg1, _arg2)

	var _layout Layout // out

	_layout = WrapLayout(externglib.Take(unsafe.Pointer(_cret)))

	return _layout
}

// BinWindow: retrieve the bin window of the layout used for drawing operations.
func (l layout) BinWindow() gdk.Window {
	var _arg0 *C.GtkLayout // out
	var _cret *C.GdkWindow // in

	_arg0 = (*C.GtkLayout)(unsafe.Pointer(l.Native()))

	_cret = C.gtk_layout_get_bin_window(_arg0)

	var _window gdk.Window // out

	_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Window)

	return _window
}

// HAdjustment: this function should only be called after the layout has been
// placed in a ScrolledWindow or otherwise configured for scrolling. It returns
// the Adjustment used for communication between the horizontal scrollbar and
// @layout.
//
// See ScrolledWindow, Scrollbar, Adjustment for details.
func (l layout) HAdjustment() Adjustment {
	var _arg0 *C.GtkLayout     // out
	var _cret *C.GtkAdjustment // in

	_arg0 = (*C.GtkLayout)(unsafe.Pointer(l.Native()))

	_cret = C.gtk_layout_get_hadjustment(_arg0)

	var _adjustment Adjustment // out

	_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

	return _adjustment
}

// Size gets the size that has been set on the layout, and that determines the
// total extents of the layout’s scrollbar area. See gtk_layout_set_size ().
func (l layout) Size() (width uint, height uint) {
	var _arg0 *C.GtkLayout // out
	var _arg1 C.guint      // in
	var _arg2 C.guint      // in

	_arg0 = (*C.GtkLayout)(unsafe.Pointer(l.Native()))

	C.gtk_layout_get_size(_arg0, &_arg1, &_arg2)

	var _width uint  // out
	var _height uint // out

	_width = (uint)(_arg1)
	_height = (uint)(_arg2)

	return _width, _height
}

// VAdjustment: this function should only be called after the layout has been
// placed in a ScrolledWindow or otherwise configured for scrolling. It returns
// the Adjustment used for communication between the vertical scrollbar and
// @layout.
//
// See ScrolledWindow, Scrollbar, Adjustment for details.
func (l layout) VAdjustment() Adjustment {
	var _arg0 *C.GtkLayout     // out
	var _cret *C.GtkAdjustment // in

	_arg0 = (*C.GtkLayout)(unsafe.Pointer(l.Native()))

	_cret = C.gtk_layout_get_vadjustment(_arg0)

	var _adjustment Adjustment // out

	_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

	return _adjustment
}

// Move moves a current child of @layout to a new position.
func (l layout) Move(childWidget Widget, x int, y int) {
	var _arg0 *C.GtkLayout // out
	var _arg1 *C.GtkWidget // out
	var _arg2 C.gint       // out
	var _arg3 C.gint       // out

	_arg0 = (*C.GtkLayout)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(childWidget.Native()))
	_arg2 = (C.gint)(x)
	_arg3 = (C.gint)(y)

	C.gtk_layout_move(_arg0, _arg1, _arg2, _arg3)
}

// Put adds @child_widget to @layout, at position (@x,@y). @layout becomes the
// new parent container of @child_widget.
func (l layout) Put(childWidget Widget, x int, y int) {
	var _arg0 *C.GtkLayout // out
	var _arg1 *C.GtkWidget // out
	var _arg2 C.gint       // out
	var _arg3 C.gint       // out

	_arg0 = (*C.GtkLayout)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(childWidget.Native()))
	_arg2 = (C.gint)(x)
	_arg3 = (C.gint)(y)

	C.gtk_layout_put(_arg0, _arg1, _arg2, _arg3)
}

// SetHAdjustment sets the horizontal scroll adjustment for the layout.
//
// See ScrolledWindow, Scrollbar, Adjustment for details.
func (l layout) SetHAdjustment(adjustment Adjustment) {
	var _arg0 *C.GtkLayout     // out
	var _arg1 *C.GtkAdjustment // out

	_arg0 = (*C.GtkLayout)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	C.gtk_layout_set_hadjustment(_arg0, _arg1)
}

// SetSize sets the size of the scrollable area of the layout.
func (l layout) SetSize(width uint, height uint) {
	var _arg0 *C.GtkLayout // out
	var _arg1 C.guint      // out
	var _arg2 C.guint      // out

	_arg0 = (*C.GtkLayout)(unsafe.Pointer(l.Native()))
	_arg1 = (C.guint)(width)
	_arg2 = (C.guint)(height)

	C.gtk_layout_set_size(_arg0, _arg1, _arg2)
}

// SetVAdjustment sets the vertical scroll adjustment for the layout.
//
// See ScrolledWindow, Scrollbar, Adjustment for details.
func (l layout) SetVAdjustment(adjustment Adjustment) {
	var _arg0 *C.GtkLayout     // out
	var _arg1 *C.GtkAdjustment // out

	_arg0 = (*C.GtkLayout)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	C.gtk_layout_set_vadjustment(_arg0, _arg1)
}

// LevelBar: the LevelBar is a bar widget that can be used as a level indicator.
// Typical use cases are displaying the strength of a password, or showing the
// charge level of a battery.
//
// Use gtk_level_bar_set_value() to set the current value, and
// gtk_level_bar_add_offset_value() to set the value offsets at which the bar
// will be considered in a different state. GTK will add a few offsets by
// default on the level bar: K_LEVEL_BAR_OFFSET_LOW, K_LEVEL_BAR_OFFSET_HIGH and
// K_LEVEL_BAR_OFFSET_FULL, with values 0.25, 0.75 and 1.0 respectively.
//
// Note that it is your responsibility to update preexisting offsets when
// changing the minimum or maximum value. GTK+ will simply clamp them to the new
// range.
//
// Adding a custom offset on the bar
//
//    levelbar[.discrete]
//    ╰── trough
//        ├── block.filled.level-name
//        ┊
//        ├── block.empty
//        ┊
//
// GtkLevelBar has a main CSS node with name levelbar and one of the style
// classes .discrete or .continuous and a subnode with name trough. Below the
// trough node are a number of nodes with name block and style class .filled or
// .empty. In continuous mode, there is exactly one node of each, in discrete
// mode, the number of filled and unfilled nodes corresponds to blocks that are
// drawn. The block.filled nodes also get a style class .level-name
// corresponding to the level for the current value.
//
// In horizontal orientation, the nodes are always arranged from left to right,
// regardless of text direction.
type LevelBar interface {
	Widget
	Buildable
	Orientable

	// AddOffsetValue adds a new offset marker on @self at the position
	// specified by @value. When the bar value is in the interval topped by
	// @value (or between @value and LevelBar:max-value in case the offset is
	// the last one on the bar) a style class named `level-`@name will be
	// applied when rendering the level bar fill. If another offset marker named
	// @name exists, its value will be replaced by @value.
	AddOffsetValue(name string, value float64)
	// Inverted: return the value of the LevelBar:inverted property.
	Inverted() bool
	// MaxValue returns the value of the LevelBar:max-value property.
	MaxValue() float64
	// MinValue returns the value of the LevelBar:min-value property.
	MinValue() float64
	// Mode returns the value of the LevelBar:mode property.
	Mode() LevelBarMode
	// OffsetValue fetches the value specified for the offset marker @name in
	// @self, returning true in case an offset named @name was found.
	OffsetValue(name string) (float64, bool)
	// Value returns the value of the LevelBar:value property.
	Value() float64
	// RemoveOffsetValue removes an offset marker previously added with
	// gtk_level_bar_add_offset_value().
	RemoveOffsetValue(name string)
	// SetInverted sets the value of the LevelBar:inverted property.
	SetInverted(inverted bool)
	// SetMaxValue sets the value of the LevelBar:max-value property.
	//
	// You probably want to update preexisting level offsets after calling this
	// function.
	SetMaxValue(value float64)
	// SetMinValue sets the value of the LevelBar:min-value property.
	//
	// You probably want to update preexisting level offsets after calling this
	// function.
	SetMinValue(value float64)
	// SetMode sets the value of the LevelBar:mode property.
	SetMode(mode LevelBarMode)
	// SetValue sets the value of the LevelBar:value property.
	SetValue(value float64)
}

// levelBar implements the LevelBar class.
type levelBar struct {
	Widget
	Buildable
	Orientable
}

var _ LevelBar = (*levelBar)(nil)

// WrapLevelBar wraps a GObject to the right type. It is
// primarily used internally.
func WrapLevelBar(obj *externglib.Object) LevelBar {
	return levelBar{
		Widget:     WrapWidget(obj),
		Buildable:  WrapBuildable(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalLevelBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLevelBar(obj), nil
}

// NewLevelBar creates a new LevelBar.
func NewLevelBar() LevelBar {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_level_bar_new()

	var _levelBar LevelBar // out

	_levelBar = WrapLevelBar(externglib.Take(unsafe.Pointer(_cret)))

	return _levelBar
}

// NewLevelBarForInterval: utility constructor that creates a new LevelBar for
// the specified interval.
func NewLevelBarForInterval(minValue float64, maxValue float64) LevelBar {
	var _arg1 C.gdouble    // out
	var _arg2 C.gdouble    // out
	var _cret *C.GtkWidget // in

	_arg1 = (C.gdouble)(minValue)
	_arg2 = (C.gdouble)(maxValue)

	_cret = C.gtk_level_bar_new_for_interval(_arg1, _arg2)

	var _levelBar LevelBar // out

	_levelBar = WrapLevelBar(externglib.Take(unsafe.Pointer(_cret)))

	return _levelBar
}

// AddOffsetValue adds a new offset marker on @self at the position specified by
// @value. When the bar value is in the interval topped by @value (or between
// @value and LevelBar:max-value in case the offset is the last one on the bar)
// a style class named `level-`@name will be applied when rendering the level
// bar fill. If another offset marker named @name exists, its value will be
// replaced by @value.
func (s levelBar) AddOffsetValue(name string, value float64) {
	var _arg0 *C.GtkLevelBar // out
	var _arg1 *C.gchar       // out
	var _arg2 C.gdouble      // out

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gdouble)(value)

	C.gtk_level_bar_add_offset_value(_arg0, _arg1, _arg2)
}

// Inverted: return the value of the LevelBar:inverted property.
func (s levelBar) Inverted() bool {
	var _arg0 *C.GtkLevelBar // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_level_bar_get_inverted(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MaxValue returns the value of the LevelBar:max-value property.
func (s levelBar) MaxValue() float64 {
	var _arg0 *C.GtkLevelBar // out
	var _cret C.gdouble      // in

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_level_bar_get_max_value(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// MinValue returns the value of the LevelBar:min-value property.
func (s levelBar) MinValue() float64 {
	var _arg0 *C.GtkLevelBar // out
	var _cret C.gdouble      // in

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_level_bar_get_min_value(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// Mode returns the value of the LevelBar:mode property.
func (s levelBar) Mode() LevelBarMode {
	var _arg0 *C.GtkLevelBar    // out
	var _cret C.GtkLevelBarMode // in

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_level_bar_get_mode(_arg0)

	var _levelBarMode LevelBarMode // out

	_levelBarMode = LevelBarMode(_cret)

	return _levelBarMode
}

// OffsetValue fetches the value specified for the offset marker @name in @self,
// returning true in case an offset named @name was found.
func (s levelBar) OffsetValue(name string) (float64, bool) {
	var _arg0 *C.GtkLevelBar // out
	var _arg1 *C.gchar       // out
	var _arg2 C.gdouble      // in
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_level_bar_get_offset_value(_arg0, _arg1, &_arg2)

	var _value float64 // out
	var _ok bool       // out

	_value = (float64)(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// Value returns the value of the LevelBar:value property.
func (s levelBar) Value() float64 {
	var _arg0 *C.GtkLevelBar // out
	var _cret C.gdouble      // in

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_level_bar_get_value(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// RemoveOffsetValue removes an offset marker previously added with
// gtk_level_bar_add_offset_value().
func (s levelBar) RemoveOffsetValue(name string) {
	var _arg0 *C.GtkLevelBar // out
	var _arg1 *C.gchar       // out

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_level_bar_remove_offset_value(_arg0, _arg1)
}

// SetInverted sets the value of the LevelBar:inverted property.
func (s levelBar) SetInverted(inverted bool) {
	var _arg0 *C.GtkLevelBar // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	if inverted {
		_arg1 = C.TRUE
	}

	C.gtk_level_bar_set_inverted(_arg0, _arg1)
}

// SetMaxValue sets the value of the LevelBar:max-value property.
//
// You probably want to update preexisting level offsets after calling this
// function.
func (s levelBar) SetMaxValue(value float64) {
	var _arg0 *C.GtkLevelBar // out
	var _arg1 C.gdouble      // out

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gdouble)(value)

	C.gtk_level_bar_set_max_value(_arg0, _arg1)
}

// SetMinValue sets the value of the LevelBar:min-value property.
//
// You probably want to update preexisting level offsets after calling this
// function.
func (s levelBar) SetMinValue(value float64) {
	var _arg0 *C.GtkLevelBar // out
	var _arg1 C.gdouble      // out

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gdouble)(value)

	C.gtk_level_bar_set_min_value(_arg0, _arg1)
}

// SetMode sets the value of the LevelBar:mode property.
func (s levelBar) SetMode(mode LevelBarMode) {
	var _arg0 *C.GtkLevelBar    // out
	var _arg1 C.GtkLevelBarMode // out

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkLevelBarMode)(mode)

	C.gtk_level_bar_set_mode(_arg0, _arg1)
}

// SetValue sets the value of the LevelBar:value property.
func (s levelBar) SetValue(value float64) {
	var _arg0 *C.GtkLevelBar // out
	var _arg1 C.gdouble      // out

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gdouble)(value)

	C.gtk_level_bar_set_value(_arg0, _arg1)
}

type LevelBarAccessible interface {
	WidgetAccessible
}

// levelBarAccessible implements the LevelBarAccessible class.
type levelBarAccessible struct {
	WidgetAccessible
}

var _ LevelBarAccessible = (*levelBarAccessible)(nil)

// WrapLevelBarAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapLevelBarAccessible(obj *externglib.Object) LevelBarAccessible {
	return levelBarAccessible{
		WidgetAccessible: WrapWidgetAccessible(obj),
	}
}

func marshalLevelBarAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLevelBarAccessible(obj), nil
}

// LinkButton: a GtkLinkButton is a Button with a hyperlink, similar to the one
// used by web browsers, which triggers an action when clicked. It is useful to
// show quick links to resources.
//
// A link button is created by calling either gtk_link_button_new() or
// gtk_link_button_new_with_label(). If using the former, the URI you pass to
// the constructor is used as a label for the widget.
//
// The URI bound to a GtkLinkButton can be set specifically using
// gtk_link_button_set_uri(), and retrieved using gtk_link_button_get_uri().
//
// By default, GtkLinkButton calls gtk_show_uri_on_window() when the button is
// clicked. This behaviour can be overridden by connecting to the
// LinkButton::activate-link signal and returning true from the signal handler.
//
//
// CSS nodes
//
// GtkLinkButton has a single CSS node with name button. To differentiate it
// from a plain Button, it gets the .link style class.
type LinkButton interface {
	Button
	Actionable
	Activatable
	Buildable

	// URI retrieves the URI set using gtk_link_button_set_uri().
	URI() string
	// Visited retrieves the “visited” state of the URI where the LinkButton
	// points. The button becomes visited when it is clicked. If the URI is
	// changed on the button, the “visited” state is unset again.
	//
	// The state may also be changed using gtk_link_button_set_visited().
	Visited() bool
	// SetURI sets @uri as the URI where the LinkButton points. As a side-effect
	// this unsets the “visited” state of the button.
	SetURI(uri string)
	// SetVisited sets the “visited” state of the URI where the LinkButton
	// points. See gtk_link_button_get_visited() for more details.
	SetVisited(visited bool)
}

// linkButton implements the LinkButton class.
type linkButton struct {
	Button
	Actionable
	Activatable
	Buildable
}

var _ LinkButton = (*linkButton)(nil)

// WrapLinkButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapLinkButton(obj *externglib.Object) LinkButton {
	return linkButton{
		Button:      WrapButton(obj),
		Actionable:  WrapActionable(obj),
		Activatable: WrapActivatable(obj),
		Buildable:   WrapBuildable(obj),
	}
}

func marshalLinkButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLinkButton(obj), nil
}

// NewLinkButton creates a new LinkButton with the URI as its text.
func NewLinkButton(uri string) LinkButton {
	var _arg1 *C.gchar     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_link_button_new(_arg1)

	var _linkButton LinkButton // out

	_linkButton = WrapLinkButton(externglib.Take(unsafe.Pointer(_cret)))

	return _linkButton
}

// NewLinkButtonWithLabel creates a new LinkButton containing a label.
func NewLinkButtonWithLabel(uri string, label string) LinkButton {
	var _arg1 *C.gchar     // out
	var _arg2 *C.gchar     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_link_button_new_with_label(_arg1, _arg2)

	var _linkButton LinkButton // out

	_linkButton = WrapLinkButton(externglib.Take(unsafe.Pointer(_cret)))

	return _linkButton
}

// URI retrieves the URI set using gtk_link_button_set_uri().
func (l linkButton) URI() string {
	var _arg0 *C.GtkLinkButton // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GtkLinkButton)(unsafe.Pointer(l.Native()))

	_cret = C.gtk_link_button_get_uri(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Visited retrieves the “visited” state of the URI where the LinkButton points.
// The button becomes visited when it is clicked. If the URI is changed on the
// button, the “visited” state is unset again.
//
// The state may also be changed using gtk_link_button_set_visited().
func (l linkButton) Visited() bool {
	var _arg0 *C.GtkLinkButton // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkLinkButton)(unsafe.Pointer(l.Native()))

	_cret = C.gtk_link_button_get_visited(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetURI sets @uri as the URI where the LinkButton points. As a side-effect
// this unsets the “visited” state of the button.
func (l linkButton) SetURI(uri string) {
	var _arg0 *C.GtkLinkButton // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GtkLinkButton)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_link_button_set_uri(_arg0, _arg1)
}

// SetVisited sets the “visited” state of the URI where the LinkButton points.
// See gtk_link_button_get_visited() for more details.
func (l linkButton) SetVisited(visited bool) {
	var _arg0 *C.GtkLinkButton // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkLinkButton)(unsafe.Pointer(l.Native()))
	if visited {
		_arg1 = C.TRUE
	}

	C.gtk_link_button_set_visited(_arg0, _arg1)
}

type LinkButtonAccessible interface {
	ButtonAccessible
}

// linkButtonAccessible implements the LinkButtonAccessible class.
type linkButtonAccessible struct {
	ButtonAccessible
}

var _ LinkButtonAccessible = (*linkButtonAccessible)(nil)

// WrapLinkButtonAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapLinkButtonAccessible(obj *externglib.Object) LinkButtonAccessible {
	return linkButtonAccessible{
		ButtonAccessible: WrapButtonAccessible(obj),
	}
}

func marshalLinkButtonAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLinkButtonAccessible(obj), nil
}

// ListBox: a GtkListBox is a vertical container that contains GtkListBoxRow
// children. These rows can by dynamically sorted and filtered, and headers can
// be added dynamically depending on the row content. It also allows keyboard
// and mouse navigation and selection like a typical list.
//
// Using GtkListBox is often an alternative to TreeView, especially when the
// list contents has a more complicated layout than what is allowed by a
// CellRenderer, or when the contents is interactive (i.e. has a button in it).
//
// Although a ListBox must have only ListBoxRow children you can add any kind of
// widget to it via gtk_container_add(), and a ListBoxRow widget will
// automatically be inserted between the list and the widget.
//
// ListBoxRows can be marked as activatable or selectable. If a row is
// activatable, ListBox::row-activated will be emitted for it when the user
// tries to activate it. If it is selectable, the row will be marked as selected
// when the user tries to select it.
//
// The GtkListBox widget was added in GTK+ 3.10.
//
//
// GtkListBox as GtkBuildable
//
// The GtkListBox implementation of the Buildable interface supports setting a
// child as the placeholder by specifying “placeholder” as the “type” attribute
// of a <child> element. See gtk_list_box_set_placeholder() for info.
//
// CSS nodes
//
//    list
//    ╰── row[.activatable]
//
// GtkListBox uses a single CSS node named list. Each GtkListBoxRow uses a
// single CSS node named row. The row nodes get the .activatable style class
// added when appropriate.
type ListBox interface {
	Container
	Buildable

	// DragHighlightRow: this is a helper function for implementing DnD onto a
	// ListBox. The passed in @row will be highlighted via gtk_drag_highlight(),
	// and any previously highlighted row will be unhighlighted.
	//
	// The row will also be unhighlighted when the widget gets a drag leave
	// event.
	DragHighlightRow(row ListBoxRow)
	// DragUnhighlightRow: if a row has previously been highlighted via
	// gtk_list_box_drag_highlight_row() it will have the highlight removed.
	DragUnhighlightRow()
	// ActivateOnSingleClick returns whether rows activate on single clicks.
	ActivateOnSingleClick() bool
	// Adjustment gets the adjustment (if any) that the widget uses to for
	// vertical scrolling.
	Adjustment() Adjustment
	// RowAtIndex gets the n-th child in the list (not counting headers). If
	// @_index is negative or larger than the number of items in the list, nil
	// is returned.
	RowAtIndex(index_ int) ListBoxRow
	// RowAtY gets the row at the @y position.
	RowAtY(y int) ListBoxRow
	// SelectedRow gets the selected row.
	//
	// Note that the box may allow multiple selection, in which case you should
	// use gtk_list_box_selected_foreach() to find all selected rows.
	SelectedRow() ListBoxRow
	// SelectionMode gets the selection mode of the listbox.
	SelectionMode() SelectionMode
	// Insert: insert the @child into the @box at @position. If a sort function
	// is set, the widget will actually be inserted at the calculated position
	// and this function has the same effect of gtk_container_add().
	//
	// If @position is -1, or larger than the total number of items in the @box,
	// then the @child will be appended to the end.
	Insert(child Widget, position int)
	// InvalidateFilter: update the filtering for all rows. Call this when
	// result of the filter function on the @box is changed due to an external
	// factor. For instance, this would be used if the filter function just
	// looked for a specific search string and the entry with the search string
	// has changed.
	InvalidateFilter()
	// InvalidateHeaders: update the separators for all rows. Call this when
	// result of the header function on the @box is changed due to an external
	// factor.
	InvalidateHeaders()
	// InvalidateSort: update the sorting for all rows. Call this when result of
	// the sort function on the @box is changed due to an external factor.
	InvalidateSort()
	// Prepend: prepend a widget to the list. If a sort function is set, the
	// widget will actually be inserted at the calculated position and this
	// function has the same effect of gtk_container_add().
	Prepend(child Widget)
	// SelectAll: select all children of @box, if the selection mode allows it.
	SelectAll()
	// SelectRow: make @row the currently selected row.
	SelectRow(row ListBoxRow)
	// SetActivateOnSingleClick: if @single is true, rows will be activated when
	// you click on them, otherwise you need to double-click.
	SetActivateOnSingleClick(single bool)
	// SetAdjustment sets the adjustment (if any) that the widget uses to for
	// vertical scrolling. For instance, this is used to get the page size for
	// PageUp/Down key handling.
	//
	// In the normal case when the @box is packed inside a ScrolledWindow the
	// adjustment from that will be picked up automatically, so there is no need
	// to manually do that.
	SetAdjustment(adjustment Adjustment)
	// SetPlaceholder sets the placeholder widget that is shown in the list when
	// it doesn't display any visible children.
	SetPlaceholder(placeholder Widget)
	// SetSelectionMode sets how selection works in the listbox. See
	// SelectionMode for details.
	SetSelectionMode(mode SelectionMode)
	// UnselectAll: unselect all children of @box, if the selection mode allows
	// it.
	UnselectAll()
	// UnselectRow unselects a single row of @box, if the selection mode allows
	// it.
	UnselectRow(row ListBoxRow)
}

// listBox implements the ListBox class.
type listBox struct {
	Container
	Buildable
}

var _ ListBox = (*listBox)(nil)

// WrapListBox wraps a GObject to the right type. It is
// primarily used internally.
func WrapListBox(obj *externglib.Object) ListBox {
	return listBox{
		Container: WrapContainer(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalListBox(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapListBox(obj), nil
}

// NewListBox creates a new ListBox container.
func NewListBox() ListBox {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_list_box_new()

	var _listBox ListBox // out

	_listBox = WrapListBox(externglib.Take(unsafe.Pointer(_cret)))

	return _listBox
}

// DragHighlightRow: this is a helper function for implementing DnD onto a
// ListBox. The passed in @row will be highlighted via gtk_drag_highlight(), and
// any previously highlighted row will be unhighlighted.
//
// The row will also be unhighlighted when the widget gets a drag leave event.
func (b listBox) DragHighlightRow(row ListBoxRow) {
	var _arg0 *C.GtkListBox    // out
	var _arg1 *C.GtkListBoxRow // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkListBoxRow)(unsafe.Pointer(row.Native()))

	C.gtk_list_box_drag_highlight_row(_arg0, _arg1)
}

// DragUnhighlightRow: if a row has previously been highlighted via
// gtk_list_box_drag_highlight_row() it will have the highlight removed.
func (b listBox) DragUnhighlightRow() {
	var _arg0 *C.GtkListBox // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	C.gtk_list_box_drag_unhighlight_row(_arg0)
}

// ActivateOnSingleClick returns whether rows activate on single clicks.
func (b listBox) ActivateOnSingleClick() bool {
	var _arg0 *C.GtkListBox // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_list_box_get_activate_on_single_click(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Adjustment gets the adjustment (if any) that the widget uses to for vertical
// scrolling.
func (b listBox) Adjustment() Adjustment {
	var _arg0 *C.GtkListBox    // out
	var _cret *C.GtkAdjustment // in

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_list_box_get_adjustment(_arg0)

	var _adjustment Adjustment // out

	_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

	return _adjustment
}

// RowAtIndex gets the n-th child in the list (not counting headers). If @_index
// is negative or larger than the number of items in the list, nil is returned.
func (b listBox) RowAtIndex(index_ int) ListBoxRow {
	var _arg0 *C.GtkListBox    // out
	var _arg1 C.gint           // out
	var _cret *C.GtkListBoxRow // in

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	_arg1 = (C.gint)(index_)

	_cret = C.gtk_list_box_get_row_at_index(_arg0, _arg1)

	var _listBoxRow ListBoxRow // out

	_listBoxRow = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ListBoxRow)

	return _listBoxRow
}

// RowAtY gets the row at the @y position.
func (b listBox) RowAtY(y int) ListBoxRow {
	var _arg0 *C.GtkListBox    // out
	var _arg1 C.gint           // out
	var _cret *C.GtkListBoxRow // in

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	_arg1 = (C.gint)(y)

	_cret = C.gtk_list_box_get_row_at_y(_arg0, _arg1)

	var _listBoxRow ListBoxRow // out

	_listBoxRow = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ListBoxRow)

	return _listBoxRow
}

// SelectedRow gets the selected row.
//
// Note that the box may allow multiple selection, in which case you should use
// gtk_list_box_selected_foreach() to find all selected rows.
func (b listBox) SelectedRow() ListBoxRow {
	var _arg0 *C.GtkListBox    // out
	var _cret *C.GtkListBoxRow // in

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_list_box_get_selected_row(_arg0)

	var _listBoxRow ListBoxRow // out

	_listBoxRow = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ListBoxRow)

	return _listBoxRow
}

// SelectionMode gets the selection mode of the listbox.
func (b listBox) SelectionMode() SelectionMode {
	var _arg0 *C.GtkListBox      // out
	var _cret C.GtkSelectionMode // in

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_list_box_get_selection_mode(_arg0)

	var _selectionMode SelectionMode // out

	_selectionMode = SelectionMode(_cret)

	return _selectionMode
}

// Insert: insert the @child into the @box at @position. If a sort function is
// set, the widget will actually be inserted at the calculated position and this
// function has the same effect of gtk_container_add().
//
// If @position is -1, or larger than the total number of items in the @box,
// then the @child will be appended to the end.
func (b listBox) Insert(child Widget, position int) {
	var _arg0 *C.GtkListBox // out
	var _arg1 *C.GtkWidget  // out
	var _arg2 C.gint        // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (C.gint)(position)

	C.gtk_list_box_insert(_arg0, _arg1, _arg2)
}

// InvalidateFilter: update the filtering for all rows. Call this when result of
// the filter function on the @box is changed due to an external factor. For
// instance, this would be used if the filter function just looked for a
// specific search string and the entry with the search string has changed.
func (b listBox) InvalidateFilter() {
	var _arg0 *C.GtkListBox // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	C.gtk_list_box_invalidate_filter(_arg0)
}

// InvalidateHeaders: update the separators for all rows. Call this when result
// of the header function on the @box is changed due to an external factor.
func (b listBox) InvalidateHeaders() {
	var _arg0 *C.GtkListBox // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	C.gtk_list_box_invalidate_headers(_arg0)
}

// InvalidateSort: update the sorting for all rows. Call this when result of the
// sort function on the @box is changed due to an external factor.
func (b listBox) InvalidateSort() {
	var _arg0 *C.GtkListBox // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	C.gtk_list_box_invalidate_sort(_arg0)
}

// Prepend: prepend a widget to the list. If a sort function is set, the widget
// will actually be inserted at the calculated position and this function has
// the same effect of gtk_container_add().
func (b listBox) Prepend(child Widget) {
	var _arg0 *C.GtkListBox // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_list_box_prepend(_arg0, _arg1)
}

// SelectAll: select all children of @box, if the selection mode allows it.
func (b listBox) SelectAll() {
	var _arg0 *C.GtkListBox // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	C.gtk_list_box_select_all(_arg0)
}

// SelectRow: make @row the currently selected row.
func (b listBox) SelectRow(row ListBoxRow) {
	var _arg0 *C.GtkListBox    // out
	var _arg1 *C.GtkListBoxRow // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkListBoxRow)(unsafe.Pointer(row.Native()))

	C.gtk_list_box_select_row(_arg0, _arg1)
}

// SetActivateOnSingleClick: if @single is true, rows will be activated when you
// click on them, otherwise you need to double-click.
func (b listBox) SetActivateOnSingleClick(single bool) {
	var _arg0 *C.GtkListBox // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	if single {
		_arg1 = C.TRUE
	}

	C.gtk_list_box_set_activate_on_single_click(_arg0, _arg1)
}

// SetAdjustment sets the adjustment (if any) that the widget uses to for
// vertical scrolling. For instance, this is used to get the page size for
// PageUp/Down key handling.
//
// In the normal case when the @box is packed inside a ScrolledWindow the
// adjustment from that will be picked up automatically, so there is no need to
// manually do that.
func (b listBox) SetAdjustment(adjustment Adjustment) {
	var _arg0 *C.GtkListBox    // out
	var _arg1 *C.GtkAdjustment // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	C.gtk_list_box_set_adjustment(_arg0, _arg1)
}

// SetPlaceholder sets the placeholder widget that is shown in the list when it
// doesn't display any visible children.
func (b listBox) SetPlaceholder(placeholder Widget) {
	var _arg0 *C.GtkListBox // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(placeholder.Native()))

	C.gtk_list_box_set_placeholder(_arg0, _arg1)
}

// SetSelectionMode sets how selection works in the listbox. See SelectionMode
// for details.
func (b listBox) SetSelectionMode(mode SelectionMode) {
	var _arg0 *C.GtkListBox      // out
	var _arg1 C.GtkSelectionMode // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	_arg1 = (C.GtkSelectionMode)(mode)

	C.gtk_list_box_set_selection_mode(_arg0, _arg1)
}

// UnselectAll: unselect all children of @box, if the selection mode allows it.
func (b listBox) UnselectAll() {
	var _arg0 *C.GtkListBox // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	C.gtk_list_box_unselect_all(_arg0)
}

// UnselectRow unselects a single row of @box, if the selection mode allows it.
func (b listBox) UnselectRow(row ListBoxRow) {
	var _arg0 *C.GtkListBox    // out
	var _arg1 *C.GtkListBoxRow // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkListBoxRow)(unsafe.Pointer(row.Native()))

	C.gtk_list_box_unselect_row(_arg0, _arg1)
}

type ListBoxAccessible interface {
	ContainerAccessible
}

// listBoxAccessible implements the ListBoxAccessible class.
type listBoxAccessible struct {
	ContainerAccessible
}

var _ ListBoxAccessible = (*listBoxAccessible)(nil)

// WrapListBoxAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapListBoxAccessible(obj *externglib.Object) ListBoxAccessible {
	return listBoxAccessible{
		ContainerAccessible: WrapContainerAccessible(obj),
	}
}

func marshalListBoxAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapListBoxAccessible(obj), nil
}

type ListBoxRow interface {
	Bin
	Actionable
	Buildable

	// Changed marks @row as changed, causing any state that depends on this to
	// be updated. This affects sorting, filtering and headers.
	//
	// Note that calls to this method must be in sync with the data used for the
	// row functions. For instance, if the list is mirroring some external data
	// set, and *two* rows changed in the external data set then when you call
	// gtk_list_box_row_changed() on the first row the sort function must only
	// read the new data for the first of the two changed rows, otherwise the
	// resorting of the rows will be wrong.
	//
	// This generally means that if you don’t fully control the data model you
	// have to duplicate the data that affects the listbox row functions into
	// the row widgets themselves. Another alternative is to call
	// gtk_list_box_invalidate_sort() on any model change, but that is more
	// expensive.
	Changed()
	// Activatable gets the value of the ListBoxRow:activatable property for
	// this row.
	Activatable() bool
	// Header returns the current header of the @row. This can be used in a
	// ListBoxUpdateHeaderFunc to see if there is a header set already, and if
	// so to update the state of it.
	Header() Widget
	// Index gets the current index of the @row in its ListBox container.
	Index() int
	// Selectable gets the value of the ListBoxRow:selectable property for this
	// row.
	Selectable() bool
	// IsSelected returns whether the child is currently selected in its ListBox
	// container.
	IsSelected() bool
	// SetActivatable: set the ListBoxRow:activatable property for this row.
	SetActivatable(activatable bool)
	// SetHeader sets the current header of the @row. This is only allowed to be
	// called from a ListBoxUpdateHeaderFunc. It will replace any existing
	// header in the row, and be shown in front of the row in the listbox.
	SetHeader(header Widget)
	// SetSelectable: set the ListBoxRow:selectable property for this row.
	SetSelectable(selectable bool)
}

// listBoxRow implements the ListBoxRow class.
type listBoxRow struct {
	Bin
	Actionable
	Buildable
}

var _ ListBoxRow = (*listBoxRow)(nil)

// WrapListBoxRow wraps a GObject to the right type. It is
// primarily used internally.
func WrapListBoxRow(obj *externglib.Object) ListBoxRow {
	return listBoxRow{
		Bin:        WrapBin(obj),
		Actionable: WrapActionable(obj),
		Buildable:  WrapBuildable(obj),
	}
}

func marshalListBoxRow(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapListBoxRow(obj), nil
}

// NewListBoxRow creates a new ListBoxRow, to be used as a child of a ListBox.
func NewListBoxRow() ListBoxRow {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_list_box_row_new()

	var _listBoxRow ListBoxRow // out

	_listBoxRow = WrapListBoxRow(externglib.Take(unsafe.Pointer(_cret)))

	return _listBoxRow
}

// Changed marks @row as changed, causing any state that depends on this to be
// updated. This affects sorting, filtering and headers.
//
// Note that calls to this method must be in sync with the data used for the row
// functions. For instance, if the list is mirroring some external data set, and
// *two* rows changed in the external data set then when you call
// gtk_list_box_row_changed() on the first row the sort function must only read
// the new data for the first of the two changed rows, otherwise the resorting
// of the rows will be wrong.
//
// This generally means that if you don’t fully control the data model you have
// to duplicate the data that affects the listbox row functions into the row
// widgets themselves. Another alternative is to call
// gtk_list_box_invalidate_sort() on any model change, but that is more
// expensive.
func (r listBoxRow) Changed() {
	var _arg0 *C.GtkListBoxRow // out

	_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))

	C.gtk_list_box_row_changed(_arg0)
}

// Activatable gets the value of the ListBoxRow:activatable property for this
// row.
func (r listBoxRow) Activatable() bool {
	var _arg0 *C.GtkListBoxRow // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_list_box_row_get_activatable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Header returns the current header of the @row. This can be used in a
// ListBoxUpdateHeaderFunc to see if there is a header set already, and if so to
// update the state of it.
func (r listBoxRow) Header() Widget {
	var _arg0 *C.GtkListBoxRow // out
	var _cret *C.GtkWidget     // in

	_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_list_box_row_get_header(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// Index gets the current index of the @row in its ListBox container.
func (r listBoxRow) Index() int {
	var _arg0 *C.GtkListBoxRow // out
	var _cret C.gint           // in

	_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_list_box_row_get_index(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Selectable gets the value of the ListBoxRow:selectable property for this row.
func (r listBoxRow) Selectable() bool {
	var _arg0 *C.GtkListBoxRow // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_list_box_row_get_selectable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsSelected returns whether the child is currently selected in its ListBox
// container.
func (r listBoxRow) IsSelected() bool {
	var _arg0 *C.GtkListBoxRow // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_list_box_row_is_selected(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetActivatable: set the ListBoxRow:activatable property for this row.
func (r listBoxRow) SetActivatable(activatable bool) {
	var _arg0 *C.GtkListBoxRow // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))
	if activatable {
		_arg1 = C.TRUE
	}

	C.gtk_list_box_row_set_activatable(_arg0, _arg1)
}

// SetHeader sets the current header of the @row. This is only allowed to be
// called from a ListBoxUpdateHeaderFunc. It will replace any existing header in
// the row, and be shown in front of the row in the listbox.
func (r listBoxRow) SetHeader(header Widget) {
	var _arg0 *C.GtkListBoxRow // out
	var _arg1 *C.GtkWidget     // out

	_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(header.Native()))

	C.gtk_list_box_row_set_header(_arg0, _arg1)
}

// SetSelectable: set the ListBoxRow:selectable property for this row.
func (r listBoxRow) SetSelectable(selectable bool) {
	var _arg0 *C.GtkListBoxRow // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))
	if selectable {
		_arg1 = C.TRUE
	}

	C.gtk_list_box_row_set_selectable(_arg0, _arg1)
}

type ListBoxRowAccessible interface {
	ContainerAccessible
}

// listBoxRowAccessible implements the ListBoxRowAccessible class.
type listBoxRowAccessible struct {
	ContainerAccessible
}

var _ ListBoxRowAccessible = (*listBoxRowAccessible)(nil)

// WrapListBoxRowAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapListBoxRowAccessible(obj *externglib.Object) ListBoxRowAccessible {
	return listBoxRowAccessible{
		ContainerAccessible: WrapContainerAccessible(obj),
	}
}

func marshalListBoxRowAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapListBoxRowAccessible(obj), nil
}

// ListStore: the ListStore object is a list model for use with a TreeView
// widget. It implements the TreeModel interface, and consequentialy, can use
// all of the methods available there. It also implements the TreeSortable
// interface so it can be sorted by the view. Finally, it also implements the
// tree [drag and drop][gtk3-GtkTreeView-drag-and-drop] interfaces.
//
// The ListStore can accept most GObject types as a column type, though it can’t
// accept all custom types. Internally, it will keep a copy of data passed in
// (such as a string or a boxed pointer). Columns that accept #GObjects are
// handled a little differently. The ListStore will keep a reference to the
// object instead of copying the value. As a result, if the object is modified,
// it is up to the application writer to call gtk_tree_model_row_changed() to
// emit the TreeModel::row_changed signal. This most commonly affects lists with
// Pixbufs stored.
//
// An example for creating a simple list store:
//
//    <object class="GtkListStore">
//      <columns>
//        <column type="gchararray"/>
//        <column type="gchararray"/>
//        <column type="gint"/>
//      </columns>
//      <data>
//        <row>
//          <col id="0">John</col>
//          <col id="1">Doe</col>
//          <col id="2">25</col>
//        </row>
//        <row>
//          <col id="0">Johan</col>
//          <col id="1">Dahlin</col>
//          <col id="2">50</col>
//        </row>
//      </data>
//    </object>
type ListStore interface {
	gextras.Objector
	Buildable
	TreeDragDest
	TreeDragSource
	TreeModel
	TreeSortable

	// Append appends a new row to @list_store. @iter will be changed to point
	// to this new row. The row will be empty after this function is called. To
	// fill in values, you need to call gtk_list_store_set() or
	// gtk_list_store_set_value().
	Append() TreeIter
	// Clear removes all rows from the list store.
	Clear()
	// Insert creates a new row at @position. @iter will be changed to point to
	// this new row. If @position is -1 or is larger than the number of rows on
	// the list, then the new row will be appended to the list. The row will be
	// empty after this function is called. To fill in values, you need to call
	// gtk_list_store_set() or gtk_list_store_set_value().
	Insert(position int) TreeIter
	// InsertAfter inserts a new row after @sibling. If @sibling is nil, then
	// the row will be prepended to the beginning of the list. @iter will be
	// changed to point to this new row. The row will be empty after this
	// function is called. To fill in values, you need to call
	// gtk_list_store_set() or gtk_list_store_set_value().
	InsertAfter(sibling *TreeIter) TreeIter
	// InsertBefore inserts a new row before @sibling. If @sibling is nil, then
	// the row will be appended to the end of the list. @iter will be changed to
	// point to this new row. The row will be empty after this function is
	// called. To fill in values, you need to call gtk_list_store_set() or
	// gtk_list_store_set_value().
	InsertBefore(sibling *TreeIter) TreeIter
	// InsertWithValuesv: a variant of gtk_list_store_insert_with_values() which
	// takes the columns and values as two arrays, instead of varargs. This
	// function is mainly intended for language-bindings.
	InsertWithValuesv(position int, columns []int, values []**externglib.Value) TreeIter
	// IterIsValid: > This function is slow. Only use it for debugging and/or
	// testing > purposes.
	//
	// Checks if the given iter is a valid iter for this ListStore.
	IterIsValid(iter *TreeIter) bool
	// MoveAfter moves @iter in @store to the position after @position. Note
	// that this function only works with unsorted stores. If @position is nil,
	// @iter will be moved to the start of the list.
	MoveAfter(iter *TreeIter, position *TreeIter)
	// MoveBefore moves @iter in @store to the position before @position. Note
	// that this function only works with unsorted stores. If @position is nil,
	// @iter will be moved to the end of the list.
	MoveBefore(iter *TreeIter, position *TreeIter)
	// Prepend prepends a new row to @list_store. @iter will be changed to point
	// to this new row. The row will be empty after this function is called. To
	// fill in values, you need to call gtk_list_store_set() or
	// gtk_list_store_set_value().
	Prepend() TreeIter
	// Remove removes the given row from the list store. After being removed,
	// @iter is set to be the next valid row, or invalidated if it pointed to
	// the last row in @list_store.
	Remove(iter *TreeIter) bool
	// Reorder reorders @store to follow the order indicated by @new_order. Note
	// that this function only works with unsorted stores.
	Reorder(newOrder []int)
	// SetColumnTypes: this function is meant primarily for #GObjects that
	// inherit from ListStore, and should only be used when constructing a new
	// ListStore. It will not function after a row has been added, or a method
	// on the TreeModel interface is called.
	SetColumnTypes(types []externglib.Type)
	// SetValue sets the data in the cell specified by @iter and @column. The
	// type of @value must be convertible to the type of the column.
	SetValue(iter *TreeIter, column int, value **externglib.Value)
	// SetValuesv: a variant of gtk_list_store_set_valist() which takes the
	// columns and values as two arrays, instead of varargs. This function is
	// mainly intended for language-bindings and in case the number of columns
	// to change is not known until run-time.
	SetValuesv(iter *TreeIter, columns []int, values []**externglib.Value)
	// Swap swaps @a and @b in @store. Note that this function only works with
	// unsorted stores.
	Swap(a *TreeIter, b *TreeIter)
}

// listStore implements the ListStore class.
type listStore struct {
	gextras.Objector
	Buildable
	TreeDragDest
	TreeDragSource
	TreeModel
	TreeSortable
}

var _ ListStore = (*listStore)(nil)

// WrapListStore wraps a GObject to the right type. It is
// primarily used internally.
func WrapListStore(obj *externglib.Object) ListStore {
	return listStore{
		Objector:       obj,
		Buildable:      WrapBuildable(obj),
		TreeDragDest:   WrapTreeDragDest(obj),
		TreeDragSource: WrapTreeDragSource(obj),
		TreeModel:      WrapTreeModel(obj),
		TreeSortable:   WrapTreeSortable(obj),
	}
}

func marshalListStore(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapListStore(obj), nil
}

// NewListStoreV: non-vararg creation function. Used primarily by language
// bindings.
func NewListStoreV(types []externglib.Type) ListStore {
	var _arg2 *C.GType
	var _arg1 C.gint
	var _cret *C.GtkListStore // in

	_arg1 = C.gint(len(types))
	_arg2 = (*C.GType)(C.malloc(C.ulong(len(types)) * C.ulong(C.sizeof_GType)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice(_arg2, len(types))
		for i := range types {
			out[i] = C.GType(types[i])
		}
	}

	_cret = C.gtk_list_store_newv(_arg1, _arg2)

	var _listStore ListStore // out

	_listStore = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(ListStore)

	return _listStore
}

// Append appends a new row to @list_store. @iter will be changed to point to
// this new row. The row will be empty after this function is called. To fill in
// values, you need to call gtk_list_store_set() or gtk_list_store_set_value().
func (l listStore) Append() TreeIter {
	var _arg0 *C.GtkListStore // out
	var _iter TreeIter

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))

	C.gtk_list_store_append(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)))

	return _iter
}

// Clear removes all rows from the list store.
func (l listStore) Clear() {
	var _arg0 *C.GtkListStore // out

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))

	C.gtk_list_store_clear(_arg0)
}

// Insert creates a new row at @position. @iter will be changed to point to this
// new row. If @position is -1 or is larger than the number of rows on the list,
// then the new row will be appended to the list. The row will be empty after
// this function is called. To fill in values, you need to call
// gtk_list_store_set() or gtk_list_store_set_value().
func (l listStore) Insert(position int) TreeIter {
	var _arg0 *C.GtkListStore // out
	var _iter TreeIter
	var _arg2 C.gint // out

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))
	_arg2 = (C.gint)(position)

	C.gtk_list_store_insert(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2)

	return _iter
}

// InsertAfter inserts a new row after @sibling. If @sibling is nil, then the
// row will be prepended to the beginning of the list. @iter will be changed to
// point to this new row. The row will be empty after this function is called.
// To fill in values, you need to call gtk_list_store_set() or
// gtk_list_store_set_value().
func (l listStore) InsertAfter(sibling *TreeIter) TreeIter {
	var _arg0 *C.GtkListStore // out
	var _iter TreeIter
	var _arg2 *C.GtkTreeIter // out

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(sibling.Native()))

	C.gtk_list_store_insert_after(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2)

	return _iter
}

// InsertBefore inserts a new row before @sibling. If @sibling is nil, then the
// row will be appended to the end of the list. @iter will be changed to point
// to this new row. The row will be empty after this function is called. To fill
// in values, you need to call gtk_list_store_set() or
// gtk_list_store_set_value().
func (l listStore) InsertBefore(sibling *TreeIter) TreeIter {
	var _arg0 *C.GtkListStore // out
	var _iter TreeIter
	var _arg2 *C.GtkTreeIter // out

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(sibling.Native()))

	C.gtk_list_store_insert_before(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2)

	return _iter
}

// InsertWithValuesv: a variant of gtk_list_store_insert_with_values() which
// takes the columns and values as two arrays, instead of varargs. This function
// is mainly intended for language-bindings.
func (l listStore) InsertWithValuesv(position int, columns []int, values []**externglib.Value) TreeIter {
	var _arg0 *C.GtkListStore // out
	var _iter TreeIter
	var _arg2 C.gint // out
	var _arg3 *C.gint
	var _arg5 C.gint
	var _arg4 *C.GValue
	var _arg5 C.gint

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))
	_arg2 = (C.gint)(position)
	_arg5 = C.gint(len(columns))
	_arg3 = (*C.gint)(unsafe.Pointer(&columns[0]))
	_arg5 = C.gint(len(values))
	_arg4 = (*C.GValue)(C.malloc(C.ulong(len(values)) * C.ulong(C.sizeof_GValue)))
	defer C.free(unsafe.Pointer(_arg4))
	{
		out := unsafe.Slice(_arg4, len(values))
		for i := range values {
			out[i] = (*C.GValue)(values[i].GValue)
		}
	}

	C.gtk_list_store_insert_with_valuesv(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2, _arg3, _arg4, _arg5)

	return _iter
}

// IterIsValid: > This function is slow. Only use it for debugging and/or
// testing > purposes.
//
// Checks if the given iter is a valid iter for this ListStore.
func (l listStore) IterIsValid(iter *TreeIter) bool {
	var _arg0 *C.GtkListStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_list_store_iter_is_valid(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MoveAfter moves @iter in @store to the position after @position. Note that
// this function only works with unsorted stores. If @position is nil, @iter
// will be moved to the start of the list.
func (s listStore) MoveAfter(iter *TreeIter, position *TreeIter) {
	var _arg0 *C.GtkListStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(position.Native()))

	C.gtk_list_store_move_after(_arg0, _arg1, _arg2)
}

// MoveBefore moves @iter in @store to the position before @position. Note that
// this function only works with unsorted stores. If @position is nil, @iter
// will be moved to the end of the list.
func (s listStore) MoveBefore(iter *TreeIter, position *TreeIter) {
	var _arg0 *C.GtkListStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(position.Native()))

	C.gtk_list_store_move_before(_arg0, _arg1, _arg2)
}

// Prepend prepends a new row to @list_store. @iter will be changed to point to
// this new row. The row will be empty after this function is called. To fill in
// values, you need to call gtk_list_store_set() or gtk_list_store_set_value().
func (l listStore) Prepend() TreeIter {
	var _arg0 *C.GtkListStore // out
	var _iter TreeIter

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))

	C.gtk_list_store_prepend(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)))

	return _iter
}

// Remove removes the given row from the list store. After being removed, @iter
// is set to be the next valid row, or invalidated if it pointed to the last row
// in @list_store.
func (l listStore) Remove(iter *TreeIter) bool {
	var _arg0 *C.GtkListStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_list_store_remove(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Reorder reorders @store to follow the order indicated by @new_order. Note
// that this function only works with unsorted stores.
func (s listStore) Reorder(newOrder []int) {
	var _arg0 *C.GtkListStore // out
	var _arg1 *C.gint

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(s.Native()))
	{
		var zero int
		newOrder = append(newOrder, zero)
	}
	_arg1 = (*C.gint)(unsafe.Pointer(&newOrder[0]))

	C.gtk_list_store_reorder(_arg0, _arg1)
}

// SetColumnTypes: this function is meant primarily for #GObjects that inherit
// from ListStore, and should only be used when constructing a new ListStore. It
// will not function after a row has been added, or a method on the TreeModel
// interface is called.
func (l listStore) SetColumnTypes(types []externglib.Type) {
	var _arg0 *C.GtkListStore // out
	var _arg2 *C.GType
	var _arg1 C.gint

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))
	_arg1 = C.gint(len(types))
	_arg2 = (*C.GType)(C.malloc(C.ulong(len(types)) * C.ulong(C.sizeof_GType)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice(_arg2, len(types))
		for i := range types {
			out[i] = C.GType(types[i])
		}
	}

	C.gtk_list_store_set_column_types(_arg0, _arg1, _arg2)
}

// SetValue sets the data in the cell specified by @iter and @column. The type
// of @value must be convertible to the type of the column.
func (l listStore) SetValue(iter *TreeIter, column int, value **externglib.Value) {
	var _arg0 *C.GtkListStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 C.gint          // out
	var _arg3 *C.GValue       // out

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (C.gint)(column)
	_arg3 = (*C.GValue)(value.GValue)

	C.gtk_list_store_set_value(_arg0, _arg1, _arg2, _arg3)
}

// SetValuesv: a variant of gtk_list_store_set_valist() which takes the columns
// and values as two arrays, instead of varargs. This function is mainly
// intended for language-bindings and in case the number of columns to change is
// not known until run-time.
func (l listStore) SetValuesv(iter *TreeIter, columns []int, values []**externglib.Value) {
	var _arg0 *C.GtkListStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 *C.gint
	var _arg4 C.gint
	var _arg3 *C.GValue
	var _arg4 C.gint

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
	_arg4 = C.gint(len(columns))
	_arg2 = (*C.gint)(unsafe.Pointer(&columns[0]))
	_arg4 = C.gint(len(values))
	_arg3 = (*C.GValue)(C.malloc(C.ulong(len(values)) * C.ulong(C.sizeof_GValue)))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice(_arg3, len(values))
		for i := range values {
			out[i] = (*C.GValue)(values[i].GValue)
		}
	}

	C.gtk_list_store_set_valuesv(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// Swap swaps @a and @b in @store. Note that this function only works with
// unsorted stores.
func (s listStore) Swap(a *TreeIter, b *TreeIter) {
	var _arg0 *C.GtkListStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(a.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(b.Native()))

	C.gtk_list_store_swap(_arg0, _arg1, _arg2)
}

// LockButton: gtkLockButton is a widget that can be used in control panels or
// preference dialogs to allow users to obtain and revoke authorizations needed
// to operate the controls. The required authorization is represented by a
// #GPermission object. Concrete implementations of #GPermission may use
// PolicyKit or some other authorization framework. To obtain a PolicyKit-based
// #GPermission, use polkit_permission_new().
//
// If the user is not currently allowed to perform the action, but can obtain
// the permission, the widget looks like this:
//
// ! (lockbutton-locked.png)
//
// and the user can click the button to request the permission. Depending on the
// platform, this may pop up an authentication dialog or ask the user to
// authenticate in some other way. Once the user has obtained the permission,
// the widget changes to this:
//
// ! (lockbutton-unlocked.png)
//
// and the permission can be dropped again by clicking the button. If the user
// is not able to obtain the permission at all, the widget looks like this:
//
// ! (lockbutton-sorry.png)
//
// If the user has the permission and cannot drop it, the button is hidden.
//
// The text (and tooltips) that are shown in the various cases can be adjusted
// with the LockButton:text-lock, LockButton:text-unlock,
// LockButton:tooltip-lock, LockButton:tooltip-unlock and
// LockButton:tooltip-not-authorized properties.
type LockButton interface {
	Button
	Actionable
	Activatable
	Buildable

	// Permission obtains the #GPermission object that controls @button.
	Permission() gio.Permission
	// SetPermission sets the #GPermission object that controls @button.
	SetPermission(permission gio.Permission)
}

// lockButton implements the LockButton class.
type lockButton struct {
	Button
	Actionable
	Activatable
	Buildable
}

var _ LockButton = (*lockButton)(nil)

// WrapLockButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapLockButton(obj *externglib.Object) LockButton {
	return lockButton{
		Button:      WrapButton(obj),
		Actionable:  WrapActionable(obj),
		Activatable: WrapActivatable(obj),
		Buildable:   WrapBuildable(obj),
	}
}

func marshalLockButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLockButton(obj), nil
}

// NewLockButton creates a new lock button which reflects the @permission.
func NewLockButton(permission gio.Permission) LockButton {
	var _arg1 *C.GPermission // out
	var _cret *C.GtkWidget   // in

	_arg1 = (*C.GPermission)(unsafe.Pointer(permission.Native()))

	_cret = C.gtk_lock_button_new(_arg1)

	var _lockButton LockButton // out

	_lockButton = WrapLockButton(externglib.Take(unsafe.Pointer(_cret)))

	return _lockButton
}

// Permission obtains the #GPermission object that controls @button.
func (b lockButton) Permission() gio.Permission {
	var _arg0 *C.GtkLockButton // out
	var _cret *C.GPermission   // in

	_arg0 = (*C.GtkLockButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_lock_button_get_permission(_arg0)

	var _permission gio.Permission // out

	_permission = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.Permission)

	return _permission
}

// SetPermission sets the #GPermission object that controls @button.
func (b lockButton) SetPermission(permission gio.Permission) {
	var _arg0 *C.GtkLockButton // out
	var _arg1 *C.GPermission   // out

	_arg0 = (*C.GtkLockButton)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GPermission)(unsafe.Pointer(permission.Native()))

	C.gtk_lock_button_set_permission(_arg0, _arg1)
}

type LockButtonAccessible interface {
	ButtonAccessible
}

// lockButtonAccessible implements the LockButtonAccessible class.
type lockButtonAccessible struct {
	ButtonAccessible
}

var _ LockButtonAccessible = (*lockButtonAccessible)(nil)

// WrapLockButtonAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapLockButtonAccessible(obj *externglib.Object) LockButtonAccessible {
	return lockButtonAccessible{
		ButtonAccessible: WrapButtonAccessible(obj),
	}
}

func marshalLockButtonAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLockButtonAccessible(obj), nil
}

// Menu: a Menu is a MenuShell that implements a drop down menu consisting of a
// list of MenuItem objects which can be navigated and activated by the user to
// perform application functions.
//
// A Menu is most commonly dropped down by activating a MenuItem in a MenuBar or
// popped up by activating a MenuItem in another Menu.
//
// A Menu can also be popped up by activating a ComboBox. Other composite
// widgets such as the Notebook can pop up a Menu as well.
//
// Applications can display a Menu as a popup menu by calling the
// gtk_menu_popup() function. The example below shows how an application can pop
// up a menu when the 3rd mouse button is pressed.
//
// Connecting the popup signal handler.
//
//    menu
//    ├── arrow.top
//    ├── <child>
//    ┊
//    ├── <child>
//    ╰── arrow.bottom
//
// The main CSS node of GtkMenu has name menu, and there are two subnodes with
// name arrow, for scrolling menu arrows. These subnodes get the .top and
// .bottom style classes.
type Menu interface {
	MenuShell
	Buildable

	// Attach adds a new MenuItem to a (table) menu. The number of “cells” that
	// an item will occupy is specified by @left_attach, @right_attach,
	// @top_attach and @bottom_attach. These each represent the leftmost,
	// rightmost, uppermost and lower column and row numbers of the table.
	// (Columns and rows are indexed from zero).
	//
	// Note that this function is not related to gtk_menu_detach().
	Attach(child Widget, leftAttach uint, rightAttach uint, topAttach uint, bottomAttach uint)
	// Detach detaches the menu from the widget to which it had been attached.
	// This function will call the callback function, @detacher, provided when
	// the gtk_menu_attach_to_widget() function was called.
	Detach()
	// AccelGroup gets the AccelGroup which holds global accelerators for the
	// menu. See gtk_menu_set_accel_group().
	AccelGroup() AccelGroup
	// AccelPath retrieves the accelerator path set on the menu.
	AccelPath() string
	// Active returns the selected menu item from the menu. This is used by the
	// ComboBox.
	Active() Widget
	// AttachWidget returns the Widget that the menu is attached to.
	AttachWidget() Widget
	// Monitor retrieves the number of the monitor on which to show the menu.
	Monitor() int
	// ReserveToggleSize returns whether the menu reserves space for toggles and
	// icons, regardless of their actual presence.
	ReserveToggleSize() bool
	// TearoffState returns whether the menu is torn off. See
	// gtk_menu_set_tearoff_state().
	TearoffState() bool
	// Title returns the title of the menu. See gtk_menu_set_title().
	Title() string
	// PlaceOnMonitor places @menu on the given monitor.
	PlaceOnMonitor(monitor gdk.Monitor)
	// Popdown removes the menu from the screen.
	Popdown()
	// ReorderChild moves @child to a new @position in the list of @menu
	// children.
	ReorderChild(child Widget, position int)
	// Reposition repositions the menu according to its position function.
	Reposition()
	// SetAccelGroup: set the AccelGroup which holds global accelerators for the
	// menu. This accelerator group needs to also be added to all windows that
	// this menu is being used in with gtk_window_add_accel_group(), in order
	// for those windows to support all the accelerators contained in this
	// group.
	SetAccelGroup(accelGroup AccelGroup)
	// SetAccelPath sets an accelerator path for this menu from which
	// accelerator paths for its immediate children, its menu items, can be
	// constructed. The main purpose of this function is to spare the programmer
	// the inconvenience of having to call gtk_menu_item_set_accel_path() on
	// each menu item that should support runtime user changable accelerators.
	// Instead, by just calling gtk_menu_set_accel_path() on their parent, each
	// menu item of this menu, that contains a label describing its purpose,
	// automatically gets an accel path assigned.
	//
	// For example, a menu containing menu items “New” and “Exit”, will, after
	// `gtk_menu_set_accel_path (menu, "<Gnumeric-Sheet>/File");` has been
	// called, assign its items the accel paths: `"<Gnumeric-Sheet>/File/New"`
	// and `"<Gnumeric-Sheet>/File/Exit"`.
	//
	// Assigning accel paths to menu items then enables the user to change their
	// accelerators at runtime. More details about accelerator paths and their
	// default setups can be found at gtk_accel_map_add_entry().
	//
	// Note that @accel_path string will be stored in a #GQuark. Therefore, if
	// you pass a static string, you can save some memory by interning it first
	// with g_intern_static_string().
	SetAccelPath(accelPath string)
	// SetActive selects the specified menu item within the menu. This is used
	// by the ComboBox and should not be used by anyone else.
	SetActive(index uint)
	// SetMonitor informs GTK+ on which monitor a menu should be popped up. See
	// gdk_monitor_get_geometry().
	//
	// This function should be called from a MenuPositionFunc if the menu should
	// not appear on the same monitor as the pointer. This information can’t be
	// reliably inferred from the coordinates returned by a MenuPositionFunc,
	// since, for very long menus, these coordinates may extend beyond the
	// monitor boundaries or even the screen boundaries.
	SetMonitor(monitorNum int)
	// SetReserveToggleSize sets whether the menu should reserve space for
	// drawing toggles or icons, regardless of their actual presence.
	SetReserveToggleSize(reserveToggleSize bool)
	// SetScreen sets the Screen on which the menu will be displayed.
	SetScreen(screen gdk.Screen)
	// SetTearoffState changes the tearoff state of the menu. A menu is normally
	// displayed as drop down menu which persists as long as the menu is active.
	// It can also be displayed as a tearoff menu which persists until it is
	// closed or reattached.
	SetTearoffState(tornOff bool)
	// SetTitle sets the title string for the menu.
	//
	// The title is displayed when the menu is shown as a tearoff menu. If
	// @title is nil, the menu will see if it is attached to a parent menu item,
	// and if so it will try to use the same text as that menu item’s label.
	SetTitle(title string)
}

// menu implements the Menu class.
type menu struct {
	MenuShell
	Buildable
}

var _ Menu = (*menu)(nil)

// WrapMenu wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenu(obj *externglib.Object) Menu {
	return menu{
		MenuShell: WrapMenuShell(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalMenu(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenu(obj), nil
}

// NewMenu creates a new Menu
func NewMenu() Menu {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_menu_new()

	var _menu Menu // out

	_menu = WrapMenu(externglib.Take(unsafe.Pointer(_cret)))

	return _menu
}

// NewMenuFromModel creates a Menu and populates it with menu items and submenus
// according to @model.
//
// The created menu items are connected to actions found in the
// ApplicationWindow to which the menu belongs - typically by means of being
// attached to a widget (see gtk_menu_attach_to_widget()) that is contained
// within the ApplicationWindows widget hierarchy.
//
// Actions can also be added using gtk_widget_insert_action_group() on the
// menu's attach widget or on any of its parent widgets.
func NewMenuFromModel(model gio.MenuModel) Menu {
	var _arg1 *C.GMenuModel // out
	var _cret *C.GtkWidget  // in

	_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

	_cret = C.gtk_menu_new_from_model(_arg1)

	var _menu Menu // out

	_menu = WrapMenu(externglib.Take(unsafe.Pointer(_cret)))

	return _menu
}

// Attach adds a new MenuItem to a (table) menu. The number of “cells” that an
// item will occupy is specified by @left_attach, @right_attach, @top_attach and
// @bottom_attach. These each represent the leftmost, rightmost, uppermost and
// lower column and row numbers of the table. (Columns and rows are indexed from
// zero).
//
// Note that this function is not related to gtk_menu_detach().
func (m menu) Attach(child Widget, leftAttach uint, rightAttach uint, topAttach uint, bottomAttach uint) {
	var _arg0 *C.GtkMenu   // out
	var _arg1 *C.GtkWidget // out
	var _arg2 C.guint      // out
	var _arg3 C.guint      // out
	var _arg4 C.guint      // out
	var _arg5 C.guint      // out

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (C.guint)(leftAttach)
	_arg3 = (C.guint)(rightAttach)
	_arg4 = (C.guint)(topAttach)
	_arg5 = (C.guint)(bottomAttach)

	C.gtk_menu_attach(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}

// Detach detaches the menu from the widget to which it had been attached. This
// function will call the callback function, @detacher, provided when the
// gtk_menu_attach_to_widget() function was called.
func (m menu) Detach() {
	var _arg0 *C.GtkMenu // out

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))

	C.gtk_menu_detach(_arg0)
}

// AccelGroup gets the AccelGroup which holds global accelerators for the menu.
// See gtk_menu_set_accel_group().
func (m menu) AccelGroup() AccelGroup {
	var _arg0 *C.GtkMenu       // out
	var _cret *C.GtkAccelGroup // in

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_get_accel_group(_arg0)

	var _accelGroup AccelGroup // out

	_accelGroup = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(AccelGroup)

	return _accelGroup
}

// AccelPath retrieves the accelerator path set on the menu.
func (m menu) AccelPath() string {
	var _arg0 *C.GtkMenu // out
	var _cret *C.gchar   // in

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_get_accel_path(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Active returns the selected menu item from the menu. This is used by the
// ComboBox.
func (m menu) Active() Widget {
	var _arg0 *C.GtkMenu   // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_get_active(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// AttachWidget returns the Widget that the menu is attached to.
func (m menu) AttachWidget() Widget {
	var _arg0 *C.GtkMenu   // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_get_attach_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// Monitor retrieves the number of the monitor on which to show the menu.
func (m menu) Monitor() int {
	var _arg0 *C.GtkMenu // out
	var _cret C.gint     // in

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_get_monitor(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// ReserveToggleSize returns whether the menu reserves space for toggles and
// icons, regardless of their actual presence.
func (m menu) ReserveToggleSize() bool {
	var _arg0 *C.GtkMenu // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_get_reserve_toggle_size(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TearoffState returns whether the menu is torn off. See
// gtk_menu_set_tearoff_state().
func (m menu) TearoffState() bool {
	var _arg0 *C.GtkMenu // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_get_tearoff_state(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Title returns the title of the menu. See gtk_menu_set_title().
func (m menu) Title() string {
	var _arg0 *C.GtkMenu // out
	var _cret *C.gchar   // in

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_get_title(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// PlaceOnMonitor places @menu on the given monitor.
func (m menu) PlaceOnMonitor(monitor gdk.Monitor) {
	var _arg0 *C.GtkMenu    // out
	var _arg1 *C.GdkMonitor // out

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GdkMonitor)(unsafe.Pointer(monitor.Native()))

	C.gtk_menu_place_on_monitor(_arg0, _arg1)
}

// Popdown removes the menu from the screen.
func (m menu) Popdown() {
	var _arg0 *C.GtkMenu // out

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))

	C.gtk_menu_popdown(_arg0)
}

// ReorderChild moves @child to a new @position in the list of @menu children.
func (m menu) ReorderChild(child Widget, position int) {
	var _arg0 *C.GtkMenu   // out
	var _arg1 *C.GtkWidget // out
	var _arg2 C.gint       // out

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (C.gint)(position)

	C.gtk_menu_reorder_child(_arg0, _arg1, _arg2)
}

// Reposition repositions the menu according to its position function.
func (m menu) Reposition() {
	var _arg0 *C.GtkMenu // out

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))

	C.gtk_menu_reposition(_arg0)
}

// SetAccelGroup: set the AccelGroup which holds global accelerators for the
// menu. This accelerator group needs to also be added to all windows that this
// menu is being used in with gtk_window_add_accel_group(), in order for those
// windows to support all the accelerators contained in this group.
func (m menu) SetAccelGroup(accelGroup AccelGroup) {
	var _arg0 *C.GtkMenu       // out
	var _arg1 *C.GtkAccelGroup // out

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GtkAccelGroup)(unsafe.Pointer(accelGroup.Native()))

	C.gtk_menu_set_accel_group(_arg0, _arg1)
}

// SetAccelPath sets an accelerator path for this menu from which accelerator
// paths for its immediate children, its menu items, can be constructed. The
// main purpose of this function is to spare the programmer the inconvenience of
// having to call gtk_menu_item_set_accel_path() on each menu item that should
// support runtime user changable accelerators. Instead, by just calling
// gtk_menu_set_accel_path() on their parent, each menu item of this menu, that
// contains a label describing its purpose, automatically gets an accel path
// assigned.
//
// For example, a menu containing menu items “New” and “Exit”, will, after
// `gtk_menu_set_accel_path (menu, "<Gnumeric-Sheet>/File");` has been called,
// assign its items the accel paths: `"<Gnumeric-Sheet>/File/New"` and
// `"<Gnumeric-Sheet>/File/Exit"`.
//
// Assigning accel paths to menu items then enables the user to change their
// accelerators at runtime. More details about accelerator paths and their
// default setups can be found at gtk_accel_map_add_entry().
//
// Note that @accel_path string will be stored in a #GQuark. Therefore, if you
// pass a static string, you can save some memory by interning it first with
// g_intern_static_string().
func (m menu) SetAccelPath(accelPath string) {
	var _arg0 *C.GtkMenu // out
	var _arg1 *C.gchar   // out

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(accelPath))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_menu_set_accel_path(_arg0, _arg1)
}

// SetActive selects the specified menu item within the menu. This is used by
// the ComboBox and should not be used by anyone else.
func (m menu) SetActive(index uint) {
	var _arg0 *C.GtkMenu // out
	var _arg1 C.guint    // out

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (C.guint)(index)

	C.gtk_menu_set_active(_arg0, _arg1)
}

// SetMonitor informs GTK+ on which monitor a menu should be popped up. See
// gdk_monitor_get_geometry().
//
// This function should be called from a MenuPositionFunc if the menu should not
// appear on the same monitor as the pointer. This information can’t be reliably
// inferred from the coordinates returned by a MenuPositionFunc, since, for very
// long menus, these coordinates may extend beyond the monitor boundaries or
// even the screen boundaries.
func (m menu) SetMonitor(monitorNum int) {
	var _arg0 *C.GtkMenu // out
	var _arg1 C.gint     // out

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (C.gint)(monitorNum)

	C.gtk_menu_set_monitor(_arg0, _arg1)
}

// SetReserveToggleSize sets whether the menu should reserve space for drawing
// toggles or icons, regardless of their actual presence.
func (m menu) SetReserveToggleSize(reserveToggleSize bool) {
	var _arg0 *C.GtkMenu // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))
	if reserveToggleSize {
		_arg1 = C.TRUE
	}

	C.gtk_menu_set_reserve_toggle_size(_arg0, _arg1)
}

// SetScreen sets the Screen on which the menu will be displayed.
func (m menu) SetScreen(screen gdk.Screen) {
	var _arg0 *C.GtkMenu   // out
	var _arg1 *C.GdkScreen // out

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GdkScreen)(unsafe.Pointer(screen.Native()))

	C.gtk_menu_set_screen(_arg0, _arg1)
}

// SetTearoffState changes the tearoff state of the menu. A menu is normally
// displayed as drop down menu which persists as long as the menu is active. It
// can also be displayed as a tearoff menu which persists until it is closed or
// reattached.
func (m menu) SetTearoffState(tornOff bool) {
	var _arg0 *C.GtkMenu // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))
	if tornOff {
		_arg1 = C.TRUE
	}

	C.gtk_menu_set_tearoff_state(_arg0, _arg1)
}

// SetTitle sets the title string for the menu.
//
// The title is displayed when the menu is shown as a tearoff menu. If @title is
// nil, the menu will see if it is attached to a parent menu item, and if so it
// will try to use the same text as that menu item’s label.
func (m menu) SetTitle(title string) {
	var _arg0 *C.GtkMenu // out
	var _arg1 *C.gchar   // out

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_menu_set_title(_arg0, _arg1)
}

type MenuAccessible interface {
	MenuShellAccessible
}

// menuAccessible implements the MenuAccessible class.
type menuAccessible struct {
	MenuShellAccessible
}

var _ MenuAccessible = (*menuAccessible)(nil)

// WrapMenuAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenuAccessible(obj *externglib.Object) MenuAccessible {
	return menuAccessible{
		MenuShellAccessible: WrapMenuShellAccessible(obj),
	}
}

func marshalMenuAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenuAccessible(obj), nil
}

// MenuBar: the MenuBar is a subclass of MenuShell which contains one or more
// MenuItems. The result is a standard menu bar which can hold many menu items.
//
//
// CSS nodes
//
// GtkMenuBar has a single CSS node with name menubar.
type MenuBar interface {
	MenuShell
	Buildable

	// ChildPackDirection retrieves the current child pack direction of the
	// menubar. See gtk_menu_bar_set_child_pack_direction().
	ChildPackDirection() PackDirection
	// PackDirection retrieves the current pack direction of the menubar. See
	// gtk_menu_bar_set_pack_direction().
	PackDirection() PackDirection
	// SetChildPackDirection sets how widgets should be packed inside the
	// children of a menubar.
	SetChildPackDirection(childPackDir PackDirection)
	// SetPackDirection sets how items should be packed inside a menubar.
	SetPackDirection(packDir PackDirection)
}

// menuBar implements the MenuBar class.
type menuBar struct {
	MenuShell
	Buildable
}

var _ MenuBar = (*menuBar)(nil)

// WrapMenuBar wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenuBar(obj *externglib.Object) MenuBar {
	return menuBar{
		MenuShell: WrapMenuShell(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalMenuBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenuBar(obj), nil
}

// NewMenuBar creates a new MenuBar
func NewMenuBar() MenuBar {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_menu_bar_new()

	var _menuBar MenuBar // out

	_menuBar = WrapMenuBar(externglib.Take(unsafe.Pointer(_cret)))

	return _menuBar
}

// NewMenuBarFromModel creates a new MenuBar and populates it with menu items
// and submenus according to @model.
//
// The created menu items are connected to actions found in the
// ApplicationWindow to which the menu bar belongs - typically by means of being
// contained within the ApplicationWindows widget hierarchy.
func NewMenuBarFromModel(model gio.MenuModel) MenuBar {
	var _arg1 *C.GMenuModel // out
	var _cret *C.GtkWidget  // in

	_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

	_cret = C.gtk_menu_bar_new_from_model(_arg1)

	var _menuBar MenuBar // out

	_menuBar = WrapMenuBar(externglib.Take(unsafe.Pointer(_cret)))

	return _menuBar
}

// ChildPackDirection retrieves the current child pack direction of the menubar.
// See gtk_menu_bar_set_child_pack_direction().
func (m menuBar) ChildPackDirection() PackDirection {
	var _arg0 *C.GtkMenuBar      // out
	var _cret C.GtkPackDirection // in

	_arg0 = (*C.GtkMenuBar)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_bar_get_child_pack_direction(_arg0)

	var _packDirection PackDirection // out

	_packDirection = PackDirection(_cret)

	return _packDirection
}

// PackDirection retrieves the current pack direction of the menubar. See
// gtk_menu_bar_set_pack_direction().
func (m menuBar) PackDirection() PackDirection {
	var _arg0 *C.GtkMenuBar      // out
	var _cret C.GtkPackDirection // in

	_arg0 = (*C.GtkMenuBar)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_bar_get_pack_direction(_arg0)

	var _packDirection PackDirection // out

	_packDirection = PackDirection(_cret)

	return _packDirection
}

// SetChildPackDirection sets how widgets should be packed inside the children
// of a menubar.
func (m menuBar) SetChildPackDirection(childPackDir PackDirection) {
	var _arg0 *C.GtkMenuBar      // out
	var _arg1 C.GtkPackDirection // out

	_arg0 = (*C.GtkMenuBar)(unsafe.Pointer(m.Native()))
	_arg1 = (C.GtkPackDirection)(childPackDir)

	C.gtk_menu_bar_set_child_pack_direction(_arg0, _arg1)
}

// SetPackDirection sets how items should be packed inside a menubar.
func (m menuBar) SetPackDirection(packDir PackDirection) {
	var _arg0 *C.GtkMenuBar      // out
	var _arg1 C.GtkPackDirection // out

	_arg0 = (*C.GtkMenuBar)(unsafe.Pointer(m.Native()))
	_arg1 = (C.GtkPackDirection)(packDir)

	C.gtk_menu_bar_set_pack_direction(_arg0, _arg1)
}

// MenuButton: the MenuButton widget is used to display a popup when clicked on.
// This popup can be provided either as a Menu, a Popover or an abstract Model.
//
// The MenuButton widget can hold any valid child widget. That is, it can hold
// almost any other standard Widget. The most commonly used child is Image. If
// no widget is explicitely added to the MenuButton, a Image is automatically
// created, using an arrow image oriented according to MenuButton:direction or
// the generic “open-menu-symbolic” icon if the direction is not set.
//
// The positioning of the popup is determined by the MenuButton:direction
// property of the menu button.
//
// For menus, the Widget:halign and Widget:valign properties of the menu are
// also taken into account. For example, when the direction is GTK_ARROW_DOWN
// and the horizontal alignment is GTK_ALIGN_START, the menu will be positioned
// below the button, with the starting edge (depending on the text direction) of
// the menu aligned with the starting edge of the button. If there is not enough
// space below the button, the menu is popped up above the button instead. If
// the alignment would move part of the menu offscreen, it is “pushed in”.
//
// Direction = Down
//
// - halign = start
//
//    ! (down-start.png)
//
// - halign = center
//
//    ! (down-center.png)
//
// - halign = end
//
//    ! (down-end.png)
//
// Direction = Up
//
// - halign = start
//
//    ! (up-start.png)
//
// - halign = center
//
//    ! (up-center.png)
//
// - halign = end
//
//    ! (up-end.png)
//
// Direction = Left
//
// - valign = start
//
//    ! (left-start.png)
//
// - valign = center
//
//    ! (left-center.png)
//
// - valign = end
//
//    ! (left-end.png)
//
// Direction = Right
//
// - valign = start
//
//    ! (right-start.png)
//
// - valign = center
//
//    ! (right-center.png)
//
// - valign = end
//
//    ! (right-end.png)
//
//
// CSS nodes
//
// GtkMenuButton has a single CSS node with name button. To differentiate it
// from a plain Button, it gets the .popup style class.
type MenuButton interface {
	ToggleButton
	Actionable
	Activatable
	Buildable

	// AlignWidget returns the parent Widget to use to line up with menu.
	AlignWidget() Widget
	// Direction returns the direction the popup will be pointing at when popped
	// up.
	Direction() ArrowType
	// MenuModel returns the Model used to generate the popup.
	MenuModel() gio.MenuModel
	// Popover returns the Popover that pops out of the button. If the button is
	// not using a Popover, this function returns nil.
	Popover() Popover
	// Popup returns the Menu that pops out of the button. If the button does
	// not use a Menu, this function returns nil.
	Popup() Menu
	// UsePopover returns whether a Popover or a Menu will be constructed from
	// the menu model.
	UsePopover() bool
	// SetAlignWidget sets the Widget to use to line the menu with when popped
	// up. Note that the @align_widget must contain the MenuButton itself.
	//
	// Setting it to nil means that the menu will be aligned with the button
	// itself.
	//
	// Note that this property is only used with menus currently, and not for
	// popovers.
	SetAlignWidget(alignWidget Widget)
	// SetDirection sets the direction in which the popup will be popped up, as
	// well as changing the arrow’s direction. The child will not be changed to
	// an arrow if it was customized.
	//
	// If the does not fit in the available space in the given direction, GTK+
	// will its best to keep it inside the screen and fully visible.
	//
	// If you pass GTK_ARROW_NONE for a @direction, the popup will behave as if
	// you passed GTK_ARROW_DOWN (although you won’t see any arrows).
	SetDirection(direction ArrowType)
	// SetMenuModel sets the Model from which the popup will be constructed, or
	// nil to dissociate any existing menu model and disable the button.
	//
	// Depending on the value of MenuButton:use-popover, either a Menu will be
	// created with gtk_menu_new_from_model(), or a Popover with
	// gtk_popover_new_from_model(). In either case, actions will be connected
	// as documented for these functions.
	//
	// If MenuButton:popup or MenuButton:popover are already set, those widgets
	// are dissociated from the @menu_button, and those properties are set to
	// nil.
	SetMenuModel(menuModel gio.MenuModel)
	// SetPopover sets the Popover that will be popped up when the @menu_button
	// is clicked, or nil to dissociate any existing popover and disable the
	// button.
	//
	// If MenuButton:menu-model or MenuButton:popup are set, those objects are
	// dissociated from the @menu_button, and those properties are set to nil.
	SetPopover(popover Widget)
	// SetPopup sets the Menu that will be popped up when the @menu_button is
	// clicked, or nil to dissociate any existing menu and disable the button.
	//
	// If MenuButton:menu-model or MenuButton:popover are set, those objects are
	// dissociated from the @menu_button, and those properties are set to nil.
	SetPopup(menu Widget)
	// SetUsePopover sets whether to construct a Popover instead of Menu when
	// gtk_menu_button_set_menu_model() is called. Note that this property is
	// only consulted when a new menu model is set.
	SetUsePopover(usePopover bool)
}

// menuButton implements the MenuButton class.
type menuButton struct {
	ToggleButton
	Actionable
	Activatable
	Buildable
}

var _ MenuButton = (*menuButton)(nil)

// WrapMenuButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenuButton(obj *externglib.Object) MenuButton {
	return menuButton{
		ToggleButton: WrapToggleButton(obj),
		Actionable:   WrapActionable(obj),
		Activatable:  WrapActivatable(obj),
		Buildable:    WrapBuildable(obj),
	}
}

func marshalMenuButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenuButton(obj), nil
}

// NewMenuButton creates a new MenuButton widget with downwards-pointing arrow
// as the only child. You can replace the child widget with another Widget
// should you wish to.
func NewMenuButton() MenuButton {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_menu_button_new()

	var _menuButton MenuButton // out

	_menuButton = WrapMenuButton(externglib.Take(unsafe.Pointer(_cret)))

	return _menuButton
}

// AlignWidget returns the parent Widget to use to line up with menu.
func (m menuButton) AlignWidget() Widget {
	var _arg0 *C.GtkMenuButton // out
	var _cret *C.GtkWidget     // in

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_button_get_align_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// Direction returns the direction the popup will be pointing at when popped up.
func (m menuButton) Direction() ArrowType {
	var _arg0 *C.GtkMenuButton // out
	var _cret C.GtkArrowType   // in

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_button_get_direction(_arg0)

	var _arrowType ArrowType // out

	_arrowType = ArrowType(_cret)

	return _arrowType
}

// MenuModel returns the Model used to generate the popup.
func (m menuButton) MenuModel() gio.MenuModel {
	var _arg0 *C.GtkMenuButton // out
	var _cret *C.GMenuModel    // in

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_button_get_menu_model(_arg0)

	var _menuModel gio.MenuModel // out

	_menuModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.MenuModel)

	return _menuModel
}

// Popover returns the Popover that pops out of the button. If the button is not
// using a Popover, this function returns nil.
func (m menuButton) Popover() Popover {
	var _arg0 *C.GtkMenuButton // out
	var _cret *C.GtkPopover    // in

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_button_get_popover(_arg0)

	var _popover Popover // out

	_popover = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Popover)

	return _popover
}

// Popup returns the Menu that pops out of the button. If the button does not
// use a Menu, this function returns nil.
func (m menuButton) Popup() Menu {
	var _arg0 *C.GtkMenuButton // out
	var _cret *C.GtkMenu       // in

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_button_get_popup(_arg0)

	var _menu Menu // out

	_menu = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Menu)

	return _menu
}

// UsePopover returns whether a Popover or a Menu will be constructed from the
// menu model.
func (m menuButton) UsePopover() bool {
	var _arg0 *C.GtkMenuButton // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_button_get_use_popover(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetAlignWidget sets the Widget to use to line the menu with when popped up.
// Note that the @align_widget must contain the MenuButton itself.
//
// Setting it to nil means that the menu will be aligned with the button itself.
//
// Note that this property is only used with menus currently, and not for
// popovers.
func (m menuButton) SetAlignWidget(alignWidget Widget) {
	var _arg0 *C.GtkMenuButton // out
	var _arg1 *C.GtkWidget     // out

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(alignWidget.Native()))

	C.gtk_menu_button_set_align_widget(_arg0, _arg1)
}

// SetDirection sets the direction in which the popup will be popped up, as well
// as changing the arrow’s direction. The child will not be changed to an arrow
// if it was customized.
//
// If the does not fit in the available space in the given direction, GTK+ will
// its best to keep it inside the screen and fully visible.
//
// If you pass GTK_ARROW_NONE for a @direction, the popup will behave as if you
// passed GTK_ARROW_DOWN (although you won’t see any arrows).
func (m menuButton) SetDirection(direction ArrowType) {
	var _arg0 *C.GtkMenuButton // out
	var _arg1 C.GtkArrowType   // out

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
	_arg1 = (C.GtkArrowType)(direction)

	C.gtk_menu_button_set_direction(_arg0, _arg1)
}

// SetMenuModel sets the Model from which the popup will be constructed, or nil
// to dissociate any existing menu model and disable the button.
//
// Depending on the value of MenuButton:use-popover, either a Menu will be
// created with gtk_menu_new_from_model(), or a Popover with
// gtk_popover_new_from_model(). In either case, actions will be connected as
// documented for these functions.
//
// If MenuButton:popup or MenuButton:popover are already set, those widgets are
// dissociated from the @menu_button, and those properties are set to nil.
func (m menuButton) SetMenuModel(menuModel gio.MenuModel) {
	var _arg0 *C.GtkMenuButton // out
	var _arg1 *C.GMenuModel    // out

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GMenuModel)(unsafe.Pointer(menuModel.Native()))

	C.gtk_menu_button_set_menu_model(_arg0, _arg1)
}

// SetPopover sets the Popover that will be popped up when the @menu_button is
// clicked, or nil to dissociate any existing popover and disable the button.
//
// If MenuButton:menu-model or MenuButton:popup are set, those objects are
// dissociated from the @menu_button, and those properties are set to nil.
func (m menuButton) SetPopover(popover Widget) {
	var _arg0 *C.GtkMenuButton // out
	var _arg1 *C.GtkWidget     // out

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(popover.Native()))

	C.gtk_menu_button_set_popover(_arg0, _arg1)
}

// SetPopup sets the Menu that will be popped up when the @menu_button is
// clicked, or nil to dissociate any existing menu and disable the button.
//
// If MenuButton:menu-model or MenuButton:popover are set, those objects are
// dissociated from the @menu_button, and those properties are set to nil.
func (m menuButton) SetPopup(menu Widget) {
	var _arg0 *C.GtkMenuButton // out
	var _arg1 *C.GtkWidget     // out

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(menu.Native()))

	C.gtk_menu_button_set_popup(_arg0, _arg1)
}

// SetUsePopover sets whether to construct a Popover instead of Menu when
// gtk_menu_button_set_menu_model() is called. Note that this property is only
// consulted when a new menu model is set.
func (m menuButton) SetUsePopover(usePopover bool) {
	var _arg0 *C.GtkMenuButton // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
	if usePopover {
		_arg1 = C.TRUE
	}

	C.gtk_menu_button_set_use_popover(_arg0, _arg1)
}

type MenuButtonAccessible interface {
	ToggleButtonAccessible
}

// menuButtonAccessible implements the MenuButtonAccessible class.
type menuButtonAccessible struct {
	ToggleButtonAccessible
}

var _ MenuButtonAccessible = (*menuButtonAccessible)(nil)

// WrapMenuButtonAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenuButtonAccessible(obj *externglib.Object) MenuButtonAccessible {
	return menuButtonAccessible{
		ToggleButtonAccessible: WrapToggleButtonAccessible(obj),
	}
}

func marshalMenuButtonAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenuButtonAccessible(obj), nil
}

// MenuItem: the MenuItem widget and the derived widgets are the only valid
// children for menus. Their function is to correctly handle highlighting,
// alignment, events and submenus.
//
// As a GtkMenuItem derives from Bin it can hold any valid child widget,
// although only a few are really useful.
//
// By default, a GtkMenuItem sets a AccelLabel as its child. GtkMenuItem has
// direct functions to set the label and its mnemonic. For more advanced label
// settings, you can fetch the child widget from the GtkBin.
//
// An example for setting markup and accelerator on a MenuItem:
//
//    menuitem
//    ├── <child>
//    ╰── [arrow.right]
//
// GtkMenuItem has a single CSS node with name menuitem. If the menuitem has a
// submenu, it gets another CSS node with name arrow, which has the .left or
// .right style class.
type MenuItem interface {
	Bin
	Actionable
	Activatable
	Buildable

	// Activate emits the MenuItem::activate signal on the given item
	Activate()
	// Deselect emits the MenuItem::deselect signal on the given item.
	Deselect()
	// AccelPath: retrieve the accelerator path that was previously set on
	// @menu_item.
	//
	// See gtk_menu_item_set_accel_path() for details.
	AccelPath() string
	// Label sets @text on the @menu_item label
	Label() string
	// ReserveIndicator returns whether the @menu_item reserves space for the
	// submenu indicator, regardless if it has a submenu or not.
	ReserveIndicator() bool
	// RightJustified gets whether the menu item appears justified at the right
	// side of the menu bar.
	RightJustified() bool
	// Submenu gets the submenu underneath this menu item, if any. See
	// gtk_menu_item_set_submenu().
	Submenu() Widget
	// UseUnderline checks if an underline in the text indicates the next
	// character should be used for the mnemonic accelerator key.
	UseUnderline() bool
	// Select emits the MenuItem::select signal on the given item.
	Select()
	// SetAccelPath: set the accelerator path on @menu_item, through which
	// runtime changes of the menu item’s accelerator caused by the user can be
	// identified and saved to persistent storage (see gtk_accel_map_save() on
	// this). To set up a default accelerator for this menu item, call
	// gtk_accel_map_add_entry() with the same @accel_path. See also
	// gtk_accel_map_add_entry() on the specifics of accelerator paths, and
	// gtk_menu_set_accel_path() for a more convenient variant of this function.
	//
	// This function is basically a convenience wrapper that handles calling
	// gtk_widget_set_accel_path() with the appropriate accelerator group for
	// the menu item.
	//
	// Note that you do need to set an accelerator on the parent menu with
	// gtk_menu_set_accel_group() for this to work.
	//
	// Note that @accel_path string will be stored in a #GQuark. Therefore, if
	// you pass a static string, you can save some memory by interning it first
	// with g_intern_static_string().
	SetAccelPath(accelPath string)
	// SetLabel sets @text on the @menu_item label
	SetLabel(label string)
	// SetReserveIndicator sets whether the @menu_item should reserve space for
	// the submenu indicator, regardless if it actually has a submenu or not.
	//
	// There should be little need for applications to call this functions.
	SetReserveIndicator(reserve bool)
	// SetRightJustified sets whether the menu item appears justified at the
	// right side of a menu bar. This was traditionally done for “Help” menu
	// items, but is now considered a bad idea. (If the widget layout is
	// reversed for a right-to-left language like Hebrew or Arabic,
	// right-justified-menu-items appear at the left.)
	SetRightJustified(rightJustified bool)
	// SetSubmenu sets or replaces the menu item’s submenu, or removes it when a
	// nil submenu is passed.
	SetSubmenu(submenu Menu)
	// SetUseUnderline: if true, an underline in the text indicates the next
	// character should be used for the mnemonic accelerator key.
	SetUseUnderline(setting bool)
	// ToggleSizeAllocate emits the MenuItem::toggle-size-allocate signal on the
	// given item.
	ToggleSizeAllocate(allocation int)
}

// menuItem implements the MenuItem class.
type menuItem struct {
	Bin
	Actionable
	Activatable
	Buildable
}

var _ MenuItem = (*menuItem)(nil)

// WrapMenuItem wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenuItem(obj *externglib.Object) MenuItem {
	return menuItem{
		Bin:         WrapBin(obj),
		Actionable:  WrapActionable(obj),
		Activatable: WrapActivatable(obj),
		Buildable:   WrapBuildable(obj),
	}
}

func marshalMenuItem(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenuItem(obj), nil
}

// NewMenuItem creates a new MenuItem.
func NewMenuItem() MenuItem {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_menu_item_new()

	var _menuItem MenuItem // out

	_menuItem = WrapMenuItem(externglib.Take(unsafe.Pointer(_cret)))

	return _menuItem
}

// NewMenuItemWithLabel creates a new MenuItem whose child is a Label.
func NewMenuItemWithLabel(label string) MenuItem {
	var _arg1 *C.gchar     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_menu_item_new_with_label(_arg1)

	var _menuItem MenuItem // out

	_menuItem = WrapMenuItem(externglib.Take(unsafe.Pointer(_cret)))

	return _menuItem
}

// NewMenuItemWithMnemonic creates a new MenuItem containing a label.
//
// The label will be created using gtk_label_new_with_mnemonic(), so underscores
// in @label indicate the mnemonic for the menu item.
func NewMenuItemWithMnemonic(label string) MenuItem {
	var _arg1 *C.gchar     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_menu_item_new_with_mnemonic(_arg1)

	var _menuItem MenuItem // out

	_menuItem = WrapMenuItem(externglib.Take(unsafe.Pointer(_cret)))

	return _menuItem
}

// Activate emits the MenuItem::activate signal on the given item
func (m menuItem) Activate() {
	var _arg0 *C.GtkMenuItem // out

	_arg0 = (*C.GtkMenuItem)(unsafe.Pointer(m.Native()))

	C.gtk_menu_item_activate(_arg0)
}

// Deselect emits the MenuItem::deselect signal on the given item.
func (m menuItem) Deselect() {
	var _arg0 *C.GtkMenuItem // out

	_arg0 = (*C.GtkMenuItem)(unsafe.Pointer(m.Native()))

	C.gtk_menu_item_deselect(_arg0)
}

// AccelPath: retrieve the accelerator path that was previously set on
// @menu_item.
//
// See gtk_menu_item_set_accel_path() for details.
func (m menuItem) AccelPath() string {
	var _arg0 *C.GtkMenuItem // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GtkMenuItem)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_item_get_accel_path(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Label sets @text on the @menu_item label
func (m menuItem) Label() string {
	var _arg0 *C.GtkMenuItem // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GtkMenuItem)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_item_get_label(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// ReserveIndicator returns whether the @menu_item reserves space for the
// submenu indicator, regardless if it has a submenu or not.
func (m menuItem) ReserveIndicator() bool {
	var _arg0 *C.GtkMenuItem // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkMenuItem)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_item_get_reserve_indicator(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RightJustified gets whether the menu item appears justified at the right side
// of the menu bar.
func (m menuItem) RightJustified() bool {
	var _arg0 *C.GtkMenuItem // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkMenuItem)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_item_get_right_justified(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Submenu gets the submenu underneath this menu item, if any. See
// gtk_menu_item_set_submenu().
func (m menuItem) Submenu() Widget {
	var _arg0 *C.GtkMenuItem // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkMenuItem)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_item_get_submenu(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// UseUnderline checks if an underline in the text indicates the next character
// should be used for the mnemonic accelerator key.
func (m menuItem) UseUnderline() bool {
	var _arg0 *C.GtkMenuItem // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkMenuItem)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_item_get_use_underline(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Select emits the MenuItem::select signal on the given item.
func (m menuItem) Select() {
	var _arg0 *C.GtkMenuItem // out

	_arg0 = (*C.GtkMenuItem)(unsafe.Pointer(m.Native()))

	C.gtk_menu_item_select(_arg0)
}

// SetAccelPath: set the accelerator path on @menu_item, through which runtime
// changes of the menu item’s accelerator caused by the user can be identified
// and saved to persistent storage (see gtk_accel_map_save() on this). To set up
// a default accelerator for this menu item, call gtk_accel_map_add_entry() with
// the same @accel_path. See also gtk_accel_map_add_entry() on the specifics of
// accelerator paths, and gtk_menu_set_accel_path() for a more convenient
// variant of this function.
//
// This function is basically a convenience wrapper that handles calling
// gtk_widget_set_accel_path() with the appropriate accelerator group for the
// menu item.
//
// Note that you do need to set an accelerator on the parent menu with
// gtk_menu_set_accel_group() for this to work.
//
// Note that @accel_path string will be stored in a #GQuark. Therefore, if you
// pass a static string, you can save some memory by interning it first with
// g_intern_static_string().
func (m menuItem) SetAccelPath(accelPath string) {
	var _arg0 *C.GtkMenuItem // out
	var _arg1 *C.gchar       // out

	_arg0 = (*C.GtkMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(accelPath))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_menu_item_set_accel_path(_arg0, _arg1)
}

// SetLabel sets @text on the @menu_item label
func (m menuItem) SetLabel(label string) {
	var _arg0 *C.GtkMenuItem // out
	var _arg1 *C.gchar       // out

	_arg0 = (*C.GtkMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_menu_item_set_label(_arg0, _arg1)
}

// SetReserveIndicator sets whether the @menu_item should reserve space for the
// submenu indicator, regardless if it actually has a submenu or not.
//
// There should be little need for applications to call this functions.
func (m menuItem) SetReserveIndicator(reserve bool) {
	var _arg0 *C.GtkMenuItem // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkMenuItem)(unsafe.Pointer(m.Native()))
	if reserve {
		_arg1 = C.TRUE
	}

	C.gtk_menu_item_set_reserve_indicator(_arg0, _arg1)
}

// SetRightJustified sets whether the menu item appears justified at the right
// side of a menu bar. This was traditionally done for “Help” menu items, but is
// now considered a bad idea. (If the widget layout is reversed for a
// right-to-left language like Hebrew or Arabic, right-justified-menu-items
// appear at the left.)
func (m menuItem) SetRightJustified(rightJustified bool) {
	var _arg0 *C.GtkMenuItem // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkMenuItem)(unsafe.Pointer(m.Native()))
	if rightJustified {
		_arg1 = C.TRUE
	}

	C.gtk_menu_item_set_right_justified(_arg0, _arg1)
}

// SetSubmenu sets or replaces the menu item’s submenu, or removes it when a nil
// submenu is passed.
func (m menuItem) SetSubmenu(submenu Menu) {
	var _arg0 *C.GtkMenuItem // out
	var _arg1 *C.GtkWidget   // out

	_arg0 = (*C.GtkMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(submenu.Native()))

	C.gtk_menu_item_set_submenu(_arg0, _arg1)
}

// SetUseUnderline: if true, an underline in the text indicates the next
// character should be used for the mnemonic accelerator key.
func (m menuItem) SetUseUnderline(setting bool) {
	var _arg0 *C.GtkMenuItem // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkMenuItem)(unsafe.Pointer(m.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_menu_item_set_use_underline(_arg0, _arg1)
}

// ToggleSizeAllocate emits the MenuItem::toggle-size-allocate signal on the
// given item.
func (m menuItem) ToggleSizeAllocate(allocation int) {
	var _arg0 *C.GtkMenuItem // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (C.gint)(allocation)

	C.gtk_menu_item_toggle_size_allocate(_arg0, _arg1)
}

type MenuItemAccessible interface {
	ContainerAccessible
}

// menuItemAccessible implements the MenuItemAccessible class.
type menuItemAccessible struct {
	ContainerAccessible
}

var _ MenuItemAccessible = (*menuItemAccessible)(nil)

// WrapMenuItemAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenuItemAccessible(obj *externglib.Object) MenuItemAccessible {
	return menuItemAccessible{
		ContainerAccessible: WrapContainerAccessible(obj),
	}
}

func marshalMenuItemAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenuItemAccessible(obj), nil
}

// MenuShell: a MenuShell is the abstract base class used to derive the Menu and
// MenuBar subclasses.
//
// A MenuShell is a container of MenuItem objects arranged in a list which can
// be navigated, selected, and activated by the user to perform application
// functions. A MenuItem can have a submenu associated with it, allowing for
// nested hierarchical menus.
//
//
// Terminology
//
// A menu item can be “selected”, this means that it is displayed in the
// prelight state, and if it has a submenu, that submenu will be popped up.
//
// A menu is “active” when it is visible onscreen and the user is selecting from
// it. A menubar is not active until the user clicks on one of its menuitems.
// When a menu is active, passing the mouse over a submenu will pop it up.
//
// There is also is a concept of the current menu and a current menu item. The
// current menu item is the selected menu item that is furthest down in the
// hierarchy. (Every active menu shell does not necessarily contain a selected
// menu item, but if it does, then the parent menu shell must also contain a
// selected menu item.) The current menu is the menu that contains the current
// menu item. It will always have a GTK grab and receive all key presses.
type MenuShell interface {
	Container
	Buildable

	// ActivateItem activates the menu item within the menu shell.
	ActivateItem(menuItem Widget, forceDeactivate bool)
	// Append adds a new MenuItem to the end of the menu shell's item list.
	Append(child MenuItem)
	// BindModel establishes a binding between a MenuShell and a Model.
	//
	// The contents of @shell are removed and then refilled with menu items
	// according to @model. When @model changes, @shell is updated. Calling this
	// function twice on @shell with different @model will cause the first
	// binding to be replaced with a binding to the new model. If @model is nil
	// then any previous binding is undone and all children are removed.
	//
	// @with_separators determines if toplevel items (eg: sections) have
	// separators inserted between them. This is typically desired for menus but
	// doesn’t make sense for menubars.
	//
	// If @action_namespace is non-nil then the effect is as if all actions
	// mentioned in the @model have their names prefixed with the namespace,
	// plus a dot. For example, if the action “quit” is mentioned and
	// @action_namespace is “app” then the effective action name is “app.quit”.
	//
	// This function uses Actionable to define the action name and target values
	// on the created menu items. If you want to use an action group other than
	// “app” and “win”, or if you want to use a MenuShell outside of a
	// ApplicationWindow, then you will need to attach your own action group to
	// the widget hierarchy using gtk_widget_insert_action_group(). As an
	// example, if you created a group with a “quit” action and inserted it with
	// the name “mygroup” then you would use the action name “mygroup.quit” in
	// your Model.
	//
	// For most cases you are probably better off using
	// gtk_menu_new_from_model() or gtk_menu_bar_new_from_model() or just
	// directly passing the Model to gtk_application_set_app_menu() or
	// gtk_application_set_menubar().
	BindModel(model gio.MenuModel, actionNamespace string, withSeparators bool)
	// Cancel cancels the selection within the menu shell.
	Cancel()
	// Deactivate deactivates the menu shell.
	//
	// Typically this results in the menu shell being erased from the screen.
	Deactivate()
	// Deselect deselects the currently selected item from the menu shell, if
	// any.
	Deselect()
	// ParentShell gets the parent menu shell.
	//
	// The parent menu shell of a submenu is the Menu or MenuBar from which it
	// was opened up.
	ParentShell() Widget
	// SelectedItem gets the currently selected item.
	SelectedItem() Widget
	// TakeFocus returns true if the menu shell will take the keyboard focus on
	// popup.
	TakeFocus() bool
	// Insert adds a new MenuItem to the menu shell’s item list at the position
	// indicated by @position.
	Insert(child Widget, position int)
	// Prepend adds a new MenuItem to the beginning of the menu shell's item
	// list.
	Prepend(child Widget)
	// SelectFirst: select the first visible or selectable child of the menu
	// shell; don’t select tearoff items unless the only item is a tearoff item.
	SelectFirst(searchSensitive bool)
	// SelectItem selects the menu item from the menu shell.
	SelectItem(menuItem Widget)
	// SetTakeFocus: if @take_focus is true (the default) the menu shell will
	// take the keyboard focus so that it will receive all keyboard events which
	// is needed to enable keyboard navigation in menus.
	//
	// Setting @take_focus to false is useful only for special applications like
	// virtual keyboard implementations which should not take keyboard focus.
	//
	// The @take_focus state of a menu or menu bar is automatically propagated
	// to submenus whenever a submenu is popped up, so you don’t have to worry
	// about recursively setting it for your entire menu hierarchy. Only when
	// programmatically picking a submenu and popping it up manually, the
	// @take_focus property of the submenu needs to be set explicitly.
	//
	// Note that setting it to false has side-effects:
	//
	// If the focus is in some other app, it keeps the focus and keynav in the
	// menu doesn’t work. Consequently, keynav on the menu will only work if the
	// focus is on some toplevel owned by the onscreen keyboard.
	//
	// To avoid confusing the user, menus with @take_focus set to false should
	// not display mnemonics or accelerators, since it cannot be guaranteed that
	// they will work.
	//
	// See also gdk_keyboard_grab()
	SetTakeFocus(takeFocus bool)
}

// menuShell implements the MenuShell class.
type menuShell struct {
	Container
	Buildable
}

var _ MenuShell = (*menuShell)(nil)

// WrapMenuShell wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenuShell(obj *externglib.Object) MenuShell {
	return menuShell{
		Container: WrapContainer(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalMenuShell(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenuShell(obj), nil
}

// ActivateItem activates the menu item within the menu shell.
func (m menuShell) ActivateItem(menuItem Widget, forceDeactivate bool) {
	var _arg0 *C.GtkMenuShell // out
	var _arg1 *C.GtkWidget    // out
	var _arg2 C.gboolean      // out

	_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(menuItem.Native()))
	if forceDeactivate {
		_arg2 = C.TRUE
	}

	C.gtk_menu_shell_activate_item(_arg0, _arg1, _arg2)
}

// Append adds a new MenuItem to the end of the menu shell's item list.
func (m menuShell) Append(child MenuItem) {
	var _arg0 *C.GtkMenuShell // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_menu_shell_append(_arg0, _arg1)
}

// BindModel establishes a binding between a MenuShell and a Model.
//
// The contents of @shell are removed and then refilled with menu items
// according to @model. When @model changes, @shell is updated. Calling this
// function twice on @shell with different @model will cause the first binding
// to be replaced with a binding to the new model. If @model is nil then any
// previous binding is undone and all children are removed.
//
// @with_separators determines if toplevel items (eg: sections) have separators
// inserted between them. This is typically desired for menus but doesn’t make
// sense for menubars.
//
// If @action_namespace is non-nil then the effect is as if all actions
// mentioned in the @model have their names prefixed with the namespace, plus a
// dot. For example, if the action “quit” is mentioned and @action_namespace is
// “app” then the effective action name is “app.quit”.
//
// This function uses Actionable to define the action name and target values on
// the created menu items. If you want to use an action group other than “app”
// and “win”, or if you want to use a MenuShell outside of a ApplicationWindow,
// then you will need to attach your own action group to the widget hierarchy
// using gtk_widget_insert_action_group(). As an example, if you created a group
// with a “quit” action and inserted it with the name “mygroup” then you would
// use the action name “mygroup.quit” in your Model.
//
// For most cases you are probably better off using gtk_menu_new_from_model() or
// gtk_menu_bar_new_from_model() or just directly passing the Model to
// gtk_application_set_app_menu() or gtk_application_set_menubar().
func (m menuShell) BindModel(model gio.MenuModel, actionNamespace string, withSeparators bool) {
	var _arg0 *C.GtkMenuShell // out
	var _arg1 *C.GMenuModel   // out
	var _arg2 *C.gchar        // out
	var _arg3 C.gboolean      // out

	_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))
	_arg2 = (*C.gchar)(C.CString(actionNamespace))
	defer C.free(unsafe.Pointer(_arg2))
	if withSeparators {
		_arg3 = C.TRUE
	}

	C.gtk_menu_shell_bind_model(_arg0, _arg1, _arg2, _arg3)
}

// Cancel cancels the selection within the menu shell.
func (m menuShell) Cancel() {
	var _arg0 *C.GtkMenuShell // out

	_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(m.Native()))

	C.gtk_menu_shell_cancel(_arg0)
}

// Deactivate deactivates the menu shell.
//
// Typically this results in the menu shell being erased from the screen.
func (m menuShell) Deactivate() {
	var _arg0 *C.GtkMenuShell // out

	_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(m.Native()))

	C.gtk_menu_shell_deactivate(_arg0)
}

// Deselect deselects the currently selected item from the menu shell, if any.
func (m menuShell) Deselect() {
	var _arg0 *C.GtkMenuShell // out

	_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(m.Native()))

	C.gtk_menu_shell_deselect(_arg0)
}

// ParentShell gets the parent menu shell.
//
// The parent menu shell of a submenu is the Menu or MenuBar from which it was
// opened up.
func (m menuShell) ParentShell() Widget {
	var _arg0 *C.GtkMenuShell // out
	var _cret *C.GtkWidget    // in

	_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_shell_get_parent_shell(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// SelectedItem gets the currently selected item.
func (m menuShell) SelectedItem() Widget {
	var _arg0 *C.GtkMenuShell // out
	var _cret *C.GtkWidget    // in

	_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_shell_get_selected_item(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// TakeFocus returns true if the menu shell will take the keyboard focus on
// popup.
func (m menuShell) TakeFocus() bool {
	var _arg0 *C.GtkMenuShell // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_shell_get_take_focus(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Insert adds a new MenuItem to the menu shell’s item list at the position
// indicated by @position.
func (m menuShell) Insert(child Widget, position int) {
	var _arg0 *C.GtkMenuShell // out
	var _arg1 *C.GtkWidget    // out
	var _arg2 C.gint          // out

	_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (C.gint)(position)

	C.gtk_menu_shell_insert(_arg0, _arg1, _arg2)
}

// Prepend adds a new MenuItem to the beginning of the menu shell's item list.
func (m menuShell) Prepend(child Widget) {
	var _arg0 *C.GtkMenuShell // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_menu_shell_prepend(_arg0, _arg1)
}

// SelectFirst: select the first visible or selectable child of the menu shell;
// don’t select tearoff items unless the only item is a tearoff item.
func (m menuShell) SelectFirst(searchSensitive bool) {
	var _arg0 *C.GtkMenuShell // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(m.Native()))
	if searchSensitive {
		_arg1 = C.TRUE
	}

	C.gtk_menu_shell_select_first(_arg0, _arg1)
}

// SelectItem selects the menu item from the menu shell.
func (m menuShell) SelectItem(menuItem Widget) {
	var _arg0 *C.GtkMenuShell // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(menuItem.Native()))

	C.gtk_menu_shell_select_item(_arg0, _arg1)
}

// SetTakeFocus: if @take_focus is true (the default) the menu shell will take
// the keyboard focus so that it will receive all keyboard events which is
// needed to enable keyboard navigation in menus.
//
// Setting @take_focus to false is useful only for special applications like
// virtual keyboard implementations which should not take keyboard focus.
//
// The @take_focus state of a menu or menu bar is automatically propagated to
// submenus whenever a submenu is popped up, so you don’t have to worry about
// recursively setting it for your entire menu hierarchy. Only when
// programmatically picking a submenu and popping it up manually, the
// @take_focus property of the submenu needs to be set explicitly.
//
// Note that setting it to false has side-effects:
//
// If the focus is in some other app, it keeps the focus and keynav in the menu
// doesn’t work. Consequently, keynav on the menu will only work if the focus is
// on some toplevel owned by the onscreen keyboard.
//
// To avoid confusing the user, menus with @take_focus set to false should not
// display mnemonics or accelerators, since it cannot be guaranteed that they
// will work.
//
// See also gdk_keyboard_grab()
func (m menuShell) SetTakeFocus(takeFocus bool) {
	var _arg0 *C.GtkMenuShell // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(m.Native()))
	if takeFocus {
		_arg1 = C.TRUE
	}

	C.gtk_menu_shell_set_take_focus(_arg0, _arg1)
}

type MenuShellAccessible interface {
	ContainerAccessible
}

// menuShellAccessible implements the MenuShellAccessible class.
type menuShellAccessible struct {
	ContainerAccessible
}

var _ MenuShellAccessible = (*menuShellAccessible)(nil)

// WrapMenuShellAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenuShellAccessible(obj *externglib.Object) MenuShellAccessible {
	return menuShellAccessible{
		ContainerAccessible: WrapContainerAccessible(obj),
	}
}

func marshalMenuShellAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenuShellAccessible(obj), nil
}

// MenuToolButton: a MenuToolButton is a ToolItem that contains a button and a
// small additional button with an arrow. When clicked, the arrow button pops up
// a dropdown menu.
//
// Use gtk_menu_tool_button_new() to create a new MenuToolButton.
//
//
// GtkMenuToolButton as GtkBuildable
//
// The GtkMenuToolButton implementation of the GtkBuildable interface supports
// adding a menu by specifying “menu” as the “type” attribute of a <child>
// element.
//
// An example for a UI definition fragment with menus:
//
//    <object class="GtkMenuToolButton">
//      <child type="menu">
//        <object class="GtkMenu"/>
//      </child>
//    </object>
type MenuToolButton interface {
	ToolButton
	Actionable
	Activatable
	Buildable

	// Menu gets the Menu associated with MenuToolButton.
	Menu() Widget
	// SetArrowTooltipMarkup sets the tooltip markup text to be used as tooltip
	// for the arrow button which pops up the menu. See
	// gtk_tool_item_set_tooltip_text() for setting a tooltip on the whole
	// MenuToolButton.
	SetArrowTooltipMarkup(markup string)
	// SetArrowTooltipText sets the tooltip text to be used as tooltip for the
	// arrow button which pops up the menu. See gtk_tool_item_set_tooltip_text()
	// for setting a tooltip on the whole MenuToolButton.
	SetArrowTooltipText(text string)
	// SetMenu sets the Menu that is popped up when the user clicks on the
	// arrow. If @menu is NULL, the arrow button becomes insensitive.
	SetMenu(menu Widget)
}

// menuToolButton implements the MenuToolButton class.
type menuToolButton struct {
	ToolButton
	Actionable
	Activatable
	Buildable
}

var _ MenuToolButton = (*menuToolButton)(nil)

// WrapMenuToolButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenuToolButton(obj *externglib.Object) MenuToolButton {
	return menuToolButton{
		ToolButton:  WrapToolButton(obj),
		Actionable:  WrapActionable(obj),
		Activatable: WrapActivatable(obj),
		Buildable:   WrapBuildable(obj),
	}
}

func marshalMenuToolButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenuToolButton(obj), nil
}

// NewMenuToolButton creates a new MenuToolButton using @icon_widget as icon and
// @label as label.
func NewMenuToolButton(iconWidget Widget, label string) MenuToolButton {
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.gchar       // out
	var _cret *C.GtkToolItem // in

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(iconWidget.Native()))
	_arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_menu_tool_button_new(_arg1, _arg2)

	var _menuToolButton MenuToolButton // out

	_menuToolButton = WrapMenuToolButton(externglib.Take(unsafe.Pointer(_cret)))

	return _menuToolButton
}

// NewMenuToolButtonFromStock creates a new MenuToolButton. The new
// MenuToolButton will contain an icon and label from the stock item indicated
// by @stock_id.
func NewMenuToolButtonFromStock(stockId string) MenuToolButton {
	var _arg1 *C.gchar       // out
	var _cret *C.GtkToolItem // in

	_arg1 = (*C.gchar)(C.CString(stockId))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_menu_tool_button_new_from_stock(_arg1)

	var _menuToolButton MenuToolButton // out

	_menuToolButton = WrapMenuToolButton(externglib.Take(unsafe.Pointer(_cret)))

	return _menuToolButton
}

// Menu gets the Menu associated with MenuToolButton.
func (b menuToolButton) Menu() Widget {
	var _arg0 *C.GtkMenuToolButton // out
	var _cret *C.GtkWidget         // in

	_arg0 = (*C.GtkMenuToolButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_menu_tool_button_get_menu(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// SetArrowTooltipMarkup sets the tooltip markup text to be used as tooltip for
// the arrow button which pops up the menu. See gtk_tool_item_set_tooltip_text()
// for setting a tooltip on the whole MenuToolButton.
func (b menuToolButton) SetArrowTooltipMarkup(markup string) {
	var _arg0 *C.GtkMenuToolButton // out
	var _arg1 *C.gchar             // out

	_arg0 = (*C.GtkMenuToolButton)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(markup))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_menu_tool_button_set_arrow_tooltip_markup(_arg0, _arg1)
}

// SetArrowTooltipText sets the tooltip text to be used as tooltip for the arrow
// button which pops up the menu. See gtk_tool_item_set_tooltip_text() for
// setting a tooltip on the whole MenuToolButton.
func (b menuToolButton) SetArrowTooltipText(text string) {
	var _arg0 *C.GtkMenuToolButton // out
	var _arg1 *C.gchar             // out

	_arg0 = (*C.GtkMenuToolButton)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_menu_tool_button_set_arrow_tooltip_text(_arg0, _arg1)
}

// SetMenu sets the Menu that is popped up when the user clicks on the arrow. If
// @menu is NULL, the arrow button becomes insensitive.
func (b menuToolButton) SetMenu(menu Widget) {
	var _arg0 *C.GtkMenuToolButton // out
	var _arg1 *C.GtkWidget         // out

	_arg0 = (*C.GtkMenuToolButton)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(menu.Native()))

	C.gtk_menu_tool_button_set_menu(_arg0, _arg1)
}

// MessageDialog presents a dialog with some message text. It’s simply a
// convenience widget; you could construct the equivalent of MessageDialog from
// Dialog without too much effort, but MessageDialog saves typing.
//
// One difference from Dialog is that MessageDialog sets the
// Window:skip-taskbar-hint property to true, so that the dialog is hidden from
// the taskbar by default.
//
// The easiest way to do a modal message dialog is to use gtk_dialog_run(),
// though you can also pass in the GTK_DIALOG_MODAL flag, gtk_dialog_run()
// automatically makes the dialog modal and waits for the user to respond to it.
// gtk_dialog_run() returns when any dialog button is clicked.
//
// An example for using a modal dialog:
//
//     GtkDialogFlags flags = GTK_DIALOG_DESTROY_WITH_PARENT;
//     dialog = gtk_message_dialog_new (parent_window,
//                                      flags,
//                                      GTK_MESSAGE_ERROR,
//                                      GTK_BUTTONS_CLOSE,
//                                      "Error reading “s”: s",
//                                      filename,
//                                      g_strerror (errno));
//
//     // Destroy the dialog when the user responds to it
//     // (e.g. clicks a button)
//
//     g_signal_connect_swapped (dialog, "response",
//                               G_CALLBACK (gtk_widget_destroy),
//                               dialog);
//
//
// GtkMessageDialog as GtkBuildable
//
// The GtkMessageDialog implementation of the GtkBuildable interface exposes the
// message area as an internal child with the name “message_area”.
type MessageDialog interface {
	Dialog
	Buildable

	// Image gets the dialog’s image.
	Image() Widget
	// MessageArea returns the message area of the dialog. This is the box where
	// the dialog’s primary and secondary labels are packed. You can add your
	// own extra content to that box and it will appear below those labels. See
	// gtk_dialog_get_content_area() for the corresponding function in the
	// parent Dialog.
	MessageArea() Widget
	// SetImage sets the dialog’s image to @image.
	SetImage(image Widget)
	// SetMarkup sets the text of the message dialog to be @str, which is marked
	// up with the [Pango text markup language][PangoMarkupFormat].
	SetMarkup(str string)
}

// messageDialog implements the MessageDialog class.
type messageDialog struct {
	Dialog
	Buildable
}

var _ MessageDialog = (*messageDialog)(nil)

// WrapMessageDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapMessageDialog(obj *externglib.Object) MessageDialog {
	return messageDialog{
		Dialog:    WrapDialog(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalMessageDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMessageDialog(obj), nil
}

// Image gets the dialog’s image.
func (d messageDialog) Image() Widget {
	var _arg0 *C.GtkMessageDialog // out
	var _cret *C.GtkWidget        // in

	_arg0 = (*C.GtkMessageDialog)(unsafe.Pointer(d.Native()))

	_cret = C.gtk_message_dialog_get_image(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// MessageArea returns the message area of the dialog. This is the box where the
// dialog’s primary and secondary labels are packed. You can add your own extra
// content to that box and it will appear below those labels. See
// gtk_dialog_get_content_area() for the corresponding function in the parent
// Dialog.
func (m messageDialog) MessageArea() Widget {
	var _arg0 *C.GtkMessageDialog // out
	var _cret *C.GtkWidget        // in

	_arg0 = (*C.GtkMessageDialog)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_message_dialog_get_message_area(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// SetImage sets the dialog’s image to @image.
func (d messageDialog) SetImage(image Widget) {
	var _arg0 *C.GtkMessageDialog // out
	var _arg1 *C.GtkWidget        // out

	_arg0 = (*C.GtkMessageDialog)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(image.Native()))

	C.gtk_message_dialog_set_image(_arg0, _arg1)
}

// SetMarkup sets the text of the message dialog to be @str, which is marked up
// with the [Pango text markup language][PangoMarkupFormat].
func (m messageDialog) SetMarkup(str string) {
	var _arg0 *C.GtkMessageDialog // out
	var _arg1 *C.gchar            // out

	_arg0 = (*C.GtkMessageDialog)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_message_dialog_set_markup(_arg0, _arg1)
}

// Misc: the Misc widget is an abstract widget which is not useful itself, but
// is used to derive subclasses which have alignment and padding attributes.
//
// The horizontal and vertical padding attributes allows extra space to be added
// around the widget.
//
// The horizontal and vertical alignment attributes enable the widget to be
// positioned within its allocated area. Note that if the widget is added to a
// container in such a way that it expands automatically to fill its allocated
// area, the alignment settings will not alter the widget's position.
//
// Note that the desired effect can in most cases be achieved by using the
// Widget:halign, Widget:valign and Widget:margin properties on the child
// widget, so GtkMisc should not be used in new code. To reflect this fact, all
// Misc API has been deprecated.
type Misc interface {
	Widget
	Buildable

	// Alignment gets the X and Y alignment of the widget within its allocation.
	// See gtk_misc_set_alignment().
	Alignment() (xalign float32, yalign float32)
	// Padding gets the padding in the X and Y directions of the widget. See
	// gtk_misc_set_padding().
	Padding() (xpad int, ypad int)
	// SetAlignment sets the alignment of the widget.
	SetAlignment(xalign float32, yalign float32)
	// SetPadding sets the amount of space to add around the widget.
	SetPadding(xpad int, ypad int)
}

// misc implements the Misc class.
type misc struct {
	Widget
	Buildable
}

var _ Misc = (*misc)(nil)

// WrapMisc wraps a GObject to the right type. It is
// primarily used internally.
func WrapMisc(obj *externglib.Object) Misc {
	return misc{
		Widget:    WrapWidget(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalMisc(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMisc(obj), nil
}

// Alignment gets the X and Y alignment of the widget within its allocation. See
// gtk_misc_set_alignment().
func (m misc) Alignment() (xalign float32, yalign float32) {
	var _arg0 *C.GtkMisc // out
	var _arg1 C.gfloat   // in
	var _arg2 C.gfloat   // in

	_arg0 = (*C.GtkMisc)(unsafe.Pointer(m.Native()))

	C.gtk_misc_get_alignment(_arg0, &_arg1, &_arg2)

	var _xalign float32 // out
	var _yalign float32 // out

	_xalign = (float32)(_arg1)
	_yalign = (float32)(_arg2)

	return _xalign, _yalign
}

// Padding gets the padding in the X and Y directions of the widget. See
// gtk_misc_set_padding().
func (m misc) Padding() (xpad int, ypad int) {
	var _arg0 *C.GtkMisc // out
	var _arg1 C.gint     // in
	var _arg2 C.gint     // in

	_arg0 = (*C.GtkMisc)(unsafe.Pointer(m.Native()))

	C.gtk_misc_get_padding(_arg0, &_arg1, &_arg2)

	var _xpad int // out
	var _ypad int // out

	_xpad = (int)(_arg1)
	_ypad = (int)(_arg2)

	return _xpad, _ypad
}

// SetAlignment sets the alignment of the widget.
func (m misc) SetAlignment(xalign float32, yalign float32) {
	var _arg0 *C.GtkMisc // out
	var _arg1 C.gfloat   // out
	var _arg2 C.gfloat   // out

	_arg0 = (*C.GtkMisc)(unsafe.Pointer(m.Native()))
	_arg1 = (C.gfloat)(xalign)
	_arg2 = (C.gfloat)(yalign)

	C.gtk_misc_set_alignment(_arg0, _arg1, _arg2)
}

// SetPadding sets the amount of space to add around the widget.
func (m misc) SetPadding(xpad int, ypad int) {
	var _arg0 *C.GtkMisc // out
	var _arg1 C.gint     // out
	var _arg2 C.gint     // out

	_arg0 = (*C.GtkMisc)(unsafe.Pointer(m.Native()))
	_arg1 = (C.gint)(xpad)
	_arg2 = (C.gint)(ypad)

	C.gtk_misc_set_padding(_arg0, _arg1, _arg2)
}

// ModelButton: gtkModelButton is a button class that can use a #GAction as its
// model. In contrast to ToggleButton or RadioButton, which can also be backed
// by a #GAction via the Actionable:action-name property, GtkModelButton will
// adapt its appearance according to the kind of action it is backed by, and
// appear either as a plain, check or radio button.
//
// Model buttons are used when popovers from a menu model with
// gtk_popover_new_from_model(); they can also be used manually in a
// PopoverMenu.
//
// When the action is specified via the Actionable:action-name and
// Actionable:action-target properties, the role of the button (i.e. whether it
// is a plain, check or radio button) is determined by the type of the action
// and doesn't have to be explicitly specified with the ModelButton:role
// property.
//
// The content of the button is specified by the ModelButton:text and
// ModelButton:icon properties.
//
// The appearance of model buttons can be influenced with the
// ModelButton:centered and ModelButton:iconic properties.
//
// Model buttons have built-in support for submenus in PopoverMenu. To make a
// GtkModelButton that opens a submenu when activated, set the
// ModelButton:menu-name property. To make a button that goes back to the parent
// menu, you should set the ModelButton:inverted property to place the submenu
// indicator at the opposite side.
//
// Example
//
//    <object class="GtkPopoverMenu">
//      <child>
//        <object class="GtkBox">
//          <property name="visible">True</property>
//          <property name="margin">10</property>
//          <child>
//            <object class="GtkModelButton">
//              <property name="visible">True</property>
//              <property name="action-name">view.cut</property>
//              <property name="text" translatable="yes">Cut</property>
//            </object>
//          </child>
//          <child>
//            <object class="GtkModelButton">
//              <property name="visible">True</property>
//              <property name="action-name">view.copy</property>
//              <property name="text" translatable="yes">Copy</property>
//            </object>
//          </child>
//          <child>
//            <object class="GtkModelButton">
//              <property name="visible">True</property>
//              <property name="action-name">view.paste</property>
//              <property name="text" translatable="yes">Paste</property>
//            </object>
//          </child>
//        </object>
//      </child>
//    </object>
//
// CSS nodes
//
//    button.model
//    ├── <child>
//    ╰── check
//
// Iconic model buttons (see ModelButton:iconic) change the name of their main
// node to button and add a .model style class to it. The indicator subnode is
// invisible in this case.
type ModelButton interface {
	Button
	Actionable
	Activatable
	Buildable
}

// modelButton implements the ModelButton class.
type modelButton struct {
	Button
	Actionable
	Activatable
	Buildable
}

var _ ModelButton = (*modelButton)(nil)

// WrapModelButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapModelButton(obj *externglib.Object) ModelButton {
	return modelButton{
		Button:      WrapButton(obj),
		Actionable:  WrapActionable(obj),
		Activatable: WrapActivatable(obj),
		Buildable:   WrapBuildable(obj),
	}
}

func marshalModelButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapModelButton(obj), nil
}

// NewModelButton creates a new GtkModelButton.
func NewModelButton() ModelButton {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_model_button_new()

	var _modelButton ModelButton // out

	_modelButton = WrapModelButton(externglib.Take(unsafe.Pointer(_cret)))

	return _modelButton
}

// MountOperation: this should not be accessed directly. Use the accessor
// functions below.
type MountOperation interface {
	gio.MountOperation

	// Parent gets the transient parent used by the MountOperation
	Parent() Window
	// Screen gets the screen on which windows of the MountOperation will be
	// shown.
	Screen() gdk.Screen
	// IsShowing returns whether the MountOperation is currently displaying a
	// window.
	IsShowing() bool
	// SetParent sets the transient parent for windows shown by the
	// MountOperation.
	SetParent(parent Window)
	// SetScreen sets the screen to show windows of the MountOperation on.
	SetScreen(screen gdk.Screen)
}

// mountOperation implements the MountOperation class.
type mountOperation struct {
	gio.MountOperation
}

var _ MountOperation = (*mountOperation)(nil)

// WrapMountOperation wraps a GObject to the right type. It is
// primarily used internally.
func WrapMountOperation(obj *externglib.Object) MountOperation {
	return mountOperation{
		MountOperation: gio.WrapMountOperation(obj),
	}
}

func marshalMountOperation(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMountOperation(obj), nil
}

// NewMountOperation creates a new MountOperation
func NewMountOperation(parent Window) MountOperation {
	var _arg1 *C.GtkWindow       // out
	var _cret *C.GMountOperation // in

	_arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))

	_cret = C.gtk_mount_operation_new(_arg1)

	var _mountOperation MountOperation // out

	_mountOperation = WrapMountOperation(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _mountOperation
}

// Parent gets the transient parent used by the MountOperation
func (o mountOperation) Parent() Window {
	var _arg0 *C.GtkMountOperation // out
	var _cret *C.GtkWindow         // in

	_arg0 = (*C.GtkMountOperation)(unsafe.Pointer(o.Native()))

	_cret = C.gtk_mount_operation_get_parent(_arg0)

	var _window Window // out

	_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Window)

	return _window
}

// Screen gets the screen on which windows of the MountOperation will be shown.
func (o mountOperation) Screen() gdk.Screen {
	var _arg0 *C.GtkMountOperation // out
	var _cret *C.GdkScreen         // in

	_arg0 = (*C.GtkMountOperation)(unsafe.Pointer(o.Native()))

	_cret = C.gtk_mount_operation_get_screen(_arg0)

	var _screen gdk.Screen // out

	_screen = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Screen)

	return _screen
}

// IsShowing returns whether the MountOperation is currently displaying a
// window.
func (o mountOperation) IsShowing() bool {
	var _arg0 *C.GtkMountOperation // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkMountOperation)(unsafe.Pointer(o.Native()))

	_cret = C.gtk_mount_operation_is_showing(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetParent sets the transient parent for windows shown by the MountOperation.
func (o mountOperation) SetParent(parent Window) {
	var _arg0 *C.GtkMountOperation // out
	var _arg1 *C.GtkWindow         // out

	_arg0 = (*C.GtkMountOperation)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))

	C.gtk_mount_operation_set_parent(_arg0, _arg1)
}

// SetScreen sets the screen to show windows of the MountOperation on.
func (o mountOperation) SetScreen(screen gdk.Screen) {
	var _arg0 *C.GtkMountOperation // out
	var _arg1 *C.GdkScreen         // out

	_arg0 = (*C.GtkMountOperation)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.GdkScreen)(unsafe.Pointer(screen.Native()))

	C.gtk_mount_operation_set_screen(_arg0, _arg1)
}

// NativeDialog: native dialogs are platform dialogs that don't use Dialog or
// Window. They are used in order to integrate better with a platform, by
// looking the same as other native applications and supporting platform
// specific features.
//
// The Dialog functions cannot be used on such objects, but we need a similar
// API in order to drive them. The NativeDialog object is an API that allows you
// to do this. It allows you to set various common properties on the dialog, as
// well as show and hide it and get a NativeDialog::response signal when the
// user finished with the dialog.
//
// There is also a gtk_native_dialog_run() helper that makes it easy to run any
// native dialog in a modal way with a recursive mainloop, similar to
// gtk_dialog_run().
type NativeDialog interface {
	gextras.Objector

	// Destroy destroys a dialog.
	//
	// When a dialog is destroyed, it will break any references it holds to
	// other objects. If it is visible it will be hidden and any underlying
	// window system resources will be destroyed.
	//
	// Note that this does not release any reference to the object (as opposed
	// to destroying a GtkWindow) because there is no reference from the
	// windowing system to the NativeDialog.
	Destroy()
	// Modal returns whether the dialog is modal. See
	// gtk_native_dialog_set_modal().
	Modal() bool
	// Title gets the title of the NativeDialog.
	Title() string
	// TransientFor fetches the transient parent for this window. See
	// gtk_native_dialog_set_transient_for().
	TransientFor() Window
	// Visible determines whether the dialog is visible.
	Visible() bool
	// Hide hides the dialog if it is visilbe, aborting any interaction. Once
	// this is called the NativeDialog::response signal will not be emitted
	// until after the next call to gtk_native_dialog_show().
	//
	// If the dialog is not visible this does nothing.
	Hide()
	// Run blocks in a recursive main loop until @self emits the
	// NativeDialog::response signal. It then returns the response ID from the
	// ::response signal emission.
	//
	// Before entering the recursive main loop, gtk_native_dialog_run() calls
	// gtk_native_dialog_show() on the dialog for you.
	//
	// After gtk_native_dialog_run() returns, then dialog will be hidden.
	//
	// Typical usage of this function might be:
	//
	//    gint result = gtk_native_dialog_run (GTK_NATIVE_DIALOG (dialog));
	//    switch (result)
	//      {
	//        case GTK_RESPONSE_ACCEPT:
	//           do_application_specific_something ();
	//           break;
	//        default:
	//           do_nothing_since_dialog_was_cancelled ();
	//           break;
	//      }
	//    g_object_unref (dialog);
	//
	// Note that even though the recursive main loop gives the effect of a modal
	// dialog (it prevents the user from interacting with other windows in the
	// same window group while the dialog is run), callbacks such as timeouts,
	// IO channel watches, DND drops, etc, will be triggered during a
	// gtk_native_dialog_run() call.
	Run() int
	// SetModal sets a dialog modal or non-modal. Modal dialogs prevent
	// interaction with other windows in the same application. To keep modal
	// dialogs on top of main application windows, use
	// gtk_native_dialog_set_transient_for() to make the dialog transient for
	// the parent; most [window managers][gtk-X11-arch] will then disallow
	// lowering the dialog below the parent.
	SetModal(modal bool)
	// SetTitle sets the title of the NativeDialog.
	SetTitle(title string)
	// SetTransientFor: dialog windows should be set transient for the main
	// application window they were spawned from. This allows [window
	// managers][gtk-X11-arch] to e.g. keep the dialog on top of the main
	// window, or center the dialog over the main window.
	//
	// Passing nil for @parent unsets the current transient window.
	SetTransientFor(parent Window)
	// Show shows the dialog on the display, allowing the user to interact with
	// it. When the user accepts the state of the dialog the dialog will be
	// automatically hidden and the NativeDialog::response signal will be
	// emitted.
	//
	// Multiple calls while the dialog is visible will be ignored.
	Show()
}

// nativeDialog implements the NativeDialog class.
type nativeDialog struct {
	gextras.Objector
}

var _ NativeDialog = (*nativeDialog)(nil)

// WrapNativeDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapNativeDialog(obj *externglib.Object) NativeDialog {
	return nativeDialog{
		Objector: obj,
	}
}

func marshalNativeDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNativeDialog(obj), nil
}

// Destroy destroys a dialog.
//
// When a dialog is destroyed, it will break any references it holds to other
// objects. If it is visible it will be hidden and any underlying window system
// resources will be destroyed.
//
// Note that this does not release any reference to the object (as opposed to
// destroying a GtkWindow) because there is no reference from the windowing
// system to the NativeDialog.
func (s nativeDialog) Destroy() {
	var _arg0 *C.GtkNativeDialog // out

	_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))

	C.gtk_native_dialog_destroy(_arg0)
}

// Modal returns whether the dialog is modal. See gtk_native_dialog_set_modal().
func (s nativeDialog) Modal() bool {
	var _arg0 *C.GtkNativeDialog // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_native_dialog_get_modal(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Title gets the title of the NativeDialog.
func (s nativeDialog) Title() string {
	var _arg0 *C.GtkNativeDialog // out
	var _cret *C.char            // in

	_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_native_dialog_get_title(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// TransientFor fetches the transient parent for this window. See
// gtk_native_dialog_set_transient_for().
func (s nativeDialog) TransientFor() Window {
	var _arg0 *C.GtkNativeDialog // out
	var _cret *C.GtkWindow       // in

	_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_native_dialog_get_transient_for(_arg0)

	var _window Window // out

	_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Window)

	return _window
}

// Visible determines whether the dialog is visible.
func (s nativeDialog) Visible() bool {
	var _arg0 *C.GtkNativeDialog // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_native_dialog_get_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Hide hides the dialog if it is visilbe, aborting any interaction. Once this
// is called the NativeDialog::response signal will not be emitted until after
// the next call to gtk_native_dialog_show().
//
// If the dialog is not visible this does nothing.
func (s nativeDialog) Hide() {
	var _arg0 *C.GtkNativeDialog // out

	_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))

	C.gtk_native_dialog_hide(_arg0)
}

// Run blocks in a recursive main loop until @self emits the
// NativeDialog::response signal. It then returns the response ID from the
// ::response signal emission.
//
// Before entering the recursive main loop, gtk_native_dialog_run() calls
// gtk_native_dialog_show() on the dialog for you.
//
// After gtk_native_dialog_run() returns, then dialog will be hidden.
//
// Typical usage of this function might be:
//
//    gint result = gtk_native_dialog_run (GTK_NATIVE_DIALOG (dialog));
//    switch (result)
//      {
//        case GTK_RESPONSE_ACCEPT:
//           do_application_specific_something ();
//           break;
//        default:
//           do_nothing_since_dialog_was_cancelled ();
//           break;
//      }
//    g_object_unref (dialog);
//
// Note that even though the recursive main loop gives the effect of a modal
// dialog (it prevents the user from interacting with other windows in the same
// window group while the dialog is run), callbacks such as timeouts, IO channel
// watches, DND drops, etc, will be triggered during a gtk_native_dialog_run()
// call.
func (s nativeDialog) Run() int {
	var _arg0 *C.GtkNativeDialog // out
	var _cret C.gint             // in

	_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_native_dialog_run(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// SetModal sets a dialog modal or non-modal. Modal dialogs prevent interaction
// with other windows in the same application. To keep modal dialogs on top of
// main application windows, use gtk_native_dialog_set_transient_for() to make
// the dialog transient for the parent; most [window managers][gtk-X11-arch]
// will then disallow lowering the dialog below the parent.
func (s nativeDialog) SetModal(modal bool) {
	var _arg0 *C.GtkNativeDialog // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))
	if modal {
		_arg1 = C.TRUE
	}

	C.gtk_native_dialog_set_modal(_arg0, _arg1)
}

// SetTitle sets the title of the NativeDialog.
func (s nativeDialog) SetTitle(title string) {
	var _arg0 *C.GtkNativeDialog // out
	var _arg1 *C.char            // out

	_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_native_dialog_set_title(_arg0, _arg1)
}

// SetTransientFor: dialog windows should be set transient for the main
// application window they were spawned from. This allows [window
// managers][gtk-X11-arch] to e.g. keep the dialog on top of the main window, or
// center the dialog over the main window.
//
// Passing nil for @parent unsets the current transient window.
func (s nativeDialog) SetTransientFor(parent Window) {
	var _arg0 *C.GtkNativeDialog // out
	var _arg1 *C.GtkWindow       // out

	_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))

	C.gtk_native_dialog_set_transient_for(_arg0, _arg1)
}

// Show shows the dialog on the display, allowing the user to interact with it.
// When the user accepts the state of the dialog the dialog will be
// automatically hidden and the NativeDialog::response signal will be emitted.
//
// Multiple calls while the dialog is visible will be ignored.
func (s nativeDialog) Show() {
	var _arg0 *C.GtkNativeDialog // out

	_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))

	C.gtk_native_dialog_show(_arg0)
}

// Notebook: the Notebook widget is a Container whose children are pages that
// can be switched between using tab labels along one edge.
//
// There are many configuration options for GtkNotebook. Among other things, you
// can choose on which edge the tabs appear (see gtk_notebook_set_tab_pos()),
// whether, if there are too many tabs to fit the notebook should be made bigger
// or scrolling arrows added (see gtk_notebook_set_scrollable()), and whether
// there will be a popup menu allowing the users to switch pages. (see
// gtk_notebook_popup_enable(), gtk_notebook_popup_disable())
//
//
// GtkNotebook as GtkBuildable
//
// The GtkNotebook implementation of the Buildable interface supports placing
// children into tabs by specifying “tab” as the “type” attribute of a <child>
// element. Note that the content of the tab must be created before the tab can
// be filled. A tab child can be specified without specifying a <child> type
// attribute.
//
// To add a child widget in the notebooks action area, specify "action-start" or
// “action-end” as the “type” attribute of the <child> element.
//
// An example of a UI definition fragment with GtkNotebook:
//
//    <object class="GtkNotebook">
//      <child>
//        <object class="GtkLabel" id="notebook-content">
//          <property name="label">Content</property>
//        </object>
//      </child>
//      <child type="tab">
//        <object class="GtkLabel" id="notebook-tab">
//          <property name="label">Tab</property>
//        </object>
//      </child>
//    </object>
//
// CSS nodes
//
//    notebook
//    ├── header.top
//    │   ├── [<action widget>]
//    │   ├── tabs
//    │   │   ├── [arrow]
//    │   │   ├── tab
//    │   │   │   ╰── <tab label>
//    ┊   ┊   ┊
//    │   │   ├── tab[.reorderable-page]
//    │   │   │   ╰── <tab label>
//    │   │   ╰── [arrow]
//    │   ╰── [<action widget>]
//    │
//    ╰── stack
//        ├── <child>
//        ┊
//        ╰── <child>
//
// GtkNotebook has a main CSS node with name notebook, a subnode with name
// header and below that a subnode with name tabs which contains one subnode per
// tab with name tab.
//
// If action widgets are present, their CSS nodes are placed next to the tabs
// node. If the notebook is scrollable, CSS nodes with name arrow are placed as
// first and last child of the tabs node.
//
// The main node gets the .frame style class when the notebook has a border (see
// gtk_notebook_set_show_border()).
//
// The header node gets one of the style class .top, .bottom, .left or .right,
// depending on where the tabs are placed. For reorderable pages, the tab node
// gets the .reorderable-page class.
//
// A tab node gets the .dnd style class while it is moved with drag-and-drop.
//
// The nodes are always arranged from left-to-right, regarldess of text
// direction.
type Notebook interface {
	Container
	Buildable

	// AppendPage appends a page to @notebook.
	AppendPage(child Widget, tabLabel Widget) int
	// AppendPageMenu appends a page to @notebook, specifying the widget to use
	// as the label in the popup menu.
	AppendPageMenu(child Widget, tabLabel Widget, menuLabel Widget) int
	// DetachTab removes the child from the notebook.
	//
	// This function is very similar to gtk_container_remove(), but additionally
	// informs the notebook that the removal is happening as part of a tab DND
	// operation, which should not be cancelled.
	DetachTab(child Widget)
	// ActionWidget gets one of the action widgets. See
	// gtk_notebook_set_action_widget().
	ActionWidget(packType PackType) Widget
	// CurrentPage returns the page number of the current page.
	CurrentPage() int
	// GroupName gets the current group name for @notebook.
	GroupName() string
	// MenuLabel retrieves the menu label widget of the page containing @child.
	MenuLabel(child Widget) Widget
	// MenuLabelText retrieves the text of the menu label for the page
	// containing @child.
	MenuLabelText(child Widget) string
	// NPages gets the number of pages in a notebook.
	NPages() int
	// NthPage returns the child widget contained in page number @page_num.
	NthPage(pageNum int) Widget
	// Scrollable returns whether the tab label area has arrows for scrolling.
	// See gtk_notebook_set_scrollable().
	Scrollable() bool
	// ShowBorder returns whether a bevel will be drawn around the notebook
	// pages. See gtk_notebook_set_show_border().
	ShowBorder() bool
	// ShowTabs returns whether the tabs of the notebook are shown. See
	// gtk_notebook_set_show_tabs().
	ShowTabs() bool
	// TabDetachable returns whether the tab contents can be detached from
	// @notebook.
	TabDetachable(child Widget) bool
	// TabHborder returns the horizontal width of a tab border.
	TabHborder() uint16
	// TabLabel returns the tab label widget for the page @child. nil is
	// returned if @child is not in @notebook or if no tab label has
	// specifically been set for @child.
	TabLabel(child Widget) Widget
	// TabLabelText retrieves the text of the tab label for the page containing
	// @child.
	TabLabelText(child Widget) string
	// TabPos gets the edge at which the tabs for switching pages in the
	// notebook are drawn.
	TabPos() PositionType
	// TabReorderable gets whether the tab can be reordered via drag and drop or
	// not.
	TabReorderable(child Widget) bool
	// TabVborder returns the vertical width of a tab border.
	TabVborder() uint16
	// InsertPage: insert a page into @notebook at the given position.
	InsertPage(child Widget, tabLabel Widget, position int) int
	// InsertPageMenu: insert a page into @notebook at the given position,
	// specifying the widget to use as the label in the popup menu.
	InsertPageMenu(child Widget, tabLabel Widget, menuLabel Widget, position int) int
	// NextPage switches to the next page. Nothing happens if the current page
	// is the last page.
	NextPage()
	// PageNum finds the index of the page which contains the given child
	// widget.
	PageNum(child Widget) int
	// PopupDisable disables the popup menu.
	PopupDisable()
	// PopupEnable enables the popup menu: if the user clicks with the right
	// mouse button on the tab labels, a menu with all the pages will be popped
	// up.
	PopupEnable()
	// PrependPage prepends a page to @notebook.
	PrependPage(child Widget, tabLabel Widget) int
	// PrependPageMenu prepends a page to @notebook, specifying the widget to
	// use as the label in the popup menu.
	PrependPageMenu(child Widget, tabLabel Widget, menuLabel Widget) int
	// PrevPage switches to the previous page. Nothing happens if the current
	// page is the first page.
	PrevPage()
	// RemovePage removes a page from the notebook given its index in the
	// notebook.
	RemovePage(pageNum int)
	// ReorderChild reorders the page containing @child, so that it appears in
	// position @position. If @position is greater than or equal to the number
	// of children in the list or negative, @child will be moved to the end of
	// the list.
	ReorderChild(child Widget, position int)
	// SetActionWidget sets @widget as one of the action widgets. Depending on
	// the pack type the widget will be placed before or after the tabs. You can
	// use a Box if you need to pack more than one widget on the same side.
	//
	// Note that action widgets are “internal” children of the notebook and thus
	// not included in the list returned from gtk_container_foreach().
	SetActionWidget(widget Widget, packType PackType)
	// SetCurrentPage switches to the page number @page_num.
	//
	// Note that due to historical reasons, GtkNotebook refuses to switch to a
	// page unless the child widget is visible. Therefore, it is recommended to
	// show child widgets before adding them to a notebook.
	SetCurrentPage(pageNum int)
	// SetGroupName sets a group name for @notebook.
	//
	// Notebooks with the same name will be able to exchange tabs via drag and
	// drop. A notebook with a nil group name will not be able to exchange tabs
	// with any other notebook.
	SetGroupName(groupName string)
	// SetMenuLabel changes the menu label for the page containing @child.
	SetMenuLabel(child Widget, menuLabel Widget)
	// SetMenuLabelText creates a new label and sets it as the menu label of
	// @child.
	SetMenuLabelText(child Widget, menuText string)
	// SetScrollable sets whether the tab label area will have arrows for
	// scrolling if there are too many tabs to fit in the area.
	SetScrollable(scrollable bool)
	// SetShowBorder sets whether a bevel will be drawn around the notebook
	// pages. This only has a visual effect when the tabs are not shown. See
	// gtk_notebook_set_show_tabs().
	SetShowBorder(showBorder bool)
	// SetShowTabs sets whether to show the tabs for the notebook or not.
	SetShowTabs(showTabs bool)
	// SetTabDetachable sets whether the tab can be detached from @notebook to
	// another notebook or widget.
	//
	// Note that 2 notebooks must share a common group identificator (see
	// gtk_notebook_set_group_name()) to allow automatic tabs interchange
	// between them.
	//
	// If you want a widget to interact with a notebook through DnD (i.e.:
	// accept dragged tabs from it) it must be set as a drop destination and
	// accept the target “GTK_NOTEBOOK_TAB”. The notebook will fill the
	// selection with a GtkWidget** pointing to the child widget that
	// corresponds to the dropped tab.
	//
	// Note that you should use gtk_notebook_detach_tab() instead of
	// gtk_container_remove() if you want to remove the tab from the source
	// notebook as part of accepting a drop. Otherwise, the source notebook will
	// think that the dragged tab was removed from underneath the ongoing drag
	// operation, and will initiate a drag cancel animation.
	//
	//     static void
	//     on_drag_data_received (GtkWidget        *widget,
	//                            GdkDragContext   *context,
	//                            gint              x,
	//                            gint              y,
	//                            GtkSelectionData *data,
	//                            guint             info,
	//                            guint             time,
	//                            gpointer          user_data)
	//     {
	//       GtkWidget *notebook;
	//       GtkWidget **child;
	//
	//       notebook = gtk_drag_get_source_widget (context);
	//       child = (void*) gtk_selection_data_get_data (data);
	//
	//       // process_widget (*child);
	//
	//       gtk_notebook_detach_tab (GTK_NOTEBOOK (notebook), *child);
	//     }
	//
	// If you want a notebook to accept drags from other widgets, you will have
	// to set your own DnD code to do it.
	SetTabDetachable(child Widget, detachable bool)
	// SetTabLabel changes the tab label for @child. If nil is specified for
	// @tab_label, then the page will have the label “page N”.
	SetTabLabel(child Widget, tabLabel Widget)
	// SetTabLabelText creates a new label and sets it as the tab label for the
	// page containing @child.
	SetTabLabelText(child Widget, tabText string)
	// SetTabPos sets the edge at which the tabs for switching pages in the
	// notebook are drawn.
	SetTabPos(pos PositionType)
	// SetTabReorderable sets whether the notebook tab can be reordered via drag
	// and drop or not.
	SetTabReorderable(child Widget, reorderable bool)
}

// notebook implements the Notebook class.
type notebook struct {
	Container
	Buildable
}

var _ Notebook = (*notebook)(nil)

// WrapNotebook wraps a GObject to the right type. It is
// primarily used internally.
func WrapNotebook(obj *externglib.Object) Notebook {
	return notebook{
		Container: WrapContainer(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalNotebook(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNotebook(obj), nil
}

// NewNotebook creates a new Notebook widget with no pages.
func NewNotebook() Notebook {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_notebook_new()

	var _notebook Notebook // out

	_notebook = WrapNotebook(externglib.Take(unsafe.Pointer(_cret)))

	return _notebook
}

// AppendPage appends a page to @notebook.
func (n notebook) AppendPage(child Widget, tabLabel Widget) int {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.GtkWidget   // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))

	_cret = C.gtk_notebook_append_page(_arg0, _arg1, _arg2)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// AppendPageMenu appends a page to @notebook, specifying the widget to use as
// the label in the popup menu.
func (n notebook) AppendPageMenu(child Widget, tabLabel Widget, menuLabel Widget) int {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.GtkWidget   // out
	var _arg3 *C.GtkWidget   // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))
	_arg3 = (*C.GtkWidget)(unsafe.Pointer(menuLabel.Native()))

	_cret = C.gtk_notebook_append_page_menu(_arg0, _arg1, _arg2, _arg3)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// DetachTab removes the child from the notebook.
//
// This function is very similar to gtk_container_remove(), but additionally
// informs the notebook that the removal is happening as part of a tab DND
// operation, which should not be cancelled.
func (n notebook) DetachTab(child Widget) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_notebook_detach_tab(_arg0, _arg1)
}

// ActionWidget gets one of the action widgets. See
// gtk_notebook_set_action_widget().
func (n notebook) ActionWidget(packType PackType) Widget {
	var _arg0 *C.GtkNotebook // out
	var _arg1 C.GtkPackType  // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (C.GtkPackType)(packType)

	_cret = C.gtk_notebook_get_action_widget(_arg0, _arg1)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// CurrentPage returns the page number of the current page.
func (n notebook) CurrentPage() int {
	var _arg0 *C.GtkNotebook // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	_cret = C.gtk_notebook_get_current_page(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// GroupName gets the current group name for @notebook.
func (n notebook) GroupName() string {
	var _arg0 *C.GtkNotebook // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	_cret = C.gtk_notebook_get_group_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// MenuLabel retrieves the menu label widget of the page containing @child.
func (n notebook) MenuLabel(child Widget) Widget {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	_cret = C.gtk_notebook_get_menu_label(_arg0, _arg1)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// MenuLabelText retrieves the text of the menu label for the page containing
// @child.
func (n notebook) MenuLabelText(child Widget) string {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	_cret = C.gtk_notebook_get_menu_label_text(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// NPages gets the number of pages in a notebook.
func (n notebook) NPages() int {
	var _arg0 *C.GtkNotebook // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	_cret = C.gtk_notebook_get_n_pages(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// NthPage returns the child widget contained in page number @page_num.
func (n notebook) NthPage(pageNum int) Widget {
	var _arg0 *C.GtkNotebook // out
	var _arg1 C.gint         // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (C.gint)(pageNum)

	_cret = C.gtk_notebook_get_nth_page(_arg0, _arg1)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// Scrollable returns whether the tab label area has arrows for scrolling. See
// gtk_notebook_set_scrollable().
func (n notebook) Scrollable() bool {
	var _arg0 *C.GtkNotebook // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	_cret = C.gtk_notebook_get_scrollable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowBorder returns whether a bevel will be drawn around the notebook pages.
// See gtk_notebook_set_show_border().
func (n notebook) ShowBorder() bool {
	var _arg0 *C.GtkNotebook // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	_cret = C.gtk_notebook_get_show_border(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowTabs returns whether the tabs of the notebook are shown. See
// gtk_notebook_set_show_tabs().
func (n notebook) ShowTabs() bool {
	var _arg0 *C.GtkNotebook // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	_cret = C.gtk_notebook_get_show_tabs(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TabDetachable returns whether the tab contents can be detached from
// @notebook.
func (n notebook) TabDetachable(child Widget) bool {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	_cret = C.gtk_notebook_get_tab_detachable(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TabHborder returns the horizontal width of a tab border.
func (n notebook) TabHborder() uint16 {
	var _arg0 *C.GtkNotebook // out
	var _cret C.guint16      // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	_cret = C.gtk_notebook_get_tab_hborder(_arg0)

	var _guint16 uint16 // out

	_guint16 = (uint16)(_cret)

	return _guint16
}

// TabLabel returns the tab label widget for the page @child. nil is returned if
// @child is not in @notebook or if no tab label has specifically been set for
// @child.
func (n notebook) TabLabel(child Widget) Widget {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	_cret = C.gtk_notebook_get_tab_label(_arg0, _arg1)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// TabLabelText retrieves the text of the tab label for the page containing
// @child.
func (n notebook) TabLabelText(child Widget) string {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	_cret = C.gtk_notebook_get_tab_label_text(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// TabPos gets the edge at which the tabs for switching pages in the notebook
// are drawn.
func (n notebook) TabPos() PositionType {
	var _arg0 *C.GtkNotebook    // out
	var _cret C.GtkPositionType // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	_cret = C.gtk_notebook_get_tab_pos(_arg0)

	var _positionType PositionType // out

	_positionType = PositionType(_cret)

	return _positionType
}

// TabReorderable gets whether the tab can be reordered via drag and drop or
// not.
func (n notebook) TabReorderable(child Widget) bool {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	_cret = C.gtk_notebook_get_tab_reorderable(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TabVborder returns the vertical width of a tab border.
func (n notebook) TabVborder() uint16 {
	var _arg0 *C.GtkNotebook // out
	var _cret C.guint16      // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	_cret = C.gtk_notebook_get_tab_vborder(_arg0)

	var _guint16 uint16 // out

	_guint16 = (uint16)(_cret)

	return _guint16
}

// InsertPage: insert a page into @notebook at the given position.
func (n notebook) InsertPage(child Widget, tabLabel Widget, position int) int {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.GtkWidget   // out
	var _arg3 C.gint         // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))
	_arg3 = (C.gint)(position)

	_cret = C.gtk_notebook_insert_page(_arg0, _arg1, _arg2, _arg3)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// InsertPageMenu: insert a page into @notebook at the given position,
// specifying the widget to use as the label in the popup menu.
func (n notebook) InsertPageMenu(child Widget, tabLabel Widget, menuLabel Widget, position int) int {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.GtkWidget   // out
	var _arg3 *C.GtkWidget   // out
	var _arg4 C.gint         // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))
	_arg3 = (*C.GtkWidget)(unsafe.Pointer(menuLabel.Native()))
	_arg4 = (C.gint)(position)

	_cret = C.gtk_notebook_insert_page_menu(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// NextPage switches to the next page. Nothing happens if the current page is
// the last page.
func (n notebook) NextPage() {
	var _arg0 *C.GtkNotebook // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	C.gtk_notebook_next_page(_arg0)
}

// PageNum finds the index of the page which contains the given child widget.
func (n notebook) PageNum(child Widget) int {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	_cret = C.gtk_notebook_page_num(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// PopupDisable disables the popup menu.
func (n notebook) PopupDisable() {
	var _arg0 *C.GtkNotebook // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	C.gtk_notebook_popup_disable(_arg0)
}

// PopupEnable enables the popup menu: if the user clicks with the right mouse
// button on the tab labels, a menu with all the pages will be popped up.
func (n notebook) PopupEnable() {
	var _arg0 *C.GtkNotebook // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	C.gtk_notebook_popup_enable(_arg0)
}

// PrependPage prepends a page to @notebook.
func (n notebook) PrependPage(child Widget, tabLabel Widget) int {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.GtkWidget   // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))

	_cret = C.gtk_notebook_prepend_page(_arg0, _arg1, _arg2)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// PrependPageMenu prepends a page to @notebook, specifying the widget to use as
// the label in the popup menu.
func (n notebook) PrependPageMenu(child Widget, tabLabel Widget, menuLabel Widget) int {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.GtkWidget   // out
	var _arg3 *C.GtkWidget   // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))
	_arg3 = (*C.GtkWidget)(unsafe.Pointer(menuLabel.Native()))

	_cret = C.gtk_notebook_prepend_page_menu(_arg0, _arg1, _arg2, _arg3)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// PrevPage switches to the previous page. Nothing happens if the current page
// is the first page.
func (n notebook) PrevPage() {
	var _arg0 *C.GtkNotebook // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	C.gtk_notebook_prev_page(_arg0)
}

// RemovePage removes a page from the notebook given its index in the notebook.
func (n notebook) RemovePage(pageNum int) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (C.gint)(pageNum)

	C.gtk_notebook_remove_page(_arg0, _arg1)
}

// ReorderChild reorders the page containing @child, so that it appears in
// position @position. If @position is greater than or equal to the number of
// children in the list or negative, @child will be moved to the end of the
// list.
func (n notebook) ReorderChild(child Widget, position int) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 C.gint         // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (C.gint)(position)

	C.gtk_notebook_reorder_child(_arg0, _arg1, _arg2)
}

// SetActionWidget sets @widget as one of the action widgets. Depending on the
// pack type the widget will be placed before or after the tabs. You can use a
// Box if you need to pack more than one widget on the same side.
//
// Note that action widgets are “internal” children of the notebook and thus not
// included in the list returned from gtk_container_foreach().
func (n notebook) SetActionWidget(widget Widget, packType PackType) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 C.GtkPackType  // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (C.GtkPackType)(packType)

	C.gtk_notebook_set_action_widget(_arg0, _arg1, _arg2)
}

// SetCurrentPage switches to the page number @page_num.
//
// Note that due to historical reasons, GtkNotebook refuses to switch to a page
// unless the child widget is visible. Therefore, it is recommended to show
// child widgets before adding them to a notebook.
func (n notebook) SetCurrentPage(pageNum int) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (C.gint)(pageNum)

	C.gtk_notebook_set_current_page(_arg0, _arg1)
}

// SetGroupName sets a group name for @notebook.
//
// Notebooks with the same name will be able to exchange tabs via drag and drop.
// A notebook with a nil group name will not be able to exchange tabs with any
// other notebook.
func (n notebook) SetGroupName(groupName string) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.gchar       // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_notebook_set_group_name(_arg0, _arg1)
}

// SetMenuLabel changes the menu label for the page containing @child.
func (n notebook) SetMenuLabel(child Widget, menuLabel Widget) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.GtkWidget   // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(menuLabel.Native()))

	C.gtk_notebook_set_menu_label(_arg0, _arg1, _arg2)
}

// SetMenuLabelText creates a new label and sets it as the menu label of @child.
func (n notebook) SetMenuLabelText(child Widget, menuText string) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.gchar       // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.gchar)(C.CString(menuText))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_notebook_set_menu_label_text(_arg0, _arg1, _arg2)
}

// SetScrollable sets whether the tab label area will have arrows for scrolling
// if there are too many tabs to fit in the area.
func (n notebook) SetScrollable(scrollable bool) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	if scrollable {
		_arg1 = C.TRUE
	}

	C.gtk_notebook_set_scrollable(_arg0, _arg1)
}

// SetShowBorder sets whether a bevel will be drawn around the notebook pages.
// This only has a visual effect when the tabs are not shown. See
// gtk_notebook_set_show_tabs().
func (n notebook) SetShowBorder(showBorder bool) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	if showBorder {
		_arg1 = C.TRUE
	}

	C.gtk_notebook_set_show_border(_arg0, _arg1)
}

// SetShowTabs sets whether to show the tabs for the notebook or not.
func (n notebook) SetShowTabs(showTabs bool) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	if showTabs {
		_arg1 = C.TRUE
	}

	C.gtk_notebook_set_show_tabs(_arg0, _arg1)
}

// SetTabDetachable sets whether the tab can be detached from @notebook to
// another notebook or widget.
//
// Note that 2 notebooks must share a common group identificator (see
// gtk_notebook_set_group_name()) to allow automatic tabs interchange between
// them.
//
// If you want a widget to interact with a notebook through DnD (i.e.: accept
// dragged tabs from it) it must be set as a drop destination and accept the
// target “GTK_NOTEBOOK_TAB”. The notebook will fill the selection with a
// GtkWidget** pointing to the child widget that corresponds to the dropped tab.
//
// Note that you should use gtk_notebook_detach_tab() instead of
// gtk_container_remove() if you want to remove the tab from the source notebook
// as part of accepting a drop. Otherwise, the source notebook will think that
// the dragged tab was removed from underneath the ongoing drag operation, and
// will initiate a drag cancel animation.
//
//     static void
//     on_drag_data_received (GtkWidget        *widget,
//                            GdkDragContext   *context,
//                            gint              x,
//                            gint              y,
//                            GtkSelectionData *data,
//                            guint             info,
//                            guint             time,
//                            gpointer          user_data)
//     {
//       GtkWidget *notebook;
//       GtkWidget **child;
//
//       notebook = gtk_drag_get_source_widget (context);
//       child = (void*) gtk_selection_data_get_data (data);
//
//       // process_widget (*child);
//
//       gtk_notebook_detach_tab (GTK_NOTEBOOK (notebook), *child);
//     }
//
// If you want a notebook to accept drags from other widgets, you will have to
// set your own DnD code to do it.
func (n notebook) SetTabDetachable(child Widget, detachable bool) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 C.gboolean     // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	if detachable {
		_arg2 = C.TRUE
	}

	C.gtk_notebook_set_tab_detachable(_arg0, _arg1, _arg2)
}

// SetTabLabel changes the tab label for @child. If nil is specified for
// @tab_label, then the page will have the label “page N”.
func (n notebook) SetTabLabel(child Widget, tabLabel Widget) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.GtkWidget   // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))

	C.gtk_notebook_set_tab_label(_arg0, _arg1, _arg2)
}

// SetTabLabelText creates a new label and sets it as the tab label for the page
// containing @child.
func (n notebook) SetTabLabelText(child Widget, tabText string) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.gchar       // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.gchar)(C.CString(tabText))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_notebook_set_tab_label_text(_arg0, _arg1, _arg2)
}

// SetTabPos sets the edge at which the tabs for switching pages in the notebook
// are drawn.
func (n notebook) SetTabPos(pos PositionType) {
	var _arg0 *C.GtkNotebook    // out
	var _arg1 C.GtkPositionType // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (C.GtkPositionType)(pos)

	C.gtk_notebook_set_tab_pos(_arg0, _arg1)
}

// SetTabReorderable sets whether the notebook tab can be reordered via drag and
// drop or not.
func (n notebook) SetTabReorderable(child Widget, reorderable bool) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 C.gboolean     // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	if reorderable {
		_arg2 = C.TRUE
	}

	C.gtk_notebook_set_tab_reorderable(_arg0, _arg1, _arg2)
}

type NotebookAccessible interface {
	ContainerAccessible
}

// notebookAccessible implements the NotebookAccessible class.
type notebookAccessible struct {
	ContainerAccessible
}

var _ NotebookAccessible = (*notebookAccessible)(nil)

// WrapNotebookAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapNotebookAccessible(obj *externglib.Object) NotebookAccessible {
	return notebookAccessible{
		ContainerAccessible: WrapContainerAccessible(obj),
	}
}

func marshalNotebookAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNotebookAccessible(obj), nil
}

// NumerableIcon: gtkNumerableIcon is a subclass of Icon that can show a number
// or short string as an emblem. The number can be overlayed on top of another
// emblem, if desired.
//
// It supports theming by taking font and color information from a provided
// StyleContext; see gtk_numerable_icon_set_style_context().
//
// Typical numerable icons: ! (numerableicon.png) ! (numerableicon2.png)
type NumerableIcon interface {
	gio.EmblemedIcon
	gio.Icon

	// BackgroundGIcon returns the #GIcon that was set as the base background
	// image, or nil if there’s none. The caller of this function does not own a
	// reference to the returned #GIcon.
	BackgroundGIcon() gio.Icon
	// BackgroundIconName returns the icon name used as the base background
	// image, or nil if there’s none.
	BackgroundIconName() string
	// Count returns the value currently displayed by @self.
	Count() int
	// Label returns the currently displayed label of the icon, or nil.
	Label() string
	// StyleContext returns the StyleContext used by the icon for theming, or
	// nil if there’s none.
	StyleContext() StyleContext
	// SetBackgroundGIcon updates the icon to use @icon as the base background
	// image. If @icon is nil, @self will go back using style information or
	// default theming for its background image.
	//
	// If this method is called and an icon name was already set as background
	// for the icon, @icon will be used, i.e. the last method called between
	// gtk_numerable_icon_set_background_gicon() and
	// gtk_numerable_icon_set_background_icon_name() has always priority.
	SetBackgroundGIcon(icon gio.Icon)
	// SetBackgroundIconName updates the icon to use the icon named @icon_name
	// from the current icon theme as the base background image. If @icon_name
	// is nil, @self will go back using style information or default theming for
	// its background image.
	//
	// If this method is called and a #GIcon was already set as background for
	// the icon, @icon_name will be used, i.e. the last method called between
	// gtk_numerable_icon_set_background_icon_name() and
	// gtk_numerable_icon_set_background_gicon() has always priority.
	SetBackgroundIconName(iconName string)
	// SetCount sets the currently displayed value of @self to @count.
	//
	// The numeric value is always clamped to make it two digits, i.e. between
	// -99 and 99. Setting a count of zero removes the emblem. If this method is
	// called, and a label was already set on the icon, it will automatically be
	// reset to nil before rendering the number, i.e. the last method called
	// between gtk_numerable_icon_set_count() and gtk_numerable_icon_set_label()
	// has always priority.
	SetCount(count int)
	// SetLabel sets the currently displayed value of @self to the string in
	// @label. Setting an empty label removes the emblem.
	//
	// Note that this is meant for displaying short labels, such as roman
	// numbers, or single letters. For roman numbers, consider using the Unicode
	// characters U+2160 - U+217F. Strings longer than two characters will
	// likely not be rendered very well.
	//
	// If this method is called, and a number was already set on the icon, it
	// will automatically be reset to zero before rendering the label, i.e. the
	// last method called between gtk_numerable_icon_set_label() and
	// gtk_numerable_icon_set_count() has always priority.
	SetLabel(label string)
	// SetStyleContext updates the icon to fetch theme information from the
	// given StyleContext.
	SetStyleContext(style StyleContext)
}

// numerableIcon implements the NumerableIcon class.
type numerableIcon struct {
	gio.EmblemedIcon
	gio.Icon
}

var _ NumerableIcon = (*numerableIcon)(nil)

// WrapNumerableIcon wraps a GObject to the right type. It is
// primarily used internally.
func WrapNumerableIcon(obj *externglib.Object) NumerableIcon {
	return numerableIcon{
		EmblemedIcon: gio.WrapEmblemedIcon(obj),
		Icon:         gio.WrapIcon(obj),
	}
}

func marshalNumerableIcon(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNumerableIcon(obj), nil
}

// BackgroundGIcon returns the #GIcon that was set as the base background image,
// or nil if there’s none. The caller of this function does not own a reference
// to the returned #GIcon.
func (s numerableIcon) BackgroundGIcon() gio.Icon {
	var _arg0 *C.GtkNumerableIcon // out
	var _cret *C.GIcon            // in

	_arg0 = (*C.GtkNumerableIcon)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_numerable_icon_get_background_gicon(_arg0)

	var _icon gio.Icon // out

	_icon = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.Icon)

	return _icon
}

// BackgroundIconName returns the icon name used as the base background image,
// or nil if there’s none.
func (s numerableIcon) BackgroundIconName() string {
	var _arg0 *C.GtkNumerableIcon // out
	var _cret *C.gchar            // in

	_arg0 = (*C.GtkNumerableIcon)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_numerable_icon_get_background_icon_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Count returns the value currently displayed by @self.
func (s numerableIcon) Count() int {
	var _arg0 *C.GtkNumerableIcon // out
	var _cret C.gint              // in

	_arg0 = (*C.GtkNumerableIcon)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_numerable_icon_get_count(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Label returns the currently displayed label of the icon, or nil.
func (s numerableIcon) Label() string {
	var _arg0 *C.GtkNumerableIcon // out
	var _cret *C.gchar            // in

	_arg0 = (*C.GtkNumerableIcon)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_numerable_icon_get_label(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// StyleContext returns the StyleContext used by the icon for theming, or nil if
// there’s none.
func (s numerableIcon) StyleContext() StyleContext {
	var _arg0 *C.GtkNumerableIcon // out
	var _cret *C.GtkStyleContext  // in

	_arg0 = (*C.GtkNumerableIcon)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_numerable_icon_get_style_context(_arg0)

	var _styleContext StyleContext // out

	_styleContext = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(StyleContext)

	return _styleContext
}

// SetBackgroundGIcon updates the icon to use @icon as the base background
// image. If @icon is nil, @self will go back using style information or default
// theming for its background image.
//
// If this method is called and an icon name was already set as background for
// the icon, @icon will be used, i.e. the last method called between
// gtk_numerable_icon_set_background_gicon() and
// gtk_numerable_icon_set_background_icon_name() has always priority.
func (s numerableIcon) SetBackgroundGIcon(icon gio.Icon) {
	var _arg0 *C.GtkNumerableIcon // out
	var _arg1 *C.GIcon            // out

	_arg0 = (*C.GtkNumerableIcon)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

	C.gtk_numerable_icon_set_background_gicon(_arg0, _arg1)
}

// SetBackgroundIconName updates the icon to use the icon named @icon_name from
// the current icon theme as the base background image. If @icon_name is nil,
// @self will go back using style information or default theming for its
// background image.
//
// If this method is called and a #GIcon was already set as background for the
// icon, @icon_name will be used, i.e. the last method called between
// gtk_numerable_icon_set_background_icon_name() and
// gtk_numerable_icon_set_background_gicon() has always priority.
func (s numerableIcon) SetBackgroundIconName(iconName string) {
	var _arg0 *C.GtkNumerableIcon // out
	var _arg1 *C.gchar            // out

	_arg0 = (*C.GtkNumerableIcon)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_numerable_icon_set_background_icon_name(_arg0, _arg1)
}

// SetCount sets the currently displayed value of @self to @count.
//
// The numeric value is always clamped to make it two digits, i.e. between -99
// and 99. Setting a count of zero removes the emblem. If this method is called,
// and a label was already set on the icon, it will automatically be reset to
// nil before rendering the number, i.e. the last method called between
// gtk_numerable_icon_set_count() and gtk_numerable_icon_set_label() has always
// priority.
func (s numerableIcon) SetCount(count int) {
	var _arg0 *C.GtkNumerableIcon // out
	var _arg1 C.gint              // out

	_arg0 = (*C.GtkNumerableIcon)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gint)(count)

	C.gtk_numerable_icon_set_count(_arg0, _arg1)
}

// SetLabel sets the currently displayed value of @self to the string in @label.
// Setting an empty label removes the emblem.
//
// Note that this is meant for displaying short labels, such as roman numbers,
// or single letters. For roman numbers, consider using the Unicode characters
// U+2160 - U+217F. Strings longer than two characters will likely not be
// rendered very well.
//
// If this method is called, and a number was already set on the icon, it will
// automatically be reset to zero before rendering the label, i.e. the last
// method called between gtk_numerable_icon_set_label() and
// gtk_numerable_icon_set_count() has always priority.
func (s numerableIcon) SetLabel(label string) {
	var _arg0 *C.GtkNumerableIcon // out
	var _arg1 *C.gchar            // out

	_arg0 = (*C.GtkNumerableIcon)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_numerable_icon_set_label(_arg0, _arg1)
}

// SetStyleContext updates the icon to fetch theme information from the given
// StyleContext.
func (s numerableIcon) SetStyleContext(style StyleContext) {
	var _arg0 *C.GtkNumerableIcon // out
	var _arg1 *C.GtkStyleContext  // out

	_arg0 = (*C.GtkNumerableIcon)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(style.Native()))

	C.gtk_numerable_icon_set_style_context(_arg0, _arg1)
}

// OffscreenWindow: gtkOffscreenWindow is strictly intended to be used for
// obtaining snapshots of widgets that are not part of a normal widget
// hierarchy. Since OffscreenWindow is a toplevel widget you cannot obtain
// snapshots of a full window with it since you cannot pack a toplevel widget in
// another toplevel.
//
// The idea is to take a widget and manually set the state of it, add it to a
// GtkOffscreenWindow and then retrieve the snapshot as a #cairo_surface_t or
// Pixbuf.
//
// GtkOffscreenWindow derives from Window only as an implementation detail.
// Applications should not use any API specific to Window to operate on this
// object. It should be treated as a Bin that has no parent widget.
//
// When contained offscreen widgets are redrawn, GtkOffscreenWindow will emit a
// Widget::damage-event signal.
type OffscreenWindow interface {
	Window
	Buildable

	// Pixbuf retrieves a snapshot of the contained widget in the form of a
	// Pixbuf. This is a new pixbuf with a reference count of 1, and the
	// application should unreference it once it is no longer needed.
	Pixbuf() gdkpixbuf.Pixbuf
	// Surface retrieves a snapshot of the contained widget in the form of a
	// #cairo_surface_t. If you need to keep this around over window resizes
	// then you should add a reference to it.
	Surface() *cairo.Surface
}

// offscreenWindow implements the OffscreenWindow class.
type offscreenWindow struct {
	Window
	Buildable
}

var _ OffscreenWindow = (*offscreenWindow)(nil)

// WrapOffscreenWindow wraps a GObject to the right type. It is
// primarily used internally.
func WrapOffscreenWindow(obj *externglib.Object) OffscreenWindow {
	return offscreenWindow{
		Window:    WrapWindow(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalOffscreenWindow(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapOffscreenWindow(obj), nil
}

// NewOffscreenWindow creates a toplevel container widget that is used to
// retrieve snapshots of widgets without showing them on the screen.
func NewOffscreenWindow() OffscreenWindow {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_offscreen_window_new()

	var _offscreenWindow OffscreenWindow // out

	_offscreenWindow = WrapOffscreenWindow(externglib.Take(unsafe.Pointer(_cret)))

	return _offscreenWindow
}

// Pixbuf retrieves a snapshot of the contained widget in the form of a Pixbuf.
// This is a new pixbuf with a reference count of 1, and the application should
// unreference it once it is no longer needed.
func (o offscreenWindow) Pixbuf() gdkpixbuf.Pixbuf {
	var _arg0 *C.GtkOffscreenWindow // out
	var _cret *C.GdkPixbuf          // in

	_arg0 = (*C.GtkOffscreenWindow)(unsafe.Pointer(o.Native()))

	_cret = C.gtk_offscreen_window_get_pixbuf(_arg0)

	var _pixbuf gdkpixbuf.Pixbuf // out

	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

	return _pixbuf
}

// Surface retrieves a snapshot of the contained widget in the form of a
// #cairo_surface_t. If you need to keep this around over window resizes then
// you should add a reference to it.
func (o offscreenWindow) Surface() *cairo.Surface {
	var _arg0 *C.GtkOffscreenWindow // out
	var _cret *C.cairo_surface_t    // in

	_arg0 = (*C.GtkOffscreenWindow)(unsafe.Pointer(o.Native()))

	_cret = C.gtk_offscreen_window_get_surface(_arg0)

	var _surface *cairo.Surface // out

	_surface = cairo.WrapSurface(unsafe.Pointer(_cret))

	return _surface
}

// Overlay: gtkOverlay is a container which contains a single main child, on top
// of which it can place “overlay” widgets. The position of each overlay widget
// is determined by its Widget:halign and Widget:valign properties. E.g. a
// widget with both alignments set to GTK_ALIGN_START will be placed at the top
// left corner of the GtkOverlay container, whereas an overlay with halign set
// to GTK_ALIGN_CENTER and valign set to GTK_ALIGN_END will be placed a the
// bottom edge of the GtkOverlay, horizontally centered. The position can be
// adjusted by setting the margin properties of the child to non-zero values.
//
// More complicated placement of overlays is possible by connecting to the
// Overlay::get-child-position signal.
//
// An overlay’s minimum and natural sizes are those of its main child. The sizes
// of overlay children are not considered when measuring these preferred sizes.
//
//
// GtkOverlay as GtkBuildable
//
// The GtkOverlay implementation of the GtkBuildable interface supports placing
// a child as an overlay by specifying “overlay” as the “type” attribute of a
// `<child>` element.
//
//
// CSS nodes
//
// GtkOverlay has a single CSS node with the name “overlay”. Overlay children
// whose alignments cause them to be positioned at an edge get the style classes
// “.left”, “.right”, “.top”, and/or “.bottom” according to their position.
type Overlay interface {
	Bin
	Buildable

	// AddOverlay adds @widget to @overlay.
	//
	// The widget will be stacked on top of the main widget added with
	// gtk_container_add().
	//
	// The position at which @widget is placed is determined from its
	// Widget:halign and Widget:valign properties.
	AddOverlay(widget Widget)
	// OverlayPassThrough: convenience function to get the value of the
	// Overlay:pass-through child property for @widget.
	OverlayPassThrough(widget Widget) bool
	// ReorderOverlay moves @child to a new @index in the list of @overlay
	// children. The list contains overlays in the order that these were added
	// to @overlay by default. See also Overlay:index.
	//
	// A widget’s index in the @overlay children list determines which order the
	// children are drawn if they overlap. The first child is drawn at the
	// bottom. It also affects the default focus chain order.
	ReorderOverlay(child Widget, index_ int)
	// SetOverlayPassThrough: convenience function to set the value of the
	// Overlay:pass-through child property for @widget.
	SetOverlayPassThrough(widget Widget, passThrough bool)
}

// overlay implements the Overlay class.
type overlay struct {
	Bin
	Buildable
}

var _ Overlay = (*overlay)(nil)

// WrapOverlay wraps a GObject to the right type. It is
// primarily used internally.
func WrapOverlay(obj *externglib.Object) Overlay {
	return overlay{
		Bin:       WrapBin(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalOverlay(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapOverlay(obj), nil
}

// NewOverlay creates a new Overlay.
func NewOverlay() Overlay {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_overlay_new()

	var _overlay Overlay // out

	_overlay = WrapOverlay(externglib.Take(unsafe.Pointer(_cret)))

	return _overlay
}

// AddOverlay adds @widget to @overlay.
//
// The widget will be stacked on top of the main widget added with
// gtk_container_add().
//
// The position at which @widget is placed is determined from its Widget:halign
// and Widget:valign properties.
func (o overlay) AddOverlay(widget Widget) {
	var _arg0 *C.GtkOverlay // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_overlay_add_overlay(_arg0, _arg1)
}

// OverlayPassThrough: convenience function to get the value of the
// Overlay:pass-through child property for @widget.
func (o overlay) OverlayPassThrough(widget Widget) bool {
	var _arg0 *C.GtkOverlay // out
	var _arg1 *C.GtkWidget  // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	_cret = C.gtk_overlay_get_overlay_pass_through(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ReorderOverlay moves @child to a new @index in the list of @overlay children.
// The list contains overlays in the order that these were added to @overlay by
// default. See also Overlay:index.
//
// A widget’s index in the @overlay children list determines which order the
// children are drawn if they overlap. The first child is drawn at the bottom.
// It also affects the default focus chain order.
func (o overlay) ReorderOverlay(child Widget, index_ int) {
	var _arg0 *C.GtkOverlay // out
	var _arg1 *C.GtkWidget  // out
	var _arg2 C.int         // out

	_arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (C.int)(index_)

	C.gtk_overlay_reorder_overlay(_arg0, _arg1, _arg2)
}

// SetOverlayPassThrough: convenience function to set the value of the
// Overlay:pass-through child property for @widget.
func (o overlay) SetOverlayPassThrough(widget Widget, passThrough bool) {
	var _arg0 *C.GtkOverlay // out
	var _arg1 *C.GtkWidget  // out
	var _arg2 C.gboolean    // out

	_arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	if passThrough {
		_arg2 = C.TRUE
	}

	C.gtk_overlay_set_overlay_pass_through(_arg0, _arg1, _arg2)
}

// PadController is an event controller for the pads found in drawing tablets
// (The collection of buttons and tactile sensors often found around the
// stylus-sensitive area).
//
// These buttons and sensors have no implicit meaning, and by default they
// perform no action, this event controller is provided to map those to #GAction
// objects, thus letting the application give those a more semantic meaning.
//
// Buttons and sensors are not constrained to triggering a single action, some
// GDK_SOURCE_TABLET_PAD devices feature multiple "modes", all these input
// elements have one current mode, which may determine the final action being
// triggered. Pad devices often divide buttons and sensors into groups, all
// elements in a group share the same current mode, but different groups may
// have different modes. See gdk_device_pad_get_n_groups() and
// gdk_device_pad_get_group_n_modes().
//
// Each of the actions that a given button/strip/ring performs for a given mode
// is defined by PadActionEntry, it contains an action name that will be looked
// up in the given Group and activated whenever the specified input element and
// mode are triggered.
//
// A simple example of PadController usage, assigning button 1 in all modes and
// pad devices to an "invert-selection" action:
//
//      GtkPadActionEntry *pad_actions[] = {
//        { GTK_PAD_ACTION_BUTTON, 1, -1, "Invert selection", "pad-actions.invert-selection" },
//        …
//      };
//
//      …
//      action_group = g_simple_action_group_new ();
//      action = g_simple_action_new ("pad-actions.invert-selection", NULL);
//      g_signal_connect (action, "activate", on_invert_selection_activated, NULL);
//      g_action_map_add_action (G_ACTION_MAP (action_group), action);
//      …
//      pad_controller = gtk_pad_controller_new (window, action_group, NULL);
//
// The actions belonging to rings/strips will be activated with a parameter of
// type G_VARIANT_TYPE_DOUBLE bearing the value of the given axis, it is
// required that those are made stateful and accepting this Type.
type PadController interface {
	EventController

	// SetAction adds an individual action to @controller. This action will only
	// be activated if the given button/ring/strip number in @index is
	// interacted while the current mode is @mode. -1 may be used for simple
	// cases, so the action is triggered on all modes.
	//
	// The given @label should be considered user-visible, so
	// internationalization rules apply. Some windowing systems may be able to
	// use those for user feedback.
	SetAction(typ PadActionType, index int, mode int, label string, actionName string)
	// SetActionEntries: this is a convenience function to add a group of action
	// entries on @controller. See PadActionEntry and
	// gtk_pad_controller_set_action().
	SetActionEntries(entries []PadActionEntry)
}

// padController implements the PadController class.
type padController struct {
	EventController
}

var _ PadController = (*padController)(nil)

// WrapPadController wraps a GObject to the right type. It is
// primarily used internally.
func WrapPadController(obj *externglib.Object) PadController {
	return padController{
		EventController: WrapEventController(obj),
	}
}

func marshalPadController(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPadController(obj), nil
}

// NewPadController creates a new PadController that will associate events from
// @pad to actions. A nil pad may be provided so the controller manages all pad
// devices generically, it is discouraged to mix PadController objects with nil
// and non-nil @pad argument on the same @window, as execution order is not
// guaranteed.
//
// The PadController is created with no mapped actions. In order to map pad
// events to actions, use gtk_pad_controller_set_action_entries() or
// gtk_pad_controller_set_action().
func NewPadController(window Window, group gio.ActionGroup, pad gdk.Device) PadController {
	var _arg1 *C.GtkWindow        // out
	var _arg2 *C.GActionGroup     // out
	var _arg3 *C.GdkDevice        // out
	var _cret *C.GtkPadController // in

	_arg1 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg2 = (*C.GActionGroup)(unsafe.Pointer(group.Native()))
	_arg3 = (*C.GdkDevice)(unsafe.Pointer(pad.Native()))

	_cret = C.gtk_pad_controller_new(_arg1, _arg2, _arg3)

	var _padController PadController // out

	_padController = WrapPadController(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _padController
}

// SetAction adds an individual action to @controller. This action will only be
// activated if the given button/ring/strip number in @index is interacted while
// the current mode is @mode. -1 may be used for simple cases, so the action is
// triggered on all modes.
//
// The given @label should be considered user-visible, so internationalization
// rules apply. Some windowing systems may be able to use those for user
// feedback.
func (c padController) SetAction(typ PadActionType, index int, mode int, label string, actionName string) {
	var _arg0 *C.GtkPadController // out
	var _arg1 C.GtkPadActionType  // out
	var _arg2 C.gint              // out
	var _arg3 C.gint              // out
	var _arg4 *C.gchar            // out
	var _arg5 *C.gchar            // out

	_arg0 = (*C.GtkPadController)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GtkPadActionType)(typ)
	_arg2 = (C.gint)(index)
	_arg3 = (C.gint)(mode)
	_arg4 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg5))

	C.gtk_pad_controller_set_action(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}

// SetActionEntries: this is a convenience function to add a group of action
// entries on @controller. See PadActionEntry and
// gtk_pad_controller_set_action().
func (c padController) SetActionEntries(entries []PadActionEntry) {
	var _arg0 *C.GtkPadController // out
	var _arg1 *C.GtkPadActionEntry
	var _arg2 C.gint

	_arg0 = (*C.GtkPadController)(unsafe.Pointer(c.Native()))
	_arg2 = C.gint(len(entries))
	_arg1 = (*C.GtkPadActionEntry)(unsafe.Pointer(&entries[0]))

	C.gtk_pad_controller_set_action_entries(_arg0, _arg1, _arg2)
}

// PageSetup: a GtkPageSetup object stores the page size, orientation and
// margins. The idea is that you can get one of these from the page setup dialog
// and then pass it to the PrintOperation when printing. The benefit of
// splitting this out of the PrintSettings is that these affect the actual
// layout of the page, and thus need to be set long before user prints.
//
//
// Margins
//
// The margins specified in this object are the “print margins”, i.e. the parts
// of the page that the printer cannot print on. These are different from the
// layout margins that a word processor uses; they are typically used to
// determine the minimal size for the layout margins.
//
// To obtain a PageSetup use gtk_page_setup_new() to get the defaults, or use
// gtk_print_run_page_setup_dialog() to show the page setup dialog and receive
// the resulting page setup.
//
// A page setup dialog
//
//    static GtkPrintSettings *settings = NULL;
//    static GtkPageSetup *page_setup = NULL;
//
//    static void
//    do_page_setup (void)
//    {
//      GtkPageSetup *new_page_setup;
//
//      if (settings == NULL)
//        settings = gtk_print_settings_new ();
//
//      new_page_setup = gtk_print_run_page_setup_dialog (GTK_WINDOW (main_window),
//                                                        page_setup, settings);
//
//      if (page_setup)
//        g_object_unref (page_setup);
//
//      page_setup = new_page_setup;
//    }
//
// Printing support was added in GTK+ 2.10.
type PageSetup interface {
	gextras.Objector

	// Copy copies a PageSetup.
	Copy() PageSetup
	// BottomMargin gets the bottom margin in units of @unit.
	BottomMargin(unit Unit) float64
	// LeftMargin gets the left margin in units of @unit.
	LeftMargin(unit Unit) float64
	// Orientation gets the page orientation of the PageSetup.
	Orientation() PageOrientation
	// PageHeight returns the page height in units of @unit.
	//
	// Note that this function takes orientation and margins into consideration.
	// See gtk_page_setup_get_paper_height().
	PageHeight(unit Unit) float64
	// PageWidth returns the page width in units of @unit.
	//
	// Note that this function takes orientation and margins into consideration.
	// See gtk_page_setup_get_paper_width().
	PageWidth(unit Unit) float64
	// PaperHeight returns the paper height in units of @unit.
	//
	// Note that this function takes orientation, but not margins into
	// consideration. See gtk_page_setup_get_page_height().
	PaperHeight(unit Unit) float64
	// PaperSize gets the paper size of the PageSetup.
	PaperSize() *PaperSize
	// PaperWidth returns the paper width in units of @unit.
	//
	// Note that this function takes orientation, but not margins into
	// consideration. See gtk_page_setup_get_page_width().
	PaperWidth(unit Unit) float64
	// RightMargin gets the right margin in units of @unit.
	RightMargin(unit Unit) float64
	// TopMargin gets the top margin in units of @unit.
	TopMargin(unit Unit) float64
	// LoadFile reads the page setup from the file @file_name. See
	// gtk_page_setup_to_file().
	LoadFile(fileName string) error
	// LoadKeyFile reads the page setup from the group @group_name in the key
	// file @key_file.
	LoadKeyFile(keyFile *glib.KeyFile, groupName string) error
	// SetBottomMargin sets the bottom margin of the PageSetup.
	SetBottomMargin(margin float64, unit Unit)
	// SetLeftMargin sets the left margin of the PageSetup.
	SetLeftMargin(margin float64, unit Unit)
	// SetOrientation sets the page orientation of the PageSetup.
	SetOrientation(orientation PageOrientation)
	// SetPaperSize sets the paper size of the PageSetup without changing the
	// margins. See gtk_page_setup_set_paper_size_and_default_margins().
	SetPaperSize(size *PaperSize)
	// SetPaperSizeAndDefaultMargins sets the paper size of the PageSetup and
	// modifies the margins according to the new paper size.
	SetPaperSizeAndDefaultMargins(size *PaperSize)
	// SetRightMargin sets the right margin of the PageSetup.
	SetRightMargin(margin float64, unit Unit)
	// SetTopMargin sets the top margin of the PageSetup.
	SetTopMargin(margin float64, unit Unit)
	// ToFile: this function saves the information from @setup to @file_name.
	ToFile(fileName string) error
	// ToGVariant: serialize page setup to an a{sv} variant.
	ToGVariant() *glib.Variant
	// ToKeyFile: this function adds the page setup from @setup to @key_file.
	ToKeyFile(keyFile *glib.KeyFile, groupName string)
}

// pageSetup implements the PageSetup class.
type pageSetup struct {
	gextras.Objector
}

var _ PageSetup = (*pageSetup)(nil)

// WrapPageSetup wraps a GObject to the right type. It is
// primarily used internally.
func WrapPageSetup(obj *externglib.Object) PageSetup {
	return pageSetup{
		Objector: obj,
	}
}

func marshalPageSetup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPageSetup(obj), nil
}

// NewPageSetup creates a new PageSetup.
func NewPageSetup() PageSetup {
	var _cret *C.GtkPageSetup // in

	_cret = C.gtk_page_setup_new()

	var _pageSetup PageSetup // out

	_pageSetup = WrapPageSetup(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _pageSetup
}

// NewPageSetupFromFile reads the page setup from the file @file_name. Returns a
// new PageSetup object with the restored page setup, or nil if an error
// occurred. See gtk_page_setup_to_file().
func NewPageSetupFromFile(fileName string) (PageSetup, error) {
	var _arg1 *C.gchar        // out
	var _cret *C.GtkPageSetup // in
	var _cerr *C.GError       // in

	_arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_page_setup_new_from_file(_arg1, &_cerr)

	var _pageSetup PageSetup // out
	var _goerr error         // out

	_pageSetup = WrapPageSetup(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _pageSetup, _goerr
}

// NewPageSetupFromGVariant: desrialize a page setup from an a{sv} variant in
// the format produced by gtk_page_setup_to_gvariant().
func NewPageSetupFromGVariant(variant *glib.Variant) PageSetup {
	var _arg1 *C.GVariant     // out
	var _cret *C.GtkPageSetup // in

	_arg1 = (*C.GVariant)(unsafe.Pointer(variant.Native()))

	_cret = C.gtk_page_setup_new_from_gvariant(_arg1)

	var _pageSetup PageSetup // out

	_pageSetup = WrapPageSetup(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _pageSetup
}

// NewPageSetupFromKeyFile reads the page setup from the group @group_name in
// the key file @key_file. Returns a new PageSetup object with the restored page
// setup, or nil if an error occurred.
func NewPageSetupFromKeyFile(keyFile *glib.KeyFile, groupName string) (PageSetup, error) {
	var _arg1 *C.GKeyFile     // out
	var _arg2 *C.gchar        // out
	var _cret *C.GtkPageSetup // in
	var _cerr *C.GError       // in

	_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
	_arg2 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_page_setup_new_from_key_file(_arg1, _arg2, &_cerr)

	var _pageSetup PageSetup // out
	var _goerr error         // out

	_pageSetup = WrapPageSetup(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _pageSetup, _goerr
}

// Copy copies a PageSetup.
func (o pageSetup) Copy() PageSetup {
	var _arg0 *C.GtkPageSetup // out
	var _cret *C.GtkPageSetup // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(o.Native()))

	_cret = C.gtk_page_setup_copy(_arg0)

	var _pageSetup PageSetup // out

	_pageSetup = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(PageSetup)

	return _pageSetup
}

// BottomMargin gets the bottom margin in units of @unit.
func (s pageSetup) BottomMargin(unit Unit) float64 {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 C.GtkUnit       // out
	var _cret C.gdouble       // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	_cret = C.gtk_page_setup_get_bottom_margin(_arg0, _arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// LeftMargin gets the left margin in units of @unit.
func (s pageSetup) LeftMargin(unit Unit) float64 {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 C.GtkUnit       // out
	var _cret C.gdouble       // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	_cret = C.gtk_page_setup_get_left_margin(_arg0, _arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// Orientation gets the page orientation of the PageSetup.
func (s pageSetup) Orientation() PageOrientation {
	var _arg0 *C.GtkPageSetup      // out
	var _cret C.GtkPageOrientation // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_page_setup_get_orientation(_arg0)

	var _pageOrientation PageOrientation // out

	_pageOrientation = PageOrientation(_cret)

	return _pageOrientation
}

// PageHeight returns the page height in units of @unit.
//
// Note that this function takes orientation and margins into consideration. See
// gtk_page_setup_get_paper_height().
func (s pageSetup) PageHeight(unit Unit) float64 {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 C.GtkUnit       // out
	var _cret C.gdouble       // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	_cret = C.gtk_page_setup_get_page_height(_arg0, _arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// PageWidth returns the page width in units of @unit.
//
// Note that this function takes orientation and margins into consideration. See
// gtk_page_setup_get_paper_width().
func (s pageSetup) PageWidth(unit Unit) float64 {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 C.GtkUnit       // out
	var _cret C.gdouble       // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	_cret = C.gtk_page_setup_get_page_width(_arg0, _arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// PaperHeight returns the paper height in units of @unit.
//
// Note that this function takes orientation, but not margins into
// consideration. See gtk_page_setup_get_page_height().
func (s pageSetup) PaperHeight(unit Unit) float64 {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 C.GtkUnit       // out
	var _cret C.gdouble       // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	_cret = C.gtk_page_setup_get_paper_height(_arg0, _arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// PaperSize gets the paper size of the PageSetup.
func (s pageSetup) PaperSize() *PaperSize {
	var _arg0 *C.GtkPageSetup // out
	var _cret *C.GtkPaperSize // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_page_setup_get_paper_size(_arg0)

	var _paperSize *PaperSize // out

	_paperSize = WrapPaperSize(unsafe.Pointer(_cret))

	return _paperSize
}

// PaperWidth returns the paper width in units of @unit.
//
// Note that this function takes orientation, but not margins into
// consideration. See gtk_page_setup_get_page_width().
func (s pageSetup) PaperWidth(unit Unit) float64 {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 C.GtkUnit       // out
	var _cret C.gdouble       // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	_cret = C.gtk_page_setup_get_paper_width(_arg0, _arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// RightMargin gets the right margin in units of @unit.
func (s pageSetup) RightMargin(unit Unit) float64 {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 C.GtkUnit       // out
	var _cret C.gdouble       // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	_cret = C.gtk_page_setup_get_right_margin(_arg0, _arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// TopMargin gets the top margin in units of @unit.
func (s pageSetup) TopMargin(unit Unit) float64 {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 C.GtkUnit       // out
	var _cret C.gdouble       // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	_cret = C.gtk_page_setup_get_top_margin(_arg0, _arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// LoadFile reads the page setup from the file @file_name. See
// gtk_page_setup_to_file().
func (s pageSetup) LoadFile(fileName string) error {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 *C.char         // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(fileName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_page_setup_load_file(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// LoadKeyFile reads the page setup from the group @group_name in the key file
// @key_file.
func (s pageSetup) LoadKeyFile(keyFile *glib.KeyFile, groupName string) error {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 *C.GKeyFile     // out
	var _arg2 *C.gchar        // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
	_arg2 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_page_setup_load_key_file(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// SetBottomMargin sets the bottom margin of the PageSetup.
func (s pageSetup) SetBottomMargin(margin float64, unit Unit) {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 C.gdouble       // out
	var _arg2 C.GtkUnit       // out

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gdouble)(margin)
	_arg2 = (C.GtkUnit)(unit)

	C.gtk_page_setup_set_bottom_margin(_arg0, _arg1, _arg2)
}

// SetLeftMargin sets the left margin of the PageSetup.
func (s pageSetup) SetLeftMargin(margin float64, unit Unit) {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 C.gdouble       // out
	var _arg2 C.GtkUnit       // out

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gdouble)(margin)
	_arg2 = (C.GtkUnit)(unit)

	C.gtk_page_setup_set_left_margin(_arg0, _arg1, _arg2)
}

// SetOrientation sets the page orientation of the PageSetup.
func (s pageSetup) SetOrientation(orientation PageOrientation) {
	var _arg0 *C.GtkPageSetup      // out
	var _arg1 C.GtkPageOrientation // out

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkPageOrientation)(orientation)

	C.gtk_page_setup_set_orientation(_arg0, _arg1)
}

// SetPaperSize sets the paper size of the PageSetup without changing the
// margins. See gtk_page_setup_set_paper_size_and_default_margins().
func (s pageSetup) SetPaperSize(size *PaperSize) {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 *C.GtkPaperSize // out

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkPaperSize)(unsafe.Pointer(size.Native()))

	C.gtk_page_setup_set_paper_size(_arg0, _arg1)
}

// SetPaperSizeAndDefaultMargins sets the paper size of the PageSetup and
// modifies the margins according to the new paper size.
func (s pageSetup) SetPaperSizeAndDefaultMargins(size *PaperSize) {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 *C.GtkPaperSize // out

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkPaperSize)(unsafe.Pointer(size.Native()))

	C.gtk_page_setup_set_paper_size_and_default_margins(_arg0, _arg1)
}

// SetRightMargin sets the right margin of the PageSetup.
func (s pageSetup) SetRightMargin(margin float64, unit Unit) {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 C.gdouble       // out
	var _arg2 C.GtkUnit       // out

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gdouble)(margin)
	_arg2 = (C.GtkUnit)(unit)

	C.gtk_page_setup_set_right_margin(_arg0, _arg1, _arg2)
}

// SetTopMargin sets the top margin of the PageSetup.
func (s pageSetup) SetTopMargin(margin float64, unit Unit) {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 C.gdouble       // out
	var _arg2 C.GtkUnit       // out

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gdouble)(margin)
	_arg2 = (C.GtkUnit)(unit)

	C.gtk_page_setup_set_top_margin(_arg0, _arg1, _arg2)
}

// ToFile: this function saves the information from @setup to @file_name.
func (s pageSetup) ToFile(fileName string) error {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 *C.char         // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(fileName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_page_setup_to_file(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// ToGVariant: serialize page setup to an a{sv} variant.
func (s pageSetup) ToGVariant() *glib.Variant {
	var _arg0 *C.GtkPageSetup // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_page_setup_to_gvariant(_arg0)

	var _variant *glib.Variant // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// ToKeyFile: this function adds the page setup from @setup to @key_file.
func (s pageSetup) ToKeyFile(keyFile *glib.KeyFile, groupName string) {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 *C.GKeyFile     // out
	var _arg2 *C.gchar        // out

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
	_arg2 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_page_setup_to_key_file(_arg0, _arg1, _arg2)
}

// Paned has two panes, arranged either horizontally or vertically. The division
// between the two panes is adjustable by the user by dragging a handle.
//
// Child widgets are added to the panes of the widget with gtk_paned_pack1() and
// gtk_paned_pack2(). The division between the two children is set by default
// from the size requests of the children, but it can be adjusted by the user.
//
// A paned widget draws a separator between the two child widgets and a small
// handle that the user can drag to adjust the division. It does not draw any
// relief around the children or around the separator. (The space in which the
// separator is called the gutter.) Often, it is useful to put each child inside
// a Frame with the shadow type set to GTK_SHADOW_IN so that the gutter appears
// as a ridge. No separator is drawn if one of the children is missing.
//
// Each child has two options that can be set, @resize and @shrink. If @resize
// is true, then when the Paned is resized, that child will expand or shrink
// along with the paned widget. If @shrink is true, then that child can be made
// smaller than its requisition by the user. Setting @shrink to false allows the
// application to set a minimum size. If @resize is false for both children,
// then this is treated as if @resize is true for both children.
//
// The application can set the position of the slider as if it were set by the
// user, by calling gtk_paned_set_position().
//
// CSS nodes
//
//    GtkWidget *hpaned = gtk_paned_new (GTK_ORIENTATION_HORIZONTAL);
//    GtkWidget *frame1 = gtk_frame_new (NULL);
//    GtkWidget *frame2 = gtk_frame_new (NULL);
//    gtk_frame_set_shadow_type (GTK_FRAME (frame1), GTK_SHADOW_IN);
//    gtk_frame_set_shadow_type (GTK_FRAME (frame2), GTK_SHADOW_IN);
//
//    gtk_widget_set_size_request (hpaned, 200, -1);
//
//    gtk_paned_pack1 (GTK_PANED (hpaned), frame1, TRUE, FALSE);
//    gtk_widget_set_size_request (frame1, 50, -1);
//
//    gtk_paned_pack2 (GTK_PANED (hpaned), frame2, FALSE, FALSE);
//    gtk_widget_set_size_request (frame2, 50, -1);
type Paned interface {
	Container
	Buildable
	Orientable

	// Add1 adds a child to the top or left pane with default parameters. This
	// is equivalent to `gtk_paned_pack1 (paned, child, FALSE, TRUE)`.
	Add1(child Widget)
	// Add2 adds a child to the bottom or right pane with default parameters.
	// This is equivalent to `gtk_paned_pack2 (paned, child, TRUE, TRUE)`.
	Add2(child Widget)
	// Child1 obtains the first child of the paned widget.
	Child1() Widget
	// Child2 obtains the second child of the paned widget.
	Child2() Widget
	// HandleWindow returns the Window of the handle. This function is useful
	// when handling button or motion events because it enables the callback to
	// distinguish between the window of the paned, a child and the handle.
	HandleWindow() gdk.Window
	// Position obtains the position of the divider between the two panes.
	Position() int
	// WideHandle gets the Paned:wide-handle property.
	WideHandle() bool
	// Pack1 adds a child to the top or left pane.
	Pack1(child Widget, resize bool, shrink bool)
	// Pack2 adds a child to the bottom or right pane.
	Pack2(child Widget, resize bool, shrink bool)
	// SetPosition sets the position of the divider between the two panes.
	SetPosition(position int)
	// SetWideHandle sets the Paned:wide-handle property.
	SetWideHandle(wide bool)
}

// paned implements the Paned class.
type paned struct {
	Container
	Buildable
	Orientable
}

var _ Paned = (*paned)(nil)

// WrapPaned wraps a GObject to the right type. It is
// primarily used internally.
func WrapPaned(obj *externglib.Object) Paned {
	return paned{
		Container:  WrapContainer(obj),
		Buildable:  WrapBuildable(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalPaned(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPaned(obj), nil
}

// NewPaned creates a new Paned widget.
func NewPaned(orientation Orientation) Paned {
	var _arg1 C.GtkOrientation // out
	var _cret *C.GtkWidget     // in

	_arg1 = (C.GtkOrientation)(orientation)

	_cret = C.gtk_paned_new(_arg1)

	var _paned Paned // out

	_paned = WrapPaned(externglib.Take(unsafe.Pointer(_cret)))

	return _paned
}

// Add1 adds a child to the top or left pane with default parameters. This is
// equivalent to `gtk_paned_pack1 (paned, child, FALSE, TRUE)`.
func (p paned) Add1(child Widget) {
	var _arg0 *C.GtkPaned  // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_paned_add1(_arg0, _arg1)
}

// Add2 adds a child to the bottom or right pane with default parameters. This
// is equivalent to `gtk_paned_pack2 (paned, child, TRUE, TRUE)`.
func (p paned) Add2(child Widget) {
	var _arg0 *C.GtkPaned  // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_paned_add2(_arg0, _arg1)
}

// Child1 obtains the first child of the paned widget.
func (p paned) Child1() Widget {
	var _arg0 *C.GtkPaned  // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_paned_get_child1(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// Child2 obtains the second child of the paned widget.
func (p paned) Child2() Widget {
	var _arg0 *C.GtkPaned  // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_paned_get_child2(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// HandleWindow returns the Window of the handle. This function is useful when
// handling button or motion events because it enables the callback to
// distinguish between the window of the paned, a child and the handle.
func (p paned) HandleWindow() gdk.Window {
	var _arg0 *C.GtkPaned  // out
	var _cret *C.GdkWindow // in

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_paned_get_handle_window(_arg0)

	var _window gdk.Window // out

	_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Window)

	return _window
}

// Position obtains the position of the divider between the two panes.
func (p paned) Position() int {
	var _arg0 *C.GtkPaned // out
	var _cret C.gint      // in

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_paned_get_position(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// WideHandle gets the Paned:wide-handle property.
func (p paned) WideHandle() bool {
	var _arg0 *C.GtkPaned // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_paned_get_wide_handle(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Pack1 adds a child to the top or left pane.
func (p paned) Pack1(child Widget, resize bool, shrink bool) {
	var _arg0 *C.GtkPaned  // out
	var _arg1 *C.GtkWidget // out
	var _arg2 C.gboolean   // out
	var _arg3 C.gboolean   // out

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	if resize {
		_arg2 = C.TRUE
	}
	if shrink {
		_arg3 = C.TRUE
	}

	C.gtk_paned_pack1(_arg0, _arg1, _arg2, _arg3)
}

// Pack2 adds a child to the bottom or right pane.
func (p paned) Pack2(child Widget, resize bool, shrink bool) {
	var _arg0 *C.GtkPaned  // out
	var _arg1 *C.GtkWidget // out
	var _arg2 C.gboolean   // out
	var _arg3 C.gboolean   // out

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	if resize {
		_arg2 = C.TRUE
	}
	if shrink {
		_arg3 = C.TRUE
	}

	C.gtk_paned_pack2(_arg0, _arg1, _arg2, _arg3)
}

// SetPosition sets the position of the divider between the two panes.
func (p paned) SetPosition(position int) {
	var _arg0 *C.GtkPaned // out
	var _arg1 C.gint      // out

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
	_arg1 = (C.gint)(position)

	C.gtk_paned_set_position(_arg0, _arg1)
}

// SetWideHandle sets the Paned:wide-handle property.
func (p paned) SetWideHandle(wide bool) {
	var _arg0 *C.GtkPaned // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
	if wide {
		_arg1 = C.TRUE
	}

	C.gtk_paned_set_wide_handle(_arg0, _arg1)
}

type PanedAccessible interface {
	ContainerAccessible
}

// panedAccessible implements the PanedAccessible class.
type panedAccessible struct {
	ContainerAccessible
}

var _ PanedAccessible = (*panedAccessible)(nil)

// WrapPanedAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapPanedAccessible(obj *externglib.Object) PanedAccessible {
	return panedAccessible{
		ContainerAccessible: WrapContainerAccessible(obj),
	}
}

func marshalPanedAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPanedAccessible(obj), nil
}

// PlacesSidebar is a widget that displays a list of frequently-used places in
// the file system: the user’s home directory, the user’s bookmarks, and volumes
// and drives. This widget is used as a sidebar in FileChooser and may be used
// by file managers and similar programs.
//
// The places sidebar displays drives and volumes, and will automatically mount
// or unmount them when the user selects them.
//
// Applications can hook to various signals in the places sidebar to customize
// its behavior. For example, they can add extra commands to the context menu of
// the sidebar.
//
// While bookmarks are completely in control of the user, the places sidebar
// also allows individual applications to provide extra shortcut folders that
// are unique to each application. For example, a Paint program may want to add
// a shortcut for a Clipart folder. You can do this with
// gtk_places_sidebar_add_shortcut().
//
// To make use of the places sidebar, an application at least needs to connect
// to the PlacesSidebar::open-location signal. This is emitted when the user
// selects in the sidebar a location to open. The application should also call
// gtk_places_sidebar_set_location() when it changes the currently-viewed
// location.
//
//
// CSS nodes
//
// GtkPlacesSidebar uses a single CSS node with name placessidebar and style
// class .sidebar.
//
// Among the children of the places sidebar, the following style classes can be
// used: - .sidebar-new-bookmark-row for the 'Add new bookmark' row -
// .sidebar-placeholder-row for a row that is a placeholder - .has-open-popup
// when a popup is open for a row
type PlacesSidebar interface {
	ScrolledWindow
	Buildable

	// AddShortcut applications may want to present some folders in the places
	// sidebar if they could be immediately useful to users. For example, a
	// drawing program could add a “/usr/share/clipart” location when the
	// sidebar is being used in an “Insert Clipart” dialog box.
	//
	// This function adds the specified @location to a special place for
	// immutable shortcuts. The shortcuts are application-specific; they are not
	// shared across applications, and they are not persistent. If this function
	// is called multiple times with different locations, then they are added to
	// the sidebar’s list in the same order as the function is called.
	AddShortcut(location gio.File)
	// LocalOnly returns the value previously set with
	// gtk_places_sidebar_set_local_only().
	LocalOnly() bool
	// Location gets the currently selected location in the @sidebar. This can
	// be nil when nothing is selected, for example, when
	// gtk_places_sidebar_set_location() has been called with a location that is
	// not among the sidebar’s list of places to show.
	//
	// You can use this function to get the selection in the @sidebar. Also, if
	// you connect to the PlacesSidebar::populate-popup signal, you can use this
	// function to get the location that is being referred to during the
	// callbacks for your menu items.
	Location() gio.File
	// NthBookmark: this function queries the bookmarks added by the user to the
	// places sidebar, and returns one of them. This function is used by
	// FileChooser to implement the “Alt-1”, “Alt-2”, etc. shortcuts, which
	// activate the cooresponding bookmark.
	NthBookmark(n int) gio.File
	// OpenFlags gets the open flags.
	OpenFlags() PlacesOpenFlags
	// ShowConnectToServer returns the value previously set with
	// gtk_places_sidebar_set_show_connect_to_server()
	ShowConnectToServer() bool
	// ShowDesktop returns the value previously set with
	// gtk_places_sidebar_set_show_desktop()
	ShowDesktop() bool
	// ShowEnterLocation returns the value previously set with
	// gtk_places_sidebar_set_show_enter_location()
	ShowEnterLocation() bool
	// ShowOtherLocations returns the value previously set with
	// gtk_places_sidebar_set_show_other_locations()
	ShowOtherLocations() bool
	// ShowRecent returns the value previously set with
	// gtk_places_sidebar_set_show_recent()
	ShowRecent() bool
	// ShowStarredLocation returns the value previously set with
	// gtk_places_sidebar_set_show_starred_location()
	ShowStarredLocation() bool
	// ShowTrash returns the value previously set with
	// gtk_places_sidebar_set_show_trash()
	ShowTrash() bool
	// RemoveShortcut removes an application-specific shortcut that has been
	// previously been inserted with gtk_places_sidebar_add_shortcut(). If the
	// @location is not a shortcut in the sidebar, then nothing is done.
	RemoveShortcut(location gio.File)
	// SetDropTargetsVisible: make the GtkPlacesSidebar show drop targets, so it
	// can show the available drop targets and a "new bookmark" row. This
	// improves the Drag-and-Drop experience of the user and allows applications
	// to show all available drop targets at once.
	//
	// This needs to be called when the application is aware of an ongoing drag
	// that might target the sidebar. The drop-targets-visible state will be
	// unset automatically if the drag finishes in the GtkPlacesSidebar. You
	// only need to unset the state when the drag ends on some other widget on
	// your application.
	SetDropTargetsVisible(visible bool, context gdk.DragContext)
	// SetLocalOnly sets whether the @sidebar should only show local files.
	SetLocalOnly(localOnly bool)
	// SetLocation sets the location that is being shown in the widgets
	// surrounding the @sidebar, for example, in a folder view in a file
	// manager. In turn, the @sidebar will highlight that location if it is
	// being shown in the list of places, or it will unhighlight everything if
	// the @location is not among the places in the list.
	SetLocation(location gio.File)
	// SetOpenFlags sets the way in which the calling application can open new
	// locations from the places sidebar. For example, some applications only
	// open locations “directly” into their main view, while others may support
	// opening locations in a new notebook tab or a new window.
	//
	// This function is used to tell the places @sidebar about the ways in which
	// the application can open new locations, so that the sidebar can display
	// (or not) the “Open in new tab” and “Open in new window” menu items as
	// appropriate.
	//
	// When the PlacesSidebar::open-location signal is emitted, its flags
	// argument will be set to one of the @flags that was passed in
	// gtk_places_sidebar_set_open_flags().
	//
	// Passing 0 for @flags will cause K_PLACES_OPEN_NORMAL to always be sent to
	// callbacks for the “open-location” signal.
	SetOpenFlags(flags PlacesOpenFlags)
	// SetShowConnectToServer sets whether the @sidebar should show an item for
	// connecting to a network server; this is off by default. An application
	// may want to turn this on if it implements a way for the user to connect
	// to network servers directly.
	//
	// If you enable this, you should connect to the
	// PlacesSidebar::show-connect-to-server signal.
	SetShowConnectToServer(showConnectToServer bool)
	// SetShowDesktop sets whether the @sidebar should show an item for the
	// Desktop folder. The default value for this option is determined by the
	// desktop environment and the user’s configuration, but this function can
	// be used to override it on a per-application basis.
	SetShowDesktop(showDesktop bool)
	// SetShowEnterLocation sets whether the @sidebar should show an item for
	// entering a location; this is off by default. An application may want to
	// turn this on if manually entering URLs is an expected user action.
	//
	// If you enable this, you should connect to the
	// PlacesSidebar::show-enter-location signal.
	SetShowEnterLocation(showEnterLocation bool)
	// SetShowOtherLocations sets whether the @sidebar should show an item for
	// the application to show an Other Locations view; this is off by default.
	// When set to true, persistent devices such as hard drives are hidden,
	// otherwise they are shown in the sidebar. An application may want to turn
	// this on if it implements a way for the user to see and interact with
	// drives and network servers directly.
	//
	// If you enable this, you should connect to the
	// PlacesSidebar::show-other-locations signal.
	SetShowOtherLocations(showOtherLocations bool)
	// SetShowRecent sets whether the @sidebar should show an item for recent
	// files. The default value for this option is determined by the desktop
	// environment, but this function can be used to override it on a
	// per-application basis.
	SetShowRecent(showRecent bool)
	// SetShowStarredLocation: if you enable this, you should connect to the
	// PlacesSidebar::show-starred-location signal.
	SetShowStarredLocation(showStarredLocation bool)
	// SetShowTrash sets whether the @sidebar should show an item for the Trash
	// location.
	SetShowTrash(showTrash bool)
}

// placesSidebar implements the PlacesSidebar class.
type placesSidebar struct {
	ScrolledWindow
	Buildable
}

var _ PlacesSidebar = (*placesSidebar)(nil)

// WrapPlacesSidebar wraps a GObject to the right type. It is
// primarily used internally.
func WrapPlacesSidebar(obj *externglib.Object) PlacesSidebar {
	return placesSidebar{
		ScrolledWindow: WrapScrolledWindow(obj),
		Buildable:      WrapBuildable(obj),
	}
}

func marshalPlacesSidebar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPlacesSidebar(obj), nil
}

// NewPlacesSidebar creates a new PlacesSidebar widget.
//
// The application should connect to at least the PlacesSidebar::open-location
// signal to be notified when the user makes a selection in the sidebar.
func NewPlacesSidebar() PlacesSidebar {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_places_sidebar_new()

	var _placesSidebar PlacesSidebar // out

	_placesSidebar = WrapPlacesSidebar(externglib.Take(unsafe.Pointer(_cret)))

	return _placesSidebar
}

// AddShortcut applications may want to present some folders in the places
// sidebar if they could be immediately useful to users. For example, a drawing
// program could add a “/usr/share/clipart” location when the sidebar is being
// used in an “Insert Clipart” dialog box.
//
// This function adds the specified @location to a special place for immutable
// shortcuts. The shortcuts are application-specific; they are not shared across
// applications, and they are not persistent. If this function is called
// multiple times with different locations, then they are added to the sidebar’s
// list in the same order as the function is called.
func (s placesSidebar) AddShortcut(location gio.File) {
	var _arg0 *C.GtkPlacesSidebar // out
	var _arg1 *C.GFile            // out

	_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(location.Native()))

	C.gtk_places_sidebar_add_shortcut(_arg0, _arg1)
}

// LocalOnly returns the value previously set with
// gtk_places_sidebar_set_local_only().
func (s placesSidebar) LocalOnly() bool {
	var _arg0 *C.GtkPlacesSidebar // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_places_sidebar_get_local_only(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Location gets the currently selected location in the @sidebar. This can be
// nil when nothing is selected, for example, when
// gtk_places_sidebar_set_location() has been called with a location that is not
// among the sidebar’s list of places to show.
//
// You can use this function to get the selection in the @sidebar. Also, if you
// connect to the PlacesSidebar::populate-popup signal, you can use this
// function to get the location that is being referred to during the callbacks
// for your menu items.
func (s placesSidebar) Location() gio.File {
	var _arg0 *C.GtkPlacesSidebar // out
	var _cret *C.GFile            // in

	_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_places_sidebar_get_location(_arg0)

	var _file gio.File // out

	_file = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.File)

	return _file
}

// NthBookmark: this function queries the bookmarks added by the user to the
// places sidebar, and returns one of them. This function is used by FileChooser
// to implement the “Alt-1”, “Alt-2”, etc. shortcuts, which activate the
// cooresponding bookmark.
func (s placesSidebar) NthBookmark(n int) gio.File {
	var _arg0 *C.GtkPlacesSidebar // out
	var _arg1 C.gint              // out
	var _cret *C.GFile            // in

	_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gint)(n)

	_cret = C.gtk_places_sidebar_get_nth_bookmark(_arg0, _arg1)

	var _file gio.File // out

	_file = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.File)

	return _file
}

// OpenFlags gets the open flags.
func (s placesSidebar) OpenFlags() PlacesOpenFlags {
	var _arg0 *C.GtkPlacesSidebar  // out
	var _cret C.GtkPlacesOpenFlags // in

	_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_places_sidebar_get_open_flags(_arg0)

	var _placesOpenFlags PlacesOpenFlags // out

	_placesOpenFlags = PlacesOpenFlags(_cret)

	return _placesOpenFlags
}

// ShowConnectToServer returns the value previously set with
// gtk_places_sidebar_set_show_connect_to_server()
func (s placesSidebar) ShowConnectToServer() bool {
	var _arg0 *C.GtkPlacesSidebar // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_places_sidebar_get_show_connect_to_server(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowDesktop returns the value previously set with
// gtk_places_sidebar_set_show_desktop()
func (s placesSidebar) ShowDesktop() bool {
	var _arg0 *C.GtkPlacesSidebar // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_places_sidebar_get_show_desktop(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowEnterLocation returns the value previously set with
// gtk_places_sidebar_set_show_enter_location()
func (s placesSidebar) ShowEnterLocation() bool {
	var _arg0 *C.GtkPlacesSidebar // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_places_sidebar_get_show_enter_location(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowOtherLocations returns the value previously set with
// gtk_places_sidebar_set_show_other_locations()
func (s placesSidebar) ShowOtherLocations() bool {
	var _arg0 *C.GtkPlacesSidebar // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_places_sidebar_get_show_other_locations(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowRecent returns the value previously set with
// gtk_places_sidebar_set_show_recent()
func (s placesSidebar) ShowRecent() bool {
	var _arg0 *C.GtkPlacesSidebar // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_places_sidebar_get_show_recent(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowStarredLocation returns the value previously set with
// gtk_places_sidebar_set_show_starred_location()
func (s placesSidebar) ShowStarredLocation() bool {
	var _arg0 *C.GtkPlacesSidebar // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_places_sidebar_get_show_starred_location(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowTrash returns the value previously set with
// gtk_places_sidebar_set_show_trash()
func (s placesSidebar) ShowTrash() bool {
	var _arg0 *C.GtkPlacesSidebar // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_places_sidebar_get_show_trash(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveShortcut removes an application-specific shortcut that has been
// previously been inserted with gtk_places_sidebar_add_shortcut(). If the
// @location is not a shortcut in the sidebar, then nothing is done.
func (s placesSidebar) RemoveShortcut(location gio.File) {
	var _arg0 *C.GtkPlacesSidebar // out
	var _arg1 *C.GFile            // out

	_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(location.Native()))

	C.gtk_places_sidebar_remove_shortcut(_arg0, _arg1)
}

// SetDropTargetsVisible: make the GtkPlacesSidebar show drop targets, so it can
// show the available drop targets and a "new bookmark" row. This improves the
// Drag-and-Drop experience of the user and allows applications to show all
// available drop targets at once.
//
// This needs to be called when the application is aware of an ongoing drag that
// might target the sidebar. The drop-targets-visible state will be unset
// automatically if the drag finishes in the GtkPlacesSidebar. You only need to
// unset the state when the drag ends on some other widget on your application.
func (s placesSidebar) SetDropTargetsVisible(visible bool, context gdk.DragContext) {
	var _arg0 *C.GtkPlacesSidebar // out
	var _arg1 C.gboolean          // out
	var _arg2 *C.GdkDragContext   // out

	_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))
	if visible {
		_arg1 = C.TRUE
	}
	_arg2 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))

	C.gtk_places_sidebar_set_drop_targets_visible(_arg0, _arg1, _arg2)
}

// SetLocalOnly sets whether the @sidebar should only show local files.
func (s placesSidebar) SetLocalOnly(localOnly bool) {
	var _arg0 *C.GtkPlacesSidebar // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))
	if localOnly {
		_arg1 = C.TRUE
	}

	C.gtk_places_sidebar_set_local_only(_arg0, _arg1)
}

// SetLocation sets the location that is being shown in the widgets surrounding
// the @sidebar, for example, in a folder view in a file manager. In turn, the
// @sidebar will highlight that location if it is being shown in the list of
// places, or it will unhighlight everything if the @location is not among the
// places in the list.
func (s placesSidebar) SetLocation(location gio.File) {
	var _arg0 *C.GtkPlacesSidebar // out
	var _arg1 *C.GFile            // out

	_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(location.Native()))

	C.gtk_places_sidebar_set_location(_arg0, _arg1)
}

// SetOpenFlags sets the way in which the calling application can open new
// locations from the places sidebar. For example, some applications only open
// locations “directly” into their main view, while others may support opening
// locations in a new notebook tab or a new window.
//
// This function is used to tell the places @sidebar about the ways in which the
// application can open new locations, so that the sidebar can display (or not)
// the “Open in new tab” and “Open in new window” menu items as appropriate.
//
// When the PlacesSidebar::open-location signal is emitted, its flags argument
// will be set to one of the @flags that was passed in
// gtk_places_sidebar_set_open_flags().
//
// Passing 0 for @flags will cause K_PLACES_OPEN_NORMAL to always be sent to
// callbacks for the “open-location” signal.
func (s placesSidebar) SetOpenFlags(flags PlacesOpenFlags) {
	var _arg0 *C.GtkPlacesSidebar  // out
	var _arg1 C.GtkPlacesOpenFlags // out

	_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkPlacesOpenFlags)(flags)

	C.gtk_places_sidebar_set_open_flags(_arg0, _arg1)
}

// SetShowConnectToServer sets whether the @sidebar should show an item for
// connecting to a network server; this is off by default. An application may
// want to turn this on if it implements a way for the user to connect to
// network servers directly.
//
// If you enable this, you should connect to the
// PlacesSidebar::show-connect-to-server signal.
func (s placesSidebar) SetShowConnectToServer(showConnectToServer bool) {
	var _arg0 *C.GtkPlacesSidebar // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))
	if showConnectToServer {
		_arg1 = C.TRUE
	}

	C.gtk_places_sidebar_set_show_connect_to_server(_arg0, _arg1)
}

// SetShowDesktop sets whether the @sidebar should show an item for the Desktop
// folder. The default value for this option is determined by the desktop
// environment and the user’s configuration, but this function can be used to
// override it on a per-application basis.
func (s placesSidebar) SetShowDesktop(showDesktop bool) {
	var _arg0 *C.GtkPlacesSidebar // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))
	if showDesktop {
		_arg1 = C.TRUE
	}

	C.gtk_places_sidebar_set_show_desktop(_arg0, _arg1)
}

// SetShowEnterLocation sets whether the @sidebar should show an item for
// entering a location; this is off by default. An application may want to turn
// this on if manually entering URLs is an expected user action.
//
// If you enable this, you should connect to the
// PlacesSidebar::show-enter-location signal.
func (s placesSidebar) SetShowEnterLocation(showEnterLocation bool) {
	var _arg0 *C.GtkPlacesSidebar // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))
	if showEnterLocation {
		_arg1 = C.TRUE
	}

	C.gtk_places_sidebar_set_show_enter_location(_arg0, _arg1)
}

// SetShowOtherLocations sets whether the @sidebar should show an item for the
// application to show an Other Locations view; this is off by default. When set
// to true, persistent devices such as hard drives are hidden, otherwise they
// are shown in the sidebar. An application may want to turn this on if it
// implements a way for the user to see and interact with drives and network
// servers directly.
//
// If you enable this, you should connect to the
// PlacesSidebar::show-other-locations signal.
func (s placesSidebar) SetShowOtherLocations(showOtherLocations bool) {
	var _arg0 *C.GtkPlacesSidebar // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))
	if showOtherLocations {
		_arg1 = C.TRUE
	}

	C.gtk_places_sidebar_set_show_other_locations(_arg0, _arg1)
}

// SetShowRecent sets whether the @sidebar should show an item for recent files.
// The default value for this option is determined by the desktop environment,
// but this function can be used to override it on a per-application basis.
func (s placesSidebar) SetShowRecent(showRecent bool) {
	var _arg0 *C.GtkPlacesSidebar // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))
	if showRecent {
		_arg1 = C.TRUE
	}

	C.gtk_places_sidebar_set_show_recent(_arg0, _arg1)
}

// SetShowStarredLocation: if you enable this, you should connect to the
// PlacesSidebar::show-starred-location signal.
func (s placesSidebar) SetShowStarredLocation(showStarredLocation bool) {
	var _arg0 *C.GtkPlacesSidebar // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))
	if showStarredLocation {
		_arg1 = C.TRUE
	}

	C.gtk_places_sidebar_set_show_starred_location(_arg0, _arg1)
}

// SetShowTrash sets whether the @sidebar should show an item for the Trash
// location.
func (s placesSidebar) SetShowTrash(showTrash bool) {
	var _arg0 *C.GtkPlacesSidebar // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))
	if showTrash {
		_arg1 = C.TRUE
	}

	C.gtk_places_sidebar_set_show_trash(_arg0, _arg1)
}

// Plug: together with Socket, Plug provides the ability to embed widgets from
// one process into another process in a fashion that is transparent to the
// user. One process creates a Socket widget and passes the ID of that widget’s
// window to the other process, which then creates a Plug with that window ID.
// Any widgets contained in the Plug then will appear inside the first
// application’s window.
//
// The communication between a Socket and a Plug follows the XEmbed Protocol
// (http://www.freedesktop.org/Standards/xembed-spec). This protocol has also
// been implemented in other toolkits, e.g. Qt, allowing the same level of
// integration when embedding a Qt widget in GTK+ or vice versa.
//
// The Plug and Socket widgets are only available when GTK+ is compiled for the
// X11 platform and GDK_WINDOWING_X11 is defined. They can only be used on a
// X11Display. To use Plug and Socket, you need to include the `gtk/gtkx.h`
// header.
type Plug interface {
	Window
	Buildable

	// Embedded determines whether the plug is embedded in a socket.
	Embedded() bool
	// SocketWindow retrieves the socket the plug is embedded in.
	SocketWindow() gdk.Window
}

// plug implements the Plug class.
type plug struct {
	Window
	Buildable
}

var _ Plug = (*plug)(nil)

// WrapPlug wraps a GObject to the right type. It is
// primarily used internally.
func WrapPlug(obj *externglib.Object) Plug {
	return plug{
		Window:    WrapWindow(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalPlug(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPlug(obj), nil
}

// Embedded determines whether the plug is embedded in a socket.
func (p plug) Embedded() bool {
	var _arg0 *C.GtkPlug // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkPlug)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_plug_get_embedded(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SocketWindow retrieves the socket the plug is embedded in.
func (p plug) SocketWindow() gdk.Window {
	var _arg0 *C.GtkPlug   // out
	var _cret *C.GdkWindow // in

	_arg0 = (*C.GtkPlug)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_plug_get_socket_window(_arg0)

	var _window gdk.Window // out

	_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Window)

	return _window
}

type PlugAccessible interface {
	WindowAccessible

	ID() string
}

// plugAccessible implements the PlugAccessible class.
type plugAccessible struct {
	WindowAccessible
}

var _ PlugAccessible = (*plugAccessible)(nil)

// WrapPlugAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapPlugAccessible(obj *externglib.Object) PlugAccessible {
	return plugAccessible{
		WindowAccessible: WrapWindowAccessible(obj),
	}
}

func marshalPlugAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPlugAccessible(obj), nil
}

func (p plugAccessible) ID() string {
	var _arg0 *C.GtkPlugAccessible // out
	var _cret *C.gchar             // in

	_arg0 = (*C.GtkPlugAccessible)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_plug_accessible_get_id(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Popover: gtkPopover is a bubble-like context window, primarily meant to
// provide context-dependent information or options. Popovers are attached to a
// widget, passed at construction time on gtk_popover_new(), or updated
// afterwards through gtk_popover_set_relative_to(), by default they will point
// to the whole widget area, although this behavior can be changed through
// gtk_popover_set_pointing_to().
//
// The position of a popover relative to the widget it is attached to can also
// be changed through gtk_popover_set_position().
//
// By default, Popover performs a GTK+ grab, in order to ensure input events get
// redirected to it while it is shown, and also so the popover is dismissed in
// the expected situations (clicks outside the popover, or the Esc key being
// pressed). If no such modal behavior is desired on a popover,
// gtk_popover_set_modal() may be called on it to tweak its behavior.
//
//
// GtkPopover as menu replacement
//
// GtkPopover is often used to replace menus. To facilitate this, it supports
// being populated from a Model, using gtk_popover_new_from_model(). In addition
// to all the regular menu model features, this function supports rendering
// sections in the model in a more compact form, as a row of icon buttons
// instead of menu items.
//
// To use this rendering, set the ”display-hint” attribute of the section to
// ”horizontal-buttons” and set the icons of your items with the ”verb-icon”
// attribute.
//
//    <section>
//      <attribute name="display-hint">horizontal-buttons</attribute>
//      <item>
//        <attribute name="label">Cut</attribute>
//        <attribute name="action">app.cut</attribute>
//        <attribute name="verb-icon">edit-cut-symbolic</attribute>
//      </item>
//      <item>
//        <attribute name="label">Copy</attribute>
//        <attribute name="action">app.copy</attribute>
//        <attribute name="verb-icon">edit-copy-symbolic</attribute>
//      </item>
//      <item>
//        <attribute name="label">Paste</attribute>
//        <attribute name="action">app.paste</attribute>
//        <attribute name="verb-icon">edit-paste-symbolic</attribute>
//      </item>
//    </section>
//
//
// CSS nodes
//
// GtkPopover has a single css node called popover. It always gets the
// .background style class and it gets the .menu style class if it is menu-like
// (e.g. PopoverMenu or created using gtk_popover_new_from_model().
//
// Particular uses of GtkPopover, such as touch selection popups or magnifiers
// in Entry or TextView get style classes like .touch-selection or .magnifier to
// differentiate from plain popovers.
type Popover interface {
	Bin
	Buildable

	// BindModel establishes a binding between a Popover and a Model.
	//
	// The contents of @popover are removed and then refilled with menu items
	// according to @model. When @model changes, @popover is updated. Calling
	// this function twice on @popover with different @model will cause the
	// first binding to be replaced with a binding to the new model. If @model
	// is nil then any previous binding is undone and all children are removed.
	//
	// If @action_namespace is non-nil then the effect is as if all actions
	// mentioned in the @model have their names prefixed with the namespace,
	// plus a dot. For example, if the action “quit” is mentioned and
	// @action_namespace is “app” then the effective action name is “app.quit”.
	//
	// This function uses Actionable to define the action name and target values
	// on the created menu items. If you want to use an action group other than
	// “app” and “win”, or if you want to use a MenuShell outside of a
	// ApplicationWindow, then you will need to attach your own action group to
	// the widget hierarchy using gtk_widget_insert_action_group(). As an
	// example, if you created a group with a “quit” action and inserted it with
	// the name “mygroup” then you would use the action name “mygroup.quit” in
	// your Model.
	BindModel(model gio.MenuModel, actionNamespace string)
	// ConstrainTo returns the constraint for placing this popover. See
	// gtk_popover_set_constrain_to().
	ConstrainTo() PopoverConstraint
	// DefaultWidget gets the widget that should be set as the default while the
	// popover is shown.
	DefaultWidget() Widget
	// Modal returns whether the popover is modal, see gtk_popover_set_modal to
	// see the implications of this.
	Modal() bool
	// PointingTo: if a rectangle to point to has been set, this function will
	// return true and fill in @rect with such rectangle, otherwise it will
	// return false and fill in @rect with the attached widget coordinates.
	PointingTo() (gdk.Rectangle, bool)
	// Position returns the preferred position of @popover.
	Position() PositionType
	// RelativeTo returns the widget @popover is currently attached to
	RelativeTo() Widget
	// TransitionsEnabled returns whether show/hide transitions are enabled on
	// this popover.
	TransitionsEnabled() bool
	// Popdown pops @popover down.This is different than a gtk_widget_hide()
	// call in that it shows the popover with a transition. If you want to hide
	// the popover without a transition, use gtk_widget_hide().
	Popdown()
	// Popup pops @popover up. This is different than a gtk_widget_show() call
	// in that it shows the popover with a transition. If you want to show the
	// popover without a transition, use gtk_widget_show().
	Popup()
	// SetConstrainTo sets a constraint for positioning this popover.
	//
	// Note that not all platforms support placing popovers freely, and may
	// already impose constraints.
	SetConstrainTo(constraint PopoverConstraint)
	// SetDefaultWidget sets the widget that should be set as default widget
	// while the popover is shown (see gtk_window_set_default()). Popover
	// remembers the previous default widget and reestablishes it when the
	// popover is dismissed.
	SetDefaultWidget(widget Widget)
	// SetModal sets whether @popover is modal, a modal popover will grab all
	// input within the toplevel and grab the keyboard focus on it when being
	// displayed. Clicking outside the popover area or pressing Esc will dismiss
	// the popover and ungrab input.
	SetModal(modal bool)
	// SetPointingTo sets the rectangle that @popover will point to, in the
	// coordinate space of the widget @popover is attached to, see
	// gtk_popover_set_relative_to().
	SetPointingTo(rect *gdk.Rectangle)
	// SetPosition sets the preferred position for @popover to appear. If the
	// @popover is currently visible, it will be immediately updated.
	//
	// This preference will be respected where possible, although on lack of
	// space (eg. if close to the window edges), the Popover may choose to
	// appear on the opposite side
	SetPosition(position PositionType)
	// SetRelativeTo sets a new widget to be attached to @popover. If @popover
	// is visible, the position will be updated.
	//
	// Note: the ownership of popovers is always given to their @relative_to
	// widget, so if @relative_to is set to nil on an attached @popover, it will
	// be detached from its previous widget, and consequently destroyed unless
	// extra references are kept.
	SetRelativeTo(relativeTo Widget)
	// SetTransitionsEnabled sets whether show/hide transitions are enabled on
	// this popover
	SetTransitionsEnabled(transitionsEnabled bool)
}

// popover implements the Popover class.
type popover struct {
	Bin
	Buildable
}

var _ Popover = (*popover)(nil)

// WrapPopover wraps a GObject to the right type. It is
// primarily used internally.
func WrapPopover(obj *externglib.Object) Popover {
	return popover{
		Bin:       WrapBin(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalPopover(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPopover(obj), nil
}

// NewPopover creates a new popover to point to @relative_to
func NewPopover(relativeTo Widget) Popover {
	var _arg1 *C.GtkWidget // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(relativeTo.Native()))

	_cret = C.gtk_popover_new(_arg1)

	var _popover Popover // out

	_popover = WrapPopover(externglib.Take(unsafe.Pointer(_cret)))

	return _popover
}

// NewPopoverFromModel creates a Popover and populates it according to @model.
// The popover is pointed to the @relative_to widget.
//
// The created buttons are connected to actions found in the ApplicationWindow
// to which the popover belongs - typically by means of being attached to a
// widget that is contained within the ApplicationWindows widget hierarchy.
//
// Actions can also be added using gtk_widget_insert_action_group() on the menus
// attach widget or on any of its parent widgets.
func NewPopoverFromModel(relativeTo Widget, model gio.MenuModel) Popover {
	var _arg1 *C.GtkWidget  // out
	var _arg2 *C.GMenuModel // out
	var _cret *C.GtkWidget  // in

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(relativeTo.Native()))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

	_cret = C.gtk_popover_new_from_model(_arg1, _arg2)

	var _popover Popover // out

	_popover = WrapPopover(externglib.Take(unsafe.Pointer(_cret)))

	return _popover
}

// BindModel establishes a binding between a Popover and a Model.
//
// The contents of @popover are removed and then refilled with menu items
// according to @model. When @model changes, @popover is updated. Calling this
// function twice on @popover with different @model will cause the first binding
// to be replaced with a binding to the new model. If @model is nil then any
// previous binding is undone and all children are removed.
//
// If @action_namespace is non-nil then the effect is as if all actions
// mentioned in the @model have their names prefixed with the namespace, plus a
// dot. For example, if the action “quit” is mentioned and @action_namespace is
// “app” then the effective action name is “app.quit”.
//
// This function uses Actionable to define the action name and target values on
// the created menu items. If you want to use an action group other than “app”
// and “win”, or if you want to use a MenuShell outside of a ApplicationWindow,
// then you will need to attach your own action group to the widget hierarchy
// using gtk_widget_insert_action_group(). As an example, if you created a group
// with a “quit” action and inserted it with the name “mygroup” then you would
// use the action name “mygroup.quit” in your Model.
func (p popover) BindModel(model gio.MenuModel, actionNamespace string) {
	var _arg0 *C.GtkPopover // out
	var _arg1 *C.GMenuModel // out
	var _arg2 *C.gchar      // out

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))
	_arg2 = (*C.gchar)(C.CString(actionNamespace))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_popover_bind_model(_arg0, _arg1, _arg2)
}

// ConstrainTo returns the constraint for placing this popover. See
// gtk_popover_set_constrain_to().
func (p popover) ConstrainTo() PopoverConstraint {
	var _arg0 *C.GtkPopover          // out
	var _cret C.GtkPopoverConstraint // in

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_popover_get_constrain_to(_arg0)

	var _popoverConstraint PopoverConstraint // out

	_popoverConstraint = PopoverConstraint(_cret)

	return _popoverConstraint
}

// DefaultWidget gets the widget that should be set as the default while the
// popover is shown.
func (p popover) DefaultWidget() Widget {
	var _arg0 *C.GtkPopover // out
	var _cret *C.GtkWidget  // in

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_popover_get_default_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// Modal returns whether the popover is modal, see gtk_popover_set_modal to see
// the implications of this.
func (p popover) Modal() bool {
	var _arg0 *C.GtkPopover // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_popover_get_modal(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PointingTo: if a rectangle to point to has been set, this function will
// return true and fill in @rect with such rectangle, otherwise it will return
// false and fill in @rect with the attached widget coordinates.
func (p popover) PointingTo() (gdk.Rectangle, bool) {
	var _arg0 *C.GtkPopover // out
	var _rect gdk.Rectangle
	var _cret C.gboolean // in

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_popover_get_pointing_to(_arg0, (*C.GdkRectangle)(unsafe.Pointer(&_rect)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _rect, _ok
}

// Position returns the preferred position of @popover.
func (p popover) Position() PositionType {
	var _arg0 *C.GtkPopover     // out
	var _cret C.GtkPositionType // in

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_popover_get_position(_arg0)

	var _positionType PositionType // out

	_positionType = PositionType(_cret)

	return _positionType
}

// RelativeTo returns the widget @popover is currently attached to
func (p popover) RelativeTo() Widget {
	var _arg0 *C.GtkPopover // out
	var _cret *C.GtkWidget  // in

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_popover_get_relative_to(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// TransitionsEnabled returns whether show/hide transitions are enabled on this
// popover.
func (p popover) TransitionsEnabled() bool {
	var _arg0 *C.GtkPopover // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_popover_get_transitions_enabled(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Popdown pops @popover down.This is different than a gtk_widget_hide() call in
// that it shows the popover with a transition. If you want to hide the popover
// without a transition, use gtk_widget_hide().
func (p popover) Popdown() {
	var _arg0 *C.GtkPopover // out

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

	C.gtk_popover_popdown(_arg0)
}

// Popup pops @popover up. This is different than a gtk_widget_show() call in
// that it shows the popover with a transition. If you want to show the popover
// without a transition, use gtk_widget_show().
func (p popover) Popup() {
	var _arg0 *C.GtkPopover // out

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

	C.gtk_popover_popup(_arg0)
}

// SetConstrainTo sets a constraint for positioning this popover.
//
// Note that not all platforms support placing popovers freely, and may already
// impose constraints.
func (p popover) SetConstrainTo(constraint PopoverConstraint) {
	var _arg0 *C.GtkPopover          // out
	var _arg1 C.GtkPopoverConstraint // out

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))
	_arg1 = (C.GtkPopoverConstraint)(constraint)

	C.gtk_popover_set_constrain_to(_arg0, _arg1)
}

// SetDefaultWidget sets the widget that should be set as default widget while
// the popover is shown (see gtk_window_set_default()). Popover remembers the
// previous default widget and reestablishes it when the popover is dismissed.
func (p popover) SetDefaultWidget(widget Widget) {
	var _arg0 *C.GtkPopover // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_popover_set_default_widget(_arg0, _arg1)
}

// SetModal sets whether @popover is modal, a modal popover will grab all input
// within the toplevel and grab the keyboard focus on it when being displayed.
// Clicking outside the popover area or pressing Esc will dismiss the popover
// and ungrab input.
func (p popover) SetModal(modal bool) {
	var _arg0 *C.GtkPopover // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))
	if modal {
		_arg1 = C.TRUE
	}

	C.gtk_popover_set_modal(_arg0, _arg1)
}

// SetPointingTo sets the rectangle that @popover will point to, in the
// coordinate space of the widget @popover is attached to, see
// gtk_popover_set_relative_to().
func (p popover) SetPointingTo(rect *gdk.Rectangle) {
	var _arg0 *C.GtkPopover   // out
	var _arg1 *C.GdkRectangle // out

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GdkRectangle)(unsafe.Pointer(rect.Native()))

	C.gtk_popover_set_pointing_to(_arg0, _arg1)
}

// SetPosition sets the preferred position for @popover to appear. If the
// @popover is currently visible, it will be immediately updated.
//
// This preference will be respected where possible, although on lack of space
// (eg. if close to the window edges), the Popover may choose to appear on the
// opposite side
func (p popover) SetPosition(position PositionType) {
	var _arg0 *C.GtkPopover     // out
	var _arg1 C.GtkPositionType // out

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))
	_arg1 = (C.GtkPositionType)(position)

	C.gtk_popover_set_position(_arg0, _arg1)
}

// SetRelativeTo sets a new widget to be attached to @popover. If @popover is
// visible, the position will be updated.
//
// Note: the ownership of popovers is always given to their @relative_to widget,
// so if @relative_to is set to nil on an attached @popover, it will be detached
// from its previous widget, and consequently destroyed unless extra references
// are kept.
func (p popover) SetRelativeTo(relativeTo Widget) {
	var _arg0 *C.GtkPopover // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(relativeTo.Native()))

	C.gtk_popover_set_relative_to(_arg0, _arg1)
}

// SetTransitionsEnabled sets whether show/hide transitions are enabled on this
// popover
func (p popover) SetTransitionsEnabled(transitionsEnabled bool) {
	var _arg0 *C.GtkPopover // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))
	if transitionsEnabled {
		_arg1 = C.TRUE
	}

	C.gtk_popover_set_transitions_enabled(_arg0, _arg1)
}

type PopoverAccessible interface {
	ContainerAccessible
}

// popoverAccessible implements the PopoverAccessible class.
type popoverAccessible struct {
	ContainerAccessible
}

var _ PopoverAccessible = (*popoverAccessible)(nil)

// WrapPopoverAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapPopoverAccessible(obj *externglib.Object) PopoverAccessible {
	return popoverAccessible{
		ContainerAccessible: WrapContainerAccessible(obj),
	}
}

func marshalPopoverAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPopoverAccessible(obj), nil
}

// PopoverMenu: gtkPopoverMenu is a subclass of Popover that treats its children
// like menus and allows switching between them. It is meant to be used
// primarily together with ModelButton, but any widget can be used, such as
// SpinButton or Scale. In this respect, GtkPopoverMenu is more flexible than
// popovers that are created from a Model with gtk_popover_new_from_model().
//
// To add a child as a submenu, set the PopoverMenu:submenu child property to
// the name of the submenu. To let the user open this submenu, add a ModelButton
// whose ModelButton:menu-name property is set to the name you've given to the
// submenu.
//
// By convention, the first child of a submenu should be a ModelButton to switch
// back to the parent menu. Such a button should use the ModelButton:inverted
// and ModelButton:centered properties to achieve a title-like appearance and
// place the submenu indicator at the opposite side. To switch back to the main
// menu, use "main" as the menu name.
//
// Example
//
//    <object class="GtkPopoverMenu">
//      <child>
//        <object class="GtkBox">
//          <property name="visible">True</property>
//          <property name="margin">10</property>
//          <child>
//            <object class="GtkModelButton">
//              <property name="visible">True</property>
//              <property name="action-name">win.frob</property>
//              <property name="text" translatable="yes">Frob</property>
//            </object>
//          </child>
//          <child>
//            <object class="GtkModelButton">
//              <property name="visible">True</property>
//              <property name="menu-name">more</property>
//              <property name="text" translatable="yes">More</property>
//            </object>
//          </child>
//        </object>
//      </child>
//      <child>
//        <object class="GtkBox">
//          <property name="visible">True</property>
//          <property name="margin">10</property>
//          <child>
//            <object class="GtkModelButton">
//              <property name="visible">True</property>
//              <property name="action-name">win.foo</property>
//              <property name="text" translatable="yes">Foo</property>
//            </object>
//          </child>
//          <child>
//            <object class="GtkModelButton">
//              <property name="visible">True</property>
//              <property name="action-name">win.bar</property>
//              <property name="text" translatable="yes">Bar</property>
//            </object>
//          </child>
//        </object>
//        <packing>
//          <property name="submenu">more</property>
//        </packing>
//      </child>
//    </object>
//
// Just like normal popovers created using gtk_popover_new_from_model,
// PopoverMenu instances have a single css node called "popover" and get the
// .menu style class.
type PopoverMenu interface {
	Popover
	Buildable

	// OpenSubmenu opens a submenu of the @popover. The @name must be one of the
	// names given to the submenus of @popover with PopoverMenu:submenu, or
	// "main" to switch back to the main menu.
	//
	// ModelButton will open submenus automatically when the
	// ModelButton:menu-name property is set, so this function is only needed
	// when you are using other kinds of widgets to initiate menu changes.
	OpenSubmenu(name string)
}

// popoverMenu implements the PopoverMenu class.
type popoverMenu struct {
	Popover
	Buildable
}

var _ PopoverMenu = (*popoverMenu)(nil)

// WrapPopoverMenu wraps a GObject to the right type. It is
// primarily used internally.
func WrapPopoverMenu(obj *externglib.Object) PopoverMenu {
	return popoverMenu{
		Popover:   WrapPopover(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalPopoverMenu(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPopoverMenu(obj), nil
}

// NewPopoverMenu creates a new popover menu.
func NewPopoverMenu() PopoverMenu {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_popover_menu_new()

	var _popoverMenu PopoverMenu // out

	_popoverMenu = WrapPopoverMenu(externglib.Take(unsafe.Pointer(_cret)))

	return _popoverMenu
}

// OpenSubmenu opens a submenu of the @popover. The @name must be one of the
// names given to the submenus of @popover with PopoverMenu:submenu, or "main"
// to switch back to the main menu.
//
// ModelButton will open submenus automatically when the ModelButton:menu-name
// property is set, so this function is only needed when you are using other
// kinds of widgets to initiate menu changes.
func (p popoverMenu) OpenSubmenu(name string) {
	var _arg0 *C.GtkPopoverMenu // out
	var _arg1 *C.gchar          // out

	_arg0 = (*C.GtkPopoverMenu)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_popover_menu_open_submenu(_arg0, _arg1)
}

// PrintContext: a GtkPrintContext encapsulates context information that is
// required when drawing pages for printing, such as the cairo context and
// important parameters like page size and resolution. It also lets you easily
// create Layout and Context objects that match the font metrics of the cairo
// surface.
//
// GtkPrintContext objects gets passed to the PrintOperation::begin-print,
// PrintOperation::end-print, PrintOperation::request-page-setup and
// PrintOperation::draw-page signals on the PrintOperation.
//
// Using GtkPrintContext in a PrintOperation::draw-page callback
//
//    static void
//    draw_page (GtkPrintOperation *operation,
//    	   GtkPrintContext   *context,
//    	   int                page_nr)
//    {
//      cairo_t *cr;
//      PangoLayout *layout;
//      PangoFontDescription *desc;
//
//      cr = gtk_print_context_get_cairo_context (context);
//
//      // Draw a red rectangle, as wide as the paper (inside the margins)
//      cairo_set_source_rgb (cr, 1.0, 0, 0);
//      cairo_rectangle (cr, 0, 0, gtk_print_context_get_width (context), 50);
//
//      cairo_fill (cr);
//
//      // Draw some lines
//      cairo_move_to (cr, 20, 10);
//      cairo_line_to (cr, 40, 20);
//      cairo_arc (cr, 60, 60, 20, 0, M_PI);
//      cairo_line_to (cr, 80, 20);
//
//      cairo_set_source_rgb (cr, 0, 0, 0);
//      cairo_set_line_width (cr, 5);
//      cairo_set_line_cap (cr, CAIRO_LINE_CAP_ROUND);
//      cairo_set_line_join (cr, CAIRO_LINE_JOIN_ROUND);
//
//      cairo_stroke (cr);
//
//      // Draw some text
//      layout = gtk_print_context_create_pango_layout (context);
//      pango_layout_set_text (layout, "Hello World! Printing is easy", -1);
//      desc = pango_font_description_from_string ("sans 28");
//      pango_layout_set_font_description (layout, desc);
//      pango_font_description_free (desc);
//
//      cairo_move_to (cr, 30, 20);
//      pango_cairo_layout_path (cr, layout);
//
//      // Font Outline
//      cairo_set_source_rgb (cr, 0.93, 1.0, 0.47);
//      cairo_set_line_width (cr, 0.5);
//      cairo_stroke_preserve (cr);
//
//      // Font Fill
//      cairo_set_source_rgb (cr, 0, 0.0, 1.0);
//      cairo_fill (cr);
//
//      g_object_unref (layout);
//    }
//
// Printing support was added in GTK+ 2.10.
type PrintContext interface {
	gextras.Objector

	// CreatePangoContext creates a new Context that can be used with the
	// PrintContext.
	CreatePangoContext() pango.Context
	// CreatePangoLayout creates a new Layout that is suitable for use with the
	// PrintContext.
	CreatePangoLayout() pango.Layout
	// CairoContext obtains the cairo context that is associated with the
	// PrintContext.
	CairoContext() *cairo.Context
	// DPIX obtains the horizontal resolution of the PrintContext, in dots per
	// inch.
	DPIX() float64
	// DPIY obtains the vertical resolution of the PrintContext, in dots per
	// inch.
	DPIY() float64
	// HardMargins obtains the hardware printer margins of the PrintContext, in
	// units.
	HardMargins() (top float64, bottom float64, left float64, right float64, ok bool)
	// Height obtains the height of the PrintContext, in pixels.
	Height() float64
	// PageSetup obtains the PageSetup that determines the page dimensions of
	// the PrintContext.
	PageSetup() PageSetup
	// PangoFontmap returns a FontMap that is suitable for use with the
	// PrintContext.
	PangoFontmap() pango.FontMap
	// Width obtains the width of the PrintContext, in pixels.
	Width() float64
	// SetCairoContext sets a new cairo context on a print context.
	//
	// This function is intended to be used when implementing an internal print
	// preview, it is not needed for printing, since GTK+ itself creates a
	// suitable cairo context in that case.
	SetCairoContext(cr *cairo.Context, dpiX float64, dpiY float64)
}

// printContext implements the PrintContext class.
type printContext struct {
	gextras.Objector
}

var _ PrintContext = (*printContext)(nil)

// WrapPrintContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapPrintContext(obj *externglib.Object) PrintContext {
	return printContext{
		Objector: obj,
	}
}

func marshalPrintContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPrintContext(obj), nil
}

// CreatePangoContext creates a new Context that can be used with the
// PrintContext.
func (c printContext) CreatePangoContext() pango.Context {
	var _arg0 *C.GtkPrintContext // out
	var _cret *C.PangoContext    // in

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_print_context_create_pango_context(_arg0)

	var _ret pango.Context // out

	_ret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(pango.Context)

	return _ret
}

// CreatePangoLayout creates a new Layout that is suitable for use with the
// PrintContext.
func (c printContext) CreatePangoLayout() pango.Layout {
	var _arg0 *C.GtkPrintContext // out
	var _cret *C.PangoLayout     // in

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_print_context_create_pango_layout(_arg0)

	var _layout pango.Layout // out

	_layout = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(pango.Layout)

	return _layout
}

// CairoContext obtains the cairo context that is associated with the
// PrintContext.
func (c printContext) CairoContext() *cairo.Context {
	var _arg0 *C.GtkPrintContext // out
	var _cret *C.cairo_t         // in

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_print_context_get_cairo_context(_arg0)

	var _ret *cairo.Context // out

	_ret = cairo.WrapContext(unsafe.Pointer(_cret))

	return _ret
}

// DPIX obtains the horizontal resolution of the PrintContext, in dots per inch.
func (c printContext) DPIX() float64 {
	var _arg0 *C.GtkPrintContext // out
	var _cret C.gdouble          // in

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_print_context_get_dpi_x(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// DPIY obtains the vertical resolution of the PrintContext, in dots per inch.
func (c printContext) DPIY() float64 {
	var _arg0 *C.GtkPrintContext // out
	var _cret C.gdouble          // in

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_print_context_get_dpi_y(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// HardMargins obtains the hardware printer margins of the PrintContext, in
// units.
func (c printContext) HardMargins() (top float64, bottom float64, left float64, right float64, ok bool) {
	var _arg0 *C.GtkPrintContext // out
	var _arg1 C.gdouble          // in
	var _arg2 C.gdouble          // in
	var _arg3 C.gdouble          // in
	var _arg4 C.gdouble          // in
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_print_context_get_hard_margins(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)

	var _top float64    // out
	var _bottom float64 // out
	var _left float64   // out
	var _right float64  // out
	var _ok bool        // out

	_top = (float64)(_arg1)
	_bottom = (float64)(_arg2)
	_left = (float64)(_arg3)
	_right = (float64)(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _top, _bottom, _left, _right, _ok
}

// Height obtains the height of the PrintContext, in pixels.
func (c printContext) Height() float64 {
	var _arg0 *C.GtkPrintContext // out
	var _cret C.gdouble          // in

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_print_context_get_height(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// PageSetup obtains the PageSetup that determines the page dimensions of the
// PrintContext.
func (c printContext) PageSetup() PageSetup {
	var _arg0 *C.GtkPrintContext // out
	var _cret *C.GtkPageSetup    // in

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_print_context_get_page_setup(_arg0)

	var _pageSetup PageSetup // out

	_pageSetup = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(PageSetup)

	return _pageSetup
}

// PangoFontmap returns a FontMap that is suitable for use with the
// PrintContext.
func (c printContext) PangoFontmap() pango.FontMap {
	var _arg0 *C.GtkPrintContext // out
	var _cret *C.PangoFontMap    // in

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_print_context_get_pango_fontmap(_arg0)

	var _fontMap pango.FontMap // out

	_fontMap = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(pango.FontMap)

	return _fontMap
}

// Width obtains the width of the PrintContext, in pixels.
func (c printContext) Width() float64 {
	var _arg0 *C.GtkPrintContext // out
	var _cret C.gdouble          // in

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_print_context_get_width(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// SetCairoContext sets a new cairo context on a print context.
//
// This function is intended to be used when implementing an internal print
// preview, it is not needed for printing, since GTK+ itself creates a suitable
// cairo context in that case.
func (c printContext) SetCairoContext(cr *cairo.Context, dpiX float64, dpiY float64) {
	var _arg0 *C.GtkPrintContext // out
	var _arg1 *C.cairo_t         // out
	var _arg2 C.double           // out
	var _arg3 C.double           // out

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg2 = (C.double)(dpiX)
	_arg3 = (C.double)(dpiY)

	C.gtk_print_context_set_cairo_context(_arg0, _arg1, _arg2, _arg3)
}

// PrintOperation: gtkPrintOperation is the high-level, portable printing API.
// It looks a bit different than other GTK+ dialogs such as the FileChooser,
// since some platforms don’t expose enough infrastructure to implement a good
// print dialog. On such platforms, GtkPrintOperation uses the native print
// dialog. On platforms which do not provide a native print dialog, GTK+ uses
// its own, see PrintUnixDialog.
//
// The typical way to use the high-level printing API is to create a
// GtkPrintOperation object with gtk_print_operation_new() when the user selects
// to print. Then you set some properties on it, e.g. the page size, any
// PrintSettings from previous print operations, the number of pages, the
// current page, etc.
//
// Then you start the print operation by calling gtk_print_operation_run(). It
// will then show a dialog, let the user select a printer and options. When the
// user finished the dialog various signals will be emitted on the
// PrintOperation, the main one being PrintOperation::draw-page, which you are
// supposed to catch and render the page on the provided PrintContext using
// Cairo.
//
// The high-level printing API
//
//    static GtkPrintSettings *settings = NULL;
//
//    static void
//    do_print (void)
//    {
//      GtkPrintOperation *print;
//      GtkPrintOperationResult res;
//
//      print = gtk_print_operation_new ();
//
//      if (settings != NULL)
//        gtk_print_operation_set_print_settings (print, settings);
//
//      g_signal_connect (print, "begin_print", G_CALLBACK (begin_print), NULL);
//      g_signal_connect (print, "draw_page", G_CALLBACK (draw_page), NULL);
//
//      res = gtk_print_operation_run (print, GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG,
//                                     GTK_WINDOW (main_window), NULL);
//
//      if (res == GTK_PRINT_OPERATION_RESULT_APPLY)
//        {
//          if (settings != NULL)
//            g_object_unref (settings);
//          settings = g_object_ref (gtk_print_operation_get_print_settings (print));
//        }
//
//      g_object_unref (print);
//    }
//
// By default GtkPrintOperation uses an external application to do print
// preview. To implement a custom print preview, an application must connect to
// the preview signal. The functions gtk_print_operation_preview_render_page(),
// gtk_print_operation_preview_end_preview() and
// gtk_print_operation_preview_is_selected() are useful when implementing a
// print preview.
type PrintOperation interface {
	gextras.Objector
	PrintOperationPreview

	// Cancel cancels a running print operation. This function may be called
	// from a PrintOperation::begin-print, PrintOperation::paginate or
	// PrintOperation::draw-page signal handler to stop the currently running
	// print operation.
	Cancel()
	// DrawPageFinish: signalize that drawing of particular page is complete.
	//
	// It is called after completion of page drawing (e.g. drawing in another
	// thread). If gtk_print_operation_set_defer_drawing() was called before,
	// then this function has to be called by application. In another case it is
	// called by the library itself.
	DrawPageFinish()
	// DefaultPageSetup returns the default page setup, see
	// gtk_print_operation_set_default_page_setup().
	DefaultPageSetup() PageSetup
	// EmbedPageSetup gets the value of PrintOperation:embed-page-setup
	// property.
	EmbedPageSetup() bool
	// Error: call this when the result of a print operation is
	// GTK_PRINT_OPERATION_RESULT_ERROR, either as returned by
	// gtk_print_operation_run(), or in the PrintOperation::done signal handler.
	// The returned #GError will contain more details on what went wrong.
	Error() error
	// HasSelection gets the value of PrintOperation:has-selection property.
	HasSelection() bool
	// NPagesToPrint returns the number of pages that will be printed.
	//
	// Note that this value is set during print preparation phase
	// (GTK_PRINT_STATUS_PREPARING), so this function should never be called
	// before the data generation phase (GTK_PRINT_STATUS_GENERATING_DATA). You
	// can connect to the PrintOperation::status-changed signal and call
	// gtk_print_operation_get_n_pages_to_print() when print status is
	// GTK_PRINT_STATUS_GENERATING_DATA. This is typically used to track the
	// progress of print operation.
	NPagesToPrint() int
	// PrintSettings returns the current print settings.
	//
	// Note that the return value is nil until either
	// gtk_print_operation_set_print_settings() or gtk_print_operation_run()
	// have been called.
	PrintSettings() PrintSettings
	// Status returns the status of the print operation. Also see
	// gtk_print_operation_get_status_string().
	Status() PrintStatus
	// StatusString returns a string representation of the status of the print
	// operation. The string is translated and suitable for displaying the print
	// status e.g. in a Statusbar.
	//
	// Use gtk_print_operation_get_status() to obtain a status value that is
	// suitable for programmatic use.
	StatusString() string
	// SupportSelection gets the value of PrintOperation:support-selection
	// property.
	SupportSelection() bool
	// IsFinished: a convenience function to find out if the print operation is
	// finished, either successfully (GTK_PRINT_STATUS_FINISHED) or
	// unsuccessfully (GTK_PRINT_STATUS_FINISHED_ABORTED).
	//
	// Note: when you enable print status tracking the print operation can be in
	// a non-finished state even after done has been called, as the operation
	// status then tracks the print job status on the printer.
	IsFinished() bool
	// Run runs the print operation, by first letting the user modify print
	// settings in the print dialog, and then print the document.
	//
	// Normally that this function does not return until the rendering of all
	// pages is complete. You can connect to the PrintOperation::status-changed
	// signal on @op to obtain some information about the progress of the print
	// operation. Furthermore, it may use a recursive mainloop to show the print
	// dialog.
	//
	// If you call gtk_print_operation_set_allow_async() or set the
	// PrintOperation:allow-async property the operation will run asynchronously
	// if this is supported on the platform. The PrintOperation::done signal
	// will be emitted with the result of the operation when the it is done
	// (i.e. when the dialog is canceled, or when the print succeeds or fails).
	//
	//    if (settings != NULL)
	//      gtk_print_operation_set_print_settings (print, settings);
	//
	//    if (page_setup != NULL)
	//      gtk_print_operation_set_default_page_setup (print, page_setup);
	//
	//    g_signal_connect (print, "begin-print",
	//                      G_CALLBACK (begin_print), &data);
	//    g_signal_connect (print, "draw-page",
	//                      G_CALLBACK (draw_page), &data);
	//
	//    res = gtk_print_operation_run (print,
	//                                   GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG,
	//                                   parent,
	//                                   &error);
	//
	//    if (res == GTK_PRINT_OPERATION_RESULT_ERROR)
	//     {
	//       error_dialog = gtk_message_dialog_new (GTK_WINDOW (parent),
	//      			                     GTK_DIALOG_DESTROY_WITH_PARENT,
	//    					     GTK_MESSAGE_ERROR,
	//    					     GTK_BUTTONS_CLOSE,
	//    					     "Error printing file:\ns",
	//    					     error->message);
	//       g_signal_connect (error_dialog, "response",
	//                         G_CALLBACK (gtk_widget_destroy), NULL);
	//       gtk_widget_show (error_dialog);
	//       g_error_free (error);
	//     }
	//    else if (res == GTK_PRINT_OPERATION_RESULT_APPLY)
	//     {
	//       if (settings != NULL)
	//    g_object_unref (settings);
	//       settings = g_object_ref (gtk_print_operation_get_print_settings (print));
	//     }
	//
	// Note that gtk_print_operation_run() can only be called once on a given
	// PrintOperation.
	Run(action PrintOperationAction, parent Window) (PrintOperationResult, error)
	// SetAllowAsync sets whether the gtk_print_operation_run() may return
	// before the print operation is completed. Note that some platforms may not
	// allow asynchronous operation.
	SetAllowAsync(allowAsync bool)
	// SetCurrentPage sets the current page.
	//
	// If this is called before gtk_print_operation_run(), the user will be able
	// to select to print only the current page.
	//
	// Note that this only makes sense for pre-paginated documents.
	SetCurrentPage(currentPage int)
	// SetCustomTabLabel sets the label for the tab holding custom widgets.
	SetCustomTabLabel(label string)
	// SetDefaultPageSetup makes @default_page_setup the default page setup for
	// @op.
	//
	// This page setup will be used by gtk_print_operation_run(), but it can be
	// overridden on a per-page basis by connecting to the
	// PrintOperation::request-page-setup signal.
	SetDefaultPageSetup(defaultPageSetup PageSetup)
	// SetDeferDrawing sets up the PrintOperation to wait for calling of
	// gtk_print_operation_draw_page_finish() from application. It can be used
	// for drawing page in another thread.
	//
	// This function must be called in the callback of “draw-page” signal.
	SetDeferDrawing()
	// SetEmbedPageSetup: embed page size combo box and orientation combo box
	// into page setup page. Selected page setup is stored as default page setup
	// in PrintOperation.
	SetEmbedPageSetup(embed bool)
	// SetExportFilename sets up the PrintOperation to generate a file instead
	// of showing the print dialog. The indended use of this function is for
	// implementing “Export to PDF” actions. Currently, PDF is the only
	// supported format.
	//
	// “Print to PDF” support is independent of this and is done by letting the
	// user pick the “Print to PDF” item from the list of printers in the print
	// dialog.
	SetExportFilename(filename string)
	// SetHasSelection sets whether there is a selection to print.
	//
	// Application has to set number of pages to which the selection will draw
	// by gtk_print_operation_set_n_pages() in a callback of
	// PrintOperation::begin-print.
	SetHasSelection(hasSelection bool)
	// SetJobName sets the name of the print job. The name is used to identify
	// the job (e.g. in monitoring applications like eggcups).
	//
	// If you don’t set a job name, GTK+ picks a default one by numbering
	// successive print jobs.
	SetJobName(jobName string)
	// SetNPages sets the number of pages in the document.
	//
	// This must be set to a positive number before the rendering starts. It may
	// be set in a PrintOperation::begin-print signal hander.
	//
	// Note that the page numbers passed to the
	// PrintOperation::request-page-setup and PrintOperation::draw-page signals
	// are 0-based, i.e. if the user chooses to print all pages, the last
	// ::draw-page signal will be for page @n_pages - 1.
	SetNPages(nPages int)
	// SetPrintSettings sets the print settings for @op. This is typically used
	// to re-establish print settings from a previous print operation, see
	// gtk_print_operation_run().
	SetPrintSettings(printSettings PrintSettings)
	// SetShowProgress: if @show_progress is true, the print operation will show
	// a progress dialog during the print operation.
	SetShowProgress(showProgress bool)
	// SetSupportSelection sets whether selection is supported by
	// PrintOperation.
	SetSupportSelection(supportSelection bool)
	// SetTrackPrintStatus: if track_status is true, the print operation will
	// try to continue report on the status of the print job in the printer
	// queues and printer. This can allow your application to show things like
	// “out of paper” issues, and when the print job actually reaches the
	// printer.
	//
	// This function is often implemented using some form of polling, so it
	// should not be enabled unless needed.
	SetTrackPrintStatus(trackStatus bool)
	// SetUnit sets up the transformation for the cairo context obtained from
	// PrintContext in such a way that distances are measured in units of @unit.
	SetUnit(unit Unit)
	// SetUseFullPage: if @full_page is true, the transformation for the cairo
	// context obtained from PrintContext puts the origin at the top left corner
	// of the page (which may not be the top left corner of the sheet, depending
	// on page orientation and the number of pages per sheet). Otherwise, the
	// origin is at the top left corner of the imageable area (i.e. inside the
	// margins).
	SetUseFullPage(fullPage bool)
}

// printOperation implements the PrintOperation class.
type printOperation struct {
	gextras.Objector
	PrintOperationPreview
}

var _ PrintOperation = (*printOperation)(nil)

// WrapPrintOperation wraps a GObject to the right type. It is
// primarily used internally.
func WrapPrintOperation(obj *externglib.Object) PrintOperation {
	return printOperation{
		Objector:              obj,
		PrintOperationPreview: WrapPrintOperationPreview(obj),
	}
}

func marshalPrintOperation(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPrintOperation(obj), nil
}

// NewPrintOperation creates a new PrintOperation.
func NewPrintOperation() PrintOperation {
	var _cret *C.GtkPrintOperation // in

	_cret = C.gtk_print_operation_new()

	var _printOperation PrintOperation // out

	_printOperation = WrapPrintOperation(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _printOperation
}

// Cancel cancels a running print operation. This function may be called from a
// PrintOperation::begin-print, PrintOperation::paginate or
// PrintOperation::draw-page signal handler to stop the currently running print
// operation.
func (o printOperation) Cancel() {
	var _arg0 *C.GtkPrintOperation // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	C.gtk_print_operation_cancel(_arg0)
}

// DrawPageFinish: signalize that drawing of particular page is complete.
//
// It is called after completion of page drawing (e.g. drawing in another
// thread). If gtk_print_operation_set_defer_drawing() was called before, then
// this function has to be called by application. In another case it is called
// by the library itself.
func (o printOperation) DrawPageFinish() {
	var _arg0 *C.GtkPrintOperation // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	C.gtk_print_operation_draw_page_finish(_arg0)
}

// DefaultPageSetup returns the default page setup, see
// gtk_print_operation_set_default_page_setup().
func (o printOperation) DefaultPageSetup() PageSetup {
	var _arg0 *C.GtkPrintOperation // out
	var _cret *C.GtkPageSetup      // in

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	_cret = C.gtk_print_operation_get_default_page_setup(_arg0)

	var _pageSetup PageSetup // out

	_pageSetup = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(PageSetup)

	return _pageSetup
}

// EmbedPageSetup gets the value of PrintOperation:embed-page-setup property.
func (o printOperation) EmbedPageSetup() bool {
	var _arg0 *C.GtkPrintOperation // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	_cret = C.gtk_print_operation_get_embed_page_setup(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Error: call this when the result of a print operation is
// GTK_PRINT_OPERATION_RESULT_ERROR, either as returned by
// gtk_print_operation_run(), or in the PrintOperation::done signal handler. The
// returned #GError will contain more details on what went wrong.
func (o printOperation) Error() error {
	var _arg0 *C.GtkPrintOperation // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	C.gtk_print_operation_get_error(_arg0, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// HasSelection gets the value of PrintOperation:has-selection property.
func (o printOperation) HasSelection() bool {
	var _arg0 *C.GtkPrintOperation // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	_cret = C.gtk_print_operation_get_has_selection(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NPagesToPrint returns the number of pages that will be printed.
//
// Note that this value is set during print preparation phase
// (GTK_PRINT_STATUS_PREPARING), so this function should never be called before
// the data generation phase (GTK_PRINT_STATUS_GENERATING_DATA). You can connect
// to the PrintOperation::status-changed signal and call
// gtk_print_operation_get_n_pages_to_print() when print status is
// GTK_PRINT_STATUS_GENERATING_DATA. This is typically used to track the
// progress of print operation.
func (o printOperation) NPagesToPrint() int {
	var _arg0 *C.GtkPrintOperation // out
	var _cret C.gint               // in

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	_cret = C.gtk_print_operation_get_n_pages_to_print(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// PrintSettings returns the current print settings.
//
// Note that the return value is nil until either
// gtk_print_operation_set_print_settings() or gtk_print_operation_run() have
// been called.
func (o printOperation) PrintSettings() PrintSettings {
	var _arg0 *C.GtkPrintOperation // out
	var _cret *C.GtkPrintSettings  // in

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	_cret = C.gtk_print_operation_get_print_settings(_arg0)

	var _printSettings PrintSettings // out

	_printSettings = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(PrintSettings)

	return _printSettings
}

// Status returns the status of the print operation. Also see
// gtk_print_operation_get_status_string().
func (o printOperation) Status() PrintStatus {
	var _arg0 *C.GtkPrintOperation // out
	var _cret C.GtkPrintStatus     // in

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	_cret = C.gtk_print_operation_get_status(_arg0)

	var _printStatus PrintStatus // out

	_printStatus = PrintStatus(_cret)

	return _printStatus
}

// StatusString returns a string representation of the status of the print
// operation. The string is translated and suitable for displaying the print
// status e.g. in a Statusbar.
//
// Use gtk_print_operation_get_status() to obtain a status value that is
// suitable for programmatic use.
func (o printOperation) StatusString() string {
	var _arg0 *C.GtkPrintOperation // out
	var _cret *C.gchar             // in

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	_cret = C.gtk_print_operation_get_status_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// SupportSelection gets the value of PrintOperation:support-selection property.
func (o printOperation) SupportSelection() bool {
	var _arg0 *C.GtkPrintOperation // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	_cret = C.gtk_print_operation_get_support_selection(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsFinished: a convenience function to find out if the print operation is
// finished, either successfully (GTK_PRINT_STATUS_FINISHED) or unsuccessfully
// (GTK_PRINT_STATUS_FINISHED_ABORTED).
//
// Note: when you enable print status tracking the print operation can be in a
// non-finished state even after done has been called, as the operation status
// then tracks the print job status on the printer.
func (o printOperation) IsFinished() bool {
	var _arg0 *C.GtkPrintOperation // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	_cret = C.gtk_print_operation_is_finished(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Run runs the print operation, by first letting the user modify print settings
// in the print dialog, and then print the document.
//
// Normally that this function does not return until the rendering of all pages
// is complete. You can connect to the PrintOperation::status-changed signal on
// @op to obtain some information about the progress of the print operation.
// Furthermore, it may use a recursive mainloop to show the print dialog.
//
// If you call gtk_print_operation_set_allow_async() or set the
// PrintOperation:allow-async property the operation will run asynchronously if
// this is supported on the platform. The PrintOperation::done signal will be
// emitted with the result of the operation when the it is done (i.e. when the
// dialog is canceled, or when the print succeeds or fails).
//
//    if (settings != NULL)
//      gtk_print_operation_set_print_settings (print, settings);
//
//    if (page_setup != NULL)
//      gtk_print_operation_set_default_page_setup (print, page_setup);
//
//    g_signal_connect (print, "begin-print",
//                      G_CALLBACK (begin_print), &data);
//    g_signal_connect (print, "draw-page",
//                      G_CALLBACK (draw_page), &data);
//
//    res = gtk_print_operation_run (print,
//                                   GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG,
//                                   parent,
//                                   &error);
//
//    if (res == GTK_PRINT_OPERATION_RESULT_ERROR)
//     {
//       error_dialog = gtk_message_dialog_new (GTK_WINDOW (parent),
//      			                     GTK_DIALOG_DESTROY_WITH_PARENT,
//    					     GTK_MESSAGE_ERROR,
//    					     GTK_BUTTONS_CLOSE,
//    					     "Error printing file:\ns",
//    					     error->message);
//       g_signal_connect (error_dialog, "response",
//                         G_CALLBACK (gtk_widget_destroy), NULL);
//       gtk_widget_show (error_dialog);
//       g_error_free (error);
//     }
//    else if (res == GTK_PRINT_OPERATION_RESULT_APPLY)
//     {
//       if (settings != NULL)
//    g_object_unref (settings);
//       settings = g_object_ref (gtk_print_operation_get_print_settings (print));
//     }
//
// Note that gtk_print_operation_run() can only be called once on a given
// PrintOperation.
func (o printOperation) Run(action PrintOperationAction, parent Window) (PrintOperationResult, error) {
	var _arg0 *C.GtkPrintOperation      // out
	var _arg1 C.GtkPrintOperationAction // out
	var _arg2 *C.GtkWindow              // out
	var _cret C.GtkPrintOperationResult // in
	var _cerr *C.GError                 // in

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	_arg1 = (C.GtkPrintOperationAction)(action)
	_arg2 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))

	_cret = C.gtk_print_operation_run(_arg0, _arg1, _arg2, &_cerr)

	var _printOperationResult PrintOperationResult // out
	var _goerr error                               // out

	_printOperationResult = PrintOperationResult(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _printOperationResult, _goerr
}

// SetAllowAsync sets whether the gtk_print_operation_run() may return before
// the print operation is completed. Note that some platforms may not allow
// asynchronous operation.
func (o printOperation) SetAllowAsync(allowAsync bool) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	if allowAsync {
		_arg1 = C.TRUE
	}

	C.gtk_print_operation_set_allow_async(_arg0, _arg1)
}

// SetCurrentPage sets the current page.
//
// If this is called before gtk_print_operation_run(), the user will be able to
// select to print only the current page.
//
// Note that this only makes sense for pre-paginated documents.
func (o printOperation) SetCurrentPage(currentPage int) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.gint               // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	_arg1 = (C.gint)(currentPage)

	C.gtk_print_operation_set_current_page(_arg0, _arg1)
}

// SetCustomTabLabel sets the label for the tab holding custom widgets.
func (o printOperation) SetCustomTabLabel(label string) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 *C.gchar             // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_operation_set_custom_tab_label(_arg0, _arg1)
}

// SetDefaultPageSetup makes @default_page_setup the default page setup for @op.
//
// This page setup will be used by gtk_print_operation_run(), but it can be
// overridden on a per-page basis by connecting to the
// PrintOperation::request-page-setup signal.
func (o printOperation) SetDefaultPageSetup(defaultPageSetup PageSetup) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 *C.GtkPageSetup      // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.GtkPageSetup)(unsafe.Pointer(defaultPageSetup.Native()))

	C.gtk_print_operation_set_default_page_setup(_arg0, _arg1)
}

// SetDeferDrawing sets up the PrintOperation to wait for calling of
// gtk_print_operation_draw_page_finish() from application. It can be used for
// drawing page in another thread.
//
// This function must be called in the callback of “draw-page” signal.
func (o printOperation) SetDeferDrawing() {
	var _arg0 *C.GtkPrintOperation // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	C.gtk_print_operation_set_defer_drawing(_arg0)
}

// SetEmbedPageSetup: embed page size combo box and orientation combo box into
// page setup page. Selected page setup is stored as default page setup in
// PrintOperation.
func (o printOperation) SetEmbedPageSetup(embed bool) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	if embed {
		_arg1 = C.TRUE
	}

	C.gtk_print_operation_set_embed_page_setup(_arg0, _arg1)
}

// SetExportFilename sets up the PrintOperation to generate a file instead of
// showing the print dialog. The indended use of this function is for
// implementing “Export to PDF” actions. Currently, PDF is the only supported
// format.
//
// “Print to PDF” support is independent of this and is done by letting the user
// pick the “Print to PDF” item from the list of printers in the print dialog.
func (o printOperation) SetExportFilename(filename string) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 *C.gchar             // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_operation_set_export_filename(_arg0, _arg1)
}

// SetHasSelection sets whether there is a selection to print.
//
// Application has to set number of pages to which the selection will draw by
// gtk_print_operation_set_n_pages() in a callback of
// PrintOperation::begin-print.
func (o printOperation) SetHasSelection(hasSelection bool) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	if hasSelection {
		_arg1 = C.TRUE
	}

	C.gtk_print_operation_set_has_selection(_arg0, _arg1)
}

// SetJobName sets the name of the print job. The name is used to identify the
// job (e.g. in monitoring applications like eggcups).
//
// If you don’t set a job name, GTK+ picks a default one by numbering successive
// print jobs.
func (o printOperation) SetJobName(jobName string) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 *C.gchar             // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.gchar)(C.CString(jobName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_operation_set_job_name(_arg0, _arg1)
}

// SetNPages sets the number of pages in the document.
//
// This must be set to a positive number before the rendering starts. It may be
// set in a PrintOperation::begin-print signal hander.
//
// Note that the page numbers passed to the PrintOperation::request-page-setup
// and PrintOperation::draw-page signals are 0-based, i.e. if the user chooses
// to print all pages, the last ::draw-page signal will be for page @n_pages -
// 1.
func (o printOperation) SetNPages(nPages int) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.gint               // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	_arg1 = (C.gint)(nPages)

	C.gtk_print_operation_set_n_pages(_arg0, _arg1)
}

// SetPrintSettings sets the print settings for @op. This is typically used to
// re-establish print settings from a previous print operation, see
// gtk_print_operation_run().
func (o printOperation) SetPrintSettings(printSettings PrintSettings) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 *C.GtkPrintSettings  // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.GtkPrintSettings)(unsafe.Pointer(printSettings.Native()))

	C.gtk_print_operation_set_print_settings(_arg0, _arg1)
}

// SetShowProgress: if @show_progress is true, the print operation will show a
// progress dialog during the print operation.
func (o printOperation) SetShowProgress(showProgress bool) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	if showProgress {
		_arg1 = C.TRUE
	}

	C.gtk_print_operation_set_show_progress(_arg0, _arg1)
}

// SetSupportSelection sets whether selection is supported by PrintOperation.
func (o printOperation) SetSupportSelection(supportSelection bool) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	if supportSelection {
		_arg1 = C.TRUE
	}

	C.gtk_print_operation_set_support_selection(_arg0, _arg1)
}

// SetTrackPrintStatus: if track_status is true, the print operation will try to
// continue report on the status of the print job in the printer queues and
// printer. This can allow your application to show things like “out of paper”
// issues, and when the print job actually reaches the printer.
//
// This function is often implemented using some form of polling, so it should
// not be enabled unless needed.
func (o printOperation) SetTrackPrintStatus(trackStatus bool) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	if trackStatus {
		_arg1 = C.TRUE
	}

	C.gtk_print_operation_set_track_print_status(_arg0, _arg1)
}

// SetUnit sets up the transformation for the cairo context obtained from
// PrintContext in such a way that distances are measured in units of @unit.
func (o printOperation) SetUnit(unit Unit) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.GtkUnit            // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	_arg1 = (C.GtkUnit)(unit)

	C.gtk_print_operation_set_unit(_arg0, _arg1)
}

// SetUseFullPage: if @full_page is true, the transformation for the cairo
// context obtained from PrintContext puts the origin at the top left corner of
// the page (which may not be the top left corner of the sheet, depending on
// page orientation and the number of pages per sheet). Otherwise, the origin is
// at the top left corner of the imageable area (i.e. inside the margins).
func (o printOperation) SetUseFullPage(fullPage bool) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	if fullPage {
		_arg1 = C.TRUE
	}

	C.gtk_print_operation_set_use_full_page(_arg0, _arg1)
}

// PrintSettings: a GtkPrintSettings object represents the settings of a print
// dialog in a system-independent way. The main use for this object is that once
// you’ve printed you can get a settings object that represents the settings the
// user chose, and the next time you print you can pass that object in so that
// the user doesn’t have to re-set all his settings.
//
// Its also possible to enumerate the settings so that you can easily save the
// settings for the next time your app runs, or even store them in a document.
// The predefined keys try to use shared values as much as possible so that
// moving such a document between systems still works.
//
// Printing support was added in GTK+ 2.10.
type PrintSettings interface {
	gextras.Objector

	// Copy copies a PrintSettings object.
	Copy() PrintSettings
	// Get looks up the string value associated with @key.
	Get(key string) string
	// Bool returns the boolean represented by the value that is associated with
	// @key.
	//
	// The string “true” represents true, any other string false.
	Bool(key string) bool
	// Collate gets the value of GTK_PRINT_SETTINGS_COLLATE.
	Collate() bool
	// DefaultSource gets the value of GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
	DefaultSource() string
	// Dither gets the value of GTK_PRINT_SETTINGS_DITHER.
	Dither() string
	// Double returns the double value associated with @key, or 0.
	Double(key string) float64
	// DoubleWithDefault returns the floating point number represented by the
	// value that is associated with @key, or @default_val if the value does not
	// represent a floating point number.
	//
	// Floating point numbers are parsed with g_ascii_strtod().
	DoubleWithDefault(key string, def float64) float64
	// Duplex gets the value of GTK_PRINT_SETTINGS_DUPLEX.
	Duplex() PrintDuplex
	// Finishings gets the value of GTK_PRINT_SETTINGS_FINISHINGS.
	Finishings() string
	// Int returns the integer value of @key, or 0.
	Int(key string) int
	// IntWithDefault returns the value of @key, interpreted as an integer, or
	// the default value.
	IntWithDefault(key string, def int) int
	// Length returns the value associated with @key, interpreted as a length.
	// The returned value is converted to @units.
	Length(key string, unit Unit) float64
	// MediaType gets the value of GTK_PRINT_SETTINGS_MEDIA_TYPE.
	//
	// The set of media types is defined in PWG 5101.1-2002 PWG.
	MediaType() string
	// NCopies gets the value of GTK_PRINT_SETTINGS_N_COPIES.
	NCopies() int
	// NumberUp gets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
	NumberUp() int
	// NumberUpLayout gets the value of GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT.
	NumberUpLayout() NumberUpLayout
	// Orientation: get the value of GTK_PRINT_SETTINGS_ORIENTATION, converted
	// to a PageOrientation.
	Orientation() PageOrientation
	// OutputBin gets the value of GTK_PRINT_SETTINGS_OUTPUT_BIN.
	OutputBin() string
	// PageSet gets the value of GTK_PRINT_SETTINGS_PAGE_SET.
	PageSet() PageSet
	// PaperHeight gets the value of GTK_PRINT_SETTINGS_PAPER_HEIGHT, converted
	// to @unit.
	PaperHeight(unit Unit) float64
	// PaperSize gets the value of GTK_PRINT_SETTINGS_PAPER_FORMAT, converted to
	// a PaperSize.
	PaperSize() *PaperSize
	// PaperWidth gets the value of GTK_PRINT_SETTINGS_PAPER_WIDTH, converted to
	// @unit.
	PaperWidth(unit Unit) float64
	// PrintPages gets the value of GTK_PRINT_SETTINGS_PRINT_PAGES.
	PrintPages() PrintPages
	// Printer: convenience function to obtain the value of
	// GTK_PRINT_SETTINGS_PRINTER.
	Printer() string
	// PrinterLpi gets the value of GTK_PRINT_SETTINGS_PRINTER_LPI.
	PrinterLpi() float64
	// Quality gets the value of GTK_PRINT_SETTINGS_QUALITY.
	Quality() PrintQuality
	// Resolution gets the value of GTK_PRINT_SETTINGS_RESOLUTION.
	Resolution() int
	// ResolutionX gets the value of GTK_PRINT_SETTINGS_RESOLUTION_X.
	ResolutionX() int
	// ResolutionY gets the value of GTK_PRINT_SETTINGS_RESOLUTION_Y.
	ResolutionY() int
	// Reverse gets the value of GTK_PRINT_SETTINGS_REVERSE.
	Reverse() bool
	// Scale gets the value of GTK_PRINT_SETTINGS_SCALE.
	Scale() float64
	// UseColor gets the value of GTK_PRINT_SETTINGS_USE_COLOR.
	UseColor() bool
	// HasKey returns true, if a value is associated with @key.
	HasKey(key string) bool
	// LoadFile reads the print settings from @file_name. If the file could not
	// be loaded then error is set to either a Error or FileError. See
	// gtk_print_settings_to_file().
	LoadFile(fileName string) error
	// LoadKeyFile reads the print settings from the group @group_name in
	// @key_file. If the file could not be loaded then error is set to either a
	// Error or FileError.
	LoadKeyFile(keyFile *glib.KeyFile, groupName string) error
	// Set associates @value with @key.
	Set(key string, value string)
	// SetBool sets @key to a boolean value.
	SetBool(key string, value bool)
	// SetCollate sets the value of GTK_PRINT_SETTINGS_COLLATE.
	SetCollate(collate bool)
	// SetDefaultSource sets the value of GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
	SetDefaultSource(defaultSource string)
	// SetDither sets the value of GTK_PRINT_SETTINGS_DITHER.
	SetDither(dither string)
	// SetDouble sets @key to a double value.
	SetDouble(key string, value float64)
	// SetDuplex sets the value of GTK_PRINT_SETTINGS_DUPLEX.
	SetDuplex(duplex PrintDuplex)
	// SetFinishings sets the value of GTK_PRINT_SETTINGS_FINISHINGS.
	SetFinishings(finishings string)
	// SetInt sets @key to an integer value.
	SetInt(key string, value int)
	// SetLength associates a length in units of @unit with @key.
	SetLength(key string, value float64, unit Unit)
	// SetMediaType sets the value of GTK_PRINT_SETTINGS_MEDIA_TYPE.
	//
	// The set of media types is defined in PWG 5101.1-2002 PWG.
	SetMediaType(mediaType string)
	// SetNCopies sets the value of GTK_PRINT_SETTINGS_N_COPIES.
	SetNCopies(numCopies int)
	// SetNumberUp sets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
	SetNumberUp(numberUp int)
	// SetNumberUpLayout sets the value of GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT.
	SetNumberUpLayout(numberUpLayout NumberUpLayout)
	// SetOrientation sets the value of GTK_PRINT_SETTINGS_ORIENTATION.
	SetOrientation(orientation PageOrientation)
	// SetOutputBin sets the value of GTK_PRINT_SETTINGS_OUTPUT_BIN.
	SetOutputBin(outputBin string)
	// SetPageRanges sets the value of GTK_PRINT_SETTINGS_PAGE_RANGES.
	SetPageRanges(pageRanges []PageRange)
	// SetPageSet sets the value of GTK_PRINT_SETTINGS_PAGE_SET.
	SetPageSet(pageSet PageSet)
	// SetPaperHeight sets the value of GTK_PRINT_SETTINGS_PAPER_HEIGHT.
	SetPaperHeight(height float64, unit Unit)
	// SetPaperSize sets the value of GTK_PRINT_SETTINGS_PAPER_FORMAT,
	// GTK_PRINT_SETTINGS_PAPER_WIDTH and GTK_PRINT_SETTINGS_PAPER_HEIGHT.
	SetPaperSize(paperSize *PaperSize)
	// SetPaperWidth sets the value of GTK_PRINT_SETTINGS_PAPER_WIDTH.
	SetPaperWidth(width float64, unit Unit)
	// SetPrintPages sets the value of GTK_PRINT_SETTINGS_PRINT_PAGES.
	SetPrintPages(pages PrintPages)
	// SetPrinter: convenience function to set GTK_PRINT_SETTINGS_PRINTER to
	// @printer.
	SetPrinter(printer string)
	// SetPrinterLpi sets the value of GTK_PRINT_SETTINGS_PRINTER_LPI.
	SetPrinterLpi(lpi float64)
	// SetQuality sets the value of GTK_PRINT_SETTINGS_QUALITY.
	SetQuality(quality PrintQuality)
	// SetResolution sets the values of GTK_PRINT_SETTINGS_RESOLUTION,
	// GTK_PRINT_SETTINGS_RESOLUTION_X and GTK_PRINT_SETTINGS_RESOLUTION_Y.
	SetResolution(resolution int)
	// SetResolutionXY sets the values of GTK_PRINT_SETTINGS_RESOLUTION,
	// GTK_PRINT_SETTINGS_RESOLUTION_X and GTK_PRINT_SETTINGS_RESOLUTION_Y.
	SetResolutionXY(resolutionX int, resolutionY int)
	// SetReverse sets the value of GTK_PRINT_SETTINGS_REVERSE.
	SetReverse(reverse bool)
	// SetScale sets the value of GTK_PRINT_SETTINGS_SCALE.
	SetScale(scale float64)
	// SetUseColor sets the value of GTK_PRINT_SETTINGS_USE_COLOR.
	SetUseColor(useColor bool)
	// ToFile: this function saves the print settings from @settings to
	// @file_name. If the file could not be loaded then error is set to either a
	// Error or FileError.
	ToFile(fileName string) error
	// ToGVariant: serialize print settings to an a{sv} variant.
	ToGVariant() *glib.Variant
	// ToKeyFile: this function adds the print settings from @settings to
	// @key_file.
	ToKeyFile(keyFile *glib.KeyFile, groupName string)
	// Unset removes any value associated with @key. This has the same effect as
	// setting the value to nil.
	Unset(key string)
}

// printSettings implements the PrintSettings class.
type printSettings struct {
	gextras.Objector
}

var _ PrintSettings = (*printSettings)(nil)

// WrapPrintSettings wraps a GObject to the right type. It is
// primarily used internally.
func WrapPrintSettings(obj *externglib.Object) PrintSettings {
	return printSettings{
		Objector: obj,
	}
}

func marshalPrintSettings(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPrintSettings(obj), nil
}

// NewPrintSettings creates a new PrintSettings object.
func NewPrintSettings() PrintSettings {
	var _cret *C.GtkPrintSettings // in

	_cret = C.gtk_print_settings_new()

	var _printSettings PrintSettings // out

	_printSettings = WrapPrintSettings(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _printSettings
}

// NewPrintSettingsFromFile reads the print settings from @file_name. Returns a
// new PrintSettings object with the restored settings, or nil if an error
// occurred. If the file could not be loaded then error is set to either a Error
// or FileError. See gtk_print_settings_to_file().
func NewPrintSettingsFromFile(fileName string) (PrintSettings, error) {
	var _arg1 *C.gchar            // out
	var _cret *C.GtkPrintSettings // in
	var _cerr *C.GError           // in

	_arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_print_settings_new_from_file(_arg1, &_cerr)

	var _printSettings PrintSettings // out
	var _goerr error                 // out

	_printSettings = WrapPrintSettings(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _printSettings, _goerr
}

// NewPrintSettingsFromGVariant: deserialize print settings from an a{sv}
// variant in the format produced by gtk_print_settings_to_gvariant().
func NewPrintSettingsFromGVariant(variant *glib.Variant) PrintSettings {
	var _arg1 *C.GVariant         // out
	var _cret *C.GtkPrintSettings // in

	_arg1 = (*C.GVariant)(unsafe.Pointer(variant.Native()))

	_cret = C.gtk_print_settings_new_from_gvariant(_arg1)

	var _printSettings PrintSettings // out

	_printSettings = WrapPrintSettings(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _printSettings
}

// NewPrintSettingsFromKeyFile reads the print settings from the group
// @group_name in @key_file. Returns a new PrintSettings object with the
// restored settings, or nil if an error occurred. If the file could not be
// loaded then error is set to either a Error or FileError.
func NewPrintSettingsFromKeyFile(keyFile *glib.KeyFile, groupName string) (PrintSettings, error) {
	var _arg1 *C.GKeyFile         // out
	var _arg2 *C.gchar            // out
	var _cret *C.GtkPrintSettings // in
	var _cerr *C.GError           // in

	_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
	_arg2 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_print_settings_new_from_key_file(_arg1, _arg2, &_cerr)

	var _printSettings PrintSettings // out
	var _goerr error                 // out

	_printSettings = WrapPrintSettings(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _printSettings, _goerr
}

// Copy copies a PrintSettings object.
func (o printSettings) Copy() PrintSettings {
	var _arg0 *C.GtkPrintSettings // out
	var _cret *C.GtkPrintSettings // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(o.Native()))

	_cret = C.gtk_print_settings_copy(_arg0)

	var _printSettings PrintSettings // out

	_printSettings = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(PrintSettings)

	return _printSettings
}

// Get looks up the string value associated with @key.
func (s printSettings) Get(key string) string {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.gchar            // out
	var _cret *C.gchar            // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_print_settings_get(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Bool returns the boolean represented by the value that is associated with
// @key.
//
// The string “true” represents true, any other string false.
func (s printSettings) Bool(key string) bool {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.gchar            // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_print_settings_get_bool(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Collate gets the value of GTK_PRINT_SETTINGS_COLLATE.
func (s printSettings) Collate() bool {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_collate(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DefaultSource gets the value of GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
func (s printSettings) DefaultSource() string {
	var _arg0 *C.GtkPrintSettings // out
	var _cret *C.gchar            // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_default_source(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Dither gets the value of GTK_PRINT_SETTINGS_DITHER.
func (s printSettings) Dither() string {
	var _arg0 *C.GtkPrintSettings // out
	var _cret *C.gchar            // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_dither(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Double returns the double value associated with @key, or 0.
func (s printSettings) Double(key string) float64 {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.gchar            // out
	var _cret C.gdouble           // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_print_settings_get_double(_arg0, _arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// DoubleWithDefault returns the floating point number represented by the value
// that is associated with @key, or @default_val if the value does not represent
// a floating point number.
//
// Floating point numbers are parsed with g_ascii_strtod().
func (s printSettings) DoubleWithDefault(key string, def float64) float64 {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.gchar            // out
	var _arg2 C.gdouble           // out
	var _cret C.gdouble           // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gdouble)(def)

	_cret = C.gtk_print_settings_get_double_with_default(_arg0, _arg1, _arg2)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// Duplex gets the value of GTK_PRINT_SETTINGS_DUPLEX.
func (s printSettings) Duplex() PrintDuplex {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.GtkPrintDuplex    // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_duplex(_arg0)

	var _printDuplex PrintDuplex // out

	_printDuplex = PrintDuplex(_cret)

	return _printDuplex
}

// Finishings gets the value of GTK_PRINT_SETTINGS_FINISHINGS.
func (s printSettings) Finishings() string {
	var _arg0 *C.GtkPrintSettings // out
	var _cret *C.gchar            // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_finishings(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Int returns the integer value of @key, or 0.
func (s printSettings) Int(key string) int {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.gchar            // out
	var _cret C.gint              // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_print_settings_get_int(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// IntWithDefault returns the value of @key, interpreted as an integer, or the
// default value.
func (s printSettings) IntWithDefault(key string, def int) int {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.gchar            // out
	var _arg2 C.gint              // out
	var _cret C.gint              // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gint)(def)

	_cret = C.gtk_print_settings_get_int_with_default(_arg0, _arg1, _arg2)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Length returns the value associated with @key, interpreted as a length. The
// returned value is converted to @units.
func (s printSettings) Length(key string, unit Unit) float64 {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.gchar            // out
	var _arg2 C.GtkUnit           // out
	var _cret C.gdouble           // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GtkUnit)(unit)

	_cret = C.gtk_print_settings_get_length(_arg0, _arg1, _arg2)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// MediaType gets the value of GTK_PRINT_SETTINGS_MEDIA_TYPE.
//
// The set of media types is defined in PWG 5101.1-2002 PWG.
func (s printSettings) MediaType() string {
	var _arg0 *C.GtkPrintSettings // out
	var _cret *C.gchar            // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_media_type(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// NCopies gets the value of GTK_PRINT_SETTINGS_N_COPIES.
func (s printSettings) NCopies() int {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.gint              // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_n_copies(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// NumberUp gets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
func (s printSettings) NumberUp() int {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.gint              // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_number_up(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// NumberUpLayout gets the value of GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT.
func (s printSettings) NumberUpLayout() NumberUpLayout {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.GtkNumberUpLayout // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_number_up_layout(_arg0)

	var _numberUpLayout NumberUpLayout // out

	_numberUpLayout = NumberUpLayout(_cret)

	return _numberUpLayout
}

// Orientation: get the value of GTK_PRINT_SETTINGS_ORIENTATION, converted to a
// PageOrientation.
func (s printSettings) Orientation() PageOrientation {
	var _arg0 *C.GtkPrintSettings  // out
	var _cret C.GtkPageOrientation // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_orientation(_arg0)

	var _pageOrientation PageOrientation // out

	_pageOrientation = PageOrientation(_cret)

	return _pageOrientation
}

// OutputBin gets the value of GTK_PRINT_SETTINGS_OUTPUT_BIN.
func (s printSettings) OutputBin() string {
	var _arg0 *C.GtkPrintSettings // out
	var _cret *C.gchar            // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_output_bin(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// PageSet gets the value of GTK_PRINT_SETTINGS_PAGE_SET.
func (s printSettings) PageSet() PageSet {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.GtkPageSet        // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_page_set(_arg0)

	var _pageSet PageSet // out

	_pageSet = PageSet(_cret)

	return _pageSet
}

// PaperHeight gets the value of GTK_PRINT_SETTINGS_PAPER_HEIGHT, converted to
// @unit.
func (s printSettings) PaperHeight(unit Unit) float64 {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.GtkUnit           // out
	var _cret C.gdouble           // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	_cret = C.gtk_print_settings_get_paper_height(_arg0, _arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// PaperSize gets the value of GTK_PRINT_SETTINGS_PAPER_FORMAT, converted to a
// PaperSize.
func (s printSettings) PaperSize() *PaperSize {
	var _arg0 *C.GtkPrintSettings // out
	var _cret *C.GtkPaperSize     // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_paper_size(_arg0)

	var _paperSize *PaperSize // out

	_paperSize = WrapPaperSize(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_paperSize, func(v *PaperSize) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _paperSize
}

// PaperWidth gets the value of GTK_PRINT_SETTINGS_PAPER_WIDTH, converted to
// @unit.
func (s printSettings) PaperWidth(unit Unit) float64 {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.GtkUnit           // out
	var _cret C.gdouble           // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	_cret = C.gtk_print_settings_get_paper_width(_arg0, _arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// PrintPages gets the value of GTK_PRINT_SETTINGS_PRINT_PAGES.
func (s printSettings) PrintPages() PrintPages {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.GtkPrintPages     // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_print_pages(_arg0)

	var _printPages PrintPages // out

	_printPages = PrintPages(_cret)

	return _printPages
}

// Printer: convenience function to obtain the value of
// GTK_PRINT_SETTINGS_PRINTER.
func (s printSettings) Printer() string {
	var _arg0 *C.GtkPrintSettings // out
	var _cret *C.gchar            // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_printer(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// PrinterLpi gets the value of GTK_PRINT_SETTINGS_PRINTER_LPI.
func (s printSettings) PrinterLpi() float64 {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.gdouble           // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_printer_lpi(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// Quality gets the value of GTK_PRINT_SETTINGS_QUALITY.
func (s printSettings) Quality() PrintQuality {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.GtkPrintQuality   // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_quality(_arg0)

	var _printQuality PrintQuality // out

	_printQuality = PrintQuality(_cret)

	return _printQuality
}

// Resolution gets the value of GTK_PRINT_SETTINGS_RESOLUTION.
func (s printSettings) Resolution() int {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.gint              // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_resolution(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// ResolutionX gets the value of GTK_PRINT_SETTINGS_RESOLUTION_X.
func (s printSettings) ResolutionX() int {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.gint              // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_resolution_x(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// ResolutionY gets the value of GTK_PRINT_SETTINGS_RESOLUTION_Y.
func (s printSettings) ResolutionY() int {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.gint              // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_resolution_y(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Reverse gets the value of GTK_PRINT_SETTINGS_REVERSE.
func (s printSettings) Reverse() bool {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_reverse(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Scale gets the value of GTK_PRINT_SETTINGS_SCALE.
func (s printSettings) Scale() float64 {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.gdouble           // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_scale(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// UseColor gets the value of GTK_PRINT_SETTINGS_USE_COLOR.
func (s printSettings) UseColor() bool {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_get_use_color(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasKey returns true, if a value is associated with @key.
func (s printSettings) HasKey(key string) bool {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.gchar            // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_print_settings_has_key(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LoadFile reads the print settings from @file_name. If the file could not be
// loaded then error is set to either a Error or FileError. See
// gtk_print_settings_to_file().
func (s printSettings) LoadFile(fileName string) error {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.gchar            // out
	var _cerr *C.GError           // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_settings_load_file(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// LoadKeyFile reads the print settings from the group @group_name in @key_file.
// If the file could not be loaded then error is set to either a Error or
// FileError.
func (s printSettings) LoadKeyFile(keyFile *glib.KeyFile, groupName string) error {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.GKeyFile         // out
	var _arg2 *C.gchar            // out
	var _cerr *C.GError           // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
	_arg2 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_print_settings_load_key_file(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// Set associates @value with @key.
func (s printSettings) Set(key string, value string) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.gchar            // out
	var _arg2 *C.gchar            // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_print_settings_set(_arg0, _arg1, _arg2)
}

// SetBool sets @key to a boolean value.
func (s printSettings) SetBool(key string, value bool) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.gchar            // out
	var _arg2 C.gboolean          // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	if value {
		_arg2 = C.TRUE
	}

	C.gtk_print_settings_set_bool(_arg0, _arg1, _arg2)
}

// SetCollate sets the value of GTK_PRINT_SETTINGS_COLLATE.
func (s printSettings) SetCollate(collate bool) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	if collate {
		_arg1 = C.TRUE
	}

	C.gtk_print_settings_set_collate(_arg0, _arg1)
}

// SetDefaultSource sets the value of GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
func (s printSettings) SetDefaultSource(defaultSource string) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.gchar            // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(defaultSource))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_settings_set_default_source(_arg0, _arg1)
}

// SetDither sets the value of GTK_PRINT_SETTINGS_DITHER.
func (s printSettings) SetDither(dither string) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.gchar            // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(dither))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_settings_set_dither(_arg0, _arg1)
}

// SetDouble sets @key to a double value.
func (s printSettings) SetDouble(key string, value float64) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.gchar            // out
	var _arg2 C.gdouble           // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gdouble)(value)

	C.gtk_print_settings_set_double(_arg0, _arg1, _arg2)
}

// SetDuplex sets the value of GTK_PRINT_SETTINGS_DUPLEX.
func (s printSettings) SetDuplex(duplex PrintDuplex) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.GtkPrintDuplex    // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkPrintDuplex)(duplex)

	C.gtk_print_settings_set_duplex(_arg0, _arg1)
}

// SetFinishings sets the value of GTK_PRINT_SETTINGS_FINISHINGS.
func (s printSettings) SetFinishings(finishings string) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.gchar            // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(finishings))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_settings_set_finishings(_arg0, _arg1)
}

// SetInt sets @key to an integer value.
func (s printSettings) SetInt(key string, value int) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.gchar            // out
	var _arg2 C.gint              // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gint)(value)

	C.gtk_print_settings_set_int(_arg0, _arg1, _arg2)
}

// SetLength associates a length in units of @unit with @key.
func (s printSettings) SetLength(key string, value float64, unit Unit) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.gchar            // out
	var _arg2 C.gdouble           // out
	var _arg3 C.GtkUnit           // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gdouble)(value)
	_arg3 = (C.GtkUnit)(unit)

	C.gtk_print_settings_set_length(_arg0, _arg1, _arg2, _arg3)
}

// SetMediaType sets the value of GTK_PRINT_SETTINGS_MEDIA_TYPE.
//
// The set of media types is defined in PWG 5101.1-2002 PWG.
func (s printSettings) SetMediaType(mediaType string) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.gchar            // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(mediaType))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_settings_set_media_type(_arg0, _arg1)
}

// SetNCopies sets the value of GTK_PRINT_SETTINGS_N_COPIES.
func (s printSettings) SetNCopies(numCopies int) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.gint              // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gint)(numCopies)

	C.gtk_print_settings_set_n_copies(_arg0, _arg1)
}

// SetNumberUp sets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
func (s printSettings) SetNumberUp(numberUp int) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.gint              // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gint)(numberUp)

	C.gtk_print_settings_set_number_up(_arg0, _arg1)
}

// SetNumberUpLayout sets the value of GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT.
func (s printSettings) SetNumberUpLayout(numberUpLayout NumberUpLayout) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.GtkNumberUpLayout // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkNumberUpLayout)(numberUpLayout)

	C.gtk_print_settings_set_number_up_layout(_arg0, _arg1)
}

// SetOrientation sets the value of GTK_PRINT_SETTINGS_ORIENTATION.
func (s printSettings) SetOrientation(orientation PageOrientation) {
	var _arg0 *C.GtkPrintSettings  // out
	var _arg1 C.GtkPageOrientation // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkPageOrientation)(orientation)

	C.gtk_print_settings_set_orientation(_arg0, _arg1)
}

// SetOutputBin sets the value of GTK_PRINT_SETTINGS_OUTPUT_BIN.
func (s printSettings) SetOutputBin(outputBin string) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.gchar            // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(outputBin))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_settings_set_output_bin(_arg0, _arg1)
}

// SetPageRanges sets the value of GTK_PRINT_SETTINGS_PAGE_RANGES.
func (s printSettings) SetPageRanges(pageRanges []PageRange) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.GtkPageRange
	var _arg2 C.gint

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg2 = C.gint(len(pageRanges))
	_arg1 = (*C.GtkPageRange)(unsafe.Pointer(&pageRanges[0]))

	C.gtk_print_settings_set_page_ranges(_arg0, _arg1, _arg2)
}

// SetPageSet sets the value of GTK_PRINT_SETTINGS_PAGE_SET.
func (s printSettings) SetPageSet(pageSet PageSet) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.GtkPageSet        // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkPageSet)(pageSet)

	C.gtk_print_settings_set_page_set(_arg0, _arg1)
}

// SetPaperHeight sets the value of GTK_PRINT_SETTINGS_PAPER_HEIGHT.
func (s printSettings) SetPaperHeight(height float64, unit Unit) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.gdouble           // out
	var _arg2 C.GtkUnit           // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gdouble)(height)
	_arg2 = (C.GtkUnit)(unit)

	C.gtk_print_settings_set_paper_height(_arg0, _arg1, _arg2)
}

// SetPaperSize sets the value of GTK_PRINT_SETTINGS_PAPER_FORMAT,
// GTK_PRINT_SETTINGS_PAPER_WIDTH and GTK_PRINT_SETTINGS_PAPER_HEIGHT.
func (s printSettings) SetPaperSize(paperSize *PaperSize) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.GtkPaperSize     // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkPaperSize)(unsafe.Pointer(paperSize.Native()))

	C.gtk_print_settings_set_paper_size(_arg0, _arg1)
}

// SetPaperWidth sets the value of GTK_PRINT_SETTINGS_PAPER_WIDTH.
func (s printSettings) SetPaperWidth(width float64, unit Unit) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.gdouble           // out
	var _arg2 C.GtkUnit           // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gdouble)(width)
	_arg2 = (C.GtkUnit)(unit)

	C.gtk_print_settings_set_paper_width(_arg0, _arg1, _arg2)
}

// SetPrintPages sets the value of GTK_PRINT_SETTINGS_PRINT_PAGES.
func (s printSettings) SetPrintPages(pages PrintPages) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.GtkPrintPages     // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkPrintPages)(pages)

	C.gtk_print_settings_set_print_pages(_arg0, _arg1)
}

// SetPrinter: convenience function to set GTK_PRINT_SETTINGS_PRINTER to
// @printer.
func (s printSettings) SetPrinter(printer string) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.gchar            // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(printer))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_settings_set_printer(_arg0, _arg1)
}

// SetPrinterLpi sets the value of GTK_PRINT_SETTINGS_PRINTER_LPI.
func (s printSettings) SetPrinterLpi(lpi float64) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.gdouble           // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gdouble)(lpi)

	C.gtk_print_settings_set_printer_lpi(_arg0, _arg1)
}

// SetQuality sets the value of GTK_PRINT_SETTINGS_QUALITY.
func (s printSettings) SetQuality(quality PrintQuality) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.GtkPrintQuality   // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkPrintQuality)(quality)

	C.gtk_print_settings_set_quality(_arg0, _arg1)
}

// SetResolution sets the values of GTK_PRINT_SETTINGS_RESOLUTION,
// GTK_PRINT_SETTINGS_RESOLUTION_X and GTK_PRINT_SETTINGS_RESOLUTION_Y.
func (s printSettings) SetResolution(resolution int) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.gint              // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gint)(resolution)

	C.gtk_print_settings_set_resolution(_arg0, _arg1)
}

// SetResolutionXY sets the values of GTK_PRINT_SETTINGS_RESOLUTION,
// GTK_PRINT_SETTINGS_RESOLUTION_X and GTK_PRINT_SETTINGS_RESOLUTION_Y.
func (s printSettings) SetResolutionXY(resolutionX int, resolutionY int) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.gint              // out
	var _arg2 C.gint              // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gint)(resolutionX)
	_arg2 = (C.gint)(resolutionY)

	C.gtk_print_settings_set_resolution_xy(_arg0, _arg1, _arg2)
}

// SetReverse sets the value of GTK_PRINT_SETTINGS_REVERSE.
func (s printSettings) SetReverse(reverse bool) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	if reverse {
		_arg1 = C.TRUE
	}

	C.gtk_print_settings_set_reverse(_arg0, _arg1)
}

// SetScale sets the value of GTK_PRINT_SETTINGS_SCALE.
func (s printSettings) SetScale(scale float64) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.gdouble           // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gdouble)(scale)

	C.gtk_print_settings_set_scale(_arg0, _arg1)
}

// SetUseColor sets the value of GTK_PRINT_SETTINGS_USE_COLOR.
func (s printSettings) SetUseColor(useColor bool) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	if useColor {
		_arg1 = C.TRUE
	}

	C.gtk_print_settings_set_use_color(_arg0, _arg1)
}

// ToFile: this function saves the print settings from @settings to @file_name.
// If the file could not be loaded then error is set to either a Error or
// FileError.
func (s printSettings) ToFile(fileName string) error {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.gchar            // out
	var _cerr *C.GError           // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_settings_to_file(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// ToGVariant: serialize print settings to an a{sv} variant.
func (s printSettings) ToGVariant() *glib.Variant {
	var _arg0 *C.GtkPrintSettings // out
	var _cret *C.GVariant         // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_print_settings_to_gvariant(_arg0)

	var _variant *glib.Variant // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// ToKeyFile: this function adds the print settings from @settings to @key_file.
func (s printSettings) ToKeyFile(keyFile *glib.KeyFile, groupName string) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.GKeyFile         // out
	var _arg2 *C.gchar            // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
	_arg2 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_print_settings_to_key_file(_arg0, _arg1, _arg2)
}

// Unset removes any value associated with @key. This has the same effect as
// setting the value to nil.
func (s printSettings) Unset(key string) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.gchar            // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_settings_unset(_arg0, _arg1)
}

// ProgressBar: the ProgressBar is typically used to display the progress of a
// long running operation. It provides a visual clue that processing is
// underway. The GtkProgressBar can be used in two different modes: percentage
// mode and activity mode.
//
// When an application can determine how much work needs to take place (e.g.
// read a fixed number of bytes from a file) and can monitor its progress, it
// can use the GtkProgressBar in percentage mode and the user sees a growing bar
// indicating the percentage of the work that has been completed. In this mode,
// the application is required to call gtk_progress_bar_set_fraction()
// periodically to update the progress bar.
//
// When an application has no accurate way of knowing the amount of work to do,
// it can use the ProgressBar in activity mode, which shows activity by a block
// moving back and forth within the progress area. In this mode, the application
// is required to call gtk_progress_bar_pulse() periodically to update the
// progress bar.
//
// There is quite a bit of flexibility provided to control the appearance of the
// ProgressBar. Functions are provided to control the orientation of the bar,
// optional text can be displayed along with the bar, and the step size used in
// activity mode can be set.
//
// CSS nodes
//
//    progressbar[.osd]
//    ├── [text]
//    ╰── trough[.empty][.full]
//        ╰── progress[.pulse]
//
// GtkProgressBar has a main CSS node with name progressbar and subnodes with
// names text and trough, of which the latter has a subnode named progress. The
// text subnode is only present if text is shown. The progress subnode has the
// style class .pulse when in activity mode. It gets the style classes .left,
// .right, .top or .bottom added when the progress 'touches' the corresponding
// end of the GtkProgressBar. The .osd class on the progressbar node is for use
// in overlays like the one Epiphany has for page loading progress.
type ProgressBar interface {
	Widget
	Buildable
	Orientable

	// Ellipsize returns the ellipsizing position of the progress bar. See
	// gtk_progress_bar_set_ellipsize().
	Ellipsize() pango.EllipsizeMode
	// Fraction returns the current fraction of the task that’s been completed.
	Fraction() float64
	// Inverted gets the value set by gtk_progress_bar_set_inverted().
	Inverted() bool
	// PulseStep retrieves the pulse step set with
	// gtk_progress_bar_set_pulse_step().
	PulseStep() float64
	// ShowText gets the value of the ProgressBar:show-text property. See
	// gtk_progress_bar_set_show_text().
	ShowText() bool
	// Text retrieves the text that is displayed with the progress bar, if any,
	// otherwise nil. The return value is a reference to the text, not a copy of
	// it, so will become invalid if you change the text in the progress bar.
	Text() string
	// Pulse indicates that some progress has been made, but you don’t know how
	// much. Causes the progress bar to enter “activity mode,” where a block
	// bounces back and forth. Each call to gtk_progress_bar_pulse() causes the
	// block to move by a little bit (the amount of movement per pulse is
	// determined by gtk_progress_bar_set_pulse_step()).
	Pulse()
	// SetEllipsize sets the mode used to ellipsize (add an ellipsis: "...") the
	// text if there is not enough space to render the entire string.
	SetEllipsize(mode pango.EllipsizeMode)
	// SetFraction causes the progress bar to “fill in” the given fraction of
	// the bar. The fraction should be between 0.0 and 1.0, inclusive.
	SetFraction(fraction float64)
	// SetInverted progress bars normally grow from top to bottom or left to
	// right. Inverted progress bars grow in the opposite direction.
	SetInverted(inverted bool)
	// SetPulseStep sets the fraction of total progress bar length to move the
	// bouncing block for each call to gtk_progress_bar_pulse().
	SetPulseStep(fraction float64)
	// SetShowText sets whether the progress bar will show text next to the bar.
	// The shown text is either the value of the ProgressBar:text property or,
	// if that is nil, the ProgressBar:fraction value, as a percentage.
	//
	// To make a progress bar that is styled and sized suitably for containing
	// text (even if the actual text is blank), set ProgressBar:show-text to
	// true and ProgressBar:text to the empty string (not nil).
	SetShowText(showText bool)
	// SetText causes the given @text to appear next to the progress bar.
	//
	// If @text is nil and ProgressBar:show-text is true, the current value of
	// ProgressBar:fraction will be displayed as a percentage.
	//
	// If @text is non-nil and ProgressBar:show-text is true, the text will be
	// displayed. In this case, it will not display the progress percentage. If
	// @text is the empty string, the progress bar will still be styled and
	// sized suitably for containing text, as long as ProgressBar:show-text is
	// true.
	SetText(text string)
}

// progressBar implements the ProgressBar class.
type progressBar struct {
	Widget
	Buildable
	Orientable
}

var _ ProgressBar = (*progressBar)(nil)

// WrapProgressBar wraps a GObject to the right type. It is
// primarily used internally.
func WrapProgressBar(obj *externglib.Object) ProgressBar {
	return progressBar{
		Widget:     WrapWidget(obj),
		Buildable:  WrapBuildable(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalProgressBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapProgressBar(obj), nil
}

// NewProgressBar creates a new ProgressBar.
func NewProgressBar() ProgressBar {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_progress_bar_new()

	var _progressBar ProgressBar // out

	_progressBar = WrapProgressBar(externglib.Take(unsafe.Pointer(_cret)))

	return _progressBar
}

// Ellipsize returns the ellipsizing position of the progress bar. See
// gtk_progress_bar_set_ellipsize().
func (p progressBar) Ellipsize() pango.EllipsizeMode {
	var _arg0 *C.GtkProgressBar    // out
	var _cret C.PangoEllipsizeMode // in

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_progress_bar_get_ellipsize(_arg0)

	var _ellipsizeMode pango.EllipsizeMode // out

	_ellipsizeMode = pango.EllipsizeMode(_cret)

	return _ellipsizeMode
}

// Fraction returns the current fraction of the task that’s been completed.
func (p progressBar) Fraction() float64 {
	var _arg0 *C.GtkProgressBar // out
	var _cret C.gdouble         // in

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_progress_bar_get_fraction(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// Inverted gets the value set by gtk_progress_bar_set_inverted().
func (p progressBar) Inverted() bool {
	var _arg0 *C.GtkProgressBar // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_progress_bar_get_inverted(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PulseStep retrieves the pulse step set with
// gtk_progress_bar_set_pulse_step().
func (p progressBar) PulseStep() float64 {
	var _arg0 *C.GtkProgressBar // out
	var _cret C.gdouble         // in

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_progress_bar_get_pulse_step(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// ShowText gets the value of the ProgressBar:show-text property. See
// gtk_progress_bar_set_show_text().
func (p progressBar) ShowText() bool {
	var _arg0 *C.GtkProgressBar // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_progress_bar_get_show_text(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Text retrieves the text that is displayed with the progress bar, if any,
// otherwise nil. The return value is a reference to the text, not a copy of it,
// so will become invalid if you change the text in the progress bar.
func (p progressBar) Text() string {
	var _arg0 *C.GtkProgressBar // out
	var _cret *C.gchar          // in

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_progress_bar_get_text(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Pulse indicates that some progress has been made, but you don’t know how
// much. Causes the progress bar to enter “activity mode,” where a block bounces
// back and forth. Each call to gtk_progress_bar_pulse() causes the block to
// move by a little bit (the amount of movement per pulse is determined by
// gtk_progress_bar_set_pulse_step()).
func (p progressBar) Pulse() {
	var _arg0 *C.GtkProgressBar // out

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

	C.gtk_progress_bar_pulse(_arg0)
}

// SetEllipsize sets the mode used to ellipsize (add an ellipsis: "...") the
// text if there is not enough space to render the entire string.
func (p progressBar) SetEllipsize(mode pango.EllipsizeMode) {
	var _arg0 *C.GtkProgressBar    // out
	var _arg1 C.PangoEllipsizeMode // out

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))
	_arg1 = (C.PangoEllipsizeMode)(mode)

	C.gtk_progress_bar_set_ellipsize(_arg0, _arg1)
}

// SetFraction causes the progress bar to “fill in” the given fraction of the
// bar. The fraction should be between 0.0 and 1.0, inclusive.
func (p progressBar) SetFraction(fraction float64) {
	var _arg0 *C.GtkProgressBar // out
	var _arg1 C.gdouble         // out

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))
	_arg1 = (C.gdouble)(fraction)

	C.gtk_progress_bar_set_fraction(_arg0, _arg1)
}

// SetInverted progress bars normally grow from top to bottom or left to right.
// Inverted progress bars grow in the opposite direction.
func (p progressBar) SetInverted(inverted bool) {
	var _arg0 *C.GtkProgressBar // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))
	if inverted {
		_arg1 = C.TRUE
	}

	C.gtk_progress_bar_set_inverted(_arg0, _arg1)
}

// SetPulseStep sets the fraction of total progress bar length to move the
// bouncing block for each call to gtk_progress_bar_pulse().
func (p progressBar) SetPulseStep(fraction float64) {
	var _arg0 *C.GtkProgressBar // out
	var _arg1 C.gdouble         // out

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))
	_arg1 = (C.gdouble)(fraction)

	C.gtk_progress_bar_set_pulse_step(_arg0, _arg1)
}

// SetShowText sets whether the progress bar will show text next to the bar. The
// shown text is either the value of the ProgressBar:text property or, if that
// is nil, the ProgressBar:fraction value, as a percentage.
//
// To make a progress bar that is styled and sized suitably for containing text
// (even if the actual text is blank), set ProgressBar:show-text to true and
// ProgressBar:text to the empty string (not nil).
func (p progressBar) SetShowText(showText bool) {
	var _arg0 *C.GtkProgressBar // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))
	if showText {
		_arg1 = C.TRUE
	}

	C.gtk_progress_bar_set_show_text(_arg0, _arg1)
}

// SetText causes the given @text to appear next to the progress bar.
//
// If @text is nil and ProgressBar:show-text is true, the current value of
// ProgressBar:fraction will be displayed as a percentage.
//
// If @text is non-nil and ProgressBar:show-text is true, the text will be
// displayed. In this case, it will not display the progress percentage. If
// @text is the empty string, the progress bar will still be styled and sized
// suitably for containing text, as long as ProgressBar:show-text is true.
func (p progressBar) SetText(text string) {
	var _arg0 *C.GtkProgressBar // out
	var _arg1 *C.gchar          // out

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_progress_bar_set_text(_arg0, _arg1)
}

type ProgressBarAccessible interface {
	WidgetAccessible
}

// progressBarAccessible implements the ProgressBarAccessible class.
type progressBarAccessible struct {
	WidgetAccessible
}

var _ ProgressBarAccessible = (*progressBarAccessible)(nil)

// WrapProgressBarAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapProgressBarAccessible(obj *externglib.Object) ProgressBarAccessible {
	return progressBarAccessible{
		WidgetAccessible: WrapWidgetAccessible(obj),
	}
}

func marshalProgressBarAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapProgressBarAccessible(obj), nil
}

// RadioAction: a RadioAction is similar to RadioMenuItem. A number of radio
// actions can be linked together so that only one may be active at any one
// time.
type RadioAction interface {
	ToggleAction
	Buildable

	// CurrentValue obtains the value property of the currently active member of
	// the group to which @action belongs.
	CurrentValue() int
	// JoinGroup joins a radio action object to the group of another radio
	// action object.
	//
	// Use this in language bindings instead of the gtk_radio_action_get_group()
	// and gtk_radio_action_set_group() methods
	//
	// A common way to set up a group of radio actions is the following:
	//
	//     GtkRadioAction *action;
	//     GtkRadioAction *last_action;
	//
	//     while ( ...more actions to add... /)
	//       {
	//          action = gtk_radio_action_new (...);
	//
	//          gtk_radio_action_join_group (action, last_action);
	//          last_action = action;
	//       }
	JoinGroup(groupSource RadioAction)
	// SetCurrentValue sets the currently active group member to the member with
	// value property @current_value.
	SetCurrentValue(currentValue int)
}

// radioAction implements the RadioAction class.
type radioAction struct {
	ToggleAction
	Buildable
}

var _ RadioAction = (*radioAction)(nil)

// WrapRadioAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapRadioAction(obj *externglib.Object) RadioAction {
	return radioAction{
		ToggleAction: WrapToggleAction(obj),
		Buildable:    WrapBuildable(obj),
	}
}

func marshalRadioAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRadioAction(obj), nil
}

// NewRadioAction creates a new RadioAction object. To add the action to a
// ActionGroup and set the accelerator for the action, call
// gtk_action_group_add_action_with_accel().
func NewRadioAction(name string, label string, tooltip string, stockId string, value int) RadioAction {
	var _arg1 *C.gchar          // out
	var _arg2 *C.gchar          // out
	var _arg3 *C.gchar          // out
	var _arg4 *C.gchar          // out
	var _arg5 C.gint            // out
	var _cret *C.GtkRadioAction // in

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(tooltip))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(C.CString(stockId))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (C.gint)(value)

	_cret = C.gtk_radio_action_new(_arg1, _arg2, _arg3, _arg4, _arg5)

	var _radioAction RadioAction // out

	_radioAction = WrapRadioAction(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _radioAction
}

// CurrentValue obtains the value property of the currently active member of the
// group to which @action belongs.
func (a radioAction) CurrentValue() int {
	var _arg0 *C.GtkRadioAction // out
	var _cret C.gint            // in

	_arg0 = (*C.GtkRadioAction)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_radio_action_get_current_value(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// JoinGroup joins a radio action object to the group of another radio action
// object.
//
// Use this in language bindings instead of the gtk_radio_action_get_group() and
// gtk_radio_action_set_group() methods
//
// A common way to set up a group of radio actions is the following:
//
//     GtkRadioAction *action;
//     GtkRadioAction *last_action;
//
//     while ( ...more actions to add... /)
//       {
//          action = gtk_radio_action_new (...);
//
//          gtk_radio_action_join_group (action, last_action);
//          last_action = action;
//       }
func (a radioAction) JoinGroup(groupSource RadioAction) {
	var _arg0 *C.GtkRadioAction // out
	var _arg1 *C.GtkRadioAction // out

	_arg0 = (*C.GtkRadioAction)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkRadioAction)(unsafe.Pointer(groupSource.Native()))

	C.gtk_radio_action_join_group(_arg0, _arg1)
}

// SetCurrentValue sets the currently active group member to the member with
// value property @current_value.
func (a radioAction) SetCurrentValue(currentValue int) {
	var _arg0 *C.GtkRadioAction // out
	var _arg1 C.gint            // out

	_arg0 = (*C.GtkRadioAction)(unsafe.Pointer(a.Native()))
	_arg1 = (C.gint)(currentValue)

	C.gtk_radio_action_set_current_value(_arg0, _arg1)
}

// RadioButton: a single radio button performs the same basic function as a
// CheckButton, as its position in the object hierarchy reflects. It is only
// when multiple radio buttons are grouped together that they become a different
// user interface component in their own right.
//
// Every radio button is a member of some group of radio buttons. When one is
// selected, all other radio buttons in the same group are deselected. A
// RadioButton is one way of giving the user a choice from many options.
//
// Radio button widgets are created with gtk_radio_button_new(), passing nil as
// the argument if this is the first radio button in a group. In subsequent
// calls, the group you wish to add this button to should be passed as an
// argument. Optionally, gtk_radio_button_new_with_label() can be used if you
// want a text label on the radio button.
//
// Alternatively, when adding widgets to an existing group of radio buttons, use
// gtk_radio_button_new_from_widget() with a RadioButton that already has a
// group assigned to it. The convenience function
// gtk_radio_button_new_with_label_from_widget() is also provided.
//
// To retrieve the group a RadioButton is assigned to, use
// gtk_radio_button_get_group().
//
// To remove a RadioButton from one group and make it part of a new one, use
// gtk_radio_button_set_group().
//
// The group list does not need to be freed, as each RadioButton will remove
// itself and its list item when it is destroyed.
//
// CSS nodes
//
//    void create_radio_buttons (void) {
//
//       GtkWidget *window, *radio1, *radio2, *box, *entry;
//       window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
//       box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 2);
//       gtk_box_set_homogeneous (GTK_BOX (box), TRUE);
//
//       // Create a radio button with a GtkEntry widget
//       radio1 = gtk_radio_button_new (NULL);
//       entry = gtk_entry_new ();
//       gtk_container_add (GTK_CONTAINER (radio1), entry);
//
//
//       // Create a radio button with a label
//       radio2 = gtk_radio_button_new_with_label_from_widget (GTK_RADIO_BUTTON (radio1),
//                                                             "I’m the second radio button.");
//
//       // Pack them into a box, then show all the widgets
//       gtk_box_pack_start (GTK_BOX (box), radio1);
//       gtk_box_pack_start (GTK_BOX (box), radio2);
//       gtk_container_add (GTK_CONTAINER (window), box);
//       gtk_widget_show_all (window);
//       return;
//    }
//
// When an unselected button in the group is clicked the clicked button receives
// the ToggleButton::toggled signal, as does the previously selected button.
// Inside the ToggleButton::toggled handler, gtk_toggle_button_get_active() can
// be used to determine if the button has been selected or deselected.
type RadioButton interface {
	CheckButton
	Actionable
	Activatable
	Buildable

	// JoinGroup joins a RadioButton object to the group of another RadioButton
	// object
	//
	// Use this in language bindings instead of the gtk_radio_button_get_group()
	// and gtk_radio_button_set_group() methods
	//
	// A common way to set up a group of radio buttons is the following:
	//
	//      GtkRadioButton *radio_button;
	//      GtkRadioButton *last_button;
	//
	//      while (some_condition)
	//        {
	//           radio_button = gtk_radio_button_new (NULL);
	//
	//           gtk_radio_button_join_group (radio_button, last_button);
	//           last_button = radio_button;
	//        }
	JoinGroup(groupSource RadioButton)
}

// radioButton implements the RadioButton class.
type radioButton struct {
	CheckButton
	Actionable
	Activatable
	Buildable
}

var _ RadioButton = (*radioButton)(nil)

// WrapRadioButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapRadioButton(obj *externglib.Object) RadioButton {
	return radioButton{
		CheckButton: WrapCheckButton(obj),
		Actionable:  WrapActionable(obj),
		Activatable: WrapActivatable(obj),
		Buildable:   WrapBuildable(obj),
	}
}

func marshalRadioButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRadioButton(obj), nil
}

// NewRadioButtonFromWidget creates a new RadioButton, adding it to the same
// group as @radio_group_member. As with gtk_radio_button_new(), a widget should
// be packed into the radio button.
func NewRadioButtonFromWidget(radioGroupMember RadioButton) RadioButton {
	var _arg1 *C.GtkRadioButton // out
	var _cret *C.GtkWidget      // in

	_arg1 = (*C.GtkRadioButton)(unsafe.Pointer(radioGroupMember.Native()))

	_cret = C.gtk_radio_button_new_from_widget(_arg1)

	var _radioButton RadioButton // out

	_radioButton = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RadioButton)

	return _radioButton
}

// NewRadioButtonWithLabelFromWidget creates a new RadioButton with a text
// label, adding it to the same group as @radio_group_member.
func NewRadioButtonWithLabelFromWidget(radioGroupMember RadioButton, label string) RadioButton {
	var _arg1 *C.GtkRadioButton // out
	var _arg2 *C.gchar          // out
	var _cret *C.GtkWidget      // in

	_arg1 = (*C.GtkRadioButton)(unsafe.Pointer(radioGroupMember.Native()))
	_arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_radio_button_new_with_label_from_widget(_arg1, _arg2)

	var _radioButton RadioButton // out

	_radioButton = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RadioButton)

	return _radioButton
}

// NewRadioButtonWithMnemonicFromWidget creates a new RadioButton containing a
// label. The label will be created using gtk_label_new_with_mnemonic(), so
// underscores in @label indicate the mnemonic for the button.
func NewRadioButtonWithMnemonicFromWidget(radioGroupMember RadioButton, label string) RadioButton {
	var _arg1 *C.GtkRadioButton // out
	var _arg2 *C.gchar          // out
	var _cret *C.GtkWidget      // in

	_arg1 = (*C.GtkRadioButton)(unsafe.Pointer(radioGroupMember.Native()))
	_arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_radio_button_new_with_mnemonic_from_widget(_arg1, _arg2)

	var _radioButton RadioButton // out

	_radioButton = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RadioButton)

	return _radioButton
}

// JoinGroup joins a RadioButton object to the group of another RadioButton
// object
//
// Use this in language bindings instead of the gtk_radio_button_get_group() and
// gtk_radio_button_set_group() methods
//
// A common way to set up a group of radio buttons is the following:
//
//      GtkRadioButton *radio_button;
//      GtkRadioButton *last_button;
//
//      while (some_condition)
//        {
//           radio_button = gtk_radio_button_new (NULL);
//
//           gtk_radio_button_join_group (radio_button, last_button);
//           last_button = radio_button;
//        }
func (r radioButton) JoinGroup(groupSource RadioButton) {
	var _arg0 *C.GtkRadioButton // out
	var _arg1 *C.GtkRadioButton // out

	_arg0 = (*C.GtkRadioButton)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.GtkRadioButton)(unsafe.Pointer(groupSource.Native()))

	C.gtk_radio_button_join_group(_arg0, _arg1)
}

type RadioButtonAccessible interface {
	ToggleButtonAccessible
}

// radioButtonAccessible implements the RadioButtonAccessible class.
type radioButtonAccessible struct {
	ToggleButtonAccessible
}

var _ RadioButtonAccessible = (*radioButtonAccessible)(nil)

// WrapRadioButtonAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapRadioButtonAccessible(obj *externglib.Object) RadioButtonAccessible {
	return radioButtonAccessible{
		ToggleButtonAccessible: WrapToggleButtonAccessible(obj),
	}
}

func marshalRadioButtonAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRadioButtonAccessible(obj), nil
}

// RadioMenuItem: a radio menu item is a check menu item that belongs to a
// group. At each instant exactly one of the radio menu items from a group is
// selected.
//
// The group list does not need to be freed, as each RadioMenuItem will remove
// itself and its list item when it is destroyed.
//
// The correct way to create a group of radio menu items is approximatively
// this:
//
// How to create a group of radio menu items.
//
//    menuitem
//    ├── radio.left
//    ╰── <child>
//
// GtkRadioMenuItem has a main CSS node with name menuitem, and a subnode with
// name radio, which gets the .left or .right style class.
type RadioMenuItem interface {
	CheckMenuItem
	Actionable
	Activatable
	Buildable

	// JoinGroup joins a RadioMenuItem object to the group of another
	// RadioMenuItem object.
	//
	// This function should be used by language bindings to avoid the memory
	// manangement of the opaque List of gtk_radio_menu_item_get_group() and
	// gtk_radio_menu_item_set_group().
	//
	// A common way to set up a group of RadioMenuItem instances is:
	//
	//      GtkRadioMenuItem *last_item = NULL;
	//
	//      while ( ...more items to add... )
	//        {
	//          GtkRadioMenuItem *radio_item;
	//
	//          radio_item = gtk_radio_menu_item_new (...);
	//
	//          gtk_radio_menu_item_join_group (radio_item, last_item);
	//          last_item = radio_item;
	//        }
	JoinGroup(groupSource RadioMenuItem)
}

// radioMenuItem implements the RadioMenuItem class.
type radioMenuItem struct {
	CheckMenuItem
	Actionable
	Activatable
	Buildable
}

var _ RadioMenuItem = (*radioMenuItem)(nil)

// WrapRadioMenuItem wraps a GObject to the right type. It is
// primarily used internally.
func WrapRadioMenuItem(obj *externglib.Object) RadioMenuItem {
	return radioMenuItem{
		CheckMenuItem: WrapCheckMenuItem(obj),
		Actionable:    WrapActionable(obj),
		Activatable:   WrapActivatable(obj),
		Buildable:     WrapBuildable(obj),
	}
}

func marshalRadioMenuItem(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRadioMenuItem(obj), nil
}

// NewRadioMenuItemFromWidget creates a new RadioMenuItem adding it to the same
// group as @group.
func NewRadioMenuItemFromWidget(group RadioMenuItem) RadioMenuItem {
	var _arg1 *C.GtkRadioMenuItem // out
	var _cret *C.GtkWidget        // in

	_arg1 = (*C.GtkRadioMenuItem)(unsafe.Pointer(group.Native()))

	_cret = C.gtk_radio_menu_item_new_from_widget(_arg1)

	var _radioMenuItem RadioMenuItem // out

	_radioMenuItem = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RadioMenuItem)

	return _radioMenuItem
}

// NewRadioMenuItemWithLabelFromWidget creates a new GtkRadioMenuItem whose
// child is a simple GtkLabel. The new RadioMenuItem is added to the same group
// as @group.
func NewRadioMenuItemWithLabelFromWidget(group RadioMenuItem, label string) RadioMenuItem {
	var _arg1 *C.GtkRadioMenuItem // out
	var _arg2 *C.gchar            // out
	var _cret *C.GtkWidget        // in

	_arg1 = (*C.GtkRadioMenuItem)(unsafe.Pointer(group.Native()))
	_arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_radio_menu_item_new_with_label_from_widget(_arg1, _arg2)

	var _radioMenuItem RadioMenuItem // out

	_radioMenuItem = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RadioMenuItem)

	return _radioMenuItem
}

// NewRadioMenuItemWithMnemonicFromWidget creates a new GtkRadioMenuItem
// containing a label. The label will be created using
// gtk_label_new_with_mnemonic(), so underscores in label indicate the mnemonic
// for the menu item.
//
// The new RadioMenuItem is added to the same group as @group.
func NewRadioMenuItemWithMnemonicFromWidget(group RadioMenuItem, label string) RadioMenuItem {
	var _arg1 *C.GtkRadioMenuItem // out
	var _arg2 *C.gchar            // out
	var _cret *C.GtkWidget        // in

	_arg1 = (*C.GtkRadioMenuItem)(unsafe.Pointer(group.Native()))
	_arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_radio_menu_item_new_with_mnemonic_from_widget(_arg1, _arg2)

	var _radioMenuItem RadioMenuItem // out

	_radioMenuItem = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RadioMenuItem)

	return _radioMenuItem
}

// JoinGroup joins a RadioMenuItem object to the group of another RadioMenuItem
// object.
//
// This function should be used by language bindings to avoid the memory
// manangement of the opaque List of gtk_radio_menu_item_get_group() and
// gtk_radio_menu_item_set_group().
//
// A common way to set up a group of RadioMenuItem instances is:
//
//      GtkRadioMenuItem *last_item = NULL;
//
//      while ( ...more items to add... )
//        {
//          GtkRadioMenuItem *radio_item;
//
//          radio_item = gtk_radio_menu_item_new (...);
//
//          gtk_radio_menu_item_join_group (radio_item, last_item);
//          last_item = radio_item;
//        }
func (r radioMenuItem) JoinGroup(groupSource RadioMenuItem) {
	var _arg0 *C.GtkRadioMenuItem // out
	var _arg1 *C.GtkRadioMenuItem // out

	_arg0 = (*C.GtkRadioMenuItem)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.GtkRadioMenuItem)(unsafe.Pointer(groupSource.Native()))

	C.gtk_radio_menu_item_join_group(_arg0, _arg1)
}

type RadioMenuItemAccessible interface {
	CheckMenuItemAccessible
}

// radioMenuItemAccessible implements the RadioMenuItemAccessible class.
type radioMenuItemAccessible struct {
	CheckMenuItemAccessible
}

var _ RadioMenuItemAccessible = (*radioMenuItemAccessible)(nil)

// WrapRadioMenuItemAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapRadioMenuItemAccessible(obj *externglib.Object) RadioMenuItemAccessible {
	return radioMenuItemAccessible{
		CheckMenuItemAccessible: WrapCheckMenuItemAccessible(obj),
	}
}

func marshalRadioMenuItemAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRadioMenuItemAccessible(obj), nil
}

// RadioToolButton: a RadioToolButton is a ToolItem that contains a radio
// button, that is, a button that is part of a group of toggle buttons where
// only one button can be active at a time.
//
// Use gtk_radio_tool_button_new() to create a new GtkRadioToolButton. Use
// gtk_radio_tool_button_new_from_widget() to create a new GtkRadioToolButton
// that is part of the same group as an existing GtkRadioToolButton.
//
//
// CSS nodes
//
// GtkRadioToolButton has a single CSS node with name toolbutton.
type RadioToolButton interface {
	ToggleToolButton
	Actionable
	Activatable
	Buildable
}

// radioToolButton implements the RadioToolButton class.
type radioToolButton struct {
	ToggleToolButton
	Actionable
	Activatable
	Buildable
}

var _ RadioToolButton = (*radioToolButton)(nil)

// WrapRadioToolButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapRadioToolButton(obj *externglib.Object) RadioToolButton {
	return radioToolButton{
		ToggleToolButton: WrapToggleToolButton(obj),
		Actionable:       WrapActionable(obj),
		Activatable:      WrapActivatable(obj),
		Buildable:        WrapBuildable(obj),
	}
}

func marshalRadioToolButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRadioToolButton(obj), nil
}

// NewRadioToolButtonFromWidget creates a new RadioToolButton adding it to the
// same group as @gruup
func NewRadioToolButtonFromWidget(group RadioToolButton) RadioToolButton {
	var _arg1 *C.GtkRadioToolButton // out
	var _cret *C.GtkToolItem        // in

	_arg1 = (*C.GtkRadioToolButton)(unsafe.Pointer(group.Native()))

	_cret = C.gtk_radio_tool_button_new_from_widget(_arg1)

	var _radioToolButton RadioToolButton // out

	_radioToolButton = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RadioToolButton)

	return _radioToolButton
}

// NewRadioToolButtonWithStockFromWidget creates a new RadioToolButton adding it
// to the same group as @group. The new RadioToolButton will contain an icon and
// label from the stock item indicated by @stock_id.
func NewRadioToolButtonWithStockFromWidget(group RadioToolButton, stockId string) RadioToolButton {
	var _arg1 *C.GtkRadioToolButton // out
	var _arg2 *C.gchar              // out
	var _cret *C.GtkToolItem        // in

	_arg1 = (*C.GtkRadioToolButton)(unsafe.Pointer(group.Native()))
	_arg2 = (*C.gchar)(C.CString(stockId))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_radio_tool_button_new_with_stock_from_widget(_arg1, _arg2)

	var _radioToolButton RadioToolButton // out

	_radioToolButton = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RadioToolButton)

	return _radioToolButton
}

// Range is the common base class for widgets which visualize an adjustment, e.g
// Scale or Scrollbar.
//
// Apart from signals for monitoring the parameters of the adjustment, Range
// provides properties and methods for influencing the sensitivity of the
// “steppers”. It also provides properties and methods for setting a “fill
// level” on range widgets. See gtk_range_set_fill_level().
type Range interface {
	Widget
	Buildable
	Orientable

	// Adjustment: get the Adjustment which is the “model” object for Range. See
	// gtk_range_set_adjustment() for details. The return value does not have a
	// reference added, so should not be unreferenced.
	Adjustment() Adjustment
	// FillLevel gets the current position of the fill level indicator.
	FillLevel() float64
	// Flippable gets the value set by gtk_range_set_flippable().
	Flippable() bool
	// Inverted gets the value set by gtk_range_set_inverted().
	Inverted() bool
	// LowerStepperSensitivity gets the sensitivity policy for the stepper that
	// points to the 'lower' end of the GtkRange’s adjustment.
	LowerStepperSensitivity() SensitivityType
	// MinSliderSize: this function is useful mainly for Range subclasses.
	//
	// See gtk_range_set_min_slider_size().
	MinSliderSize() int
	// RangeRect: this function returns the area that contains the range’s
	// trough and its steppers, in widget->window coordinates.
	//
	// This function is useful mainly for Range subclasses.
	RangeRect() gdk.Rectangle
	// RestrictToFillLevel gets whether the range is restricted to the fill
	// level.
	RestrictToFillLevel() bool
	// RoundDigits gets the number of digits to round the value to when it
	// changes. See Range::change-value.
	RoundDigits() int
	// ShowFillLevel gets whether the range displays the fill level graphically.
	ShowFillLevel() bool
	// SliderRange: this function returns sliders range along the long
	// dimension, in widget->window coordinates.
	//
	// This function is useful mainly for Range subclasses.
	SliderRange() (sliderStart int, sliderEnd int)
	// SliderSizeFixed: this function is useful mainly for Range subclasses.
	//
	// See gtk_range_set_slider_size_fixed().
	SliderSizeFixed() bool
	// UpperStepperSensitivity gets the sensitivity policy for the stepper that
	// points to the 'upper' end of the GtkRange’s adjustment.
	UpperStepperSensitivity() SensitivityType
	// Value gets the current value of the range.
	Value() float64
	// SetAdjustment sets the adjustment to be used as the “model” object for
	// this range widget. The adjustment indicates the current range value, the
	// minimum and maximum range values, the step/page increments used for
	// keybindings and scrolling, and the page size. The page size is normally 0
	// for Scale and nonzero for Scrollbar, and indicates the size of the
	// visible area of the widget being scrolled. The page size affects the size
	// of the scrollbar slider.
	SetAdjustment(adjustment Adjustment)
	// SetFillLevel: set the new position of the fill level indicator.
	//
	// The “fill level” is probably best described by its most prominent use
	// case, which is an indicator for the amount of pre-buffering in a
	// streaming media player. In that use case, the value of the range would
	// indicate the current play position, and the fill level would be the
	// position up to which the file/stream has been downloaded.
	//
	// This amount of prebuffering can be displayed on the range’s trough and is
	// themeable separately from the trough. To enable fill level display, use
	// gtk_range_set_show_fill_level(). The range defaults to not showing the
	// fill level.
	//
	// Additionally, it’s possible to restrict the range’s slider position to
	// values which are smaller than the fill level. This is controller by
	// gtk_range_set_restrict_to_fill_level() and is by default enabled.
	SetFillLevel(fillLevel float64)
	// SetFlippable: if a range is flippable, it will switch its direction if it
	// is horizontal and its direction is GTK_TEXT_DIR_RTL.
	//
	// See gtk_widget_get_direction().
	SetFlippable(flippable bool)
	// SetIncrements sets the step and page sizes for the range. The step size
	// is used when the user clicks the Scrollbar arrows or moves Scale via
	// arrow keys. The page size is used for example when moving via Page Up or
	// Page Down keys.
	SetIncrements(step float64, page float64)
	// SetInverted ranges normally move from lower to higher values as the
	// slider moves from top to bottom or left to right. Inverted ranges have
	// higher values at the top or on the right rather than on the bottom or
	// left.
	SetInverted(setting bool)
	// SetLowerStepperSensitivity sets the sensitivity policy for the stepper
	// that points to the 'lower' end of the GtkRange’s adjustment.
	SetLowerStepperSensitivity(sensitivity SensitivityType)
	// SetMinSliderSize sets the minimum size of the range’s slider.
	//
	// This function is useful mainly for Range subclasses.
	SetMinSliderSize(minSize int)
	// SetRange sets the allowable values in the Range, and clamps the range
	// value to be between @min and @max. (If the range has a non-zero page
	// size, it is clamped between @min and @max - page-size.)
	SetRange(min float64, max float64)
	// SetRestrictToFillLevel sets whether the slider is restricted to the fill
	// level. See gtk_range_set_fill_level() for a general description of the
	// fill level concept.
	SetRestrictToFillLevel(restrictToFillLevel bool)
	// SetRoundDigits sets the number of digits to round the value to when it
	// changes. See Range::change-value.
	SetRoundDigits(roundDigits int)
	// SetShowFillLevel sets whether a graphical fill level is show on the
	// trough. See gtk_range_set_fill_level() for a general description of the
	// fill level concept.
	SetShowFillLevel(showFillLevel bool)
	// SetSliderSizeFixed sets whether the range’s slider has a fixed size, or a
	// size that depends on its adjustment’s page size.
	//
	// This function is useful mainly for Range subclasses.
	SetSliderSizeFixed(sizeFixed bool)
	// SetUpperStepperSensitivity sets the sensitivity policy for the stepper
	// that points to the 'upper' end of the GtkRange’s adjustment.
	SetUpperStepperSensitivity(sensitivity SensitivityType)
	// SetValue sets the current value of the range; if the value is outside the
	// minimum or maximum range values, it will be clamped to fit inside them.
	// The range emits the Range::value-changed signal if the value changes.
	SetValue(value float64)
}

// _range implements the Range class.
type _range struct {
	Widget
	Buildable
	Orientable
}

var _ Range = (*_range)(nil)

// WrapRange wraps a GObject to the right type. It is
// primarily used internally.
func WrapRange(obj *externglib.Object) Range {
	return _range{
		Widget:     WrapWidget(obj),
		Buildable:  WrapBuildable(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalRange(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRange(obj), nil
}

// Adjustment: get the Adjustment which is the “model” object for Range. See
// gtk_range_set_adjustment() for details. The return value does not have a
// reference added, so should not be unreferenced.
func (r _range) Adjustment() Adjustment {
	var _arg0 *C.GtkRange      // out
	var _cret *C.GtkAdjustment // in

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_range_get_adjustment(_arg0)

	var _adjustment Adjustment // out

	_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

	return _adjustment
}

// FillLevel gets the current position of the fill level indicator.
func (r _range) FillLevel() float64 {
	var _arg0 *C.GtkRange // out
	var _cret C.gdouble   // in

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_range_get_fill_level(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// Flippable gets the value set by gtk_range_set_flippable().
func (r _range) Flippable() bool {
	var _arg0 *C.GtkRange // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_range_get_flippable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Inverted gets the value set by gtk_range_set_inverted().
func (r _range) Inverted() bool {
	var _arg0 *C.GtkRange // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_range_get_inverted(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LowerStepperSensitivity gets the sensitivity policy for the stepper that
// points to the 'lower' end of the GtkRange’s adjustment.
func (r _range) LowerStepperSensitivity() SensitivityType {
	var _arg0 *C.GtkRange          // out
	var _cret C.GtkSensitivityType // in

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_range_get_lower_stepper_sensitivity(_arg0)

	var _sensitivityType SensitivityType // out

	_sensitivityType = SensitivityType(_cret)

	return _sensitivityType
}

// MinSliderSize: this function is useful mainly for Range subclasses.
//
// See gtk_range_set_min_slider_size().
func (r _range) MinSliderSize() int {
	var _arg0 *C.GtkRange // out
	var _cret C.gint      // in

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_range_get_min_slider_size(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// RangeRect: this function returns the area that contains the range’s trough
// and its steppers, in widget->window coordinates.
//
// This function is useful mainly for Range subclasses.
func (r _range) RangeRect() gdk.Rectangle {
	var _arg0 *C.GtkRange // out
	var _rangeRect gdk.Rectangle

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

	C.gtk_range_get_range_rect(_arg0, (*C.GdkRectangle)(unsafe.Pointer(&_rangeRect)))

	return _rangeRect
}

// RestrictToFillLevel gets whether the range is restricted to the fill level.
func (r _range) RestrictToFillLevel() bool {
	var _arg0 *C.GtkRange // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_range_get_restrict_to_fill_level(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RoundDigits gets the number of digits to round the value to when it changes.
// See Range::change-value.
func (r _range) RoundDigits() int {
	var _arg0 *C.GtkRange // out
	var _cret C.gint      // in

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_range_get_round_digits(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// ShowFillLevel gets whether the range displays the fill level graphically.
func (r _range) ShowFillLevel() bool {
	var _arg0 *C.GtkRange // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_range_get_show_fill_level(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SliderRange: this function returns sliders range along the long dimension, in
// widget->window coordinates.
//
// This function is useful mainly for Range subclasses.
func (r _range) SliderRange() (sliderStart int, sliderEnd int) {
	var _arg0 *C.GtkRange // out
	var _arg1 C.gint      // in
	var _arg2 C.gint      // in

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

	C.gtk_range_get_slider_range(_arg0, &_arg1, &_arg2)

	var _sliderStart int // out
	var _sliderEnd int   // out

	_sliderStart = (int)(_arg1)
	_sliderEnd = (int)(_arg2)

	return _sliderStart, _sliderEnd
}

// SliderSizeFixed: this function is useful mainly for Range subclasses.
//
// See gtk_range_set_slider_size_fixed().
func (r _range) SliderSizeFixed() bool {
	var _arg0 *C.GtkRange // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_range_get_slider_size_fixed(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UpperStepperSensitivity gets the sensitivity policy for the stepper that
// points to the 'upper' end of the GtkRange’s adjustment.
func (r _range) UpperStepperSensitivity() SensitivityType {
	var _arg0 *C.GtkRange          // out
	var _cret C.GtkSensitivityType // in

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_range_get_upper_stepper_sensitivity(_arg0)

	var _sensitivityType SensitivityType // out

	_sensitivityType = SensitivityType(_cret)

	return _sensitivityType
}

// Value gets the current value of the range.
func (r _range) Value() float64 {
	var _arg0 *C.GtkRange // out
	var _cret C.gdouble   // in

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_range_get_value(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// SetAdjustment sets the adjustment to be used as the “model” object for this
// range widget. The adjustment indicates the current range value, the minimum
// and maximum range values, the step/page increments used for keybindings and
// scrolling, and the page size. The page size is normally 0 for Scale and
// nonzero for Scrollbar, and indicates the size of the visible area of the
// widget being scrolled. The page size affects the size of the scrollbar
// slider.
func (r _range) SetAdjustment(adjustment Adjustment) {
	var _arg0 *C.GtkRange      // out
	var _arg1 *C.GtkAdjustment // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	C.gtk_range_set_adjustment(_arg0, _arg1)
}

// SetFillLevel: set the new position of the fill level indicator.
//
// The “fill level” is probably best described by its most prominent use case,
// which is an indicator for the amount of pre-buffering in a streaming media
// player. In that use case, the value of the range would indicate the current
// play position, and the fill level would be the position up to which the
// file/stream has been downloaded.
//
// This amount of prebuffering can be displayed on the range’s trough and is
// themeable separately from the trough. To enable fill level display, use
// gtk_range_set_show_fill_level(). The range defaults to not showing the fill
// level.
//
// Additionally, it’s possible to restrict the range’s slider position to values
// which are smaller than the fill level. This is controller by
// gtk_range_set_restrict_to_fill_level() and is by default enabled.
func (r _range) SetFillLevel(fillLevel float64) {
	var _arg0 *C.GtkRange // out
	var _arg1 C.gdouble   // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
	_arg1 = (C.gdouble)(fillLevel)

	C.gtk_range_set_fill_level(_arg0, _arg1)
}

// SetFlippable: if a range is flippable, it will switch its direction if it is
// horizontal and its direction is GTK_TEXT_DIR_RTL.
//
// See gtk_widget_get_direction().
func (r _range) SetFlippable(flippable bool) {
	var _arg0 *C.GtkRange // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
	if flippable {
		_arg1 = C.TRUE
	}

	C.gtk_range_set_flippable(_arg0, _arg1)
}

// SetIncrements sets the step and page sizes for the range. The step size is
// used when the user clicks the Scrollbar arrows or moves Scale via arrow keys.
// The page size is used for example when moving via Page Up or Page Down keys.
func (r _range) SetIncrements(step float64, page float64) {
	var _arg0 *C.GtkRange // out
	var _arg1 C.gdouble   // out
	var _arg2 C.gdouble   // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
	_arg1 = (C.gdouble)(step)
	_arg2 = (C.gdouble)(page)

	C.gtk_range_set_increments(_arg0, _arg1, _arg2)
}

// SetInverted ranges normally move from lower to higher values as the slider
// moves from top to bottom or left to right. Inverted ranges have higher values
// at the top or on the right rather than on the bottom or left.
func (r _range) SetInverted(setting bool) {
	var _arg0 *C.GtkRange // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_range_set_inverted(_arg0, _arg1)
}

// SetLowerStepperSensitivity sets the sensitivity policy for the stepper that
// points to the 'lower' end of the GtkRange’s adjustment.
func (r _range) SetLowerStepperSensitivity(sensitivity SensitivityType) {
	var _arg0 *C.GtkRange          // out
	var _arg1 C.GtkSensitivityType // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
	_arg1 = (C.GtkSensitivityType)(sensitivity)

	C.gtk_range_set_lower_stepper_sensitivity(_arg0, _arg1)
}

// SetMinSliderSize sets the minimum size of the range’s slider.
//
// This function is useful mainly for Range subclasses.
func (r _range) SetMinSliderSize(minSize int) {
	var _arg0 *C.GtkRange // out
	var _arg1 C.gint      // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
	_arg1 = (C.gint)(minSize)

	C.gtk_range_set_min_slider_size(_arg0, _arg1)
}

// SetRange sets the allowable values in the Range, and clamps the range value
// to be between @min and @max. (If the range has a non-zero page size, it is
// clamped between @min and @max - page-size.)
func (r _range) SetRange(min float64, max float64) {
	var _arg0 *C.GtkRange // out
	var _arg1 C.gdouble   // out
	var _arg2 C.gdouble   // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
	_arg1 = (C.gdouble)(min)
	_arg2 = (C.gdouble)(max)

	C.gtk_range_set_range(_arg0, _arg1, _arg2)
}

// SetRestrictToFillLevel sets whether the slider is restricted to the fill
// level. See gtk_range_set_fill_level() for a general description of the fill
// level concept.
func (r _range) SetRestrictToFillLevel(restrictToFillLevel bool) {
	var _arg0 *C.GtkRange // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
	if restrictToFillLevel {
		_arg1 = C.TRUE
	}

	C.gtk_range_set_restrict_to_fill_level(_arg0, _arg1)
}

// SetRoundDigits sets the number of digits to round the value to when it
// changes. See Range::change-value.
func (r _range) SetRoundDigits(roundDigits int) {
	var _arg0 *C.GtkRange // out
	var _arg1 C.gint      // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
	_arg1 = (C.gint)(roundDigits)

	C.gtk_range_set_round_digits(_arg0, _arg1)
}

// SetShowFillLevel sets whether a graphical fill level is show on the trough.
// See gtk_range_set_fill_level() for a general description of the fill level
// concept.
func (r _range) SetShowFillLevel(showFillLevel bool) {
	var _arg0 *C.GtkRange // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
	if showFillLevel {
		_arg1 = C.TRUE
	}

	C.gtk_range_set_show_fill_level(_arg0, _arg1)
}

// SetSliderSizeFixed sets whether the range’s slider has a fixed size, or a
// size that depends on its adjustment’s page size.
//
// This function is useful mainly for Range subclasses.
func (r _range) SetSliderSizeFixed(sizeFixed bool) {
	var _arg0 *C.GtkRange // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
	if sizeFixed {
		_arg1 = C.TRUE
	}

	C.gtk_range_set_slider_size_fixed(_arg0, _arg1)
}

// SetUpperStepperSensitivity sets the sensitivity policy for the stepper that
// points to the 'upper' end of the GtkRange’s adjustment.
func (r _range) SetUpperStepperSensitivity(sensitivity SensitivityType) {
	var _arg0 *C.GtkRange          // out
	var _arg1 C.GtkSensitivityType // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
	_arg1 = (C.GtkSensitivityType)(sensitivity)

	C.gtk_range_set_upper_stepper_sensitivity(_arg0, _arg1)
}

// SetValue sets the current value of the range; if the value is outside the
// minimum or maximum range values, it will be clamped to fit inside them. The
// range emits the Range::value-changed signal if the value changes.
func (r _range) SetValue(value float64) {
	var _arg0 *C.GtkRange // out
	var _arg1 C.gdouble   // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
	_arg1 = (C.gdouble)(value)

	C.gtk_range_set_value(_arg0, _arg1)
}

type RangeAccessible interface {
	WidgetAccessible
}

// rangeAccessible implements the RangeAccessible class.
type rangeAccessible struct {
	WidgetAccessible
}

var _ RangeAccessible = (*rangeAccessible)(nil)

// WrapRangeAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapRangeAccessible(obj *externglib.Object) RangeAccessible {
	return rangeAccessible{
		WidgetAccessible: WrapWidgetAccessible(obj),
	}
}

func marshalRangeAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRangeAccessible(obj), nil
}

// RCStyle: the RcStyle-struct is used to represent a set of information about
// the appearance of a widget. This can later be composited together with other
// RcStyle-struct<!-- -->s to form a Style.
type RCStyle interface {
	gextras.Objector

	// Copy makes a copy of the specified RcStyle. This function will correctly
	// copy an RC style that is a member of a class derived from RcStyle.
	Copy() RCStyle
}

// rcStyle implements the RCStyle class.
type rcStyle struct {
	gextras.Objector
}

var _ RCStyle = (*rcStyle)(nil)

// WrapRCStyle wraps a GObject to the right type. It is
// primarily used internally.
func WrapRCStyle(obj *externglib.Object) RCStyle {
	return rcStyle{
		Objector: obj,
	}
}

func marshalRCStyle(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRCStyle(obj), nil
}

// NewRCStyle creates a new RcStyle with no fields set and a reference count of
// 1.
func NewRCStyle() RCStyle {
	var _cret *C.GtkRcStyle // in

	_cret = C.gtk_rc_style_new()

	var _rcStyle RCStyle // out

	_rcStyle = WrapRCStyle(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _rcStyle
}

// Copy makes a copy of the specified RcStyle. This function will correctly copy
// an RC style that is a member of a class derived from RcStyle.
func (o rcStyle) Copy() RCStyle {
	var _arg0 *C.GtkRcStyle // out
	var _cret *C.GtkRcStyle // in

	_arg0 = (*C.GtkRcStyle)(unsafe.Pointer(o.Native()))

	_cret = C.gtk_rc_style_copy(_arg0)

	var _rcStyle RCStyle // out

	_rcStyle = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(RCStyle)

	return _rcStyle
}

// RecentAction: a RecentAction represents a list of recently used files, which
// can be shown by widgets such as RecentChooserDialog or RecentChooserMenu.
//
// To construct a submenu showing recently used files, use a RecentAction as the
// action for a <menuitem>. To construct a menu toolbutton showing the recently
// used files in the popup menu, use a RecentAction as the action for a
// <toolitem> element.
type RecentAction interface {
	Action
	Buildable
	RecentChooser

	// ShowNumbers returns the value set by
	// gtk_recent_chooser_menu_set_show_numbers().
	ShowNumbers() bool
	// SetShowNumbers sets whether a number should be added to the items shown
	// by the widgets representing @action. The numbers are shown to provide a
	// unique character for a mnemonic to be used inside the menu item's label.
	// Only the first ten items get a number to avoid clashes.
	SetShowNumbers(showNumbers bool)
}

// recentAction implements the RecentAction class.
type recentAction struct {
	Action
	Buildable
	RecentChooser
}

var _ RecentAction = (*recentAction)(nil)

// WrapRecentAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapRecentAction(obj *externglib.Object) RecentAction {
	return recentAction{
		Action:        WrapAction(obj),
		Buildable:     WrapBuildable(obj),
		RecentChooser: WrapRecentChooser(obj),
	}
}

func marshalRecentAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRecentAction(obj), nil
}

// NewRecentAction creates a new RecentAction object. To add the action to a
// ActionGroup and set the accelerator for the action, call
// gtk_action_group_add_action_with_accel().
func NewRecentAction(name string, label string, tooltip string, stockId string) RecentAction {
	var _arg1 *C.gchar     // out
	var _arg2 *C.gchar     // out
	var _arg3 *C.gchar     // out
	var _arg4 *C.gchar     // out
	var _cret *C.GtkAction // in

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(tooltip))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(C.CString(stockId))
	defer C.free(unsafe.Pointer(_arg4))

	_cret = C.gtk_recent_action_new(_arg1, _arg2, _arg3, _arg4)

	var _recentAction RecentAction // out

	_recentAction = WrapRecentAction(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _recentAction
}

// NewRecentActionForManager creates a new RecentAction object. To add the
// action to a ActionGroup and set the accelerator for the action, call
// gtk_action_group_add_action_with_accel().
func NewRecentActionForManager(name string, label string, tooltip string, stockId string, manager RecentManager) RecentAction {
	var _arg1 *C.gchar            // out
	var _arg2 *C.gchar            // out
	var _arg3 *C.gchar            // out
	var _arg4 *C.gchar            // out
	var _arg5 *C.GtkRecentManager // out
	var _cret *C.GtkAction        // in

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(tooltip))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(C.CString(stockId))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.GtkRecentManager)(unsafe.Pointer(manager.Native()))

	_cret = C.gtk_recent_action_new_for_manager(_arg1, _arg2, _arg3, _arg4, _arg5)

	var _recentAction RecentAction // out

	_recentAction = WrapRecentAction(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _recentAction
}

// ShowNumbers returns the value set by
// gtk_recent_chooser_menu_set_show_numbers().
func (a recentAction) ShowNumbers() bool {
	var _arg0 *C.GtkRecentAction // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkRecentAction)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_recent_action_get_show_numbers(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetShowNumbers sets whether a number should be added to the items shown by
// the widgets representing @action. The numbers are shown to provide a unique
// character for a mnemonic to be used inside the menu item's label. Only the
// first ten items get a number to avoid clashes.
func (a recentAction) SetShowNumbers(showNumbers bool) {
	var _arg0 *C.GtkRecentAction // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GtkRecentAction)(unsafe.Pointer(a.Native()))
	if showNumbers {
		_arg1 = C.TRUE
	}

	C.gtk_recent_action_set_show_numbers(_arg0, _arg1)
}

// RecentChooserDialog is a dialog box suitable for displaying the recently used
// documents. This widgets works by putting a RecentChooserWidget inside a
// Dialog. It exposes the RecentChooserIface interface, so you can use all the
// RecentChooser functions on the recent chooser dialog as well as those for
// Dialog.
//
// Note that RecentChooserDialog does not have any methods of its own. Instead,
// you should use the functions that work on a RecentChooser.
//
//
// Typical usage
//
// In the simplest of cases, you can use the following code to use a
// RecentChooserDialog to select a recently used file:
//
//    GtkWidget *dialog;
//    gint res;
//
//    dialog = gtk_recent_chooser_dialog_new ("Recent Documents",
//                                            parent_window,
//                                            _("_Cancel"),
//                                            GTK_RESPONSE_CANCEL,
//                                            _("_Open"),
//                                            GTK_RESPONSE_ACCEPT,
//                                            NULL);
//
//    res = gtk_dialog_run (GTK_DIALOG (dialog));
//    if (res == GTK_RESPONSE_ACCEPT)
//      {
//        GtkRecentInfo *info;
//        GtkRecentChooser *chooser = GTK_RECENT_CHOOSER (dialog);
//
//        info = gtk_recent_chooser_get_current_item (chooser);
//        open_file (gtk_recent_info_get_uri (info));
//        gtk_recent_info_unref (info);
//      }
//
//    gtk_widget_destroy (dialog);
//
// Recently used files are supported since GTK+ 2.10.
type RecentChooserDialog interface {
	Dialog
	Buildable
	RecentChooser
}

// recentChooserDialog implements the RecentChooserDialog class.
type recentChooserDialog struct {
	Dialog
	Buildable
	RecentChooser
}

var _ RecentChooserDialog = (*recentChooserDialog)(nil)

// WrapRecentChooserDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapRecentChooserDialog(obj *externglib.Object) RecentChooserDialog {
	return recentChooserDialog{
		Dialog:        WrapDialog(obj),
		Buildable:     WrapBuildable(obj),
		RecentChooser: WrapRecentChooser(obj),
	}
}

func marshalRecentChooserDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRecentChooserDialog(obj), nil
}

// RecentChooserMenu is a widget suitable for displaying recently used files
// inside a menu. It can be used to set a sub-menu of a MenuItem using
// gtk_menu_item_set_submenu(), or as the menu of a MenuToolButton.
//
// Note that RecentChooserMenu does not have any methods of its own. Instead,
// you should use the functions that work on a RecentChooser.
//
// Note also that RecentChooserMenu does not support multiple filters, as it has
// no way to let the user choose between them as the RecentChooserWidget and
// RecentChooserDialog widgets do. Thus using gtk_recent_chooser_add_filter() on
// a RecentChooserMenu widget will yield the same effects as using
// gtk_recent_chooser_set_filter(), replacing any currently set filter with the
// supplied filter; gtk_recent_chooser_remove_filter() will remove any currently
// set RecentFilter object and will unset the current filter;
// gtk_recent_chooser_list_filters() will return a list containing a single
// RecentFilter object.
//
// Recently used files are supported since GTK+ 2.10.
type RecentChooserMenu interface {
	Menu
	Activatable
	Buildable
	RecentChooser

	// ShowNumbers returns the value set by
	// gtk_recent_chooser_menu_set_show_numbers().
	ShowNumbers() bool
	// SetShowNumbers sets whether a number should be added to the items of
	// @menu. The numbers are shown to provide a unique character for a mnemonic
	// to be used inside ten menu item’s label. Only the first the items get a
	// number to avoid clashes.
	SetShowNumbers(showNumbers bool)
}

// recentChooserMenu implements the RecentChooserMenu class.
type recentChooserMenu struct {
	Menu
	Activatable
	Buildable
	RecentChooser
}

var _ RecentChooserMenu = (*recentChooserMenu)(nil)

// WrapRecentChooserMenu wraps a GObject to the right type. It is
// primarily used internally.
func WrapRecentChooserMenu(obj *externglib.Object) RecentChooserMenu {
	return recentChooserMenu{
		Menu:          WrapMenu(obj),
		Activatable:   WrapActivatable(obj),
		Buildable:     WrapBuildable(obj),
		RecentChooser: WrapRecentChooser(obj),
	}
}

func marshalRecentChooserMenu(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRecentChooserMenu(obj), nil
}

// NewRecentChooserMenu creates a new RecentChooserMenu widget.
//
// This kind of widget shows the list of recently used resources as a menu, each
// item as a menu item. Each item inside the menu might have an icon,
// representing its MIME type, and a number, for mnemonic access.
//
// This widget implements the RecentChooser interface.
//
// This widget creates its own RecentManager object. See the
// gtk_recent_chooser_menu_new_for_manager() function to know how to create a
// RecentChooserMenu widget bound to another RecentManager object.
func NewRecentChooserMenu() RecentChooserMenu {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_recent_chooser_menu_new()

	var _recentChooserMenu RecentChooserMenu // out

	_recentChooserMenu = WrapRecentChooserMenu(externglib.Take(unsafe.Pointer(_cret)))

	return _recentChooserMenu
}

// NewRecentChooserMenuForManager creates a new RecentChooserMenu widget using
// @manager as the underlying recently used resources manager.
//
// This is useful if you have implemented your own recent manager, or if you
// have a customized instance of a RecentManager object or if you wish to share
// a common RecentManager object among multiple RecentChooser widgets.
func NewRecentChooserMenuForManager(manager RecentManager) RecentChooserMenu {
	var _arg1 *C.GtkRecentManager // out
	var _cret *C.GtkWidget        // in

	_arg1 = (*C.GtkRecentManager)(unsafe.Pointer(manager.Native()))

	_cret = C.gtk_recent_chooser_menu_new_for_manager(_arg1)

	var _recentChooserMenu RecentChooserMenu // out

	_recentChooserMenu = WrapRecentChooserMenu(externglib.Take(unsafe.Pointer(_cret)))

	return _recentChooserMenu
}

// ShowNumbers returns the value set by
// gtk_recent_chooser_menu_set_show_numbers().
func (m recentChooserMenu) ShowNumbers() bool {
	var _arg0 *C.GtkRecentChooserMenu // out
	var _cret C.gboolean              // in

	_arg0 = (*C.GtkRecentChooserMenu)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_recent_chooser_menu_get_show_numbers(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetShowNumbers sets whether a number should be added to the items of @menu.
// The numbers are shown to provide a unique character for a mnemonic to be used
// inside ten menu item’s label. Only the first the items get a number to avoid
// clashes.
func (m recentChooserMenu) SetShowNumbers(showNumbers bool) {
	var _arg0 *C.GtkRecentChooserMenu // out
	var _arg1 C.gboolean              // out

	_arg0 = (*C.GtkRecentChooserMenu)(unsafe.Pointer(m.Native()))
	if showNumbers {
		_arg1 = C.TRUE
	}

	C.gtk_recent_chooser_menu_set_show_numbers(_arg0, _arg1)
}

// RecentChooserWidget is a widget suitable for selecting recently used files.
// It is the main building block of a RecentChooserDialog. Most applications
// will only need to use the latter; you can use RecentChooserWidget as part of
// a larger window if you have special needs.
//
// Note that RecentChooserWidget does not have any methods of its own. Instead,
// you should use the functions that work on a RecentChooser.
//
// Recently used files are supported since GTK+ 2.10.
type RecentChooserWidget interface {
	Box
	Buildable
	Orientable
	RecentChooser
}

// recentChooserWidget implements the RecentChooserWidget class.
type recentChooserWidget struct {
	Box
	Buildable
	Orientable
	RecentChooser
}

var _ RecentChooserWidget = (*recentChooserWidget)(nil)

// WrapRecentChooserWidget wraps a GObject to the right type. It is
// primarily used internally.
func WrapRecentChooserWidget(obj *externglib.Object) RecentChooserWidget {
	return recentChooserWidget{
		Box:           WrapBox(obj),
		Buildable:     WrapBuildable(obj),
		Orientable:    WrapOrientable(obj),
		RecentChooser: WrapRecentChooser(obj),
	}
}

func marshalRecentChooserWidget(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRecentChooserWidget(obj), nil
}

// NewRecentChooserWidget creates a new RecentChooserWidget object. This is an
// embeddable widget used to access the recently used resources list.
func NewRecentChooserWidget() RecentChooserWidget {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_recent_chooser_widget_new()

	var _recentChooserWidget RecentChooserWidget // out

	_recentChooserWidget = WrapRecentChooserWidget(externglib.Take(unsafe.Pointer(_cret)))

	return _recentChooserWidget
}

// NewRecentChooserWidgetForManager creates a new RecentChooserWidget with a
// specified recent manager.
//
// This is useful if you have implemented your own recent manager, or if you
// have a customized instance of a RecentManager object.
func NewRecentChooserWidgetForManager(manager RecentManager) RecentChooserWidget {
	var _arg1 *C.GtkRecentManager // out
	var _cret *C.GtkWidget        // in

	_arg1 = (*C.GtkRecentManager)(unsafe.Pointer(manager.Native()))

	_cret = C.gtk_recent_chooser_widget_new_for_manager(_arg1)

	var _recentChooserWidget RecentChooserWidget // out

	_recentChooserWidget = WrapRecentChooserWidget(externglib.Take(unsafe.Pointer(_cret)))

	return _recentChooserWidget
}

// RecentFilter: a RecentFilter can be used to restrict the files being shown in
// a RecentChooser. Files can be filtered based on their name (with
// gtk_recent_filter_add_pattern()), on their mime type (with
// gtk_file_filter_add_mime_type()), on the application that has registered them
// (with gtk_recent_filter_add_application()), or by a custom filter function
// (with gtk_recent_filter_add_custom()).
//
// Filtering by mime type handles aliasing and subclassing of mime types; e.g. a
// filter for text/plain also matches a file with mime type application/rtf,
// since application/rtf is a subclass of text/plain. Note that RecentFilter
// allows wildcards for the subtype of a mime type, so you can e.g. filter for
// image/\*.
//
// Normally, filters are used by adding them to a RecentChooser, see
// gtk_recent_chooser_add_filter(), but it is also possible to manually use a
// filter on a file with gtk_recent_filter_filter().
//
// Recently used files are supported since GTK+ 2.10.
//
//
// GtkRecentFilter as GtkBuildable
//
// The GtkRecentFilter implementation of the GtkBuildable interface supports
// adding rules using the <mime-types>, <patterns> and <applications> elements
// and listing the rules within. Specifying a <mime-type>, <pattern> or
// <application> has the same effect as calling
// gtk_recent_filter_add_mime_type(), gtk_recent_filter_add_pattern() or
// gtk_recent_filter_add_application().
//
// An example of a UI definition fragment specifying GtkRecentFilter rules:
//
//    <object class="GtkRecentFilter">
//      <mime-types>
//        <mime-type>text/plain</mime-type>
//        <mime-type>image/png</mime-type>
//      </mime-types>
//      <patterns>
//        <pattern>*.txt</pattern>
//        <pattern>*.png</pattern>
//      </patterns>
//      <applications>
//        <application>gimp</application>
//        <application>gedit</application>
//        <application>glade</application>
//      </applications>
//    </object>
type RecentFilter interface {
	gextras.Objector
	Buildable

	// AddAge adds a rule that allows resources based on their age - that is,
	// the number of days elapsed since they were last modified.
	AddAge(days int)
	// AddApplication adds a rule that allows resources based on the name of the
	// application that has registered them.
	AddApplication(application string)
	// AddGroup adds a rule that allows resources based on the name of the group
	// to which they belong
	AddGroup(group string)
	// AddMIMEType adds a rule that allows resources based on their registered
	// MIME type.
	AddMIMEType(mimeType string)
	// AddPattern adds a rule that allows resources based on a pattern matching
	// their display name.
	AddPattern(pattern string)
	// AddPixbufFormats adds a rule allowing image files in the formats
	// supported by GdkPixbuf.
	AddPixbufFormats()
	// Filter tests whether a file should be displayed according to @filter. The
	// RecentFilterInfo @filter_info should include the fields returned from
	// gtk_recent_filter_get_needed(), and must set the
	// RecentFilterInfo.contains field of @filter_info to indicate which fields
	// have been set.
	//
	// This function will not typically be used by applications; it is intended
	// principally for use in the implementation of RecentChooser.
	Filter(filterInfo *RecentFilterInfo) bool
	// Name gets the human-readable name for the filter. See
	// gtk_recent_filter_set_name().
	Name() string
	// Needed gets the fields that need to be filled in for the RecentFilterInfo
	// passed to gtk_recent_filter_filter()
	//
	// This function will not typically be used by applications; it is intended
	// principally for use in the implementation of RecentChooser.
	Needed() RecentFilterFlags
	// SetName sets the human-readable name of the filter; this is the string
	// that will be displayed in the recently used resources selector user
	// interface if there is a selectable list of filters.
	SetName(name string)
}

// recentFilter implements the RecentFilter class.
type recentFilter struct {
	gextras.Objector
	Buildable
}

var _ RecentFilter = (*recentFilter)(nil)

// WrapRecentFilter wraps a GObject to the right type. It is
// primarily used internally.
func WrapRecentFilter(obj *externglib.Object) RecentFilter {
	return recentFilter{
		Objector:  obj,
		Buildable: WrapBuildable(obj),
	}
}

func marshalRecentFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRecentFilter(obj), nil
}

// NewRecentFilter creates a new RecentFilter with no rules added to it. Such
// filter does not accept any recently used resources, so is not particularly
// useful until you add rules with gtk_recent_filter_add_pattern(),
// gtk_recent_filter_add_mime_type(), gtk_recent_filter_add_application(),
// gtk_recent_filter_add_age(). To create a filter that accepts any recently
// used resource, use:
//
//    GtkRecentFilter *filter = gtk_recent_filter_new ();
//    gtk_recent_filter_add_pattern (filter, "*");
func NewRecentFilter() RecentFilter {
	var _cret *C.GtkRecentFilter // in

	_cret = C.gtk_recent_filter_new()

	var _recentFilter RecentFilter // out

	_recentFilter = WrapRecentFilter(externglib.Take(unsafe.Pointer(_cret)))

	return _recentFilter
}

// AddAge adds a rule that allows resources based on their age - that is, the
// number of days elapsed since they were last modified.
func (f recentFilter) AddAge(days int) {
	var _arg0 *C.GtkRecentFilter // out
	var _arg1 C.gint             // out

	_arg0 = (*C.GtkRecentFilter)(unsafe.Pointer(f.Native()))
	_arg1 = (C.gint)(days)

	C.gtk_recent_filter_add_age(_arg0, _arg1)
}

// AddApplication adds a rule that allows resources based on the name of the
// application that has registered them.
func (f recentFilter) AddApplication(application string) {
	var _arg0 *C.GtkRecentFilter // out
	var _arg1 *C.gchar           // out

	_arg0 = (*C.GtkRecentFilter)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.gchar)(C.CString(application))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_recent_filter_add_application(_arg0, _arg1)
}

// AddGroup adds a rule that allows resources based on the name of the group to
// which they belong
func (f recentFilter) AddGroup(group string) {
	var _arg0 *C.GtkRecentFilter // out
	var _arg1 *C.gchar           // out

	_arg0 = (*C.GtkRecentFilter)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.gchar)(C.CString(group))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_recent_filter_add_group(_arg0, _arg1)
}

// AddMIMEType adds a rule that allows resources based on their registered MIME
// type.
func (f recentFilter) AddMIMEType(mimeType string) {
	var _arg0 *C.GtkRecentFilter // out
	var _arg1 *C.gchar           // out

	_arg0 = (*C.GtkRecentFilter)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.gchar)(C.CString(mimeType))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_recent_filter_add_mime_type(_arg0, _arg1)
}

// AddPattern adds a rule that allows resources based on a pattern matching
// their display name.
func (f recentFilter) AddPattern(pattern string) {
	var _arg0 *C.GtkRecentFilter // out
	var _arg1 *C.gchar           // out

	_arg0 = (*C.GtkRecentFilter)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.gchar)(C.CString(pattern))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_recent_filter_add_pattern(_arg0, _arg1)
}

// AddPixbufFormats adds a rule allowing image files in the formats supported by
// GdkPixbuf.
func (f recentFilter) AddPixbufFormats() {
	var _arg0 *C.GtkRecentFilter // out

	_arg0 = (*C.GtkRecentFilter)(unsafe.Pointer(f.Native()))

	C.gtk_recent_filter_add_pixbuf_formats(_arg0)
}

// Filter tests whether a file should be displayed according to @filter. The
// RecentFilterInfo @filter_info should include the fields returned from
// gtk_recent_filter_get_needed(), and must set the RecentFilterInfo.contains
// field of @filter_info to indicate which fields have been set.
//
// This function will not typically be used by applications; it is intended
// principally for use in the implementation of RecentChooser.
func (f recentFilter) Filter(filterInfo *RecentFilterInfo) bool {
	var _arg0 *C.GtkRecentFilter     // out
	var _arg1 *C.GtkRecentFilterInfo // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkRecentFilter)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GtkRecentFilterInfo)(unsafe.Pointer(filterInfo.Native()))

	_cret = C.gtk_recent_filter_filter(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Name gets the human-readable name for the filter. See
// gtk_recent_filter_set_name().
func (f recentFilter) Name() string {
	var _arg0 *C.GtkRecentFilter // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GtkRecentFilter)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_recent_filter_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Needed gets the fields that need to be filled in for the RecentFilterInfo
// passed to gtk_recent_filter_filter()
//
// This function will not typically be used by applications; it is intended
// principally for use in the implementation of RecentChooser.
func (f recentFilter) Needed() RecentFilterFlags {
	var _arg0 *C.GtkRecentFilter     // out
	var _cret C.GtkRecentFilterFlags // in

	_arg0 = (*C.GtkRecentFilter)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_recent_filter_get_needed(_arg0)

	var _recentFilterFlags RecentFilterFlags // out

	_recentFilterFlags = RecentFilterFlags(_cret)

	return _recentFilterFlags
}

// SetName sets the human-readable name of the filter; this is the string that
// will be displayed in the recently used resources selector user interface if
// there is a selectable list of filters.
func (f recentFilter) SetName(name string) {
	var _arg0 *C.GtkRecentFilter // out
	var _arg1 *C.gchar           // out

	_arg0 = (*C.GtkRecentFilter)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_recent_filter_set_name(_arg0, _arg1)
}

// RecentManager provides a facility for adding, removing and looking up
// recently used files. Each recently used file is identified by its URI, and
// has meta-data associated to it, like the names and command lines of the
// applications that have registered it, the number of time each application has
// registered the same file, the mime type of the file and whether the file
// should be displayed only by the applications that have registered it.
//
// The recently used files list is per user.
//
// The RecentManager acts like a database of all the recently used files. You
// can create new RecentManager objects, but it is more efficient to use the
// default manager created by GTK+.
//
// Adding a new recently used file is as simple as:
//
//    GtkRecentManager *manager;
//    GtkRecentInfo *info;
//    GError *error = NULL;
//
//    manager = gtk_recent_manager_get_default ();
//    info = gtk_recent_manager_lookup_item (manager, file_uri, &error);
//    if (error)
//      {
//        g_warning ("Could not find the file: s", error->message);
//        g_error_free (error);
//      }
//    else
//     {
//       // Use the info object
//       gtk_recent_info_unref (info);
//     }
//
// In order to retrieve the list of recently used files, you can use
// gtk_recent_manager_get_items(), which returns a list of RecentInfo-structs.
//
// A RecentManager is the model used to populate the contents of one, or more
// RecentChooser implementations.
//
// Note that the maximum age of the recently used files list is controllable
// through the Settings:gtk-recent-files-max-age property.
//
// Recently used files are supported since GTK+ 2.10.
type RecentManager interface {
	gextras.Objector

	// AddFull adds a new resource, pointed by @uri, into the recently used
	// resources list, using the metadata specified inside the RecentData-struct
	// passed in @recent_data.
	//
	// The passed URI will be used to identify this resource inside the list.
	//
	// In order to register the new recently used resource, metadata about the
	// resource must be passed as well as the URI; the metadata is stored in a
	// RecentData-struct, which must contain the MIME type of the resource
	// pointed by the URI; the name of the application that is registering the
	// item, and a command line to be used when launching the item.
	//
	// Optionally, a RecentData-struct might contain a UTF-8 string to be used
	// when viewing the item instead of the last component of the URI; a short
	// description of the item; whether the item should be considered private -
	// that is, should be displayed only by the applications that have
	// registered it.
	AddFull(uri string, recentData *RecentData) bool
	// AddItem adds a new resource, pointed by @uri, into the recently used
	// resources list.
	//
	// This function automatically retrieves some of the needed metadata and
	// setting other metadata to common default values; it then feeds the data
	// to gtk_recent_manager_add_full().
	//
	// See gtk_recent_manager_add_full() if you want to explicitly define the
	// metadata for the resource pointed by @uri.
	AddItem(uri string) bool
	// HasItem checks whether there is a recently used resource registered with
	// @uri inside the recent manager.
	HasItem(uri string) bool
	// LookupItem searches for a URI inside the recently used resources list,
	// and returns a RecentInfo-struct containing informations about the
	// resource like its MIME type, or its display name.
	LookupItem(uri string) (*RecentInfo, error)
	// MoveItem changes the location of a recently used resource from @uri to
	// @new_uri.
	//
	// Please note that this function will not affect the resource pointed by
	// the URIs, but only the URI used in the recently used resources list.
	MoveItem(uri string, newUri string) error
	// PurgeItems purges every item from the recently used resources list.
	PurgeItems() (int, error)
	// RemoveItem removes a resource pointed by @uri from the recently used
	// resources list handled by a recent manager.
	RemoveItem(uri string) error
}

// recentManager implements the RecentManager class.
type recentManager struct {
	gextras.Objector
}

var _ RecentManager = (*recentManager)(nil)

// WrapRecentManager wraps a GObject to the right type. It is
// primarily used internally.
func WrapRecentManager(obj *externglib.Object) RecentManager {
	return recentManager{
		Objector: obj,
	}
}

func marshalRecentManager(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRecentManager(obj), nil
}

// NewRecentManager creates a new recent manager object. Recent manager objects
// are used to handle the list of recently used resources. A RecentManager
// object monitors the recently used resources list, and emits the “changed”
// signal each time something inside the list changes.
//
// RecentManager objects are expensive: be sure to create them only when needed.
// You should use gtk_recent_manager_get_default() instead.
func NewRecentManager() RecentManager {
	var _cret *C.GtkRecentManager // in

	_cret = C.gtk_recent_manager_new()

	var _recentManager RecentManager // out

	_recentManager = WrapRecentManager(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _recentManager
}

// AddFull adds a new resource, pointed by @uri, into the recently used
// resources list, using the metadata specified inside the RecentData-struct
// passed in @recent_data.
//
// The passed URI will be used to identify this resource inside the list.
//
// In order to register the new recently used resource, metadata about the
// resource must be passed as well as the URI; the metadata is stored in a
// RecentData-struct, which must contain the MIME type of the resource pointed
// by the URI; the name of the application that is registering the item, and a
// command line to be used when launching the item.
//
// Optionally, a RecentData-struct might contain a UTF-8 string to be used when
// viewing the item instead of the last component of the URI; a short
// description of the item; whether the item should be considered private - that
// is, should be displayed only by the applications that have registered it.
func (m recentManager) AddFull(uri string, recentData *RecentData) bool {
	var _arg0 *C.GtkRecentManager // out
	var _arg1 *C.gchar            // out
	var _arg2 *C.GtkRecentData    // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkRecentData)(unsafe.Pointer(recentData.Native()))

	_cret = C.gtk_recent_manager_add_full(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AddItem adds a new resource, pointed by @uri, into the recently used
// resources list.
//
// This function automatically retrieves some of the needed metadata and setting
// other metadata to common default values; it then feeds the data to
// gtk_recent_manager_add_full().
//
// See gtk_recent_manager_add_full() if you want to explicitly define the
// metadata for the resource pointed by @uri.
func (m recentManager) AddItem(uri string) bool {
	var _arg0 *C.GtkRecentManager // out
	var _arg1 *C.gchar            // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_recent_manager_add_item(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasItem checks whether there is a recently used resource registered with @uri
// inside the recent manager.
func (m recentManager) HasItem(uri string) bool {
	var _arg0 *C.GtkRecentManager // out
	var _arg1 *C.gchar            // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_recent_manager_has_item(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LookupItem searches for a URI inside the recently used resources list, and
// returns a RecentInfo-struct containing informations about the resource like
// its MIME type, or its display name.
func (m recentManager) LookupItem(uri string) (*RecentInfo, error) {
	var _arg0 *C.GtkRecentManager // out
	var _arg1 *C.gchar            // out
	var _cret *C.GtkRecentInfo    // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_recent_manager_lookup_item(_arg0, _arg1, &_cerr)

	var _recentInfo *RecentInfo // out
	var _goerr error            // out

	_recentInfo = WrapRecentInfo(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_recentInfo, func(v *RecentInfo) {
		C.free(unsafe.Pointer(v.Native()))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _recentInfo, _goerr
}

// MoveItem changes the location of a recently used resource from @uri to
// @new_uri.
//
// Please note that this function will not affect the resource pointed by the
// URIs, but only the URI used in the recently used resources list.
func (m recentManager) MoveItem(uri string, newUri string) error {
	var _arg0 *C.GtkRecentManager // out
	var _arg1 *C.gchar            // out
	var _arg2 *C.gchar            // out
	var _cerr *C.GError           // in

	_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(newUri))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_recent_manager_move_item(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// PurgeItems purges every item from the recently used resources list.
func (m recentManager) PurgeItems() (int, error) {
	var _arg0 *C.GtkRecentManager // out
	var _cret C.gint              // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_recent_manager_purge_items(_arg0, &_cerr)

	var _gint int    // out
	var _goerr error // out

	_gint = (int)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gint, _goerr
}

// RemoveItem removes a resource pointed by @uri from the recently used
// resources list handled by a recent manager.
func (m recentManager) RemoveItem(uri string) error {
	var _arg0 *C.GtkRecentManager // out
	var _arg1 *C.gchar            // out
	var _cerr *C.GError           // in

	_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_recent_manager_remove_item(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

type RendererCellAccessible interface {
	CellAccessible
}

// rendererCellAccessible implements the RendererCellAccessible class.
type rendererCellAccessible struct {
	CellAccessible
}

var _ RendererCellAccessible = (*rendererCellAccessible)(nil)

// WrapRendererCellAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapRendererCellAccessible(obj *externglib.Object) RendererCellAccessible {
	return rendererCellAccessible{
		CellAccessible: WrapCellAccessible(obj),
	}
}

func marshalRendererCellAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRendererCellAccessible(obj), nil
}

func NewRendererCellAccessible(renderer CellRenderer) RendererCellAccessible {
	var _arg1 *C.GtkCellRenderer // out
	var _cret *C.AtkObject       // in

	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))

	_cret = C.gtk_renderer_cell_accessible_new(_arg1)

	var _rendererCellAccessible RendererCellAccessible // out

	_rendererCellAccessible = WrapRendererCellAccessible(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _rendererCellAccessible
}

// Revealer: the GtkRevealer widget is a container which animates the transition
// of its child from invisible to visible.
//
// The style of transition can be controlled with
// gtk_revealer_set_transition_type().
//
// These animations respect the Settings:gtk-enable-animations setting.
//
//
// CSS nodes
//
// GtkRevealer has a single CSS node with name revealer.
//
// The GtkRevealer widget was added in GTK+ 3.10.
type Revealer interface {
	Bin
	Buildable

	// ChildRevealed returns whether the child is fully revealed, in other words
	// whether the transition to the revealed state is completed.
	ChildRevealed() bool
	// RevealChild returns whether the child is currently revealed. See
	// gtk_revealer_set_reveal_child().
	//
	// This function returns true as soon as the transition is to the revealed
	// state is started. To learn whether the child is fully revealed (ie the
	// transition is completed), use gtk_revealer_get_child_revealed().
	RevealChild() bool
	// TransitionDuration returns the amount of time (in milliseconds) that
	// transitions will take.
	TransitionDuration() uint
	// TransitionType gets the type of animation that will be used for
	// transitions in @revealer.
	TransitionType() RevealerTransitionType
	// SetRevealChild tells the Revealer to reveal or conceal its child.
	//
	// The transition will be animated with the current transition type of
	// @revealer.
	SetRevealChild(revealChild bool)
	// SetTransitionDuration sets the duration that transitions will take.
	SetTransitionDuration(duration uint)
	// SetTransitionType sets the type of animation that will be used for
	// transitions in @revealer. Available types include various kinds of fades
	// and slides.
	SetTransitionType(transition RevealerTransitionType)
}

// revealer implements the Revealer class.
type revealer struct {
	Bin
	Buildable
}

var _ Revealer = (*revealer)(nil)

// WrapRevealer wraps a GObject to the right type. It is
// primarily used internally.
func WrapRevealer(obj *externglib.Object) Revealer {
	return revealer{
		Bin:       WrapBin(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalRevealer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRevealer(obj), nil
}

// NewRevealer creates a new Revealer.
func NewRevealer() Revealer {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_revealer_new()

	var _revealer Revealer // out

	_revealer = WrapRevealer(externglib.Take(unsafe.Pointer(_cret)))

	return _revealer
}

// ChildRevealed returns whether the child is fully revealed, in other words
// whether the transition to the revealed state is completed.
func (r revealer) ChildRevealed() bool {
	var _arg0 *C.GtkRevealer // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_revealer_get_child_revealed(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RevealChild returns whether the child is currently revealed. See
// gtk_revealer_set_reveal_child().
//
// This function returns true as soon as the transition is to the revealed state
// is started. To learn whether the child is fully revealed (ie the transition
// is completed), use gtk_revealer_get_child_revealed().
func (r revealer) RevealChild() bool {
	var _arg0 *C.GtkRevealer // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_revealer_get_reveal_child(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TransitionDuration returns the amount of time (in milliseconds) that
// transitions will take.
func (r revealer) TransitionDuration() uint {
	var _arg0 *C.GtkRevealer // out
	var _cret C.guint        // in

	_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_revealer_get_transition_duration(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// TransitionType gets the type of animation that will be used for transitions
// in @revealer.
func (r revealer) TransitionType() RevealerTransitionType {
	var _arg0 *C.GtkRevealer              // out
	var _cret C.GtkRevealerTransitionType // in

	_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_revealer_get_transition_type(_arg0)

	var _revealerTransitionType RevealerTransitionType // out

	_revealerTransitionType = RevealerTransitionType(_cret)

	return _revealerTransitionType
}

// SetRevealChild tells the Revealer to reveal or conceal its child.
//
// The transition will be animated with the current transition type of
// @revealer.
func (r revealer) SetRevealChild(revealChild bool) {
	var _arg0 *C.GtkRevealer // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))
	if revealChild {
		_arg1 = C.TRUE
	}

	C.gtk_revealer_set_reveal_child(_arg0, _arg1)
}

// SetTransitionDuration sets the duration that transitions will take.
func (r revealer) SetTransitionDuration(duration uint) {
	var _arg0 *C.GtkRevealer // out
	var _arg1 C.guint        // out

	_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))
	_arg1 = (C.guint)(duration)

	C.gtk_revealer_set_transition_duration(_arg0, _arg1)
}

// SetTransitionType sets the type of animation that will be used for
// transitions in @revealer. Available types include various kinds of fades and
// slides.
func (r revealer) SetTransitionType(transition RevealerTransitionType) {
	var _arg0 *C.GtkRevealer              // out
	var _arg1 C.GtkRevealerTransitionType // out

	_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))
	_arg1 = (C.GtkRevealerTransitionType)(transition)

	C.gtk_revealer_set_transition_type(_arg0, _arg1)
}

// Scale: a GtkScale is a slider control used to select a numeric value. To use
// it, you’ll probably want to investigate the methods on its base class, Range,
// in addition to the methods for GtkScale itself. To set the value of a scale,
// you would normally use gtk_range_set_value(). To detect changes to the value,
// you would normally use the Range::value-changed signal.
//
// Note that using the same upper and lower bounds for the Scale (through the
// Range methods) will hide the slider itself. This is useful for applications
// that want to show an undeterminate value on the scale, without changing the
// layout of the application (such as movie or music players).
//
//
// GtkScale as GtkBuildable
//
// GtkScale supports a custom <marks> element, which can contain multiple <mark>
// elements. The “value” and “position” attributes have the same meaning as
// gtk_scale_add_mark() parameters of the same name. If the element is not
// empty, its content is taken as the markup to show at the mark. It can be
// translated with the usual ”translatable” and “context” attributes.
//
// CSS nodes
//
//    scale[.fine-tune][.marks-before][.marks-after]
//    ├── marks.top
//    │   ├── mark
//    │   ┊    ├── [label]
//    │   ┊    ╰── indicator
//    ┊   ┊
//    │   ╰── mark
//    ├── [value]
//    ├── contents
//    │   ╰── trough
//    │       ├── slider
//    │       ├── [highlight]
//    │       ╰── [fill]
//    ╰── marks.bottom
//        ├── mark
//        ┊    ├── indicator
//        ┊    ╰── [label]
//        ╰── mark
//
// GtkScale has a main CSS node with name scale and a subnode for its contents,
// with subnodes named trough and slider.
//
// The main node gets the style class .fine-tune added when the scale is in
// 'fine-tuning' mode.
//
// If the scale has an origin (see gtk_scale_set_has_origin()), there is a
// subnode with name highlight below the trough node that is used for rendering
// the highlighted part of the trough.
//
// If the scale is showing a fill level (see gtk_range_set_show_fill_level()),
// there is a subnode with name fill below the trough node that is used for
// rendering the filled in part of the trough.
//
// If marks are present, there is a marks subnode before or after the contents
// node, below which each mark gets a node with name mark. The marks nodes get
// either the .top or .bottom style class.
//
// The mark node has a subnode named indicator. If the mark has text, it also
// has a subnode named label. When the mark is either above or left of the
// scale, the label subnode is the first when present. Otherwise, the indicator
// subnode is the first.
//
// The main CSS node gets the 'marks-before' and/or 'marks-after' style classes
// added depending on what marks are present.
//
// If the scale is displaying the value (see Scale:draw-value), there is subnode
// with name value.
type Scale interface {
	Range
	Buildable
	Orientable

	// AddMark adds a mark at @value.
	//
	// A mark is indicated visually by drawing a tick mark next to the scale,
	// and GTK+ makes it easy for the user to position the scale exactly at the
	// marks value.
	//
	// If @markup is not nil, text is shown next to the tick mark.
	//
	// To remove marks from a scale, use gtk_scale_clear_marks().
	AddMark(value float64, position PositionType, markup string)
	// ClearMarks removes any marks that have been added with
	// gtk_scale_add_mark().
	ClearMarks()
	// Digits gets the number of decimal places that are displayed in the value.
	Digits() int
	// DrawValue returns whether the current value is displayed as a string next
	// to the slider.
	DrawValue() bool
	// HasOrigin returns whether the scale has an origin.
	HasOrigin() bool
	// Layout gets the Layout used to display the scale. The returned object is
	// owned by the scale so does not need to be freed by the caller.
	Layout() pango.Layout
	// LayoutOffsets obtains the coordinates where the scale will draw the
	// Layout representing the text in the scale. Remember when using the Layout
	// function you need to convert to and from pixels using PANGO_PIXELS() or
	// NGO_SCALE.
	//
	// If the Scale:draw-value property is false, the return values are
	// undefined.
	LayoutOffsets() (x int, y int)
	// ValuePos gets the position in which the current value is displayed.
	ValuePos() PositionType
	// SetDigits sets the number of decimal places that are displayed in the
	// value. Also causes the value of the adjustment to be rounded to this
	// number of digits, so the retrieved value matches the displayed one, if
	// Scale:draw-value is true when the value changes. If you want to enforce
	// rounding the value when Scale:draw-value is false, you can set
	// Range:round-digits instead.
	//
	// Note that rounding to a small number of digits can interfere with the
	// smooth autoscrolling that is built into Scale. As an alternative, you can
	// use the Scale::format-value signal to format the displayed value
	// yourself.
	SetDigits(digits int)
	// SetDrawValue specifies whether the current value is displayed as a string
	// next to the slider.
	SetDrawValue(drawValue bool)
	// SetHasOrigin: if Scale:has-origin is set to true (the default), the scale
	// will highlight the part of the trough between the origin (bottom or left
	// side) and the current value.
	SetHasOrigin(hasOrigin bool)
	// SetValuePos sets the position in which the current value is displayed.
	SetValuePos(pos PositionType)
}

// scale implements the Scale class.
type scale struct {
	Range
	Buildable
	Orientable
}

var _ Scale = (*scale)(nil)

// WrapScale wraps a GObject to the right type. It is
// primarily used internally.
func WrapScale(obj *externglib.Object) Scale {
	return scale{
		Range:      WrapRange(obj),
		Buildable:  WrapBuildable(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalScale(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapScale(obj), nil
}

// NewScale creates a new Scale.
func NewScale(orientation Orientation, adjustment Adjustment) Scale {
	var _arg1 C.GtkOrientation // out
	var _arg2 *C.GtkAdjustment // out
	var _cret *C.GtkWidget     // in

	_arg1 = (C.GtkOrientation)(orientation)
	_arg2 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	_cret = C.gtk_scale_new(_arg1, _arg2)

	var _scale Scale // out

	_scale = WrapScale(externglib.Take(unsafe.Pointer(_cret)))

	return _scale
}

// NewScaleWithRange creates a new scale widget with the given orientation that
// lets the user input a number between @min and @max (including @min and @max)
// with the increment @step. @step must be nonzero; it’s the distance the slider
// moves when using the arrow keys to adjust the scale value.
//
// Note that the way in which the precision is derived works best if @step is a
// power of ten. If the resulting precision is not suitable for your needs, use
// gtk_scale_set_digits() to correct it.
func NewScaleWithRange(orientation Orientation, min float64, max float64, step float64) Scale {
	var _arg1 C.GtkOrientation // out
	var _arg2 C.gdouble        // out
	var _arg3 C.gdouble        // out
	var _arg4 C.gdouble        // out
	var _cret *C.GtkWidget     // in

	_arg1 = (C.GtkOrientation)(orientation)
	_arg2 = (C.gdouble)(min)
	_arg3 = (C.gdouble)(max)
	_arg4 = (C.gdouble)(step)

	_cret = C.gtk_scale_new_with_range(_arg1, _arg2, _arg3, _arg4)

	var _scale Scale // out

	_scale = WrapScale(externglib.Take(unsafe.Pointer(_cret)))

	return _scale
}

// AddMark adds a mark at @value.
//
// A mark is indicated visually by drawing a tick mark next to the scale, and
// GTK+ makes it easy for the user to position the scale exactly at the marks
// value.
//
// If @markup is not nil, text is shown next to the tick mark.
//
// To remove marks from a scale, use gtk_scale_clear_marks().
func (s scale) AddMark(value float64, position PositionType, markup string) {
	var _arg0 *C.GtkScale       // out
	var _arg1 C.gdouble         // out
	var _arg2 C.GtkPositionType // out
	var _arg3 *C.gchar          // out

	_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gdouble)(value)
	_arg2 = (C.GtkPositionType)(position)
	_arg3 = (*C.gchar)(C.CString(markup))
	defer C.free(unsafe.Pointer(_arg3))

	C.gtk_scale_add_mark(_arg0, _arg1, _arg2, _arg3)
}

// ClearMarks removes any marks that have been added with gtk_scale_add_mark().
func (s scale) ClearMarks() {
	var _arg0 *C.GtkScale // out

	_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))

	C.gtk_scale_clear_marks(_arg0)
}

// Digits gets the number of decimal places that are displayed in the value.
func (s scale) Digits() int {
	var _arg0 *C.GtkScale // out
	var _cret C.gint      // in

	_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scale_get_digits(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// DrawValue returns whether the current value is displayed as a string next to
// the slider.
func (s scale) DrawValue() bool {
	var _arg0 *C.GtkScale // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scale_get_draw_value(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasOrigin returns whether the scale has an origin.
func (s scale) HasOrigin() bool {
	var _arg0 *C.GtkScale // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scale_get_has_origin(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Layout gets the Layout used to display the scale. The returned object is
// owned by the scale so does not need to be freed by the caller.
func (s scale) Layout() pango.Layout {
	var _arg0 *C.GtkScale    // out
	var _cret *C.PangoLayout // in

	_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scale_get_layout(_arg0)

	var _layout pango.Layout // out

	_layout = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(pango.Layout)

	return _layout
}

// LayoutOffsets obtains the coordinates where the scale will draw the Layout
// representing the text in the scale. Remember when using the Layout function
// you need to convert to and from pixels using PANGO_PIXELS() or NGO_SCALE.
//
// If the Scale:draw-value property is false, the return values are undefined.
func (s scale) LayoutOffsets() (x int, y int) {
	var _arg0 *C.GtkScale // out
	var _arg1 C.gint      // in
	var _arg2 C.gint      // in

	_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))

	C.gtk_scale_get_layout_offsets(_arg0, &_arg1, &_arg2)

	var _x int // out
	var _y int // out

	_x = (int)(_arg1)
	_y = (int)(_arg2)

	return _x, _y
}

// ValuePos gets the position in which the current value is displayed.
func (s scale) ValuePos() PositionType {
	var _arg0 *C.GtkScale       // out
	var _cret C.GtkPositionType // in

	_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scale_get_value_pos(_arg0)

	var _positionType PositionType // out

	_positionType = PositionType(_cret)

	return _positionType
}

// SetDigits sets the number of decimal places that are displayed in the value.
// Also causes the value of the adjustment to be rounded to this number of
// digits, so the retrieved value matches the displayed one, if Scale:draw-value
// is true when the value changes. If you want to enforce rounding the value
// when Scale:draw-value is false, you can set Range:round-digits instead.
//
// Note that rounding to a small number of digits can interfere with the smooth
// autoscrolling that is built into Scale. As an alternative, you can use the
// Scale::format-value signal to format the displayed value yourself.
func (s scale) SetDigits(digits int) {
	var _arg0 *C.GtkScale // out
	var _arg1 C.gint      // out

	_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gint)(digits)

	C.gtk_scale_set_digits(_arg0, _arg1)
}

// SetDrawValue specifies whether the current value is displayed as a string
// next to the slider.
func (s scale) SetDrawValue(drawValue bool) {
	var _arg0 *C.GtkScale // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))
	if drawValue {
		_arg1 = C.TRUE
	}

	C.gtk_scale_set_draw_value(_arg0, _arg1)
}

// SetHasOrigin: if Scale:has-origin is set to true (the default), the scale
// will highlight the part of the trough between the origin (bottom or left
// side) and the current value.
func (s scale) SetHasOrigin(hasOrigin bool) {
	var _arg0 *C.GtkScale // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))
	if hasOrigin {
		_arg1 = C.TRUE
	}

	C.gtk_scale_set_has_origin(_arg0, _arg1)
}

// SetValuePos sets the position in which the current value is displayed.
func (s scale) SetValuePos(pos PositionType) {
	var _arg0 *C.GtkScale       // out
	var _arg1 C.GtkPositionType // out

	_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkPositionType)(pos)

	C.gtk_scale_set_value_pos(_arg0, _arg1)
}

type ScaleAccessible interface {
	RangeAccessible
}

// scaleAccessible implements the ScaleAccessible class.
type scaleAccessible struct {
	RangeAccessible
}

var _ ScaleAccessible = (*scaleAccessible)(nil)

// WrapScaleAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapScaleAccessible(obj *externglib.Object) ScaleAccessible {
	return scaleAccessible{
		RangeAccessible: WrapRangeAccessible(obj),
	}
}

func marshalScaleAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapScaleAccessible(obj), nil
}

// ScaleButton provides a button which pops up a scale widget. This kind of
// widget is commonly used for volume controls in multimedia applications, and
// GTK+ provides a VolumeButton subclass that is tailored for this use case.
//
//
// CSS nodes
//
// GtkScaleButton has a single CSS node with name button. To differentiate it
// from a plain Button, it gets the .scale style class.
//
// The popup widget that contains the scale has a .scale-popup style class.
type ScaleButton interface {
	Button
	Actionable
	Activatable
	Buildable
	Orientable

	// Adjustment gets the Adjustment associated with the ScaleButton’s scale.
	// See gtk_range_get_adjustment() for details.
	Adjustment() Adjustment
	// MinusButton retrieves the minus button of the ScaleButton.
	MinusButton() Button
	// PlusButton retrieves the plus button of the ScaleButton.
	PlusButton() Button
	// Popup retrieves the popup of the ScaleButton.
	Popup() Widget
	// Value gets the current value of the scale button.
	Value() float64
	// SetAdjustment sets the Adjustment to be used as a model for the
	// ScaleButton’s scale. See gtk_range_set_adjustment() for details.
	SetAdjustment(adjustment Adjustment)
	// SetIcons sets the icons to be used by the scale button. For details, see
	// the ScaleButton:icons property.
	SetIcons(icons []string)
	// SetValue sets the current value of the scale; if the value is outside the
	// minimum or maximum range values, it will be clamped to fit inside them.
	// The scale button emits the ScaleButton::value-changed signal if the value
	// changes.
	SetValue(value float64)
}

// scaleButton implements the ScaleButton class.
type scaleButton struct {
	Button
	Actionable
	Activatable
	Buildable
	Orientable
}

var _ ScaleButton = (*scaleButton)(nil)

// WrapScaleButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapScaleButton(obj *externglib.Object) ScaleButton {
	return scaleButton{
		Button:      WrapButton(obj),
		Actionable:  WrapActionable(obj),
		Activatable: WrapActivatable(obj),
		Buildable:   WrapBuildable(obj),
		Orientable:  WrapOrientable(obj),
	}
}

func marshalScaleButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapScaleButton(obj), nil
}

// NewScaleButton creates a ScaleButton, with a range between @min and @max,
// with a stepping of @step.
func NewScaleButton(size int, min float64, max float64, step float64, icons []string) ScaleButton {
	var _arg1 C.GtkIconSize // out
	var _arg2 C.gdouble     // out
	var _arg3 C.gdouble     // out
	var _arg4 C.gdouble     // out
	var _arg5 **C.gchar
	var _cret *C.GtkWidget // in

	_arg1 = (C.GtkIconSize)(size)
	_arg2 = (C.gdouble)(min)
	_arg3 = (C.gdouble)(max)
	_arg4 = (C.gdouble)(step)
	_arg5 = (**C.gchar)(C.malloc(C.ulong(len(icons)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg5))
	{
		out := unsafe.Slice(_arg5, len(icons))
		for i := range icons {
			out[i] = (*C.gchar)(C.CString(icons[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.gtk_scale_button_new(_arg1, _arg2, _arg3, _arg4, _arg5)

	var _scaleButton ScaleButton // out

	_scaleButton = WrapScaleButton(externglib.Take(unsafe.Pointer(_cret)))

	return _scaleButton
}

// Adjustment gets the Adjustment associated with the ScaleButton’s scale. See
// gtk_range_get_adjustment() for details.
func (b scaleButton) Adjustment() Adjustment {
	var _arg0 *C.GtkScaleButton // out
	var _cret *C.GtkAdjustment  // in

	_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_scale_button_get_adjustment(_arg0)

	var _adjustment Adjustment // out

	_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

	return _adjustment
}

// MinusButton retrieves the minus button of the ScaleButton.
func (b scaleButton) MinusButton() Button {
	var _arg0 *C.GtkScaleButton // out
	var _cret *C.GtkWidget      // in

	_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_scale_button_get_minus_button(_arg0)

	var _ret Button // out

	_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Button)

	return _ret
}

// PlusButton retrieves the plus button of the ScaleButton.
func (b scaleButton) PlusButton() Button {
	var _arg0 *C.GtkScaleButton // out
	var _cret *C.GtkWidget      // in

	_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_scale_button_get_plus_button(_arg0)

	var _ret Button // out

	_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Button)

	return _ret
}

// Popup retrieves the popup of the ScaleButton.
func (b scaleButton) Popup() Widget {
	var _arg0 *C.GtkScaleButton // out
	var _cret *C.GtkWidget      // in

	_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_scale_button_get_popup(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// Value gets the current value of the scale button.
func (b scaleButton) Value() float64 {
	var _arg0 *C.GtkScaleButton // out
	var _cret C.gdouble         // in

	_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_scale_button_get_value(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// SetAdjustment sets the Adjustment to be used as a model for the ScaleButton’s
// scale. See gtk_range_set_adjustment() for details.
func (b scaleButton) SetAdjustment(adjustment Adjustment) {
	var _arg0 *C.GtkScaleButton // out
	var _arg1 *C.GtkAdjustment  // out

	_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	C.gtk_scale_button_set_adjustment(_arg0, _arg1)
}

// SetIcons sets the icons to be used by the scale button. For details, see the
// ScaleButton:icons property.
func (b scaleButton) SetIcons(icons []string) {
	var _arg0 *C.GtkScaleButton // out
	var _arg1 **C.gchar

	_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(b.Native()))
	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(icons)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(icons))
		for i := range icons {
			out[i] = (*C.gchar)(C.CString(icons[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.gtk_scale_button_set_icons(_arg0, _arg1)
}

// SetValue sets the current value of the scale; if the value is outside the
// minimum or maximum range values, it will be clamped to fit inside them. The
// scale button emits the ScaleButton::value-changed signal if the value
// changes.
func (b scaleButton) SetValue(value float64) {
	var _arg0 *C.GtkScaleButton // out
	var _arg1 C.gdouble         // out

	_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(b.Native()))
	_arg1 = (C.gdouble)(value)

	C.gtk_scale_button_set_value(_arg0, _arg1)
}

type ScaleButtonAccessible interface {
	ButtonAccessible
}

// scaleButtonAccessible implements the ScaleButtonAccessible class.
type scaleButtonAccessible struct {
	ButtonAccessible
}

var _ ScaleButtonAccessible = (*scaleButtonAccessible)(nil)

// WrapScaleButtonAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapScaleButtonAccessible(obj *externglib.Object) ScaleButtonAccessible {
	return scaleButtonAccessible{
		ButtonAccessible: WrapButtonAccessible(obj),
	}
}

func marshalScaleButtonAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapScaleButtonAccessible(obj), nil
}

// Scrollbar: the Scrollbar widget is a horizontal or vertical scrollbar,
// depending on the value of the Orientable:orientation property.
//
// Its position and movement are controlled by the adjustment that is passed to
// or created by gtk_scrollbar_new(). See Adjustment for more details. The
// Adjustment:value field sets the position of the thumb and must be between
// Adjustment:lower and Adjustment:upper - Adjustment:page-size. The
// Adjustment:page-size represents the size of the visible scrollable area. The
// fields Adjustment:step-increment and Adjustment:page-increment fields are
// added to or subtracted from the Adjustment:value when the user asks to move
// by a step (using e.g. the cursor arrow keys or, if present, the stepper
// buttons) or by a page (using e.g. the Page Down/Up keys).
//
// CSS nodes
//
//    scrollbar[.fine-tune]
//    ╰── contents
//        ├── [button.up]
//        ├── [button.down]
//        ├── trough
//        │   ╰── slider
//        ├── [button.up]
//        ╰── [button.down]
//
// GtkScrollbar has a main CSS node with name scrollbar and a subnode for its
// contents, with subnodes named trough and slider.
//
// The main node gets the style class .fine-tune added when the scrollbar is in
// 'fine-tuning' mode.
//
// If steppers are enabled, they are represented by up to four additional
// subnodes with name button. These get the style classes .up and .down to
// indicate in which direction they are moving.
//
// Other style classes that may be added to scrollbars inside ScrolledWindow
// include the positional classes (.left, .right, .top, .bottom) and style
// classes related to overlay scrolling (.overlay-indicator, .dragging,
// .hovering).
type Scrollbar interface {
	Range
	Buildable
	Orientable
}

// scrollbar implements the Scrollbar class.
type scrollbar struct {
	Range
	Buildable
	Orientable
}

var _ Scrollbar = (*scrollbar)(nil)

// WrapScrollbar wraps a GObject to the right type. It is
// primarily used internally.
func WrapScrollbar(obj *externglib.Object) Scrollbar {
	return scrollbar{
		Range:      WrapRange(obj),
		Buildable:  WrapBuildable(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalScrollbar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapScrollbar(obj), nil
}

// NewScrollbar creates a new scrollbar with the given orientation.
func NewScrollbar(orientation Orientation, adjustment Adjustment) Scrollbar {
	var _arg1 C.GtkOrientation // out
	var _arg2 *C.GtkAdjustment // out
	var _cret *C.GtkWidget     // in

	_arg1 = (C.GtkOrientation)(orientation)
	_arg2 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	_cret = C.gtk_scrollbar_new(_arg1, _arg2)

	var _scrollbar Scrollbar // out

	_scrollbar = WrapScrollbar(externglib.Take(unsafe.Pointer(_cret)))

	return _scrollbar
}

// ScrolledWindow: gtkScrolledWindow is a container that accepts a single child
// widget, makes that child scrollable using either internally added scrollbars
// or externally associated adjustments, and optionally draws a frame around the
// child.
//
// Widgets with native scrolling support, i.e. those whose classes implement the
// Scrollable interface, are added directly. For other types of widget, the
// class Viewport acts as an adaptor, giving scrollability to other widgets.
// GtkScrolledWindow’s implementation of gtk_container_add() intelligently
// accounts for whether or not the added child is a Scrollable. If it isn’t,
// ScrolledWindow wraps the child in a Viewport and adds that for you.
// Therefore, you can just add any child widget and not worry about the details.
//
// If gtk_container_add() has added a Viewport for you, you can remove both your
// added child widget from the Viewport, and the Viewport from the
// GtkScrolledWindow, like this:
//
//    GtkWidget *scrolled_window = gtk_scrolled_window_new (NULL, NULL);
//    GtkWidget *child_widget = gtk_button_new ();
//
//    // GtkButton is not a GtkScrollable, so GtkScrolledWindow will automatically
//    // add a GtkViewport.
//    gtk_container_add (GTK_CONTAINER (scrolled_window),
//                       child_widget);
//
//    // Either of these will result in child_widget being unparented:
//    gtk_container_remove (GTK_CONTAINER (scrolled_window),
//                          child_widget);
//    // or
//    gtk_container_remove (GTK_CONTAINER (scrolled_window),
//                          gtk_bin_get_child (GTK_BIN (scrolled_window)));
//
// Unless ScrolledWindow:policy is GTK_POLICY_NEVER or GTK_POLICY_EXTERNAL,
// GtkScrolledWindow adds internal Scrollbar widgets around its child. The
// scroll position of the child, and if applicable the scrollbars, is controlled
// by the ScrolledWindow:hadjustment and ScrolledWindow:vadjustment that are
// associated with the GtkScrolledWindow. See the docs on Scrollbar for the
// details, but note that the “step_increment” and “page_increment” fields are
// only effective if the policy causes scrollbars to be present.
//
// If a GtkScrolledWindow doesn’t behave quite as you would like, or doesn’t
// have exactly the right layout, it’s very possible to set up your own
// scrolling with Scrollbar and for example a Grid.
//
//
// Touch support
//
// GtkScrolledWindow has built-in support for touch devices. When a touchscreen
// is used, swiping will move the scrolled window, and will expose 'kinetic'
// behavior. This can be turned off with the ScrolledWindow:kinetic-scrolling
// property if it is undesired.
//
// GtkScrolledWindow also displays visual 'overshoot' indication when the
// content is pulled beyond the end, and this situation can be captured with the
// ScrolledWindow::edge-overshot signal.
//
// If no mouse device is present, the scrollbars will overlayed as narrow,
// auto-hiding indicators over the content. If traditional scrollbars are
// desired although no mouse is present, this behaviour can be turned off with
// the ScrolledWindow:overlay-scrolling property.
//
//
// CSS nodes
//
// GtkScrolledWindow has a main CSS node with name scrolledwindow.
//
// It uses subnodes with names overshoot and undershoot to draw the overflow and
// underflow indications. These nodes get the .left, .right, .top or .bottom
// style class added depending on where the indication is drawn.
//
// GtkScrolledWindow also sets the positional style classes (.left, .right,
// .top, .bottom) and style classes related to overlay scrolling
// (.overlay-indicator, .dragging, .hovering) on its scrollbars.
//
// If both scrollbars are visible, the area where they meet is drawn with a
// subnode named junction.
type ScrolledWindow interface {
	Bin
	Buildable

	// AddWithViewport: used to add children without native scrolling
	// capabilities. This is simply a convenience function; it is equivalent to
	// adding the unscrollable child to a viewport, then adding the viewport to
	// the scrolled window. If a child has native scrolling, use
	// gtk_container_add() instead of this function.
	//
	// The viewport scrolls the child by moving its Window, and takes the size
	// of the child to be the size of its toplevel Window. This will be very
	// wrong for most widgets that support native scrolling; for example, if you
	// add a widget such as TreeView with a viewport, the whole widget will
	// scroll, including the column headings. Thus, widgets with native
	// scrolling support should not be used with the Viewport proxy.
	//
	// A widget supports scrolling natively if it implements the Scrollable
	// interface.
	AddWithViewport(child Widget)
	// CaptureButtonPress: return whether button presses are captured during
	// kinetic scrolling. See gtk_scrolled_window_set_capture_button_press().
	CaptureButtonPress() bool
	// HAdjustment returns the horizontal scrollbar’s adjustment, used to
	// connect the horizontal scrollbar to the child widget’s horizontal scroll
	// functionality.
	HAdjustment() Adjustment
	// HScrollbar returns the horizontal scrollbar of @scrolled_window.
	HScrollbar() Widget
	// KineticScrolling returns the specified kinetic scrolling behavior.
	KineticScrolling() bool
	// MaxContentHeight returns the maximum content height set.
	MaxContentHeight() int
	// MaxContentWidth returns the maximum content width set.
	MaxContentWidth() int
	// MinContentHeight gets the minimal content height of @scrolled_window, or
	// -1 if not set.
	MinContentHeight() int
	// MinContentWidth gets the minimum content width of @scrolled_window, or -1
	// if not set.
	MinContentWidth() int
	// OverlayScrolling returns whether overlay scrolling is enabled for this
	// scrolled window.
	OverlayScrolling() bool
	// Placement gets the placement of the contents with respect to the
	// scrollbars for the scrolled window. See
	// gtk_scrolled_window_set_placement().
	Placement() CornerType
	// Policy retrieves the current policy values for the horizontal and
	// vertical scrollbars. See gtk_scrolled_window_set_policy().
	Policy() (hscrollbarPolicy PolicyType, vscrollbarPolicy PolicyType)
	// PropagateNaturalHeight reports whether the natural height of the child
	// will be calculated and propagated through the scrolled window’s requested
	// natural height.
	PropagateNaturalHeight() bool
	// PropagateNaturalWidth reports whether the natural width of the child will
	// be calculated and propagated through the scrolled window’s requested
	// natural width.
	PropagateNaturalWidth() bool
	// ShadowType gets the shadow type of the scrolled window. See
	// gtk_scrolled_window_set_shadow_type().
	ShadowType() ShadowType
	// VAdjustment returns the vertical scrollbar’s adjustment, used to connect
	// the vertical scrollbar to the child widget’s vertical scroll
	// functionality.
	VAdjustment() Adjustment
	// VScrollbar returns the vertical scrollbar of @scrolled_window.
	VScrollbar() Widget
	// SetCaptureButtonPress changes the behaviour of @scrolled_window with
	// regard to the initial event that possibly starts kinetic scrolling. When
	// @capture_button_press is set to true, the event is captured by the
	// scrolled window, and then later replayed if it is meant to go to the
	// child widget.
	//
	// This should be enabled if any child widgets perform non-reversible
	// actions on Widget::button-press-event. If they don't, and handle
	// additionally handle Widget::grab-broken-event, it might be better to set
	// @capture_button_press to false.
	//
	// This setting only has an effect if kinetic scrolling is enabled.
	SetCaptureButtonPress(captureButtonPress bool)
	// SetHAdjustment sets the Adjustment for the horizontal scrollbar.
	SetHAdjustment(hadjustment Adjustment)
	// SetKineticScrolling turns kinetic scrolling on or off. Kinetic scrolling
	// only applies to devices with source GDK_SOURCE_TOUCHSCREEN.
	SetKineticScrolling(kineticScrolling bool)
	// SetMaxContentHeight sets the maximum height that @scrolled_window should
	// keep visible. The @scrolled_window will grow up to this height before it
	// starts scrolling the content.
	//
	// It is a programming error to set the maximum content height to a value
	// smaller than ScrolledWindow:min-content-height.
	SetMaxContentHeight(height int)
	// SetMaxContentWidth sets the maximum width that @scrolled_window should
	// keep visible. The @scrolled_window will grow up to this width before it
	// starts scrolling the content.
	//
	// It is a programming error to set the maximum content width to a value
	// smaller than ScrolledWindow:min-content-width.
	SetMaxContentWidth(width int)
	// SetMinContentHeight sets the minimum height that @scrolled_window should
	// keep visible. Note that this can and (usually will) be smaller than the
	// minimum size of the content.
	//
	// It is a programming error to set the minimum content height to a value
	// greater than ScrolledWindow:max-content-height.
	SetMinContentHeight(height int)
	// SetMinContentWidth sets the minimum width that @scrolled_window should
	// keep visible. Note that this can and (usually will) be smaller than the
	// minimum size of the content.
	//
	// It is a programming error to set the minimum content width to a value
	// greater than ScrolledWindow:max-content-width.
	SetMinContentWidth(width int)
	// SetOverlayScrolling enables or disables overlay scrolling for this
	// scrolled window.
	SetOverlayScrolling(overlayScrolling bool)
	// SetPlacement sets the placement of the contents with respect to the
	// scrollbars for the scrolled window.
	//
	// The default is GTK_CORNER_TOP_LEFT, meaning the child is in the top left,
	// with the scrollbars underneath and to the right. Other values in
	// CornerType are GTK_CORNER_TOP_RIGHT, GTK_CORNER_BOTTOM_LEFT, and
	// GTK_CORNER_BOTTOM_RIGHT.
	//
	// See also gtk_scrolled_window_get_placement() and
	// gtk_scrolled_window_unset_placement().
	SetPlacement(windowPlacement CornerType)
	// SetPolicy sets the scrollbar policy for the horizontal and vertical
	// scrollbars.
	//
	// The policy determines when the scrollbar should appear; it is a value
	// from the PolicyType enumeration. If GTK_POLICY_ALWAYS, the scrollbar is
	// always present; if GTK_POLICY_NEVER, the scrollbar is never present; if
	// GTK_POLICY_AUTOMATIC, the scrollbar is present only if needed (that is,
	// if the slider part of the bar would be smaller than the trough — the
	// display is larger than the page size).
	SetPolicy(hscrollbarPolicy PolicyType, vscrollbarPolicy PolicyType)
	// SetPropagateNaturalHeight sets whether the natural height of the child
	// should be calculated and propagated through the scrolled window’s
	// requested natural height.
	SetPropagateNaturalHeight(propagate bool)
	// SetPropagateNaturalWidth sets whether the natural width of the child
	// should be calculated and propagated through the scrolled window’s
	// requested natural width.
	SetPropagateNaturalWidth(propagate bool)
	// SetShadowType changes the type of shadow drawn around the contents of
	// @scrolled_window.
	SetShadowType(typ ShadowType)
	// SetVAdjustment sets the Adjustment for the vertical scrollbar.
	SetVAdjustment(vadjustment Adjustment)
	// UnsetPlacement unsets the placement of the contents with respect to the
	// scrollbars for the scrolled window. If no window placement is set for a
	// scrolled window, it defaults to GTK_CORNER_TOP_LEFT.
	//
	// See also gtk_scrolled_window_set_placement() and
	// gtk_scrolled_window_get_placement().
	UnsetPlacement()
}

// scrolledWindow implements the ScrolledWindow class.
type scrolledWindow struct {
	Bin
	Buildable
}

var _ ScrolledWindow = (*scrolledWindow)(nil)

// WrapScrolledWindow wraps a GObject to the right type. It is
// primarily used internally.
func WrapScrolledWindow(obj *externglib.Object) ScrolledWindow {
	return scrolledWindow{
		Bin:       WrapBin(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalScrolledWindow(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapScrolledWindow(obj), nil
}

// NewScrolledWindow creates a new scrolled window.
//
// The two arguments are the scrolled window’s adjustments; these will be shared
// with the scrollbars and the child widget to keep the bars in sync with the
// child. Usually you want to pass nil for the adjustments, which will cause the
// scrolled window to create them for you.
func NewScrolledWindow(hadjustment Adjustment, vadjustment Adjustment) ScrolledWindow {
	var _arg1 *C.GtkAdjustment // out
	var _arg2 *C.GtkAdjustment // out
	var _cret *C.GtkWidget     // in

	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(hadjustment.Native()))
	_arg2 = (*C.GtkAdjustment)(unsafe.Pointer(vadjustment.Native()))

	_cret = C.gtk_scrolled_window_new(_arg1, _arg2)

	var _scrolledWindow ScrolledWindow // out

	_scrolledWindow = WrapScrolledWindow(externglib.Take(unsafe.Pointer(_cret)))

	return _scrolledWindow
}

// AddWithViewport: used to add children without native scrolling capabilities.
// This is simply a convenience function; it is equivalent to adding the
// unscrollable child to a viewport, then adding the viewport to the scrolled
// window. If a child has native scrolling, use gtk_container_add() instead of
// this function.
//
// The viewport scrolls the child by moving its Window, and takes the size of
// the child to be the size of its toplevel Window. This will be very wrong for
// most widgets that support native scrolling; for example, if you add a widget
// such as TreeView with a viewport, the whole widget will scroll, including the
// column headings. Thus, widgets with native scrolling support should not be
// used with the Viewport proxy.
//
// A widget supports scrolling natively if it implements the Scrollable
// interface.
func (s scrolledWindow) AddWithViewport(child Widget) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 *C.GtkWidget         // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_scrolled_window_add_with_viewport(_arg0, _arg1)
}

// CaptureButtonPress: return whether button presses are captured during kinetic
// scrolling. See gtk_scrolled_window_set_capture_button_press().
func (s scrolledWindow) CaptureButtonPress() bool {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_capture_button_press(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HAdjustment returns the horizontal scrollbar’s adjustment, used to connect
// the horizontal scrollbar to the child widget’s horizontal scroll
// functionality.
func (s scrolledWindow) HAdjustment() Adjustment {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret *C.GtkAdjustment     // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_hadjustment(_arg0)

	var _adjustment Adjustment // out

	_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

	return _adjustment
}

// HScrollbar returns the horizontal scrollbar of @scrolled_window.
func (s scrolledWindow) HScrollbar() Widget {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret *C.GtkWidget         // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_hscrollbar(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// KineticScrolling returns the specified kinetic scrolling behavior.
func (s scrolledWindow) KineticScrolling() bool {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_kinetic_scrolling(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MaxContentHeight returns the maximum content height set.
func (s scrolledWindow) MaxContentHeight() int {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.gint               // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_max_content_height(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// MaxContentWidth returns the maximum content width set.
func (s scrolledWindow) MaxContentWidth() int {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.gint               // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_max_content_width(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// MinContentHeight gets the minimal content height of @scrolled_window, or -1
// if not set.
func (s scrolledWindow) MinContentHeight() int {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.gint               // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_min_content_height(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// MinContentWidth gets the minimum content width of @scrolled_window, or -1 if
// not set.
func (s scrolledWindow) MinContentWidth() int {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.gint               // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_min_content_width(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// OverlayScrolling returns whether overlay scrolling is enabled for this
// scrolled window.
func (s scrolledWindow) OverlayScrolling() bool {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_overlay_scrolling(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Placement gets the placement of the contents with respect to the scrollbars
// for the scrolled window. See gtk_scrolled_window_set_placement().
func (s scrolledWindow) Placement() CornerType {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.GtkCornerType      // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_placement(_arg0)

	var _cornerType CornerType // out

	_cornerType = CornerType(_cret)

	return _cornerType
}

// Policy retrieves the current policy values for the horizontal and vertical
// scrollbars. See gtk_scrolled_window_set_policy().
func (s scrolledWindow) Policy() (hscrollbarPolicy PolicyType, vscrollbarPolicy PolicyType) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.GtkPolicyType      // in
	var _arg2 C.GtkPolicyType      // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	C.gtk_scrolled_window_get_policy(_arg0, &_arg1, &_arg2)

	var _hscrollbarPolicy PolicyType // out
	var _vscrollbarPolicy PolicyType // out

	_hscrollbarPolicy = PolicyType(_arg1)
	_vscrollbarPolicy = PolicyType(_arg2)

	return _hscrollbarPolicy, _vscrollbarPolicy
}

// PropagateNaturalHeight reports whether the natural height of the child will
// be calculated and propagated through the scrolled window’s requested natural
// height.
func (s scrolledWindow) PropagateNaturalHeight() bool {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_propagate_natural_height(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PropagateNaturalWidth reports whether the natural width of the child will be
// calculated and propagated through the scrolled window’s requested natural
// width.
func (s scrolledWindow) PropagateNaturalWidth() bool {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_propagate_natural_width(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShadowType gets the shadow type of the scrolled window. See
// gtk_scrolled_window_set_shadow_type().
func (s scrolledWindow) ShadowType() ShadowType {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.GtkShadowType      // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_shadow_type(_arg0)

	var _shadowType ShadowType // out

	_shadowType = ShadowType(_cret)

	return _shadowType
}

// VAdjustment returns the vertical scrollbar’s adjustment, used to connect the
// vertical scrollbar to the child widget’s vertical scroll functionality.
func (s scrolledWindow) VAdjustment() Adjustment {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret *C.GtkAdjustment     // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_vadjustment(_arg0)

	var _adjustment Adjustment // out

	_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

	return _adjustment
}

// VScrollbar returns the vertical scrollbar of @scrolled_window.
func (s scrolledWindow) VScrollbar() Widget {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret *C.GtkWidget         // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_vscrollbar(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// SetCaptureButtonPress changes the behaviour of @scrolled_window with regard
// to the initial event that possibly starts kinetic scrolling. When
// @capture_button_press is set to true, the event is captured by the scrolled
// window, and then later replayed if it is meant to go to the child widget.
//
// This should be enabled if any child widgets perform non-reversible actions on
// Widget::button-press-event. If they don't, and handle additionally handle
// Widget::grab-broken-event, it might be better to set @capture_button_press to
// false.
//
// This setting only has an effect if kinetic scrolling is enabled.
func (s scrolledWindow) SetCaptureButtonPress(captureButtonPress bool) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	if captureButtonPress {
		_arg1 = C.TRUE
	}

	C.gtk_scrolled_window_set_capture_button_press(_arg0, _arg1)
}

// SetHAdjustment sets the Adjustment for the horizontal scrollbar.
func (s scrolledWindow) SetHAdjustment(hadjustment Adjustment) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 *C.GtkAdjustment     // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(hadjustment.Native()))

	C.gtk_scrolled_window_set_hadjustment(_arg0, _arg1)
}

// SetKineticScrolling turns kinetic scrolling on or off. Kinetic scrolling only
// applies to devices with source GDK_SOURCE_TOUCHSCREEN.
func (s scrolledWindow) SetKineticScrolling(kineticScrolling bool) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	if kineticScrolling {
		_arg1 = C.TRUE
	}

	C.gtk_scrolled_window_set_kinetic_scrolling(_arg0, _arg1)
}

// SetMaxContentHeight sets the maximum height that @scrolled_window should keep
// visible. The @scrolled_window will grow up to this height before it starts
// scrolling the content.
//
// It is a programming error to set the maximum content height to a value
// smaller than ScrolledWindow:min-content-height.
func (s scrolledWindow) SetMaxContentHeight(height int) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.gint               // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gint)(height)

	C.gtk_scrolled_window_set_max_content_height(_arg0, _arg1)
}

// SetMaxContentWidth sets the maximum width that @scrolled_window should keep
// visible. The @scrolled_window will grow up to this width before it starts
// scrolling the content.
//
// It is a programming error to set the maximum content width to a value smaller
// than ScrolledWindow:min-content-width.
func (s scrolledWindow) SetMaxContentWidth(width int) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.gint               // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gint)(width)

	C.gtk_scrolled_window_set_max_content_width(_arg0, _arg1)
}

// SetMinContentHeight sets the minimum height that @scrolled_window should keep
// visible. Note that this can and (usually will) be smaller than the minimum
// size of the content.
//
// It is a programming error to set the minimum content height to a value
// greater than ScrolledWindow:max-content-height.
func (s scrolledWindow) SetMinContentHeight(height int) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.gint               // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gint)(height)

	C.gtk_scrolled_window_set_min_content_height(_arg0, _arg1)
}

// SetMinContentWidth sets the minimum width that @scrolled_window should keep
// visible. Note that this can and (usually will) be smaller than the minimum
// size of the content.
//
// It is a programming error to set the minimum content width to a value greater
// than ScrolledWindow:max-content-width.
func (s scrolledWindow) SetMinContentWidth(width int) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.gint               // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gint)(width)

	C.gtk_scrolled_window_set_min_content_width(_arg0, _arg1)
}

// SetOverlayScrolling enables or disables overlay scrolling for this scrolled
// window.
func (s scrolledWindow) SetOverlayScrolling(overlayScrolling bool) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	if overlayScrolling {
		_arg1 = C.TRUE
	}

	C.gtk_scrolled_window_set_overlay_scrolling(_arg0, _arg1)
}

// SetPlacement sets the placement of the contents with respect to the
// scrollbars for the scrolled window.
//
// The default is GTK_CORNER_TOP_LEFT, meaning the child is in the top left,
// with the scrollbars underneath and to the right. Other values in CornerType
// are GTK_CORNER_TOP_RIGHT, GTK_CORNER_BOTTOM_LEFT, and
// GTK_CORNER_BOTTOM_RIGHT.
//
// See also gtk_scrolled_window_get_placement() and
// gtk_scrolled_window_unset_placement().
func (s scrolledWindow) SetPlacement(windowPlacement CornerType) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.GtkCornerType      // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkCornerType)(windowPlacement)

	C.gtk_scrolled_window_set_placement(_arg0, _arg1)
}

// SetPolicy sets the scrollbar policy for the horizontal and vertical
// scrollbars.
//
// The policy determines when the scrollbar should appear; it is a value from
// the PolicyType enumeration. If GTK_POLICY_ALWAYS, the scrollbar is always
// present; if GTK_POLICY_NEVER, the scrollbar is never present; if
// GTK_POLICY_AUTOMATIC, the scrollbar is present only if needed (that is, if
// the slider part of the bar would be smaller than the trough — the display is
// larger than the page size).
func (s scrolledWindow) SetPolicy(hscrollbarPolicy PolicyType, vscrollbarPolicy PolicyType) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.GtkPolicyType      // out
	var _arg2 C.GtkPolicyType      // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkPolicyType)(hscrollbarPolicy)
	_arg2 = (C.GtkPolicyType)(vscrollbarPolicy)

	C.gtk_scrolled_window_set_policy(_arg0, _arg1, _arg2)
}

// SetPropagateNaturalHeight sets whether the natural height of the child should
// be calculated and propagated through the scrolled window’s requested natural
// height.
func (s scrolledWindow) SetPropagateNaturalHeight(propagate bool) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	if propagate {
		_arg1 = C.TRUE
	}

	C.gtk_scrolled_window_set_propagate_natural_height(_arg0, _arg1)
}

// SetPropagateNaturalWidth sets whether the natural width of the child should
// be calculated and propagated through the scrolled window’s requested natural
// width.
func (s scrolledWindow) SetPropagateNaturalWidth(propagate bool) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	if propagate {
		_arg1 = C.TRUE
	}

	C.gtk_scrolled_window_set_propagate_natural_width(_arg0, _arg1)
}

// SetShadowType changes the type of shadow drawn around the contents of
// @scrolled_window.
func (s scrolledWindow) SetShadowType(typ ShadowType) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.GtkShadowType      // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkShadowType)(typ)

	C.gtk_scrolled_window_set_shadow_type(_arg0, _arg1)
}

// SetVAdjustment sets the Adjustment for the vertical scrollbar.
func (s scrolledWindow) SetVAdjustment(vadjustment Adjustment) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 *C.GtkAdjustment     // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(vadjustment.Native()))

	C.gtk_scrolled_window_set_vadjustment(_arg0, _arg1)
}

// UnsetPlacement unsets the placement of the contents with respect to the
// scrollbars for the scrolled window. If no window placement is set for a
// scrolled window, it defaults to GTK_CORNER_TOP_LEFT.
//
// See also gtk_scrolled_window_set_placement() and
// gtk_scrolled_window_get_placement().
func (s scrolledWindow) UnsetPlacement() {
	var _arg0 *C.GtkScrolledWindow // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	C.gtk_scrolled_window_unset_placement(_arg0)
}

type ScrolledWindowAccessible interface {
	ContainerAccessible
}

// scrolledWindowAccessible implements the ScrolledWindowAccessible class.
type scrolledWindowAccessible struct {
	ContainerAccessible
}

var _ ScrolledWindowAccessible = (*scrolledWindowAccessible)(nil)

// WrapScrolledWindowAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapScrolledWindowAccessible(obj *externglib.Object) ScrolledWindowAccessible {
	return scrolledWindowAccessible{
		ContainerAccessible: WrapContainerAccessible(obj),
	}
}

func marshalScrolledWindowAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapScrolledWindowAccessible(obj), nil
}

// SearchBar is a container made to have a search entry (possibly with
// additional connex widgets, such as drop-down menus, or buttons) built-in. The
// search bar would appear when a search is started through typing on the
// keyboard, or the application’s search mode is toggled on.
//
// For keyboard presses to start a search, events will need to be forwarded from
// the top-level window that contains the search bar. See
// gtk_search_bar_handle_event() for example code. Common shortcuts such as
// Ctrl+F should be handled as an application action, or through the menu items.
//
// You will also need to tell the search bar about which entry you are using as
// your search entry using gtk_search_bar_connect_entry(). The following example
// shows you how to create a more complex search entry.
//
//
// CSS nodes
//
// GtkSearchBar has a single CSS node with name searchbar.
//
//
// Creating a search bar
//
// A simple example
// (https://gitlab.gnome.org/GNOME/gtk/blob/gtk-3-24/examples/search-bar.c)
type SearchBar interface {
	Bin
	Buildable

	// ConnectEntry connects the Entry widget passed as the one to be used in
	// this search bar. The entry should be a descendant of the search bar. This
	// is only required if the entry isn’t the direct child of the search bar
	// (as in our main example).
	ConnectEntry(entry Entry)
	// SearchMode returns whether the search mode is on or off.
	SearchMode() bool
	// ShowCloseButton returns whether the close button is shown.
	ShowCloseButton() bool
	// SetSearchMode switches the search mode on or off.
	SetSearchMode(searchMode bool)
	// SetShowCloseButton shows or hides the close button. Applications that
	// already have a “search” toggle button should not show a close button in
	// their search bar, as it duplicates the role of the toggle button.
	SetShowCloseButton(visible bool)
}

// searchBar implements the SearchBar class.
type searchBar struct {
	Bin
	Buildable
}

var _ SearchBar = (*searchBar)(nil)

// WrapSearchBar wraps a GObject to the right type. It is
// primarily used internally.
func WrapSearchBar(obj *externglib.Object) SearchBar {
	return searchBar{
		Bin:       WrapBin(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalSearchBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSearchBar(obj), nil
}

// NewSearchBar creates a SearchBar. You will need to tell it about which widget
// is going to be your text entry using gtk_search_bar_connect_entry().
func NewSearchBar() SearchBar {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_search_bar_new()

	var _searchBar SearchBar // out

	_searchBar = WrapSearchBar(externglib.Take(unsafe.Pointer(_cret)))

	return _searchBar
}

// ConnectEntry connects the Entry widget passed as the one to be used in this
// search bar. The entry should be a descendant of the search bar. This is only
// required if the entry isn’t the direct child of the search bar (as in our
// main example).
func (b searchBar) ConnectEntry(entry Entry) {
	var _arg0 *C.GtkSearchBar // out
	var _arg1 *C.GtkEntry     // out

	_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkEntry)(unsafe.Pointer(entry.Native()))

	C.gtk_search_bar_connect_entry(_arg0, _arg1)
}

// SearchMode returns whether the search mode is on or off.
func (b searchBar) SearchMode() bool {
	var _arg0 *C.GtkSearchBar // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_search_bar_get_search_mode(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowCloseButton returns whether the close button is shown.
func (b searchBar) ShowCloseButton() bool {
	var _arg0 *C.GtkSearchBar // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_search_bar_get_show_close_button(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetSearchMode switches the search mode on or off.
func (b searchBar) SetSearchMode(searchMode bool) {
	var _arg0 *C.GtkSearchBar // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))
	if searchMode {
		_arg1 = C.TRUE
	}

	C.gtk_search_bar_set_search_mode(_arg0, _arg1)
}

// SetShowCloseButton shows or hides the close button. Applications that already
// have a “search” toggle button should not show a close button in their search
// bar, as it duplicates the role of the toggle button.
func (b searchBar) SetShowCloseButton(visible bool) {
	var _arg0 *C.GtkSearchBar // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))
	if visible {
		_arg1 = C.TRUE
	}

	C.gtk_search_bar_set_show_close_button(_arg0, _arg1)
}

// SearchEntry is a subclass of Entry that has been tailored for use as a search
// entry.
//
// It will show an inactive symbolic “find” icon when the search entry is empty,
// and a symbolic “clear” icon when there is text. Clicking on the “clear” icon
// will empty the search entry.
//
// Note that the search/clear icon is shown using a secondary icon, and thus
// does not work if you are using the secondary icon position for some other
// purpose.
//
// To make filtering appear more reactive, it is a good idea to not react to
// every change in the entry text immediately, but only after a short delay. To
// support this, SearchEntry emits the SearchEntry::search-changed signal which
// can be used instead of the Editable::changed signal.
//
// The SearchEntry::previous-match, SearchEntry::next-match and
// SearchEntry::stop-search signals can be used to implement moving between
// search results and ending the search.
//
// Often, GtkSearchEntry will be fed events by means of being placed inside a
// SearchBar. If that is not the case, you can use
// gtk_search_entry_handle_event() to pass events.
type SearchEntry interface {
	Entry
	Buildable
	CellEditable
	Editable
}

// searchEntry implements the SearchEntry class.
type searchEntry struct {
	Entry
	Buildable
	CellEditable
	Editable
}

var _ SearchEntry = (*searchEntry)(nil)

// WrapSearchEntry wraps a GObject to the right type. It is
// primarily used internally.
func WrapSearchEntry(obj *externglib.Object) SearchEntry {
	return searchEntry{
		Entry:        WrapEntry(obj),
		Buildable:    WrapBuildable(obj),
		CellEditable: WrapCellEditable(obj),
		Editable:     WrapEditable(obj),
	}
}

func marshalSearchEntry(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSearchEntry(obj), nil
}

// NewSearchEntry creates a SearchEntry, with a find icon when the search field
// is empty, and a clear icon when it isn't.
func NewSearchEntry() SearchEntry {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_search_entry_new()

	var _searchEntry SearchEntry // out

	_searchEntry = WrapSearchEntry(externglib.Take(unsafe.Pointer(_cret)))

	return _searchEntry
}

// Separator: gtkSeparator is a horizontal or vertical separator widget,
// depending on the value of the Orientable:orientation property, used to group
// the widgets within a window. It displays a line with a shadow to make it
// appear sunken into the interface.
//
//
// CSS nodes
//
// GtkSeparator has a single CSS node with name separator. The node gets one of
// the .horizontal or .vertical style classes.
type Separator interface {
	Widget
	Buildable
	Orientable
}

// separator implements the Separator class.
type separator struct {
	Widget
	Buildable
	Orientable
}

var _ Separator = (*separator)(nil)

// WrapSeparator wraps a GObject to the right type. It is
// primarily used internally.
func WrapSeparator(obj *externglib.Object) Separator {
	return separator{
		Widget:     WrapWidget(obj),
		Buildable:  WrapBuildable(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalSeparator(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSeparator(obj), nil
}

// NewSeparator creates a new Separator with the given orientation.
func NewSeparator(orientation Orientation) Separator {
	var _arg1 C.GtkOrientation // out
	var _cret *C.GtkWidget     // in

	_arg1 = (C.GtkOrientation)(orientation)

	_cret = C.gtk_separator_new(_arg1)

	var _separator Separator // out

	_separator = WrapSeparator(externglib.Take(unsafe.Pointer(_cret)))

	return _separator
}

// SeparatorMenuItem: the SeparatorMenuItem is a separator used to group items
// within a menu. It displays a horizontal line with a shadow to make it appear
// sunken into the interface.
//
//
// CSS nodes
//
// GtkSeparatorMenuItem has a single CSS node with name separator.
type SeparatorMenuItem interface {
	MenuItem
	Actionable
	Activatable
	Buildable
}

// separatorMenuItem implements the SeparatorMenuItem class.
type separatorMenuItem struct {
	MenuItem
	Actionable
	Activatable
	Buildable
}

var _ SeparatorMenuItem = (*separatorMenuItem)(nil)

// WrapSeparatorMenuItem wraps a GObject to the right type. It is
// primarily used internally.
func WrapSeparatorMenuItem(obj *externglib.Object) SeparatorMenuItem {
	return separatorMenuItem{
		MenuItem:    WrapMenuItem(obj),
		Actionable:  WrapActionable(obj),
		Activatable: WrapActivatable(obj),
		Buildable:   WrapBuildable(obj),
	}
}

func marshalSeparatorMenuItem(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSeparatorMenuItem(obj), nil
}

// NewSeparatorMenuItem creates a new SeparatorMenuItem.
func NewSeparatorMenuItem() SeparatorMenuItem {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_separator_menu_item_new()

	var _separatorMenuItem SeparatorMenuItem // out

	_separatorMenuItem = WrapSeparatorMenuItem(externglib.Take(unsafe.Pointer(_cret)))

	return _separatorMenuItem
}

// SeparatorToolItem: a SeparatorToolItem is a ToolItem that separates groups of
// other ToolItems. Depending on the theme, a SeparatorToolItem will often look
// like a vertical line on horizontally docked toolbars.
//
// If the Toolbar child property “expand” is true and the property
// SeparatorToolItem:draw is false, a SeparatorToolItem will act as a “spring”
// that forces other items to the ends of the toolbar.
//
// Use gtk_separator_tool_item_new() to create a new SeparatorToolItem.
//
//
// CSS nodes
//
// GtkSeparatorToolItem has a single CSS node with name separator.
type SeparatorToolItem interface {
	ToolItem
	Activatable
	Buildable

	// Draw returns whether @item is drawn as a line, or just blank. See
	// gtk_separator_tool_item_set_draw().
	Draw() bool
	// SetDraw: whether @item is drawn as a vertical line, or just blank.
	// Setting this to false along with gtk_tool_item_set_expand() is useful to
	// create an item that forces following items to the end of the toolbar.
	SetDraw(draw bool)
}

// separatorToolItem implements the SeparatorToolItem class.
type separatorToolItem struct {
	ToolItem
	Activatable
	Buildable
}

var _ SeparatorToolItem = (*separatorToolItem)(nil)

// WrapSeparatorToolItem wraps a GObject to the right type. It is
// primarily used internally.
func WrapSeparatorToolItem(obj *externglib.Object) SeparatorToolItem {
	return separatorToolItem{
		ToolItem:    WrapToolItem(obj),
		Activatable: WrapActivatable(obj),
		Buildable:   WrapBuildable(obj),
	}
}

func marshalSeparatorToolItem(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSeparatorToolItem(obj), nil
}

// NewSeparatorToolItem: create a new SeparatorToolItem
func NewSeparatorToolItem() SeparatorToolItem {
	var _cret *C.GtkToolItem // in

	_cret = C.gtk_separator_tool_item_new()

	var _separatorToolItem SeparatorToolItem // out

	_separatorToolItem = WrapSeparatorToolItem(externglib.Take(unsafe.Pointer(_cret)))

	return _separatorToolItem
}

// Draw returns whether @item is drawn as a line, or just blank. See
// gtk_separator_tool_item_set_draw().
func (i separatorToolItem) Draw() bool {
	var _arg0 *C.GtkSeparatorToolItem // out
	var _cret C.gboolean              // in

	_arg0 = (*C.GtkSeparatorToolItem)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_separator_tool_item_get_draw(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetDraw: whether @item is drawn as a vertical line, or just blank. Setting
// this to false along with gtk_tool_item_set_expand() is useful to create an
// item that forces following items to the end of the toolbar.
func (i separatorToolItem) SetDraw(draw bool) {
	var _arg0 *C.GtkSeparatorToolItem // out
	var _arg1 C.gboolean              // out

	_arg0 = (*C.GtkSeparatorToolItem)(unsafe.Pointer(i.Native()))
	if draw {
		_arg1 = C.TRUE
	}

	C.gtk_separator_tool_item_set_draw(_arg0, _arg1)
}

// Settings gtkSettings provide a mechanism to share global settings between
// applications.
//
// On the X window system, this sharing is realized by an XSettings
// (http://www.freedesktop.org/wiki/Specifications/xsettings-spec) manager that
// is usually part of the desktop environment, along with utilities that let the
// user change these settings. In the absence of an Xsettings manager, GTK+
// reads default values for settings from `settings.ini` files in
// `/etc/gtk-3.0`, `$XDG_CONFIG_DIRS/gtk-3.0` and `$XDG_CONFIG_HOME/gtk-3.0`.
// These files must be valid key files (see File), and have a section called
// Settings. Themes can also provide default values for settings by installing a
// `settings.ini` file next to their `gtk.css` file.
//
// Applications can override system-wide settings by setting the property of the
// GtkSettings object with g_object_set(). This should be restricted to special
// cases though; GtkSettings are not meant as an application configuration
// facility. When doing so, you need to be aware that settings that are specific
// to individual widgets may not be available before the widget type has been
// realized at least once. The following example demonstrates a way to do this:
//
//      gtk_init (&argc, &argv);
//
//      // make sure the type is realized
//      g_type_class_unref (g_type_class_ref (GTK_TYPE_IMAGE_MENU_ITEM));
//
//      g_object_set (gtk_settings_get_default (), "gtk-enable-animations", FALSE, NULL);
//
// There is one GtkSettings instance per screen. It can be obtained with
// gtk_settings_get_for_screen(), but in many cases, it is more convenient to
// use gtk_widget_get_settings(). gtk_settings_get_default() returns the
// GtkSettings instance for the default screen.
type Settings interface {
	gextras.Objector
	StyleProvider

	// ResetProperty undoes the effect of calling g_object_set() to install an
	// application-specific value for a setting. After this call, the setting
	// will again follow the session-wide value for this setting.
	ResetProperty(name string)

	SetDoubleProperty(name string, vDouble float64, origin string)

	SetLongProperty(name string, vLong int32, origin string)

	SetStringProperty(name string, vString string, origin string)
}

// settings implements the Settings class.
type settings struct {
	gextras.Objector
	StyleProvider
}

var _ Settings = (*settings)(nil)

// WrapSettings wraps a GObject to the right type. It is
// primarily used internally.
func WrapSettings(obj *externglib.Object) Settings {
	return settings{
		Objector:      obj,
		StyleProvider: WrapStyleProvider(obj),
	}
}

func marshalSettings(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSettings(obj), nil
}

// ResetProperty undoes the effect of calling g_object_set() to install an
// application-specific value for a setting. After this call, the setting will
// again follow the session-wide value for this setting.
func (s settings) ResetProperty(name string) {
	var _arg0 *C.GtkSettings // out
	var _arg1 *C.gchar       // out

	_arg0 = (*C.GtkSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_settings_reset_property(_arg0, _arg1)
}

func (s settings) SetDoubleProperty(name string, vDouble float64, origin string) {
	var _arg0 *C.GtkSettings // out
	var _arg1 *C.gchar       // out
	var _arg2 C.gdouble      // out
	var _arg3 *C.gchar       // out

	_arg0 = (*C.GtkSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gdouble)(vDouble)
	_arg3 = (*C.gchar)(C.CString(origin))
	defer C.free(unsafe.Pointer(_arg3))

	C.gtk_settings_set_double_property(_arg0, _arg1, _arg2, _arg3)
}

func (s settings) SetLongProperty(name string, vLong int32, origin string) {
	var _arg0 *C.GtkSettings // out
	var _arg1 *C.gchar       // out
	var _arg2 C.glong        // out
	var _arg3 *C.gchar       // out

	_arg0 = (*C.GtkSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.glong)(vLong)
	_arg3 = (*C.gchar)(C.CString(origin))
	defer C.free(unsafe.Pointer(_arg3))

	C.gtk_settings_set_long_property(_arg0, _arg1, _arg2, _arg3)
}

func (s settings) SetStringProperty(name string, vString string, origin string) {
	var _arg0 *C.GtkSettings // out
	var _arg1 *C.gchar       // out
	var _arg2 *C.gchar       // out
	var _arg3 *C.gchar       // out

	_arg0 = (*C.GtkSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(vString))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(origin))
	defer C.free(unsafe.Pointer(_arg3))

	C.gtk_settings_set_string_property(_arg0, _arg1, _arg2, _arg3)
}

// ShortcutLabel is a widget that represents a single keyboard shortcut or
// gesture in the user interface.
type ShortcutLabel interface {
	Box
	Buildable
	Orientable

	// Accelerator retrieves the current accelerator of @self.
	Accelerator() string
	// DisabledText retrieves the text that is displayed when no accelerator is
	// set.
	DisabledText() string
	// SetAccelerator sets the accelerator to be displayed by @self.
	SetAccelerator(accelerator string)
	// SetDisabledText sets the text to be displayed by @self when no
	// accelerator is set.
	SetDisabledText(disabledText string)
}

// shortcutLabel implements the ShortcutLabel class.
type shortcutLabel struct {
	Box
	Buildable
	Orientable
}

var _ ShortcutLabel = (*shortcutLabel)(nil)

// WrapShortcutLabel wraps a GObject to the right type. It is
// primarily used internally.
func WrapShortcutLabel(obj *externglib.Object) ShortcutLabel {
	return shortcutLabel{
		Box:        WrapBox(obj),
		Buildable:  WrapBuildable(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalShortcutLabel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapShortcutLabel(obj), nil
}

// NewShortcutLabel creates a new ShortcutLabel with @accelerator set.
func NewShortcutLabel(accelerator string) ShortcutLabel {
	var _arg1 *C.gchar     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.gchar)(C.CString(accelerator))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_shortcut_label_new(_arg1)

	var _shortcutLabel ShortcutLabel // out

	_shortcutLabel = WrapShortcutLabel(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _shortcutLabel
}

// Accelerator retrieves the current accelerator of @self.
func (s shortcutLabel) Accelerator() string {
	var _arg0 *C.GtkShortcutLabel // out
	var _cret *C.gchar            // in

	_arg0 = (*C.GtkShortcutLabel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_shortcut_label_get_accelerator(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// DisabledText retrieves the text that is displayed when no accelerator is set.
func (s shortcutLabel) DisabledText() string {
	var _arg0 *C.GtkShortcutLabel // out
	var _cret *C.gchar            // in

	_arg0 = (*C.GtkShortcutLabel)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_shortcut_label_get_disabled_text(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// SetAccelerator sets the accelerator to be displayed by @self.
func (s shortcutLabel) SetAccelerator(accelerator string) {
	var _arg0 *C.GtkShortcutLabel // out
	var _arg1 *C.gchar            // out

	_arg0 = (*C.GtkShortcutLabel)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(accelerator))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_shortcut_label_set_accelerator(_arg0, _arg1)
}

// SetDisabledText sets the text to be displayed by @self when no accelerator is
// set.
func (s shortcutLabel) SetDisabledText(disabledText string) {
	var _arg0 *C.GtkShortcutLabel // out
	var _arg1 *C.gchar            // out

	_arg0 = (*C.GtkShortcutLabel)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(disabledText))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_shortcut_label_set_disabled_text(_arg0, _arg1)
}

// ShortcutsGroup: a GtkShortcutsGroup represents a group of related keyboard
// shortcuts or gestures. The group has a title. It may optionally be associated
// with a view of the application, which can be used to show only relevant
// shortcuts depending on the application context.
//
// This widget is only meant to be used with ShortcutsWindow.
type ShortcutsGroup interface {
	Box
	Buildable
	Orientable
}

// shortcutsGroup implements the ShortcutsGroup class.
type shortcutsGroup struct {
	Box
	Buildable
	Orientable
}

var _ ShortcutsGroup = (*shortcutsGroup)(nil)

// WrapShortcutsGroup wraps a GObject to the right type. It is
// primarily used internally.
func WrapShortcutsGroup(obj *externglib.Object) ShortcutsGroup {
	return shortcutsGroup{
		Box:        WrapBox(obj),
		Buildable:  WrapBuildable(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalShortcutsGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapShortcutsGroup(obj), nil
}

// ShortcutsSection: a GtkShortcutsSection collects all the keyboard shortcuts
// and gestures for a major application mode. If your application needs multiple
// sections, you should give each section a unique ShortcutsSection:section-name
// and a ShortcutsSection:title that can be shown in the section selector of the
// GtkShortcutsWindow.
//
// The ShortcutsSection:max-height property can be used to influence how the
// groups in the section are distributed over pages and columns.
//
// This widget is only meant to be used with ShortcutsWindow.
type ShortcutsSection interface {
	Box
	Buildable
	Orientable
}

// shortcutsSection implements the ShortcutsSection class.
type shortcutsSection struct {
	Box
	Buildable
	Orientable
}

var _ ShortcutsSection = (*shortcutsSection)(nil)

// WrapShortcutsSection wraps a GObject to the right type. It is
// primarily used internally.
func WrapShortcutsSection(obj *externglib.Object) ShortcutsSection {
	return shortcutsSection{
		Box:        WrapBox(obj),
		Buildable:  WrapBuildable(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalShortcutsSection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapShortcutsSection(obj), nil
}

// ShortcutsShortcut: a GtkShortcutsShortcut represents a single keyboard
// shortcut or gesture with a short text. This widget is only meant to be used
// with ShortcutsWindow.
type ShortcutsShortcut interface {
	Box
	Buildable
	Orientable
}

// shortcutsShortcut implements the ShortcutsShortcut class.
type shortcutsShortcut struct {
	Box
	Buildable
	Orientable
}

var _ ShortcutsShortcut = (*shortcutsShortcut)(nil)

// WrapShortcutsShortcut wraps a GObject to the right type. It is
// primarily used internally.
func WrapShortcutsShortcut(obj *externglib.Object) ShortcutsShortcut {
	return shortcutsShortcut{
		Box:        WrapBox(obj),
		Buildable:  WrapBuildable(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalShortcutsShortcut(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapShortcutsShortcut(obj), nil
}

// ShortcutsWindow: a GtkShortcutsWindow shows brief information about the
// keyboard shortcuts and gestures of an application. The shortcuts can be
// grouped, and you can have multiple sections in this window, corresponding to
// the major modes of your application.
//
// Additionally, the shortcuts can be filtered by the current view, to avoid
// showing information that is not relevant in the current application context.
//
// The recommended way to construct a GtkShortcutsWindow is with GtkBuilder, by
// populating a ShortcutsWindow with one or more ShortcutsSection objects, which
// contain ShortcutsGroups that in turn contain objects of class
// ShortcutsShortcut.
//
// A simple example:
//
// ! (gedit-shortcuts.png)
//
// This example has as single section. As you can see, the shortcut groups are
// arranged in columns, and spread across several pages if there are too many to
// find on a single page.
//
// The .ui file for this example can be found here
// (https://git.gnome.org/browse/gtk+/tree/demos/gtk-demo/shortcuts-gedit.ui).
//
// An example with multiple views:
//
// ! (clocks-shortcuts.png)
//
// This example shows a ShortcutsWindow that has been configured to show only
// the shortcuts relevant to the "stopwatch" view.
//
// The .ui file for this example can be found here
// (https://git.gnome.org/browse/gtk+/tree/demos/gtk-demo/shortcuts-clocks.ui).
//
// An example with multiple sections:
//
// ! (builder-shortcuts.png)
//
// This example shows a ShortcutsWindow with two sections, "Editor Shortcuts"
// and "Terminal Shortcuts".
//
// The .ui file for this example can be found here
// (https://git.gnome.org/browse/gtk+/tree/demos/gtk-demo/shortcuts-builder.ui).
type ShortcutsWindow interface {
	Window
	Buildable
}

// shortcutsWindow implements the ShortcutsWindow class.
type shortcutsWindow struct {
	Window
	Buildable
}

var _ ShortcutsWindow = (*shortcutsWindow)(nil)

// WrapShortcutsWindow wraps a GObject to the right type. It is
// primarily used internally.
func WrapShortcutsWindow(obj *externglib.Object) ShortcutsWindow {
	return shortcutsWindow{
		Window:    WrapWindow(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalShortcutsWindow(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapShortcutsWindow(obj), nil
}

// SizeGroup provides a mechanism for grouping a number of widgets together so
// they all request the same amount of space. This is typically useful when you
// want a column of widgets to have the same size, but you can’t use a Grid
// widget.
//
// In detail, the size requested for each widget in a SizeGroup is the maximum
// of the sizes that would have been requested for each widget in the size group
// if they were not in the size group. The mode of the size group (see
// gtk_size_group_set_mode()) determines whether this applies to the horizontal
// size, the vertical size, or both sizes.
//
// Note that size groups only affect the amount of space requested, not the size
// that the widgets finally receive. If you want the widgets in a SizeGroup to
// actually be the same size, you need to pack them in such a way that they get
// the size they request and not more. For example, if you are packing your
// widgets into a table, you would not include the GTK_FILL flag.
//
// SizeGroup objects are referenced by each widget in the size group, so once
// you have added all widgets to a SizeGroup, you can drop the initial reference
// to the size group with g_object_unref(). If the widgets in the size group are
// subsequently destroyed, then they will be removed from the size group and
// drop their references on the size group; when all widgets have been removed,
// the size group will be freed.
//
// Widgets can be part of multiple size groups; GTK+ will compute the horizontal
// size of a widget from the horizontal requisition of all widgets that can be
// reached from the widget by a chain of size groups of type
// GTK_SIZE_GROUP_HORIZONTAL or GTK_SIZE_GROUP_BOTH, and the vertical size from
// the vertical requisition of all widgets that can be reached from the widget
// by a chain of size groups of type GTK_SIZE_GROUP_VERTICAL or
// GTK_SIZE_GROUP_BOTH.
//
// Note that only non-contextual sizes of every widget are ever consulted by
// size groups (since size groups have no knowledge of what size a widget will
// be allocated in one dimension, it cannot derive how much height a widget will
// receive for a given width). When grouping widgets that trade height for width
// in mode GTK_SIZE_GROUP_VERTICAL or GTK_SIZE_GROUP_BOTH: the height for the
// minimum width will be the requested height for all widgets in the group. The
// same is of course true when horizontally grouping width for height widgets.
//
// Widgets that trade height-for-width should set a reasonably large minimum
// width by way of Label:width-chars for instance. Widgets with static sizes as
// well as widgets that grow (such as ellipsizing text) need no such
// considerations.
//
//
// GtkSizeGroup as GtkBuildable
//
// Size groups can be specified in a UI definition by placing an <object>
// element with `class="GtkSizeGroup"` somewhere in the UI definition. The
// widgets that belong to the size group are specified by a <widgets> element
// that may contain multiple <widget> elements, one for each member of the size
// group. The ”name” attribute gives the id of the widget.
//
// An example of a UI definition fragment with GtkSizeGroup:
//
//    <object class="GtkSizeGroup">
//      <property name="mode">GTK_SIZE_GROUP_HORIZONTAL</property>
//      <widgets>
//        <widget name="radio1"/>
//        <widget name="radio2"/>
//      </widgets>
//    </object>
type SizeGroup interface {
	gextras.Objector
	Buildable

	// AddWidget adds a widget to a SizeGroup. In the future, the requisition of
	// the widget will be determined as the maximum of its requisition and the
	// requisition of the other widgets in the size group. Whether this applies
	// horizontally, vertically, or in both directions depends on the mode of
	// the size group. See gtk_size_group_set_mode().
	//
	// When the widget is destroyed or no longer referenced elsewhere, it will
	// be removed from the size group.
	AddWidget(widget Widget)
	// IgnoreHidden returns if invisible widgets are ignored when calculating
	// the size.
	IgnoreHidden() bool
	// Mode gets the current mode of the size group. See
	// gtk_size_group_set_mode().
	Mode() SizeGroupMode
	// RemoveWidget removes a widget from a SizeGroup.
	RemoveWidget(widget Widget)
	// SetIgnoreHidden sets whether unmapped widgets should be ignored when
	// calculating the size.
	SetIgnoreHidden(ignoreHidden bool)
	// SetMode sets the SizeGroupMode of the size group. The mode of the size
	// group determines whether the widgets in the size group should all have
	// the same horizontal requisition (GTK_SIZE_GROUP_HORIZONTAL) all have the
	// same vertical requisition (GTK_SIZE_GROUP_VERTICAL), or should all have
	// the same requisition in both directions (GTK_SIZE_GROUP_BOTH).
	SetMode(mode SizeGroupMode)
}

// sizeGroup implements the SizeGroup class.
type sizeGroup struct {
	gextras.Objector
	Buildable
}

var _ SizeGroup = (*sizeGroup)(nil)

// WrapSizeGroup wraps a GObject to the right type. It is
// primarily used internally.
func WrapSizeGroup(obj *externglib.Object) SizeGroup {
	return sizeGroup{
		Objector:  obj,
		Buildable: WrapBuildable(obj),
	}
}

func marshalSizeGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSizeGroup(obj), nil
}

// NewSizeGroup: create a new SizeGroup.
func NewSizeGroup(mode SizeGroupMode) SizeGroup {
	var _arg1 C.GtkSizeGroupMode // out
	var _cret *C.GtkSizeGroup    // in

	_arg1 = (C.GtkSizeGroupMode)(mode)

	_cret = C.gtk_size_group_new(_arg1)

	var _sizeGroup SizeGroup // out

	_sizeGroup = WrapSizeGroup(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _sizeGroup
}

// AddWidget adds a widget to a SizeGroup. In the future, the requisition of the
// widget will be determined as the maximum of its requisition and the
// requisition of the other widgets in the size group. Whether this applies
// horizontally, vertically, or in both directions depends on the mode of the
// size group. See gtk_size_group_set_mode().
//
// When the widget is destroyed or no longer referenced elsewhere, it will be
// removed from the size group.
func (s sizeGroup) AddWidget(widget Widget) {
	var _arg0 *C.GtkSizeGroup // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkSizeGroup)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_size_group_add_widget(_arg0, _arg1)
}

// IgnoreHidden returns if invisible widgets are ignored when calculating the
// size.
func (s sizeGroup) IgnoreHidden() bool {
	var _arg0 *C.GtkSizeGroup // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkSizeGroup)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_size_group_get_ignore_hidden(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Mode gets the current mode of the size group. See gtk_size_group_set_mode().
func (s sizeGroup) Mode() SizeGroupMode {
	var _arg0 *C.GtkSizeGroup    // out
	var _cret C.GtkSizeGroupMode // in

	_arg0 = (*C.GtkSizeGroup)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_size_group_get_mode(_arg0)

	var _sizeGroupMode SizeGroupMode // out

	_sizeGroupMode = SizeGroupMode(_cret)

	return _sizeGroupMode
}

// RemoveWidget removes a widget from a SizeGroup.
func (s sizeGroup) RemoveWidget(widget Widget) {
	var _arg0 *C.GtkSizeGroup // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkSizeGroup)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_size_group_remove_widget(_arg0, _arg1)
}

// SetIgnoreHidden sets whether unmapped widgets should be ignored when
// calculating the size.
func (s sizeGroup) SetIgnoreHidden(ignoreHidden bool) {
	var _arg0 *C.GtkSizeGroup // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GtkSizeGroup)(unsafe.Pointer(s.Native()))
	if ignoreHidden {
		_arg1 = C.TRUE
	}

	C.gtk_size_group_set_ignore_hidden(_arg0, _arg1)
}

// SetMode sets the SizeGroupMode of the size group. The mode of the size group
// determines whether the widgets in the size group should all have the same
// horizontal requisition (GTK_SIZE_GROUP_HORIZONTAL) all have the same vertical
// requisition (GTK_SIZE_GROUP_VERTICAL), or should all have the same
// requisition in both directions (GTK_SIZE_GROUP_BOTH).
func (s sizeGroup) SetMode(mode SizeGroupMode) {
	var _arg0 *C.GtkSizeGroup    // out
	var _arg1 C.GtkSizeGroupMode // out

	_arg0 = (*C.GtkSizeGroup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkSizeGroupMode)(mode)

	C.gtk_size_group_set_mode(_arg0, _arg1)
}

// Socket: together with Plug, Socket provides the ability to embed widgets from
// one process into another process in a fashion that is transparent to the
// user. One process creates a Socket widget and passes that widget’s window ID
// to the other process, which then creates a Plug with that window ID. Any
// widgets contained in the Plug then will appear inside the first application’s
// window.
//
// The socket’s window ID is obtained by using gtk_socket_get_id(). Before using
// this function, the socket must have been realized, and for hence, have been
// added to its parent.
//
// Obtaining the window ID of a socket.
//
//    GtkWidget *socket = gtk_socket_new ();
//    gtk_widget_show (socket);
//    gtk_container_add (GTK_CONTAINER (parent), socket);
//
//    // The following call is only necessary if one of
//    // the ancestors of the socket is not yet visible.
//    gtk_widget_realize (socket);
//    g_print ("The ID of the sockets window is %#x\n",
//             gtk_socket_get_id (socket));
//
// Note that if you pass the window ID of the socket to another process that
// will create a plug in the socket, you must make sure that the socket widget
// is not destroyed until that plug is created. Violating this rule will cause
// unpredictable consequences, the most likely consequence being that the plug
// will appear as a separate toplevel window. You can check if the plug has been
// created by using gtk_socket_get_plug_window(). If it returns a non-nil value,
// then the plug has been successfully created inside of the socket.
//
// When GTK+ is notified that the embedded window has been destroyed, then it
// will destroy the socket as well. You should always, therefore, be prepared
// for your sockets to be destroyed at any time when the main event loop is
// running. To prevent this from happening, you can connect to the
// Socket::plug-removed signal.
//
// The communication between a Socket and a Plug follows the XEmbed Protocol
// (http://www.freedesktop.org/Standards/xembed-spec). This protocol has also
// been implemented in other toolkits, e.g. Qt, allowing the same level of
// integration when embedding a Qt widget in GTK or vice versa.
//
// The Plug and Socket widgets are only available when GTK+ is compiled for the
// X11 platform and GDK_WINDOWING_X11 is defined. They can only be used on a
// X11Display. To use Plug and Socket, you need to include the `gtk/gtkx.h`
// header.
type Socket interface {
	Container
	Buildable

	// PlugWindow retrieves the window of the plug. Use this to check if the
	// plug has been created inside of the socket.
	PlugWindow() gdk.Window
}

// socket implements the Socket class.
type socket struct {
	Container
	Buildable
}

var _ Socket = (*socket)(nil)

// WrapSocket wraps a GObject to the right type. It is
// primarily used internally.
func WrapSocket(obj *externglib.Object) Socket {
	return socket{
		Container: WrapContainer(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalSocket(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSocket(obj), nil
}

// NewSocket: create a new empty Socket.
func NewSocket() Socket {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_socket_new()

	var _socket Socket // out

	_socket = WrapSocket(externglib.Take(unsafe.Pointer(_cret)))

	return _socket
}

// PlugWindow retrieves the window of the plug. Use this to check if the plug
// has been created inside of the socket.
func (s socket) PlugWindow() gdk.Window {
	var _arg0 *C.GtkSocket // out
	var _cret *C.GdkWindow // in

	_arg0 = (*C.GtkSocket)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_socket_get_plug_window(_arg0)

	var _window gdk.Window // out

	_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Window)

	return _window
}

type SocketAccessible interface {
	ContainerAccessible

	Embed(path string)
}

// socketAccessible implements the SocketAccessible class.
type socketAccessible struct {
	ContainerAccessible
}

var _ SocketAccessible = (*socketAccessible)(nil)

// WrapSocketAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapSocketAccessible(obj *externglib.Object) SocketAccessible {
	return socketAccessible{
		ContainerAccessible: WrapContainerAccessible(obj),
	}
}

func marshalSocketAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSocketAccessible(obj), nil
}

func (s socketAccessible) Embed(path string) {
	var _arg0 *C.GtkSocketAccessible // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GtkSocketAccessible)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_socket_accessible_embed(_arg0, _arg1)
}

// SpinButton: a SpinButton is an ideal way to allow the user to set the value
// of some attribute. Rather than having to directly type a number into a Entry,
// GtkSpinButton allows the user to click on one of two arrows to increment or
// decrement the displayed value. A value can still be typed in, with the bonus
// that it can be checked to ensure it is in a given range.
//
// The main properties of a GtkSpinButton are through an adjustment. See the
// Adjustment section for more details about an adjustment's properties. Note
// that GtkSpinButton will by default make its entry large enough to accomodate
// the lower and upper bounds of the adjustment, which can lead to surprising
// results. Best practice is to set both the Entry:width-chars and
// Entry:max-width-chars poperties to the desired number of characters to
// display in the entry.
//
// CSS nodes
//
//    // Provides a function to retrieve a floating point value from a
//    // GtkSpinButton, and creates a high precision spin button.
//
//    gfloat
//    grab_float_value (GtkSpinButton *button,
//                      gpointer       user_data)
//    {
//      return gtk_spin_button_get_value (button);
//    }
//
//    void
//    create_floating_spin_button (void)
//    {
//      GtkWidget *window, *button;
//      GtkAdjustment *adjustment;
//
//      adjustment = gtk_adjustment_new (2.500, 0.0, 5.0, 0.001, 0.1, 0.0);
//
//      window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
//      gtk_container_set_border_width (GTK_CONTAINER (window), 5);
//
//      // creates the spinbutton, with three decimal places
//      button = gtk_spin_button_new (adjustment, 0.001, 3);
//      gtk_container_add (GTK_CONTAINER (window), button);
//
//      gtk_widget_show_all (window);
//    }
type SpinButton interface {
	Entry
	Buildable
	CellEditable
	Editable
	Orientable

	// Configure changes the properties of an existing spin button. The
	// adjustment, climb rate, and number of decimal places are updated
	// accordingly.
	Configure(adjustment Adjustment, climbRate float64, digits uint)
	// Adjustment: get the adjustment associated with a SpinButton
	Adjustment() Adjustment
	// Digits fetches the precision of @spin_button. See
	// gtk_spin_button_set_digits().
	Digits() uint
	// Increments gets the current step and page the increments used by
	// @spin_button. See gtk_spin_button_set_increments().
	Increments() (step float64, page float64)
	// Numeric returns whether non-numeric text can be typed into the spin
	// button. See gtk_spin_button_set_numeric().
	Numeric() bool
	// Range gets the range allowed for @spin_button. See
	// gtk_spin_button_set_range().
	Range() (min float64, max float64)
	// SnapToTicks returns whether the values are corrected to the nearest step.
	// See gtk_spin_button_set_snap_to_ticks().
	SnapToTicks() bool
	// UpdatePolicy gets the update behavior of a spin button. See
	// gtk_spin_button_set_update_policy().
	UpdatePolicy() SpinButtonUpdatePolicy
	// Value: get the value in the @spin_button.
	Value() float64
	// ValueAsInt: get the value @spin_button represented as an integer.
	ValueAsInt() int
	// Wrap returns whether the spin button’s value wraps around to the opposite
	// limit when the upper or lower limit of the range is exceeded. See
	// gtk_spin_button_set_wrap().
	Wrap() bool
	// SetAdjustment replaces the Adjustment associated with @spin_button.
	SetAdjustment(adjustment Adjustment)
	// SetDigits: set the precision to be displayed by @spin_button. Up to 20
	// digit precision is allowed.
	SetDigits(digits uint)
	// SetIncrements sets the step and page increments for spin_button. This
	// affects how quickly the value changes when the spin button’s arrows are
	// activated.
	SetIncrements(step float64, page float64)
	// SetNumeric sets the flag that determines if non-numeric text can be typed
	// into the spin button.
	SetNumeric(numeric bool)
	// SetRange sets the minimum and maximum allowable values for @spin_button.
	//
	// If the current value is outside this range, it will be adjusted to fit
	// within the range, otherwise it will remain unchanged.
	SetRange(min float64, max float64)
	// SetSnapToTicks sets the policy as to whether values are corrected to the
	// nearest step increment when a spin button is activated after providing an
	// invalid value.
	SetSnapToTicks(snapToTicks bool)
	// SetUpdatePolicy sets the update behavior of a spin button. This
	// determines whether the spin button is always updated or only when a valid
	// value is set.
	SetUpdatePolicy(policy SpinButtonUpdatePolicy)
	// SetValue sets the value of @spin_button.
	SetValue(value float64)
	// SetWrap sets the flag that determines if a spin button value wraps around
	// to the opposite limit when the upper or lower limit of the range is
	// exceeded.
	SetWrap(wrap bool)
	// Spin: increment or decrement a spin button’s value in a specified
	// direction by a specified amount.
	Spin(direction SpinType, increment float64)
	// Update: manually force an update of the spin button.
	Update()
}

// spinButton implements the SpinButton class.
type spinButton struct {
	Entry
	Buildable
	CellEditable
	Editable
	Orientable
}

var _ SpinButton = (*spinButton)(nil)

// WrapSpinButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapSpinButton(obj *externglib.Object) SpinButton {
	return spinButton{
		Entry:        WrapEntry(obj),
		Buildable:    WrapBuildable(obj),
		CellEditable: WrapCellEditable(obj),
		Editable:     WrapEditable(obj),
		Orientable:   WrapOrientable(obj),
	}
}

func marshalSpinButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSpinButton(obj), nil
}

// NewSpinButton creates a new SpinButton.
func NewSpinButton(adjustment Adjustment, climbRate float64, digits uint) SpinButton {
	var _arg1 *C.GtkAdjustment // out
	var _arg2 C.gdouble        // out
	var _arg3 C.guint          // out
	var _cret *C.GtkWidget     // in

	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))
	_arg2 = (C.gdouble)(climbRate)
	_arg3 = (C.guint)(digits)

	_cret = C.gtk_spin_button_new(_arg1, _arg2, _arg3)

	var _spinButton SpinButton // out

	_spinButton = WrapSpinButton(externglib.Take(unsafe.Pointer(_cret)))

	return _spinButton
}

// NewSpinButtonWithRange: this is a convenience constructor that allows
// creation of a numeric SpinButton without manually creating an adjustment. The
// value is initially set to the minimum value and a page increment of 10 *
// @step is the default. The precision of the spin button is equivalent to the
// precision of @step.
//
// Note that the way in which the precision is derived works best if @step is a
// power of ten. If the resulting precision is not suitable for your needs, use
// gtk_spin_button_set_digits() to correct it.
func NewSpinButtonWithRange(min float64, max float64, step float64) SpinButton {
	var _arg1 C.gdouble    // out
	var _arg2 C.gdouble    // out
	var _arg3 C.gdouble    // out
	var _cret *C.GtkWidget // in

	_arg1 = (C.gdouble)(min)
	_arg2 = (C.gdouble)(max)
	_arg3 = (C.gdouble)(step)

	_cret = C.gtk_spin_button_new_with_range(_arg1, _arg2, _arg3)

	var _spinButton SpinButton // out

	_spinButton = WrapSpinButton(externglib.Take(unsafe.Pointer(_cret)))

	return _spinButton
}

// Configure changes the properties of an existing spin button. The adjustment,
// climb rate, and number of decimal places are updated accordingly.
func (s spinButton) Configure(adjustment Adjustment, climbRate float64, digits uint) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 *C.GtkAdjustment // out
	var _arg2 C.gdouble        // out
	var _arg3 C.guint          // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))
	_arg2 = (C.gdouble)(climbRate)
	_arg3 = (C.guint)(digits)

	C.gtk_spin_button_configure(_arg0, _arg1, _arg2, _arg3)
}

// Adjustment: get the adjustment associated with a SpinButton
func (s spinButton) Adjustment() Adjustment {
	var _arg0 *C.GtkSpinButton // out
	var _cret *C.GtkAdjustment // in

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_spin_button_get_adjustment(_arg0)

	var _adjustment Adjustment // out

	_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

	return _adjustment
}

// Digits fetches the precision of @spin_button. See
// gtk_spin_button_set_digits().
func (s spinButton) Digits() uint {
	var _arg0 *C.GtkSpinButton // out
	var _cret C.guint          // in

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_spin_button_get_digits(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// Increments gets the current step and page the increments used by
// @spin_button. See gtk_spin_button_set_increments().
func (s spinButton) Increments() (step float64, page float64) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 C.gdouble        // in
	var _arg2 C.gdouble        // in

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	C.gtk_spin_button_get_increments(_arg0, &_arg1, &_arg2)

	var _step float64 // out
	var _page float64 // out

	_step = (float64)(_arg1)
	_page = (float64)(_arg2)

	return _step, _page
}

// Numeric returns whether non-numeric text can be typed into the spin button.
// See gtk_spin_button_set_numeric().
func (s spinButton) Numeric() bool {
	var _arg0 *C.GtkSpinButton // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_spin_button_get_numeric(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Range gets the range allowed for @spin_button. See
// gtk_spin_button_set_range().
func (s spinButton) Range() (min float64, max float64) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 C.gdouble        // in
	var _arg2 C.gdouble        // in

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	C.gtk_spin_button_get_range(_arg0, &_arg1, &_arg2)

	var _min float64 // out
	var _max float64 // out

	_min = (float64)(_arg1)
	_max = (float64)(_arg2)

	return _min, _max
}

// SnapToTicks returns whether the values are corrected to the nearest step. See
// gtk_spin_button_set_snap_to_ticks().
func (s spinButton) SnapToTicks() bool {
	var _arg0 *C.GtkSpinButton // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_spin_button_get_snap_to_ticks(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UpdatePolicy gets the update behavior of a spin button. See
// gtk_spin_button_set_update_policy().
func (s spinButton) UpdatePolicy() SpinButtonUpdatePolicy {
	var _arg0 *C.GtkSpinButton            // out
	var _cret C.GtkSpinButtonUpdatePolicy // in

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_spin_button_get_update_policy(_arg0)

	var _spinButtonUpdatePolicy SpinButtonUpdatePolicy // out

	_spinButtonUpdatePolicy = SpinButtonUpdatePolicy(_cret)

	return _spinButtonUpdatePolicy
}

// Value: get the value in the @spin_button.
func (s spinButton) Value() float64 {
	var _arg0 *C.GtkSpinButton // out
	var _cret C.gdouble        // in

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_spin_button_get_value(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// ValueAsInt: get the value @spin_button represented as an integer.
func (s spinButton) ValueAsInt() int {
	var _arg0 *C.GtkSpinButton // out
	var _cret C.gint           // in

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_spin_button_get_value_as_int(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Wrap returns whether the spin button’s value wraps around to the opposite
// limit when the upper or lower limit of the range is exceeded. See
// gtk_spin_button_set_wrap().
func (s spinButton) Wrap() bool {
	var _arg0 *C.GtkSpinButton // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_spin_button_get_wrap(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetAdjustment replaces the Adjustment associated with @spin_button.
func (s spinButton) SetAdjustment(adjustment Adjustment) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 *C.GtkAdjustment // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	C.gtk_spin_button_set_adjustment(_arg0, _arg1)
}

// SetDigits: set the precision to be displayed by @spin_button. Up to 20 digit
// precision is allowed.
func (s spinButton) SetDigits(digits uint) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 C.guint          // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(digits)

	C.gtk_spin_button_set_digits(_arg0, _arg1)
}

// SetIncrements sets the step and page increments for spin_button. This affects
// how quickly the value changes when the spin button’s arrows are activated.
func (s spinButton) SetIncrements(step float64, page float64) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 C.gdouble        // out
	var _arg2 C.gdouble        // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gdouble)(step)
	_arg2 = (C.gdouble)(page)

	C.gtk_spin_button_set_increments(_arg0, _arg1, _arg2)
}

// SetNumeric sets the flag that determines if non-numeric text can be typed
// into the spin button.
func (s spinButton) SetNumeric(numeric bool) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	if numeric {
		_arg1 = C.TRUE
	}

	C.gtk_spin_button_set_numeric(_arg0, _arg1)
}

// SetRange sets the minimum and maximum allowable values for @spin_button.
//
// If the current value is outside this range, it will be adjusted to fit within
// the range, otherwise it will remain unchanged.
func (s spinButton) SetRange(min float64, max float64) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 C.gdouble        // out
	var _arg2 C.gdouble        // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gdouble)(min)
	_arg2 = (C.gdouble)(max)

	C.gtk_spin_button_set_range(_arg0, _arg1, _arg2)
}

// SetSnapToTicks sets the policy as to whether values are corrected to the
// nearest step increment when a spin button is activated after providing an
// invalid value.
func (s spinButton) SetSnapToTicks(snapToTicks bool) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	if snapToTicks {
		_arg1 = C.TRUE
	}

	C.gtk_spin_button_set_snap_to_ticks(_arg0, _arg1)
}

// SetUpdatePolicy sets the update behavior of a spin button. This determines
// whether the spin button is always updated or only when a valid value is set.
func (s spinButton) SetUpdatePolicy(policy SpinButtonUpdatePolicy) {
	var _arg0 *C.GtkSpinButton            // out
	var _arg1 C.GtkSpinButtonUpdatePolicy // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkSpinButtonUpdatePolicy)(policy)

	C.gtk_spin_button_set_update_policy(_arg0, _arg1)
}

// SetValue sets the value of @spin_button.
func (s spinButton) SetValue(value float64) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 C.gdouble        // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gdouble)(value)

	C.gtk_spin_button_set_value(_arg0, _arg1)
}

// SetWrap sets the flag that determines if a spin button value wraps around to
// the opposite limit when the upper or lower limit of the range is exceeded.
func (s spinButton) SetWrap(wrap bool) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	if wrap {
		_arg1 = C.TRUE
	}

	C.gtk_spin_button_set_wrap(_arg0, _arg1)
}

// Spin: increment or decrement a spin button’s value in a specified direction
// by a specified amount.
func (s spinButton) Spin(direction SpinType, increment float64) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 C.GtkSpinType    // out
	var _arg2 C.gdouble        // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkSpinType)(direction)
	_arg2 = (C.gdouble)(increment)

	C.gtk_spin_button_spin(_arg0, _arg1, _arg2)
}

// Update: manually force an update of the spin button.
func (s spinButton) Update() {
	var _arg0 *C.GtkSpinButton // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	C.gtk_spin_button_update(_arg0)
}

type SpinButtonAccessible interface {
	EntryAccessible
}

// spinButtonAccessible implements the SpinButtonAccessible class.
type spinButtonAccessible struct {
	EntryAccessible
}

var _ SpinButtonAccessible = (*spinButtonAccessible)(nil)

// WrapSpinButtonAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapSpinButtonAccessible(obj *externglib.Object) SpinButtonAccessible {
	return spinButtonAccessible{
		EntryAccessible: WrapEntryAccessible(obj),
	}
}

func marshalSpinButtonAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSpinButtonAccessible(obj), nil
}

// Spinner: a GtkSpinner widget displays an icon-size spinning animation. It is
// often used as an alternative to a ProgressBar for displaying indefinite
// activity, instead of actual progress.
//
// To start the animation, use gtk_spinner_start(), to stop it use
// gtk_spinner_stop().
//
//
// CSS nodes
//
// GtkSpinner has a single CSS node with the name spinner. When the animation is
// active, the :checked pseudoclass is added to this node.
type Spinner interface {
	Widget
	Buildable

	// Start starts the animation of the spinner.
	Start()
	// Stop stops the animation of the spinner.
	Stop()
}

// spinner implements the Spinner class.
type spinner struct {
	Widget
	Buildable
}

var _ Spinner = (*spinner)(nil)

// WrapSpinner wraps a GObject to the right type. It is
// primarily used internally.
func WrapSpinner(obj *externglib.Object) Spinner {
	return spinner{
		Widget:    WrapWidget(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalSpinner(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSpinner(obj), nil
}

// NewSpinner returns a new spinner widget. Not yet started.
func NewSpinner() Spinner {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_spinner_new()

	var _spinner Spinner // out

	_spinner = WrapSpinner(externglib.Take(unsafe.Pointer(_cret)))

	return _spinner
}

// Start starts the animation of the spinner.
func (s spinner) Start() {
	var _arg0 *C.GtkSpinner // out

	_arg0 = (*C.GtkSpinner)(unsafe.Pointer(s.Native()))

	C.gtk_spinner_start(_arg0)
}

// Stop stops the animation of the spinner.
func (s spinner) Stop() {
	var _arg0 *C.GtkSpinner // out

	_arg0 = (*C.GtkSpinner)(unsafe.Pointer(s.Native()))

	C.gtk_spinner_stop(_arg0)
}

type SpinnerAccessible interface {
	WidgetAccessible
}

// spinnerAccessible implements the SpinnerAccessible class.
type spinnerAccessible struct {
	WidgetAccessible
}

var _ SpinnerAccessible = (*spinnerAccessible)(nil)

// WrapSpinnerAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapSpinnerAccessible(obj *externglib.Object) SpinnerAccessible {
	return spinnerAccessible{
		WidgetAccessible: WrapWidgetAccessible(obj),
	}
}

func marshalSpinnerAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSpinnerAccessible(obj), nil
}

// Stack: the GtkStack widget is a container which only shows one of its
// children at a time. In contrast to GtkNotebook, GtkStack does not provide a
// means for users to change the visible child. Instead, the StackSwitcher
// widget can be used with GtkStack to provide this functionality.
//
// Transitions between pages can be animated as slides or fades. This can be
// controlled with gtk_stack_set_transition_type(). These animations respect the
// Settings:gtk-enable-animations setting.
//
// The GtkStack widget was added in GTK+ 3.10.
//
//
// CSS nodes
//
// GtkStack has a single CSS node named stack.
type Stack interface {
	Container
	Buildable

	// AddNamed adds a child to @stack. The child is identified by the @name.
	AddNamed(child Widget, name string)
	// AddTitled adds a child to @stack. The child is identified by the @name.
	// The @title will be used by StackSwitcher to represent @child in a tab
	// bar, so it should be short.
	AddTitled(child Widget, name string, title string)
	// ChildByName finds the child of the Stack with the name given as the
	// argument. Returns nil if there is no child with this name.
	ChildByName(name string) Widget
	// Hhomogeneous gets whether @stack is horizontally homogeneous. See
	// gtk_stack_set_hhomogeneous().
	Hhomogeneous() bool
	// Homogeneous gets whether @stack is homogeneous. See
	// gtk_stack_set_homogeneous().
	Homogeneous() bool
	// InterpolateSize returns wether the Stack is set up to interpolate between
	// the sizes of children on page switch.
	InterpolateSize() bool
	// TransitionDuration returns the amount of time (in milliseconds) that
	// transitions between pages in @stack will take.
	TransitionDuration() uint
	// TransitionRunning returns whether the @stack is currently in a transition
	// from one page to another.
	TransitionRunning() bool
	// TransitionType gets the type of animation that will be used for
	// transitions between pages in @stack.
	TransitionType() StackTransitionType
	// Vhomogeneous gets whether @stack is vertically homogeneous. See
	// gtk_stack_set_vhomogeneous().
	Vhomogeneous() bool
	// VisibleChild gets the currently visible child of @stack, or nil if there
	// are no visible children.
	VisibleChild() Widget
	// VisibleChildName returns the name of the currently visible child of
	// @stack, or nil if there is no visible child.
	VisibleChildName() string
	// SetHhomogeneous sets the Stack to be horizontally homogeneous or not. If
	// it is homogeneous, the Stack will request the same width for all its
	// children. If it isn't, the stack may change width when a different child
	// becomes visible.
	SetHhomogeneous(hhomogeneous bool)
	// SetHomogeneous sets the Stack to be homogeneous or not. If it is
	// homogeneous, the Stack will request the same size for all its children.
	// If it isn't, the stack may change size when a different child becomes
	// visible.
	//
	// Since 3.16, homogeneity can be controlled separately for horizontal and
	// vertical size, with the Stack:hhomogeneous and Stack:vhomogeneous.
	SetHomogeneous(homogeneous bool)
	// SetInterpolateSize sets whether or not @stack will interpolate its size
	// when changing the visible child. If the Stack:interpolate-size property
	// is set to true, @stack will interpolate its size between the current one
	// and the one it'll take after changing the visible child, according to the
	// set transition duration.
	SetInterpolateSize(interpolateSize bool)
	// SetTransitionDuration sets the duration that transitions between pages in
	// @stack will take.
	SetTransitionDuration(duration uint)
	// SetTransitionType sets the type of animation that will be used for
	// transitions between pages in @stack. Available types include various
	// kinds of fades and slides.
	//
	// The transition type can be changed without problems at runtime, so it is
	// possible to change the animation based on the page that is about to
	// become current.
	SetTransitionType(transition StackTransitionType)
	// SetVhomogeneous sets the Stack to be vertically homogeneous or not. If it
	// is homogeneous, the Stack will request the same height for all its
	// children. If it isn't, the stack may change height when a different child
	// becomes visible.
	SetVhomogeneous(vhomogeneous bool)
	// SetVisibleChild makes @child the visible child of @stack.
	//
	// If @child is different from the currently visible child, the transition
	// between the two will be animated with the current transition type of
	// @stack.
	//
	// Note that the @child widget has to be visible itself (see
	// gtk_widget_show()) in order to become the visible child of @stack.
	SetVisibleChild(child Widget)
	// SetVisibleChildFull makes the child with the given name visible.
	//
	// Note that the child widget has to be visible itself (see
	// gtk_widget_show()) in order to become the visible child of @stack.
	SetVisibleChildFull(name string, transition StackTransitionType)
	// SetVisibleChildName makes the child with the given name visible.
	//
	// If @child is different from the currently visible child, the transition
	// between the two will be animated with the current transition type of
	// @stack.
	//
	// Note that the child widget has to be visible itself (see
	// gtk_widget_show()) in order to become the visible child of @stack.
	SetVisibleChildName(name string)
}

// stack implements the Stack class.
type stack struct {
	Container
	Buildable
}

var _ Stack = (*stack)(nil)

// WrapStack wraps a GObject to the right type. It is
// primarily used internally.
func WrapStack(obj *externglib.Object) Stack {
	return stack{
		Container: WrapContainer(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalStack(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStack(obj), nil
}

// NewStack creates a new Stack container.
func NewStack() Stack {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_stack_new()

	var _stack Stack // out

	_stack = WrapStack(externglib.Take(unsafe.Pointer(_cret)))

	return _stack
}

// AddNamed adds a child to @stack. The child is identified by the @name.
func (s stack) AddNamed(child Widget, name string) {
	var _arg0 *C.GtkStack  // out
	var _arg1 *C.GtkWidget // out
	var _arg2 *C.gchar     // out

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_stack_add_named(_arg0, _arg1, _arg2)
}

// AddTitled adds a child to @stack. The child is identified by the @name. The
// @title will be used by StackSwitcher to represent @child in a tab bar, so it
// should be short.
func (s stack) AddTitled(child Widget, name string, title string) {
	var _arg0 *C.GtkStack  // out
	var _arg1 *C.GtkWidget // out
	var _arg2 *C.gchar     // out
	var _arg3 *C.gchar     // out

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg3))

	C.gtk_stack_add_titled(_arg0, _arg1, _arg2, _arg3)
}

// ChildByName finds the child of the Stack with the name given as the argument.
// Returns nil if there is no child with this name.
func (s stack) ChildByName(name string) Widget {
	var _arg0 *C.GtkStack  // out
	var _arg1 *C.gchar     // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_stack_get_child_by_name(_arg0, _arg1)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// Hhomogeneous gets whether @stack is horizontally homogeneous. See
// gtk_stack_set_hhomogeneous().
func (s stack) Hhomogeneous() bool {
	var _arg0 *C.GtkStack // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_stack_get_hhomogeneous(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Homogeneous gets whether @stack is homogeneous. See
// gtk_stack_set_homogeneous().
func (s stack) Homogeneous() bool {
	var _arg0 *C.GtkStack // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_stack_get_homogeneous(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InterpolateSize returns wether the Stack is set up to interpolate between the
// sizes of children on page switch.
func (s stack) InterpolateSize() bool {
	var _arg0 *C.GtkStack // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_stack_get_interpolate_size(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TransitionDuration returns the amount of time (in milliseconds) that
// transitions between pages in @stack will take.
func (s stack) TransitionDuration() uint {
	var _arg0 *C.GtkStack // out
	var _cret C.guint     // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_stack_get_transition_duration(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// TransitionRunning returns whether the @stack is currently in a transition
// from one page to another.
func (s stack) TransitionRunning() bool {
	var _arg0 *C.GtkStack // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_stack_get_transition_running(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TransitionType gets the type of animation that will be used for transitions
// between pages in @stack.
func (s stack) TransitionType() StackTransitionType {
	var _arg0 *C.GtkStack              // out
	var _cret C.GtkStackTransitionType // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_stack_get_transition_type(_arg0)

	var _stackTransitionType StackTransitionType // out

	_stackTransitionType = StackTransitionType(_cret)

	return _stackTransitionType
}

// Vhomogeneous gets whether @stack is vertically homogeneous. See
// gtk_stack_set_vhomogeneous().
func (s stack) Vhomogeneous() bool {
	var _arg0 *C.GtkStack // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_stack_get_vhomogeneous(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// VisibleChild gets the currently visible child of @stack, or nil if there are
// no visible children.
func (s stack) VisibleChild() Widget {
	var _arg0 *C.GtkStack  // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_stack_get_visible_child(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// VisibleChildName returns the name of the currently visible child of @stack,
// or nil if there is no visible child.
func (s stack) VisibleChildName() string {
	var _arg0 *C.GtkStack // out
	var _cret *C.gchar    // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_stack_get_visible_child_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// SetHhomogeneous sets the Stack to be horizontally homogeneous or not. If it
// is homogeneous, the Stack will request the same width for all its children.
// If it isn't, the stack may change width when a different child becomes
// visible.
func (s stack) SetHhomogeneous(hhomogeneous bool) {
	var _arg0 *C.GtkStack // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	if hhomogeneous {
		_arg1 = C.TRUE
	}

	C.gtk_stack_set_hhomogeneous(_arg0, _arg1)
}

// SetHomogeneous sets the Stack to be homogeneous or not. If it is homogeneous,
// the Stack will request the same size for all its children. If it isn't, the
// stack may change size when a different child becomes visible.
//
// Since 3.16, homogeneity can be controlled separately for horizontal and
// vertical size, with the Stack:hhomogeneous and Stack:vhomogeneous.
func (s stack) SetHomogeneous(homogeneous bool) {
	var _arg0 *C.GtkStack // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	if homogeneous {
		_arg1 = C.TRUE
	}

	C.gtk_stack_set_homogeneous(_arg0, _arg1)
}

// SetInterpolateSize sets whether or not @stack will interpolate its size when
// changing the visible child. If the Stack:interpolate-size property is set to
// true, @stack will interpolate its size between the current one and the one
// it'll take after changing the visible child, according to the set transition
// duration.
func (s stack) SetInterpolateSize(interpolateSize bool) {
	var _arg0 *C.GtkStack // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	if interpolateSize {
		_arg1 = C.TRUE
	}

	C.gtk_stack_set_interpolate_size(_arg0, _arg1)
}

// SetTransitionDuration sets the duration that transitions between pages in
// @stack will take.
func (s stack) SetTransitionDuration(duration uint) {
	var _arg0 *C.GtkStack // out
	var _arg1 C.guint     // out

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(duration)

	C.gtk_stack_set_transition_duration(_arg0, _arg1)
}

// SetTransitionType sets the type of animation that will be used for
// transitions between pages in @stack. Available types include various kinds of
// fades and slides.
//
// The transition type can be changed without problems at runtime, so it is
// possible to change the animation based on the page that is about to become
// current.
func (s stack) SetTransitionType(transition StackTransitionType) {
	var _arg0 *C.GtkStack              // out
	var _arg1 C.GtkStackTransitionType // out

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkStackTransitionType)(transition)

	C.gtk_stack_set_transition_type(_arg0, _arg1)
}

// SetVhomogeneous sets the Stack to be vertically homogeneous or not. If it is
// homogeneous, the Stack will request the same height for all its children. If
// it isn't, the stack may change height when a different child becomes visible.
func (s stack) SetVhomogeneous(vhomogeneous bool) {
	var _arg0 *C.GtkStack // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	if vhomogeneous {
		_arg1 = C.TRUE
	}

	C.gtk_stack_set_vhomogeneous(_arg0, _arg1)
}

// SetVisibleChild makes @child the visible child of @stack.
//
// If @child is different from the currently visible child, the transition
// between the two will be animated with the current transition type of @stack.
//
// Note that the @child widget has to be visible itself (see gtk_widget_show())
// in order to become the visible child of @stack.
func (s stack) SetVisibleChild(child Widget) {
	var _arg0 *C.GtkStack  // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_stack_set_visible_child(_arg0, _arg1)
}

// SetVisibleChildFull makes the child with the given name visible.
//
// Note that the child widget has to be visible itself (see gtk_widget_show())
// in order to become the visible child of @stack.
func (s stack) SetVisibleChildFull(name string, transition StackTransitionType) {
	var _arg0 *C.GtkStack              // out
	var _arg1 *C.gchar                 // out
	var _arg2 C.GtkStackTransitionType // out

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GtkStackTransitionType)(transition)

	C.gtk_stack_set_visible_child_full(_arg0, _arg1, _arg2)
}

// SetVisibleChildName makes the child with the given name visible.
//
// If @child is different from the currently visible child, the transition
// between the two will be animated with the current transition type of @stack.
//
// Note that the child widget has to be visible itself (see gtk_widget_show())
// in order to become the visible child of @stack.
func (s stack) SetVisibleChildName(name string) {
	var _arg0 *C.GtkStack // out
	var _arg1 *C.gchar    // out

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_stack_set_visible_child_name(_arg0, _arg1)
}

type StackAccessible interface {
	ContainerAccessible
}

// stackAccessible implements the StackAccessible class.
type stackAccessible struct {
	ContainerAccessible
}

var _ StackAccessible = (*stackAccessible)(nil)

// WrapStackAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapStackAccessible(obj *externglib.Object) StackAccessible {
	return stackAccessible{
		ContainerAccessible: WrapContainerAccessible(obj),
	}
}

func marshalStackAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStackAccessible(obj), nil
}

// StackSidebar: a GtkStackSidebar enables you to quickly and easily provide a
// consistent "sidebar" object for your user interface.
//
// In order to use a GtkStackSidebar, you simply use a GtkStack to organize your
// UI flow, and add the sidebar to your sidebar area. You can use
// gtk_stack_sidebar_set_stack() to connect the StackSidebar to the Stack.
//
//
// CSS nodes
//
// GtkStackSidebar has a single CSS node with name stacksidebar and style class
// .sidebar.
//
// When circumstances require it, GtkStackSidebar adds the .needs-attention
// style class to the widgets representing the stack pages.
type StackSidebar interface {
	Bin
	Buildable

	// Stack retrieves the stack. See gtk_stack_sidebar_set_stack().
	Stack() Stack
	// SetStack: set the Stack associated with this StackSidebar.
	//
	// The sidebar widget will automatically update according to the order
	// (packing) and items within the given Stack.
	SetStack(stack Stack)
}

// stackSidebar implements the StackSidebar class.
type stackSidebar struct {
	Bin
	Buildable
}

var _ StackSidebar = (*stackSidebar)(nil)

// WrapStackSidebar wraps a GObject to the right type. It is
// primarily used internally.
func WrapStackSidebar(obj *externglib.Object) StackSidebar {
	return stackSidebar{
		Bin:       WrapBin(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalStackSidebar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStackSidebar(obj), nil
}

// NewStackSidebar creates a new sidebar.
func NewStackSidebar() StackSidebar {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_stack_sidebar_new()

	var _stackSidebar StackSidebar // out

	_stackSidebar = WrapStackSidebar(externglib.Take(unsafe.Pointer(_cret)))

	return _stackSidebar
}

// Stack retrieves the stack. See gtk_stack_sidebar_set_stack().
func (s stackSidebar) Stack() Stack {
	var _arg0 *C.GtkStackSidebar // out
	var _cret *C.GtkStack        // in

	_arg0 = (*C.GtkStackSidebar)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_stack_sidebar_get_stack(_arg0)

	var _stack Stack // out

	_stack = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Stack)

	return _stack
}

// SetStack: set the Stack associated with this StackSidebar.
//
// The sidebar widget will automatically update according to the order (packing)
// and items within the given Stack.
func (s stackSidebar) SetStack(stack Stack) {
	var _arg0 *C.GtkStackSidebar // out
	var _arg1 *C.GtkStack        // out

	_arg0 = (*C.GtkStackSidebar)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkStack)(unsafe.Pointer(stack.Native()))

	C.gtk_stack_sidebar_set_stack(_arg0, _arg1)
}

// StackSwitcher: the GtkStackSwitcher widget acts as a controller for a Stack;
// it shows a row of buttons to switch between the various pages of the
// associated stack widget.
//
// All the content for the buttons comes from the child properties of the Stack;
// the button visibility in a StackSwitcher widget is controlled by the
// visibility of the child in the Stack.
//
// It is possible to associate multiple StackSwitcher widgets with the same
// Stack widget.
//
// The GtkStackSwitcher widget was added in 3.10.
//
//
// CSS nodes
//
// GtkStackSwitcher has a single CSS node named stackswitcher and style class
// .stack-switcher.
//
// When circumstances require it, GtkStackSwitcher adds the .needs-attention
// style class to the widgets representing the stack pages.
type StackSwitcher interface {
	Box
	Buildable
	Orientable

	// Stack retrieves the stack. See gtk_stack_switcher_set_stack().
	Stack() Stack
	// SetStack sets the stack to control.
	SetStack(stack Stack)
}

// stackSwitcher implements the StackSwitcher class.
type stackSwitcher struct {
	Box
	Buildable
	Orientable
}

var _ StackSwitcher = (*stackSwitcher)(nil)

// WrapStackSwitcher wraps a GObject to the right type. It is
// primarily used internally.
func WrapStackSwitcher(obj *externglib.Object) StackSwitcher {
	return stackSwitcher{
		Box:        WrapBox(obj),
		Buildable:  WrapBuildable(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalStackSwitcher(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStackSwitcher(obj), nil
}

// NewStackSwitcher: create a new StackSwitcher.
func NewStackSwitcher() StackSwitcher {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_stack_switcher_new()

	var _stackSwitcher StackSwitcher // out

	_stackSwitcher = WrapStackSwitcher(externglib.Take(unsafe.Pointer(_cret)))

	return _stackSwitcher
}

// Stack retrieves the stack. See gtk_stack_switcher_set_stack().
func (s stackSwitcher) Stack() Stack {
	var _arg0 *C.GtkStackSwitcher // out
	var _cret *C.GtkStack         // in

	_arg0 = (*C.GtkStackSwitcher)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_stack_switcher_get_stack(_arg0)

	var _stack Stack // out

	_stack = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Stack)

	return _stack
}

// SetStack sets the stack to control.
func (s stackSwitcher) SetStack(stack Stack) {
	var _arg0 *C.GtkStackSwitcher // out
	var _arg1 *C.GtkStack         // out

	_arg0 = (*C.GtkStackSwitcher)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkStack)(unsafe.Pointer(stack.Native()))

	C.gtk_stack_switcher_set_stack(_arg0, _arg1)
}

// StatusIcon: the “system tray” or notification area is normally used for
// transient icons that indicate some special state. For example, a system tray
// icon might appear to tell the user that they have new mail, or have an
// incoming instant message, or something along those lines. The basic idea is
// that creating an icon in the notification area is less annoying than popping
// up a dialog.
//
// A StatusIcon object can be used to display an icon in a “system tray”. The
// icon can have a tooltip, and the user can interact with it by activating it
// or popping up a context menu.
//
// It is very important to notice that status icons depend on the existence of a
// notification area being available to the user; you should not use status
// icons as the only way to convey critical information regarding your
// application, as the notification area may not exist on the user's
// environment, or may have been removed. You should always check that a status
// icon has been embedded into a notification area by using
// gtk_status_icon_is_embedded(), and gracefully recover if the function returns
// false.
//
// On X11, the implementation follows the FreeDesktop System Tray Specification
// (http://www.freedesktop.org/wiki/Specifications/systemtray-spec).
// Implementations of the “tray” side of this specification can be found e.g. in
// the GNOME 2 and KDE panel applications.
//
// Note that a GtkStatusIcon is not a widget, but just a #GObject. Making it a
// widget would be impractical, since the system tray on Windows doesn’t allow
// to embed arbitrary widgets.
//
// GtkStatusIcon has been deprecated in 3.14. You should consider using
// notifications or more modern platform-specific APIs instead. GLib provides
// the #GNotification API which works well with Application on multiple
// platforms and environments, and should be the preferred mechanism to notify
// the users of transient status updates. See this HowDoI
// (https://wiki.gnome.org/HowDoI/GNotification) for code examples.
type StatusIcon interface {
	gextras.Objector

	// Geometry obtains information about the location of the status icon on
	// screen. This information can be used to e.g. position popups like
	// notification bubbles.
	//
	// See gtk_status_icon_position_menu() for a more convenient alternative for
	// positioning menus.
	//
	// Note that some platforms do not allow GTK+ to provide this information,
	// and even on platforms that do allow it, the information is not reliable
	// unless the status icon is embedded in a notification area, see
	// gtk_status_icon_is_embedded().
	Geometry() (gdk.Screen, gdk.Rectangle, Orientation, bool)
	// GIcon retrieves the #GIcon being displayed by the StatusIcon. The storage
	// type of the status icon must be GTK_IMAGE_EMPTY or GTK_IMAGE_GICON (see
	// gtk_status_icon_get_storage_type()). The caller of this function does not
	// own a reference to the returned #GIcon.
	//
	// If this function fails, @icon is left unchanged;
	GIcon() gio.Icon
	// HasTooltip returns the current value of the has-tooltip property. See
	// StatusIcon:has-tooltip for more information.
	HasTooltip() bool
	// IconName gets the name of the icon being displayed by the StatusIcon. The
	// storage type of the status icon must be GTK_IMAGE_EMPTY or
	// GTK_IMAGE_ICON_NAME (see gtk_status_icon_get_storage_type()). The
	// returned string is owned by the StatusIcon and should not be freed or
	// modified.
	IconName() string
	// Pixbuf gets the Pixbuf being displayed by the StatusIcon. The storage
	// type of the status icon must be GTK_IMAGE_EMPTY or GTK_IMAGE_PIXBUF (see
	// gtk_status_icon_get_storage_type()). The caller of this function does not
	// own a reference to the returned pixbuf.
	Pixbuf() gdkpixbuf.Pixbuf
	// Screen returns the Screen associated with @status_icon.
	Screen() gdk.Screen
	// Size gets the size in pixels that is available for the image. Stock icons
	// and named icons adapt their size automatically if the size of the
	// notification area changes. For other storage types, the size-changed
	// signal can be used to react to size changes.
	//
	// Note that the returned size is only meaningful while the status icon is
	// embedded (see gtk_status_icon_is_embedded()).
	Size() int
	// Stock gets the id of the stock icon being displayed by the StatusIcon.
	// The storage type of the status icon must be GTK_IMAGE_EMPTY or
	// GTK_IMAGE_STOCK (see gtk_status_icon_get_storage_type()). The returned
	// string is owned by the StatusIcon and should not be freed or modified.
	Stock() string
	// StorageType gets the type of representation being used by the StatusIcon
	// to store image data. If the StatusIcon has no image data, the return
	// value will be GTK_IMAGE_EMPTY.
	StorageType() ImageType
	// Title gets the title of this tray icon. See gtk_status_icon_set_title().
	Title() string
	// TooltipMarkup gets the contents of the tooltip for @status_icon.
	TooltipMarkup() string
	// TooltipText gets the contents of the tooltip for @status_icon.
	TooltipText() string
	// Visible returns whether the status icon is visible or not. Note that
	// being visible does not guarantee that the user can actually see the icon,
	// see also gtk_status_icon_is_embedded().
	Visible() bool
	// X11WindowID: this function is only useful on the X11/freedesktop.org
	// platform.
	//
	// It returns a window ID for the widget in the underlying status icon
	// implementation. This is useful for the Galago notification service, which
	// can send a window ID in the protocol in order for the server to position
	// notification windows pointing to a status icon reliably.
	//
	// This function is not intended for other use cases which are more likely
	// to be met by one of the non-X11 specific methods, such as
	// gtk_status_icon_position_menu().
	X11WindowID() uint32
	// IsEmbedded returns whether the status icon is embedded in a notification
	// area.
	IsEmbedded() bool
	// SetFromFile makes @status_icon display the file @filename. See
	// gtk_status_icon_new_from_file() for details.
	SetFromFile(filename string)
	// SetFromGIcon makes @status_icon display the #GIcon. See
	// gtk_status_icon_new_from_gicon() for details.
	SetFromGIcon(icon gio.Icon)
	// SetFromIconName makes @status_icon display the icon named @icon_name from
	// the current icon theme. See gtk_status_icon_new_from_icon_name() for
	// details.
	SetFromIconName(iconName string)
	// SetFromPixbuf makes @status_icon display @pixbuf. See
	// gtk_status_icon_new_from_pixbuf() for details.
	SetFromPixbuf(pixbuf gdkpixbuf.Pixbuf)
	// SetFromStock makes @status_icon display the stock icon with the id
	// @stock_id. See gtk_status_icon_new_from_stock() for details.
	SetFromStock(stockId string)
	// SetHasTooltip sets the has-tooltip property on @status_icon to
	// @has_tooltip. See StatusIcon:has-tooltip for more information.
	SetHasTooltip(hasTooltip bool)
	// SetName sets the name of this tray icon. This should be a string
	// identifying this icon. It is may be used for sorting the icons in the
	// tray and will not be shown to the user.
	SetName(name string)
	// SetScreen sets the Screen where @status_icon is displayed; if the icon is
	// already mapped, it will be unmapped, and then remapped on the new screen.
	SetScreen(screen gdk.Screen)
	// SetTitle sets the title of this tray icon. This should be a short,
	// human-readable, localized string describing the tray icon. It may be used
	// by tools like screen readers to render the tray icon.
	SetTitle(title string)
	// SetTooltipMarkup sets @markup as the contents of the tooltip, which is
	// marked up with the [Pango text markup language][PangoMarkupFormat].
	//
	// This function will take care of setting StatusIcon:has-tooltip to true
	// and of the default handler for the StatusIcon::query-tooltip signal.
	//
	// See also the StatusIcon:tooltip-markup property and
	// gtk_tooltip_set_markup().
	SetTooltipMarkup(markup string)
	// SetTooltipText sets @text as the contents of the tooltip.
	//
	// This function will take care of setting StatusIcon:has-tooltip to true
	// and of the default handler for the StatusIcon::query-tooltip signal.
	//
	// See also the StatusIcon:tooltip-text property and gtk_tooltip_set_text().
	SetTooltipText(text string)
	// SetVisible shows or hides a status icon.
	SetVisible(visible bool)
}

// statusIcon implements the StatusIcon class.
type statusIcon struct {
	gextras.Objector
}

var _ StatusIcon = (*statusIcon)(nil)

// WrapStatusIcon wraps a GObject to the right type. It is
// primarily used internally.
func WrapStatusIcon(obj *externglib.Object) StatusIcon {
	return statusIcon{
		Objector: obj,
	}
}

func marshalStatusIcon(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStatusIcon(obj), nil
}

// NewStatusIcon creates an empty status icon object.
func NewStatusIcon() StatusIcon {
	var _cret *C.GtkStatusIcon // in

	_cret = C.gtk_status_icon_new()

	var _statusIcon StatusIcon // out

	_statusIcon = WrapStatusIcon(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _statusIcon
}

// NewStatusIconFromFile creates a status icon displaying the file @filename.
//
// The image will be scaled down to fit in the available space in the
// notification area, if necessary.
func NewStatusIconFromFile(filename string) StatusIcon {
	var _arg1 *C.gchar         // out
	var _cret *C.GtkStatusIcon // in

	_arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_status_icon_new_from_file(_arg1)

	var _statusIcon StatusIcon // out

	_statusIcon = WrapStatusIcon(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _statusIcon
}

// NewStatusIconFromGIcon creates a status icon displaying a #GIcon. If the icon
// is a themed icon, it will be updated when the theme changes.
func NewStatusIconFromGIcon(icon gio.Icon) StatusIcon {
	var _arg1 *C.GIcon         // out
	var _cret *C.GtkStatusIcon // in

	_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

	_cret = C.gtk_status_icon_new_from_gicon(_arg1)

	var _statusIcon StatusIcon // out

	_statusIcon = WrapStatusIcon(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _statusIcon
}

// NewStatusIconFromIconName creates a status icon displaying an icon from the
// current icon theme. If the current icon theme is changed, the icon will be
// updated appropriately.
func NewStatusIconFromIconName(iconName string) StatusIcon {
	var _arg1 *C.gchar         // out
	var _cret *C.GtkStatusIcon // in

	_arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_status_icon_new_from_icon_name(_arg1)

	var _statusIcon StatusIcon // out

	_statusIcon = WrapStatusIcon(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _statusIcon
}

// NewStatusIconFromPixbuf creates a status icon displaying @pixbuf.
//
// The image will be scaled down to fit in the available space in the
// notification area, if necessary.
func NewStatusIconFromPixbuf(pixbuf gdkpixbuf.Pixbuf) StatusIcon {
	var _arg1 *C.GdkPixbuf     // out
	var _cret *C.GtkStatusIcon // in

	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	_cret = C.gtk_status_icon_new_from_pixbuf(_arg1)

	var _statusIcon StatusIcon // out

	_statusIcon = WrapStatusIcon(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _statusIcon
}

// NewStatusIconFromStock creates a status icon displaying a stock icon. Sample
// stock icon names are K_STOCK_OPEN, K_STOCK_QUIT. You can register your own
// stock icon names, see gtk_icon_factory_add_default() and
// gtk_icon_factory_add().
func NewStatusIconFromStock(stockId string) StatusIcon {
	var _arg1 *C.gchar         // out
	var _cret *C.GtkStatusIcon // in

	_arg1 = (*C.gchar)(C.CString(stockId))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_status_icon_new_from_stock(_arg1)

	var _statusIcon StatusIcon // out

	_statusIcon = WrapStatusIcon(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _statusIcon
}

// Geometry obtains information about the location of the status icon on screen.
// This information can be used to e.g. position popups like notification
// bubbles.
//
// See gtk_status_icon_position_menu() for a more convenient alternative for
// positioning menus.
//
// Note that some platforms do not allow GTK+ to provide this information, and
// even on platforms that do allow it, the information is not reliable unless
// the status icon is embedded in a notification area, see
// gtk_status_icon_is_embedded().
func (s statusIcon) Geometry() (gdk.Screen, gdk.Rectangle, Orientation, bool) {
	var _arg0 *C.GtkStatusIcon // out
	var _arg1 *C.GdkScreen     // in
	var _area gdk.Rectangle
	var _arg3 C.GtkOrientation // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_status_icon_get_geometry(_arg0, &_arg1, (*C.GdkRectangle)(unsafe.Pointer(&_area)), &_arg3)

	var _screen gdk.Screen // out

	var _orientation Orientation // out
	var _ok bool                 // out

	_screen = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg1))).(gdk.Screen)

	_orientation = Orientation(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _screen, _area, _orientation, _ok
}

// GIcon retrieves the #GIcon being displayed by the StatusIcon. The storage
// type of the status icon must be GTK_IMAGE_EMPTY or GTK_IMAGE_GICON (see
// gtk_status_icon_get_storage_type()). The caller of this function does not own
// a reference to the returned #GIcon.
//
// If this function fails, @icon is left unchanged;
func (s statusIcon) GIcon() gio.Icon {
	var _arg0 *C.GtkStatusIcon // out
	var _cret *C.GIcon         // in

	_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_status_icon_get_gicon(_arg0)

	var _icon gio.Icon // out

	_icon = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.Icon)

	return _icon
}

// HasTooltip returns the current value of the has-tooltip property. See
// StatusIcon:has-tooltip for more information.
func (s statusIcon) HasTooltip() bool {
	var _arg0 *C.GtkStatusIcon // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_status_icon_get_has_tooltip(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IconName gets the name of the icon being displayed by the StatusIcon. The
// storage type of the status icon must be GTK_IMAGE_EMPTY or
// GTK_IMAGE_ICON_NAME (see gtk_status_icon_get_storage_type()). The returned
// string is owned by the StatusIcon and should not be freed or modified.
func (s statusIcon) IconName() string {
	var _arg0 *C.GtkStatusIcon // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_status_icon_get_icon_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Pixbuf gets the Pixbuf being displayed by the StatusIcon. The storage type of
// the status icon must be GTK_IMAGE_EMPTY or GTK_IMAGE_PIXBUF (see
// gtk_status_icon_get_storage_type()). The caller of this function does not own
// a reference to the returned pixbuf.
func (s statusIcon) Pixbuf() gdkpixbuf.Pixbuf {
	var _arg0 *C.GtkStatusIcon // out
	var _cret *C.GdkPixbuf     // in

	_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_status_icon_get_pixbuf(_arg0)

	var _pixbuf gdkpixbuf.Pixbuf // out

	_pixbuf = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

	return _pixbuf
}

// Screen returns the Screen associated with @status_icon.
func (s statusIcon) Screen() gdk.Screen {
	var _arg0 *C.GtkStatusIcon // out
	var _cret *C.GdkScreen     // in

	_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_status_icon_get_screen(_arg0)

	var _screen gdk.Screen // out

	_screen = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Screen)

	return _screen
}

// Size gets the size in pixels that is available for the image. Stock icons and
// named icons adapt their size automatically if the size of the notification
// area changes. For other storage types, the size-changed signal can be used to
// react to size changes.
//
// Note that the returned size is only meaningful while the status icon is
// embedded (see gtk_status_icon_is_embedded()).
func (s statusIcon) Size() int {
	var _arg0 *C.GtkStatusIcon // out
	var _cret C.gint           // in

	_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_status_icon_get_size(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Stock gets the id of the stock icon being displayed by the StatusIcon. The
// storage type of the status icon must be GTK_IMAGE_EMPTY or GTK_IMAGE_STOCK
// (see gtk_status_icon_get_storage_type()). The returned string is owned by the
// StatusIcon and should not be freed or modified.
func (s statusIcon) Stock() string {
	var _arg0 *C.GtkStatusIcon // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_status_icon_get_stock(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// StorageType gets the type of representation being used by the StatusIcon to
// store image data. If the StatusIcon has no image data, the return value will
// be GTK_IMAGE_EMPTY.
func (s statusIcon) StorageType() ImageType {
	var _arg0 *C.GtkStatusIcon // out
	var _cret C.GtkImageType   // in

	_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_status_icon_get_storage_type(_arg0)

	var _imageType ImageType // out

	_imageType = ImageType(_cret)

	return _imageType
}

// Title gets the title of this tray icon. See gtk_status_icon_set_title().
func (s statusIcon) Title() string {
	var _arg0 *C.GtkStatusIcon // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_status_icon_get_title(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// TooltipMarkup gets the contents of the tooltip for @status_icon.
func (s statusIcon) TooltipMarkup() string {
	var _arg0 *C.GtkStatusIcon // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_status_icon_get_tooltip_markup(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// TooltipText gets the contents of the tooltip for @status_icon.
func (s statusIcon) TooltipText() string {
	var _arg0 *C.GtkStatusIcon // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_status_icon_get_tooltip_text(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Visible returns whether the status icon is visible or not. Note that being
// visible does not guarantee that the user can actually see the icon, see also
// gtk_status_icon_is_embedded().
func (s statusIcon) Visible() bool {
	var _arg0 *C.GtkStatusIcon // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_status_icon_get_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// X11WindowID: this function is only useful on the X11/freedesktop.org
// platform.
//
// It returns a window ID for the widget in the underlying status icon
// implementation. This is useful for the Galago notification service, which can
// send a window ID in the protocol in order for the server to position
// notification windows pointing to a status icon reliably.
//
// This function is not intended for other use cases which are more likely to be
// met by one of the non-X11 specific methods, such as
// gtk_status_icon_position_menu().
func (s statusIcon) X11WindowID() uint32 {
	var _arg0 *C.GtkStatusIcon // out
	var _cret C.guint32        // in

	_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_status_icon_get_x11_window_id(_arg0)

	var _guint32 uint32 // out

	_guint32 = (uint32)(_cret)

	return _guint32
}

// IsEmbedded returns whether the status icon is embedded in a notification
// area.
func (s statusIcon) IsEmbedded() bool {
	var _arg0 *C.GtkStatusIcon // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_status_icon_is_embedded(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetFromFile makes @status_icon display the file @filename. See
// gtk_status_icon_new_from_file() for details.
func (s statusIcon) SetFromFile(filename string) {
	var _arg0 *C.GtkStatusIcon // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_status_icon_set_from_file(_arg0, _arg1)
}

// SetFromGIcon makes @status_icon display the #GIcon. See
// gtk_status_icon_new_from_gicon() for details.
func (s statusIcon) SetFromGIcon(icon gio.Icon) {
	var _arg0 *C.GtkStatusIcon // out
	var _arg1 *C.GIcon         // out

	_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

	C.gtk_status_icon_set_from_gicon(_arg0, _arg1)
}

// SetFromIconName makes @status_icon display the icon named @icon_name from the
// current icon theme. See gtk_status_icon_new_from_icon_name() for details.
func (s statusIcon) SetFromIconName(iconName string) {
	var _arg0 *C.GtkStatusIcon // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_status_icon_set_from_icon_name(_arg0, _arg1)
}

// SetFromPixbuf makes @status_icon display @pixbuf. See
// gtk_status_icon_new_from_pixbuf() for details.
func (s statusIcon) SetFromPixbuf(pixbuf gdkpixbuf.Pixbuf) {
	var _arg0 *C.GtkStatusIcon // out
	var _arg1 *C.GdkPixbuf     // out

	_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	C.gtk_status_icon_set_from_pixbuf(_arg0, _arg1)
}

// SetFromStock makes @status_icon display the stock icon with the id @stock_id.
// See gtk_status_icon_new_from_stock() for details.
func (s statusIcon) SetFromStock(stockId string) {
	var _arg0 *C.GtkStatusIcon // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(stockId))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_status_icon_set_from_stock(_arg0, _arg1)
}

// SetHasTooltip sets the has-tooltip property on @status_icon to @has_tooltip.
// See StatusIcon:has-tooltip for more information.
func (s statusIcon) SetHasTooltip(hasTooltip bool) {
	var _arg0 *C.GtkStatusIcon // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))
	if hasTooltip {
		_arg1 = C.TRUE
	}

	C.gtk_status_icon_set_has_tooltip(_arg0, _arg1)
}

// SetName sets the name of this tray icon. This should be a string identifying
// this icon. It is may be used for sorting the icons in the tray and will not
// be shown to the user.
func (s statusIcon) SetName(name string) {
	var _arg0 *C.GtkStatusIcon // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_status_icon_set_name(_arg0, _arg1)
}

// SetScreen sets the Screen where @status_icon is displayed; if the icon is
// already mapped, it will be unmapped, and then remapped on the new screen.
func (s statusIcon) SetScreen(screen gdk.Screen) {
	var _arg0 *C.GtkStatusIcon // out
	var _arg1 *C.GdkScreen     // out

	_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkScreen)(unsafe.Pointer(screen.Native()))

	C.gtk_status_icon_set_screen(_arg0, _arg1)
}

// SetTitle sets the title of this tray icon. This should be a short,
// human-readable, localized string describing the tray icon. It may be used by
// tools like screen readers to render the tray icon.
func (s statusIcon) SetTitle(title string) {
	var _arg0 *C.GtkStatusIcon // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_status_icon_set_title(_arg0, _arg1)
}

// SetTooltipMarkup sets @markup as the contents of the tooltip, which is marked
// up with the [Pango text markup language][PangoMarkupFormat].
//
// This function will take care of setting StatusIcon:has-tooltip to true and of
// the default handler for the StatusIcon::query-tooltip signal.
//
// See also the StatusIcon:tooltip-markup property and gtk_tooltip_set_markup().
func (s statusIcon) SetTooltipMarkup(markup string) {
	var _arg0 *C.GtkStatusIcon // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(markup))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_status_icon_set_tooltip_markup(_arg0, _arg1)
}

// SetTooltipText sets @text as the contents of the tooltip.
//
// This function will take care of setting StatusIcon:has-tooltip to true and of
// the default handler for the StatusIcon::query-tooltip signal.
//
// See also the StatusIcon:tooltip-text property and gtk_tooltip_set_text().
func (s statusIcon) SetTooltipText(text string) {
	var _arg0 *C.GtkStatusIcon // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_status_icon_set_tooltip_text(_arg0, _arg1)
}

// SetVisible shows or hides a status icon.
func (s statusIcon) SetVisible(visible bool) {
	var _arg0 *C.GtkStatusIcon // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))
	if visible {
		_arg1 = C.TRUE
	}

	C.gtk_status_icon_set_visible(_arg0, _arg1)
}

// Statusbar: a Statusbar is usually placed along the bottom of an application's
// main Window. It may provide a regular commentary of the application's status
// (as is usually the case in a web browser, for example), or may be used to
// simply output a message when the status changes, (when an upload is complete
// in an FTP client, for example).
//
// Status bars in GTK+ maintain a stack of messages. The message at the top of
// the each bar’s stack is the one that will currently be displayed.
//
// Any messages added to a statusbar’s stack must specify a context id that is
// used to uniquely identify the source of a message. This context id can be
// generated by gtk_statusbar_get_context_id(), given a message and the
// statusbar that it will be added to. Note that messages are stored in a stack,
// and when choosing which message to display, the stack structure is adhered
// to, regardless of the context identifier of a message.
//
// One could say that a statusbar maintains one stack of messages for display
// purposes, but allows multiple message producers to maintain sub-stacks of the
// messages they produced (via context ids).
//
// Status bars are created using gtk_statusbar_new().
//
// Messages are added to the bar’s stack with gtk_statusbar_push().
//
// The message at the top of the stack can be removed using gtk_statusbar_pop().
// A message can be removed from anywhere in the stack if its message id was
// recorded at the time it was added. This is done using gtk_statusbar_remove().
//
//
// CSS node
//
// GtkStatusbar has a single CSS node with name statusbar.
type Statusbar interface {
	Box
	Buildable
	Orientable

	// ContextID returns a new context identifier, given a description of the
	// actual context. Note that the description is not shown in the UI.
	ContextID(contextDescription string) uint
	// MessageArea retrieves the box containing the label widget.
	MessageArea() Box
	// Pop removes the first message in the Statusbar’s stack with the given
	// context id.
	//
	// Note that this may not change the displayed message, if the message at
	// the top of the stack has a different context id.
	Pop(contextId uint)
	// Push pushes a new message onto a statusbar’s stack.
	Push(contextId uint, text string) uint
	// Remove forces the removal of a message from a statusbar’s stack. The
	// exact @context_id and @message_id must be specified.
	Remove(contextId uint, messageId uint)
	// RemoveAll forces the removal of all messages from a statusbar's stack
	// with the exact @context_id.
	RemoveAll(contextId uint)
}

// statusbar implements the Statusbar class.
type statusbar struct {
	Box
	Buildable
	Orientable
}

var _ Statusbar = (*statusbar)(nil)

// WrapStatusbar wraps a GObject to the right type. It is
// primarily used internally.
func WrapStatusbar(obj *externglib.Object) Statusbar {
	return statusbar{
		Box:        WrapBox(obj),
		Buildable:  WrapBuildable(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalStatusbar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStatusbar(obj), nil
}

// NewStatusbar creates a new Statusbar ready for messages.
func NewStatusbar() Statusbar {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_statusbar_new()

	var _statusbar Statusbar // out

	_statusbar = WrapStatusbar(externglib.Take(unsafe.Pointer(_cret)))

	return _statusbar
}

// ContextID returns a new context identifier, given a description of the actual
// context. Note that the description is not shown in the UI.
func (s statusbar) ContextID(contextDescription string) uint {
	var _arg0 *C.GtkStatusbar // out
	var _arg1 *C.gchar        // out
	var _cret C.guint         // in

	_arg0 = (*C.GtkStatusbar)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(contextDescription))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_statusbar_get_context_id(_arg0, _arg1)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// MessageArea retrieves the box containing the label widget.
func (s statusbar) MessageArea() Box {
	var _arg0 *C.GtkStatusbar // out
	var _cret *C.GtkWidget    // in

	_arg0 = (*C.GtkStatusbar)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_statusbar_get_message_area(_arg0)

	var _box Box // out

	_box = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Box)

	return _box
}

// Pop removes the first message in the Statusbar’s stack with the given context
// id.
//
// Note that this may not change the displayed message, if the message at the
// top of the stack has a different context id.
func (s statusbar) Pop(contextId uint) {
	var _arg0 *C.GtkStatusbar // out
	var _arg1 C.guint         // out

	_arg0 = (*C.GtkStatusbar)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(contextId)

	C.gtk_statusbar_pop(_arg0, _arg1)
}

// Push pushes a new message onto a statusbar’s stack.
func (s statusbar) Push(contextId uint, text string) uint {
	var _arg0 *C.GtkStatusbar // out
	var _arg1 C.guint         // out
	var _arg2 *C.gchar        // out
	var _cret C.guint         // in

	_arg0 = (*C.GtkStatusbar)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(contextId)
	_arg2 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_statusbar_push(_arg0, _arg1, _arg2)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// Remove forces the removal of a message from a statusbar’s stack. The exact
// @context_id and @message_id must be specified.
func (s statusbar) Remove(contextId uint, messageId uint) {
	var _arg0 *C.GtkStatusbar // out
	var _arg1 C.guint         // out
	var _arg2 C.guint         // out

	_arg0 = (*C.GtkStatusbar)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(contextId)
	_arg2 = (C.guint)(messageId)

	C.gtk_statusbar_remove(_arg0, _arg1, _arg2)
}

// RemoveAll forces the removal of all messages from a statusbar's stack with
// the exact @context_id.
func (s statusbar) RemoveAll(contextId uint) {
	var _arg0 *C.GtkStatusbar // out
	var _arg1 C.guint         // out

	_arg0 = (*C.GtkStatusbar)(unsafe.Pointer(s.Native()))
	_arg1 = (C.guint)(contextId)

	C.gtk_statusbar_remove_all(_arg0, _arg1)
}

type StatusbarAccessible interface {
	ContainerAccessible
}

// statusbarAccessible implements the StatusbarAccessible class.
type statusbarAccessible struct {
	ContainerAccessible
}

var _ StatusbarAccessible = (*statusbarAccessible)(nil)

// WrapStatusbarAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapStatusbarAccessible(obj *externglib.Object) StatusbarAccessible {
	return statusbarAccessible{
		ContainerAccessible: WrapContainerAccessible(obj),
	}
}

func marshalStatusbarAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStatusbarAccessible(obj), nil
}

// Style: a Style object encapsulates the information that provides the look and
// feel for a widget.
//
// > In GTK+ 3.0, GtkStyle has been deprecated and replaced by > StyleContext.
//
// Each Widget has an associated Style object that is used when rendering that
// widget. Also, a Style holds information for the five possible widget states
// though not every widget supports all five states; see StateType.
//
// Usually the Style for a widget is the same as the default style that is set
// by GTK+ and modified the theme engine.
//
// Usually applications should not need to use or modify the Style of their
// widgets.
type Style interface {
	gextras.Objector

	ApplyDefaultBackground(cr *cairo.Context, window gdk.Window, stateType StateType, x int, y int, width int, height int)
	// Copy creates a copy of the passed in Style object.
	Copy() Style
	// Detach detaches a style from a window. If the style is not attached to
	// any windows anymore, it is unrealized. See gtk_style_attach().
	Detach()
	// StyleProperty queries the value of a style property corresponding to a
	// widget class is in the given style.
	StyleProperty(widgetType externglib.Type, propertyName string) *externglib.Value
	// HasContext returns whether @style has an associated StyleContext.
	HasContext() bool
	// LookupColor looks up @color_name in the style’s logical color mappings,
	// filling in @color and returning true if found, otherwise returning false.
	// Do not cache the found mapping, because it depends on the Style and might
	// change when a theme switch occurs.
	LookupColor(colorName string) (gdk.Color, bool)
	// LookupIconSet looks up @stock_id in the icon factories associated with
	// @style and the default icon factory, returning an icon set if found,
	// otherwise nil.
	LookupIconSet(stockId string) *IconSet
	// RenderIcon renders the icon specified by @source at the given @size
	// according to the given parameters and returns the result in a pixbuf.
	RenderIcon(source *IconSource, direction TextDirection, state StateType, size int, widget Widget, detail string) gdkpixbuf.Pixbuf
	// SetBackground sets the background of @window to the background color or
	// pixmap specified by @style for the given state.
	SetBackground(window gdk.Window, stateType StateType)
}

// style implements the Style class.
type style struct {
	gextras.Objector
}

var _ Style = (*style)(nil)

// WrapStyle wraps a GObject to the right type. It is
// primarily used internally.
func WrapStyle(obj *externglib.Object) Style {
	return style{
		Objector: obj,
	}
}

func marshalStyle(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStyle(obj), nil
}

// NewStyle creates a new Style.
func NewStyle() Style {
	var _cret *C.GtkStyle // in

	_cret = C.gtk_style_new()

	var _style Style // out

	_style = WrapStyle(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _style
}

func (s style) ApplyDefaultBackground(cr *cairo.Context, window gdk.Window, stateType StateType, x int, y int, width int, height int) {
	var _arg0 *C.GtkStyle    // out
	var _arg1 *C.cairo_t     // out
	var _arg2 *C.GdkWindow   // out
	var _arg3 C.GtkStateType // out
	var _arg4 C.gint         // out
	var _arg5 C.gint         // out
	var _arg6 C.gint         // out
	var _arg7 C.gint         // out

	_arg0 = (*C.GtkStyle)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg2 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))
	_arg3 = (C.GtkStateType)(stateType)
	_arg4 = (C.gint)(x)
	_arg5 = (C.gint)(y)
	_arg6 = (C.gint)(width)
	_arg7 = (C.gint)(height)

	C.gtk_style_apply_default_background(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
}

// Copy creates a copy of the passed in Style object.
func (s style) Copy() Style {
	var _arg0 *C.GtkStyle // out
	var _cret *C.GtkStyle // in

	_arg0 = (*C.GtkStyle)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_style_copy(_arg0)

	var _ret Style // out

	_ret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Style)

	return _ret
}

// Detach detaches a style from a window. If the style is not attached to any
// windows anymore, it is unrealized. See gtk_style_attach().
func (s style) Detach() {
	var _arg0 *C.GtkStyle // out

	_arg0 = (*C.GtkStyle)(unsafe.Pointer(s.Native()))

	C.gtk_style_detach(_arg0)
}

// StyleProperty queries the value of a style property corresponding to a widget
// class is in the given style.
func (s style) StyleProperty(widgetType externglib.Type, propertyName string) *externglib.Value {
	var _arg0 *C.GtkStyle // out
	var _arg1 C.GType     // out
	var _arg2 *C.gchar    // out
	var _arg3 C.GValue    // in

	_arg0 = (*C.GtkStyle)(unsafe.Pointer(s.Native()))
	_arg1 = C.GType(widgetType)
	_arg2 = (*C.gchar)(C.CString(propertyName))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_style_get_style_property(_arg0, _arg1, _arg2, &_arg3)

	var _value *externglib.Value // out

	_value = externglib.ValueFromNative(unsafe.Pointer(_arg3))

	return _value
}

// HasContext returns whether @style has an associated StyleContext.
func (s style) HasContext() bool {
	var _arg0 *C.GtkStyle // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkStyle)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_style_has_context(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LookupColor looks up @color_name in the style’s logical color mappings,
// filling in @color and returning true if found, otherwise returning false. Do
// not cache the found mapping, because it depends on the Style and might change
// when a theme switch occurs.
func (s style) LookupColor(colorName string) (gdk.Color, bool) {
	var _arg0 *C.GtkStyle // out
	var _arg1 *C.gchar    // out
	var _color gdk.Color
	var _cret C.gboolean // in

	_arg0 = (*C.GtkStyle)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(colorName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_style_lookup_color(_arg0, _arg1, (*C.GdkColor)(unsafe.Pointer(&_color)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _color, _ok
}

// LookupIconSet looks up @stock_id in the icon factories associated with @style
// and the default icon factory, returning an icon set if found, otherwise nil.
func (s style) LookupIconSet(stockId string) *IconSet {
	var _arg0 *C.GtkStyle   // out
	var _arg1 *C.gchar      // out
	var _cret *C.GtkIconSet // in

	_arg0 = (*C.GtkStyle)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(stockId))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_style_lookup_icon_set(_arg0, _arg1)

	var _iconSet *IconSet // out

	_iconSet = WrapIconSet(unsafe.Pointer(_cret))

	return _iconSet
}

// RenderIcon renders the icon specified by @source at the given @size according
// to the given parameters and returns the result in a pixbuf.
func (s style) RenderIcon(source *IconSource, direction TextDirection, state StateType, size int, widget Widget, detail string) gdkpixbuf.Pixbuf {
	var _arg0 *C.GtkStyle        // out
	var _arg1 *C.GtkIconSource   // out
	var _arg2 C.GtkTextDirection // out
	var _arg3 C.GtkStateType     // out
	var _arg4 C.GtkIconSize      // out
	var _arg5 *C.GtkWidget       // out
	var _arg6 *C.gchar           // out
	var _cret *C.GdkPixbuf       // in

	_arg0 = (*C.GtkStyle)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkIconSource)(unsafe.Pointer(source.Native()))
	_arg2 = (C.GtkTextDirection)(direction)
	_arg3 = (C.GtkStateType)(state)
	_arg4 = (C.GtkIconSize)(size)
	_arg5 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg6 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(_arg6))

	_cret = C.gtk_style_render_icon(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)

	var _pixbuf gdkpixbuf.Pixbuf // out

	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

	return _pixbuf
}

// SetBackground sets the background of @window to the background color or
// pixmap specified by @style for the given state.
func (s style) SetBackground(window gdk.Window, stateType StateType) {
	var _arg0 *C.GtkStyle    // out
	var _arg1 *C.GdkWindow   // out
	var _arg2 C.GtkStateType // out

	_arg0 = (*C.GtkStyle)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))
	_arg2 = (C.GtkStateType)(stateType)

	C.gtk_style_set_background(_arg0, _arg1, _arg2)
}

// StyleContext is an object that stores styling information affecting a widget
// defined by WidgetPath.
//
// In order to construct the final style information, StyleContext queries
// information from all attached StyleProviders. Style providers can be either
// attached explicitly to the context through gtk_style_context_add_provider(),
// or to the screen through gtk_style_context_add_provider_for_screen(). The
// resulting style is a combination of all providers’ information in priority
// order.
//
// For GTK+ widgets, any StyleContext returned by gtk_widget_get_style_context()
// will already have a WidgetPath, a Screen and RTL/LTR information set. The
// style context will also be updated automatically if any of these settings
// change on the widget.
//
// If you are using the theming layer standalone, you will need to set a widget
// path and a screen yourself to the created style context through
// gtk_style_context_set_path() and possibly gtk_style_context_set_screen(). See
// the “Foreign drawing“ example in gtk3-demo.
//
//
// Style Classes
//
// Widgets can add style classes to their context, which can be used to
// associate different styles by class. The documentation for individual widgets
// lists which style classes it uses itself, and which style classes may be
// added by applications to affect their appearance.
//
// GTK+ defines macros for a number of style classes.
//
//
// Style Regions
//
// Widgets can also add regions with flags to their context. This feature is
// deprecated and will be removed in a future GTK+ update. Please use style
// classes instead.
//
// GTK+ defines macros for a number of style regions.
//
//
// Custom styling in UI libraries and applications
//
// If you are developing a library with custom Widgets that render differently
// than standard components, you may need to add a StyleProvider yourself with
// the GTK_STYLE_PROVIDER_PRIORITY_FALLBACK priority, either a CssProvider or a
// custom object implementing the StyleProvider interface. This way themes may
// still attempt to style your UI elements in a different way if needed so.
//
// If you are using custom styling on an applications, you probably want then to
// make your style information prevail to the theme’s, so you must use a
// StyleProvider with the GTK_STYLE_PROVIDER_PRIORITY_APPLICATION priority, keep
// in mind that the user settings in `XDG_CONFIG_HOME/gtk-3.0/gtk.css` will
// still take precedence over your changes, as it uses the
// GTK_STYLE_PROVIDER_PRIORITY_USER priority.
type StyleContext interface {
	gextras.Objector

	// AddClass adds a style class to @context, so posterior calls to
	// gtk_style_context_get() or any of the gtk_render_*() functions will make
	// use of this new class for styling.
	//
	// In the CSS file format, a Entry defining a “search” class, would be
	// matched by:
	//
	// |[ <!-- language="CSS" --> entry.search { ... } ]|
	//
	// While any widget defining a “search” class would be matched by: |[ <!--
	// language="CSS" --> .search { ... } ]|
	AddClass(className string)
	// AddProvider adds a style provider to @context, to be used in style
	// construction. Note that a style provider added by this function only
	// affects the style of the widget to which @context belongs. If you want to
	// affect the style of all widgets, use
	// gtk_style_context_add_provider_for_screen().
	//
	// Note: If both priorities are the same, a StyleProvider added through this
	// function takes precedence over another added through
	// gtk_style_context_add_provider_for_screen().
	AddProvider(provider StyleProvider, priority uint)
	// AddRegion adds a region to @context, so posterior calls to
	// gtk_style_context_get() or any of the gtk_render_*() functions will make
	// use of this new region for styling.
	//
	// In the CSS file format, a TreeView defining a “row” region, would be
	// matched by:
	//
	// |[ <!-- language="CSS" --> treeview row { ... } ]|
	//
	// Pseudo-classes are used for matching @flags, so the two following rules:
	// |[ <!-- language="CSS" --> treeview row:nth-child(even) { ... } treeview
	// row:nth-child(odd) { ... } ]|
	//
	// would apply to even and odd rows, respectively.
	//
	// Region names must only contain lowercase letters and “-”, starting always
	// with a lowercase letter.
	AddRegion(regionName string, flags RegionFlags)
	// BackgroundColor gets the background color for a given state.
	//
	// This function is far less useful than it seems, and it should not be used
	// in newly written code. CSS has no concept of "background color", as a
	// background can be an image, or a gradient, or any other pattern including
	// solid colors.
	//
	// The only reason why you would call
	// gtk_style_context_get_background_color() is to use the returned value to
	// draw the background with it; the correct way to achieve this result is to
	// use gtk_render_background() instead, along with CSS style classes to
	// modify the color to be rendered.
	BackgroundColor(state StateFlags) gdk.RGBA
	// Border gets the border for a given state as a Border.
	//
	// See gtk_style_context_get_property() and K_STYLE_PROPERTY_BORDER_WIDTH
	// for details.
	Border(state StateFlags) Border
	// BorderColor gets the border color for a given state.
	BorderColor(state StateFlags) gdk.RGBA
	// Color gets the foreground color for a given state.
	//
	// See gtk_style_context_get_property() and K_STYLE_PROPERTY_COLOR for
	// details.
	Color(state StateFlags) gdk.RGBA
	// Direction returns the widget direction used for rendering.
	Direction() TextDirection
	// Font returns the font description for a given state. The returned object
	// is const and will remain valid until the StyleContext::changed signal
	// happens.
	Font(state StateFlags) *pango.FontDescription
	// FrameClock returns the FrameClock to which @context is attached.
	FrameClock() gdk.FrameClock
	// JunctionSides returns the sides where rendered elements connect visually
	// with others.
	JunctionSides() JunctionSides
	// Margin gets the margin for a given state as a Border. See
	// gtk_style_property_get() and K_STYLE_PROPERTY_MARGIN for details.
	Margin(state StateFlags) Border
	// Padding gets the padding for a given state as a Border. See
	// gtk_style_context_get() and K_STYLE_PROPERTY_PADDING for details.
	Padding(state StateFlags) Border
	// Parent gets the parent context set via gtk_style_context_set_parent().
	// See that function for details.
	Parent() StyleContext
	// Path returns the widget path used for style matching.
	Path() *WidgetPath
	// Property gets a style property from @context for the given state.
	//
	// Note that not all CSS properties that are supported by GTK+ can be
	// retrieved in this way, since they may not be representable as #GValue.
	// GTK+ defines macros for a number of properties that can be used with this
	// function.
	//
	// Note that passing a state other than the current state of @context is not
	// recommended unless the style context has been saved with
	// gtk_style_context_save().
	//
	// When @value is no longer needed, g_value_unset() must be called to free
	// any allocated memory.
	Property(property string, state StateFlags) *externglib.Value
	// Scale returns the scale used for assets.
	Scale() int
	// Screen returns the Screen to which @context is attached.
	Screen() gdk.Screen
	// Section queries the location in the CSS where @property was defined for
	// the current @context. Note that the state to be queried is taken from
	// gtk_style_context_get_state().
	//
	// If the location is not available, nil will be returned. The location
	// might not be available for various reasons, such as the property being
	// overridden, @property not naming a supported CSS property or tracking of
	// definitions being disabled for performance reasons.
	//
	// Shorthand CSS properties cannot be queried for a location and will always
	// return nil.
	Section(property string) *CSSSection
	// State returns the state used for style matching.
	//
	// This method should only be used to retrieve the StateFlags to pass to
	// StyleContext methods, like gtk_style_context_get_padding(). If you need
	// to retrieve the current state of a Widget, use
	// gtk_widget_get_state_flags().
	State() StateFlags
	// StyleProperty gets the value for a widget style property.
	//
	// When @value is no longer needed, g_value_unset() must be called to free
	// any allocated memory.
	StyleProperty(propertyName string, value **externglib.Value)
	// HasClass returns true if @context currently has defined the given class
	// name.
	HasClass(className string) bool
	// HasRegion returns true if @context has the region defined. If
	// @flags_return is not nil, it is set to the flags affecting the region.
	HasRegion(regionName string) (RegionFlags, bool)
	// Invalidate invalidates @context style information, so it will be
	// reconstructed again. It is useful if you modify the @context and need the
	// new information immediately.
	Invalidate()
	// LookupColor looks up and resolves a color name in the @context color map.
	LookupColor(colorName string) (gdk.RGBA, bool)
	// LookupIconSet looks up @stock_id in the icon factories associated to
	// @context and the default icon factory, returning an icon set if found,
	// otherwise nil.
	LookupIconSet(stockId string) *IconSet
	// PopAnimatableRegion pops an animatable region from @context. See
	// gtk_style_context_push_animatable_region().
	PopAnimatableRegion()
	// RemoveClass removes @class_name from @context.
	RemoveClass(className string)
	// RemoveProvider removes @provider from the style providers list in
	// @context.
	RemoveProvider(provider StyleProvider)
	// RemoveRegion removes a region from @context.
	RemoveRegion(regionName string)
	// Restore restores @context state to a previous stage. See
	// gtk_style_context_save().
	Restore()
	// Save saves the @context state, so temporary modifications done through
	// gtk_style_context_add_class(), gtk_style_context_remove_class(),
	// gtk_style_context_set_state(), etc. can quickly be reverted in one go
	// through gtk_style_context_restore().
	//
	// The matching call to gtk_style_context_restore() must be done before GTK
	// returns to the main loop.
	Save()
	// ScrollAnimations: this function is analogous to gdk_window_scroll(), and
	// should be called together with it so the invalidation areas for any
	// ongoing animation are scrolled together with it.
	ScrollAnimations(window gdk.Window, dx int, dy int)
	// SetBackground sets the background of @window to the background pattern or
	// color specified in @context for its current state.
	SetBackground(window gdk.Window)
	// SetDirection sets the reading direction for rendering purposes.
	//
	// If you are using a StyleContext returned from
	// gtk_widget_get_style_context(), you do not need to call this yourself.
	SetDirection(direction TextDirection)
	// SetFrameClock attaches @context to the given frame clock.
	//
	// The frame clock is used for the timing of animations.
	//
	// If you are using a StyleContext returned from
	// gtk_widget_get_style_context(), you do not need to call this yourself.
	SetFrameClock(frameClock gdk.FrameClock)
	// SetJunctionSides sets the sides where rendered elements (mostly through
	// gtk_render_frame()) will visually connect with other visual elements.
	//
	// This is merely a hint that may or may not be honored by themes.
	//
	// Container widgets are expected to set junction hints as appropriate for
	// their children, so it should not normally be necessary to call this
	// function manually.
	SetJunctionSides(sides JunctionSides)
	// SetParent sets the parent style context for @context. The parent style
	// context is used to implement inheritance
	// (http://www.w3.org/TR/css3-cascade/#inheritance) of properties.
	//
	// If you are using a StyleContext returned from
	// gtk_widget_get_style_context(), the parent will be set for you.
	SetParent(parent StyleContext)
	// SetPath sets the WidgetPath used for style matching. As a consequence,
	// the style will be regenerated to match the new given path.
	//
	// If you are using a StyleContext returned from
	// gtk_widget_get_style_context(), you do not need to call this yourself.
	SetPath(path *WidgetPath)
	// SetScale sets the scale to use when getting image assets for the style.
	SetScale(scale int)
	// SetScreen attaches @context to the given screen.
	//
	// The screen is used to add style information from “global” style
	// providers, such as the screen’s Settings instance.
	//
	// If you are using a StyleContext returned from
	// gtk_widget_get_style_context(), you do not need to call this yourself.
	SetScreen(screen gdk.Screen)
	// SetState sets the state to be used for style matching.
	SetState(flags StateFlags)
	// StateIsRunning returns true if there is a transition animation running
	// for the current region (see gtk_style_context_push_animatable_region()).
	//
	// If @progress is not nil, the animation progress will be returned there,
	// 0.0 means the state is closest to being unset, while 1.0 means it’s
	// closest to being set. This means transition animation will run from 0 to
	// 1 when @state is being set and from 1 to 0 when it’s being unset.
	StateIsRunning(state StateType) (float64, bool)
	// String converts the style context into a string representation.
	//
	// The string representation always includes information about the name,
	// state, id, visibility and style classes of the CSS node that is backing
	// @context. Depending on the flags, more information may be included.
	//
	// This function is intended for testing and debugging of the CSS
	// implementation in GTK+. There are no guarantees about the format of the
	// returned string, it may change.
	String(flags StyleContextPrintFlags) string
}

// styleContext implements the StyleContext class.
type styleContext struct {
	gextras.Objector
}

var _ StyleContext = (*styleContext)(nil)

// WrapStyleContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapStyleContext(obj *externglib.Object) StyleContext {
	return styleContext{
		Objector: obj,
	}
}

func marshalStyleContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStyleContext(obj), nil
}

// NewStyleContext creates a standalone StyleContext, this style context won’t
// be attached to any widget, so you may want to call
// gtk_style_context_set_path() yourself.
//
// This function is only useful when using the theming layer separated from
// GTK+, if you are using StyleContext to theme Widgets, use
// gtk_widget_get_style_context() in order to get a style context ready to theme
// the widget.
func NewStyleContext() StyleContext {
	var _cret *C.GtkStyleContext // in

	_cret = C.gtk_style_context_new()

	var _styleContext StyleContext // out

	_styleContext = WrapStyleContext(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _styleContext
}

// AddClass adds a style class to @context, so posterior calls to
// gtk_style_context_get() or any of the gtk_render_*() functions will make use
// of this new class for styling.
//
// In the CSS file format, a Entry defining a “search” class, would be matched
// by:
//
// |[ <!-- language="CSS" --> entry.search { ... } ]|
//
// While any widget defining a “search” class would be matched by: |[ <!--
// language="CSS" --> .search { ... } ]|
func (c styleContext) AddClass(className string) {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 *C.gchar           // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(className))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_style_context_add_class(_arg0, _arg1)
}

// AddProvider adds a style provider to @context, to be used in style
// construction. Note that a style provider added by this function only affects
// the style of the widget to which @context belongs. If you want to affect the
// style of all widgets, use gtk_style_context_add_provider_for_screen().
//
// Note: If both priorities are the same, a StyleProvider added through this
// function takes precedence over another added through
// gtk_style_context_add_provider_for_screen().
func (c styleContext) AddProvider(provider StyleProvider, priority uint) {
	var _arg0 *C.GtkStyleContext  // out
	var _arg1 *C.GtkStyleProvider // out
	var _arg2 C.guint             // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkStyleProvider)(unsafe.Pointer(provider.Native()))
	_arg2 = (C.guint)(priority)

	C.gtk_style_context_add_provider(_arg0, _arg1, _arg2)
}

// AddRegion adds a region to @context, so posterior calls to
// gtk_style_context_get() or any of the gtk_render_*() functions will make use
// of this new region for styling.
//
// In the CSS file format, a TreeView defining a “row” region, would be matched
// by:
//
// |[ <!-- language="CSS" --> treeview row { ... } ]|
//
// Pseudo-classes are used for matching @flags, so the two following rules: |[
// <!-- language="CSS" --> treeview row:nth-child(even) { ... } treeview
// row:nth-child(odd) { ... } ]|
//
// would apply to even and odd rows, respectively.
//
// Region names must only contain lowercase letters and “-”, starting always
// with a lowercase letter.
func (c styleContext) AddRegion(regionName string, flags RegionFlags) {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 *C.gchar           // out
	var _arg2 C.GtkRegionFlags   // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(regionName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GtkRegionFlags)(flags)

	C.gtk_style_context_add_region(_arg0, _arg1, _arg2)
}

// BackgroundColor gets the background color for a given state.
//
// This function is far less useful than it seems, and it should not be used in
// newly written code. CSS has no concept of "background color", as a background
// can be an image, or a gradient, or any other pattern including solid colors.
//
// The only reason why you would call gtk_style_context_get_background_color()
// is to use the returned value to draw the background with it; the correct way
// to achieve this result is to use gtk_render_background() instead, along with
// CSS style classes to modify the color to be rendered.
func (c styleContext) BackgroundColor(state StateFlags) gdk.RGBA {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 C.GtkStateFlags    // out
	var _color gdk.RGBA

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GtkStateFlags)(state)

	C.gtk_style_context_get_background_color(_arg0, _arg1, (*C.GdkRGBA)(unsafe.Pointer(&_color)))

	return _color
}

// Border gets the border for a given state as a Border.
//
// See gtk_style_context_get_property() and K_STYLE_PROPERTY_BORDER_WIDTH for
// details.
func (c styleContext) Border(state StateFlags) Border {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 C.GtkStateFlags    // out
	var _border Border

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GtkStateFlags)(state)

	C.gtk_style_context_get_border(_arg0, _arg1, (*C.GtkBorder)(unsafe.Pointer(&_border)))

	return _border
}

// BorderColor gets the border color for a given state.
func (c styleContext) BorderColor(state StateFlags) gdk.RGBA {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 C.GtkStateFlags    // out
	var _color gdk.RGBA

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GtkStateFlags)(state)

	C.gtk_style_context_get_border_color(_arg0, _arg1, (*C.GdkRGBA)(unsafe.Pointer(&_color)))

	return _color
}

// Color gets the foreground color for a given state.
//
// See gtk_style_context_get_property() and K_STYLE_PROPERTY_COLOR for details.
func (c styleContext) Color(state StateFlags) gdk.RGBA {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 C.GtkStateFlags    // out
	var _color gdk.RGBA

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GtkStateFlags)(state)

	C.gtk_style_context_get_color(_arg0, _arg1, (*C.GdkRGBA)(unsafe.Pointer(&_color)))

	return _color
}

// Direction returns the widget direction used for rendering.
func (c styleContext) Direction() TextDirection {
	var _arg0 *C.GtkStyleContext // out
	var _cret C.GtkTextDirection // in

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_style_context_get_direction(_arg0)

	var _textDirection TextDirection // out

	_textDirection = TextDirection(_cret)

	return _textDirection
}

// Font returns the font description for a given state. The returned object is
// const and will remain valid until the StyleContext::changed signal happens.
func (c styleContext) Font(state StateFlags) *pango.FontDescription {
	var _arg0 *C.GtkStyleContext      // out
	var _arg1 C.GtkStateFlags         // out
	var _cret *C.PangoFontDescription // in

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GtkStateFlags)(state)

	_cret = C.gtk_style_context_get_font(_arg0, _arg1)

	var _fontDescription *pango.FontDescription // out

	_fontDescription = pango.WrapFontDescription(unsafe.Pointer(_cret))

	return _fontDescription
}

// FrameClock returns the FrameClock to which @context is attached.
func (c styleContext) FrameClock() gdk.FrameClock {
	var _arg0 *C.GtkStyleContext // out
	var _cret *C.GdkFrameClock   // in

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_style_context_get_frame_clock(_arg0)

	var _frameClock gdk.FrameClock // out

	_frameClock = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.FrameClock)

	return _frameClock
}

// JunctionSides returns the sides where rendered elements connect visually with
// others.
func (c styleContext) JunctionSides() JunctionSides {
	var _arg0 *C.GtkStyleContext // out
	var _cret C.GtkJunctionSides // in

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_style_context_get_junction_sides(_arg0)

	var _junctionSides JunctionSides // out

	_junctionSides = JunctionSides(_cret)

	return _junctionSides
}

// Margin gets the margin for a given state as a Border. See
// gtk_style_property_get() and K_STYLE_PROPERTY_MARGIN for details.
func (c styleContext) Margin(state StateFlags) Border {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 C.GtkStateFlags    // out
	var _margin Border

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GtkStateFlags)(state)

	C.gtk_style_context_get_margin(_arg0, _arg1, (*C.GtkBorder)(unsafe.Pointer(&_margin)))

	return _margin
}

// Padding gets the padding for a given state as a Border. See
// gtk_style_context_get() and K_STYLE_PROPERTY_PADDING for details.
func (c styleContext) Padding(state StateFlags) Border {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 C.GtkStateFlags    // out
	var _padding Border

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GtkStateFlags)(state)

	C.gtk_style_context_get_padding(_arg0, _arg1, (*C.GtkBorder)(unsafe.Pointer(&_padding)))

	return _padding
}

// Parent gets the parent context set via gtk_style_context_set_parent(). See
// that function for details.
func (c styleContext) Parent() StyleContext {
	var _arg0 *C.GtkStyleContext // out
	var _cret *C.GtkStyleContext // in

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_style_context_get_parent(_arg0)

	var _styleContext StyleContext // out

	_styleContext = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(StyleContext)

	return _styleContext
}

// Path returns the widget path used for style matching.
func (c styleContext) Path() *WidgetPath {
	var _arg0 *C.GtkStyleContext // out
	var _cret *C.GtkWidgetPath   // in

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_style_context_get_path(_arg0)

	var _widgetPath *WidgetPath // out

	_widgetPath = WrapWidgetPath(unsafe.Pointer(_cret))

	return _widgetPath
}

// Property gets a style property from @context for the given state.
//
// Note that not all CSS properties that are supported by GTK+ can be retrieved
// in this way, since they may not be representable as #GValue. GTK+ defines
// macros for a number of properties that can be used with this function.
//
// Note that passing a state other than the current state of @context is not
// recommended unless the style context has been saved with
// gtk_style_context_save().
//
// When @value is no longer needed, g_value_unset() must be called to free any
// allocated memory.
func (c styleContext) Property(property string, state StateFlags) *externglib.Value {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 *C.gchar           // out
	var _arg2 C.GtkStateFlags    // out
	var _arg3 C.GValue           // in

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(property))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GtkStateFlags)(state)

	C.gtk_style_context_get_property(_arg0, _arg1, _arg2, &_arg3)

	var _value *externglib.Value // out

	_value = externglib.ValueFromNative(unsafe.Pointer(_arg3))
	runtime.SetFinalizer(_value, func(v *externglib.Value) {
		C.g_value_unset((*C.GValue)(v.GValue))
	})

	return _value
}

// Scale returns the scale used for assets.
func (c styleContext) Scale() int {
	var _arg0 *C.GtkStyleContext // out
	var _cret C.gint             // in

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_style_context_get_scale(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Screen returns the Screen to which @context is attached.
func (c styleContext) Screen() gdk.Screen {
	var _arg0 *C.GtkStyleContext // out
	var _cret *C.GdkScreen       // in

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_style_context_get_screen(_arg0)

	var _screen gdk.Screen // out

	_screen = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Screen)

	return _screen
}

// Section queries the location in the CSS where @property was defined for the
// current @context. Note that the state to be queried is taken from
// gtk_style_context_get_state().
//
// If the location is not available, nil will be returned. The location might
// not be available for various reasons, such as the property being overridden,
// @property not naming a supported CSS property or tracking of definitions
// being disabled for performance reasons.
//
// Shorthand CSS properties cannot be queried for a location and will always
// return nil.
func (c styleContext) Section(property string) *CSSSection {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 *C.gchar           // out
	var _cret *C.GtkCssSection   // in

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(property))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_style_context_get_section(_arg0, _arg1)

	var _cssSection *CSSSection // out

	_cssSection = WrapCSSSection(unsafe.Pointer(_cret))

	return _cssSection
}

// State returns the state used for style matching.
//
// This method should only be used to retrieve the StateFlags to pass to
// StyleContext methods, like gtk_style_context_get_padding(). If you need to
// retrieve the current state of a Widget, use gtk_widget_get_state_flags().
func (c styleContext) State() StateFlags {
	var _arg0 *C.GtkStyleContext // out
	var _cret C.GtkStateFlags    // in

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_style_context_get_state(_arg0)

	var _stateFlags StateFlags // out

	_stateFlags = StateFlags(_cret)

	return _stateFlags
}

// StyleProperty gets the value for a widget style property.
//
// When @value is no longer needed, g_value_unset() must be called to free any
// allocated memory.
func (c styleContext) StyleProperty(propertyName string, value **externglib.Value) {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.GValue          // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(propertyName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GValue)(value.GValue)

	C.gtk_style_context_get_style_property(_arg0, _arg1, _arg2)
}

// HasClass returns true if @context currently has defined the given class name.
func (c styleContext) HasClass(className string) bool {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 *C.gchar           // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(className))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_style_context_has_class(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasRegion returns true if @context has the region defined. If @flags_return
// is not nil, it is set to the flags affecting the region.
func (c styleContext) HasRegion(regionName string) (RegionFlags, bool) {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 *C.gchar           // out
	var _arg2 C.GtkRegionFlags   // in
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(regionName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_style_context_has_region(_arg0, _arg1, &_arg2)

	var _flagsReturn RegionFlags // out
	var _ok bool                 // out

	_flagsReturn = RegionFlags(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _flagsReturn, _ok
}

// Invalidate invalidates @context style information, so it will be
// reconstructed again. It is useful if you modify the @context and need the new
// information immediately.
func (c styleContext) Invalidate() {
	var _arg0 *C.GtkStyleContext // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

	C.gtk_style_context_invalidate(_arg0)
}

// LookupColor looks up and resolves a color name in the @context color map.
func (c styleContext) LookupColor(colorName string) (gdk.RGBA, bool) {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 *C.gchar           // out
	var _color gdk.RGBA
	var _cret C.gboolean // in

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(colorName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_style_context_lookup_color(_arg0, _arg1, (*C.GdkRGBA)(unsafe.Pointer(&_color)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _color, _ok
}

// LookupIconSet looks up @stock_id in the icon factories associated to @context
// and the default icon factory, returning an icon set if found, otherwise nil.
func (c styleContext) LookupIconSet(stockId string) *IconSet {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 *C.gchar           // out
	var _cret *C.GtkIconSet      // in

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(stockId))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_style_context_lookup_icon_set(_arg0, _arg1)

	var _iconSet *IconSet // out

	_iconSet = WrapIconSet(unsafe.Pointer(_cret))

	return _iconSet
}

// PopAnimatableRegion pops an animatable region from @context. See
// gtk_style_context_push_animatable_region().
func (c styleContext) PopAnimatableRegion() {
	var _arg0 *C.GtkStyleContext // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

	C.gtk_style_context_pop_animatable_region(_arg0)
}

// RemoveClass removes @class_name from @context.
func (c styleContext) RemoveClass(className string) {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 *C.gchar           // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(className))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_style_context_remove_class(_arg0, _arg1)
}

// RemoveProvider removes @provider from the style providers list in @context.
func (c styleContext) RemoveProvider(provider StyleProvider) {
	var _arg0 *C.GtkStyleContext  // out
	var _arg1 *C.GtkStyleProvider // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkStyleProvider)(unsafe.Pointer(provider.Native()))

	C.gtk_style_context_remove_provider(_arg0, _arg1)
}

// RemoveRegion removes a region from @context.
func (c styleContext) RemoveRegion(regionName string) {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 *C.gchar           // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(regionName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_style_context_remove_region(_arg0, _arg1)
}

// Restore restores @context state to a previous stage. See
// gtk_style_context_save().
func (c styleContext) Restore() {
	var _arg0 *C.GtkStyleContext // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

	C.gtk_style_context_restore(_arg0)
}

// Save saves the @context state, so temporary modifications done through
// gtk_style_context_add_class(), gtk_style_context_remove_class(),
// gtk_style_context_set_state(), etc. can quickly be reverted in one go through
// gtk_style_context_restore().
//
// The matching call to gtk_style_context_restore() must be done before GTK
// returns to the main loop.
func (c styleContext) Save() {
	var _arg0 *C.GtkStyleContext // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

	C.gtk_style_context_save(_arg0)
}

// ScrollAnimations: this function is analogous to gdk_window_scroll(), and
// should be called together with it so the invalidation areas for any ongoing
// animation are scrolled together with it.
func (c styleContext) ScrollAnimations(window gdk.Window, dx int, dy int) {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 *C.GdkWindow       // out
	var _arg2 C.gint             // out
	var _arg3 C.gint             // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))
	_arg2 = (C.gint)(dx)
	_arg3 = (C.gint)(dy)

	C.gtk_style_context_scroll_animations(_arg0, _arg1, _arg2, _arg3)
}

// SetBackground sets the background of @window to the background pattern or
// color specified in @context for its current state.
func (c styleContext) SetBackground(window gdk.Window) {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 *C.GdkWindow       // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_style_context_set_background(_arg0, _arg1)
}

// SetDirection sets the reading direction for rendering purposes.
//
// If you are using a StyleContext returned from gtk_widget_get_style_context(),
// you do not need to call this yourself.
func (c styleContext) SetDirection(direction TextDirection) {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 C.GtkTextDirection // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GtkTextDirection)(direction)

	C.gtk_style_context_set_direction(_arg0, _arg1)
}

// SetFrameClock attaches @context to the given frame clock.
//
// The frame clock is used for the timing of animations.
//
// If you are using a StyleContext returned from gtk_widget_get_style_context(),
// you do not need to call this yourself.
func (c styleContext) SetFrameClock(frameClock gdk.FrameClock) {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 *C.GdkFrameClock   // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GdkFrameClock)(unsafe.Pointer(frameClock.Native()))

	C.gtk_style_context_set_frame_clock(_arg0, _arg1)
}

// SetJunctionSides sets the sides where rendered elements (mostly through
// gtk_render_frame()) will visually connect with other visual elements.
//
// This is merely a hint that may or may not be honored by themes.
//
// Container widgets are expected to set junction hints as appropriate for their
// children, so it should not normally be necessary to call this function
// manually.
func (c styleContext) SetJunctionSides(sides JunctionSides) {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 C.GtkJunctionSides // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GtkJunctionSides)(sides)

	C.gtk_style_context_set_junction_sides(_arg0, _arg1)
}

// SetParent sets the parent style context for @context. The parent style
// context is used to implement inheritance
// (http://www.w3.org/TR/css3-cascade/#inheritance) of properties.
//
// If you are using a StyleContext returned from gtk_widget_get_style_context(),
// the parent will be set for you.
func (c styleContext) SetParent(parent StyleContext) {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 *C.GtkStyleContext // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(parent.Native()))

	C.gtk_style_context_set_parent(_arg0, _arg1)
}

// SetPath sets the WidgetPath used for style matching. As a consequence, the
// style will be regenerated to match the new given path.
//
// If you are using a StyleContext returned from gtk_widget_get_style_context(),
// you do not need to call this yourself.
func (c styleContext) SetPath(path *WidgetPath) {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 *C.GtkWidgetPath   // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkWidgetPath)(unsafe.Pointer(path.Native()))

	C.gtk_style_context_set_path(_arg0, _arg1)
}

// SetScale sets the scale to use when getting image assets for the style.
func (c styleContext) SetScale(scale int) {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 C.gint             // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (C.gint)(scale)

	C.gtk_style_context_set_scale(_arg0, _arg1)
}

// SetScreen attaches @context to the given screen.
//
// The screen is used to add style information from “global” style providers,
// such as the screen’s Settings instance.
//
// If you are using a StyleContext returned from gtk_widget_get_style_context(),
// you do not need to call this yourself.
func (c styleContext) SetScreen(screen gdk.Screen) {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 *C.GdkScreen       // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GdkScreen)(unsafe.Pointer(screen.Native()))

	C.gtk_style_context_set_screen(_arg0, _arg1)
}

// SetState sets the state to be used for style matching.
func (c styleContext) SetState(flags StateFlags) {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 C.GtkStateFlags    // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GtkStateFlags)(flags)

	C.gtk_style_context_set_state(_arg0, _arg1)
}

// StateIsRunning returns true if there is a transition animation running for
// the current region (see gtk_style_context_push_animatable_region()).
//
// If @progress is not nil, the animation progress will be returned there, 0.0
// means the state is closest to being unset, while 1.0 means it’s closest to
// being set. This means transition animation will run from 0 to 1 when @state
// is being set and from 1 to 0 when it’s being unset.
func (c styleContext) StateIsRunning(state StateType) (float64, bool) {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 C.GtkStateType     // out
	var _arg2 C.gdouble          // in
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GtkStateType)(state)

	_cret = C.gtk_style_context_state_is_running(_arg0, _arg1, &_arg2)

	var _progress float64 // out
	var _ok bool          // out

	_progress = (float64)(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _progress, _ok
}

// String converts the style context into a string representation.
//
// The string representation always includes information about the name, state,
// id, visibility and style classes of the CSS node that is backing @context.
// Depending on the flags, more information may be included.
//
// This function is intended for testing and debugging of the CSS implementation
// in GTK+. There are no guarantees about the format of the returned string, it
// may change.
func (c styleContext) String(flags StyleContextPrintFlags) string {
	var _arg0 *C.GtkStyleContext          // out
	var _arg1 C.GtkStyleContextPrintFlags // out
	var _cret *C.char                     // in

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GtkStyleContextPrintFlags)(flags)

	_cret = C.gtk_style_context_to_string(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// StyleProperties gtkStyleProperties provides the storage for style information
// that is used by StyleContext and other StyleProvider implementations.
//
// Before style properties can be stored in GtkStyleProperties, they must be
// registered with gtk_style_properties_register_property().
//
// Unless you are writing a StyleProvider implementation, you are unlikely to
// use this API directly, as gtk_style_context_get() and its variants are the
// preferred way to access styling information from widget implementations and
// theming engine implementations should use the APIs provided by ThemingEngine
// instead.
//
// StyleProperties has been deprecated in GTK 3.16. The CSS machinery does not
// use it anymore and all users of this object have been deprecated.
type StyleProperties interface {
	gextras.Objector
	StyleProvider

	// Clear clears all style information from @props.
	Clear()
	// Property gets a style property from @props for the given state. When done
	// with @value, g_value_unset() needs to be called to free any allocated
	// memory.
	Property(property string, state StateFlags) (*externglib.Value, bool)
	// LookupColor returns the symbolic color that is mapped to @name.
	LookupColor(name string) *SymbolicColor
	// MapColor maps @color so it can be referenced by @name. See
	// gtk_style_properties_lookup_color()
	MapColor(name string, color *SymbolicColor)
	// Merge merges into @props all the style information contained in
	// @props_to_merge. If @replace is true, the values will be overwritten, if
	// it is false, the older values will prevail.
	Merge(propsToMerge StyleProperties, replace bool)
	// SetProperty sets a styling property in @props.
	SetProperty(property string, state StateFlags, value **externglib.Value)
	// UnsetProperty unsets a style property in @props.
	UnsetProperty(property string, state StateFlags)
}

// styleProperties implements the StyleProperties class.
type styleProperties struct {
	gextras.Objector
	StyleProvider
}

var _ StyleProperties = (*styleProperties)(nil)

// WrapStyleProperties wraps a GObject to the right type. It is
// primarily used internally.
func WrapStyleProperties(obj *externglib.Object) StyleProperties {
	return styleProperties{
		Objector:      obj,
		StyleProvider: WrapStyleProvider(obj),
	}
}

func marshalStyleProperties(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStyleProperties(obj), nil
}

// NewStyleProperties returns a newly created StyleProperties
func NewStyleProperties() StyleProperties {
	var _cret *C.GtkStyleProperties // in

	_cret = C.gtk_style_properties_new()

	var _styleProperties StyleProperties // out

	_styleProperties = WrapStyleProperties(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _styleProperties
}

// Clear clears all style information from @props.
func (p styleProperties) Clear() {
	var _arg0 *C.GtkStyleProperties // out

	_arg0 = (*C.GtkStyleProperties)(unsafe.Pointer(p.Native()))

	C.gtk_style_properties_clear(_arg0)
}

// Property gets a style property from @props for the given state. When done
// with @value, g_value_unset() needs to be called to free any allocated memory.
func (p styleProperties) Property(property string, state StateFlags) (*externglib.Value, bool) {
	var _arg0 *C.GtkStyleProperties // out
	var _arg1 *C.gchar              // out
	var _arg2 C.GtkStateFlags       // out
	var _arg3 C.GValue              // in
	var _cret C.gboolean            // in

	_arg0 = (*C.GtkStyleProperties)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.gchar)(C.CString(property))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GtkStateFlags)(state)

	_cret = C.gtk_style_properties_get_property(_arg0, _arg1, _arg2, &_arg3)

	var _value *externglib.Value // out
	var _ok bool                 // out

	_value = externglib.ValueFromNative(unsafe.Pointer(_arg3))
	runtime.SetFinalizer(_value, func(v *externglib.Value) {
		C.g_value_unset((*C.GValue)(v.GValue))
	})
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// LookupColor returns the symbolic color that is mapped to @name.
func (p styleProperties) LookupColor(name string) *SymbolicColor {
	var _arg0 *C.GtkStyleProperties // out
	var _arg1 *C.gchar              // out
	var _cret *C.GtkSymbolicColor   // in

	_arg0 = (*C.GtkStyleProperties)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_style_properties_lookup_color(_arg0, _arg1)

	var _symbolicColor *SymbolicColor // out

	_symbolicColor = WrapSymbolicColor(unsafe.Pointer(_cret))

	return _symbolicColor
}

// MapColor maps @color so it can be referenced by @name. See
// gtk_style_properties_lookup_color()
func (p styleProperties) MapColor(name string, color *SymbolicColor) {
	var _arg0 *C.GtkStyleProperties // out
	var _arg1 *C.gchar              // out
	var _arg2 *C.GtkSymbolicColor   // out

	_arg0 = (*C.GtkStyleProperties)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkSymbolicColor)(unsafe.Pointer(color.Native()))

	C.gtk_style_properties_map_color(_arg0, _arg1, _arg2)
}

// Merge merges into @props all the style information contained in
// @props_to_merge. If @replace is true, the values will be overwritten, if it
// is false, the older values will prevail.
func (p styleProperties) Merge(propsToMerge StyleProperties, replace bool) {
	var _arg0 *C.GtkStyleProperties // out
	var _arg1 *C.GtkStyleProperties // out
	var _arg2 C.gboolean            // out

	_arg0 = (*C.GtkStyleProperties)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkStyleProperties)(unsafe.Pointer(propsToMerge.Native()))
	if replace {
		_arg2 = C.TRUE
	}

	C.gtk_style_properties_merge(_arg0, _arg1, _arg2)
}

// SetProperty sets a styling property in @props.
func (p styleProperties) SetProperty(property string, state StateFlags, value **externglib.Value) {
	var _arg0 *C.GtkStyleProperties // out
	var _arg1 *C.gchar              // out
	var _arg2 C.GtkStateFlags       // out
	var _arg3 *C.GValue             // out

	_arg0 = (*C.GtkStyleProperties)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.gchar)(C.CString(property))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GtkStateFlags)(state)
	_arg3 = (*C.GValue)(value.GValue)

	C.gtk_style_properties_set_property(_arg0, _arg1, _arg2, _arg3)
}

// UnsetProperty unsets a style property in @props.
func (p styleProperties) UnsetProperty(property string, state StateFlags) {
	var _arg0 *C.GtkStyleProperties // out
	var _arg1 *C.gchar              // out
	var _arg2 C.GtkStateFlags       // out

	_arg0 = (*C.GtkStyleProperties)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.gchar)(C.CString(property))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GtkStateFlags)(state)

	C.gtk_style_properties_unset_property(_arg0, _arg1, _arg2)
}

// Switch is a widget that has two states: on or off. The user can control which
// state should be active by clicking the empty area, or by dragging the handle.
//
// GtkSwitch can also handle situations where the underlying state changes with
// a delay. See Switch::state-set for details.
//
// CSS nodes
//
//    switch
//    ╰── slider
//
// GtkSwitch has two css nodes, the main node with the name switch and a subnode
// named slider. Neither of them is using any style classes.
type Switch interface {
	Widget
	Actionable
	Activatable
	Buildable

	// Active gets whether the Switch is in its “on” or “off” state.
	Active() bool
	// State gets the underlying state of the Switch.
	State() bool
	// SetActive changes the state of @sw to the desired one.
	SetActive(isActive bool)
	// SetState sets the underlying state of the Switch.
	//
	// Normally, this is the same as Switch:active, unless the switch is set up
	// for delayed state changes. This function is typically called from a
	// Switch::state-set signal handler.
	//
	// See Switch::state-set for details.
	SetState(state bool)
}

// _switch implements the Switch class.
type _switch struct {
	Widget
	Actionable
	Activatable
	Buildable
}

var _ Switch = (*_switch)(nil)

// WrapSwitch wraps a GObject to the right type. It is
// primarily used internally.
func WrapSwitch(obj *externglib.Object) Switch {
	return _switch{
		Widget:      WrapWidget(obj),
		Actionable:  WrapActionable(obj),
		Activatable: WrapActivatable(obj),
		Buildable:   WrapBuildable(obj),
	}
}

func marshalSwitch(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSwitch(obj), nil
}

// NewSwitch creates a new Switch widget.
func NewSwitch() Switch {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_switch_new()

	var __switch Switch // out

	__switch = WrapSwitch(externglib.Take(unsafe.Pointer(_cret)))

	return __switch
}

// Active gets whether the Switch is in its “on” or “off” state.
func (s _switch) Active() bool {
	var _arg0 *C.GtkSwitch // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkSwitch)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_switch_get_active(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// State gets the underlying state of the Switch.
func (s _switch) State() bool {
	var _arg0 *C.GtkSwitch // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkSwitch)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_switch_get_state(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetActive changes the state of @sw to the desired one.
func (s _switch) SetActive(isActive bool) {
	var _arg0 *C.GtkSwitch // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkSwitch)(unsafe.Pointer(s.Native()))
	if isActive {
		_arg1 = C.TRUE
	}

	C.gtk_switch_set_active(_arg0, _arg1)
}

// SetState sets the underlying state of the Switch.
//
// Normally, this is the same as Switch:active, unless the switch is set up for
// delayed state changes. This function is typically called from a
// Switch::state-set signal handler.
//
// See Switch::state-set for details.
func (s _switch) SetState(state bool) {
	var _arg0 *C.GtkSwitch // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkSwitch)(unsafe.Pointer(s.Native()))
	if state {
		_arg1 = C.TRUE
	}

	C.gtk_switch_set_state(_arg0, _arg1)
}

type SwitchAccessible interface {
	WidgetAccessible
}

// switchAccessible implements the SwitchAccessible class.
type switchAccessible struct {
	WidgetAccessible
}

var _ SwitchAccessible = (*switchAccessible)(nil)

// WrapSwitchAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapSwitchAccessible(obj *externglib.Object) SwitchAccessible {
	return switchAccessible{
		WidgetAccessible: WrapWidgetAccessible(obj),
	}
}

func marshalSwitchAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSwitchAccessible(obj), nil
}

// Table: the Table functions allow the programmer to arrange widgets in rows
// and columns, making it easy to align many widgets next to each other,
// horizontally and vertically.
//
// Tables are created with a call to gtk_table_new(), the size of which can
// later be changed with gtk_table_resize().
//
// Widgets can be added to a table using gtk_table_attach() or the more
// convenient (but slightly less flexible) gtk_table_attach_defaults().
//
// To alter the space next to a specific row, use gtk_table_set_row_spacing(),
// and for a column, gtk_table_set_col_spacing(). The gaps between all rows or
// columns can be changed by calling gtk_table_set_row_spacings() or
// gtk_table_set_col_spacings() respectively. Note that spacing is added between
// the children, while padding added by gtk_table_attach() is added on either
// side of the widget it belongs to.
//
// gtk_table_set_homogeneous(), can be used to set whether all cells in the
// table will resize themselves to the size of the largest widget in the table.
//
// > Table has been deprecated. Use Grid instead. It provides the same >
// capabilities as GtkTable for arranging widgets in a rectangular grid, but >
// does support height-for-width geometry management.
type Table interface {
	Container
	Buildable

	// Attach adds a widget to a table. The number of “cells” that a widget will
	// occupy is specified by @left_attach, @right_attach, @top_attach and
	// @bottom_attach. These each represent the leftmost, rightmost, uppermost
	// and lowest column and row numbers of the table. (Columns and rows are
	// indexed from zero).
	//
	// To make a button occupy the lower right cell of a 2x2 table, use
	//
	//    gtk_table_attach (table, button,
	//                      1, 2, // left, right attach
	//                      1, 2, // top, bottom attach
	//                      xoptions, yoptions,
	//                      xpadding, ypadding);
	//
	// If you want to make the button span the entire bottom row, use
	// @left_attach == 0 and @right_attach = 2 instead.
	Attach(child Widget, leftAttach uint, rightAttach uint, topAttach uint, bottomAttach uint, xoptions AttachOptions, yoptions AttachOptions, xpadding uint, ypadding uint)
	// AttachDefaults as there are many options associated with
	// gtk_table_attach(), this convenience function provides the programmer
	// with a means to add children to a table with identical padding and
	// expansion options. The values used for the AttachOptions are `GTK_EXPAND
	// | GTK_FILL`, and the padding is set to 0.
	AttachDefaults(widget Widget, leftAttach uint, rightAttach uint, topAttach uint, bottomAttach uint)
	// ColSpacing gets the amount of space between column @col, and column @col
	// + 1. See gtk_table_set_col_spacing().
	ColSpacing(column uint) uint
	// DefaultColSpacing gets the default column spacing for the table. This is
	// the spacing that will be used for newly added columns. (See
	// gtk_table_set_col_spacings())
	DefaultColSpacing() uint
	// DefaultRowSpacing gets the default row spacing for the table. This is the
	// spacing that will be used for newly added rows. (See
	// gtk_table_set_row_spacings())
	DefaultRowSpacing() uint
	// Homogeneous returns whether the table cells are all constrained to the
	// same width and height. (See gtk_table_set_homogeneous ())
	Homogeneous() bool
	// RowSpacing gets the amount of space between row @row, and row @row + 1.
	// See gtk_table_set_row_spacing().
	RowSpacing(row uint) uint
	// Size gets the number of rows and columns in the table.
	Size() (rows uint, columns uint)
	// Resize: if you need to change a table’s size after it has been created,
	// this function allows you to do so.
	Resize(rows uint, columns uint)
	// SetColSpacing alters the amount of space between a given table column and
	// the following column.
	SetColSpacing(column uint, spacing uint)
	// SetColSpacings sets the space between every column in @table equal to
	// @spacing.
	SetColSpacings(spacing uint)
	// SetHomogeneous changes the homogenous property of table cells, ie.
	// whether all cells are an equal size or not.
	SetHomogeneous(homogeneous bool)
	// SetRowSpacing changes the space between a given table row and the
	// subsequent row.
	SetRowSpacing(row uint, spacing uint)
	// SetRowSpacings sets the space between every row in @table equal to
	// @spacing.
	SetRowSpacings(spacing uint)
}

// table implements the Table class.
type table struct {
	Container
	Buildable
}

var _ Table = (*table)(nil)

// WrapTable wraps a GObject to the right type. It is
// primarily used internally.
func WrapTable(obj *externglib.Object) Table {
	return table{
		Container: WrapContainer(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalTable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTable(obj), nil
}

// NewTable: used to create a new table widget. An initial size must be given by
// specifying how many rows and columns the table should have, although this can
// be changed later with gtk_table_resize(). @rows and @columns must both be in
// the range 1 .. 65535. For historical reasons, 0 is accepted as well and is
// silently interpreted as 1.
func NewTable(rows uint, columns uint, homogeneous bool) Table {
	var _arg1 C.guint      // out
	var _arg2 C.guint      // out
	var _arg3 C.gboolean   // out
	var _cret *C.GtkWidget // in

	_arg1 = (C.guint)(rows)
	_arg2 = (C.guint)(columns)
	if homogeneous {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_table_new(_arg1, _arg2, _arg3)

	var _table Table // out

	_table = WrapTable(externglib.Take(unsafe.Pointer(_cret)))

	return _table
}

// Attach adds a widget to a table. The number of “cells” that a widget will
// occupy is specified by @left_attach, @right_attach, @top_attach and
// @bottom_attach. These each represent the leftmost, rightmost, uppermost and
// lowest column and row numbers of the table. (Columns and rows are indexed
// from zero).
//
// To make a button occupy the lower right cell of a 2x2 table, use
//
//    gtk_table_attach (table, button,
//                      1, 2, // left, right attach
//                      1, 2, // top, bottom attach
//                      xoptions, yoptions,
//                      xpadding, ypadding);
//
// If you want to make the button span the entire bottom row, use @left_attach
// == 0 and @right_attach = 2 instead.
func (t table) Attach(child Widget, leftAttach uint, rightAttach uint, topAttach uint, bottomAttach uint, xoptions AttachOptions, yoptions AttachOptions, xpadding uint, ypadding uint) {
	var _arg0 *C.GtkTable        // out
	var _arg1 *C.GtkWidget       // out
	var _arg2 C.guint            // out
	var _arg3 C.guint            // out
	var _arg4 C.guint            // out
	var _arg5 C.guint            // out
	var _arg6 C.GtkAttachOptions // out
	var _arg7 C.GtkAttachOptions // out
	var _arg8 C.guint            // out
	var _arg9 C.guint            // out

	_arg0 = (*C.GtkTable)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (C.guint)(leftAttach)
	_arg3 = (C.guint)(rightAttach)
	_arg4 = (C.guint)(topAttach)
	_arg5 = (C.guint)(bottomAttach)
	_arg6 = (C.GtkAttachOptions)(xoptions)
	_arg7 = (C.GtkAttachOptions)(yoptions)
	_arg8 = (C.guint)(xpadding)
	_arg9 = (C.guint)(ypadding)

	C.gtk_table_attach(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9)
}

// AttachDefaults as there are many options associated with gtk_table_attach(),
// this convenience function provides the programmer with a means to add
// children to a table with identical padding and expansion options. The values
// used for the AttachOptions are `GTK_EXPAND | GTK_FILL`, and the padding is
// set to 0.
func (t table) AttachDefaults(widget Widget, leftAttach uint, rightAttach uint, topAttach uint, bottomAttach uint) {
	var _arg0 *C.GtkTable  // out
	var _arg1 *C.GtkWidget // out
	var _arg2 C.guint      // out
	var _arg3 C.guint      // out
	var _arg4 C.guint      // out
	var _arg5 C.guint      // out

	_arg0 = (*C.GtkTable)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (C.guint)(leftAttach)
	_arg3 = (C.guint)(rightAttach)
	_arg4 = (C.guint)(topAttach)
	_arg5 = (C.guint)(bottomAttach)

	C.gtk_table_attach_defaults(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}

// ColSpacing gets the amount of space between column @col, and column @col + 1.
// See gtk_table_set_col_spacing().
func (t table) ColSpacing(column uint) uint {
	var _arg0 *C.GtkTable // out
	var _arg1 C.guint     // out
	var _cret C.guint     // in

	_arg0 = (*C.GtkTable)(unsafe.Pointer(t.Native()))
	_arg1 = (C.guint)(column)

	_cret = C.gtk_table_get_col_spacing(_arg0, _arg1)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// DefaultColSpacing gets the default column spacing for the table. This is the
// spacing that will be used for newly added columns. (See
// gtk_table_set_col_spacings())
func (t table) DefaultColSpacing() uint {
	var _arg0 *C.GtkTable // out
	var _cret C.guint     // in

	_arg0 = (*C.GtkTable)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_table_get_default_col_spacing(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// DefaultRowSpacing gets the default row spacing for the table. This is the
// spacing that will be used for newly added rows. (See
// gtk_table_set_row_spacings())
func (t table) DefaultRowSpacing() uint {
	var _arg0 *C.GtkTable // out
	var _cret C.guint     // in

	_arg0 = (*C.GtkTable)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_table_get_default_row_spacing(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// Homogeneous returns whether the table cells are all constrained to the same
// width and height. (See gtk_table_set_homogeneous ())
func (t table) Homogeneous() bool {
	var _arg0 *C.GtkTable // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkTable)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_table_get_homogeneous(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RowSpacing gets the amount of space between row @row, and row @row + 1. See
// gtk_table_set_row_spacing().
func (t table) RowSpacing(row uint) uint {
	var _arg0 *C.GtkTable // out
	var _arg1 C.guint     // out
	var _cret C.guint     // in

	_arg0 = (*C.GtkTable)(unsafe.Pointer(t.Native()))
	_arg1 = (C.guint)(row)

	_cret = C.gtk_table_get_row_spacing(_arg0, _arg1)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// Size gets the number of rows and columns in the table.
func (t table) Size() (rows uint, columns uint) {
	var _arg0 *C.GtkTable // out
	var _arg1 C.guint     // in
	var _arg2 C.guint     // in

	_arg0 = (*C.GtkTable)(unsafe.Pointer(t.Native()))

	C.gtk_table_get_size(_arg0, &_arg1, &_arg2)

	var _rows uint    // out
	var _columns uint // out

	_rows = (uint)(_arg1)
	_columns = (uint)(_arg2)

	return _rows, _columns
}

// Resize: if you need to change a table’s size after it has been created, this
// function allows you to do so.
func (t table) Resize(rows uint, columns uint) {
	var _arg0 *C.GtkTable // out
	var _arg1 C.guint     // out
	var _arg2 C.guint     // out

	_arg0 = (*C.GtkTable)(unsafe.Pointer(t.Native()))
	_arg1 = (C.guint)(rows)
	_arg2 = (C.guint)(columns)

	C.gtk_table_resize(_arg0, _arg1, _arg2)
}

// SetColSpacing alters the amount of space between a given table column and the
// following column.
func (t table) SetColSpacing(column uint, spacing uint) {
	var _arg0 *C.GtkTable // out
	var _arg1 C.guint     // out
	var _arg2 C.guint     // out

	_arg0 = (*C.GtkTable)(unsafe.Pointer(t.Native()))
	_arg1 = (C.guint)(column)
	_arg2 = (C.guint)(spacing)

	C.gtk_table_set_col_spacing(_arg0, _arg1, _arg2)
}

// SetColSpacings sets the space between every column in @table equal to
// @spacing.
func (t table) SetColSpacings(spacing uint) {
	var _arg0 *C.GtkTable // out
	var _arg1 C.guint     // out

	_arg0 = (*C.GtkTable)(unsafe.Pointer(t.Native()))
	_arg1 = (C.guint)(spacing)

	C.gtk_table_set_col_spacings(_arg0, _arg1)
}

// SetHomogeneous changes the homogenous property of table cells, ie. whether
// all cells are an equal size or not.
func (t table) SetHomogeneous(homogeneous bool) {
	var _arg0 *C.GtkTable // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkTable)(unsafe.Pointer(t.Native()))
	if homogeneous {
		_arg1 = C.TRUE
	}

	C.gtk_table_set_homogeneous(_arg0, _arg1)
}

// SetRowSpacing changes the space between a given table row and the subsequent
// row.
func (t table) SetRowSpacing(row uint, spacing uint) {
	var _arg0 *C.GtkTable // out
	var _arg1 C.guint     // out
	var _arg2 C.guint     // out

	_arg0 = (*C.GtkTable)(unsafe.Pointer(t.Native()))
	_arg1 = (C.guint)(row)
	_arg2 = (C.guint)(spacing)

	C.gtk_table_set_row_spacing(_arg0, _arg1, _arg2)
}

// SetRowSpacings sets the space between every row in @table equal to @spacing.
func (t table) SetRowSpacings(spacing uint) {
	var _arg0 *C.GtkTable // out
	var _arg1 C.guint     // out

	_arg0 = (*C.GtkTable)(unsafe.Pointer(t.Native()))
	_arg1 = (C.guint)(spacing)

	C.gtk_table_set_row_spacings(_arg0, _arg1)
}

// TearoffMenuItem: a TearoffMenuItem is a special MenuItem which is used to
// tear off and reattach its menu.
//
// When its menu is shown normally, the TearoffMenuItem is drawn as a dotted
// line indicating that the menu can be torn off. Activating it causes its menu
// to be torn off and displayed in its own window as a tearoff menu.
//
// When its menu is shown as a tearoff menu, the TearoffMenuItem is drawn as a
// dotted line which has a left pointing arrow graphic indicating that the
// tearoff menu can be reattached. Activating it will erase the tearoff menu
// window.
//
// > TearoffMenuItem is deprecated and should not be used in newly > written
// code. Menus are not meant to be torn around.
type TearoffMenuItem interface {
	MenuItem
	Actionable
	Activatable
	Buildable
}

// tearoffMenuItem implements the TearoffMenuItem class.
type tearoffMenuItem struct {
	MenuItem
	Actionable
	Activatable
	Buildable
}

var _ TearoffMenuItem = (*tearoffMenuItem)(nil)

// WrapTearoffMenuItem wraps a GObject to the right type. It is
// primarily used internally.
func WrapTearoffMenuItem(obj *externglib.Object) TearoffMenuItem {
	return tearoffMenuItem{
		MenuItem:    WrapMenuItem(obj),
		Actionable:  WrapActionable(obj),
		Activatable: WrapActivatable(obj),
		Buildable:   WrapBuildable(obj),
	}
}

func marshalTearoffMenuItem(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTearoffMenuItem(obj), nil
}

// NewTearoffMenuItem creates a new TearoffMenuItem.
func NewTearoffMenuItem() TearoffMenuItem {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_tearoff_menu_item_new()

	var _tearoffMenuItem TearoffMenuItem // out

	_tearoffMenuItem = WrapTearoffMenuItem(externglib.Take(unsafe.Pointer(_cret)))

	return _tearoffMenuItem
}

// TextBuffer: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
type TextBuffer interface {
	gextras.Objector

	// AddMark adds the mark at position @where. The mark must not be added to
	// another buffer, and if its name is not nil then there must not be another
	// mark in the buffer with the same name.
	//
	// Emits the TextBuffer::mark-set signal as notification of the mark's
	// initial placement.
	AddMark(mark TextMark, where *TextIter)
	// AddSelectionClipboard adds @clipboard to the list of clipboards in which
	// the selection contents of @buffer are available. In most cases,
	// @clipboard will be the Clipboard of type GDK_SELECTION_PRIMARY for a view
	// of @buffer.
	AddSelectionClipboard(clipboard Clipboard)
	// ApplyTag emits the “apply-tag” signal on @buffer. The default handler for
	// the signal applies @tag to the given range. @start and @end do not have
	// to be in order.
	ApplyTag(tag TextTag, start *TextIter, end *TextIter)
	// ApplyTagByName calls gtk_text_tag_table_lookup() on the buffer’s tag
	// table to get a TextTag, then calls gtk_text_buffer_apply_tag().
	ApplyTagByName(name string, start *TextIter, end *TextIter)
	// Backspace performs the appropriate action as if the user hit the delete
	// key with the cursor at the position specified by @iter. In the normal
	// case a single character will be deleted, but when combining accents are
	// involved, more than one character can be deleted, and when precomposed
	// character and accent combinations are involved, less than one character
	// will be deleted.
	//
	// Because the buffer is modified, all outstanding iterators become invalid
	// after calling this function; however, the @iter will be re-initialized to
	// point to the location where text was deleted.
	Backspace(iter *TextIter, interactive bool, defaultEditable bool) bool
	// BeginUserAction: called to indicate that the buffer operations between
	// here and a call to gtk_text_buffer_end_user_action() are part of a single
	// user-visible operation. The operations between
	// gtk_text_buffer_begin_user_action() and gtk_text_buffer_end_user_action()
	// can then be grouped when creating an undo stack. TextBuffer maintains a
	// count of calls to gtk_text_buffer_begin_user_action() that have not been
	// closed with a call to gtk_text_buffer_end_user_action(), and emits the
	// “begin-user-action” and “end-user-action” signals only for the outermost
	// pair of calls. This allows you to build user actions from other user
	// actions.
	//
	// The “interactive” buffer mutation functions, such as
	// gtk_text_buffer_insert_interactive(), automatically call begin/end user
	// action around the buffer operations they perform, so there's no need to
	// add extra calls if you user action consists solely of a single call to
	// one of those functions.
	BeginUserAction()
	// CopyClipboard copies the currently-selected text to a clipboard.
	CopyClipboard(clipboard Clipboard)
	// CreateChildAnchor: this is a convenience function which simply creates a
	// child anchor with gtk_text_child_anchor_new() and inserts it into the
	// buffer with gtk_text_buffer_insert_child_anchor(). The new anchor is
	// owned by the buffer; no reference count is returned to the caller of
	// gtk_text_buffer_create_child_anchor().
	CreateChildAnchor(iter *TextIter) TextChildAnchor
	// CreateMark creates a mark at position @where. If @mark_name is nil, the
	// mark is anonymous; otherwise, the mark can be retrieved by name using
	// gtk_text_buffer_get_mark(). If a mark has left gravity, and text is
	// inserted at the mark’s current location, the mark will be moved to the
	// left of the newly-inserted text. If the mark has right gravity
	// (@left_gravity = false), the mark will end up on the right of
	// newly-inserted text. The standard left-to-right cursor is a mark with
	// right gravity (when you type, the cursor stays on the right side of the
	// text you’re typing).
	//
	// The caller of this function does not own a reference to the returned
	// TextMark, so you can ignore the return value if you like. Marks are owned
	// by the buffer and go away when the buffer does.
	//
	// Emits the TextBuffer::mark-set signal as notification of the mark's
	// initial placement.
	CreateMark(markName string, where *TextIter, leftGravity bool) TextMark
	// CutClipboard copies the currently-selected text to a clipboard, then
	// deletes said text if it’s editable.
	CutClipboard(clipboard Clipboard, defaultEditable bool)
	// Delete deletes text between @start and @end. The order of @start and @end
	// is not actually relevant; gtk_text_buffer_delete() will reorder them.
	// This function actually emits the “delete-range” signal, and the default
	// handler of that signal deletes the text. Because the buffer is modified,
	// all outstanding iterators become invalid after calling this function;
	// however, the @start and @end will be re-initialized to point to the
	// location where text was deleted.
	Delete(start *TextIter, end *TextIter)
	// DeleteInteractive deletes all editable text in the given range. Calls
	// gtk_text_buffer_delete() for each editable sub-range of [@start,@end).
	// @start and @end are revalidated to point to the location of the last
	// deleted range, or left untouched if no text was deleted.
	DeleteInteractive(startIter *TextIter, endIter *TextIter, defaultEditable bool) bool
	// DeleteMark deletes @mark, so that it’s no longer located anywhere in the
	// buffer. Removes the reference the buffer holds to the mark, so if you
	// haven’t called g_object_ref() on the mark, it will be freed. Even if the
	// mark isn’t freed, most operations on @mark become invalid, until it gets
	// added to a buffer again with gtk_text_buffer_add_mark(). Use
	// gtk_text_mark_get_deleted() to find out if a mark has been removed from
	// its buffer. The TextBuffer::mark-deleted signal will be emitted as
	// notification after the mark is deleted.
	DeleteMark(mark TextMark)
	// DeleteMarkByName deletes the mark named @name; the mark must exist. See
	// gtk_text_buffer_delete_mark() for details.
	DeleteMarkByName(name string)
	// DeleteSelection deletes the range between the “insert” and
	// “selection_bound” marks, that is, the currently-selected text. If
	// @interactive is true, the editability of the selection will be considered
	// (users can’t delete uneditable text).
	DeleteSelection(interactive bool, defaultEditable bool) bool
	// Deserialize: this function deserializes rich text in format @format and
	// inserts it at @iter.
	//
	// @formats to be used must be registered using
	// gtk_text_buffer_register_deserialize_format() or
	// gtk_text_buffer_register_deserialize_tagset() beforehand.
	Deserialize(contentBuffer TextBuffer, format *gdk.Atom, iter *TextIter, data []byte) error
	// DeserializeGetCanCreateTags: this functions returns the value set with
	// gtk_text_buffer_deserialize_set_can_create_tags()
	DeserializeGetCanCreateTags(format *gdk.Atom) bool
	// DeserializeSetCanCreateTags: use this function to allow a rich text
	// deserialization function to create new tags in the receiving buffer. Note
	// that using this function is almost always a bad idea, because the rich
	// text functions you register should know how to map the rich text format
	// they handler to your text buffers set of tags.
	//
	// The ability of creating new (arbitrary!) tags in the receiving buffer is
	// meant for special rich text formats like the internal one that is
	// registered using gtk_text_buffer_register_deserialize_tagset(), because
	// that format is essentially a dump of the internal structure of the source
	// buffer, including its tag names.
	//
	// You should allow creation of tags only if you know what you are doing,
	// e.g. if you defined a tagset name for your application suite’s text
	// buffers and you know that it’s fine to receive new tags from these
	// buffers, because you know that your application can handle the newly
	// created tags.
	DeserializeSetCanCreateTags(format *gdk.Atom, canCreateTags bool)
	// EndUserAction: should be paired with a call to
	// gtk_text_buffer_begin_user_action(). See that function for a full
	// explanation.
	EndUserAction()
	// Bounds retrieves the first and last iterators in the buffer, i.e. the
	// entire buffer lies within the range [@start,@end).
	Bounds() (start TextIter, end TextIter)
	// CharCount gets the number of characters in the buffer; note that
	// characters and bytes are not the same, you can’t e.g. expect the contents
	// of the buffer in string form to be this many bytes long. The character
	// count is cached, so this function is very fast.
	CharCount() int
	// CopyTargetList: this function returns the list of targets this text
	// buffer can provide for copying and as DND source. The targets in the list
	// are added with @info values from the TextBufferTargetInfo enum, using
	// gtk_target_list_add_rich_text_targets() and
	// gtk_target_list_add_text_targets().
	CopyTargetList() *TargetList
	// EndIter initializes @iter with the “end iterator,” one past the last
	// valid character in the text buffer. If dereferenced with
	// gtk_text_iter_get_char(), the end iterator has a character value of 0.
	// The entire buffer lies in the range from the first position in the buffer
	// (call gtk_text_buffer_get_start_iter() to get character position 0) to
	// the end iterator.
	EndIter() TextIter
	// HasSelection indicates whether the buffer has some text currently
	// selected.
	HasSelection() bool
	// GetInsert returns the mark that represents the cursor (insertion point).
	// Equivalent to calling gtk_text_buffer_get_mark() to get the mark named
	// “insert”, but very slightly more efficient, and involves less typing.
	GetInsert() TextMark
	// IterAtChildAnchor obtains the location of @anchor within @buffer.
	IterAtChildAnchor(anchor TextChildAnchor) TextIter
	// IterAtLine initializes @iter to the start of the given line. If
	// @line_number is greater than the number of lines in the @buffer, the end
	// iterator is returned.
	IterAtLine(lineNumber int) TextIter
	// IterAtLineIndex obtains an iterator pointing to @byte_index within the
	// given line. @byte_index must be the start of a UTF-8 character. Note
	// bytes, not characters; UTF-8 may encode one character as multiple bytes.
	//
	// Before the 3.20 version, it was not allowed to pass an invalid location.
	//
	// Since the 3.20 version, if @line_number is greater than the number of
	// lines in the @buffer, the end iterator is returned. And if @byte_index is
	// off the end of the line, the iterator at the end of the line is returned.
	IterAtLineIndex(lineNumber int, byteIndex int) TextIter
	// IterAtLineOffset obtains an iterator pointing to @char_offset within the
	// given line. Note characters, not bytes; UTF-8 may encode one character as
	// multiple bytes.
	//
	// Before the 3.20 version, it was not allowed to pass an invalid location.
	//
	// Since the 3.20 version, if @line_number is greater than the number of
	// lines in the @buffer, the end iterator is returned. And if @char_offset
	// is off the end of the line, the iterator at the end of the line is
	// returned.
	IterAtLineOffset(lineNumber int, charOffset int) TextIter
	// IterAtMark initializes @iter with the current position of @mark.
	IterAtMark(mark TextMark) TextIter
	// IterAtOffset initializes @iter to a position @char_offset chars from the
	// start of the entire buffer. If @char_offset is -1 or greater than the
	// number of characters in the buffer, @iter is initialized to the end
	// iterator, the iterator one past the last valid character in the buffer.
	IterAtOffset(charOffset int) TextIter
	// LineCount obtains the number of lines in the buffer. This value is
	// cached, so the function is very fast.
	LineCount() int
	// Mark returns the mark named @name in buffer @buffer, or nil if no such
	// mark exists in the buffer.
	Mark(name string) TextMark
	// Modified indicates whether the buffer has been modified since the last
	// call to gtk_text_buffer_set_modified() set the modification flag to
	// false. Used for example to enable a “save” function in a text editor.
	Modified() bool
	// PasteTargetList: this function returns the list of targets this text
	// buffer supports for pasting and as DND destination. The targets in the
	// list are added with @info values from the TextBufferTargetInfo enum,
	// using gtk_target_list_add_rich_text_targets() and
	// gtk_target_list_add_text_targets().
	PasteTargetList() *TargetList
	// SelectionBound returns the mark that represents the selection bound.
	// Equivalent to calling gtk_text_buffer_get_mark() to get the mark named
	// “selection_bound”, but very slightly more efficient, and involves less
	// typing.
	//
	// The currently-selected text in @buffer is the region between the
	// “selection_bound” and “insert” marks. If “selection_bound” and “insert”
	// are in the same place, then there is no current selection.
	// gtk_text_buffer_get_selection_bounds() is another convenient function for
	// handling the selection, if you just want to know whether there’s a
	// selection and what its bounds are.
	SelectionBound() TextMark
	// SelectionBounds returns true if some text is selected; places the bounds
	// of the selection in @start and @end (if the selection has length 0, then
	// @start and @end are filled in with the same value). @start and @end will
	// be in ascending order. If @start and @end are NULL, then they are not
	// filled in, but the return value still indicates whether text is selected.
	SelectionBounds() (start TextIter, end TextIter, ok bool)
	// Slice returns the text in the range [@start,@end). Excludes undisplayed
	// text (text marked with tags that set the invisibility attribute) if
	// @include_hidden_chars is false. The returned string includes a 0xFFFC
	// character whenever the buffer contains embedded images, so byte and
	// character indexes into the returned string do correspond to byte and
	// character indexes into the buffer. Contrast with
	// gtk_text_buffer_get_text(). Note that 0xFFFC can occur in normal text as
	// well, so it is not a reliable indicator that a pixbuf or widget is in the
	// buffer.
	Slice(start *TextIter, end *TextIter, includeHiddenChars bool) string
	// StartIter: initialized @iter with the first position in the text buffer.
	// This is the same as using gtk_text_buffer_get_iter_at_offset() to get the
	// iter at character offset 0.
	StartIter() TextIter
	// TagTable: get the TextTagTable associated with this buffer.
	TagTable() TextTagTable
	// Text returns the text in the range [@start,@end). Excludes undisplayed
	// text (text marked with tags that set the invisibility attribute) if
	// @include_hidden_chars is false. Does not include characters representing
	// embedded images, so byte and character indexes into the returned string
	// do not correspond to byte and character indexes into the buffer. Contrast
	// with gtk_text_buffer_get_slice().
	Text(start *TextIter, end *TextIter, includeHiddenChars bool) string
	// Insert inserts @len bytes of @text at position @iter. If @len is -1,
	// @text must be nul-terminated and will be inserted in its entirety. Emits
	// the “insert-text” signal; insertion actually occurs in the default
	// handler for the signal. @iter is invalidated when insertion occurs
	// (because the buffer contents change), but the default signal handler
	// revalidates it to point to the end of the inserted text.
	Insert(iter *TextIter, text string, len int)
	// InsertAtCursor: simply calls gtk_text_buffer_insert(), using the current
	// cursor position as the insertion point.
	InsertAtCursor(text string, len int)
	// InsertChildAnchor inserts a child widget anchor into the text buffer at
	// @iter. The anchor will be counted as one character in character counts,
	// and when obtaining the buffer contents as a string, will be represented
	// by the Unicode “object replacement character” 0xFFFC. Note that the
	// “slice” variants for obtaining portions of the buffer as a string include
	// this character for child anchors, but the “text” variants do not. E.g.
	// see gtk_text_buffer_get_slice() and gtk_text_buffer_get_text(). Consider
	// gtk_text_buffer_create_child_anchor() as a more convenient alternative to
	// this function. The buffer will add a reference to the anchor, so you can
	// unref it after insertion.
	InsertChildAnchor(iter *TextIter, anchor TextChildAnchor)
	// InsertInteractive: like gtk_text_buffer_insert(), but the insertion will
	// not occur if @iter is at a non-editable location in the buffer. Usually
	// you want to prevent insertions at ineditable locations if the insertion
	// results from a user action (is interactive).
	//
	// @default_editable indicates the editability of text that doesn't have a
	// tag affecting editability applied to it. Typically the result of
	// gtk_text_view_get_editable() is appropriate here.
	InsertInteractive(iter *TextIter, text string, len int, defaultEditable bool) bool
	// InsertInteractiveAtCursor calls gtk_text_buffer_insert_interactive() at
	// the cursor position.
	//
	// @default_editable indicates the editability of text that doesn't have a
	// tag affecting editability applied to it. Typically the result of
	// gtk_text_view_get_editable() is appropriate here.
	InsertInteractiveAtCursor(text string, len int, defaultEditable bool) bool
	// InsertMarkup inserts the text in @markup at position @iter. @markup will
	// be inserted in its entirety and must be nul-terminated and valid UTF-8.
	// Emits the TextBuffer::insert-text signal, possibly multiple times;
	// insertion actually occurs in the default handler for the signal. @iter
	// will point to the end of the inserted text on return.
	InsertMarkup(iter *TextIter, markup string, len int)
	// InsertPixbuf inserts an image into the text buffer at @iter. The image
	// will be counted as one character in character counts, and when obtaining
	// the buffer contents as a string, will be represented by the Unicode
	// “object replacement character” 0xFFFC. Note that the “slice” variants for
	// obtaining portions of the buffer as a string include this character for
	// pixbufs, but the “text” variants do not. e.g. see
	// gtk_text_buffer_get_slice() and gtk_text_buffer_get_text().
	InsertPixbuf(iter *TextIter, pixbuf gdkpixbuf.Pixbuf)
	// InsertRange copies text, tags, and pixbufs between @start and @end (the
	// order of @start and @end doesn’t matter) and inserts the copy at @iter.
	// Used instead of simply getting/inserting text because it preserves images
	// and tags. If @start and @end are in a different buffer from @buffer, the
	// two buffers must share the same tag table.
	//
	// Implemented via emissions of the insert_text and apply_tag signals, so
	// expect those.
	InsertRange(iter *TextIter, start *TextIter, end *TextIter)
	// InsertRangeInteractive: same as gtk_text_buffer_insert_range(), but does
	// nothing if the insertion point isn’t editable. The @default_editable
	// parameter indicates whether the text is editable at @iter if no tags
	// enclosing @iter affect editability. Typically the result of
	// gtk_text_view_get_editable() is appropriate here.
	InsertRangeInteractive(iter *TextIter, start *TextIter, end *TextIter, defaultEditable bool) bool
	// MoveMark moves @mark to the new location @where. Emits the
	// TextBuffer::mark-set signal as notification of the move.
	MoveMark(mark TextMark, where *TextIter)
	// MoveMarkByName moves the mark named @name (which must exist) to location
	// @where. See gtk_text_buffer_move_mark() for details.
	MoveMarkByName(name string, where *TextIter)
	// PasteClipboard pastes the contents of a clipboard. If @override_location
	// is nil, the pasted text will be inserted at the cursor position, or the
	// buffer selection will be replaced if the selection is non-empty.
	//
	// Note: pasting is asynchronous, that is, we’ll ask for the paste data and
	// return, and at some point later after the main loop runs, the paste data
	// will be inserted.
	PasteClipboard(clipboard Clipboard, overrideLocation *TextIter, defaultEditable bool)
	// PlaceCursor: this function moves the “insert” and “selection_bound” marks
	// simultaneously. If you move them to the same place in two steps with
	// gtk_text_buffer_move_mark(), you will temporarily select a region in
	// between their old and new locations, which can be pretty inefficient
	// since the temporarily-selected region will force stuff to be
	// recalculated. This function moves them as a unit, which can be optimized.
	PlaceCursor(where *TextIter)
	// RegisterDeserializeTagset: this function registers GTK+’s internal rich
	// text serialization format with the passed @buffer. See
	// gtk_text_buffer_register_serialize_tagset() for details.
	RegisterDeserializeTagset(tagsetName string) *gdk.Atom
	// RegisterSerializeTagset: this function registers GTK+’s internal rich
	// text serialization format with the passed @buffer. The internal format
	// does not comply to any standard rich text format and only works between
	// TextBuffer instances. It is capable of serializing all of a text buffer’s
	// tags and embedded pixbufs.
	//
	// This function is just a wrapper around
	// gtk_text_buffer_register_serialize_format(). The mime type used for
	// registering is “application/x-gtk-text-buffer-rich-text”, or
	// “application/x-gtk-text-buffer-rich-text;format=@tagset_name” if a
	// @tagset_name was passed.
	//
	// The @tagset_name can be used to restrict the transfer of rich text to
	// buffers with compatible sets of tags, in order to avoid unknown tags from
	// being pasted. It is probably the common case to pass an identifier != nil
	// here, since the nil tagset requires the receiving buffer to deal with
	// with pasting of arbitrary tags.
	RegisterSerializeTagset(tagsetName string) *gdk.Atom
	// RemoveAllTags removes all tags in the range between @start and @end. Be
	// careful with this function; it could remove tags added in code unrelated
	// to the code you’re currently writing. That is, using this function is
	// probably a bad idea if you have two or more unrelated code sections that
	// add tags.
	RemoveAllTags(start *TextIter, end *TextIter)
	// RemoveSelectionClipboard removes a Clipboard added with
	// gtk_text_buffer_add_selection_clipboard().
	RemoveSelectionClipboard(clipboard Clipboard)
	// RemoveTag emits the “remove-tag” signal. The default handler for the
	// signal removes all occurrences of @tag from the given range. @start and
	// @end don’t have to be in order.
	RemoveTag(tag TextTag, start *TextIter, end *TextIter)
	// RemoveTagByName calls gtk_text_tag_table_lookup() on the buffer’s tag
	// table to get a TextTag, then calls gtk_text_buffer_remove_tag().
	RemoveTagByName(name string, start *TextIter, end *TextIter)
	// SelectRange: this function moves the “insert” and “selection_bound” marks
	// simultaneously. If you move them in two steps with
	// gtk_text_buffer_move_mark(), you will temporarily select a region in
	// between their old and new locations, which can be pretty inefficient
	// since the temporarily-selected region will force stuff to be
	// recalculated. This function moves them as a unit, which can be optimized.
	SelectRange(ins *TextIter, bound *TextIter)
	// SetModified: used to keep track of whether the buffer has been modified
	// since the last time it was saved. Whenever the buffer is saved to disk,
	// call gtk_text_buffer_set_modified (@buffer, FALSE). When the buffer is
	// modified, it will automatically toggled on the modified bit again. When
	// the modified bit flips, the buffer emits the TextBuffer::modified-changed
	// signal.
	SetModified(setting bool)
	// SetText deletes current contents of @buffer, and inserts @text instead.
	// If @len is -1, @text must be nul-terminated. @text must be valid UTF-8.
	SetText(text string, len int)
	// UnregisterDeserializeFormat: this function unregisters a rich text format
	// that was previously registered using
	// gtk_text_buffer_register_deserialize_format() or
	// gtk_text_buffer_register_deserialize_tagset().
	UnregisterDeserializeFormat(format *gdk.Atom)
	// UnregisterSerializeFormat: this function unregisters a rich text format
	// that was previously registered using
	// gtk_text_buffer_register_serialize_format() or
	// gtk_text_buffer_register_serialize_tagset()
	UnregisterSerializeFormat(format *gdk.Atom)
}

// textBuffer implements the TextBuffer class.
type textBuffer struct {
	gextras.Objector
}

var _ TextBuffer = (*textBuffer)(nil)

// WrapTextBuffer wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextBuffer(obj *externglib.Object) TextBuffer {
	return textBuffer{
		Objector: obj,
	}
}

func marshalTextBuffer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextBuffer(obj), nil
}

// NewTextBuffer creates a new text buffer.
func NewTextBuffer(table TextTagTable) TextBuffer {
	var _arg1 *C.GtkTextTagTable // out
	var _cret *C.GtkTextBuffer   // in

	_arg1 = (*C.GtkTextTagTable)(unsafe.Pointer(table.Native()))

	_cret = C.gtk_text_buffer_new(_arg1)

	var _textBuffer TextBuffer // out

	_textBuffer = WrapTextBuffer(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _textBuffer
}

// AddMark adds the mark at position @where. The mark must not be added to
// another buffer, and if its name is not nil then there must not be another
// mark in the buffer with the same name.
//
// Emits the TextBuffer::mark-set signal as notification of the mark's initial
// placement.
func (b textBuffer) AddMark(mark TextMark, where *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextMark   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))

	C.gtk_text_buffer_add_mark(_arg0, _arg1, _arg2)
}

// AddSelectionClipboard adds @clipboard to the list of clipboards in which the
// selection contents of @buffer are available. In most cases, @clipboard will
// be the Clipboard of type GDK_SELECTION_PRIMARY for a view of @buffer.
func (b textBuffer) AddSelectionClipboard(clipboard Clipboard) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkClipboard  // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkClipboard)(unsafe.Pointer(clipboard.Native()))

	C.gtk_text_buffer_add_selection_clipboard(_arg0, _arg1)
}

// ApplyTag emits the “apply-tag” signal on @buffer. The default handler for the
// signal applies @tag to the given range. @start and @end do not have to be in
// order.
func (b textBuffer) ApplyTag(tag TextTag, start *TextIter, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextTag    // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_apply_tag(_arg0, _arg1, _arg2, _arg3)
}

// ApplyTagByName calls gtk_text_tag_table_lookup() on the buffer’s tag table to
// get a TextTag, then calls gtk_text_buffer_apply_tag().
func (b textBuffer) ApplyTagByName(name string, start *TextIter, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_apply_tag_by_name(_arg0, _arg1, _arg2, _arg3)
}

// Backspace performs the appropriate action as if the user hit the delete key
// with the cursor at the position specified by @iter. In the normal case a
// single character will be deleted, but when combining accents are involved,
// more than one character can be deleted, and when precomposed character and
// accent combinations are involved, less than one character will be deleted.
//
// Because the buffer is modified, all outstanding iterators become invalid
// after calling this function; however, the @iter will be re-initialized to
// point to the location where text was deleted.
func (b textBuffer) Backspace(iter *TextIter, interactive bool, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 C.gboolean       // out
	var _arg3 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	if interactive {
		_arg2 = C.TRUE
	}
	if defaultEditable {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_backspace(_arg0, _arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BeginUserAction: called to indicate that the buffer operations between here
// and a call to gtk_text_buffer_end_user_action() are part of a single
// user-visible operation. The operations between
// gtk_text_buffer_begin_user_action() and gtk_text_buffer_end_user_action() can
// then be grouped when creating an undo stack. TextBuffer maintains a count of
// calls to gtk_text_buffer_begin_user_action() that have not been closed with a
// call to gtk_text_buffer_end_user_action(), and emits the “begin-user-action”
// and “end-user-action” signals only for the outermost pair of calls. This
// allows you to build user actions from other user actions.
//
// The “interactive” buffer mutation functions, such as
// gtk_text_buffer_insert_interactive(), automatically call begin/end user
// action around the buffer operations they perform, so there's no need to add
// extra calls if you user action consists solely of a single call to one of
// those functions.
func (b textBuffer) BeginUserAction() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	C.gtk_text_buffer_begin_user_action(_arg0)
}

// CopyClipboard copies the currently-selected text to a clipboard.
func (b textBuffer) CopyClipboard(clipboard Clipboard) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkClipboard  // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkClipboard)(unsafe.Pointer(clipboard.Native()))

	C.gtk_text_buffer_copy_clipboard(_arg0, _arg1)
}

// CreateChildAnchor: this is a convenience function which simply creates a
// child anchor with gtk_text_child_anchor_new() and inserts it into the buffer
// with gtk_text_buffer_insert_child_anchor(). The new anchor is owned by the
// buffer; no reference count is returned to the caller of
// gtk_text_buffer_create_child_anchor().
func (b textBuffer) CreateChildAnchor(iter *TextIter) TextChildAnchor {
	var _arg0 *C.GtkTextBuffer      // out
	var _arg1 *C.GtkTextIter        // out
	var _cret *C.GtkTextChildAnchor // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_text_buffer_create_child_anchor(_arg0, _arg1)

	var _textChildAnchor TextChildAnchor // out

	_textChildAnchor = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextChildAnchor)

	return _textChildAnchor
}

// CreateMark creates a mark at position @where. If @mark_name is nil, the mark
// is anonymous; otherwise, the mark can be retrieved by name using
// gtk_text_buffer_get_mark(). If a mark has left gravity, and text is inserted
// at the mark’s current location, the mark will be moved to the left of the
// newly-inserted text. If the mark has right gravity (@left_gravity = false),
// the mark will end up on the right of newly-inserted text. The standard
// left-to-right cursor is a mark with right gravity (when you type, the cursor
// stays on the right side of the text you’re typing).
//
// The caller of this function does not own a reference to the returned
// TextMark, so you can ignore the return value if you like. Marks are owned by
// the buffer and go away when the buffer does.
//
// Emits the TextBuffer::mark-set signal as notification of the mark's initial
// placement.
func (b textBuffer) CreateMark(markName string, where *TextIter, leftGravity bool) TextMark {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out
	var _cret *C.GtkTextMark   // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(markName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))
	if leftGravity {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_create_mark(_arg0, _arg1, _arg2, _arg3)

	var _textMark TextMark // out

	_textMark = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextMark)

	return _textMark
}

// CutClipboard copies the currently-selected text to a clipboard, then deletes
// said text if it’s editable.
func (b textBuffer) CutClipboard(clipboard Clipboard, defaultEditable bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkClipboard  // out
	var _arg2 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkClipboard)(unsafe.Pointer(clipboard.Native()))
	if defaultEditable {
		_arg2 = C.TRUE
	}

	C.gtk_text_buffer_cut_clipboard(_arg0, _arg1, _arg2)
}

// Delete deletes text between @start and @end. The order of @start and @end is
// not actually relevant; gtk_text_buffer_delete() will reorder them. This
// function actually emits the “delete-range” signal, and the default handler of
// that signal deletes the text. Because the buffer is modified, all outstanding
// iterators become invalid after calling this function; however, the @start and
// @end will be re-initialized to point to the location where text was deleted.
func (b textBuffer) Delete(start *TextIter, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_delete(_arg0, _arg1, _arg2)
}

// DeleteInteractive deletes all editable text in the given range. Calls
// gtk_text_buffer_delete() for each editable sub-range of [@start,@end). @start
// and @end are revalidated to point to the location of the last deleted range,
// or left untouched if no text was deleted.
func (b textBuffer) DeleteInteractive(startIter *TextIter, endIter *TextIter, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(startIter.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(endIter.Native()))
	if defaultEditable {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_delete_interactive(_arg0, _arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DeleteMark deletes @mark, so that it’s no longer located anywhere in the
// buffer. Removes the reference the buffer holds to the mark, so if you haven’t
// called g_object_ref() on the mark, it will be freed. Even if the mark isn’t
// freed, most operations on @mark become invalid, until it gets added to a
// buffer again with gtk_text_buffer_add_mark(). Use gtk_text_mark_get_deleted()
// to find out if a mark has been removed from its buffer. The
// TextBuffer::mark-deleted signal will be emitted as notification after the
// mark is deleted.
func (b textBuffer) DeleteMark(mark TextMark) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextMark   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))

	C.gtk_text_buffer_delete_mark(_arg0, _arg1)
}

// DeleteMarkByName deletes the mark named @name; the mark must exist. See
// gtk_text_buffer_delete_mark() for details.
func (b textBuffer) DeleteMarkByName(name string) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_text_buffer_delete_mark_by_name(_arg0, _arg1)
}

// DeleteSelection deletes the range between the “insert” and “selection_bound”
// marks, that is, the currently-selected text. If @interactive is true, the
// editability of the selection will be considered (users can’t delete
// uneditable text).
func (b textBuffer) DeleteSelection(interactive bool, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.gboolean       // out
	var _arg2 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	if interactive {
		_arg1 = C.TRUE
	}
	if defaultEditable {
		_arg2 = C.TRUE
	}

	_cret = C.gtk_text_buffer_delete_selection(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Deserialize: this function deserializes rich text in format @format and
// inserts it at @iter.
//
// @formats to be used must be registered using
// gtk_text_buffer_register_deserialize_format() or
// gtk_text_buffer_register_deserialize_tagset() beforehand.
func (r textBuffer) Deserialize(contentBuffer TextBuffer, format *gdk.Atom, iter *TextIter, data []byte) error {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextBuffer // out
	var _arg2 C.GdkAtom        // out
	var _arg3 *C.GtkTextIter   // out
	var _arg4 *C.guint8
	var _arg5 C.gsize
	var _cerr *C.GError // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.GtkTextBuffer)(unsafe.Pointer(contentBuffer.Native()))
	_arg2 = (C.GdkAtom)(unsafe.Pointer(format.Native()))
	_arg3 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	_arg5 = C.gsize(len(data))
	_arg4 = (*C.guint8)(unsafe.Pointer(&data[0]))

	C.gtk_text_buffer_deserialize(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// DeserializeGetCanCreateTags: this functions returns the value set with
// gtk_text_buffer_deserialize_set_can_create_tags()
func (b textBuffer) DeserializeGetCanCreateTags(format *gdk.Atom) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GdkAtom        // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (C.GdkAtom)(unsafe.Pointer(format.Native()))

	_cret = C.gtk_text_buffer_deserialize_get_can_create_tags(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DeserializeSetCanCreateTags: use this function to allow a rich text
// deserialization function to create new tags in the receiving buffer. Note
// that using this function is almost always a bad idea, because the rich text
// functions you register should know how to map the rich text format they
// handler to your text buffers set of tags.
//
// The ability of creating new (arbitrary!) tags in the receiving buffer is
// meant for special rich text formats like the internal one that is registered
// using gtk_text_buffer_register_deserialize_tagset(), because that format is
// essentially a dump of the internal structure of the source buffer, including
// its tag names.
//
// You should allow creation of tags only if you know what you are doing, e.g.
// if you defined a tagset name for your application suite’s text buffers and
// you know that it’s fine to receive new tags from these buffers, because you
// know that your application can handle the newly created tags.
func (b textBuffer) DeserializeSetCanCreateTags(format *gdk.Atom, canCreateTags bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GdkAtom        // out
	var _arg2 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (C.GdkAtom)(unsafe.Pointer(format.Native()))
	if canCreateTags {
		_arg2 = C.TRUE
	}

	C.gtk_text_buffer_deserialize_set_can_create_tags(_arg0, _arg1, _arg2)
}

// EndUserAction: should be paired with a call to
// gtk_text_buffer_begin_user_action(). See that function for a full
// explanation.
func (b textBuffer) EndUserAction() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	C.gtk_text_buffer_end_user_action(_arg0)
}

// Bounds retrieves the first and last iterators in the buffer, i.e. the entire
// buffer lies within the range [@start,@end).
func (b textBuffer) Bounds() (start TextIter, end TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _start TextIter
	var _end TextIter

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	C.gtk_text_buffer_get_bounds(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_start)), (*C.GtkTextIter)(unsafe.Pointer(&_end)))

	return _start, _end
}

// CharCount gets the number of characters in the buffer; note that characters
// and bytes are not the same, you can’t e.g. expect the contents of the buffer
// in string form to be this many bytes long. The character count is cached, so
// this function is very fast.
func (b textBuffer) CharCount() int {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.gint           // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_text_buffer_get_char_count(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// CopyTargetList: this function returns the list of targets this text buffer
// can provide for copying and as DND source. The targets in the list are added
// with @info values from the TextBufferTargetInfo enum, using
// gtk_target_list_add_rich_text_targets() and
// gtk_target_list_add_text_targets().
func (b textBuffer) CopyTargetList() *TargetList {
	var _arg0 *C.GtkTextBuffer // out
	var _cret *C.GtkTargetList // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_text_buffer_get_copy_target_list(_arg0)

	var _targetList *TargetList // out

	_targetList = WrapTargetList(unsafe.Pointer(_cret))

	return _targetList
}

// EndIter initializes @iter with the “end iterator,” one past the last valid
// character in the text buffer. If dereferenced with gtk_text_iter_get_char(),
// the end iterator has a character value of 0. The entire buffer lies in the
// range from the first position in the buffer (call
// gtk_text_buffer_get_start_iter() to get character position 0) to the end
// iterator.
func (b textBuffer) EndIter() TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _iter TextIter

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	C.gtk_text_buffer_get_end_iter(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)))

	return _iter
}

// HasSelection indicates whether the buffer has some text currently selected.
func (b textBuffer) HasSelection() bool {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_text_buffer_get_has_selection(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// GetInsert returns the mark that represents the cursor (insertion point).
// Equivalent to calling gtk_text_buffer_get_mark() to get the mark named
// “insert”, but very slightly more efficient, and involves less typing.
func (b textBuffer) GetInsert() TextMark {
	var _arg0 *C.GtkTextBuffer // out
	var _cret *C.GtkTextMark   // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_text_buffer_get_insert(_arg0)

	var _textMark TextMark // out

	_textMark = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextMark)

	return _textMark
}

// IterAtChildAnchor obtains the location of @anchor within @buffer.
func (b textBuffer) IterAtChildAnchor(anchor TextChildAnchor) TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _iter TextIter
	var _arg2 *C.GtkTextChildAnchor // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg2 = (*C.GtkTextChildAnchor)(unsafe.Pointer(anchor.Native()))

	C.gtk_text_buffer_get_iter_at_child_anchor(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)), _arg2)

	return _iter
}

// IterAtLine initializes @iter to the start of the given line. If @line_number
// is greater than the number of lines in the @buffer, the end iterator is
// returned.
func (b textBuffer) IterAtLine(lineNumber int) TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _iter TextIter
	var _arg2 C.gint // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg2 = (C.gint)(lineNumber)

	C.gtk_text_buffer_get_iter_at_line(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)), _arg2)

	return _iter
}

// IterAtLineIndex obtains an iterator pointing to @byte_index within the given
// line. @byte_index must be the start of a UTF-8 character. Note bytes, not
// characters; UTF-8 may encode one character as multiple bytes.
//
// Before the 3.20 version, it was not allowed to pass an invalid location.
//
// Since the 3.20 version, if @line_number is greater than the number of lines
// in the @buffer, the end iterator is returned. And if @byte_index is off the
// end of the line, the iterator at the end of the line is returned.
func (b textBuffer) IterAtLineIndex(lineNumber int, byteIndex int) TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _iter TextIter
	var _arg2 C.gint // out
	var _arg3 C.gint // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg2 = (C.gint)(lineNumber)
	_arg3 = (C.gint)(byteIndex)

	C.gtk_text_buffer_get_iter_at_line_index(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)), _arg2, _arg3)

	return _iter
}

// IterAtLineOffset obtains an iterator pointing to @char_offset within the
// given line. Note characters, not bytes; UTF-8 may encode one character as
// multiple bytes.
//
// Before the 3.20 version, it was not allowed to pass an invalid location.
//
// Since the 3.20 version, if @line_number is greater than the number of lines
// in the @buffer, the end iterator is returned. And if @char_offset is off the
// end of the line, the iterator at the end of the line is returned.
func (b textBuffer) IterAtLineOffset(lineNumber int, charOffset int) TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _iter TextIter
	var _arg2 C.gint // out
	var _arg3 C.gint // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg2 = (C.gint)(lineNumber)
	_arg3 = (C.gint)(charOffset)

	C.gtk_text_buffer_get_iter_at_line_offset(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)), _arg2, _arg3)

	return _iter
}

// IterAtMark initializes @iter with the current position of @mark.
func (b textBuffer) IterAtMark(mark TextMark) TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _iter TextIter
	var _arg2 *C.GtkTextMark // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg2 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))

	C.gtk_text_buffer_get_iter_at_mark(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)), _arg2)

	return _iter
}

// IterAtOffset initializes @iter to a position @char_offset chars from the
// start of the entire buffer. If @char_offset is -1 or greater than the number
// of characters in the buffer, @iter is initialized to the end iterator, the
// iterator one past the last valid character in the buffer.
func (b textBuffer) IterAtOffset(charOffset int) TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _iter TextIter
	var _arg2 C.gint // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg2 = (C.gint)(charOffset)

	C.gtk_text_buffer_get_iter_at_offset(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)), _arg2)

	return _iter
}

// LineCount obtains the number of lines in the buffer. This value is cached, so
// the function is very fast.
func (b textBuffer) LineCount() int {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.gint           // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_text_buffer_get_line_count(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Mark returns the mark named @name in buffer @buffer, or nil if no such mark
// exists in the buffer.
func (b textBuffer) Mark(name string) TextMark {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.gchar         // out
	var _cret *C.GtkTextMark   // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_text_buffer_get_mark(_arg0, _arg1)

	var _textMark TextMark // out

	_textMark = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextMark)

	return _textMark
}

// Modified indicates whether the buffer has been modified since the last call
// to gtk_text_buffer_set_modified() set the modification flag to false. Used
// for example to enable a “save” function in a text editor.
func (b textBuffer) Modified() bool {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_text_buffer_get_modified(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PasteTargetList: this function returns the list of targets this text buffer
// supports for pasting and as DND destination. The targets in the list are
// added with @info values from the TextBufferTargetInfo enum, using
// gtk_target_list_add_rich_text_targets() and
// gtk_target_list_add_text_targets().
func (b textBuffer) PasteTargetList() *TargetList {
	var _arg0 *C.GtkTextBuffer // out
	var _cret *C.GtkTargetList // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_text_buffer_get_paste_target_list(_arg0)

	var _targetList *TargetList // out

	_targetList = WrapTargetList(unsafe.Pointer(_cret))

	return _targetList
}

// SelectionBound returns the mark that represents the selection bound.
// Equivalent to calling gtk_text_buffer_get_mark() to get the mark named
// “selection_bound”, but very slightly more efficient, and involves less
// typing.
//
// The currently-selected text in @buffer is the region between the
// “selection_bound” and “insert” marks. If “selection_bound” and “insert” are
// in the same place, then there is no current selection.
// gtk_text_buffer_get_selection_bounds() is another convenient function for
// handling the selection, if you just want to know whether there’s a selection
// and what its bounds are.
func (b textBuffer) SelectionBound() TextMark {
	var _arg0 *C.GtkTextBuffer // out
	var _cret *C.GtkTextMark   // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_text_buffer_get_selection_bound(_arg0)

	var _textMark TextMark // out

	_textMark = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextMark)

	return _textMark
}

// SelectionBounds returns true if some text is selected; places the bounds of
// the selection in @start and @end (if the selection has length 0, then @start
// and @end are filled in with the same value). @start and @end will be in
// ascending order. If @start and @end are NULL, then they are not filled in,
// but the return value still indicates whether text is selected.
func (b textBuffer) SelectionBounds() (start TextIter, end TextIter, ok bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _start TextIter
	var _end TextIter
	var _cret C.gboolean // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_text_buffer_get_selection_bounds(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_start)), (*C.GtkTextIter)(unsafe.Pointer(&_end)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _start, _end, _ok
}

// Slice returns the text in the range [@start,@end). Excludes undisplayed text
// (text marked with tags that set the invisibility attribute) if
// @include_hidden_chars is false. The returned string includes a 0xFFFC
// character whenever the buffer contains embedded images, so byte and character
// indexes into the returned string do correspond to byte and character indexes
// into the buffer. Contrast with gtk_text_buffer_get_text(). Note that 0xFFFC
// can occur in normal text as well, so it is not a reliable indicator that a
// pixbuf or widget is in the buffer.
func (b textBuffer) Slice(start *TextIter, end *TextIter, includeHiddenChars bool) string {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))
	if includeHiddenChars {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_get_slice(_arg0, _arg1, _arg2, _arg3)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// StartIter: initialized @iter with the first position in the text buffer. This
// is the same as using gtk_text_buffer_get_iter_at_offset() to get the iter at
// character offset 0.
func (b textBuffer) StartIter() TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _iter TextIter

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	C.gtk_text_buffer_get_start_iter(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)))

	return _iter
}

// TagTable: get the TextTagTable associated with this buffer.
func (b textBuffer) TagTable() TextTagTable {
	var _arg0 *C.GtkTextBuffer   // out
	var _cret *C.GtkTextTagTable // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_text_buffer_get_tag_table(_arg0)

	var _textTagTable TextTagTable // out

	_textTagTable = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextTagTable)

	return _textTagTable
}

// Text returns the text in the range [@start,@end). Excludes undisplayed text
// (text marked with tags that set the invisibility attribute) if
// @include_hidden_chars is false. Does not include characters representing
// embedded images, so byte and character indexes into the returned string do
// not correspond to byte and character indexes into the buffer. Contrast with
// gtk_text_buffer_get_slice().
func (b textBuffer) Text(start *TextIter, end *TextIter, includeHiddenChars bool) string {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))
	if includeHiddenChars {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_get_text(_arg0, _arg1, _arg2, _arg3)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Insert inserts @len bytes of @text at position @iter. If @len is -1, @text
// must be nul-terminated and will be inserted in its entirety. Emits the
// “insert-text” signal; insertion actually occurs in the default handler for
// the signal. @iter is invalidated when insertion occurs (because the buffer
// contents change), but the default signal handler revalidates it to point to
// the end of the inserted text.
func (b textBuffer) Insert(iter *TextIter, text string, len int) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.gchar         // out
	var _arg3 C.gint           // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.gint)(len)

	C.gtk_text_buffer_insert(_arg0, _arg1, _arg2, _arg3)
}

// InsertAtCursor: simply calls gtk_text_buffer_insert(), using the current
// cursor position as the insertion point.
func (b textBuffer) InsertAtCursor(text string, len int) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.gchar         // out
	var _arg2 C.gint           // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gint)(len)

	C.gtk_text_buffer_insert_at_cursor(_arg0, _arg1, _arg2)
}

// InsertChildAnchor inserts a child widget anchor into the text buffer at
// @iter. The anchor will be counted as one character in character counts, and
// when obtaining the buffer contents as a string, will be represented by the
// Unicode “object replacement character” 0xFFFC. Note that the “slice” variants
// for obtaining portions of the buffer as a string include this character for
// child anchors, but the “text” variants do not. E.g. see
// gtk_text_buffer_get_slice() and gtk_text_buffer_get_text(). Consider
// gtk_text_buffer_create_child_anchor() as a more convenient alternative to
// this function. The buffer will add a reference to the anchor, so you can
// unref it after insertion.
func (b textBuffer) InsertChildAnchor(iter *TextIter, anchor TextChildAnchor) {
	var _arg0 *C.GtkTextBuffer      // out
	var _arg1 *C.GtkTextIter        // out
	var _arg2 *C.GtkTextChildAnchor // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.GtkTextChildAnchor)(unsafe.Pointer(anchor.Native()))

	C.gtk_text_buffer_insert_child_anchor(_arg0, _arg1, _arg2)
}

// InsertInteractive: like gtk_text_buffer_insert(), but the insertion will not
// occur if @iter is at a non-editable location in the buffer. Usually you want
// to prevent insertions at ineditable locations if the insertion results from a
// user action (is interactive).
//
// @default_editable indicates the editability of text that doesn't have a tag
// affecting editability applied to it. Typically the result of
// gtk_text_view_get_editable() is appropriate here.
func (b textBuffer) InsertInteractive(iter *TextIter, text string, len int, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.gchar         // out
	var _arg3 C.gint           // out
	var _arg4 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.gint)(len)
	if defaultEditable {
		_arg4 = C.TRUE
	}

	_cret = C.gtk_text_buffer_insert_interactive(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InsertInteractiveAtCursor calls gtk_text_buffer_insert_interactive() at the
// cursor position.
//
// @default_editable indicates the editability of text that doesn't have a tag
// affecting editability applied to it. Typically the result of
// gtk_text_view_get_editable() is appropriate here.
func (b textBuffer) InsertInteractiveAtCursor(text string, len int, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.gchar         // out
	var _arg2 C.gint           // out
	var _arg3 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gint)(len)
	if defaultEditable {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_insert_interactive_at_cursor(_arg0, _arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InsertMarkup inserts the text in @markup at position @iter. @markup will be
// inserted in its entirety and must be nul-terminated and valid UTF-8. Emits
// the TextBuffer::insert-text signal, possibly multiple times; insertion
// actually occurs in the default handler for the signal. @iter will point to
// the end of the inserted text on return.
func (b textBuffer) InsertMarkup(iter *TextIter, markup string, len int) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.gchar         // out
	var _arg3 C.gint           // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.gchar)(C.CString(markup))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.gint)(len)

	C.gtk_text_buffer_insert_markup(_arg0, _arg1, _arg2, _arg3)
}

// InsertPixbuf inserts an image into the text buffer at @iter. The image will
// be counted as one character in character counts, and when obtaining the
// buffer contents as a string, will be represented by the Unicode “object
// replacement character” 0xFFFC. Note that the “slice” variants for obtaining
// portions of the buffer as a string include this character for pixbufs, but
// the “text” variants do not. e.g. see gtk_text_buffer_get_slice() and
// gtk_text_buffer_get_text().
func (b textBuffer) InsertPixbuf(iter *TextIter, pixbuf gdkpixbuf.Pixbuf) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GdkPixbuf     // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	C.gtk_text_buffer_insert_pixbuf(_arg0, _arg1, _arg2)
}

// InsertRange copies text, tags, and pixbufs between @start and @end (the order
// of @start and @end doesn’t matter) and inserts the copy at @iter. Used
// instead of simply getting/inserting text because it preserves images and
// tags. If @start and @end are in a different buffer from @buffer, the two
// buffers must share the same tag table.
//
// Implemented via emissions of the insert_text and apply_tag signals, so expect
// those.
func (b textBuffer) InsertRange(iter *TextIter, start *TextIter, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_insert_range(_arg0, _arg1, _arg2, _arg3)
}

// InsertRangeInteractive: same as gtk_text_buffer_insert_range(), but does
// nothing if the insertion point isn’t editable. The @default_editable
// parameter indicates whether the text is editable at @iter if no tags
// enclosing @iter affect editability. Typically the result of
// gtk_text_view_get_editable() is appropriate here.
func (b textBuffer) InsertRangeInteractive(iter *TextIter, start *TextIter, end *TextIter, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out
	var _arg4 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))
	if defaultEditable {
		_arg4 = C.TRUE
	}

	_cret = C.gtk_text_buffer_insert_range_interactive(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MoveMark moves @mark to the new location @where. Emits the
// TextBuffer::mark-set signal as notification of the move.
func (b textBuffer) MoveMark(mark TextMark, where *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextMark   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))

	C.gtk_text_buffer_move_mark(_arg0, _arg1, _arg2)
}

// MoveMarkByName moves the mark named @name (which must exist) to location
// @where. See gtk_text_buffer_move_mark() for details.
func (b textBuffer) MoveMarkByName(name string, where *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))

	C.gtk_text_buffer_move_mark_by_name(_arg0, _arg1, _arg2)
}

// PasteClipboard pastes the contents of a clipboard. If @override_location is
// nil, the pasted text will be inserted at the cursor position, or the buffer
// selection will be replaced if the selection is non-empty.
//
// Note: pasting is asynchronous, that is, we’ll ask for the paste data and
// return, and at some point later after the main loop runs, the paste data will
// be inserted.
func (b textBuffer) PasteClipboard(clipboard Clipboard, overrideLocation *TextIter, defaultEditable bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkClipboard  // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkClipboard)(unsafe.Pointer(clipboard.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(overrideLocation.Native()))
	if defaultEditable {
		_arg3 = C.TRUE
	}

	C.gtk_text_buffer_paste_clipboard(_arg0, _arg1, _arg2, _arg3)
}

// PlaceCursor: this function moves the “insert” and “selection_bound” marks
// simultaneously. If you move them to the same place in two steps with
// gtk_text_buffer_move_mark(), you will temporarily select a region in between
// their old and new locations, which can be pretty inefficient since the
// temporarily-selected region will force stuff to be recalculated. This
// function moves them as a unit, which can be optimized.
func (b textBuffer) PlaceCursor(where *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))

	C.gtk_text_buffer_place_cursor(_arg0, _arg1)
}

// RegisterDeserializeTagset: this function registers GTK+’s internal rich text
// serialization format with the passed @buffer. See
// gtk_text_buffer_register_serialize_tagset() for details.
func (b textBuffer) RegisterDeserializeTagset(tagsetName string) *gdk.Atom {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.gchar         // out
	var _cret C.GdkAtom        // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(tagsetName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_text_buffer_register_deserialize_tagset(_arg0, _arg1)

	var _atom *gdk.Atom // out

	_atom = gdk.WrapAtom(unsafe.Pointer(_cret))

	return _atom
}

// RegisterSerializeTagset: this function registers GTK+’s internal rich text
// serialization format with the passed @buffer. The internal format does not
// comply to any standard rich text format and only works between TextBuffer
// instances. It is capable of serializing all of a text buffer’s tags and
// embedded pixbufs.
//
// This function is just a wrapper around
// gtk_text_buffer_register_serialize_format(). The mime type used for
// registering is “application/x-gtk-text-buffer-rich-text”, or
// “application/x-gtk-text-buffer-rich-text;format=@tagset_name” if a
// @tagset_name was passed.
//
// The @tagset_name can be used to restrict the transfer of rich text to buffers
// with compatible sets of tags, in order to avoid unknown tags from being
// pasted. It is probably the common case to pass an identifier != nil here,
// since the nil tagset requires the receiving buffer to deal with with pasting
// of arbitrary tags.
func (b textBuffer) RegisterSerializeTagset(tagsetName string) *gdk.Atom {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.gchar         // out
	var _cret C.GdkAtom        // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(tagsetName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_text_buffer_register_serialize_tagset(_arg0, _arg1)

	var _atom *gdk.Atom // out

	_atom = gdk.WrapAtom(unsafe.Pointer(_cret))

	return _atom
}

// RemoveAllTags removes all tags in the range between @start and @end. Be
// careful with this function; it could remove tags added in code unrelated to
// the code you’re currently writing. That is, using this function is probably a
// bad idea if you have two or more unrelated code sections that add tags.
func (b textBuffer) RemoveAllTags(start *TextIter, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_remove_all_tags(_arg0, _arg1, _arg2)
}

// RemoveSelectionClipboard removes a Clipboard added with
// gtk_text_buffer_add_selection_clipboard().
func (b textBuffer) RemoveSelectionClipboard(clipboard Clipboard) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkClipboard  // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkClipboard)(unsafe.Pointer(clipboard.Native()))

	C.gtk_text_buffer_remove_selection_clipboard(_arg0, _arg1)
}

// RemoveTag emits the “remove-tag” signal. The default handler for the signal
// removes all occurrences of @tag from the given range. @start and @end don’t
// have to be in order.
func (b textBuffer) RemoveTag(tag TextTag, start *TextIter, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextTag    // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_remove_tag(_arg0, _arg1, _arg2, _arg3)
}

// RemoveTagByName calls gtk_text_tag_table_lookup() on the buffer’s tag table
// to get a TextTag, then calls gtk_text_buffer_remove_tag().
func (b textBuffer) RemoveTagByName(name string, start *TextIter, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_remove_tag_by_name(_arg0, _arg1, _arg2, _arg3)
}

// SelectRange: this function moves the “insert” and “selection_bound” marks
// simultaneously. If you move them in two steps with
// gtk_text_buffer_move_mark(), you will temporarily select a region in between
// their old and new locations, which can be pretty inefficient since the
// temporarily-selected region will force stuff to be recalculated. This
// function moves them as a unit, which can be optimized.
func (b textBuffer) SelectRange(ins *TextIter, bound *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(ins.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(bound.Native()))

	C.gtk_text_buffer_select_range(_arg0, _arg1, _arg2)
}

// SetModified: used to keep track of whether the buffer has been modified since
// the last time it was saved. Whenever the buffer is saved to disk, call
// gtk_text_buffer_set_modified (@buffer, FALSE). When the buffer is modified,
// it will automatically toggled on the modified bit again. When the modified
// bit flips, the buffer emits the TextBuffer::modified-changed signal.
func (b textBuffer) SetModified(setting bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_text_buffer_set_modified(_arg0, _arg1)
}

// SetText deletes current contents of @buffer, and inserts @text instead. If
// @len is -1, @text must be nul-terminated. @text must be valid UTF-8.
func (b textBuffer) SetText(text string, len int) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.gchar         // out
	var _arg2 C.gint           // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gint)(len)

	C.gtk_text_buffer_set_text(_arg0, _arg1, _arg2)
}

// UnregisterDeserializeFormat: this function unregisters a rich text format
// that was previously registered using
// gtk_text_buffer_register_deserialize_format() or
// gtk_text_buffer_register_deserialize_tagset().
func (b textBuffer) UnregisterDeserializeFormat(format *gdk.Atom) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GdkAtom        // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (C.GdkAtom)(unsafe.Pointer(format.Native()))

	C.gtk_text_buffer_unregister_deserialize_format(_arg0, _arg1)
}

// UnregisterSerializeFormat: this function unregisters a rich text format that
// was previously registered using gtk_text_buffer_register_serialize_format()
// or gtk_text_buffer_register_serialize_tagset()
func (b textBuffer) UnregisterSerializeFormat(format *gdk.Atom) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GdkAtom        // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (C.GdkAtom)(unsafe.Pointer(format.Native()))

	C.gtk_text_buffer_unregister_serialize_format(_arg0, _arg1)
}

type TextCellAccessible interface {
	RendererCellAccessible
}

// textCellAccessible implements the TextCellAccessible class.
type textCellAccessible struct {
	RendererCellAccessible
}

var _ TextCellAccessible = (*textCellAccessible)(nil)

// WrapTextCellAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextCellAccessible(obj *externglib.Object) TextCellAccessible {
	return textCellAccessible{
		RendererCellAccessible: WrapRendererCellAccessible(obj),
	}
}

func marshalTextCellAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextCellAccessible(obj), nil
}

// TextChildAnchor: a TextChildAnchor is a spot in the buffer where child
// widgets can be “anchored” (inserted inline, as if they were characters). The
// anchor can have multiple widgets anchored, to allow for multiple views.
type TextChildAnchor interface {
	gextras.Objector

	// Deleted determines whether a child anchor has been deleted from the
	// buffer. Keep in mind that the child anchor will be unreferenced when
	// removed from the buffer, so you need to hold your own reference (with
	// g_object_ref()) if you plan to use this function — otherwise all deleted
	// child anchors will also be finalized.
	Deleted() bool
}

// textChildAnchor implements the TextChildAnchor class.
type textChildAnchor struct {
	gextras.Objector
}

var _ TextChildAnchor = (*textChildAnchor)(nil)

// WrapTextChildAnchor wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextChildAnchor(obj *externglib.Object) TextChildAnchor {
	return textChildAnchor{
		Objector: obj,
	}
}

func marshalTextChildAnchor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextChildAnchor(obj), nil
}

// NewTextChildAnchor creates a new TextChildAnchor. Usually you would then
// insert it into a TextBuffer with gtk_text_buffer_insert_child_anchor(). To
// perform the creation and insertion in one step, use the convenience function
// gtk_text_buffer_create_child_anchor().
func NewTextChildAnchor() TextChildAnchor {
	var _cret *C.GtkTextChildAnchor // in

	_cret = C.gtk_text_child_anchor_new()

	var _textChildAnchor TextChildAnchor // out

	_textChildAnchor = WrapTextChildAnchor(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _textChildAnchor
}

// Deleted determines whether a child anchor has been deleted from the buffer.
// Keep in mind that the child anchor will be unreferenced when removed from the
// buffer, so you need to hold your own reference (with g_object_ref()) if you
// plan to use this function — otherwise all deleted child anchors will also be
// finalized.
func (a textChildAnchor) Deleted() bool {
	var _arg0 *C.GtkTextChildAnchor // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GtkTextChildAnchor)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_text_child_anchor_get_deleted(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TextMark: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
//
// A TextMark is like a bookmark in a text buffer; it preserves a position in
// the text. You can convert the mark to an iterator using
// gtk_text_buffer_get_iter_at_mark(). Unlike iterators, marks remain valid
// across buffer mutations, because their behavior is defined when text is
// inserted or deleted. When text containing a mark is deleted, the mark remains
// in the position originally occupied by the deleted text. When text is
// inserted at a mark, a mark with “left gravity” will be moved to the beginning
// of the newly-inserted text, and a mark with “right gravity” will be moved to
// the end.
//
// Note that “left” and “right” here refer to logical direction (left is the
// toward the start of the buffer); in some languages such as Hebrew the
// logically-leftmost text is not actually on the left when displayed.
//
// Marks are reference counted, but the reference count only controls the
// validity of the memory; marks can be deleted from the buffer at any time with
// gtk_text_buffer_delete_mark(). Once deleted from the buffer, a mark is
// essentially useless.
//
// Marks optionally have names; these can be convenient to avoid passing the
// TextMark object around.
//
// Marks are typically created using the gtk_text_buffer_create_mark() function.
type TextMark interface {
	gextras.Objector

	// Buffer gets the buffer this mark is located inside, or nil if the mark is
	// deleted.
	Buffer() TextBuffer
	// Deleted returns true if the mark has been removed from its buffer with
	// gtk_text_buffer_delete_mark(). See gtk_text_buffer_add_mark() for a way
	// to add it to a buffer again.
	Deleted() bool
	// LeftGravity determines whether the mark has left gravity.
	LeftGravity() bool
	// Name returns the mark name; returns NULL for anonymous marks.
	Name() string
	// Visible returns true if the mark is visible (i.e. a cursor is displayed
	// for it).
	Visible() bool
	// SetVisible sets the visibility of @mark; the insertion point is normally
	// visible, i.e. you can see it as a vertical bar. Also, the text widget
	// uses a visible mark to indicate where a drop will occur when
	// dragging-and-dropping text. Most other marks are not visible. Marks are
	// not visible by default.
	SetVisible(setting bool)
}

// textMark implements the TextMark class.
type textMark struct {
	gextras.Objector
}

var _ TextMark = (*textMark)(nil)

// WrapTextMark wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextMark(obj *externglib.Object) TextMark {
	return textMark{
		Objector: obj,
	}
}

func marshalTextMark(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextMark(obj), nil
}

// NewTextMark creates a text mark. Add it to a buffer using
// gtk_text_buffer_add_mark(). If @name is nil, the mark is anonymous;
// otherwise, the mark can be retrieved by name using
// gtk_text_buffer_get_mark(). If a mark has left gravity, and text is inserted
// at the mark’s current location, the mark will be moved to the left of the
// newly-inserted text. If the mark has right gravity (@left_gravity = false),
// the mark will end up on the right of newly-inserted text. The standard
// left-to-right cursor is a mark with right gravity (when you type, the cursor
// stays on the right side of the text you’re typing).
func NewTextMark(name string, leftGravity bool) TextMark {
	var _arg1 *C.gchar       // out
	var _arg2 C.gboolean     // out
	var _cret *C.GtkTextMark // in

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	if leftGravity {
		_arg2 = C.TRUE
	}

	_cret = C.gtk_text_mark_new(_arg1, _arg2)

	var _textMark TextMark // out

	_textMark = WrapTextMark(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _textMark
}

// Buffer gets the buffer this mark is located inside, or nil if the mark is
// deleted.
func (m textMark) Buffer() TextBuffer {
	var _arg0 *C.GtkTextMark   // out
	var _cret *C.GtkTextBuffer // in

	_arg0 = (*C.GtkTextMark)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_text_mark_get_buffer(_arg0)

	var _textBuffer TextBuffer // out

	_textBuffer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextBuffer)

	return _textBuffer
}

// Deleted returns true if the mark has been removed from its buffer with
// gtk_text_buffer_delete_mark(). See gtk_text_buffer_add_mark() for a way to
// add it to a buffer again.
func (m textMark) Deleted() bool {
	var _arg0 *C.GtkTextMark // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextMark)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_text_mark_get_deleted(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LeftGravity determines whether the mark has left gravity.
func (m textMark) LeftGravity() bool {
	var _arg0 *C.GtkTextMark // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextMark)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_text_mark_get_left_gravity(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Name returns the mark name; returns NULL for anonymous marks.
func (m textMark) Name() string {
	var _arg0 *C.GtkTextMark // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GtkTextMark)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_text_mark_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Visible returns true if the mark is visible (i.e. a cursor is displayed for
// it).
func (m textMark) Visible() bool {
	var _arg0 *C.GtkTextMark // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextMark)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_text_mark_get_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetVisible sets the visibility of @mark; the insertion point is normally
// visible, i.e. you can see it as a vertical bar. Also, the text widget uses a
// visible mark to indicate where a drop will occur when dragging-and-dropping
// text. Most other marks are not visible. Marks are not visible by default.
func (m textMark) SetVisible(setting bool) {
	var _arg0 *C.GtkTextMark // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextMark)(unsafe.Pointer(m.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_text_mark_set_visible(_arg0, _arg1)
}

// TextTag: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
//
// Tags should be in the TextTagTable for a given TextBuffer before using them
// with that buffer.
//
// gtk_text_buffer_create_tag() is the best way to create tags. See “gtk3-demo”
// for numerous examples.
//
// For each property of TextTag, there is a “set” property, e.g. “font-set”
// corresponds to “font”. These “set” properties reflect whether a property has
// been set or not. They are maintained by GTK+ and you should not set them
// independently.
type TextTag interface {
	gextras.Objector

	// Changed emits the TextTagTable::tag-changed signal on the TextTagTable
	// where the tag is included.
	//
	// The signal is already emitted when setting a TextTag property. This
	// function is useful for a TextTag subclass.
	Changed(sizeChanged bool)
	// Priority: get the tag priority.
	Priority() int
	// SetPriority sets the priority of a TextTag. Valid priorities start at 0
	// and go to one less than gtk_text_tag_table_get_size(). Each tag in a
	// table has a unique priority; setting the priority of one tag shifts the
	// priorities of all the other tags in the table to maintain a unique
	// priority for each tag. Higher priority tags “win” if two tags both set
	// the same text attribute. When adding a tag to a tag table, it will be
	// assigned the highest priority in the table by default; so normally the
	// precedence of a set of tags is the order in which they were added to the
	// table, or created with gtk_text_buffer_create_tag(), which adds the tag
	// to the buffer’s table automatically.
	SetPriority(priority int)
}

// textTag implements the TextTag class.
type textTag struct {
	gextras.Objector
}

var _ TextTag = (*textTag)(nil)

// WrapTextTag wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextTag(obj *externglib.Object) TextTag {
	return textTag{
		Objector: obj,
	}
}

func marshalTextTag(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextTag(obj), nil
}

// NewTextTag creates a TextTag. Configure the tag using object arguments, i.e.
// using g_object_set().
func NewTextTag(name string) TextTag {
	var _arg1 *C.gchar      // out
	var _cret *C.GtkTextTag // in

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_text_tag_new(_arg1)

	var _textTag TextTag // out

	_textTag = WrapTextTag(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _textTag
}

// Changed emits the TextTagTable::tag-changed signal on the TextTagTable where
// the tag is included.
//
// The signal is already emitted when setting a TextTag property. This function
// is useful for a TextTag subclass.
func (t textTag) Changed(sizeChanged bool) {
	var _arg0 *C.GtkTextTag // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkTextTag)(unsafe.Pointer(t.Native()))
	if sizeChanged {
		_arg1 = C.TRUE
	}

	C.gtk_text_tag_changed(_arg0, _arg1)
}

// Priority: get the tag priority.
func (t textTag) Priority() int {
	var _arg0 *C.GtkTextTag // out
	var _cret C.gint        // in

	_arg0 = (*C.GtkTextTag)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_tag_get_priority(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// SetPriority sets the priority of a TextTag. Valid priorities start at 0 and
// go to one less than gtk_text_tag_table_get_size(). Each tag in a table has a
// unique priority; setting the priority of one tag shifts the priorities of all
// the other tags in the table to maintain a unique priority for each tag.
// Higher priority tags “win” if two tags both set the same text attribute. When
// adding a tag to a tag table, it will be assigned the highest priority in the
// table by default; so normally the precedence of a set of tags is the order in
// which they were added to the table, or created with
// gtk_text_buffer_create_tag(), which adds the tag to the buffer’s table
// automatically.
func (t textTag) SetPriority(priority int) {
	var _arg0 *C.GtkTextTag // out
	var _arg1 C.gint        // out

	_arg0 = (*C.GtkTextTag)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(priority)

	C.gtk_text_tag_set_priority(_arg0, _arg1)
}

// TextTagTable: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
//
//
// GtkTextTagTables as GtkBuildable
//
// The GtkTextTagTable implementation of the GtkBuildable interface supports
// adding tags by specifying “tag” as the “type” attribute of a <child> element.
//
// An example of a UI definition fragment specifying tags:
//
//    <object class="GtkTextTagTable">
//     <child type="tag">
//       <object class="GtkTextTag"/>
//     </child>
//    </object>
type TextTagTable interface {
	gextras.Objector
	Buildable

	// Add: add a tag to the table. The tag is assigned the highest priority in
	// the table.
	//
	// @tag must not be in a tag table already, and may not have the same name
	// as an already-added tag.
	Add(tag TextTag) bool
	// Size returns the size of the table (number of tags)
	Size() int
	// Lookup: look up a named tag.
	Lookup(name string) TextTag
	// Remove: remove a tag from the table. If a TextBuffer has @table as its
	// tag table, the tag is removed from the buffer. The table’s reference to
	// the tag is removed, so the tag will end up destroyed if you don’t have a
	// reference to it.
	Remove(tag TextTag)
}

// textTagTable implements the TextTagTable class.
type textTagTable struct {
	gextras.Objector
	Buildable
}

var _ TextTagTable = (*textTagTable)(nil)

// WrapTextTagTable wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextTagTable(obj *externglib.Object) TextTagTable {
	return textTagTable{
		Objector:  obj,
		Buildable: WrapBuildable(obj),
	}
}

func marshalTextTagTable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextTagTable(obj), nil
}

// NewTextTagTable creates a new TextTagTable. The table contains no tags by
// default.
func NewTextTagTable() TextTagTable {
	var _cret *C.GtkTextTagTable // in

	_cret = C.gtk_text_tag_table_new()

	var _textTagTable TextTagTable // out

	_textTagTable = WrapTextTagTable(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _textTagTable
}

// Add: add a tag to the table. The tag is assigned the highest priority in the
// table.
//
// @tag must not be in a tag table already, and may not have the same name as an
// already-added tag.
func (t textTagTable) Add(tag TextTag) bool {
	var _arg0 *C.GtkTextTagTable // out
	var _arg1 *C.GtkTextTag      // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkTextTagTable)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	_cret = C.gtk_text_tag_table_add(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Size returns the size of the table (number of tags)
func (t textTagTable) Size() int {
	var _arg0 *C.GtkTextTagTable // out
	var _cret C.gint             // in

	_arg0 = (*C.GtkTextTagTable)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_tag_table_get_size(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Lookup: look up a named tag.
func (t textTagTable) Lookup(name string) TextTag {
	var _arg0 *C.GtkTextTagTable // out
	var _arg1 *C.gchar           // out
	var _cret *C.GtkTextTag      // in

	_arg0 = (*C.GtkTextTagTable)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_text_tag_table_lookup(_arg0, _arg1)

	var _textTag TextTag // out

	_textTag = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextTag)

	return _textTag
}

// Remove: remove a tag from the table. If a TextBuffer has @table as its tag
// table, the tag is removed from the buffer. The table’s reference to the tag
// is removed, so the tag will end up destroyed if you don’t have a reference to
// it.
func (t textTagTable) Remove(tag TextTag) {
	var _arg0 *C.GtkTextTagTable // out
	var _arg1 *C.GtkTextTag      // out

	_arg0 = (*C.GtkTextTagTable)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	C.gtk_text_tag_table_remove(_arg0, _arg1)
}

// TextView: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
//
// CSS nodes
//
//    textview.view
//    ├── border.top
//    ├── border.left
//    ├── text
//    │   ╰── [selection]
//    ├── border.right
//    ├── border.bottom
//    ╰── [window.popup]
//
// GtkTextView has a main css node with name textview and style class .view, and
// subnodes for each of the border windows, and the main text area, with names
// border and text, respectively. The border nodes each get one of the style
// classes .left, .right, .top or .bottom.
//
// A node representing the selection will appear below the text node.
//
// If a context menu is opened, the window node will appear as a subnode of the
// main node.
type TextView interface {
	Container
	Buildable
	Scrollable

	// AddChildAtAnchor adds a child widget in the text buffer, at the given
	// @anchor.
	AddChildAtAnchor(child Widget, anchor TextChildAnchor)
	// AddChildInWindow adds a child at fixed coordinates in one of the text
	// widget's windows.
	//
	// The window must have nonzero size (see
	// gtk_text_view_set_border_window_size()). Note that the child coordinates
	// are given relative to scrolling. When placing a child in
	// K_TEXT_WINDOW_WIDGET, scrolling is irrelevant, the child floats above all
	// scrollable areas. But when placing a child in one of the scrollable
	// windows (border windows or text window) it will move with the scrolling
	// as needed.
	AddChildInWindow(child Widget, whichWindow TextWindowType, xpos int, ypos int)
	// BackwardDisplayLine moves the given @iter backward by one display
	// (wrapped) line. A display line is different from a paragraph. Paragraphs
	// are separated by newlines or other paragraph separator characters.
	// Display lines are created by line-wrapping a paragraph. If wrapping is
	// turned off, display lines and paragraphs will be the same. Display lines
	// are divided differently for each view, since they depend on the view’s
	// width; paragraphs are the same in all views, since they depend on the
	// contents of the TextBuffer.
	BackwardDisplayLine(iter *TextIter) bool
	// BackwardDisplayLineStart moves the given @iter backward to the next
	// display line start. A display line is different from a paragraph.
	// Paragraphs are separated by newlines or other paragraph separator
	// characters. Display lines are created by line-wrapping a paragraph. If
	// wrapping is turned off, display lines and paragraphs will be the same.
	// Display lines are divided differently for each view, since they depend on
	// the view’s width; paragraphs are the same in all views, since they depend
	// on the contents of the TextBuffer.
	BackwardDisplayLineStart(iter *TextIter) bool
	// BufferToWindowCoords converts coordinate (@buffer_x, @buffer_y) to
	// coordinates for the window @win, and stores the result in (@window_x,
	// @window_y).
	//
	// Note that you can’t convert coordinates for a nonexisting window (see
	// gtk_text_view_set_border_window_size()).
	BufferToWindowCoords(win TextWindowType, bufferX int, bufferY int) (windowX int, windowY int)
	// ForwardDisplayLine moves the given @iter forward by one display (wrapped)
	// line. A display line is different from a paragraph. Paragraphs are
	// separated by newlines or other paragraph separator characters. Display
	// lines are created by line-wrapping a paragraph. If wrapping is turned
	// off, display lines and paragraphs will be the same. Display lines are
	// divided differently for each view, since they depend on the view’s width;
	// paragraphs are the same in all views, since they depend on the contents
	// of the TextBuffer.
	ForwardDisplayLine(iter *TextIter) bool
	// ForwardDisplayLineEnd moves the given @iter forward to the next display
	// line end. A display line is different from a paragraph. Paragraphs are
	// separated by newlines or other paragraph separator characters. Display
	// lines are created by line-wrapping a paragraph. If wrapping is turned
	// off, display lines and paragraphs will be the same. Display lines are
	// divided differently for each view, since they depend on the view’s width;
	// paragraphs are the same in all views, since they depend on the contents
	// of the TextBuffer.
	ForwardDisplayLineEnd(iter *TextIter) bool
	// AcceptsTab returns whether pressing the Tab key inserts a tab characters.
	// gtk_text_view_set_accepts_tab().
	AcceptsTab() bool
	// BorderWindowSize gets the width of the specified border window. See
	// gtk_text_view_set_border_window_size().
	BorderWindowSize(typ TextWindowType) int
	// BottomMargin gets the bottom margin for text in the @text_view.
	BottomMargin() int
	// Buffer returns the TextBuffer being displayed by this text view. The
	// reference count on the buffer is not incremented; the caller of this
	// function won’t own a new reference.
	Buffer() TextBuffer
	// CursorLocations: given an @iter within a text layout, determine the
	// positions of the strong and weak cursors if the insertion point is at
	// that iterator. The position of each cursor is stored as a zero-width
	// rectangle. The strong cursor location is the location where characters of
	// the directionality equal to the base direction of the paragraph are
	// inserted. The weak cursor location is the location where characters of
	// the directionality opposite to the base direction of the paragraph are
	// inserted.
	//
	// If @iter is nil, the actual cursor position is used.
	//
	// Note that if @iter happens to be the actual cursor position, and there is
	// currently an IM preedit sequence being entered, the returned locations
	// will be adjusted to account for the preedit cursor’s offset within the
	// preedit sequence.
	//
	// The rectangle position is in buffer coordinates; use
	// gtk_text_view_buffer_to_window_coords() to convert these coordinates to
	// coordinates for one of the windows in the text view.
	CursorLocations(iter *TextIter) (strong gdk.Rectangle, weak gdk.Rectangle)
	// CursorVisible: find out whether the cursor should be displayed.
	CursorVisible() bool
	// DefaultAttributes obtains a copy of the default text attributes. These
	// are the attributes used for text unless a tag overrides them. You’d
	// typically pass the default attributes in to
	// gtk_text_iter_get_attributes() in order to get the attributes in effect
	// at a given text position.
	//
	// The return value is a copy owned by the caller of this function, and
	// should be freed with gtk_text_attributes_unref().
	DefaultAttributes() *TextAttributes
	// Editable returns the default editability of the TextView. Tags in the
	// buffer may override this setting for some ranges of text.
	Editable() bool
	// HAdjustment gets the horizontal-scrolling Adjustment.
	HAdjustment() Adjustment
	// Indent gets the default indentation of paragraphs in @text_view. Tags in
	// the view’s buffer may override the default. The indentation may be
	// negative.
	Indent() int
	// InputHints gets the value of the TextView:input-hints property.
	InputHints() InputHints
	// InputPurpose gets the value of the TextView:input-purpose property.
	InputPurpose() InputPurpose
	// IterAtLocation retrieves the iterator at buffer coordinates @x and @y.
	// Buffer coordinates are coordinates for the entire buffer, not just the
	// currently-displayed portion. If you have coordinates from an event, you
	// have to convert those to buffer coordinates with
	// gtk_text_view_window_to_buffer_coords().
	IterAtLocation(x int, y int) (TextIter, bool)
	// IterAtPosition retrieves the iterator pointing to the character at buffer
	// coordinates @x and @y. Buffer coordinates are coordinates for the entire
	// buffer, not just the currently-displayed portion. If you have coordinates
	// from an event, you have to convert those to buffer coordinates with
	// gtk_text_view_window_to_buffer_coords().
	//
	// Note that this is different from gtk_text_view_get_iter_at_location(),
	// which returns cursor locations, i.e. positions between characters.
	IterAtPosition(x int, y int) (TextIter, int, bool)
	// IterLocation gets a rectangle which roughly contains the character at
	// @iter. The rectangle position is in buffer coordinates; use
	// gtk_text_view_buffer_to_window_coords() to convert these coordinates to
	// coordinates for one of the windows in the text view.
	IterLocation(iter *TextIter) gdk.Rectangle
	// Justification gets the default justification of paragraphs in @text_view.
	// Tags in the buffer may override the default.
	Justification() Justification
	// LeftMargin gets the default left margin size of paragraphs in the
	// @text_view. Tags in the buffer may override the default.
	LeftMargin() int
	// LineAtY gets the TextIter at the start of the line containing the
	// coordinate @y. @y is in buffer coordinates, convert from window
	// coordinates with gtk_text_view_window_to_buffer_coords(). If non-nil,
	// @line_top will be filled with the coordinate of the top edge of the line.
	LineAtY(y int) (TextIter, int)
	// LineYrange gets the y coordinate of the top of the line containing @iter,
	// and the height of the line. The coordinate is a buffer coordinate;
	// convert to window coordinates with
	// gtk_text_view_buffer_to_window_coords().
	LineYrange(iter *TextIter) (y int, height int)
	// Monospace gets the value of the TextView:monospace property.
	Monospace() bool
	// Overwrite returns whether the TextView is in overwrite mode or not.
	Overwrite() bool
	// PixelsAboveLines gets the default number of pixels to put above
	// paragraphs. Adding this function with
	// gtk_text_view_get_pixels_below_lines() is equal to the line space between
	// each paragraph.
	PixelsAboveLines() int
	// PixelsBelowLines gets the value set by
	// gtk_text_view_set_pixels_below_lines().
	//
	// The line space is the sum of the value returned by this function and the
	// value returned by gtk_text_view_get_pixels_above_lines().
	PixelsBelowLines() int
	// PixelsInsideWrap gets the value set by
	// gtk_text_view_set_pixels_inside_wrap().
	PixelsInsideWrap() int
	// RightMargin gets the default right margin for text in @text_view. Tags in
	// the buffer may override the default.
	RightMargin() int
	// Tabs gets the default tabs for @text_view. Tags in the buffer may
	// override the defaults. The returned array will be nil if “standard”
	// (8-space) tabs are used. Free the return value with
	// pango_tab_array_free().
	Tabs() *pango.TabArray
	// TopMargin gets the top margin for text in the @text_view.
	TopMargin() int
	// VAdjustment gets the vertical-scrolling Adjustment.
	VAdjustment() Adjustment
	// VisibleRect fills @visible_rect with the currently-visible region of the
	// buffer, in buffer coordinates. Convert to window coordinates with
	// gtk_text_view_buffer_to_window_coords().
	VisibleRect() gdk.Rectangle
	// Window retrieves the Window corresponding to an area of the text view;
	// possible windows include the overall widget window, child windows on the
	// left, right, top, bottom, and the window that displays the text buffer.
	// Windows are nil and nonexistent if their width or height is 0, and are
	// nonexistent before the widget has been realized.
	Window(win TextWindowType) gdk.Window
	// WindowType: usually used to find out which window an event corresponds
	// to.
	//
	// If you connect to an event signal on @text_view, this function should be
	// called on `event->window` to see which window it was.
	WindowType(window gdk.Window) TextWindowType
	// WrapMode gets the line wrapping for the view.
	WrapMode() WrapMode
	// ImContextFilterKeypress: allow the TextView input method to internally
	// handle key press and release events. If this function returns true, then
	// no further processing should be done for this key event. See
	// gtk_im_context_filter_keypress().
	//
	// Note that you are expected to call this function from your handler when
	// overriding key event handling. This is needed in the case when you need
	// to insert your own key handling between the input method and the default
	// key event handling of the TextView.
	//
	//    static gboolean
	//    gtk_foo_bar_key_press_event (GtkWidget   *widget,
	//                                 GdkEventKey *event)
	//    {
	//      guint keyval;
	//
	//      gdk_event_get_keyval ((GdkEvent*)event, &keyval);
	//
	//      if (keyval == GDK_KEY_Return || keyval == GDK_KEY_KP_Enter)
	//        {
	//          if (gtk_text_view_im_context_filter_keypress (GTK_TEXT_VIEW (widget), event))
	//            return TRUE;
	//        }
	//
	//      // Do some stuff
	//
	//      return GTK_WIDGET_CLASS (gtk_foo_bar_parent_class)->key_press_event (widget, event);
	//    }
	ImContextFilterKeypress(event *gdk.EventKey) bool
	// MoveChild updates the position of a child, as for
	// gtk_text_view_add_child_in_window().
	MoveChild(child Widget, xpos int, ypos int)
	// MoveMarkOnscreen moves a mark within the buffer so that it's located
	// within the currently-visible text area.
	MoveMarkOnscreen(mark TextMark) bool
	// MoveVisually: move the iterator a given number of characters visually,
	// treating it as the strong cursor position. If @count is positive, then
	// the new strong cursor position will be @count positions to the right of
	// the old cursor position. If @count is negative then the new strong cursor
	// position will be @count positions to the left of the old cursor position.
	//
	// In the presence of bi-directional text, the correspondence between
	// logical and visual order will depend on the direction of the current run,
	// and there may be jumps when the cursor is moved off of the end of a run.
	MoveVisually(iter *TextIter, count int) bool
	// PlaceCursorOnscreen moves the cursor to the currently visible region of
	// the buffer, it it isn’t there already.
	PlaceCursorOnscreen() bool
	// ResetCursorBlink ensures that the cursor is shown (i.e. not in an 'off'
	// blink interval) and resets the time that it will stay blinking (or
	// visible, in case blinking is disabled).
	//
	// This function should be called in response to user input (e.g. from
	// derived classes that override the textview's Widget::key-press-event
	// handler).
	ResetCursorBlink()
	// ResetImContext: reset the input method context of the text view if
	// needed.
	//
	// This can be necessary in the case where modifying the buffer would
	// confuse on-going input method behavior.
	ResetImContext()
	// ScrollMarkOnscreen scrolls @text_view the minimum distance such that
	// @mark is contained within the visible area of the widget.
	ScrollMarkOnscreen(mark TextMark)
	// ScrollToIter scrolls @text_view so that @iter is on the screen in the
	// position indicated by @xalign and @yalign. An alignment of 0.0 indicates
	// left or top, 1.0 indicates right or bottom, 0.5 means center. If
	// @use_align is false, the text scrolls the minimal distance to get the
	// mark onscreen, possibly not scrolling at all. The effective screen for
	// purposes of this function is reduced by a margin of size @within_margin.
	//
	// Note that this function uses the currently-computed height of the lines
	// in the text buffer. Line heights are computed in an idle handler; so this
	// function may not have the desired effect if it’s called before the height
	// computations. To avoid oddness, consider using
	// gtk_text_view_scroll_to_mark() which saves a point to be scrolled to
	// after line validation.
	ScrollToIter(iter *TextIter, withinMargin float64, useAlign bool, xalign float64, yalign float64) bool
	// ScrollToMark scrolls @text_view so that @mark is on the screen in the
	// position indicated by @xalign and @yalign. An alignment of 0.0 indicates
	// left or top, 1.0 indicates right or bottom, 0.5 means center. If
	// @use_align is false, the text scrolls the minimal distance to get the
	// mark onscreen, possibly not scrolling at all. The effective screen for
	// purposes of this function is reduced by a margin of size @within_margin.
	ScrollToMark(mark TextMark, withinMargin float64, useAlign bool, xalign float64, yalign float64)
	// SetAcceptsTab sets the behavior of the text widget when the Tab key is
	// pressed. If @accepts_tab is true, a tab character is inserted. If
	// @accepts_tab is false the keyboard focus is moved to the next widget in
	// the focus chain.
	SetAcceptsTab(acceptsTab bool)
	// SetBorderWindowSize sets the width of GTK_TEXT_WINDOW_LEFT or
	// GTK_TEXT_WINDOW_RIGHT, or the height of GTK_TEXT_WINDOW_TOP or
	// GTK_TEXT_WINDOW_BOTTOM. Automatically destroys the corresponding window
	// if the size is set to 0, and creates the window if the size is set to
	// non-zero. This function can only be used for the “border windows”, and it
	// won’t work with GTK_TEXT_WINDOW_WIDGET, GTK_TEXT_WINDOW_TEXT, or
	// GTK_TEXT_WINDOW_PRIVATE.
	SetBorderWindowSize(typ TextWindowType, size int)
	// SetBottomMargin sets the bottom margin for text in @text_view.
	//
	// Note that this function is confusingly named. In CSS terms, the value set
	// here is padding.
	SetBottomMargin(bottomMargin int)
	// SetBuffer sets @buffer as the buffer being displayed by @text_view. The
	// previous buffer displayed by the text view is unreferenced, and a
	// reference is added to @buffer. If you owned a reference to @buffer before
	// passing it to this function, you must remove that reference yourself;
	// TextView will not “adopt” it.
	SetBuffer(buffer TextBuffer)
	// SetCursorVisible toggles whether the insertion point should be displayed.
	// A buffer with no editable text probably shouldn’t have a visible cursor,
	// so you may want to turn the cursor off.
	//
	// Note that this property may be overridden by the
	// Settings:gtk-keynave-use-caret settings.
	SetCursorVisible(setting bool)
	// SetEditable sets the default editability of the TextView. You can
	// override this default setting with tags in the buffer, using the
	// “editable” attribute of tags.
	SetEditable(setting bool)
	// SetIndent sets the default indentation for paragraphs in @text_view. Tags
	// in the buffer may override the default.
	SetIndent(indent int)
	// SetInputHints sets the TextView:input-hints property, which allows input
	// methods to fine-tune their behaviour.
	SetInputHints(hints InputHints)
	// SetInputPurpose sets the TextView:input-purpose property which can be
	// used by on-screen keyboards and other input methods to adjust their
	// behaviour.
	SetInputPurpose(purpose InputPurpose)
	// SetJustification sets the default justification of text in @text_view.
	// Tags in the view’s buffer may override the default.
	SetJustification(justification Justification)
	// SetLeftMargin sets the default left margin for text in @text_view. Tags
	// in the buffer may override the default.
	//
	// Note that this function is confusingly named. In CSS terms, the value set
	// here is padding.
	SetLeftMargin(leftMargin int)
	// SetMonospace sets the TextView:monospace property, which indicates that
	// the text view should use monospace fonts.
	SetMonospace(monospace bool)
	// SetOverwrite changes the TextView overwrite mode.
	SetOverwrite(overwrite bool)
	// SetPixelsAboveLines sets the default number of blank pixels above
	// paragraphs in @text_view. Tags in the buffer for @text_view may override
	// the defaults.
	SetPixelsAboveLines(pixelsAboveLines int)
	// SetPixelsBelowLines sets the default number of pixels of blank space to
	// put below paragraphs in @text_view. May be overridden by tags applied to
	// @text_view’s buffer.
	SetPixelsBelowLines(pixelsBelowLines int)
	// SetPixelsInsideWrap sets the default number of pixels of blank space to
	// leave between display/wrapped lines within a paragraph. May be overridden
	// by tags in @text_view’s buffer.
	SetPixelsInsideWrap(pixelsInsideWrap int)
	// SetRightMargin sets the default right margin for text in the text view.
	// Tags in the buffer may override the default.
	//
	// Note that this function is confusingly named. In CSS terms, the value set
	// here is padding.
	SetRightMargin(rightMargin int)
	// SetTabs sets the default tab stops for paragraphs in @text_view. Tags in
	// the buffer may override the default.
	SetTabs(tabs *pango.TabArray)
	// SetTopMargin sets the top margin for text in @text_view.
	//
	// Note that this function is confusingly named. In CSS terms, the value set
	// here is padding.
	SetTopMargin(topMargin int)
	// SetWrapMode sets the line wrapping for the view.
	SetWrapMode(wrapMode WrapMode)
	// StartsDisplayLine determines whether @iter is at the start of a display
	// line. See gtk_text_view_forward_display_line() for an explanation of
	// display lines vs. paragraphs.
	StartsDisplayLine(iter *TextIter) bool
	// WindowToBufferCoords converts coordinates on the window identified by
	// @win to buffer coordinates, storing the result in (@buffer_x,@buffer_y).
	//
	// Note that you can’t convert coordinates for a nonexisting window (see
	// gtk_text_view_set_border_window_size()).
	WindowToBufferCoords(win TextWindowType, windowX int, windowY int) (bufferX int, bufferY int)
}

// textView implements the TextView class.
type textView struct {
	Container
	Buildable
	Scrollable
}

var _ TextView = (*textView)(nil)

// WrapTextView wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextView(obj *externglib.Object) TextView {
	return textView{
		Container:  WrapContainer(obj),
		Buildable:  WrapBuildable(obj),
		Scrollable: WrapScrollable(obj),
	}
}

func marshalTextView(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextView(obj), nil
}

// NewTextView creates a new TextView. If you don’t call
// gtk_text_view_set_buffer() before using the text view, an empty default
// buffer will be created for you. Get the buffer with
// gtk_text_view_get_buffer(). If you want to specify your own buffer, consider
// gtk_text_view_new_with_buffer().
func NewTextView() TextView {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_text_view_new()

	var _textView TextView // out

	_textView = WrapTextView(externglib.Take(unsafe.Pointer(_cret)))

	return _textView
}

// NewTextViewWithBuffer creates a new TextView widget displaying the buffer
// @buffer. One buffer can be shared among many widgets. @buffer may be nil to
// create a default buffer, in which case this function is equivalent to
// gtk_text_view_new(). The text view adds its own reference count to the
// buffer; it does not take over an existing reference.
func NewTextViewWithBuffer(buffer TextBuffer) TextView {
	var _arg1 *C.GtkTextBuffer // out
	var _cret *C.GtkWidget     // in

	_arg1 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_text_view_new_with_buffer(_arg1)

	var _textView TextView // out

	_textView = WrapTextView(externglib.Take(unsafe.Pointer(_cret)))

	return _textView
}

// AddChildAtAnchor adds a child widget in the text buffer, at the given
// @anchor.
func (t textView) AddChildAtAnchor(child Widget, anchor TextChildAnchor) {
	var _arg0 *C.GtkTextView        // out
	var _arg1 *C.GtkWidget          // out
	var _arg2 *C.GtkTextChildAnchor // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GtkTextChildAnchor)(unsafe.Pointer(anchor.Native()))

	C.gtk_text_view_add_child_at_anchor(_arg0, _arg1, _arg2)
}

// AddChildInWindow adds a child at fixed coordinates in one of the text
// widget's windows.
//
// The window must have nonzero size (see
// gtk_text_view_set_border_window_size()). Note that the child coordinates are
// given relative to scrolling. When placing a child in K_TEXT_WINDOW_WIDGET,
// scrolling is irrelevant, the child floats above all scrollable areas. But
// when placing a child in one of the scrollable windows (border windows or text
// window) it will move with the scrolling as needed.
func (t textView) AddChildInWindow(child Widget, whichWindow TextWindowType, xpos int, ypos int) {
	var _arg0 *C.GtkTextView      // out
	var _arg1 *C.GtkWidget        // out
	var _arg2 C.GtkTextWindowType // out
	var _arg3 C.gint              // out
	var _arg4 C.gint              // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (C.GtkTextWindowType)(whichWindow)
	_arg3 = (C.gint)(xpos)
	_arg4 = (C.gint)(ypos)

	C.gtk_text_view_add_child_in_window(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// BackwardDisplayLine moves the given @iter backward by one display (wrapped)
// line. A display line is different from a paragraph. Paragraphs are separated
// by newlines or other paragraph separator characters. Display lines are
// created by line-wrapping a paragraph. If wrapping is turned off, display
// lines and paragraphs will be the same. Display lines are divided differently
// for each view, since they depend on the view’s width; paragraphs are the same
// in all views, since they depend on the contents of the TextBuffer.
func (t textView) BackwardDisplayLine(iter *TextIter) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_text_view_backward_display_line(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardDisplayLineStart moves the given @iter backward to the next display
// line start. A display line is different from a paragraph. Paragraphs are
// separated by newlines or other paragraph separator characters. Display lines
// are created by line-wrapping a paragraph. If wrapping is turned off, display
// lines and paragraphs will be the same. Display lines are divided differently
// for each view, since they depend on the view’s width; paragraphs are the same
// in all views, since they depend on the contents of the TextBuffer.
func (t textView) BackwardDisplayLineStart(iter *TextIter) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_text_view_backward_display_line_start(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BufferToWindowCoords converts coordinate (@buffer_x, @buffer_y) to
// coordinates for the window @win, and stores the result in (@window_x,
// @window_y).
//
// Note that you can’t convert coordinates for a nonexisting window (see
// gtk_text_view_set_border_window_size()).
func (t textView) BufferToWindowCoords(win TextWindowType, bufferX int, bufferY int) (windowX int, windowY int) {
	var _arg0 *C.GtkTextView      // out
	var _arg1 C.GtkTextWindowType // out
	var _arg2 C.gint              // out
	var _arg3 C.gint              // out
	var _arg4 C.gint              // in
	var _arg5 C.gint              // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.GtkTextWindowType)(win)
	_arg2 = (C.gint)(bufferX)
	_arg3 = (C.gint)(bufferY)

	C.gtk_text_view_buffer_to_window_coords(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)

	var _windowX int // out
	var _windowY int // out

	_windowX = (int)(_arg4)
	_windowY = (int)(_arg5)

	return _windowX, _windowY
}

// ForwardDisplayLine moves the given @iter forward by one display (wrapped)
// line. A display line is different from a paragraph. Paragraphs are separated
// by newlines or other paragraph separator characters. Display lines are
// created by line-wrapping a paragraph. If wrapping is turned off, display
// lines and paragraphs will be the same. Display lines are divided differently
// for each view, since they depend on the view’s width; paragraphs are the same
// in all views, since they depend on the contents of the TextBuffer.
func (t textView) ForwardDisplayLine(iter *TextIter) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_text_view_forward_display_line(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardDisplayLineEnd moves the given @iter forward to the next display line
// end. A display line is different from a paragraph. Paragraphs are separated
// by newlines or other paragraph separator characters. Display lines are
// created by line-wrapping a paragraph. If wrapping is turned off, display
// lines and paragraphs will be the same. Display lines are divided differently
// for each view, since they depend on the view’s width; paragraphs are the same
// in all views, since they depend on the contents of the TextBuffer.
func (t textView) ForwardDisplayLineEnd(iter *TextIter) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_text_view_forward_display_line_end(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AcceptsTab returns whether pressing the Tab key inserts a tab characters.
// gtk_text_view_set_accepts_tab().
func (t textView) AcceptsTab() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_accepts_tab(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BorderWindowSize gets the width of the specified border window. See
// gtk_text_view_set_border_window_size().
func (t textView) BorderWindowSize(typ TextWindowType) int {
	var _arg0 *C.GtkTextView      // out
	var _arg1 C.GtkTextWindowType // out
	var _cret C.gint              // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.GtkTextWindowType)(typ)

	_cret = C.gtk_text_view_get_border_window_size(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// BottomMargin gets the bottom margin for text in the @text_view.
func (t textView) BottomMargin() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_bottom_margin(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Buffer returns the TextBuffer being displayed by this text view. The
// reference count on the buffer is not incremented; the caller of this function
// won’t own a new reference.
func (t textView) Buffer() TextBuffer {
	var _arg0 *C.GtkTextView   // out
	var _cret *C.GtkTextBuffer // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_buffer(_arg0)

	var _textBuffer TextBuffer // out

	_textBuffer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextBuffer)

	return _textBuffer
}

// CursorLocations: given an @iter within a text layout, determine the positions
// of the strong and weak cursors if the insertion point is at that iterator.
// The position of each cursor is stored as a zero-width rectangle. The strong
// cursor location is the location where characters of the directionality equal
// to the base direction of the paragraph are inserted. The weak cursor location
// is the location where characters of the directionality opposite to the base
// direction of the paragraph are inserted.
//
// If @iter is nil, the actual cursor position is used.
//
// Note that if @iter happens to be the actual cursor position, and there is
// currently an IM preedit sequence being entered, the returned locations will
// be adjusted to account for the preedit cursor’s offset within the preedit
// sequence.
//
// The rectangle position is in buffer coordinates; use
// gtk_text_view_buffer_to_window_coords() to convert these coordinates to
// coordinates for one of the windows in the text view.
func (t textView) CursorLocations(iter *TextIter) (strong gdk.Rectangle, weak gdk.Rectangle) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _strong gdk.Rectangle
	var _weak gdk.Rectangle

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

	C.gtk_text_view_get_cursor_locations(_arg0, _arg1, (*C.GdkRectangle)(unsafe.Pointer(&_strong)), (*C.GdkRectangle)(unsafe.Pointer(&_weak)))

	return _strong, _weak
}

// CursorVisible: find out whether the cursor should be displayed.
func (t textView) CursorVisible() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_cursor_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DefaultAttributes obtains a copy of the default text attributes. These are
// the attributes used for text unless a tag overrides them. You’d typically
// pass the default attributes in to gtk_text_iter_get_attributes() in order to
// get the attributes in effect at a given text position.
//
// The return value is a copy owned by the caller of this function, and should
// be freed with gtk_text_attributes_unref().
func (t textView) DefaultAttributes() *TextAttributes {
	var _arg0 *C.GtkTextView       // out
	var _cret *C.GtkTextAttributes // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_default_attributes(_arg0)

	var _textAttributes *TextAttributes // out

	_textAttributes = WrapTextAttributes(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_textAttributes, func(v *TextAttributes) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _textAttributes
}

// Editable returns the default editability of the TextView. Tags in the buffer
// may override this setting for some ranges of text.
func (t textView) Editable() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_editable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HAdjustment gets the horizontal-scrolling Adjustment.
func (t textView) HAdjustment() Adjustment {
	var _arg0 *C.GtkTextView   // out
	var _cret *C.GtkAdjustment // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_hadjustment(_arg0)

	var _adjustment Adjustment // out

	_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

	return _adjustment
}

// Indent gets the default indentation of paragraphs in @text_view. Tags in the
// view’s buffer may override the default. The indentation may be negative.
func (t textView) Indent() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_indent(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// InputHints gets the value of the TextView:input-hints property.
func (t textView) InputHints() InputHints {
	var _arg0 *C.GtkTextView  // out
	var _cret C.GtkInputHints // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_input_hints(_arg0)

	var _inputHints InputHints // out

	_inputHints = InputHints(_cret)

	return _inputHints
}

// InputPurpose gets the value of the TextView:input-purpose property.
func (t textView) InputPurpose() InputPurpose {
	var _arg0 *C.GtkTextView    // out
	var _cret C.GtkInputPurpose // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_input_purpose(_arg0)

	var _inputPurpose InputPurpose // out

	_inputPurpose = InputPurpose(_cret)

	return _inputPurpose
}

// IterAtLocation retrieves the iterator at buffer coordinates @x and @y. Buffer
// coordinates are coordinates for the entire buffer, not just the
// currently-displayed portion. If you have coordinates from an event, you have
// to convert those to buffer coordinates with
// gtk_text_view_window_to_buffer_coords().
func (t textView) IterAtLocation(x int, y int) (TextIter, bool) {
	var _arg0 *C.GtkTextView // out
	var _iter TextIter
	var _arg2 C.gint     // out
	var _arg3 C.gint     // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg2 = (C.gint)(x)
	_arg3 = (C.gint)(y)

	_cret = C.gtk_text_view_get_iter_at_location(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)), _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// IterAtPosition retrieves the iterator pointing to the character at buffer
// coordinates @x and @y. Buffer coordinates are coordinates for the entire
// buffer, not just the currently-displayed portion. If you have coordinates
// from an event, you have to convert those to buffer coordinates with
// gtk_text_view_window_to_buffer_coords().
//
// Note that this is different from gtk_text_view_get_iter_at_location(), which
// returns cursor locations, i.e. positions between characters.
func (t textView) IterAtPosition(x int, y int) (TextIter, int, bool) {
	var _arg0 *C.GtkTextView // out
	var _iter TextIter
	var _arg2 C.gint     // in
	var _arg3 C.gint     // out
	var _arg4 C.gint     // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg3 = (C.gint)(x)
	_arg4 = (C.gint)(y)

	_cret = C.gtk_text_view_get_iter_at_position(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)), &_arg2, _arg3, _arg4)

	var _trailing int // out
	var _ok bool      // out

	_trailing = (int)(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _iter, _trailing, _ok
}

// IterLocation gets a rectangle which roughly contains the character at @iter.
// The rectangle position is in buffer coordinates; use
// gtk_text_view_buffer_to_window_coords() to convert these coordinates to
// coordinates for one of the windows in the text view.
func (t textView) IterLocation(iter *TextIter) gdk.Rectangle {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _location gdk.Rectangle

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

	C.gtk_text_view_get_iter_location(_arg0, _arg1, (*C.GdkRectangle)(unsafe.Pointer(&_location)))

	return _location
}

// Justification gets the default justification of paragraphs in @text_view.
// Tags in the buffer may override the default.
func (t textView) Justification() Justification {
	var _arg0 *C.GtkTextView     // out
	var _cret C.GtkJustification // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_justification(_arg0)

	var _justification Justification // out

	_justification = Justification(_cret)

	return _justification
}

// LeftMargin gets the default left margin size of paragraphs in the @text_view.
// Tags in the buffer may override the default.
func (t textView) LeftMargin() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_left_margin(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// LineAtY gets the TextIter at the start of the line containing the coordinate
// @y. @y is in buffer coordinates, convert from window coordinates with
// gtk_text_view_window_to_buffer_coords(). If non-nil, @line_top will be filled
// with the coordinate of the top edge of the line.
func (t textView) LineAtY(y int) (TextIter, int) {
	var _arg0 *C.GtkTextView // out
	var _targetIter TextIter
	var _arg2 C.gint // out
	var _arg3 C.gint // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg2 = (C.gint)(y)

	C.gtk_text_view_get_line_at_y(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_targetIter)), _arg2, &_arg3)

	var _lineTop int // out

	_lineTop = (int)(_arg3)

	return _targetIter, _lineTop
}

// LineYrange gets the y coordinate of the top of the line containing @iter, and
// the height of the line. The coordinate is a buffer coordinate; convert to
// window coordinates with gtk_text_view_buffer_to_window_coords().
func (t textView) LineYrange(iter *TextIter) (y int, height int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _arg2 C.gint         // in
	var _arg3 C.gint         // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

	C.gtk_text_view_get_line_yrange(_arg0, _arg1, &_arg2, &_arg3)

	var _y int      // out
	var _height int // out

	_y = (int)(_arg2)
	_height = (int)(_arg3)

	return _y, _height
}

// Monospace gets the value of the TextView:monospace property.
func (t textView) Monospace() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_monospace(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Overwrite returns whether the TextView is in overwrite mode or not.
func (t textView) Overwrite() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_overwrite(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PixelsAboveLines gets the default number of pixels to put above paragraphs.
// Adding this function with gtk_text_view_get_pixels_below_lines() is equal to
// the line space between each paragraph.
func (t textView) PixelsAboveLines() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_pixels_above_lines(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// PixelsBelowLines gets the value set by
// gtk_text_view_set_pixels_below_lines().
//
// The line space is the sum of the value returned by this function and the
// value returned by gtk_text_view_get_pixels_above_lines().
func (t textView) PixelsBelowLines() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_pixels_below_lines(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// PixelsInsideWrap gets the value set by
// gtk_text_view_set_pixels_inside_wrap().
func (t textView) PixelsInsideWrap() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_pixels_inside_wrap(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// RightMargin gets the default right margin for text in @text_view. Tags in the
// buffer may override the default.
func (t textView) RightMargin() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_right_margin(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Tabs gets the default tabs for @text_view. Tags in the buffer may override
// the defaults. The returned array will be nil if “standard” (8-space) tabs are
// used. Free the return value with pango_tab_array_free().
func (t textView) Tabs() *pango.TabArray {
	var _arg0 *C.GtkTextView   // out
	var _cret *C.PangoTabArray // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_tabs(_arg0)

	var _tabArray *pango.TabArray // out

	_tabArray = pango.WrapTabArray(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_tabArray, func(v *pango.TabArray) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _tabArray
}

// TopMargin gets the top margin for text in the @text_view.
func (t textView) TopMargin() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_top_margin(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// VAdjustment gets the vertical-scrolling Adjustment.
func (t textView) VAdjustment() Adjustment {
	var _arg0 *C.GtkTextView   // out
	var _cret *C.GtkAdjustment // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_vadjustment(_arg0)

	var _adjustment Adjustment // out

	_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

	return _adjustment
}

// VisibleRect fills @visible_rect with the currently-visible region of the
// buffer, in buffer coordinates. Convert to window coordinates with
// gtk_text_view_buffer_to_window_coords().
func (t textView) VisibleRect() gdk.Rectangle {
	var _arg0 *C.GtkTextView // out
	var _visibleRect gdk.Rectangle

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	C.gtk_text_view_get_visible_rect(_arg0, (*C.GdkRectangle)(unsafe.Pointer(&_visibleRect)))

	return _visibleRect
}

// Window retrieves the Window corresponding to an area of the text view;
// possible windows include the overall widget window, child windows on the
// left, right, top, bottom, and the window that displays the text buffer.
// Windows are nil and nonexistent if their width or height is 0, and are
// nonexistent before the widget has been realized.
func (t textView) Window(win TextWindowType) gdk.Window {
	var _arg0 *C.GtkTextView      // out
	var _arg1 C.GtkTextWindowType // out
	var _cret *C.GdkWindow        // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.GtkTextWindowType)(win)

	_cret = C.gtk_text_view_get_window(_arg0, _arg1)

	var _window gdk.Window // out

	_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Window)

	return _window
}

// WindowType: usually used to find out which window an event corresponds to.
//
// If you connect to an event signal on @text_view, this function should be
// called on `event->window` to see which window it was.
func (t textView) WindowType(window gdk.Window) TextWindowType {
	var _arg0 *C.GtkTextView      // out
	var _arg1 *C.GdkWindow        // out
	var _cret C.GtkTextWindowType // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_text_view_get_window_type(_arg0, _arg1)

	var _textWindowType TextWindowType // out

	_textWindowType = TextWindowType(_cret)

	return _textWindowType
}

// WrapMode gets the line wrapping for the view.
func (t textView) WrapMode() WrapMode {
	var _arg0 *C.GtkTextView // out
	var _cret C.GtkWrapMode  // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_wrap_mode(_arg0)

	var _wrapMode WrapMode // out

	_wrapMode = WrapMode(_cret)

	return _wrapMode
}

// ImContextFilterKeypress: allow the TextView input method to internally handle
// key press and release events. If this function returns true, then no further
// processing should be done for this key event. See
// gtk_im_context_filter_keypress().
//
// Note that you are expected to call this function from your handler when
// overriding key event handling. This is needed in the case when you need to
// insert your own key handling between the input method and the default key
// event handling of the TextView.
//
//    static gboolean
//    gtk_foo_bar_key_press_event (GtkWidget   *widget,
//                                 GdkEventKey *event)
//    {
//      guint keyval;
//
//      gdk_event_get_keyval ((GdkEvent*)event, &keyval);
//
//      if (keyval == GDK_KEY_Return || keyval == GDK_KEY_KP_Enter)
//        {
//          if (gtk_text_view_im_context_filter_keypress (GTK_TEXT_VIEW (widget), event))
//            return TRUE;
//        }
//
//      // Do some stuff
//
//      return GTK_WIDGET_CLASS (gtk_foo_bar_parent_class)->key_press_event (widget, event);
//    }
func (t textView) ImContextFilterKeypress(event *gdk.EventKey) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GdkEventKey // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GdkEventKey)(unsafe.Pointer(event.Native()))

	_cret = C.gtk_text_view_im_context_filter_keypress(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MoveChild updates the position of a child, as for
// gtk_text_view_add_child_in_window().
func (t textView) MoveChild(child Widget, xpos int, ypos int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 C.gint         // out
	var _arg3 C.gint         // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (C.gint)(xpos)
	_arg3 = (C.gint)(ypos)

	C.gtk_text_view_move_child(_arg0, _arg1, _arg2, _arg3)
}

// MoveMarkOnscreen moves a mark within the buffer so that it's located within
// the currently-visible text area.
func (t textView) MoveMarkOnscreen(mark TextMark) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextMark // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))

	_cret = C.gtk_text_view_move_mark_onscreen(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MoveVisually: move the iterator a given number of characters visually,
// treating it as the strong cursor position. If @count is positive, then the
// new strong cursor position will be @count positions to the right of the old
// cursor position. If @count is negative then the new strong cursor position
// will be @count positions to the left of the old cursor position.
//
// In the presence of bi-directional text, the correspondence between logical
// and visual order will depend on the direction of the current run, and there
// may be jumps when the cursor is moved off of the end of a run.
func (t textView) MoveVisually(iter *TextIter, count int) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _arg2 C.gint         // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (C.gint)(count)

	_cret = C.gtk_text_view_move_visually(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PlaceCursorOnscreen moves the cursor to the currently visible region of the
// buffer, it it isn’t there already.
func (t textView) PlaceCursorOnscreen() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_place_cursor_onscreen(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ResetCursorBlink ensures that the cursor is shown (i.e. not in an 'off' blink
// interval) and resets the time that it will stay blinking (or visible, in case
// blinking is disabled).
//
// This function should be called in response to user input (e.g. from derived
// classes that override the textview's Widget::key-press-event handler).
func (t textView) ResetCursorBlink() {
	var _arg0 *C.GtkTextView // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	C.gtk_text_view_reset_cursor_blink(_arg0)
}

// ResetImContext: reset the input method context of the text view if needed.
//
// This can be necessary in the case where modifying the buffer would confuse
// on-going input method behavior.
func (t textView) ResetImContext() {
	var _arg0 *C.GtkTextView // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	C.gtk_text_view_reset_im_context(_arg0)
}

// ScrollMarkOnscreen scrolls @text_view the minimum distance such that @mark is
// contained within the visible area of the widget.
func (t textView) ScrollMarkOnscreen(mark TextMark) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextMark // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))

	C.gtk_text_view_scroll_mark_onscreen(_arg0, _arg1)
}

// ScrollToIter scrolls @text_view so that @iter is on the screen in the
// position indicated by @xalign and @yalign. An alignment of 0.0 indicates left
// or top, 1.0 indicates right or bottom, 0.5 means center. If @use_align is
// false, the text scrolls the minimal distance to get the mark onscreen,
// possibly not scrolling at all. The effective screen for purposes of this
// function is reduced by a margin of size @within_margin.
//
// Note that this function uses the currently-computed height of the lines in
// the text buffer. Line heights are computed in an idle handler; so this
// function may not have the desired effect if it’s called before the height
// computations. To avoid oddness, consider using gtk_text_view_scroll_to_mark()
// which saves a point to be scrolled to after line validation.
func (t textView) ScrollToIter(iter *TextIter, withinMargin float64, useAlign bool, xalign float64, yalign float64) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _arg2 C.gdouble      // out
	var _arg3 C.gboolean     // out
	var _arg4 C.gdouble      // out
	var _arg5 C.gdouble      // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (C.gdouble)(withinMargin)
	if useAlign {
		_arg3 = C.TRUE
	}
	_arg4 = (C.gdouble)(xalign)
	_arg5 = (C.gdouble)(yalign)

	_cret = C.gtk_text_view_scroll_to_iter(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ScrollToMark scrolls @text_view so that @mark is on the screen in the
// position indicated by @xalign and @yalign. An alignment of 0.0 indicates left
// or top, 1.0 indicates right or bottom, 0.5 means center. If @use_align is
// false, the text scrolls the minimal distance to get the mark onscreen,
// possibly not scrolling at all. The effective screen for purposes of this
// function is reduced by a margin of size @within_margin.
func (t textView) ScrollToMark(mark TextMark, withinMargin float64, useAlign bool, xalign float64, yalign float64) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextMark // out
	var _arg2 C.gdouble      // out
	var _arg3 C.gboolean     // out
	var _arg4 C.gdouble      // out
	var _arg5 C.gdouble      // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))
	_arg2 = (C.gdouble)(withinMargin)
	if useAlign {
		_arg3 = C.TRUE
	}
	_arg4 = (C.gdouble)(xalign)
	_arg5 = (C.gdouble)(yalign)

	C.gtk_text_view_scroll_to_mark(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}

// SetAcceptsTab sets the behavior of the text widget when the Tab key is
// pressed. If @accepts_tab is true, a tab character is inserted. If
// @accepts_tab is false the keyboard focus is moved to the next widget in the
// focus chain.
func (t textView) SetAcceptsTab(acceptsTab bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	if acceptsTab {
		_arg1 = C.TRUE
	}

	C.gtk_text_view_set_accepts_tab(_arg0, _arg1)
}

// SetBorderWindowSize sets the width of GTK_TEXT_WINDOW_LEFT or
// GTK_TEXT_WINDOW_RIGHT, or the height of GTK_TEXT_WINDOW_TOP or
// GTK_TEXT_WINDOW_BOTTOM. Automatically destroys the corresponding window if
// the size is set to 0, and creates the window if the size is set to non-zero.
// This function can only be used for the “border windows”, and it won’t work
// with GTK_TEXT_WINDOW_WIDGET, GTK_TEXT_WINDOW_TEXT, or
// GTK_TEXT_WINDOW_PRIVATE.
func (t textView) SetBorderWindowSize(typ TextWindowType, size int) {
	var _arg0 *C.GtkTextView      // out
	var _arg1 C.GtkTextWindowType // out
	var _arg2 C.gint              // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.GtkTextWindowType)(typ)
	_arg2 = (C.gint)(size)

	C.gtk_text_view_set_border_window_size(_arg0, _arg1, _arg2)
}

// SetBottomMargin sets the bottom margin for text in @text_view.
//
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
func (t textView) SetBottomMargin(bottomMargin int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(bottomMargin)

	C.gtk_text_view_set_bottom_margin(_arg0, _arg1)
}

// SetBuffer sets @buffer as the buffer being displayed by @text_view. The
// previous buffer displayed by the text view is unreferenced, and a reference
// is added to @buffer. If you owned a reference to @buffer before passing it to
// this function, you must remove that reference yourself; TextView will not
// “adopt” it.
func (t textView) SetBuffer(buffer TextBuffer) {
	var _arg0 *C.GtkTextView   // out
	var _arg1 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	C.gtk_text_view_set_buffer(_arg0, _arg1)
}

// SetCursorVisible toggles whether the insertion point should be displayed. A
// buffer with no editable text probably shouldn’t have a visible cursor, so you
// may want to turn the cursor off.
//
// Note that this property may be overridden by the
// Settings:gtk-keynave-use-caret settings.
func (t textView) SetCursorVisible(setting bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_text_view_set_cursor_visible(_arg0, _arg1)
}

// SetEditable sets the default editability of the TextView. You can override
// this default setting with tags in the buffer, using the “editable” attribute
// of tags.
func (t textView) SetEditable(setting bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_text_view_set_editable(_arg0, _arg1)
}

// SetIndent sets the default indentation for paragraphs in @text_view. Tags in
// the buffer may override the default.
func (t textView) SetIndent(indent int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(indent)

	C.gtk_text_view_set_indent(_arg0, _arg1)
}

// SetInputHints sets the TextView:input-hints property, which allows input
// methods to fine-tune their behaviour.
func (t textView) SetInputHints(hints InputHints) {
	var _arg0 *C.GtkTextView  // out
	var _arg1 C.GtkInputHints // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.GtkInputHints)(hints)

	C.gtk_text_view_set_input_hints(_arg0, _arg1)
}

// SetInputPurpose sets the TextView:input-purpose property which can be used by
// on-screen keyboards and other input methods to adjust their behaviour.
func (t textView) SetInputPurpose(purpose InputPurpose) {
	var _arg0 *C.GtkTextView    // out
	var _arg1 C.GtkInputPurpose // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.GtkInputPurpose)(purpose)

	C.gtk_text_view_set_input_purpose(_arg0, _arg1)
}

// SetJustification sets the default justification of text in @text_view. Tags
// in the view’s buffer may override the default.
func (t textView) SetJustification(justification Justification) {
	var _arg0 *C.GtkTextView     // out
	var _arg1 C.GtkJustification // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.GtkJustification)(justification)

	C.gtk_text_view_set_justification(_arg0, _arg1)
}

// SetLeftMargin sets the default left margin for text in @text_view. Tags in
// the buffer may override the default.
//
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
func (t textView) SetLeftMargin(leftMargin int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(leftMargin)

	C.gtk_text_view_set_left_margin(_arg0, _arg1)
}

// SetMonospace sets the TextView:monospace property, which indicates that the
// text view should use monospace fonts.
func (t textView) SetMonospace(monospace bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	if monospace {
		_arg1 = C.TRUE
	}

	C.gtk_text_view_set_monospace(_arg0, _arg1)
}

// SetOverwrite changes the TextView overwrite mode.
func (t textView) SetOverwrite(overwrite bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	if overwrite {
		_arg1 = C.TRUE
	}

	C.gtk_text_view_set_overwrite(_arg0, _arg1)
}

// SetPixelsAboveLines sets the default number of blank pixels above paragraphs
// in @text_view. Tags in the buffer for @text_view may override the defaults.
func (t textView) SetPixelsAboveLines(pixelsAboveLines int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(pixelsAboveLines)

	C.gtk_text_view_set_pixels_above_lines(_arg0, _arg1)
}

// SetPixelsBelowLines sets the default number of pixels of blank space to put
// below paragraphs in @text_view. May be overridden by tags applied to
// @text_view’s buffer.
func (t textView) SetPixelsBelowLines(pixelsBelowLines int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(pixelsBelowLines)

	C.gtk_text_view_set_pixels_below_lines(_arg0, _arg1)
}

// SetPixelsInsideWrap sets the default number of pixels of blank space to leave
// between display/wrapped lines within a paragraph. May be overridden by tags
// in @text_view’s buffer.
func (t textView) SetPixelsInsideWrap(pixelsInsideWrap int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(pixelsInsideWrap)

	C.gtk_text_view_set_pixels_inside_wrap(_arg0, _arg1)
}

// SetRightMargin sets the default right margin for text in the text view. Tags
// in the buffer may override the default.
//
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
func (t textView) SetRightMargin(rightMargin int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(rightMargin)

	C.gtk_text_view_set_right_margin(_arg0, _arg1)
}

// SetTabs sets the default tab stops for paragraphs in @text_view. Tags in the
// buffer may override the default.
func (t textView) SetTabs(tabs *pango.TabArray) {
	var _arg0 *C.GtkTextView   // out
	var _arg1 *C.PangoTabArray // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.PangoTabArray)(unsafe.Pointer(tabs.Native()))

	C.gtk_text_view_set_tabs(_arg0, _arg1)
}

// SetTopMargin sets the top margin for text in @text_view.
//
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
func (t textView) SetTopMargin(topMargin int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(topMargin)

	C.gtk_text_view_set_top_margin(_arg0, _arg1)
}

// SetWrapMode sets the line wrapping for the view.
func (t textView) SetWrapMode(wrapMode WrapMode) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.GtkWrapMode  // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.GtkWrapMode)(wrapMode)

	C.gtk_text_view_set_wrap_mode(_arg0, _arg1)
}

// StartsDisplayLine determines whether @iter is at the start of a display line.
// See gtk_text_view_forward_display_line() for an explanation of display lines
// vs. paragraphs.
func (t textView) StartsDisplayLine(iter *TextIter) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_text_view_starts_display_line(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// WindowToBufferCoords converts coordinates on the window identified by @win to
// buffer coordinates, storing the result in (@buffer_x,@buffer_y).
//
// Note that you can’t convert coordinates for a nonexisting window (see
// gtk_text_view_set_border_window_size()).
func (t textView) WindowToBufferCoords(win TextWindowType, windowX int, windowY int) (bufferX int, bufferY int) {
	var _arg0 *C.GtkTextView      // out
	var _arg1 C.GtkTextWindowType // out
	var _arg2 C.gint              // out
	var _arg3 C.gint              // out
	var _arg4 C.gint              // in
	var _arg5 C.gint              // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.GtkTextWindowType)(win)
	_arg2 = (C.gint)(windowX)
	_arg3 = (C.gint)(windowY)

	C.gtk_text_view_window_to_buffer_coords(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)

	var _bufferX int // out
	var _bufferY int // out

	_bufferX = (int)(_arg4)
	_bufferY = (int)(_arg5)

	return _bufferX, _bufferY
}

type TextViewAccessible interface {
	ContainerAccessible
}

// textViewAccessible implements the TextViewAccessible class.
type textViewAccessible struct {
	ContainerAccessible
}

var _ TextViewAccessible = (*textViewAccessible)(nil)

// WrapTextViewAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextViewAccessible(obj *externglib.Object) TextViewAccessible {
	return textViewAccessible{
		ContainerAccessible: WrapContainerAccessible(obj),
	}
}

func marshalTextViewAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextViewAccessible(obj), nil
}

// ThemingEngine was the object used for rendering themed content in GTK+
// widgets. It used to allow overriding GTK+'s default implementation of
// rendering functions by allowing engines to be loaded as modules.
//
// ThemingEngine has been deprecated in GTK+ 3.14 and will be ignored for
// rendering. The advancements in CSS theming are good enough to allow themers
// to achieve their goals without the need to modify source code.
type ThemingEngine interface {
	gextras.Objector

	// BackgroundColor gets the background color for a given state.
	BackgroundColor(state StateFlags) gdk.RGBA
	// Border gets the border for a given state as a Border.
	Border(state StateFlags) Border
	// BorderColor gets the border color for a given state.
	BorderColor(state StateFlags) gdk.RGBA
	// Color gets the foreground color for a given state.
	Color(state StateFlags) gdk.RGBA
	// Direction returns the widget direction used for rendering.
	Direction() TextDirection
	// Font returns the font description for a given state.
	Font(state StateFlags) *pango.FontDescription
	// JunctionSides returns the widget direction used for rendering.
	JunctionSides() JunctionSides
	// Margin gets the margin for a given state as a Border.
	Margin(state StateFlags) Border
	// Padding gets the padding for a given state as a Border.
	Padding(state StateFlags) Border
	// Path returns the widget path used for style matching.
	Path() *WidgetPath
	// Property gets a property value as retrieved from the style settings that
	// apply to the currently rendered element.
	Property(property string, state StateFlags) *externglib.Value
	// Screen returns the Screen to which @engine currently rendering to.
	Screen() gdk.Screen
	// State returns the state used when rendering.
	State() StateFlags
	// StyleProperty gets the value for a widget style property.
	StyleProperty(propertyName string) *externglib.Value
	// HasClass returns true if the currently rendered contents have defined the
	// given class name.
	HasClass(styleClass string) bool
	// HasRegion returns true if the currently rendered contents have the region
	// defined. If @flags_return is not nil, it is set to the flags affecting
	// the region.
	HasRegion(styleRegion string) (RegionFlags, bool)
	// LookupColor looks up and resolves a color name in the current style’s
	// color map.
	LookupColor(colorName string) (gdk.RGBA, bool)
	// StateIsRunning returns true if there is a transition animation running
	// for the current region (see gtk_style_context_push_animatable_region()).
	//
	// If @progress is not nil, the animation progress will be returned there,
	// 0.0 means the state is closest to being false, while 1.0 means it’s
	// closest to being true. This means transition animations will run from 0
	// to 1 when @state is being set to true and from 1 to 0 when it’s being set
	// to false.
	StateIsRunning(state StateType) (float64, bool)
}

// themingEngine implements the ThemingEngine class.
type themingEngine struct {
	gextras.Objector
}

var _ ThemingEngine = (*themingEngine)(nil)

// WrapThemingEngine wraps a GObject to the right type. It is
// primarily used internally.
func WrapThemingEngine(obj *externglib.Object) ThemingEngine {
	return themingEngine{
		Objector: obj,
	}
}

func marshalThemingEngine(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapThemingEngine(obj), nil
}

// BackgroundColor gets the background color for a given state.
func (e themingEngine) BackgroundColor(state StateFlags) gdk.RGBA {
	var _arg0 *C.GtkThemingEngine // out
	var _arg1 C.GtkStateFlags     // out
	var _color gdk.RGBA

	_arg0 = (*C.GtkThemingEngine)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkStateFlags)(state)

	C.gtk_theming_engine_get_background_color(_arg0, _arg1, (*C.GdkRGBA)(unsafe.Pointer(&_color)))

	return _color
}

// Border gets the border for a given state as a Border.
func (e themingEngine) Border(state StateFlags) Border {
	var _arg0 *C.GtkThemingEngine // out
	var _arg1 C.GtkStateFlags     // out
	var _border Border

	_arg0 = (*C.GtkThemingEngine)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkStateFlags)(state)

	C.gtk_theming_engine_get_border(_arg0, _arg1, (*C.GtkBorder)(unsafe.Pointer(&_border)))

	return _border
}

// BorderColor gets the border color for a given state.
func (e themingEngine) BorderColor(state StateFlags) gdk.RGBA {
	var _arg0 *C.GtkThemingEngine // out
	var _arg1 C.GtkStateFlags     // out
	var _color gdk.RGBA

	_arg0 = (*C.GtkThemingEngine)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkStateFlags)(state)

	C.gtk_theming_engine_get_border_color(_arg0, _arg1, (*C.GdkRGBA)(unsafe.Pointer(&_color)))

	return _color
}

// Color gets the foreground color for a given state.
func (e themingEngine) Color(state StateFlags) gdk.RGBA {
	var _arg0 *C.GtkThemingEngine // out
	var _arg1 C.GtkStateFlags     // out
	var _color gdk.RGBA

	_arg0 = (*C.GtkThemingEngine)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkStateFlags)(state)

	C.gtk_theming_engine_get_color(_arg0, _arg1, (*C.GdkRGBA)(unsafe.Pointer(&_color)))

	return _color
}

// Direction returns the widget direction used for rendering.
func (e themingEngine) Direction() TextDirection {
	var _arg0 *C.GtkThemingEngine // out
	var _cret C.GtkTextDirection  // in

	_arg0 = (*C.GtkThemingEngine)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_theming_engine_get_direction(_arg0)

	var _textDirection TextDirection // out

	_textDirection = TextDirection(_cret)

	return _textDirection
}

// Font returns the font description for a given state.
func (e themingEngine) Font(state StateFlags) *pango.FontDescription {
	var _arg0 *C.GtkThemingEngine     // out
	var _arg1 C.GtkStateFlags         // out
	var _cret *C.PangoFontDescription // in

	_arg0 = (*C.GtkThemingEngine)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkStateFlags)(state)

	_cret = C.gtk_theming_engine_get_font(_arg0, _arg1)

	var _fontDescription *pango.FontDescription // out

	_fontDescription = pango.WrapFontDescription(unsafe.Pointer(_cret))

	return _fontDescription
}

// JunctionSides returns the widget direction used for rendering.
func (e themingEngine) JunctionSides() JunctionSides {
	var _arg0 *C.GtkThemingEngine // out
	var _cret C.GtkJunctionSides  // in

	_arg0 = (*C.GtkThemingEngine)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_theming_engine_get_junction_sides(_arg0)

	var _junctionSides JunctionSides // out

	_junctionSides = JunctionSides(_cret)

	return _junctionSides
}

// Margin gets the margin for a given state as a Border.
func (e themingEngine) Margin(state StateFlags) Border {
	var _arg0 *C.GtkThemingEngine // out
	var _arg1 C.GtkStateFlags     // out
	var _margin Border

	_arg0 = (*C.GtkThemingEngine)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkStateFlags)(state)

	C.gtk_theming_engine_get_margin(_arg0, _arg1, (*C.GtkBorder)(unsafe.Pointer(&_margin)))

	return _margin
}

// Padding gets the padding for a given state as a Border.
func (e themingEngine) Padding(state StateFlags) Border {
	var _arg0 *C.GtkThemingEngine // out
	var _arg1 C.GtkStateFlags     // out
	var _padding Border

	_arg0 = (*C.GtkThemingEngine)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkStateFlags)(state)

	C.gtk_theming_engine_get_padding(_arg0, _arg1, (*C.GtkBorder)(unsafe.Pointer(&_padding)))

	return _padding
}

// Path returns the widget path used for style matching.
func (e themingEngine) Path() *WidgetPath {
	var _arg0 *C.GtkThemingEngine // out
	var _cret *C.GtkWidgetPath    // in

	_arg0 = (*C.GtkThemingEngine)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_theming_engine_get_path(_arg0)

	var _widgetPath *WidgetPath // out

	_widgetPath = WrapWidgetPath(unsafe.Pointer(_cret))

	return _widgetPath
}

// Property gets a property value as retrieved from the style settings that
// apply to the currently rendered element.
func (e themingEngine) Property(property string, state StateFlags) *externglib.Value {
	var _arg0 *C.GtkThemingEngine // out
	var _arg1 *C.gchar            // out
	var _arg2 C.GtkStateFlags     // out
	var _arg3 C.GValue            // in

	_arg0 = (*C.GtkThemingEngine)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.gchar)(C.CString(property))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GtkStateFlags)(state)

	C.gtk_theming_engine_get_property(_arg0, _arg1, _arg2, &_arg3)

	var _value *externglib.Value // out

	_value = externglib.ValueFromNative(unsafe.Pointer(_arg3))
	runtime.SetFinalizer(_value, func(v *externglib.Value) {
		C.g_value_unset((*C.GValue)(v.GValue))
	})

	return _value
}

// Screen returns the Screen to which @engine currently rendering to.
func (e themingEngine) Screen() gdk.Screen {
	var _arg0 *C.GtkThemingEngine // out
	var _cret *C.GdkScreen        // in

	_arg0 = (*C.GtkThemingEngine)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_theming_engine_get_screen(_arg0)

	var _screen gdk.Screen // out

	_screen = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Screen)

	return _screen
}

// State returns the state used when rendering.
func (e themingEngine) State() StateFlags {
	var _arg0 *C.GtkThemingEngine // out
	var _cret C.GtkStateFlags     // in

	_arg0 = (*C.GtkThemingEngine)(unsafe.Pointer(e.Native()))

	_cret = C.gtk_theming_engine_get_state(_arg0)

	var _stateFlags StateFlags // out

	_stateFlags = StateFlags(_cret)

	return _stateFlags
}

// StyleProperty gets the value for a widget style property.
func (e themingEngine) StyleProperty(propertyName string) *externglib.Value {
	var _arg0 *C.GtkThemingEngine // out
	var _arg1 *C.gchar            // out
	var _arg2 C.GValue            // in

	_arg0 = (*C.GtkThemingEngine)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.gchar)(C.CString(propertyName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_theming_engine_get_style_property(_arg0, _arg1, &_arg2)

	var _value *externglib.Value // out

	_value = externglib.ValueFromNative(unsafe.Pointer(_arg2))

	return _value
}

// HasClass returns true if the currently rendered contents have defined the
// given class name.
func (e themingEngine) HasClass(styleClass string) bool {
	var _arg0 *C.GtkThemingEngine // out
	var _arg1 *C.gchar            // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkThemingEngine)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.gchar)(C.CString(styleClass))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_theming_engine_has_class(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasRegion returns true if the currently rendered contents have the region
// defined. If @flags_return is not nil, it is set to the flags affecting the
// region.
func (e themingEngine) HasRegion(styleRegion string) (RegionFlags, bool) {
	var _arg0 *C.GtkThemingEngine // out
	var _arg1 *C.gchar            // out
	var _arg2 C.GtkRegionFlags    // in
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkThemingEngine)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.gchar)(C.CString(styleRegion))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_theming_engine_has_region(_arg0, _arg1, &_arg2)

	var _flags RegionFlags // out
	var _ok bool           // out

	_flags = RegionFlags(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _flags, _ok
}

// LookupColor looks up and resolves a color name in the current style’s color
// map.
func (e themingEngine) LookupColor(colorName string) (gdk.RGBA, bool) {
	var _arg0 *C.GtkThemingEngine // out
	var _arg1 *C.gchar            // out
	var _color gdk.RGBA
	var _cret C.gboolean // in

	_arg0 = (*C.GtkThemingEngine)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.gchar)(C.CString(colorName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_theming_engine_lookup_color(_arg0, _arg1, (*C.GdkRGBA)(unsafe.Pointer(&_color)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _color, _ok
}

// StateIsRunning returns true if there is a transition animation running for
// the current region (see gtk_style_context_push_animatable_region()).
//
// If @progress is not nil, the animation progress will be returned there, 0.0
// means the state is closest to being false, while 1.0 means it’s closest to
// being true. This means transition animations will run from 0 to 1 when @state
// is being set to true and from 1 to 0 when it’s being set to false.
func (e themingEngine) StateIsRunning(state StateType) (float64, bool) {
	var _arg0 *C.GtkThemingEngine // out
	var _arg1 C.GtkStateType      // out
	var _arg2 C.gdouble           // in
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkThemingEngine)(unsafe.Pointer(e.Native()))
	_arg1 = (C.GtkStateType)(state)

	_cret = C.gtk_theming_engine_state_is_running(_arg0, _arg1, &_arg2)

	var _progress float64 // out
	var _ok bool          // out

	_progress = (float64)(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _progress, _ok
}

// ToggleAction: a ToggleAction corresponds roughly to a CheckMenuItem. It has
// an “active” state specifying whether the action has been checked or not.
type ToggleAction interface {
	Action
	Buildable

	// Active returns the checked state of the toggle action.
	Active() bool
	// DrawAsRadio returns whether the action should have proxies like a radio
	// action.
	DrawAsRadio() bool
	// SetActive sets the checked state on the toggle action.
	SetActive(isActive bool)
	// SetDrawAsRadio sets whether the action should have proxies like a radio
	// action.
	SetDrawAsRadio(drawAsRadio bool)
	// Toggled emits the “toggled” signal on the toggle action.
	Toggled()
}

// toggleAction implements the ToggleAction class.
type toggleAction struct {
	Action
	Buildable
}

var _ ToggleAction = (*toggleAction)(nil)

// WrapToggleAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapToggleAction(obj *externglib.Object) ToggleAction {
	return toggleAction{
		Action:    WrapAction(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalToggleAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapToggleAction(obj), nil
}

// NewToggleAction creates a new ToggleAction object. To add the action to a
// ActionGroup and set the accelerator for the action, call
// gtk_action_group_add_action_with_accel().
func NewToggleAction(name string, label string, tooltip string, stockId string) ToggleAction {
	var _arg1 *C.gchar           // out
	var _arg2 *C.gchar           // out
	var _arg3 *C.gchar           // out
	var _arg4 *C.gchar           // out
	var _cret *C.GtkToggleAction // in

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(tooltip))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(C.CString(stockId))
	defer C.free(unsafe.Pointer(_arg4))

	_cret = C.gtk_toggle_action_new(_arg1, _arg2, _arg3, _arg4)

	var _toggleAction ToggleAction // out

	_toggleAction = WrapToggleAction(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _toggleAction
}

// Active returns the checked state of the toggle action.
func (a toggleAction) Active() bool {
	var _arg0 *C.GtkToggleAction // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkToggleAction)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_toggle_action_get_active(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DrawAsRadio returns whether the action should have proxies like a radio
// action.
func (a toggleAction) DrawAsRadio() bool {
	var _arg0 *C.GtkToggleAction // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkToggleAction)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_toggle_action_get_draw_as_radio(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetActive sets the checked state on the toggle action.
func (a toggleAction) SetActive(isActive bool) {
	var _arg0 *C.GtkToggleAction // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GtkToggleAction)(unsafe.Pointer(a.Native()))
	if isActive {
		_arg1 = C.TRUE
	}

	C.gtk_toggle_action_set_active(_arg0, _arg1)
}

// SetDrawAsRadio sets whether the action should have proxies like a radio
// action.
func (a toggleAction) SetDrawAsRadio(drawAsRadio bool) {
	var _arg0 *C.GtkToggleAction // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GtkToggleAction)(unsafe.Pointer(a.Native()))
	if drawAsRadio {
		_arg1 = C.TRUE
	}

	C.gtk_toggle_action_set_draw_as_radio(_arg0, _arg1)
}

// Toggled emits the “toggled” signal on the toggle action.
func (a toggleAction) Toggled() {
	var _arg0 *C.GtkToggleAction // out

	_arg0 = (*C.GtkToggleAction)(unsafe.Pointer(a.Native()))

	C.gtk_toggle_action_toggled(_arg0)
}

// ToggleButton: a ToggleButton is a Button which will remain “pressed-in” when
// clicked. Clicking again will cause the toggle button to return to its normal
// state.
//
// A toggle button is created by calling either gtk_toggle_button_new() or
// gtk_toggle_button_new_with_label(). If using the former, it is advisable to
// pack a widget, (such as a Label and/or a Image), into the toggle button’s
// container. (See Button for more information).
//
// The state of a ToggleButton can be set specifically using
// gtk_toggle_button_set_active(), and retrieved using
// gtk_toggle_button_get_active().
//
// To simply switch the state of a toggle button, use
// gtk_toggle_button_toggled().
//
//
// CSS nodes
//
// GtkToggleButton has a single CSS node with name button. To differentiate it
// from a plain Button, it gets the .toggle style class.
//
// Creating two ToggleButton widgets.
//
//    static void output_state (GtkToggleButton *source, gpointer user_data) {
//      printf ("Active: d\n", gtk_toggle_button_get_active (source));
//    }
//
//    void make_toggles (void) {
//      GtkWidget *window, *toggle1, *toggle2;
//      GtkWidget *box;
//      const char *text;
//
//      window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
//      box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 12);
//
//      text = "Hi, I’m a toggle button.";
//      toggle1 = gtk_toggle_button_new_with_label (text);
//
//      // Makes this toggle button invisible
//      gtk_toggle_button_set_mode (GTK_TOGGLE_BUTTON (toggle1),
//                                  TRUE);
//
//      g_signal_connect (toggle1, "toggled",
//                        G_CALLBACK (output_state),
//                        NULL);
//      gtk_container_add (GTK_CONTAINER (box), toggle1);
//
//      text = "Hi, I’m a toggle button.";
//      toggle2 = gtk_toggle_button_new_with_label (text);
//      gtk_toggle_button_set_mode (GTK_TOGGLE_BUTTON (toggle2),
//                                  FALSE);
//      g_signal_connect (toggle2, "toggled",
//                        G_CALLBACK (output_state),
//                        NULL);
//      gtk_container_add (GTK_CONTAINER (box), toggle2);
//
//      gtk_container_add (GTK_CONTAINER (window), box);
//      gtk_widget_show_all (window);
//    }
type ToggleButton interface {
	Button
	Actionable
	Activatable
	Buildable

	// Active queries a ToggleButton and returns its current state. Returns true
	// if the toggle button is pressed in and false if it is raised.
	Active() bool
	// Inconsistent gets the value set by gtk_toggle_button_set_inconsistent().
	Inconsistent() bool
	// Mode retrieves whether the button is displayed as a separate indicator
	// and label. See gtk_toggle_button_set_mode().
	Mode() bool
	// SetActive sets the status of the toggle button. Set to true if you want
	// the GtkToggleButton to be “pressed in”, and false to raise it. This
	// action causes the ToggleButton::toggled signal and the Button::clicked
	// signal to be emitted.
	SetActive(isActive bool)
	// SetInconsistent: if the user has selected a range of elements (such as
	// some text or spreadsheet cells) that are affected by a toggle button, and
	// the current values in that range are inconsistent, you may want to
	// display the toggle in an “in between” state. This function turns on “in
	// between” display. Normally you would turn off the inconsistent state
	// again if the user toggles the toggle button. This has to be done
	// manually, gtk_toggle_button_set_inconsistent() only affects visual
	// appearance, it doesn’t affect the semantics of the button.
	SetInconsistent(setting bool)
	// SetMode sets whether the button is displayed as a separate indicator and
	// label. You can call this function on a checkbutton or a radiobutton with
	// @draw_indicator = false to make the button look like a normal button.
	//
	// This can be used to create linked strip of buttons that work like a
	// StackSwitcher.
	//
	// This function only affects instances of classes like CheckButton and
	// RadioButton that derive from ToggleButton, not instances of ToggleButton
	// itself.
	SetMode(drawIndicator bool)
	// Toggled emits the ToggleButton::toggled signal on the ToggleButton. There
	// is no good reason for an application ever to call this function.
	Toggled()
}

// toggleButton implements the ToggleButton class.
type toggleButton struct {
	Button
	Actionable
	Activatable
	Buildable
}

var _ ToggleButton = (*toggleButton)(nil)

// WrapToggleButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapToggleButton(obj *externglib.Object) ToggleButton {
	return toggleButton{
		Button:      WrapButton(obj),
		Actionable:  WrapActionable(obj),
		Activatable: WrapActivatable(obj),
		Buildable:   WrapBuildable(obj),
	}
}

func marshalToggleButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapToggleButton(obj), nil
}

// NewToggleButton creates a new toggle button. A widget should be packed into
// the button, as in gtk_button_new().
func NewToggleButton() ToggleButton {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_toggle_button_new()

	var _toggleButton ToggleButton // out

	_toggleButton = WrapToggleButton(externglib.Take(unsafe.Pointer(_cret)))

	return _toggleButton
}

// NewToggleButtonWithLabel creates a new toggle button with a text label.
func NewToggleButtonWithLabel(label string) ToggleButton {
	var _arg1 *C.gchar     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_toggle_button_new_with_label(_arg1)

	var _toggleButton ToggleButton // out

	_toggleButton = WrapToggleButton(externglib.Take(unsafe.Pointer(_cret)))

	return _toggleButton
}

// NewToggleButtonWithMnemonic creates a new ToggleButton containing a label.
// The label will be created using gtk_label_new_with_mnemonic(), so underscores
// in @label indicate the mnemonic for the button.
func NewToggleButtonWithMnemonic(label string) ToggleButton {
	var _arg1 *C.gchar     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_toggle_button_new_with_mnemonic(_arg1)

	var _toggleButton ToggleButton // out

	_toggleButton = WrapToggleButton(externglib.Take(unsafe.Pointer(_cret)))

	return _toggleButton
}

// Active queries a ToggleButton and returns its current state. Returns true if
// the toggle button is pressed in and false if it is raised.
func (t toggleButton) Active() bool {
	var _arg0 *C.GtkToggleButton // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkToggleButton)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_toggle_button_get_active(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Inconsistent gets the value set by gtk_toggle_button_set_inconsistent().
func (t toggleButton) Inconsistent() bool {
	var _arg0 *C.GtkToggleButton // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkToggleButton)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_toggle_button_get_inconsistent(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Mode retrieves whether the button is displayed as a separate indicator and
// label. See gtk_toggle_button_set_mode().
func (t toggleButton) Mode() bool {
	var _arg0 *C.GtkToggleButton // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkToggleButton)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_toggle_button_get_mode(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetActive sets the status of the toggle button. Set to true if you want the
// GtkToggleButton to be “pressed in”, and false to raise it. This action causes
// the ToggleButton::toggled signal and the Button::clicked signal to be
// emitted.
func (t toggleButton) SetActive(isActive bool) {
	var _arg0 *C.GtkToggleButton // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GtkToggleButton)(unsafe.Pointer(t.Native()))
	if isActive {
		_arg1 = C.TRUE
	}

	C.gtk_toggle_button_set_active(_arg0, _arg1)
}

// SetInconsistent: if the user has selected a range of elements (such as some
// text or spreadsheet cells) that are affected by a toggle button, and the
// current values in that range are inconsistent, you may want to display the
// toggle in an “in between” state. This function turns on “in between” display.
// Normally you would turn off the inconsistent state again if the user toggles
// the toggle button. This has to be done manually,
// gtk_toggle_button_set_inconsistent() only affects visual appearance, it
// doesn’t affect the semantics of the button.
func (t toggleButton) SetInconsistent(setting bool) {
	var _arg0 *C.GtkToggleButton // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GtkToggleButton)(unsafe.Pointer(t.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_toggle_button_set_inconsistent(_arg0, _arg1)
}

// SetMode sets whether the button is displayed as a separate indicator and
// label. You can call this function on a checkbutton or a radiobutton with
// @draw_indicator = false to make the button look like a normal button.
//
// This can be used to create linked strip of buttons that work like a
// StackSwitcher.
//
// This function only affects instances of classes like CheckButton and
// RadioButton that derive from ToggleButton, not instances of ToggleButton
// itself.
func (t toggleButton) SetMode(drawIndicator bool) {
	var _arg0 *C.GtkToggleButton // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GtkToggleButton)(unsafe.Pointer(t.Native()))
	if drawIndicator {
		_arg1 = C.TRUE
	}

	C.gtk_toggle_button_set_mode(_arg0, _arg1)
}

// Toggled emits the ToggleButton::toggled signal on the ToggleButton. There is
// no good reason for an application ever to call this function.
func (t toggleButton) Toggled() {
	var _arg0 *C.GtkToggleButton // out

	_arg0 = (*C.GtkToggleButton)(unsafe.Pointer(t.Native()))

	C.gtk_toggle_button_toggled(_arg0)
}

type ToggleButtonAccessible interface {
	ButtonAccessible
}

// toggleButtonAccessible implements the ToggleButtonAccessible class.
type toggleButtonAccessible struct {
	ButtonAccessible
}

var _ ToggleButtonAccessible = (*toggleButtonAccessible)(nil)

// WrapToggleButtonAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapToggleButtonAccessible(obj *externglib.Object) ToggleButtonAccessible {
	return toggleButtonAccessible{
		ButtonAccessible: WrapButtonAccessible(obj),
	}
}

func marshalToggleButtonAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapToggleButtonAccessible(obj), nil
}

// ToggleToolButton: a ToggleToolButton is a ToolItem that contains a toggle
// button.
//
// Use gtk_toggle_tool_button_new() to create a new GtkToggleToolButton.
//
//
// CSS nodes
//
// GtkToggleToolButton has a single CSS node with name togglebutton.
type ToggleToolButton interface {
	ToolButton
	Actionable
	Activatable
	Buildable

	// Active queries a ToggleToolButton and returns its current state. Returns
	// true if the toggle button is pressed in and false if it is raised.
	Active() bool
	// SetActive sets the status of the toggle tool button. Set to true if you
	// want the GtkToggleButton to be “pressed in”, and false to raise it. This
	// action causes the toggled signal to be emitted.
	SetActive(isActive bool)
}

// toggleToolButton implements the ToggleToolButton class.
type toggleToolButton struct {
	ToolButton
	Actionable
	Activatable
	Buildable
}

var _ ToggleToolButton = (*toggleToolButton)(nil)

// WrapToggleToolButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapToggleToolButton(obj *externglib.Object) ToggleToolButton {
	return toggleToolButton{
		ToolButton:  WrapToolButton(obj),
		Actionable:  WrapActionable(obj),
		Activatable: WrapActivatable(obj),
		Buildable:   WrapBuildable(obj),
	}
}

func marshalToggleToolButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapToggleToolButton(obj), nil
}

// NewToggleToolButton returns a new ToggleToolButton
func NewToggleToolButton() ToggleToolButton {
	var _cret *C.GtkToolItem // in

	_cret = C.gtk_toggle_tool_button_new()

	var _toggleToolButton ToggleToolButton // out

	_toggleToolButton = WrapToggleToolButton(externglib.Take(unsafe.Pointer(_cret)))

	return _toggleToolButton
}

// NewToggleToolButtonFromStock creates a new ToggleToolButton containing the
// image and text from a stock item. Some stock ids have preprocessor macros
// like K_STOCK_OK and K_STOCK_APPLY.
//
// It is an error if @stock_id is not a name of a stock item.
func NewToggleToolButtonFromStock(stockId string) ToggleToolButton {
	var _arg1 *C.gchar       // out
	var _cret *C.GtkToolItem // in

	_arg1 = (*C.gchar)(C.CString(stockId))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_toggle_tool_button_new_from_stock(_arg1)

	var _toggleToolButton ToggleToolButton // out

	_toggleToolButton = WrapToggleToolButton(externglib.Take(unsafe.Pointer(_cret)))

	return _toggleToolButton
}

// Active queries a ToggleToolButton and returns its current state. Returns true
// if the toggle button is pressed in and false if it is raised.
func (b toggleToolButton) Active() bool {
	var _arg0 *C.GtkToggleToolButton // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkToggleToolButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_toggle_tool_button_get_active(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetActive sets the status of the toggle tool button. Set to true if you want
// the GtkToggleButton to be “pressed in”, and false to raise it. This action
// causes the toggled signal to be emitted.
func (b toggleToolButton) SetActive(isActive bool) {
	var _arg0 *C.GtkToggleToolButton // out
	var _arg1 C.gboolean             // out

	_arg0 = (*C.GtkToggleToolButton)(unsafe.Pointer(b.Native()))
	if isActive {
		_arg1 = C.TRUE
	}

	C.gtk_toggle_tool_button_set_active(_arg0, _arg1)
}

// ToolButton ToolButtons are ToolItems containing buttons.
//
// Use gtk_tool_button_new() to create a new ToolButton.
//
// The label of a ToolButton is determined by the properties
// ToolButton:label-widget, ToolButton:label, and ToolButton:stock-id. If
// ToolButton:label-widget is non-nil, then that widget is used as the label.
// Otherwise, if ToolButton:label is non-nil, that string is used as the label.
// Otherwise, if ToolButton:stock-id is non-nil, the label is determined by the
// stock item. Otherwise, the button does not have a label.
//
// The icon of a ToolButton is determined by the properties
// ToolButton:icon-widget and ToolButton:stock-id. If ToolButton:icon-widget is
// non-nil, then that widget is used as the icon. Otherwise, if
// ToolButton:stock-id is non-nil, the icon is determined by the stock item.
// Otherwise, the button does not have a icon.
//
//
// CSS nodes
//
// GtkToolButton has a single CSS node with name toolbutton.
type ToolButton interface {
	ToolItem
	Actionable
	Activatable
	Buildable

	// IconName returns the name of the themed icon for the tool button, see
	// gtk_tool_button_set_icon_name().
	IconName() string
	// IconWidget: return the widget used as icon widget on @button. See
	// gtk_tool_button_set_icon_widget().
	IconWidget() Widget
	// Label returns the label used by the tool button, or nil if the tool
	// button doesn’t have a label. or uses a the label from a stock item. The
	// returned string is owned by GTK+, and must not be modified or freed.
	Label() string
	// LabelWidget returns the widget used as label on @button. See
	// gtk_tool_button_set_label_widget().
	LabelWidget() Widget
	// StockID returns the name of the stock item. See
	// gtk_tool_button_set_stock_id(). The returned string is owned by GTK+ and
	// must not be freed or modifed.
	StockID() string
	// UseUnderline returns whether underscores in the label property are used
	// as mnemonics on menu items on the overflow menu. See
	// gtk_tool_button_set_use_underline().
	UseUnderline() bool
	// SetIconName sets the icon for the tool button from a named themed icon.
	// See the docs for IconTheme for more details. The ToolButton:icon-name
	// property only has an effect if not overridden by non-nil
	// ToolButton:label-widget, ToolButton:icon-widget and ToolButton:stock-id
	// properties.
	SetIconName(iconName string)
	// SetIconWidget sets @icon as the widget used as icon on @button. If
	// @icon_widget is nil the icon is determined by the ToolButton:stock-id
	// property. If the ToolButton:stock-id property is also nil, @button will
	// not have an icon.
	SetIconWidget(iconWidget Widget)
	// SetLabel sets @label as the label used for the tool button. The
	// ToolButton:label property only has an effect if not overridden by a
	// non-nil ToolButton:label-widget property. If both the
	// ToolButton:label-widget and ToolButton:label properties are nil, the
	// label is determined by the ToolButton:stock-id property. If the
	// ToolButton:stock-id property is also nil, @button will not have a label.
	SetLabel(label string)
	// SetLabelWidget sets @label_widget as the widget that will be used as the
	// label for @button. If @label_widget is nil the ToolButton:label property
	// is used as label. If ToolButton:label is also nil, the label in the stock
	// item determined by the ToolButton:stock-id property is used as label. If
	// ToolButton:stock-id is also nil, @button does not have a label.
	SetLabelWidget(labelWidget Widget)
	// SetStockID sets the name of the stock item. See
	// gtk_tool_button_new_from_stock(). The stock_id property only has an
	// effect if not overridden by non-nil ToolButton:label-widget and
	// ToolButton:icon-widget properties.
	SetStockID(stockId string)
	// SetUseUnderline: if set, an underline in the label property indicates
	// that the next character should be used for the mnemonic accelerator key
	// in the overflow menu. For example, if the label property is “_Open” and
	// @use_underline is true, the label on the tool button will be “Open” and
	// the item on the overflow menu will have an underlined “O”.
	//
	// Labels shown on tool buttons never have mnemonics on them; this property
	// only affects the menu item on the overflow menu.
	SetUseUnderline(useUnderline bool)
}

// toolButton implements the ToolButton class.
type toolButton struct {
	ToolItem
	Actionable
	Activatable
	Buildable
}

var _ ToolButton = (*toolButton)(nil)

// WrapToolButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapToolButton(obj *externglib.Object) ToolButton {
	return toolButton{
		ToolItem:    WrapToolItem(obj),
		Actionable:  WrapActionable(obj),
		Activatable: WrapActivatable(obj),
		Buildable:   WrapBuildable(obj),
	}
}

func marshalToolButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapToolButton(obj), nil
}

// NewToolButton creates a new ToolButton using @icon_widget as contents and
// @label as label.
func NewToolButton(iconWidget Widget, label string) ToolButton {
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.gchar       // out
	var _cret *C.GtkToolItem // in

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(iconWidget.Native()))
	_arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_tool_button_new(_arg1, _arg2)

	var _toolButton ToolButton // out

	_toolButton = WrapToolButton(externglib.Take(unsafe.Pointer(_cret)))

	return _toolButton
}

// NewToolButtonFromStock creates a new ToolButton containing the image and text
// from a stock item. Some stock ids have preprocessor macros like K_STOCK_OK
// and K_STOCK_APPLY.
//
// It is an error if @stock_id is not a name of a stock item.
func NewToolButtonFromStock(stockId string) ToolButton {
	var _arg1 *C.gchar       // out
	var _cret *C.GtkToolItem // in

	_arg1 = (*C.gchar)(C.CString(stockId))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_tool_button_new_from_stock(_arg1)

	var _toolButton ToolButton // out

	_toolButton = WrapToolButton(externglib.Take(unsafe.Pointer(_cret)))

	return _toolButton
}

// IconName returns the name of the themed icon for the tool button, see
// gtk_tool_button_set_icon_name().
func (b toolButton) IconName() string {
	var _arg0 *C.GtkToolButton // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GtkToolButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_tool_button_get_icon_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// IconWidget: return the widget used as icon widget on @button. See
// gtk_tool_button_set_icon_widget().
func (b toolButton) IconWidget() Widget {
	var _arg0 *C.GtkToolButton // out
	var _cret *C.GtkWidget     // in

	_arg0 = (*C.GtkToolButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_tool_button_get_icon_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// Label returns the label used by the tool button, or nil if the tool button
// doesn’t have a label. or uses a the label from a stock item. The returned
// string is owned by GTK+, and must not be modified or freed.
func (b toolButton) Label() string {
	var _arg0 *C.GtkToolButton // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GtkToolButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_tool_button_get_label(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// LabelWidget returns the widget used as label on @button. See
// gtk_tool_button_set_label_widget().
func (b toolButton) LabelWidget() Widget {
	var _arg0 *C.GtkToolButton // out
	var _cret *C.GtkWidget     // in

	_arg0 = (*C.GtkToolButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_tool_button_get_label_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// StockID returns the name of the stock item. See
// gtk_tool_button_set_stock_id(). The returned string is owned by GTK+ and must
// not be freed or modifed.
func (b toolButton) StockID() string {
	var _arg0 *C.GtkToolButton // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GtkToolButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_tool_button_get_stock_id(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// UseUnderline returns whether underscores in the label property are used as
// mnemonics on menu items on the overflow menu. See
// gtk_tool_button_set_use_underline().
func (b toolButton) UseUnderline() bool {
	var _arg0 *C.GtkToolButton // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkToolButton)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_tool_button_get_use_underline(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetIconName sets the icon for the tool button from a named themed icon. See
// the docs for IconTheme for more details. The ToolButton:icon-name property
// only has an effect if not overridden by non-nil ToolButton:label-widget,
// ToolButton:icon-widget and ToolButton:stock-id properties.
func (b toolButton) SetIconName(iconName string) {
	var _arg0 *C.GtkToolButton // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GtkToolButton)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_tool_button_set_icon_name(_arg0, _arg1)
}

// SetIconWidget sets @icon as the widget used as icon on @button. If
// @icon_widget is nil the icon is determined by the ToolButton:stock-id
// property. If the ToolButton:stock-id property is also nil, @button will not
// have an icon.
func (b toolButton) SetIconWidget(iconWidget Widget) {
	var _arg0 *C.GtkToolButton // out
	var _arg1 *C.GtkWidget     // out

	_arg0 = (*C.GtkToolButton)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(iconWidget.Native()))

	C.gtk_tool_button_set_icon_widget(_arg0, _arg1)
}

// SetLabel sets @label as the label used for the tool button. The
// ToolButton:label property only has an effect if not overridden by a non-nil
// ToolButton:label-widget property. If both the ToolButton:label-widget and
// ToolButton:label properties are nil, the label is determined by the
// ToolButton:stock-id property. If the ToolButton:stock-id property is also
// nil, @button will not have a label.
func (b toolButton) SetLabel(label string) {
	var _arg0 *C.GtkToolButton // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GtkToolButton)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_tool_button_set_label(_arg0, _arg1)
}

// SetLabelWidget sets @label_widget as the widget that will be used as the
// label for @button. If @label_widget is nil the ToolButton:label property is
// used as label. If ToolButton:label is also nil, the label in the stock item
// determined by the ToolButton:stock-id property is used as label. If
// ToolButton:stock-id is also nil, @button does not have a label.
func (b toolButton) SetLabelWidget(labelWidget Widget) {
	var _arg0 *C.GtkToolButton // out
	var _arg1 *C.GtkWidget     // out

	_arg0 = (*C.GtkToolButton)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(labelWidget.Native()))

	C.gtk_tool_button_set_label_widget(_arg0, _arg1)
}

// SetStockID sets the name of the stock item. See
// gtk_tool_button_new_from_stock(). The stock_id property only has an effect if
// not overridden by non-nil ToolButton:label-widget and ToolButton:icon-widget
// properties.
func (b toolButton) SetStockID(stockId string) {
	var _arg0 *C.GtkToolButton // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GtkToolButton)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(stockId))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_tool_button_set_stock_id(_arg0, _arg1)
}

// SetUseUnderline: if set, an underline in the label property indicates that
// the next character should be used for the mnemonic accelerator key in the
// overflow menu. For example, if the label property is “_Open” and
// @use_underline is true, the label on the tool button will be “Open” and the
// item on the overflow menu will have an underlined “O”.
//
// Labels shown on tool buttons never have mnemonics on them; this property only
// affects the menu item on the overflow menu.
func (b toolButton) SetUseUnderline(useUnderline bool) {
	var _arg0 *C.GtkToolButton // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkToolButton)(unsafe.Pointer(b.Native()))
	if useUnderline {
		_arg1 = C.TRUE
	}

	C.gtk_tool_button_set_use_underline(_arg0, _arg1)
}

// ToolItem ToolItems are widgets that can appear on a toolbar. To create a
// toolbar item that contain something else than a button, use
// gtk_tool_item_new(). Use gtk_container_add() to add a child widget to the
// tool item.
//
// For toolbar items that contain buttons, see the ToolButton, ToggleToolButton
// and RadioToolButton classes.
//
// See the Toolbar class for a description of the toolbar widget, and ToolShell
// for a description of the tool shell interface.
type ToolItem interface {
	Bin
	Activatable
	Buildable

	// EllipsizeMode returns the ellipsize mode used for @tool_item. Custom
	// subclasses of ToolItem should call this function to find out how text
	// should be ellipsized.
	EllipsizeMode() pango.EllipsizeMode
	// Expand returns whether @tool_item is allocated extra space. See
	// gtk_tool_item_set_expand().
	Expand() bool
	// Homogeneous returns whether @tool_item is the same size as other
	// homogeneous items. See gtk_tool_item_set_homogeneous().
	Homogeneous() bool
	// IconSize returns the icon size used for @tool_item. Custom subclasses of
	// ToolItem should call this function to find out what size icons they
	// should use.
	IconSize() int
	// IsImportant returns whether @tool_item is considered important. See
	// gtk_tool_item_set_is_important()
	IsImportant() bool
	// Orientation returns the orientation used for @tool_item. Custom
	// subclasses of ToolItem should call this function to find out what size
	// icons they should use.
	Orientation() Orientation
	// ProXYMenuItem: if @menu_item_id matches the string passed to
	// gtk_tool_item_set_proxy_menu_item() return the corresponding MenuItem.
	//
	// Custom subclasses of ToolItem should use this function to update their
	// menu item when the ToolItem changes. That the @menu_item_ids must match
	// ensures that a ToolItem will not inadvertently change a menu item that
	// they did not create.
	ProXYMenuItem(menuItemId string) Widget
	// ReliefStyle returns the relief style of @tool_item. See
	// gtk_button_set_relief(). Custom subclasses of ToolItem should call this
	// function in the handler of the ToolItem::toolbar_reconfigured signal to
	// find out the relief style of buttons.
	ReliefStyle() ReliefStyle
	// TextAlignment returns the text alignment used for @tool_item. Custom
	// subclasses of ToolItem should call this function to find out how text
	// should be aligned.
	TextAlignment() float32
	// TextOrientation returns the text orientation used for @tool_item. Custom
	// subclasses of ToolItem should call this function to find out how text
	// should be orientated.
	TextOrientation() Orientation
	// TextSizeGroup returns the size group used for labels in @tool_item.
	// Custom subclasses of ToolItem should call this function and use the size
	// group for labels.
	TextSizeGroup() SizeGroup
	// ToolbarStyle returns the toolbar style used for @tool_item. Custom
	// subclasses of ToolItem should call this function in the handler of the
	// GtkToolItem::toolbar_reconfigured signal to find out in what style the
	// toolbar is displayed and change themselves accordingly
	//
	// Possibilities are: - GTK_TOOLBAR_BOTH, meaning the tool item should show
	// both an icon and a label, stacked vertically - GTK_TOOLBAR_ICONS, meaning
	// the toolbar shows only icons - GTK_TOOLBAR_TEXT, meaning the tool item
	// should only show text - GTK_TOOLBAR_BOTH_HORIZ, meaning the tool item
	// should show both an icon and a label, arranged horizontally
	ToolbarStyle() ToolbarStyle
	// UseDragWindow returns whether @tool_item has a drag window. See
	// gtk_tool_item_set_use_drag_window().
	UseDragWindow() bool
	// VisibleHorizontal returns whether the @tool_item is visible on toolbars
	// that are docked horizontally.
	VisibleHorizontal() bool
	// VisibleVertical returns whether @tool_item is visible when the toolbar is
	// docked vertically. See gtk_tool_item_set_visible_vertical().
	VisibleVertical() bool
	// RebuildMenu: calling this function signals to the toolbar that the
	// overflow menu item for @tool_item has changed. If the overflow menu is
	// visible when this function it called, the menu will be rebuilt.
	//
	// The function must be called when the tool item changes what it will do in
	// response to the ToolItem::create-menu-proxy signal.
	RebuildMenu()
	// RetrieveProXYMenuItem returns the MenuItem that was last set by
	// gtk_tool_item_set_proxy_menu_item(), ie. the MenuItem that is going to
	// appear in the overflow menu.
	RetrieveProXYMenuItem() Widget
	// SetExpand sets whether @tool_item is allocated extra space when there is
	// more room on the toolbar then needed for the items. The effect is that
	// the item gets bigger when the toolbar gets bigger and smaller when the
	// toolbar gets smaller.
	SetExpand(expand bool)
	// SetHomogeneous sets whether @tool_item is to be allocated the same size
	// as other homogeneous items. The effect is that all homogeneous items will
	// have the same width as the widest of the items.
	SetHomogeneous(homogeneous bool)
	// SetIsImportant sets whether @tool_item should be considered important.
	// The ToolButton class uses this property to determine whether to show or
	// hide its label when the toolbar style is GTK_TOOLBAR_BOTH_HORIZ. The
	// result is that only tool buttons with the “is_important” property set
	// have labels, an effect known as “priority text”
	SetIsImportant(isImportant bool)
	// SetProXYMenuItem sets the MenuItem used in the toolbar overflow menu. The
	// @menu_item_id is used to identify the caller of this function and should
	// also be used with gtk_tool_item_get_proxy_menu_item().
	//
	// See also ToolItem::create-menu-proxy.
	SetProXYMenuItem(menuItemId string, menuItem Widget)
	// SetTooltipMarkup sets the markup text to be displayed as tooltip on the
	// item. See gtk_widget_set_tooltip_markup().
	SetTooltipMarkup(markup string)
	// SetTooltipText sets the text to be displayed as tooltip on the item. See
	// gtk_widget_set_tooltip_text().
	SetTooltipText(text string)
	// SetUseDragWindow sets whether @tool_item has a drag window. When true the
	// toolitem can be used as a drag source through gtk_drag_source_set(). When
	// @tool_item has a drag window it will intercept all events, even those
	// that would otherwise be sent to a child of @tool_item.
	SetUseDragWindow(useDragWindow bool)
	// SetVisibleHorizontal sets whether @tool_item is visible when the toolbar
	// is docked horizontally.
	SetVisibleHorizontal(visibleHorizontal bool)
	// SetVisibleVertical sets whether @tool_item is visible when the toolbar is
	// docked vertically. Some tool items, such as text entries, are too wide to
	// be useful on a vertically docked toolbar. If @visible_vertical is false
	// @tool_item will not appear on toolbars that are docked vertically.
	SetVisibleVertical(visibleVertical bool)
	// ToolbarReconfigured emits the signal ToolItem::toolbar_reconfigured on
	// @tool_item. Toolbar and other ToolShell implementations use this function
	// to notify children, when some aspect of their configuration changes.
	ToolbarReconfigured()
}

// toolItem implements the ToolItem class.
type toolItem struct {
	Bin
	Activatable
	Buildable
}

var _ ToolItem = (*toolItem)(nil)

// WrapToolItem wraps a GObject to the right type. It is
// primarily used internally.
func WrapToolItem(obj *externglib.Object) ToolItem {
	return toolItem{
		Bin:         WrapBin(obj),
		Activatable: WrapActivatable(obj),
		Buildable:   WrapBuildable(obj),
	}
}

func marshalToolItem(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapToolItem(obj), nil
}

// NewToolItem creates a new ToolItem
func NewToolItem() ToolItem {
	var _cret *C.GtkToolItem // in

	_cret = C.gtk_tool_item_new()

	var _toolItem ToolItem // out

	_toolItem = WrapToolItem(externglib.Take(unsafe.Pointer(_cret)))

	return _toolItem
}

// EllipsizeMode returns the ellipsize mode used for @tool_item. Custom
// subclasses of ToolItem should call this function to find out how text should
// be ellipsized.
func (t toolItem) EllipsizeMode() pango.EllipsizeMode {
	var _arg0 *C.GtkToolItem       // out
	var _cret C.PangoEllipsizeMode // in

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tool_item_get_ellipsize_mode(_arg0)

	var _ellipsizeMode pango.EllipsizeMode // out

	_ellipsizeMode = pango.EllipsizeMode(_cret)

	return _ellipsizeMode
}

// Expand returns whether @tool_item is allocated extra space. See
// gtk_tool_item_set_expand().
func (t toolItem) Expand() bool {
	var _arg0 *C.GtkToolItem // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tool_item_get_expand(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Homogeneous returns whether @tool_item is the same size as other homogeneous
// items. See gtk_tool_item_set_homogeneous().
func (t toolItem) Homogeneous() bool {
	var _arg0 *C.GtkToolItem // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tool_item_get_homogeneous(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IconSize returns the icon size used for @tool_item. Custom subclasses of
// ToolItem should call this function to find out what size icons they should
// use.
func (t toolItem) IconSize() int {
	var _arg0 *C.GtkToolItem // out
	var _cret C.GtkIconSize  // in

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tool_item_get_icon_size(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// IsImportant returns whether @tool_item is considered important. See
// gtk_tool_item_set_is_important()
func (t toolItem) IsImportant() bool {
	var _arg0 *C.GtkToolItem // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tool_item_get_is_important(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Orientation returns the orientation used for @tool_item. Custom subclasses of
// ToolItem should call this function to find out what size icons they should
// use.
func (t toolItem) Orientation() Orientation {
	var _arg0 *C.GtkToolItem   // out
	var _cret C.GtkOrientation // in

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tool_item_get_orientation(_arg0)

	var _orientation Orientation // out

	_orientation = Orientation(_cret)

	return _orientation
}

// ProXYMenuItem: if @menu_item_id matches the string passed to
// gtk_tool_item_set_proxy_menu_item() return the corresponding MenuItem.
//
// Custom subclasses of ToolItem should use this function to update their menu
// item when the ToolItem changes. That the @menu_item_ids must match ensures
// that a ToolItem will not inadvertently change a menu item that they did not
// create.
func (t toolItem) ProXYMenuItem(menuItemId string) Widget {
	var _arg0 *C.GtkToolItem // out
	var _arg1 *C.gchar       // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.gchar)(C.CString(menuItemId))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_tool_item_get_proxy_menu_item(_arg0, _arg1)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// ReliefStyle returns the relief style of @tool_item. See
// gtk_button_set_relief(). Custom subclasses of ToolItem should call this
// function in the handler of the ToolItem::toolbar_reconfigured signal to find
// out the relief style of buttons.
func (t toolItem) ReliefStyle() ReliefStyle {
	var _arg0 *C.GtkToolItem   // out
	var _cret C.GtkReliefStyle // in

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tool_item_get_relief_style(_arg0)

	var _reliefStyle ReliefStyle // out

	_reliefStyle = ReliefStyle(_cret)

	return _reliefStyle
}

// TextAlignment returns the text alignment used for @tool_item. Custom
// subclasses of ToolItem should call this function to find out how text should
// be aligned.
func (t toolItem) TextAlignment() float32 {
	var _arg0 *C.GtkToolItem // out
	var _cret C.gfloat       // in

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tool_item_get_text_alignment(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// TextOrientation returns the text orientation used for @tool_item. Custom
// subclasses of ToolItem should call this function to find out how text should
// be orientated.
func (t toolItem) TextOrientation() Orientation {
	var _arg0 *C.GtkToolItem   // out
	var _cret C.GtkOrientation // in

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tool_item_get_text_orientation(_arg0)

	var _orientation Orientation // out

	_orientation = Orientation(_cret)

	return _orientation
}

// TextSizeGroup returns the size group used for labels in @tool_item. Custom
// subclasses of ToolItem should call this function and use the size group for
// labels.
func (t toolItem) TextSizeGroup() SizeGroup {
	var _arg0 *C.GtkToolItem  // out
	var _cret *C.GtkSizeGroup // in

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tool_item_get_text_size_group(_arg0)

	var _sizeGroup SizeGroup // out

	_sizeGroup = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(SizeGroup)

	return _sizeGroup
}

// ToolbarStyle returns the toolbar style used for @tool_item. Custom subclasses
// of ToolItem should call this function in the handler of the
// GtkToolItem::toolbar_reconfigured signal to find out in what style the
// toolbar is displayed and change themselves accordingly
//
// Possibilities are: - GTK_TOOLBAR_BOTH, meaning the tool item should show both
// an icon and a label, stacked vertically - GTK_TOOLBAR_ICONS, meaning the
// toolbar shows only icons - GTK_TOOLBAR_TEXT, meaning the tool item should
// only show text - GTK_TOOLBAR_BOTH_HORIZ, meaning the tool item should show
// both an icon and a label, arranged horizontally
func (t toolItem) ToolbarStyle() ToolbarStyle {
	var _arg0 *C.GtkToolItem    // out
	var _cret C.GtkToolbarStyle // in

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tool_item_get_toolbar_style(_arg0)

	var _toolbarStyle ToolbarStyle // out

	_toolbarStyle = ToolbarStyle(_cret)

	return _toolbarStyle
}

// UseDragWindow returns whether @tool_item has a drag window. See
// gtk_tool_item_set_use_drag_window().
func (t toolItem) UseDragWindow() bool {
	var _arg0 *C.GtkToolItem // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tool_item_get_use_drag_window(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// VisibleHorizontal returns whether the @tool_item is visible on toolbars that
// are docked horizontally.
func (t toolItem) VisibleHorizontal() bool {
	var _arg0 *C.GtkToolItem // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tool_item_get_visible_horizontal(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// VisibleVertical returns whether @tool_item is visible when the toolbar is
// docked vertically. See gtk_tool_item_set_visible_vertical().
func (t toolItem) VisibleVertical() bool {
	var _arg0 *C.GtkToolItem // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tool_item_get_visible_vertical(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RebuildMenu: calling this function signals to the toolbar that the overflow
// menu item for @tool_item has changed. If the overflow menu is visible when
// this function it called, the menu will be rebuilt.
//
// The function must be called when the tool item changes what it will do in
// response to the ToolItem::create-menu-proxy signal.
func (t toolItem) RebuildMenu() {
	var _arg0 *C.GtkToolItem // out

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

	C.gtk_tool_item_rebuild_menu(_arg0)
}

// RetrieveProXYMenuItem returns the MenuItem that was last set by
// gtk_tool_item_set_proxy_menu_item(), ie. the MenuItem that is going to appear
// in the overflow menu.
func (t toolItem) RetrieveProXYMenuItem() Widget {
	var _arg0 *C.GtkToolItem // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tool_item_retrieve_proxy_menu_item(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// SetExpand sets whether @tool_item is allocated extra space when there is more
// room on the toolbar then needed for the items. The effect is that the item
// gets bigger when the toolbar gets bigger and smaller when the toolbar gets
// smaller.
func (t toolItem) SetExpand(expand bool) {
	var _arg0 *C.GtkToolItem // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))
	if expand {
		_arg1 = C.TRUE
	}

	C.gtk_tool_item_set_expand(_arg0, _arg1)
}

// SetHomogeneous sets whether @tool_item is to be allocated the same size as
// other homogeneous items. The effect is that all homogeneous items will have
// the same width as the widest of the items.
func (t toolItem) SetHomogeneous(homogeneous bool) {
	var _arg0 *C.GtkToolItem // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))
	if homogeneous {
		_arg1 = C.TRUE
	}

	C.gtk_tool_item_set_homogeneous(_arg0, _arg1)
}

// SetIsImportant sets whether @tool_item should be considered important. The
// ToolButton class uses this property to determine whether to show or hide its
// label when the toolbar style is GTK_TOOLBAR_BOTH_HORIZ. The result is that
// only tool buttons with the “is_important” property set have labels, an effect
// known as “priority text”
func (t toolItem) SetIsImportant(isImportant bool) {
	var _arg0 *C.GtkToolItem // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))
	if isImportant {
		_arg1 = C.TRUE
	}

	C.gtk_tool_item_set_is_important(_arg0, _arg1)
}

// SetProXYMenuItem sets the MenuItem used in the toolbar overflow menu. The
// @menu_item_id is used to identify the caller of this function and should also
// be used with gtk_tool_item_get_proxy_menu_item().
//
// See also ToolItem::create-menu-proxy.
func (t toolItem) SetProXYMenuItem(menuItemId string, menuItem Widget) {
	var _arg0 *C.GtkToolItem // out
	var _arg1 *C.gchar       // out
	var _arg2 *C.GtkWidget   // out

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.gchar)(C.CString(menuItemId))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(menuItem.Native()))

	C.gtk_tool_item_set_proxy_menu_item(_arg0, _arg1, _arg2)
}

// SetTooltipMarkup sets the markup text to be displayed as tooltip on the item.
// See gtk_widget_set_tooltip_markup().
func (t toolItem) SetTooltipMarkup(markup string) {
	var _arg0 *C.GtkToolItem // out
	var _arg1 *C.gchar       // out

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.gchar)(C.CString(markup))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_tool_item_set_tooltip_markup(_arg0, _arg1)
}

// SetTooltipText sets the text to be displayed as tooltip on the item. See
// gtk_widget_set_tooltip_text().
func (t toolItem) SetTooltipText(text string) {
	var _arg0 *C.GtkToolItem // out
	var _arg1 *C.gchar       // out

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_tool_item_set_tooltip_text(_arg0, _arg1)
}

// SetUseDragWindow sets whether @tool_item has a drag window. When true the
// toolitem can be used as a drag source through gtk_drag_source_set(). When
// @tool_item has a drag window it will intercept all events, even those that
// would otherwise be sent to a child of @tool_item.
func (t toolItem) SetUseDragWindow(useDragWindow bool) {
	var _arg0 *C.GtkToolItem // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))
	if useDragWindow {
		_arg1 = C.TRUE
	}

	C.gtk_tool_item_set_use_drag_window(_arg0, _arg1)
}

// SetVisibleHorizontal sets whether @tool_item is visible when the toolbar is
// docked horizontally.
func (t toolItem) SetVisibleHorizontal(visibleHorizontal bool) {
	var _arg0 *C.GtkToolItem // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))
	if visibleHorizontal {
		_arg1 = C.TRUE
	}

	C.gtk_tool_item_set_visible_horizontal(_arg0, _arg1)
}

// SetVisibleVertical sets whether @tool_item is visible when the toolbar is
// docked vertically. Some tool items, such as text entries, are too wide to be
// useful on a vertically docked toolbar. If @visible_vertical is false
// @tool_item will not appear on toolbars that are docked vertically.
func (t toolItem) SetVisibleVertical(visibleVertical bool) {
	var _arg0 *C.GtkToolItem // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))
	if visibleVertical {
		_arg1 = C.TRUE
	}

	C.gtk_tool_item_set_visible_vertical(_arg0, _arg1)
}

// ToolbarReconfigured emits the signal ToolItem::toolbar_reconfigured on
// @tool_item. Toolbar and other ToolShell implementations use this function to
// notify children, when some aspect of their configuration changes.
func (t toolItem) ToolbarReconfigured() {
	var _arg0 *C.GtkToolItem // out

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

	C.gtk_tool_item_toolbar_reconfigured(_arg0)
}

// ToolItemGroup: a ToolItemGroup is used together with ToolPalette to add
// ToolItems to a palette like container with different categories and drag and
// drop support.
//
//
// CSS nodes
//
// GtkToolItemGroup has a single CSS node named toolitemgroup.
type ToolItemGroup interface {
	Container
	Buildable
	ToolShell

	// Collapsed gets whether @group is collapsed or expanded.
	Collapsed() bool
	// DropItem gets the tool item at position (x, y).
	DropItem(x int, y int) ToolItem
	// Ellipsize gets the ellipsization mode of @group.
	Ellipsize() pango.EllipsizeMode
	// HeaderRelief gets the relief mode of the header button of @group.
	HeaderRelief() ReliefStyle
	// ItemPosition gets the position of @item in @group as index.
	ItemPosition(item ToolItem) int
	// Label gets the label of @group.
	Label() string
	// LabelWidget gets the label widget of @group. See
	// gtk_tool_item_group_set_label_widget().
	LabelWidget() Widget
	// NItems gets the number of tool items in @group.
	NItems() uint
	// NthItem gets the tool item at @index in group.
	NthItem(index uint) ToolItem
	// Insert inserts @item at @position in the list of children of @group.
	Insert(item ToolItem, position int)
	// SetCollapsed sets whether the @group should be collapsed or expanded.
	SetCollapsed(collapsed bool)
	// SetEllipsize sets the ellipsization mode which should be used by labels
	// in @group.
	SetEllipsize(ellipsize pango.EllipsizeMode)
	// SetHeaderRelief: set the button relief of the group header. See
	// gtk_button_set_relief() for details.
	SetHeaderRelief(style ReliefStyle)
	// SetItemPosition sets the position of @item in the list of children of
	// @group.
	SetItemPosition(item ToolItem, position int)
	// SetLabel sets the label of the tool item group. The label is displayed in
	// the header of the group.
	SetLabel(label string)
	// SetLabelWidget sets the label of the tool item group. The label widget is
	// displayed in the header of the group, in place of the usual label.
	SetLabelWidget(labelWidget Widget)
}

// toolItemGroup implements the ToolItemGroup class.
type toolItemGroup struct {
	Container
	Buildable
	ToolShell
}

var _ ToolItemGroup = (*toolItemGroup)(nil)

// WrapToolItemGroup wraps a GObject to the right type. It is
// primarily used internally.
func WrapToolItemGroup(obj *externglib.Object) ToolItemGroup {
	return toolItemGroup{
		Container: WrapContainer(obj),
		Buildable: WrapBuildable(obj),
		ToolShell: WrapToolShell(obj),
	}
}

func marshalToolItemGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapToolItemGroup(obj), nil
}

// NewToolItemGroup creates a new tool item group with label @label.
func NewToolItemGroup(label string) ToolItemGroup {
	var _arg1 *C.gchar     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_tool_item_group_new(_arg1)

	var _toolItemGroup ToolItemGroup // out

	_toolItemGroup = WrapToolItemGroup(externglib.Take(unsafe.Pointer(_cret)))

	return _toolItemGroup
}

// Collapsed gets whether @group is collapsed or expanded.
func (g toolItemGroup) Collapsed() bool {
	var _arg0 *C.GtkToolItemGroup // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkToolItemGroup)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_tool_item_group_get_collapsed(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DropItem gets the tool item at position (x, y).
func (g toolItemGroup) DropItem(x int, y int) ToolItem {
	var _arg0 *C.GtkToolItemGroup // out
	var _arg1 C.gint              // out
	var _arg2 C.gint              // out
	var _cret *C.GtkToolItem      // in

	_arg0 = (*C.GtkToolItemGroup)(unsafe.Pointer(g.Native()))
	_arg1 = (C.gint)(x)
	_arg2 = (C.gint)(y)

	_cret = C.gtk_tool_item_group_get_drop_item(_arg0, _arg1, _arg2)

	var _toolItem ToolItem // out

	_toolItem = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ToolItem)

	return _toolItem
}

// Ellipsize gets the ellipsization mode of @group.
func (g toolItemGroup) Ellipsize() pango.EllipsizeMode {
	var _arg0 *C.GtkToolItemGroup  // out
	var _cret C.PangoEllipsizeMode // in

	_arg0 = (*C.GtkToolItemGroup)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_tool_item_group_get_ellipsize(_arg0)

	var _ellipsizeMode pango.EllipsizeMode // out

	_ellipsizeMode = pango.EllipsizeMode(_cret)

	return _ellipsizeMode
}

// HeaderRelief gets the relief mode of the header button of @group.
func (g toolItemGroup) HeaderRelief() ReliefStyle {
	var _arg0 *C.GtkToolItemGroup // out
	var _cret C.GtkReliefStyle    // in

	_arg0 = (*C.GtkToolItemGroup)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_tool_item_group_get_header_relief(_arg0)

	var _reliefStyle ReliefStyle // out

	_reliefStyle = ReliefStyle(_cret)

	return _reliefStyle
}

// ItemPosition gets the position of @item in @group as index.
func (g toolItemGroup) ItemPosition(item ToolItem) int {
	var _arg0 *C.GtkToolItemGroup // out
	var _arg1 *C.GtkToolItem      // out
	var _cret C.gint              // in

	_arg0 = (*C.GtkToolItemGroup)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.GtkToolItem)(unsafe.Pointer(item.Native()))

	_cret = C.gtk_tool_item_group_get_item_position(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Label gets the label of @group.
func (g toolItemGroup) Label() string {
	var _arg0 *C.GtkToolItemGroup // out
	var _cret *C.gchar            // in

	_arg0 = (*C.GtkToolItemGroup)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_tool_item_group_get_label(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// LabelWidget gets the label widget of @group. See
// gtk_tool_item_group_set_label_widget().
func (g toolItemGroup) LabelWidget() Widget {
	var _arg0 *C.GtkToolItemGroup // out
	var _cret *C.GtkWidget        // in

	_arg0 = (*C.GtkToolItemGroup)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_tool_item_group_get_label_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// NItems gets the number of tool items in @group.
func (g toolItemGroup) NItems() uint {
	var _arg0 *C.GtkToolItemGroup // out
	var _cret C.guint             // in

	_arg0 = (*C.GtkToolItemGroup)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_tool_item_group_get_n_items(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// NthItem gets the tool item at @index in group.
func (g toolItemGroup) NthItem(index uint) ToolItem {
	var _arg0 *C.GtkToolItemGroup // out
	var _arg1 C.guint             // out
	var _cret *C.GtkToolItem      // in

	_arg0 = (*C.GtkToolItemGroup)(unsafe.Pointer(g.Native()))
	_arg1 = (C.guint)(index)

	_cret = C.gtk_tool_item_group_get_nth_item(_arg0, _arg1)

	var _toolItem ToolItem // out

	_toolItem = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ToolItem)

	return _toolItem
}

// Insert inserts @item at @position in the list of children of @group.
func (g toolItemGroup) Insert(item ToolItem, position int) {
	var _arg0 *C.GtkToolItemGroup // out
	var _arg1 *C.GtkToolItem      // out
	var _arg2 C.gint              // out

	_arg0 = (*C.GtkToolItemGroup)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.GtkToolItem)(unsafe.Pointer(item.Native()))
	_arg2 = (C.gint)(position)

	C.gtk_tool_item_group_insert(_arg0, _arg1, _arg2)
}

// SetCollapsed sets whether the @group should be collapsed or expanded.
func (g toolItemGroup) SetCollapsed(collapsed bool) {
	var _arg0 *C.GtkToolItemGroup // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkToolItemGroup)(unsafe.Pointer(g.Native()))
	if collapsed {
		_arg1 = C.TRUE
	}

	C.gtk_tool_item_group_set_collapsed(_arg0, _arg1)
}

// SetEllipsize sets the ellipsization mode which should be used by labels in
// @group.
func (g toolItemGroup) SetEllipsize(ellipsize pango.EllipsizeMode) {
	var _arg0 *C.GtkToolItemGroup  // out
	var _arg1 C.PangoEllipsizeMode // out

	_arg0 = (*C.GtkToolItemGroup)(unsafe.Pointer(g.Native()))
	_arg1 = (C.PangoEllipsizeMode)(ellipsize)

	C.gtk_tool_item_group_set_ellipsize(_arg0, _arg1)
}

// SetHeaderRelief: set the button relief of the group header. See
// gtk_button_set_relief() for details.
func (g toolItemGroup) SetHeaderRelief(style ReliefStyle) {
	var _arg0 *C.GtkToolItemGroup // out
	var _arg1 C.GtkReliefStyle    // out

	_arg0 = (*C.GtkToolItemGroup)(unsafe.Pointer(g.Native()))
	_arg1 = (C.GtkReliefStyle)(style)

	C.gtk_tool_item_group_set_header_relief(_arg0, _arg1)
}

// SetItemPosition sets the position of @item in the list of children of @group.
func (g toolItemGroup) SetItemPosition(item ToolItem, position int) {
	var _arg0 *C.GtkToolItemGroup // out
	var _arg1 *C.GtkToolItem      // out
	var _arg2 C.gint              // out

	_arg0 = (*C.GtkToolItemGroup)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.GtkToolItem)(unsafe.Pointer(item.Native()))
	_arg2 = (C.gint)(position)

	C.gtk_tool_item_group_set_item_position(_arg0, _arg1, _arg2)
}

// SetLabel sets the label of the tool item group. The label is displayed in the
// header of the group.
func (g toolItemGroup) SetLabel(label string) {
	var _arg0 *C.GtkToolItemGroup // out
	var _arg1 *C.gchar            // out

	_arg0 = (*C.GtkToolItemGroup)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_tool_item_group_set_label(_arg0, _arg1)
}

// SetLabelWidget sets the label of the tool item group. The label widget is
// displayed in the header of the group, in place of the usual label.
func (g toolItemGroup) SetLabelWidget(labelWidget Widget) {
	var _arg0 *C.GtkToolItemGroup // out
	var _arg1 *C.GtkWidget        // out

	_arg0 = (*C.GtkToolItemGroup)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(labelWidget.Native()))

	C.gtk_tool_item_group_set_label_widget(_arg0, _arg1)
}

// ToolPalette: a ToolPalette allows you to add ToolItems to a palette-like
// container with different categories and drag and drop support.
//
// A ToolPalette is created with a call to gtk_tool_palette_new().
//
// ToolItems cannot be added directly to a ToolPalette - instead they are added
// to a ToolItemGroup which can than be added to a ToolPalette. To add a
// ToolItemGroup to a ToolPalette, use gtk_container_add().
//
//    static void
//    passive_canvas_drag_data_received (GtkWidget        *widget,
//                                       GdkDragContext   *context,
//                                       gint              x,
//                                       gint              y,
//                                       GtkSelectionData *selection,
//                                       guint             info,
//                                       guint             time,
//                                       gpointer          data)
//    {
//      GtkWidget *palette;
//      GtkWidget *item;
//
//      // Get the dragged item
//      palette = gtk_widget_get_ancestor (gtk_drag_get_source_widget (context),
//                                         GTK_TYPE_TOOL_PALETTE);
//      if (palette != NULL)
//        item = gtk_tool_palette_get_drag_item (GTK_TOOL_PALETTE (palette),
//                                               selection);
//
//      // Do something with item
//    }
//
//    GtkWidget *target, palette;
//
//    palette = gtk_tool_palette_new ();
//    target = gtk_drawing_area_new ();
//
//    g_signal_connect (G_OBJECT (target), "drag-data-received",
//                      G_CALLBACK (passive_canvas_drag_data_received), NULL);
//    gtk_tool_palette_add_drag_dest (GTK_TOOL_PALETTE (palette), target,
//                                    GTK_DEST_DEFAULT_ALL,
//                                    GTK_TOOL_PALETTE_DRAG_ITEMS,
//                                    GDK_ACTION_COPY);
//
//
// CSS nodes
//
// GtkToolPalette has a single CSS node named toolpalette.
type ToolPalette interface {
	Container
	Buildable
	Orientable
	Scrollable

	// AddDragDest sets @palette as drag source (see
	// gtk_tool_palette_set_drag_source()) and sets @widget as a drag
	// destination for drags from @palette. See gtk_drag_dest_set().
	AddDragDest(widget Widget, flags DestDefaults, targets ToolPaletteDragTargets, actions gdk.DragAction)
	// DragItem: get the dragged item from the selection. This could be a
	// ToolItem or a ToolItemGroup.
	DragItem(selection *SelectionData) Widget
	// DropGroup gets the group at position (x, y).
	DropGroup(x int, y int) ToolItemGroup
	// DropItem gets the item at position (x, y). See
	// gtk_tool_palette_get_drop_group().
	DropItem(x int, y int) ToolItem
	// Exclusive gets whether @group is exclusive or not. See
	// gtk_tool_palette_set_exclusive().
	Exclusive(group ToolItemGroup) bool
	// Expand gets whether group should be given extra space. See
	// gtk_tool_palette_set_expand().
	Expand(group ToolItemGroup) bool
	// GroupPosition gets the position of @group in @palette as index. See
	// gtk_tool_palette_set_group_position().
	GroupPosition(group ToolItemGroup) int
	// HAdjustment gets the horizontal adjustment of the tool palette.
	HAdjustment() Adjustment
	// IconSize gets the size of icons in the tool palette. See
	// gtk_tool_palette_set_icon_size().
	IconSize() int
	// Style gets the style (icons, text or both) of items in the tool palette.
	Style() ToolbarStyle
	// VAdjustment gets the vertical adjustment of the tool palette.
	VAdjustment() Adjustment
	// SetDragSource sets the tool palette as a drag source. Enables all groups
	// and items in the tool palette as drag sources on button 1 and button 3
	// press with copy and move actions. See gtk_drag_source_set().
	SetDragSource(targets ToolPaletteDragTargets)
	// SetExclusive sets whether the group should be exclusive or not. If an
	// exclusive group is expanded all other groups are collapsed.
	SetExclusive(group ToolItemGroup, exclusive bool)
	// SetExpand sets whether the group should be given extra space.
	SetExpand(group ToolItemGroup, expand bool)
	// SetGroupPosition sets the position of the group as an index of the tool
	// palette. If position is 0 the group will become the first child, if
	// position is -1 it will become the last child.
	SetGroupPosition(group ToolItemGroup, position int)
	// SetIconSize sets the size of icons in the tool palette.
	SetIconSize(iconSize int)
	// SetStyle sets the style (text, icons or both) of items in the tool
	// palette.
	SetStyle(style ToolbarStyle)
	// UnsetIconSize unsets the tool palette icon size set with
	// gtk_tool_palette_set_icon_size(), so that user preferences will be used
	// to determine the icon size.
	UnsetIconSize()
	// UnsetStyle unsets a toolbar style set with gtk_tool_palette_set_style(),
	// so that user preferences will be used to determine the toolbar style.
	UnsetStyle()
}

// toolPalette implements the ToolPalette class.
type toolPalette struct {
	Container
	Buildable
	Orientable
	Scrollable
}

var _ ToolPalette = (*toolPalette)(nil)

// WrapToolPalette wraps a GObject to the right type. It is
// primarily used internally.
func WrapToolPalette(obj *externglib.Object) ToolPalette {
	return toolPalette{
		Container:  WrapContainer(obj),
		Buildable:  WrapBuildable(obj),
		Orientable: WrapOrientable(obj),
		Scrollable: WrapScrollable(obj),
	}
}

func marshalToolPalette(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapToolPalette(obj), nil
}

// NewToolPalette creates a new tool palette.
func NewToolPalette() ToolPalette {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_tool_palette_new()

	var _toolPalette ToolPalette // out

	_toolPalette = WrapToolPalette(externglib.Take(unsafe.Pointer(_cret)))

	return _toolPalette
}

// AddDragDest sets @palette as drag source (see
// gtk_tool_palette_set_drag_source()) and sets @widget as a drag destination
// for drags from @palette. See gtk_drag_dest_set().
func (p toolPalette) AddDragDest(widget Widget, flags DestDefaults, targets ToolPaletteDragTargets, actions gdk.DragAction) {
	var _arg0 *C.GtkToolPalette           // out
	var _arg1 *C.GtkWidget                // out
	var _arg2 C.GtkDestDefaults           // out
	var _arg3 C.GtkToolPaletteDragTargets // out
	var _arg4 C.GdkDragAction             // out

	_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (C.GtkDestDefaults)(flags)
	_arg3 = (C.GtkToolPaletteDragTargets)(targets)
	_arg4 = (C.GdkDragAction)(actions)

	C.gtk_tool_palette_add_drag_dest(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// DragItem: get the dragged item from the selection. This could be a ToolItem
// or a ToolItemGroup.
func (p toolPalette) DragItem(selection *SelectionData) Widget {
	var _arg0 *C.GtkToolPalette   // out
	var _arg1 *C.GtkSelectionData // out
	var _cret *C.GtkWidget        // in

	_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkSelectionData)(unsafe.Pointer(selection.Native()))

	_cret = C.gtk_tool_palette_get_drag_item(_arg0, _arg1)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// DropGroup gets the group at position (x, y).
func (p toolPalette) DropGroup(x int, y int) ToolItemGroup {
	var _arg0 *C.GtkToolPalette   // out
	var _arg1 C.gint              // out
	var _arg2 C.gint              // out
	var _cret *C.GtkToolItemGroup // in

	_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))
	_arg1 = (C.gint)(x)
	_arg2 = (C.gint)(y)

	_cret = C.gtk_tool_palette_get_drop_group(_arg0, _arg1, _arg2)

	var _toolItemGroup ToolItemGroup // out

	_toolItemGroup = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ToolItemGroup)

	return _toolItemGroup
}

// DropItem gets the item at position (x, y). See
// gtk_tool_palette_get_drop_group().
func (p toolPalette) DropItem(x int, y int) ToolItem {
	var _arg0 *C.GtkToolPalette // out
	var _arg1 C.gint            // out
	var _arg2 C.gint            // out
	var _cret *C.GtkToolItem    // in

	_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))
	_arg1 = (C.gint)(x)
	_arg2 = (C.gint)(y)

	_cret = C.gtk_tool_palette_get_drop_item(_arg0, _arg1, _arg2)

	var _toolItem ToolItem // out

	_toolItem = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ToolItem)

	return _toolItem
}

// Exclusive gets whether @group is exclusive or not. See
// gtk_tool_palette_set_exclusive().
func (p toolPalette) Exclusive(group ToolItemGroup) bool {
	var _arg0 *C.GtkToolPalette   // out
	var _arg1 *C.GtkToolItemGroup // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkToolItemGroup)(unsafe.Pointer(group.Native()))

	_cret = C.gtk_tool_palette_get_exclusive(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Expand gets whether group should be given extra space. See
// gtk_tool_palette_set_expand().
func (p toolPalette) Expand(group ToolItemGroup) bool {
	var _arg0 *C.GtkToolPalette   // out
	var _arg1 *C.GtkToolItemGroup // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkToolItemGroup)(unsafe.Pointer(group.Native()))

	_cret = C.gtk_tool_palette_get_expand(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// GroupPosition gets the position of @group in @palette as index. See
// gtk_tool_palette_set_group_position().
func (p toolPalette) GroupPosition(group ToolItemGroup) int {
	var _arg0 *C.GtkToolPalette   // out
	var _arg1 *C.GtkToolItemGroup // out
	var _cret C.gint              // in

	_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkToolItemGroup)(unsafe.Pointer(group.Native()))

	_cret = C.gtk_tool_palette_get_group_position(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// HAdjustment gets the horizontal adjustment of the tool palette.
func (p toolPalette) HAdjustment() Adjustment {
	var _arg0 *C.GtkToolPalette // out
	var _cret *C.GtkAdjustment  // in

	_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_tool_palette_get_hadjustment(_arg0)

	var _adjustment Adjustment // out

	_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

	return _adjustment
}

// IconSize gets the size of icons in the tool palette. See
// gtk_tool_palette_set_icon_size().
func (p toolPalette) IconSize() int {
	var _arg0 *C.GtkToolPalette // out
	var _cret C.GtkIconSize     // in

	_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_tool_palette_get_icon_size(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Style gets the style (icons, text or both) of items in the tool palette.
func (p toolPalette) Style() ToolbarStyle {
	var _arg0 *C.GtkToolPalette // out
	var _cret C.GtkToolbarStyle // in

	_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_tool_palette_get_style(_arg0)

	var _toolbarStyle ToolbarStyle // out

	_toolbarStyle = ToolbarStyle(_cret)

	return _toolbarStyle
}

// VAdjustment gets the vertical adjustment of the tool palette.
func (p toolPalette) VAdjustment() Adjustment {
	var _arg0 *C.GtkToolPalette // out
	var _cret *C.GtkAdjustment  // in

	_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_tool_palette_get_vadjustment(_arg0)

	var _adjustment Adjustment // out

	_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

	return _adjustment
}

// SetDragSource sets the tool palette as a drag source. Enables all groups and
// items in the tool palette as drag sources on button 1 and button 3 press with
// copy and move actions. See gtk_drag_source_set().
func (p toolPalette) SetDragSource(targets ToolPaletteDragTargets) {
	var _arg0 *C.GtkToolPalette           // out
	var _arg1 C.GtkToolPaletteDragTargets // out

	_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))
	_arg1 = (C.GtkToolPaletteDragTargets)(targets)

	C.gtk_tool_palette_set_drag_source(_arg0, _arg1)
}

// SetExclusive sets whether the group should be exclusive or not. If an
// exclusive group is expanded all other groups are collapsed.
func (p toolPalette) SetExclusive(group ToolItemGroup, exclusive bool) {
	var _arg0 *C.GtkToolPalette   // out
	var _arg1 *C.GtkToolItemGroup // out
	var _arg2 C.gboolean          // out

	_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkToolItemGroup)(unsafe.Pointer(group.Native()))
	if exclusive {
		_arg2 = C.TRUE
	}

	C.gtk_tool_palette_set_exclusive(_arg0, _arg1, _arg2)
}

// SetExpand sets whether the group should be given extra space.
func (p toolPalette) SetExpand(group ToolItemGroup, expand bool) {
	var _arg0 *C.GtkToolPalette   // out
	var _arg1 *C.GtkToolItemGroup // out
	var _arg2 C.gboolean          // out

	_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkToolItemGroup)(unsafe.Pointer(group.Native()))
	if expand {
		_arg2 = C.TRUE
	}

	C.gtk_tool_palette_set_expand(_arg0, _arg1, _arg2)
}

// SetGroupPosition sets the position of the group as an index of the tool
// palette. If position is 0 the group will become the first child, if position
// is -1 it will become the last child.
func (p toolPalette) SetGroupPosition(group ToolItemGroup, position int) {
	var _arg0 *C.GtkToolPalette   // out
	var _arg1 *C.GtkToolItemGroup // out
	var _arg2 C.gint              // out

	_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkToolItemGroup)(unsafe.Pointer(group.Native()))
	_arg2 = (C.gint)(position)

	C.gtk_tool_palette_set_group_position(_arg0, _arg1, _arg2)
}

// SetIconSize sets the size of icons in the tool palette.
func (p toolPalette) SetIconSize(iconSize int) {
	var _arg0 *C.GtkToolPalette // out
	var _arg1 C.GtkIconSize     // out

	_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))
	_arg1 = (C.GtkIconSize)(iconSize)

	C.gtk_tool_palette_set_icon_size(_arg0, _arg1)
}

// SetStyle sets the style (text, icons or both) of items in the tool palette.
func (p toolPalette) SetStyle(style ToolbarStyle) {
	var _arg0 *C.GtkToolPalette // out
	var _arg1 C.GtkToolbarStyle // out

	_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))
	_arg1 = (C.GtkToolbarStyle)(style)

	C.gtk_tool_palette_set_style(_arg0, _arg1)
}

// UnsetIconSize unsets the tool palette icon size set with
// gtk_tool_palette_set_icon_size(), so that user preferences will be used to
// determine the icon size.
func (p toolPalette) UnsetIconSize() {
	var _arg0 *C.GtkToolPalette // out

	_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))

	C.gtk_tool_palette_unset_icon_size(_arg0)
}

// UnsetStyle unsets a toolbar style set with gtk_tool_palette_set_style(), so
// that user preferences will be used to determine the toolbar style.
func (p toolPalette) UnsetStyle() {
	var _arg0 *C.GtkToolPalette // out

	_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))

	C.gtk_tool_palette_unset_style(_arg0)
}

// Toolbar: a toolbar is created with a call to gtk_toolbar_new().
//
// A toolbar can contain instances of a subclass of ToolItem. To add a ToolItem
// to the a toolbar, use gtk_toolbar_insert(). To remove an item from the
// toolbar use gtk_container_remove(). To add a button to the toolbar, add an
// instance of ToolButton.
//
// Toolbar items can be visually grouped by adding instances of
// SeparatorToolItem to the toolbar. If the GtkToolbar child property “expand”
// is UE and the property SeparatorToolItem:draw is set to LSE, the effect is to
// force all following items to the end of the toolbar.
//
// By default, a toolbar can be shrunk, upon which it will add an arrow button
// to show an overflow menu offering access to any ToolItem child that has a
// proxy menu item. To disable this and request enough size for all children,
// call gtk_toolbar_set_show_arrow() to set Toolbar:show-arrow to false.
//
// Creating a context menu for the toolbar can be done by connecting to the
// Toolbar::popup-context-menu signal.
//
//
// CSS nodes
//
// GtkToolbar has a single CSS node with name toolbar.
type Toolbar interface {
	Container
	Buildable
	Orientable
	ToolShell

	// DropIndex returns the position corresponding to the indicated point on
	// @toolbar. This is useful when dragging items to the toolbar: this
	// function returns the position a new item should be inserted.
	//
	// @x and @y are in @toolbar coordinates.
	DropIndex(x int, y int) int
	// IconSize retrieves the icon size for the toolbar. See
	// gtk_toolbar_set_icon_size().
	IconSize() IconSize
	// ItemIndex returns the position of @item on the toolbar, starting from 0.
	// It is an error if @item is not a child of the toolbar.
	ItemIndex(item ToolItem) int
	// NItems returns the number of items on the toolbar.
	NItems() int
	// NthItem returns the @n'th item on @toolbar, or nil if the toolbar does
	// not contain an @n'th item.
	NthItem(n int) ToolItem
	// ReliefStyle returns the relief style of buttons on @toolbar. See
	// gtk_button_set_relief().
	ReliefStyle() ReliefStyle
	// ShowArrow returns whether the toolbar has an overflow menu. See
	// gtk_toolbar_set_show_arrow().
	ShowArrow() bool
	// Style retrieves whether the toolbar has text, icons, or both . See
	// gtk_toolbar_set_style().
	Style() ToolbarStyle
	// Insert: insert a ToolItem into the toolbar at position @pos. If @pos is 0
	// the item is prepended to the start of the toolbar. If @pos is negative,
	// the item is appended to the end of the toolbar.
	Insert(item ToolItem, pos int)
	// SetDropHighlightItem highlights @toolbar to give an idea of what it would
	// look like if @item was added to @toolbar at the position indicated by
	// @index_. If @item is nil, highlighting is turned off. In that case
	// @index_ is ignored.
	//
	// The @tool_item passed to this function must not be part of any widget
	// hierarchy. When an item is set as drop highlight item it can not added to
	// any widget hierarchy or used as highlight item for another toolbar.
	SetDropHighlightItem(toolItem ToolItem, index_ int)
	// SetIconSize: this function sets the size of stock icons in the toolbar.
	// You can call it both before you add the icons and after they’ve been
	// added. The size you set will override user preferences for the default
	// icon size.
	//
	// This should only be used for special-purpose toolbars, normal application
	// toolbars should respect the user preferences for the size of icons.
	SetIconSize(iconSize IconSize)
	// SetShowArrow sets whether to show an overflow menu when @toolbar isn’t
	// allocated enough size to show all of its items. If true, items which
	// can’t fit in @toolbar, and which have a proxy menu item set by
	// gtk_tool_item_set_proxy_menu_item() or ToolItem::create-menu-proxy, will
	// be available in an overflow menu, which can be opened by an added arrow
	// button. If false, @toolbar will request enough size to fit all of its
	// child items without any overflow.
	SetShowArrow(showArrow bool)
	// SetStyle alters the view of @toolbar to display either icons only, text
	// only, or both.
	SetStyle(style ToolbarStyle)
	// UnsetIconSize unsets toolbar icon size set with
	// gtk_toolbar_set_icon_size(), so that user preferences will be used to
	// determine the icon size.
	UnsetIconSize()
	// UnsetStyle unsets a toolbar style set with gtk_toolbar_set_style(), so
	// that user preferences will be used to determine the toolbar style.
	UnsetStyle()
}

// toolbar implements the Toolbar class.
type toolbar struct {
	Container
	Buildable
	Orientable
	ToolShell
}

var _ Toolbar = (*toolbar)(nil)

// WrapToolbar wraps a GObject to the right type. It is
// primarily used internally.
func WrapToolbar(obj *externglib.Object) Toolbar {
	return toolbar{
		Container:  WrapContainer(obj),
		Buildable:  WrapBuildable(obj),
		Orientable: WrapOrientable(obj),
		ToolShell:  WrapToolShell(obj),
	}
}

func marshalToolbar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapToolbar(obj), nil
}

// NewToolbar creates a new toolbar.
func NewToolbar() Toolbar {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_toolbar_new()

	var _toolbar Toolbar // out

	_toolbar = WrapToolbar(externglib.Take(unsafe.Pointer(_cret)))

	return _toolbar
}

// DropIndex returns the position corresponding to the indicated point on
// @toolbar. This is useful when dragging items to the toolbar: this function
// returns the position a new item should be inserted.
//
// @x and @y are in @toolbar coordinates.
func (t toolbar) DropIndex(x int, y int) int {
	var _arg0 *C.GtkToolbar // out
	var _arg1 C.gint        // out
	var _arg2 C.gint        // out
	var _cret C.gint        // in

	_arg0 = (*C.GtkToolbar)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(x)
	_arg2 = (C.gint)(y)

	_cret = C.gtk_toolbar_get_drop_index(_arg0, _arg1, _arg2)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// IconSize retrieves the icon size for the toolbar. See
// gtk_toolbar_set_icon_size().
func (t toolbar) IconSize() IconSize {
	var _arg0 *C.GtkToolbar // out
	var _cret C.GtkIconSize // in

	_arg0 = (*C.GtkToolbar)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_toolbar_get_icon_size(_arg0)

	var _iconSize IconSize // out

	_iconSize = IconSize(_cret)

	return _iconSize
}

// ItemIndex returns the position of @item on the toolbar, starting from 0. It
// is an error if @item is not a child of the toolbar.
func (t toolbar) ItemIndex(item ToolItem) int {
	var _arg0 *C.GtkToolbar  // out
	var _arg1 *C.GtkToolItem // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkToolbar)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkToolItem)(unsafe.Pointer(item.Native()))

	_cret = C.gtk_toolbar_get_item_index(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// NItems returns the number of items on the toolbar.
func (t toolbar) NItems() int {
	var _arg0 *C.GtkToolbar // out
	var _cret C.gint        // in

	_arg0 = (*C.GtkToolbar)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_toolbar_get_n_items(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// NthItem returns the @n'th item on @toolbar, or nil if the toolbar does not
// contain an @n'th item.
func (t toolbar) NthItem(n int) ToolItem {
	var _arg0 *C.GtkToolbar  // out
	var _arg1 C.gint         // out
	var _cret *C.GtkToolItem // in

	_arg0 = (*C.GtkToolbar)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(n)

	_cret = C.gtk_toolbar_get_nth_item(_arg0, _arg1)

	var _toolItem ToolItem // out

	_toolItem = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ToolItem)

	return _toolItem
}

// ReliefStyle returns the relief style of buttons on @toolbar. See
// gtk_button_set_relief().
func (t toolbar) ReliefStyle() ReliefStyle {
	var _arg0 *C.GtkToolbar    // out
	var _cret C.GtkReliefStyle // in

	_arg0 = (*C.GtkToolbar)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_toolbar_get_relief_style(_arg0)

	var _reliefStyle ReliefStyle // out

	_reliefStyle = ReliefStyle(_cret)

	return _reliefStyle
}

// ShowArrow returns whether the toolbar has an overflow menu. See
// gtk_toolbar_set_show_arrow().
func (t toolbar) ShowArrow() bool {
	var _arg0 *C.GtkToolbar // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkToolbar)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_toolbar_get_show_arrow(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Style retrieves whether the toolbar has text, icons, or both . See
// gtk_toolbar_set_style().
func (t toolbar) Style() ToolbarStyle {
	var _arg0 *C.GtkToolbar     // out
	var _cret C.GtkToolbarStyle // in

	_arg0 = (*C.GtkToolbar)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_toolbar_get_style(_arg0)

	var _toolbarStyle ToolbarStyle // out

	_toolbarStyle = ToolbarStyle(_cret)

	return _toolbarStyle
}

// Insert: insert a ToolItem into the toolbar at position @pos. If @pos is 0 the
// item is prepended to the start of the toolbar. If @pos is negative, the item
// is appended to the end of the toolbar.
func (t toolbar) Insert(item ToolItem, pos int) {
	var _arg0 *C.GtkToolbar  // out
	var _arg1 *C.GtkToolItem // out
	var _arg2 C.gint         // out

	_arg0 = (*C.GtkToolbar)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkToolItem)(unsafe.Pointer(item.Native()))
	_arg2 = (C.gint)(pos)

	C.gtk_toolbar_insert(_arg0, _arg1, _arg2)
}

// SetDropHighlightItem highlights @toolbar to give an idea of what it would
// look like if @item was added to @toolbar at the position indicated by
// @index_. If @item is nil, highlighting is turned off. In that case @index_ is
// ignored.
//
// The @tool_item passed to this function must not be part of any widget
// hierarchy. When an item is set as drop highlight item it can not added to any
// widget hierarchy or used as highlight item for another toolbar.
func (t toolbar) SetDropHighlightItem(toolItem ToolItem, index_ int) {
	var _arg0 *C.GtkToolbar  // out
	var _arg1 *C.GtkToolItem // out
	var _arg2 C.gint         // out

	_arg0 = (*C.GtkToolbar)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkToolItem)(unsafe.Pointer(toolItem.Native()))
	_arg2 = (C.gint)(index_)

	C.gtk_toolbar_set_drop_highlight_item(_arg0, _arg1, _arg2)
}

// SetIconSize: this function sets the size of stock icons in the toolbar. You
// can call it both before you add the icons and after they’ve been added. The
// size you set will override user preferences for the default icon size.
//
// This should only be used for special-purpose toolbars, normal application
// toolbars should respect the user preferences for the size of icons.
func (t toolbar) SetIconSize(iconSize IconSize) {
	var _arg0 *C.GtkToolbar // out
	var _arg1 C.GtkIconSize // out

	_arg0 = (*C.GtkToolbar)(unsafe.Pointer(t.Native()))
	_arg1 = (C.GtkIconSize)(iconSize)

	C.gtk_toolbar_set_icon_size(_arg0, _arg1)
}

// SetShowArrow sets whether to show an overflow menu when @toolbar isn’t
// allocated enough size to show all of its items. If true, items which can’t
// fit in @toolbar, and which have a proxy menu item set by
// gtk_tool_item_set_proxy_menu_item() or ToolItem::create-menu-proxy, will be
// available in an overflow menu, which can be opened by an added arrow button.
// If false, @toolbar will request enough size to fit all of its child items
// without any overflow.
func (t toolbar) SetShowArrow(showArrow bool) {
	var _arg0 *C.GtkToolbar // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkToolbar)(unsafe.Pointer(t.Native()))
	if showArrow {
		_arg1 = C.TRUE
	}

	C.gtk_toolbar_set_show_arrow(_arg0, _arg1)
}

// SetStyle alters the view of @toolbar to display either icons only, text only,
// or both.
func (t toolbar) SetStyle(style ToolbarStyle) {
	var _arg0 *C.GtkToolbar     // out
	var _arg1 C.GtkToolbarStyle // out

	_arg0 = (*C.GtkToolbar)(unsafe.Pointer(t.Native()))
	_arg1 = (C.GtkToolbarStyle)(style)

	C.gtk_toolbar_set_style(_arg0, _arg1)
}

// UnsetIconSize unsets toolbar icon size set with gtk_toolbar_set_icon_size(),
// so that user preferences will be used to determine the icon size.
func (t toolbar) UnsetIconSize() {
	var _arg0 *C.GtkToolbar // out

	_arg0 = (*C.GtkToolbar)(unsafe.Pointer(t.Native()))

	C.gtk_toolbar_unset_icon_size(_arg0)
}

// UnsetStyle unsets a toolbar style set with gtk_toolbar_set_style(), so that
// user preferences will be used to determine the toolbar style.
func (t toolbar) UnsetStyle() {
	var _arg0 *C.GtkToolbar // out

	_arg0 = (*C.GtkToolbar)(unsafe.Pointer(t.Native()))

	C.gtk_toolbar_unset_style(_arg0)
}

// Tooltip: basic tooltips can be realized simply by using
// gtk_widget_set_tooltip_text() or gtk_widget_set_tooltip_markup() without any
// explicit tooltip object.
//
// When you need a tooltip with a little more fancy contents, like adding an
// image, or you want the tooltip to have different contents per TreeView row or
// cell, you will have to do a little more work:
//
// - Set the Widget:has-tooltip property to true, this will make GTK+ monitor
// the widget for motion and related events which are needed to determine when
// and where to show a tooltip.
//
// - Connect to the Widget::query-tooltip signal. This signal will be emitted
// when a tooltip is supposed to be shown. One of the arguments passed to the
// signal handler is a GtkTooltip object. This is the object that we are about
// to display as a tooltip, and can be manipulated in your callback using
// functions like gtk_tooltip_set_icon(). There are functions for setting the
// tooltip’s markup, setting an image from a named icon, or even putting in a
// custom widget.
//
//    Return true from your query-tooltip handler. This causes the tooltip to be
//    show. If you return false, it will not be shown.
//
// In the probably rare case where you want to have even more control over the
// tooltip that is about to be shown, you can set your own Window which will be
// used as tooltip window. This works as follows:
//
// - Set Widget:has-tooltip and connect to Widget::query-tooltip as before. Use
// gtk_widget_set_tooltip_window() to set a Window created by you as tooltip
// window.
//
// - In the Widget::query-tooltip callback you can access your window using
// gtk_widget_get_tooltip_window() and manipulate as you wish. The semantics of
// the return value are exactly as before, return true to show the window, false
// to not show it.
type Tooltip interface {
	gextras.Objector

	// SetCustom replaces the widget packed into the tooltip with
	// @custom_widget. @custom_widget does not get destroyed when the tooltip
	// goes away. By default a box with a Image and Label is embedded in the
	// tooltip, which can be configured using gtk_tooltip_set_markup() and
	// gtk_tooltip_set_icon().
	SetCustom(customWidget Widget)
	// SetIcon sets the icon of the tooltip (which is in front of the text) to
	// be @pixbuf. If @pixbuf is nil, the image will be hidden.
	SetIcon(pixbuf gdkpixbuf.Pixbuf)
	// SetIconFromGIcon sets the icon of the tooltip (which is in front of the
	// text) to be the icon indicated by @gicon with the size indicated by
	// @size. If @gicon is nil, the image will be hidden.
	SetIconFromGIcon(gicon gio.Icon, size int)
	// SetIconFromIconName sets the icon of the tooltip (which is in front of
	// the text) to be the icon indicated by @icon_name with the size indicated
	// by @size. If @icon_name is nil, the image will be hidden.
	SetIconFromIconName(iconName string, size int)
	// SetIconFromStock sets the icon of the tooltip (which is in front of the
	// text) to be the stock item indicated by @stock_id with the size indicated
	// by @size. If @stock_id is nil, the image will be hidden.
	SetIconFromStock(stockId string, size int)
	// SetMarkup sets the text of the tooltip to be @markup, which is marked up
	// with the [Pango text markup language][PangoMarkupFormat]. If @markup is
	// nil, the label will be hidden.
	SetMarkup(markup string)
	// SetText sets the text of the tooltip to be @text. If @text is nil, the
	// label will be hidden. See also gtk_tooltip_set_markup().
	SetText(text string)
	// SetTipArea sets the area of the widget, where the contents of this
	// tooltip apply, to be @rect (in widget coordinates). This is especially
	// useful for properly setting tooltips on TreeView rows and cells,
	// IconViews, etc.
	//
	// For setting tooltips on TreeView, please refer to the convenience
	// functions for this: gtk_tree_view_set_tooltip_row() and
	// gtk_tree_view_set_tooltip_cell().
	SetTipArea(rect *gdk.Rectangle)
}

// tooltip implements the Tooltip class.
type tooltip struct {
	gextras.Objector
}

var _ Tooltip = (*tooltip)(nil)

// WrapTooltip wraps a GObject to the right type. It is
// primarily used internally.
func WrapTooltip(obj *externglib.Object) Tooltip {
	return tooltip{
		Objector: obj,
	}
}

func marshalTooltip(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTooltip(obj), nil
}

// SetCustom replaces the widget packed into the tooltip with @custom_widget.
// @custom_widget does not get destroyed when the tooltip goes away. By default
// a box with a Image and Label is embedded in the tooltip, which can be
// configured using gtk_tooltip_set_markup() and gtk_tooltip_set_icon().
func (t tooltip) SetCustom(customWidget Widget) {
	var _arg0 *C.GtkTooltip // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(customWidget.Native()))

	C.gtk_tooltip_set_custom(_arg0, _arg1)
}

// SetIcon sets the icon of the tooltip (which is in front of the text) to be
// @pixbuf. If @pixbuf is nil, the image will be hidden.
func (t tooltip) SetIcon(pixbuf gdkpixbuf.Pixbuf) {
	var _arg0 *C.GtkTooltip // out
	var _arg1 *C.GdkPixbuf  // out

	_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	C.gtk_tooltip_set_icon(_arg0, _arg1)
}

// SetIconFromGIcon sets the icon of the tooltip (which is in front of the text)
// to be the icon indicated by @gicon with the size indicated by @size. If
// @gicon is nil, the image will be hidden.
func (t tooltip) SetIconFromGIcon(gicon gio.Icon, size int) {
	var _arg0 *C.GtkTooltip // out
	var _arg1 *C.GIcon      // out
	var _arg2 C.GtkIconSize // out

	_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(gicon.Native()))
	_arg2 = (C.GtkIconSize)(size)

	C.gtk_tooltip_set_icon_from_gicon(_arg0, _arg1, _arg2)
}

// SetIconFromIconName sets the icon of the tooltip (which is in front of the
// text) to be the icon indicated by @icon_name with the size indicated by
// @size. If @icon_name is nil, the image will be hidden.
func (t tooltip) SetIconFromIconName(iconName string, size int) {
	var _arg0 *C.GtkTooltip // out
	var _arg1 *C.gchar      // out
	var _arg2 C.GtkIconSize // out

	_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GtkIconSize)(size)

	C.gtk_tooltip_set_icon_from_icon_name(_arg0, _arg1, _arg2)
}

// SetIconFromStock sets the icon of the tooltip (which is in front of the text)
// to be the stock item indicated by @stock_id with the size indicated by @size.
// If @stock_id is nil, the image will be hidden.
func (t tooltip) SetIconFromStock(stockId string, size int) {
	var _arg0 *C.GtkTooltip // out
	var _arg1 *C.gchar      // out
	var _arg2 C.GtkIconSize // out

	_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.gchar)(C.CString(stockId))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GtkIconSize)(size)

	C.gtk_tooltip_set_icon_from_stock(_arg0, _arg1, _arg2)
}

// SetMarkup sets the text of the tooltip to be @markup, which is marked up with
// the [Pango text markup language][PangoMarkupFormat]. If @markup is nil, the
// label will be hidden.
func (t tooltip) SetMarkup(markup string) {
	var _arg0 *C.GtkTooltip // out
	var _arg1 *C.gchar      // out

	_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.gchar)(C.CString(markup))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_tooltip_set_markup(_arg0, _arg1)
}

// SetText sets the text of the tooltip to be @text. If @text is nil, the label
// will be hidden. See also gtk_tooltip_set_markup().
func (t tooltip) SetText(text string) {
	var _arg0 *C.GtkTooltip // out
	var _arg1 *C.gchar      // out

	_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_tooltip_set_text(_arg0, _arg1)
}

// SetTipArea sets the area of the widget, where the contents of this tooltip
// apply, to be @rect (in widget coordinates). This is especially useful for
// properly setting tooltips on TreeView rows and cells, IconViews, etc.
//
// For setting tooltips on TreeView, please refer to the convenience functions
// for this: gtk_tree_view_set_tooltip_row() and
// gtk_tree_view_set_tooltip_cell().
func (t tooltip) SetTipArea(rect *gdk.Rectangle) {
	var _arg0 *C.GtkTooltip   // out
	var _arg1 *C.GdkRectangle // out

	_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GdkRectangle)(unsafe.Pointer(rect.Native()))

	C.gtk_tooltip_set_tip_area(_arg0, _arg1)
}

// TreeModelFilter: a TreeModelFilter is a tree model which wraps another tree
// model, and can do the following things:
//
// - Filter specific rows, based on data from a “visible column”, a column
// storing booleans indicating whether the row should be filtered or not, or
// based on the return value of a “visible function”, which gets a model, iter
// and user_data and returns a boolean indicating whether the row should be
// filtered or not.
//
// - Modify the “appearance” of the model, using a modify function. This is
// extremely powerful and allows for just changing some values and also for
// creating a completely different model based on the given child model.
//
// - Set a different root node, also known as a “virtual root”. You can pass in
// a TreePath indicating the root node for the filter at construction time.
//
// The basic API is similar to TreeModelSort. For an example on its usage, see
// the section on TreeModelSort.
//
// When using TreeModelFilter, it is important to realize that TreeModelFilter
// maintains an internal cache of all nodes which are visible in its clients.
// The cache is likely to be a subtree of the tree exposed by the child model.
// TreeModelFilter will not cache the entire child model when unnecessary to not
// compromise the caching mechanism that is exposed by the reference counting
// scheme. If the child model implements reference counting, unnecessary signals
// may not be emitted because of reference counting rule 3, see the TreeModel
// documentation. (Note that e.g. TreeStore does not implement reference
// counting and will always emit all signals, even when the receiving node is
// not visible).
//
// Because of this, limitations for possible visible functions do apply. In
// general, visible functions should only use data or properties from the node
// for which the visibility state must be determined, its siblings or its
// parents. Usually, having a dependency on the state of any child node is not
// possible, unless references are taken on these explicitly. When no such
// reference exists, no signals may be received for these child nodes (see
// reference couting rule number 3 in the TreeModel section).
//
// Determining the visibility state of a given node based on the state of its
// child nodes is a frequently occurring use case. Therefore, TreeModelFilter
// explicitly supports this. For example, when a node does not have any
// children, you might not want the node to be visible. As soon as the first row
// is added to the node’s child level (or the last row removed), the node’s
// visibility should be updated.
//
// This introduces a dependency from the node on its child nodes. In order to
// accommodate this, TreeModelFilter must make sure the necessary signals are
// received from the child model. This is achieved by building, for all nodes
// which are exposed as visible nodes to TreeModelFilter's clients, the child
// level (if any) and take a reference on the first node in this level.
// Furthermore, for every row-inserted, row-changed or row-deleted signal (also
// these which were not handled because the node was not cached),
// TreeModelFilter will check if the visibility state of any parent node has
// changed.
//
// Beware, however, that this explicit support is limited to these two cases.
// For example, if you want a node to be visible only if two nodes in a child’s
// child level (2 levels deeper) are visible, you are on your own. In this case,
// either rely on TreeStore to emit all signals because it does not implement
// reference counting, or for models that do implement reference counting,
// obtain references on these child levels yourself.
type TreeModelFilter interface {
	gextras.Objector
	TreeDragSource
	TreeModel

	// ClearCache: this function should almost never be called. It clears the
	// @filter of any cached iterators that haven’t been reffed with
	// gtk_tree_model_ref_node(). This might be useful if the child model being
	// filtered is static (and doesn’t change often) and there has been a lot of
	// unreffed access to nodes. As a side effect of this function, all unreffed
	// iters will be invalid.
	ClearCache()
	// ConvertChildIterToIter sets @filter_iter to point to the row in @filter
	// that corresponds to the row pointed at by @child_iter. If @filter_iter
	// was not set, false is returned.
	ConvertChildIterToIter(childIter *TreeIter) (TreeIter, bool)
	// ConvertChildPathToPath converts @child_path to a path relative to
	// @filter. That is, @child_path points to a path in the child model. The
	// rerturned path will point to the same row in the filtered model. If
	// @child_path isn’t a valid path on the child model or points to a row
	// which is not visible in @filter, then nil is returned.
	ConvertChildPathToPath(childPath *TreePath) *TreePath
	// ConvertIterToChildIter sets @child_iter to point to the row pointed to by
	// @filter_iter.
	ConvertIterToChildIter(filterIter *TreeIter) TreeIter
	// ConvertPathToChildPath converts @filter_path to a path on the child model
	// of @filter. That is, @filter_path points to a location in @filter. The
	// returned path will point to the same location in the model not being
	// filtered. If @filter_path does not point to a location in the child
	// model, nil is returned.
	ConvertPathToChildPath(filterPath *TreePath) *TreePath
	// Model returns a pointer to the child model of @filter.
	Model() TreeModel
	// Refilter emits ::row_changed for each row in the child model, which
	// causes the filter to re-evaluate whether a row is visible or not.
	Refilter()
	// SetVisibleColumn sets @column of the child_model to be the column where
	// @filter should look for visibility information. @columns should be a
	// column of type G_TYPE_BOOLEAN, where true means that a row is visible,
	// and false if not.
	//
	// Note that gtk_tree_model_filter_set_visible_func() or
	// gtk_tree_model_filter_set_visible_column() can only be called once for a
	// given filter model.
	SetVisibleColumn(column int)
}

// treeModelFilter implements the TreeModelFilter class.
type treeModelFilter struct {
	gextras.Objector
	TreeDragSource
	TreeModel
}

var _ TreeModelFilter = (*treeModelFilter)(nil)

// WrapTreeModelFilter wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeModelFilter(obj *externglib.Object) TreeModelFilter {
	return treeModelFilter{
		Objector:       obj,
		TreeDragSource: WrapTreeDragSource(obj),
		TreeModel:      WrapTreeModel(obj),
	}
}

func marshalTreeModelFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeModelFilter(obj), nil
}

// ClearCache: this function should almost never be called. It clears the
// @filter of any cached iterators that haven’t been reffed with
// gtk_tree_model_ref_node(). This might be useful if the child model being
// filtered is static (and doesn’t change often) and there has been a lot of
// unreffed access to nodes. As a side effect of this function, all unreffed
// iters will be invalid.
func (f treeModelFilter) ClearCache() {
	var _arg0 *C.GtkTreeModelFilter // out

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))

	C.gtk_tree_model_filter_clear_cache(_arg0)
}

// ConvertChildIterToIter sets @filter_iter to point to the row in @filter that
// corresponds to the row pointed at by @child_iter. If @filter_iter was not
// set, false is returned.
func (f treeModelFilter) ConvertChildIterToIter(childIter *TreeIter) (TreeIter, bool) {
	var _arg0 *C.GtkTreeModelFilter // out
	var _filterIter TreeIter
	var _arg2 *C.GtkTreeIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(childIter.Native()))

	_cret = C.gtk_tree_model_filter_convert_child_iter_to_iter(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_filterIter)), _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _filterIter, _ok
}

// ConvertChildPathToPath converts @child_path to a path relative to @filter.
// That is, @child_path points to a path in the child model. The rerturned path
// will point to the same row in the filtered model. If @child_path isn’t a
// valid path on the child model or points to a row which is not visible in
// @filter, then nil is returned.
func (f treeModelFilter) ConvertChildPathToPath(childPath *TreePath) *TreePath {
	var _arg0 *C.GtkTreeModelFilter // out
	var _arg1 *C.GtkTreePath        // out
	var _cret *C.GtkTreePath        // in

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(childPath.Native()))

	_cret = C.gtk_tree_model_filter_convert_child_path_to_path(_arg0, _arg1)

	var _treePath *TreePath // out

	_treePath = WrapTreePath(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treePath, func(v *TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treePath
}

// ConvertIterToChildIter sets @child_iter to point to the row pointed to by
// @filter_iter.
func (f treeModelFilter) ConvertIterToChildIter(filterIter *TreeIter) TreeIter {
	var _arg0 *C.GtkTreeModelFilter // out
	var _childIter TreeIter
	var _arg2 *C.GtkTreeIter // out

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(filterIter.Native()))

	C.gtk_tree_model_filter_convert_iter_to_child_iter(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_childIter)), _arg2)

	return _childIter
}

// ConvertPathToChildPath converts @filter_path to a path on the child model of
// @filter. That is, @filter_path points to a location in @filter. The returned
// path will point to the same location in the model not being filtered. If
// @filter_path does not point to a location in the child model, nil is
// returned.
func (f treeModelFilter) ConvertPathToChildPath(filterPath *TreePath) *TreePath {
	var _arg0 *C.GtkTreeModelFilter // out
	var _arg1 *C.GtkTreePath        // out
	var _cret *C.GtkTreePath        // in

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(filterPath.Native()))

	_cret = C.gtk_tree_model_filter_convert_path_to_child_path(_arg0, _arg1)

	var _treePath *TreePath // out

	_treePath = WrapTreePath(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treePath, func(v *TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treePath
}

// Model returns a pointer to the child model of @filter.
func (f treeModelFilter) Model() TreeModel {
	var _arg0 *C.GtkTreeModelFilter // out
	var _cret *C.GtkTreeModel       // in

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))

	_cret = C.gtk_tree_model_filter_get_model(_arg0)

	var _treeModel TreeModel // out

	_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeModel)

	return _treeModel
}

// Refilter emits ::row_changed for each row in the child model, which causes
// the filter to re-evaluate whether a row is visible or not.
func (f treeModelFilter) Refilter() {
	var _arg0 *C.GtkTreeModelFilter // out

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))

	C.gtk_tree_model_filter_refilter(_arg0)
}

// SetVisibleColumn sets @column of the child_model to be the column where
// @filter should look for visibility information. @columns should be a column
// of type G_TYPE_BOOLEAN, where true means that a row is visible, and false if
// not.
//
// Note that gtk_tree_model_filter_set_visible_func() or
// gtk_tree_model_filter_set_visible_column() can only be called once for a
// given filter model.
func (f treeModelFilter) SetVisibleColumn(column int) {
	var _arg0 *C.GtkTreeModelFilter // out
	var _arg1 C.gint                // out

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))
	_arg1 = (C.gint)(column)

	C.gtk_tree_model_filter_set_visible_column(_arg0, _arg1)
}

// TreeModelSort: the TreeModelSort is a model which implements the TreeSortable
// interface. It does not hold any data itself, but rather is created with a
// child model and proxies its data. It has identical column types to this child
// model, and the changes in the child are propagated. The primary purpose of
// this model is to provide a way to sort a different model without modifying
// it. Note that the sort function used by TreeModelSort is not guaranteed to be
// stable.
//
// The use of this is best demonstrated through an example. In the following
// sample code we create two TreeView widgets each with a view of the same data.
// As the model is wrapped here by a TreeModelSort, the two TreeViews can each
// sort their view of the data without affecting the other. By contrast, if we
// simply put the same model in each widget, then sorting the first would sort
// the second.
//
// Using a TreeModelSort
//
//    void
//    selection_changed (GtkTreeSelection *selection, gpointer data)
//    {
//      GtkTreeModel *sort_model = NULL;
//      GtkTreeModel *child_model;
//      GtkTreeIter sort_iter;
//      GtkTreeIter child_iter;
//      char *some_data = NULL;
//      char *modified_data;
//
//      // Get the current selected row and the model.
//      if (! gtk_tree_selection_get_selected (selection,
//                                             &sort_model,
//                                             &sort_iter))
//        return;
//
//      // Look up the current value on the selected row and get
//      // a new value to change it to.
//      gtk_tree_model_get (GTK_TREE_MODEL (sort_model), &sort_iter,
//                          COLUMN_1, &some_data,
//                          -1);
//
//      modified_data = change_the_data (some_data);
//      g_free (some_data);
//
//      // Get an iterator on the child model, instead of the sort model.
//      gtk_tree_model_sort_convert_iter_to_child_iter (GTK_TREE_MODEL_SORT (sort_model),
//                                                      &child_iter,
//                                                      &sort_iter);
//
//      // Get the child model and change the value of the row. In this
//      // example, the child model is a GtkListStore. It could be any other
//      // type of model, though.
//      child_model = gtk_tree_model_sort_get_model (GTK_TREE_MODEL_SORT (sort_model));
//      gtk_list_store_set (GTK_LIST_STORE (child_model), &child_iter,
//                          COLUMN_1, &modified_data,
//                          -1);
//      g_free (modified_data);
//    }
type TreeModelSort interface {
	gextras.Objector
	TreeDragSource
	TreeModel
	TreeSortable

	// ClearCache: this function should almost never be called. It clears the
	// @tree_model_sort of any cached iterators that haven’t been reffed with
	// gtk_tree_model_ref_node(). This might be useful if the child model being
	// sorted is static (and doesn’t change often) and there has been a lot of
	// unreffed access to nodes. As a side effect of this function, all unreffed
	// iters will be invalid.
	ClearCache()
	// ConvertChildIterToIter sets @sort_iter to point to the row in
	// @tree_model_sort that corresponds to the row pointed at by @child_iter.
	// If @sort_iter was not set, false is returned. Note: a boolean is only
	// returned since 2.14.
	ConvertChildIterToIter(childIter *TreeIter) (TreeIter, bool)
	// ConvertChildPathToPath converts @child_path to a path relative to
	// @tree_model_sort. That is, @child_path points to a path in the child
	// model. The returned path will point to the same row in the sorted model.
	// If @child_path isn’t a valid path on the child model, then nil is
	// returned.
	ConvertChildPathToPath(childPath *TreePath) *TreePath
	// ConvertIterToChildIter sets @child_iter to point to the row pointed to by
	// @sorted_iter.
	ConvertIterToChildIter(sortedIter *TreeIter) TreeIter
	// ConvertPathToChildPath converts @sorted_path to a path on the child model
	// of @tree_model_sort. That is, @sorted_path points to a location in
	// @tree_model_sort. The returned path will point to the same location in
	// the model not being sorted. If @sorted_path does not point to a location
	// in the child model, nil is returned.
	ConvertPathToChildPath(sortedPath *TreePath) *TreePath
	// Model returns the model the TreeModelSort is sorting.
	Model() TreeModel
	// IterIsValid: > This function is slow. Only use it for debugging and/or
	// testing > purposes.
	//
	// Checks if the given iter is a valid iter for this TreeModelSort.
	IterIsValid(iter *TreeIter) bool
	// ResetDefaultSortFunc: this resets the default sort function to be in the
	// “unsorted” state. That is, it is in the same order as the child model. It
	// will re-sort the model to be in the same order as the child model only if
	// the TreeModelSort is in “unsorted” state.
	ResetDefaultSortFunc()
}

// treeModelSort implements the TreeModelSort class.
type treeModelSort struct {
	gextras.Objector
	TreeDragSource
	TreeModel
	TreeSortable
}

var _ TreeModelSort = (*treeModelSort)(nil)

// WrapTreeModelSort wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeModelSort(obj *externglib.Object) TreeModelSort {
	return treeModelSort{
		Objector:       obj,
		TreeDragSource: WrapTreeDragSource(obj),
		TreeModel:      WrapTreeModel(obj),
		TreeSortable:   WrapTreeSortable(obj),
	}
}

func marshalTreeModelSort(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeModelSort(obj), nil
}

// NewTreeModelSortWithModel creates a new TreeModelSort, with @child_model as
// the child model.
func NewTreeModelSortWithModel(childModel TreeModel) TreeModelSort {
	var _arg1 *C.GtkTreeModel // out
	var _cret *C.GtkTreeModel // in

	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(childModel.Native()))

	_cret = C.gtk_tree_model_sort_new_with_model(_arg1)

	var _treeModelSort TreeModelSort // out

	_treeModelSort = WrapTreeModelSort(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _treeModelSort
}

// ClearCache: this function should almost never be called. It clears the
// @tree_model_sort of any cached iterators that haven’t been reffed with
// gtk_tree_model_ref_node(). This might be useful if the child model being
// sorted is static (and doesn’t change often) and there has been a lot of
// unreffed access to nodes. As a side effect of this function, all unreffed
// iters will be invalid.
func (t treeModelSort) ClearCache() {
	var _arg0 *C.GtkTreeModelSort // out

	_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(t.Native()))

	C.gtk_tree_model_sort_clear_cache(_arg0)
}

// ConvertChildIterToIter sets @sort_iter to point to the row in
// @tree_model_sort that corresponds to the row pointed at by @child_iter. If
// @sort_iter was not set, false is returned. Note: a boolean is only returned
// since 2.14.
func (t treeModelSort) ConvertChildIterToIter(childIter *TreeIter) (TreeIter, bool) {
	var _arg0 *C.GtkTreeModelSort // out
	var _sortIter TreeIter
	var _arg2 *C.GtkTreeIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(t.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(childIter.Native()))

	_cret = C.gtk_tree_model_sort_convert_child_iter_to_iter(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_sortIter)), _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _sortIter, _ok
}

// ConvertChildPathToPath converts @child_path to a path relative to
// @tree_model_sort. That is, @child_path points to a path in the child model.
// The returned path will point to the same row in the sorted model. If
// @child_path isn’t a valid path on the child model, then nil is returned.
func (t treeModelSort) ConvertChildPathToPath(childPath *TreePath) *TreePath {
	var _arg0 *C.GtkTreeModelSort // out
	var _arg1 *C.GtkTreePath      // out
	var _cret *C.GtkTreePath      // in

	_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(childPath.Native()))

	_cret = C.gtk_tree_model_sort_convert_child_path_to_path(_arg0, _arg1)

	var _treePath *TreePath // out

	_treePath = WrapTreePath(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treePath, func(v *TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treePath
}

// ConvertIterToChildIter sets @child_iter to point to the row pointed to by
// @sorted_iter.
func (t treeModelSort) ConvertIterToChildIter(sortedIter *TreeIter) TreeIter {
	var _arg0 *C.GtkTreeModelSort // out
	var _childIter TreeIter
	var _arg2 *C.GtkTreeIter // out

	_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(t.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(sortedIter.Native()))

	C.gtk_tree_model_sort_convert_iter_to_child_iter(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_childIter)), _arg2)

	return _childIter
}

// ConvertPathToChildPath converts @sorted_path to a path on the child model of
// @tree_model_sort. That is, @sorted_path points to a location in
// @tree_model_sort. The returned path will point to the same location in the
// model not being sorted. If @sorted_path does not point to a location in the
// child model, nil is returned.
func (t treeModelSort) ConvertPathToChildPath(sortedPath *TreePath) *TreePath {
	var _arg0 *C.GtkTreeModelSort // out
	var _arg1 *C.GtkTreePath      // out
	var _cret *C.GtkTreePath      // in

	_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(sortedPath.Native()))

	_cret = C.gtk_tree_model_sort_convert_path_to_child_path(_arg0, _arg1)

	var _treePath *TreePath // out

	_treePath = WrapTreePath(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treePath, func(v *TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treePath
}

// Model returns the model the TreeModelSort is sorting.
func (t treeModelSort) Model() TreeModel {
	var _arg0 *C.GtkTreeModelSort // out
	var _cret *C.GtkTreeModel     // in

	_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_model_sort_get_model(_arg0)

	var _treeModel TreeModel // out

	_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeModel)

	return _treeModel
}

// IterIsValid: > This function is slow. Only use it for debugging and/or
// testing > purposes.
//
// Checks if the given iter is a valid iter for this TreeModelSort.
func (t treeModelSort) IterIsValid(iter *TreeIter) bool {
	var _arg0 *C.GtkTreeModelSort // out
	var _arg1 *C.GtkTreeIter      // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_tree_model_sort_iter_is_valid(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ResetDefaultSortFunc: this resets the default sort function to be in the
// “unsorted” state. That is, it is in the same order as the child model. It
// will re-sort the model to be in the same order as the child model only if the
// TreeModelSort is in “unsorted” state.
func (t treeModelSort) ResetDefaultSortFunc() {
	var _arg0 *C.GtkTreeModelSort // out

	_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(t.Native()))

	C.gtk_tree_model_sort_reset_default_sort_func(_arg0)
}

// TreeSelection: the TreeSelection object is a helper object to manage the
// selection for a TreeView widget. The TreeSelection object is automatically
// created when a new TreeView widget is created, and cannot exist independently
// of this widget. The primary reason the TreeSelection objects exists is for
// cleanliness of code and API. That is, there is no conceptual reason all these
// functions could not be methods on the TreeView widget instead of a separate
// function.
//
// The TreeSelection object is gotten from a TreeView by calling
// gtk_tree_view_get_selection(). It can be manipulated to check the selection
// status of the tree, as well as select and deselect individual rows. Selection
// is done completely view side. As a result, multiple views of the same model
// can have completely different selections. Additionally, you cannot change the
// selection of a row on the model that is not currently displayed by the view
// without expanding its parents first.
//
// One of the important things to remember when monitoring the selection of a
// view is that the TreeSelection::changed signal is mostly a hint. That is, it
// may only emit one signal when a range of rows is selected. Additionally, it
// may on occasion emit a TreeSelection::changed signal when nothing has
// happened (mostly as a result of programmers calling select_row on an already
// selected row).
type TreeSelection interface {
	gextras.Objector

	// CountSelectedRows returns the number of rows that have been selected in
	// @tree.
	CountSelectedRows() int
	// Mode gets the selection mode for @selection. See
	// gtk_tree_selection_set_mode().
	Mode() SelectionMode
	// Selected sets @iter to the currently selected node if @selection is set
	// to K_SELECTION_SINGLE or K_SELECTION_BROWSE. @iter may be NULL if you
	// just want to test if @selection has any selected nodes. @model is filled
	// with the current model as a convenience. This function will not work if
	// you use @selection is K_SELECTION_MULTIPLE.
	Selected() (TreeModel, TreeIter, bool)
	// TreeView returns the tree view associated with @selection.
	TreeView() TreeView
	// IterIsSelected returns true if the row at @iter is currently selected.
	IterIsSelected(iter *TreeIter) bool
	// PathIsSelected returns true if the row pointed to by @path is currently
	// selected. If @path does not point to a valid location, false is returned
	PathIsSelected(path *TreePath) bool
	// SelectAll selects all the nodes. @selection must be set to
	// K_SELECTION_MULTIPLE mode.
	SelectAll()
	// SelectIter selects the specified iterator.
	SelectIter(iter *TreeIter)
	// SelectPath: select the row at @path.
	SelectPath(path *TreePath)
	// SelectRange selects a range of nodes, determined by @start_path and
	// @end_path inclusive. @selection must be set to K_SELECTION_MULTIPLE mode.
	SelectRange(startPath *TreePath, endPath *TreePath)
	// SetMode sets the selection mode of the @selection. If the previous type
	// was K_SELECTION_MULTIPLE, then the anchor is kept selected, if it was
	// previously selected.
	SetMode(typ SelectionMode)
	// UnselectAll unselects all the nodes.
	UnselectAll()
	// UnselectIter unselects the specified iterator.
	UnselectIter(iter *TreeIter)
	// UnselectPath unselects the row at @path.
	UnselectPath(path *TreePath)
	// UnselectRange unselects a range of nodes, determined by @start_path and
	// @end_path inclusive.
	UnselectRange(startPath *TreePath, endPath *TreePath)
}

// treeSelection implements the TreeSelection class.
type treeSelection struct {
	gextras.Objector
}

var _ TreeSelection = (*treeSelection)(nil)

// WrapTreeSelection wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeSelection(obj *externglib.Object) TreeSelection {
	return treeSelection{
		Objector: obj,
	}
}

func marshalTreeSelection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeSelection(obj), nil
}

// CountSelectedRows returns the number of rows that have been selected in
// @tree.
func (s treeSelection) CountSelectedRows() int {
	var _arg0 *C.GtkTreeSelection // out
	var _cret C.gint              // in

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_tree_selection_count_selected_rows(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Mode gets the selection mode for @selection. See
// gtk_tree_selection_set_mode().
func (s treeSelection) Mode() SelectionMode {
	var _arg0 *C.GtkTreeSelection // out
	var _cret C.GtkSelectionMode  // in

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_tree_selection_get_mode(_arg0)

	var _selectionMode SelectionMode // out

	_selectionMode = SelectionMode(_cret)

	return _selectionMode
}

// Selected sets @iter to the currently selected node if @selection is set to
// K_SELECTION_SINGLE or K_SELECTION_BROWSE. @iter may be NULL if you just want
// to test if @selection has any selected nodes. @model is filled with the
// current model as a convenience. This function will not work if you use
// @selection is K_SELECTION_MULTIPLE.
func (s treeSelection) Selected() (TreeModel, TreeIter, bool) {
	var _arg0 *C.GtkTreeSelection // out
	var _arg1 *C.GtkTreeModel     // in
	var _iter TreeIter
	var _cret C.gboolean // in

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_tree_selection_get_selected(_arg0, &_arg1, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)))

	var _model TreeModel // out

	var _ok bool // out

	_model = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg1))).(TreeModel)

	if _cret != 0 {
		_ok = true
	}

	return _model, _iter, _ok
}

// TreeView returns the tree view associated with @selection.
func (s treeSelection) TreeView() TreeView {
	var _arg0 *C.GtkTreeSelection // out
	var _cret *C.GtkTreeView      // in

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_tree_selection_get_tree_view(_arg0)

	var _treeView TreeView // out

	_treeView = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeView)

	return _treeView
}

// IterIsSelected returns true if the row at @iter is currently selected.
func (s treeSelection) IterIsSelected(iter *TreeIter) bool {
	var _arg0 *C.GtkTreeSelection // out
	var _arg1 *C.GtkTreeIter      // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_tree_selection_iter_is_selected(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PathIsSelected returns true if the row pointed to by @path is currently
// selected. If @path does not point to a valid location, false is returned
func (s treeSelection) PathIsSelected(path *TreePath) bool {
	var _arg0 *C.GtkTreeSelection // out
	var _arg1 *C.GtkTreePath      // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	_cret = C.gtk_tree_selection_path_is_selected(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SelectAll selects all the nodes. @selection must be set to
// K_SELECTION_MULTIPLE mode.
func (s treeSelection) SelectAll() {
	var _arg0 *C.GtkTreeSelection // out

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

	C.gtk_tree_selection_select_all(_arg0)
}

// SelectIter selects the specified iterator.
func (s treeSelection) SelectIter(iter *TreeIter) {
	var _arg0 *C.GtkTreeSelection // out
	var _arg1 *C.GtkTreeIter      // out

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	C.gtk_tree_selection_select_iter(_arg0, _arg1)
}

// SelectPath: select the row at @path.
func (s treeSelection) SelectPath(path *TreePath) {
	var _arg0 *C.GtkTreeSelection // out
	var _arg1 *C.GtkTreePath      // out

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_tree_selection_select_path(_arg0, _arg1)
}

// SelectRange selects a range of nodes, determined by @start_path and @end_path
// inclusive. @selection must be set to K_SELECTION_MULTIPLE mode.
func (s treeSelection) SelectRange(startPath *TreePath, endPath *TreePath) {
	var _arg0 *C.GtkTreeSelection // out
	var _arg1 *C.GtkTreePath      // out
	var _arg2 *C.GtkTreePath      // out

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(startPath.Native()))
	_arg2 = (*C.GtkTreePath)(unsafe.Pointer(endPath.Native()))

	C.gtk_tree_selection_select_range(_arg0, _arg1, _arg2)
}

// SetMode sets the selection mode of the @selection. If the previous type was
// K_SELECTION_MULTIPLE, then the anchor is kept selected, if it was previously
// selected.
func (s treeSelection) SetMode(typ SelectionMode) {
	var _arg0 *C.GtkTreeSelection // out
	var _arg1 C.GtkSelectionMode  // out

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkSelectionMode)(typ)

	C.gtk_tree_selection_set_mode(_arg0, _arg1)
}

// UnselectAll unselects all the nodes.
func (s treeSelection) UnselectAll() {
	var _arg0 *C.GtkTreeSelection // out

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

	C.gtk_tree_selection_unselect_all(_arg0)
}

// UnselectIter unselects the specified iterator.
func (s treeSelection) UnselectIter(iter *TreeIter) {
	var _arg0 *C.GtkTreeSelection // out
	var _arg1 *C.GtkTreeIter      // out

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	C.gtk_tree_selection_unselect_iter(_arg0, _arg1)
}

// UnselectPath unselects the row at @path.
func (s treeSelection) UnselectPath(path *TreePath) {
	var _arg0 *C.GtkTreeSelection // out
	var _arg1 *C.GtkTreePath      // out

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_tree_selection_unselect_path(_arg0, _arg1)
}

// UnselectRange unselects a range of nodes, determined by @start_path and
// @end_path inclusive.
func (s treeSelection) UnselectRange(startPath *TreePath, endPath *TreePath) {
	var _arg0 *C.GtkTreeSelection // out
	var _arg1 *C.GtkTreePath      // out
	var _arg2 *C.GtkTreePath      // out

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(startPath.Native()))
	_arg2 = (*C.GtkTreePath)(unsafe.Pointer(endPath.Native()))

	C.gtk_tree_selection_unselect_range(_arg0, _arg1, _arg2)
}

// TreeStore: the TreeStore object is a list model for use with a TreeView
// widget. It implements the TreeModel interface, and consequentially, can use
// all of the methods available there. It also implements the TreeSortable
// interface so it can be sorted by the view. Finally, it also implements the
// tree [drag and drop][gtk3-GtkTreeView-drag-and-drop] interfaces.
//
//
// GtkTreeStore as GtkBuildable
//
// The GtkTreeStore implementation of the Buildable interface allows to specify
// the model columns with a <columns> element that may contain multiple <column>
// elements, each specifying one model column. The “type” attribute specifies
// the data type for the column.
//
// An example of a UI Definition fragment for a tree store:
//
//    <object class="GtkTreeStore">
//      <columns>
//        <column type="gchararray"/>
//        <column type="gchararray"/>
//        <column type="gint"/>
//      </columns>
//    </object>
type TreeStore interface {
	gextras.Objector
	Buildable
	TreeDragDest
	TreeDragSource
	TreeModel
	TreeSortable

	// Append appends a new row to @tree_store. If @parent is non-nil, then it
	// will append the new row after the last child of @parent, otherwise it
	// will append a row to the top level. @iter will be changed to point to
	// this new row. The row will be empty after this function is called. To
	// fill in values, you need to call gtk_tree_store_set() or
	// gtk_tree_store_set_value().
	Append(parent *TreeIter) TreeIter
	// Clear removes all rows from @tree_store
	Clear()
	// Insert creates a new row at @position. If parent is non-nil, then the row
	// will be made a child of @parent. Otherwise, the row will be created at
	// the toplevel. If @position is -1 or is larger than the number of rows at
	// that level, then the new row will be inserted to the end of the list.
	// @iter will be changed to point to this new row. The row will be empty
	// after this function is called. To fill in values, you need to call
	// gtk_tree_store_set() or gtk_tree_store_set_value().
	Insert(parent *TreeIter, position int) TreeIter
	// InsertAfter inserts a new row after @sibling. If @sibling is nil, then
	// the row will be prepended to @parent ’s children. If @parent and @sibling
	// are nil, then the row will be prepended to the toplevel. If both @sibling
	// and @parent are set, then @parent must be the parent of @sibling. When
	// @sibling is set, @parent is optional.
	//
	// @iter will be changed to point to this new row. The row will be empty
	// after this function is called. To fill in values, you need to call
	// gtk_tree_store_set() or gtk_tree_store_set_value().
	InsertAfter(parent *TreeIter, sibling *TreeIter) TreeIter
	// InsertBefore inserts a new row before @sibling. If @sibling is nil, then
	// the row will be appended to @parent ’s children. If @parent and @sibling
	// are nil, then the row will be appended to the toplevel. If both @sibling
	// and @parent are set, then @parent must be the parent of @sibling. When
	// @sibling is set, @parent is optional.
	//
	// @iter will be changed to point to this new row. The row will be empty
	// after this function is called. To fill in values, you need to call
	// gtk_tree_store_set() or gtk_tree_store_set_value().
	InsertBefore(parent *TreeIter, sibling *TreeIter) TreeIter
	// InsertWithValuesv: a variant of gtk_tree_store_insert_with_values() which
	// takes the columns and values as two arrays, instead of varargs. This
	// function is mainly intended for language bindings.
	InsertWithValuesv(parent *TreeIter, position int, columns []int, values []**externglib.Value) TreeIter
	// IsAncestor returns true if @iter is an ancestor of @descendant. That is,
	// @iter is the parent (or grandparent or great-grandparent) of @descendant.
	IsAncestor(iter *TreeIter, descendant *TreeIter) bool
	// IterDepth returns the depth of @iter. This will be 0 for anything on the
	// root level, 1 for anything down a level, etc.
	IterDepth(iter *TreeIter) int
	// IterIsValid: WARNING: This function is slow. Only use it for debugging
	// and/or testing purposes.
	//
	// Checks if the given iter is a valid iter for this TreeStore.
	IterIsValid(iter *TreeIter) bool
	// MoveAfter moves @iter in @tree_store to the position after @position.
	// @iter and @position should be in the same level. Note that this function
	// only works with unsorted stores. If @position is nil, @iter will be moved
	// to the start of the level.
	MoveAfter(iter *TreeIter, position *TreeIter)
	// MoveBefore moves @iter in @tree_store to the position before @position.
	// @iter and @position should be in the same level. Note that this function
	// only works with unsorted stores. If @position is nil, @iter will be moved
	// to the end of the level.
	MoveBefore(iter *TreeIter, position *TreeIter)
	// Prepend prepends a new row to @tree_store. If @parent is non-nil, then it
	// will prepend the new row before the first child of @parent, otherwise it
	// will prepend a row to the top level. @iter will be changed to point to
	// this new row. The row will be empty after this function is called. To
	// fill in values, you need to call gtk_tree_store_set() or
	// gtk_tree_store_set_value().
	Prepend(parent *TreeIter) TreeIter
	// Remove removes @iter from @tree_store. After being removed, @iter is set
	// to the next valid row at that level, or invalidated if it previously
	// pointed to the last one.
	Remove(iter *TreeIter) bool
	// SetColumnTypes: this function is meant primarily for #GObjects that
	// inherit from TreeStore, and should only be used when constructing a new
	// TreeStore. It will not function after a row has been added, or a method
	// on the TreeModel interface is called.
	SetColumnTypes(types []externglib.Type)
	// SetValue sets the data in the cell specified by @iter and @column. The
	// type of @value must be convertible to the type of the column.
	SetValue(iter *TreeIter, column int, value **externglib.Value)
	// SetValuesv: a variant of gtk_tree_store_set_valist() which takes the
	// columns and values as two arrays, instead of varargs. This function is
	// mainly intended for language bindings or in case the number of columns to
	// change is not known until run-time.
	SetValuesv(iter *TreeIter, columns []int, values []**externglib.Value)
	// Swap swaps @a and @b in the same level of @tree_store. Note that this
	// function only works with unsorted stores.
	Swap(a *TreeIter, b *TreeIter)
}

// treeStore implements the TreeStore class.
type treeStore struct {
	gextras.Objector
	Buildable
	TreeDragDest
	TreeDragSource
	TreeModel
	TreeSortable
}

var _ TreeStore = (*treeStore)(nil)

// WrapTreeStore wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeStore(obj *externglib.Object) TreeStore {
	return treeStore{
		Objector:       obj,
		Buildable:      WrapBuildable(obj),
		TreeDragDest:   WrapTreeDragDest(obj),
		TreeDragSource: WrapTreeDragSource(obj),
		TreeModel:      WrapTreeModel(obj),
		TreeSortable:   WrapTreeSortable(obj),
	}
}

func marshalTreeStore(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeStore(obj), nil
}

// NewTreeStoreV: non vararg creation function. Used primarily by language
// bindings.
func NewTreeStoreV(types []externglib.Type) TreeStore {
	var _arg2 *C.GType
	var _arg1 C.gint
	var _cret *C.GtkTreeStore // in

	_arg1 = C.gint(len(types))
	_arg2 = (*C.GType)(C.malloc(C.ulong(len(types)) * C.ulong(C.sizeof_GType)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice(_arg2, len(types))
		for i := range types {
			out[i] = C.GType(types[i])
		}
	}

	_cret = C.gtk_tree_store_newv(_arg1, _arg2)

	var _treeStore TreeStore // out

	_treeStore = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(TreeStore)

	return _treeStore
}

// Append appends a new row to @tree_store. If @parent is non-nil, then it will
// append the new row after the last child of @parent, otherwise it will append
// a row to the top level. @iter will be changed to point to this new row. The
// row will be empty after this function is called. To fill in values, you need
// to call gtk_tree_store_set() or gtk_tree_store_set_value().
func (t treeStore) Append(parent *TreeIter) TreeIter {
	var _arg0 *C.GtkTreeStore // out
	var _iter TreeIter
	var _arg2 *C.GtkTreeIter // out

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(parent.Native()))

	C.gtk_tree_store_append(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2)

	return _iter
}

// Clear removes all rows from @tree_store
func (t treeStore) Clear() {
	var _arg0 *C.GtkTreeStore // out

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))

	C.gtk_tree_store_clear(_arg0)
}

// Insert creates a new row at @position. If parent is non-nil, then the row
// will be made a child of @parent. Otherwise, the row will be created at the
// toplevel. If @position is -1 or is larger than the number of rows at that
// level, then the new row will be inserted to the end of the list. @iter will
// be changed to point to this new row. The row will be empty after this
// function is called. To fill in values, you need to call gtk_tree_store_set()
// or gtk_tree_store_set_value().
func (t treeStore) Insert(parent *TreeIter, position int) TreeIter {
	var _arg0 *C.GtkTreeStore // out
	var _iter TreeIter
	var _arg2 *C.GtkTreeIter // out
	var _arg3 C.gint         // out

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(parent.Native()))
	_arg3 = (C.gint)(position)

	C.gtk_tree_store_insert(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2, _arg3)

	return _iter
}

// InsertAfter inserts a new row after @sibling. If @sibling is nil, then the
// row will be prepended to @parent ’s children. If @parent and @sibling are
// nil, then the row will be prepended to the toplevel. If both @sibling and
// @parent are set, then @parent must be the parent of @sibling. When @sibling
// is set, @parent is optional.
//
// @iter will be changed to point to this new row. The row will be empty after
// this function is called. To fill in values, you need to call
// gtk_tree_store_set() or gtk_tree_store_set_value().
func (t treeStore) InsertAfter(parent *TreeIter, sibling *TreeIter) TreeIter {
	var _arg0 *C.GtkTreeStore // out
	var _iter TreeIter
	var _arg2 *C.GtkTreeIter // out
	var _arg3 *C.GtkTreeIter // out

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(parent.Native()))
	_arg3 = (*C.GtkTreeIter)(unsafe.Pointer(sibling.Native()))

	C.gtk_tree_store_insert_after(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2, _arg3)

	return _iter
}

// InsertBefore inserts a new row before @sibling. If @sibling is nil, then the
// row will be appended to @parent ’s children. If @parent and @sibling are nil,
// then the row will be appended to the toplevel. If both @sibling and @parent
// are set, then @parent must be the parent of @sibling. When @sibling is set,
// @parent is optional.
//
// @iter will be changed to point to this new row. The row will be empty after
// this function is called. To fill in values, you need to call
// gtk_tree_store_set() or gtk_tree_store_set_value().
func (t treeStore) InsertBefore(parent *TreeIter, sibling *TreeIter) TreeIter {
	var _arg0 *C.GtkTreeStore // out
	var _iter TreeIter
	var _arg2 *C.GtkTreeIter // out
	var _arg3 *C.GtkTreeIter // out

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(parent.Native()))
	_arg3 = (*C.GtkTreeIter)(unsafe.Pointer(sibling.Native()))

	C.gtk_tree_store_insert_before(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2, _arg3)

	return _iter
}

// InsertWithValuesv: a variant of gtk_tree_store_insert_with_values() which
// takes the columns and values as two arrays, instead of varargs. This function
// is mainly intended for language bindings.
func (t treeStore) InsertWithValuesv(parent *TreeIter, position int, columns []int, values []**externglib.Value) TreeIter {
	var _arg0 *C.GtkTreeStore // out
	var _iter TreeIter
	var _arg2 *C.GtkTreeIter // out
	var _arg3 C.gint         // out
	var _arg4 *C.gint
	var _arg6 C.gint
	var _arg5 *C.GValue
	var _arg6 C.gint

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(parent.Native()))
	_arg3 = (C.gint)(position)
	_arg6 = C.gint(len(columns))
	_arg4 = (*C.gint)(unsafe.Pointer(&columns[0]))
	_arg6 = C.gint(len(values))
	_arg5 = (*C.GValue)(C.malloc(C.ulong(len(values)) * C.ulong(C.sizeof_GValue)))
	defer C.free(unsafe.Pointer(_arg5))
	{
		out := unsafe.Slice(_arg5, len(values))
		for i := range values {
			out[i] = (*C.GValue)(values[i].GValue)
		}
	}

	C.gtk_tree_store_insert_with_valuesv(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2, _arg3, _arg4, _arg5, _arg6)

	return _iter
}

// IsAncestor returns true if @iter is an ancestor of @descendant. That is,
// @iter is the parent (or grandparent or great-grandparent) of @descendant.
func (t treeStore) IsAncestor(iter *TreeIter, descendant *TreeIter) bool {
	var _arg0 *C.GtkTreeStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 *C.GtkTreeIter  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(descendant.Native()))

	_cret = C.gtk_tree_store_is_ancestor(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IterDepth returns the depth of @iter. This will be 0 for anything on the root
// level, 1 for anything down a level, etc.
func (t treeStore) IterDepth(iter *TreeIter) int {
	var _arg0 *C.GtkTreeStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret C.gint          // in

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_tree_store_iter_depth(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// IterIsValid: WARNING: This function is slow. Only use it for debugging and/or
// testing purposes.
//
// Checks if the given iter is a valid iter for this TreeStore.
func (t treeStore) IterIsValid(iter *TreeIter) bool {
	var _arg0 *C.GtkTreeStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_tree_store_iter_is_valid(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MoveAfter moves @iter in @tree_store to the position after @position. @iter
// and @position should be in the same level. Note that this function only works
// with unsorted stores. If @position is nil, @iter will be moved to the start
// of the level.
func (t treeStore) MoveAfter(iter *TreeIter, position *TreeIter) {
	var _arg0 *C.GtkTreeStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(position.Native()))

	C.gtk_tree_store_move_after(_arg0, _arg1, _arg2)
}

// MoveBefore moves @iter in @tree_store to the position before @position. @iter
// and @position should be in the same level. Note that this function only works
// with unsorted stores. If @position is nil, @iter will be moved to the end of
// the level.
func (t treeStore) MoveBefore(iter *TreeIter, position *TreeIter) {
	var _arg0 *C.GtkTreeStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(position.Native()))

	C.gtk_tree_store_move_before(_arg0, _arg1, _arg2)
}

// Prepend prepends a new row to @tree_store. If @parent is non-nil, then it
// will prepend the new row before the first child of @parent, otherwise it will
// prepend a row to the top level. @iter will be changed to point to this new
// row. The row will be empty after this function is called. To fill in values,
// you need to call gtk_tree_store_set() or gtk_tree_store_set_value().
func (t treeStore) Prepend(parent *TreeIter) TreeIter {
	var _arg0 *C.GtkTreeStore // out
	var _iter TreeIter
	var _arg2 *C.GtkTreeIter // out

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(parent.Native()))

	C.gtk_tree_store_prepend(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2)

	return _iter
}

// Remove removes @iter from @tree_store. After being removed, @iter is set to
// the next valid row at that level, or invalidated if it previously pointed to
// the last one.
func (t treeStore) Remove(iter *TreeIter) bool {
	var _arg0 *C.GtkTreeStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_tree_store_remove(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetColumnTypes: this function is meant primarily for #GObjects that inherit
// from TreeStore, and should only be used when constructing a new TreeStore. It
// will not function after a row has been added, or a method on the TreeModel
// interface is called.
func (t treeStore) SetColumnTypes(types []externglib.Type) {
	var _arg0 *C.GtkTreeStore // out
	var _arg2 *C.GType
	var _arg1 C.gint

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
	_arg1 = C.gint(len(types))
	_arg2 = (*C.GType)(C.malloc(C.ulong(len(types)) * C.ulong(C.sizeof_GType)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice(_arg2, len(types))
		for i := range types {
			out[i] = C.GType(types[i])
		}
	}

	C.gtk_tree_store_set_column_types(_arg0, _arg1, _arg2)
}

// SetValue sets the data in the cell specified by @iter and @column. The type
// of @value must be convertible to the type of the column.
func (t treeStore) SetValue(iter *TreeIter, column int, value **externglib.Value) {
	var _arg0 *C.GtkTreeStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 C.gint          // out
	var _arg3 *C.GValue       // out

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (C.gint)(column)
	_arg3 = (*C.GValue)(value.GValue)

	C.gtk_tree_store_set_value(_arg0, _arg1, _arg2, _arg3)
}

// SetValuesv: a variant of gtk_tree_store_set_valist() which takes the columns
// and values as two arrays, instead of varargs. This function is mainly
// intended for language bindings or in case the number of columns to change is
// not known until run-time.
func (t treeStore) SetValuesv(iter *TreeIter, columns []int, values []**externglib.Value) {
	var _arg0 *C.GtkTreeStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 *C.gint
	var _arg4 C.gint
	var _arg3 *C.GValue
	var _arg4 C.gint

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
	_arg4 = C.gint(len(columns))
	_arg2 = (*C.gint)(unsafe.Pointer(&columns[0]))
	_arg4 = C.gint(len(values))
	_arg3 = (*C.GValue)(C.malloc(C.ulong(len(values)) * C.ulong(C.sizeof_GValue)))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice(_arg3, len(values))
		for i := range values {
			out[i] = (*C.GValue)(values[i].GValue)
		}
	}

	C.gtk_tree_store_set_valuesv(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// Swap swaps @a and @b in the same level of @tree_store. Note that this
// function only works with unsorted stores.
func (t treeStore) Swap(a *TreeIter, b *TreeIter) {
	var _arg0 *C.GtkTreeStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(a.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(b.Native()))

	C.gtk_tree_store_swap(_arg0, _arg1, _arg2)
}

// TreeView: widget that displays any object that implements the TreeModel
// interface.
//
// Please refer to the [tree widget conceptual overview][TreeWidget] for an
// overview of all the objects and data types related to the tree widget and how
// they work together.
//
// Several different coordinate systems are exposed in the GtkTreeView API.
// These are:
//
// ! (tree-view-coordinates.png)
//
// Coordinate systems in GtkTreeView API:
//
// - Widget coordinates: Coordinates relative to the widget (usually
// `widget->window`).
//
// - Bin window coordinates: Coordinates relative to the window that GtkTreeView
// renders to.
//
// - Tree coordinates: Coordinates relative to the entire scrollable area of
// GtkTreeView. These coordinates start at (0, 0) for row 0 of the tree.
//
// Several functions are available for converting between the different
// coordinate systems. The most common translations are between widget and bin
// window coordinates and between bin window and tree coordinates. For the
// former you can use gtk_tree_view_convert_widget_to_bin_window_coords() (and
// vice versa), for the latter gtk_tree_view_convert_bin_window_to_tree_coords()
// (and vice versa).
//
//
// GtkTreeView as GtkBuildable
//
// The GtkTreeView implementation of the GtkBuildable interface accepts
// TreeViewColumn objects as <child> elements and exposes the internal
// TreeSelection in UI definitions.
//
// An example of a UI definition fragment with GtkTreeView:
//
//    <object class="GtkTreeView" id="treeview">
//      <property name="model">liststore1</property>
//      <child>
//        <object class="GtkTreeViewColumn" id="test-column">
//          <property name="title">Test</property>
//          <child>
//            <object class="GtkCellRendererText" id="test-renderer"/>
//            <attributes>
//              <attribute name="text">1</attribute>
//            </attributes>
//          </child>
//        </object>
//      </child>
//      <child internal-child="selection">
//        <object class="GtkTreeSelection" id="selection">
//          <signal name="changed" handler="on_treeview_selection_changed"/>
//        </object>
//      </child>
//    </object>
//
// CSS nodes
//
//    treeview.view
//    ├── header
//    │   ├── <column header>
//    ┊   ┊
//    │   ╰── <column header>
//    │
//    ╰── [rubberband]
//
// GtkTreeView has a main CSS node with name treeview and style class .view. It
// has a subnode with name header, which is the parent for all the column header
// widgets' CSS nodes. For rubberband selection, a subnode with name rubberband
// is used.
type TreeView interface {
	Container
	Buildable
	Scrollable

	// AppendColumn appends @column to the list of columns. If @tree_view has
	// “fixed_height” mode enabled, then @column must have its “sizing” property
	// set to be GTK_TREE_VIEW_COLUMN_FIXED.
	AppendColumn(column TreeViewColumn) int
	// CollapseAll: recursively collapses all visible, expanded nodes in
	// @tree_view.
	CollapseAll()
	// CollapseRow collapses a row (hides its child rows, if they exist).
	CollapseRow(path *TreePath) bool
	// ColumnsAutosize resizes all columns to their optimal width. Only works
	// after the treeview has been realized.
	ColumnsAutosize()
	// ConvertBinWindowToTreeCoords converts bin_window coordinates to
	// coordinates for the tree (the full scrollable area of the tree).
	ConvertBinWindowToTreeCoords(bx int, by int) (tx int, ty int)
	// ConvertBinWindowToWidgetCoords converts bin_window coordinates (see
	// gtk_tree_view_get_bin_window()) to widget relative coordinates.
	ConvertBinWindowToWidgetCoords(bx int, by int) (wx int, wy int)
	// ConvertTreeToBinWindowCoords converts tree coordinates (coordinates in
	// full scrollable area of the tree) to bin_window coordinates.
	ConvertTreeToBinWindowCoords(tx int, ty int) (bx int, by int)
	// ConvertTreeToWidgetCoords converts tree coordinates (coordinates in full
	// scrollable area of the tree) to widget coordinates.
	ConvertTreeToWidgetCoords(tx int, ty int) (wx int, wy int)
	// ConvertWidgetToBinWindowCoords converts widget coordinates to coordinates
	// for the bin_window (see gtk_tree_view_get_bin_window()).
	ConvertWidgetToBinWindowCoords(wx int, wy int) (bx int, by int)
	// ConvertWidgetToTreeCoords converts widget coordinates to coordinates for
	// the tree (the full scrollable area of the tree).
	ConvertWidgetToTreeCoords(wx int, wy int) (tx int, ty int)
	// CreateRowDragIcon creates a #cairo_surface_t representation of the row at
	// @path. This image is used for a drag icon.
	CreateRowDragIcon(path *TreePath) *cairo.Surface
	// EnableModelDragDest turns @tree_view into a drop destination for
	// automatic DND. Calling this method sets TreeView:reorderable to false.
	EnableModelDragDest(targets []TargetEntry, actions gdk.DragAction)
	// EnableModelDragSource turns @tree_view into a drag source for automatic
	// DND. Calling this method sets TreeView:reorderable to false.
	EnableModelDragSource(startButtonMask gdk.ModifierType, targets []TargetEntry, actions gdk.DragAction)
	// ExpandAll: recursively expands all nodes in the @tree_view.
	ExpandAll()
	// ExpandRow opens the row so its children are visible.
	ExpandRow(path *TreePath, openAll bool) bool
	// ExpandToPath expands the row at @path. This will also expand all parent
	// rows of @path as necessary.
	ExpandToPath(path *TreePath)
	// ActivateOnSingleClick gets the setting set by
	// gtk_tree_view_set_activate_on_single_click().
	ActivateOnSingleClick() bool
	// BackgroundArea fills the bounding rectangle in bin_window coordinates for
	// the cell at the row specified by @path and the column specified by
	// @column. If @path is nil, or points to a node not found in the tree, the
	// @y and @height fields of the rectangle will be filled with 0. If @column
	// is nil, the @x and @width fields will be filled with 0. The returned
	// rectangle is equivalent to the @background_area passed to
	// gtk_cell_renderer_render(). These background areas tile to cover the
	// entire bin window. Contrast with the @cell_area, returned by
	// gtk_tree_view_get_cell_area(), which returns only the cell itself,
	// excluding surrounding borders and the tree expander area.
	BackgroundArea(path *TreePath, column TreeViewColumn) gdk.Rectangle
	// BinWindow returns the window that @tree_view renders to. This is used
	// primarily to compare to `event->window` to confirm that the event on
	// @tree_view is on the right window.
	BinWindow() gdk.Window
	// CellArea fills the bounding rectangle in bin_window coordinates for the
	// cell at the row specified by @path and the column specified by @column.
	// If @path is nil, or points to a path not currently displayed, the @y and
	// @height fields of the rectangle will be filled with 0. If @column is nil,
	// the @x and @width fields will be filled with 0. The sum of all cell rects
	// does not cover the entire tree; there are extra pixels in between rows,
	// for example. The returned rectangle is equivalent to the @cell_area
	// passed to gtk_cell_renderer_render(). This function is only valid if
	// @tree_view is realized.
	CellArea(path *TreePath, column TreeViewColumn) gdk.Rectangle
	// Column gets the TreeViewColumn at the given position in the #tree_view.
	Column(n int) TreeViewColumn
	// Cursor fills in @path and @focus_column with the current path and focus
	// column. If the cursor isn’t currently set, then *@path will be nil. If no
	// column currently has focus, then *@focus_column will be nil.
	//
	// The returned TreePath must be freed with gtk_tree_path_free() when you
	// are done with it.
	Cursor() (*TreePath, TreeViewColumn)
	// DestRowAtPos determines the destination row for a given position. @drag_x
	// and @drag_y are expected to be in widget coordinates. This function is
	// only meaningful if @tree_view is realized. Therefore this function will
	// always return false if @tree_view is not realized or does not have a
	// model.
	DestRowAtPos(dragX int, dragY int) (*TreePath, TreeViewDropPosition, bool)
	// DragDestRow gets information about the row that is highlighted for
	// feedback.
	DragDestRow() (*TreePath, TreeViewDropPosition)
	// EnableSearch returns whether or not the tree allows to start interactive
	// searching by typing in text.
	EnableSearch() bool
	// EnableTreeLines returns whether or not tree lines are drawn in
	// @tree_view.
	EnableTreeLines() bool
	// ExpanderColumn returns the column that is the current expander column.
	// This column has the expander arrow drawn next to it.
	ExpanderColumn() TreeViewColumn
	// FixedHeightMode returns whether fixed height mode is turned on for
	// @tree_view.
	FixedHeightMode() bool
	// GridLines returns which grid lines are enabled in @tree_view.
	GridLines() TreeViewGridLines
	// HAdjustment gets the Adjustment currently being used for the horizontal
	// aspect.
	HAdjustment() Adjustment
	// HeadersClickable returns whether all header columns are clickable.
	HeadersClickable() bool
	// HeadersVisible returns true if the headers on the @tree_view are visible.
	HeadersVisible() bool
	// HoverExpand returns whether hover expansion mode is turned on for
	// @tree_view.
	HoverExpand() bool
	// HoverSelection returns whether hover selection mode is turned on for
	// @tree_view.
	HoverSelection() bool
	// LevelIndentation returns the amount, in pixels, of extra indentation for
	// child levels in @tree_view.
	LevelIndentation() int
	// Model returns the model the TreeView is based on. Returns nil if the
	// model is unset.
	Model() TreeModel
	// NColumns queries the number of columns in the given @tree_view.
	NColumns() uint
	// PathAtPos finds the path at the point (@x, @y), relative to bin_window
	// coordinates (please see gtk_tree_view_get_bin_window()). That is, @x and
	// @y are relative to an events coordinates. @x and @y must come from an
	// event on the @tree_view only where `event->window ==
	// gtk_tree_view_get_bin_window ()`. It is primarily for things like popup
	// menus. If @path is non-nil, then it will be filled with the TreePath at
	// that point. This path should be freed with gtk_tree_path_free(). If
	// @column is non-nil, then it will be filled with the column at that point.
	// @cell_x and @cell_y return the coordinates relative to the cell
	// background (i.e. the @background_area passed to
	// gtk_cell_renderer_render()). This function is only meaningful if
	// @tree_view is realized. Therefore this function will always return false
	// if @tree_view is not realized or does not have a model.
	//
	// For converting widget coordinates (eg. the ones you get from
	// GtkWidget::query-tooltip), please see
	// gtk_tree_view_convert_widget_to_bin_window_coords().
	PathAtPos(x int, y int) (path *TreePath, column TreeViewColumn, cellX int, cellY int, ok bool)
	// Reorderable retrieves whether the user can reorder the tree via
	// drag-and-drop. See gtk_tree_view_set_reorderable().
	Reorderable() bool
	// RubberBanding returns whether rubber banding is turned on for @tree_view.
	// If the selection mode is K_SELECTION_MULTIPLE, rubber banding will allow
	// the user to select multiple rows by dragging the mouse.
	RubberBanding() bool
	// RulesHint gets the setting set by gtk_tree_view_set_rules_hint().
	RulesHint() bool
	// SearchColumn gets the column searched on by the interactive search code.
	SearchColumn() int
	// SearchEntry returns the Entry which is currently in use as interactive
	// search entry for @tree_view. In case the built-in entry is being used,
	// nil will be returned.
	SearchEntry() Entry
	// Selection gets the TreeSelection associated with @tree_view.
	Selection() TreeSelection
	// ShowExpanders returns whether or not expanders are drawn in @tree_view.
	ShowExpanders() bool
	// TooltipColumn returns the column of @tree_view’s model which is being
	// used for displaying tooltips on @tree_view’s rows.
	TooltipColumn() int
	// VAdjustment gets the Adjustment currently being used for the vertical
	// aspect.
	VAdjustment() Adjustment
	// VisibleRange sets @start_path and @end_path to be the first and last
	// visible path. Note that there may be invisible paths in between.
	//
	// The paths should be freed with gtk_tree_path_free() after use.
	VisibleRange() (startPath *TreePath, endPath *TreePath, ok bool)
	// VisibleRect fills @visible_rect with the currently-visible region of the
	// buffer, in tree coordinates. Convert to bin_window coordinates with
	// gtk_tree_view_convert_tree_to_bin_window_coords(). Tree coordinates start
	// at 0,0 for row 0 of the tree, and cover the entire scrollable area of the
	// tree.
	VisibleRect() gdk.Rectangle
	// InsertColumn: this inserts the @column into the @tree_view at @position.
	// If @position is -1, then the column is inserted at the end. If @tree_view
	// has “fixed_height” mode enabled, then @column must have its “sizing”
	// property set to be GTK_TREE_VIEW_COLUMN_FIXED.
	InsertColumn(column TreeViewColumn, position int) int
	// IsBlankAtPos: determine whether the point (@x, @y) in @tree_view is
	// blank, that is no cell content nor an expander arrow is drawn at the
	// location. If so, the location can be considered as the background. You
	// might wish to take special action on clicks on the background, such as
	// clearing a current selection, having a custom context menu or starting
	// rubber banding.
	//
	// The @x and @y coordinate that are provided must be relative to bin_window
	// coordinates. That is, @x and @y must come from an event on @tree_view
	// where `event->window == gtk_tree_view_get_bin_window ()`.
	//
	// For converting widget coordinates (eg. the ones you get from
	// GtkWidget::query-tooltip), please see
	// gtk_tree_view_convert_widget_to_bin_window_coords().
	//
	// The @path, @column, @cell_x and @cell_y arguments will be filled in
	// likewise as for gtk_tree_view_get_path_at_pos(). Please see
	// gtk_tree_view_get_path_at_pos() for more information.
	IsBlankAtPos(x int, y int) (path *TreePath, column TreeViewColumn, cellX int, cellY int, ok bool)
	// IsRubberBandingActive returns whether a rubber banding operation is
	// currently being done in @tree_view.
	IsRubberBandingActive() bool
	// MoveColumnAfter moves @column to be after to @base_column. If
	// @base_column is nil, then @column is placed in the first position.
	MoveColumnAfter(column TreeViewColumn, baseColumn TreeViewColumn)
	// RemoveColumn removes @column from @tree_view.
	RemoveColumn(column TreeViewColumn) int
	// RowActivated activates the cell determined by @path and @column.
	RowActivated(path *TreePath, column TreeViewColumn)
	// RowExpanded returns true if the node pointed to by @path is expanded in
	// @tree_view.
	RowExpanded(path *TreePath) bool
	// ScrollToCell moves the alignments of @tree_view to the position specified
	// by @column and @path. If @column is nil, then no horizontal scrolling
	// occurs. Likewise, if @path is nil no vertical scrolling occurs. At a
	// minimum, one of @column or @path need to be non-nil. @row_align
	// determines where the row is placed, and @col_align determines where
	// @column is placed. Both are expected to be between 0.0 and 1.0. 0.0 means
	// left/top alignment, 1.0 means right/bottom alignment, 0.5 means center.
	//
	// If @use_align is false, then the alignment arguments are ignored, and the
	// tree does the minimum amount of work to scroll the cell onto the screen.
	// This means that the cell will be scrolled to the edge closest to its
	// current position. If the cell is currently visible on the screen, nothing
	// is done.
	//
	// This function only works if the model is set, and @path is a valid row on
	// the model. If the model changes before the @tree_view is realized, the
	// centered path will be modified to reflect this change.
	ScrollToCell(path *TreePath, column TreeViewColumn, useAlign bool, rowAlign float32, colAlign float32)
	// ScrollToPoint scrolls the tree view such that the top-left corner of the
	// visible area is @tree_x, @tree_y, where @tree_x and @tree_y are specified
	// in tree coordinates. The @tree_view must be realized before this function
	// is called. If it isn't, you probably want to be using
	// gtk_tree_view_scroll_to_cell().
	//
	// If either @tree_x or @tree_y are -1, then that direction isn’t scrolled.
	ScrollToPoint(treeX int, treeY int)
	// SetActivateOnSingleClick: cause the TreeView::row-activated signal to be
	// emitted on a single click instead of a double click.
	SetActivateOnSingleClick(single bool)
	// SetCursor sets the current keyboard focus to be at @path, and selects it.
	// This is useful when you want to focus the user’s attention on a
	// particular row. If @focus_column is not nil, then focus is given to the
	// column specified by it. Additionally, if @focus_column is specified, and
	// @start_editing is true, then editing should be started in the specified
	// cell. This function is often followed by @gtk_widget_grab_focus
	// (@tree_view) in order to give keyboard focus to the widget. Please note
	// that editing can only happen when the widget is realized.
	//
	// If @path is invalid for @model, the current cursor (if any) will be unset
	// and the function will return without failing.
	SetCursor(path *TreePath, focusColumn TreeViewColumn, startEditing bool)
	// SetCursorOnCell sets the current keyboard focus to be at @path, and
	// selects it. This is useful when you want to focus the user’s attention on
	// a particular row. If @focus_column is not nil, then focus is given to the
	// column specified by it. If @focus_column and @focus_cell are not nil, and
	// @focus_column contains 2 or more editable or activatable cells, then
	// focus is given to the cell specified by @focus_cell. Additionally, if
	// @focus_column is specified, and @start_editing is true, then editing
	// should be started in the specified cell. This function is often followed
	// by @gtk_widget_grab_focus (@tree_view) in order to give keyboard focus to
	// the widget. Please note that editing can only happen when the widget is
	// realized.
	//
	// If @path is invalid for @model, the current cursor (if any) will be unset
	// and the function will return without failing.
	SetCursorOnCell(path *TreePath, focusColumn TreeViewColumn, focusCell CellRenderer, startEditing bool)
	// SetDragDestRow sets the row that is highlighted for feedback. If @path is
	// nil, an existing highlight is removed.
	SetDragDestRow(path *TreePath, pos TreeViewDropPosition)
	// SetEnableSearch: if @enable_search is set, then the user can type in text
	// to search through the tree interactively (this is sometimes called
	// "typeahead find").
	//
	// Note that even if this is false, the user can still initiate a search
	// using the “start-interactive-search” key binding.
	SetEnableSearch(enableSearch bool)
	// SetEnableTreeLines sets whether to draw lines interconnecting the
	// expanders in @tree_view. This does not have any visible effects for
	// lists.
	SetEnableTreeLines(enabled bool)
	// SetExpanderColumn sets the column to draw the expander arrow at. It must
	// be in @tree_view. If @column is nil, then the expander arrow is always at
	// the first visible column.
	//
	// If you do not want expander arrow to appear in your tree, set the
	// expander column to a hidden column.
	SetExpanderColumn(column TreeViewColumn)
	// SetFixedHeightMode enables or disables the fixed height mode of
	// @tree_view. Fixed height mode speeds up TreeView by assuming that all
	// rows have the same height. Only enable this option if all rows are the
	// same height and all columns are of type GTK_TREE_VIEW_COLUMN_FIXED.
	SetFixedHeightMode(enable bool)
	// SetGridLines sets which grid lines to draw in @tree_view.
	SetGridLines(gridLines TreeViewGridLines)
	// SetHAdjustment sets the Adjustment for the current horizontal aspect.
	SetHAdjustment(adjustment Adjustment)
	// SetHeadersClickable: allow the column title buttons to be clicked.
	SetHeadersClickable(setting bool)
	// SetHeadersVisible sets the visibility state of the headers.
	SetHeadersVisible(headersVisible bool)
	// SetHoverExpand enables or disables the hover expansion mode of
	// @tree_view. Hover expansion makes rows expand or collapse if the pointer
	// moves over them.
	SetHoverExpand(expand bool)
	// SetHoverSelection enables or disables the hover selection mode of
	// @tree_view. Hover selection makes the selected row follow the pointer.
	// Currently, this works only for the selection modes GTK_SELECTION_SINGLE
	// and GTK_SELECTION_BROWSE.
	SetHoverSelection(hover bool)
	// SetLevelIndentation sets the amount of extra indentation for child levels
	// to use in @tree_view in addition to the default indentation. The value
	// should be specified in pixels, a value of 0 disables this feature and in
	// this case only the default indentation will be used. This does not have
	// any visible effects for lists.
	SetLevelIndentation(indentation int)
	// SetModel sets the model for a TreeView. If the @tree_view already has a
	// model set, it will remove it before setting the new model. If @model is
	// nil, then it will unset the old model.
	SetModel(model TreeModel)
	// SetReorderable: this function is a convenience function to allow you to
	// reorder models that support the TreeDragSourceIface and the
	// TreeDragDestIface. Both TreeStore and ListStore support these. If
	// @reorderable is true, then the user can reorder the model by dragging and
	// dropping rows. The developer can listen to these changes by connecting to
	// the model’s TreeModel::row-inserted and TreeModel::row-deleted signals.
	// The reordering is implemented by setting up the tree view as a drag
	// source and destination. Therefore, drag and drop can not be used in a
	// reorderable view for any other purpose.
	//
	// This function does not give you any degree of control over the order --
	// any reordering is allowed. If more control is needed, you should probably
	// handle drag and drop manually.
	SetReorderable(reorderable bool)
	// SetRubberBanding enables or disables rubber banding in @tree_view. If the
	// selection mode is K_SELECTION_MULTIPLE, rubber banding will allow the
	// user to select multiple rows by dragging the mouse.
	SetRubberBanding(enable bool)
	// SetRulesHint sets a hint for the theme to draw even/odd rows in the
	// @tree_view with different colors, also known as "zebra striping".
	//
	// This function tells the GTK+ theme that the user interface for your
	// application requires users to read across tree rows and associate cells
	// with one another.
	//
	// Do not use it just because you prefer the appearance of the ruled tree;
	// that’s a question for the theme. Some themes will draw tree rows in
	// alternating colors even when rules are turned off, and users who prefer
	// that appearance all the time can choose those themes. You should call
	// this function only as a semantic hint to the theme engine that your tree
	// makes alternating colors useful from a functional standpoint (since it
	// has lots of columns, generally).
	SetRulesHint(setting bool)
	// SetSearchColumn sets @column as the column where the interactive search
	// code should search in for the current model.
	//
	// If the search column is set, users can use the “start-interactive-search”
	// key binding to bring up search popup. The enable-search property controls
	// whether simply typing text will also start an interactive search.
	//
	// Note that @column refers to a column of the current model. The search
	// column is reset to -1 when the model is changed.
	SetSearchColumn(column int)
	// SetSearchEntry sets the entry which the interactive search code will use
	// for this @tree_view. This is useful when you want to provide a search
	// entry in our interface at all time at a fixed position. Passing nil for
	// @entry will make the interactive search code use the built-in popup entry
	// again.
	SetSearchEntry(entry Entry)
	// SetShowExpanders sets whether to draw and enable expanders and indent
	// child rows in @tree_view. When disabled there will be no expanders
	// visible in trees and there will be no way to expand and collapse rows by
	// default. Also note that hiding the expanders will disable the default
	// indentation. You can set a custom indentation in this case using
	// gtk_tree_view_set_level_indentation(). This does not have any visible
	// effects for lists.
	SetShowExpanders(enabled bool)
	// SetTooltipCell sets the tip area of @tooltip to the area @path, @column
	// and @cell have in common. For example if @path is nil and @column is set,
	// the tip area will be set to the full area covered by @column. See also
	// gtk_tooltip_set_tip_area().
	//
	// Note that if @path is not specified and @cell is set and part of a column
	// containing the expander, the tooltip might not show and hide at the
	// correct position. In such cases @path must be set to the current node
	// under the mouse cursor for this function to operate correctly.
	//
	// See also gtk_tree_view_set_tooltip_column() for a simpler alternative.
	SetTooltipCell(tooltip Tooltip, path *TreePath, column TreeViewColumn, cell CellRenderer)
	// SetTooltipColumn: if you only plan to have simple (text-only) tooltips on
	// full rows, you can use this function to have TreeView handle these
	// automatically for you. @column should be set to the column in
	// @tree_view’s model containing the tooltip texts, or -1 to disable this
	// feature.
	//
	// When enabled, Widget:has-tooltip will be set to true and @tree_view will
	// connect a Widget::query-tooltip signal handler.
	//
	// Note that the signal handler sets the text with gtk_tooltip_set_markup(),
	// so &, <, etc have to be escaped in the text.
	SetTooltipColumn(column int)
	// SetTooltipRow sets the tip area of @tooltip to be the area covered by the
	// row at @path. See also gtk_tree_view_set_tooltip_column() for a simpler
	// alternative. See also gtk_tooltip_set_tip_area().
	SetTooltipRow(tooltip Tooltip, path *TreePath)
	// SetVAdjustment sets the Adjustment for the current vertical aspect.
	SetVAdjustment(adjustment Adjustment)
	// UnsetRowsDragDest undoes the effect of
	// gtk_tree_view_enable_model_drag_dest(). Calling this method sets
	// TreeView:reorderable to false.
	UnsetRowsDragDest()
	// UnsetRowsDragSource undoes the effect of
	// gtk_tree_view_enable_model_drag_source(). Calling this method sets
	// TreeView:reorderable to false.
	UnsetRowsDragSource()
}

// treeView implements the TreeView class.
type treeView struct {
	Container
	Buildable
	Scrollable
}

var _ TreeView = (*treeView)(nil)

// WrapTreeView wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeView(obj *externglib.Object) TreeView {
	return treeView{
		Container:  WrapContainer(obj),
		Buildable:  WrapBuildable(obj),
		Scrollable: WrapScrollable(obj),
	}
}

func marshalTreeView(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeView(obj), nil
}

// NewTreeView creates a new TreeView widget.
func NewTreeView() TreeView {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_tree_view_new()

	var _treeView TreeView // out

	_treeView = WrapTreeView(externglib.Take(unsafe.Pointer(_cret)))

	return _treeView
}

// NewTreeViewWithModel creates a new TreeView widget with the model initialized
// to @model.
func NewTreeViewWithModel(model TreeModel) TreeView {
	var _arg1 *C.GtkTreeModel // out
	var _cret *C.GtkWidget    // in

	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

	_cret = C.gtk_tree_view_new_with_model(_arg1)

	var _treeView TreeView // out

	_treeView = WrapTreeView(externglib.Take(unsafe.Pointer(_cret)))

	return _treeView
}

// AppendColumn appends @column to the list of columns. If @tree_view has
// “fixed_height” mode enabled, then @column must have its “sizing” property set
// to be GTK_TREE_VIEW_COLUMN_FIXED.
func (t treeView) AppendColumn(column TreeViewColumn) int {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreeViewColumn // out
	var _cret C.gint               // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))

	_cret = C.gtk_tree_view_append_column(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// CollapseAll: recursively collapses all visible, expanded nodes in @tree_view.
func (t treeView) CollapseAll() {
	var _arg0 *C.GtkTreeView // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_collapse_all(_arg0)
}

// CollapseRow collapses a row (hides its child rows, if they exist).
func (t treeView) CollapseRow(path *TreePath) bool {
	var _arg0 *C.GtkTreeView // out
	var _arg1 *C.GtkTreePath // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	_cret = C.gtk_tree_view_collapse_row(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ColumnsAutosize resizes all columns to their optimal width. Only works after
// the treeview has been realized.
func (t treeView) ColumnsAutosize() {
	var _arg0 *C.GtkTreeView // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_columns_autosize(_arg0)
}

// ConvertBinWindowToTreeCoords converts bin_window coordinates to coordinates
// for the tree (the full scrollable area of the tree).
func (t treeView) ConvertBinWindowToTreeCoords(bx int, by int) (tx int, ty int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gint         // out
	var _arg2 C.gint         // out
	var _arg3 C.gint         // in
	var _arg4 C.gint         // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(bx)
	_arg2 = (C.gint)(by)

	C.gtk_tree_view_convert_bin_window_to_tree_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)

	var _tx int // out
	var _ty int // out

	_tx = (int)(_arg3)
	_ty = (int)(_arg4)

	return _tx, _ty
}

// ConvertBinWindowToWidgetCoords converts bin_window coordinates (see
// gtk_tree_view_get_bin_window()) to widget relative coordinates.
func (t treeView) ConvertBinWindowToWidgetCoords(bx int, by int) (wx int, wy int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gint         // out
	var _arg2 C.gint         // out
	var _arg3 C.gint         // in
	var _arg4 C.gint         // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(bx)
	_arg2 = (C.gint)(by)

	C.gtk_tree_view_convert_bin_window_to_widget_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)

	var _wx int // out
	var _wy int // out

	_wx = (int)(_arg3)
	_wy = (int)(_arg4)

	return _wx, _wy
}

// ConvertTreeToBinWindowCoords converts tree coordinates (coordinates in full
// scrollable area of the tree) to bin_window coordinates.
func (t treeView) ConvertTreeToBinWindowCoords(tx int, ty int) (bx int, by int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gint         // out
	var _arg2 C.gint         // out
	var _arg3 C.gint         // in
	var _arg4 C.gint         // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(tx)
	_arg2 = (C.gint)(ty)

	C.gtk_tree_view_convert_tree_to_bin_window_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)

	var _bx int // out
	var _by int // out

	_bx = (int)(_arg3)
	_by = (int)(_arg4)

	return _bx, _by
}

// ConvertTreeToWidgetCoords converts tree coordinates (coordinates in full
// scrollable area of the tree) to widget coordinates.
func (t treeView) ConvertTreeToWidgetCoords(tx int, ty int) (wx int, wy int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gint         // out
	var _arg2 C.gint         // out
	var _arg3 C.gint         // in
	var _arg4 C.gint         // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(tx)
	_arg2 = (C.gint)(ty)

	C.gtk_tree_view_convert_tree_to_widget_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)

	var _wx int // out
	var _wy int // out

	_wx = (int)(_arg3)
	_wy = (int)(_arg4)

	return _wx, _wy
}

// ConvertWidgetToBinWindowCoords converts widget coordinates to coordinates for
// the bin_window (see gtk_tree_view_get_bin_window()).
func (t treeView) ConvertWidgetToBinWindowCoords(wx int, wy int) (bx int, by int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gint         // out
	var _arg2 C.gint         // out
	var _arg3 C.gint         // in
	var _arg4 C.gint         // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(wx)
	_arg2 = (C.gint)(wy)

	C.gtk_tree_view_convert_widget_to_bin_window_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)

	var _bx int // out
	var _by int // out

	_bx = (int)(_arg3)
	_by = (int)(_arg4)

	return _bx, _by
}

// ConvertWidgetToTreeCoords converts widget coordinates to coordinates for the
// tree (the full scrollable area of the tree).
func (t treeView) ConvertWidgetToTreeCoords(wx int, wy int) (tx int, ty int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gint         // out
	var _arg2 C.gint         // out
	var _arg3 C.gint         // in
	var _arg4 C.gint         // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(wx)
	_arg2 = (C.gint)(wy)

	C.gtk_tree_view_convert_widget_to_tree_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)

	var _tx int // out
	var _ty int // out

	_tx = (int)(_arg3)
	_ty = (int)(_arg4)

	return _tx, _ty
}

// CreateRowDragIcon creates a #cairo_surface_t representation of the row at
// @path. This image is used for a drag icon.
func (t treeView) CreateRowDragIcon(path *TreePath) *cairo.Surface {
	var _arg0 *C.GtkTreeView     // out
	var _arg1 *C.GtkTreePath     // out
	var _cret *C.cairo_surface_t // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	_cret = C.gtk_tree_view_create_row_drag_icon(_arg0, _arg1)

	var _surface *cairo.Surface // out

	_surface = cairo.WrapSurface(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_surface, func(v *cairo.Surface) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _surface
}

// EnableModelDragDest turns @tree_view into a drop destination for automatic
// DND. Calling this method sets TreeView:reorderable to false.
func (t treeView) EnableModelDragDest(targets []TargetEntry, actions gdk.DragAction) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 *C.GtkTargetEntry
	var _arg2 C.gint
	var _arg3 C.GdkDragAction // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg2 = C.gint(len(targets))
	_arg1 = (*C.GtkTargetEntry)(unsafe.Pointer(&targets[0]))
	_arg3 = (C.GdkDragAction)(actions)

	C.gtk_tree_view_enable_model_drag_dest(_arg0, _arg1, _arg2, _arg3)
}

// EnableModelDragSource turns @tree_view into a drag source for automatic DND.
// Calling this method sets TreeView:reorderable to false.
func (t treeView) EnableModelDragSource(startButtonMask gdk.ModifierType, targets []TargetEntry, actions gdk.DragAction) {
	var _arg0 *C.GtkTreeView    // out
	var _arg1 C.GdkModifierType // out
	var _arg2 *C.GtkTargetEntry
	var _arg3 C.gint
	var _arg4 C.GdkDragAction // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.GdkModifierType)(startButtonMask)
	_arg3 = C.gint(len(targets))
	_arg2 = (*C.GtkTargetEntry)(unsafe.Pointer(&targets[0]))
	_arg4 = (C.GdkDragAction)(actions)

	C.gtk_tree_view_enable_model_drag_source(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// ExpandAll: recursively expands all nodes in the @tree_view.
func (t treeView) ExpandAll() {
	var _arg0 *C.GtkTreeView // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_expand_all(_arg0)
}

// ExpandRow opens the row so its children are visible.
func (t treeView) ExpandRow(path *TreePath, openAll bool) bool {
	var _arg0 *C.GtkTreeView // out
	var _arg1 *C.GtkTreePath // out
	var _arg2 C.gboolean     // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	if openAll {
		_arg2 = C.TRUE
	}

	_cret = C.gtk_tree_view_expand_row(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ExpandToPath expands the row at @path. This will also expand all parent rows
// of @path as necessary.
func (t treeView) ExpandToPath(path *TreePath) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 *C.GtkTreePath // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_tree_view_expand_to_path(_arg0, _arg1)
}

// ActivateOnSingleClick gets the setting set by
// gtk_tree_view_set_activate_on_single_click().
func (t treeView) ActivateOnSingleClick() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_activate_on_single_click(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackgroundArea fills the bounding rectangle in bin_window coordinates for the
// cell at the row specified by @path and the column specified by @column. If
// @path is nil, or points to a node not found in the tree, the @y and @height
// fields of the rectangle will be filled with 0. If @column is nil, the @x and
// @width fields will be filled with 0. The returned rectangle is equivalent to
// the @background_area passed to gtk_cell_renderer_render(). These background
// areas tile to cover the entire bin window. Contrast with the @cell_area,
// returned by gtk_tree_view_get_cell_area(), which returns only the cell
// itself, excluding surrounding borders and the tree expander area.
func (t treeView) BackgroundArea(path *TreePath, column TreeViewColumn) gdk.Rectangle {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreePath       // out
	var _arg2 *C.GtkTreeViewColumn // out
	var _rect gdk.Rectangle

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))

	C.gtk_tree_view_get_background_area(_arg0, _arg1, _arg2, (*C.GdkRectangle)(unsafe.Pointer(&_rect)))

	return _rect
}

// BinWindow returns the window that @tree_view renders to. This is used
// primarily to compare to `event->window` to confirm that the event on
// @tree_view is on the right window.
func (t treeView) BinWindow() gdk.Window {
	var _arg0 *C.GtkTreeView // out
	var _cret *C.GdkWindow   // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_bin_window(_arg0)

	var _window gdk.Window // out

	_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Window)

	return _window
}

// CellArea fills the bounding rectangle in bin_window coordinates for the cell
// at the row specified by @path and the column specified by @column. If @path
// is nil, or points to a path not currently displayed, the @y and @height
// fields of the rectangle will be filled with 0. If @column is nil, the @x and
// @width fields will be filled with 0. The sum of all cell rects does not cover
// the entire tree; there are extra pixels in between rows, for example. The
// returned rectangle is equivalent to the @cell_area passed to
// gtk_cell_renderer_render(). This function is only valid if @tree_view is
// realized.
func (t treeView) CellArea(path *TreePath, column TreeViewColumn) gdk.Rectangle {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreePath       // out
	var _arg2 *C.GtkTreeViewColumn // out
	var _rect gdk.Rectangle

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))

	C.gtk_tree_view_get_cell_area(_arg0, _arg1, _arg2, (*C.GdkRectangle)(unsafe.Pointer(&_rect)))

	return _rect
}

// Column gets the TreeViewColumn at the given position in the #tree_view.
func (t treeView) Column(n int) TreeViewColumn {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 C.gint               // out
	var _cret *C.GtkTreeViewColumn // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(n)

	_cret = C.gtk_tree_view_get_column(_arg0, _arg1)

	var _treeViewColumn TreeViewColumn // out

	_treeViewColumn = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeViewColumn)

	return _treeViewColumn
}

// Cursor fills in @path and @focus_column with the current path and focus
// column. If the cursor isn’t currently set, then *@path will be nil. If no
// column currently has focus, then *@focus_column will be nil.
//
// The returned TreePath must be freed with gtk_tree_path_free() when you are
// done with it.
func (t treeView) Cursor() (*TreePath, TreeViewColumn) {
	var _arg0 *C.GtkTreeView // out
	var _path *TreePath
	var _arg2 *C.GtkTreeViewColumn // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_get_cursor(_arg0, (**C.GtkTreePath)(unsafe.Pointer(&_path)), &_arg2)

	var _focusColumn TreeViewColumn // out

	_focusColumn = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg2))).(TreeViewColumn)

	return _path, _focusColumn
}

// DestRowAtPos determines the destination row for a given position. @drag_x and
// @drag_y are expected to be in widget coordinates. This function is only
// meaningful if @tree_view is realized. Therefore this function will always
// return false if @tree_view is not realized or does not have a model.
func (t treeView) DestRowAtPos(dragX int, dragY int) (*TreePath, TreeViewDropPosition, bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gint         // out
	var _arg2 C.gint         // out
	var _path *TreePath
	var _arg4 C.GtkTreeViewDropPosition // in
	var _cret C.gboolean                // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(dragX)
	_arg2 = (C.gint)(dragY)

	_cret = C.gtk_tree_view_get_dest_row_at_pos(_arg0, _arg1, _arg2, (**C.GtkTreePath)(unsafe.Pointer(&_path)), &_arg4)

	var _pos TreeViewDropPosition // out
	var _ok bool                  // out

	_pos = TreeViewDropPosition(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _path, _pos, _ok
}

// DragDestRow gets information about the row that is highlighted for feedback.
func (t treeView) DragDestRow() (*TreePath, TreeViewDropPosition) {
	var _arg0 *C.GtkTreeView // out
	var _path *TreePath
	var _arg2 C.GtkTreeViewDropPosition // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_get_drag_dest_row(_arg0, (**C.GtkTreePath)(unsafe.Pointer(&_path)), &_arg2)

	var _pos TreeViewDropPosition // out

	_pos = TreeViewDropPosition(_arg2)

	return _path, _pos
}

// EnableSearch returns whether or not the tree allows to start interactive
// searching by typing in text.
func (t treeView) EnableSearch() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_enable_search(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EnableTreeLines returns whether or not tree lines are drawn in @tree_view.
func (t treeView) EnableTreeLines() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_enable_tree_lines(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ExpanderColumn returns the column that is the current expander column. This
// column has the expander arrow drawn next to it.
func (t treeView) ExpanderColumn() TreeViewColumn {
	var _arg0 *C.GtkTreeView       // out
	var _cret *C.GtkTreeViewColumn // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_expander_column(_arg0)

	var _treeViewColumn TreeViewColumn // out

	_treeViewColumn = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeViewColumn)

	return _treeViewColumn
}

// FixedHeightMode returns whether fixed height mode is turned on for
// @tree_view.
func (t treeView) FixedHeightMode() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_fixed_height_mode(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// GridLines returns which grid lines are enabled in @tree_view.
func (t treeView) GridLines() TreeViewGridLines {
	var _arg0 *C.GtkTreeView         // out
	var _cret C.GtkTreeViewGridLines // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_grid_lines(_arg0)

	var _treeViewGridLines TreeViewGridLines // out

	_treeViewGridLines = TreeViewGridLines(_cret)

	return _treeViewGridLines
}

// HAdjustment gets the Adjustment currently being used for the horizontal
// aspect.
func (t treeView) HAdjustment() Adjustment {
	var _arg0 *C.GtkTreeView   // out
	var _cret *C.GtkAdjustment // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_hadjustment(_arg0)

	var _adjustment Adjustment // out

	_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

	return _adjustment
}

// HeadersClickable returns whether all header columns are clickable.
func (t treeView) HeadersClickable() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_headers_clickable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HeadersVisible returns true if the headers on the @tree_view are visible.
func (t treeView) HeadersVisible() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_headers_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HoverExpand returns whether hover expansion mode is turned on for @tree_view.
func (t treeView) HoverExpand() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_hover_expand(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HoverSelection returns whether hover selection mode is turned on for
// @tree_view.
func (t treeView) HoverSelection() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_hover_selection(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LevelIndentation returns the amount, in pixels, of extra indentation for
// child levels in @tree_view.
func (t treeView) LevelIndentation() int {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_level_indentation(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Model returns the model the TreeView is based on. Returns nil if the model is
// unset.
func (t treeView) Model() TreeModel {
	var _arg0 *C.GtkTreeView  // out
	var _cret *C.GtkTreeModel // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_model(_arg0)

	var _treeModel TreeModel // out

	_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeModel)

	return _treeModel
}

// NColumns queries the number of columns in the given @tree_view.
func (t treeView) NColumns() uint {
	var _arg0 *C.GtkTreeView // out
	var _cret C.guint        // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_n_columns(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// PathAtPos finds the path at the point (@x, @y), relative to bin_window
// coordinates (please see gtk_tree_view_get_bin_window()). That is, @x and @y
// are relative to an events coordinates. @x and @y must come from an event on
// the @tree_view only where `event->window == gtk_tree_view_get_bin_window ()`.
// It is primarily for things like popup menus. If @path is non-nil, then it
// will be filled with the TreePath at that point. This path should be freed
// with gtk_tree_path_free(). If @column is non-nil, then it will be filled with
// the column at that point. @cell_x and @cell_y return the coordinates relative
// to the cell background (i.e. the @background_area passed to
// gtk_cell_renderer_render()). This function is only meaningful if @tree_view
// is realized. Therefore this function will always return false if @tree_view
// is not realized or does not have a model.
//
// For converting widget coordinates (eg. the ones you get from
// GtkWidget::query-tooltip), please see
// gtk_tree_view_convert_widget_to_bin_window_coords().
func (t treeView) PathAtPos(x int, y int) (path *TreePath, column TreeViewColumn, cellX int, cellY int, ok bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gint         // out
	var _arg2 C.gint         // out
	var _path *TreePath
	var _arg4 *C.GtkTreeViewColumn // in
	var _arg5 C.gint               // in
	var _arg6 C.gint               // in
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(x)
	_arg2 = (C.gint)(y)

	_cret = C.gtk_tree_view_get_path_at_pos(_arg0, _arg1, _arg2, (**C.GtkTreePath)(unsafe.Pointer(&_path)), &_arg4, &_arg5, &_arg6)

	var _column TreeViewColumn // out
	var _cellX int             // out
	var _cellY int             // out
	var _ok bool               // out

	_column = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg4))).(TreeViewColumn)
	_cellX = (int)(_arg5)
	_cellY = (int)(_arg6)
	if _cret != 0 {
		_ok = true
	}

	return _path, _column, _cellX, _cellY, _ok
}

// Reorderable retrieves whether the user can reorder the tree via
// drag-and-drop. See gtk_tree_view_set_reorderable().
func (t treeView) Reorderable() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_reorderable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RubberBanding returns whether rubber banding is turned on for @tree_view. If
// the selection mode is K_SELECTION_MULTIPLE, rubber banding will allow the
// user to select multiple rows by dragging the mouse.
func (t treeView) RubberBanding() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_rubber_banding(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RulesHint gets the setting set by gtk_tree_view_set_rules_hint().
func (t treeView) RulesHint() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_rules_hint(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SearchColumn gets the column searched on by the interactive search code.
func (t treeView) SearchColumn() int {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_search_column(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// SearchEntry returns the Entry which is currently in use as interactive search
// entry for @tree_view. In case the built-in entry is being used, nil will be
// returned.
func (t treeView) SearchEntry() Entry {
	var _arg0 *C.GtkTreeView // out
	var _cret *C.GtkEntry    // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_search_entry(_arg0)

	var _entry Entry // out

	_entry = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Entry)

	return _entry
}

// Selection gets the TreeSelection associated with @tree_view.
func (t treeView) Selection() TreeSelection {
	var _arg0 *C.GtkTreeView      // out
	var _cret *C.GtkTreeSelection // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_selection(_arg0)

	var _treeSelection TreeSelection // out

	_treeSelection = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeSelection)

	return _treeSelection
}

// ShowExpanders returns whether or not expanders are drawn in @tree_view.
func (t treeView) ShowExpanders() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_show_expanders(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TooltipColumn returns the column of @tree_view’s model which is being used
// for displaying tooltips on @tree_view’s rows.
func (t treeView) TooltipColumn() int {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_tooltip_column(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// VAdjustment gets the Adjustment currently being used for the vertical aspect.
func (t treeView) VAdjustment() Adjustment {
	var _arg0 *C.GtkTreeView   // out
	var _cret *C.GtkAdjustment // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_vadjustment(_arg0)

	var _adjustment Adjustment // out

	_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

	return _adjustment
}

// VisibleRange sets @start_path and @end_path to be the first and last visible
// path. Note that there may be invisible paths in between.
//
// The paths should be freed with gtk_tree_path_free() after use.
func (t treeView) VisibleRange() (startPath *TreePath, endPath *TreePath, ok bool) {
	var _arg0 *C.GtkTreeView // out
	var _startPath *TreePath
	var _endPath *TreePath
	var _cret C.gboolean // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_get_visible_range(_arg0, (**C.GtkTreePath)(unsafe.Pointer(&_startPath)), (**C.GtkTreePath)(unsafe.Pointer(&_endPath)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _startPath, _endPath, _ok
}

// VisibleRect fills @visible_rect with the currently-visible region of the
// buffer, in tree coordinates. Convert to bin_window coordinates with
// gtk_tree_view_convert_tree_to_bin_window_coords(). Tree coordinates start at
// 0,0 for row 0 of the tree, and cover the entire scrollable area of the tree.
func (t treeView) VisibleRect() gdk.Rectangle {
	var _arg0 *C.GtkTreeView // out
	var _visibleRect gdk.Rectangle

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_get_visible_rect(_arg0, (*C.GdkRectangle)(unsafe.Pointer(&_visibleRect)))

	return _visibleRect
}

// InsertColumn: this inserts the @column into the @tree_view at @position. If
// @position is -1, then the column is inserted at the end. If @tree_view has
// “fixed_height” mode enabled, then @column must have its “sizing” property set
// to be GTK_TREE_VIEW_COLUMN_FIXED.
func (t treeView) InsertColumn(column TreeViewColumn, position int) int {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreeViewColumn // out
	var _arg2 C.gint               // out
	var _cret C.gint               // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))
	_arg2 = (C.gint)(position)

	_cret = C.gtk_tree_view_insert_column(_arg0, _arg1, _arg2)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// IsBlankAtPos: determine whether the point (@x, @y) in @tree_view is blank,
// that is no cell content nor an expander arrow is drawn at the location. If
// so, the location can be considered as the background. You might wish to take
// special action on clicks on the background, such as clearing a current
// selection, having a custom context menu or starting rubber banding.
//
// The @x and @y coordinate that are provided must be relative to bin_window
// coordinates. That is, @x and @y must come from an event on @tree_view where
// `event->window == gtk_tree_view_get_bin_window ()`.
//
// For converting widget coordinates (eg. the ones you get from
// GtkWidget::query-tooltip), please see
// gtk_tree_view_convert_widget_to_bin_window_coords().
//
// The @path, @column, @cell_x and @cell_y arguments will be filled in likewise
// as for gtk_tree_view_get_path_at_pos(). Please see
// gtk_tree_view_get_path_at_pos() for more information.
func (t treeView) IsBlankAtPos(x int, y int) (path *TreePath, column TreeViewColumn, cellX int, cellY int, ok bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gint         // out
	var _arg2 C.gint         // out
	var _path *TreePath
	var _arg4 *C.GtkTreeViewColumn // in
	var _arg5 C.gint               // in
	var _arg6 C.gint               // in
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(x)
	_arg2 = (C.gint)(y)

	_cret = C.gtk_tree_view_is_blank_at_pos(_arg0, _arg1, _arg2, (**C.GtkTreePath)(unsafe.Pointer(&_path)), &_arg4, &_arg5, &_arg6)

	var _column TreeViewColumn // out
	var _cellX int             // out
	var _cellY int             // out
	var _ok bool               // out

	_column = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg4))).(TreeViewColumn)
	_cellX = (int)(_arg5)
	_cellY = (int)(_arg6)
	if _cret != 0 {
		_ok = true
	}

	return _path, _column, _cellX, _cellY, _ok
}

// IsRubberBandingActive returns whether a rubber banding operation is currently
// being done in @tree_view.
func (t treeView) IsRubberBandingActive() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_is_rubber_banding_active(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MoveColumnAfter moves @column to be after to @base_column. If @base_column is
// nil, then @column is placed in the first position.
func (t treeView) MoveColumnAfter(column TreeViewColumn, baseColumn TreeViewColumn) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreeViewColumn // out
	var _arg2 *C.GtkTreeViewColumn // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))
	_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(baseColumn.Native()))

	C.gtk_tree_view_move_column_after(_arg0, _arg1, _arg2)
}

// RemoveColumn removes @column from @tree_view.
func (t treeView) RemoveColumn(column TreeViewColumn) int {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreeViewColumn // out
	var _cret C.gint               // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))

	_cret = C.gtk_tree_view_remove_column(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// RowActivated activates the cell determined by @path and @column.
func (t treeView) RowActivated(path *TreePath, column TreeViewColumn) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreePath       // out
	var _arg2 *C.GtkTreeViewColumn // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))

	C.gtk_tree_view_row_activated(_arg0, _arg1, _arg2)
}

// RowExpanded returns true if the node pointed to by @path is expanded in
// @tree_view.
func (t treeView) RowExpanded(path *TreePath) bool {
	var _arg0 *C.GtkTreeView // out
	var _arg1 *C.GtkTreePath // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	_cret = C.gtk_tree_view_row_expanded(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ScrollToCell moves the alignments of @tree_view to the position specified by
// @column and @path. If @column is nil, then no horizontal scrolling occurs.
// Likewise, if @path is nil no vertical scrolling occurs. At a minimum, one of
// @column or @path need to be non-nil. @row_align determines where the row is
// placed, and @col_align determines where @column is placed. Both are expected
// to be between 0.0 and 1.0. 0.0 means left/top alignment, 1.0 means
// right/bottom alignment, 0.5 means center.
//
// If @use_align is false, then the alignment arguments are ignored, and the
// tree does the minimum amount of work to scroll the cell onto the screen. This
// means that the cell will be scrolled to the edge closest to its current
// position. If the cell is currently visible on the screen, nothing is done.
//
// This function only works if the model is set, and @path is a valid row on the
// model. If the model changes before the @tree_view is realized, the centered
// path will be modified to reflect this change.
func (t treeView) ScrollToCell(path *TreePath, column TreeViewColumn, useAlign bool, rowAlign float32, colAlign float32) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreePath       // out
	var _arg2 *C.GtkTreeViewColumn // out
	var _arg3 C.gboolean           // out
	var _arg4 C.gfloat             // out
	var _arg5 C.gfloat             // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))
	if useAlign {
		_arg3 = C.TRUE
	}
	_arg4 = (C.gfloat)(rowAlign)
	_arg5 = (C.gfloat)(colAlign)

	C.gtk_tree_view_scroll_to_cell(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}

// ScrollToPoint scrolls the tree view such that the top-left corner of the
// visible area is @tree_x, @tree_y, where @tree_x and @tree_y are specified in
// tree coordinates. The @tree_view must be realized before this function is
// called. If it isn't, you probably want to be using
// gtk_tree_view_scroll_to_cell().
//
// If either @tree_x or @tree_y are -1, then that direction isn’t scrolled.
func (t treeView) ScrollToPoint(treeX int, treeY int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gint         // out
	var _arg2 C.gint         // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(treeX)
	_arg2 = (C.gint)(treeY)

	C.gtk_tree_view_scroll_to_point(_arg0, _arg1, _arg2)
}

// SetActivateOnSingleClick: cause the TreeView::row-activated signal to be
// emitted on a single click instead of a double click.
func (t treeView) SetActivateOnSingleClick(single bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	if single {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_activate_on_single_click(_arg0, _arg1)
}

// SetCursor sets the current keyboard focus to be at @path, and selects it.
// This is useful when you want to focus the user’s attention on a particular
// row. If @focus_column is not nil, then focus is given to the column specified
// by it. Additionally, if @focus_column is specified, and @start_editing is
// true, then editing should be started in the specified cell. This function is
// often followed by @gtk_widget_grab_focus (@tree_view) in order to give
// keyboard focus to the widget. Please note that editing can only happen when
// the widget is realized.
//
// If @path is invalid for @model, the current cursor (if any) will be unset and
// the function will return without failing.
func (t treeView) SetCursor(path *TreePath, focusColumn TreeViewColumn, startEditing bool) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreePath       // out
	var _arg2 *C.GtkTreeViewColumn // out
	var _arg3 C.gboolean           // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(focusColumn.Native()))
	if startEditing {
		_arg3 = C.TRUE
	}

	C.gtk_tree_view_set_cursor(_arg0, _arg1, _arg2, _arg3)
}

// SetCursorOnCell sets the current keyboard focus to be at @path, and selects
// it. This is useful when you want to focus the user’s attention on a
// particular row. If @focus_column is not nil, then focus is given to the
// column specified by it. If @focus_column and @focus_cell are not nil, and
// @focus_column contains 2 or more editable or activatable cells, then focus is
// given to the cell specified by @focus_cell. Additionally, if @focus_column is
// specified, and @start_editing is true, then editing should be started in the
// specified cell. This function is often followed by @gtk_widget_grab_focus
// (@tree_view) in order to give keyboard focus to the widget. Please note that
// editing can only happen when the widget is realized.
//
// If @path is invalid for @model, the current cursor (if any) will be unset and
// the function will return without failing.
func (t treeView) SetCursorOnCell(path *TreePath, focusColumn TreeViewColumn, focusCell CellRenderer, startEditing bool) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreePath       // out
	var _arg2 *C.GtkTreeViewColumn // out
	var _arg3 *C.GtkCellRenderer   // out
	var _arg4 C.gboolean           // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(focusColumn.Native()))
	_arg3 = (*C.GtkCellRenderer)(unsafe.Pointer(focusCell.Native()))
	if startEditing {
		_arg4 = C.TRUE
	}

	C.gtk_tree_view_set_cursor_on_cell(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// SetDragDestRow sets the row that is highlighted for feedback. If @path is
// nil, an existing highlight is removed.
func (t treeView) SetDragDestRow(path *TreePath, pos TreeViewDropPosition) {
	var _arg0 *C.GtkTreeView            // out
	var _arg1 *C.GtkTreePath            // out
	var _arg2 C.GtkTreeViewDropPosition // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg2 = (C.GtkTreeViewDropPosition)(pos)

	C.gtk_tree_view_set_drag_dest_row(_arg0, _arg1, _arg2)
}

// SetEnableSearch: if @enable_search is set, then the user can type in text to
// search through the tree interactively (this is sometimes called "typeahead
// find").
//
// Note that even if this is false, the user can still initiate a search using
// the “start-interactive-search” key binding.
func (t treeView) SetEnableSearch(enableSearch bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	if enableSearch {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_enable_search(_arg0, _arg1)
}

// SetEnableTreeLines sets whether to draw lines interconnecting the expanders
// in @tree_view. This does not have any visible effects for lists.
func (t treeView) SetEnableTreeLines(enabled bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_enable_tree_lines(_arg0, _arg1)
}

// SetExpanderColumn sets the column to draw the expander arrow at. It must be
// in @tree_view. If @column is nil, then the expander arrow is always at the
// first visible column.
//
// If you do not want expander arrow to appear in your tree, set the expander
// column to a hidden column.
func (t treeView) SetExpanderColumn(column TreeViewColumn) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreeViewColumn // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))

	C.gtk_tree_view_set_expander_column(_arg0, _arg1)
}

// SetFixedHeightMode enables or disables the fixed height mode of @tree_view.
// Fixed height mode speeds up TreeView by assuming that all rows have the same
// height. Only enable this option if all rows are the same height and all
// columns are of type GTK_TREE_VIEW_COLUMN_FIXED.
func (t treeView) SetFixedHeightMode(enable bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	if enable {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_fixed_height_mode(_arg0, _arg1)
}

// SetGridLines sets which grid lines to draw in @tree_view.
func (t treeView) SetGridLines(gridLines TreeViewGridLines) {
	var _arg0 *C.GtkTreeView         // out
	var _arg1 C.GtkTreeViewGridLines // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.GtkTreeViewGridLines)(gridLines)

	C.gtk_tree_view_set_grid_lines(_arg0, _arg1)
}

// SetHAdjustment sets the Adjustment for the current horizontal aspect.
func (t treeView) SetHAdjustment(adjustment Adjustment) {
	var _arg0 *C.GtkTreeView   // out
	var _arg1 *C.GtkAdjustment // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	C.gtk_tree_view_set_hadjustment(_arg0, _arg1)
}

// SetHeadersClickable: allow the column title buttons to be clicked.
func (t treeView) SetHeadersClickable(setting bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_headers_clickable(_arg0, _arg1)
}

// SetHeadersVisible sets the visibility state of the headers.
func (t treeView) SetHeadersVisible(headersVisible bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	if headersVisible {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_headers_visible(_arg0, _arg1)
}

// SetHoverExpand enables or disables the hover expansion mode of @tree_view.
// Hover expansion makes rows expand or collapse if the pointer moves over them.
func (t treeView) SetHoverExpand(expand bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	if expand {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_hover_expand(_arg0, _arg1)
}

// SetHoverSelection enables or disables the hover selection mode of @tree_view.
// Hover selection makes the selected row follow the pointer. Currently, this
// works only for the selection modes GTK_SELECTION_SINGLE and
// GTK_SELECTION_BROWSE.
func (t treeView) SetHoverSelection(hover bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	if hover {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_hover_selection(_arg0, _arg1)
}

// SetLevelIndentation sets the amount of extra indentation for child levels to
// use in @tree_view in addition to the default indentation. The value should be
// specified in pixels, a value of 0 disables this feature and in this case only
// the default indentation will be used. This does not have any visible effects
// for lists.
func (t treeView) SetLevelIndentation(indentation int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(indentation)

	C.gtk_tree_view_set_level_indentation(_arg0, _arg1)
}

// SetModel sets the model for a TreeView. If the @tree_view already has a model
// set, it will remove it before setting the new model. If @model is nil, then
// it will unset the old model.
func (t treeView) SetModel(model TreeModel) {
	var _arg0 *C.GtkTreeView  // out
	var _arg1 *C.GtkTreeModel // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

	C.gtk_tree_view_set_model(_arg0, _arg1)
}

// SetReorderable: this function is a convenience function to allow you to
// reorder models that support the TreeDragSourceIface and the
// TreeDragDestIface. Both TreeStore and ListStore support these. If
// @reorderable is true, then the user can reorder the model by dragging and
// dropping rows. The developer can listen to these changes by connecting to the
// model’s TreeModel::row-inserted and TreeModel::row-deleted signals. The
// reordering is implemented by setting up the tree view as a drag source and
// destination. Therefore, drag and drop can not be used in a reorderable view
// for any other purpose.
//
// This function does not give you any degree of control over the order -- any
// reordering is allowed. If more control is needed, you should probably handle
// drag and drop manually.
func (t treeView) SetReorderable(reorderable bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	if reorderable {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_reorderable(_arg0, _arg1)
}

// SetRubberBanding enables or disables rubber banding in @tree_view. If the
// selection mode is K_SELECTION_MULTIPLE, rubber banding will allow the user to
// select multiple rows by dragging the mouse.
func (t treeView) SetRubberBanding(enable bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	if enable {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_rubber_banding(_arg0, _arg1)
}

// SetRulesHint sets a hint for the theme to draw even/odd rows in the
// @tree_view with different colors, also known as "zebra striping".
//
// This function tells the GTK+ theme that the user interface for your
// application requires users to read across tree rows and associate cells with
// one another.
//
// Do not use it just because you prefer the appearance of the ruled tree;
// that’s a question for the theme. Some themes will draw tree rows in
// alternating colors even when rules are turned off, and users who prefer that
// appearance all the time can choose those themes. You should call this
// function only as a semantic hint to the theme engine that your tree makes
// alternating colors useful from a functional standpoint (since it has lots of
// columns, generally).
func (t treeView) SetRulesHint(setting bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_rules_hint(_arg0, _arg1)
}

// SetSearchColumn sets @column as the column where the interactive search code
// should search in for the current model.
//
// If the search column is set, users can use the “start-interactive-search” key
// binding to bring up search popup. The enable-search property controls whether
// simply typing text will also start an interactive search.
//
// Note that @column refers to a column of the current model. The search column
// is reset to -1 when the model is changed.
func (t treeView) SetSearchColumn(column int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(column)

	C.gtk_tree_view_set_search_column(_arg0, _arg1)
}

// SetSearchEntry sets the entry which the interactive search code will use for
// this @tree_view. This is useful when you want to provide a search entry in
// our interface at all time at a fixed position. Passing nil for @entry will
// make the interactive search code use the built-in popup entry again.
func (t treeView) SetSearchEntry(entry Entry) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 *C.GtkEntry    // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkEntry)(unsafe.Pointer(entry.Native()))

	C.gtk_tree_view_set_search_entry(_arg0, _arg1)
}

// SetShowExpanders sets whether to draw and enable expanders and indent child
// rows in @tree_view. When disabled there will be no expanders visible in trees
// and there will be no way to expand and collapse rows by default. Also note
// that hiding the expanders will disable the default indentation. You can set a
// custom indentation in this case using gtk_tree_view_set_level_indentation().
// This does not have any visible effects for lists.
func (t treeView) SetShowExpanders(enabled bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_show_expanders(_arg0, _arg1)
}

// SetTooltipCell sets the tip area of @tooltip to the area @path, @column and
// @cell have in common. For example if @path is nil and @column is set, the tip
// area will be set to the full area covered by @column. See also
// gtk_tooltip_set_tip_area().
//
// Note that if @path is not specified and @cell is set and part of a column
// containing the expander, the tooltip might not show and hide at the correct
// position. In such cases @path must be set to the current node under the mouse
// cursor for this function to operate correctly.
//
// See also gtk_tree_view_set_tooltip_column() for a simpler alternative.
func (t treeView) SetTooltipCell(tooltip Tooltip, path *TreePath, column TreeViewColumn, cell CellRenderer) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTooltip        // out
	var _arg2 *C.GtkTreePath       // out
	var _arg3 *C.GtkTreeViewColumn // out
	var _arg4 *C.GtkCellRenderer   // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTooltip)(unsafe.Pointer(tooltip.Native()))
	_arg2 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg3 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))
	_arg4 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))

	C.gtk_tree_view_set_tooltip_cell(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// SetTooltipColumn: if you only plan to have simple (text-only) tooltips on
// full rows, you can use this function to have TreeView handle these
// automatically for you. @column should be set to the column in @tree_view’s
// model containing the tooltip texts, or -1 to disable this feature.
//
// When enabled, Widget:has-tooltip will be set to true and @tree_view will
// connect a Widget::query-tooltip signal handler.
//
// Note that the signal handler sets the text with gtk_tooltip_set_markup(), so
// &, <, etc have to be escaped in the text.
func (t treeView) SetTooltipColumn(column int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(column)

	C.gtk_tree_view_set_tooltip_column(_arg0, _arg1)
}

// SetTooltipRow sets the tip area of @tooltip to be the area covered by the row
// at @path. See also gtk_tree_view_set_tooltip_column() for a simpler
// alternative. See also gtk_tooltip_set_tip_area().
func (t treeView) SetTooltipRow(tooltip Tooltip, path *TreePath) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 *C.GtkTooltip  // out
	var _arg2 *C.GtkTreePath // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTooltip)(unsafe.Pointer(tooltip.Native()))
	_arg2 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_tree_view_set_tooltip_row(_arg0, _arg1, _arg2)
}

// SetVAdjustment sets the Adjustment for the current vertical aspect.
func (t treeView) SetVAdjustment(adjustment Adjustment) {
	var _arg0 *C.GtkTreeView   // out
	var _arg1 *C.GtkAdjustment // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	C.gtk_tree_view_set_vadjustment(_arg0, _arg1)
}

// UnsetRowsDragDest undoes the effect of
// gtk_tree_view_enable_model_drag_dest(). Calling this method sets
// TreeView:reorderable to false.
func (t treeView) UnsetRowsDragDest() {
	var _arg0 *C.GtkTreeView // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_unset_rows_drag_dest(_arg0)
}

// UnsetRowsDragSource undoes the effect of
// gtk_tree_view_enable_model_drag_source(). Calling this method sets
// TreeView:reorderable to false.
func (t treeView) UnsetRowsDragSource() {
	var _arg0 *C.GtkTreeView // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_unset_rows_drag_source(_arg0)
}

type TreeViewAccessible interface {
	ContainerAccessible
	CellAccessibleParent
}

// treeViewAccessible implements the TreeViewAccessible class.
type treeViewAccessible struct {
	ContainerAccessible
	CellAccessibleParent
}

var _ TreeViewAccessible = (*treeViewAccessible)(nil)

// WrapTreeViewAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeViewAccessible(obj *externglib.Object) TreeViewAccessible {
	return treeViewAccessible{
		ContainerAccessible:  WrapContainerAccessible(obj),
		CellAccessibleParent: WrapCellAccessibleParent(obj),
	}
}

func marshalTreeViewAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeViewAccessible(obj), nil
}

// TreeViewColumn: the GtkTreeViewColumn object represents a visible column in a
// TreeView widget. It allows to set properties of the column header, and
// functions as a holding pen for the cell renderers which determine how the
// data in the column is displayed.
//
// Please refer to the [tree widget conceptual overview][TreeWidget] for an
// overview of all the objects and data types related to the tree widget and how
// they work together.
type TreeViewColumn interface {
	gextras.Objector
	Buildable
	CellLayout

	// AddAttribute adds an attribute mapping to the list in @tree_column. The
	// @column is the column of the model to get a value from, and the
	// @attribute is the parameter on @cell_renderer to be set from the value.
	// So for example if column 2 of the model contains strings, you could have
	// the “text” attribute of a CellRendererText get its values from column 2.
	AddAttribute(cellRenderer CellRenderer, attribute string, column int)
	// CellGetPosition obtains the horizontal position and size of a cell in a
	// column. If the cell is not found in the column, @start_pos and @width are
	// not changed and false is returned.
	CellGetPosition(cellRenderer CellRenderer) (xOffset int, width int, ok bool)
	// CellGetSize obtains the width and height needed to render the column.
	// This is used primarily by the TreeView.
	CellGetSize(cellArea *gdk.Rectangle) (xOffset int, yOffset int, width int, height int)
	// CellIsVisible returns true if any of the cells packed into the
	// @tree_column are visible. For this to be meaningful, you must first
	// initialize the cells with gtk_tree_view_column_cell_set_cell_data()
	CellIsVisible() bool
	// CellSetCellData sets the cell renderer based on the @tree_model and
	// @iter. That is, for every attribute mapping in @tree_column, it will get
	// a value from the set column on the @iter, and use that value to set the
	// attribute on the cell renderer. This is used primarily by the TreeView.
	CellSetCellData(treeModel TreeModel, iter *TreeIter, isExpander bool, isExpanded bool)
	// Clear unsets all the mappings on all renderers on the @tree_column.
	Clear()
	// ClearAttributes clears all existing attributes previously set with
	// gtk_tree_view_column_set_attributes().
	ClearAttributes(cellRenderer CellRenderer)
	// Clicked emits the “clicked” signal on the column. This function will only
	// work if @tree_column is clickable.
	Clicked()
	// FocusCell sets the current keyboard focus to be at @cell, if the column
	// contains 2 or more editable and activatable cells.
	FocusCell(cell CellRenderer)
	// Alignment returns the current x alignment of @tree_column. This value can
	// range between 0.0 and 1.0.
	Alignment() float32
	// Button returns the button used in the treeview column header
	Button() Widget
	// Clickable returns true if the user can click on the header for the
	// column.
	Clickable() bool
	// Expand returns true if the column expands to fill available space.
	Expand() bool
	// FixedWidth gets the fixed width of the column. This may not be the actual
	// displayed width of the column; for that, use
	// gtk_tree_view_column_get_width().
	FixedWidth() int
	// MaxWidth returns the maximum width in pixels of the @tree_column, or -1
	// if no maximum width is set.
	MaxWidth() int
	// MinWidth returns the minimum width in pixels of the @tree_column, or -1
	// if no minimum width is set.
	MinWidth() int
	// Reorderable returns true if the @tree_column can be reordered by the
	// user.
	Reorderable() bool
	// Resizable returns true if the @tree_column can be resized by the end
	// user.
	Resizable() bool
	// Sizing returns the current type of @tree_column.
	Sizing() TreeViewColumnSizing
	// SortColumnID gets the logical @sort_column_id that the model sorts on
	// when this column is selected for sorting. See
	// gtk_tree_view_column_set_sort_column_id().
	SortColumnID() int
	// SortIndicator gets the value set by
	// gtk_tree_view_column_set_sort_indicator().
	SortIndicator() bool
	// SortOrder gets the value set by gtk_tree_view_column_set_sort_order().
	SortOrder() SortType
	// Spacing returns the spacing of @tree_column.
	Spacing() int
	// Title returns the title of the widget.
	Title() string
	// TreeView returns the TreeView wherein @tree_column has been inserted. If
	// @column is currently not inserted in any tree view, nil is returned.
	TreeView() Widget
	// Visible returns true if @tree_column is visible.
	Visible() bool
	// Widget returns the Widget in the button on the column header. If a custom
	// widget has not been set then nil is returned.
	Widget() Widget
	// Width returns the current size of @tree_column in pixels.
	Width() int
	// XOffset returns the current X offset of @tree_column in pixels.
	XOffset() int
	// PackEnd adds the @cell to end of the column. If @expand is false, then
	// the @cell is allocated no more space than it needs. Any unused space is
	// divided evenly between cells for which @expand is true.
	PackEnd(cell CellRenderer, expand bool)
	// PackStart packs the @cell into the beginning of the column. If @expand is
	// false, then the @cell is allocated no more space than it needs. Any
	// unused space is divided evenly between cells for which @expand is true.
	PackStart(cell CellRenderer, expand bool)
	// QueueResize flags the column, and the cell renderers added to this
	// column, to have their sizes renegotiated.
	QueueResize()
	// SetAlignment sets the alignment of the title or custom widget inside the
	// column header. The alignment determines its location inside the button --
	// 0.0 for left, 0.5 for center, 1.0 for right.
	SetAlignment(xalign float32)
	// SetClickable sets the header to be active if @clickable is true. When the
	// header is active, then it can take keyboard focus, and can be clicked.
	SetClickable(clickable bool)
	// SetExpand sets the column to take available extra space. This space is
	// shared equally amongst all columns that have the expand set to true. If
	// no column has this option set, then the last column gets all extra space.
	// By default, every column is created with this false.
	//
	// Along with “fixed-width”, the “expand” property changes when the column
	// is resized by the user.
	SetExpand(expand bool)
	// SetFixedWidth: if @fixed_width is not -1, sets the fixed width of
	// @tree_column; otherwise unsets it. The effective value of @fixed_width is
	// clamped between the minimum and maximum width of the column; however, the
	// value stored in the “fixed-width” property is not clamped. If the column
	// sizing is K_TREE_VIEW_COLUMN_GROW_ONLY or K_TREE_VIEW_COLUMN_AUTOSIZE,
	// setting a fixed width overrides the automatically calculated width. Note
	// that @fixed_width is only a hint to GTK+; the width actually allocated to
	// the column may be greater or less than requested.
	//
	// Along with “expand”, the “fixed-width” property changes when the column
	// is resized by the user.
	SetFixedWidth(fixedWidth int)
	// SetMaxWidth sets the maximum width of the @tree_column. If @max_width is
	// -1, then the maximum width is unset. Note, the column can actually be
	// wider than max width if it’s the last column in a view. In this case, the
	// column expands to fill any extra space.
	SetMaxWidth(maxWidth int)
	// SetMinWidth sets the minimum width of the @tree_column. If @min_width is
	// -1, then the minimum width is unset.
	SetMinWidth(minWidth int)
	// SetReorderable: if @reorderable is true, then the column can be reordered
	// by the end user dragging the header.
	SetReorderable(reorderable bool)
	// SetResizable: if @resizable is true, then the user can explicitly resize
	// the column by grabbing the outer edge of the column button. If resizable
	// is true and sizing mode of the column is K_TREE_VIEW_COLUMN_AUTOSIZE,
	// then the sizing mode is changed to K_TREE_VIEW_COLUMN_GROW_ONLY.
	SetResizable(resizable bool)
	// SetSizing sets the growth behavior of @tree_column to @type.
	SetSizing(typ TreeViewColumnSizing)
	// SetSortColumnID sets the logical @sort_column_id that this column sorts
	// on when this column is selected for sorting. Doing so makes the column
	// header clickable.
	SetSortColumnID(sortColumnId int)
	// SetSortIndicator: call this function with a @setting of true to display
	// an arrow in the header button indicating the column is sorted. Call
	// gtk_tree_view_column_set_sort_order() to change the direction of the
	// arrow.
	SetSortIndicator(setting bool)
	// SetSortOrder changes the appearance of the sort indicator.
	//
	// This does not actually sort the model. Use
	// gtk_tree_view_column_set_sort_column_id() if you want automatic sorting
	// support. This function is primarily for custom sorting behavior, and
	// should be used in conjunction with gtk_tree_sortable_set_sort_column_id()
	// to do that. For custom models, the mechanism will vary.
	//
	// The sort indicator changes direction to indicate normal sort or reverse
	// sort. Note that you must have the sort indicator enabled to see anything
	// when calling this function; see
	// gtk_tree_view_column_set_sort_indicator().
	SetSortOrder(order SortType)
	// SetSpacing sets the spacing field of @tree_column, which is the number of
	// pixels to place between cell renderers packed into it.
	SetSpacing(spacing int)
	// SetTitle sets the title of the @tree_column. If a custom widget has been
	// set, then this value is ignored.
	SetTitle(title string)
	// SetVisible sets the visibility of @tree_column.
	SetVisible(visible bool)
	// SetWidget sets the widget in the header to be @widget. If widget is nil,
	// then the header button is set with a Label set to the title of
	// @tree_column.
	SetWidget(widget Widget)
}

// treeViewColumn implements the TreeViewColumn class.
type treeViewColumn struct {
	gextras.Objector
	Buildable
	CellLayout
}

var _ TreeViewColumn = (*treeViewColumn)(nil)

// WrapTreeViewColumn wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeViewColumn(obj *externglib.Object) TreeViewColumn {
	return treeViewColumn{
		Objector:   obj,
		Buildable:  WrapBuildable(obj),
		CellLayout: WrapCellLayout(obj),
	}
}

func marshalTreeViewColumn(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeViewColumn(obj), nil
}

// NewTreeViewColumn creates a new TreeViewColumn.
func NewTreeViewColumn() TreeViewColumn {
	var _cret *C.GtkTreeViewColumn // in

	_cret = C.gtk_tree_view_column_new()

	var _treeViewColumn TreeViewColumn // out

	_treeViewColumn = WrapTreeViewColumn(externglib.Take(unsafe.Pointer(_cret)))

	return _treeViewColumn
}

// NewTreeViewColumnWithArea creates a new TreeViewColumn using @area to render
// its cells.
func NewTreeViewColumnWithArea(area CellArea) TreeViewColumn {
	var _arg1 *C.GtkCellArea       // out
	var _cret *C.GtkTreeViewColumn // in

	_arg1 = (*C.GtkCellArea)(unsafe.Pointer(area.Native()))

	_cret = C.gtk_tree_view_column_new_with_area(_arg1)

	var _treeViewColumn TreeViewColumn // out

	_treeViewColumn = WrapTreeViewColumn(externglib.Take(unsafe.Pointer(_cret)))

	return _treeViewColumn
}

// AddAttribute adds an attribute mapping to the list in @tree_column. The
// @column is the column of the model to get a value from, and the @attribute is
// the parameter on @cell_renderer to be set from the value. So for example if
// column 2 of the model contains strings, you could have the “text” attribute
// of a CellRendererText get its values from column 2.
func (t treeViewColumn) AddAttribute(cellRenderer CellRenderer, attribute string, column int) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 *C.GtkCellRenderer   // out
	var _arg2 *C.gchar             // out
	var _arg3 C.gint               // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cellRenderer.Native()))
	_arg2 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.gint)(column)

	C.gtk_tree_view_column_add_attribute(_arg0, _arg1, _arg2, _arg3)
}

// CellGetPosition obtains the horizontal position and size of a cell in a
// column. If the cell is not found in the column, @start_pos and @width are not
// changed and false is returned.
func (t treeViewColumn) CellGetPosition(cellRenderer CellRenderer) (xOffset int, width int, ok bool) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 *C.GtkCellRenderer   // out
	var _arg2 C.gint               // in
	var _arg3 C.gint               // in
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cellRenderer.Native()))

	_cret = C.gtk_tree_view_column_cell_get_position(_arg0, _arg1, &_arg2, &_arg3)

	var _xOffset int // out
	var _width int   // out
	var _ok bool     // out

	_xOffset = (int)(_arg2)
	_width = (int)(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _xOffset, _width, _ok
}

// CellGetSize obtains the width and height needed to render the column. This is
// used primarily by the TreeView.
func (t treeViewColumn) CellGetSize(cellArea *gdk.Rectangle) (xOffset int, yOffset int, width int, height int) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 *C.GdkRectangle      // out
	var _arg2 C.gint               // in
	var _arg3 C.gint               // in
	var _arg4 C.gint               // in
	var _arg5 C.gint               // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))

	C.gtk_tree_view_column_cell_get_size(_arg0, _arg1, &_arg2, &_arg3, &_arg4, &_arg5)

	var _xOffset int // out
	var _yOffset int // out
	var _width int   // out
	var _height int  // out

	_xOffset = (int)(_arg2)
	_yOffset = (int)(_arg3)
	_width = (int)(_arg4)
	_height = (int)(_arg5)

	return _xOffset, _yOffset, _width, _height
}

// CellIsVisible returns true if any of the cells packed into the @tree_column
// are visible. For this to be meaningful, you must first initialize the cells
// with gtk_tree_view_column_cell_set_cell_data()
func (t treeViewColumn) CellIsVisible() bool {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_cell_is_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CellSetCellData sets the cell renderer based on the @tree_model and @iter.
// That is, for every attribute mapping in @tree_column, it will get a value
// from the set column on the @iter, and use that value to set the attribute on
// the cell renderer. This is used primarily by the TreeView.
func (t treeViewColumn) CellSetCellData(treeModel TreeModel, iter *TreeIter, isExpander bool, isExpanded bool) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 *C.GtkTreeModel      // out
	var _arg2 *C.GtkTreeIter       // out
	var _arg3 C.gboolean           // out
	var _arg4 C.gboolean           // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(treeModel.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
	if isExpander {
		_arg3 = C.TRUE
	}
	if isExpanded {
		_arg4 = C.TRUE
	}

	C.gtk_tree_view_column_cell_set_cell_data(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// Clear unsets all the mappings on all renderers on the @tree_column.
func (t treeViewColumn) Clear() {
	var _arg0 *C.GtkTreeViewColumn // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_column_clear(_arg0)
}

// ClearAttributes clears all existing attributes previously set with
// gtk_tree_view_column_set_attributes().
func (t treeViewColumn) ClearAttributes(cellRenderer CellRenderer) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 *C.GtkCellRenderer   // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cellRenderer.Native()))

	C.gtk_tree_view_column_clear_attributes(_arg0, _arg1)
}

// Clicked emits the “clicked” signal on the column. This function will only
// work if @tree_column is clickable.
func (t treeViewColumn) Clicked() {
	var _arg0 *C.GtkTreeViewColumn // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_column_clicked(_arg0)
}

// FocusCell sets the current keyboard focus to be at @cell, if the column
// contains 2 or more editable and activatable cells.
func (t treeViewColumn) FocusCell(cell CellRenderer) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 *C.GtkCellRenderer   // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))

	C.gtk_tree_view_column_focus_cell(_arg0, _arg1)
}

// Alignment returns the current x alignment of @tree_column. This value can
// range between 0.0 and 1.0.
func (t treeViewColumn) Alignment() float32 {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.gfloat             // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_alignment(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Button returns the button used in the treeview column header
func (t treeViewColumn) Button() Widget {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret *C.GtkWidget         // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_button(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// Clickable returns true if the user can click on the header for the column.
func (t treeViewColumn) Clickable() bool {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_clickable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Expand returns true if the column expands to fill available space.
func (t treeViewColumn) Expand() bool {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_expand(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FixedWidth gets the fixed width of the column. This may not be the actual
// displayed width of the column; for that, use
// gtk_tree_view_column_get_width().
func (t treeViewColumn) FixedWidth() int {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.gint               // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_fixed_width(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// MaxWidth returns the maximum width in pixels of the @tree_column, or -1 if no
// maximum width is set.
func (t treeViewColumn) MaxWidth() int {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.gint               // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_max_width(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// MinWidth returns the minimum width in pixels of the @tree_column, or -1 if no
// minimum width is set.
func (t treeViewColumn) MinWidth() int {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.gint               // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_min_width(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Reorderable returns true if the @tree_column can be reordered by the user.
func (t treeViewColumn) Reorderable() bool {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_reorderable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Resizable returns true if the @tree_column can be resized by the end user.
func (t treeViewColumn) Resizable() bool {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_resizable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Sizing returns the current type of @tree_column.
func (t treeViewColumn) Sizing() TreeViewColumnSizing {
	var _arg0 *C.GtkTreeViewColumn      // out
	var _cret C.GtkTreeViewColumnSizing // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_sizing(_arg0)

	var _treeViewColumnSizing TreeViewColumnSizing // out

	_treeViewColumnSizing = TreeViewColumnSizing(_cret)

	return _treeViewColumnSizing
}

// SortColumnID gets the logical @sort_column_id that the model sorts on when
// this column is selected for sorting. See
// gtk_tree_view_column_set_sort_column_id().
func (t treeViewColumn) SortColumnID() int {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.gint               // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_sort_column_id(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// SortIndicator gets the value set by
// gtk_tree_view_column_set_sort_indicator().
func (t treeViewColumn) SortIndicator() bool {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_sort_indicator(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SortOrder gets the value set by gtk_tree_view_column_set_sort_order().
func (t treeViewColumn) SortOrder() SortType {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.GtkSortType        // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_sort_order(_arg0)

	var _sortType SortType // out

	_sortType = SortType(_cret)

	return _sortType
}

// Spacing returns the spacing of @tree_column.
func (t treeViewColumn) Spacing() int {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.gint               // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_spacing(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Title returns the title of the widget.
func (t treeViewColumn) Title() string {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret *C.gchar             // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_title(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// TreeView returns the TreeView wherein @tree_column has been inserted. If
// @column is currently not inserted in any tree view, nil is returned.
func (t treeViewColumn) TreeView() Widget {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret *C.GtkWidget         // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_tree_view(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// Visible returns true if @tree_column is visible.
func (t treeViewColumn) Visible() bool {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Widget returns the Widget in the button on the column header. If a custom
// widget has not been set then nil is returned.
func (t treeViewColumn) Widget() Widget {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret *C.GtkWidget         // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// Width returns the current size of @tree_column in pixels.
func (t treeViewColumn) Width() int {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.gint               // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_width(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// XOffset returns the current X offset of @tree_column in pixels.
func (t treeViewColumn) XOffset() int {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.gint               // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_tree_view_column_get_x_offset(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// PackEnd adds the @cell to end of the column. If @expand is false, then the
// @cell is allocated no more space than it needs. Any unused space is divided
// evenly between cells for which @expand is true.
func (t treeViewColumn) PackEnd(cell CellRenderer, expand bool) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 *C.GtkCellRenderer   // out
	var _arg2 C.gboolean           // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))
	if expand {
		_arg2 = C.TRUE
	}

	C.gtk_tree_view_column_pack_end(_arg0, _arg1, _arg2)
}

// PackStart packs the @cell into the beginning of the column. If @expand is
// false, then the @cell is allocated no more space than it needs. Any unused
// space is divided evenly between cells for which @expand is true.
func (t treeViewColumn) PackStart(cell CellRenderer, expand bool) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 *C.GtkCellRenderer   // out
	var _arg2 C.gboolean           // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))
	if expand {
		_arg2 = C.TRUE
	}

	C.gtk_tree_view_column_pack_start(_arg0, _arg1, _arg2)
}

// QueueResize flags the column, and the cell renderers added to this column, to
// have their sizes renegotiated.
func (t treeViewColumn) QueueResize() {
	var _arg0 *C.GtkTreeViewColumn // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_column_queue_resize(_arg0)
}

// SetAlignment sets the alignment of the title or custom widget inside the
// column header. The alignment determines its location inside the button -- 0.0
// for left, 0.5 for center, 1.0 for right.
func (t treeViewColumn) SetAlignment(xalign float32) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.gfloat             // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gfloat)(xalign)

	C.gtk_tree_view_column_set_alignment(_arg0, _arg1)
}

// SetClickable sets the header to be active if @clickable is true. When the
// header is active, then it can take keyboard focus, and can be clicked.
func (t treeViewColumn) SetClickable(clickable bool) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	if clickable {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_column_set_clickable(_arg0, _arg1)
}

// SetExpand sets the column to take available extra space. This space is shared
// equally amongst all columns that have the expand set to true. If no column
// has this option set, then the last column gets all extra space. By default,
// every column is created with this false.
//
// Along with “fixed-width”, the “expand” property changes when the column is
// resized by the user.
func (t treeViewColumn) SetExpand(expand bool) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	if expand {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_column_set_expand(_arg0, _arg1)
}

// SetFixedWidth: if @fixed_width is not -1, sets the fixed width of
// @tree_column; otherwise unsets it. The effective value of @fixed_width is
// clamped between the minimum and maximum width of the column; however, the
// value stored in the “fixed-width” property is not clamped. If the column
// sizing is K_TREE_VIEW_COLUMN_GROW_ONLY or K_TREE_VIEW_COLUMN_AUTOSIZE,
// setting a fixed width overrides the automatically calculated width. Note that
// @fixed_width is only a hint to GTK+; the width actually allocated to the
// column may be greater or less than requested.
//
// Along with “expand”, the “fixed-width” property changes when the column is
// resized by the user.
func (t treeViewColumn) SetFixedWidth(fixedWidth int) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.gint               // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(fixedWidth)

	C.gtk_tree_view_column_set_fixed_width(_arg0, _arg1)
}

// SetMaxWidth sets the maximum width of the @tree_column. If @max_width is -1,
// then the maximum width is unset. Note, the column can actually be wider than
// max width if it’s the last column in a view. In this case, the column expands
// to fill any extra space.
func (t treeViewColumn) SetMaxWidth(maxWidth int) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.gint               // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(maxWidth)

	C.gtk_tree_view_column_set_max_width(_arg0, _arg1)
}

// SetMinWidth sets the minimum width of the @tree_column. If @min_width is -1,
// then the minimum width is unset.
func (t treeViewColumn) SetMinWidth(minWidth int) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.gint               // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(minWidth)

	C.gtk_tree_view_column_set_min_width(_arg0, _arg1)
}

// SetReorderable: if @reorderable is true, then the column can be reordered by
// the end user dragging the header.
func (t treeViewColumn) SetReorderable(reorderable bool) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	if reorderable {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_column_set_reorderable(_arg0, _arg1)
}

// SetResizable: if @resizable is true, then the user can explicitly resize the
// column by grabbing the outer edge of the column button. If resizable is true
// and sizing mode of the column is K_TREE_VIEW_COLUMN_AUTOSIZE, then the sizing
// mode is changed to K_TREE_VIEW_COLUMN_GROW_ONLY.
func (t treeViewColumn) SetResizable(resizable bool) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	if resizable {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_column_set_resizable(_arg0, _arg1)
}

// SetSizing sets the growth behavior of @tree_column to @type.
func (t treeViewColumn) SetSizing(typ TreeViewColumnSizing) {
	var _arg0 *C.GtkTreeViewColumn      // out
	var _arg1 C.GtkTreeViewColumnSizing // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (C.GtkTreeViewColumnSizing)(typ)

	C.gtk_tree_view_column_set_sizing(_arg0, _arg1)
}

// SetSortColumnID sets the logical @sort_column_id that this column sorts on
// when this column is selected for sorting. Doing so makes the column header
// clickable.
func (t treeViewColumn) SetSortColumnID(sortColumnId int) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.gint               // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(sortColumnId)

	C.gtk_tree_view_column_set_sort_column_id(_arg0, _arg1)
}

// SetSortIndicator: call this function with a @setting of true to display an
// arrow in the header button indicating the column is sorted. Call
// gtk_tree_view_column_set_sort_order() to change the direction of the arrow.
func (t treeViewColumn) SetSortIndicator(setting bool) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_column_set_sort_indicator(_arg0, _arg1)
}

// SetSortOrder changes the appearance of the sort indicator.
//
// This does not actually sort the model. Use
// gtk_tree_view_column_set_sort_column_id() if you want automatic sorting
// support. This function is primarily for custom sorting behavior, and should
// be used in conjunction with gtk_tree_sortable_set_sort_column_id() to do
// that. For custom models, the mechanism will vary.
//
// The sort indicator changes direction to indicate normal sort or reverse sort.
// Note that you must have the sort indicator enabled to see anything when
// calling this function; see gtk_tree_view_column_set_sort_indicator().
func (t treeViewColumn) SetSortOrder(order SortType) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.GtkSortType        // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (C.GtkSortType)(order)

	C.gtk_tree_view_column_set_sort_order(_arg0, _arg1)
}

// SetSpacing sets the spacing field of @tree_column, which is the number of
// pixels to place between cell renderers packed into it.
func (t treeViewColumn) SetSpacing(spacing int) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.gint               // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(spacing)

	C.gtk_tree_view_column_set_spacing(_arg0, _arg1)
}

// SetTitle sets the title of the @tree_column. If a custom widget has been set,
// then this value is ignored.
func (t treeViewColumn) SetTitle(title string) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 *C.gchar             // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_tree_view_column_set_title(_arg0, _arg1)
}

// SetVisible sets the visibility of @tree_column.
func (t treeViewColumn) SetVisible(visible bool) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	if visible {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_column_set_visible(_arg0, _arg1)
}

// SetWidget sets the widget in the header to be @widget. If widget is nil, then
// the header button is set with a Label set to the title of @tree_column.
func (t treeViewColumn) SetWidget(widget Widget) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 *C.GtkWidget         // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_tree_view_column_set_widget(_arg0, _arg1)
}

// UIManager: > GtkUIManager is deprecated since GTK+ 3.10. To construct user
// interfaces > from XML definitions, you should use Builder, Model, et al. To >
// work with actions, use #GAction, Actionable et al. These newer classes >
// support richer functionality and integration with various desktop shells. >
// It should be possible to migrate most/all functionality from GtkUIManager.
//
// A UIManager constructs a user interface (menus and toolbars) from one or more
// UI definitions, which reference actions from one or more action groups.
//
//
// UI Definitions
//
// The UI definitions are specified in an XML format which can be roughly
// described by the following DTD.
//
// > Do not confuse the GtkUIManager UI Definitions described here with > the
// similarly named [GtkBuilder UI Definitions][BUILDER-UI].
//
//    <!ELEMENT ui          (menubar|toolbar|popup|accelerator)* >
//    <!ELEMENT menubar     (menuitem|separator|placeholder|menu)* >
//    <!ELEMENT menu        (menuitem|separator|placeholder|menu)* >
//    <!ELEMENT popup       (menuitem|separator|placeholder|menu)* >
//    <!ELEMENT toolbar     (toolitem|separator|placeholder)* >
//    <!ELEMENT placeholder (menuitem|toolitem|separator|placeholder|menu)* >
//    <!ELEMENT menuitem     EMPTY >
//    <!ELEMENT toolitem     (menu?) >
//    <!ELEMENT separator    EMPTY >
//    <!ELEMENT accelerator  EMPTY >
//    <!ATTLIST menubar      name                      PLIED
//                           action                    PLIED >
//    <!ATTLIST toolbar      name                      PLIED
//                           action                    PLIED >
//    <!ATTLIST popup        name                      PLIED
//                           action                    PLIED
//                           accelerators (true|false) PLIED >
//    <!ATTLIST placeholder  name                      PLIED
//                           action                    PLIED >
//    <!ATTLIST separator    name                      PLIED
//                           action                    PLIED
//                           expand       (true|false) PLIED >
//    <!ATTLIST menu         name                      PLIED
//                           action                    QUIRED
//                           position     (top|bot)    PLIED >
//    <!ATTLIST menuitem     name                      PLIED
//                           action                    QUIRED
//                           position     (top|bot)    PLIED
//                           always-show-image (true|false) PLIED >
//    <!ATTLIST toolitem     name                      PLIED
//                           action                    QUIRED
//                           position     (top|bot)    PLIED >
//    <!ATTLIST accelerator  name                      PLIED
//                           action                    QUIRED >
//
// There are some additional restrictions beyond those specified in the DTD,
// e.g. every toolitem must have a toolbar in its anchestry and every menuitem
// must have a menubar or popup in its anchestry. Since a Parser is used to
// parse the UI description, it must not only be valid XML, but valid markup.
//
// If a name is not specified, it defaults to the action. If an action is not
// specified either, the element name is used. The name and action attributes
// must not contain “/” characters after parsing (since that would mess up path
// lookup) and must be usable as XML attributes when enclosed in doublequotes,
// thus they must not “"” characters or references to the &quot; entity.
//
// A UI definition #
//
//    <ui>
//      <menubar>
//        <menu name="FileMenu" action="FileMenuAction">
//          <menuitem name="New" action="New2Action" />
//          <placeholder name="FileMenuAdditions" />
//        </menu>
//        <menu name="JustifyMenu" action="JustifyMenuAction">
//          <menuitem name="Left" action="justify-left"/>
//          <menuitem name="Centre" action="justify-center"/>
//          <menuitem name="Right" action="justify-right"/>
//          <menuitem name="Fill" action="justify-fill"/>
//        </menu>
//      </menubar>
//      <toolbar action="toolbar1">
//        <placeholder name="JustifyToolItems">
//          <separator/>
//          <toolitem name="Left" action="justify-left"/>
//          <toolitem name="Centre" action="justify-center"/>
//          <toolitem name="Right" action="justify-right"/>
//          <toolitem name="Fill" action="justify-fill"/>
//          <separator/>
//        </placeholder>
//      </toolbar>
//    </ui>
//
// The constructed widget hierarchy is very similar to the element tree of the
// XML, with the exception that placeholders are merged into their parents. The
// correspondence of XML elements to widgets should be almost obvious:
//
// - menubar
//
//    a MenuBar
//
// - toolbar
//
//    a Toolbar
//
// - popup
//
//    a toplevel Menu
//
// - menu
//
//    a Menu attached to a menuitem
//
// - menuitem
//
//    a MenuItem subclass, the exact type depends on the action
//
// - toolitem
//
//    a ToolItem subclass, the exact type depends on the
//    action. Note that toolitem elements may contain a menu element,
//    but only if their associated action specifies a
//    MenuToolButton as proxy.
//
// - separator
//
//    a SeparatorMenuItem or SeparatorToolItem
//
// - accelerator
//
//    a keyboard accelerator
//
// The “position” attribute determines where a constructed widget is positioned
// wrt. to its siblings in the partially constructed tree. If it is “top”, the
// widget is prepended, otherwise it is appended.
//
//
// UI Merging
//
// The most remarkable feature of UIManager is that it can overlay a set of
// menuitems and toolitems over another one, and demerge them later.
//
// Merging is done based on the names of the XML elements. Each element is
// identified by a path which consists of the names of its anchestors, separated
// by slashes. For example, the menuitem named “Left” in the example above has
// the path `/ui/menubar/JustifyMenu/Left` and the toolitem with the same name
// has path `/ui/toolbar1/JustifyToolItems/Left`.
//
// Accelerators #
//
// Every action has an accelerator path. Accelerators are installed together
// with menuitem proxies, but they can also be explicitly added with
// <accelerator> elements in the UI definition. This makes it possible to have
// accelerators for actions even if they have no visible proxies.
//
//
// Smart Separators
//
// The separators created by UIManager are “smart”, i.e. they do not show up in
// the UI unless they end up between two visible menu or tool items. Separators
// which are located at the very beginning or end of the menu or toolbar
// containing them, or multiple separators next to each other, are hidden. This
// is a useful feature, since the merging of UI elements from multiple sources
// can make it hard or impossible to determine in advance whether a separator
// will end up in such an unfortunate position.
//
// For separators in toolbars, you can set `expand="true"` to turn them from a
// small, visible separator to an expanding, invisible one. Toolitems following
// an expanding separator are effectively right-aligned.
//
//
// Empty Menus
//
// Submenus pose similar problems to separators inconnection with merging. It is
// impossible to know in advance whether they will end up empty after merging.
// UIManager offers two ways to treat empty submenus:
//
// - make them disappear by hiding the menu item they’re attached to
//
// - add an insensitive “Empty” item
//
// The behaviour is chosen based on the “hide_if_empty” property of the action
// to which the submenu is associated.
//
//
// GtkUIManager as GtkBuildable
//
// The GtkUIManager implementation of the GtkBuildable interface accepts
// GtkActionGroup objects as <child> elements in UI definitions.
//
// A GtkUIManager UI definition as described above can be embedded in an
// GtkUIManager <object> element in a GtkBuilder UI definition.
//
// The widgets that are constructed by a GtkUIManager can be embedded in other
// parts of the constructed user interface with the help of the “constructor”
// attribute. See the example below.
//
// An embedded GtkUIManager UI definition
//
//    <object class="GtkUIManager" id="uiman">
//      <child>
//        <object class="GtkActionGroup" id="actiongroup">
//          <child>
//            <object class="GtkAction" id="file">
//              <property name="label">_File</property>
//            </object>
//          </child>
//        </object>
//      </child>
//      <ui>
//        <menubar name="menubar1">
//          <menu action="file">
//          </menu>
//        </menubar>
//      </ui>
//    </object>
//    <object class="GtkWindow" id="main-window">
//      <child>
//        <object class="GtkMenuBar" id="menubar1" constructor="uiman"/>
//      </child>
//    </object>
type UIManager interface {
	gextras.Objector
	Buildable

	// AddUi adds a UI element to the current contents of @manager.
	//
	// If @type is GTK_UI_MANAGER_AUTO, GTK+ inserts a menuitem, toolitem or
	// separator if such an element can be inserted at the place determined by
	// @path. Otherwise @type must indicate an element that can be inserted at
	// the place determined by @path.
	//
	// If @path points to a menuitem or toolitem, the new element will be
	// inserted before or after this item, depending on @top.
	AddUi(mergeId uint, path string, name string, action string, typ UIManagerItemType, top bool)
	// AddUiFromFile parses a file containing a [UI definition][XML-UI] and
	// merges it with the current contents of @manager.
	AddUiFromFile(filename string) (uint, error)
	// AddUiFromResource parses a resource file containing a [UI
	// definition][XML-UI] and merges it with the current contents of @manager.
	AddUiFromResource(resourcePath string) (uint, error)
	// AddUiFromString parses a string containing a [UI definition][XML-UI] and
	// merges it with the current contents of @manager. An enclosing <ui>
	// element is added if it is missing.
	AddUiFromString(buffer string, length int) (uint, error)
	// EnsureUpdate makes sure that all pending updates to the UI have been
	// completed.
	//
	// This may occasionally be necessary, since UIManager updates the UI in an
	// idle function. A typical example where this function is useful is to
	// enforce that the menubar and toolbar have been added to the main window
	// before showing it:
	//
	//    gtk_container_add (GTK_CONTAINER (window), vbox);
	//    g_signal_connect (merge, "add-widget",
	//                      G_CALLBACK (add_widget), vbox);
	//    gtk_ui_manager_add_ui_from_file (merge, "my-menus");
	//    gtk_ui_manager_add_ui_from_file (merge, "my-toolbars");
	//    gtk_ui_manager_ensure_update (merge);
	//    gtk_widget_show (window);
	EnsureUpdate()
	// AccelGroup returns the AccelGroup associated with @manager.
	AccelGroup() AccelGroup
	// Action looks up an action by following a path. See
	// gtk_ui_manager_get_widget() for more information about paths.
	Action(path string) Action
	// AddTearoffs returns whether menus generated by this UIManager will have
	// tearoff menu items.
	AddTearoffs() bool
	// Ui creates a [UI definition][XML-UI] of the merged UI.
	Ui() string
	// Widget looks up a widget by following a path. The path consists of the
	// names specified in the XML description of the UI. separated by “/”.
	// Elements which don’t have a name or action attribute in the XML (e.g.
	// <popup>) can be addressed by their XML element name (e.g. "popup"). The
	// root element ("/ui") can be omitted in the path.
	//
	// Note that the widget found by following a path that ends in a <menu>;
	// element is the menuitem to which the menu is attached, not the menu it
	// manages.
	//
	// Also note that the widgets constructed by a ui manager are not tied to
	// the lifecycle of the ui manager. If you add the widgets returned by this
	// function to some container or explicitly ref them, they will survive the
	// destruction of the ui manager.
	Widget(path string) Widget
	// InsertActionGroup inserts an action group into the list of action groups
	// associated with @manager. Actions in earlier groups hide actions with the
	// same name in later groups.
	//
	// If @pos is larger than the number of action groups in @manager, or
	// negative, @action_group will be inserted at the end of the internal list.
	InsertActionGroup(actionGroup ActionGroup, pos int)
	// NewMergeID returns an unused merge id, suitable for use with
	// gtk_ui_manager_add_ui().
	NewMergeID() uint
	// RemoveActionGroup removes an action group from the list of action groups
	// associated with @manager.
	RemoveActionGroup(actionGroup ActionGroup)
	// RemoveUi unmerges the part of @manager's content identified by @merge_id.
	RemoveUi(mergeId uint)
	// SetAddTearoffs sets the “add_tearoffs” property, which controls whether
	// menus generated by this UIManager will have tearoff menu items.
	//
	// Note that this only affects regular menus. Generated popup menus never
	// have tearoff menu items.
	SetAddTearoffs(addTearoffs bool)
}

// uiManager implements the UIManager class.
type uiManager struct {
	gextras.Objector
	Buildable
}

var _ UIManager = (*uiManager)(nil)

// WrapUIManager wraps a GObject to the right type. It is
// primarily used internally.
func WrapUIManager(obj *externglib.Object) UIManager {
	return uiManager{
		Objector:  obj,
		Buildable: WrapBuildable(obj),
	}
}

func marshalUIManager(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapUIManager(obj), nil
}

// NewUIManager creates a new ui manager object.
func NewUIManager() UIManager {
	var _cret *C.GtkUIManager // in

	_cret = C.gtk_ui_manager_new()

	var _uiManager UIManager // out

	_uiManager = WrapUIManager(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _uiManager
}

// AddUi adds a UI element to the current contents of @manager.
//
// If @type is GTK_UI_MANAGER_AUTO, GTK+ inserts a menuitem, toolitem or
// separator if such an element can be inserted at the place determined by
// @path. Otherwise @type must indicate an element that can be inserted at the
// place determined by @path.
//
// If @path points to a menuitem or toolitem, the new element will be inserted
// before or after this item, depending on @top.
func (m uiManager) AddUi(mergeId uint, path string, name string, action string, typ UIManagerItemType, top bool) {
	var _arg0 *C.GtkUIManager        // out
	var _arg1 C.guint                // out
	var _arg2 *C.gchar               // out
	var _arg3 *C.gchar               // out
	var _arg4 *C.gchar               // out
	var _arg5 C.GtkUIManagerItemType // out
	var _arg6 C.gboolean             // out

	_arg0 = (*C.GtkUIManager)(unsafe.Pointer(m.Native()))
	_arg1 = (C.guint)(mergeId)
	_arg2 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(C.CString(action))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (C.GtkUIManagerItemType)(typ)
	if top {
		_arg6 = C.TRUE
	}

	C.gtk_ui_manager_add_ui(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}

// AddUiFromFile parses a file containing a [UI definition][XML-UI] and merges
// it with the current contents of @manager.
func (m uiManager) AddUiFromFile(filename string) (uint, error) {
	var _arg0 *C.GtkUIManager // out
	var _arg1 *C.gchar        // out
	var _cret C.guint         // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GtkUIManager)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_ui_manager_add_ui_from_file(_arg0, _arg1, &_cerr)

	var _guint uint  // out
	var _goerr error // out

	_guint = (uint)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _guint, _goerr
}

// AddUiFromResource parses a resource file containing a [UI definition][XML-UI]
// and merges it with the current contents of @manager.
func (m uiManager) AddUiFromResource(resourcePath string) (uint, error) {
	var _arg0 *C.GtkUIManager // out
	var _arg1 *C.gchar        // out
	var _cret C.guint         // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GtkUIManager)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_ui_manager_add_ui_from_resource(_arg0, _arg1, &_cerr)

	var _guint uint  // out
	var _goerr error // out

	_guint = (uint)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _guint, _goerr
}

// AddUiFromString parses a string containing a [UI definition][XML-UI] and
// merges it with the current contents of @manager. An enclosing <ui> element is
// added if it is missing.
func (m uiManager) AddUiFromString(buffer string, length int) (uint, error) {
	var _arg0 *C.GtkUIManager // out
	var _arg1 *C.gchar        // out
	var _arg2 C.gssize        // out
	var _cret C.guint         // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GtkUIManager)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(buffer))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gssize)(length)

	_cret = C.gtk_ui_manager_add_ui_from_string(_arg0, _arg1, _arg2, &_cerr)

	var _guint uint  // out
	var _goerr error // out

	_guint = (uint)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _guint, _goerr
}

// EnsureUpdate makes sure that all pending updates to the UI have been
// completed.
//
// This may occasionally be necessary, since UIManager updates the UI in an idle
// function. A typical example where this function is useful is to enforce that
// the menubar and toolbar have been added to the main window before showing it:
//
//    gtk_container_add (GTK_CONTAINER (window), vbox);
//    g_signal_connect (merge, "add-widget",
//                      G_CALLBACK (add_widget), vbox);
//    gtk_ui_manager_add_ui_from_file (merge, "my-menus");
//    gtk_ui_manager_add_ui_from_file (merge, "my-toolbars");
//    gtk_ui_manager_ensure_update (merge);
//    gtk_widget_show (window);
func (m uiManager) EnsureUpdate() {
	var _arg0 *C.GtkUIManager // out

	_arg0 = (*C.GtkUIManager)(unsafe.Pointer(m.Native()))

	C.gtk_ui_manager_ensure_update(_arg0)
}

// AccelGroup returns the AccelGroup associated with @manager.
func (m uiManager) AccelGroup() AccelGroup {
	var _arg0 *C.GtkUIManager  // out
	var _cret *C.GtkAccelGroup // in

	_arg0 = (*C.GtkUIManager)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_ui_manager_get_accel_group(_arg0)

	var _accelGroup AccelGroup // out

	_accelGroup = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(AccelGroup)

	return _accelGroup
}

// Action looks up an action by following a path. See
// gtk_ui_manager_get_widget() for more information about paths.
func (m uiManager) Action(path string) Action {
	var _arg0 *C.GtkUIManager // out
	var _arg1 *C.gchar        // out
	var _cret *C.GtkAction    // in

	_arg0 = (*C.GtkUIManager)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_ui_manager_get_action(_arg0, _arg1)

	var _action Action // out

	_action = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Action)

	return _action
}

// AddTearoffs returns whether menus generated by this UIManager will have
// tearoff menu items.
func (m uiManager) AddTearoffs() bool {
	var _arg0 *C.GtkUIManager // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkUIManager)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_ui_manager_get_add_tearoffs(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Ui creates a [UI definition][XML-UI] of the merged UI.
func (m uiManager) Ui() string {
	var _arg0 *C.GtkUIManager // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GtkUIManager)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_ui_manager_get_ui(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Widget looks up a widget by following a path. The path consists of the names
// specified in the XML description of the UI. separated by “/”. Elements which
// don’t have a name or action attribute in the XML (e.g. <popup>) can be
// addressed by their XML element name (e.g. "popup"). The root element ("/ui")
// can be omitted in the path.
//
// Note that the widget found by following a path that ends in a <menu>; element
// is the menuitem to which the menu is attached, not the menu it manages.
//
// Also note that the widgets constructed by a ui manager are not tied to the
// lifecycle of the ui manager. If you add the widgets returned by this function
// to some container or explicitly ref them, they will survive the destruction
// of the ui manager.
func (m uiManager) Widget(path string) Widget {
	var _arg0 *C.GtkUIManager // out
	var _arg1 *C.gchar        // out
	var _cret *C.GtkWidget    // in

	_arg0 = (*C.GtkUIManager)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_ui_manager_get_widget(_arg0, _arg1)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// InsertActionGroup inserts an action group into the list of action groups
// associated with @manager. Actions in earlier groups hide actions with the
// same name in later groups.
//
// If @pos is larger than the number of action groups in @manager, or negative,
// @action_group will be inserted at the end of the internal list.
func (m uiManager) InsertActionGroup(actionGroup ActionGroup, pos int) {
	var _arg0 *C.GtkUIManager   // out
	var _arg1 *C.GtkActionGroup // out
	var _arg2 C.gint            // out

	_arg0 = (*C.GtkUIManager)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GtkActionGroup)(unsafe.Pointer(actionGroup.Native()))
	_arg2 = (C.gint)(pos)

	C.gtk_ui_manager_insert_action_group(_arg0, _arg1, _arg2)
}

// NewMergeID returns an unused merge id, suitable for use with
// gtk_ui_manager_add_ui().
func (m uiManager) NewMergeID() uint {
	var _arg0 *C.GtkUIManager // out
	var _cret C.guint         // in

	_arg0 = (*C.GtkUIManager)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_ui_manager_new_merge_id(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// RemoveActionGroup removes an action group from the list of action groups
// associated with @manager.
func (m uiManager) RemoveActionGroup(actionGroup ActionGroup) {
	var _arg0 *C.GtkUIManager   // out
	var _arg1 *C.GtkActionGroup // out

	_arg0 = (*C.GtkUIManager)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GtkActionGroup)(unsafe.Pointer(actionGroup.Native()))

	C.gtk_ui_manager_remove_action_group(_arg0, _arg1)
}

// RemoveUi unmerges the part of @manager's content identified by @merge_id.
func (m uiManager) RemoveUi(mergeId uint) {
	var _arg0 *C.GtkUIManager // out
	var _arg1 C.guint         // out

	_arg0 = (*C.GtkUIManager)(unsafe.Pointer(m.Native()))
	_arg1 = (C.guint)(mergeId)

	C.gtk_ui_manager_remove_ui(_arg0, _arg1)
}

// SetAddTearoffs sets the “add_tearoffs” property, which controls whether menus
// generated by this UIManager will have tearoff menu items.
//
// Note that this only affects regular menus. Generated popup menus never have
// tearoff menu items.
func (m uiManager) SetAddTearoffs(addTearoffs bool) {
	var _arg0 *C.GtkUIManager // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GtkUIManager)(unsafe.Pointer(m.Native()))
	if addTearoffs {
		_arg1 = C.TRUE
	}

	C.gtk_ui_manager_set_add_tearoffs(_arg0, _arg1)
}

// VBox: a VBox is a container that organizes child widgets into a single
// column.
//
// Use the Box packing interface to determine the arrangement, spacing, height,
// and alignment of VBox children.
//
// All children are allocated the same width.
//
// GtkVBox has been deprecated. You can use Box with a Orientable:orientation
// set to GTK_ORIENTATION_VERTICAL instead when calling gtk_box_new(), which is
// a very quick and easy change.
//
// If you have derived your own classes from GtkVBox, you can change the
// inheritance to derive directly from Box, and set the Orientable:orientation
// property to GTK_ORIENTATION_VERTICAL in your instance init function, with a
// call like:
//
//    gtk_orientable_set_orientation (GTK_ORIENTABLE (object),
//                                    GTK_ORIENTATION_VERTICAL);
//
// If you have a grid-like layout composed of nested boxes, and you don’t need
// first-child or last-child styling, the recommendation is to switch to Grid.
// For more information about migrating to Grid, see [Migrating from other
// containers to GtkGrid][gtk-migrating-GtkGrid].
type VBox interface {
	Box
	Buildable
	Orientable
}

// vBox implements the VBox class.
type vBox struct {
	Box
	Buildable
	Orientable
}

var _ VBox = (*vBox)(nil)

// WrapVBox wraps a GObject to the right type. It is
// primarily used internally.
func WrapVBox(obj *externglib.Object) VBox {
	return vBox{
		Box:        WrapBox(obj),
		Buildable:  WrapBuildable(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalVBox(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapVBox(obj), nil
}

// NewVBox creates a new VBox.
func NewVBox(homogeneous bool, spacing int) VBox {
	var _arg1 C.gboolean   // out
	var _arg2 C.gint       // out
	var _cret *C.GtkWidget // in

	if homogeneous {
		_arg1 = C.TRUE
	}
	_arg2 = (C.gint)(spacing)

	_cret = C.gtk_vbox_new(_arg1, _arg2)

	var _vBox VBox // out

	_vBox = WrapVBox(externglib.Take(unsafe.Pointer(_cret)))

	return _vBox
}

type VButtonBox interface {
	ButtonBox
	Buildable
	Orientable
}

// vButtonBox implements the VButtonBox class.
type vButtonBox struct {
	ButtonBox
	Buildable
	Orientable
}

var _ VButtonBox = (*vButtonBox)(nil)

// WrapVButtonBox wraps a GObject to the right type. It is
// primarily used internally.
func WrapVButtonBox(obj *externglib.Object) VButtonBox {
	return vButtonBox{
		ButtonBox:  WrapButtonBox(obj),
		Buildable:  WrapBuildable(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalVButtonBox(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapVButtonBox(obj), nil
}

// NewVButtonBox creates a new vertical button box.
func NewVButtonBox() VButtonBox {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_vbutton_box_new()

	var _vButtonBox VButtonBox // out

	_vButtonBox = WrapVButtonBox(externglib.Take(unsafe.Pointer(_cret)))

	return _vButtonBox
}

// VPaned: the VPaned widget is a container widget with two children arranged
// vertically. The division between the two panes is adjustable by the user by
// dragging a handle. See Paned for details.
//
// GtkVPaned has been deprecated, use Paned instead.
type VPaned interface {
	Paned
	Buildable
	Orientable
}

// vPaned implements the VPaned class.
type vPaned struct {
	Paned
	Buildable
	Orientable
}

var _ VPaned = (*vPaned)(nil)

// WrapVPaned wraps a GObject to the right type. It is
// primarily used internally.
func WrapVPaned(obj *externglib.Object) VPaned {
	return vPaned{
		Paned:      WrapPaned(obj),
		Buildable:  WrapBuildable(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalVPaned(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapVPaned(obj), nil
}

// NewVPaned: create a new VPaned
func NewVPaned() VPaned {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_vpaned_new()

	var _vPaned VPaned // out

	_vPaned = WrapVPaned(externglib.Take(unsafe.Pointer(_cret)))

	return _vPaned
}

// VScale: the VScale widget is used to allow the user to select a value using a
// vertical slider. To create one, use gtk_hscale_new_with_range().
//
// The position to show the current value, and the number of decimal places
// shown can be set using the parent Scale class’s functions.
//
// GtkVScale has been deprecated, use Scale instead.
type VScale interface {
	Scale
	Buildable
	Orientable
}

// vScale implements the VScale class.
type vScale struct {
	Scale
	Buildable
	Orientable
}

var _ VScale = (*vScale)(nil)

// WrapVScale wraps a GObject to the right type. It is
// primarily used internally.
func WrapVScale(obj *externglib.Object) VScale {
	return vScale{
		Scale:      WrapScale(obj),
		Buildable:  WrapBuildable(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalVScale(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapVScale(obj), nil
}

// NewVScale creates a new VScale.
func NewVScale(adjustment Adjustment) VScale {
	var _arg1 *C.GtkAdjustment // out
	var _cret *C.GtkWidget     // in

	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	_cret = C.gtk_vscale_new(_arg1)

	var _vScale VScale // out

	_vScale = WrapVScale(externglib.Take(unsafe.Pointer(_cret)))

	return _vScale
}

// NewVScaleWithRange creates a new vertical scale widget that lets the user
// input a number between @min and @max (including @min and @max) with the
// increment @step. @step must be nonzero; it’s the distance the slider moves
// when using the arrow keys to adjust the scale value.
//
// Note that the way in which the precision is derived works best if @step is a
// power of ten. If the resulting precision is not suitable for your needs, use
// gtk_scale_set_digits() to correct it.
func NewVScaleWithRange(min float64, max float64, step float64) VScale {
	var _arg1 C.gdouble    // out
	var _arg2 C.gdouble    // out
	var _arg3 C.gdouble    // out
	var _cret *C.GtkWidget // in

	_arg1 = (C.gdouble)(min)
	_arg2 = (C.gdouble)(max)
	_arg3 = (C.gdouble)(step)

	_cret = C.gtk_vscale_new_with_range(_arg1, _arg2, _arg3)

	var _vScale VScale // out

	_vScale = WrapVScale(externglib.Take(unsafe.Pointer(_cret)))

	return _vScale
}

// VScrollbar: the VScrollbar widget is a widget arranged vertically creating a
// scrollbar. See Scrollbar for details on scrollbars. Adjustment pointers may
// be added to handle the adjustment of the scrollbar or it may be left nil in
// which case one will be created for you. See Scrollbar for a description of
// what the fields in an adjustment represent for a scrollbar.
//
// GtkVScrollbar has been deprecated, use Scrollbar instead.
type VScrollbar interface {
	Scrollbar
	Buildable
	Orientable
}

// vScrollbar implements the VScrollbar class.
type vScrollbar struct {
	Scrollbar
	Buildable
	Orientable
}

var _ VScrollbar = (*vScrollbar)(nil)

// WrapVScrollbar wraps a GObject to the right type. It is
// primarily used internally.
func WrapVScrollbar(obj *externglib.Object) VScrollbar {
	return vScrollbar{
		Scrollbar:  WrapScrollbar(obj),
		Buildable:  WrapBuildable(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalVScrollbar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapVScrollbar(obj), nil
}

// NewVScrollbar creates a new vertical scrollbar.
func NewVScrollbar(adjustment Adjustment) VScrollbar {
	var _arg1 *C.GtkAdjustment // out
	var _cret *C.GtkWidget     // in

	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	_cret = C.gtk_vscrollbar_new(_arg1)

	var _vScrollbar VScrollbar // out

	_vScrollbar = WrapVScrollbar(externglib.Take(unsafe.Pointer(_cret)))

	return _vScrollbar
}

// VSeparator: the VSeparator widget is a vertical separator, used to group the
// widgets within a window. It displays a vertical line with a shadow to make it
// appear sunken into the interface.
//
// GtkVSeparator has been deprecated, use Separator instead.
type VSeparator interface {
	Separator
	Buildable
	Orientable
}

// vSeparator implements the VSeparator class.
type vSeparator struct {
	Separator
	Buildable
	Orientable
}

var _ VSeparator = (*vSeparator)(nil)

// WrapVSeparator wraps a GObject to the right type. It is
// primarily used internally.
func WrapVSeparator(obj *externglib.Object) VSeparator {
	return vSeparator{
		Separator:  WrapSeparator(obj),
		Buildable:  WrapBuildable(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalVSeparator(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapVSeparator(obj), nil
}

// NewVSeparator creates a new VSeparator.
func NewVSeparator() VSeparator {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_vseparator_new()

	var _vSeparator VSeparator // out

	_vSeparator = WrapVSeparator(externglib.Take(unsafe.Pointer(_cret)))

	return _vSeparator
}

// Viewport: the Viewport widget acts as an adaptor class, implementing
// scrollability for child widgets that lack their own scrolling capabilities.
// Use GtkViewport to scroll child widgets such as Grid, Box, and so on.
//
// If a widget has native scrolling abilities, such as TextView, TreeView or
// IconView, it can be added to a ScrolledWindow with gtk_container_add(). If a
// widget does not, you must first add the widget to a Viewport, then add the
// viewport to the scrolled window. gtk_container_add() does this automatically
// if a child that does not implement Scrollable is added to a ScrolledWindow,
// so you can ignore the presence of the viewport.
//
// The GtkViewport will start scrolling content only if allocated less than the
// child widget’s minimum size in a given orientation.
//
//
// CSS nodes
//
// GtkViewport has a single CSS node with name viewport.
type Viewport interface {
	Bin
	Buildable
	Scrollable

	// BinWindow gets the bin window of the Viewport.
	BinWindow() gdk.Window
	// HAdjustment returns the horizontal adjustment of the viewport.
	HAdjustment() Adjustment
	// ShadowType gets the shadow type of the Viewport. See
	// gtk_viewport_set_shadow_type().
	ShadowType() ShadowType
	// VAdjustment returns the vertical adjustment of the viewport.
	VAdjustment() Adjustment
	// ViewWindow gets the view window of the Viewport.
	ViewWindow() gdk.Window
	// SetHAdjustment sets the horizontal adjustment of the viewport.
	SetHAdjustment(adjustment Adjustment)
	// SetShadowType sets the shadow type of the viewport.
	SetShadowType(typ ShadowType)
	// SetVAdjustment sets the vertical adjustment of the viewport.
	SetVAdjustment(adjustment Adjustment)
}

// viewport implements the Viewport class.
type viewport struct {
	Bin
	Buildable
	Scrollable
}

var _ Viewport = (*viewport)(nil)

// WrapViewport wraps a GObject to the right type. It is
// primarily used internally.
func WrapViewport(obj *externglib.Object) Viewport {
	return viewport{
		Bin:        WrapBin(obj),
		Buildable:  WrapBuildable(obj),
		Scrollable: WrapScrollable(obj),
	}
}

func marshalViewport(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapViewport(obj), nil
}

// NewViewport creates a new Viewport with the given adjustments, or with
// default adjustments if none are given.
func NewViewport(hadjustment Adjustment, vadjustment Adjustment) Viewport {
	var _arg1 *C.GtkAdjustment // out
	var _arg2 *C.GtkAdjustment // out
	var _cret *C.GtkWidget     // in

	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(hadjustment.Native()))
	_arg2 = (*C.GtkAdjustment)(unsafe.Pointer(vadjustment.Native()))

	_cret = C.gtk_viewport_new(_arg1, _arg2)

	var _viewport Viewport // out

	_viewport = WrapViewport(externglib.Take(unsafe.Pointer(_cret)))

	return _viewport
}

// BinWindow gets the bin window of the Viewport.
func (v viewport) BinWindow() gdk.Window {
	var _arg0 *C.GtkViewport // out
	var _cret *C.GdkWindow   // in

	_arg0 = (*C.GtkViewport)(unsafe.Pointer(v.Native()))

	_cret = C.gtk_viewport_get_bin_window(_arg0)

	var _window gdk.Window // out

	_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Window)

	return _window
}

// HAdjustment returns the horizontal adjustment of the viewport.
func (v viewport) HAdjustment() Adjustment {
	var _arg0 *C.GtkViewport   // out
	var _cret *C.GtkAdjustment // in

	_arg0 = (*C.GtkViewport)(unsafe.Pointer(v.Native()))

	_cret = C.gtk_viewport_get_hadjustment(_arg0)

	var _adjustment Adjustment // out

	_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

	return _adjustment
}

// ShadowType gets the shadow type of the Viewport. See
// gtk_viewport_set_shadow_type().
func (v viewport) ShadowType() ShadowType {
	var _arg0 *C.GtkViewport  // out
	var _cret C.GtkShadowType // in

	_arg0 = (*C.GtkViewport)(unsafe.Pointer(v.Native()))

	_cret = C.gtk_viewport_get_shadow_type(_arg0)

	var _shadowType ShadowType // out

	_shadowType = ShadowType(_cret)

	return _shadowType
}

// VAdjustment returns the vertical adjustment of the viewport.
func (v viewport) VAdjustment() Adjustment {
	var _arg0 *C.GtkViewport   // out
	var _cret *C.GtkAdjustment // in

	_arg0 = (*C.GtkViewport)(unsafe.Pointer(v.Native()))

	_cret = C.gtk_viewport_get_vadjustment(_arg0)

	var _adjustment Adjustment // out

	_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

	return _adjustment
}

// ViewWindow gets the view window of the Viewport.
func (v viewport) ViewWindow() gdk.Window {
	var _arg0 *C.GtkViewport // out
	var _cret *C.GdkWindow   // in

	_arg0 = (*C.GtkViewport)(unsafe.Pointer(v.Native()))

	_cret = C.gtk_viewport_get_view_window(_arg0)

	var _window gdk.Window // out

	_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Window)

	return _window
}

// SetHAdjustment sets the horizontal adjustment of the viewport.
func (v viewport) SetHAdjustment(adjustment Adjustment) {
	var _arg0 *C.GtkViewport   // out
	var _arg1 *C.GtkAdjustment // out

	_arg0 = (*C.GtkViewport)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	C.gtk_viewport_set_hadjustment(_arg0, _arg1)
}

// SetShadowType sets the shadow type of the viewport.
func (v viewport) SetShadowType(typ ShadowType) {
	var _arg0 *C.GtkViewport  // out
	var _arg1 C.GtkShadowType // out

	_arg0 = (*C.GtkViewport)(unsafe.Pointer(v.Native()))
	_arg1 = (C.GtkShadowType)(typ)

	C.gtk_viewport_set_shadow_type(_arg0, _arg1)
}

// SetVAdjustment sets the vertical adjustment of the viewport.
func (v viewport) SetVAdjustment(adjustment Adjustment) {
	var _arg0 *C.GtkViewport   // out
	var _arg1 *C.GtkAdjustment // out

	_arg0 = (*C.GtkViewport)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	C.gtk_viewport_set_vadjustment(_arg0, _arg1)
}

// VolumeButton is a subclass of ScaleButton that has been tailored for use as a
// volume control widget with suitable icons, tooltips and accessible labels.
type VolumeButton interface {
	ScaleButton
	Actionable
	Activatable
	Buildable
	Orientable
}

// volumeButton implements the VolumeButton class.
type volumeButton struct {
	ScaleButton
	Actionable
	Activatable
	Buildable
	Orientable
}

var _ VolumeButton = (*volumeButton)(nil)

// WrapVolumeButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapVolumeButton(obj *externglib.Object) VolumeButton {
	return volumeButton{
		ScaleButton: WrapScaleButton(obj),
		Actionable:  WrapActionable(obj),
		Activatable: WrapActivatable(obj),
		Buildable:   WrapBuildable(obj),
		Orientable:  WrapOrientable(obj),
	}
}

func marshalVolumeButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapVolumeButton(obj), nil
}

// NewVolumeButton creates a VolumeButton, with a range between 0.0 and 1.0,
// with a stepping of 0.02. Volume values can be obtained and modified using the
// functions from ScaleButton.
func NewVolumeButton() VolumeButton {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_volume_button_new()

	var _volumeButton VolumeButton // out

	_volumeButton = WrapVolumeButton(externglib.Take(unsafe.Pointer(_cret)))

	return _volumeButton
}

// Widget: gtkWidget is the base class all widgets in GTK+ derive from. It
// manages the widget lifecycle, states and style.
//
//
// Height-for-width Geometry Management
//
// GTK+ uses a height-for-width (and width-for-height) geometry management
// system. Height-for-width means that a widget can change how much vertical
// space it needs, depending on the amount of horizontal space that it is given
// (and similar for width-for-height). The most common example is a label that
// reflows to fill up the available width, wraps to fewer lines, and therefore
// needs less height.
//
// Height-for-width geometry management is implemented in GTK+ by way of five
// virtual methods:
//
// - WidgetClass.get_request_mode() - WidgetClass.get_preferred_width() -
// WidgetClass.get_preferred_height() -
// WidgetClass.get_preferred_height_for_width() -
// WidgetClass.get_preferred_width_for_height() -
// WidgetClass.get_preferred_height_and_baseline_for_width()
//
// There are some important things to keep in mind when implementing
// height-for-width and when using it in container implementations.
//
// The geometry management system will query a widget hierarchy in only one
// orientation at a time. When widgets are initially queried for their minimum
// sizes it is generally done in two initial passes in the SizeRequestMode
// chosen by the toplevel.
//
// For example, when queried in the normal GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH
// mode: First, the default minimum and natural width for each widget in the
// interface will be computed using gtk_widget_get_preferred_width(). Because
// the preferred widths for each container depend on the preferred widths of
// their children, this information propagates up the hierarchy, and finally a
// minimum and natural width is determined for the entire toplevel. Next, the
// toplevel will use the minimum width to query for the minimum height
// contextual to that width using gtk_widget_get_preferred_height_for_width(),
// which will also be a highly recursive operation. The minimum height for the
// minimum width is normally used to set the minimum size constraint on the
// toplevel (unless gtk_window_set_geometry_hints() is explicitly used instead).
//
// After the toplevel window has initially requested its size in both dimensions
// it can go on to allocate itself a reasonable size (or a size previously
// specified with gtk_window_set_default_size()). During the recursive
// allocation process it’s important to note that request cycles will be
// recursively executed while container widgets allocate their children. Each
// container widget, once allocated a size, will go on to first share the space
// in one orientation among its children and then request each child's height
// for its target allocated width or its width for allocated height, depending.
// In this way a Widget will typically be requested its size a number of times
// before actually being allocated a size. The size a widget is finally
// allocated can of course differ from the size it has requested. For this
// reason, Widget caches a small number of results to avoid re-querying for the
// same sizes in one allocation cycle.
//
// See [GtkContainer’s geometry management
// section][container-geometry-management] to learn more about how
// height-for-width allocations are performed by container widgets.
//
// If a widget does move content around to intelligently use up the allocated
// size then it must support the request in both SizeRequestModes even if the
// widget in question only trades sizes in a single orientation.
//
// For instance, a Label that does height-for-width word wrapping will not
// expect to have WidgetClass.get_preferred_height() called because that call is
// specific to a width-for-height request. In this case the label must return
// the height required for its own minimum possible width. By following this
// rule any widget that handles height-for-width or width-for-height requests
// will always be allocated at least enough space to fit its own content.
//
// Here are some examples of how a GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH widget
// generally deals with width-for-height requests, for
// WidgetClass.get_preferred_height() it will do:
//
//    // the signal handler has the instance and user data swapped
//    // because of the swapped="yes" attribute in the template XML
//    static void
//    hello_button_clicked (FooWidget *self,
//                          GtkButton *button)
//    {
//      g_print ("Hello, world!\n");
//    }
//
//    static void
//    foo_widget_class_init (FooWidgetClass *klass)
//    {
//      // ...
//      gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
//                                                   "/com/example/ui/foowidget.ui");
//      gtk_widget_class_bind_template_callback (GTK_WIDGET_CLASS (klass), hello_button_clicked);
//    }
type Widget interface {
	gextras.Objector
	Buildable

	// Activate: for widgets that can be “activated” (buttons, menu items, etc.)
	// this function activates them. Activation is what happens when you press
	// Enter on a widget during key navigation. If @widget isn't activatable,
	// the function returns false.
	Activate() bool
	// AddAccelerator installs an accelerator for this @widget in @accel_group
	// that causes @accel_signal to be emitted if the accelerator is activated.
	// The @accel_group needs to be added to the widget’s toplevel via
	// gtk_window_add_accel_group(), and the signal must be of type
	// G_SIGNAL_ACTION. Accelerators added through this function are not user
	// changeable during runtime. If you want to support accelerators that can
	// be changed by the user, use gtk_accel_map_add_entry() and
	// gtk_widget_set_accel_path() or gtk_menu_item_set_accel_path() instead.
	AddAccelerator(accelSignal string, accelGroup AccelGroup, accelKey uint, accelMods gdk.ModifierType, accelFlags AccelFlags)
	// AddDeviceEvents adds the device events in the bitfield @events to the
	// event mask for @widget. See gtk_widget_set_device_events() for details.
	AddDeviceEvents(device gdk.Device, events gdk.EventMask)
	// AddEvents adds the events in the bitfield @events to the event mask for
	// @widget. See gtk_widget_set_events() and the [input handling
	// overview][event-masks] for details.
	AddEvents(events int)
	// AddMnemonicLabel adds a widget to the list of mnemonic labels for this
	// widget. (See gtk_widget_list_mnemonic_labels()). Note the list of
	// mnemonic labels for the widget is cleared when the widget is destroyed,
	// so the caller must make sure to update its internal state at this point
	// as well, by using a connection to the Widget::destroy signal or a weak
	// notifier.
	AddMnemonicLabel(label Widget)
	// CanActivateAccel determines whether an accelerator that activates the
	// signal identified by @signal_id can currently be activated. This is done
	// by emitting the Widget::can-activate-accel signal on @widget; if the
	// signal isn’t overridden by a handler or in a derived widget, then the
	// default check is that the widget must be sensitive, and the widget and
	// all its ancestors mapped.
	CanActivateAccel(signalId uint) bool
	// ChildFocus: this function is used by custom widget implementations; if
	// you're writing an app, you’d use gtk_widget_grab_focus() to move the
	// focus to a particular widget, and gtk_container_set_focus_chain() to
	// change the focus tab order. So you may want to investigate those
	// functions instead.
	//
	// gtk_widget_child_focus() is called by containers as the user moves around
	// the window using keyboard shortcuts. @direction indicates what kind of
	// motion is taking place (up, down, left, right, tab forward, tab
	// backward). gtk_widget_child_focus() emits the Widget::focus signal;
	// widgets override the default handler for this signal in order to
	// implement appropriate focus behavior.
	//
	// The default ::focus handler for a widget should return true if moving in
	// @direction left the focus on a focusable location inside that widget, and
	// false if moving in @direction moved the focus outside the widget. If
	// returning true, widgets normally call gtk_widget_grab_focus() to place
	// the focus accordingly; if returning false, they don’t modify the current
	// focus location.
	ChildFocus(direction DirectionType) bool
	// ChildNotify emits a Widget::child-notify signal for the [child
	// property][child-properties] @child_property on @widget.
	//
	// This is the analogue of g_object_notify() for child properties.
	//
	// Also see gtk_container_child_notify().
	ChildNotify(childProperty string)
	// ClassPath: same as gtk_widget_path(), but always uses the name of a
	// widget’s type, never uses a custom name set with gtk_widget_set_name().
	ClassPath() (pathLength uint, path string, pathReversed string)
	// ComputeExpand computes whether a container should give this widget extra
	// space when possible. Containers should check this, rather than looking at
	// gtk_widget_get_hexpand() or gtk_widget_get_vexpand().
	//
	// This function already checks whether the widget is visible, so visibility
	// does not need to be checked separately. Non-visible widgets are not
	// expanded.
	//
	// The computed expand value uses either the expand setting explicitly set
	// on the widget itself, or, if none has been explicitly set, the widget may
	// expand if some of its children do.
	ComputeExpand(orientation Orientation) bool
	// CreatePangoContext creates a new Context with the appropriate font map,
	// font options, font description, and base direction for drawing text for
	// this widget. See also gtk_widget_get_pango_context().
	CreatePangoContext() pango.Context
	// CreatePangoLayout creates a new Layout with the appropriate font map,
	// font description, and base direction for drawing text for this widget.
	//
	// If you keep a Layout created in this way around, you need to re-create it
	// when the widget Context is replaced. This can be tracked by using the
	// Widget::screen-changed signal on the widget.
	CreatePangoLayout(text string) pango.Layout
	// Destroy destroys a widget.
	//
	// When a widget is destroyed all references it holds on other objects will
	// be released:
	//
	//    - if the widget is inside a container, it will be removed from its
	//    parent
	//    - if the widget is a container, all its children will be destroyed,
	//    recursively
	//    - if the widget is a top level, it will be removed from the list
	//    of top level widgets that GTK+ maintains internally
	//
	// It's expected that all references held on the widget will also be
	// released; you should connect to the Widget::destroy signal if you hold a
	// reference to @widget and you wish to remove it when this function is
	// called. It is not necessary to do so if you are implementing a Container,
	// as you'll be able to use the ContainerClass.remove() virtual function for
	// that.
	//
	// It's important to notice that gtk_widget_destroy() will only cause the
	// @widget to be finalized if no additional references, acquired using
	// g_object_ref(), are held on it. In case additional references are in
	// place, the @widget will be in an "inert" state after calling this
	// function; @widget will still point to valid memory, allowing you to
	// release the references you hold, but you may not query the widget's own
	// state.
	//
	// You should typically call this function on top level widgets, and rarely
	// on child widgets.
	//
	// See also: gtk_container_remove()
	Destroy()
	// DeviceIsShadowed returns true if @device has been shadowed by a GTK+
	// device grab on another widget, so it would stop sending events to
	// @widget. This may be used in the Widget::grab-notify signal to check for
	// specific devices. See gtk_device_grab_add().
	DeviceIsShadowed(device gdk.Device) bool
	// DragCheckThreshold checks to see if a mouse drag starting at (@start_x,
	// @start_y) and ending at (@current_x, @current_y) has passed the GTK+ drag
	// threshold, and thus should trigger the beginning of a drag-and-drop
	// operation.
	DragCheckThreshold(startX int, startY int, currentX int, currentY int) bool
	// DragDestAddImageTargets: add the image targets supported by SelectionData
	// to the target list of the drag destination. The targets are added with
	// @info = 0. If you need another value, use
	// gtk_target_list_add_image_targets() and gtk_drag_dest_set_target_list().
	DragDestAddImageTargets()
	// DragDestAddTextTargets: add the text targets supported by SelectionData
	// to the target list of the drag destination. The targets are added with
	// @info = 0. If you need another value, use
	// gtk_target_list_add_text_targets() and gtk_drag_dest_set_target_list().
	DragDestAddTextTargets()
	// DragDestAddURITargets: add the URI targets supported by SelectionData to
	// the target list of the drag destination. The targets are added with @info
	// = 0. If you need another value, use gtk_target_list_add_uri_targets() and
	// gtk_drag_dest_set_target_list().
	DragDestAddURITargets()
	// DragDestFindTarget looks for a match between the supported targets of
	// @context and the @dest_target_list, returning the first matching target,
	// otherwise returning GDK_NONE. @dest_target_list should usually be the
	// return value from gtk_drag_dest_get_target_list(), but some widgets may
	// have different valid targets for different parts of the widget; in that
	// case, they will have to implement a drag_motion handler that passes the
	// correct target list to this function.
	DragDestFindTarget(context gdk.DragContext, targetList *TargetList) *gdk.Atom
	// DragDestGetTargetList returns the list of targets this widget can accept
	// from drag-and-drop.
	DragDestGetTargetList() *TargetList
	// DragDestGetTrackMotion returns whether the widget has been configured to
	// always emit Widget::drag-motion signals.
	DragDestGetTrackMotion() bool
	// DragDestSet sets a widget as a potential drop destination, and adds
	// default behaviors.
	//
	// The default behaviors listed in @flags have an effect similar to
	// installing default handlers for the widget’s drag-and-drop signals
	// (Widget::drag-motion, Widget::drag-drop, ...). They all exist for
	// convenience. When passing K_DEST_DEFAULT_ALL for instance it is
	// sufficient to connect to the widget’s Widget::drag-data-received signal
	// to get primitive, but consistent drag-and-drop support.
	//
	// Things become more complicated when you try to preview the dragged data,
	// as described in the documentation for Widget::drag-motion. The default
	// behaviors described by @flags make some assumptions, that can conflict
	// with your own signal handlers. For instance K_DEST_DEFAULT_DROP causes
	// invokations of gdk_drag_status() in the context of Widget::drag-motion,
	// and invokations of gtk_drag_finish() in Widget::drag-data-received.
	// Especially the later is dramatic, when your own Widget::drag-motion
	// handler calls gtk_drag_get_data() to inspect the dragged data.
	//
	// There’s no way to set a default action here, you can use the
	// Widget::drag-motion callback for that. Here’s an example which selects
	// the action to use depending on whether the control key is pressed or not:
	//
	//    static void
	//    drag_motion (GtkWidget *widget,
	//                 GdkDragContext *context,
	//                 gint x,
	//                 gint y,
	//                 guint time)
	//    {
	//      GdkModifierType mask;
	//
	//      gdk_window_get_pointer (gtk_widget_get_window (widget),
	//                              NULL, NULL, &mask);
	//      if (mask & GDK_CONTROL_MASK)
	//        gdk_drag_status (context, GDK_ACTION_COPY, time);
	//      else
	//        gdk_drag_status (context, GDK_ACTION_MOVE, time);
	//    }
	DragDestSet(flags DestDefaults, targets []TargetEntry, actions gdk.DragAction)
	// DragDestSetProXY sets this widget as a proxy for drops to another window.
	DragDestSetProXY(proxyWindow gdk.Window, protocol gdk.DragProtocol, useCoordinates bool)
	// DragDestSetTargetList sets the target types that this widget can accept
	// from drag-and-drop. The widget must first be made into a drag destination
	// with gtk_drag_dest_set().
	DragDestSetTargetList(targetList *TargetList)
	// DragDestSetTrackMotion tells the widget to emit Widget::drag-motion and
	// Widget::drag-leave events regardless of the targets and the
	// GTK_DEST_DEFAULT_MOTION flag.
	//
	// This may be used when a widget wants to do generic actions regardless of
	// the targets that the source offers.
	DragDestSetTrackMotion(trackMotion bool)
	// DragDestUnset clears information about a drop destination set with
	// gtk_drag_dest_set(). The widget will no longer receive notification of
	// drags.
	DragDestUnset()
	// DragGetData gets the data associated with a drag. When the data is
	// received or the retrieval fails, GTK+ will emit a
	// Widget::drag-data-received signal. Failure of the retrieval is indicated
	// by the length field of the @selection_data signal parameter being
	// negative. However, when gtk_drag_get_data() is called implicitely because
	// the GTK_DEST_DEFAULT_DROP was set, then the widget will not receive
	// notification of failed drops.
	DragGetData(context gdk.DragContext, target *gdk.Atom, time_ uint32)
	// DragHighlight highlights a widget as a currently hovered drop target. To
	// end the highlight, call gtk_drag_unhighlight(). GTK+ calls this
	// automatically if GTK_DEST_DEFAULT_HIGHLIGHT is set.
	DragHighlight()
	// DragSourceAddImageTargets: add the writable image targets supported by
	// SelectionData to the target list of the drag source. The targets are
	// added with @info = 0. If you need another value, use
	// gtk_target_list_add_image_targets() and
	// gtk_drag_source_set_target_list().
	DragSourceAddImageTargets()
	// DragSourceAddTextTargets: add the text targets supported by SelectionData
	// to the target list of the drag source. The targets are added with @info =
	// 0. If you need another value, use gtk_target_list_add_text_targets() and
	// gtk_drag_source_set_target_list().
	DragSourceAddTextTargets()
	// DragSourceAddURITargets: add the URI targets supported by SelectionData
	// to the target list of the drag source. The targets are added with @info =
	// 0. If you need another value, use gtk_target_list_add_uri_targets() and
	// gtk_drag_source_set_target_list().
	DragSourceAddURITargets()
	// DragSourceGetTargetList gets the list of targets this widget can provide
	// for drag-and-drop.
	DragSourceGetTargetList() *TargetList
	// DragSourceSet sets up a widget so that GTK+ will start a drag operation
	// when the user clicks and drags on the widget. The widget must have a
	// window.
	DragSourceSet(startButtonMask gdk.ModifierType, targets []TargetEntry, actions gdk.DragAction)
	// DragSourceSetIconGIcon sets the icon that will be used for drags from a
	// particular source to @icon. See the docs for IconTheme for more details.
	DragSourceSetIconGIcon(icon gio.Icon)
	// DragSourceSetIconName sets the icon that will be used for drags from a
	// particular source to a themed icon. See the docs for IconTheme for more
	// details.
	DragSourceSetIconName(iconName string)
	// DragSourceSetIconPixbuf sets the icon that will be used for drags from a
	// particular widget from a Pixbuf. GTK+ retains a reference for @pixbuf and
	// will release it when it is no longer needed.
	DragSourceSetIconPixbuf(pixbuf gdkpixbuf.Pixbuf)
	// DragSourceSetIconStock sets the icon that will be used for drags from a
	// particular source to a stock icon.
	DragSourceSetIconStock(stockId string)
	// DragSourceSetTargetList changes the target types that this widget offers
	// for drag-and-drop. The widget must first be made into a drag source with
	// gtk_drag_source_set().
	DragSourceSetTargetList(targetList *TargetList)
	// DragSourceUnset undoes the effects of gtk_drag_source_set().
	DragSourceUnset()
	// DragUnhighlight removes a highlight set by gtk_drag_highlight() from a
	// widget.
	DragUnhighlight()
	// Draw draws @widget to @cr. The top left corner of the widget will be
	// drawn to the currently set origin point of @cr.
	//
	// You should pass a cairo context as @cr argument that is in an original
	// state. Otherwise the resulting drawing is undefined. For example changing
	// the operator using cairo_set_operator() or the line width using
	// cairo_set_line_width() might have unwanted side effects. You may however
	// change the context’s transform matrix - like with cairo_scale(),
	// cairo_translate() or cairo_set_matrix() and clip region with cairo_clip()
	// prior to calling this function. Also, it is fine to modify the context
	// with cairo_save() and cairo_push_group() prior to calling this function.
	//
	// Note that special-purpose widgets may contain special code for rendering
	// to the screen and might appear differently on screen and when rendered
	// using gtk_widget_draw().
	Draw(cr *cairo.Context)
	// EnsureStyle ensures that @widget has a style (@widget->style).
	//
	// Not a very useful function; most of the time, if you want the style, the
	// widget is realized, and realized widgets are guaranteed to have a style
	// already.
	EnsureStyle()
	// ErrorBell notifies the user about an input-related error on this widget.
	// If the Settings:gtk-error-bell setting is true, it calls
	// gdk_window_beep(), otherwise it does nothing.
	//
	// Note that the effect of gdk_window_beep() can be configured in many ways,
	// depending on the windowing backend and the desktop environment or window
	// manager that is used.
	ErrorBell()
	// FreezeChildNotify stops emission of Widget::child-notify signals on
	// @widget. The signals are queued until gtk_widget_thaw_child_notify() is
	// called on @widget.
	//
	// This is the analogue of g_object_freeze_notify() for child properties.
	FreezeChildNotify()
	// ActionGroup retrieves the Group that was registered using @prefix. The
	// resulting Group may have been registered to @widget or any Widget in its
	// ancestry.
	//
	// If no action group was found matching @prefix, then nil is returned.
	ActionGroup(prefix string) gio.ActionGroup
	// AllocatedBaseline returns the baseline that has currently been allocated
	// to @widget. This function is intended to be used when implementing
	// handlers for the Widget::draw function, and when allocating child widgets
	// in Widget::size_allocate.
	AllocatedBaseline() int
	// AllocatedHeight returns the height that has currently been allocated to
	// @widget. This function is intended to be used when implementing handlers
	// for the Widget::draw function.
	AllocatedHeight() int
	// AllocatedWidth returns the width that has currently been allocated to
	// @widget. This function is intended to be used when implementing handlers
	// for the Widget::draw function.
	AllocatedWidth() int
	// Ancestor gets the first ancestor of @widget with type @widget_type. For
	// example, `gtk_widget_get_ancestor (widget, GTK_TYPE_BOX)` gets the first
	// Box that’s an ancestor of @widget. No reference will be added to the
	// returned widget; it should not be unreferenced. See note about checking
	// for a toplevel Window in the docs for gtk_widget_get_toplevel().
	//
	// Note that unlike gtk_widget_is_ancestor(), gtk_widget_get_ancestor()
	// considers @widget to be an ancestor of itself.
	Ancestor(widgetType externglib.Type) Widget
	// AppPaintable determines whether the application intends to draw on the
	// widget in an Widget::draw handler.
	//
	// See gtk_widget_set_app_paintable()
	AppPaintable() bool
	// CanDefault determines whether @widget can be a default widget. See
	// gtk_widget_set_can_default().
	CanDefault() bool
	// CanFocus determines whether @widget can own the input focus. See
	// gtk_widget_set_can_focus().
	CanFocus() bool
	// ChildRequisition: this function is only for use in widget
	// implementations. Obtains @widget->requisition, unless someone has forced
	// a particular geometry on the widget (e.g. with
	// gtk_widget_set_size_request()), in which case it returns that geometry
	// instead of the widget's requisition.
	//
	// This function differs from gtk_widget_size_request() in that it retrieves
	// the last size request value from @widget->requisition, while
	// gtk_widget_size_request() actually calls the "size_request" method on
	// @widget to compute the size request and fill in @widget->requisition, and
	// only then returns @widget->requisition.
	//
	// Because this function does not call the “size_request” method, it can
	// only be used when you know that @widget->requisition is up-to-date, that
	// is, gtk_widget_size_request() has been called since the last time a
	// resize was queued. In general, only container implementations have this
	// information; applications should use gtk_widget_size_request().
	ChildRequisition() Requisition
	// ChildVisible gets the value set with gtk_widget_set_child_visible(). If
	// you feel a need to use this function, your code probably needs
	// reorganization.
	//
	// This function is only useful for container implementations and never
	// should be called by an application.
	ChildVisible() bool
	// Clipboard returns the clipboard object for the given selection to be used
	// with @widget. @widget must have a Display associated with it, so must be
	// attached to a toplevel window.
	Clipboard(selection *gdk.Atom) Clipboard
	// CompositeName obtains the composite name of a widget.
	CompositeName() string
	// DeviceEnabled returns whether @device can interact with @widget and its
	// children. See gtk_widget_set_device_enabled().
	DeviceEnabled(device gdk.Device) bool
	// DeviceEvents returns the events mask for the widget corresponding to an
	// specific device. These are the events that the widget will receive when
	// @device operates on it.
	DeviceEvents(device gdk.Device) gdk.EventMask
	// Direction gets the reading direction for a particular widget. See
	// gtk_widget_set_direction().
	Direction() TextDirection
	// Display: get the Display for the toplevel window associated with this
	// widget. This function can only be called after the widget has been added
	// to a widget hierarchy with a Window at the top.
	//
	// In general, you should only create display specific resources when a
	// widget has been realized, and you should free those resources when the
	// widget is unrealized.
	Display() gdk.Display
	// DoubleBuffered determines whether the widget is double buffered.
	//
	// See gtk_widget_set_double_buffered()
	DoubleBuffered() bool
	// Events returns the event mask (see EventMask) for the widget. These are
	// the events that the widget will receive.
	//
	// Note: Internally, the widget event mask will be the logical OR of the
	// event mask set through gtk_widget_set_events() or
	// gtk_widget_add_events(), and the event mask necessary to cater for every
	// EventController created for the widget.
	Events() int
	// FocusOnClick returns whether the widget should grab focus when it is
	// clicked with the mouse. See gtk_widget_set_focus_on_click().
	FocusOnClick() bool
	// FontMap gets the font map that has been set with
	// gtk_widget_set_font_map().
	FontMap() pango.FontMap
	// FontOptions returns the #cairo_font_options_t used for Pango rendering.
	// When not set, the defaults font options for the Screen will be used.
	FontOptions() *cairo.FontOptions
	// FrameClock obtains the frame clock for a widget. The frame clock is a
	// global “ticker” that can be used to drive animations and repaints. The
	// most common reason to get the frame clock is to call
	// gdk_frame_clock_get_frame_time(), in order to get a time to use for
	// animating. For example you might record the start of the animation with
	// an initial value from gdk_frame_clock_get_frame_time(), and then update
	// the animation by calling gdk_frame_clock_get_frame_time() again during
	// each repaint.
	//
	// gdk_frame_clock_request_phase() will result in a new frame on the clock,
	// but won’t necessarily repaint any widgets. To repaint a widget, you have
	// to use gtk_widget_queue_draw() which invalidates the widget (thus
	// scheduling it to receive a draw on the next frame).
	// gtk_widget_queue_draw() will also end up requesting a frame on the
	// appropriate frame clock.
	//
	// A widget’s frame clock will not change while the widget is mapped.
	// Reparenting a widget (which implies a temporary unmap) can change the
	// widget’s frame clock.
	//
	// Unrealized widgets do not have a frame clock.
	FrameClock() gdk.FrameClock
	// Halign gets the value of the Widget:halign property.
	//
	// For backwards compatibility reasons this method will never return
	// GTK_ALIGN_BASELINE, but instead it will convert it to GTK_ALIGN_FILL.
	// Baselines are not supported for horizontal alignment.
	Halign() Align
	// HasTooltip returns the current value of the has-tooltip property. See
	// Widget:has-tooltip for more information.
	HasTooltip() bool
	// HasWindow determines whether @widget has a Window of its own. See
	// gtk_widget_set_has_window().
	HasWindow() bool
	// Hexpand gets whether the widget would like any available extra horizontal
	// space. When a user resizes a Window, widgets with expand=TRUE generally
	// receive the extra space. For example, a list or scrollable area or
	// document in your window would often be set to expand.
	//
	// Containers should use gtk_widget_compute_expand() rather than this
	// function, to see whether a widget, or any of its children, has the expand
	// flag set. If any child of a widget wants to expand, the parent may ask to
	// expand also.
	//
	// This function only looks at the widget’s own hexpand flag, rather than
	// computing whether the entire widget tree rooted at this widget wants to
	// expand.
	Hexpand() bool
	// HexpandSet gets whether gtk_widget_set_hexpand() has been used to
	// explicitly set the expand flag on this widget.
	//
	// If hexpand is set, then it overrides any computed expand value based on
	// child widgets. If hexpand is not set, then the expand value depends on
	// whether any children of the widget would like to expand.
	//
	// There are few reasons to use this function, but it’s here for
	// completeness and consistency.
	HexpandSet() bool
	// Mapped: whether the widget is mapped.
	Mapped() bool
	// MarginBottom gets the value of the Widget:margin-bottom property.
	MarginBottom() int
	// MarginEnd gets the value of the Widget:margin-end property.
	MarginEnd() int
	// MarginLeft gets the value of the Widget:margin-left property.
	MarginLeft() int
	// MarginRight gets the value of the Widget:margin-right property.
	MarginRight() int
	// MarginStart gets the value of the Widget:margin-start property.
	MarginStart() int
	// MarginTop gets the value of the Widget:margin-top property.
	MarginTop() int
	// ModifierMask returns the modifier mask the @widget’s windowing system
	// backend uses for a particular purpose.
	//
	// See gdk_keymap_get_modifier_mask().
	ModifierMask(intent gdk.ModifierIntent) gdk.ModifierType
	// ModifierStyle returns the current modifier style for the widget. (As set
	// by gtk_widget_modify_style().) If no style has previously set, a new
	// RcStyle will be created with all values unset, and set as the modifier
	// style for the widget. If you make changes to this rc style, you must call
	// gtk_widget_modify_style(), passing in the returned rc style, to make sure
	// that your changes take effect.
	//
	// Caution: passing the style back to gtk_widget_modify_style() will
	// normally end up destroying it, because gtk_widget_modify_style() copies
	// the passed-in style and sets the copy as the new modifier style, thus
	// dropping any reference to the old modifier style. Add a reference to the
	// modifier style if you want to keep it alive.
	ModifierStyle() RCStyle
	// Name retrieves the name of a widget. See gtk_widget_set_name() for the
	// significance of widget names.
	Name() string
	// NoShowAll returns the current value of the Widget:no-show-all property,
	// which determines whether calls to gtk_widget_show_all() will affect this
	// widget.
	NoShowAll() bool
	// Opacity fetches the requested opacity for this widget. See
	// gtk_widget_set_opacity().
	Opacity() float64
	// PangoContext gets a Context with the appropriate font map, font
	// description, and base direction for this widget. Unlike the context
	// returned by gtk_widget_create_pango_context(), this context is owned by
	// the widget (it can be used until the screen for the widget changes or the
	// widget is removed from its toplevel), and will be updated to match any
	// changes to the widget’s attributes. This can be tracked by using the
	// Widget::screen-changed signal on the widget.
	PangoContext() pango.Context
	// Parent returns the parent container of @widget.
	Parent() Widget
	// ParentWindow gets @widget’s parent window, or nil if it does not have
	// one.
	ParentWindow() gdk.Window
	// GetPath returns the WidgetPath representing @widget, if the widget is not
	// connected to a toplevel widget, a partial path will be created.
	GetPath() *WidgetPath
	// Pointer obtains the location of the mouse pointer in widget coordinates.
	// Widget coordinates are a bit odd; for historical reasons, they are
	// defined as @widget->window coordinates for widgets that return true for
	// gtk_widget_get_has_window(); and are relative to @widget->allocation.x,
	// @widget->allocation.y otherwise.
	Pointer() (x int, y int)
	// PreferredHeight retrieves a widget’s initial minimum and natural height.
	//
	// This call is specific to width-for-height requests.
	//
	// The returned request will be modified by the
	// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups
	// that have been applied. That is, the returned request is the one that
	// should be used for layout, not necessarily the one returned by the widget
	// itself.
	PreferredHeight() (minimumHeight int, naturalHeight int)
	// PreferredHeightAndBaselineForWidth retrieves a widget’s minimum and
	// natural height and the corresponding baselines if it would be given the
	// specified @width, or the default height if @width is -1. The baselines
	// may be -1 which means that no baseline is requested for this widget.
	//
	// The returned request will be modified by the
	// GtkWidgetClass::adjust_size_request and
	// GtkWidgetClass::adjust_baseline_request virtual methods and by any
	// SizeGroups that have been applied. That is, the returned request is the
	// one that should be used for layout, not necessarily the one returned by
	// the widget itself.
	PreferredHeightAndBaselineForWidth(width int) (minimumHeight int, naturalHeight int, minimumBaseline int, naturalBaseline int)
	// PreferredHeightForWidth retrieves a widget’s minimum and natural height
	// if it would be given the specified @width.
	//
	// The returned request will be modified by the
	// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups
	// that have been applied. That is, the returned request is the one that
	// should be used for layout, not necessarily the one returned by the widget
	// itself.
	PreferredHeightForWidth(width int) (minimumHeight int, naturalHeight int)
	// PreferredSize retrieves the minimum and natural size of a widget, taking
	// into account the widget’s preference for height-for-width management.
	//
	// This is used to retrieve a suitable size by container widgets which do
	// not impose any restrictions on the child placement. It can be used to
	// deduce toplevel window and menu sizes as well as child widgets in
	// free-form containers such as GtkLayout.
	//
	// Handle with care. Note that the natural height of a height-for-width
	// widget will generally be a smaller size than the minimum height, since
	// the required height for the natural width is generally smaller than the
	// required height for the minimum width.
	//
	// Use gtk_widget_get_preferred_height_and_baseline_for_width() if you want
	// to support baseline alignment.
	PreferredSize() (minimumSize Requisition, naturalSize Requisition)
	// PreferredWidth retrieves a widget’s initial minimum and natural width.
	//
	// This call is specific to height-for-width requests.
	//
	// The returned request will be modified by the
	// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups
	// that have been applied. That is, the returned request is the one that
	// should be used for layout, not necessarily the one returned by the widget
	// itself.
	PreferredWidth() (minimumWidth int, naturalWidth int)
	// PreferredWidthForHeight retrieves a widget’s minimum and natural width if
	// it would be given the specified @height.
	//
	// The returned request will be modified by the
	// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups
	// that have been applied. That is, the returned request is the one that
	// should be used for layout, not necessarily the one returned by the widget
	// itself.
	PreferredWidthForHeight(height int) (minimumWidth int, naturalWidth int)
	// Realized determines whether @widget is realized.
	Realized() bool
	// ReceivesDefault determines whether @widget is always treated as the
	// default widget within its toplevel when it has the focus, even if another
	// widget is the default.
	//
	// See gtk_widget_set_receives_default().
	ReceivesDefault() bool
	// RequestMode gets whether the widget prefers a height-for-width layout or
	// a width-for-height layout.
	//
	// Bin widgets generally propagate the preference of their child, container
	// widgets need to request something either in context of their children or
	// in context of their allocation capabilities.
	RequestMode() SizeRequestMode
	// Requisition retrieves the widget’s requisition.
	//
	// This function should only be used by widget implementations in order to
	// figure whether the widget’s requisition has actually changed after some
	// internal state change (so that they can call gtk_widget_queue_resize()
	// instead of gtk_widget_queue_draw()).
	//
	// Normally, gtk_widget_size_request() should be used.
	Requisition() Requisition
	// RootWindow: get the root window where this widget is located. This
	// function can only be called after the widget has been added to a widget
	// hierarchy with Window at the top.
	//
	// The root window is useful for such purposes as creating a popup Window
	// associated with the window. In general, you should only create display
	// specific resources when a widget has been realized, and you should free
	// those resources when the widget is unrealized.
	RootWindow() gdk.Window
	// ScaleFactor retrieves the internal scale factor that maps from window
	// coordinates to the actual device pixels. On traditional systems this is
	// 1, on high density outputs, it can be a higher value (typically 2).
	//
	// See gdk_window_get_scale_factor().
	ScaleFactor() int
	// Screen: get the Screen from the toplevel window associated with this
	// widget. This function can only be called after the widget has been added
	// to a widget hierarchy with a Window at the top.
	//
	// In general, you should only create screen specific resources when a
	// widget has been realized, and you should free those resources when the
	// widget is unrealized.
	Screen() gdk.Screen
	// Sensitive returns the widget’s sensitivity (in the sense of returning the
	// value that has been set using gtk_widget_set_sensitive()).
	//
	// The effective sensitivity of a widget is however determined by both its
	// own and its parent widget’s sensitivity. See gtk_widget_is_sensitive().
	Sensitive() bool
	// Settings gets the settings object holding the settings used for this
	// widget.
	//
	// Note that this function can only be called when the Widget is attached to
	// a toplevel, since the settings object is specific to a particular Screen.
	Settings() Settings
	// GetSizeRequest gets the size request that was explicitly set for the
	// widget using gtk_widget_set_size_request(). A value of -1 stored in
	// @width or @height indicates that that dimension has not been set
	// explicitly and the natural requisition of the widget will be used
	// instead. See gtk_widget_set_size_request(). To get the size a widget will
	// actually request, call gtk_widget_get_preferred_size() instead of this
	// function.
	GetSizeRequest() (width int, height int)
	// State returns the widget’s state. See gtk_widget_set_state().
	State() StateType
	// StateFlags returns the widget state as a flag set. It is worth mentioning
	// that the effective GTK_STATE_FLAG_INSENSITIVE state will be returned,
	// that is, also based on parent insensitivity, even if @widget itself is
	// sensitive.
	//
	// Also note that if you are looking for a way to obtain the StateFlags to
	// pass to a StyleContext method, you should look at
	// gtk_style_context_get_state().
	StateFlags() StateFlags
	// Style: simply an accessor function that returns @widget->style.
	Style() Style
	// StyleContext returns the style context associated to @widget. The
	// returned object is guaranteed to be the same for the lifetime of @widget.
	StyleContext() StyleContext
	// SupportMultidevice returns true if @widget is multiple pointer aware. See
	// gtk_widget_set_support_multidevice() for more information.
	SupportMultidevice() bool
	// TemplateChild: fetch an object build from the template XML for
	// @widget_type in this @widget instance.
	//
	// This will only report children which were previously declared with
	// gtk_widget_class_bind_template_child_full() or one of its variants.
	//
	// This function is only meant to be called for code which is private to the
	// @widget_type which declared the child and is meant for language bindings
	// which cannot easily make use of the GObject structure offsets.
	TemplateChild(widgetType externglib.Type, name string) gextras.Objector
	// TooltipMarkup gets the contents of the tooltip for @widget.
	TooltipMarkup() string
	// TooltipText gets the contents of the tooltip for @widget.
	TooltipText() string
	// TooltipWindow returns the Window of the current tooltip. This can be the
	// GtkWindow created by default, or the custom tooltip window set using
	// gtk_widget_set_tooltip_window().
	TooltipWindow() Window
	// Toplevel: this function returns the topmost widget in the container
	// hierarchy @widget is a part of. If @widget has no parent widgets, it will
	// be returned as the topmost widget. No reference will be added to the
	// returned widget; it should not be unreferenced.
	//
	// Note the difference in behavior vs. gtk_widget_get_ancestor();
	// `gtk_widget_get_ancestor (widget, GTK_TYPE_WINDOW)` would return nil if
	// @widget wasn’t inside a toplevel window, and if the window was inside a
	// Window-derived widget which was in turn inside the toplevel Window. While
	// the second case may seem unlikely, it actually happens when a Plug is
	// embedded inside a Socket within the same application.
	//
	// To reliably find the toplevel Window, use gtk_widget_get_toplevel() and
	// call GTK_IS_WINDOW() on the result. For instance, to get the title of a
	// widget's toplevel window, one might use:
	//
	//    static const char *
	//    get_widget_toplevel_title (GtkWidget *widget)
	//    {
	//      GtkWidget *toplevel = gtk_widget_get_toplevel (widget);
	//      if (GTK_IS_WINDOW (toplevel))
	//        {
	//          return gtk_window_get_title (GTK_WINDOW (toplevel));
	//        }
	//
	//      return NULL;
	//    }
	Toplevel() Widget
	// Valign gets the value of the Widget:valign property.
	//
	// For backwards compatibility reasons this method will never return
	// GTK_ALIGN_BASELINE, but instead it will convert it to GTK_ALIGN_FILL. If
	// your widget want to support baseline aligned children it must use
	// gtk_widget_get_valign_with_baseline(), or `g_object_get (widget,
	// "valign", &value, NULL)`, which will also report the true value.
	Valign() Align
	// ValignWithBaseline gets the value of the Widget:valign property,
	// including GTK_ALIGN_BASELINE.
	ValignWithBaseline() Align
	// Vexpand gets whether the widget would like any available extra vertical
	// space.
	//
	// See gtk_widget_get_hexpand() for more detail.
	Vexpand() bool
	// VexpandSet gets whether gtk_widget_set_vexpand() has been used to
	// explicitly set the expand flag on this widget.
	//
	// See gtk_widget_get_hexpand_set() for more detail.
	VexpandSet() bool
	// Visible determines whether the widget is visible. If you want to take
	// into account whether the widget’s parent is also marked as visible, use
	// gtk_widget_is_visible() instead.
	//
	// This function does not check if the widget is obscured in any way.
	//
	// See gtk_widget_set_visible().
	Visible() bool
	// Visual gets the visual that will be used to render @widget.
	Visual() gdk.Visual
	// Window returns the widget’s window if it is realized, nil otherwise
	Window() gdk.Window
	// GrabAdd makes @widget the current grabbed widget.
	//
	// This means that interaction with other widgets in the same application is
	// blocked and mouse as well as keyboard events are delivered to this
	// widget.
	//
	// If @widget is not sensitive, it is not set as the current grabbed widget
	// and this function does nothing.
	GrabAdd()
	// GrabDefault causes @widget to become the default widget. @widget must be
	// able to be a default widget; typically you would ensure this yourself by
	// calling gtk_widget_set_can_default() with a true value. The default
	// widget is activated when the user presses Enter in a window. Default
	// widgets must be activatable, that is, gtk_widget_activate() should affect
	// them. Note that Entry widgets require the “activates-default” property
	// set to true before they activate the default widget when Enter is pressed
	// and the Entry is focused.
	GrabDefault()
	// GrabFocus causes @widget to have the keyboard focus for the Window it's
	// inside. @widget must be a focusable widget, such as a Entry; something
	// like Frame won’t work.
	//
	// More precisely, it must have the GTK_CAN_FOCUS flag set. Use
	// gtk_widget_set_can_focus() to modify that flag.
	//
	// The widget also needs to be realized and mapped. This is indicated by the
	// related signals. Grabbing the focus immediately after creating the widget
	// will likely fail and cause critical warnings.
	GrabFocus()
	// GrabRemove removes the grab from the given widget.
	//
	// You have to pair calls to gtk_grab_add() and gtk_grab_remove().
	//
	// If @widget does not have the grab, this function does nothing.
	GrabRemove()
	// HasDefault determines whether @widget is the current default widget
	// within its toplevel. See gtk_widget_set_can_default().
	HasDefault() bool
	// HasFocus determines if the widget has the global input focus. See
	// gtk_widget_is_focus() for the difference between having the global input
	// focus, and only having the focus within a toplevel.
	HasFocus() bool
	// HasGrab determines whether the widget is currently grabbing events, so it
	// is the only widget receiving input events (keyboard and mouse).
	//
	// See also gtk_grab_add().
	HasGrab() bool
	// HasRCStyle determines if the widget style has been looked up through the
	// rc mechanism.
	HasRCStyle() bool
	// HasScreen checks whether there is a Screen is associated with this
	// widget. All toplevel widgets have an associated screen, and all widgets
	// added into a hierarchy with a toplevel window at the top.
	HasScreen() bool
	// HasVisibleFocus determines if the widget should show a visible indication
	// that it has the global input focus. This is a convenience function for
	// use in ::draw handlers that takes into account whether focus indication
	// should currently be shown in the toplevel window of @widget. See
	// gtk_window_get_focus_visible() for more information about focus
	// indication.
	//
	// To find out if the widget has the global input focus, use
	// gtk_widget_has_focus().
	HasVisibleFocus() bool
	// Hide reverses the effects of gtk_widget_show(), causing the widget to be
	// hidden (invisible to the user).
	Hide()
	// HideOnDelete: utility function; intended to be connected to the
	// Widget::delete-event signal on a Window. The function calls
	// gtk_widget_hide() on its argument, then returns true. If connected to
	// ::delete-event, the result is that clicking the close button for a window
	// (on the window frame, top right corner usually) will hide but not destroy
	// the window. By default, GTK+ destroys windows when ::delete-event is
	// received.
	HideOnDelete() bool
	// InDestruction returns whether the widget is currently being destroyed.
	// This information can sometimes be used to avoid doing unnecessary work.
	InDestruction() bool
	// InitTemplate creates and initializes child widgets defined in templates.
	// This function must be called in the instance initializer for any class
	// which assigned itself a template using gtk_widget_class_set_template()
	//
	// It is important to call this function in the instance initializer of a
	// Widget subclass and not in #GObject.constructed() or
	// #GObject.constructor() for two reasons.
	//
	// One reason is that generally derived widgets will assume that parent
	// class composite widgets have been created in their instance initializers.
	//
	// Another reason is that when calling g_object_new() on a widget with
	// composite templates, it’s important to build the composite widgets before
	// the construct properties are set. Properties passed to g_object_new()
	// should take precedence over properties set in the private template XML.
	InitTemplate()
	// InputShapeCombineRegion sets an input shape for this widget’s GDK window.
	// This allows for windows which react to mouse click in a nonrectangular
	// region, see gdk_window_input_shape_combine_region() for more information.
	InputShapeCombineRegion(region *cairo.Region)
	// InsertActionGroup inserts @group into @widget. Children of @widget that
	// implement Actionable can then be associated with actions in @group by
	// setting their “action-name” to @prefix.`action-name`.
	//
	// If @group is nil, a previously inserted group for @name is removed from
	// @widget.
	InsertActionGroup(name string, group gio.ActionGroup)
	// Intersect computes the intersection of a @widget’s area and @area,
	// storing the intersection in @intersection, and returns true if there was
	// an intersection. @intersection may be nil if you’re only interested in
	// whether there was an intersection.
	Intersect(area *gdk.Rectangle) (gdk.Rectangle, bool)
	// IsAncestor determines whether @widget is somewhere inside @ancestor,
	// possibly with intermediate containers.
	IsAncestor(ancestor Widget) bool
	// IsComposited: whether @widget can rely on having its alpha channel drawn
	// correctly. On X11 this function returns whether a compositing manager is
	// running for @widget’s screen.
	//
	// Please note that the semantics of this call will change in the future if
	// used on a widget that has a composited window in its hierarchy (as set by
	// gdk_window_set_composited()).
	IsComposited() bool
	// IsDrawable determines whether @widget can be drawn to. A widget can be
	// drawn to if it is mapped and visible.
	IsDrawable() bool
	// IsFocus determines if the widget is the focus widget within its toplevel.
	// (This does not mean that the Widget:has-focus property is necessarily
	// set; Widget:has-focus will only be set if the toplevel widget
	// additionally has the global input focus.)
	IsFocus() bool
	// IsSensitive returns the widget’s effective sensitivity, which means it is
	// sensitive itself and also its parent widget is sensitive
	IsSensitive() bool
	// IsToplevel determines whether @widget is a toplevel widget.
	//
	// Currently only Window and Invisible (and out-of-process Plugs) are
	// toplevel widgets. Toplevel widgets have no parent widget.
	IsToplevel() bool
	// IsVisible determines whether the widget and all its parents are marked as
	// visible.
	//
	// This function does not check if the widget is obscured in any way.
	//
	// See also gtk_widget_get_visible() and gtk_widget_set_visible()
	IsVisible() bool
	// KeynavFailed: this function should be called whenever keyboard navigation
	// within a single widget hits a boundary. The function emits the
	// Widget::keynav-failed signal on the widget and its return value should be
	// interpreted in a way similar to the return value of
	// gtk_widget_child_focus():
	//
	// When true is returned, stay in the widget, the failed keyboard navigation
	// is OK and/or there is nowhere we can/should move the focus to.
	//
	// When false is returned, the caller should continue with keyboard
	// navigation outside the widget, e.g. by calling gtk_widget_child_focus()
	// on the widget’s toplevel.
	//
	// The default ::keynav-failed handler returns false for GTK_DIR_TAB_FORWARD
	// and GTK_DIR_TAB_BACKWARD. For the other values of DirectionType it
	// returns true.
	//
	// Whenever the default handler returns true, it also calls
	// gtk_widget_error_bell() to notify the user of the failed keyboard
	// navigation.
	//
	// A use case for providing an own implementation of ::keynav-failed (either
	// by connecting to it or by overriding it) would be a row of Entry widgets
	// where the user should be able to navigate the entire row with the cursor
	// keys, as e.g. known from user interfaces that require entering license
	// keys.
	KeynavFailed(direction DirectionType) bool
	// ListActionPrefixes retrieves a nil-terminated array of strings containing
	// the prefixes of Group's available to @widget.
	ListActionPrefixes() []string
	// Map: this function is only for use in widget implementations. Causes a
	// widget to be mapped if it isn’t already.
	Map()
	// MnemonicActivate emits the Widget::mnemonic-activate signal.
	MnemonicActivate(groupCycling bool) bool
	// ModifyBase sets the base color for a widget in a particular state. All
	// other style values are left untouched. The base color is the background
	// color used along with the text color (see gtk_widget_modify_text()) for
	// widgets such as Entry and TextView. See also gtk_widget_modify_style().
	//
	// > Note that “no window” widgets (which have the GTK_NO_WINDOW > flag set)
	// draw on their parent container’s window and thus may > not draw any
	// background themselves. This is the case for e.g. > Label. > > To modify
	// the background of such widgets, you have to set the > base color on their
	// parent; if you want to set the background > of a rectangular area around
	// a label, try placing the label in > a EventBox widget and setting the
	// base color on that.
	ModifyBase(state StateType, color *gdk.Color)
	// ModifyBg sets the background color for a widget in a particular state.
	//
	// All other style values are left untouched. See also
	// gtk_widget_modify_style().
	//
	// > Note that “no window” widgets (which have the GTK_NO_WINDOW > flag set)
	// draw on their parent container’s window and thus may > not draw any
	// background themselves. This is the case for e.g. > Label. > > To modify
	// the background of such widgets, you have to set the > background color on
	// their parent; if you want to set the background > of a rectangular area
	// around a label, try placing the label in > a EventBox widget and setting
	// the background color on that.
	ModifyBg(state StateType, color *gdk.Color)
	// ModifyCursor sets the cursor color to use in a widget, overriding the
	// Widget cursor-color and secondary-cursor-color style properties.
	//
	// All other style values are left untouched. See also
	// gtk_widget_modify_style().
	ModifyCursor(primary *gdk.Color, secondary *gdk.Color)
	// ModifyFg sets the foreground color for a widget in a particular state.
	//
	// All other style values are left untouched. See also
	// gtk_widget_modify_style().
	ModifyFg(state StateType, color *gdk.Color)
	// ModifyFont sets the font to use for a widget.
	//
	// All other style values are left untouched. See also
	// gtk_widget_modify_style().
	ModifyFont(fontDesc *pango.FontDescription)
	// ModifyStyle modifies style values on the widget.
	//
	// Modifications made using this technique take precedence over style values
	// set via an RC file, however, they will be overridden if a style is
	// explicitly set on the widget using gtk_widget_set_style(). The
	// RcStyle-struct is designed so each field can either be set or unset, so
	// it is possible, using this function, to modify some style values and
	// leave the others unchanged.
	//
	// Note that modifications made with this function are not cumulative with
	// previous calls to gtk_widget_modify_style() or with such functions as
	// gtk_widget_modify_fg(). If you wish to retain previous values, you must
	// first call gtk_widget_get_modifier_style(), make your modifications to
	// the returned style, then call gtk_widget_modify_style() with that style.
	// On the other hand, if you first call gtk_widget_modify_style(),
	// subsequent calls to such functions gtk_widget_modify_fg() will have a
	// cumulative effect with the initial modifications.
	ModifyStyle(style RCStyle)
	// ModifyText sets the text color for a widget in a particular state.
	//
	// All other style values are left untouched. The text color is the
	// foreground color used along with the base color (see
	// gtk_widget_modify_base()) for widgets such as Entry and TextView. See
	// also gtk_widget_modify_style().
	ModifyText(state StateType, color *gdk.Color)
	// OverrideBackgroundColor sets the background color to use for a widget.
	//
	// All other style values are left untouched. See
	// gtk_widget_override_color().
	OverrideBackgroundColor(state StateFlags, color *gdk.RGBA)
	// OverrideColor sets the color to use for a widget.
	//
	// All other style values are left untouched.
	//
	// This function does not act recursively. Setting the color of a container
	// does not affect its children. Note that some widgets that you may not
	// think of as containers, for instance Buttons, are actually containers.
	//
	// This API is mostly meant as a quick way for applications to change a
	// widget appearance. If you are developing a widgets library and intend
	// this change to be themeable, it is better done by setting meaningful CSS
	// classes in your widget/container implementation through
	// gtk_style_context_add_class().
	//
	// This way, your widget library can install a CssProvider with the
	// GTK_STYLE_PROVIDER_PRIORITY_FALLBACK priority in order to provide a
	// default styling for those widgets that need so, and this theming may
	// fully overridden by the user’s theme.
	//
	// Note that for complex widgets this may bring in undesired results (such
	// as uniform background color everywhere), in these cases it is better to
	// fully style such widgets through a CssProvider with the
	// GTK_STYLE_PROVIDER_PRIORITY_APPLICATION priority.
	OverrideColor(state StateFlags, color *gdk.RGBA)
	// OverrideCursor sets the cursor color to use in a widget, overriding the
	// cursor-color and secondary-cursor-color style properties. All other style
	// values are left untouched. See also gtk_widget_modify_style().
	//
	// Note that the underlying properties have the Color type, so the alpha
	// value in @primary and @secondary will be ignored.
	OverrideCursor(cursor *gdk.RGBA, secondaryCursor *gdk.RGBA)
	// OverrideFont sets the font to use for a widget. All other style values
	// are left untouched. See gtk_widget_override_color().
	OverrideFont(fontDesc *pango.FontDescription)
	// OverrideSymbolicColor sets a symbolic color for a widget.
	//
	// All other style values are left untouched. See
	// gtk_widget_override_color() for overriding the foreground or background
	// color.
	OverrideSymbolicColor(name string, color *gdk.RGBA)
	// Path obtains the full path to @widget. The path is simply the name of a
	// widget and all its parents in the container hierarchy, separated by
	// periods. The name of a widget comes from gtk_widget_get_name(). Paths are
	// used to apply styles to a widget in gtkrc configuration files. Widget
	// names are the type of the widget by default (e.g. “GtkButton”) or can be
	// set to an application-specific value with gtk_widget_set_name(). By
	// setting the name of a widget, you allow users or theme authors to apply
	// styles to that specific widget in their gtkrc file. @path_reversed_p
	// fills in the path in reverse order, i.e. starting with @widget’s name
	// instead of starting with the name of @widget’s outermost ancestor.
	Path() (pathLength uint, path string, pathReversed string)
	// QueueAllocate: this function is only for use in widget implementations.
	//
	// Flags the widget for a rerun of the GtkWidgetClass::size_allocate
	// function. Use this function instead of gtk_widget_queue_resize() when the
	// @widget's size request didn't change but it wants to reposition its
	// contents.
	//
	// An example user of this function is gtk_widget_set_halign().
	QueueAllocate()
	// QueueComputeExpand: mark @widget as needing to recompute its expand
	// flags. Call this function when setting legacy expand child properties on
	// the child of a container.
	//
	// See gtk_widget_compute_expand().
	QueueComputeExpand()
	// QueueDraw: equivalent to calling gtk_widget_queue_draw_area() for the
	// entire area of a widget.
	QueueDraw()
	// QueueDrawArea: convenience function that calls
	// gtk_widget_queue_draw_region() on the region created from the given
	// coordinates.
	//
	// The region here is specified in widget coordinates. Widget coordinates
	// are a bit odd; for historical reasons, they are defined as
	// @widget->window coordinates for widgets that return true for
	// gtk_widget_get_has_window(), and are relative to @widget->allocation.x,
	// @widget->allocation.y otherwise.
	//
	// @width or @height may be 0, in this case this function does nothing.
	// Negative values for @width and @height are not allowed.
	QueueDrawArea(x int, y int, width int, height int)
	// QueueDrawRegion invalidates the area of @widget defined by @region by
	// calling gdk_window_invalidate_region() on the widget’s window and all its
	// child windows. Once the main loop becomes idle (after the current batch
	// of events has been processed, roughly), the window will receive expose
	// events for the union of all regions that have been invalidated.
	//
	// Normally you would only use this function in widget implementations. You
	// might also use it to schedule a redraw of a DrawingArea or some portion
	// thereof.
	QueueDrawRegion(region *cairo.Region)
	// QueueResize: this function is only for use in widget implementations.
	// Flags a widget to have its size renegotiated; should be called when a
	// widget for some reason has a new size request. For example, when you
	// change the text in a Label, Label queues a resize to ensure there’s
	// enough space for the new text.
	//
	// Note that you cannot call gtk_widget_queue_resize() on a widget from
	// inside its implementation of the GtkWidgetClass::size_allocate virtual
	// method. Calls to gtk_widget_queue_resize() from inside
	// GtkWidgetClass::size_allocate will be silently ignored.
	QueueResize()
	// QueueResizeNoRedraw: this function works like gtk_widget_queue_resize(),
	// except that the widget is not invalidated.
	QueueResizeNoRedraw()
	// Realize creates the GDK (windowing system) resources associated with a
	// widget. For example, @widget->window will be created when a widget is
	// realized. Normally realization happens implicitly; if you show a widget
	// and all its parent containers, then the widget will be realized and
	// mapped automatically.
	//
	// Realizing a widget requires all the widget’s parent widgets to be
	// realized; calling gtk_widget_realize() realizes the widget’s parents in
	// addition to @widget itself. If a widget is not yet inside a toplevel
	// window when you realize it, bad things will happen.
	//
	// This function is primarily used in widget implementations, and isn’t very
	// useful otherwise. Many times when you think you might need it, a better
	// approach is to connect to a signal that will be called after the widget
	// is realized automatically, such as Widget::draw. Or simply
	// g_signal_connect () to the Widget::realize signal.
	Realize()
	// RegionIntersect computes the intersection of a @widget’s area and
	// @region, returning the intersection. The result may be empty, use
	// cairo_region_is_empty() to check.
	RegionIntersect(region *cairo.Region) *cairo.Region
	// RegisterWindow registers a Window with the widget and sets it up so that
	// the widget receives events for it. Call gtk_widget_unregister_window()
	// when destroying the window.
	//
	// Before 3.8 you needed to call gdk_window_set_user_data() directly to set
	// this up. This is now deprecated and you should use
	// gtk_widget_register_window() instead. Old code will keep working as is,
	// although some new features like transparency might not work perfectly.
	RegisterWindow(window gdk.Window)
	// RemoveAccelerator removes an accelerator from @widget, previously
	// installed with gtk_widget_add_accelerator().
	RemoveAccelerator(accelGroup AccelGroup, accelKey uint, accelMods gdk.ModifierType) bool
	// RemoveMnemonicLabel removes a widget from the list of mnemonic labels for
	// this widget. (See gtk_widget_list_mnemonic_labels()). The widget must
	// have previously been added to the list with
	// gtk_widget_add_mnemonic_label().
	RemoveMnemonicLabel(label Widget)
	// RemoveTickCallback removes a tick callback previously registered with
	// gtk_widget_add_tick_callback().
	RemoveTickCallback(id uint)
	// RenderIcon: a convenience function that uses the theme settings for
	// @widget to look up @stock_id and render it to a pixbuf. @stock_id should
	// be a stock icon ID such as K_STOCK_OPEN or K_STOCK_OK. @size should be a
	// size such as K_ICON_SIZE_MENU. @detail should be a string that identifies
	// the widget or code doing the rendering, so that theme engines can
	// special-case rendering for that widget or code.
	//
	// The pixels in the returned Pixbuf are shared with the rest of the
	// application and should not be modified. The pixbuf should be freed after
	// use with g_object_unref().
	RenderIcon(stockId string, size int, detail string) gdkpixbuf.Pixbuf
	// RenderIconPixbuf: a convenience function that uses the theme engine and
	// style settings for @widget to look up @stock_id and render it to a
	// pixbuf. @stock_id should be a stock icon ID such as K_STOCK_OPEN or
	// K_STOCK_OK. @size should be a size such as K_ICON_SIZE_MENU.
	//
	// The pixels in the returned Pixbuf are shared with the rest of the
	// application and should not be modified. The pixbuf should be freed after
	// use with g_object_unref().
	RenderIconPixbuf(stockId string, size int) gdkpixbuf.Pixbuf
	// Reparent moves a widget from one Container to another, handling reference
	// count issues to avoid destroying the widget.
	Reparent(newParent Widget)
	// ResetRCStyles: reset the styles of @widget and all descendents, so when
	// they are looked up again, they get the correct values for the currently
	// loaded RC file settings.
	//
	// This function is not useful for applications.
	ResetRCStyles()
	// ResetStyle updates the style context of @widget and all descendants by
	// updating its widget path. Containers may want to use this on a child when
	// reordering it in a way that a different style might apply to it. See also
	// gtk_container_get_path_for_child().
	ResetStyle()
	// SetAccelPath: given an accelerator group, @accel_group, and an
	// accelerator path, @accel_path, sets up an accelerator in @accel_group so
	// whenever the key binding that is defined for @accel_path is pressed,
	// @widget will be activated. This removes any accelerators (for any
	// accelerator group) installed by previous calls to
	// gtk_widget_set_accel_path(). Associating accelerators with paths allows
	// them to be modified by the user and the modifications to be saved for
	// future use. (See gtk_accel_map_save().)
	//
	// This function is a low level function that would most likely be used by a
	// menu creation system like UIManager. If you use UIManager, setting up
	// accelerator paths will be done automatically.
	//
	// Even when you you aren’t using UIManager, if you only want to set up
	// accelerators on menu items gtk_menu_item_set_accel_path() provides a
	// somewhat more convenient interface.
	//
	// Note that @accel_path string will be stored in a #GQuark. Therefore, if
	// you pass a static string, you can save some memory by interning it first
	// with g_intern_static_string().
	SetAccelPath(accelPath string, accelGroup AccelGroup)
	// SetAppPaintable sets whether the application intends to draw on the
	// widget in an Widget::draw handler.
	//
	// This is a hint to the widget and does not affect the behavior of the GTK+
	// core; many widgets ignore this flag entirely. For widgets that do pay
	// attention to the flag, such as EventBox and Window, the effect is to
	// suppress default themed drawing of the widget's background. (Children of
	// the widget will still be drawn.) The application is then entirely
	// responsible for drawing the widget background.
	//
	// Note that the background is still drawn when the widget is mapped.
	SetAppPaintable(appPaintable bool)
	// SetCanDefault specifies whether @widget can be a default widget. See
	// gtk_widget_grab_default() for details about the meaning of “default”.
	SetCanDefault(canDefault bool)
	// SetCanFocus specifies whether @widget can own the input focus. See
	// gtk_widget_grab_focus() for actually setting the input focus on a widget.
	SetCanFocus(canFocus bool)
	// SetChildVisible sets whether @widget should be mapped along with its when
	// its parent is mapped and @widget has been shown with gtk_widget_show().
	//
	// The child visibility can be set for widget before it is added to a
	// container with gtk_widget_set_parent(), to avoid mapping children
	// unnecessary before immediately unmapping them. However it will be reset
	// to its default state of true when the widget is removed from a container.
	//
	// Note that changing the child visibility of a widget does not queue a
	// resize on the widget. Most of the time, the size of a widget is computed
	// from all visible children, whether or not they are mapped. If this is not
	// the case, the container can queue a resize itself.
	//
	// This function is only useful for container implementations and never
	// should be called by an application.
	SetChildVisible(isVisible bool)
	// SetCompositeName sets a widgets composite name. The widget must be a
	// composite child of its parent; see gtk_widget_push_composite_child().
	SetCompositeName(name string)
	// SetDeviceEnabled enables or disables a Device to interact with @widget
	// and all its children.
	//
	// It does so by descending through the Window hierarchy and enabling the
	// same mask that is has for core events (i.e. the one that
	// gdk_window_get_events() returns).
	SetDeviceEnabled(device gdk.Device, enabled bool)
	// SetDeviceEvents sets the device event mask (see EventMask) for a widget.
	// The event mask determines which events a widget will receive from
	// @device. Keep in mind that different widgets have different default event
	// masks, and by changing the event mask you may disrupt a widget’s
	// functionality, so be careful. This function must be called while a widget
	// is unrealized. Consider gtk_widget_add_device_events() for widgets that
	// are already realized, or if you want to preserve the existing event mask.
	// This function can’t be used with windowless widgets (which return false
	// from gtk_widget_get_has_window()); to get events on those widgets, place
	// them inside a EventBox and receive events on the event box.
	SetDeviceEvents(device gdk.Device, events gdk.EventMask)
	// SetDirection sets the reading direction on a particular widget. This
	// direction controls the primary direction for widgets containing text, and
	// also the direction in which the children of a container are packed. The
	// ability to set the direction is present in order so that correct
	// localization into languages with right-to-left reading directions can be
	// done. Generally, applications will let the default reading direction
	// present, except for containers where the containers are arranged in an
	// order that is explicitly visual rather than logical (such as buttons for
	// text justification).
	//
	// If the direction is set to GTK_TEXT_DIR_NONE, then the value set by
	// gtk_widget_set_default_direction() will be used.
	SetDirection(dir TextDirection)
	// SetDoubleBuffered widgets are double buffered by default; you can use
	// this function to turn off the buffering. “Double buffered” simply means
	// that gdk_window_begin_draw_frame() and gdk_window_end_draw_frame() are
	// called automatically around expose events sent to the widget.
	// gdk_window_begin_draw_frame() diverts all drawing to a widget's window to
	// an offscreen buffer, and gdk_window_end_draw_frame() draws the buffer to
	// the screen. The result is that users see the window update in one smooth
	// step, and don’t see individual graphics primitives being rendered.
	//
	// In very simple terms, double buffered widgets don’t flicker, so you would
	// only use this function to turn off double buffering if you had special
	// needs and really knew what you were doing.
	//
	// Note: if you turn off double-buffering, you have to handle expose events,
	// since even the clearing to the background color or pixmap will not happen
	// automatically (as it is done in gdk_window_begin_draw_frame()).
	//
	// In 3.10 GTK and GDK have been restructured for translucent drawing. Since
	// then expose events for double-buffered widgets are culled into a single
	// event to the toplevel GDK window. If you now unset double buffering, you
	// will cause a separate rendering pass for every widget. This will likely
	// cause rendering problems - in particular related to stacking - and
	// usually increases rendering times significantly.
	SetDoubleBuffered(doubleBuffered bool)
	// SetEvents sets the event mask (see EventMask) for a widget. The event
	// mask determines which events a widget will receive. Keep in mind that
	// different widgets have different default event masks, and by changing the
	// event mask you may disrupt a widget’s functionality, so be careful. This
	// function must be called while a widget is unrealized. Consider
	// gtk_widget_add_events() for widgets that are already realized, or if you
	// want to preserve the existing event mask. This function can’t be used
	// with widgets that have no window. (See gtk_widget_get_has_window()). To
	// get events on those widgets, place them inside a EventBox and receive
	// events on the event box.
	SetEvents(events int)
	// SetFocusOnClick sets whether the widget should grab focus when it is
	// clicked with the mouse. Making mouse clicks not grab focus is useful in
	// places like toolbars where you don’t want the keyboard focus removed from
	// the main area of the application.
	SetFocusOnClick(focusOnClick bool)
	// SetFontMap sets the font map to use for Pango rendering. When not set,
	// the widget will inherit the font map from its parent.
	SetFontMap(fontMap pango.FontMap)
	// SetFontOptions sets the #cairo_font_options_t used for Pango rendering in
	// this widget. When not set, the default font options for the Screen will
	// be used.
	SetFontOptions(options *cairo.FontOptions)
	// SetHalign sets the horizontal alignment of @widget. See the Widget:halign
	// property.
	SetHalign(align Align)
	// SetHasTooltip sets the has-tooltip property on @widget to @has_tooltip.
	// See Widget:has-tooltip for more information.
	SetHasTooltip(hasTooltip bool)
	// SetHasWindow specifies whether @widget has a Window of its own. Note that
	// all realized widgets have a non-nil “window” pointer
	// (gtk_widget_get_window() never returns a nil window when a widget is
	// realized), but for many of them it’s actually the Window of one of its
	// parent widgets. Widgets that do not create a window for themselves in
	// Widget::realize must announce this by calling this function with
	// @has_window = false.
	//
	// This function should only be called by widget implementations, and they
	// should call it in their init() function.
	SetHasWindow(hasWindow bool)
	// SetHexpand sets whether the widget would like any available extra
	// horizontal space. When a user resizes a Window, widgets with expand=TRUE
	// generally receive the extra space. For example, a list or scrollable area
	// or document in your window would often be set to expand.
	//
	// Call this function to set the expand flag if you would like your widget
	// to become larger horizontally when the window has extra room.
	//
	// By default, widgets automatically expand if any of their children want to
	// expand. (To see if a widget will automatically expand given its current
	// children and state, call gtk_widget_compute_expand(). A container can
	// decide how the expandability of children affects the expansion of the
	// container by overriding the compute_expand virtual method on Widget.).
	//
	// Setting hexpand explicitly with this function will override the automatic
	// expand behavior.
	//
	// This function forces the widget to expand or not to expand, regardless of
	// children. The override occurs because gtk_widget_set_hexpand() sets the
	// hexpand-set property (see gtk_widget_set_hexpand_set()) which causes the
	// widget’s hexpand value to be used, rather than looking at children and
	// widget state.
	SetHexpand(expand bool)
	// SetHexpandSet sets whether the hexpand flag (see
	// gtk_widget_get_hexpand()) will be used.
	//
	// The hexpand-set property will be set automatically when you call
	// gtk_widget_set_hexpand() to set hexpand, so the most likely reason to use
	// this function would be to unset an explicit expand flag.
	//
	// If hexpand is set, then it overrides any computed expand value based on
	// child widgets. If hexpand is not set, then the expand value depends on
	// whether any children of the widget would like to expand.
	//
	// There are few reasons to use this function, but it’s here for
	// completeness and consistency.
	SetHexpandSet(set bool)
	// SetMapped marks the widget as being mapped.
	//
	// This function should only ever be called in a derived widget's “map” or
	// “unmap” implementation.
	SetMapped(mapped bool)
	// SetMarginBottom sets the bottom margin of @widget. See the
	// Widget:margin-bottom property.
	SetMarginBottom(margin int)
	// SetMarginEnd sets the end margin of @widget. See the Widget:margin-end
	// property.
	SetMarginEnd(margin int)
	// SetMarginLeft sets the left margin of @widget. See the Widget:margin-left
	// property.
	SetMarginLeft(margin int)
	// SetMarginRight sets the right margin of @widget. See the
	// Widget:margin-right property.
	SetMarginRight(margin int)
	// SetMarginStart sets the start margin of @widget. See the
	// Widget:margin-start property.
	SetMarginStart(margin int)
	// SetMarginTop sets the top margin of @widget. See the Widget:margin-top
	// property.
	SetMarginTop(margin int)
	// SetName widgets can be named, which allows you to refer to them from a
	// CSS file. You can apply a style to widgets with a particular name in the
	// CSS file. See the documentation for the CSS syntax (on the same page as
	// the docs for StyleContext).
	//
	// Note that the CSS syntax has certain special characters to delimit and
	// represent elements in a selector (period, #, >, *...), so using these
	// will make your widget impossible to match by name. Any combination of
	// alphanumeric symbols, dashes and underscores will suffice.
	SetName(name string)
	// SetNoShowAll sets the Widget:no-show-all property, which determines
	// whether calls to gtk_widget_show_all() will affect this widget.
	//
	// This is mostly for use in constructing widget hierarchies with externally
	// controlled visibility, see UIManager.
	SetNoShowAll(noShowAll bool)
	// SetOpacity: request the @widget to be rendered partially transparent,
	// with opacity 0 being fully transparent and 1 fully opaque. (Opacity
	// values are clamped to the [0,1] range.). This works on both toplevel
	// widget, and child widgets, although there are some limitations:
	//
	// For toplevel widgets this depends on the capabilities of the windowing
	// system. On X11 this has any effect only on X screens with a compositing
	// manager running. See gtk_widget_is_composited(). On Windows it should
	// work always, although setting a window’s opacity after the window has
	// been shown causes it to flicker once on Windows.
	//
	// For child widgets it doesn’t work if any affected widget has a native
	// window, or disables double buffering.
	SetOpacity(opacity float64)
	// SetParent: this function is useful only when implementing subclasses of
	// Container. Sets the container as the parent of @widget, and takes care of
	// some details such as updating the state and style of the child to reflect
	// its new location. The opposite function is gtk_widget_unparent().
	SetParent(parent Widget)
	// SetParentWindow sets a non default parent window for @widget.
	//
	// For Window classes, setting a @parent_window effects whether the window
	// is a toplevel window or can be embedded into other widgets.
	//
	// For Window classes, this needs to be called before the window is
	// realized.
	SetParentWindow(parentWindow gdk.Window)
	// SetRealized marks the widget as being realized. This function must only
	// be called after all Windows for the @widget have been created and
	// registered.
	//
	// This function should only ever be called in a derived widget's “realize”
	// or “unrealize” implementation.
	SetRealized(realized bool)
	// SetReceivesDefault specifies whether @widget will be treated as the
	// default widget within its toplevel when it has the focus, even if another
	// widget is the default.
	//
	// See gtk_widget_grab_default() for details about the meaning of “default”.
	SetReceivesDefault(receivesDefault bool)
	// SetRedrawOnAllocate sets whether the entire widget is queued for drawing
	// when its size allocation changes. By default, this setting is true and
	// the entire widget is redrawn on every size change. If your widget leaves
	// the upper left unchanged when made bigger, turning this setting off will
	// improve performance.
	//
	// Note that for widgets where gtk_widget_get_has_window() is false setting
	// this flag to false turns off all allocation on resizing: the widget will
	// not even redraw if its position changes; this is to allow containers that
	// don’t draw anything to avoid excess invalidations. If you set this flag
	// on a widget with no window that does draw on @widget->window, you are
	// responsible for invalidating both the old and new allocation of the
	// widget when the widget is moved and responsible for invalidating regions
	// newly when the widget increases size.
	SetRedrawOnAllocate(redrawOnAllocate bool)
	// SetSensitive sets the sensitivity of a widget. A widget is sensitive if
	// the user can interact with it. Insensitive widgets are “grayed out” and
	// the user can’t interact with them. Insensitive widgets are known as
	// “inactive”, “disabled”, or “ghosted” in some other toolkits.
	SetSensitive(sensitive bool)
	// SetSizeRequest sets the minimum size of a widget; that is, the widget’s
	// size request will be at least @width by @height. You can use this
	// function to force a widget to be larger than it normally would be.
	//
	// In most cases, gtk_window_set_default_size() is a better choice for
	// toplevel windows than this function; setting the default size will still
	// allow users to shrink the window. Setting the size request will force
	// them to leave the window at least as large as the size request. When
	// dealing with window sizes, gtk_window_set_geometry_hints() can be a
	// useful function as well.
	//
	// Note the inherent danger of setting any fixed size - themes, translations
	// into other languages, different fonts, and user action can all change the
	// appropriate size for a given widget. So, it's basically impossible to
	// hardcode a size that will always be correct.
	//
	// The size request of a widget is the smallest size a widget can accept
	// while still functioning well and drawing itself correctly. However in
	// some strange cases a widget may be allocated less than its requested
	// size, and in many cases a widget may be allocated more space than it
	// requested.
	//
	// If the size request in a given direction is -1 (unset), then the
	// “natural” size request of the widget will be used instead.
	//
	// The size request set here does not include any margin from the Widget
	// properties margin-left, margin-right, margin-top, and margin-bottom, but
	// it does include pretty much all other padding or border properties set by
	// any subclass of Widget.
	SetSizeRequest(width int, height int)
	// SetState: this function is for use in widget implementations. Sets the
	// state of a widget (insensitive, prelighted, etc.) Usually you should set
	// the state using wrapper functions such as gtk_widget_set_sensitive().
	SetState(state StateType)
	// SetStateFlags: this function is for use in widget implementations. Turns
	// on flag values in the current widget state (insensitive, prelighted,
	// etc.).
	//
	// This function accepts the values GTK_STATE_FLAG_DIR_LTR and
	// GTK_STATE_FLAG_DIR_RTL but ignores them. If you want to set the widget's
	// direction, use gtk_widget_set_direction().
	//
	// It is worth mentioning that any other state than
	// GTK_STATE_FLAG_INSENSITIVE, will be propagated down to all non-internal
	// children if @widget is a Container, while GTK_STATE_FLAG_INSENSITIVE
	// itself will be propagated down to all Container children by different
	// means than turning on the state flag down the hierarchy, both
	// gtk_widget_get_state_flags() and gtk_widget_is_sensitive() will make use
	// of these.
	SetStateFlags(flags StateFlags, clear bool)
	// SetStyle: used to set the Style for a widget (@widget->style). Since GTK
	// 3, this function does nothing, the passed in style is ignored.
	SetStyle(style Style)
	// SetSupportMultidevice enables or disables multiple pointer awareness. If
	// this setting is true, @widget will start receiving multiple, per device
	// enter/leave events. Note that if custom Windows are created in
	// Widget::realize, gdk_window_set_support_multidevice() will have to be
	// called manually on them.
	SetSupportMultidevice(supportMultidevice bool)
	// SetTooltipMarkup sets @markup as the contents of the tooltip, which is
	// marked up with the [Pango text markup language][PangoMarkupFormat].
	//
	// This function will take care of setting Widget:has-tooltip to true and of
	// the default handler for the Widget::query-tooltip signal.
	//
	// See also the Widget:tooltip-markup property and gtk_tooltip_set_markup().
	SetTooltipMarkup(markup string)
	// SetTooltipText sets @text as the contents of the tooltip. This function
	// will take care of setting Widget:has-tooltip to true and of the default
	// handler for the Widget::query-tooltip signal.
	//
	// See also the Widget:tooltip-text property and gtk_tooltip_set_text().
	SetTooltipText(text string)
	// SetTooltipWindow replaces the default window used for displaying tooltips
	// with @custom_window. GTK+ will take care of showing and hiding
	// @custom_window at the right moment, to behave likewise as the default
	// tooltip window. If @custom_window is nil, the default tooltip window will
	// be used.
	SetTooltipWindow(customWindow Window)
	// SetValign sets the vertical alignment of @widget. See the Widget:valign
	// property.
	SetValign(align Align)
	// SetVexpand sets whether the widget would like any available extra
	// vertical space.
	//
	// See gtk_widget_set_hexpand() for more detail.
	SetVexpand(expand bool)
	// SetVexpandSet sets whether the vexpand flag (see
	// gtk_widget_get_vexpand()) will be used.
	//
	// See gtk_widget_set_hexpand_set() for more detail.
	SetVexpandSet(set bool)
	// SetVisible sets the visibility state of @widget. Note that setting this
	// to true doesn’t mean the widget is actually viewable, see
	// gtk_widget_get_visible().
	//
	// This function simply calls gtk_widget_show() or gtk_widget_hide() but is
	// nicer to use when the visibility of the widget depends on some condition.
	SetVisible(visible bool)
	// SetVisual sets the visual that should be used for by widget and its
	// children for creating Windows. The visual must be on the same Screen as
	// returned by gtk_widget_get_screen(), so handling the
	// Widget::screen-changed signal is necessary.
	//
	// Setting a new @visual will not cause @widget to recreate its windows, so
	// you should call this function before @widget is realized.
	SetVisual(visual gdk.Visual)
	// SetWindow sets a widget’s window. This function should only be used in a
	// widget’s Widget::realize implementation. The window passed is usually
	// either new window created with gdk_window_new(), or the window of its
	// parent widget as returned by gtk_widget_get_parent_window().
	//
	// Widgets must indicate whether they will create their own Window by
	// calling gtk_widget_set_has_window(). This is usually done in the widget’s
	// init() function.
	//
	// Note that this function does not add any reference to @window.
	SetWindow(window gdk.Window)
	// ShapeCombineRegion sets a shape for this widget’s GDK window. This allows
	// for transparent windows etc., see gdk_window_shape_combine_region() for
	// more information.
	ShapeCombineRegion(region *cairo.Region)
	// Show flags a widget to be displayed. Any widget that isn’t shown will not
	// appear on the screen. If you want to show all the widgets in a container,
	// it’s easier to call gtk_widget_show_all() on the container, instead of
	// individually showing the widgets.
	//
	// Remember that you have to show the containers containing a widget, in
	// addition to the widget itself, before it will appear onscreen.
	//
	// When a toplevel container is shown, it is immediately realized and
	// mapped; other shown widgets are realized and mapped when their toplevel
	// container is realized and mapped.
	Show()
	// ShowAll: recursively shows a widget, and any child widgets (if the widget
	// is a container).
	ShowAll()
	// ShowNow shows a widget. If the widget is an unmapped toplevel widget
	// (i.e. a Window that has not yet been shown), enter the main loop and wait
	// for the window to actually be mapped. Be careful; because the main loop
	// is running, anything can happen during this function.
	ShowNow()
	// SizeRequest: this function is typically used when implementing a
	// Container subclass. Obtains the preferred size of a widget. The container
	// uses this information to arrange its child widgets and decide what size
	// allocations to give them with gtk_widget_size_allocate().
	//
	// You can also call this function from an application, with some caveats.
	// Most notably, getting a size request requires the widget to be associated
	// with a screen, because font information may be needed. Multihead-aware
	// applications should keep this in mind.
	//
	// Also remember that the size request is not necessarily the size a widget
	// will actually be allocated.
	SizeRequest() Requisition
	// StyleAttach: this function attaches the widget’s Style to the widget's
	// Window. It is a replacement for
	//
	//    widget->style = gtk_style_attach (widget->style, widget->window);
	//
	// and should only ever be called in a derived widget’s “realize”
	// implementation which does not chain up to its parent class' “realize”
	// implementation, because one of the parent classes (finally Widget) would
	// attach the style itself.
	StyleAttach()
	// StyleGetProperty gets the value of a style property of @widget.
	StyleGetProperty(propertyName string, value **externglib.Value)
	// ThawChildNotify reverts the effect of a previous call to
	// gtk_widget_freeze_child_notify(). This causes all queued
	// Widget::child-notify signals on @widget to be emitted.
	ThawChildNotify()
	// TranslateCoordinates: translate coordinates relative to @src_widget’s
	// allocation to coordinates relative to @dest_widget’s allocations. In
	// order to perform this operation, both widgets must be realized, and must
	// share a common toplevel.
	TranslateCoordinates(destWidget Widget, srcX int, srcY int) (destX int, destY int, ok bool)
	// TriggerTooltipQuery triggers a tooltip query on the display where the
	// toplevel of @widget is located. See gtk_tooltip_trigger_tooltip_query()
	// for more information.
	TriggerTooltipQuery()
	// Unmap: this function is only for use in widget implementations. Causes a
	// widget to be unmapped if it’s currently mapped.
	Unmap()
	// Unparent: this function is only for use in widget implementations. Should
	// be called by implementations of the remove method on Container, to
	// dissociate a child from the container.
	Unparent()
	// Unrealize: this function is only useful in widget implementations. Causes
	// a widget to be unrealized (frees all GDK resources associated with the
	// widget, such as @widget->window).
	Unrealize()
	// UnregisterWindow unregisters a Window from the widget that was previously
	// set up with gtk_widget_register_window(). You need to call this when the
	// window is no longer used by the widget, such as when you destroy it.
	UnregisterWindow(window gdk.Window)
	// UnsetStateFlags: this function is for use in widget implementations.
	// Turns off flag values for the current widget state (insensitive,
	// prelighted, etc.). See gtk_widget_set_state_flags().
	UnsetStateFlags(flags StateFlags)
}

// widget implements the Widget class.
type widget struct {
	gextras.Objector
	Buildable
}

var _ Widget = (*widget)(nil)

// WrapWidget wraps a GObject to the right type. It is
// primarily used internally.
func WrapWidget(obj *externglib.Object) Widget {
	return widget{
		Objector:  obj,
		Buildable: WrapBuildable(obj),
	}
}

func marshalWidget(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapWidget(obj), nil
}

// Activate: for widgets that can be “activated” (buttons, menu items, etc.)
// this function activates them. Activation is what happens when you press Enter
// on a widget during key navigation. If @widget isn't activatable, the function
// returns false.
func (w widget) Activate() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_activate(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AddAccelerator installs an accelerator for this @widget in @accel_group that
// causes @accel_signal to be emitted if the accelerator is activated. The
// @accel_group needs to be added to the widget’s toplevel via
// gtk_window_add_accel_group(), and the signal must be of type G_SIGNAL_ACTION.
// Accelerators added through this function are not user changeable during
// runtime. If you want to support accelerators that can be changed by the user,
// use gtk_accel_map_add_entry() and gtk_widget_set_accel_path() or
// gtk_menu_item_set_accel_path() instead.
func (w widget) AddAccelerator(accelSignal string, accelGroup AccelGroup, accelKey uint, accelMods gdk.ModifierType, accelFlags AccelFlags) {
	var _arg0 *C.GtkWidget      // out
	var _arg1 *C.gchar          // out
	var _arg2 *C.GtkAccelGroup  // out
	var _arg3 C.guint           // out
	var _arg4 C.GdkModifierType // out
	var _arg5 C.GtkAccelFlags   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.gchar)(C.CString(accelSignal))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkAccelGroup)(unsafe.Pointer(accelGroup.Native()))
	_arg3 = (C.guint)(accelKey)
	_arg4 = (C.GdkModifierType)(accelMods)
	_arg5 = (C.GtkAccelFlags)(accelFlags)

	C.gtk_widget_add_accelerator(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}

// AddDeviceEvents adds the device events in the bitfield @events to the event
// mask for @widget. See gtk_widget_set_device_events() for details.
func (w widget) AddDeviceEvents(device gdk.Device, events gdk.EventMask) {
	var _arg0 *C.GtkWidget   // out
	var _arg1 *C.GdkDevice   // out
	var _arg2 C.GdkEventMask // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))
	_arg2 = (C.GdkEventMask)(events)

	C.gtk_widget_add_device_events(_arg0, _arg1, _arg2)
}

// AddEvents adds the events in the bitfield @events to the event mask for
// @widget. See gtk_widget_set_events() and the [input handling
// overview][event-masks] for details.
func (w widget) AddEvents(events int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.gint)(events)

	C.gtk_widget_add_events(_arg0, _arg1)
}

// AddMnemonicLabel adds a widget to the list of mnemonic labels for this
// widget. (See gtk_widget_list_mnemonic_labels()). Note the list of mnemonic
// labels for the widget is cleared when the widget is destroyed, so the caller
// must make sure to update its internal state at this point as well, by using a
// connection to the Widget::destroy signal or a weak notifier.
func (w widget) AddMnemonicLabel(label Widget) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(label.Native()))

	C.gtk_widget_add_mnemonic_label(_arg0, _arg1)
}

// CanActivateAccel determines whether an accelerator that activates the signal
// identified by @signal_id can currently be activated. This is done by emitting
// the Widget::can-activate-accel signal on @widget; if the signal isn’t
// overridden by a handler or in a derived widget, then the default check is
// that the widget must be sensitive, and the widget and all its ancestors
// mapped.
func (w widget) CanActivateAccel(signalId uint) bool {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.guint      // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.guint)(signalId)

	_cret = C.gtk_widget_can_activate_accel(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ChildFocus: this function is used by custom widget implementations; if you're
// writing an app, you’d use gtk_widget_grab_focus() to move the focus to a
// particular widget, and gtk_container_set_focus_chain() to change the focus
// tab order. So you may want to investigate those functions instead.
//
// gtk_widget_child_focus() is called by containers as the user moves around the
// window using keyboard shortcuts. @direction indicates what kind of motion is
// taking place (up, down, left, right, tab forward, tab backward).
// gtk_widget_child_focus() emits the Widget::focus signal; widgets override the
// default handler for this signal in order to implement appropriate focus
// behavior.
//
// The default ::focus handler for a widget should return true if moving in
// @direction left the focus on a focusable location inside that widget, and
// false if moving in @direction moved the focus outside the widget. If
// returning true, widgets normally call gtk_widget_grab_focus() to place the
// focus accordingly; if returning false, they don’t modify the current focus
// location.
func (w widget) ChildFocus(direction DirectionType) bool {
	var _arg0 *C.GtkWidget       // out
	var _arg1 C.GtkDirectionType // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GtkDirectionType)(direction)

	_cret = C.gtk_widget_child_focus(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ChildNotify emits a Widget::child-notify signal for the [child
// property][child-properties] @child_property on @widget.
//
// This is the analogue of g_object_notify() for child properties.
//
// Also see gtk_container_child_notify().
func (w widget) ChildNotify(childProperty string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.gchar)(C.CString(childProperty))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_widget_child_notify(_arg0, _arg1)
}

// ClassPath: same as gtk_widget_path(), but always uses the name of a widget’s
// type, never uses a custom name set with gtk_widget_set_name().
func (w widget) ClassPath() (pathLength uint, path string, pathReversed string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.guint      // in
	var _arg2 *C.gchar     // in
	var _arg3 *C.gchar     // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_class_path(_arg0, &_arg1, &_arg2, &_arg3)

	var _pathLength uint     // out
	var _path string         // out
	var _pathReversed string // out

	_pathLength = (uint)(_arg1)
	_path = C.GoString(_arg2)
	defer C.free(unsafe.Pointer(_arg2))
	_pathReversed = C.GoString(_arg3)
	defer C.free(unsafe.Pointer(_arg3))

	return _pathLength, _path, _pathReversed
}

// ComputeExpand computes whether a container should give this widget extra
// space when possible. Containers should check this, rather than looking at
// gtk_widget_get_hexpand() or gtk_widget_get_vexpand().
//
// This function already checks whether the widget is visible, so visibility
// does not need to be checked separately. Non-visible widgets are not expanded.
//
// The computed expand value uses either the expand setting explicitly set on
// the widget itself, or, if none has been explicitly set, the widget may expand
// if some of its children do.
func (w widget) ComputeExpand(orientation Orientation) bool {
	var _arg0 *C.GtkWidget     // out
	var _arg1 C.GtkOrientation // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GtkOrientation)(orientation)

	_cret = C.gtk_widget_compute_expand(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CreatePangoContext creates a new Context with the appropriate font map, font
// options, font description, and base direction for drawing text for this
// widget. See also gtk_widget_get_pango_context().
func (w widget) CreatePangoContext() pango.Context {
	var _arg0 *C.GtkWidget    // out
	var _cret *C.PangoContext // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_create_pango_context(_arg0)

	var _context pango.Context // out

	_context = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(pango.Context)

	return _context
}

// CreatePangoLayout creates a new Layout with the appropriate font map, font
// description, and base direction for drawing text for this widget.
//
// If you keep a Layout created in this way around, you need to re-create it
// when the widget Context is replaced. This can be tracked by using the
// Widget::screen-changed signal on the widget.
func (w widget) CreatePangoLayout(text string) pango.Layout {
	var _arg0 *C.GtkWidget   // out
	var _arg1 *C.gchar       // out
	var _cret *C.PangoLayout // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_widget_create_pango_layout(_arg0, _arg1)

	var _layout pango.Layout // out

	_layout = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(pango.Layout)

	return _layout
}

// Destroy destroys a widget.
//
// When a widget is destroyed all references it holds on other objects will be
// released:
//
//    - if the widget is inside a container, it will be removed from its
//    parent
//    - if the widget is a container, all its children will be destroyed,
//    recursively
//    - if the widget is a top level, it will be removed from the list
//    of top level widgets that GTK+ maintains internally
//
// It's expected that all references held on the widget will also be released;
// you should connect to the Widget::destroy signal if you hold a reference to
// @widget and you wish to remove it when this function is called. It is not
// necessary to do so if you are implementing a Container, as you'll be able to
// use the ContainerClass.remove() virtual function for that.
//
// It's important to notice that gtk_widget_destroy() will only cause the
// @widget to be finalized if no additional references, acquired using
// g_object_ref(), are held on it. In case additional references are in place,
// the @widget will be in an "inert" state after calling this function; @widget
// will still point to valid memory, allowing you to release the references you
// hold, but you may not query the widget's own state.
//
// You should typically call this function on top level widgets, and rarely on
// child widgets.
//
// See also: gtk_container_remove()
func (w widget) Destroy() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_destroy(_arg0)
}

// DeviceIsShadowed returns true if @device has been shadowed by a GTK+ device
// grab on another widget, so it would stop sending events to @widget. This may
// be used in the Widget::grab-notify signal to check for specific devices. See
// gtk_device_grab_add().
func (w widget) DeviceIsShadowed(device gdk.Device) bool {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GdkDevice // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))

	_cret = C.gtk_widget_device_is_shadowed(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DragCheckThreshold checks to see if a mouse drag starting at (@start_x,
// @start_y) and ending at (@current_x, @current_y) has passed the GTK+ drag
// threshold, and thus should trigger the beginning of a drag-and-drop
// operation.
func (w widget) DragCheckThreshold(startX int, startY int, currentX int, currentY int) bool {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // out
	var _arg3 C.gint       // out
	var _arg4 C.gint       // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.gint)(startX)
	_arg2 = (C.gint)(startY)
	_arg3 = (C.gint)(currentX)
	_arg4 = (C.gint)(currentY)

	_cret = C.gtk_drag_check_threshold(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DragDestAddImageTargets: add the image targets supported by SelectionData to
// the target list of the drag destination. The targets are added with @info =
// 0. If you need another value, use gtk_target_list_add_image_targets() and
// gtk_drag_dest_set_target_list().
func (w widget) DragDestAddImageTargets() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_drag_dest_add_image_targets(_arg0)
}

// DragDestAddTextTargets: add the text targets supported by SelectionData to
// the target list of the drag destination. The targets are added with @info =
// 0. If you need another value, use gtk_target_list_add_text_targets() and
// gtk_drag_dest_set_target_list().
func (w widget) DragDestAddTextTargets() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_drag_dest_add_text_targets(_arg0)
}

// DragDestAddURITargets: add the URI targets supported by SelectionData to the
// target list of the drag destination. The targets are added with @info = 0. If
// you need another value, use gtk_target_list_add_uri_targets() and
// gtk_drag_dest_set_target_list().
func (w widget) DragDestAddURITargets() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_drag_dest_add_uri_targets(_arg0)
}

// DragDestFindTarget looks for a match between the supported targets of
// @context and the @dest_target_list, returning the first matching target,
// otherwise returning GDK_NONE. @dest_target_list should usually be the return
// value from gtk_drag_dest_get_target_list(), but some widgets may have
// different valid targets for different parts of the widget; in that case, they
// will have to implement a drag_motion handler that passes the correct target
// list to this function.
func (w widget) DragDestFindTarget(context gdk.DragContext, targetList *TargetList) *gdk.Atom {
	var _arg0 *C.GtkWidget      // out
	var _arg1 *C.GdkDragContext // out
	var _arg2 *C.GtkTargetList  // out
	var _cret C.GdkAtom         // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.GtkTargetList)(unsafe.Pointer(targetList.Native()))

	_cret = C.gtk_drag_dest_find_target(_arg0, _arg1, _arg2)

	var _atom *gdk.Atom // out

	_atom = gdk.WrapAtom(unsafe.Pointer(_cret))

	return _atom
}

// DragDestGetTargetList returns the list of targets this widget can accept from
// drag-and-drop.
func (w widget) DragDestGetTargetList() *TargetList {
	var _arg0 *C.GtkWidget     // out
	var _cret *C.GtkTargetList // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_drag_dest_get_target_list(_arg0)

	var _targetList *TargetList // out

	_targetList = WrapTargetList(unsafe.Pointer(_cret))

	return _targetList
}

// DragDestGetTrackMotion returns whether the widget has been configured to
// always emit Widget::drag-motion signals.
func (w widget) DragDestGetTrackMotion() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_drag_dest_get_track_motion(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DragDestSet sets a widget as a potential drop destination, and adds default
// behaviors.
//
// The default behaviors listed in @flags have an effect similar to installing
// default handlers for the widget’s drag-and-drop signals (Widget::drag-motion,
// Widget::drag-drop, ...). They all exist for convenience. When passing
// K_DEST_DEFAULT_ALL for instance it is sufficient to connect to the widget’s
// Widget::drag-data-received signal to get primitive, but consistent
// drag-and-drop support.
//
// Things become more complicated when you try to preview the dragged data, as
// described in the documentation for Widget::drag-motion. The default behaviors
// described by @flags make some assumptions, that can conflict with your own
// signal handlers. For instance K_DEST_DEFAULT_DROP causes invokations of
// gdk_drag_status() in the context of Widget::drag-motion, and invokations of
// gtk_drag_finish() in Widget::drag-data-received. Especially the later is
// dramatic, when your own Widget::drag-motion handler calls gtk_drag_get_data()
// to inspect the dragged data.
//
// There’s no way to set a default action here, you can use the
// Widget::drag-motion callback for that. Here’s an example which selects the
// action to use depending on whether the control key is pressed or not:
//
//    static void
//    drag_motion (GtkWidget *widget,
//                 GdkDragContext *context,
//                 gint x,
//                 gint y,
//                 guint time)
//    {
//      GdkModifierType mask;
//
//      gdk_window_get_pointer (gtk_widget_get_window (widget),
//                              NULL, NULL, &mask);
//      if (mask & GDK_CONTROL_MASK)
//        gdk_drag_status (context, GDK_ACTION_COPY, time);
//      else
//        gdk_drag_status (context, GDK_ACTION_MOVE, time);
//    }
func (w widget) DragDestSet(flags DestDefaults, targets []TargetEntry, actions gdk.DragAction) {
	var _arg0 *C.GtkWidget      // out
	var _arg1 C.GtkDestDefaults // out
	var _arg2 *C.GtkTargetEntry
	var _arg3 C.gint
	var _arg4 C.GdkDragAction // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GtkDestDefaults)(flags)
	_arg3 = C.gint(len(targets))
	_arg2 = (*C.GtkTargetEntry)(unsafe.Pointer(&targets[0]))
	_arg4 = (C.GdkDragAction)(actions)

	C.gtk_drag_dest_set(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// DragDestSetProXY sets this widget as a proxy for drops to another window.
func (w widget) DragDestSetProXY(proxyWindow gdk.Window, protocol gdk.DragProtocol, useCoordinates bool) {
	var _arg0 *C.GtkWidget      // out
	var _arg1 *C.GdkWindow      // out
	var _arg2 C.GdkDragProtocol // out
	var _arg3 C.gboolean        // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GdkWindow)(unsafe.Pointer(proxyWindow.Native()))
	_arg2 = (C.GdkDragProtocol)(protocol)
	if useCoordinates {
		_arg3 = C.TRUE
	}

	C.gtk_drag_dest_set_proxy(_arg0, _arg1, _arg2, _arg3)
}

// DragDestSetTargetList sets the target types that this widget can accept from
// drag-and-drop. The widget must first be made into a drag destination with
// gtk_drag_dest_set().
func (w widget) DragDestSetTargetList(targetList *TargetList) {
	var _arg0 *C.GtkWidget     // out
	var _arg1 *C.GtkTargetList // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkTargetList)(unsafe.Pointer(targetList.Native()))

	C.gtk_drag_dest_set_target_list(_arg0, _arg1)
}

// DragDestSetTrackMotion tells the widget to emit Widget::drag-motion and
// Widget::drag-leave events regardless of the targets and the
// GTK_DEST_DEFAULT_MOTION flag.
//
// This may be used when a widget wants to do generic actions regardless of the
// targets that the source offers.
func (w widget) DragDestSetTrackMotion(trackMotion bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if trackMotion {
		_arg1 = C.TRUE
	}

	C.gtk_drag_dest_set_track_motion(_arg0, _arg1)
}

// DragDestUnset clears information about a drop destination set with
// gtk_drag_dest_set(). The widget will no longer receive notification of drags.
func (w widget) DragDestUnset() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_drag_dest_unset(_arg0)
}

// DragGetData gets the data associated with a drag. When the data is received
// or the retrieval fails, GTK+ will emit a Widget::drag-data-received signal.
// Failure of the retrieval is indicated by the length field of the
// @selection_data signal parameter being negative. However, when
// gtk_drag_get_data() is called implicitely because the GTK_DEST_DEFAULT_DROP
// was set, then the widget will not receive notification of failed drops.
func (w widget) DragGetData(context gdk.DragContext, target *gdk.Atom, time_ uint32) {
	var _arg0 *C.GtkWidget      // out
	var _arg1 *C.GdkDragContext // out
	var _arg2 C.GdkAtom         // out
	var _arg3 C.guint32         // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))
	_arg2 = (C.GdkAtom)(unsafe.Pointer(target.Native()))
	_arg3 = (C.guint32)(time_)

	C.gtk_drag_get_data(_arg0, _arg1, _arg2, _arg3)
}

// DragHighlight highlights a widget as a currently hovered drop target. To end
// the highlight, call gtk_drag_unhighlight(). GTK+ calls this automatically if
// GTK_DEST_DEFAULT_HIGHLIGHT is set.
func (w widget) DragHighlight() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_drag_highlight(_arg0)
}

// DragSourceAddImageTargets: add the writable image targets supported by
// SelectionData to the target list of the drag source. The targets are added
// with @info = 0. If you need another value, use
// gtk_target_list_add_image_targets() and gtk_drag_source_set_target_list().
func (w widget) DragSourceAddImageTargets() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_drag_source_add_image_targets(_arg0)
}

// DragSourceAddTextTargets: add the text targets supported by SelectionData to
// the target list of the drag source. The targets are added with @info = 0. If
// you need another value, use gtk_target_list_add_text_targets() and
// gtk_drag_source_set_target_list().
func (w widget) DragSourceAddTextTargets() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_drag_source_add_text_targets(_arg0)
}

// DragSourceAddURITargets: add the URI targets supported by SelectionData to
// the target list of the drag source. The targets are added with @info = 0. If
// you need another value, use gtk_target_list_add_uri_targets() and
// gtk_drag_source_set_target_list().
func (w widget) DragSourceAddURITargets() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_drag_source_add_uri_targets(_arg0)
}

// DragSourceGetTargetList gets the list of targets this widget can provide for
// drag-and-drop.
func (w widget) DragSourceGetTargetList() *TargetList {
	var _arg0 *C.GtkWidget     // out
	var _cret *C.GtkTargetList // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_drag_source_get_target_list(_arg0)

	var _targetList *TargetList // out

	_targetList = WrapTargetList(unsafe.Pointer(_cret))

	return _targetList
}

// DragSourceSet sets up a widget so that GTK+ will start a drag operation when
// the user clicks and drags on the widget. The widget must have a window.
func (w widget) DragSourceSet(startButtonMask gdk.ModifierType, targets []TargetEntry, actions gdk.DragAction) {
	var _arg0 *C.GtkWidget      // out
	var _arg1 C.GdkModifierType // out
	var _arg2 *C.GtkTargetEntry
	var _arg3 C.gint
	var _arg4 C.GdkDragAction // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GdkModifierType)(startButtonMask)
	_arg3 = C.gint(len(targets))
	_arg2 = (*C.GtkTargetEntry)(unsafe.Pointer(&targets[0]))
	_arg4 = (C.GdkDragAction)(actions)

	C.gtk_drag_source_set(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// DragSourceSetIconGIcon sets the icon that will be used for drags from a
// particular source to @icon. See the docs for IconTheme for more details.
func (w widget) DragSourceSetIconGIcon(icon gio.Icon) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GIcon     // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

	C.gtk_drag_source_set_icon_gicon(_arg0, _arg1)
}

// DragSourceSetIconName sets the icon that will be used for drags from a
// particular source to a themed icon. See the docs for IconTheme for more
// details.
func (w widget) DragSourceSetIconName(iconName string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_drag_source_set_icon_name(_arg0, _arg1)
}

// DragSourceSetIconPixbuf sets the icon that will be used for drags from a
// particular widget from a Pixbuf. GTK+ retains a reference for @pixbuf and
// will release it when it is no longer needed.
func (w widget) DragSourceSetIconPixbuf(pixbuf gdkpixbuf.Pixbuf) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GdkPixbuf // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	C.gtk_drag_source_set_icon_pixbuf(_arg0, _arg1)
}

// DragSourceSetIconStock sets the icon that will be used for drags from a
// particular source to a stock icon.
func (w widget) DragSourceSetIconStock(stockId string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.gchar)(C.CString(stockId))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_drag_source_set_icon_stock(_arg0, _arg1)
}

// DragSourceSetTargetList changes the target types that this widget offers for
// drag-and-drop. The widget must first be made into a drag source with
// gtk_drag_source_set().
func (w widget) DragSourceSetTargetList(targetList *TargetList) {
	var _arg0 *C.GtkWidget     // out
	var _arg1 *C.GtkTargetList // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkTargetList)(unsafe.Pointer(targetList.Native()))

	C.gtk_drag_source_set_target_list(_arg0, _arg1)
}

// DragSourceUnset undoes the effects of gtk_drag_source_set().
func (w widget) DragSourceUnset() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_drag_source_unset(_arg0)
}

// DragUnhighlight removes a highlight set by gtk_drag_highlight() from a
// widget.
func (w widget) DragUnhighlight() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_drag_unhighlight(_arg0)
}

// Draw draws @widget to @cr. The top left corner of the widget will be drawn to
// the currently set origin point of @cr.
//
// You should pass a cairo context as @cr argument that is in an original state.
// Otherwise the resulting drawing is undefined. For example changing the
// operator using cairo_set_operator() or the line width using
// cairo_set_line_width() might have unwanted side effects. You may however
// change the context’s transform matrix - like with cairo_scale(),
// cairo_translate() or cairo_set_matrix() and clip region with cairo_clip()
// prior to calling this function. Also, it is fine to modify the context with
// cairo_save() and cairo_push_group() prior to calling this function.
//
// Note that special-purpose widgets may contain special code for rendering to
// the screen and might appear differently on screen and when rendered using
// gtk_widget_draw().
func (w widget) Draw(cr *cairo.Context) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.cairo_t   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))

	C.gtk_widget_draw(_arg0, _arg1)
}

// EnsureStyle ensures that @widget has a style (@widget->style).
//
// Not a very useful function; most of the time, if you want the style, the
// widget is realized, and realized widgets are guaranteed to have a style
// already.
func (w widget) EnsureStyle() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_ensure_style(_arg0)
}

// ErrorBell notifies the user about an input-related error on this widget. If
// the Settings:gtk-error-bell setting is true, it calls gdk_window_beep(),
// otherwise it does nothing.
//
// Note that the effect of gdk_window_beep() can be configured in many ways,
// depending on the windowing backend and the desktop environment or window
// manager that is used.
func (w widget) ErrorBell() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_error_bell(_arg0)
}

// FreezeChildNotify stops emission of Widget::child-notify signals on @widget.
// The signals are queued until gtk_widget_thaw_child_notify() is called on
// @widget.
//
// This is the analogue of g_object_freeze_notify() for child properties.
func (w widget) FreezeChildNotify() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_freeze_child_notify(_arg0)
}

// ActionGroup retrieves the Group that was registered using @prefix. The
// resulting Group may have been registered to @widget or any Widget in its
// ancestry.
//
// If no action group was found matching @prefix, then nil is returned.
func (w widget) ActionGroup(prefix string) gio.ActionGroup {
	var _arg0 *C.GtkWidget    // out
	var _arg1 *C.gchar        // out
	var _cret *C.GActionGroup // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.gchar)(C.CString(prefix))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_widget_get_action_group(_arg0, _arg1)

	var _actionGroup gio.ActionGroup // out

	_actionGroup = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.ActionGroup)

	return _actionGroup
}

// AllocatedBaseline returns the baseline that has currently been allocated to
// @widget. This function is intended to be used when implementing handlers for
// the Widget::draw function, and when allocating child widgets in
// Widget::size_allocate.
func (w widget) AllocatedBaseline() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_allocated_baseline(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// AllocatedHeight returns the height that has currently been allocated to
// @widget. This function is intended to be used when implementing handlers for
// the Widget::draw function.
func (w widget) AllocatedHeight() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_allocated_height(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// AllocatedWidth returns the width that has currently been allocated to
// @widget. This function is intended to be used when implementing handlers for
// the Widget::draw function.
func (w widget) AllocatedWidth() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_allocated_width(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Ancestor gets the first ancestor of @widget with type @widget_type. For
// example, `gtk_widget_get_ancestor (widget, GTK_TYPE_BOX)` gets the first Box
// that’s an ancestor of @widget. No reference will be added to the returned
// widget; it should not be unreferenced. See note about checking for a toplevel
// Window in the docs for gtk_widget_get_toplevel().
//
// Note that unlike gtk_widget_is_ancestor(), gtk_widget_get_ancestor()
// considers @widget to be an ancestor of itself.
func (w widget) Ancestor(widgetType externglib.Type) Widget {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.GType      // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = C.GType(widgetType)

	_cret = C.gtk_widget_get_ancestor(_arg0, _arg1)

	var _ret Widget // out

	_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _ret
}

// AppPaintable determines whether the application intends to draw on the widget
// in an Widget::draw handler.
//
// See gtk_widget_set_app_paintable()
func (w widget) AppPaintable() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_app_paintable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanDefault determines whether @widget can be a default widget. See
// gtk_widget_set_can_default().
func (w widget) CanDefault() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_can_default(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanFocus determines whether @widget can own the input focus. See
// gtk_widget_set_can_focus().
func (w widget) CanFocus() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_can_focus(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ChildRequisition: this function is only for use in widget implementations.
// Obtains @widget->requisition, unless someone has forced a particular geometry
// on the widget (e.g. with gtk_widget_set_size_request()), in which case it
// returns that geometry instead of the widget's requisition.
//
// This function differs from gtk_widget_size_request() in that it retrieves the
// last size request value from @widget->requisition, while
// gtk_widget_size_request() actually calls the "size_request" method on @widget
// to compute the size request and fill in @widget->requisition, and only then
// returns @widget->requisition.
//
// Because this function does not call the “size_request” method, it can only be
// used when you know that @widget->requisition is up-to-date, that is,
// gtk_widget_size_request() has been called since the last time a resize was
// queued. In general, only container implementations have this information;
// applications should use gtk_widget_size_request().
func (w widget) ChildRequisition() Requisition {
	var _arg0 *C.GtkWidget // out
	var _requisition Requisition

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_child_requisition(_arg0, (*C.GtkRequisition)(unsafe.Pointer(&_requisition)))

	return _requisition
}

// ChildVisible gets the value set with gtk_widget_set_child_visible(). If you
// feel a need to use this function, your code probably needs reorganization.
//
// This function is only useful for container implementations and never should
// be called by an application.
func (w widget) ChildVisible() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_child_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Clipboard returns the clipboard object for the given selection to be used
// with @widget. @widget must have a Display associated with it, so must be
// attached to a toplevel window.
func (w widget) Clipboard(selection *gdk.Atom) Clipboard {
	var _arg0 *C.GtkWidget    // out
	var _arg1 C.GdkAtom       // out
	var _cret *C.GtkClipboard // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GdkAtom)(unsafe.Pointer(selection.Native()))

	_cret = C.gtk_widget_get_clipboard(_arg0, _arg1)

	var _clipboard Clipboard // out

	_clipboard = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Clipboard)

	return _clipboard
}

// CompositeName obtains the composite name of a widget.
func (w widget) CompositeName() string {
	var _arg0 *C.GtkWidget // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_composite_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// DeviceEnabled returns whether @device can interact with @widget and its
// children. See gtk_widget_set_device_enabled().
func (w widget) DeviceEnabled(device gdk.Device) bool {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GdkDevice // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))

	_cret = C.gtk_widget_get_device_enabled(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DeviceEvents returns the events mask for the widget corresponding to an
// specific device. These are the events that the widget will receive when
// @device operates on it.
func (w widget) DeviceEvents(device gdk.Device) gdk.EventMask {
	var _arg0 *C.GtkWidget   // out
	var _arg1 *C.GdkDevice   // out
	var _cret C.GdkEventMask // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))

	_cret = C.gtk_widget_get_device_events(_arg0, _arg1)

	var _eventMask gdk.EventMask // out

	_eventMask = gdk.EventMask(_cret)

	return _eventMask
}

// Direction gets the reading direction for a particular widget. See
// gtk_widget_set_direction().
func (w widget) Direction() TextDirection {
	var _arg0 *C.GtkWidget       // out
	var _cret C.GtkTextDirection // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_direction(_arg0)

	var _textDirection TextDirection // out

	_textDirection = TextDirection(_cret)

	return _textDirection
}

// Display: get the Display for the toplevel window associated with this widget.
// This function can only be called after the widget has been added to a widget
// hierarchy with a Window at the top.
//
// In general, you should only create display specific resources when a widget
// has been realized, and you should free those resources when the widget is
// unrealized.
func (w widget) Display() gdk.Display {
	var _arg0 *C.GtkWidget  // out
	var _cret *C.GdkDisplay // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_display(_arg0)

	var _display gdk.Display // out

	_display = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Display)

	return _display
}

// DoubleBuffered determines whether the widget is double buffered.
//
// See gtk_widget_set_double_buffered()
func (w widget) DoubleBuffered() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_double_buffered(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Events returns the event mask (see EventMask) for the widget. These are the
// events that the widget will receive.
//
// Note: Internally, the widget event mask will be the logical OR of the event
// mask set through gtk_widget_set_events() or gtk_widget_add_events(), and the
// event mask necessary to cater for every EventController created for the
// widget.
func (w widget) Events() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_events(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// FocusOnClick returns whether the widget should grab focus when it is clicked
// with the mouse. See gtk_widget_set_focus_on_click().
func (w widget) FocusOnClick() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_focus_on_click(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FontMap gets the font map that has been set with gtk_widget_set_font_map().
func (w widget) FontMap() pango.FontMap {
	var _arg0 *C.GtkWidget    // out
	var _cret *C.PangoFontMap // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_font_map(_arg0)

	var _fontMap pango.FontMap // out

	_fontMap = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(pango.FontMap)

	return _fontMap
}

// FontOptions returns the #cairo_font_options_t used for Pango rendering. When
// not set, the defaults font options for the Screen will be used.
func (w widget) FontOptions() *cairo.FontOptions {
	var _arg0 *C.GtkWidget            // out
	var _cret *C.cairo_font_options_t // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_font_options(_arg0)

	var _fontOptions *cairo.FontOptions // out

	_fontOptions = cairo.WrapFontOptions(unsafe.Pointer(_cret))

	return _fontOptions
}

// FrameClock obtains the frame clock for a widget. The frame clock is a global
// “ticker” that can be used to drive animations and repaints. The most common
// reason to get the frame clock is to call gdk_frame_clock_get_frame_time(), in
// order to get a time to use for animating. For example you might record the
// start of the animation with an initial value from
// gdk_frame_clock_get_frame_time(), and then update the animation by calling
// gdk_frame_clock_get_frame_time() again during each repaint.
//
// gdk_frame_clock_request_phase() will result in a new frame on the clock, but
// won’t necessarily repaint any widgets. To repaint a widget, you have to use
// gtk_widget_queue_draw() which invalidates the widget (thus scheduling it to
// receive a draw on the next frame). gtk_widget_queue_draw() will also end up
// requesting a frame on the appropriate frame clock.
//
// A widget’s frame clock will not change while the widget is mapped.
// Reparenting a widget (which implies a temporary unmap) can change the
// widget’s frame clock.
//
// Unrealized widgets do not have a frame clock.
func (w widget) FrameClock() gdk.FrameClock {
	var _arg0 *C.GtkWidget     // out
	var _cret *C.GdkFrameClock // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_frame_clock(_arg0)

	var _frameClock gdk.FrameClock // out

	_frameClock = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.FrameClock)

	return _frameClock
}

// Halign gets the value of the Widget:halign property.
//
// For backwards compatibility reasons this method will never return
// GTK_ALIGN_BASELINE, but instead it will convert it to GTK_ALIGN_FILL.
// Baselines are not supported for horizontal alignment.
func (w widget) Halign() Align {
	var _arg0 *C.GtkWidget // out
	var _cret C.GtkAlign   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_halign(_arg0)

	var _align Align // out

	_align = Align(_cret)

	return _align
}

// HasTooltip returns the current value of the has-tooltip property. See
// Widget:has-tooltip for more information.
func (w widget) HasTooltip() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_has_tooltip(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasWindow determines whether @widget has a Window of its own. See
// gtk_widget_set_has_window().
func (w widget) HasWindow() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_has_window(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Hexpand gets whether the widget would like any available extra horizontal
// space. When a user resizes a Window, widgets with expand=TRUE generally
// receive the extra space. For example, a list or scrollable area or document
// in your window would often be set to expand.
//
// Containers should use gtk_widget_compute_expand() rather than this function,
// to see whether a widget, or any of its children, has the expand flag set. If
// any child of a widget wants to expand, the parent may ask to expand also.
//
// This function only looks at the widget’s own hexpand flag, rather than
// computing whether the entire widget tree rooted at this widget wants to
// expand.
func (w widget) Hexpand() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_hexpand(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HexpandSet gets whether gtk_widget_set_hexpand() has been used to explicitly
// set the expand flag on this widget.
//
// If hexpand is set, then it overrides any computed expand value based on child
// widgets. If hexpand is not set, then the expand value depends on whether any
// children of the widget would like to expand.
//
// There are few reasons to use this function, but it’s here for completeness
// and consistency.
func (w widget) HexpandSet() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_hexpand_set(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Mapped: whether the widget is mapped.
func (w widget) Mapped() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_mapped(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MarginBottom gets the value of the Widget:margin-bottom property.
func (w widget) MarginBottom() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_margin_bottom(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// MarginEnd gets the value of the Widget:margin-end property.
func (w widget) MarginEnd() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_margin_end(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// MarginLeft gets the value of the Widget:margin-left property.
func (w widget) MarginLeft() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_margin_left(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// MarginRight gets the value of the Widget:margin-right property.
func (w widget) MarginRight() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_margin_right(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// MarginStart gets the value of the Widget:margin-start property.
func (w widget) MarginStart() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_margin_start(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// MarginTop gets the value of the Widget:margin-top property.
func (w widget) MarginTop() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_margin_top(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// ModifierMask returns the modifier mask the @widget’s windowing system backend
// uses for a particular purpose.
//
// See gdk_keymap_get_modifier_mask().
func (w widget) ModifierMask(intent gdk.ModifierIntent) gdk.ModifierType {
	var _arg0 *C.GtkWidget        // out
	var _arg1 C.GdkModifierIntent // out
	var _cret C.GdkModifierType   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GdkModifierIntent)(intent)

	_cret = C.gtk_widget_get_modifier_mask(_arg0, _arg1)

	var _modifierType gdk.ModifierType // out

	_modifierType = gdk.ModifierType(_cret)

	return _modifierType
}

// ModifierStyle returns the current modifier style for the widget. (As set by
// gtk_widget_modify_style().) If no style has previously set, a new RcStyle
// will be created with all values unset, and set as the modifier style for the
// widget. If you make changes to this rc style, you must call
// gtk_widget_modify_style(), passing in the returned rc style, to make sure
// that your changes take effect.
//
// Caution: passing the style back to gtk_widget_modify_style() will normally
// end up destroying it, because gtk_widget_modify_style() copies the passed-in
// style and sets the copy as the new modifier style, thus dropping any
// reference to the old modifier style. Add a reference to the modifier style if
// you want to keep it alive.
func (w widget) ModifierStyle() RCStyle {
	var _arg0 *C.GtkWidget  // out
	var _cret *C.GtkRcStyle // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_modifier_style(_arg0)

	var _rcStyle RCStyle // out

	_rcStyle = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RCStyle)

	return _rcStyle
}

// Name retrieves the name of a widget. See gtk_widget_set_name() for the
// significance of widget names.
func (w widget) Name() string {
	var _arg0 *C.GtkWidget // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// NoShowAll returns the current value of the Widget:no-show-all property, which
// determines whether calls to gtk_widget_show_all() will affect this widget.
func (w widget) NoShowAll() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_no_show_all(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Opacity fetches the requested opacity for this widget. See
// gtk_widget_set_opacity().
func (w widget) Opacity() float64 {
	var _arg0 *C.GtkWidget // out
	var _cret C.double     // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_opacity(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// PangoContext gets a Context with the appropriate font map, font description,
// and base direction for this widget. Unlike the context returned by
// gtk_widget_create_pango_context(), this context is owned by the widget (it
// can be used until the screen for the widget changes or the widget is removed
// from its toplevel), and will be updated to match any changes to the widget’s
// attributes. This can be tracked by using the Widget::screen-changed signal on
// the widget.
func (w widget) PangoContext() pango.Context {
	var _arg0 *C.GtkWidget    // out
	var _cret *C.PangoContext // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_pango_context(_arg0)

	var _context pango.Context // out

	_context = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(pango.Context)

	return _context
}

// Parent returns the parent container of @widget.
func (w widget) Parent() Widget {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_parent(_arg0)

	var _ret Widget // out

	_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _ret
}

// ParentWindow gets @widget’s parent window, or nil if it does not have one.
func (w widget) ParentWindow() gdk.Window {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GdkWindow // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_parent_window(_arg0)

	var _window gdk.Window // out

	_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Window)

	return _window
}

// GetPath returns the WidgetPath representing @widget, if the widget is not
// connected to a toplevel widget, a partial path will be created.
func (w widget) GetPath() *WidgetPath {
	var _arg0 *C.GtkWidget     // out
	var _cret *C.GtkWidgetPath // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_path(_arg0)

	var _widgetPath *WidgetPath // out

	_widgetPath = WrapWidgetPath(unsafe.Pointer(_cret))

	return _widgetPath
}

// Pointer obtains the location of the mouse pointer in widget coordinates.
// Widget coordinates are a bit odd; for historical reasons, they are defined as
// @widget->window coordinates for widgets that return true for
// gtk_widget_get_has_window(); and are relative to @widget->allocation.x,
// @widget->allocation.y otherwise.
func (w widget) Pointer() (x int, y int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // in
	var _arg2 C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_pointer(_arg0, &_arg1, &_arg2)

	var _x int // out
	var _y int // out

	_x = (int)(_arg1)
	_y = (int)(_arg2)

	return _x, _y
}

// PreferredHeight retrieves a widget’s initial minimum and natural height.
//
// This call is specific to width-for-height requests.
//
// The returned request will be modified by the
// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups that
// have been applied. That is, the returned request is the one that should be
// used for layout, not necessarily the one returned by the widget itself.
func (w widget) PreferredHeight() (minimumHeight int, naturalHeight int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // in
	var _arg2 C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_preferred_height(_arg0, &_arg1, &_arg2)

	var _minimumHeight int // out
	var _naturalHeight int // out

	_minimumHeight = (int)(_arg1)
	_naturalHeight = (int)(_arg2)

	return _minimumHeight, _naturalHeight
}

// PreferredHeightAndBaselineForWidth retrieves a widget’s minimum and natural
// height and the corresponding baselines if it would be given the specified
// @width, or the default height if @width is -1. The baselines may be -1 which
// means that no baseline is requested for this widget.
//
// The returned request will be modified by the
// GtkWidgetClass::adjust_size_request and
// GtkWidgetClass::adjust_baseline_request virtual methods and by any SizeGroups
// that have been applied. That is, the returned request is the one that should
// be used for layout, not necessarily the one returned by the widget itself.
func (w widget) PreferredHeightAndBaselineForWidth(width int) (minimumHeight int, naturalHeight int, minimumBaseline int, naturalBaseline int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // in
	var _arg3 C.gint       // in
	var _arg4 C.gint       // in
	var _arg5 C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.gint)(width)

	C.gtk_widget_get_preferred_height_and_baseline_for_width(_arg0, _arg1, &_arg2, &_arg3, &_arg4, &_arg5)

	var _minimumHeight int   // out
	var _naturalHeight int   // out
	var _minimumBaseline int // out
	var _naturalBaseline int // out

	_minimumHeight = (int)(_arg2)
	_naturalHeight = (int)(_arg3)
	_minimumBaseline = (int)(_arg4)
	_naturalBaseline = (int)(_arg5)

	return _minimumHeight, _naturalHeight, _minimumBaseline, _naturalBaseline
}

// PreferredHeightForWidth retrieves a widget’s minimum and natural height if it
// would be given the specified @width.
//
// The returned request will be modified by the
// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups that
// have been applied. That is, the returned request is the one that should be
// used for layout, not necessarily the one returned by the widget itself.
func (w widget) PreferredHeightForWidth(width int) (minimumHeight int, naturalHeight int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // in
	var _arg3 C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.gint)(width)

	C.gtk_widget_get_preferred_height_for_width(_arg0, _arg1, &_arg2, &_arg3)

	var _minimumHeight int // out
	var _naturalHeight int // out

	_minimumHeight = (int)(_arg2)
	_naturalHeight = (int)(_arg3)

	return _minimumHeight, _naturalHeight
}

// PreferredSize retrieves the minimum and natural size of a widget, taking into
// account the widget’s preference for height-for-width management.
//
// This is used to retrieve a suitable size by container widgets which do not
// impose any restrictions on the child placement. It can be used to deduce
// toplevel window and menu sizes as well as child widgets in free-form
// containers such as GtkLayout.
//
// Handle with care. Note that the natural height of a height-for-width widget
// will generally be a smaller size than the minimum height, since the required
// height for the natural width is generally smaller than the required height
// for the minimum width.
//
// Use gtk_widget_get_preferred_height_and_baseline_for_width() if you want to
// support baseline alignment.
func (w widget) PreferredSize() (minimumSize Requisition, naturalSize Requisition) {
	var _arg0 *C.GtkWidget // out
	var _minimumSize Requisition
	var _naturalSize Requisition

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_preferred_size(_arg0, (*C.GtkRequisition)(unsafe.Pointer(&_minimumSize)), (*C.GtkRequisition)(unsafe.Pointer(&_naturalSize)))

	return _minimumSize, _naturalSize
}

// PreferredWidth retrieves a widget’s initial minimum and natural width.
//
// This call is specific to height-for-width requests.
//
// The returned request will be modified by the
// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups that
// have been applied. That is, the returned request is the one that should be
// used for layout, not necessarily the one returned by the widget itself.
func (w widget) PreferredWidth() (minimumWidth int, naturalWidth int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // in
	var _arg2 C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_preferred_width(_arg0, &_arg1, &_arg2)

	var _minimumWidth int // out
	var _naturalWidth int // out

	_minimumWidth = (int)(_arg1)
	_naturalWidth = (int)(_arg2)

	return _minimumWidth, _naturalWidth
}

// PreferredWidthForHeight retrieves a widget’s minimum and natural width if it
// would be given the specified @height.
//
// The returned request will be modified by the
// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups that
// have been applied. That is, the returned request is the one that should be
// used for layout, not necessarily the one returned by the widget itself.
func (w widget) PreferredWidthForHeight(height int) (minimumWidth int, naturalWidth int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // in
	var _arg3 C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.gint)(height)

	C.gtk_widget_get_preferred_width_for_height(_arg0, _arg1, &_arg2, &_arg3)

	var _minimumWidth int // out
	var _naturalWidth int // out

	_minimumWidth = (int)(_arg2)
	_naturalWidth = (int)(_arg3)

	return _minimumWidth, _naturalWidth
}

// Realized determines whether @widget is realized.
func (w widget) Realized() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_realized(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ReceivesDefault determines whether @widget is always treated as the default
// widget within its toplevel when it has the focus, even if another widget is
// the default.
//
// See gtk_widget_set_receives_default().
func (w widget) ReceivesDefault() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_receives_default(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RequestMode gets whether the widget prefers a height-for-width layout or a
// width-for-height layout.
//
// Bin widgets generally propagate the preference of their child, container
// widgets need to request something either in context of their children or in
// context of their allocation capabilities.
func (w widget) RequestMode() SizeRequestMode {
	var _arg0 *C.GtkWidget         // out
	var _cret C.GtkSizeRequestMode // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_request_mode(_arg0)

	var _sizeRequestMode SizeRequestMode // out

	_sizeRequestMode = SizeRequestMode(_cret)

	return _sizeRequestMode
}

// Requisition retrieves the widget’s requisition.
//
// This function should only be used by widget implementations in order to
// figure whether the widget’s requisition has actually changed after some
// internal state change (so that they can call gtk_widget_queue_resize()
// instead of gtk_widget_queue_draw()).
//
// Normally, gtk_widget_size_request() should be used.
func (w widget) Requisition() Requisition {
	var _arg0 *C.GtkWidget // out
	var _requisition Requisition

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_requisition(_arg0, (*C.GtkRequisition)(unsafe.Pointer(&_requisition)))

	return _requisition
}

// RootWindow: get the root window where this widget is located. This function
// can only be called after the widget has been added to a widget hierarchy with
// Window at the top.
//
// The root window is useful for such purposes as creating a popup Window
// associated with the window. In general, you should only create display
// specific resources when a widget has been realized, and you should free those
// resources when the widget is unrealized.
func (w widget) RootWindow() gdk.Window {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GdkWindow // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_root_window(_arg0)

	var _window gdk.Window // out

	_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Window)

	return _window
}

// ScaleFactor retrieves the internal scale factor that maps from window
// coordinates to the actual device pixels. On traditional systems this is 1, on
// high density outputs, it can be a higher value (typically 2).
//
// See gdk_window_get_scale_factor().
func (w widget) ScaleFactor() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_scale_factor(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Screen: get the Screen from the toplevel window associated with this widget.
// This function can only be called after the widget has been added to a widget
// hierarchy with a Window at the top.
//
// In general, you should only create screen specific resources when a widget
// has been realized, and you should free those resources when the widget is
// unrealized.
func (w widget) Screen() gdk.Screen {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GdkScreen // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_screen(_arg0)

	var _screen gdk.Screen // out

	_screen = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Screen)

	return _screen
}

// Sensitive returns the widget’s sensitivity (in the sense of returning the
// value that has been set using gtk_widget_set_sensitive()).
//
// The effective sensitivity of a widget is however determined by both its own
// and its parent widget’s sensitivity. See gtk_widget_is_sensitive().
func (w widget) Sensitive() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_sensitive(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Settings gets the settings object holding the settings used for this widget.
//
// Note that this function can only be called when the Widget is attached to a
// toplevel, since the settings object is specific to a particular Screen.
func (w widget) Settings() Settings {
	var _arg0 *C.GtkWidget   // out
	var _cret *C.GtkSettings // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_settings(_arg0)

	var _settings Settings // out

	_settings = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Settings)

	return _settings
}

// GetSizeRequest gets the size request that was explicitly set for the widget
// using gtk_widget_set_size_request(). A value of -1 stored in @width or
// @height indicates that that dimension has not been set explicitly and the
// natural requisition of the widget will be used instead. See
// gtk_widget_set_size_request(). To get the size a widget will actually
// request, call gtk_widget_get_preferred_size() instead of this function.
func (w widget) GetSizeRequest() (width int, height int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // in
	var _arg2 C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_size_request(_arg0, &_arg1, &_arg2)

	var _width int  // out
	var _height int // out

	_width = (int)(_arg1)
	_height = (int)(_arg2)

	return _width, _height
}

// State returns the widget’s state. See gtk_widget_set_state().
func (w widget) State() StateType {
	var _arg0 *C.GtkWidget   // out
	var _cret C.GtkStateType // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_state(_arg0)

	var _stateType StateType // out

	_stateType = StateType(_cret)

	return _stateType
}

// StateFlags returns the widget state as a flag set. It is worth mentioning
// that the effective GTK_STATE_FLAG_INSENSITIVE state will be returned, that
// is, also based on parent insensitivity, even if @widget itself is sensitive.
//
// Also note that if you are looking for a way to obtain the StateFlags to pass
// to a StyleContext method, you should look at gtk_style_context_get_state().
func (w widget) StateFlags() StateFlags {
	var _arg0 *C.GtkWidget    // out
	var _cret C.GtkStateFlags // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_state_flags(_arg0)

	var _stateFlags StateFlags // out

	_stateFlags = StateFlags(_cret)

	return _stateFlags
}

// Style: simply an accessor function that returns @widget->style.
func (w widget) Style() Style {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GtkStyle  // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_style(_arg0)

	var _style Style // out

	_style = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Style)

	return _style
}

// StyleContext returns the style context associated to @widget. The returned
// object is guaranteed to be the same for the lifetime of @widget.
func (w widget) StyleContext() StyleContext {
	var _arg0 *C.GtkWidget       // out
	var _cret *C.GtkStyleContext // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_style_context(_arg0)

	var _styleContext StyleContext // out

	_styleContext = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(StyleContext)

	return _styleContext
}

// SupportMultidevice returns true if @widget is multiple pointer aware. See
// gtk_widget_set_support_multidevice() for more information.
func (w widget) SupportMultidevice() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_support_multidevice(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TemplateChild: fetch an object build from the template XML for @widget_type
// in this @widget instance.
//
// This will only report children which were previously declared with
// gtk_widget_class_bind_template_child_full() or one of its variants.
//
// This function is only meant to be called for code which is private to the
// @widget_type which declared the child and is meant for language bindings
// which cannot easily make use of the GObject structure offsets.
func (w widget) TemplateChild(widgetType externglib.Type, name string) gextras.Objector {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.GType      // out
	var _arg2 *C.gchar     // out
	var _cret *C.GObject   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = C.GType(widgetType)
	_arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_widget_get_template_child(_arg0, _arg1, _arg2)

	var _object gextras.Objector // out

	_object = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gextras.Objector)

	return _object
}

// TooltipMarkup gets the contents of the tooltip for @widget.
func (w widget) TooltipMarkup() string {
	var _arg0 *C.GtkWidget // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_tooltip_markup(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// TooltipText gets the contents of the tooltip for @widget.
func (w widget) TooltipText() string {
	var _arg0 *C.GtkWidget // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_tooltip_text(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// TooltipWindow returns the Window of the current tooltip. This can be the
// GtkWindow created by default, or the custom tooltip window set using
// gtk_widget_set_tooltip_window().
func (w widget) TooltipWindow() Window {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GtkWindow // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_tooltip_window(_arg0)

	var _window Window // out

	_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Window)

	return _window
}

// Toplevel: this function returns the topmost widget in the container hierarchy
// @widget is a part of. If @widget has no parent widgets, it will be returned
// as the topmost widget. No reference will be added to the returned widget; it
// should not be unreferenced.
//
// Note the difference in behavior vs. gtk_widget_get_ancestor();
// `gtk_widget_get_ancestor (widget, GTK_TYPE_WINDOW)` would return nil if
// @widget wasn’t inside a toplevel window, and if the window was inside a
// Window-derived widget which was in turn inside the toplevel Window. While the
// second case may seem unlikely, it actually happens when a Plug is embedded
// inside a Socket within the same application.
//
// To reliably find the toplevel Window, use gtk_widget_get_toplevel() and call
// GTK_IS_WINDOW() on the result. For instance, to get the title of a widget's
// toplevel window, one might use:
//
//    static const char *
//    get_widget_toplevel_title (GtkWidget *widget)
//    {
//      GtkWidget *toplevel = gtk_widget_get_toplevel (widget);
//      if (GTK_IS_WINDOW (toplevel))
//        {
//          return gtk_window_get_title (GTK_WINDOW (toplevel));
//        }
//
//      return NULL;
//    }
func (w widget) Toplevel() Widget {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_toplevel(_arg0)

	var _ret Widget // out

	_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _ret
}

// Valign gets the value of the Widget:valign property.
//
// For backwards compatibility reasons this method will never return
// GTK_ALIGN_BASELINE, but instead it will convert it to GTK_ALIGN_FILL. If your
// widget want to support baseline aligned children it must use
// gtk_widget_get_valign_with_baseline(), or `g_object_get (widget, "valign",
// &value, NULL)`, which will also report the true value.
func (w widget) Valign() Align {
	var _arg0 *C.GtkWidget // out
	var _cret C.GtkAlign   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_valign(_arg0)

	var _align Align // out

	_align = Align(_cret)

	return _align
}

// ValignWithBaseline gets the value of the Widget:valign property, including
// GTK_ALIGN_BASELINE.
func (w widget) ValignWithBaseline() Align {
	var _arg0 *C.GtkWidget // out
	var _cret C.GtkAlign   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_valign_with_baseline(_arg0)

	var _align Align // out

	_align = Align(_cret)

	return _align
}

// Vexpand gets whether the widget would like any available extra vertical
// space.
//
// See gtk_widget_get_hexpand() for more detail.
func (w widget) Vexpand() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_vexpand(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// VexpandSet gets whether gtk_widget_set_vexpand() has been used to explicitly
// set the expand flag on this widget.
//
// See gtk_widget_get_hexpand_set() for more detail.
func (w widget) VexpandSet() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_vexpand_set(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Visible determines whether the widget is visible. If you want to take into
// account whether the widget’s parent is also marked as visible, use
// gtk_widget_is_visible() instead.
//
// This function does not check if the widget is obscured in any way.
//
// See gtk_widget_set_visible().
func (w widget) Visible() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Visual gets the visual that will be used to render @widget.
func (w widget) Visual() gdk.Visual {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GdkVisual // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_visual(_arg0)

	var _visual gdk.Visual // out

	_visual = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Visual)

	return _visual
}

// Window returns the widget’s window if it is realized, nil otherwise
func (w widget) Window() gdk.Window {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GdkWindow // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_get_window(_arg0)

	var _window gdk.Window // out

	_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Window)

	return _window
}

// GrabAdd makes @widget the current grabbed widget.
//
// This means that interaction with other widgets in the same application is
// blocked and mouse as well as keyboard events are delivered to this widget.
//
// If @widget is not sensitive, it is not set as the current grabbed widget and
// this function does nothing.
func (w widget) GrabAdd() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_grab_add(_arg0)
}

// GrabDefault causes @widget to become the default widget. @widget must be able
// to be a default widget; typically you would ensure this yourself by calling
// gtk_widget_set_can_default() with a true value. The default widget is
// activated when the user presses Enter in a window. Default widgets must be
// activatable, that is, gtk_widget_activate() should affect them. Note that
// Entry widgets require the “activates-default” property set to true before
// they activate the default widget when Enter is pressed and the Entry is
// focused.
func (w widget) GrabDefault() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_grab_default(_arg0)
}

// GrabFocus causes @widget to have the keyboard focus for the Window it's
// inside. @widget must be a focusable widget, such as a Entry; something like
// Frame won’t work.
//
// More precisely, it must have the GTK_CAN_FOCUS flag set. Use
// gtk_widget_set_can_focus() to modify that flag.
//
// The widget also needs to be realized and mapped. This is indicated by the
// related signals. Grabbing the focus immediately after creating the widget
// will likely fail and cause critical warnings.
func (w widget) GrabFocus() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_grab_focus(_arg0)
}

// GrabRemove removes the grab from the given widget.
//
// You have to pair calls to gtk_grab_add() and gtk_grab_remove().
//
// If @widget does not have the grab, this function does nothing.
func (w widget) GrabRemove() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_grab_remove(_arg0)
}

// HasDefault determines whether @widget is the current default widget within
// its toplevel. See gtk_widget_set_can_default().
func (w widget) HasDefault() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_has_default(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasFocus determines if the widget has the global input focus. See
// gtk_widget_is_focus() for the difference between having the global input
// focus, and only having the focus within a toplevel.
func (w widget) HasFocus() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_has_focus(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasGrab determines whether the widget is currently grabbing events, so it is
// the only widget receiving input events (keyboard and mouse).
//
// See also gtk_grab_add().
func (w widget) HasGrab() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_has_grab(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasRCStyle determines if the widget style has been looked up through the rc
// mechanism.
func (w widget) HasRCStyle() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_has_rc_style(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasScreen checks whether there is a Screen is associated with this widget.
// All toplevel widgets have an associated screen, and all widgets added into a
// hierarchy with a toplevel window at the top.
func (w widget) HasScreen() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_has_screen(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasVisibleFocus determines if the widget should show a visible indication
// that it has the global input focus. This is a convenience function for use in
// ::draw handlers that takes into account whether focus indication should
// currently be shown in the toplevel window of @widget. See
// gtk_window_get_focus_visible() for more information about focus indication.
//
// To find out if the widget has the global input focus, use
// gtk_widget_has_focus().
func (w widget) HasVisibleFocus() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_has_visible_focus(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Hide reverses the effects of gtk_widget_show(), causing the widget to be
// hidden (invisible to the user).
func (w widget) Hide() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_hide(_arg0)
}

// HideOnDelete: utility function; intended to be connected to the
// Widget::delete-event signal on a Window. The function calls gtk_widget_hide()
// on its argument, then returns true. If connected to ::delete-event, the
// result is that clicking the close button for a window (on the window frame,
// top right corner usually) will hide but not destroy the window. By default,
// GTK+ destroys windows when ::delete-event is received.
func (w widget) HideOnDelete() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_hide_on_delete(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InDestruction returns whether the widget is currently being destroyed. This
// information can sometimes be used to avoid doing unnecessary work.
func (w widget) InDestruction() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_in_destruction(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InitTemplate creates and initializes child widgets defined in templates. This
// function must be called in the instance initializer for any class which
// assigned itself a template using gtk_widget_class_set_template()
//
// It is important to call this function in the instance initializer of a Widget
// subclass and not in #GObject.constructed() or #GObject.constructor() for two
// reasons.
//
// One reason is that generally derived widgets will assume that parent class
// composite widgets have been created in their instance initializers.
//
// Another reason is that when calling g_object_new() on a widget with composite
// templates, it’s important to build the composite widgets before the construct
// properties are set. Properties passed to g_object_new() should take
// precedence over properties set in the private template XML.
func (w widget) InitTemplate() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_init_template(_arg0)
}

// InputShapeCombineRegion sets an input shape for this widget’s GDK window.
// This allows for windows which react to mouse click in a nonrectangular
// region, see gdk_window_input_shape_combine_region() for more information.
func (w widget) InputShapeCombineRegion(region *cairo.Region) {
	var _arg0 *C.GtkWidget      // out
	var _arg1 *C.cairo_region_t // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))

	C.gtk_widget_input_shape_combine_region(_arg0, _arg1)
}

// InsertActionGroup inserts @group into @widget. Children of @widget that
// implement Actionable can then be associated with actions in @group by setting
// their “action-name” to @prefix.`action-name`.
//
// If @group is nil, a previously inserted group for @name is removed from
// @widget.
func (w widget) InsertActionGroup(name string, group gio.ActionGroup) {
	var _arg0 *C.GtkWidget    // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GActionGroup // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GActionGroup)(unsafe.Pointer(group.Native()))

	C.gtk_widget_insert_action_group(_arg0, _arg1, _arg2)
}

// Intersect computes the intersection of a @widget’s area and @area, storing
// the intersection in @intersection, and returns true if there was an
// intersection. @intersection may be nil if you’re only interested in whether
// there was an intersection.
func (w widget) Intersect(area *gdk.Rectangle) (gdk.Rectangle, bool) {
	var _arg0 *C.GtkWidget    // out
	var _arg1 *C.GdkRectangle // out
	var _intersection gdk.Rectangle
	var _cret C.gboolean // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GdkRectangle)(unsafe.Pointer(area.Native()))

	_cret = C.gtk_widget_intersect(_arg0, _arg1, (*C.GdkRectangle)(unsafe.Pointer(&_intersection)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _intersection, _ok
}

// IsAncestor determines whether @widget is somewhere inside @ancestor, possibly
// with intermediate containers.
func (w widget) IsAncestor(ancestor Widget) bool {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(ancestor.Native()))

	_cret = C.gtk_widget_is_ancestor(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsComposited: whether @widget can rely on having its alpha channel drawn
// correctly. On X11 this function returns whether a compositing manager is
// running for @widget’s screen.
//
// Please note that the semantics of this call will change in the future if used
// on a widget that has a composited window in its hierarchy (as set by
// gdk_window_set_composited()).
func (w widget) IsComposited() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_is_composited(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsDrawable determines whether @widget can be drawn to. A widget can be drawn
// to if it is mapped and visible.
func (w widget) IsDrawable() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_is_drawable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsFocus determines if the widget is the focus widget within its toplevel.
// (This does not mean that the Widget:has-focus property is necessarily set;
// Widget:has-focus will only be set if the toplevel widget additionally has the
// global input focus.)
func (w widget) IsFocus() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_is_focus(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsSensitive returns the widget’s effective sensitivity, which means it is
// sensitive itself and also its parent widget is sensitive
func (w widget) IsSensitive() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_is_sensitive(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsToplevel determines whether @widget is a toplevel widget.
//
// Currently only Window and Invisible (and out-of-process Plugs) are toplevel
// widgets. Toplevel widgets have no parent widget.
func (w widget) IsToplevel() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_is_toplevel(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsVisible determines whether the widget and all its parents are marked as
// visible.
//
// This function does not check if the widget is obscured in any way.
//
// See also gtk_widget_get_visible() and gtk_widget_set_visible()
func (w widget) IsVisible() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_is_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// KeynavFailed: this function should be called whenever keyboard navigation
// within a single widget hits a boundary. The function emits the
// Widget::keynav-failed signal on the widget and its return value should be
// interpreted in a way similar to the return value of gtk_widget_child_focus():
//
// When true is returned, stay in the widget, the failed keyboard navigation is
// OK and/or there is nowhere we can/should move the focus to.
//
// When false is returned, the caller should continue with keyboard navigation
// outside the widget, e.g. by calling gtk_widget_child_focus() on the widget’s
// toplevel.
//
// The default ::keynav-failed handler returns false for GTK_DIR_TAB_FORWARD and
// GTK_DIR_TAB_BACKWARD. For the other values of DirectionType it returns true.
//
// Whenever the default handler returns true, it also calls
// gtk_widget_error_bell() to notify the user of the failed keyboard navigation.
//
// A use case for providing an own implementation of ::keynav-failed (either by
// connecting to it or by overriding it) would be a row of Entry widgets where
// the user should be able to navigate the entire row with the cursor keys, as
// e.g. known from user interfaces that require entering license keys.
func (w widget) KeynavFailed(direction DirectionType) bool {
	var _arg0 *C.GtkWidget       // out
	var _arg1 C.GtkDirectionType // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GtkDirectionType)(direction)

	_cret = C.gtk_widget_keynav_failed(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ListActionPrefixes retrieves a nil-terminated array of strings containing the
// prefixes of Group's available to @widget.
func (w widget) ListActionPrefixes() []string {
	var _arg0 *C.GtkWidget // out
	var _cret **C.gchar

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_widget_list_action_prefixes(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
		}
	}

	return _utf8s
}

// Map: this function is only for use in widget implementations. Causes a widget
// to be mapped if it isn’t already.
func (w widget) Map() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_map(_arg0)
}

// MnemonicActivate emits the Widget::mnemonic-activate signal.
func (w widget) MnemonicActivate(groupCycling bool) bool {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if groupCycling {
		_arg1 = C.TRUE
	}

	_cret = C.gtk_widget_mnemonic_activate(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ModifyBase sets the base color for a widget in a particular state. All other
// style values are left untouched. The base color is the background color used
// along with the text color (see gtk_widget_modify_text()) for widgets such as
// Entry and TextView. See also gtk_widget_modify_style().
//
// > Note that “no window” widgets (which have the GTK_NO_WINDOW > flag set)
// draw on their parent container’s window and thus may > not draw any
// background themselves. This is the case for e.g. > Label. > > To modify the
// background of such widgets, you have to set the > base color on their parent;
// if you want to set the background > of a rectangular area around a label, try
// placing the label in > a EventBox widget and setting the base color on that.
func (w widget) ModifyBase(state StateType, color *gdk.Color) {
	var _arg0 *C.GtkWidget   // out
	var _arg1 C.GtkStateType // out
	var _arg2 *C.GdkColor    // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GtkStateType)(state)
	_arg2 = (*C.GdkColor)(unsafe.Pointer(color.Native()))

	C.gtk_widget_modify_base(_arg0, _arg1, _arg2)
}

// ModifyBg sets the background color for a widget in a particular state.
//
// All other style values are left untouched. See also
// gtk_widget_modify_style().
//
// > Note that “no window” widgets (which have the GTK_NO_WINDOW > flag set)
// draw on their parent container’s window and thus may > not draw any
// background themselves. This is the case for e.g. > Label. > > To modify the
// background of such widgets, you have to set the > background color on their
// parent; if you want to set the background > of a rectangular area around a
// label, try placing the label in > a EventBox widget and setting the
// background color on that.
func (w widget) ModifyBg(state StateType, color *gdk.Color) {
	var _arg0 *C.GtkWidget   // out
	var _arg1 C.GtkStateType // out
	var _arg2 *C.GdkColor    // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GtkStateType)(state)
	_arg2 = (*C.GdkColor)(unsafe.Pointer(color.Native()))

	C.gtk_widget_modify_bg(_arg0, _arg1, _arg2)
}

// ModifyCursor sets the cursor color to use in a widget, overriding the Widget
// cursor-color and secondary-cursor-color style properties.
//
// All other style values are left untouched. See also
// gtk_widget_modify_style().
func (w widget) ModifyCursor(primary *gdk.Color, secondary *gdk.Color) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GdkColor  // out
	var _arg2 *C.GdkColor  // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GdkColor)(unsafe.Pointer(primary.Native()))
	_arg2 = (*C.GdkColor)(unsafe.Pointer(secondary.Native()))

	C.gtk_widget_modify_cursor(_arg0, _arg1, _arg2)
}

// ModifyFg sets the foreground color for a widget in a particular state.
//
// All other style values are left untouched. See also
// gtk_widget_modify_style().
func (w widget) ModifyFg(state StateType, color *gdk.Color) {
	var _arg0 *C.GtkWidget   // out
	var _arg1 C.GtkStateType // out
	var _arg2 *C.GdkColor    // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GtkStateType)(state)
	_arg2 = (*C.GdkColor)(unsafe.Pointer(color.Native()))

	C.gtk_widget_modify_fg(_arg0, _arg1, _arg2)
}

// ModifyFont sets the font to use for a widget.
//
// All other style values are left untouched. See also
// gtk_widget_modify_style().
func (w widget) ModifyFont(fontDesc *pango.FontDescription) {
	var _arg0 *C.GtkWidget            // out
	var _arg1 *C.PangoFontDescription // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.PangoFontDescription)(unsafe.Pointer(fontDesc.Native()))

	C.gtk_widget_modify_font(_arg0, _arg1)
}

// ModifyStyle modifies style values on the widget.
//
// Modifications made using this technique take precedence over style values set
// via an RC file, however, they will be overridden if a style is explicitly set
// on the widget using gtk_widget_set_style(). The RcStyle-struct is designed so
// each field can either be set or unset, so it is possible, using this
// function, to modify some style values and leave the others unchanged.
//
// Note that modifications made with this function are not cumulative with
// previous calls to gtk_widget_modify_style() or with such functions as
// gtk_widget_modify_fg(). If you wish to retain previous values, you must first
// call gtk_widget_get_modifier_style(), make your modifications to the returned
// style, then call gtk_widget_modify_style() with that style. On the other
// hand, if you first call gtk_widget_modify_style(), subsequent calls to such
// functions gtk_widget_modify_fg() will have a cumulative effect with the
// initial modifications.
func (w widget) ModifyStyle(style RCStyle) {
	var _arg0 *C.GtkWidget  // out
	var _arg1 *C.GtkRcStyle // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkRcStyle)(unsafe.Pointer(style.Native()))

	C.gtk_widget_modify_style(_arg0, _arg1)
}

// ModifyText sets the text color for a widget in a particular state.
//
// All other style values are left untouched. The text color is the foreground
// color used along with the base color (see gtk_widget_modify_base()) for
// widgets such as Entry and TextView. See also gtk_widget_modify_style().
func (w widget) ModifyText(state StateType, color *gdk.Color) {
	var _arg0 *C.GtkWidget   // out
	var _arg1 C.GtkStateType // out
	var _arg2 *C.GdkColor    // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GtkStateType)(state)
	_arg2 = (*C.GdkColor)(unsafe.Pointer(color.Native()))

	C.gtk_widget_modify_text(_arg0, _arg1, _arg2)
}

// OverrideBackgroundColor sets the background color to use for a widget.
//
// All other style values are left untouched. See gtk_widget_override_color().
func (w widget) OverrideBackgroundColor(state StateFlags, color *gdk.RGBA) {
	var _arg0 *C.GtkWidget    // out
	var _arg1 C.GtkStateFlags // out
	var _arg2 *C.GdkRGBA      // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GtkStateFlags)(state)
	_arg2 = (*C.GdkRGBA)(unsafe.Pointer(color.Native()))

	C.gtk_widget_override_background_color(_arg0, _arg1, _arg2)
}

// OverrideColor sets the color to use for a widget.
//
// All other style values are left untouched.
//
// This function does not act recursively. Setting the color of a container does
// not affect its children. Note that some widgets that you may not think of as
// containers, for instance Buttons, are actually containers.
//
// This API is mostly meant as a quick way for applications to change a widget
// appearance. If you are developing a widgets library and intend this change to
// be themeable, it is better done by setting meaningful CSS classes in your
// widget/container implementation through gtk_style_context_add_class().
//
// This way, your widget library can install a CssProvider with the
// GTK_STYLE_PROVIDER_PRIORITY_FALLBACK priority in order to provide a default
// styling for those widgets that need so, and this theming may fully overridden
// by the user’s theme.
//
// Note that for complex widgets this may bring in undesired results (such as
// uniform background color everywhere), in these cases it is better to fully
// style such widgets through a CssProvider with the
// GTK_STYLE_PROVIDER_PRIORITY_APPLICATION priority.
func (w widget) OverrideColor(state StateFlags, color *gdk.RGBA) {
	var _arg0 *C.GtkWidget    // out
	var _arg1 C.GtkStateFlags // out
	var _arg2 *C.GdkRGBA      // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GtkStateFlags)(state)
	_arg2 = (*C.GdkRGBA)(unsafe.Pointer(color.Native()))

	C.gtk_widget_override_color(_arg0, _arg1, _arg2)
}

// OverrideCursor sets the cursor color to use in a widget, overriding the
// cursor-color and secondary-cursor-color style properties. All other style
// values are left untouched. See also gtk_widget_modify_style().
//
// Note that the underlying properties have the Color type, so the alpha value
// in @primary and @secondary will be ignored.
func (w widget) OverrideCursor(cursor *gdk.RGBA, secondaryCursor *gdk.RGBA) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GdkRGBA   // out
	var _arg2 *C.GdkRGBA   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GdkRGBA)(unsafe.Pointer(cursor.Native()))
	_arg2 = (*C.GdkRGBA)(unsafe.Pointer(secondaryCursor.Native()))

	C.gtk_widget_override_cursor(_arg0, _arg1, _arg2)
}

// OverrideFont sets the font to use for a widget. All other style values are
// left untouched. See gtk_widget_override_color().
func (w widget) OverrideFont(fontDesc *pango.FontDescription) {
	var _arg0 *C.GtkWidget            // out
	var _arg1 *C.PangoFontDescription // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.PangoFontDescription)(unsafe.Pointer(fontDesc.Native()))

	C.gtk_widget_override_font(_arg0, _arg1)
}

// OverrideSymbolicColor sets a symbolic color for a widget.
//
// All other style values are left untouched. See gtk_widget_override_color()
// for overriding the foreground or background color.
func (w widget) OverrideSymbolicColor(name string, color *gdk.RGBA) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.GdkRGBA   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GdkRGBA)(unsafe.Pointer(color.Native()))

	C.gtk_widget_override_symbolic_color(_arg0, _arg1, _arg2)
}

// Path obtains the full path to @widget. The path is simply the name of a
// widget and all its parents in the container hierarchy, separated by periods.
// The name of a widget comes from gtk_widget_get_name(). Paths are used to
// apply styles to a widget in gtkrc configuration files. Widget names are the
// type of the widget by default (e.g. “GtkButton”) or can be set to an
// application-specific value with gtk_widget_set_name(). By setting the name of
// a widget, you allow users or theme authors to apply styles to that specific
// widget in their gtkrc file. @path_reversed_p fills in the path in reverse
// order, i.e. starting with @widget’s name instead of starting with the name of
// @widget’s outermost ancestor.
func (w widget) Path() (pathLength uint, path string, pathReversed string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.guint      // in
	var _arg2 *C.gchar     // in
	var _arg3 *C.gchar     // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_path(_arg0, &_arg1, &_arg2, &_arg3)

	var _pathLength uint     // out
	var _path string         // out
	var _pathReversed string // out

	_pathLength = (uint)(_arg1)
	_path = C.GoString(_arg2)
	defer C.free(unsafe.Pointer(_arg2))
	_pathReversed = C.GoString(_arg3)
	defer C.free(unsafe.Pointer(_arg3))

	return _pathLength, _path, _pathReversed
}

// QueueAllocate: this function is only for use in widget implementations.
//
// Flags the widget for a rerun of the GtkWidgetClass::size_allocate function.
// Use this function instead of gtk_widget_queue_resize() when the @widget's
// size request didn't change but it wants to reposition its contents.
//
// An example user of this function is gtk_widget_set_halign().
func (w widget) QueueAllocate() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_queue_allocate(_arg0)
}

// QueueComputeExpand: mark @widget as needing to recompute its expand flags.
// Call this function when setting legacy expand child properties on the child
// of a container.
//
// See gtk_widget_compute_expand().
func (w widget) QueueComputeExpand() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_queue_compute_expand(_arg0)
}

// QueueDraw: equivalent to calling gtk_widget_queue_draw_area() for the entire
// area of a widget.
func (w widget) QueueDraw() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_queue_draw(_arg0)
}

// QueueDrawArea: convenience function that calls gtk_widget_queue_draw_region()
// on the region created from the given coordinates.
//
// The region here is specified in widget coordinates. Widget coordinates are a
// bit odd; for historical reasons, they are defined as @widget->window
// coordinates for widgets that return true for gtk_widget_get_has_window(), and
// are relative to @widget->allocation.x, @widget->allocation.y otherwise.
//
// @width or @height may be 0, in this case this function does nothing. Negative
// values for @width and @height are not allowed.
func (w widget) QueueDrawArea(x int, y int, width int, height int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // out
	var _arg3 C.gint       // out
	var _arg4 C.gint       // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.gint)(x)
	_arg2 = (C.gint)(y)
	_arg3 = (C.gint)(width)
	_arg4 = (C.gint)(height)

	C.gtk_widget_queue_draw_area(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// QueueDrawRegion invalidates the area of @widget defined by @region by calling
// gdk_window_invalidate_region() on the widget’s window and all its child
// windows. Once the main loop becomes idle (after the current batch of events
// has been processed, roughly), the window will receive expose events for the
// union of all regions that have been invalidated.
//
// Normally you would only use this function in widget implementations. You
// might also use it to schedule a redraw of a DrawingArea or some portion
// thereof.
func (w widget) QueueDrawRegion(region *cairo.Region) {
	var _arg0 *C.GtkWidget      // out
	var _arg1 *C.cairo_region_t // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))

	C.gtk_widget_queue_draw_region(_arg0, _arg1)
}

// QueueResize: this function is only for use in widget implementations. Flags a
// widget to have its size renegotiated; should be called when a widget for some
// reason has a new size request. For example, when you change the text in a
// Label, Label queues a resize to ensure there’s enough space for the new text.
//
// Note that you cannot call gtk_widget_queue_resize() on a widget from inside
// its implementation of the GtkWidgetClass::size_allocate virtual method. Calls
// to gtk_widget_queue_resize() from inside GtkWidgetClass::size_allocate will
// be silently ignored.
func (w widget) QueueResize() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_queue_resize(_arg0)
}

// QueueResizeNoRedraw: this function works like gtk_widget_queue_resize(),
// except that the widget is not invalidated.
func (w widget) QueueResizeNoRedraw() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_queue_resize_no_redraw(_arg0)
}

// Realize creates the GDK (windowing system) resources associated with a
// widget. For example, @widget->window will be created when a widget is
// realized. Normally realization happens implicitly; if you show a widget and
// all its parent containers, then the widget will be realized and mapped
// automatically.
//
// Realizing a widget requires all the widget’s parent widgets to be realized;
// calling gtk_widget_realize() realizes the widget’s parents in addition to
// @widget itself. If a widget is not yet inside a toplevel window when you
// realize it, bad things will happen.
//
// This function is primarily used in widget implementations, and isn’t very
// useful otherwise. Many times when you think you might need it, a better
// approach is to connect to a signal that will be called after the widget is
// realized automatically, such as Widget::draw. Or simply g_signal_connect ()
// to the Widget::realize signal.
func (w widget) Realize() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_realize(_arg0)
}

// RegionIntersect computes the intersection of a @widget’s area and @region,
// returning the intersection. The result may be empty, use
// cairo_region_is_empty() to check.
func (w widget) RegionIntersect(region *cairo.Region) *cairo.Region {
	var _arg0 *C.GtkWidget      // out
	var _arg1 *C.cairo_region_t // out
	var _cret *C.cairo_region_t // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))

	_cret = C.gtk_widget_region_intersect(_arg0, _arg1)

	var _ret *cairo.Region // out

	_ret = cairo.WrapRegion(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_ret, func(v *cairo.Region) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _ret
}

// RegisterWindow registers a Window with the widget and sets it up so that the
// widget receives events for it. Call gtk_widget_unregister_window() when
// destroying the window.
//
// Before 3.8 you needed to call gdk_window_set_user_data() directly to set this
// up. This is now deprecated and you should use gtk_widget_register_window()
// instead. Old code will keep working as is, although some new features like
// transparency might not work perfectly.
func (w widget) RegisterWindow(window gdk.Window) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GdkWindow // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_widget_register_window(_arg0, _arg1)
}

// RemoveAccelerator removes an accelerator from @widget, previously installed
// with gtk_widget_add_accelerator().
func (w widget) RemoveAccelerator(accelGroup AccelGroup, accelKey uint, accelMods gdk.ModifierType) bool {
	var _arg0 *C.GtkWidget      // out
	var _arg1 *C.GtkAccelGroup  // out
	var _arg2 C.guint           // out
	var _arg3 C.GdkModifierType // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkAccelGroup)(unsafe.Pointer(accelGroup.Native()))
	_arg2 = (C.guint)(accelKey)
	_arg3 = (C.GdkModifierType)(accelMods)

	_cret = C.gtk_widget_remove_accelerator(_arg0, _arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveMnemonicLabel removes a widget from the list of mnemonic labels for
// this widget. (See gtk_widget_list_mnemonic_labels()). The widget must have
// previously been added to the list with gtk_widget_add_mnemonic_label().
func (w widget) RemoveMnemonicLabel(label Widget) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(label.Native()))

	C.gtk_widget_remove_mnemonic_label(_arg0, _arg1)
}

// RemoveTickCallback removes a tick callback previously registered with
// gtk_widget_add_tick_callback().
func (w widget) RemoveTickCallback(id uint) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.guint      // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.guint)(id)

	C.gtk_widget_remove_tick_callback(_arg0, _arg1)
}

// RenderIcon: a convenience function that uses the theme settings for @widget
// to look up @stock_id and render it to a pixbuf. @stock_id should be a stock
// icon ID such as K_STOCK_OPEN or K_STOCK_OK. @size should be a size such as
// K_ICON_SIZE_MENU. @detail should be a string that identifies the widget or
// code doing the rendering, so that theme engines can special-case rendering
// for that widget or code.
//
// The pixels in the returned Pixbuf are shared with the rest of the application
// and should not be modified. The pixbuf should be freed after use with
// g_object_unref().
func (w widget) RenderIcon(stockId string, size int, detail string) gdkpixbuf.Pixbuf {
	var _arg0 *C.GtkWidget  // out
	var _arg1 *C.gchar      // out
	var _arg2 C.GtkIconSize // out
	var _arg3 *C.gchar      // out
	var _cret *C.GdkPixbuf  // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.gchar)(C.CString(stockId))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GtkIconSize)(size)
	_arg3 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.gtk_widget_render_icon(_arg0, _arg1, _arg2, _arg3)

	var _pixbuf gdkpixbuf.Pixbuf // out

	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

	return _pixbuf
}

// RenderIconPixbuf: a convenience function that uses the theme engine and style
// settings for @widget to look up @stock_id and render it to a pixbuf.
// @stock_id should be a stock icon ID such as K_STOCK_OPEN or K_STOCK_OK. @size
// should be a size such as K_ICON_SIZE_MENU.
//
// The pixels in the returned Pixbuf are shared with the rest of the application
// and should not be modified. The pixbuf should be freed after use with
// g_object_unref().
func (w widget) RenderIconPixbuf(stockId string, size int) gdkpixbuf.Pixbuf {
	var _arg0 *C.GtkWidget  // out
	var _arg1 *C.gchar      // out
	var _arg2 C.GtkIconSize // out
	var _cret *C.GdkPixbuf  // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.gchar)(C.CString(stockId))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GtkIconSize)(size)

	_cret = C.gtk_widget_render_icon_pixbuf(_arg0, _arg1, _arg2)

	var _pixbuf gdkpixbuf.Pixbuf // out

	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

	return _pixbuf
}

// Reparent moves a widget from one Container to another, handling reference
// count issues to avoid destroying the widget.
func (w widget) Reparent(newParent Widget) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(newParent.Native()))

	C.gtk_widget_reparent(_arg0, _arg1)
}

// ResetRCStyles: reset the styles of @widget and all descendents, so when they
// are looked up again, they get the correct values for the currently loaded RC
// file settings.
//
// This function is not useful for applications.
func (w widget) ResetRCStyles() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_reset_rc_styles(_arg0)
}

// ResetStyle updates the style context of @widget and all descendants by
// updating its widget path. Containers may want to use this on a child when
// reordering it in a way that a different style might apply to it. See also
// gtk_container_get_path_for_child().
func (w widget) ResetStyle() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_reset_style(_arg0)
}

// SetAccelPath: given an accelerator group, @accel_group, and an accelerator
// path, @accel_path, sets up an accelerator in @accel_group so whenever the key
// binding that is defined for @accel_path is pressed, @widget will be
// activated. This removes any accelerators (for any accelerator group)
// installed by previous calls to gtk_widget_set_accel_path(). Associating
// accelerators with paths allows them to be modified by the user and the
// modifications to be saved for future use. (See gtk_accel_map_save().)
//
// This function is a low level function that would most likely be used by a
// menu creation system like UIManager. If you use UIManager, setting up
// accelerator paths will be done automatically.
//
// Even when you you aren’t using UIManager, if you only want to set up
// accelerators on menu items gtk_menu_item_set_accel_path() provides a somewhat
// more convenient interface.
//
// Note that @accel_path string will be stored in a #GQuark. Therefore, if you
// pass a static string, you can save some memory by interning it first with
// g_intern_static_string().
func (w widget) SetAccelPath(accelPath string, accelGroup AccelGroup) {
	var _arg0 *C.GtkWidget     // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.GtkAccelGroup // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.gchar)(C.CString(accelPath))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkAccelGroup)(unsafe.Pointer(accelGroup.Native()))

	C.gtk_widget_set_accel_path(_arg0, _arg1, _arg2)
}

// SetAppPaintable sets whether the application intends to draw on the widget in
// an Widget::draw handler.
//
// This is a hint to the widget and does not affect the behavior of the GTK+
// core; many widgets ignore this flag entirely. For widgets that do pay
// attention to the flag, such as EventBox and Window, the effect is to suppress
// default themed drawing of the widget's background. (Children of the widget
// will still be drawn.) The application is then entirely responsible for
// drawing the widget background.
//
// Note that the background is still drawn when the widget is mapped.
func (w widget) SetAppPaintable(appPaintable bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if appPaintable {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_app_paintable(_arg0, _arg1)
}

// SetCanDefault specifies whether @widget can be a default widget. See
// gtk_widget_grab_default() for details about the meaning of “default”.
func (w widget) SetCanDefault(canDefault bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if canDefault {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_can_default(_arg0, _arg1)
}

// SetCanFocus specifies whether @widget can own the input focus. See
// gtk_widget_grab_focus() for actually setting the input focus on a widget.
func (w widget) SetCanFocus(canFocus bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if canFocus {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_can_focus(_arg0, _arg1)
}

// SetChildVisible sets whether @widget should be mapped along with its when its
// parent is mapped and @widget has been shown with gtk_widget_show().
//
// The child visibility can be set for widget before it is added to a container
// with gtk_widget_set_parent(), to avoid mapping children unnecessary before
// immediately unmapping them. However it will be reset to its default state of
// true when the widget is removed from a container.
//
// Note that changing the child visibility of a widget does not queue a resize
// on the widget. Most of the time, the size of a widget is computed from all
// visible children, whether or not they are mapped. If this is not the case,
// the container can queue a resize itself.
//
// This function is only useful for container implementations and never should
// be called by an application.
func (w widget) SetChildVisible(isVisible bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if isVisible {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_child_visible(_arg0, _arg1)
}

// SetCompositeName sets a widgets composite name. The widget must be a
// composite child of its parent; see gtk_widget_push_composite_child().
func (w widget) SetCompositeName(name string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_widget_set_composite_name(_arg0, _arg1)
}

// SetDeviceEnabled enables or disables a Device to interact with @widget and
// all its children.
//
// It does so by descending through the Window hierarchy and enabling the same
// mask that is has for core events (i.e. the one that gdk_window_get_events()
// returns).
func (w widget) SetDeviceEnabled(device gdk.Device, enabled bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GdkDevice // out
	var _arg2 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))
	if enabled {
		_arg2 = C.TRUE
	}

	C.gtk_widget_set_device_enabled(_arg0, _arg1, _arg2)
}

// SetDeviceEvents sets the device event mask (see EventMask) for a widget. The
// event mask determines which events a widget will receive from @device. Keep
// in mind that different widgets have different default event masks, and by
// changing the event mask you may disrupt a widget’s functionality, so be
// careful. This function must be called while a widget is unrealized. Consider
// gtk_widget_add_device_events() for widgets that are already realized, or if
// you want to preserve the existing event mask. This function can’t be used
// with windowless widgets (which return false from
// gtk_widget_get_has_window()); to get events on those widgets, place them
// inside a EventBox and receive events on the event box.
func (w widget) SetDeviceEvents(device gdk.Device, events gdk.EventMask) {
	var _arg0 *C.GtkWidget   // out
	var _arg1 *C.GdkDevice   // out
	var _arg2 C.GdkEventMask // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))
	_arg2 = (C.GdkEventMask)(events)

	C.gtk_widget_set_device_events(_arg0, _arg1, _arg2)
}

// SetDirection sets the reading direction on a particular widget. This
// direction controls the primary direction for widgets containing text, and
// also the direction in which the children of a container are packed. The
// ability to set the direction is present in order so that correct localization
// into languages with right-to-left reading directions can be done. Generally,
// applications will let the default reading direction present, except for
// containers where the containers are arranged in an order that is explicitly
// visual rather than logical (such as buttons for text justification).
//
// If the direction is set to GTK_TEXT_DIR_NONE, then the value set by
// gtk_widget_set_default_direction() will be used.
func (w widget) SetDirection(dir TextDirection) {
	var _arg0 *C.GtkWidget       // out
	var _arg1 C.GtkTextDirection // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GtkTextDirection)(dir)

	C.gtk_widget_set_direction(_arg0, _arg1)
}

// SetDoubleBuffered widgets are double buffered by default; you can use this
// function to turn off the buffering. “Double buffered” simply means that
// gdk_window_begin_draw_frame() and gdk_window_end_draw_frame() are called
// automatically around expose events sent to the widget.
// gdk_window_begin_draw_frame() diverts all drawing to a widget's window to an
// offscreen buffer, and gdk_window_end_draw_frame() draws the buffer to the
// screen. The result is that users see the window update in one smooth step,
// and don’t see individual graphics primitives being rendered.
//
// In very simple terms, double buffered widgets don’t flicker, so you would
// only use this function to turn off double buffering if you had special needs
// and really knew what you were doing.
//
// Note: if you turn off double-buffering, you have to handle expose events,
// since even the clearing to the background color or pixmap will not happen
// automatically (as it is done in gdk_window_begin_draw_frame()).
//
// In 3.10 GTK and GDK have been restructured for translucent drawing. Since
// then expose events for double-buffered widgets are culled into a single event
// to the toplevel GDK window. If you now unset double buffering, you will cause
// a separate rendering pass for every widget. This will likely cause rendering
// problems - in particular related to stacking - and usually increases
// rendering times significantly.
func (w widget) SetDoubleBuffered(doubleBuffered bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if doubleBuffered {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_double_buffered(_arg0, _arg1)
}

// SetEvents sets the event mask (see EventMask) for a widget. The event mask
// determines which events a widget will receive. Keep in mind that different
// widgets have different default event masks, and by changing the event mask
// you may disrupt a widget’s functionality, so be careful. This function must
// be called while a widget is unrealized. Consider gtk_widget_add_events() for
// widgets that are already realized, or if you want to preserve the existing
// event mask. This function can’t be used with widgets that have no window.
// (See gtk_widget_get_has_window()). To get events on those widgets, place them
// inside a EventBox and receive events on the event box.
func (w widget) SetEvents(events int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.gint)(events)

	C.gtk_widget_set_events(_arg0, _arg1)
}

// SetFocusOnClick sets whether the widget should grab focus when it is clicked
// with the mouse. Making mouse clicks not grab focus is useful in places like
// toolbars where you don’t want the keyboard focus removed from the main area
// of the application.
func (w widget) SetFocusOnClick(focusOnClick bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if focusOnClick {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_focus_on_click(_arg0, _arg1)
}

// SetFontMap sets the font map to use for Pango rendering. When not set, the
// widget will inherit the font map from its parent.
func (w widget) SetFontMap(fontMap pango.FontMap) {
	var _arg0 *C.GtkWidget    // out
	var _arg1 *C.PangoFontMap // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.PangoFontMap)(unsafe.Pointer(fontMap.Native()))

	C.gtk_widget_set_font_map(_arg0, _arg1)
}

// SetFontOptions sets the #cairo_font_options_t used for Pango rendering in
// this widget. When not set, the default font options for the Screen will be
// used.
func (w widget) SetFontOptions(options *cairo.FontOptions) {
	var _arg0 *C.GtkWidget            // out
	var _arg1 *C.cairo_font_options_t // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.cairo_font_options_t)(unsafe.Pointer(options.Native()))

	C.gtk_widget_set_font_options(_arg0, _arg1)
}

// SetHalign sets the horizontal alignment of @widget. See the Widget:halign
// property.
func (w widget) SetHalign(align Align) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.GtkAlign   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GtkAlign)(align)

	C.gtk_widget_set_halign(_arg0, _arg1)
}

// SetHasTooltip sets the has-tooltip property on @widget to @has_tooltip. See
// Widget:has-tooltip for more information.
func (w widget) SetHasTooltip(hasTooltip bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if hasTooltip {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_has_tooltip(_arg0, _arg1)
}

// SetHasWindow specifies whether @widget has a Window of its own. Note that all
// realized widgets have a non-nil “window” pointer (gtk_widget_get_window()
// never returns a nil window when a widget is realized), but for many of them
// it’s actually the Window of one of its parent widgets. Widgets that do not
// create a window for themselves in Widget::realize must announce this by
// calling this function with @has_window = false.
//
// This function should only be called by widget implementations, and they
// should call it in their init() function.
func (w widget) SetHasWindow(hasWindow bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if hasWindow {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_has_window(_arg0, _arg1)
}

// SetHexpand sets whether the widget would like any available extra horizontal
// space. When a user resizes a Window, widgets with expand=TRUE generally
// receive the extra space. For example, a list or scrollable area or document
// in your window would often be set to expand.
//
// Call this function to set the expand flag if you would like your widget to
// become larger horizontally when the window has extra room.
//
// By default, widgets automatically expand if any of their children want to
// expand. (To see if a widget will automatically expand given its current
// children and state, call gtk_widget_compute_expand(). A container can decide
// how the expandability of children affects the expansion of the container by
// overriding the compute_expand virtual method on Widget.).
//
// Setting hexpand explicitly with this function will override the automatic
// expand behavior.
//
// This function forces the widget to expand or not to expand, regardless of
// children. The override occurs because gtk_widget_set_hexpand() sets the
// hexpand-set property (see gtk_widget_set_hexpand_set()) which causes the
// widget’s hexpand value to be used, rather than looking at children and widget
// state.
func (w widget) SetHexpand(expand bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if expand {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_hexpand(_arg0, _arg1)
}

// SetHexpandSet sets whether the hexpand flag (see gtk_widget_get_hexpand())
// will be used.
//
// The hexpand-set property will be set automatically when you call
// gtk_widget_set_hexpand() to set hexpand, so the most likely reason to use
// this function would be to unset an explicit expand flag.
//
// If hexpand is set, then it overrides any computed expand value based on child
// widgets. If hexpand is not set, then the expand value depends on whether any
// children of the widget would like to expand.
//
// There are few reasons to use this function, but it’s here for completeness
// and consistency.
func (w widget) SetHexpandSet(set bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if set {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_hexpand_set(_arg0, _arg1)
}

// SetMapped marks the widget as being mapped.
//
// This function should only ever be called in a derived widget's “map” or
// “unmap” implementation.
func (w widget) SetMapped(mapped bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if mapped {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_mapped(_arg0, _arg1)
}

// SetMarginBottom sets the bottom margin of @widget. See the
// Widget:margin-bottom property.
func (w widget) SetMarginBottom(margin int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.gint)(margin)

	C.gtk_widget_set_margin_bottom(_arg0, _arg1)
}

// SetMarginEnd sets the end margin of @widget. See the Widget:margin-end
// property.
func (w widget) SetMarginEnd(margin int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.gint)(margin)

	C.gtk_widget_set_margin_end(_arg0, _arg1)
}

// SetMarginLeft sets the left margin of @widget. See the Widget:margin-left
// property.
func (w widget) SetMarginLeft(margin int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.gint)(margin)

	C.gtk_widget_set_margin_left(_arg0, _arg1)
}

// SetMarginRight sets the right margin of @widget. See the Widget:margin-right
// property.
func (w widget) SetMarginRight(margin int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.gint)(margin)

	C.gtk_widget_set_margin_right(_arg0, _arg1)
}

// SetMarginStart sets the start margin of @widget. See the Widget:margin-start
// property.
func (w widget) SetMarginStart(margin int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.gint)(margin)

	C.gtk_widget_set_margin_start(_arg0, _arg1)
}

// SetMarginTop sets the top margin of @widget. See the Widget:margin-top
// property.
func (w widget) SetMarginTop(margin int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.gint)(margin)

	C.gtk_widget_set_margin_top(_arg0, _arg1)
}

// SetName widgets can be named, which allows you to refer to them from a CSS
// file. You can apply a style to widgets with a particular name in the CSS
// file. See the documentation for the CSS syntax (on the same page as the docs
// for StyleContext).
//
// Note that the CSS syntax has certain special characters to delimit and
// represent elements in a selector (period, #, >, *...), so using these will
// make your widget impossible to match by name. Any combination of alphanumeric
// symbols, dashes and underscores will suffice.
func (w widget) SetName(name string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_widget_set_name(_arg0, _arg1)
}

// SetNoShowAll sets the Widget:no-show-all property, which determines whether
// calls to gtk_widget_show_all() will affect this widget.
//
// This is mostly for use in constructing widget hierarchies with externally
// controlled visibility, see UIManager.
func (w widget) SetNoShowAll(noShowAll bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if noShowAll {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_no_show_all(_arg0, _arg1)
}

// SetOpacity: request the @widget to be rendered partially transparent, with
// opacity 0 being fully transparent and 1 fully opaque. (Opacity values are
// clamped to the [0,1] range.). This works on both toplevel widget, and child
// widgets, although there are some limitations:
//
// For toplevel widgets this depends on the capabilities of the windowing
// system. On X11 this has any effect only on X screens with a compositing
// manager running. See gtk_widget_is_composited(). On Windows it should work
// always, although setting a window’s opacity after the window has been shown
// causes it to flicker once on Windows.
//
// For child widgets it doesn’t work if any affected widget has a native window,
// or disables double buffering.
func (w widget) SetOpacity(opacity float64) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.double     // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.double)(opacity)

	C.gtk_widget_set_opacity(_arg0, _arg1)
}

// SetParent: this function is useful only when implementing subclasses of
// Container. Sets the container as the parent of @widget, and takes care of
// some details such as updating the state and style of the child to reflect its
// new location. The opposite function is gtk_widget_unparent().
func (w widget) SetParent(parent Widget) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(parent.Native()))

	C.gtk_widget_set_parent(_arg0, _arg1)
}

// SetParentWindow sets a non default parent window for @widget.
//
// For Window classes, setting a @parent_window effects whether the window is a
// toplevel window or can be embedded into other widgets.
//
// For Window classes, this needs to be called before the window is realized.
func (w widget) SetParentWindow(parentWindow gdk.Window) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GdkWindow // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GdkWindow)(unsafe.Pointer(parentWindow.Native()))

	C.gtk_widget_set_parent_window(_arg0, _arg1)
}

// SetRealized marks the widget as being realized. This function must only be
// called after all Windows for the @widget have been created and registered.
//
// This function should only ever be called in a derived widget's “realize” or
// “unrealize” implementation.
func (w widget) SetRealized(realized bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if realized {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_realized(_arg0, _arg1)
}

// SetReceivesDefault specifies whether @widget will be treated as the default
// widget within its toplevel when it has the focus, even if another widget is
// the default.
//
// See gtk_widget_grab_default() for details about the meaning of “default”.
func (w widget) SetReceivesDefault(receivesDefault bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if receivesDefault {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_receives_default(_arg0, _arg1)
}

// SetRedrawOnAllocate sets whether the entire widget is queued for drawing when
// its size allocation changes. By default, this setting is true and the entire
// widget is redrawn on every size change. If your widget leaves the upper left
// unchanged when made bigger, turning this setting off will improve
// performance.
//
// Note that for widgets where gtk_widget_get_has_window() is false setting this
// flag to false turns off all allocation on resizing: the widget will not even
// redraw if its position changes; this is to allow containers that don’t draw
// anything to avoid excess invalidations. If you set this flag on a widget with
// no window that does draw on @widget->window, you are responsible for
// invalidating both the old and new allocation of the widget when the widget is
// moved and responsible for invalidating regions newly when the widget
// increases size.
func (w widget) SetRedrawOnAllocate(redrawOnAllocate bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if redrawOnAllocate {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_redraw_on_allocate(_arg0, _arg1)
}

// SetSensitive sets the sensitivity of a widget. A widget is sensitive if the
// user can interact with it. Insensitive widgets are “grayed out” and the user
// can’t interact with them. Insensitive widgets are known as “inactive”,
// “disabled”, or “ghosted” in some other toolkits.
func (w widget) SetSensitive(sensitive bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if sensitive {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_sensitive(_arg0, _arg1)
}

// SetSizeRequest sets the minimum size of a widget; that is, the widget’s size
// request will be at least @width by @height. You can use this function to
// force a widget to be larger than it normally would be.
//
// In most cases, gtk_window_set_default_size() is a better choice for toplevel
// windows than this function; setting the default size will still allow users
// to shrink the window. Setting the size request will force them to leave the
// window at least as large as the size request. When dealing with window sizes,
// gtk_window_set_geometry_hints() can be a useful function as well.
//
// Note the inherent danger of setting any fixed size - themes, translations
// into other languages, different fonts, and user action can all change the
// appropriate size for a given widget. So, it's basically impossible to
// hardcode a size that will always be correct.
//
// The size request of a widget is the smallest size a widget can accept while
// still functioning well and drawing itself correctly. However in some strange
// cases a widget may be allocated less than its requested size, and in many
// cases a widget may be allocated more space than it requested.
//
// If the size request in a given direction is -1 (unset), then the “natural”
// size request of the widget will be used instead.
//
// The size request set here does not include any margin from the Widget
// properties margin-left, margin-right, margin-top, and margin-bottom, but it
// does include pretty much all other padding or border properties set by any
// subclass of Widget.
func (w widget) SetSizeRequest(width int, height int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.gint)(width)
	_arg2 = (C.gint)(height)

	C.gtk_widget_set_size_request(_arg0, _arg1, _arg2)
}

// SetState: this function is for use in widget implementations. Sets the state
// of a widget (insensitive, prelighted, etc.) Usually you should set the state
// using wrapper functions such as gtk_widget_set_sensitive().
func (w widget) SetState(state StateType) {
	var _arg0 *C.GtkWidget   // out
	var _arg1 C.GtkStateType // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GtkStateType)(state)

	C.gtk_widget_set_state(_arg0, _arg1)
}

// SetStateFlags: this function is for use in widget implementations. Turns on
// flag values in the current widget state (insensitive, prelighted, etc.).
//
// This function accepts the values GTK_STATE_FLAG_DIR_LTR and
// GTK_STATE_FLAG_DIR_RTL but ignores them. If you want to set the widget's
// direction, use gtk_widget_set_direction().
//
// It is worth mentioning that any other state than GTK_STATE_FLAG_INSENSITIVE,
// will be propagated down to all non-internal children if @widget is a
// Container, while GTK_STATE_FLAG_INSENSITIVE itself will be propagated down to
// all Container children by different means than turning on the state flag down
// the hierarchy, both gtk_widget_get_state_flags() and
// gtk_widget_is_sensitive() will make use of these.
func (w widget) SetStateFlags(flags StateFlags, clear bool) {
	var _arg0 *C.GtkWidget    // out
	var _arg1 C.GtkStateFlags // out
	var _arg2 C.gboolean      // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GtkStateFlags)(flags)
	if clear {
		_arg2 = C.TRUE
	}

	C.gtk_widget_set_state_flags(_arg0, _arg1, _arg2)
}

// SetStyle: used to set the Style for a widget (@widget->style). Since GTK 3,
// this function does nothing, the passed in style is ignored.
func (w widget) SetStyle(style Style) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkStyle  // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))

	C.gtk_widget_set_style(_arg0, _arg1)
}

// SetSupportMultidevice enables or disables multiple pointer awareness. If this
// setting is true, @widget will start receiving multiple, per device
// enter/leave events. Note that if custom Windows are created in
// Widget::realize, gdk_window_set_support_multidevice() will have to be called
// manually on them.
func (w widget) SetSupportMultidevice(supportMultidevice bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if supportMultidevice {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_support_multidevice(_arg0, _arg1)
}

// SetTooltipMarkup sets @markup as the contents of the tooltip, which is marked
// up with the [Pango text markup language][PangoMarkupFormat].
//
// This function will take care of setting Widget:has-tooltip to true and of the
// default handler for the Widget::query-tooltip signal.
//
// See also the Widget:tooltip-markup property and gtk_tooltip_set_markup().
func (w widget) SetTooltipMarkup(markup string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.gchar)(C.CString(markup))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_widget_set_tooltip_markup(_arg0, _arg1)
}

// SetTooltipText sets @text as the contents of the tooltip. This function will
// take care of setting Widget:has-tooltip to true and of the default handler
// for the Widget::query-tooltip signal.
//
// See also the Widget:tooltip-text property and gtk_tooltip_set_text().
func (w widget) SetTooltipText(text string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_widget_set_tooltip_text(_arg0, _arg1)
}

// SetTooltipWindow replaces the default window used for displaying tooltips
// with @custom_window. GTK+ will take care of showing and hiding @custom_window
// at the right moment, to behave likewise as the default tooltip window. If
// @custom_window is nil, the default tooltip window will be used.
func (w widget) SetTooltipWindow(customWindow Window) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWindow // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWindow)(unsafe.Pointer(customWindow.Native()))

	C.gtk_widget_set_tooltip_window(_arg0, _arg1)
}

// SetValign sets the vertical alignment of @widget. See the Widget:valign
// property.
func (w widget) SetValign(align Align) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.GtkAlign   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GtkAlign)(align)

	C.gtk_widget_set_valign(_arg0, _arg1)
}

// SetVexpand sets whether the widget would like any available extra vertical
// space.
//
// See gtk_widget_set_hexpand() for more detail.
func (w widget) SetVexpand(expand bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if expand {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_vexpand(_arg0, _arg1)
}

// SetVexpandSet sets whether the vexpand flag (see gtk_widget_get_vexpand())
// will be used.
//
// See gtk_widget_set_hexpand_set() for more detail.
func (w widget) SetVexpandSet(set bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if set {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_vexpand_set(_arg0, _arg1)
}

// SetVisible sets the visibility state of @widget. Note that setting this to
// true doesn’t mean the widget is actually viewable, see
// gtk_widget_get_visible().
//
// This function simply calls gtk_widget_show() or gtk_widget_hide() but is
// nicer to use when the visibility of the widget depends on some condition.
func (w widget) SetVisible(visible bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if visible {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_visible(_arg0, _arg1)
}

// SetVisual sets the visual that should be used for by widget and its children
// for creating Windows. The visual must be on the same Screen as returned by
// gtk_widget_get_screen(), so handling the Widget::screen-changed signal is
// necessary.
//
// Setting a new @visual will not cause @widget to recreate its windows, so you
// should call this function before @widget is realized.
func (w widget) SetVisual(visual gdk.Visual) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GdkVisual // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GdkVisual)(unsafe.Pointer(visual.Native()))

	C.gtk_widget_set_visual(_arg0, _arg1)
}

// SetWindow sets a widget’s window. This function should only be used in a
// widget’s Widget::realize implementation. The window passed is usually either
// new window created with gdk_window_new(), or the window of its parent widget
// as returned by gtk_widget_get_parent_window().
//
// Widgets must indicate whether they will create their own Window by calling
// gtk_widget_set_has_window(). This is usually done in the widget’s init()
// function.
//
// Note that this function does not add any reference to @window.
func (w widget) SetWindow(window gdk.Window) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GdkWindow // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_widget_set_window(_arg0, _arg1)
}

// ShapeCombineRegion sets a shape for this widget’s GDK window. This allows for
// transparent windows etc., see gdk_window_shape_combine_region() for more
// information.
func (w widget) ShapeCombineRegion(region *cairo.Region) {
	var _arg0 *C.GtkWidget      // out
	var _arg1 *C.cairo_region_t // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))

	C.gtk_widget_shape_combine_region(_arg0, _arg1)
}

// Show flags a widget to be displayed. Any widget that isn’t shown will not
// appear on the screen. If you want to show all the widgets in a container,
// it’s easier to call gtk_widget_show_all() on the container, instead of
// individually showing the widgets.
//
// Remember that you have to show the containers containing a widget, in
// addition to the widget itself, before it will appear onscreen.
//
// When a toplevel container is shown, it is immediately realized and mapped;
// other shown widgets are realized and mapped when their toplevel container is
// realized and mapped.
func (w widget) Show() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_show(_arg0)
}

// ShowAll: recursively shows a widget, and any child widgets (if the widget is
// a container).
func (w widget) ShowAll() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_show_all(_arg0)
}

// ShowNow shows a widget. If the widget is an unmapped toplevel widget (i.e. a
// Window that has not yet been shown), enter the main loop and wait for the
// window to actually be mapped. Be careful; because the main loop is running,
// anything can happen during this function.
func (w widget) ShowNow() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_show_now(_arg0)
}

// SizeRequest: this function is typically used when implementing a Container
// subclass. Obtains the preferred size of a widget. The container uses this
// information to arrange its child widgets and decide what size allocations to
// give them with gtk_widget_size_allocate().
//
// You can also call this function from an application, with some caveats. Most
// notably, getting a size request requires the widget to be associated with a
// screen, because font information may be needed. Multihead-aware applications
// should keep this in mind.
//
// Also remember that the size request is not necessarily the size a widget will
// actually be allocated.
func (w widget) SizeRequest() Requisition {
	var _arg0 *C.GtkWidget // out
	var _requisition Requisition

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_size_request(_arg0, (*C.GtkRequisition)(unsafe.Pointer(&_requisition)))

	return _requisition
}

// StyleAttach: this function attaches the widget’s Style to the widget's
// Window. It is a replacement for
//
//    widget->style = gtk_style_attach (widget->style, widget->window);
//
// and should only ever be called in a derived widget’s “realize” implementation
// which does not chain up to its parent class' “realize” implementation,
// because one of the parent classes (finally Widget) would attach the style
// itself.
func (w widget) StyleAttach() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_style_attach(_arg0)
}

// StyleGetProperty gets the value of a style property of @widget.
func (w widget) StyleGetProperty(propertyName string, value **externglib.Value) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.GValue    // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.gchar)(C.CString(propertyName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GValue)(value.GValue)

	C.gtk_widget_style_get_property(_arg0, _arg1, _arg2)
}

// ThawChildNotify reverts the effect of a previous call to
// gtk_widget_freeze_child_notify(). This causes all queued Widget::child-notify
// signals on @widget to be emitted.
func (w widget) ThawChildNotify() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_thaw_child_notify(_arg0)
}

// TranslateCoordinates: translate coordinates relative to @src_widget’s
// allocation to coordinates relative to @dest_widget’s allocations. In order to
// perform this operation, both widgets must be realized, and must share a
// common toplevel.
func (s widget) TranslateCoordinates(destWidget Widget, srcX int, srcY int) (destX int, destY int, ok bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out
	var _arg2 C.gint       // out
	var _arg3 C.gint       // out
	var _arg4 C.gint       // in
	var _arg5 C.gint       // in
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(destWidget.Native()))
	_arg2 = (C.gint)(srcX)
	_arg3 = (C.gint)(srcY)

	_cret = C.gtk_widget_translate_coordinates(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)

	var _destX int // out
	var _destY int // out
	var _ok bool   // out

	_destX = (int)(_arg4)
	_destY = (int)(_arg5)
	if _cret != 0 {
		_ok = true
	}

	return _destX, _destY, _ok
}

// TriggerTooltipQuery triggers a tooltip query on the display where the
// toplevel of @widget is located. See gtk_tooltip_trigger_tooltip_query() for
// more information.
func (w widget) TriggerTooltipQuery() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_trigger_tooltip_query(_arg0)
}

// Unmap: this function is only for use in widget implementations. Causes a
// widget to be unmapped if it’s currently mapped.
func (w widget) Unmap() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_unmap(_arg0)
}

// Unparent: this function is only for use in widget implementations. Should be
// called by implementations of the remove method on Container, to dissociate a
// child from the container.
func (w widget) Unparent() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_unparent(_arg0)
}

// Unrealize: this function is only useful in widget implementations. Causes a
// widget to be unrealized (frees all GDK resources associated with the widget,
// such as @widget->window).
func (w widget) Unrealize() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_unrealize(_arg0)
}

// UnregisterWindow unregisters a Window from the widget that was previously set
// up with gtk_widget_register_window(). You need to call this when the window
// is no longer used by the widget, such as when you destroy it.
func (w widget) UnregisterWindow(window gdk.Window) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GdkWindow // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_widget_unregister_window(_arg0, _arg1)
}

// UnsetStateFlags: this function is for use in widget implementations. Turns
// off flag values for the current widget state (insensitive, prelighted, etc.).
// See gtk_widget_set_state_flags().
func (w widget) UnsetStateFlags(flags StateFlags) {
	var _arg0 *C.GtkWidget    // out
	var _arg1 C.GtkStateFlags // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GtkStateFlags)(flags)

	C.gtk_widget_unset_state_flags(_arg0, _arg1)
}

// Window: a GtkWindow is a toplevel window which can contain other widgets.
// Windows normally have decorations that are under the control of the windowing
// system and allow the user to manipulate the window (resize it, move it, close
// it,...).
//
//
// GtkWindow as GtkBuildable
//
// The GtkWindow implementation of the Buildable interface supports a custom
// <accel-groups> element, which supports any number of <group> elements
// representing the AccelGroup objects you want to add to your window
// (synonymous with gtk_window_add_accel_group().
//
// It also supports the <initial-focus> element, whose name property names the
// widget to receive the focus when the window is mapped.
//
// An example of a UI definition fragment with accel groups:
//
//    <object class="GtkWindow">
//      <accel-groups>
//        <group name="accelgroup1"/>
//      </accel-groups>
//      <initial-focus name="thunderclap"/>
//    </object>
//
//    ...
//
//    <object class="GtkAccelGroup" id="accelgroup1"/>
//
// The GtkWindow implementation of the Buildable interface supports setting a
// child as the titlebar by specifying “titlebar” as the “type” attribute of a
// <child> element.
//
// CSS nodes
//
//    window.background
//    ├── decoration
//    ├── <titlebar child>.titlebar [.default-decoration]
//    ╰── <child>
//
// GtkWindow has a main CSS node with name window and style class .background,
// and a subnode with name decoration.
//
// Style classes that are typically used with the main CSS node are .csd (when
// client-side decorations are in use), .solid-csd (for client-side decorations
// without invisible borders), .ssd (used by mutter when rendering server-side
// decorations). GtkWindow also represents window states with the following
// style classes on the main node: .tiled, .maximized, .fullscreen. Specialized
// types of window often add their own discriminating style classes, such as
// .popup or .tooltip.
//
// GtkWindow adds the .titlebar and .default-decoration style classes to the
// widget that is added as a titlebar child.
type Window interface {
	Bin
	Buildable

	// ActivateDefault activates the default widget for the window, unless the
	// current focused widget has been configured to receive the default action
	// (see gtk_widget_set_receives_default()), in which case the focused widget
	// is activated.
	ActivateDefault() bool
	// ActivateFocus activates the current focused widget within the window.
	ActivateFocus() bool
	// ActivateKey activates mnemonics and accelerators for this Window. This is
	// normally called by the default ::key_press_event handler for toplevel
	// windows, however in some cases it may be useful to call this directly
	// when overriding the standard key handling for a toplevel window.
	ActivateKey(event *gdk.EventKey) bool
	// AddAccelGroup: associate @accel_group with @window, such that calling
	// gtk_accel_groups_activate() on @window will activate accelerators in
	// @accel_group.
	AddAccelGroup(accelGroup AccelGroup)
	// AddMnemonic adds a mnemonic to this window.
	AddMnemonic(keyval uint, target Widget)
	// BeginMoveDrag starts moving a window. This function is used if an
	// application has window movement grips. When GDK can support it, the
	// window movement will be done using the standard mechanism for the [window
	// manager][gtk-X11-arch] or windowing system. Otherwise, GDK will try to
	// emulate window movement, potentially not all that well, depending on the
	// windowing system.
	BeginMoveDrag(button int, rootX int, rootY int, timestamp uint32)
	// BeginResizeDrag starts resizing a window. This function is used if an
	// application has window resizing controls. When GDK can support it, the
	// resize will be done using the standard mechanism for the [window
	// manager][gtk-X11-arch] or windowing system. Otherwise, GDK will try to
	// emulate window resizing, potentially not all that well, depending on the
	// windowing system.
	BeginResizeDrag(edge gdk.WindowEdge, button int, rootX int, rootY int, timestamp uint32)
	// Close requests that the window is closed, similar to what happens when a
	// window manager close button is clicked.
	//
	// This function can be used with close buttons in custom titlebars.
	Close()
	// Deiconify asks to deiconify (i.e. unminimize) the specified @window. Note
	// that you shouldn’t assume the window is definitely deiconified afterward,
	// because other entities (e.g. the user or [window manager][gtk-X11-arch]))
	// could iconify it again before your code which assumes deiconification
	// gets to run.
	//
	// You can track iconification via the “window-state-event” signal on
	// Widget.
	Deiconify()
	// Fullscreen asks to place @window in the fullscreen state. Note that you
	// shouldn’t assume the window is definitely full screen afterward, because
	// other entities (e.g. the user or [window manager][gtk-X11-arch]) could
	// unfullscreen it again, and not all window managers honor requests to
	// fullscreen windows. But normally the window will end up fullscreen. Just
	// don’t write code that crashes if not.
	//
	// You can track the fullscreen state via the “window-state-event” signal on
	// Widget.
	Fullscreen()
	// FullscreenOnMonitor asks to place @window in the fullscreen state. Note
	// that you shouldn't assume the window is definitely full screen afterward.
	//
	// You can track the fullscreen state via the "window-state-event" signal on
	// Widget.
	FullscreenOnMonitor(screen gdk.Screen, monitor int)
	// AcceptFocus gets the value set by gtk_window_set_accept_focus().
	AcceptFocus() bool
	// Application gets the Application associated with the window (if any).
	Application() Application
	// AttachedTo fetches the attach widget for this window. See
	// gtk_window_set_attached_to().
	AttachedTo() Widget
	// Decorated returns whether the window has been set to have decorations
	// such as a title bar via gtk_window_set_decorated().
	Decorated() bool
	// DefaultSize gets the default size of the window. A value of -1 for the
	// width or height indicates that a default size has not been explicitly set
	// for that dimension, so the “natural” size of the window will be used.
	DefaultSize() (width int, height int)
	// DefaultWidget returns the default widget for @window. See
	// gtk_window_set_default() for more details.
	DefaultWidget() Widget
	// Deletable returns whether the window has been set to have a close button
	// via gtk_window_set_deletable().
	Deletable() bool
	// DestroyWithParent returns whether the window will be destroyed with its
	// transient parent. See gtk_window_set_destroy_with_parent ().
	DestroyWithParent() bool
	// Focus retrieves the current focused widget within the window. Note that
	// this is the widget that would have the focus if the toplevel window
	// focused; if the toplevel window is not focused then `gtk_widget_has_focus
	// (widget)` will not be true for the widget.
	Focus() Widget
	// FocusOnMap gets the value set by gtk_window_set_focus_on_map().
	FocusOnMap() bool
	// FocusVisible gets the value of the Window:focus-visible property.
	FocusVisible() bool
	// Gravity gets the value set by gtk_window_set_gravity().
	Gravity() gdk.Gravity
	// Group returns the group for @window or the default group, if @window is
	// nil or if @window does not have an explicit window group.
	Group() WindowGroup
	// HasResizeGrip determines whether the window may have a resize grip.
	HasResizeGrip() bool
	// HideTitlebarWhenMaximized returns whether the window has requested to
	// have its titlebar hidden when maximized. See
	// gtk_window_set_hide_titlebar_when_maximized ().
	HideTitlebarWhenMaximized() bool
	// Icon gets the value set by gtk_window_set_icon() (or if you've called
	// gtk_window_set_icon_list(), gets the first icon in the icon list).
	Icon() gdkpixbuf.Pixbuf
	// IconName returns the name of the themed icon for the window, see
	// gtk_window_set_icon_name().
	IconName() string
	// MnemonicModifier returns the mnemonic modifier for this window. See
	// gtk_window_set_mnemonic_modifier().
	MnemonicModifier() gdk.ModifierType
	// MnemonicsVisible gets the value of the Window:mnemonics-visible property.
	MnemonicsVisible() bool
	// Modal returns whether the window is modal. See gtk_window_set_modal().
	Modal() bool
	// Opacity fetches the requested opacity for this window. See
	// gtk_window_set_opacity().
	Opacity() float64
	// Position: this function returns the position you need to pass to
	// gtk_window_move() to keep @window in its current position. This means
	// that the meaning of the returned value varies with window gravity. See
	// gtk_window_move() for more details.
	//
	// The reliability of this function depends on the windowing system
	// currently in use. Some windowing systems, such as Wayland, do not support
	// a global coordinate system, and thus the position of the window will
	// always be (0, 0). Others, like X11, do not have a reliable way to obtain
	// the geometry of the decorations of a window if they are provided by the
	// window manager. Additionally, on X11, window manager have been known to
	// mismanage window gravity, which result in windows moving even if you use
	// the coordinates of the current position as returned by this function.
	//
	// If you haven’t changed the window gravity, its gravity will be
	// K_GRAVITY_NORTH_WEST. This means that gtk_window_get_position() gets the
	// position of the top-left corner of the window manager frame for the
	// window. gtk_window_move() sets the position of this same top-left corner.
	//
	// If a window has gravity K_GRAVITY_STATIC the window manager frame is not
	// relevant, and thus gtk_window_get_position() will always produce accurate
	// results. However you can’t use static gravity to do things like place a
	// window in a corner of the screen, because static gravity ignores the
	// window manager decorations.
	//
	// Ideally, this function should return appropriate values if the window has
	// client side decorations, assuming that the windowing system supports
	// global coordinates.
	//
	// In practice, saving the window position should not be left to
	// applications, as they lack enough knowledge of the windowing system and
	// the window manager state to effectively do so. The appropriate way to
	// implement saving the window position is to use a platform-specific
	// protocol, wherever that is available.
	Position() (rootX int, rootY int)
	// Resizable gets the value set by gtk_window_set_resizable().
	Resizable() bool
	// ResizeGripArea: if a window has a resize grip, this will retrieve the
	// grip position, width and height into the specified Rectangle.
	ResizeGripArea() (gdk.Rectangle, bool)
	// Role returns the role of the window. See gtk_window_set_role() for
	// further explanation.
	Role() string
	// Screen returns the Screen associated with @window.
	Screen() gdk.Screen
	// Size obtains the current size of @window.
	//
	// If @window is not visible on screen, this function return the size GTK+
	// will suggest to the [window manager][gtk-X11-arch] for the initial window
	// size (but this is not reliably the same as the size the window manager
	// will actually select). See: gtk_window_set_default_size().
	//
	// Depending on the windowing system and the window manager constraints, the
	// size returned by this function may not match the size set using
	// gtk_window_resize(); additionally, since gtk_window_resize() may be
	// implemented as an asynchronous operation, GTK+ cannot guarantee in any
	// way that this code:
	//
	//    static void
	//    on_size_allocate (GtkWidget *widget, GtkAllocation *allocation)
	//    {
	//      int new_width, new_height;
	//
	//      gtk_window_get_size (GTK_WINDOW (widget), &new_width, &new_height);
	//
	//      ...
	//    }
	//
	// Note that, if you connect to the Widget::size-allocate signal, you should
	// not use the dimensions of the Allocation passed to the signal handler, as
	// the allocation may contain client side decorations added by GTK+,
	// depending on the windowing system in use.
	//
	// If you are getting a window size in order to position the window on the
	// screen, you should, instead, simply set the window’s semantic type with
	// gtk_window_set_type_hint(), which allows the window manager to e.g.
	// center dialogs. Also, if you set the transient parent of dialogs with
	// gtk_window_set_transient_for() window managers will often center the
	// dialog over its parent window. It's much preferred to let the window
	// manager handle these cases rather than doing it yourself, because all
	// apps will behave consistently and according to user or system
	// preferences, if the window manager handles it. Also, the window manager
	// can take into account the size of the window decorations and border that
	// it may add, and of which GTK+ has no knowledge. Additionally, positioning
	// windows in global screen coordinates may not be allowed by the windowing
	// system. For more information, see: gtk_window_set_position().
	Size() (width int, height int)
	// SkipPagerHint gets the value set by gtk_window_set_skip_pager_hint().
	SkipPagerHint() bool
	// SkipTaskbarHint gets the value set by gtk_window_set_skip_taskbar_hint()
	SkipTaskbarHint() bool
	// Title retrieves the title of the window. See gtk_window_set_title().
	Title() string
	// Titlebar returns the custom titlebar that has been set with
	// gtk_window_set_titlebar().
	Titlebar() Widget
	// TransientFor fetches the transient parent for this window. See
	// gtk_window_set_transient_for().
	TransientFor() Window
	// TypeHint gets the type hint for this window. See
	// gtk_window_set_type_hint().
	TypeHint() gdk.WindowTypeHint
	// UrgencyHint gets the value set by gtk_window_set_urgency_hint()
	UrgencyHint() bool
	// WindowType gets the type of the window. See WindowType.
	WindowType() WindowType
	// HasGroup returns whether @window has an explicit window group.
	HasGroup() bool
	// HasToplevelFocus returns whether the input focus is within this
	// GtkWindow. For real toplevel windows, this is identical to
	// gtk_window_is_active(), but for embedded windows, like Plug, the results
	// will differ.
	HasToplevelFocus() bool
	// Iconify asks to iconify (i.e. minimize) the specified @window. Note that
	// you shouldn’t assume the window is definitely iconified afterward,
	// because other entities (e.g. the user or [window manager][gtk-X11-arch])
	// could deiconify it again, or there may not be a window manager in which
	// case iconification isn’t possible, etc. But normally the window will end
	// up iconified. Just don’t write code that crashes if not.
	//
	// It’s permitted to call this function before showing a window, in which
	// case the window will be iconified before it ever appears onscreen.
	//
	// You can track iconification via the “window-state-event” signal on
	// Widget.
	Iconify()
	// IsActive returns whether the window is part of the current active
	// toplevel. (That is, the toplevel window receiving keystrokes.) The return
	// value is true if the window is active toplevel itself, but also if it is,
	// say, a Plug embedded in the active toplevel. You might use this function
	// if you wanted to draw a widget differently in an active window from a
	// widget in an inactive window. See gtk_window_has_toplevel_focus()
	IsActive() bool
	// IsMaximized retrieves the current maximized state of @window.
	//
	// Note that since maximization is ultimately handled by the window manager
	// and happens asynchronously to an application request, you shouldn’t
	// assume the return value of this function changing immediately (or at
	// all), as an effect of calling gtk_window_maximize() or
	// gtk_window_unmaximize().
	IsMaximized() bool
	// Maximize asks to maximize @window, so that it becomes full-screen. Note
	// that you shouldn’t assume the window is definitely maximized afterward,
	// because other entities (e.g. the user or [window manager][gtk-X11-arch])
	// could unmaximize it again, and not all window managers support
	// maximization. But normally the window will end up maximized. Just don’t
	// write code that crashes if not.
	//
	// It’s permitted to call this function before showing a window, in which
	// case the window will be maximized when it appears onscreen initially.
	//
	// You can track maximization via the “window-state-event” signal on Widget,
	// or by listening to notifications on the Window:is-maximized property.
	Maximize()
	// MnemonicActivate activates the targets associated with the mnemonic.
	MnemonicActivate(keyval uint, modifier gdk.ModifierType) bool
	// Move asks the [window manager][gtk-X11-arch] to move @window to the given
	// position. Window managers are free to ignore this; most window managers
	// ignore requests for initial window positions (instead using a
	// user-defined placement algorithm) and honor requests after the window has
	// already been shown.
	//
	// Note: the position is the position of the gravity-determined reference
	// point for the window. The gravity determines two things: first, the
	// location of the reference point in root window coordinates; and second,
	// which point on the window is positioned at the reference point.
	//
	// By default the gravity is K_GRAVITY_NORTH_WEST, so the reference point is
	// simply the @x, @y supplied to gtk_window_move(). The top-left corner of
	// the window decorations (aka window frame or border) will be placed at @x,
	// @y. Therefore, to position a window at the top left of the screen, you
	// want to use the default gravity (which is K_GRAVITY_NORTH_WEST) and move
	// the window to 0,0.
	//
	// To position a window at the bottom right corner of the screen, you would
	// set K_GRAVITY_SOUTH_EAST, which means that the reference point is at @x +
	// the window width and @y + the window height, and the bottom-right corner
	// of the window border will be placed at that reference point. So, to place
	// a window in the bottom right corner you would first set gravity to south
	// east, then write: `gtk_window_move (window, gdk_screen_width () -
	// window_width, gdk_screen_height () - window_height)` (note that this
	// example does not take multi-head scenarios into account).
	//
	// The Extended Window Manager Hints Specification
	// (http://www.freedesktop.org/Standards/wm-spec) has a nice table of
	// gravities in the “implementation notes” section.
	//
	// The gtk_window_get_position() documentation may also be relevant.
	Move(x int, y int)
	// ParseGeometry parses a standard X Window System geometry string - see the
	// manual page for X (type “man X”) for details on this.
	// gtk_window_parse_geometry() does work on all GTK+ ports including Win32
	// but is primarily intended for an X environment.
	//
	// If either a size or a position can be extracted from the geometry string,
	// gtk_window_parse_geometry() returns true and calls
	// gtk_window_set_default_size() and/or gtk_window_move() to resize/move the
	// window.
	//
	// If gtk_window_parse_geometry() returns true, it will also set the
	// K_HINT_USER_POS and/or K_HINT_USER_SIZE hints indicating to the window
	// manager that the size/position of the window was user-specified. This
	// causes most window managers to honor the geometry.
	//
	// Note that for gtk_window_parse_geometry() to work as expected, it has to
	// be called when the window has its “final” size, i.e. after calling
	// gtk_widget_show_all() on the contents and gtk_window_set_geometry_hints()
	// on the window.
	//
	//    #include <gtk/gtk.h>
	//
	//    static void
	//    fill_with_content (GtkWidget *vbox)
	//    {
	//      // fill with content...
	//    }
	//
	//    int
	//    main (int argc, char *argv[])
	//    {
	//      GtkWidget *window, *vbox;
	//      GdkGeometry size_hints = {
	//        100, 50, 0, 0, 100, 50, 10,
	//        10, 0.0, 0.0, GDK_GRAVITY_NORTH_WEST
	//      };
	//
	//      gtk_init (&argc, &argv);
	//
	//      window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
	//      vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
	//
	//      gtk_container_add (GTK_CONTAINER (window), vbox);
	//      fill_with_content (vbox);
	//      gtk_widget_show_all (vbox);
	//
	//      gtk_window_set_geometry_hints (GTK_WINDOW (window),
	//    	  			    NULL,
	//    				    &size_hints,
	//    				    GDK_HINT_MIN_SIZE |
	//    				    GDK_HINT_BASE_SIZE |
	//    				    GDK_HINT_RESIZE_INC);
	//
	//      if (argc > 1)
	//        {
	//          gboolean res;
	//          res = gtk_window_parse_geometry (GTK_WINDOW (window),
	//                                           argv[1]);
	//          if (! res)
	//            fprintf (stderr,
	//                     "Failed to parse “s”\n",
	//                     argv[1]);
	//        }
	//
	//      gtk_widget_show_all (window);
	//      gtk_main ();
	//
	//      return 0;
	//    }
	ParseGeometry(geometry string) bool
	// Present presents a window to the user. This function should not be used
	// as when it is called, it is too late to gather a valid timestamp to allow
	// focus stealing prevention to work correctly.
	Present()
	// PresentWithTime presents a window to the user. This may mean raising the
	// window in the stacking order, deiconifying it, moving it to the current
	// desktop, and/or giving it the keyboard focus, possibly dependent on the
	// user’s platform, window manager, and preferences.
	//
	// If @window is hidden, this function calls gtk_widget_show() as well.
	//
	// This function should be used when the user tries to open a window that’s
	// already open. Say for example the preferences dialog is currently open,
	// and the user chooses Preferences from the menu a second time; use
	// gtk_window_present() to move the already-open dialog where the user can
	// see it.
	//
	// Presents a window to the user in response to a user interaction. The
	// timestamp should be gathered when the window was requested to be shown
	// (when clicking a link for example), rather than once the window is ready
	// to be shown.
	PresentWithTime(timestamp uint32)
	// PropagateKeyEvent: propagate a key press or release event to the focus
	// widget and up the focus container chain until a widget handles @event.
	// This is normally called by the default ::key_press_event and
	// ::key_release_event handlers for toplevel windows, however in some cases
	// it may be useful to call this directly when overriding the standard key
	// handling for a toplevel window.
	PropagateKeyEvent(event *gdk.EventKey) bool
	// RemoveAccelGroup reverses the effects of gtk_window_add_accel_group().
	RemoveAccelGroup(accelGroup AccelGroup)
	// RemoveMnemonic removes a mnemonic from this window.
	RemoveMnemonic(keyval uint, target Widget)
	// ReshowWithInitialSize hides @window, then reshows it, resetting the
	// default size and position of the window. Used by GUI builders only.
	ReshowWithInitialSize()
	// Resize resizes the window as if the user had done so, obeying geometry
	// constraints. The default geometry constraint is that windows may not be
	// smaller than their size request; to override this constraint, call
	// gtk_widget_set_size_request() to set the window's request to a smaller
	// value.
	//
	// If gtk_window_resize() is called before showing a window for the first
	// time, it overrides any default size set with
	// gtk_window_set_default_size().
	//
	// Windows may not be resized smaller than 1 by 1 pixels.
	//
	// When using client side decorations, GTK+ will do its best to adjust the
	// given size so that the resulting window size matches the requested size
	// without the title bar, borders and shadows added for the client side
	// decorations, but there is no guarantee that the result will be totally
	// accurate because these widgets added for client side decorations depend
	// on the theme and may not be realized or visible at the time
	// gtk_window_resize() is issued.
	//
	// If the GtkWindow has a titlebar widget (see gtk_window_set_titlebar()),
	// then typically, gtk_window_resize() will compensate for the height of the
	// titlebar widget only if the height is known when the resulting GtkWindow
	// configuration is issued. For example, if new widgets are added after the
	// GtkWindow configuration and cause the titlebar widget to grow in height,
	// this will result in a window content smaller that specified by
	// gtk_window_resize() and not a larger window.
	Resize(width int, height int)
	// ResizeGripIsVisible determines whether a resize grip is visible for the
	// specified window.
	ResizeGripIsVisible() bool
	// ResizeToGeometry: like gtk_window_resize(), but @width and @height are
	// interpreted in terms of the base size and increment set with
	// gtk_window_set_geometry_hints.
	ResizeToGeometry(width int, height int)
	// SetAcceptFocus windows may set a hint asking the desktop environment not
	// to receive the input focus. This function sets this hint.
	SetAcceptFocus(setting bool)
	// SetApplication sets or unsets the Application associated with the window.
	//
	// The application will be kept alive for at least as long as it has any
	// windows associated with it (see g_application_hold() for a way to keep it
	// alive without windows).
	//
	// Normally, the connection between the application and the window will
	// remain until the window is destroyed, but you can explicitly remove it by
	// setting the @application to nil.
	//
	// This is equivalent to calling gtk_application_remove_window() and/or
	// gtk_application_add_window() on the old/new applications as relevant.
	SetApplication(application Application)
	// SetAttachedTo marks @window as attached to @attach_widget. This creates a
	// logical binding between the window and the widget it belongs to, which is
	// used by GTK+ to propagate information such as styling or accessibility to
	// @window as if it was a children of @attach_widget.
	//
	// Examples of places where specifying this relation is useful are for
	// instance a Menu created by a ComboBox, a completion popup window created
	// by Entry or a typeahead search entry created by TreeView.
	//
	// Note that this function should not be confused with
	// gtk_window_set_transient_for(), which specifies a window manager relation
	// between two toplevels instead.
	//
	// Passing nil for @attach_widget detaches the window.
	SetAttachedTo(attachWidget Widget)
	// SetDecorated: by default, windows are decorated with a title bar, resize
	// controls, etc. Some [window managers][gtk-X11-arch] allow GTK+ to disable
	// these decorations, creating a borderless window. If you set the decorated
	// property to false using this function, GTK+ will do its best to convince
	// the window manager not to decorate the window. Depending on the system,
	// this function may not have any effect when called on a window that is
	// already visible, so you should call it before calling gtk_widget_show().
	//
	// On Windows, this function always works, since there’s no window manager
	// policy involved.
	SetDecorated(setting bool)
	// SetDefault: the default widget is the widget that’s activated when the
	// user presses Enter in a dialog (for example). This function sets or
	// unsets the default widget for a Window. When setting (rather than
	// unsetting) the default widget it’s generally easier to call
	// gtk_widget_grab_default() on the widget. Before making a widget the
	// default widget, you must call gtk_widget_set_can_default() on the widget
	// you’d like to make the default.
	SetDefault(defaultWidget Widget)
	// SetDefaultGeometry: like gtk_window_set_default_size(), but @width and
	// @height are interpreted in terms of the base size and increment set with
	// gtk_window_set_geometry_hints.
	SetDefaultGeometry(width int, height int)
	// SetDefaultSize sets the default size of a window. If the window’s
	// “natural” size (its size request) is larger than the default, the default
	// will be ignored. More generally, if the default size does not obey the
	// geometry hints for the window (gtk_window_set_geometry_hints() can be
	// used to set these explicitly), the default size will be clamped to the
	// nearest permitted size.
	//
	// Unlike gtk_widget_set_size_request(), which sets a size request for a
	// widget and thus would keep users from shrinking the window, this function
	// only sets the initial size, just as if the user had resized the window
	// themselves. Users can still shrink the window again as they normally
	// would. Setting a default size of -1 means to use the “natural” default
	// size (the size request of the window).
	//
	// For more control over a window’s initial size and how resizing works,
	// investigate gtk_window_set_geometry_hints().
	//
	// For some uses, gtk_window_resize() is a more appropriate function.
	// gtk_window_resize() changes the current size of the window, rather than
	// the size to be used on initial display. gtk_window_resize() always
	// affects the window itself, not the geometry widget.
	//
	// The default size of a window only affects the first time a window is
	// shown; if a window is hidden and re-shown, it will remember the size it
	// had prior to hiding, rather than using the default size.
	//
	// Windows can’t actually be 0x0 in size, they must be at least 1x1, but
	// passing 0 for @width and @height is OK, resulting in a 1x1 default size.
	//
	// If you use this function to reestablish a previously saved window size,
	// note that the appropriate size to save is the one returned by
	// gtk_window_get_size(). Using the window allocation directly will not work
	// in all circumstances and can lead to growing or shrinking windows.
	SetDefaultSize(width int, height int)
	// SetDeletable: by default, windows have a close button in the window
	// frame. Some [window managers][gtk-X11-arch] allow GTK+ to disable this
	// button. If you set the deletable property to false using this function,
	// GTK+ will do its best to convince the window manager not to show a close
	// button. Depending on the system, this function may not have any effect
	// when called on a window that is already visible, so you should call it
	// before calling gtk_widget_show().
	//
	// On Windows, this function always works, since there’s no window manager
	// policy involved.
	SetDeletable(setting bool)
	// SetDestroyWithParent: if @setting is true, then destroying the transient
	// parent of @window will also destroy @window itself. This is useful for
	// dialogs that shouldn’t persist beyond the lifetime of the main window
	// they're associated with, for example.
	SetDestroyWithParent(setting bool)
	// SetFocus: if @focus is not the current focus widget, and is focusable,
	// sets it as the focus widget for the window. If @focus is nil, unsets the
	// focus widget for this window. To set the focus to a particular widget in
	// the toplevel, it is usually more convenient to use
	// gtk_widget_grab_focus() instead of this function.
	SetFocus(focus Widget)
	// SetFocusOnMap windows may set a hint asking the desktop environment not
	// to receive the input focus when the window is mapped. This function sets
	// this hint.
	SetFocusOnMap(setting bool)
	// SetFocusVisible sets the Window:focus-visible property.
	SetFocusVisible(setting bool)
	// SetGeometryHints: this function sets up hints about how a window can be
	// resized by the user. You can set a minimum and maximum size; allowed
	// resize increments (e.g. for xterm, you can only resize by the size of a
	// character); aspect ratios; and more. See the Geometry struct.
	SetGeometryHints(geometryWidget Widget, geometry *gdk.Geometry, geomMask gdk.WindowHints)
	// SetGravity: window gravity defines the meaning of coordinates passed to
	// gtk_window_move(). See gtk_window_move() and Gravity for more details.
	//
	// The default window gravity is K_GRAVITY_NORTH_WEST which will typically
	// “do what you mean.”
	SetGravity(gravity gdk.Gravity)
	// SetHasResizeGrip sets whether @window has a corner resize grip.
	//
	// Note that the resize grip is only shown if the window is actually
	// resizable and not maximized. Use gtk_window_resize_grip_is_visible() to
	// find out if the resize grip is currently shown.
	SetHasResizeGrip(value bool)
	// SetHasUserRefCount tells GTK+ whether to drop its extra reference to the
	// window when gtk_widget_destroy() is called.
	//
	// This function is only exported for the benefit of language bindings which
	// may need to keep the window alive until their wrapper object is garbage
	// collected. There is no justification for ever calling this function in an
	// application.
	SetHasUserRefCount(setting bool)
	// SetHideTitlebarWhenMaximized: if @setting is true, then @window will
	// request that it’s titlebar should be hidden when maximized. This is
	// useful for windows that don’t convey any information other than the
	// application name in the titlebar, to put the available screen space to
	// better use. If the underlying window system does not support the request,
	// the setting will not have any effect.
	//
	// Note that custom titlebars set with gtk_window_set_titlebar() are not
	// affected by this. The application is in full control of their content and
	// visibility anyway.
	SetHideTitlebarWhenMaximized(setting bool)
	// SetIcon sets up the icon representing a Window. This icon is used when
	// the window is minimized (also known as iconified). Some window managers
	// or desktop environments may also place it in the window frame, or display
	// it in other contexts. On others, the icon is not used at all, so your
	// mileage may vary.
	//
	// The icon should be provided in whatever size it was naturally drawn; that
	// is, don’t scale the image before passing it to GTK+. Scaling is postponed
	// until the last minute, when the desired final size is known, to allow
	// best quality.
	//
	// If you have your icon hand-drawn in multiple sizes, use
	// gtk_window_set_icon_list(). Then the best size will be used.
	//
	// This function is equivalent to calling gtk_window_set_icon_list() with a
	// 1-element list.
	//
	// See also gtk_window_set_default_icon_list() to set the icon for all
	// windows in your application in one go.
	SetIcon(icon gdkpixbuf.Pixbuf)
	// SetIconFromFile sets the icon for @window. Warns on failure if @err is
	// nil.
	//
	// This function is equivalent to calling gtk_window_set_icon() with a
	// pixbuf created by loading the image from @filename.
	SetIconFromFile(filename string) error
	// SetIconName sets the icon for the window from a named themed icon. See
	// the docs for IconTheme for more details. On some platforms, the window
	// icon is not used at all.
	//
	// Note that this has nothing to do with the WM_ICON_NAME property which is
	// mentioned in the ICCCM.
	SetIconName(name string)
	// SetKeepAbove asks to keep @window above, so that it stays on top. Note
	// that you shouldn’t assume the window is definitely above afterward,
	// because other entities (e.g. the user or [window manager][gtk-X11-arch])
	// could not keep it above, and not all window managers support keeping
	// windows above. But normally the window will end kept above. Just don’t
	// write code that crashes if not.
	//
	// It’s permitted to call this function before showing a window, in which
	// case the window will be kept above when it appears onscreen initially.
	//
	// You can track the above state via the “window-state-event” signal on
	// Widget.
	//
	// Note that, according to the Extended Window Manager Hints Specification
	// (http://www.freedesktop.org/Standards/wm-spec), the above state is mainly
	// meant for user preferences and should not be used by applications e.g.
	// for drawing attention to their dialogs.
	SetKeepAbove(setting bool)
	// SetKeepBelow asks to keep @window below, so that it stays in bottom. Note
	// that you shouldn’t assume the window is definitely below afterward,
	// because other entities (e.g. the user or [window manager][gtk-X11-arch])
	// could not keep it below, and not all window managers support putting
	// windows below. But normally the window will be kept below. Just don’t
	// write code that crashes if not.
	//
	// It’s permitted to call this function before showing a window, in which
	// case the window will be kept below when it appears onscreen initially.
	//
	// You can track the below state via the “window-state-event” signal on
	// Widget.
	//
	// Note that, according to the Extended Window Manager Hints Specification
	// (http://www.freedesktop.org/Standards/wm-spec), the above state is mainly
	// meant for user preferences and should not be used by applications e.g.
	// for drawing attention to their dialogs.
	SetKeepBelow(setting bool)
	// SetMnemonicModifier sets the mnemonic modifier for this window.
	SetMnemonicModifier(modifier gdk.ModifierType)
	// SetMnemonicsVisible sets the Window:mnemonics-visible property.
	SetMnemonicsVisible(setting bool)
	// SetModal sets a window modal or non-modal. Modal windows prevent
	// interaction with other windows in the same application. To keep modal
	// dialogs on top of main application windows, use
	// gtk_window_set_transient_for() to make the dialog transient for the
	// parent; most [window managers][gtk-X11-arch] will then disallow lowering
	// the dialog below the parent.
	SetModal(modal bool)
	// SetOpacity: request the windowing system to make @window partially
	// transparent, with opacity 0 being fully transparent and 1 fully opaque.
	// (Values of the opacity parameter are clamped to the [0,1] range.) On X11
	// this has any effect only on X screens with a compositing manager running.
	// See gtk_widget_is_composited(). On Windows it should work always.
	//
	// Note that setting a window’s opacity after the window has been shown
	// causes it to flicker once on Windows.
	SetOpacity(opacity float64)
	// SetPosition sets a position constraint for this window. If the old or new
	// constraint is GTK_WIN_POS_CENTER_ALWAYS, this will also cause the window
	// to be repositioned to satisfy the new constraint.
	SetPosition(position WindowPosition)
	// SetResizable sets whether the user can resize a window. Windows are user
	// resizable by default.
	SetResizable(resizable bool)
	// SetRole: this function is only useful on X11, not with other GTK+
	// targets.
	//
	// In combination with the window title, the window role allows a [window
	// manager][gtk-X11-arch] to identify "the same" window when an application
	// is restarted. So for example you might set the “toolbox” role on your
	// app’s toolbox window, so that when the user restarts their session, the
	// window manager can put the toolbox back in the same place.
	//
	// If a window already has a unique title, you don’t need to set the role,
	// since the WM can use the title to identify the window when restoring the
	// session.
	SetRole(role string)
	// SetScreen sets the Screen where the @window is displayed; if the window
	// is already mapped, it will be unmapped, and then remapped on the new
	// screen.
	SetScreen(screen gdk.Screen)
	// SetSkipPagerHint windows may set a hint asking the desktop environment
	// not to display the window in the pager. This function sets this hint. (A
	// "pager" is any desktop navigation tool such as a workspace switcher that
	// displays a thumbnail representation of the windows on the screen.)
	SetSkipPagerHint(setting bool)
	// SetSkipTaskbarHint windows may set a hint asking the desktop environment
	// not to display the window in the task bar. This function sets this hint.
	SetSkipTaskbarHint(setting bool)
	// SetStartupID: startup notification identifiers are used by desktop
	// environment to track application startup, to provide user feedback and
	// other features. This function changes the corresponding property on the
	// underlying GdkWindow. Normally, startup identifier is managed
	// automatically and you should only use this function in special cases like
	// transferring focus from other processes. You should use this function
	// before calling gtk_window_present() or any equivalent function generating
	// a window map event.
	//
	// This function is only useful on X11, not with other GTK+ targets.
	SetStartupID(startupId string)
	// SetTitle sets the title of the Window. The title of a window will be
	// displayed in its title bar; on the X Window System, the title bar is
	// rendered by the [window manager][gtk-X11-arch], so exactly how the title
	// appears to users may vary according to a user’s exact configuration. The
	// title should help a user distinguish this window from other windows they
	// may have open. A good title might include the application name and
	// current document filename, for example.
	SetTitle(title string)
	// SetTitlebar sets a custom titlebar for @window.
	//
	// A typical widget used here is HeaderBar, as it provides various features
	// expected of a titlebar while allowing the addition of child widgets to
	// it.
	//
	// If you set a custom titlebar, GTK+ will do its best to convince the
	// window manager not to put its own titlebar on the window. Depending on
	// the system, this function may not work for a window that is already
	// visible, so you set the titlebar before calling gtk_widget_show().
	SetTitlebar(titlebar Widget)
	// SetTransientFor: dialog windows should be set transient for the main
	// application window they were spawned from. This allows [window
	// managers][gtk-X11-arch] to e.g. keep the dialog on top of the main
	// window, or center the dialog over the main window.
	// gtk_dialog_new_with_buttons() and other convenience functions in GTK+
	// will sometimes call gtk_window_set_transient_for() on your behalf.
	//
	// Passing nil for @parent unsets the current transient window.
	//
	// On Wayland, this function can also be used to attach a new K_WINDOW_POPUP
	// to a K_WINDOW_TOPLEVEL parent already mapped on screen so that the
	// K_WINDOW_POPUP will be created as a subsurface-based window
	// K_WINDOW_SUBSURFACE which can be positioned at will relatively to the
	// K_WINDOW_TOPLEVEL surface.
	//
	// On Windows, this function puts the child window on top of the parent,
	// much as the window manager would have done on X.
	SetTransientFor(parent Window)
	// SetTypeHint: by setting the type hint for the window, you allow the
	// window manager to decorate and handle the window in a way which is
	// suitable to the function of the window in your application.
	//
	// This function should be called before the window becomes visible.
	//
	// gtk_dialog_new_with_buttons() and other convenience functions in GTK+
	// will sometimes call gtk_window_set_type_hint() on your behalf.
	SetTypeHint(hint gdk.WindowTypeHint)
	// SetUrgencyHint windows may set a hint asking the desktop environment to
	// draw the users attention to the window. This function sets this hint.
	SetUrgencyHint(setting bool)
	// SetWmclass: don’t use this function. It sets the X Window System “class”
	// and “name” hints for a window. According to the ICCCM, you should always
	// set these to the same value for all windows in an application, and GTK+
	// sets them to that value by default, so calling this function is sort of
	// pointless. However, you may want to call gtk_window_set_role() on each
	// window in your application, for the benefit of the session manager.
	// Setting the role allows the window manager to restore window positions
	// when loading a saved session.
	SetWmclass(wmclassName string, wmclassClass string)
	// Stick asks to stick @window, which means that it will appear on all user
	// desktops. Note that you shouldn’t assume the window is definitely stuck
	// afterward, because other entities (e.g. the user or [window
	// manager][gtk-X11-arch] could unstick it again, and some window managers
	// do not support sticking windows. But normally the window will end up
	// stuck. Just don't write code that crashes if not.
	//
	// It’s permitted to call this function before showing a window.
	//
	// You can track stickiness via the “window-state-event” signal on Widget.
	Stick()
	// Unfullscreen asks to toggle off the fullscreen state for @window. Note
	// that you shouldn’t assume the window is definitely not full screen
	// afterward, because other entities (e.g. the user or [window
	// manager][gtk-X11-arch]) could fullscreen it again, and not all window
	// managers honor requests to unfullscreen windows. But normally the window
	// will end up restored to its normal state. Just don’t write code that
	// crashes if not.
	//
	// You can track the fullscreen state via the “window-state-event” signal on
	// Widget.
	Unfullscreen()
	// Unmaximize asks to unmaximize @window. Note that you shouldn’t assume the
	// window is definitely unmaximized afterward, because other entities (e.g.
	// the user or [window manager][gtk-X11-arch]) could maximize it again, and
	// not all window managers honor requests to unmaximize. But normally the
	// window will end up unmaximized. Just don’t write code that crashes if
	// not.
	//
	// You can track maximization via the “window-state-event” signal on Widget.
	Unmaximize()
	// Unstick asks to unstick @window, which means that it will appear on only
	// one of the user’s desktops. Note that you shouldn’t assume the window is
	// definitely unstuck afterward, because other entities (e.g. the user or
	// [window manager][gtk-X11-arch]) could stick it again. But normally the
	// window will end up stuck. Just don’t write code that crashes if not.
	//
	// You can track stickiness via the “window-state-event” signal on Widget.
	Unstick()
}

// window implements the Window class.
type window struct {
	Bin
	Buildable
}

var _ Window = (*window)(nil)

// WrapWindow wraps a GObject to the right type. It is
// primarily used internally.
func WrapWindow(obj *externglib.Object) Window {
	return window{
		Bin:       WrapBin(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalWindow(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapWindow(obj), nil
}

// NewWindow creates a new Window, which is a toplevel window that can contain
// other widgets. Nearly always, the type of the window should be
// K_WINDOW_TOPLEVEL. If you’re implementing something like a popup menu from
// scratch (which is a bad idea, just use Menu), you might use K_WINDOW_POPUP.
// K_WINDOW_POPUP is not for dialogs, though in some other toolkits dialogs are
// called “popups”. In GTK+, K_WINDOW_POPUP means a pop-up menu or pop-up
// tooltip. On X11, popup windows are not controlled by the [window
// manager][gtk-X11-arch].
//
// If you simply want an undecorated window (no window borders), use
// gtk_window_set_decorated(), don’t use K_WINDOW_POPUP.
//
// All top-level windows created by gtk_window_new() are stored in an internal
// top-level window list. This list can be obtained from
// gtk_window_list_toplevels(). Due to Gtk+ keeping a reference to the window
// internally, gtk_window_new() does not return a reference to the caller.
//
// To delete a Window, call gtk_widget_destroy().
func NewWindow(typ WindowType) Window {
	var _arg1 C.GtkWindowType // out
	var _cret *C.GtkWidget    // in

	_arg1 = (C.GtkWindowType)(typ)

	_cret = C.gtk_window_new(_arg1)

	var _window Window // out

	_window = WrapWindow(externglib.Take(unsafe.Pointer(_cret)))

	return _window
}

// ActivateDefault activates the default widget for the window, unless the
// current focused widget has been configured to receive the default action (see
// gtk_widget_set_receives_default()), in which case the focused widget is
// activated.
func (w window) ActivateDefault() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_activate_default(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ActivateFocus activates the current focused widget within the window.
func (w window) ActivateFocus() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_activate_focus(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ActivateKey activates mnemonics and accelerators for this Window. This is
// normally called by the default ::key_press_event handler for toplevel
// windows, however in some cases it may be useful to call this directly when
// overriding the standard key handling for a toplevel window.
func (w window) ActivateKey(event *gdk.EventKey) bool {
	var _arg0 *C.GtkWindow   // out
	var _arg1 *C.GdkEventKey // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GdkEventKey)(unsafe.Pointer(event.Native()))

	_cret = C.gtk_window_activate_key(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AddAccelGroup: associate @accel_group with @window, such that calling
// gtk_accel_groups_activate() on @window will activate accelerators in
// @accel_group.
func (w window) AddAccelGroup(accelGroup AccelGroup) {
	var _arg0 *C.GtkWindow     // out
	var _arg1 *C.GtkAccelGroup // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkAccelGroup)(unsafe.Pointer(accelGroup.Native()))

	C.gtk_window_add_accel_group(_arg0, _arg1)
}

// AddMnemonic adds a mnemonic to this window.
func (w window) AddMnemonic(keyval uint, target Widget) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.guint      // out
	var _arg2 *C.GtkWidget // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (C.guint)(keyval)
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(target.Native()))

	C.gtk_window_add_mnemonic(_arg0, _arg1, _arg2)
}

// BeginMoveDrag starts moving a window. This function is used if an application
// has window movement grips. When GDK can support it, the window movement will
// be done using the standard mechanism for the [window manager][gtk-X11-arch]
// or windowing system. Otherwise, GDK will try to emulate window movement,
// potentially not all that well, depending on the windowing system.
func (w window) BeginMoveDrag(button int, rootX int, rootY int, timestamp uint32) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // out
	var _arg3 C.gint       // out
	var _arg4 C.guint32    // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (C.gint)(button)
	_arg2 = (C.gint)(rootX)
	_arg3 = (C.gint)(rootY)
	_arg4 = (C.guint32)(timestamp)

	C.gtk_window_begin_move_drag(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// BeginResizeDrag starts resizing a window. This function is used if an
// application has window resizing controls. When GDK can support it, the resize
// will be done using the standard mechanism for the [window
// manager][gtk-X11-arch] or windowing system. Otherwise, GDK will try to
// emulate window resizing, potentially not all that well, depending on the
// windowing system.
func (w window) BeginResizeDrag(edge gdk.WindowEdge, button int, rootX int, rootY int, timestamp uint32) {
	var _arg0 *C.GtkWindow    // out
	var _arg1 C.GdkWindowEdge // out
	var _arg2 C.gint          // out
	var _arg3 C.gint          // out
	var _arg4 C.gint          // out
	var _arg5 C.guint32       // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GdkWindowEdge)(edge)
	_arg2 = (C.gint)(button)
	_arg3 = (C.gint)(rootX)
	_arg4 = (C.gint)(rootY)
	_arg5 = (C.guint32)(timestamp)

	C.gtk_window_begin_resize_drag(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}

// Close requests that the window is closed, similar to what happens when a
// window manager close button is clicked.
//
// This function can be used with close buttons in custom titlebars.
func (w window) Close() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_close(_arg0)
}

// Deiconify asks to deiconify (i.e. unminimize) the specified @window. Note
// that you shouldn’t assume the window is definitely deiconified afterward,
// because other entities (e.g. the user or [window manager][gtk-X11-arch]))
// could iconify it again before your code which assumes deiconification gets to
// run.
//
// You can track iconification via the “window-state-event” signal on Widget.
func (w window) Deiconify() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_deiconify(_arg0)
}

// Fullscreen asks to place @window in the fullscreen state. Note that you
// shouldn’t assume the window is definitely full screen afterward, because
// other entities (e.g. the user or [window manager][gtk-X11-arch]) could
// unfullscreen it again, and not all window managers honor requests to
// fullscreen windows. But normally the window will end up fullscreen. Just
// don’t write code that crashes if not.
//
// You can track the fullscreen state via the “window-state-event” signal on
// Widget.
func (w window) Fullscreen() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_fullscreen(_arg0)
}

// FullscreenOnMonitor asks to place @window in the fullscreen state. Note that
// you shouldn't assume the window is definitely full screen afterward.
//
// You can track the fullscreen state via the "window-state-event" signal on
// Widget.
func (w window) FullscreenOnMonitor(screen gdk.Screen, monitor int) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GdkScreen // out
	var _arg2 C.gint       // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GdkScreen)(unsafe.Pointer(screen.Native()))
	_arg2 = (C.gint)(monitor)

	C.gtk_window_fullscreen_on_monitor(_arg0, _arg1, _arg2)
}

// AcceptFocus gets the value set by gtk_window_set_accept_focus().
func (w window) AcceptFocus() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_accept_focus(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Application gets the Application associated with the window (if any).
func (w window) Application() Application {
	var _arg0 *C.GtkWindow      // out
	var _cret *C.GtkApplication // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_application(_arg0)

	var _application Application // out

	_application = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Application)

	return _application
}

// AttachedTo fetches the attach widget for this window. See
// gtk_window_set_attached_to().
func (w window) AttachedTo() Widget {
	var _arg0 *C.GtkWindow // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_attached_to(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// Decorated returns whether the window has been set to have decorations such as
// a title bar via gtk_window_set_decorated().
func (w window) Decorated() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_decorated(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DefaultSize gets the default size of the window. A value of -1 for the width
// or height indicates that a default size has not been explicitly set for that
// dimension, so the “natural” size of the window will be used.
func (w window) DefaultSize() (width int, height int) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gint       // in
	var _arg2 C.gint       // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_get_default_size(_arg0, &_arg1, &_arg2)

	var _width int  // out
	var _height int // out

	_width = (int)(_arg1)
	_height = (int)(_arg2)

	return _width, _height
}

// DefaultWidget returns the default widget for @window. See
// gtk_window_set_default() for more details.
func (w window) DefaultWidget() Widget {
	var _arg0 *C.GtkWindow // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_default_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// Deletable returns whether the window has been set to have a close button via
// gtk_window_set_deletable().
func (w window) Deletable() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_deletable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DestroyWithParent returns whether the window will be destroyed with its
// transient parent. See gtk_window_set_destroy_with_parent ().
func (w window) DestroyWithParent() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_destroy_with_parent(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Focus retrieves the current focused widget within the window. Note that this
// is the widget that would have the focus if the toplevel window focused; if
// the toplevel window is not focused then `gtk_widget_has_focus (widget)` will
// not be true for the widget.
func (w window) Focus() Widget {
	var _arg0 *C.GtkWindow // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_focus(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// FocusOnMap gets the value set by gtk_window_set_focus_on_map().
func (w window) FocusOnMap() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_focus_on_map(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FocusVisible gets the value of the Window:focus-visible property.
func (w window) FocusVisible() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_focus_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Gravity gets the value set by gtk_window_set_gravity().
func (w window) Gravity() gdk.Gravity {
	var _arg0 *C.GtkWindow // out
	var _cret C.GdkGravity // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_gravity(_arg0)

	var _gravity gdk.Gravity // out

	_gravity = gdk.Gravity(_cret)

	return _gravity
}

// Group returns the group for @window or the default group, if @window is nil
// or if @window does not have an explicit window group.
func (w window) Group() WindowGroup {
	var _arg0 *C.GtkWindow      // out
	var _cret *C.GtkWindowGroup // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_group(_arg0)

	var _windowGroup WindowGroup // out

	_windowGroup = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(WindowGroup)

	return _windowGroup
}

// HasResizeGrip determines whether the window may have a resize grip.
func (w window) HasResizeGrip() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_has_resize_grip(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HideTitlebarWhenMaximized returns whether the window has requested to have
// its titlebar hidden when maximized. See
// gtk_window_set_hide_titlebar_when_maximized ().
func (w window) HideTitlebarWhenMaximized() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_hide_titlebar_when_maximized(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Icon gets the value set by gtk_window_set_icon() (or if you've called
// gtk_window_set_icon_list(), gets the first icon in the icon list).
func (w window) Icon() gdkpixbuf.Pixbuf {
	var _arg0 *C.GtkWindow // out
	var _cret *C.GdkPixbuf // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_icon(_arg0)

	var _pixbuf gdkpixbuf.Pixbuf // out

	_pixbuf = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

	return _pixbuf
}

// IconName returns the name of the themed icon for the window, see
// gtk_window_set_icon_name().
func (w window) IconName() string {
	var _arg0 *C.GtkWindow // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_icon_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// MnemonicModifier returns the mnemonic modifier for this window. See
// gtk_window_set_mnemonic_modifier().
func (w window) MnemonicModifier() gdk.ModifierType {
	var _arg0 *C.GtkWindow      // out
	var _cret C.GdkModifierType // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_mnemonic_modifier(_arg0)

	var _modifierType gdk.ModifierType // out

	_modifierType = gdk.ModifierType(_cret)

	return _modifierType
}

// MnemonicsVisible gets the value of the Window:mnemonics-visible property.
func (w window) MnemonicsVisible() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_mnemonics_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Modal returns whether the window is modal. See gtk_window_set_modal().
func (w window) Modal() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_modal(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Opacity fetches the requested opacity for this window. See
// gtk_window_set_opacity().
func (w window) Opacity() float64 {
	var _arg0 *C.GtkWindow // out
	var _cret C.gdouble    // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_opacity(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// Position: this function returns the position you need to pass to
// gtk_window_move() to keep @window in its current position. This means that
// the meaning of the returned value varies with window gravity. See
// gtk_window_move() for more details.
//
// The reliability of this function depends on the windowing system currently in
// use. Some windowing systems, such as Wayland, do not support a global
// coordinate system, and thus the position of the window will always be (0, 0).
// Others, like X11, do not have a reliable way to obtain the geometry of the
// decorations of a window if they are provided by the window manager.
// Additionally, on X11, window manager have been known to mismanage window
// gravity, which result in windows moving even if you use the coordinates of
// the current position as returned by this function.
//
// If you haven’t changed the window gravity, its gravity will be
// K_GRAVITY_NORTH_WEST. This means that gtk_window_get_position() gets the
// position of the top-left corner of the window manager frame for the window.
// gtk_window_move() sets the position of this same top-left corner.
//
// If a window has gravity K_GRAVITY_STATIC the window manager frame is not
// relevant, and thus gtk_window_get_position() will always produce accurate
// results. However you can’t use static gravity to do things like place a
// window in a corner of the screen, because static gravity ignores the window
// manager decorations.
//
// Ideally, this function should return appropriate values if the window has
// client side decorations, assuming that the windowing system supports global
// coordinates.
//
// In practice, saving the window position should not be left to applications,
// as they lack enough knowledge of the windowing system and the window manager
// state to effectively do so. The appropriate way to implement saving the
// window position is to use a platform-specific protocol, wherever that is
// available.
func (w window) Position() (rootX int, rootY int) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gint       // in
	var _arg2 C.gint       // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_get_position(_arg0, &_arg1, &_arg2)

	var _rootX int // out
	var _rootY int // out

	_rootX = (int)(_arg1)
	_rootY = (int)(_arg2)

	return _rootX, _rootY
}

// Resizable gets the value set by gtk_window_set_resizable().
func (w window) Resizable() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_resizable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ResizeGripArea: if a window has a resize grip, this will retrieve the grip
// position, width and height into the specified Rectangle.
func (w window) ResizeGripArea() (gdk.Rectangle, bool) {
	var _arg0 *C.GtkWindow // out
	var _rect gdk.Rectangle
	var _cret C.gboolean // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_resize_grip_area(_arg0, (*C.GdkRectangle)(unsafe.Pointer(&_rect)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _rect, _ok
}

// Role returns the role of the window. See gtk_window_set_role() for further
// explanation.
func (w window) Role() string {
	var _arg0 *C.GtkWindow // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_role(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Screen returns the Screen associated with @window.
func (w window) Screen() gdk.Screen {
	var _arg0 *C.GtkWindow // out
	var _cret *C.GdkScreen // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_screen(_arg0)

	var _screen gdk.Screen // out

	_screen = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Screen)

	return _screen
}

// Size obtains the current size of @window.
//
// If @window is not visible on screen, this function return the size GTK+ will
// suggest to the [window manager][gtk-X11-arch] for the initial window size
// (but this is not reliably the same as the size the window manager will
// actually select). See: gtk_window_set_default_size().
//
// Depending on the windowing system and the window manager constraints, the
// size returned by this function may not match the size set using
// gtk_window_resize(); additionally, since gtk_window_resize() may be
// implemented as an asynchronous operation, GTK+ cannot guarantee in any way
// that this code:
//
//    static void
//    on_size_allocate (GtkWidget *widget, GtkAllocation *allocation)
//    {
//      int new_width, new_height;
//
//      gtk_window_get_size (GTK_WINDOW (widget), &new_width, &new_height);
//
//      ...
//    }
//
// Note that, if you connect to the Widget::size-allocate signal, you should not
// use the dimensions of the Allocation passed to the signal handler, as the
// allocation may contain client side decorations added by GTK+, depending on
// the windowing system in use.
//
// If you are getting a window size in order to position the window on the
// screen, you should, instead, simply set the window’s semantic type with
// gtk_window_set_type_hint(), which allows the window manager to e.g. center
// dialogs. Also, if you set the transient parent of dialogs with
// gtk_window_set_transient_for() window managers will often center the dialog
// over its parent window. It's much preferred to let the window manager handle
// these cases rather than doing it yourself, because all apps will behave
// consistently and according to user or system preferences, if the window
// manager handles it. Also, the window manager can take into account the size
// of the window decorations and border that it may add, and of which GTK+ has
// no knowledge. Additionally, positioning windows in global screen coordinates
// may not be allowed by the windowing system. For more information, see:
// gtk_window_set_position().
func (w window) Size() (width int, height int) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gint       // in
	var _arg2 C.gint       // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_get_size(_arg0, &_arg1, &_arg2)

	var _width int  // out
	var _height int // out

	_width = (int)(_arg1)
	_height = (int)(_arg2)

	return _width, _height
}

// SkipPagerHint gets the value set by gtk_window_set_skip_pager_hint().
func (w window) SkipPagerHint() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_skip_pager_hint(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SkipTaskbarHint gets the value set by gtk_window_set_skip_taskbar_hint()
func (w window) SkipTaskbarHint() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_skip_taskbar_hint(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Title retrieves the title of the window. See gtk_window_set_title().
func (w window) Title() string {
	var _arg0 *C.GtkWindow // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_title(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Titlebar returns the custom titlebar that has been set with
// gtk_window_set_titlebar().
func (w window) Titlebar() Widget {
	var _arg0 *C.GtkWindow // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_titlebar(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// TransientFor fetches the transient parent for this window. See
// gtk_window_set_transient_for().
func (w window) TransientFor() Window {
	var _arg0 *C.GtkWindow // out
	var _cret *C.GtkWindow // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_transient_for(_arg0)

	var _ret Window // out

	_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Window)

	return _ret
}

// TypeHint gets the type hint for this window. See gtk_window_set_type_hint().
func (w window) TypeHint() gdk.WindowTypeHint {
	var _arg0 *C.GtkWindow        // out
	var _cret C.GdkWindowTypeHint // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_type_hint(_arg0)

	var _windowTypeHint gdk.WindowTypeHint // out

	_windowTypeHint = gdk.WindowTypeHint(_cret)

	return _windowTypeHint
}

// UrgencyHint gets the value set by gtk_window_set_urgency_hint()
func (w window) UrgencyHint() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_urgency_hint(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// WindowType gets the type of the window. See WindowType.
func (w window) WindowType() WindowType {
	var _arg0 *C.GtkWindow    // out
	var _cret C.GtkWindowType // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_window_type(_arg0)

	var _windowType WindowType // out

	_windowType = WindowType(_cret)

	return _windowType
}

// HasGroup returns whether @window has an explicit window group.
func (w window) HasGroup() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_has_group(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasToplevelFocus returns whether the input focus is within this GtkWindow.
// For real toplevel windows, this is identical to gtk_window_is_active(), but
// for embedded windows, like Plug, the results will differ.
func (w window) HasToplevelFocus() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_has_toplevel_focus(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Iconify asks to iconify (i.e. minimize) the specified @window. Note that you
// shouldn’t assume the window is definitely iconified afterward, because other
// entities (e.g. the user or [window manager][gtk-X11-arch]) could deiconify it
// again, or there may not be a window manager in which case iconification isn’t
// possible, etc. But normally the window will end up iconified. Just don’t
// write code that crashes if not.
//
// It’s permitted to call this function before showing a window, in which case
// the window will be iconified before it ever appears onscreen.
//
// You can track iconification via the “window-state-event” signal on Widget.
func (w window) Iconify() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_iconify(_arg0)
}

// IsActive returns whether the window is part of the current active toplevel.
// (That is, the toplevel window receiving keystrokes.) The return value is true
// if the window is active toplevel itself, but also if it is, say, a Plug
// embedded in the active toplevel. You might use this function if you wanted to
// draw a widget differently in an active window from a widget in an inactive
// window. See gtk_window_has_toplevel_focus()
func (w window) IsActive() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_is_active(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsMaximized retrieves the current maximized state of @window.
//
// Note that since maximization is ultimately handled by the window manager and
// happens asynchronously to an application request, you shouldn’t assume the
// return value of this function changing immediately (or at all), as an effect
// of calling gtk_window_maximize() or gtk_window_unmaximize().
func (w window) IsMaximized() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_is_maximized(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Maximize asks to maximize @window, so that it becomes full-screen. Note that
// you shouldn’t assume the window is definitely maximized afterward, because
// other entities (e.g. the user or [window manager][gtk-X11-arch]) could
// unmaximize it again, and not all window managers support maximization. But
// normally the window will end up maximized. Just don’t write code that crashes
// if not.
//
// It’s permitted to call this function before showing a window, in which case
// the window will be maximized when it appears onscreen initially.
//
// You can track maximization via the “window-state-event” signal on Widget, or
// by listening to notifications on the Window:is-maximized property.
func (w window) Maximize() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_maximize(_arg0)
}

// MnemonicActivate activates the targets associated with the mnemonic.
func (w window) MnemonicActivate(keyval uint, modifier gdk.ModifierType) bool {
	var _arg0 *C.GtkWindow      // out
	var _arg1 C.guint           // out
	var _arg2 C.GdkModifierType // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (C.guint)(keyval)
	_arg2 = (C.GdkModifierType)(modifier)

	_cret = C.gtk_window_mnemonic_activate(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Move asks the [window manager][gtk-X11-arch] to move @window to the given
// position. Window managers are free to ignore this; most window managers
// ignore requests for initial window positions (instead using a user-defined
// placement algorithm) and honor requests after the window has already been
// shown.
//
// Note: the position is the position of the gravity-determined reference point
// for the window. The gravity determines two things: first, the location of the
// reference point in root window coordinates; and second, which point on the
// window is positioned at the reference point.
//
// By default the gravity is K_GRAVITY_NORTH_WEST, so the reference point is
// simply the @x, @y supplied to gtk_window_move(). The top-left corner of the
// window decorations (aka window frame or border) will be placed at @x, @y.
// Therefore, to position a window at the top left of the screen, you want to
// use the default gravity (which is K_GRAVITY_NORTH_WEST) and move the window
// to 0,0.
//
// To position a window at the bottom right corner of the screen, you would set
// K_GRAVITY_SOUTH_EAST, which means that the reference point is at @x + the
// window width and @y + the window height, and the bottom-right corner of the
// window border will be placed at that reference point. So, to place a window
// in the bottom right corner you would first set gravity to south east, then
// write: `gtk_window_move (window, gdk_screen_width () - window_width,
// gdk_screen_height () - window_height)` (note that this example does not take
// multi-head scenarios into account).
//
// The Extended Window Manager Hints Specification
// (http://www.freedesktop.org/Standards/wm-spec) has a nice table of gravities
// in the “implementation notes” section.
//
// The gtk_window_get_position() documentation may also be relevant.
func (w window) Move(x int, y int) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (C.gint)(x)
	_arg2 = (C.gint)(y)

	C.gtk_window_move(_arg0, _arg1, _arg2)
}

// ParseGeometry parses a standard X Window System geometry string - see the
// manual page for X (type “man X”) for details on this.
// gtk_window_parse_geometry() does work on all GTK+ ports including Win32 but
// is primarily intended for an X environment.
//
// If either a size or a position can be extracted from the geometry string,
// gtk_window_parse_geometry() returns true and calls
// gtk_window_set_default_size() and/or gtk_window_move() to resize/move the
// window.
//
// If gtk_window_parse_geometry() returns true, it will also set the
// K_HINT_USER_POS and/or K_HINT_USER_SIZE hints indicating to the window
// manager that the size/position of the window was user-specified. This causes
// most window managers to honor the geometry.
//
// Note that for gtk_window_parse_geometry() to work as expected, it has to be
// called when the window has its “final” size, i.e. after calling
// gtk_widget_show_all() on the contents and gtk_window_set_geometry_hints() on
// the window.
//
//    #include <gtk/gtk.h>
//
//    static void
//    fill_with_content (GtkWidget *vbox)
//    {
//      // fill with content...
//    }
//
//    int
//    main (int argc, char *argv[])
//    {
//      GtkWidget *window, *vbox;
//      GdkGeometry size_hints = {
//        100, 50, 0, 0, 100, 50, 10,
//        10, 0.0, 0.0, GDK_GRAVITY_NORTH_WEST
//      };
//
//      gtk_init (&argc, &argv);
//
//      window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
//      vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
//
//      gtk_container_add (GTK_CONTAINER (window), vbox);
//      fill_with_content (vbox);
//      gtk_widget_show_all (vbox);
//
//      gtk_window_set_geometry_hints (GTK_WINDOW (window),
//    	  			    NULL,
//    				    &size_hints,
//    				    GDK_HINT_MIN_SIZE |
//    				    GDK_HINT_BASE_SIZE |
//    				    GDK_HINT_RESIZE_INC);
//
//      if (argc > 1)
//        {
//          gboolean res;
//          res = gtk_window_parse_geometry (GTK_WINDOW (window),
//                                           argv[1]);
//          if (! res)
//            fprintf (stderr,
//                     "Failed to parse “s”\n",
//                     argv[1]);
//        }
//
//      gtk_widget_show_all (window);
//      gtk_main ();
//
//      return 0;
//    }
func (w window) ParseGeometry(geometry string) bool {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.gchar     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.gchar)(C.CString(geometry))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_window_parse_geometry(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Present presents a window to the user. This function should not be used as
// when it is called, it is too late to gather a valid timestamp to allow focus
// stealing prevention to work correctly.
func (w window) Present() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_present(_arg0)
}

// PresentWithTime presents a window to the user. This may mean raising the
// window in the stacking order, deiconifying it, moving it to the current
// desktop, and/or giving it the keyboard focus, possibly dependent on the
// user’s platform, window manager, and preferences.
//
// If @window is hidden, this function calls gtk_widget_show() as well.
//
// This function should be used when the user tries to open a window that’s
// already open. Say for example the preferences dialog is currently open, and
// the user chooses Preferences from the menu a second time; use
// gtk_window_present() to move the already-open dialog where the user can see
// it.
//
// Presents a window to the user in response to a user interaction. The
// timestamp should be gathered when the window was requested to be shown (when
// clicking a link for example), rather than once the window is ready to be
// shown.
func (w window) PresentWithTime(timestamp uint32) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.guint32    // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (C.guint32)(timestamp)

	C.gtk_window_present_with_time(_arg0, _arg1)
}

// PropagateKeyEvent: propagate a key press or release event to the focus widget
// and up the focus container chain until a widget handles @event. This is
// normally called by the default ::key_press_event and ::key_release_event
// handlers for toplevel windows, however in some cases it may be useful to call
// this directly when overriding the standard key handling for a toplevel
// window.
func (w window) PropagateKeyEvent(event *gdk.EventKey) bool {
	var _arg0 *C.GtkWindow   // out
	var _arg1 *C.GdkEventKey // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GdkEventKey)(unsafe.Pointer(event.Native()))

	_cret = C.gtk_window_propagate_key_event(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveAccelGroup reverses the effects of gtk_window_add_accel_group().
func (w window) RemoveAccelGroup(accelGroup AccelGroup) {
	var _arg0 *C.GtkWindow     // out
	var _arg1 *C.GtkAccelGroup // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkAccelGroup)(unsafe.Pointer(accelGroup.Native()))

	C.gtk_window_remove_accel_group(_arg0, _arg1)
}

// RemoveMnemonic removes a mnemonic from this window.
func (w window) RemoveMnemonic(keyval uint, target Widget) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.guint      // out
	var _arg2 *C.GtkWidget // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (C.guint)(keyval)
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(target.Native()))

	C.gtk_window_remove_mnemonic(_arg0, _arg1, _arg2)
}

// ReshowWithInitialSize hides @window, then reshows it, resetting the default
// size and position of the window. Used by GUI builders only.
func (w window) ReshowWithInitialSize() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_reshow_with_initial_size(_arg0)
}

// Resize resizes the window as if the user had done so, obeying geometry
// constraints. The default geometry constraint is that windows may not be
// smaller than their size request; to override this constraint, call
// gtk_widget_set_size_request() to set the window's request to a smaller value.
//
// If gtk_window_resize() is called before showing a window for the first time,
// it overrides any default size set with gtk_window_set_default_size().
//
// Windows may not be resized smaller than 1 by 1 pixels.
//
// When using client side decorations, GTK+ will do its best to adjust the given
// size so that the resulting window size matches the requested size without the
// title bar, borders and shadows added for the client side decorations, but
// there is no guarantee that the result will be totally accurate because these
// widgets added for client side decorations depend on the theme and may not be
// realized or visible at the time gtk_window_resize() is issued.
//
// If the GtkWindow has a titlebar widget (see gtk_window_set_titlebar()), then
// typically, gtk_window_resize() will compensate for the height of the titlebar
// widget only if the height is known when the resulting GtkWindow configuration
// is issued. For example, if new widgets are added after the GtkWindow
// configuration and cause the titlebar widget to grow in height, this will
// result in a window content smaller that specified by gtk_window_resize() and
// not a larger window.
func (w window) Resize(width int, height int) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (C.gint)(width)
	_arg2 = (C.gint)(height)

	C.gtk_window_resize(_arg0, _arg1, _arg2)
}

// ResizeGripIsVisible determines whether a resize grip is visible for the
// specified window.
func (w window) ResizeGripIsVisible() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_resize_grip_is_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ResizeToGeometry: like gtk_window_resize(), but @width and @height are
// interpreted in terms of the base size and increment set with
// gtk_window_set_geometry_hints.
func (w window) ResizeToGeometry(width int, height int) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (C.gint)(width)
	_arg2 = (C.gint)(height)

	C.gtk_window_resize_to_geometry(_arg0, _arg1, _arg2)
}

// SetAcceptFocus windows may set a hint asking the desktop environment not to
// receive the input focus. This function sets this hint.
func (w window) SetAcceptFocus(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_accept_focus(_arg0, _arg1)
}

// SetApplication sets or unsets the Application associated with the window.
//
// The application will be kept alive for at least as long as it has any windows
// associated with it (see g_application_hold() for a way to keep it alive
// without windows).
//
// Normally, the connection between the application and the window will remain
// until the window is destroyed, but you can explicitly remove it by setting
// the @application to nil.
//
// This is equivalent to calling gtk_application_remove_window() and/or
// gtk_application_add_window() on the old/new applications as relevant.
func (w window) SetApplication(application Application) {
	var _arg0 *C.GtkWindow      // out
	var _arg1 *C.GtkApplication // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkApplication)(unsafe.Pointer(application.Native()))

	C.gtk_window_set_application(_arg0, _arg1)
}

// SetAttachedTo marks @window as attached to @attach_widget. This creates a
// logical binding between the window and the widget it belongs to, which is
// used by GTK+ to propagate information such as styling or accessibility to
// @window as if it was a children of @attach_widget.
//
// Examples of places where specifying this relation is useful are for instance
// a Menu created by a ComboBox, a completion popup window created by Entry or a
// typeahead search entry created by TreeView.
//
// Note that this function should not be confused with
// gtk_window_set_transient_for(), which specifies a window manager relation
// between two toplevels instead.
//
// Passing nil for @attach_widget detaches the window.
func (w window) SetAttachedTo(attachWidget Widget) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(attachWidget.Native()))

	C.gtk_window_set_attached_to(_arg0, _arg1)
}

// SetDecorated: by default, windows are decorated with a title bar, resize
// controls, etc. Some [window managers][gtk-X11-arch] allow GTK+ to disable
// these decorations, creating a borderless window. If you set the decorated
// property to false using this function, GTK+ will do its best to convince the
// window manager not to decorate the window. Depending on the system, this
// function may not have any effect when called on a window that is already
// visible, so you should call it before calling gtk_widget_show().
//
// On Windows, this function always works, since there’s no window manager
// policy involved.
func (w window) SetDecorated(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_decorated(_arg0, _arg1)
}

// SetDefault: the default widget is the widget that’s activated when the user
// presses Enter in a dialog (for example). This function sets or unsets the
// default widget for a Window. When setting (rather than unsetting) the default
// widget it’s generally easier to call gtk_widget_grab_default() on the widget.
// Before making a widget the default widget, you must call
// gtk_widget_set_can_default() on the widget you’d like to make the default.
func (w window) SetDefault(defaultWidget Widget) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(defaultWidget.Native()))

	C.gtk_window_set_default(_arg0, _arg1)
}

// SetDefaultGeometry: like gtk_window_set_default_size(), but @width and
// @height are interpreted in terms of the base size and increment set with
// gtk_window_set_geometry_hints.
func (w window) SetDefaultGeometry(width int, height int) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (C.gint)(width)
	_arg2 = (C.gint)(height)

	C.gtk_window_set_default_geometry(_arg0, _arg1, _arg2)
}

// SetDefaultSize sets the default size of a window. If the window’s “natural”
// size (its size request) is larger than the default, the default will be
// ignored. More generally, if the default size does not obey the geometry hints
// for the window (gtk_window_set_geometry_hints() can be used to set these
// explicitly), the default size will be clamped to the nearest permitted size.
//
// Unlike gtk_widget_set_size_request(), which sets a size request for a widget
// and thus would keep users from shrinking the window, this function only sets
// the initial size, just as if the user had resized the window themselves.
// Users can still shrink the window again as they normally would. Setting a
// default size of -1 means to use the “natural” default size (the size request
// of the window).
//
// For more control over a window’s initial size and how resizing works,
// investigate gtk_window_set_geometry_hints().
//
// For some uses, gtk_window_resize() is a more appropriate function.
// gtk_window_resize() changes the current size of the window, rather than the
// size to be used on initial display. gtk_window_resize() always affects the
// window itself, not the geometry widget.
//
// The default size of a window only affects the first time a window is shown;
// if a window is hidden and re-shown, it will remember the size it had prior to
// hiding, rather than using the default size.
//
// Windows can’t actually be 0x0 in size, they must be at least 1x1, but passing
// 0 for @width and @height is OK, resulting in a 1x1 default size.
//
// If you use this function to reestablish a previously saved window size, note
// that the appropriate size to save is the one returned by
// gtk_window_get_size(). Using the window allocation directly will not work in
// all circumstances and can lead to growing or shrinking windows.
func (w window) SetDefaultSize(width int, height int) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (C.gint)(width)
	_arg2 = (C.gint)(height)

	C.gtk_window_set_default_size(_arg0, _arg1, _arg2)
}

// SetDeletable: by default, windows have a close button in the window frame.
// Some [window managers][gtk-X11-arch] allow GTK+ to disable this button. If
// you set the deletable property to false using this function, GTK+ will do its
// best to convince the window manager not to show a close button. Depending on
// the system, this function may not have any effect when called on a window
// that is already visible, so you should call it before calling
// gtk_widget_show().
//
// On Windows, this function always works, since there’s no window manager
// policy involved.
func (w window) SetDeletable(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_deletable(_arg0, _arg1)
}

// SetDestroyWithParent: if @setting is true, then destroying the transient
// parent of @window will also destroy @window itself. This is useful for
// dialogs that shouldn’t persist beyond the lifetime of the main window they're
// associated with, for example.
func (w window) SetDestroyWithParent(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_destroy_with_parent(_arg0, _arg1)
}

// SetFocus: if @focus is not the current focus widget, and is focusable, sets
// it as the focus widget for the window. If @focus is nil, unsets the focus
// widget for this window. To set the focus to a particular widget in the
// toplevel, it is usually more convenient to use gtk_widget_grab_focus()
// instead of this function.
func (w window) SetFocus(focus Widget) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(focus.Native()))

	C.gtk_window_set_focus(_arg0, _arg1)
}

// SetFocusOnMap windows may set a hint asking the desktop environment not to
// receive the input focus when the window is mapped. This function sets this
// hint.
func (w window) SetFocusOnMap(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_focus_on_map(_arg0, _arg1)
}

// SetFocusVisible sets the Window:focus-visible property.
func (w window) SetFocusVisible(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_focus_visible(_arg0, _arg1)
}

// SetGeometryHints: this function sets up hints about how a window can be
// resized by the user. You can set a minimum and maximum size; allowed resize
// increments (e.g. for xterm, you can only resize by the size of a character);
// aspect ratios; and more. See the Geometry struct.
func (w window) SetGeometryHints(geometryWidget Widget, geometry *gdk.Geometry, geomMask gdk.WindowHints) {
	var _arg0 *C.GtkWindow     // out
	var _arg1 *C.GtkWidget     // out
	var _arg2 *C.GdkGeometry   // out
	var _arg3 C.GdkWindowHints // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(geometryWidget.Native()))
	_arg2 = (*C.GdkGeometry)(unsafe.Pointer(geometry.Native()))
	_arg3 = (C.GdkWindowHints)(geomMask)

	C.gtk_window_set_geometry_hints(_arg0, _arg1, _arg2, _arg3)
}

// SetGravity: window gravity defines the meaning of coordinates passed to
// gtk_window_move(). See gtk_window_move() and Gravity for more details.
//
// The default window gravity is K_GRAVITY_NORTH_WEST which will typically “do
// what you mean.”
func (w window) SetGravity(gravity gdk.Gravity) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.GdkGravity // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GdkGravity)(gravity)

	C.gtk_window_set_gravity(_arg0, _arg1)
}

// SetHasResizeGrip sets whether @window has a corner resize grip.
//
// Note that the resize grip is only shown if the window is actually resizable
// and not maximized. Use gtk_window_resize_grip_is_visible() to find out if the
// resize grip is currently shown.
func (w window) SetHasResizeGrip(value bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if value {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_has_resize_grip(_arg0, _arg1)
}

// SetHasUserRefCount tells GTK+ whether to drop its extra reference to the
// window when gtk_widget_destroy() is called.
//
// This function is only exported for the benefit of language bindings which may
// need to keep the window alive until their wrapper object is garbage
// collected. There is no justification for ever calling this function in an
// application.
func (w window) SetHasUserRefCount(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_has_user_ref_count(_arg0, _arg1)
}

// SetHideTitlebarWhenMaximized: if @setting is true, then @window will request
// that it’s titlebar should be hidden when maximized. This is useful for
// windows that don’t convey any information other than the application name in
// the titlebar, to put the available screen space to better use. If the
// underlying window system does not support the request, the setting will not
// have any effect.
//
// Note that custom titlebars set with gtk_window_set_titlebar() are not
// affected by this. The application is in full control of their content and
// visibility anyway.
func (w window) SetHideTitlebarWhenMaximized(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_hide_titlebar_when_maximized(_arg0, _arg1)
}

// SetIcon sets up the icon representing a Window. This icon is used when the
// window is minimized (also known as iconified). Some window managers or
// desktop environments may also place it in the window frame, or display it in
// other contexts. On others, the icon is not used at all, so your mileage may
// vary.
//
// The icon should be provided in whatever size it was naturally drawn; that is,
// don’t scale the image before passing it to GTK+. Scaling is postponed until
// the last minute, when the desired final size is known, to allow best quality.
//
// If you have your icon hand-drawn in multiple sizes, use
// gtk_window_set_icon_list(). Then the best size will be used.
//
// This function is equivalent to calling gtk_window_set_icon_list() with a
// 1-element list.
//
// See also gtk_window_set_default_icon_list() to set the icon for all windows
// in your application in one go.
func (w window) SetIcon(icon gdkpixbuf.Pixbuf) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GdkPixbuf // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(icon.Native()))

	C.gtk_window_set_icon(_arg0, _arg1)
}

// SetIconFromFile sets the icon for @window. Warns on failure if @err is nil.
//
// This function is equivalent to calling gtk_window_set_icon() with a pixbuf
// created by loading the image from @filename.
func (w window) SetIconFromFile(filename string) error {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.gchar     // out
	var _cerr *C.GError    // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_window_set_icon_from_file(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// SetIconName sets the icon for the window from a named themed icon. See the
// docs for IconTheme for more details. On some platforms, the window icon is
// not used at all.
//
// Note that this has nothing to do with the WM_ICON_NAME property which is
// mentioned in the ICCCM.
func (w window) SetIconName(name string) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_window_set_icon_name(_arg0, _arg1)
}

// SetKeepAbove asks to keep @window above, so that it stays on top. Note that
// you shouldn’t assume the window is definitely above afterward, because other
// entities (e.g. the user or [window manager][gtk-X11-arch]) could not keep it
// above, and not all window managers support keeping windows above. But
// normally the window will end kept above. Just don’t write code that crashes
// if not.
//
// It’s permitted to call this function before showing a window, in which case
// the window will be kept above when it appears onscreen initially.
//
// You can track the above state via the “window-state-event” signal on Widget.
//
// Note that, according to the Extended Window Manager Hints Specification
// (http://www.freedesktop.org/Standards/wm-spec), the above state is mainly
// meant for user preferences and should not be used by applications e.g. for
// drawing attention to their dialogs.
func (w window) SetKeepAbove(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_keep_above(_arg0, _arg1)
}

// SetKeepBelow asks to keep @window below, so that it stays in bottom. Note
// that you shouldn’t assume the window is definitely below afterward, because
// other entities (e.g. the user or [window manager][gtk-X11-arch]) could not
// keep it below, and not all window managers support putting windows below. But
// normally the window will be kept below. Just don’t write code that crashes if
// not.
//
// It’s permitted to call this function before showing a window, in which case
// the window will be kept below when it appears onscreen initially.
//
// You can track the below state via the “window-state-event” signal on Widget.
//
// Note that, according to the Extended Window Manager Hints Specification
// (http://www.freedesktop.org/Standards/wm-spec), the above state is mainly
// meant for user preferences and should not be used by applications e.g. for
// drawing attention to their dialogs.
func (w window) SetKeepBelow(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_keep_below(_arg0, _arg1)
}

// SetMnemonicModifier sets the mnemonic modifier for this window.
func (w window) SetMnemonicModifier(modifier gdk.ModifierType) {
	var _arg0 *C.GtkWindow      // out
	var _arg1 C.GdkModifierType // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GdkModifierType)(modifier)

	C.gtk_window_set_mnemonic_modifier(_arg0, _arg1)
}

// SetMnemonicsVisible sets the Window:mnemonics-visible property.
func (w window) SetMnemonicsVisible(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_mnemonics_visible(_arg0, _arg1)
}

// SetModal sets a window modal or non-modal. Modal windows prevent interaction
// with other windows in the same application. To keep modal dialogs on top of
// main application windows, use gtk_window_set_transient_for() to make the
// dialog transient for the parent; most [window managers][gtk-X11-arch] will
// then disallow lowering the dialog below the parent.
func (w window) SetModal(modal bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if modal {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_modal(_arg0, _arg1)
}

// SetOpacity: request the windowing system to make @window partially
// transparent, with opacity 0 being fully transparent and 1 fully opaque.
// (Values of the opacity parameter are clamped to the [0,1] range.) On X11 this
// has any effect only on X screens with a compositing manager running. See
// gtk_widget_is_composited(). On Windows it should work always.
//
// Note that setting a window’s opacity after the window has been shown causes
// it to flicker once on Windows.
func (w window) SetOpacity(opacity float64) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gdouble    // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (C.gdouble)(opacity)

	C.gtk_window_set_opacity(_arg0, _arg1)
}

// SetPosition sets a position constraint for this window. If the old or new
// constraint is GTK_WIN_POS_CENTER_ALWAYS, this will also cause the window to
// be repositioned to satisfy the new constraint.
func (w window) SetPosition(position WindowPosition) {
	var _arg0 *C.GtkWindow        // out
	var _arg1 C.GtkWindowPosition // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GtkWindowPosition)(position)

	C.gtk_window_set_position(_arg0, _arg1)
}

// SetResizable sets whether the user can resize a window. Windows are user
// resizable by default.
func (w window) SetResizable(resizable bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if resizable {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_resizable(_arg0, _arg1)
}

// SetRole: this function is only useful on X11, not with other GTK+ targets.
//
// In combination with the window title, the window role allows a [window
// manager][gtk-X11-arch] to identify "the same" window when an application is
// restarted. So for example you might set the “toolbox” role on your app’s
// toolbox window, so that when the user restarts their session, the window
// manager can put the toolbox back in the same place.
//
// If a window already has a unique title, you don’t need to set the role, since
// the WM can use the title to identify the window when restoring the session.
func (w window) SetRole(role string) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.gchar)(C.CString(role))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_window_set_role(_arg0, _arg1)
}

// SetScreen sets the Screen where the @window is displayed; if the window is
// already mapped, it will be unmapped, and then remapped on the new screen.
func (w window) SetScreen(screen gdk.Screen) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GdkScreen // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GdkScreen)(unsafe.Pointer(screen.Native()))

	C.gtk_window_set_screen(_arg0, _arg1)
}

// SetSkipPagerHint windows may set a hint asking the desktop environment not to
// display the window in the pager. This function sets this hint. (A "pager" is
// any desktop navigation tool such as a workspace switcher that displays a
// thumbnail representation of the windows on the screen.)
func (w window) SetSkipPagerHint(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_skip_pager_hint(_arg0, _arg1)
}

// SetSkipTaskbarHint windows may set a hint asking the desktop environment not
// to display the window in the task bar. This function sets this hint.
func (w window) SetSkipTaskbarHint(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_skip_taskbar_hint(_arg0, _arg1)
}

// SetStartupID: startup notification identifiers are used by desktop
// environment to track application startup, to provide user feedback and other
// features. This function changes the corresponding property on the underlying
// GdkWindow. Normally, startup identifier is managed automatically and you
// should only use this function in special cases like transferring focus from
// other processes. You should use this function before calling
// gtk_window_present() or any equivalent function generating a window map
// event.
//
// This function is only useful on X11, not with other GTK+ targets.
func (w window) SetStartupID(startupId string) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.gchar)(C.CString(startupId))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_window_set_startup_id(_arg0, _arg1)
}

// SetTitle sets the title of the Window. The title of a window will be
// displayed in its title bar; on the X Window System, the title bar is rendered
// by the [window manager][gtk-X11-arch], so exactly how the title appears to
// users may vary according to a user’s exact configuration. The title should
// help a user distinguish this window from other windows they may have open. A
// good title might include the application name and current document filename,
// for example.
func (w window) SetTitle(title string) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_window_set_title(_arg0, _arg1)
}

// SetTitlebar sets a custom titlebar for @window.
//
// A typical widget used here is HeaderBar, as it provides various features
// expected of a titlebar while allowing the addition of child widgets to it.
//
// If you set a custom titlebar, GTK+ will do its best to convince the window
// manager not to put its own titlebar on the window. Depending on the system,
// this function may not work for a window that is already visible, so you set
// the titlebar before calling gtk_widget_show().
func (w window) SetTitlebar(titlebar Widget) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(titlebar.Native()))

	C.gtk_window_set_titlebar(_arg0, _arg1)
}

// SetTransientFor: dialog windows should be set transient for the main
// application window they were spawned from. This allows [window
// managers][gtk-X11-arch] to e.g. keep the dialog on top of the main window, or
// center the dialog over the main window. gtk_dialog_new_with_buttons() and
// other convenience functions in GTK+ will sometimes call
// gtk_window_set_transient_for() on your behalf.
//
// Passing nil for @parent unsets the current transient window.
//
// On Wayland, this function can also be used to attach a new K_WINDOW_POPUP to
// a K_WINDOW_TOPLEVEL parent already mapped on screen so that the
// K_WINDOW_POPUP will be created as a subsurface-based window
// K_WINDOW_SUBSURFACE which can be positioned at will relatively to the
// K_WINDOW_TOPLEVEL surface.
//
// On Windows, this function puts the child window on top of the parent, much as
// the window manager would have done on X.
func (w window) SetTransientFor(parent Window) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))

	C.gtk_window_set_transient_for(_arg0, _arg1)
}

// SetTypeHint: by setting the type hint for the window, you allow the window
// manager to decorate and handle the window in a way which is suitable to the
// function of the window in your application.
//
// This function should be called before the window becomes visible.
//
// gtk_dialog_new_with_buttons() and other convenience functions in GTK+ will
// sometimes call gtk_window_set_type_hint() on your behalf.
func (w window) SetTypeHint(hint gdk.WindowTypeHint) {
	var _arg0 *C.GtkWindow        // out
	var _arg1 C.GdkWindowTypeHint // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (C.GdkWindowTypeHint)(hint)

	C.gtk_window_set_type_hint(_arg0, _arg1)
}

// SetUrgencyHint windows may set a hint asking the desktop environment to draw
// the users attention to the window. This function sets this hint.
func (w window) SetUrgencyHint(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_urgency_hint(_arg0, _arg1)
}

// SetWmclass: don’t use this function. It sets the X Window System “class” and
// “name” hints for a window. According to the ICCCM, you should always set
// these to the same value for all windows in an application, and GTK+ sets them
// to that value by default, so calling this function is sort of pointless.
// However, you may want to call gtk_window_set_role() on each window in your
// application, for the benefit of the session manager. Setting the role allows
// the window manager to restore window positions when loading a saved session.
func (w window) SetWmclass(wmclassName string, wmclassClass string) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.gchar     // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.gchar)(C.CString(wmclassName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(wmclassClass))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_window_set_wmclass(_arg0, _arg1, _arg2)
}

// Stick asks to stick @window, which means that it will appear on all user
// desktops. Note that you shouldn’t assume the window is definitely stuck
// afterward, because other entities (e.g. the user or [window
// manager][gtk-X11-arch] could unstick it again, and some window managers do
// not support sticking windows. But normally the window will end up stuck. Just
// don't write code that crashes if not.
//
// It’s permitted to call this function before showing a window.
//
// You can track stickiness via the “window-state-event” signal on Widget.
func (w window) Stick() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_stick(_arg0)
}

// Unfullscreen asks to toggle off the fullscreen state for @window. Note that
// you shouldn’t assume the window is definitely not full screen afterward,
// because other entities (e.g. the user or [window manager][gtk-X11-arch])
// could fullscreen it again, and not all window managers honor requests to
// unfullscreen windows. But normally the window will end up restored to its
// normal state. Just don’t write code that crashes if not.
//
// You can track the fullscreen state via the “window-state-event” signal on
// Widget.
func (w window) Unfullscreen() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_unfullscreen(_arg0)
}

// Unmaximize asks to unmaximize @window. Note that you shouldn’t assume the
// window is definitely unmaximized afterward, because other entities (e.g. the
// user or [window manager][gtk-X11-arch]) could maximize it again, and not all
// window managers honor requests to unmaximize. But normally the window will
// end up unmaximized. Just don’t write code that crashes if not.
//
// You can track maximization via the “window-state-event” signal on Widget.
func (w window) Unmaximize() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_unmaximize(_arg0)
}

// Unstick asks to unstick @window, which means that it will appear on only one
// of the user’s desktops. Note that you shouldn’t assume the window is
// definitely unstuck afterward, because other entities (e.g. the user or
// [window manager][gtk-X11-arch]) could stick it again. But normally the window
// will end up stuck. Just don’t write code that crashes if not.
//
// You can track stickiness via the “window-state-event” signal on Widget.
func (w window) Unstick() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_unstick(_arg0)
}

type WindowAccessible interface {
	ContainerAccessible
}

// windowAccessible implements the WindowAccessible class.
type windowAccessible struct {
	ContainerAccessible
}

var _ WindowAccessible = (*windowAccessible)(nil)

// WrapWindowAccessible wraps a GObject to the right type. It is
// primarily used internally.
func WrapWindowAccessible(obj *externglib.Object) WindowAccessible {
	return windowAccessible{
		ContainerAccessible: WrapContainerAccessible(obj),
	}
}

func marshalWindowAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapWindowAccessible(obj), nil
}

// WindowGroup: a WindowGroup restricts the effect of grabs to windows in the
// same group, thereby making window groups almost behave like separate
// applications.
//
// A window can be a member in at most one window group at a time. Windows that
// have not been explicitly assigned to a group are implicitly treated like
// windows of the default window group.
//
// GtkWindowGroup objects are referenced by each window in the group, so once
// you have added all windows to a GtkWindowGroup, you can drop the initial
// reference to the window group with g_object_unref(). If the windows in the
// window group are subsequently destroyed, then they will be removed from the
// window group and drop their references on the window group; when all window
// have been removed, the window group will be freed.
type WindowGroup interface {
	gextras.Objector

	// AddWindow adds a window to a WindowGroup.
	AddWindow(window Window)
	// CurrentDeviceGrab returns the current grab widget for @device, or nil if
	// none.
	CurrentDeviceGrab(device gdk.Device) Widget
	// CurrentGrab gets the current grab widget of the given group, see
	// gtk_grab_add().
	CurrentGrab() Widget
	// RemoveWindow removes a window from a WindowGroup.
	RemoveWindow(window Window)
}

// windowGroup implements the WindowGroup class.
type windowGroup struct {
	gextras.Objector
}

var _ WindowGroup = (*windowGroup)(nil)

// WrapWindowGroup wraps a GObject to the right type. It is
// primarily used internally.
func WrapWindowGroup(obj *externglib.Object) WindowGroup {
	return windowGroup{
		Objector: obj,
	}
}

func marshalWindowGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapWindowGroup(obj), nil
}

// NewWindowGroup creates a new WindowGroup object. Grabs added with
// gtk_grab_add() only affect windows within the same WindowGroup.
func NewWindowGroup() WindowGroup {
	var _cret *C.GtkWindowGroup // in

	_cret = C.gtk_window_group_new()

	var _windowGroup WindowGroup // out

	_windowGroup = WrapWindowGroup(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _windowGroup
}

// AddWindow adds a window to a WindowGroup.
func (w windowGroup) AddWindow(window Window) {
	var _arg0 *C.GtkWindowGroup // out
	var _arg1 *C.GtkWindow      // out

	_arg0 = (*C.GtkWindowGroup)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_window_group_add_window(_arg0, _arg1)
}

// CurrentDeviceGrab returns the current grab widget for @device, or nil if
// none.
func (w windowGroup) CurrentDeviceGrab(device gdk.Device) Widget {
	var _arg0 *C.GtkWindowGroup // out
	var _arg1 *C.GdkDevice      // out
	var _cret *C.GtkWidget      // in

	_arg0 = (*C.GtkWindowGroup)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))

	_cret = C.gtk_window_group_get_current_device_grab(_arg0, _arg1)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// CurrentGrab gets the current grab widget of the given group, see
// gtk_grab_add().
func (w windowGroup) CurrentGrab() Widget {
	var _arg0 *C.GtkWindowGroup // out
	var _cret *C.GtkWidget      // in

	_arg0 = (*C.GtkWindowGroup)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_group_get_current_grab(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

// RemoveWindow removes a window from a WindowGroup.
func (w windowGroup) RemoveWindow(window Window) {
	var _arg0 *C.GtkWindowGroup // out
	var _arg1 *C.GtkWindow      // out

	_arg0 = (*C.GtkWindowGroup)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_window_group_remove_window(_arg0, _arg1)
}

type AccelKey struct {
	native C.GtkAccelKey
}

// WrapAccelKey wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAccelKey(ptr unsafe.Pointer) *AccelKey {
	if ptr == nil {
		return nil
	}

	return (*AccelKey)(ptr)
}

// Native returns the underlying C source pointer.
func (a *AccelKey) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// BindingArg: a BindingArg holds the data associated with an argument for a key
// binding signal emission as stored in BindingSignal.
type BindingArg struct {
	native C.GtkBindingArg
}

// WrapBindingArg wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapBindingArg(ptr unsafe.Pointer) *BindingArg {
	if ptr == nil {
		return nil
	}

	return (*BindingArg)(ptr)
}

// Native returns the underlying C source pointer.
func (b *BindingArg) Native() unsafe.Pointer {
	return unsafe.Pointer(&b.native)
}

// BindingEntry: each key binding element of a binding sets binding list is
// represented by a GtkBindingEntry.
type BindingEntry struct {
	native C.GtkBindingEntry
}

// WrapBindingEntry wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapBindingEntry(ptr unsafe.Pointer) *BindingEntry {
	if ptr == nil {
		return nil
	}

	return (*BindingEntry)(ptr)
}

// Native returns the underlying C source pointer.
func (b *BindingEntry) Native() unsafe.Pointer {
	return unsafe.Pointer(&b.native)
}

// BindingSignal: a GtkBindingSignal stores the necessary information to
// activate a widget in response to a key press via a signal emission.
type BindingSignal struct {
	native C.GtkBindingSignal
}

// WrapBindingSignal wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapBindingSignal(ptr unsafe.Pointer) *BindingSignal {
	if ptr == nil {
		return nil
	}

	return (*BindingSignal)(ptr)
}

// Native returns the underlying C source pointer.
func (b *BindingSignal) Native() unsafe.Pointer {
	return unsafe.Pointer(&b.native)
}

// Border: a struct that specifies a border around a rectangular area that can
// be of different width on each side.
type Border struct {
	native C.GtkBorder
}

// WrapBorder wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapBorder(ptr unsafe.Pointer) *Border {
	if ptr == nil {
		return nil
	}

	return (*Border)(ptr)
}

func marshalBorder(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapBorder(unsafe.Pointer(b)), nil
}

// NewBorder constructs a struct Border.
func NewBorder() *Border {
	var _cret *C.GtkBorder // in

	_cret = C.gtk_border_new()

	var _border *Border // out

	_border = WrapBorder(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_border, func(v *Border) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _border
}

// Native returns the underlying C source pointer.
func (b *Border) Native() unsafe.Pointer {
	return unsafe.Pointer(&b.native)
}

// Copy copies a Border-struct.
func (b *Border) Copy() *Border {
	var _arg0 *C.GtkBorder // out
	var _cret *C.GtkBorder // in

	_arg0 = (*C.GtkBorder)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_border_copy(_arg0)

	var _border *Border // out

	_border = WrapBorder(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_border, func(v *Border) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _border
}

// Free frees a Border-struct.
func (b *Border) Free() {
	var _arg0 *C.GtkBorder // out

	_arg0 = (*C.GtkBorder)(unsafe.Pointer(b.Native()))

	C.gtk_border_free(_arg0)
}

// CSSSection defines a part of a CSS document. Because sections are nested into
// one another, you can use gtk_css_section_get_parent() to get the containing
// region.
type CSSSection struct {
	native C.GtkCssSection
}

// WrapCSSSection wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapCSSSection(ptr unsafe.Pointer) *CSSSection {
	if ptr == nil {
		return nil
	}

	return (*CSSSection)(ptr)
}

func marshalCSSSection(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapCSSSection(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *CSSSection) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

// EndLine returns the line in the CSS document where this section end. The line
// number is 0-indexed, so the first line of the document will return 0. This
// value may change in future invocations of this function if @section is not
// yet parsed completely. This will for example happen in the
// GtkCssProvider::parsing-error signal. The end position and line may be
// identical to the start position and line for sections which failed to parse
// anything successfully.
func (s *CSSSection) EndLine() uint {
	var _arg0 *C.GtkCssSection // out
	var _cret C.guint          // in

	_arg0 = (*C.GtkCssSection)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_css_section_get_end_line(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// EndPosition returns the offset in bytes from the start of the current line
// returned via gtk_css_section_get_end_line(). This value may change in future
// invocations of this function if @section is not yet parsed completely. This
// will for example happen in the GtkCssProvider::parsing-error signal. The end
// position and line may be identical to the start position and line for
// sections which failed to parse anything successfully.
func (s *CSSSection) EndPosition() uint {
	var _arg0 *C.GtkCssSection // out
	var _cret C.guint          // in

	_arg0 = (*C.GtkCssSection)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_css_section_get_end_position(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// File gets the file that @section was parsed from. If no such file exists, for
// example because the CSS was loaded via @gtk_css_provider_load_from_data(),
// then nil is returned.
func (s *CSSSection) File() gio.File {
	var _arg0 *C.GtkCssSection // out
	var _cret *C.GFile         // in

	_arg0 = (*C.GtkCssSection)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_css_section_get_file(_arg0)

	var _file gio.File // out

	_file = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.File)

	return _file
}

// Parent gets the parent section for the given @section. The parent section is
// the section that contains this @section. A special case are sections of type
// K_CSS_SECTION_DOCUMENT. Their parent will either be nil if they are the
// original CSS document that was loaded by gtk_css_provider_load_from_file() or
// a section of type K_CSS_SECTION_IMPORT if it was loaded with an import rule
// from a different file.
func (s *CSSSection) Parent() *CSSSection {
	var _arg0 *C.GtkCssSection // out
	var _cret *C.GtkCssSection // in

	_arg0 = (*C.GtkCssSection)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_css_section_get_parent(_arg0)

	var _cssSection *CSSSection // out

	_cssSection = WrapCSSSection(unsafe.Pointer(_cret))

	return _cssSection
}

// SectionType gets the type of information that @section describes.
func (s *CSSSection) SectionType() CSSSectionType {
	var _arg0 *C.GtkCssSection    // out
	var _cret C.GtkCssSectionType // in

	_arg0 = (*C.GtkCssSection)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_css_section_get_section_type(_arg0)

	var _cssSectionType CSSSectionType // out

	_cssSectionType = CSSSectionType(_cret)

	return _cssSectionType
}

// StartLine returns the line in the CSS document where this section starts. The
// line number is 0-indexed, so the first line of the document will return 0.
func (s *CSSSection) StartLine() uint {
	var _arg0 *C.GtkCssSection // out
	var _cret C.guint          // in

	_arg0 = (*C.GtkCssSection)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_css_section_get_start_line(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// StartPosition returns the offset in bytes from the start of the current line
// returned via gtk_css_section_get_start_line().
func (s *CSSSection) StartPosition() uint {
	var _arg0 *C.GtkCssSection // out
	var _cret C.guint          // in

	_arg0 = (*C.GtkCssSection)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_css_section_get_start_position(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// Ref increments the reference count on @section.
func (s *CSSSection) Ref() *CSSSection {
	var _arg0 *C.GtkCssSection // out
	var _cret *C.GtkCssSection // in

	_arg0 = (*C.GtkCssSection)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_css_section_ref(_arg0)

	var _cssSection *CSSSection // out

	_cssSection = WrapCSSSection(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_cssSection, func(v *CSSSection) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _cssSection
}

// Unref decrements the reference count on @section, freeing the structure if
// the reference count reaches 0.
func (s *CSSSection) Unref() {
	var _arg0 *C.GtkCssSection // out

	_arg0 = (*C.GtkCssSection)(unsafe.Pointer(s.Native()))

	C.gtk_css_section_unref(_arg0)
}

// FileFilterInfo: a FileFilterInfo-struct is used to pass information about the
// tested file to gtk_file_filter_filter().
type FileFilterInfo struct {
	native C.GtkFileFilterInfo
}

// WrapFileFilterInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFileFilterInfo(ptr unsafe.Pointer) *FileFilterInfo {
	if ptr == nil {
		return nil
	}

	return (*FileFilterInfo)(ptr)
}

// Native returns the underlying C source pointer.
func (f *FileFilterInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&f.native)
}

type FixedChild struct {
	native C.GtkFixedChild
}

// WrapFixedChild wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFixedChild(ptr unsafe.Pointer) *FixedChild {
	if ptr == nil {
		return nil
	}

	return (*FixedChild)(ptr)
}

// Native returns the underlying C source pointer.
func (f *FixedChild) Native() unsafe.Pointer {
	return unsafe.Pointer(&f.native)
}

// Gradient: gtkGradient is a boxed type that represents a gradient. It is the
// result of parsing a [gradient expression][gtkcssprovider-gradients]. To
// obtain the gradient represented by a GtkGradient, it has to be resolved with
// gtk_gradient_resolve(), which replaces all symbolic color references by the
// colors they refer to (in a given context) and constructs a #cairo_pattern_t
// value.
//
// It is not normally necessary to deal directly with Gradients, since they are
// mostly used behind the scenes by StyleContext and CssProvider.
//
// Gradient is deprecated. It was used internally by GTK’s CSS engine to
// represent gradients. As its handling is not conforming to modern web
// standards, it is not used anymore. If you want to use gradients in your own
// code, please use Cairo directly.
type Gradient struct {
	native C.GtkGradient
}

// WrapGradient wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapGradient(ptr unsafe.Pointer) *Gradient {
	if ptr == nil {
		return nil
	}

	return (*Gradient)(ptr)
}

func marshalGradient(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapGradient(unsafe.Pointer(b)), nil
}

// NewGradientLinear constructs a struct Gradient.
func NewGradientLinear(x0 float64, y0 float64, x1 float64, y1 float64) *Gradient {
	var _arg1 C.gdouble      // out
	var _arg2 C.gdouble      // out
	var _arg3 C.gdouble      // out
	var _arg4 C.gdouble      // out
	var _cret *C.GtkGradient // in

	_arg1 = (C.gdouble)(x0)
	_arg2 = (C.gdouble)(y0)
	_arg3 = (C.gdouble)(x1)
	_arg4 = (C.gdouble)(y1)

	_cret = C.gtk_gradient_new_linear(_arg1, _arg2, _arg3, _arg4)

	var _gradient *Gradient // out

	_gradient = WrapGradient(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_gradient, func(v *Gradient) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _gradient
}

// NewGradientRadial constructs a struct Gradient.
func NewGradientRadial(x0 float64, y0 float64, radius0 float64, x1 float64, y1 float64, radius1 float64) *Gradient {
	var _arg1 C.gdouble      // out
	var _arg2 C.gdouble      // out
	var _arg3 C.gdouble      // out
	var _arg4 C.gdouble      // out
	var _arg5 C.gdouble      // out
	var _arg6 C.gdouble      // out
	var _cret *C.GtkGradient // in

	_arg1 = (C.gdouble)(x0)
	_arg2 = (C.gdouble)(y0)
	_arg3 = (C.gdouble)(radius0)
	_arg4 = (C.gdouble)(x1)
	_arg5 = (C.gdouble)(y1)
	_arg6 = (C.gdouble)(radius1)

	_cret = C.gtk_gradient_new_radial(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)

	var _gradient *Gradient // out

	_gradient = WrapGradient(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_gradient, func(v *Gradient) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _gradient
}

// Native returns the underlying C source pointer.
func (g *Gradient) Native() unsafe.Pointer {
	return unsafe.Pointer(&g.native)
}

// AddColorStop adds a stop color to @gradient.
func (g *Gradient) AddColorStop(offset float64, color *SymbolicColor) {
	var _arg0 *C.GtkGradient      // out
	var _arg1 C.gdouble           // out
	var _arg2 *C.GtkSymbolicColor // out

	_arg0 = (*C.GtkGradient)(unsafe.Pointer(g.Native()))
	_arg1 = (C.gdouble)(offset)
	_arg2 = (*C.GtkSymbolicColor)(unsafe.Pointer(color.Native()))

	C.gtk_gradient_add_color_stop(_arg0, _arg1, _arg2)
}

// Ref increases the reference count of @gradient.
func (g *Gradient) Ref() *Gradient {
	var _arg0 *C.GtkGradient // out
	var _cret *C.GtkGradient // in

	_arg0 = (*C.GtkGradient)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gradient_ref(_arg0)

	var _ret *Gradient // out

	_ret = WrapGradient(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_ret, func(v *Gradient) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _ret
}

// Resolve: if @gradient is resolvable, @resolved_gradient will be filled in
// with the resolved gradient as a cairo_pattern_t, and true will be returned.
// Generally, if @gradient can’t be resolved, it is due to it being defined on
// top of a named color that doesn't exist in @props.
func (g *Gradient) Resolve(props StyleProperties) (*cairo.Pattern, bool) {
	var _arg0 *C.GtkGradient        // out
	var _arg1 *C.GtkStyleProperties // out
	var _resolvedGradient *cairo.Pattern
	var _cret C.gboolean // in

	_arg0 = (*C.GtkGradient)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.GtkStyleProperties)(unsafe.Pointer(props.Native()))

	_cret = C.gtk_gradient_resolve(_arg0, _arg1, (**C.cairo_pattern_t)(unsafe.Pointer(&_resolvedGradient)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _resolvedGradient, _ok
}

func (g *Gradient) ResolveForContext(context StyleContext) *cairo.Pattern {
	var _arg0 *C.GtkGradient     // out
	var _arg1 *C.GtkStyleContext // out
	var _cret *C.cairo_pattern_t // in

	_arg0 = (*C.GtkGradient)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))

	_cret = C.gtk_gradient_resolve_for_context(_arg0, _arg1)

	var _pattern *cairo.Pattern // out

	_pattern = cairo.WrapPattern(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_pattern, func(v *cairo.Pattern) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _pattern
}

// String creates a string representation for @gradient that is suitable for
// using in GTK CSS files.
func (g *Gradient) String() string {
	var _arg0 *C.GtkGradient // out
	var _cret *C.char        // in

	_arg0 = (*C.GtkGradient)(unsafe.Pointer(g.Native()))

	_cret = C.gtk_gradient_to_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Unref decreases the reference count of @gradient, freeing its memory if the
// reference count reaches 0.
func (g *Gradient) Unref() {
	var _arg0 *C.GtkGradient // out

	_arg0 = (*C.GtkGradient)(unsafe.Pointer(g.Native()))

	C.gtk_gradient_unref(_arg0)
}

// IMContextInfo: bookkeeping information about a loadable input method.
type IMContextInfo struct {
	native C.GtkIMContextInfo
}

// WrapIMContextInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapIMContextInfo(ptr unsafe.Pointer) *IMContextInfo {
	if ptr == nil {
		return nil
	}

	return (*IMContextInfo)(ptr)
}

// Native returns the underlying C source pointer.
func (i *IMContextInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

type IconSet struct {
	native C.GtkIconSet
}

// WrapIconSet wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapIconSet(ptr unsafe.Pointer) *IconSet {
	if ptr == nil {
		return nil
	}

	return (*IconSet)(ptr)
}

func marshalIconSet(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapIconSet(unsafe.Pointer(b)), nil
}

// NewIconSet constructs a struct IconSet.
func NewIconSet() *IconSet {
	var _cret *C.GtkIconSet // in

	_cret = C.gtk_icon_set_new()

	var _iconSet *IconSet // out

	_iconSet = WrapIconSet(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_iconSet, func(v *IconSet) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _iconSet
}

// NewIconSetFromPixbuf constructs a struct IconSet.
func NewIconSetFromPixbuf(pixbuf gdkpixbuf.Pixbuf) *IconSet {
	var _arg1 *C.GdkPixbuf  // out
	var _cret *C.GtkIconSet // in

	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	_cret = C.gtk_icon_set_new_from_pixbuf(_arg1)

	var _iconSet *IconSet // out

	_iconSet = WrapIconSet(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_iconSet, func(v *IconSet) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _iconSet
}

// Native returns the underlying C source pointer.
func (i *IconSet) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

// AddSource: icon sets have a list of IconSource, which they use as base icons
// for rendering icons in different states and sizes. Icons are scaled, made to
// look insensitive, etc. in gtk_icon_set_render_icon(), but IconSet needs base
// images to work with. The base images and when to use them are described by a
// IconSource.
//
// This function copies @source, so you can reuse the same source immediately
// without affecting the icon set.
//
// An example of when you’d use this function: a web browser’s "Back to Previous
// Page" icon might point in a different direction in Hebrew and in English; it
// might look different when insensitive; and it might change size depending on
// toolbar mode (small/large icons). So a single icon set would contain all
// those variants of the icon, and you might add a separate source for each one.
//
// You should nearly always add a “default” icon source with all fields
// wildcarded, which will be used as a fallback if no more specific source
// matches. IconSet always prefers more specific icon sources to more generic
// icon sources. The order in which you add the sources to the icon set does not
// matter.
//
// gtk_icon_set_new_from_pixbuf() creates a new icon set with a default icon
// source based on the given pixbuf.
func (i *IconSet) AddSource(source *IconSource) {
	var _arg0 *C.GtkIconSet    // out
	var _arg1 *C.GtkIconSource // out

	_arg0 = (*C.GtkIconSet)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkIconSource)(unsafe.Pointer(source.Native()))

	C.gtk_icon_set_add_source(_arg0, _arg1)
}

// Copy copies @icon_set by value.
func (i *IconSet) Copy() *IconSet {
	var _arg0 *C.GtkIconSet // out
	var _cret *C.GtkIconSet // in

	_arg0 = (*C.GtkIconSet)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_set_copy(_arg0)

	var _iconSet *IconSet // out

	_iconSet = WrapIconSet(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_iconSet, func(v *IconSet) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _iconSet
}

// Sizes obtains a list of icon sizes this icon set can render. The returned
// array must be freed with g_free().
func (i *IconSet) Sizes() []int {
	var _arg0 *C.GtkIconSet // out
	var _arg1 *C.GtkIconSize
	var _arg2 C.gint // in

	_arg0 = (*C.GtkIconSet)(unsafe.Pointer(i.Native()))

	C.gtk_icon_set_get_sizes(_arg0, &_arg1, &_arg2)

	var _sizes []int

	_sizes = unsafe.Slice((*int)(unsafe.Pointer(_arg1)), _arg2)
	runtime.SetFinalizer(&_sizes, func(v *[]int) {
		C.free(unsafe.Pointer(&(*v)[0]))
	})

	return _sizes
}

// Ref increments the reference count on @icon_set.
func (i *IconSet) Ref() *IconSet {
	var _arg0 *C.GtkIconSet // out
	var _cret *C.GtkIconSet // in

	_arg0 = (*C.GtkIconSet)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_icon_set_ref(_arg0)

	var _iconSet *IconSet // out

	_iconSet = WrapIconSet(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_iconSet, func(v *IconSet) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _iconSet
}

// RenderIcon renders an icon using gtk_style_render_icon(). In most cases,
// gtk_widget_render_icon() is better, since it automatically provides most of
// the arguments from the current widget settings. This function never returns
// nil; if the icon can’t be rendered (perhaps because an image file fails to
// load), a default "missing image" icon will be returned instead.
func (i *IconSet) RenderIcon(style Style, direction TextDirection, state StateType, size int, widget Widget, detail string) gdkpixbuf.Pixbuf {
	var _arg0 *C.GtkIconSet      // out
	var _arg1 *C.GtkStyle        // out
	var _arg2 C.GtkTextDirection // out
	var _arg3 C.GtkStateType     // out
	var _arg4 C.GtkIconSize      // out
	var _arg5 *C.GtkWidget       // out
	var _arg6 *C.gchar           // out
	var _cret *C.GdkPixbuf       // in

	_arg0 = (*C.GtkIconSet)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
	_arg2 = (C.GtkTextDirection)(direction)
	_arg3 = (C.GtkStateType)(state)
	_arg4 = (C.GtkIconSize)(size)
	_arg5 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg6 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(_arg6))

	_cret = C.gtk_icon_set_render_icon(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)

	var _pixbuf gdkpixbuf.Pixbuf // out

	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

	return _pixbuf
}

// RenderIconPixbuf renders an icon using gtk_render_icon_pixbuf(). In most
// cases, gtk_widget_render_icon_pixbuf() is better, since it automatically
// provides most of the arguments from the current widget settings. This
// function never returns nil; if the icon can’t be rendered (perhaps because an
// image file fails to load), a default "missing image" icon will be returned
// instead.
func (i *IconSet) RenderIconPixbuf(context StyleContext, size int) gdkpixbuf.Pixbuf {
	var _arg0 *C.GtkIconSet      // out
	var _arg1 *C.GtkStyleContext // out
	var _arg2 C.GtkIconSize      // out
	var _cret *C.GdkPixbuf       // in

	_arg0 = (*C.GtkIconSet)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (C.GtkIconSize)(size)

	_cret = C.gtk_icon_set_render_icon_pixbuf(_arg0, _arg1, _arg2)

	var _pixbuf gdkpixbuf.Pixbuf // out

	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

	return _pixbuf
}

// RenderIconSurface renders an icon using gtk_render_icon_pixbuf() and converts
// it to a cairo surface.
//
// This function never returns nil; if the icon can’t be rendered (perhaps
// because an image file fails to load), a default "missing image" icon will be
// returned instead.
func (i *IconSet) RenderIconSurface(context StyleContext, size int, scale int, forWindow gdk.Window) *cairo.Surface {
	var _arg0 *C.GtkIconSet      // out
	var _arg1 *C.GtkStyleContext // out
	var _arg2 C.GtkIconSize      // out
	var _arg3 C.int              // out
	var _arg4 *C.GdkWindow       // out
	var _cret *C.cairo_surface_t // in

	_arg0 = (*C.GtkIconSet)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	_arg2 = (C.GtkIconSize)(size)
	_arg3 = (C.int)(scale)
	_arg4 = (*C.GdkWindow)(unsafe.Pointer(forWindow.Native()))

	_cret = C.gtk_icon_set_render_icon_surface(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _surface *cairo.Surface // out

	_surface = cairo.WrapSurface(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_surface, func(v *cairo.Surface) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _surface
}

// Unref decrements the reference count on @icon_set, and frees memory if the
// reference count reaches 0.
func (i *IconSet) Unref() {
	var _arg0 *C.GtkIconSet // out

	_arg0 = (*C.GtkIconSet)(unsafe.Pointer(i.Native()))

	C.gtk_icon_set_unref(_arg0)
}

type IconSource struct {
	native C.GtkIconSource
}

// WrapIconSource wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapIconSource(ptr unsafe.Pointer) *IconSource {
	if ptr == nil {
		return nil
	}

	return (*IconSource)(ptr)
}

func marshalIconSource(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapIconSource(unsafe.Pointer(b)), nil
}

// NewIconSource constructs a struct IconSource.
func NewIconSource() *IconSource {
	var _cret *C.GtkIconSource // in

	_cret = C.gtk_icon_source_new()

	var _iconSource *IconSource // out

	_iconSource = WrapIconSource(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_iconSource, func(v *IconSource) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _iconSource
}

// Native returns the underlying C source pointer.
func (i *IconSource) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

// Copy creates a copy of @source; mostly useful for language bindings.
func (s *IconSource) Copy() *IconSource {
	var _arg0 *C.GtkIconSource // out
	var _cret *C.GtkIconSource // in

	_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_icon_source_copy(_arg0)

	var _iconSource *IconSource // out

	_iconSource = WrapIconSource(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_iconSource, func(v *IconSource) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _iconSource
}

// Free frees a dynamically-allocated icon source, along with its filename,
// size, and pixbuf fields if those are not nil.
func (s *IconSource) Free() {
	var _arg0 *C.GtkIconSource // out

	_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

	C.gtk_icon_source_free(_arg0)
}

// Direction obtains the text direction this icon source applies to. The return
// value is only useful/meaningful if the text direction is not wildcarded.
func (s *IconSource) Direction() TextDirection {
	var _arg0 *C.GtkIconSource   // out
	var _cret C.GtkTextDirection // in

	_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_icon_source_get_direction(_arg0)

	var _textDirection TextDirection // out

	_textDirection = TextDirection(_cret)

	return _textDirection
}

// DirectionWildcarded gets the value set by
// gtk_icon_source_set_direction_wildcarded().
func (s *IconSource) DirectionWildcarded() bool {
	var _arg0 *C.GtkIconSource // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_icon_source_get_direction_wildcarded(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Filename retrieves the source filename, or nil if none is set. The filename
// is not a copy, and should not be modified or expected to persist beyond the
// lifetime of the icon source.
func (s *IconSource) Filename() string {
	var _arg0 *C.GtkIconSource // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_icon_source_get_filename(_arg0)

	var _filename string // out

	_filename = C.GoString(_cret)

	return _filename
}

// IconName retrieves the source icon name, or nil if none is set. The icon_name
// is not a copy, and should not be modified or expected to persist beyond the
// lifetime of the icon source.
func (s *IconSource) IconName() string {
	var _arg0 *C.GtkIconSource // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_icon_source_get_icon_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Pixbuf retrieves the source pixbuf, or nil if none is set. In addition, if a
// filename source is in use, this function in some cases will return the pixbuf
// from loaded from the filename. This is, for example, true for the
// GtkIconSource passed to the Style render_icon() virtual function. The
// reference count on the pixbuf is not incremented.
func (s *IconSource) Pixbuf() gdkpixbuf.Pixbuf {
	var _arg0 *C.GtkIconSource // out
	var _cret *C.GdkPixbuf     // in

	_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_icon_source_get_pixbuf(_arg0)

	var _pixbuf gdkpixbuf.Pixbuf // out

	_pixbuf = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

	return _pixbuf
}

// Size obtains the icon size this source applies to. The return value is only
// useful/meaningful if the icon size is not wildcarded.
func (s *IconSource) Size() int {
	var _arg0 *C.GtkIconSource // out
	var _cret C.GtkIconSize    // in

	_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_icon_source_get_size(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// SizeWildcarded gets the value set by gtk_icon_source_set_size_wildcarded().
func (s *IconSource) SizeWildcarded() bool {
	var _arg0 *C.GtkIconSource // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_icon_source_get_size_wildcarded(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// State obtains the widget state this icon source applies to. The return value
// is only useful/meaningful if the widget state is not wildcarded.
func (s *IconSource) State() StateType {
	var _arg0 *C.GtkIconSource // out
	var _cret C.GtkStateType   // in

	_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_icon_source_get_state(_arg0)

	var _stateType StateType // out

	_stateType = StateType(_cret)

	return _stateType
}

// StateWildcarded gets the value set by gtk_icon_source_set_state_wildcarded().
func (s *IconSource) StateWildcarded() bool {
	var _arg0 *C.GtkIconSource // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_icon_source_get_state_wildcarded(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetDirection sets the text direction this icon source is intended to be used
// with.
//
// Setting the text direction on an icon source makes no difference if the text
// direction is wildcarded. Therefore, you should usually call
// gtk_icon_source_set_direction_wildcarded() to un-wildcard it in addition to
// calling this function.
func (s *IconSource) SetDirection(direction TextDirection) {
	var _arg0 *C.GtkIconSource   // out
	var _arg1 C.GtkTextDirection // out

	_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkTextDirection)(direction)

	C.gtk_icon_source_set_direction(_arg0, _arg1)
}

// SetDirectionWildcarded: if the text direction is wildcarded, this source can
// be used as the base image for an icon in any TextDirection. If the text
// direction is not wildcarded, then the text direction the icon source applies
// to should be set with gtk_icon_source_set_direction(), and the icon source
// will only be used with that text direction.
//
// IconSet prefers non-wildcarded sources (exact matches) over wildcarded
// sources, and will use an exact match when possible.
func (s *IconSource) SetDirectionWildcarded(setting bool) {
	var _arg0 *C.GtkIconSource // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_icon_source_set_direction_wildcarded(_arg0, _arg1)
}

// SetFilename sets the name of an image file to use as a base image when
// creating icon variants for IconSet. The filename must be absolute.
func (s *IconSource) SetFilename(filename string) {
	var _arg0 *C.GtkIconSource // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_icon_source_set_filename(_arg0, _arg1)
}

// SetIconName sets the name of an icon to look up in the current icon theme to
// use as a base image when creating icon variants for IconSet.
func (s *IconSource) SetIconName(iconName string) {
	var _arg0 *C.GtkIconSource // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_icon_source_set_icon_name(_arg0, _arg1)
}

// SetPixbuf sets a pixbuf to use as a base image when creating icon variants
// for IconSet.
func (s *IconSource) SetPixbuf(pixbuf gdkpixbuf.Pixbuf) {
	var _arg0 *C.GtkIconSource // out
	var _arg1 *C.GdkPixbuf     // out

	_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	C.gtk_icon_source_set_pixbuf(_arg0, _arg1)
}

// SetSize sets the icon size this icon source is intended to be used with.
//
// Setting the icon size on an icon source makes no difference if the size is
// wildcarded. Therefore, you should usually call
// gtk_icon_source_set_size_wildcarded() to un-wildcard it in addition to
// calling this function.
func (s *IconSource) SetSize(size int) {
	var _arg0 *C.GtkIconSource // out
	var _arg1 C.GtkIconSize    // out

	_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkIconSize)(size)

	C.gtk_icon_source_set_size(_arg0, _arg1)
}

// SetSizeWildcarded: if the icon size is wildcarded, this source can be used as
// the base image for an icon of any size. If the size is not wildcarded, then
// the size the source applies to should be set with gtk_icon_source_set_size()
// and the icon source will only be used with that specific size.
//
// IconSet prefers non-wildcarded sources (exact matches) over wildcarded
// sources, and will use an exact match when possible.
//
// IconSet will normally scale wildcarded source images to produce an
// appropriate icon at a given size, but will not change the size of source
// images that match exactly.
func (s *IconSource) SetSizeWildcarded(setting bool) {
	var _arg0 *C.GtkIconSource // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_icon_source_set_size_wildcarded(_arg0, _arg1)
}

// SetState sets the widget state this icon source is intended to be used with.
//
// Setting the widget state on an icon source makes no difference if the state
// is wildcarded. Therefore, you should usually call
// gtk_icon_source_set_state_wildcarded() to un-wildcard it in addition to
// calling this function.
func (s *IconSource) SetState(state StateType) {
	var _arg0 *C.GtkIconSource // out
	var _arg1 C.GtkStateType   // out

	_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkStateType)(state)

	C.gtk_icon_source_set_state(_arg0, _arg1)
}

// SetStateWildcarded: if the widget state is wildcarded, this source can be
// used as the base image for an icon in any StateType. If the widget state is
// not wildcarded, then the state the source applies to should be set with
// gtk_icon_source_set_state() and the icon source will only be used with that
// specific state.
//
// IconSet prefers non-wildcarded sources (exact matches) over wildcarded
// sources, and will use an exact match when possible.
//
// IconSet will normally transform wildcarded source images to produce an
// appropriate icon for a given state, for example lightening an image on
// prelight, but will not modify source images that match exactly.
func (s *IconSource) SetStateWildcarded(setting bool) {
	var _arg0 *C.GtkIconSource // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_icon_source_set_state_wildcarded(_arg0, _arg1)
}

type LabelSelectionInfo struct {
	native C.GtkLabelSelectionInfo
}

// WrapLabelSelectionInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapLabelSelectionInfo(ptr unsafe.Pointer) *LabelSelectionInfo {
	if ptr == nil {
		return nil
	}

	return (*LabelSelectionInfo)(ptr)
}

// Native returns the underlying C source pointer.
func (l *LabelSelectionInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&l.native)
}

// PadActionEntry: struct defining a pad action entry.
type PadActionEntry struct {
	native C.GtkPadActionEntry
}

// WrapPadActionEntry wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPadActionEntry(ptr unsafe.Pointer) *PadActionEntry {
	if ptr == nil {
		return nil
	}

	return (*PadActionEntry)(ptr)
}

// Native returns the underlying C source pointer.
func (p *PadActionEntry) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

// PageRange: see also gtk_print_settings_set_page_ranges().
type PageRange struct {
	native C.GtkPageRange
}

// WrapPageRange wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPageRange(ptr unsafe.Pointer) *PageRange {
	if ptr == nil {
		return nil
	}

	return (*PageRange)(ptr)
}

// Native returns the underlying C source pointer.
func (p *PageRange) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

// PaperSize: gtkPaperSize handles paper sizes. It uses the standard called PWG
// 5101.1-2002 PWG: Standard for Media Standardized Names
// (http://www.pwg.org/standards.html) to name the paper sizes (and to get the
// data for the page sizes). In addition to standard paper sizes, GtkPaperSize
// allows to construct custom paper sizes with arbitrary dimensions.
//
// The PaperSize object stores not only the dimensions (width and height) of a
// paper size and its name, it also provides default [print
// margins][print-margins].
//
// Printing support has been added in GTK+ 2.10.
type PaperSize struct {
	native C.GtkPaperSize
}

// WrapPaperSize wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPaperSize(ptr unsafe.Pointer) *PaperSize {
	if ptr == nil {
		return nil
	}

	return (*PaperSize)(ptr)
}

func marshalPaperSize(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapPaperSize(unsafe.Pointer(b)), nil
}

// NewPaperSize constructs a struct PaperSize.
func NewPaperSize(name string) *PaperSize {
	var _arg1 *C.gchar        // out
	var _cret *C.GtkPaperSize // in

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_paper_size_new(_arg1)

	var _paperSize *PaperSize // out

	_paperSize = WrapPaperSize(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_paperSize, func(v *PaperSize) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _paperSize
}

// NewPaperSizeCustom constructs a struct PaperSize.
func NewPaperSizeCustom(name string, displayName string, width float64, height float64, unit Unit) *PaperSize {
	var _arg1 *C.gchar        // out
	var _arg2 *C.gchar        // out
	var _arg3 C.gdouble       // out
	var _arg4 C.gdouble       // out
	var _arg5 C.GtkUnit       // out
	var _cret *C.GtkPaperSize // in

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(displayName))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.gdouble)(width)
	_arg4 = (C.gdouble)(height)
	_arg5 = (C.GtkUnit)(unit)

	_cret = C.gtk_paper_size_new_custom(_arg1, _arg2, _arg3, _arg4, _arg5)

	var _paperSize *PaperSize // out

	_paperSize = WrapPaperSize(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_paperSize, func(v *PaperSize) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _paperSize
}

// NewPaperSizeFromGVariant constructs a struct PaperSize.
func NewPaperSizeFromGVariant(variant *glib.Variant) *PaperSize {
	var _arg1 *C.GVariant     // out
	var _cret *C.GtkPaperSize // in

	_arg1 = (*C.GVariant)(unsafe.Pointer(variant.Native()))

	_cret = C.gtk_paper_size_new_from_gvariant(_arg1)

	var _paperSize *PaperSize // out

	_paperSize = WrapPaperSize(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_paperSize, func(v *PaperSize) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _paperSize
}

// NewPaperSizeFromIpp constructs a struct PaperSize.
func NewPaperSizeFromIpp(ippName string, width float64, height float64) *PaperSize {
	var _arg1 *C.gchar        // out
	var _arg2 C.gdouble       // out
	var _arg3 C.gdouble       // out
	var _cret *C.GtkPaperSize // in

	_arg1 = (*C.gchar)(C.CString(ippName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gdouble)(width)
	_arg3 = (C.gdouble)(height)

	_cret = C.gtk_paper_size_new_from_ipp(_arg1, _arg2, _arg3)

	var _paperSize *PaperSize // out

	_paperSize = WrapPaperSize(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_paperSize, func(v *PaperSize) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _paperSize
}

// NewPaperSizeFromKeyFile constructs a struct PaperSize.
func NewPaperSizeFromKeyFile(keyFile *glib.KeyFile, groupName string) (*PaperSize, error) {
	var _arg1 *C.GKeyFile     // out
	var _arg2 *C.gchar        // out
	var _cret *C.GtkPaperSize // in
	var _cerr *C.GError       // in

	_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
	_arg2 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_paper_size_new_from_key_file(_arg1, _arg2, &_cerr)

	var _paperSize *PaperSize // out
	var _goerr error          // out

	_paperSize = WrapPaperSize(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_paperSize, func(v *PaperSize) {
		C.free(unsafe.Pointer(v.Native()))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _paperSize, _goerr
}

// NewPaperSizeFromPpd constructs a struct PaperSize.
func NewPaperSizeFromPpd(ppdName string, ppdDisplayName string, width float64, height float64) *PaperSize {
	var _arg1 *C.gchar        // out
	var _arg2 *C.gchar        // out
	var _arg3 C.gdouble       // out
	var _arg4 C.gdouble       // out
	var _cret *C.GtkPaperSize // in

	_arg1 = (*C.gchar)(C.CString(ppdName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(ppdDisplayName))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.gdouble)(width)
	_arg4 = (C.gdouble)(height)

	_cret = C.gtk_paper_size_new_from_ppd(_arg1, _arg2, _arg3, _arg4)

	var _paperSize *PaperSize // out

	_paperSize = WrapPaperSize(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_paperSize, func(v *PaperSize) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _paperSize
}

// Native returns the underlying C source pointer.
func (p *PaperSize) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

// Copy copies an existing PaperSize.
func (o *PaperSize) Copy() *PaperSize {
	var _arg0 *C.GtkPaperSize // out
	var _cret *C.GtkPaperSize // in

	_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(o.Native()))

	_cret = C.gtk_paper_size_copy(_arg0)

	var _paperSize *PaperSize // out

	_paperSize = WrapPaperSize(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_paperSize, func(v *PaperSize) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _paperSize
}

// Free: free the given PaperSize object.
func (s *PaperSize) Free() {
	var _arg0 *C.GtkPaperSize // out

	_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))

	C.gtk_paper_size_free(_arg0)
}

// DefaultBottomMargin gets the default bottom margin for the PaperSize.
func (s *PaperSize) DefaultBottomMargin(unit Unit) float64 {
	var _arg0 *C.GtkPaperSize // out
	var _arg1 C.GtkUnit       // out
	var _cret C.gdouble       // in

	_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	_cret = C.gtk_paper_size_get_default_bottom_margin(_arg0, _arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// DefaultLeftMargin gets the default left margin for the PaperSize.
func (s *PaperSize) DefaultLeftMargin(unit Unit) float64 {
	var _arg0 *C.GtkPaperSize // out
	var _arg1 C.GtkUnit       // out
	var _cret C.gdouble       // in

	_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	_cret = C.gtk_paper_size_get_default_left_margin(_arg0, _arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// DefaultRightMargin gets the default right margin for the PaperSize.
func (s *PaperSize) DefaultRightMargin(unit Unit) float64 {
	var _arg0 *C.GtkPaperSize // out
	var _arg1 C.GtkUnit       // out
	var _cret C.gdouble       // in

	_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	_cret = C.gtk_paper_size_get_default_right_margin(_arg0, _arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// DefaultTopMargin gets the default top margin for the PaperSize.
func (s *PaperSize) DefaultTopMargin(unit Unit) float64 {
	var _arg0 *C.GtkPaperSize // out
	var _arg1 C.GtkUnit       // out
	var _cret C.gdouble       // in

	_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	_cret = C.gtk_paper_size_get_default_top_margin(_arg0, _arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// DisplayName gets the human-readable name of the PaperSize.
func (s *PaperSize) DisplayName() string {
	var _arg0 *C.GtkPaperSize // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_paper_size_get_display_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Height gets the paper height of the PaperSize, in units of @unit.
func (s *PaperSize) Height(unit Unit) float64 {
	var _arg0 *C.GtkPaperSize // out
	var _arg1 C.GtkUnit       // out
	var _cret C.gdouble       // in

	_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	_cret = C.gtk_paper_size_get_height(_arg0, _arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// Name gets the name of the PaperSize.
func (s *PaperSize) Name() string {
	var _arg0 *C.GtkPaperSize // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_paper_size_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// PpdName gets the PPD name of the PaperSize, which may be nil.
func (s *PaperSize) PpdName() string {
	var _arg0 *C.GtkPaperSize // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_paper_size_get_ppd_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Width gets the paper width of the PaperSize, in units of @unit.
func (s *PaperSize) Width(unit Unit) float64 {
	var _arg0 *C.GtkPaperSize // out
	var _arg1 C.GtkUnit       // out
	var _cret C.gdouble       // in

	_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	_cret = C.gtk_paper_size_get_width(_arg0, _arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// IsCustom returns true if @size is not a standard paper size.
func (s *PaperSize) IsCustom() bool {
	var _arg0 *C.GtkPaperSize // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_paper_size_is_custom(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsEqual compares two PaperSize objects.
func (s *PaperSize) IsEqual(size2 *PaperSize) bool {
	var _arg0 *C.GtkPaperSize // out
	var _arg1 *C.GtkPaperSize // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkPaperSize)(unsafe.Pointer(size2.Native()))

	_cret = C.gtk_paper_size_is_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsIpp returns true if @size is an IPP standard paper size.
func (s *PaperSize) IsIpp() bool {
	var _arg0 *C.GtkPaperSize // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_paper_size_is_ipp(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetSize changes the dimensions of a @size to @width x @height.
func (s *PaperSize) SetSize(width float64, height float64, unit Unit) {
	var _arg0 *C.GtkPaperSize // out
	var _arg1 C.gdouble       // out
	var _arg2 C.gdouble       // out
	var _arg3 C.GtkUnit       // out

	_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gdouble)(width)
	_arg2 = (C.gdouble)(height)
	_arg3 = (C.GtkUnit)(unit)

	C.gtk_paper_size_set_size(_arg0, _arg1, _arg2, _arg3)
}

// ToGVariant: serialize a paper size to an a{sv} variant.
func (p *PaperSize) ToGVariant() *glib.Variant {
	var _arg0 *C.GtkPaperSize // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_paper_size_to_gvariant(_arg0)

	var _variant *glib.Variant // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// ToKeyFile: this function adds the paper size from @size to @key_file.
func (s *PaperSize) ToKeyFile(keyFile *glib.KeyFile, groupName string) {
	var _arg0 *C.GtkPaperSize // out
	var _arg1 *C.GKeyFile     // out
	var _arg2 *C.gchar        // out

	_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
	_arg2 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_paper_size_to_key_file(_arg0, _arg1, _arg2)
}

// RadioActionEntry structs are used with gtk_action_group_add_radio_actions()
// to construct groups of radio actions.
type RadioActionEntry struct {
	native C.GtkRadioActionEntry
}

// WrapRadioActionEntry wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRadioActionEntry(ptr unsafe.Pointer) *RadioActionEntry {
	if ptr == nil {
		return nil
	}

	return (*RadioActionEntry)(ptr)
}

// Native returns the underlying C source pointer.
func (r *RadioActionEntry) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

type RCContext struct {
	native C.GtkRcContext
}

// WrapRCContext wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRCContext(ptr unsafe.Pointer) *RCContext {
	if ptr == nil {
		return nil
	}

	return (*RCContext)(ptr)
}

// Native returns the underlying C source pointer.
func (r *RCContext) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// RecentData: meta-data to be passed to gtk_recent_manager_add_full() when
// registering a recently used resource.
type RecentData struct {
	native C.GtkRecentData
}

// WrapRecentData wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRecentData(ptr unsafe.Pointer) *RecentData {
	if ptr == nil {
		return nil
	}

	return (*RecentData)(ptr)
}

// Native returns the underlying C source pointer.
func (r *RecentData) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// RecentFilterInfo: a GtkRecentFilterInfo struct is used to pass information
// about the tested file to gtk_recent_filter_filter().
type RecentFilterInfo struct {
	native C.GtkRecentFilterInfo
}

// WrapRecentFilterInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRecentFilterInfo(ptr unsafe.Pointer) *RecentFilterInfo {
	if ptr == nil {
		return nil
	}

	return (*RecentFilterInfo)(ptr)
}

// Native returns the underlying C source pointer.
func (r *RecentFilterInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// RecentInfo contains private data only, and should be accessed using the
// provided API.
//
// RecentInfo constains all the meta-data associated with an entry in the
// recently used files list.
type RecentInfo struct {
	native C.GtkRecentInfo
}

// WrapRecentInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRecentInfo(ptr unsafe.Pointer) *RecentInfo {
	if ptr == nil {
		return nil
	}

	return (*RecentInfo)(ptr)
}

func marshalRecentInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRecentInfo(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *RecentInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// CreateAppInfo creates a Info for the specified RecentInfo
func (i *RecentInfo) CreateAppInfo(appName string) (gio.AppInfo, error) {
	var _arg0 *C.GtkRecentInfo // out
	var _arg1 *C.gchar         // out
	var _cret *C.GAppInfo      // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(appName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_recent_info_create_app_info(_arg0, _arg1, &_cerr)

	var _appInfo gio.AppInfo // out
	var _goerr error         // out

	_appInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.AppInfo)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _appInfo, _goerr
}

// Exists checks whether the resource pointed by @info still exists. At the
// moment this check is done only on resources pointing to local files.
func (i *RecentInfo) Exists() bool {
	var _arg0 *C.GtkRecentInfo // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_recent_info_exists(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Added gets the timestamp (seconds from system’s Epoch) when the resource was
// added to the recently used resources list.
func (i *RecentInfo) Added() int32 {
	var _arg0 *C.GtkRecentInfo // out
	var _cret C.time_t         // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_recent_info_get_added(_arg0)

	var _glong int32 // out

	_glong = (int32)(_cret)

	return _glong
}

// Age gets the number of days elapsed since the last update of the resource
// pointed by @info.
func (i *RecentInfo) Age() int {
	var _arg0 *C.GtkRecentInfo // out
	var _cret C.gint           // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_recent_info_get_age(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// ApplicationInfo gets the data regarding the application that has registered
// the resource pointed by @info.
//
// If the command line contains any escape characters defined inside the storage
// specification, they will be expanded.
func (i *RecentInfo) ApplicationInfo(appName string) (string, uint, int32, bool) {
	var _arg0 *C.GtkRecentInfo // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // in
	var _arg3 C.guint          // in
	var _arg4 C.time_t         // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(appName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_recent_info_get_application_info(_arg0, _arg1, &_arg2, &_arg3, &_arg4)

	var _appExec string // out
	var _count uint     // out
	var _time_ int32    // out
	var _ok bool        // out

	_appExec = C.GoString(_arg2)
	_count = (uint)(_arg3)
	_time_ = (int32)(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _appExec, _count, _time_, _ok
}

// Description gets the (short) description of the resource.
func (i *RecentInfo) Description() string {
	var _arg0 *C.GtkRecentInfo // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_recent_info_get_description(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// DisplayName gets the name of the resource. If none has been defined, the
// basename of the resource is obtained.
func (i *RecentInfo) DisplayName() string {
	var _arg0 *C.GtkRecentInfo // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_recent_info_get_display_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// GIcon retrieves the icon associated to the resource MIME type.
func (i *RecentInfo) GIcon() gio.Icon {
	var _arg0 *C.GtkRecentInfo // out
	var _cret *C.GIcon         // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_recent_info_get_gicon(_arg0)

	var _icon gio.Icon // out

	_icon = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.Icon)

	return _icon
}

// Icon retrieves the icon of size @size associated to the resource MIME type.
func (i *RecentInfo) Icon(size int) gdkpixbuf.Pixbuf {
	var _arg0 *C.GtkRecentInfo // out
	var _arg1 C.gint           // out
	var _cret *C.GdkPixbuf     // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(size)

	_cret = C.gtk_recent_info_get_icon(_arg0, _arg1)

	var _pixbuf gdkpixbuf.Pixbuf // out

	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

	return _pixbuf
}

// MIMEType gets the MIME type of the resource.
func (i *RecentInfo) MIMEType() string {
	var _arg0 *C.GtkRecentInfo // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_recent_info_get_mime_type(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Modified gets the timestamp (seconds from system’s Epoch) when the meta-data
// for the resource was last modified.
func (i *RecentInfo) Modified() int32 {
	var _arg0 *C.GtkRecentInfo // out
	var _cret C.time_t         // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_recent_info_get_modified(_arg0)

	var _glong int32 // out

	_glong = (int32)(_cret)

	return _glong
}

// PrivateHint gets the value of the “private” flag. Resources in the recently
// used list that have this flag set to true should only be displayed by the
// applications that have registered them.
func (i *RecentInfo) PrivateHint() bool {
	var _arg0 *C.GtkRecentInfo // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_recent_info_get_private_hint(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShortName computes a valid UTF-8 string that can be used as the name of the
// item in a menu or list. For example, calling this function on an item that
// refers to “file:///foo/bar.txt” will yield “bar.txt”.
func (i *RecentInfo) ShortName() string {
	var _arg0 *C.GtkRecentInfo // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_recent_info_get_short_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// URI gets the URI of the resource.
func (i *RecentInfo) URI() string {
	var _arg0 *C.GtkRecentInfo // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_recent_info_get_uri(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// URIDisplay gets a displayable version of the resource’s URI. If the resource
// is local, it returns a local path; if the resource is not local, it returns
// the UTF-8 encoded content of gtk_recent_info_get_uri().
func (i *RecentInfo) URIDisplay() string {
	var _arg0 *C.GtkRecentInfo // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_recent_info_get_uri_display(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Visited gets the timestamp (seconds from system’s Epoch) when the meta-data
// for the resource was last visited.
func (i *RecentInfo) Visited() int32 {
	var _arg0 *C.GtkRecentInfo // out
	var _cret C.time_t         // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_recent_info_get_visited(_arg0)

	var _glong int32 // out

	_glong = (int32)(_cret)

	return _glong
}

// HasApplication checks whether an application registered this resource using
// @app_name.
func (i *RecentInfo) HasApplication(appName string) bool {
	var _arg0 *C.GtkRecentInfo // out
	var _arg1 *C.gchar         // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(appName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_recent_info_has_application(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasGroup checks whether @group_name appears inside the groups registered for
// the recently used item @info.
func (i *RecentInfo) HasGroup(groupName string) bool {
	var _arg0 *C.GtkRecentInfo // out
	var _arg1 *C.gchar         // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_recent_info_has_group(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsLocal checks whether the resource is local or not by looking at the scheme
// of its URI.
func (i *RecentInfo) IsLocal() bool {
	var _arg0 *C.GtkRecentInfo // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_recent_info_is_local(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LastApplication gets the name of the last application that have registered
// the recently used resource represented by @info.
func (i *RecentInfo) LastApplication() string {
	var _arg0 *C.GtkRecentInfo // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_recent_info_last_application(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Match checks whether two RecentInfo-struct point to the same resource.
func (i *RecentInfo) Match(infoB *RecentInfo) bool {
	var _arg0 *C.GtkRecentInfo // out
	var _arg1 *C.GtkRecentInfo // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkRecentInfo)(unsafe.Pointer(infoB.Native()))

	_cret = C.gtk_recent_info_match(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Ref increases the reference count of @recent_info by one.
func (i *RecentInfo) Ref() *RecentInfo {
	var _arg0 *C.GtkRecentInfo // out
	var _cret *C.GtkRecentInfo // in

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_recent_info_ref(_arg0)

	var _recentInfo *RecentInfo // out

	_recentInfo = WrapRecentInfo(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_recentInfo, func(v *RecentInfo) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _recentInfo
}

// Unref decreases the reference count of @info by one. If the reference count
// reaches zero, @info is deallocated, and the memory freed.
func (i *RecentInfo) Unref() {
	var _arg0 *C.GtkRecentInfo // out

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	C.gtk_recent_info_unref(_arg0)
}

// RequestedSize represents a request of a screen object in a given orientation.
// These are primarily used in container implementations when allocating a
// natural size for children calling. See gtk_distribute_natural_allocation().
type RequestedSize struct {
	native C.GtkRequestedSize
}

// WrapRequestedSize wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRequestedSize(ptr unsafe.Pointer) *RequestedSize {
	if ptr == nil {
		return nil
	}

	return (*RequestedSize)(ptr)
}

// Native returns the underlying C source pointer.
func (r *RequestedSize) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// Requisition: a Requisition-struct represents the desired size of a widget.
// See [GtkWidget’s geometry management section][geometry-management] for more
// information.
type Requisition struct {
	native C.GtkRequisition
}

// WrapRequisition wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRequisition(ptr unsafe.Pointer) *Requisition {
	if ptr == nil {
		return nil
	}

	return (*Requisition)(ptr)
}

func marshalRequisition(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRequisition(unsafe.Pointer(b)), nil
}

// NewRequisition constructs a struct Requisition.
func NewRequisition() *Requisition {
	var _cret *C.GtkRequisition // in

	_cret = C.gtk_requisition_new()

	var _requisition *Requisition // out

	_requisition = WrapRequisition(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_requisition, func(v *Requisition) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _requisition
}

// Native returns the underlying C source pointer.
func (r *Requisition) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// Copy copies a Requisition.
func (r *Requisition) Copy() *Requisition {
	var _arg0 *C.GtkRequisition // out
	var _cret *C.GtkRequisition // in

	_arg0 = (*C.GtkRequisition)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_requisition_copy(_arg0)

	var _ret *Requisition // out

	_ret = WrapRequisition(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_ret, func(v *Requisition) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _ret
}

// Free frees a Requisition.
func (r *Requisition) Free() {
	var _arg0 *C.GtkRequisition // out

	_arg0 = (*C.GtkRequisition)(unsafe.Pointer(r.Native()))

	C.gtk_requisition_free(_arg0)
}

type SelectionData struct {
	native C.GtkSelectionData
}

// WrapSelectionData wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSelectionData(ptr unsafe.Pointer) *SelectionData {
	if ptr == nil {
		return nil
	}

	return (*SelectionData)(ptr)
}

func marshalSelectionData(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSelectionData(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *SelectionData) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// Copy makes a copy of a SelectionData-struct and its data.
func (d *SelectionData) Copy() *SelectionData {
	var _arg0 *C.GtkSelectionData // out
	var _cret *C.GtkSelectionData // in

	_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(d.Native()))

	_cret = C.gtk_selection_data_copy(_arg0)

	var _selectionData *SelectionData // out

	_selectionData = WrapSelectionData(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_selectionData, func(v *SelectionData) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _selectionData
}

// Free frees a SelectionData-struct returned from gtk_selection_data_copy().
func (d *SelectionData) Free() {
	var _arg0 *C.GtkSelectionData // out

	_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(d.Native()))

	C.gtk_selection_data_free(_arg0)
}

// DataType retrieves the data type of the selection.
func (s *SelectionData) DataType() *gdk.Atom {
	var _arg0 *C.GtkSelectionData // out
	var _cret C.GdkAtom           // in

	_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_selection_data_get_data_type(_arg0)

	var _atom *gdk.Atom // out

	_atom = gdk.WrapAtom(unsafe.Pointer(_cret))

	return _atom
}

// Display retrieves the display of the selection.
func (s *SelectionData) Display() gdk.Display {
	var _arg0 *C.GtkSelectionData // out
	var _cret *C.GdkDisplay       // in

	_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_selection_data_get_display(_arg0)

	var _display gdk.Display // out

	_display = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Display)

	return _display
}

// Format retrieves the format of the selection.
func (s *SelectionData) Format() int {
	var _arg0 *C.GtkSelectionData // out
	var _cret C.gint              // in

	_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_selection_data_get_format(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Length retrieves the length of the raw data of the selection.
func (s *SelectionData) Length() int {
	var _arg0 *C.GtkSelectionData // out
	var _cret C.gint              // in

	_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_selection_data_get_length(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Pixbuf gets the contents of the selection data as a Pixbuf.
func (s *SelectionData) Pixbuf() gdkpixbuf.Pixbuf {
	var _arg0 *C.GtkSelectionData // out
	var _cret *C.GdkPixbuf        // in

	_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_selection_data_get_pixbuf(_arg0)

	var _pixbuf gdkpixbuf.Pixbuf // out

	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

	return _pixbuf
}

// Selection retrieves the selection Atom of the selection data.
func (s *SelectionData) Selection() *gdk.Atom {
	var _arg0 *C.GtkSelectionData // out
	var _cret C.GdkAtom           // in

	_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_selection_data_get_selection(_arg0)

	var _atom *gdk.Atom // out

	_atom = gdk.WrapAtom(unsafe.Pointer(_cret))

	return _atom
}

// Target retrieves the target of the selection.
func (s *SelectionData) Target() *gdk.Atom {
	var _arg0 *C.GtkSelectionData // out
	var _cret C.GdkAtom           // in

	_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_selection_data_get_target(_arg0)

	var _atom *gdk.Atom // out

	_atom = gdk.WrapAtom(unsafe.Pointer(_cret))

	return _atom
}

// Targets gets the contents of @selection_data as an array of targets. This can
// be used to interpret the results of getting the standard TARGETS target that
// is always supplied for any selection.
func (s *SelectionData) Targets() ([]gdk.Atom, bool) {
	var _arg0 *C.GtkSelectionData // out
	var _arg1 *C.GdkAtom
	var _arg2 C.gint     // in
	var _cret C.gboolean // in

	_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_selection_data_get_targets(_arg0, &_arg1, &_arg2)

	var _targets []gdk.Atom
	var _ok bool // out

	_targets = unsafe.Slice((*gdk.Atom)(unsafe.Pointer(_arg1)), _arg2)
	runtime.SetFinalizer(&_targets, func(v *[]gdk.Atom) {
		C.free(unsafe.Pointer(&(*v)[0]))
	})
	if _cret != 0 {
		_ok = true
	}

	return _targets, _ok
}

// Text gets the contents of the selection data as a UTF-8 string.
func (s *SelectionData) Text() string {
	var _arg0 *C.GtkSelectionData // out
	var _cret *C.guchar           // in

	_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_selection_data_get_text(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Uris gets the contents of the selection data as array of URIs.
func (s *SelectionData) Uris() []string {
	var _arg0 *C.GtkSelectionData // out
	var _cret **C.gchar

	_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_selection_data_get_uris(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// Set stores new data into a SelectionData object. Should only be called from a
// selection handler callback. Zero-terminates the stored data.
func (s *SelectionData) Set(typ *gdk.Atom, format int, data []byte) {
	var _arg0 *C.GtkSelectionData // out
	var _arg1 C.GdkAtom           // out
	var _arg2 C.gint              // out
	var _arg3 *C.guchar
	var _arg4 C.gint

	_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GdkAtom)(unsafe.Pointer(typ.Native()))
	_arg2 = (C.gint)(format)
	_arg4 = C.gint(len(data))
	_arg3 = (*C.guchar)(unsafe.Pointer(&data[0]))

	C.gtk_selection_data_set(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// SetPixbuf sets the contents of the selection from a Pixbuf The pixbuf is
// converted to the form determined by @selection_data->target.
func (s *SelectionData) SetPixbuf(pixbuf gdkpixbuf.Pixbuf) bool {
	var _arg0 *C.GtkSelectionData // out
	var _arg1 *C.GdkPixbuf        // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	_cret = C.gtk_selection_data_set_pixbuf(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetText sets the contents of the selection from a UTF-8 encoded string. The
// string is converted to the form determined by @selection_data->target.
func (s *SelectionData) SetText(str string, len int) bool {
	var _arg0 *C.GtkSelectionData // out
	var _arg1 *C.gchar            // out
	var _arg2 C.gint              // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gint)(len)

	_cret = C.gtk_selection_data_set_text(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetUris sets the contents of the selection from a list of URIs. The string is
// converted to the form determined by @selection_data->target.
func (s *SelectionData) SetUris(uris []string) bool {
	var _arg0 *C.GtkSelectionData // out
	var _arg1 **C.gchar
	var _cret C.gboolean // in

	_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))
	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(uris)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(uris))
		for i := range uris {
			out[i] = (*C.gchar)(C.CString(uris[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.gtk_selection_data_set_uris(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TargetsIncludeImage: given a SelectionData object holding a list of targets,
// determines if any of the targets in @targets can be used to provide a Pixbuf.
func (s *SelectionData) TargetsIncludeImage(writable bool) bool {
	var _arg0 *C.GtkSelectionData // out
	var _arg1 C.gboolean          // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))
	if writable {
		_arg1 = C.TRUE
	}

	_cret = C.gtk_selection_data_targets_include_image(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TargetsIncludeRichText: given a SelectionData object holding a list of
// targets, determines if any of the targets in @targets can be used to provide
// rich text.
func (s *SelectionData) TargetsIncludeRichText(buffer TextBuffer) bool {
	var _arg0 *C.GtkSelectionData // out
	var _arg1 *C.GtkTextBuffer    // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_selection_data_targets_include_rich_text(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TargetsIncludeText: given a SelectionData object holding a list of targets,
// determines if any of the targets in @targets can be used to provide text.
func (s *SelectionData) TargetsIncludeText() bool {
	var _arg0 *C.GtkSelectionData // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_selection_data_targets_include_text(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TargetsIncludeURI: given a SelectionData object holding a list of targets,
// determines if any of the targets in @targets can be used to provide a list or
// URIs.
func (s *SelectionData) TargetsIncludeURI() bool {
	var _arg0 *C.GtkSelectionData // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_selection_data_targets_include_uri(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

type StockItem struct {
	native C.GtkStockItem
}

// WrapStockItem wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapStockItem(ptr unsafe.Pointer) *StockItem {
	if ptr == nil {
		return nil
	}

	return (*StockItem)(ptr)
}

// Native returns the underlying C source pointer.
func (s *StockItem) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// Free frees a stock item allocated on the heap, such as one returned by
// gtk_stock_item_copy(). Also frees the fields inside the stock item, if they
// are not nil.
func (i *StockItem) Free() {
	var _arg0 *C.GtkStockItem // out

	_arg0 = (*C.GtkStockItem)(unsafe.Pointer(i.Native()))

	C.gtk_stock_item_free(_arg0)
}

// SymbolicColor: gtkSymbolicColor is a boxed type that represents a symbolic
// color. It is the result of parsing a [color
// expression][gtkcssprovider-symbolic-colors]. To obtain the color represented
// by a GtkSymbolicColor, it has to be resolved with
// gtk_symbolic_color_resolve(), which replaces all symbolic color references by
// the colors they refer to (in a given context) and evaluates mix, shade and
// other expressions, resulting in a RGBA value.
//
// It is not normally necessary to deal directly with SymbolicColors, since they
// are mostly used behind the scenes by StyleContext and CssProvider.
//
// SymbolicColor is deprecated. Symbolic colors are considered an implementation
// detail of GTK+.
type SymbolicColor struct {
	native C.GtkSymbolicColor
}

// WrapSymbolicColor wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSymbolicColor(ptr unsafe.Pointer) *SymbolicColor {
	if ptr == nil {
		return nil
	}

	return (*SymbolicColor)(ptr)
}

func marshalSymbolicColor(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSymbolicColor(unsafe.Pointer(b)), nil
}

// NewSymbolicColorAlpha constructs a struct SymbolicColor.
func NewSymbolicColorAlpha(color *SymbolicColor, factor float64) *SymbolicColor {
	var _arg1 *C.GtkSymbolicColor // out
	var _arg2 C.gdouble           // out
	var _cret *C.GtkSymbolicColor // in

	_arg1 = (*C.GtkSymbolicColor)(unsafe.Pointer(color.Native()))
	_arg2 = (C.gdouble)(factor)

	_cret = C.gtk_symbolic_color_new_alpha(_arg1, _arg2)

	var _symbolicColor *SymbolicColor // out

	_symbolicColor = WrapSymbolicColor(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_symbolicColor, func(v *SymbolicColor) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _symbolicColor
}

// NewSymbolicColorLiteral constructs a struct SymbolicColor.
func NewSymbolicColorLiteral(color *gdk.RGBA) *SymbolicColor {
	var _arg1 *C.GdkRGBA          // out
	var _cret *C.GtkSymbolicColor // in

	_arg1 = (*C.GdkRGBA)(unsafe.Pointer(color.Native()))

	_cret = C.gtk_symbolic_color_new_literal(_arg1)

	var _symbolicColor *SymbolicColor // out

	_symbolicColor = WrapSymbolicColor(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_symbolicColor, func(v *SymbolicColor) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _symbolicColor
}

// NewSymbolicColorMix constructs a struct SymbolicColor.
func NewSymbolicColorMix(color1 *SymbolicColor, color2 *SymbolicColor, factor float64) *SymbolicColor {
	var _arg1 *C.GtkSymbolicColor // out
	var _arg2 *C.GtkSymbolicColor // out
	var _arg3 C.gdouble           // out
	var _cret *C.GtkSymbolicColor // in

	_arg1 = (*C.GtkSymbolicColor)(unsafe.Pointer(color1.Native()))
	_arg2 = (*C.GtkSymbolicColor)(unsafe.Pointer(color2.Native()))
	_arg3 = (C.gdouble)(factor)

	_cret = C.gtk_symbolic_color_new_mix(_arg1, _arg2, _arg3)

	var _symbolicColor *SymbolicColor // out

	_symbolicColor = WrapSymbolicColor(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_symbolicColor, func(v *SymbolicColor) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _symbolicColor
}

// NewSymbolicColorName constructs a struct SymbolicColor.
func NewSymbolicColorName(name string) *SymbolicColor {
	var _arg1 *C.gchar            // out
	var _cret *C.GtkSymbolicColor // in

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_symbolic_color_new_name(_arg1)

	var _symbolicColor *SymbolicColor // out

	_symbolicColor = WrapSymbolicColor(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_symbolicColor, func(v *SymbolicColor) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _symbolicColor
}

// NewSymbolicColorShade constructs a struct SymbolicColor.
func NewSymbolicColorShade(color *SymbolicColor, factor float64) *SymbolicColor {
	var _arg1 *C.GtkSymbolicColor // out
	var _arg2 C.gdouble           // out
	var _cret *C.GtkSymbolicColor // in

	_arg1 = (*C.GtkSymbolicColor)(unsafe.Pointer(color.Native()))
	_arg2 = (C.gdouble)(factor)

	_cret = C.gtk_symbolic_color_new_shade(_arg1, _arg2)

	var _symbolicColor *SymbolicColor // out

	_symbolicColor = WrapSymbolicColor(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_symbolicColor, func(v *SymbolicColor) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _symbolicColor
}

// NewSymbolicColorWin32 constructs a struct SymbolicColor.
func NewSymbolicColorWin32(themeClass string, id int) *SymbolicColor {
	var _arg1 *C.gchar            // out
	var _arg2 C.gint              // out
	var _cret *C.GtkSymbolicColor // in

	_arg1 = (*C.gchar)(C.CString(themeClass))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gint)(id)

	_cret = C.gtk_symbolic_color_new_win32(_arg1, _arg2)

	var _symbolicColor *SymbolicColor // out

	_symbolicColor = WrapSymbolicColor(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_symbolicColor, func(v *SymbolicColor) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _symbolicColor
}

// Native returns the underlying C source pointer.
func (s *SymbolicColor) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// Ref increases the reference count of @color
func (c *SymbolicColor) Ref() *SymbolicColor {
	var _arg0 *C.GtkSymbolicColor // out
	var _cret *C.GtkSymbolicColor // in

	_arg0 = (*C.GtkSymbolicColor)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_symbolic_color_ref(_arg0)

	var _symbolicColor *SymbolicColor // out

	_symbolicColor = WrapSymbolicColor(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_symbolicColor, func(v *SymbolicColor) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _symbolicColor
}

// Resolve: if @color is resolvable, @resolved_color will be filled in with the
// resolved color, and true will be returned. Generally, if @color can’t be
// resolved, it is due to it being defined on top of a named color that doesn’t
// exist in @props.
//
// When @props is nil, resolving of named colors will fail, so if your @color is
// or references such a color, this function will return false.
func (c *SymbolicColor) Resolve(props StyleProperties) (gdk.RGBA, bool) {
	var _arg0 *C.GtkSymbolicColor   // out
	var _arg1 *C.GtkStyleProperties // out
	var _resolvedColor gdk.RGBA
	var _cret C.gboolean // in

	_arg0 = (*C.GtkSymbolicColor)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkStyleProperties)(unsafe.Pointer(props.Native()))

	_cret = C.gtk_symbolic_color_resolve(_arg0, _arg1, (*C.GdkRGBA)(unsafe.Pointer(&_resolvedColor)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _resolvedColor, _ok
}

// String converts the given @color to a string representation. This is useful
// both for debugging and for serialization of strings. The format of the string
// may change between different versions of GTK, but it is guaranteed that the
// GTK css parser is able to read the string and create the same symbolic color
// from it.
func (c *SymbolicColor) String() string {
	var _arg0 *C.GtkSymbolicColor // out
	var _cret *C.char             // in

	_arg0 = (*C.GtkSymbolicColor)(unsafe.Pointer(c.Native()))

	_cret = C.gtk_symbolic_color_to_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Unref decreases the reference count of @color, freeing its memory if the
// reference count reaches 0.
func (c *SymbolicColor) Unref() {
	var _arg0 *C.GtkSymbolicColor // out

	_arg0 = (*C.GtkSymbolicColor)(unsafe.Pointer(c.Native()))

	C.gtk_symbolic_color_unref(_arg0)
}

type TableChild struct {
	native C.GtkTableChild
}

// WrapTableChild wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTableChild(ptr unsafe.Pointer) *TableChild {
	if ptr == nil {
		return nil
	}

	return (*TableChild)(ptr)
}

// Native returns the underlying C source pointer.
func (t *TableChild) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

type TableRowCol struct {
	native C.GtkTableRowCol
}

// WrapTableRowCol wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTableRowCol(ptr unsafe.Pointer) *TableRowCol {
	if ptr == nil {
		return nil
	}

	return (*TableRowCol)(ptr)
}

// Native returns the underlying C source pointer.
func (t *TableRowCol) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// TargetEntry: a TargetEntry represents a single type of data than can be
// supplied for by a widget for a selection or for supplied or received during
// drag-and-drop.
type TargetEntry struct {
	native C.GtkTargetEntry
}

// WrapTargetEntry wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTargetEntry(ptr unsafe.Pointer) *TargetEntry {
	if ptr == nil {
		return nil
	}

	return (*TargetEntry)(ptr)
}

func marshalTargetEntry(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTargetEntry(unsafe.Pointer(b)), nil
}

// NewTargetEntry constructs a struct TargetEntry.
func NewTargetEntry(target string, flags uint, info uint) *TargetEntry {
	var _arg1 *C.gchar          // out
	var _arg2 C.guint           // out
	var _arg3 C.guint           // out
	var _cret *C.GtkTargetEntry // in

	_arg1 = (*C.gchar)(C.CString(target))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.guint)(flags)
	_arg3 = (C.guint)(info)

	_cret = C.gtk_target_entry_new(_arg1, _arg2, _arg3)

	var _targetEntry *TargetEntry // out

	_targetEntry = WrapTargetEntry(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_targetEntry, func(v *TargetEntry) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _targetEntry
}

// Native returns the underlying C source pointer.
func (t *TargetEntry) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// Copy makes a copy of a TargetEntry and its data.
func (d *TargetEntry) Copy() *TargetEntry {
	var _arg0 *C.GtkTargetEntry // out
	var _cret *C.GtkTargetEntry // in

	_arg0 = (*C.GtkTargetEntry)(unsafe.Pointer(d.Native()))

	_cret = C.gtk_target_entry_copy(_arg0)

	var _targetEntry *TargetEntry // out

	_targetEntry = WrapTargetEntry(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_targetEntry, func(v *TargetEntry) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _targetEntry
}

// Free frees a TargetEntry returned from gtk_target_entry_new() or
// gtk_target_entry_copy().
func (d *TargetEntry) Free() {
	var _arg0 *C.GtkTargetEntry // out

	_arg0 = (*C.GtkTargetEntry)(unsafe.Pointer(d.Native()))

	C.gtk_target_entry_free(_arg0)
}

// TargetList: a TargetList-struct is a reference counted list of TargetPair and
// should be treated as opaque.
type TargetList struct {
	native C.GtkTargetList
}

// WrapTargetList wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTargetList(ptr unsafe.Pointer) *TargetList {
	if ptr == nil {
		return nil
	}

	return (*TargetList)(ptr)
}

func marshalTargetList(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTargetList(unsafe.Pointer(b)), nil
}

// NewTargetList constructs a struct TargetList.
func NewTargetList(targets []TargetEntry) *TargetList {
	var _arg1 *C.GtkTargetEntry
	var _arg2 C.guint
	var _cret *C.GtkTargetList // in

	_arg2 = C.guint(len(targets))
	_arg1 = (*C.GtkTargetEntry)(unsafe.Pointer(&targets[0]))

	_cret = C.gtk_target_list_new(_arg1, _arg2)

	var _targetList *TargetList // out

	_targetList = WrapTargetList(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_targetList, func(v *TargetList) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _targetList
}

// Native returns the underlying C source pointer.
func (t *TargetList) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// Add appends another target to a TargetList.
func (l *TargetList) Add(target *gdk.Atom, flags uint, info uint) {
	var _arg0 *C.GtkTargetList // out
	var _arg1 C.GdkAtom        // out
	var _arg2 C.guint          // out
	var _arg3 C.guint          // out

	_arg0 = (*C.GtkTargetList)(unsafe.Pointer(l.Native()))
	_arg1 = (C.GdkAtom)(unsafe.Pointer(target.Native()))
	_arg2 = (C.guint)(flags)
	_arg3 = (C.guint)(info)

	C.gtk_target_list_add(_arg0, _arg1, _arg2, _arg3)
}

// AddImageTargets appends the image targets supported by SelectionData to the
// target list. All targets are added with the same @info.
func (l *TargetList) AddImageTargets(info uint, writable bool) {
	var _arg0 *C.GtkTargetList // out
	var _arg1 C.guint          // out
	var _arg2 C.gboolean       // out

	_arg0 = (*C.GtkTargetList)(unsafe.Pointer(l.Native()))
	_arg1 = (C.guint)(info)
	if writable {
		_arg2 = C.TRUE
	}

	C.gtk_target_list_add_image_targets(_arg0, _arg1, _arg2)
}

// AddRichTextTargets appends the rich text targets registered with
// gtk_text_buffer_register_serialize_format() or
// gtk_text_buffer_register_deserialize_format() to the target list. All targets
// are added with the same @info.
func (l *TargetList) AddRichTextTargets(info uint, deserializable bool, buffer TextBuffer) {
	var _arg0 *C.GtkTargetList // out
	var _arg1 C.guint          // out
	var _arg2 C.gboolean       // out
	var _arg3 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTargetList)(unsafe.Pointer(l.Native()))
	_arg1 = (C.guint)(info)
	if deserializable {
		_arg2 = C.TRUE
	}
	_arg3 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	C.gtk_target_list_add_rich_text_targets(_arg0, _arg1, _arg2, _arg3)
}

// AddTable prepends a table of TargetEntry to a target list.
func (l *TargetList) AddTable(targets []TargetEntry) {
	var _arg0 *C.GtkTargetList // out
	var _arg1 *C.GtkTargetEntry
	var _arg2 C.guint

	_arg0 = (*C.GtkTargetList)(unsafe.Pointer(l.Native()))
	_arg2 = C.guint(len(targets))
	_arg1 = (*C.GtkTargetEntry)(unsafe.Pointer(&targets[0]))

	C.gtk_target_list_add_table(_arg0, _arg1, _arg2)
}

// AddTextTargets appends the text targets supported by SelectionData to the
// target list. All targets are added with the same @info.
func (l *TargetList) AddTextTargets(info uint) {
	var _arg0 *C.GtkTargetList // out
	var _arg1 C.guint          // out

	_arg0 = (*C.GtkTargetList)(unsafe.Pointer(l.Native()))
	_arg1 = (C.guint)(info)

	C.gtk_target_list_add_text_targets(_arg0, _arg1)
}

// AddURITargets appends the URI targets supported by SelectionData to the
// target list. All targets are added with the same @info.
func (l *TargetList) AddURITargets(info uint) {
	var _arg0 *C.GtkTargetList // out
	var _arg1 C.guint          // out

	_arg0 = (*C.GtkTargetList)(unsafe.Pointer(l.Native()))
	_arg1 = (C.guint)(info)

	C.gtk_target_list_add_uri_targets(_arg0, _arg1)
}

// Find looks up a given target in a TargetList.
func (l *TargetList) Find(target *gdk.Atom) (uint, bool) {
	var _arg0 *C.GtkTargetList // out
	var _arg1 C.GdkAtom        // out
	var _arg2 C.guint          // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTargetList)(unsafe.Pointer(l.Native()))
	_arg1 = (C.GdkAtom)(unsafe.Pointer(target.Native()))

	_cret = C.gtk_target_list_find(_arg0, _arg1, &_arg2)

	var _info uint // out
	var _ok bool   // out

	_info = (uint)(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _info, _ok
}

// Ref increases the reference count of a TargetList by one.
func (l *TargetList) Ref() *TargetList {
	var _arg0 *C.GtkTargetList // out
	var _cret *C.GtkTargetList // in

	_arg0 = (*C.GtkTargetList)(unsafe.Pointer(l.Native()))

	_cret = C.gtk_target_list_ref(_arg0)

	var _targetList *TargetList // out

	_targetList = WrapTargetList(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_targetList, func(v *TargetList) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _targetList
}

// Remove removes a target from a target list.
func (l *TargetList) Remove(target *gdk.Atom) {
	var _arg0 *C.GtkTargetList // out
	var _arg1 C.GdkAtom        // out

	_arg0 = (*C.GtkTargetList)(unsafe.Pointer(l.Native()))
	_arg1 = (C.GdkAtom)(unsafe.Pointer(target.Native()))

	C.gtk_target_list_remove(_arg0, _arg1)
}

// Unref decreases the reference count of a TargetList by one. If the resulting
// reference count is zero, frees the list.
func (l *TargetList) Unref() {
	var _arg0 *C.GtkTargetList // out

	_arg0 = (*C.GtkTargetList)(unsafe.Pointer(l.Native()))

	C.gtk_target_list_unref(_arg0)
}

// TargetPair: a TargetPair is used to represent the same information as a table
// of TargetEntry, but in an efficient form.
type TargetPair struct {
	native C.GtkTargetPair
}

// WrapTargetPair wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTargetPair(ptr unsafe.Pointer) *TargetPair {
	if ptr == nil {
		return nil
	}

	return (*TargetPair)(ptr)
}

// Native returns the underlying C source pointer.
func (t *TargetPair) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

type TextAppearance struct {
	native C.GtkTextAppearance
}

// WrapTextAppearance wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTextAppearance(ptr unsafe.Pointer) *TextAppearance {
	if ptr == nil {
		return nil
	}

	return (*TextAppearance)(ptr)
}

// Native returns the underlying C source pointer.
func (t *TextAppearance) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// TextAttributes: using TextAttributes directly should rarely be necessary.
// It’s primarily useful with gtk_text_iter_get_attributes(). As with most GTK+
// structs, the fields in this struct should only be read, never modified
// directly.
type TextAttributes struct {
	native C.GtkTextAttributes
}

// WrapTextAttributes wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTextAttributes(ptr unsafe.Pointer) *TextAttributes {
	if ptr == nil {
		return nil
	}

	return (*TextAttributes)(ptr)
}

func marshalTextAttributes(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTextAttributes(unsafe.Pointer(b)), nil
}

// NewTextAttributes constructs a struct TextAttributes.
func NewTextAttributes() *TextAttributes {
	var _cret *C.GtkTextAttributes // in

	_cret = C.gtk_text_attributes_new()

	var _textAttributes *TextAttributes // out

	_textAttributes = WrapTextAttributes(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_textAttributes, func(v *TextAttributes) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _textAttributes
}

// Native returns the underlying C source pointer.
func (t *TextAttributes) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// Copy copies @src and returns a new TextAttributes.
func (s *TextAttributes) Copy() *TextAttributes {
	var _arg0 *C.GtkTextAttributes // out
	var _cret *C.GtkTextAttributes // in

	_arg0 = (*C.GtkTextAttributes)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_text_attributes_copy(_arg0)

	var _textAttributes *TextAttributes // out

	_textAttributes = WrapTextAttributes(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_textAttributes, func(v *TextAttributes) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _textAttributes
}

// CopyValues copies the values from @src to @dest so that @dest has the same
// values as @src. Frees existing values in @dest.
func (s *TextAttributes) CopyValues(dest *TextAttributes) {
	var _arg0 *C.GtkTextAttributes // out
	var _arg1 *C.GtkTextAttributes // out

	_arg0 = (*C.GtkTextAttributes)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTextAttributes)(unsafe.Pointer(dest.Native()))

	C.gtk_text_attributes_copy_values(_arg0, _arg1)
}

// Ref increments the reference count on @values.
func (v *TextAttributes) Ref() *TextAttributes {
	var _arg0 *C.GtkTextAttributes // out
	var _cret *C.GtkTextAttributes // in

	_arg0 = (*C.GtkTextAttributes)(unsafe.Pointer(v.Native()))

	_cret = C.gtk_text_attributes_ref(_arg0)

	var _textAttributes *TextAttributes // out

	_textAttributes = WrapTextAttributes(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_textAttributes, func(v *TextAttributes) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _textAttributes
}

// Unref decrements the reference count on @values, freeing the structure if the
// reference count reaches 0.
func (v *TextAttributes) Unref() {
	var _arg0 *C.GtkTextAttributes // out

	_arg0 = (*C.GtkTextAttributes)(unsafe.Pointer(v.Native()))

	C.gtk_text_attributes_unref(_arg0)
}

type TextBTree struct {
	native C.GtkTextBTree
}

// WrapTextBTree wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTextBTree(ptr unsafe.Pointer) *TextBTree {
	if ptr == nil {
		return nil
	}

	return (*TextBTree)(ptr)
}

// Native returns the underlying C source pointer.
func (t *TextBTree) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// TextIter: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
type TextIter struct {
	native C.GtkTextIter
}

// WrapTextIter wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTextIter(ptr unsafe.Pointer) *TextIter {
	if ptr == nil {
		return nil
	}

	return (*TextIter)(ptr)
}

func marshalTextIter(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTextIter(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TextIter) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// Assign assigns the value of @other to @iter. This function is not useful in
// applications, because iterators can be assigned with `GtkTextIter i = j;`.
// The function is used by language bindings.
func (i *TextIter) Assign(other *TextIter) {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextIter // out

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(other.Native()))

	C.gtk_text_iter_assign(_arg0, _arg1)
}

// BackwardChar moves backward by one character offset. Returns true if movement
// was possible; if @iter was the first in the buffer (character offset 0),
// gtk_text_iter_backward_char() returns false for convenience when writing
// loops.
func (i *TextIter) BackwardChar() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_backward_char(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardChars moves @count characters backward, if possible (if @count would
// move past the start or end of the buffer, moves to the start or end of the
// buffer). The return value indicates whether the iterator moved onto a
// dereferenceable position; if the iterator didn’t move, or moved onto the end
// iterator, then false is returned. If @count is 0, the function does nothing
// and returns false.
func (i *TextIter) BackwardChars(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.gint         // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(count)

	_cret = C.gtk_text_iter_backward_chars(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardCursorPosition: like gtk_text_iter_forward_cursor_position(), but
// moves backward.
func (i *TextIter) BackwardCursorPosition() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_backward_cursor_position(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardCursorPositions moves up to @count cursor positions. See
// gtk_text_iter_forward_cursor_position() for details.
func (i *TextIter) BackwardCursorPositions(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.gint         // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(count)

	_cret = C.gtk_text_iter_backward_cursor_positions(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardLine moves @iter to the start of the previous line. Returns true if
// @iter could be moved; i.e. if @iter was at character offset 0, this function
// returns false. Therefore if @iter was already on line 0, but not at the start
// of the line, @iter is snapped to the start of the line and the function
// returns true. (Note that this implies that in a loop calling this function,
// the line number may not change on every iteration, if your first iteration is
// on line 0.)
func (i *TextIter) BackwardLine() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_backward_line(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardLines moves @count lines backward, if possible (if @count would move
// past the start or end of the buffer, moves to the start or end of the
// buffer). The return value indicates whether the iterator moved onto a
// dereferenceable position; if the iterator didn’t move, or moved onto the end
// iterator, then false is returned. If @count is 0, the function does nothing
// and returns false. If @count is negative, moves forward by 0 - @count lines.
func (i *TextIter) BackwardLines(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.gint         // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(count)

	_cret = C.gtk_text_iter_backward_lines(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardSearch: same as gtk_text_iter_forward_search(), but moves backward.
//
// @match_end will never be set to a TextIter located after @iter, even if there
// is a possible @match_start before or at @iter.
func (i *TextIter) BackwardSearch(str string, flags TextSearchFlags, limit *TextIter) (matchStart TextIter, matchEnd TextIter, ok bool) {
	var _arg0 *C.GtkTextIter       // out
	var _arg1 *C.gchar             // out
	var _arg2 C.GtkTextSearchFlags // out
	var _matchStart TextIter
	var _matchEnd TextIter
	var _arg5 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GtkTextSearchFlags)(flags)
	_arg5 = (*C.GtkTextIter)(unsafe.Pointer(limit.Native()))

	_cret = C.gtk_text_iter_backward_search(_arg0, _arg1, _arg2, (*C.GtkTextIter)(unsafe.Pointer(&_matchStart)), (*C.GtkTextIter)(unsafe.Pointer(&_matchEnd)), _arg5)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _matchStart, _matchEnd, _ok
}

// BackwardSentenceStart moves backward to the previous sentence start; if @iter
// is already at the start of a sentence, moves backward to the next one.
// Sentence boundaries are determined by Pango and should be correct for nearly
// any language (if not, the correct fix would be to the Pango text boundary
// algorithms).
func (i *TextIter) BackwardSentenceStart() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_backward_sentence_start(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardSentenceStarts calls gtk_text_iter_backward_sentence_start() up to
// @count times, or until it returns false. If @count is negative, moves forward
// instead of backward.
func (i *TextIter) BackwardSentenceStarts(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.gint         // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(count)

	_cret = C.gtk_text_iter_backward_sentence_starts(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardToTagToggle moves backward to the next toggle (on or off) of the
// TextTag @tag, or to the next toggle of any tag if @tag is nil. If no matching
// tag toggles are found, returns false, otherwise true. Does not return toggles
// located at @iter, only toggles before @iter. Sets @iter to the location of
// the toggle, or the start of the buffer if no toggle is found.
func (i *TextIter) BackwardToTagToggle(tag TextTag) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextTag  // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	_cret = C.gtk_text_iter_backward_to_tag_toggle(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardVisibleCursorPosition moves @iter forward to the previous visible
// cursor position. See gtk_text_iter_backward_cursor_position() for details.
func (i *TextIter) BackwardVisibleCursorPosition() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_backward_visible_cursor_position(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardVisibleCursorPositions moves up to @count visible cursor positions.
// See gtk_text_iter_backward_cursor_position() for details.
func (i *TextIter) BackwardVisibleCursorPositions(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.gint         // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(count)

	_cret = C.gtk_text_iter_backward_visible_cursor_positions(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardVisibleLine moves @iter to the start of the previous visible line.
// Returns true if @iter could be moved; i.e. if @iter was at character offset
// 0, this function returns false. Therefore if @iter was already on line 0, but
// not at the start of the line, @iter is snapped to the start of the line and
// the function returns true. (Note that this implies that in a loop calling
// this function, the line number may not change on every iteration, if your
// first iteration is on line 0.)
func (i *TextIter) BackwardVisibleLine() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_backward_visible_line(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardVisibleLines moves @count visible lines backward, if possible (if
// @count would move past the start or end of the buffer, moves to the start or
// end of the buffer). The return value indicates whether the iterator moved
// onto a dereferenceable position; if the iterator didn’t move, or moved onto
// the end iterator, then false is returned. If @count is 0, the function does
// nothing and returns false. If @count is negative, moves forward by 0 - @count
// lines.
func (i *TextIter) BackwardVisibleLines(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.gint         // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(count)

	_cret = C.gtk_text_iter_backward_visible_lines(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardVisibleWordStart moves backward to the previous visible word start.
// (If @iter is currently on a word start, moves backward to the next one after
// that.) Word breaks are determined by Pango and should be correct for nearly
// any language (if not, the correct fix would be to the Pango word break
// algorithms).
func (i *TextIter) BackwardVisibleWordStart() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_backward_visible_word_start(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardVisibleWordStarts calls gtk_text_iter_backward_visible_word_start()
// up to @count times.
func (i *TextIter) BackwardVisibleWordStarts(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.gint         // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(count)

	_cret = C.gtk_text_iter_backward_visible_word_starts(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardWordStart moves backward to the previous word start. (If @iter is
// currently on a word start, moves backward to the next one after that.) Word
// breaks are determined by Pango and should be correct for nearly any language
// (if not, the correct fix would be to the Pango word break algorithms).
func (i *TextIter) BackwardWordStart() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_backward_word_start(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardWordStarts calls gtk_text_iter_backward_word_start() up to @count
// times.
func (i *TextIter) BackwardWordStarts(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.gint         // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(count)

	_cret = C.gtk_text_iter_backward_word_starts(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BeginsTag returns true if @tag is toggled on at exactly this point. If @tag
// is nil, returns true if any tag is toggled on at this point.
//
// Note that if gtk_text_iter_begins_tag() returns true, it means that @iter is
// at the beginning of the tagged range, and that the character at @iter is
// inside the tagged range. In other words, unlike gtk_text_iter_ends_tag(), if
// gtk_text_iter_begins_tag() returns true, gtk_text_iter_has_tag() will also
// return true for the same parameters.
func (i *TextIter) BeginsTag(tag TextTag) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextTag  // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	_cret = C.gtk_text_iter_begins_tag(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanInsert: considering the default editability of the buffer, and tags that
// affect editability, determines whether text inserted at @iter would be
// editable. If text inserted at @iter would be editable then the user should be
// allowed to insert text at @iter. gtk_text_buffer_insert_interactive() uses
// this function to decide whether insertions are allowed at a given position.
func (i *TextIter) CanInsert(defaultEditability bool) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.gboolean     // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	if defaultEditability {
		_arg1 = C.TRUE
	}

	_cret = C.gtk_text_iter_can_insert(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Compare: a qsort()-style function that returns negative if @lhs is less than
// @rhs, positive if @lhs is greater than @rhs, and 0 if they’re equal. Ordering
// is in character offset order, i.e. the first character in the buffer is less
// than the second character in the buffer.
func (l *TextIter) Compare(rhs *TextIter) int {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(rhs.Native()))

	_cret = C.gtk_text_iter_compare(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Copy creates a dynamically-allocated copy of an iterator. This function is
// not useful in applications, because iterators can be copied with a simple
// assignment (`GtkTextIter i = j;`). The function is used by language bindings.
func (i *TextIter) Copy() *TextIter {
	var _arg0 *C.GtkTextIter // out
	var _cret *C.GtkTextIter // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_copy(_arg0)

	var _textIter *TextIter // out

	_textIter = WrapTextIter(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_textIter, func(v *TextIter) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _textIter
}

// Editable returns whether the character at @iter is within an editable region
// of text. Non-editable text is “locked” and can’t be changed by the user via
// TextView. This function is simply a convenience wrapper around
// gtk_text_iter_get_attributes(). If no tags applied to this text affect
// editability, @default_setting will be returned.
//
// You don’t want to use this function to decide whether text can be inserted at
// @iter, because for insertion you don’t want to know whether the char at @iter
// is inside an editable range, you want to know whether a new character
// inserted at @iter would be inside an editable range. Use
// gtk_text_iter_can_insert() to handle this case.
func (i *TextIter) Editable(defaultSetting bool) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.gboolean     // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	if defaultSetting {
		_arg1 = C.TRUE
	}

	_cret = C.gtk_text_iter_editable(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EndsLine returns true if @iter points to the start of the paragraph delimiter
// characters for a line (delimiters will be either a newline, a carriage
// return, a carriage return followed by a newline, or a Unicode paragraph
// separator character). Note that an iterator pointing to the \n of a \r\n pair
// will not be counted as the end of a line, the line ends before the \r. The
// end iterator is considered to be at the end of a line, even though there are
// no paragraph delimiter chars there.
func (i *TextIter) EndsLine() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_ends_line(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EndsSentence determines whether @iter ends a sentence. Sentence boundaries
// are determined by Pango and should be correct for nearly any language (if
// not, the correct fix would be to the Pango text boundary algorithms).
func (i *TextIter) EndsSentence() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_ends_sentence(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EndsTag returns true if @tag is toggled off at exactly this point. If @tag is
// nil, returns true if any tag is toggled off at this point.
//
// Note that if gtk_text_iter_ends_tag() returns true, it means that @iter is at
// the end of the tagged range, but that the character at @iter is outside the
// tagged range. In other words, unlike gtk_text_iter_starts_tag(), if
// gtk_text_iter_ends_tag() returns true, gtk_text_iter_has_tag() will return
// false for the same parameters.
func (i *TextIter) EndsTag(tag TextTag) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextTag  // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	_cret = C.gtk_text_iter_ends_tag(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EndsWord determines whether @iter ends a natural-language word. Word breaks
// are determined by Pango and should be correct for nearly any language (if
// not, the correct fix would be to the Pango word break algorithms).
func (i *TextIter) EndsWord() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_ends_word(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Equal tests whether two iterators are equal, using the fastest possible
// mechanism. This function is very fast; you can expect it to perform better
// than e.g. getting the character offset for each iterator and comparing the
// offsets yourself. Also, it’s a bit faster than gtk_text_iter_compare().
func (l *TextIter) Equal(rhs *TextIter) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(rhs.Native()))

	_cret = C.gtk_text_iter_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardChar moves @iter forward by one character offset. Note that images
// embedded in the buffer occupy 1 character slot, so
// gtk_text_iter_forward_char() may actually move onto an image instead of a
// character, if you have images in your buffer. If @iter is the end iterator or
// one character before it, @iter will now point at the end iterator, and
// gtk_text_iter_forward_char() returns false for convenience when writing
// loops.
func (i *TextIter) ForwardChar() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_forward_char(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardChars moves @count characters if possible (if @count would move past
// the start or end of the buffer, moves to the start or end of the buffer). The
// return value indicates whether the new position of @iter is different from
// its original position, and dereferenceable (the last iterator in the buffer
// is not dereferenceable). If @count is 0, the function does nothing and
// returns false.
func (i *TextIter) ForwardChars(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.gint         // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(count)

	_cret = C.gtk_text_iter_forward_chars(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardCursorPosition moves @iter forward by a single cursor position. Cursor
// positions are (unsurprisingly) positions where the cursor can appear. Perhaps
// surprisingly, there may not be a cursor position between all characters. The
// most common example for European languages would be a carriage return/newline
// sequence. For some Unicode characters, the equivalent of say the letter “a”
// with an accent mark will be represented as two characters, first the letter
// then a "combining mark" that causes the accent to be rendered; so the cursor
// can’t go between those two characters. See also the LogAttr-struct and
// pango_break() function.
func (i *TextIter) ForwardCursorPosition() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_forward_cursor_position(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardCursorPositions moves up to @count cursor positions. See
// gtk_text_iter_forward_cursor_position() for details.
func (i *TextIter) ForwardCursorPositions(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.gint         // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(count)

	_cret = C.gtk_text_iter_forward_cursor_positions(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardLine moves @iter to the start of the next line. If the iter is already
// on the last line of the buffer, moves the iter to the end of the current
// line. If after the operation, the iter is at the end of the buffer and not
// dereferencable, returns false. Otherwise, returns true.
func (i *TextIter) ForwardLine() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_forward_line(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardLines moves @count lines forward, if possible (if @count would move
// past the start or end of the buffer, moves to the start or end of the
// buffer). The return value indicates whether the iterator moved onto a
// dereferenceable position; if the iterator didn’t move, or moved onto the end
// iterator, then false is returned. If @count is 0, the function does nothing
// and returns false. If @count is negative, moves backward by 0 - @count lines.
func (i *TextIter) ForwardLines(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.gint         // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(count)

	_cret = C.gtk_text_iter_forward_lines(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardSearch searches forward for @str. Any match is returned by setting
// @match_start to the first character of the match and @match_end to the first
// character after the match. The search will not continue past @limit. Note
// that a search is a linear or O(n) operation, so you may wish to use @limit to
// avoid locking up your UI on large buffers.
//
// @match_start will never be set to a TextIter located before @iter, even if
// there is a possible @match_end after or at @iter.
func (i *TextIter) ForwardSearch(str string, flags TextSearchFlags, limit *TextIter) (matchStart TextIter, matchEnd TextIter, ok bool) {
	var _arg0 *C.GtkTextIter       // out
	var _arg1 *C.gchar             // out
	var _arg2 C.GtkTextSearchFlags // out
	var _matchStart TextIter
	var _matchEnd TextIter
	var _arg5 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GtkTextSearchFlags)(flags)
	_arg5 = (*C.GtkTextIter)(unsafe.Pointer(limit.Native()))

	_cret = C.gtk_text_iter_forward_search(_arg0, _arg1, _arg2, (*C.GtkTextIter)(unsafe.Pointer(&_matchStart)), (*C.GtkTextIter)(unsafe.Pointer(&_matchEnd)), _arg5)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _matchStart, _matchEnd, _ok
}

// ForwardSentenceEnd moves forward to the next sentence end. (If @iter is at
// the end of a sentence, moves to the next end of sentence.) Sentence
// boundaries are determined by Pango and should be correct for nearly any
// language (if not, the correct fix would be to the Pango text boundary
// algorithms).
func (i *TextIter) ForwardSentenceEnd() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_forward_sentence_end(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardSentenceEnds calls gtk_text_iter_forward_sentence_end() @count times
// (or until gtk_text_iter_forward_sentence_end() returns false). If @count is
// negative, moves backward instead of forward.
func (i *TextIter) ForwardSentenceEnds(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.gint         // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(count)

	_cret = C.gtk_text_iter_forward_sentence_ends(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardToEnd moves @iter forward to the “end iterator,” which points one past
// the last valid character in the buffer. gtk_text_iter_get_char() called on
// the end iterator returns 0, which is convenient for writing loops.
func (i *TextIter) ForwardToEnd() {
	var _arg0 *C.GtkTextIter // out

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	C.gtk_text_iter_forward_to_end(_arg0)
}

// ForwardToLineEnd moves the iterator to point to the paragraph delimiter
// characters, which will be either a newline, a carriage return, a carriage
// return/newline in sequence, or the Unicode paragraph separator character. If
// the iterator is already at the paragraph delimiter characters, moves to the
// paragraph delimiter characters for the next line. If @iter is on the last
// line in the buffer, which does not end in paragraph delimiters, moves to the
// end iterator (end of the last line), and returns false.
func (i *TextIter) ForwardToLineEnd() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_forward_to_line_end(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardToTagToggle moves forward to the next toggle (on or off) of the
// TextTag @tag, or to the next toggle of any tag if @tag is nil. If no matching
// tag toggles are found, returns false, otherwise true. Does not return toggles
// located at @iter, only toggles after @iter. Sets @iter to the location of the
// toggle, or to the end of the buffer if no toggle is found.
func (i *TextIter) ForwardToTagToggle(tag TextTag) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextTag  // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	_cret = C.gtk_text_iter_forward_to_tag_toggle(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardVisibleCursorPosition moves @iter forward to the next visible cursor
// position. See gtk_text_iter_forward_cursor_position() for details.
func (i *TextIter) ForwardVisibleCursorPosition() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_forward_visible_cursor_position(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardVisibleCursorPositions moves up to @count visible cursor positions.
// See gtk_text_iter_forward_cursor_position() for details.
func (i *TextIter) ForwardVisibleCursorPositions(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.gint         // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(count)

	_cret = C.gtk_text_iter_forward_visible_cursor_positions(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardVisibleLine moves @iter to the start of the next visible line. Returns
// true if there was a next line to move to, and false if @iter was simply moved
// to the end of the buffer and is now not dereferenceable, or if @iter was
// already at the end of the buffer.
func (i *TextIter) ForwardVisibleLine() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_forward_visible_line(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardVisibleLines moves @count visible lines forward, if possible (if
// @count would move past the start or end of the buffer, moves to the start or
// end of the buffer). The return value indicates whether the iterator moved
// onto a dereferenceable position; if the iterator didn’t move, or moved onto
// the end iterator, then false is returned. If @count is 0, the function does
// nothing and returns false. If @count is negative, moves backward by 0 -
// @count lines.
func (i *TextIter) ForwardVisibleLines(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.gint         // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(count)

	_cret = C.gtk_text_iter_forward_visible_lines(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardVisibleWordEnd moves forward to the next visible word end. (If @iter
// is currently on a word end, moves forward to the next one after that.) Word
// breaks are determined by Pango and should be correct for nearly any language
// (if not, the correct fix would be to the Pango word break algorithms).
func (i *TextIter) ForwardVisibleWordEnd() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_forward_visible_word_end(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardVisibleWordEnds calls gtk_text_iter_forward_visible_word_end() up to
// @count times.
func (i *TextIter) ForwardVisibleWordEnds(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.gint         // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(count)

	_cret = C.gtk_text_iter_forward_visible_word_ends(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardWordEnd moves forward to the next word end. (If @iter is currently on
// a word end, moves forward to the next one after that.) Word breaks are
// determined by Pango and should be correct for nearly any language (if not,
// the correct fix would be to the Pango word break algorithms).
func (i *TextIter) ForwardWordEnd() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_forward_word_end(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardWordEnds calls gtk_text_iter_forward_word_end() up to @count times.
func (i *TextIter) ForwardWordEnds(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.gint         // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(count)

	_cret = C.gtk_text_iter_forward_word_ends(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Free: free an iterator allocated on the heap. This function is intended for
// use in language bindings, and is not especially useful for applications,
// because iterators can simply be allocated on the stack.
func (i *TextIter) Free() {
	var _arg0 *C.GtkTextIter // out

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	C.gtk_text_iter_free(_arg0)
}

// Attributes computes the effect of any tags applied to this spot in the text.
// The @values parameter should be initialized to the default settings you wish
// to use if no tags are in effect. You’d typically obtain the defaults from
// gtk_text_view_get_default_attributes().
//
// gtk_text_iter_get_attributes() will modify @values, applying the effects of
// any tags present at @iter. If any tags affected @values, the function returns
// true.
func (i *TextIter) Attributes() (TextAttributes, bool) {
	var _arg0 *C.GtkTextIter // out
	var _values TextAttributes
	var _cret C.gboolean // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_get_attributes(_arg0, (*C.GtkTextAttributes)(unsafe.Pointer(&_values)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _values, _ok
}

// Buffer returns the TextBuffer this iterator is associated with.
func (i *TextIter) Buffer() TextBuffer {
	var _arg0 *C.GtkTextIter   // out
	var _cret *C.GtkTextBuffer // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_get_buffer(_arg0)

	var _textBuffer TextBuffer // out

	_textBuffer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextBuffer)

	return _textBuffer
}

// BytesInLine returns the number of bytes in the line containing @iter,
// including the paragraph delimiters.
func (i *TextIter) BytesInLine() int {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_get_bytes_in_line(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Char: the Unicode character at this iterator is returned. (Equivalent to
// operator* on a C++ iterator.) If the element at this iterator is a
// non-character element, such as an image embedded in the buffer, the Unicode
// “unknown” character 0xFFFC is returned. If invoked on the end iterator, zero
// is returned; zero is not a valid Unicode character. So you can write a loop
// which ends when gtk_text_iter_get_char() returns 0.
func (i *TextIter) Char() uint32 {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gunichar     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_get_char(_arg0)

	var _gunichar uint32 // out

	_gunichar = (uint32)(_cret)

	return _gunichar
}

// CharsInLine returns the number of characters in the line containing @iter,
// including the paragraph delimiters.
func (i *TextIter) CharsInLine() int {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_get_chars_in_line(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// ChildAnchor: if the location at @iter contains a child anchor, the anchor is
// returned (with no new reference count added). Otherwise, nil is returned.
func (i *TextIter) ChildAnchor() TextChildAnchor {
	var _arg0 *C.GtkTextIter        // out
	var _cret *C.GtkTextChildAnchor // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_get_child_anchor(_arg0)

	var _textChildAnchor TextChildAnchor // out

	_textChildAnchor = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextChildAnchor)

	return _textChildAnchor
}

// Language: a convenience wrapper around gtk_text_iter_get_attributes(), which
// returns the language in effect at @iter. If no tags affecting language apply
// to @iter, the return value is identical to that of
// gtk_get_default_language().
func (i *TextIter) Language() *pango.Language {
	var _arg0 *C.GtkTextIter   // out
	var _cret *C.PangoLanguage // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_get_language(_arg0)

	var _language *pango.Language // out

	_language = pango.WrapLanguage(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_language, func(v *pango.Language) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _language
}

// Line returns the line number containing the iterator. Lines in a TextBuffer
// are numbered beginning with 0 for the first line in the buffer.
func (i *TextIter) Line() int {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_get_line(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// LineIndex returns the byte index of the iterator, counting from the start of
// a newline-terminated line. Remember that TextBuffer encodes text in UTF-8,
// and that characters can require a variable number of bytes to represent.
func (i *TextIter) LineIndex() int {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_get_line_index(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// LineOffset returns the character offset of the iterator, counting from the
// start of a newline-terminated line. The first character on the line has
// offset 0.
func (i *TextIter) LineOffset() int {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_get_line_offset(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Offset returns the character offset of an iterator. Each character in a
// TextBuffer has an offset, starting with 0 for the first character in the
// buffer. Use gtk_text_buffer_get_iter_at_offset() to convert an offset back
// into an iterator.
func (i *TextIter) Offset() int {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_get_offset(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Pixbuf: if the element at @iter is a pixbuf, the pixbuf is returned (with no
// new reference count added). Otherwise, nil is returned.
func (i *TextIter) Pixbuf() gdkpixbuf.Pixbuf {
	var _arg0 *C.GtkTextIter // out
	var _cret *C.GdkPixbuf   // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_get_pixbuf(_arg0)

	var _pixbuf gdkpixbuf.Pixbuf // out

	_pixbuf = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

	return _pixbuf
}

// Slice returns the text in the given range. A “slice” is an array of
// characters encoded in UTF-8 format, including the Unicode “unknown” character
// 0xFFFC for iterable non-character elements in the buffer, such as images.
// Because images are encoded in the slice, byte and character offsets in the
// returned array will correspond to byte offsets in the text buffer. Note that
// 0xFFFC can occur in normal text as well, so it is not a reliable indicator
// that a pixbuf or widget is in the buffer.
func (s *TextIter) Slice(end *TextIter) string {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextIter // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	_cret = C.gtk_text_iter_get_slice(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Text returns text in the given range. If the range contains non-text elements
// such as images, the character and byte offsets in the returned string will
// not correspond to character and byte offsets in the buffer. If you want
// offsets to correspond, see gtk_text_iter_get_slice().
func (s *TextIter) Text(end *TextIter) string {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextIter // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	_cret = C.gtk_text_iter_get_text(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// VisibleLineIndex returns the number of bytes from the start of the line to
// the given @iter, not counting bytes that are invisible due to tags with the
// “invisible” flag toggled on.
func (i *TextIter) VisibleLineIndex() int {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_get_visible_line_index(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// VisibleLineOffset returns the offset in characters from the start of the line
// to the given @iter, not counting characters that are invisible due to tags
// with the “invisible” flag toggled on.
func (i *TextIter) VisibleLineOffset() int {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_get_visible_line_offset(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// VisibleSlice: like gtk_text_iter_get_slice(), but invisible text is not
// included. Invisible text is usually invisible because a TextTag with the
// “invisible” attribute turned on has been applied to it.
func (s *TextIter) VisibleSlice(end *TextIter) string {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextIter // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	_cret = C.gtk_text_iter_get_visible_slice(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// VisibleText: like gtk_text_iter_get_text(), but invisible text is not
// included. Invisible text is usually invisible because a TextTag with the
// “invisible” attribute turned on has been applied to it.
func (s *TextIter) VisibleText(end *TextIter) string {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextIter // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	_cret = C.gtk_text_iter_get_visible_text(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// HasTag returns true if @iter points to a character that is part of a range
// tagged with @tag. See also gtk_text_iter_starts_tag() and
// gtk_text_iter_ends_tag().
func (i *TextIter) HasTag(tag TextTag) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextTag  // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	_cret = C.gtk_text_iter_has_tag(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InRange checks whether @iter falls in the range [@start, @end). @start and
// @end must be in ascending order.
func (i *TextIter) InRange(start *TextIter, end *TextIter) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextIter // out
	var _arg2 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	_cret = C.gtk_text_iter_in_range(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InsideSentence determines whether @iter is inside a sentence (as opposed to
// in between two sentences, e.g. after a period and before the first letter of
// the next sentence). Sentence boundaries are determined by Pango and should be
// correct for nearly any language (if not, the correct fix would be to the
// Pango text boundary algorithms).
func (i *TextIter) InsideSentence() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_inside_sentence(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InsideWord determines whether the character pointed by @iter is part of a
// natural-language word (as opposed to say inside some whitespace). Word breaks
// are determined by Pango and should be correct for nearly any language (if
// not, the correct fix would be to the Pango word break algorithms).
//
// Note that if gtk_text_iter_starts_word() returns true, then this function
// returns true too, since @iter points to the first character of the word.
func (i *TextIter) InsideWord() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_inside_word(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsCursorPosition: see gtk_text_iter_forward_cursor_position() or LogAttr or
// pango_break() for details on what a cursor position is.
func (i *TextIter) IsCursorPosition() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_is_cursor_position(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsEnd returns true if @iter is the end iterator, i.e. one past the last
// dereferenceable iterator in the buffer. gtk_text_iter_is_end() is the most
// efficient way to check whether an iterator is the end iterator.
func (i *TextIter) IsEnd() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_is_end(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsStart returns true if @iter is the first iterator in the buffer, that is if
// @iter has a character offset of 0.
func (i *TextIter) IsStart() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_is_start(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Order swaps the value of @first and @second if @second comes before @first in
// the buffer. That is, ensures that @first and @second are in sequence. Most
// text buffer functions that take a range call this automatically on your
// behalf, so there’s no real reason to call it yourself in those cases. There
// are some exceptions, such as gtk_text_iter_in_range(), that expect a
// pre-sorted range.
func (f *TextIter) Order(second *TextIter) {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextIter // out

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(second.Native()))

	C.gtk_text_iter_order(_arg0, _arg1)
}

// SetLine moves iterator @iter to the start of the line @line_number. If
// @line_number is negative or larger than the number of lines in the buffer,
// moves @iter to the start of the last line in the buffer.
func (i *TextIter) SetLine(lineNumber int) {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(lineNumber)

	C.gtk_text_iter_set_line(_arg0, _arg1)
}

// SetLineIndex: same as gtk_text_iter_set_line_offset(), but works with a byte
// index. The given byte index must be at the start of a character, it can’t be
// in the middle of a UTF-8 encoded character.
func (i *TextIter) SetLineIndex(byteOnLine int) {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(byteOnLine)

	C.gtk_text_iter_set_line_index(_arg0, _arg1)
}

// SetLineOffset moves @iter within a line, to a new character (not byte)
// offset. The given character offset must be less than or equal to the number
// of characters in the line; if equal, @iter moves to the start of the next
// line. See gtk_text_iter_set_line_index() if you have a byte index rather than
// a character offset.
func (i *TextIter) SetLineOffset(charOnLine int) {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(charOnLine)

	C.gtk_text_iter_set_line_offset(_arg0, _arg1)
}

// SetOffset sets @iter to point to @char_offset. @char_offset counts from the
// start of the entire text buffer, starting with 0.
func (i *TextIter) SetOffset(charOffset int) {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(charOffset)

	C.gtk_text_iter_set_offset(_arg0, _arg1)
}

// SetVisibleLineIndex: like gtk_text_iter_set_line_index(), but the index is in
// visible bytes, i.e. text with a tag making it invisible is not counted in the
// index.
func (i *TextIter) SetVisibleLineIndex(byteOnLine int) {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(byteOnLine)

	C.gtk_text_iter_set_visible_line_index(_arg0, _arg1)
}

// SetVisibleLineOffset: like gtk_text_iter_set_line_offset(), but the offset is
// in visible characters, i.e. text with a tag making it invisible is not
// counted in the offset.
func (i *TextIter) SetVisibleLineOffset(charOnLine int) {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (C.gint)(charOnLine)

	C.gtk_text_iter_set_visible_line_offset(_arg0, _arg1)
}

// StartsLine returns true if @iter begins a paragraph, i.e. if
// gtk_text_iter_get_line_offset() would return 0. However this function is
// potentially more efficient than gtk_text_iter_get_line_offset() because it
// doesn’t have to compute the offset, it just has to see whether it’s 0.
func (i *TextIter) StartsLine() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_starts_line(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// StartsSentence determines whether @iter begins a sentence. Sentence
// boundaries are determined by Pango and should be correct for nearly any
// language (if not, the correct fix would be to the Pango text boundary
// algorithms).
func (i *TextIter) StartsSentence() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_starts_sentence(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// StartsTag returns true if @tag is toggled on at exactly this point. If @tag
// is nil, returns true if any tag is toggled on at this point.
//
// Note that if gtk_text_iter_starts_tag() returns true, it means that @iter is
// at the beginning of the tagged range, and that the character at @iter is
// inside the tagged range. In other words, unlike gtk_text_iter_ends_tag(), if
// gtk_text_iter_starts_tag() returns true, gtk_text_iter_has_tag() will also
// return true for the same parameters.
func (i *TextIter) StartsTag(tag TextTag) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextTag  // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	_cret = C.gtk_text_iter_starts_tag(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// StartsWord determines whether @iter begins a natural-language word. Word
// breaks are determined by Pango and should be correct for nearly any language
// (if not, the correct fix would be to the Pango word break algorithms).
func (i *TextIter) StartsWord() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_text_iter_starts_word(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TogglesTag: this is equivalent to (gtk_text_iter_starts_tag() ||
// gtk_text_iter_ends_tag()), i.e. it tells you whether a range with @tag
// applied to it begins or ends at @iter.
func (i *TextIter) TogglesTag(tag TextTag) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextTag  // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	_cret = C.gtk_text_iter_toggles_tag(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

type ThemeEngine struct {
	native C.GtkThemeEngine
}

// WrapThemeEngine wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapThemeEngine(ptr unsafe.Pointer) *ThemeEngine {
	if ptr == nil {
		return nil
	}

	return (*ThemeEngine)(ptr)
}

// Native returns the underlying C source pointer.
func (t *ThemeEngine) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// TreeIter: the TreeIter is the primary structure for accessing a TreeModel.
// Models are expected to put a unique integer in the @stamp member, and put
// model-specific data in the three @user_data members.
type TreeIter struct {
	native C.GtkTreeIter
}

// WrapTreeIter wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTreeIter(ptr unsafe.Pointer) *TreeIter {
	if ptr == nil {
		return nil
	}

	return (*TreeIter)(ptr)
}

func marshalTreeIter(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTreeIter(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TreeIter) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// Copy creates a dynamically allocated tree iterator as a copy of @iter.
//
// This function is not intended for use in applications, because you can just
// copy the structs by value (`GtkTreeIter new_iter = iter;`). You must free
// this iter with gtk_tree_iter_free().
func (i *TreeIter) Copy() *TreeIter {
	var _arg0 *C.GtkTreeIter // out
	var _cret *C.GtkTreeIter // in

	_arg0 = (*C.GtkTreeIter)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_tree_iter_copy(_arg0)

	var _treeIter *TreeIter // out

	_treeIter = WrapTreeIter(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treeIter, func(v *TreeIter) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treeIter
}

// Free frees an iterator that has been allocated by gtk_tree_iter_copy().
//
// This function is mainly used for language bindings.
func (i *TreeIter) Free() {
	var _arg0 *C.GtkTreeIter // out

	_arg0 = (*C.GtkTreeIter)(unsafe.Pointer(i.Native()))

	C.gtk_tree_iter_free(_arg0)
}

type TreePath struct {
	native C.GtkTreePath
}

// WrapTreePath wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTreePath(ptr unsafe.Pointer) *TreePath {
	if ptr == nil {
		return nil
	}

	return (*TreePath)(ptr)
}

func marshalTreePath(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTreePath(unsafe.Pointer(b)), nil
}

// NewTreePath constructs a struct TreePath.
func NewTreePath() *TreePath {
	var _cret *C.GtkTreePath // in

	_cret = C.gtk_tree_path_new()

	var _treePath *TreePath // out

	_treePath = WrapTreePath(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treePath, func(v *TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treePath
}

// NewTreePathFirst constructs a struct TreePath.
func NewTreePathFirst() *TreePath {
	var _cret *C.GtkTreePath // in

	_cret = C.gtk_tree_path_new_first()

	var _treePath *TreePath // out

	_treePath = WrapTreePath(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treePath, func(v *TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treePath
}

// NewTreePathFromIndicesv constructs a struct TreePath.
func NewTreePathFromIndicesv(indices []int) *TreePath {
	var _arg1 *C.gint
	var _arg2 C.gsize
	var _cret *C.GtkTreePath // in

	_arg2 = C.gsize(len(indices))
	_arg1 = (*C.gint)(unsafe.Pointer(&indices[0]))

	_cret = C.gtk_tree_path_new_from_indicesv(_arg1, _arg2)

	var _treePath *TreePath // out

	_treePath = WrapTreePath(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treePath, func(v *TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treePath
}

// NewTreePathFromString constructs a struct TreePath.
func NewTreePathFromString(path string) *TreePath {
	var _arg1 *C.gchar       // out
	var _cret *C.GtkTreePath // in

	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_tree_path_new_from_string(_arg1)

	var _treePath *TreePath // out

	_treePath = WrapTreePath(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treePath, func(v *TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treePath
}

// Native returns the underlying C source pointer.
func (t *TreePath) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// AppendIndex appends a new index to a path.
//
// As a result, the depth of the path is increased.
func (p *TreePath) AppendIndex(index_ int) {
	var _arg0 *C.GtkTreePath // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))
	_arg1 = (C.gint)(index_)

	C.gtk_tree_path_append_index(_arg0, _arg1)
}

// Compare compares two paths.
//
// If @a appears before @b in a tree, then -1 is returned. If @b appears before
// @a, then 1 is returned. If the two nodes are equal, then 0 is returned.
func (a *TreePath) Compare(b *TreePath) int {
	var _arg0 *C.GtkTreePath // out
	var _arg1 *C.GtkTreePath // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_tree_path_compare(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Copy creates a new TreePath-struct as a copy of @path.
func (p *TreePath) Copy() *TreePath {
	var _arg0 *C.GtkTreePath // out
	var _cret *C.GtkTreePath // in

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_tree_path_copy(_arg0)

	var _treePath *TreePath // out

	_treePath = WrapTreePath(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treePath, func(v *TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treePath
}

// Down moves @path to point to the first child of the current path.
func (p *TreePath) Down() {
	var _arg0 *C.GtkTreePath // out

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

	C.gtk_tree_path_down(_arg0)
}

// Free frees @path. If @path is nil, it simply returns.
func (p *TreePath) Free() {
	var _arg0 *C.GtkTreePath // out

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

	C.gtk_tree_path_free(_arg0)
}

// Depth returns the current depth of @path.
func (p *TreePath) Depth() int {
	var _arg0 *C.GtkTreePath // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_tree_path_get_depth(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// IsAncestor returns true if @descendant is a descendant of @path.
func (p *TreePath) IsAncestor(descendant *TreePath) bool {
	var _arg0 *C.GtkTreePath // out
	var _arg1 *C.GtkTreePath // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(descendant.Native()))

	_cret = C.gtk_tree_path_is_ancestor(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsDescendant returns true if @path is a descendant of @ancestor.
func (p *TreePath) IsDescendant(ancestor *TreePath) bool {
	var _arg0 *C.GtkTreePath // out
	var _arg1 *C.GtkTreePath // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(ancestor.Native()))

	_cret = C.gtk_tree_path_is_descendant(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Next moves the @path to point to the next node at the current depth.
func (p *TreePath) Next() {
	var _arg0 *C.GtkTreePath // out

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

	C.gtk_tree_path_next(_arg0)
}

// PrependIndex prepends a new index to a path.
//
// As a result, the depth of the path is increased.
func (p *TreePath) PrependIndex(index_ int) {
	var _arg0 *C.GtkTreePath // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))
	_arg1 = (C.gint)(index_)

	C.gtk_tree_path_prepend_index(_arg0, _arg1)
}

// Prev moves the @path to point to the previous node at the current depth, if
// it exists.
func (p *TreePath) Prev() bool {
	var _arg0 *C.GtkTreePath // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_tree_path_prev(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// String generates a string representation of the path.
//
// This string is a “:” separated list of numbers. For example, “4:10:0:3” would
// be an acceptable return value for this string.
func (p *TreePath) String() string {
	var _arg0 *C.GtkTreePath // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_tree_path_to_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Up moves the @path to point to its parent node, if it has a parent.
func (p *TreePath) Up() bool {
	var _arg0 *C.GtkTreePath // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_tree_path_up(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TreeRowReference: a GtkTreeRowReference tracks model changes so that it
// always refers to the same row (a TreePath refers to a position, not a fixed
// row). Create a new GtkTreeRowReference with gtk_tree_row_reference_new().
type TreeRowReference struct {
	native C.GtkTreeRowReference
}

// WrapTreeRowReference wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTreeRowReference(ptr unsafe.Pointer) *TreeRowReference {
	if ptr == nil {
		return nil
	}

	return (*TreeRowReference)(ptr)
}

func marshalTreeRowReference(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTreeRowReference(unsafe.Pointer(b)), nil
}

// NewTreeRowReference constructs a struct TreeRowReference.
func NewTreeRowReference(model TreeModel, path *TreePath) *TreeRowReference {
	var _arg1 *C.GtkTreeModel        // out
	var _arg2 *C.GtkTreePath         // out
	var _cret *C.GtkTreeRowReference // in

	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))
	_arg2 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	_cret = C.gtk_tree_row_reference_new(_arg1, _arg2)

	var _treeRowReference *TreeRowReference // out

	_treeRowReference = WrapTreeRowReference(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treeRowReference, func(v *TreeRowReference) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treeRowReference
}

// NewTreeRowReferenceProXY constructs a struct TreeRowReference.
func NewTreeRowReferenceProXY(proxy gextras.Objector, model TreeModel, path *TreePath) *TreeRowReference {
	var _arg1 *C.GObject             // out
	var _arg2 *C.GtkTreeModel        // out
	var _arg3 *C.GtkTreePath         // out
	var _cret *C.GtkTreeRowReference // in

	_arg1 = (*C.GObject)(unsafe.Pointer(proxy.Native()))
	_arg2 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))
	_arg3 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	_cret = C.gtk_tree_row_reference_new_proxy(_arg1, _arg2, _arg3)

	var _treeRowReference *TreeRowReference // out

	_treeRowReference = WrapTreeRowReference(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treeRowReference, func(v *TreeRowReference) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treeRowReference
}

// Native returns the underlying C source pointer.
func (t *TreeRowReference) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// Copy copies a TreeRowReference.
func (r *TreeRowReference) Copy() *TreeRowReference {
	var _arg0 *C.GtkTreeRowReference // out
	var _cret *C.GtkTreeRowReference // in

	_arg0 = (*C.GtkTreeRowReference)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_tree_row_reference_copy(_arg0)

	var _treeRowReference *TreeRowReference // out

	_treeRowReference = WrapTreeRowReference(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treeRowReference, func(v *TreeRowReference) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treeRowReference
}

// Free free’s @reference. @reference may be nil
func (r *TreeRowReference) Free() {
	var _arg0 *C.GtkTreeRowReference // out

	_arg0 = (*C.GtkTreeRowReference)(unsafe.Pointer(r.Native()))

	C.gtk_tree_row_reference_free(_arg0)
}

// Model returns the model that the row reference is monitoring.
func (r *TreeRowReference) Model() TreeModel {
	var _arg0 *C.GtkTreeRowReference // out
	var _cret *C.GtkTreeModel        // in

	_arg0 = (*C.GtkTreeRowReference)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_tree_row_reference_get_model(_arg0)

	var _treeModel TreeModel // out

	_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeModel)

	return _treeModel
}

// Path returns a path that the row reference currently points to, or nil if the
// path pointed to is no longer valid.
func (r *TreeRowReference) Path() *TreePath {
	var _arg0 *C.GtkTreeRowReference // out
	var _cret *C.GtkTreePath         // in

	_arg0 = (*C.GtkTreeRowReference)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_tree_row_reference_get_path(_arg0)

	var _treePath *TreePath // out

	_treePath = WrapTreePath(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treePath, func(v *TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treePath
}

// Valid returns true if the @reference is non-nil and refers to a current valid
// path.
func (r *TreeRowReference) Valid() bool {
	var _arg0 *C.GtkTreeRowReference // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkTreeRowReference)(unsafe.Pointer(r.Native()))

	_cret = C.gtk_tree_row_reference_valid(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// WidgetPath: gtkWidgetPath is a boxed type that represents a widget hierarchy
// from the topmost widget, typically a toplevel, to any child. This widget path
// abstraction is used in StyleContext on behalf of the real widget in order to
// query style information.
//
// If you are using GTK+ widgets, you probably will not need to use this API
// directly, as there is gtk_widget_get_path(), and the style context returned
// by gtk_widget_get_style_context() will be automatically updated on widget
// hierarchy changes.
//
// The widget path generation is generally simple:
//
// Defining a button within a window
//
//    {
//      GtkWidgetPath *path;
//      guint pos;
//
//      path = gtk_widget_path_new ();
//
//      pos = gtk_widget_path_append_type (path, GTK_TYPE_NOTEBOOK);
//      gtk_widget_path_iter_add_region (path, pos, "tab", GTK_REGION_EVEN | GTK_REGION_FIRST);
//
//      pos = gtk_widget_path_append_type (path, GTK_TYPE_LABEL);
//      gtk_widget_path_iter_set_name (path, pos, "first tab label");
//    }
//
// All this information will be used to match the style information that applies
// to the described widget.
type WidgetPath struct {
	native C.GtkWidgetPath
}

// WrapWidgetPath wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapWidgetPath(ptr unsafe.Pointer) *WidgetPath {
	if ptr == nil {
		return nil
	}

	return (*WidgetPath)(ptr)
}

func marshalWidgetPath(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapWidgetPath(unsafe.Pointer(b)), nil
}

// NewWidgetPath constructs a struct WidgetPath.
func NewWidgetPath() *WidgetPath {
	var _cret *C.GtkWidgetPath // in

	_cret = C.gtk_widget_path_new()

	var _widgetPath *WidgetPath // out

	_widgetPath = WrapWidgetPath(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_widgetPath, func(v *WidgetPath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _widgetPath
}

// Native returns the underlying C source pointer.
func (w *WidgetPath) Native() unsafe.Pointer {
	return unsafe.Pointer(&w.native)
}

// AppendForWidget appends the data from @widget to the widget hierarchy
// represented by @path. This function is a shortcut for adding information from
// @widget to the given @path. This includes setting the name or adding the
// style classes from @widget.
func (p *WidgetPath) AppendForWidget(widget Widget) int {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 *C.GtkWidget     // out
	var _cret C.gint           // in

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	_cret = C.gtk_widget_path_append_for_widget(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// AppendType appends a widget type to the widget hierarchy represented by
// @path.
func (p *WidgetPath) AppendType(typ externglib.Type) int {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.GType          // out
	var _cret C.gint           // in

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = C.GType(typ)

	_cret = C.gtk_widget_path_append_type(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// AppendWithSiblings appends a widget type with all its siblings to the widget
// hierarchy represented by @path. Using this function instead of
// gtk_widget_path_append_type() will allow the CSS theming to use sibling
// matches in selectors and apply :nth-child() pseudo classes. In turn, it
// requires a lot more care in widget implementations as widgets need to make
// sure to call gtk_widget_reset_style() on all involved widgets when the
// @siblings path changes.
func (p *WidgetPath) AppendWithSiblings(siblings *WidgetPath, siblingIndex uint) int {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 *C.GtkWidgetPath // out
	var _arg2 C.guint          // out
	var _cret C.gint           // in

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkWidgetPath)(unsafe.Pointer(siblings.Native()))
	_arg2 = (C.guint)(siblingIndex)

	_cret = C.gtk_widget_path_append_with_siblings(_arg0, _arg1, _arg2)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Copy returns a copy of @path
func (p *WidgetPath) Copy() *WidgetPath {
	var _arg0 *C.GtkWidgetPath // out
	var _cret *C.GtkWidgetPath // in

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_widget_path_copy(_arg0)

	var _widgetPath *WidgetPath // out

	_widgetPath = WrapWidgetPath(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_widgetPath, func(v *WidgetPath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _widgetPath
}

// Free decrements the reference count on @path, freeing the structure if the
// reference count reaches 0.
func (p *WidgetPath) Free() {
	var _arg0 *C.GtkWidgetPath // out

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))

	C.gtk_widget_path_free(_arg0)
}

// ObjectType returns the topmost object type, that is, the object type this
// path is representing.
func (p *WidgetPath) ObjectType() externglib.Type {
	var _arg0 *C.GtkWidgetPath // out
	var _cret C.GType          // in

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_widget_path_get_object_type(_arg0)

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

// HasParent returns true if any of the parents of the widget represented in
// @path is of type @type, or any subtype of it.
func (p *WidgetPath) HasParent(typ externglib.Type) bool {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.GType          // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = C.GType(typ)

	_cret = C.gtk_widget_path_has_parent(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsType returns true if the widget type represented by this path is @type, or
// a subtype of it.
func (p *WidgetPath) IsType(typ externglib.Type) bool {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.GType          // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = C.GType(typ)

	_cret = C.gtk_widget_path_is_type(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IterAddClass adds the class @name to the widget at position @pos in the
// hierarchy defined in @path. See gtk_style_context_add_class().
func (p *WidgetPath) IterAddClass(pos int, name string) {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _arg2 *C.gchar         // out

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = (C.gint)(pos)
	_arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_widget_path_iter_add_class(_arg0, _arg1, _arg2)
}

// IterAddRegion adds the region @name to the widget at position @pos in the
// hierarchy defined in @path. See gtk_style_context_add_region().
//
// Region names must only contain lowercase letters and “-”, starting always
// with a lowercase letter.
func (p *WidgetPath) IterAddRegion(pos int, name string, flags RegionFlags) {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _arg2 *C.gchar         // out
	var _arg3 C.GtkRegionFlags // out

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = (C.gint)(pos)
	_arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.GtkRegionFlags)(flags)

	C.gtk_widget_path_iter_add_region(_arg0, _arg1, _arg2, _arg3)
}

// IterClearClasses removes all classes from the widget at position @pos in the
// hierarchy defined in @path.
func (p *WidgetPath) IterClearClasses(pos int) {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = (C.gint)(pos)

	C.gtk_widget_path_iter_clear_classes(_arg0, _arg1)
}

// IterClearRegions removes all regions from the widget at position @pos in the
// hierarchy defined in @path.
func (p *WidgetPath) IterClearRegions(pos int) {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = (C.gint)(pos)

	C.gtk_widget_path_iter_clear_regions(_arg0, _arg1)
}

// IterGetName returns the name corresponding to the widget found at the
// position @pos in the widget hierarchy defined by @path
func (p *WidgetPath) IterGetName(pos int) string {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = (C.gint)(pos)

	_cret = C.gtk_widget_path_iter_get_name(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// IterGetObjectName returns the object name that is at position @pos in the
// widget hierarchy defined in @path.
func (p *WidgetPath) IterGetObjectName(pos int) string {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = (C.gint)(pos)

	_cret = C.gtk_widget_path_iter_get_object_name(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// IterGetObjectType returns the object #GType that is at position @pos in the
// widget hierarchy defined in @path.
func (p *WidgetPath) IterGetObjectType(pos int) externglib.Type {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _cret C.GType          // in

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = (C.gint)(pos)

	_cret = C.gtk_widget_path_iter_get_object_type(_arg0, _arg1)

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

// IterGetSiblingIndex returns the index into the list of siblings for the
// element at @pos as returned by gtk_widget_path_iter_get_siblings(). If that
// function would return nil because the element at @pos has no siblings, this
// function will return 0.
func (p *WidgetPath) IterGetSiblingIndex(pos int) uint {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _cret C.guint          // in

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = (C.gint)(pos)

	_cret = C.gtk_widget_path_iter_get_sibling_index(_arg0, _arg1)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// IterGetSiblings returns the list of siblings for the element at @pos. If the
// element was not added with siblings, nil is returned.
func (p *WidgetPath) IterGetSiblings(pos int) *WidgetPath {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _cret *C.GtkWidgetPath // in

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = (C.gint)(pos)

	_cret = C.gtk_widget_path_iter_get_siblings(_arg0, _arg1)

	var _widgetPath *WidgetPath // out

	_widgetPath = WrapWidgetPath(unsafe.Pointer(_cret))

	return _widgetPath
}

// IterGetState returns the state flags corresponding to the widget found at the
// position @pos in the widget hierarchy defined by @path
func (p *WidgetPath) IterGetState(pos int) StateFlags {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _cret C.GtkStateFlags  // in

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = (C.gint)(pos)

	_cret = C.gtk_widget_path_iter_get_state(_arg0, _arg1)

	var _stateFlags StateFlags // out

	_stateFlags = StateFlags(_cret)

	return _stateFlags
}

// IterHasClass returns true if the widget at position @pos has the class @name
// defined, false otherwise.
func (p *WidgetPath) IterHasClass(pos int, name string) bool {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _arg2 *C.gchar         // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = (C.gint)(pos)
	_arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_widget_path_iter_has_class(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IterHasName returns true if the widget at position @pos has the name @name,
// false otherwise.
func (p *WidgetPath) IterHasName(pos int, name string) bool {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _arg2 *C.gchar         // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = (C.gint)(pos)
	_arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_widget_path_iter_has_name(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IterHasRegion returns true if the widget at position @pos has the class @name
// defined, false otherwise.
func (p *WidgetPath) IterHasRegion(pos int, name string) (RegionFlags, bool) {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _arg2 *C.gchar         // out
	var _arg3 C.GtkRegionFlags // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = (C.gint)(pos)
	_arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_widget_path_iter_has_region(_arg0, _arg1, _arg2, &_arg3)

	var _flags RegionFlags // out
	var _ok bool           // out

	_flags = RegionFlags(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _flags, _ok
}

// IterRemoveClass removes the class @name from the widget at position @pos in
// the hierarchy defined in @path.
func (p *WidgetPath) IterRemoveClass(pos int, name string) {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _arg2 *C.gchar         // out

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = (C.gint)(pos)
	_arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_widget_path_iter_remove_class(_arg0, _arg1, _arg2)
}

// IterRemoveRegion removes the region @name from the widget at position @pos in
// the hierarchy defined in @path.
func (p *WidgetPath) IterRemoveRegion(pos int, name string) {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _arg2 *C.gchar         // out

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = (C.gint)(pos)
	_arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_widget_path_iter_remove_region(_arg0, _arg1, _arg2)
}

// IterSetName sets the widget name for the widget found at position @pos in the
// widget hierarchy defined by @path.
func (p *WidgetPath) IterSetName(pos int, name string) {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _arg2 *C.gchar         // out

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = (C.gint)(pos)
	_arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_widget_path_iter_set_name(_arg0, _arg1, _arg2)
}

// IterSetObjectName sets the object name for a given position in the widget
// hierarchy defined by @path.
//
// When set, the object name overrides the object type when matching CSS.
func (p *WidgetPath) IterSetObjectName(pos int, name string) {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _arg2 *C.char          // out

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = (C.gint)(pos)
	_arg2 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_widget_path_iter_set_object_name(_arg0, _arg1, _arg2)
}

// IterSetObjectType sets the object type for a given position in the widget
// hierarchy defined by @path.
func (p *WidgetPath) IterSetObjectType(pos int, typ externglib.Type) {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _arg2 C.GType          // out

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = (C.gint)(pos)
	_arg2 = C.GType(typ)

	C.gtk_widget_path_iter_set_object_type(_arg0, _arg1, _arg2)
}

// IterSetState sets the widget name for the widget found at position @pos in
// the widget hierarchy defined by @path.
//
// If you want to update just a single state flag, you need to do this manually,
// as this function updates all state flags.
//
// Setting a flag
//
//    gtk_widget_path_iter_set_state (path, pos, gtk_widget_path_iter_get_state (path, pos) & ~flag);
func (p *WidgetPath) IterSetState(pos int, state StateFlags) {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _arg2 C.GtkStateFlags  // out

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = (C.gint)(pos)
	_arg2 = (C.GtkStateFlags)(state)

	C.gtk_widget_path_iter_set_state(_arg0, _arg1, _arg2)
}

// Length returns the number of Widget #GTypes between the represented widget
// and its topmost container.
func (p *WidgetPath) Length() int {
	var _arg0 *C.GtkWidgetPath // out
	var _cret C.gint           // in

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_widget_path_length(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// PrependType prepends a widget type to the widget hierachy represented by
// @path.
func (p *WidgetPath) PrependType(typ externglib.Type) {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.GType          // out

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
	_arg1 = C.GType(typ)

	C.gtk_widget_path_prepend_type(_arg0, _arg1)
}

// Ref increments the reference count on @path.
func (p *WidgetPath) Ref() *WidgetPath {
	var _arg0 *C.GtkWidgetPath // out
	var _cret *C.GtkWidgetPath // in

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_widget_path_ref(_arg0)

	var _widgetPath *WidgetPath // out

	_widgetPath = WrapWidgetPath(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_widgetPath, func(v *WidgetPath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _widgetPath
}

// String dumps the widget path into a string representation. It tries to match
// the CSS style as closely as possible (Note that there might be paths that
// cannot be represented in CSS).
//
// The main use of this code is for debugging purposes, so that you can
// g_print() the path or dump it in a gdb session.
func (p *WidgetPath) String() string {
	var _arg0 *C.GtkWidgetPath // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))

	_cret = C.gtk_widget_path_to_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Unref decrements the reference count on @path, freeing the structure if the
// reference count reaches 0.
func (p *WidgetPath) Unref() {
	var _arg0 *C.GtkWidgetPath // out

	_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))

	C.gtk_widget_path_unref(_arg0)
}

type WindowGeometryInfo struct {
	native C.GtkWindowGeometryInfo
}

// WrapWindowGeometryInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapWindowGeometryInfo(ptr unsafe.Pointer) *WindowGeometryInfo {
	if ptr == nil {
		return nil
	}

	return (*WindowGeometryInfo)(ptr)
}

// Native returns the underlying C source pointer.
func (w *WindowGeometryInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&w.native)
}
