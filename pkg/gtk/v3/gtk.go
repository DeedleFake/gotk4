// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_align_get_type()), F: marshalAlign},
		{T: externglib.Type(C.gtk_arrow_placement_get_type()), F: marshalArrowPlacement},
		{T: externglib.Type(C.gtk_arrow_type_get_type()), F: marshalArrowType},
		{T: externglib.Type(C.gtk_assistant_page_type_get_type()), F: marshalAssistantPageType},
		{T: externglib.Type(C.gtk_baseline_position_get_type()), F: marshalBaselinePosition},
		{T: externglib.Type(C.gtk_border_style_get_type()), F: marshalBorderStyle},
		{T: externglib.Type(C.gtk_builder_error_get_type()), F: marshalBuilderError},
		{T: externglib.Type(C.gtk_button_box_style_get_type()), F: marshalButtonBoxStyle},
		{T: externglib.Type(C.gtk_button_role_get_type()), F: marshalButtonRole},
		{T: externglib.Type(C.gtk_buttons_type_get_type()), F: marshalButtonsType},
		{T: externglib.Type(C.gtk_cell_renderer_accel_mode_get_type()), F: marshalCellRendererAccelMode},
		{T: externglib.Type(C.gtk_cell_renderer_mode_get_type()), F: marshalCellRendererMode},
		{T: externglib.Type(C.gtk_corner_type_get_type()), F: marshalCornerType},
		{T: externglib.Type(C.gtk_css_provider_error_get_type()), F: marshalCSSProviderError},
		{T: externglib.Type(C.gtk_css_section_type_get_type()), F: marshalCSSSectionType},
		{T: externglib.Type(C.gtk_delete_type_get_type()), F: marshalDeleteType},
		{T: externglib.Type(C.gtk_direction_type_get_type()), F: marshalDirectionType},
		{T: externglib.Type(C.gtk_drag_result_get_type()), F: marshalDragResult},
		{T: externglib.Type(C.gtk_entry_icon_position_get_type()), F: marshalEntryIconPosition},
		{T: externglib.Type(C.gtk_event_sequence_state_get_type()), F: marshalEventSequenceState},
		{T: externglib.Type(C.gtk_expander_style_get_type()), F: marshalExpanderStyle},
		{T: externglib.Type(C.gtk_file_chooser_action_get_type()), F: marshalFileChooserAction},
		{T: externglib.Type(C.gtk_file_chooser_confirmation_get_type()), F: marshalFileChooserConfirmation},
		{T: externglib.Type(C.gtk_file_chooser_error_get_type()), F: marshalFileChooserError},
		{T: externglib.Type(C.gtk_im_preedit_style_get_type()), F: marshalIMPreeditStyle},
		{T: externglib.Type(C.gtk_im_status_style_get_type()), F: marshalIMStatusStyle},
		{T: externglib.Type(C.gtk_icon_size_get_type()), F: marshalIconSize},
		{T: externglib.Type(C.gtk_icon_theme_error_get_type()), F: marshalIconThemeError},
		{T: externglib.Type(C.gtk_icon_view_drop_position_get_type()), F: marshalIconViewDropPosition},
		{T: externglib.Type(C.gtk_image_type_get_type()), F: marshalImageType},
		{T: externglib.Type(C.gtk_input_purpose_get_type()), F: marshalInputPurpose},
		{T: externglib.Type(C.gtk_justification_get_type()), F: marshalJustification},
		{T: externglib.Type(C.gtk_level_bar_mode_get_type()), F: marshalLevelBarMode},
		{T: externglib.Type(C.gtk_license_get_type()), F: marshalLicense},
		{T: externglib.Type(C.gtk_menu_direction_type_get_type()), F: marshalMenuDirectionType},
		{T: externglib.Type(C.gtk_message_type_get_type()), F: marshalMessageType},
		{T: externglib.Type(C.gtk_movement_step_get_type()), F: marshalMovementStep},
		{T: externglib.Type(C.gtk_notebook_tab_get_type()), F: marshalNotebookTab},
		{T: externglib.Type(C.gtk_number_up_layout_get_type()), F: marshalNumberUpLayout},
		{T: externglib.Type(C.gtk_orientation_get_type()), F: marshalOrientation},
		{T: externglib.Type(C.gtk_pack_direction_get_type()), F: marshalPackDirection},
		{T: externglib.Type(C.gtk_pack_type_get_type()), F: marshalPackType},
		{T: externglib.Type(C.gtk_pad_action_type_get_type()), F: marshalPadActionType},
		{T: externglib.Type(C.gtk_page_orientation_get_type()), F: marshalPageOrientation},
		{T: externglib.Type(C.gtk_page_set_get_type()), F: marshalPageSet},
		{T: externglib.Type(C.gtk_pan_direction_get_type()), F: marshalPanDirection},
		{T: externglib.Type(C.gtk_path_priority_type_get_type()), F: marshalPathPriorityType},
		{T: externglib.Type(C.gtk_path_type_get_type()), F: marshalPathType},
		{T: externglib.Type(C.gtk_policy_type_get_type()), F: marshalPolicyType},
		{T: externglib.Type(C.gtk_popover_constraint_get_type()), F: marshalPopoverConstraint},
		{T: externglib.Type(C.gtk_position_type_get_type()), F: marshalPositionType},
		{T: externglib.Type(C.gtk_print_duplex_get_type()), F: marshalPrintDuplex},
		{T: externglib.Type(C.gtk_print_error_get_type()), F: marshalPrintError},
		{T: externglib.Type(C.gtk_print_operation_action_get_type()), F: marshalPrintOperationAction},
		{T: externglib.Type(C.gtk_print_operation_result_get_type()), F: marshalPrintOperationResult},
		{T: externglib.Type(C.gtk_print_pages_get_type()), F: marshalPrintPages},
		{T: externglib.Type(C.gtk_print_quality_get_type()), F: marshalPrintQuality},
		{T: externglib.Type(C.gtk_print_status_get_type()), F: marshalPrintStatus},
		{T: externglib.Type(C.gtk_propagation_phase_get_type()), F: marshalPropagationPhase},
		{T: externglib.Type(C.gtk_rc_token_type_get_type()), F: marshalRCTokenType},
		{T: externglib.Type(C.gtk_recent_chooser_error_get_type()), F: marshalRecentChooserError},
		{T: externglib.Type(C.gtk_recent_manager_error_get_type()), F: marshalRecentManagerError},
		{T: externglib.Type(C.gtk_recent_sort_type_get_type()), F: marshalRecentSortType},
		{T: externglib.Type(C.gtk_relief_style_get_type()), F: marshalReliefStyle},
		{T: externglib.Type(C.gtk_resize_mode_get_type()), F: marshalResizeMode},
		{T: externglib.Type(C.gtk_response_type_get_type()), F: marshalResponseType},
		{T: externglib.Type(C.gtk_revealer_transition_type_get_type()), F: marshalRevealerTransitionType},
		{T: externglib.Type(C.gtk_scroll_step_get_type()), F: marshalScrollStep},
		{T: externglib.Type(C.gtk_scroll_type_get_type()), F: marshalScrollType},
		{T: externglib.Type(C.gtk_scrollable_policy_get_type()), F: marshalScrollablePolicy},
		{T: externglib.Type(C.gtk_selection_mode_get_type()), F: marshalSelectionMode},
		{T: externglib.Type(C.gtk_sensitivity_type_get_type()), F: marshalSensitivityType},
		{T: externglib.Type(C.gtk_shadow_type_get_type()), F: marshalShadowType},
		{T: externglib.Type(C.gtk_shortcut_type_get_type()), F: marshalShortcutType},
		{T: externglib.Type(C.gtk_size_group_mode_get_type()), F: marshalSizeGroupMode},
		{T: externglib.Type(C.gtk_size_request_mode_get_type()), F: marshalSizeRequestMode},
		{T: externglib.Type(C.gtk_sort_type_get_type()), F: marshalSortType},
		{T: externglib.Type(C.gtk_spin_button_update_policy_get_type()), F: marshalSpinButtonUpdatePolicy},
		{T: externglib.Type(C.gtk_spin_type_get_type()), F: marshalSpinType},
		{T: externglib.Type(C.gtk_stack_transition_type_get_type()), F: marshalStackTransitionType},
		{T: externglib.Type(C.gtk_state_type_get_type()), F: marshalStateType},
		{T: externglib.Type(C.gtk_text_buffer_target_info_get_type()), F: marshalTextBufferTargetInfo},
		{T: externglib.Type(C.gtk_text_direction_get_type()), F: marshalTextDirection},
		{T: externglib.Type(C.gtk_text_extend_selection_get_type()), F: marshalTextExtendSelection},
		{T: externglib.Type(C.gtk_text_view_layer_get_type()), F: marshalTextViewLayer},
		{T: externglib.Type(C.gtk_text_window_type_get_type()), F: marshalTextWindowType},
		{T: externglib.Type(C.gtk_toolbar_space_style_get_type()), F: marshalToolbarSpaceStyle},
		{T: externglib.Type(C.gtk_toolbar_style_get_type()), F: marshalToolbarStyle},
		{T: externglib.Type(C.gtk_tree_view_column_sizing_get_type()), F: marshalTreeViewColumnSizing},
		{T: externglib.Type(C.gtk_tree_view_drop_position_get_type()), F: marshalTreeViewDropPosition},
		{T: externglib.Type(C.gtk_tree_view_grid_lines_get_type()), F: marshalTreeViewGridLines},
		{T: externglib.Type(C.gtk_unit_get_type()), F: marshalUnit},
		{T: externglib.Type(C.gtk_widget_help_type_get_type()), F: marshalWidgetHelpType},
		{T: externglib.Type(C.gtk_window_position_get_type()), F: marshalWindowPosition},
		{T: externglib.Type(C.gtk_window_type_get_type()), F: marshalWindowType},
		{T: externglib.Type(C.gtk_wrap_mode_get_type()), F: marshalWrapMode},
		{T: externglib.Type(C.gtk_accel_flags_get_type()), F: marshalAccelFlags},
		{T: externglib.Type(C.gtk_application_inhibit_flags_get_type()), F: marshalApplicationInhibitFlags},
		{T: externglib.Type(C.gtk_attach_options_get_type()), F: marshalAttachOptions},
		{T: externglib.Type(C.gtk_calendar_display_options_get_type()), F: marshalCalendarDisplayOptions},
		{T: externglib.Type(C.gtk_cell_renderer_state_get_type()), F: marshalCellRendererState},
		{T: externglib.Type(C.gtk_debug_flag_get_type()), F: marshalDebugFlag},
		{T: externglib.Type(C.gtk_dest_defaults_get_type()), F: marshalDestDefaults},
		{T: externglib.Type(C.gtk_dialog_flags_get_type()), F: marshalDialogFlags},
		{T: externglib.Type(C.gtk_event_controller_scroll_flags_get_type()), F: marshalEventControllerScrollFlags},
		{T: externglib.Type(C.gtk_file_filter_flags_get_type()), F: marshalFileFilterFlags},
		{T: externglib.Type(C.gtk_font_chooser_level_get_type()), F: marshalFontChooserLevel},
		{T: externglib.Type(C.gtk_icon_lookup_flags_get_type()), F: marshalIconLookupFlags},
		{T: externglib.Type(C.gtk_input_hints_get_type()), F: marshalInputHints},
		{T: externglib.Type(C.gtk_junction_sides_get_type()), F: marshalJunctionSides},
		{T: externglib.Type(C.gtk_places_open_flags_get_type()), F: marshalPlacesOpenFlags},
		{T: externglib.Type(C.gtk_rc_flags_get_type()), F: marshalRCFlags},
		{T: externglib.Type(C.gtk_recent_filter_flags_get_type()), F: marshalRecentFilterFlags},
		{T: externglib.Type(C.gtk_region_flags_get_type()), F: marshalRegionFlags},
		{T: externglib.Type(C.gtk_state_flags_get_type()), F: marshalStateFlags},
		{T: externglib.Type(C.gtk_style_context_print_flags_get_type()), F: marshalStyleContextPrintFlags},
		{T: externglib.Type(C.gtk_target_flags_get_type()), F: marshalTargetFlags},
		{T: externglib.Type(C.gtk_text_search_flags_get_type()), F: marshalTextSearchFlags},
		{T: externglib.Type(C.gtk_tool_palette_drag_targets_get_type()), F: marshalToolPaletteDragTargets},
		{T: externglib.Type(C.gtk_tree_model_flags_get_type()), F: marshalTreeModelFlags},
		{T: externglib.Type(C.gtk_ui_manager_item_type_get_type()), F: marshalUIManagerItemType},
		{T: externglib.Type(C.gtk_app_chooser_get_type()), F: marshalAppChooser},
		{T: externglib.Type(C.gtk_file_chooser_get_type()), F: marshalFileChooser},
		{T: externglib.Type(C.gtk_clipboard_get_type()), F: marshalClipboard},
		{T: externglib.Type(C.gtk_file_filter_get_type()), F: marshalFileFilter},
		{T: externglib.Type(C.gtk_model_button_get_type()), F: marshalModelButton},
		{T: externglib.Type(C.gtk_page_setup_get_type()), F: marshalPageSetup},
		{T: externglib.Type(C.gtk_print_context_get_type()), F: marshalPrintContext},
		{T: externglib.Type(C.gtk_print_settings_get_type()), F: marshalPrintSettings},
		{T: externglib.Type(C.gtk_recent_filter_get_type()), F: marshalRecentFilter},
		{T: externglib.Type(C.gtk_tooltip_get_type()), F: marshalTooltip},
	})
}

// Align controls how a widget deals with extra space in a single (x or y)
// dimension.
//
// Alignment only matters if the widget receives a “too large” allocation, for
// example if you packed the widget with the Widget:expand flag inside a Box,
// then the widget might get extra space. If you have for example a 16x16 icon
// inside a 32x32 space, the icon could be scaled and stretched, it could be
// centered, or it could be positioned to one side of the space.
//
// Note that in horizontal context @GTK_ALIGN_START and @GTK_ALIGN_END are
// interpreted relative to text direction.
//
// GTK_ALIGN_BASELINE support for it is optional for containers and widgets, and
// it is only supported for vertical alignment. When its not supported by a
// child or a container it is treated as @GTK_ALIGN_FILL.
type Align int

const (
	// AlignFill: stretch to fill all space if possible, center if no meaningful
	// way to stretch
	AlignFill Align = 0
	// AlignStart: snap to left or top side, leaving space on right or bottom
	AlignStart Align = 1
	// AlignEnd: snap to right or bottom side, leaving space on left or top
	AlignEnd Align = 2
	// AlignCenter: center natural width of widget inside the allocation
	AlignCenter Align = 3
	// AlignBaseline: align the widget according to the baseline. Since 3.10.
	AlignBaseline Align = 4
)

func marshalAlign(p uintptr) (interface{}, error) {
	return Align(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ArrowPlacement: used to specify the placement of scroll arrows in scrolling
// menus.
type ArrowPlacement int

const (
	// ArrowPlacementBoth: place one arrow on each end of the menu.
	ArrowPlacementBoth ArrowPlacement = 0
	// ArrowPlacementStart: place both arrows at the top of the menu.
	ArrowPlacementStart ArrowPlacement = 1
	// ArrowPlacementEnd: place both arrows at the bottom of the menu.
	ArrowPlacementEnd ArrowPlacement = 2
)

func marshalArrowPlacement(p uintptr) (interface{}, error) {
	return ArrowPlacement(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ArrowType: used to indicate the direction in which an arrow should point.
type ArrowType int

const (
	// ArrowTypeUp represents an upward pointing arrow.
	ArrowTypeUp ArrowType = 0
	// ArrowTypeDown represents a downward pointing arrow.
	ArrowTypeDown ArrowType = 1
	// ArrowTypeLeft represents a left pointing arrow.
	ArrowTypeLeft ArrowType = 2
	// ArrowTypeRight represents a right pointing arrow.
	ArrowTypeRight ArrowType = 3
	// ArrowTypeNone: no arrow. Since 2.10.
	ArrowTypeNone ArrowType = 4
)

func marshalArrowType(p uintptr) (interface{}, error) {
	return ArrowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AssistantPageType: an enum for determining the page role inside the
// Assistant. It's used to handle buttons sensitivity and visibility.
//
// Note that an assistant needs to end its page flow with a page of type
// GTK_ASSISTANT_PAGE_CONFIRM, GTK_ASSISTANT_PAGE_SUMMARY or
// GTK_ASSISTANT_PAGE_PROGRESS to be correct.
//
// The Cancel button will only be shown if the page isn’t “committed”. See
// gtk_assistant_commit() for details.
type AssistantPageType int

const (
	// AssistantPageTypeContent: the page has regular contents. Both the Back
	// and forward buttons will be shown.
	AssistantPageTypeContent AssistantPageType = 0
	// AssistantPageTypeIntro: the page contains an introduction to the
	// assistant task. Only the Forward button will be shown if there is a next
	// page.
	AssistantPageTypeIntro AssistantPageType = 1
	// AssistantPageTypeConfirm: the page lets the user confirm or deny the
	// changes. The Back and Apply buttons will be shown.
	AssistantPageTypeConfirm AssistantPageType = 2
	// AssistantPageTypeSummary: the page informs the user of the changes done.
	// Only the Close button will be shown.
	AssistantPageTypeSummary AssistantPageType = 3
	// AssistantPageTypeProgress: used for tasks that take a long time to
	// complete, blocks the assistant until the page is marked as complete. Only
	// the back button will be shown.
	AssistantPageTypeProgress AssistantPageType = 4
	// AssistantPageTypeCustom: used for when other page types are not
	// appropriate. No buttons will be shown, and the application must add its
	// own buttons through gtk_assistant_add_action_widget().
	AssistantPageTypeCustom AssistantPageType = 5
)

func marshalAssistantPageType(p uintptr) (interface{}, error) {
	return AssistantPageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BaselinePosition: whenever a container has some form of natural row it may
// align children in that row along a common typographical baseline. If the
// amount of verical space in the row is taller than the total requested height
// of the baseline-aligned children then it can use a BaselinePosition to select
// where to put the baseline inside the extra availible space.
type BaselinePosition int

const (
	// BaselinePositionTop: align the baseline at the top
	BaselinePositionTop BaselinePosition = 0
	// BaselinePositionCenter: center the baseline
	BaselinePositionCenter BaselinePosition = 1
	// BaselinePositionBottom: align the baseline at the bottom
	BaselinePositionBottom BaselinePosition = 2
)

func marshalBaselinePosition(p uintptr) (interface{}, error) {
	return BaselinePosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BorderStyle describes how the border of a UI element should be rendered.
type BorderStyle int

const (
	// BorderStyleNone: no visible border
	BorderStyleNone BorderStyle = 0
	// BorderStyleSolid: a single line segment
	BorderStyleSolid BorderStyle = 1
	// BorderStyleInset looks as if the content is sunken into the canvas
	BorderStyleInset BorderStyle = 2
	// BorderStyleOutset looks as if the content is coming out of the canvas
	BorderStyleOutset BorderStyle = 3
	// BorderStyleHidden: same as @GTK_BORDER_STYLE_NONE
	BorderStyleHidden BorderStyle = 4
	// BorderStyleDotted: a series of round dots
	BorderStyleDotted BorderStyle = 5
	// BorderStyleDashed: a series of square-ended dashes
	BorderStyleDashed BorderStyle = 6
	// BorderStyleDouble: two parallel lines with some space between them
	BorderStyleDouble BorderStyle = 7
	// BorderStyleGroove looks as if it were carved in the canvas
	BorderStyleGroove BorderStyle = 8
	// BorderStyleRidge looks as if it were coming out of the canvas
	BorderStyleRidge BorderStyle = 9
)

func marshalBorderStyle(p uintptr) (interface{}, error) {
	return BorderStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BuilderError: error codes that identify various errors that can occur while
// using Builder.
type BuilderError int

const (
	// BuilderErrorInvalidTypeFunction: a type-func attribute didn’t name a
	// function that returns a #GType.
	BuilderErrorInvalidTypeFunction BuilderError = 0
	// BuilderErrorUnhandledTag: the input contained a tag that Builder can’t
	// handle.
	BuilderErrorUnhandledTag BuilderError = 1
	// BuilderErrorMissingAttribute: an attribute that is required by Builder
	// was missing.
	BuilderErrorMissingAttribute BuilderError = 2
	// BuilderErrorInvalidAttribute: Builder found an attribute that it doesn’t
	// understand.
	BuilderErrorInvalidAttribute BuilderError = 3
	// BuilderErrorInvalidTag: Builder found a tag that it doesn’t understand.
	BuilderErrorInvalidTag BuilderError = 4
	// BuilderErrorMissingPropertyValue: a required property value was missing.
	BuilderErrorMissingPropertyValue BuilderError = 5
	// BuilderErrorInvalidValue: Builder couldn’t parse some attribute value.
	BuilderErrorInvalidValue BuilderError = 6
	// BuilderErrorVersionMismatch: the input file requires a newer version of
	// GTK+.
	BuilderErrorVersionMismatch BuilderError = 7
	// BuilderErrorDuplicateID: an object id occurred twice.
	BuilderErrorDuplicateID BuilderError = 8
	// BuilderErrorObjectTypeRefused: a specified object type is of the same
	// type or derived from the type of the composite class being extended with
	// builder XML.
	BuilderErrorObjectTypeRefused BuilderError = 9
	// BuilderErrorTemplateMismatch: the wrong type was specified in a composite
	// class’s template XML
	BuilderErrorTemplateMismatch BuilderError = 10
	// BuilderErrorInvalidProperty: the specified property is unknown for the
	// object class.
	BuilderErrorInvalidProperty BuilderError = 11
	// BuilderErrorInvalidSignal: the specified signal is unknown for the object
	// class.
	BuilderErrorInvalidSignal BuilderError = 12
	// BuilderErrorInvalidID: an object id is unknown
	BuilderErrorInvalidID BuilderError = 13
)

func marshalBuilderError(p uintptr) (interface{}, error) {
	return BuilderError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ButtonBoxStyle: used to dictate the style that a ButtonBox uses to layout the
// buttons it contains.
type ButtonBoxStyle int

const (
	// ButtonBoxStyleSpread buttons are evenly spread across the box.
	ButtonBoxStyleSpread ButtonBoxStyle = 1
	// ButtonBoxStyleEdge buttons are placed at the edges of the box.
	ButtonBoxStyleEdge ButtonBoxStyle = 2
	// ButtonBoxStyleStart buttons are grouped towards the start of the box, (on
	// the left for a HBox, or the top for a VBox).
	ButtonBoxStyleStart ButtonBoxStyle = 3
	// ButtonBoxStyleEnd buttons are grouped towards the end of the box, (on the
	// right for a HBox, or the bottom for a VBox).
	ButtonBoxStyleEnd ButtonBoxStyle = 4
	// ButtonBoxStyleCenter buttons are centered in the box. Since 2.12.
	ButtonBoxStyleCenter ButtonBoxStyle = 5
	// ButtonBoxStyleExpand buttons expand to fill the box. This entails giving
	// buttons a "linked" appearance, making button sizes homogeneous, and
	// setting spacing to 0 (same as calling gtk_box_set_homogeneous() and
	// gtk_box_set_spacing() manually). Since 3.12.
	ButtonBoxStyleExpand ButtonBoxStyle = 6
)

func marshalButtonBoxStyle(p uintptr) (interface{}, error) {
	return ButtonBoxStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ButtonRole: the role specifies the desired appearance of a ModelButton.
type ButtonRole int

const (
	// ButtonRoleNormal: a plain button
	ButtonRoleNormal ButtonRole = 0
	// ButtonRoleCheck: a check button
	ButtonRoleCheck ButtonRole = 1
	// ButtonRoleRadio: a radio button
	ButtonRoleRadio ButtonRole = 2
)

func marshalButtonRole(p uintptr) (interface{}, error) {
	return ButtonRole(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ButtonsType: prebuilt sets of buttons for the dialog. If none of these
// choices are appropriate, simply use GTK_BUTTONS_NONE then call
// gtk_dialog_add_buttons().
//
// > Please note that GTK_BUTTONS_OK, GTK_BUTTONS_YES_NO > and
// GTK_BUTTONS_OK_CANCEL are discouraged by the > GNOME Human Interface
// Guidelines (http://library.gnome.org/devel/hig-book/stable/).
type ButtonsType int

const (
	// ButtonsTypeNone: no buttons at all
	ButtonsTypeNone ButtonsType = 0
	// ButtonsTypeOk: an OK button
	ButtonsTypeOk ButtonsType = 1
	// ButtonsTypeClose: a Close button
	ButtonsTypeClose ButtonsType = 2
	// ButtonsTypeCancel: a Cancel button
	ButtonsTypeCancel ButtonsType = 3
	// ButtonsTypeYesNo yes and No buttons
	ButtonsTypeYesNo ButtonsType = 4
	// ButtonsTypeOkCancel: OK and Cancel buttons
	ButtonsTypeOkCancel ButtonsType = 5
)

func marshalButtonsType(p uintptr) (interface{}, error) {
	return ButtonsType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CellRendererAccelMode determines if the edited accelerators are GTK+
// accelerators. If they are, consumed modifiers are suppressed, only
// accelerators accepted by GTK+ are allowed, and the accelerators are rendered
// in the same way as they are in menus.
type CellRendererAccelMode int

const (
	// CellRendererAccelModeGTK: GTK+ accelerators mode
	CellRendererAccelModeGTK CellRendererAccelMode = 0
	// CellRendererAccelModeOther: other accelerator mode
	CellRendererAccelModeOther CellRendererAccelMode = 1
)

func marshalCellRendererAccelMode(p uintptr) (interface{}, error) {
	return CellRendererAccelMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CellRendererMode identifies how the user can interact with a particular cell.
type CellRendererMode int

const (
	// CellRendererModeInert: the cell is just for display and cannot be
	// interacted with. Note that this doesn’t mean that eg. the row being drawn
	// can’t be selected -- just that a particular element of it cannot be
	// individually modified.
	CellRendererModeInert CellRendererMode = 0
	// CellRendererModeActivatable: the cell can be clicked.
	CellRendererModeActivatable CellRendererMode = 1
	// CellRendererModeEditable: the cell can be edited or otherwise modified.
	CellRendererModeEditable CellRendererMode = 2
)

func marshalCellRendererMode(p uintptr) (interface{}, error) {
	return CellRendererMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CornerType specifies which corner a child widget should be placed in when
// packed into a ScrolledWindow. This is effectively the opposite of where the
// scroll bars are placed.
type CornerType int

const (
	// CornerTypeTopLeft: place the scrollbars on the right and bottom of the
	// widget (default behaviour).
	CornerTypeTopLeft CornerType = 0
	// CornerTypeBottomLeft: place the scrollbars on the top and right of the
	// widget.
	CornerTypeBottomLeft CornerType = 1
	// CornerTypeTopRight: place the scrollbars on the left and bottom of the
	// widget.
	CornerTypeTopRight CornerType = 2
	// CornerTypeBottomRight: place the scrollbars on the top and left of the
	// widget.
	CornerTypeBottomRight CornerType = 3
)

func marshalCornerType(p uintptr) (interface{}, error) {
	return CornerType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CSSProviderError: error codes for GTK_CSS_PROVIDER_ERROR.
type CSSProviderError int

const (
	// CSSProviderErrorFailed: failed.
	CSSProviderErrorFailed CSSProviderError = 0
	// CSSProviderErrorSyntax: syntax error.
	CSSProviderErrorSyntax CSSProviderError = 1
	// CSSProviderErrorImport: import error.
	CSSProviderErrorImport CSSProviderError = 2
	// CSSProviderErrorName: name error.
	CSSProviderErrorName CSSProviderError = 3
	// CSSProviderErrorDeprecated: deprecation error.
	CSSProviderErrorDeprecated CSSProviderError = 4
	// CSSProviderErrorUnknownValue: unknown value.
	CSSProviderErrorUnknownValue CSSProviderError = 5
)

func marshalCSSProviderError(p uintptr) (interface{}, error) {
	return CSSProviderError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CSSSectionType: the different types of sections indicate parts of a CSS
// document as parsed by GTK’s CSS parser. They are oriented towards the CSS
// Grammar (http://www.w3.org/TR/CSS21/grammar.html), but may contain
// extensions.
//
// More types might be added in the future as the parser incorporates more
// features.
type CSSSectionType int

const (
	// CSSSectionTypeDocument: the section describes a complete document. This
	// section time is the only one where gtk_css_section_get_parent() might
	// return nil.
	CSSSectionTypeDocument CSSSectionType = 0
	// CSSSectionTypeImport: the section defines an import rule.
	CSSSectionTypeImport CSSSectionType = 1
	// CSSSectionTypeColorDefinition: the section defines a color. This is a GTK
	// extension to CSS.
	CSSSectionTypeColorDefinition CSSSectionType = 2
	// CSSSectionTypeBindingSet: the section defines a binding set. This is a
	// GTK extension to CSS.
	CSSSectionTypeBindingSet CSSSectionType = 3
	// CSSSectionTypeRuleset: the section defines a CSS ruleset.
	CSSSectionTypeRuleset CSSSectionType = 4
	// CSSSectionTypeSelector: the section defines a CSS selector.
	CSSSectionTypeSelector CSSSectionType = 5
	// CSSSectionTypeDeclaration: the section defines the declaration of a CSS
	// variable.
	CSSSectionTypeDeclaration CSSSectionType = 6
	// CSSSectionTypeValue: the section defines the value of a CSS declaration.
	CSSSectionTypeValue CSSSectionType = 7
	// CSSSectionTypeKeyframes: the section defines keyframes. See [CSS
	// Animations](http://dev.w3.org/csswg/css3-animations/#keyframes) for
	// details. Since 3.6
	CSSSectionTypeKeyframes CSSSectionType = 8
)

func marshalCSSSectionType(p uintptr) (interface{}, error) {
	return CSSSectionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DeleteType: see also: Entry::delete-from-cursor.
type DeleteType int

const (
	// DeleteTypeChars: delete characters.
	DeleteTypeChars DeleteType = 0
	// DeleteTypeWordEnds: delete only the portion of the word to the left/right
	// of cursor if we’re in the middle of a word.
	DeleteTypeWordEnds DeleteType = 1
	// DeleteTypeWords: delete words.
	DeleteTypeWords DeleteType = 2
	// DeleteTypeDisplayLines: delete display-lines. Display-lines refers to the
	// visible lines, with respect to to the current line breaks. As opposed to
	// paragraphs, which are defined by line breaks in the input.
	DeleteTypeDisplayLines DeleteType = 3
	// DeleteTypeDisplayLineEnds: delete only the portion of the display-line to
	// the left/right of cursor.
	DeleteTypeDisplayLineEnds DeleteType = 4
	// DeleteTypeParagraphEnds: delete to the end of the paragraph. Like C-k in
	// Emacs (or its reverse).
	DeleteTypeParagraphEnds DeleteType = 5
	// DeleteTypeParagraphs: delete entire line. Like C-k in pico.
	DeleteTypeParagraphs DeleteType = 6
	// DeleteTypeWhitespace: delete only whitespace. Like M-\ in Emacs.
	DeleteTypeWhitespace DeleteType = 7
)

func marshalDeleteType(p uintptr) (interface{}, error) {
	return DeleteType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DirectionType focus movement types.
type DirectionType int

const (
	// DirectionTypeTabForward: move forward.
	DirectionTypeTabForward DirectionType = 0
	// DirectionTypeTabBackward: move backward.
	DirectionTypeTabBackward DirectionType = 1
	// DirectionTypeUp: move up.
	DirectionTypeUp DirectionType = 2
	// DirectionTypeDown: move down.
	DirectionTypeDown DirectionType = 3
	// DirectionTypeLeft: move left.
	DirectionTypeLeft DirectionType = 4
	// DirectionTypeRight: move right.
	DirectionTypeRight DirectionType = 5
)

func marshalDirectionType(p uintptr) (interface{}, error) {
	return DirectionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DragResult gives an indication why a drag operation failed. The value can by
// obtained by connecting to the Widget::drag-failed signal.
type DragResult int

const (
	// DragResultSuccess: the drag operation was successful.
	DragResultSuccess DragResult = 0
	// DragResultNoTarget: no suitable drag target.
	DragResultNoTarget DragResult = 1
	// DragResultUserCancelled: the user cancelled the drag operation.
	DragResultUserCancelled DragResult = 2
	// DragResultTimeoutExpired: the drag operation timed out.
	DragResultTimeoutExpired DragResult = 3
	// DragResultGrabBroken: the pointer or keyboard grab used for the drag
	// operation was broken.
	DragResultGrabBroken DragResult = 4
	// DragResultError: the drag operation failed due to some unspecified error.
	DragResultError DragResult = 5
)

func marshalDragResult(p uintptr) (interface{}, error) {
	return DragResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EntryIconPosition specifies the side of the entry at which an icon is placed.
type EntryIconPosition int

const (
	// EntryIconPositionPrimary: at the beginning of the entry (depending on the
	// text direction).
	EntryIconPositionPrimary EntryIconPosition = 0
	// EntryIconPositionSecondary: at the end of the entry (depending on the
	// text direction).
	EntryIconPositionSecondary EntryIconPosition = 1
)

func marshalEntryIconPosition(p uintptr) (interface{}, error) {
	return EntryIconPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EventSequenceState describes the state of a EventSequence in a Gesture.
type EventSequenceState int

const (
	// EventSequenceStateNone: the sequence is handled, but not grabbed.
	EventSequenceStateNone EventSequenceState = 0
	// EventSequenceStateClaimed: the sequence is handled and grabbed.
	EventSequenceStateClaimed EventSequenceState = 1
	// EventSequenceStateDenied: the sequence is denied.
	EventSequenceStateDenied EventSequenceState = 2
)

func marshalEventSequenceState(p uintptr) (interface{}, error) {
	return EventSequenceState(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ExpanderStyle: used to specify the style of the expanders drawn by a
// TreeView.
type ExpanderStyle int

const (
	// ExpanderStyleCollapsed: the style used for a collapsed subtree.
	ExpanderStyleCollapsed ExpanderStyle = 0
	// ExpanderStyleSemiCollapsed: intermediate style used during animation.
	ExpanderStyleSemiCollapsed ExpanderStyle = 1
	// ExpanderStyleSemiExpanded: intermediate style used during animation.
	ExpanderStyleSemiExpanded ExpanderStyle = 2
	// ExpanderStyleExpanded: the style used for an expanded subtree.
	ExpanderStyleExpanded ExpanderStyle = 3
)

func marshalExpanderStyle(p uintptr) (interface{}, error) {
	return ExpanderStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileChooserAction describes whether a FileChooser is being used to open
// existing files or to save to a possibly new file.
type FileChooserAction int

const (
	// FileChooserActionOpen indicates open mode. The file chooser will only let
	// the user pick an existing file.
	FileChooserActionOpen FileChooserAction = 0
	// FileChooserActionSave indicates save mode. The file chooser will let the
	// user pick an existing file, or type in a new filename.
	FileChooserActionSave FileChooserAction = 1
	// FileChooserActionSelectFolder indicates an Open mode for selecting
	// folders. The file chooser will let the user pick an existing folder.
	FileChooserActionSelectFolder FileChooserAction = 2
	// FileChooserActionCreateFolder indicates a mode for creating a new folder.
	// The file chooser will let the user name an existing or new folder.
	FileChooserActionCreateFolder FileChooserAction = 3
)

func marshalFileChooserAction(p uintptr) (interface{}, error) {
	return FileChooserAction(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileChooserConfirmation: used as a return value of handlers for the
// FileChooser::confirm-overwrite signal of a FileChooser. This value determines
// whether the file chooser will present the stock confirmation dialog, accept
// the user’s choice of a filename, or let the user choose another filename.
type FileChooserConfirmation int

const (
	// FileChooserConfirmationConfirm: the file chooser will present its stock
	// dialog to confirm about overwriting an existing file.
	FileChooserConfirmationConfirm FileChooserConfirmation = 0
	// FileChooserConfirmationAcceptFilename: the file chooser will terminate
	// and accept the user’s choice of a file name.
	FileChooserConfirmationAcceptFilename FileChooserConfirmation = 1
	// FileChooserConfirmationSelectAgain: the file chooser will continue
	// running, so as to let the user select another file name.
	FileChooserConfirmationSelectAgain FileChooserConfirmation = 2
)

func marshalFileChooserConfirmation(p uintptr) (interface{}, error) {
	return FileChooserConfirmation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileChooserError: these identify the various errors that can occur while
// calling FileChooser functions.
type FileChooserError int

const (
	// FileChooserErrorNonexistent indicates that a file does not exist.
	FileChooserErrorNonexistent FileChooserError = 0
	// FileChooserErrorBadFilename indicates a malformed filename.
	FileChooserErrorBadFilename FileChooserError = 1
	// FileChooserErrorAlreadyExists indicates a duplicate path (e.g. when
	// adding a bookmark).
	FileChooserErrorAlreadyExists FileChooserError = 2
	// FileChooserErrorIncompleteHostname indicates an incomplete hostname (e.g.
	// "http://foo" without a slash after that).
	FileChooserErrorIncompleteHostname FileChooserError = 3
)

func marshalFileChooserError(p uintptr) (interface{}, error) {
	return FileChooserError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IMPreeditStyle: style for input method preedit. See also
// Settings:gtk-im-preedit-style
type IMPreeditStyle int

const (
	// IMPreeditStyleNothing: deprecated
	IMPreeditStyleNothing IMPreeditStyle = 0
	// IMPreeditStyleCallback: deprecated
	IMPreeditStyleCallback IMPreeditStyle = 1
	// IMPreeditStyleNone: deprecated
	IMPreeditStyleNone IMPreeditStyle = 2
)

func marshalIMPreeditStyle(p uintptr) (interface{}, error) {
	return IMPreeditStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IMStatusStyle: style for input method status. See also
// Settings:gtk-im-status-style
type IMStatusStyle int

const (
	// IMStatusStyleNothing: deprecated
	IMStatusStyleNothing IMStatusStyle = 0
	// IMStatusStyleCallback: deprecated
	IMStatusStyleCallback IMStatusStyle = 1
	// IMStatusStyleNone: deprecated
	IMStatusStyleNone IMStatusStyle = 2
)

func marshalIMStatusStyle(p uintptr) (interface{}, error) {
	return IMStatusStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconSize: built-in stock icon sizes.
type IconSize int

const (
	// IconSizeInvalid: invalid size.
	IconSizeInvalid IconSize = 0
	// IconSizeMenu: size appropriate for menus (16px).
	IconSizeMenu IconSize = 1
	// IconSizeSmallToolbar: size appropriate for small toolbars (16px).
	IconSizeSmallToolbar IconSize = 2
	// IconSizeLargeToolbar: size appropriate for large toolbars (24px)
	IconSizeLargeToolbar IconSize = 3
	// IconSizeButton: size appropriate for buttons (16px)
	IconSizeButton IconSize = 4
	// IconSizeDnd: size appropriate for drag and drop (32px)
	IconSizeDnd IconSize = 5
	// IconSizeDialog: size appropriate for dialogs (48px)
	IconSizeDialog IconSize = 6
)

func marshalIconSize(p uintptr) (interface{}, error) {
	return IconSize(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconThemeError: error codes for GtkIconTheme operations.
type IconThemeError int

const (
	// IconThemeErrorNotFound: the icon specified does not exist in the theme
	IconThemeErrorNotFound IconThemeError = 0
	// IconThemeErrorFailed: an unspecified error occurred.
	IconThemeErrorFailed IconThemeError = 1
)

func marshalIconThemeError(p uintptr) (interface{}, error) {
	return IconThemeError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconViewDropPosition: an enum for determining where a dropped item goes.
type IconViewDropPosition int

const (
	// IconViewDropPositionNoDrop: no drop possible
	IconViewDropPositionNoDrop IconViewDropPosition = 0
	// IconViewDropPositionDropInto: dropped item replaces the item
	IconViewDropPositionDropInto IconViewDropPosition = 1
	// IconViewDropPositionDropLeft: droppped item is inserted to the left
	IconViewDropPositionDropLeft IconViewDropPosition = 2
	// IconViewDropPositionDropRight: dropped item is inserted to the right
	IconViewDropPositionDropRight IconViewDropPosition = 3
	// IconViewDropPositionDropAbove: dropped item is inserted above
	IconViewDropPositionDropAbove IconViewDropPosition = 4
	// IconViewDropPositionDropBelow: dropped item is inserted below
	IconViewDropPositionDropBelow IconViewDropPosition = 5
)

func marshalIconViewDropPosition(p uintptr) (interface{}, error) {
	return IconViewDropPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ImageType describes the image data representation used by a Image. If you
// want to get the image from the widget, you can only get the currently-stored
// representation. e.g. if the gtk_image_get_storage_type() returns
// K_IMAGE_PIXBUF, then you can call gtk_image_get_pixbuf() but not
// gtk_image_get_stock(). For empty images, you can request any storage type
// (call any of the "get" functions), but they will all return nil values.
type ImageType int

const (
	// ImageTypeEmpty: there is no image displayed by the widget
	ImageTypeEmpty ImageType = 0
	// ImageTypePixbuf: the widget contains a Pixbuf
	ImageTypePixbuf ImageType = 1
	// ImageTypeStock: the widget contains a [stock item name][gtkstock]
	ImageTypeStock ImageType = 2
	// ImageTypeIconSet: the widget contains a IconSet
	ImageTypeIconSet ImageType = 3
	// ImageTypeAnimation: the widget contains a PixbufAnimation
	ImageTypeAnimation ImageType = 4
	// ImageTypeIconName: the widget contains a named icon. This image type was
	// added in GTK+ 2.6
	ImageTypeIconName ImageType = 5
	// ImageTypeGIcon: the widget contains a #GIcon. This image type was added
	// in GTK+ 2.14
	ImageTypeGIcon ImageType = 6
	// ImageTypeSurface: the widget contains a #cairo_surface_t. This image type
	// was added in GTK+ 3.10
	ImageTypeSurface ImageType = 7
)

func marshalImageType(p uintptr) (interface{}, error) {
	return ImageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// InputPurpose describes primary purpose of the input widget. This information
// is useful for on-screen keyboards and similar input methods to decide which
// keys should be presented to the user.
//
// Note that the purpose is not meant to impose a totally strict rule about
// allowed characters, and does not replace input validation. It is fine for an
// on-screen keyboard to let the user override the character set restriction
// that is expressed by the purpose. The application is expected to validate the
// entry contents, even if it specified a purpose.
//
// The difference between @GTK_INPUT_PURPOSE_DIGITS and
// @GTK_INPUT_PURPOSE_NUMBER is that the former accepts only digits while the
// latter also some punctuation (like commas or points, plus, minus) and “e” or
// “E” as in 3.14E+000.
//
// This enumeration may be extended in the future; input methods should
// interpret unknown values as “free form”.
type InputPurpose int

const (
	// InputPurposeFreeForm: allow any character
	InputPurposeFreeForm InputPurpose = 0
	// InputPurposeAlpha: allow only alphabetic characters
	InputPurposeAlpha InputPurpose = 1
	// InputPurposeDigits: allow only digits
	InputPurposeDigits InputPurpose = 2
	// InputPurposeNumber: edited field expects numbers
	InputPurposeNumber InputPurpose = 3
	// InputPurposePhone: edited field expects phone number
	InputPurposePhone InputPurpose = 4
	// InputPurposeURL: edited field expects URL
	InputPurposeURL InputPurpose = 5
	// InputPurposeEmail: edited field expects email address
	InputPurposeEmail InputPurpose = 6
	// InputPurposeName: edited field expects the name of a person
	InputPurposeName InputPurpose = 7
	// InputPurposePassword: like @GTK_INPUT_PURPOSE_FREE_FORM, but characters
	// are hidden
	InputPurposePassword InputPurpose = 8
	// InputPurposePin: like @GTK_INPUT_PURPOSE_DIGITS, but characters are
	// hidden
	InputPurposePin InputPurpose = 9
	// InputPurposeTerminal: allow any character, in addition to control codes
	InputPurposeTerminal InputPurpose = 10
)

func marshalInputPurpose(p uintptr) (interface{}, error) {
	return InputPurpose(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Justification: used for justifying the text inside a Label widget. (See also
// Alignment).
type Justification int

const (
	// JustificationLeft: the text is placed at the left edge of the label.
	JustificationLeft Justification = 0
	// JustificationRight: the text is placed at the right edge of the label.
	JustificationRight Justification = 1
	// JustificationCenter: the text is placed in the center of the label.
	JustificationCenter Justification = 2
	// JustificationFill: the text is placed is distributed across the label.
	JustificationFill Justification = 3
)

func marshalJustification(p uintptr) (interface{}, error) {
	return Justification(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// LevelBarMode describes how LevelBar contents should be rendered. Note that
// this enumeration could be extended with additional modes in the future.
type LevelBarMode int

const (
	// LevelBarModeContinuous: the bar has a continuous mode
	LevelBarModeContinuous LevelBarMode = 0
	// LevelBarModeDiscrete: the bar has a discrete mode
	LevelBarModeDiscrete LevelBarMode = 1
)

func marshalLevelBarMode(p uintptr) (interface{}, error) {
	return LevelBarMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// License: the type of license for an application.
//
// This enumeration can be expanded at later date.
type License int

const (
	// LicenseUnknown: no license specified
	LicenseUnknown License = 0
	// LicenseCustom: a license text is going to be specified by the developer
	LicenseCustom License = 1
	// LicenseGPL20: the GNU General Public License, version 2.0 or later
	LicenseGPL20 License = 2
	// LicenseGPL30: the GNU General Public License, version 3.0 or later
	LicenseGPL30 License = 3
	// LicenseLGPL21: the GNU Lesser General Public License, version 2.1 or
	// later
	LicenseLGPL21 License = 4
	// LicenseLGPL30: the GNU Lesser General Public License, version 3.0 or
	// later
	LicenseLGPL30 License = 5
	// LicenseBSD: the BSD standard license
	LicenseBSD License = 6
	// LicenseMITX11: the MIT/X11 standard license
	LicenseMITX11 License = 7
	// LicenseArtistic: the Artistic License, version 2.0
	LicenseArtistic License = 8
	// LicenseGPL20Only: the GNU General Public License, version 2.0 only. Since
	// 3.12.
	LicenseGPL20Only License = 9
	// LicenseGPL30Only: the GNU General Public License, version 3.0 only. Since
	// 3.12.
	LicenseGPL30Only License = 10
	// LicenseLGPL21Only: the GNU Lesser General Public License, version 2.1
	// only. Since 3.12.
	LicenseLGPL21Only License = 11
	// LicenseLGPL30Only: the GNU Lesser General Public License, version 3.0
	// only. Since 3.12.
	LicenseLGPL30Only License = 12
	// LicenseAGPL30: the GNU Affero General Public License, version 3.0 or
	// later. Since: 3.22.
	LicenseAGPL30 License = 13
	// LicenseAGPL30Only: the GNU Affero General Public License, version 3.0
	// only. Since: 3.22.27.
	LicenseAGPL30Only License = 14
	// LicenseBSD3: the 3-clause BSD licence. Since: 3.24.20.
	LicenseBSD3 License = 15
	// LicenseApache20: the Apache License, version 2.0. Since: 3.24.20.
	LicenseApache20 License = 16
	// LicenseMPL20: the Mozilla Public License, version 2.0. Since: 3.24.20.
	LicenseMPL20 License = 17
)

func marshalLicense(p uintptr) (interface{}, error) {
	return License(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MenuDirectionType: an enumeration representing directional movements within a
// menu.
type MenuDirectionType int

const (
	// MenuDirectionTypeParent: to the parent menu shell
	MenuDirectionTypeParent MenuDirectionType = 0
	// MenuDirectionTypeChild: to the submenu, if any, associated with the item
	MenuDirectionTypeChild MenuDirectionType = 1
	// MenuDirectionTypeNext: to the next menu item
	MenuDirectionTypeNext MenuDirectionType = 2
	// MenuDirectionTypePrev: to the previous menu item
	MenuDirectionTypePrev MenuDirectionType = 3
)

func marshalMenuDirectionType(p uintptr) (interface{}, error) {
	return MenuDirectionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MessageType: the type of message being displayed in the dialog.
type MessageType int

const (
	// MessageTypeInfo: informational message
	MessageTypeInfo MessageType = 0
	// MessageTypeWarning: non-fatal warning message
	MessageTypeWarning MessageType = 1
	// MessageTypeQuestion: question requiring a choice
	MessageTypeQuestion MessageType = 2
	// MessageTypeError: fatal error message
	MessageTypeError MessageType = 3
	// MessageTypeOther: none of the above
	MessageTypeOther MessageType = 4
)

func marshalMessageType(p uintptr) (interface{}, error) {
	return MessageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

type MovementStep int

const (
	// MovementStepLogicalPositions: move forward or back by graphemes
	MovementStepLogicalPositions MovementStep = 0
	// MovementStepVisualPositions: move left or right by graphemes
	MovementStepVisualPositions MovementStep = 1
	// MovementStepWords: move forward or back by words
	MovementStepWords MovementStep = 2
	// MovementStepDisplayLines: move up or down lines (wrapped lines)
	MovementStepDisplayLines MovementStep = 3
	// MovementStepDisplayLineEnds: move to either end of a line
	MovementStepDisplayLineEnds MovementStep = 4
	// MovementStepParagraphs: move up or down paragraphs (newline-ended lines)
	MovementStepParagraphs MovementStep = 5
	// MovementStepParagraphEnds: move to either end of a paragraph
	MovementStepParagraphEnds MovementStep = 6
	// MovementStepPages: move by pages
	MovementStepPages MovementStep = 7
	// MovementStepBufferEnds: move to ends of the buffer
	MovementStepBufferEnds MovementStep = 8
	// MovementStepHorizontalPages: move horizontally by pages
	MovementStepHorizontalPages MovementStep = 9
)

func marshalMovementStep(p uintptr) (interface{}, error) {
	return MovementStep(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

type NotebookTab int

const (
	NotebookTabFirst NotebookTab = 0
	NotebookTabLast  NotebookTab = 1
)

func marshalNotebookTab(p uintptr) (interface{}, error) {
	return NotebookTab(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// NumberUpLayout: used to determine the layout of pages on a sheet when
// printing multiple pages per sheet.
type NumberUpLayout int

const (
	// NumberUpLayoutLrtb: ! (layout-lrtb.png)
	NumberUpLayoutLrtb NumberUpLayout = 0
	// NumberUpLayoutLrbt: ! (layout-lrbt.png)
	NumberUpLayoutLrbt NumberUpLayout = 1
	// NumberUpLayoutRltb: ! (layout-rltb.png)
	NumberUpLayoutRltb NumberUpLayout = 2
	// NumberUpLayoutRlbt: ! (layout-rlbt.png)
	NumberUpLayoutRlbt NumberUpLayout = 3
	// NumberUpLayoutTblr: ! (layout-tblr.png)
	NumberUpLayoutTblr NumberUpLayout = 4
	// NumberUpLayoutTbrl: ! (layout-tbrl.png)
	NumberUpLayoutTbrl NumberUpLayout = 5
	// NumberUpLayoutBtlr: ! (layout-btlr.png)
	NumberUpLayoutBtlr NumberUpLayout = 6
	// NumberUpLayoutBtrl: ! (layout-btrl.png)
	NumberUpLayoutBtrl NumberUpLayout = 7
)

func marshalNumberUpLayout(p uintptr) (interface{}, error) {
	return NumberUpLayout(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Orientation represents the orientation of widgets and other objects which can
// be switched between horizontal and vertical orientation on the fly, like
// Toolbar or GesturePan.
type Orientation int

const (
	// OrientationHorizontal: the element is in horizontal orientation.
	OrientationHorizontal Orientation = 0
	// OrientationVertical: the element is in vertical orientation.
	OrientationVertical Orientation = 1
)

func marshalOrientation(p uintptr) (interface{}, error) {
	return Orientation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PackDirection determines how widgets should be packed inside menubars and
// menuitems contained in menubars.
type PackDirection int

const (
	// PackDirectionLTR widgets are packed left-to-right
	PackDirectionLTR PackDirection = 0
	// PackDirectionRTL widgets are packed right-to-left
	PackDirectionRTL PackDirection = 1
	// PackDirectionTtb widgets are packed top-to-bottom
	PackDirectionTtb PackDirection = 2
	// PackDirectionBtt widgets are packed bottom-to-top
	PackDirectionBtt PackDirection = 3
)

func marshalPackDirection(p uintptr) (interface{}, error) {
	return PackDirection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PackType represents the packing location Box children. (See: VBox, HBox, and
// ButtonBox).
type PackType int

const (
	// PackTypeStart: the child is packed into the start of the box
	PackTypeStart PackType = 0
	// PackTypeEnd: the child is packed into the end of the box
	PackTypeEnd PackType = 1
)

func marshalPackType(p uintptr) (interface{}, error) {
	return PackType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PadActionType: the type of a pad action.
type PadActionType int

const (
	// PadActionTypeButton: action is triggered by a pad button
	PadActionTypeButton PadActionType = 0
	// PadActionTypeRing: action is triggered by a pad ring
	PadActionTypeRing PadActionType = 1
	// PadActionTypeStrip: action is triggered by a pad strip
	PadActionTypeStrip PadActionType = 2
)

func marshalPadActionType(p uintptr) (interface{}, error) {
	return PadActionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PageOrientation: see also gtk_print_settings_set_orientation().
type PageOrientation int

const (
	// PageOrientationPortrait: portrait mode.
	PageOrientationPortrait PageOrientation = 0
	// PageOrientationLandscape: landscape mode.
	PageOrientationLandscape PageOrientation = 1
	// PageOrientationReversePortrait: reverse portrait mode.
	PageOrientationReversePortrait PageOrientation = 2
	// PageOrientationReverseLandscape: reverse landscape mode.
	PageOrientationReverseLandscape PageOrientation = 3
)

func marshalPageOrientation(p uintptr) (interface{}, error) {
	return PageOrientation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PageSet: see also gtk_print_job_set_page_set().
type PageSet int

const (
	// PageSetAll: all pages.
	PageSetAll PageSet = 0
	// PageSetEven: even pages.
	PageSetEven PageSet = 1
	// PageSetOdd: odd pages.
	PageSetOdd PageSet = 2
)

func marshalPageSet(p uintptr) (interface{}, error) {
	return PageSet(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PanDirection describes the panning direction of a GesturePan
type PanDirection int

const (
	// PanDirectionLeft: panned towards the left
	PanDirectionLeft PanDirection = 0
	// PanDirectionRight: panned towards the right
	PanDirectionRight PanDirection = 1
	// PanDirectionUp: panned upwards
	PanDirectionUp PanDirection = 2
	// PanDirectionDown: panned downwards
	PanDirectionDown PanDirection = 3
)

func marshalPanDirection(p uintptr) (interface{}, error) {
	return PanDirection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PathPriorityType priorities for path lookups. See also
// gtk_binding_set_add_path().
type PathPriorityType int

const (
	// PathPriorityTypeLowest: deprecated
	PathPriorityTypeLowest PathPriorityType = 0
	// PathPriorityTypeGTK: deprecated
	PathPriorityTypeGTK PathPriorityType = 4
	// PathPriorityTypeApplication: deprecated
	PathPriorityTypeApplication PathPriorityType = 8
	// PathPriorityTypeTheme: deprecated
	PathPriorityTypeTheme PathPriorityType = 10
	// PathPriorityTypeRC: deprecated
	PathPriorityTypeRC PathPriorityType = 12
	// PathPriorityTypeHighest: deprecated
	PathPriorityTypeHighest PathPriorityType = 15
)

func marshalPathPriorityType(p uintptr) (interface{}, error) {
	return PathPriorityType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PathType: widget path types. See also gtk_binding_set_add_path().
type PathType int

const (
	// PathTypeWidget: deprecated
	PathTypeWidget PathType = 0
	// PathTypeWidgetClass: deprecated
	PathTypeWidgetClass PathType = 1
	// PathTypeClass: deprecated
	PathTypeClass PathType = 2
)

func marshalPathType(p uintptr) (interface{}, error) {
	return PathType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PolicyType determines how the size should be computed to achieve the one of
// the visibility mode for the scrollbars.
type PolicyType int

const (
	// PolicyTypeAlways: the scrollbar is always visible. The view size is
	// independent of the content.
	PolicyTypeAlways PolicyType = 0
	// PolicyTypeAutomatic: the scrollbar will appear and disappear as
	// necessary. For example, when all of a TreeView can not be seen.
	PolicyTypeAutomatic PolicyType = 1
	// PolicyTypeNever: the scrollbar should never appear. In this mode the
	// content determines the size.
	PolicyTypeNever PolicyType = 2
	// PolicyTypeExternal: don't show a scrollbar, but don't force the size to
	// follow the content. This can be used e.g. to make multiple scrolled
	// windows share a scrollbar. Since: 3.16
	PolicyTypeExternal PolicyType = 3
)

func marshalPolicyType(p uintptr) (interface{}, error) {
	return PolicyType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PopoverConstraint describes constraints to positioning of popovers. More
// values may be added to this enumeration in the future.
type PopoverConstraint int

const (
	// PopoverConstraintNone: don't constrain the popover position beyond what
	// is imposed by the implementation
	PopoverConstraintNone PopoverConstraint = 0
	// PopoverConstraintWindow: constrain the popover to the boundaries of the
	// window that it is attached to
	PopoverConstraintWindow PopoverConstraint = 1
)

func marshalPopoverConstraint(p uintptr) (interface{}, error) {
	return PopoverConstraint(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PositionType describes which edge of a widget a certain feature is positioned
// at, e.g. the tabs of a Notebook, the handle of a HandleBox or the label of a
// Scale.
type PositionType int

const (
	// PositionTypeLeft: the feature is at the left edge.
	PositionTypeLeft PositionType = 0
	// PositionTypeRight: the feature is at the right edge.
	PositionTypeRight PositionType = 1
	// PositionTypeTop: the feature is at the top edge.
	PositionTypeTop PositionType = 2
	// PositionTypeBottom: the feature is at the bottom edge.
	PositionTypeBottom PositionType = 3
)

func marshalPositionType(p uintptr) (interface{}, error) {
	return PositionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintDuplex: see also gtk_print_settings_set_duplex().
type PrintDuplex int

const (
	// PrintDuplexSimplex: no duplex.
	PrintDuplexSimplex PrintDuplex = 0
	// PrintDuplexHorizontal: horizontal duplex.
	PrintDuplexHorizontal PrintDuplex = 1
	// PrintDuplexVertical: vertical duplex.
	PrintDuplexVertical PrintDuplex = 2
)

func marshalPrintDuplex(p uintptr) (interface{}, error) {
	return PrintDuplex(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintError: error codes that identify various errors that can occur while
// using the GTK+ printing support.
type PrintError int

const (
	// PrintErrorGeneral: an unspecified error occurred.
	PrintErrorGeneral PrintError = 0
	// PrintErrorInternalError: an internal error occurred.
	PrintErrorInternalError PrintError = 1
	// PrintErrorNOMEM: a memory allocation failed.
	PrintErrorNOMEM PrintError = 2
	// PrintErrorInvalidFile: an error occurred while loading a page setup or
	// paper size from a key file.
	PrintErrorInvalidFile PrintError = 3
)

func marshalPrintError(p uintptr) (interface{}, error) {
	return PrintError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintOperationAction: the @action parameter to gtk_print_operation_run()
// determines what action the print operation should perform.
type PrintOperationAction int

const (
	// PrintOperationActionPrintDialog: show the print dialog.
	PrintOperationActionPrintDialog PrintOperationAction = 0
	// PrintOperationActionPrint: start to print without showing the print
	// dialog, based on the current print settings.
	PrintOperationActionPrint PrintOperationAction = 1
	// PrintOperationActionPreview: show the print preview.
	PrintOperationActionPreview PrintOperationAction = 2
	// PrintOperationActionExport: export to a file. This requires the
	// export-filename property to be set.
	PrintOperationActionExport PrintOperationAction = 3
)

func marshalPrintOperationAction(p uintptr) (interface{}, error) {
	return PrintOperationAction(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintOperationResult: a value of this type is returned by
// gtk_print_operation_run().
type PrintOperationResult int

const (
	// PrintOperationResultError: an error has occurred.
	PrintOperationResultError PrintOperationResult = 0
	// PrintOperationResultApply: the print settings should be stored.
	PrintOperationResultApply PrintOperationResult = 1
	// PrintOperationResultCancel: the print operation has been canceled, the
	// print settings should not be stored.
	PrintOperationResultCancel PrintOperationResult = 2
	// PrintOperationResultInProgress: the print operation is not complete yet.
	// This value will only be returned when running asynchronously.
	PrintOperationResultInProgress PrintOperationResult = 3
)

func marshalPrintOperationResult(p uintptr) (interface{}, error) {
	return PrintOperationResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintPages: see also gtk_print_job_set_pages()
type PrintPages int

const (
	// PrintPagesAll: all pages.
	PrintPagesAll PrintPages = 0
	// PrintPagesCurrent: current page.
	PrintPagesCurrent PrintPages = 1
	// PrintPagesRanges: range of pages.
	PrintPagesRanges PrintPages = 2
	// PrintPagesSelection: selected pages.
	PrintPagesSelection PrintPages = 3
)

func marshalPrintPages(p uintptr) (interface{}, error) {
	return PrintPages(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintQuality: see also gtk_print_settings_set_quality().
type PrintQuality int

const (
	// PrintQualityLow: low quality.
	PrintQualityLow PrintQuality = 0
	// PrintQualityNormal: normal quality.
	PrintQualityNormal PrintQuality = 1
	// PrintQualityHigh: high quality.
	PrintQualityHigh PrintQuality = 2
	// PrintQualityDraft: draft quality.
	PrintQualityDraft PrintQuality = 3
)

func marshalPrintQuality(p uintptr) (interface{}, error) {
	return PrintQuality(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintStatus: the status gives a rough indication of the completion of a
// running print operation.
type PrintStatus int

const (
	// PrintStatusInitial: the printing has not started yet; this status is set
	// initially, and while the print dialog is shown.
	PrintStatusInitial PrintStatus = 0
	// PrintStatusPreparing: this status is set while the begin-print signal is
	// emitted and during pagination.
	PrintStatusPreparing PrintStatus = 1
	// PrintStatusGeneratingData: this status is set while the pages are being
	// rendered.
	PrintStatusGeneratingData PrintStatus = 2
	// PrintStatusSendingData: the print job is being sent off to the printer.
	PrintStatusSendingData PrintStatus = 3
	// PrintStatusPending: the print job has been sent to the printer, but is
	// not printed for some reason, e.g. the printer may be stopped.
	PrintStatusPending PrintStatus = 4
	// PrintStatusPendingIssue: some problem has occurred during printing, e.g.
	// a paper jam.
	PrintStatusPendingIssue PrintStatus = 5
	// PrintStatusPrinting: the printer is processing the print job.
	PrintStatusPrinting PrintStatus = 6
	// PrintStatusFinished: the printing has been completed successfully.
	PrintStatusFinished PrintStatus = 7
	// PrintStatusFinishedAborted: the printing has been aborted.
	PrintStatusFinishedAborted PrintStatus = 8
)

func marshalPrintStatus(p uintptr) (interface{}, error) {
	return PrintStatus(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PropagationPhase describes the stage at which events are fed into a
// EventController.
type PropagationPhase int

const (
	// PropagationPhaseNone events are not delivered automatically. Those can be
	// manually fed through gtk_event_controller_handle_event(). This should
	// only be used when full control about when, or whether the controller
	// handles the event is needed.
	PropagationPhaseNone PropagationPhase = 0
	// PropagationPhaseCapture events are delivered in the capture phase. The
	// capture phase happens before the bubble phase, runs from the toplevel
	// down to the event widget. This option should only be used on containers
	// that might possibly handle events before their children do.
	PropagationPhaseCapture PropagationPhase = 1
	// PropagationPhaseBubble events are delivered in the bubble phase. The
	// bubble phase happens after the capture phase, and before the default
	// handlers are run. This phase runs from the event widget, up to the
	// toplevel.
	PropagationPhaseBubble PropagationPhase = 2
	// PropagationPhaseTarget events are delivered in the default widget event
	// handlers, note that widget implementations must chain up on button,
	// motion, touch and grab broken handlers for controllers in this phase to
	// be run.
	PropagationPhaseTarget PropagationPhase = 3
)

func marshalPropagationPhase(p uintptr) (interface{}, error) {
	return PropagationPhase(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RCTokenType: the RcTokenType enumeration represents the tokens in the RC
// file. It is exposed so that theme engines can reuse these tokens when parsing
// the theme-engine specific portions of a RC file.
type RCTokenType int

const (
	// RCTokenTypeInvalid: deprecated
	RCTokenTypeInvalid RCTokenType = 270
	// RCTokenTypeInclude: deprecated
	RCTokenTypeInclude RCTokenType = 271
	// RCTokenTypeNormal: deprecated
	RCTokenTypeNormal RCTokenType = 272
	// RCTokenTypeActive: deprecated
	RCTokenTypeActive RCTokenType = 273
	// RCTokenTypePrelight: deprecated
	RCTokenTypePrelight RCTokenType = 274
	// RCTokenTypeSelected: deprecated
	RCTokenTypeSelected RCTokenType = 275
	// RCTokenTypeInsensitive: deprecated
	RCTokenTypeInsensitive RCTokenType = 276
	// RCTokenTypeFg: deprecated
	RCTokenTypeFg RCTokenType = 277
	// RCTokenTypeBg: deprecated
	RCTokenTypeBg RCTokenType = 278
	// RCTokenTypeText: deprecated
	RCTokenTypeText RCTokenType = 279
	// RCTokenTypeBase: deprecated
	RCTokenTypeBase RCTokenType = 280
	// RCTokenTypeXthickness: deprecated
	RCTokenTypeXthickness RCTokenType = 281
	// RCTokenTypeYthickness: deprecated
	RCTokenTypeYthickness RCTokenType = 282
	// RCTokenTypeFont: deprecated
	RCTokenTypeFont RCTokenType = 283
	// RCTokenTypeFontset: deprecated
	RCTokenTypeFontset RCTokenType = 284
	// RCTokenTypeFontName: deprecated
	RCTokenTypeFontName RCTokenType = 285
	// RCTokenTypeBgPixmap: deprecated
	RCTokenTypeBgPixmap RCTokenType = 286
	// RCTokenTypePixmapPath: deprecated
	RCTokenTypePixmapPath RCTokenType = 287
	// RCTokenTypeStyle: deprecated
	RCTokenTypeStyle RCTokenType = 288
	// RCTokenTypeBinding: deprecated
	RCTokenTypeBinding RCTokenType = 289
	// RCTokenTypeBind: deprecated
	RCTokenTypeBind RCTokenType = 290
	// RCTokenTypeWidget: deprecated
	RCTokenTypeWidget RCTokenType = 291
	// RCTokenTypeWidgetClass: deprecated
	RCTokenTypeWidgetClass RCTokenType = 292
	// RCTokenTypeClass: deprecated
	RCTokenTypeClass RCTokenType = 293
	// RCTokenTypeLowest: deprecated
	RCTokenTypeLowest RCTokenType = 294
	// RCTokenTypeGTK: deprecated
	RCTokenTypeGTK RCTokenType = 295
	// RCTokenTypeApplication: deprecated
	RCTokenTypeApplication RCTokenType = 296
	// RCTokenTypeTheme: deprecated
	RCTokenTypeTheme RCTokenType = 297
	// RCTokenTypeRC: deprecated
	RCTokenTypeRC RCTokenType = 298
	// RCTokenTypeHighest: deprecated
	RCTokenTypeHighest RCTokenType = 299
	// RCTokenTypeEngine: deprecated
	RCTokenTypeEngine RCTokenType = 300
	// RCTokenTypeModulePath: deprecated
	RCTokenTypeModulePath RCTokenType = 301
	// RCTokenTypeImModulePath: deprecated
	RCTokenTypeImModulePath RCTokenType = 302
	// RCTokenTypeImModuleFile: deprecated
	RCTokenTypeImModuleFile RCTokenType = 303
	// RCTokenTypeStock: deprecated
	RCTokenTypeStock RCTokenType = 304
	// RCTokenTypeLTR: deprecated
	RCTokenTypeLTR RCTokenType = 305
	// RCTokenTypeRTL: deprecated
	RCTokenTypeRTL RCTokenType = 306
	// RCTokenTypeColor: deprecated
	RCTokenTypeColor RCTokenType = 307
	// RCTokenTypeUnbind: deprecated
	RCTokenTypeUnbind RCTokenType = 308
	// RCTokenTypeLast: deprecated
	RCTokenTypeLast RCTokenType = 309
)

func marshalRCTokenType(p uintptr) (interface{}, error) {
	return RCTokenType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RecentChooserError: these identify the various errors that can occur while
// calling RecentChooser functions.
type RecentChooserError int

const (
	// RecentChooserErrorNotFound indicates that a file does not exist
	RecentChooserErrorNotFound RecentChooserError = 0
	// RecentChooserErrorInvalidURI indicates a malformed URI
	RecentChooserErrorInvalidURI RecentChooserError = 1
)

func marshalRecentChooserError(p uintptr) (interface{}, error) {
	return RecentChooserError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RecentManagerError: error codes for RecentManager operations
type RecentManagerError int

const (
	// RecentManagerErrorNotFound: the URI specified does not exists in the
	// recently used resources list.
	RecentManagerErrorNotFound RecentManagerError = 0
	// RecentManagerErrorInvalidURI: the URI specified is not valid.
	RecentManagerErrorInvalidURI RecentManagerError = 1
	// RecentManagerErrorInvalidEncoding: the supplied string is not UTF-8
	// encoded.
	RecentManagerErrorInvalidEncoding RecentManagerError = 2
	// RecentManagerErrorNotRegistered: no application has registered the
	// specified item.
	RecentManagerErrorNotRegistered RecentManagerError = 3
	// RecentManagerErrorRead: failure while reading the recently used resources
	// file.
	RecentManagerErrorRead RecentManagerError = 4
	// RecentManagerErrorWrite: failure while writing the recently used
	// resources file.
	RecentManagerErrorWrite RecentManagerError = 5
	// RecentManagerErrorUnknown: unspecified error.
	RecentManagerErrorUnknown RecentManagerError = 6
)

func marshalRecentManagerError(p uintptr) (interface{}, error) {
	return RecentManagerError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RecentSortType: used to specify the sorting method to be applyed to the
// recently used resource list.
type RecentSortType int

const (
	// RecentSortTypeNone: do not sort the returned list of recently used
	// resources.
	RecentSortTypeNone RecentSortType = 0
	// RecentSortTypeMru: sort the returned list with the most recently used
	// items first.
	RecentSortTypeMru RecentSortType = 1
	// RecentSortTypeLru: sort the returned list with the least recently used
	// items first.
	RecentSortTypeLru RecentSortType = 2
	// RecentSortTypeCustom: sort the returned list using a custom sorting
	// function passed using gtk_recent_chooser_set_sort_func().
	RecentSortTypeCustom RecentSortType = 3
)

func marshalRecentSortType(p uintptr) (interface{}, error) {
	return RecentSortType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ReliefStyle: indicated the relief to be drawn around a Button.
type ReliefStyle int

const (
	// ReliefStyleNormal: draw a normal relief.
	ReliefStyleNormal ReliefStyle = 0
	// ReliefStyleHalf: a half relief. Deprecated in 3.14, does the same as
	// @GTK_RELIEF_NORMAL
	ReliefStyleHalf ReliefStyle = 1
	// ReliefStyleNone: no relief.
	ReliefStyleNone ReliefStyle = 2
)

func marshalReliefStyle(p uintptr) (interface{}, error) {
	return ReliefStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

type ResizeMode int

const (
	// ResizeModeParent pass resize request to the parent
	ResizeModeParent ResizeMode = 0
	// ResizeModeQueue: queue resizes on this widget
	ResizeModeQueue ResizeMode = 1
	// ResizeModeImmediate: resize immediately. Deprecated.
	ResizeModeImmediate ResizeMode = 2
)

func marshalResizeMode(p uintptr) (interface{}, error) {
	return ResizeMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResponseType: predefined values for use as response ids in
// gtk_dialog_add_button(). All predefined values are negative; GTK+ leaves
// values of 0 or greater for application-defined response ids.
type ResponseType int

const (
	// ResponseTypeNone: returned if an action widget has no response id, or if
	// the dialog gets programmatically hidden or destroyed
	ResponseTypeNone ResponseType = -1
	// ResponseTypeReject: generic response id, not used by GTK+ dialogs
	ResponseTypeReject ResponseType = -2
	// ResponseTypeAccept: generic response id, not used by GTK+ dialogs
	ResponseTypeAccept ResponseType = -3
	// ResponseTypeDeleteEvent: returned if the dialog is deleted
	ResponseTypeDeleteEvent ResponseType = -4
	// ResponseTypeOk: returned by OK buttons in GTK+ dialogs
	ResponseTypeOk ResponseType = -5
	// ResponseTypeCancel: returned by Cancel buttons in GTK+ dialogs
	ResponseTypeCancel ResponseType = -6
	// ResponseTypeClose: returned by Close buttons in GTK+ dialogs
	ResponseTypeClose ResponseType = -7
	// ResponseTypeYes: returned by Yes buttons in GTK+ dialogs
	ResponseTypeYes ResponseType = -8
	// ResponseTypeNo: returned by No buttons in GTK+ dialogs
	ResponseTypeNo ResponseType = -9
	// ResponseTypeApply: returned by Apply buttons in GTK+ dialogs
	ResponseTypeApply ResponseType = -10
	// ResponseTypeHelp: returned by Help buttons in GTK+ dialogs
	ResponseTypeHelp ResponseType = -11
)

func marshalResponseType(p uintptr) (interface{}, error) {
	return ResponseType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RevealerTransitionType: these enumeration values describe the possible
// transitions when the child of a Revealer widget is shown or hidden.
type RevealerTransitionType int

const (
	// RevealerTransitionTypeNone: no transition
	RevealerTransitionTypeNone RevealerTransitionType = 0
	// RevealerTransitionTypeCrossfade: fade in
	RevealerTransitionTypeCrossfade RevealerTransitionType = 1
	// RevealerTransitionTypeSlideRight: slide in from the left
	RevealerTransitionTypeSlideRight RevealerTransitionType = 2
	// RevealerTransitionTypeSlideLeft: slide in from the right
	RevealerTransitionTypeSlideLeft RevealerTransitionType = 3
	// RevealerTransitionTypeSlideUp: slide in from the bottom
	RevealerTransitionTypeSlideUp RevealerTransitionType = 4
	// RevealerTransitionTypeSlideDown: slide in from the top
	RevealerTransitionTypeSlideDown RevealerTransitionType = 5
)

func marshalRevealerTransitionType(p uintptr) (interface{}, error) {
	return RevealerTransitionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

type ScrollStep int

const (
	// ScrollStepSteps: scroll in steps.
	ScrollStepSteps ScrollStep = 0
	// ScrollStepPages: scroll by pages.
	ScrollStepPages ScrollStep = 1
	// ScrollStepEnds: scroll to ends.
	ScrollStepEnds ScrollStep = 2
	// ScrollStepHorizontalSteps: scroll in horizontal steps.
	ScrollStepHorizontalSteps ScrollStep = 3
	// ScrollStepHorizontalPages: scroll by horizontal pages.
	ScrollStepHorizontalPages ScrollStep = 4
	// ScrollStepHorizontalEnds: scroll to the horizontal ends.
	ScrollStepHorizontalEnds ScrollStep = 5
)

func marshalScrollStep(p uintptr) (interface{}, error) {
	return ScrollStep(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ScrollType: scrolling types.
type ScrollType int

const (
	// ScrollTypeNone: no scrolling.
	ScrollTypeNone ScrollType = 0
	// ScrollTypeJump: jump to new location.
	ScrollTypeJump ScrollType = 1
	// ScrollTypeStepBackward: step backward.
	ScrollTypeStepBackward ScrollType = 2
	// ScrollTypeStepForward: step forward.
	ScrollTypeStepForward ScrollType = 3
	// ScrollTypePageBackward: page backward.
	ScrollTypePageBackward ScrollType = 4
	// ScrollTypePageForward: page forward.
	ScrollTypePageForward ScrollType = 5
	// ScrollTypeStepUp: step up.
	ScrollTypeStepUp ScrollType = 6
	// ScrollTypeStepDown: step down.
	ScrollTypeStepDown ScrollType = 7
	// ScrollTypePageUp: page up.
	ScrollTypePageUp ScrollType = 8
	// ScrollTypePageDown: page down.
	ScrollTypePageDown ScrollType = 9
	// ScrollTypeStepLeft: step to the left.
	ScrollTypeStepLeft ScrollType = 10
	// ScrollTypeStepRight: step to the right.
	ScrollTypeStepRight ScrollType = 11
	// ScrollTypePageLeft: page to the left.
	ScrollTypePageLeft ScrollType = 12
	// ScrollTypePageRight: page to the right.
	ScrollTypePageRight ScrollType = 13
	// ScrollTypeStart: scroll to start.
	ScrollTypeStart ScrollType = 14
	// ScrollTypeEnd: scroll to end.
	ScrollTypeEnd ScrollType = 15
)

func marshalScrollType(p uintptr) (interface{}, error) {
	return ScrollType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ScrollablePolicy defines the policy to be used in a scrollable widget when
// updating the scrolled window adjustments in a given orientation.
type ScrollablePolicy int

const (
	// ScrollablePolicyMinimum: scrollable adjustments are based on the minimum
	// size
	ScrollablePolicyMinimum ScrollablePolicy = 0
	// ScrollablePolicyNatural: scrollable adjustments are based on the natural
	// size
	ScrollablePolicyNatural ScrollablePolicy = 1
)

func marshalScrollablePolicy(p uintptr) (interface{}, error) {
	return ScrollablePolicy(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SelectionMode: used to control what selections users are allowed to make.
type SelectionMode int

const (
	// SelectionModeNone: no selection is possible.
	SelectionModeNone SelectionMode = 0
	// SelectionModeSingle: zero or one element may be selected.
	SelectionModeSingle SelectionMode = 1
	// SelectionModeBrowse: exactly one element is selected. In some
	// circumstances, such as initially or during a search operation, it’s
	// possible for no element to be selected with GTK_SELECTION_BROWSE. What is
	// really enforced is that the user can’t deselect a currently selected
	// element except by selecting another element.
	SelectionModeBrowse SelectionMode = 2
	// SelectionModeMultiple: any number of elements may be selected. The Ctrl
	// key may be used to enlarge the selection, and Shift key to select between
	// the focus and the child pointed to. Some widgets may also allow
	// Click-drag to select a range of elements.
	SelectionModeMultiple SelectionMode = 3
)

func marshalSelectionMode(p uintptr) (interface{}, error) {
	return SelectionMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SensitivityType determines how GTK+ handles the sensitivity of stepper arrows
// at the end of range widgets.
type SensitivityType int

const (
	// SensitivityTypeAuto: the arrow is made insensitive if the thumb is at the
	// end
	SensitivityTypeAuto SensitivityType = 0
	// SensitivityTypeOn: the arrow is always sensitive
	SensitivityTypeOn SensitivityType = 1
	// SensitivityTypeOff: the arrow is always insensitive
	SensitivityTypeOff SensitivityType = 2
)

func marshalSensitivityType(p uintptr) (interface{}, error) {
	return SensitivityType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ShadowType: used to change the appearance of an outline typically provided by
// a Frame.
//
// Note that many themes do not differentiate the appearance of the various
// shadow types: Either their is no visible shadow (@GTK_SHADOW_NONE), or there
// is (any other value).
type ShadowType int

const (
	// ShadowTypeNone: no outline.
	ShadowTypeNone ShadowType = 0
	// ShadowTypeIn: the outline is bevelled inwards.
	ShadowTypeIn ShadowType = 1
	// ShadowTypeOut: the outline is bevelled outwards like a button.
	ShadowTypeOut ShadowType = 2
	// ShadowTypeEtchedIn: the outline has a sunken 3d appearance.
	ShadowTypeEtchedIn ShadowType = 3
	// ShadowTypeEtchedOut: the outline has a raised 3d appearance.
	ShadowTypeEtchedOut ShadowType = 4
)

func marshalShadowType(p uintptr) (interface{}, error) {
	return ShadowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ShortcutType: gtkShortcutType specifies the kind of shortcut that is being
// described. More values may be added to this enumeration over time.
type ShortcutType int

const (
	// ShortcutTypeAccelerator: the shortcut is a keyboard accelerator. The
	// ShortcutsShortcut:accelerator property will be used.
	ShortcutTypeAccelerator ShortcutType = 0
	// ShortcutTypeGesturePinch: the shortcut is a pinch gesture. GTK+ provides
	// an icon and subtitle.
	ShortcutTypeGesturePinch ShortcutType = 1
	// ShortcutTypeGestureStretch: the shortcut is a stretch gesture. GTK+
	// provides an icon and subtitle.
	ShortcutTypeGestureStretch ShortcutType = 2
	// ShortcutTypeGestureRotateClockwise: the shortcut is a clockwise rotation
	// gesture. GTK+ provides an icon and subtitle.
	ShortcutTypeGestureRotateClockwise ShortcutType = 3
	// ShortcutTypeGestureRotateCounterclockwise: the shortcut is a
	// counterclockwise rotation gesture. GTK+ provides an icon and subtitle.
	ShortcutTypeGestureRotateCounterclockwise ShortcutType = 4
	// ShortcutTypeGestureTwoFingerSwipeLeft: the shortcut is a two-finger swipe
	// gesture. GTK+ provides an icon and subtitle.
	ShortcutTypeGestureTwoFingerSwipeLeft ShortcutType = 5
	// ShortcutTypeGestureTwoFingerSwipeRight: the shortcut is a two-finger
	// swipe gesture. GTK+ provides an icon and subtitle.
	ShortcutTypeGestureTwoFingerSwipeRight ShortcutType = 6
	// ShortcutTypeGesture: the shortcut is a gesture. The
	// ShortcutsShortcut:icon property will be used.
	ShortcutTypeGesture ShortcutType = 7
)

func marshalShortcutType(p uintptr) (interface{}, error) {
	return ShortcutType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SizeGroupMode: the mode of the size group determines the directions in which
// the size group affects the requested sizes of its component widgets.
type SizeGroupMode int

const (
	// SizeGroupModeNone: group has no effect
	SizeGroupModeNone SizeGroupMode = 0
	// SizeGroupModeHorizontal: group affects horizontal requisition
	SizeGroupModeHorizontal SizeGroupMode = 1
	// SizeGroupModeVertical: group affects vertical requisition
	SizeGroupModeVertical SizeGroupMode = 2
	// SizeGroupModeBoth: group affects both horizontal and vertical requisition
	SizeGroupModeBoth SizeGroupMode = 3
)

func marshalSizeGroupMode(p uintptr) (interface{}, error) {
	return SizeGroupMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SizeRequestMode specifies a preference for height-for-width or
// width-for-height geometry management.
type SizeRequestMode int

const (
	// SizeRequestModeHeightForWidth: prefer height-for-width geometry
	// management
	SizeRequestModeHeightForWidth SizeRequestMode = 0
	// SizeRequestModeWidthForHeight: prefer width-for-height geometry
	// management
	SizeRequestModeWidthForHeight SizeRequestMode = 1
	// SizeRequestModeConstantSize: don’t trade height-for-width or
	// width-for-height
	SizeRequestModeConstantSize SizeRequestMode = 2
)

func marshalSizeRequestMode(p uintptr) (interface{}, error) {
	return SizeRequestMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SortType determines the direction of a sort.
type SortType int

const (
	// SortTypeAscending: sorting is in ascending order.
	SortTypeAscending SortType = 0
	// SortTypeDescending: sorting is in descending order.
	SortTypeDescending SortType = 1
)

func marshalSortType(p uintptr) (interface{}, error) {
	return SortType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SpinButtonUpdatePolicy: the spin button update policy determines whether the
// spin button displays values even if they are outside the bounds of its
// adjustment. See gtk_spin_button_set_update_policy().
type SpinButtonUpdatePolicy int

const (
	// SpinButtonUpdatePolicyAlways: when refreshing your SpinButton, the value
	// is always displayed
	SpinButtonUpdatePolicyAlways SpinButtonUpdatePolicy = 0
	// SpinButtonUpdatePolicyIfValid: when refreshing your SpinButton, the value
	// is only displayed if it is valid within the bounds of the spin button's
	// adjustment
	SpinButtonUpdatePolicyIfValid SpinButtonUpdatePolicy = 1
)

func marshalSpinButtonUpdatePolicy(p uintptr) (interface{}, error) {
	return SpinButtonUpdatePolicy(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SpinType: the values of the GtkSpinType enumeration are used to specify the
// change to make in gtk_spin_button_spin().
type SpinType int

const (
	// SpinTypeStepForward: increment by the adjustments step increment.
	SpinTypeStepForward SpinType = 0
	// SpinTypeStepBackward: decrement by the adjustments step increment.
	SpinTypeStepBackward SpinType = 1
	// SpinTypePageForward: increment by the adjustments page increment.
	SpinTypePageForward SpinType = 2
	// SpinTypePageBackward: decrement by the adjustments page increment.
	SpinTypePageBackward SpinType = 3
	// SpinTypeHome: go to the adjustments lower bound.
	SpinTypeHome SpinType = 4
	// SpinTypeEnd: go to the adjustments upper bound.
	SpinTypeEnd SpinType = 5
	// SpinTypeUserDefined: change by a specified amount.
	SpinTypeUserDefined SpinType = 6
)

func marshalSpinType(p uintptr) (interface{}, error) {
	return SpinType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// StackTransitionType: these enumeration values describe the possible
// transitions between pages in a Stack widget.
//
// New values may be added to this enumeration over time.
type StackTransitionType int

const (
	// StackTransitionTypeNone: no transition
	StackTransitionTypeNone StackTransitionType = 0
	// StackTransitionTypeCrossfade: a cross-fade
	StackTransitionTypeCrossfade StackTransitionType = 1
	// StackTransitionTypeSlideRight: slide from left to right
	StackTransitionTypeSlideRight StackTransitionType = 2
	// StackTransitionTypeSlideLeft: slide from right to left
	StackTransitionTypeSlideLeft StackTransitionType = 3
	// StackTransitionTypeSlideUp: slide from bottom up
	StackTransitionTypeSlideUp StackTransitionType = 4
	// StackTransitionTypeSlideDown: slide from top down
	StackTransitionTypeSlideDown StackTransitionType = 5
	// StackTransitionTypeSlideLeftRight: slide from left or right according to
	// the children order
	StackTransitionTypeSlideLeftRight StackTransitionType = 6
	// StackTransitionTypeSlideUpDown: slide from top down or bottom up
	// according to the order
	StackTransitionTypeSlideUpDown StackTransitionType = 7
	// StackTransitionTypeOverUp: cover the old page by sliding up. Since 3.12
	StackTransitionTypeOverUp StackTransitionType = 8
	// StackTransitionTypeOverDown: cover the old page by sliding down. Since:
	// 3.12
	StackTransitionTypeOverDown StackTransitionType = 9
	// StackTransitionTypeOverLeft: cover the old page by sliding to the left.
	// Since: 3.12
	StackTransitionTypeOverLeft StackTransitionType = 10
	// StackTransitionTypeOverRight: cover the old page by sliding to the right.
	// Since: 3.12
	StackTransitionTypeOverRight StackTransitionType = 11
	// StackTransitionTypeUnderUp: uncover the new page by sliding up. Since
	// 3.12
	StackTransitionTypeUnderUp StackTransitionType = 12
	// StackTransitionTypeUnderDown: uncover the new page by sliding down.
	// Since: 3.12
	StackTransitionTypeUnderDown StackTransitionType = 13
	// StackTransitionTypeUnderLeft: uncover the new page by sliding to the
	// left. Since: 3.12
	StackTransitionTypeUnderLeft StackTransitionType = 14
	// StackTransitionTypeUnderRight: uncover the new page by sliding to the
	// right. Since: 3.12
	StackTransitionTypeUnderRight StackTransitionType = 15
	// StackTransitionTypeOverUpDown: cover the old page sliding up or uncover
	// the new page sliding down, according to order. Since: 3.12
	StackTransitionTypeOverUpDown StackTransitionType = 16
	// StackTransitionTypeOverDownUp: cover the old page sliding down or uncover
	// the new page sliding up, according to order. Since: 3.14
	StackTransitionTypeOverDownUp StackTransitionType = 17
	// StackTransitionTypeOverLeftRight: cover the old page sliding left or
	// uncover the new page sliding right, according to order. Since: 3.14
	StackTransitionTypeOverLeftRight StackTransitionType = 18
	// StackTransitionTypeOverRightLeft: cover the old page sliding right or
	// uncover the new page sliding left, according to order. Since: 3.14
	StackTransitionTypeOverRightLeft StackTransitionType = 19
)

func marshalStackTransitionType(p uintptr) (interface{}, error) {
	return StackTransitionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// StateType: this type indicates the current state of a widget; the state
// determines how the widget is drawn. The StateType enumeration is also used to
// identify different colors in a Style for drawing, so states can be used for
// subparts of a widget as well as entire widgets.
type StateType int

const (
	// StateTypeNormal: state during normal operation.
	StateTypeNormal StateType = 0
	// StateTypeActive: state of a currently active widget, such as a depressed
	// button.
	StateTypeActive StateType = 1
	// StateTypePrelight: state indicating that the mouse pointer is over the
	// widget and the widget will respond to mouse clicks.
	StateTypePrelight StateType = 2
	// StateTypeSelected: state of a selected item, such the selected row in a
	// list.
	StateTypeSelected StateType = 3
	// StateTypeInsensitive: state indicating that the widget is unresponsive to
	// user actions.
	StateTypeInsensitive StateType = 4
	// StateTypeInconsistent: the widget is inconsistent, such as checkbuttons
	// or radiobuttons that aren’t either set to true nor false, or buttons
	// requiring the user attention.
	StateTypeInconsistent StateType = 5
	// StateTypeFocused: the widget has the keyboard focus.
	StateTypeFocused StateType = 6
)

func marshalStateType(p uintptr) (interface{}, error) {
	return StateType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextBufferTargetInfo: these values are used as “info” for the targets
// contained in the lists returned by gtk_text_buffer_get_copy_target_list() and
// gtk_text_buffer_get_paste_target_list().
//
// The values counts down from `-1` to avoid clashes with application added drag
// destinations which usually start at 0.
type TextBufferTargetInfo int

const (
	// TextBufferTargetInfoBufferContents: buffer contents
	TextBufferTargetInfoBufferContents TextBufferTargetInfo = -1
	// TextBufferTargetInfoRichText: rich text
	TextBufferTargetInfoRichText TextBufferTargetInfo = -2
	// TextBufferTargetInfoText: text
	TextBufferTargetInfoText TextBufferTargetInfo = -3
)

func marshalTextBufferTargetInfo(p uintptr) (interface{}, error) {
	return TextBufferTargetInfo(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextDirection: reading directions for text.
type TextDirection int

const (
	// TextDirectionNone: no direction.
	TextDirectionNone TextDirection = 0
	// TextDirectionLTR: left to right text direction.
	TextDirectionLTR TextDirection = 1
	// TextDirectionRTL: right to left text direction.
	TextDirectionRTL TextDirection = 2
)

func marshalTextDirection(p uintptr) (interface{}, error) {
	return TextDirection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextExtendSelection: granularity types that extend the text selection. Use
// the TextView::extend-selection signal to customize the selection.
type TextExtendSelection int

const (
	// TextExtendSelectionWord selects the current word. It is triggered by a
	// double-click for example.
	TextExtendSelectionWord TextExtendSelection = 0
	// TextExtendSelectionLine selects the current line. It is triggered by a
	// triple-click for example.
	TextExtendSelectionLine TextExtendSelection = 1
)

func marshalTextExtendSelection(p uintptr) (interface{}, error) {
	return TextExtendSelection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextViewLayer: used to reference the layers of TextView for the purpose of
// customized drawing with the ::draw_layer vfunc.
type TextViewLayer int

const (
	// TextViewLayerBelow: old deprecated layer, use
	// GTK_TEXT_VIEW_LAYER_BELOW_TEXT instead
	TextViewLayerBelow TextViewLayer = 0
	// TextViewLayerAbove: old deprecated layer, use
	// GTK_TEXT_VIEW_LAYER_ABOVE_TEXT instead
	TextViewLayerAbove TextViewLayer = 1
	// TextViewLayerBelowText: the layer rendered below the text (but above the
	// background). Since: 3.20
	TextViewLayerBelowText TextViewLayer = 2
	// TextViewLayerAboveText: the layer rendered above the text. Since: 3.20
	TextViewLayerAboveText TextViewLayer = 3
)

func marshalTextViewLayer(p uintptr) (interface{}, error) {
	return TextViewLayer(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextWindowType: used to reference the parts of TextView.
type TextWindowType int

const (
	// TextWindowTypePrivate: invalid value, used as a marker
	TextWindowTypePrivate TextWindowType = 0
	// TextWindowTypeWidget: window that floats over scrolling areas.
	TextWindowTypeWidget TextWindowType = 1
	// TextWindowTypeText: scrollable text window.
	TextWindowTypeText TextWindowType = 2
	// TextWindowTypeLeft: left side border window.
	TextWindowTypeLeft TextWindowType = 3
	// TextWindowTypeRight: right side border window.
	TextWindowTypeRight TextWindowType = 4
	// TextWindowTypeTop: top border window.
	TextWindowTypeTop TextWindowType = 5
	// TextWindowTypeBottom: bottom border window.
	TextWindowTypeBottom TextWindowType = 6
)

func marshalTextWindowType(p uintptr) (interface{}, error) {
	return TextWindowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ToolbarSpaceStyle: whether spacers are vertical lines or just blank.
type ToolbarSpaceStyle int

const (
	// ToolbarSpaceStyleEmpty: use blank spacers.
	ToolbarSpaceStyleEmpty ToolbarSpaceStyle = 0
	// ToolbarSpaceStyleLine: use vertical lines for spacers.
	ToolbarSpaceStyleLine ToolbarSpaceStyle = 1
)

func marshalToolbarSpaceStyle(p uintptr) (interface{}, error) {
	return ToolbarSpaceStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ToolbarStyle: used to customize the appearance of a Toolbar. Note that
// setting the toolbar style overrides the user’s preferences for the default
// toolbar style. Note that if the button has only a label set and
// GTK_TOOLBAR_ICONS is used, the label will be visible, and vice versa.
type ToolbarStyle int

const (
	// ToolbarStyleIcons buttons display only icons in the toolbar.
	ToolbarStyleIcons ToolbarStyle = 0
	// ToolbarStyleText buttons display only text labels in the toolbar.
	ToolbarStyleText ToolbarStyle = 1
	// ToolbarStyleBoth buttons display text and icons in the toolbar.
	ToolbarStyleBoth ToolbarStyle = 2
	// ToolbarStyleBothHoriz buttons display icons and text alongside each
	// other, rather than vertically stacked
	ToolbarStyleBothHoriz ToolbarStyle = 3
)

func marshalToolbarStyle(p uintptr) (interface{}, error) {
	return ToolbarStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TreeViewColumnSizing: the sizing method the column uses to determine its
// width. Please note that @GTK_TREE_VIEW_COLUMN_AUTOSIZE are inefficient for
// large views, and can make columns appear choppy.
type TreeViewColumnSizing int

const (
	// TreeViewColumnSizingGrowOnly columns only get bigger in reaction to
	// changes in the model
	TreeViewColumnSizingGrowOnly TreeViewColumnSizing = 0
	// TreeViewColumnSizingAutosize columns resize to be the optimal size
	// everytime the model changes.
	TreeViewColumnSizingAutosize TreeViewColumnSizing = 1
	// TreeViewColumnSizingFixed columns are a fixed numbers of pixels wide.
	TreeViewColumnSizingFixed TreeViewColumnSizing = 2
)

func marshalTreeViewColumnSizing(p uintptr) (interface{}, error) {
	return TreeViewColumnSizing(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TreeViewDropPosition: an enum for determining where a dropped row goes.
type TreeViewDropPosition int

const (
	// TreeViewDropPositionBefore: dropped row is inserted before
	TreeViewDropPositionBefore TreeViewDropPosition = 0
	// TreeViewDropPositionAfter: dropped row is inserted after
	TreeViewDropPositionAfter TreeViewDropPosition = 1
	// TreeViewDropPositionIntoOrBefore: dropped row becomes a child or is
	// inserted before
	TreeViewDropPositionIntoOrBefore TreeViewDropPosition = 2
	// TreeViewDropPositionIntoOrAfter: dropped row becomes a child or is
	// inserted after
	TreeViewDropPositionIntoOrAfter TreeViewDropPosition = 3
)

func marshalTreeViewDropPosition(p uintptr) (interface{}, error) {
	return TreeViewDropPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TreeViewGridLines: used to indicate which grid lines to draw in a tree view.
type TreeViewGridLines int

const (
	// TreeViewGridLinesNone: no grid lines.
	TreeViewGridLinesNone TreeViewGridLines = 0
	// TreeViewGridLinesHorizontal: horizontal grid lines.
	TreeViewGridLinesHorizontal TreeViewGridLines = 1
	// TreeViewGridLinesVertical: vertical grid lines.
	TreeViewGridLinesVertical TreeViewGridLines = 2
	// TreeViewGridLinesBoth: horizontal and vertical grid lines.
	TreeViewGridLinesBoth TreeViewGridLines = 3
)

func marshalTreeViewGridLines(p uintptr) (interface{}, error) {
	return TreeViewGridLines(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Unit: see also gtk_print_settings_set_paper_width().
type Unit int

const (
	// UnitNone: no units.
	UnitNone Unit = 0
	// UnitPoints dimensions in points.
	UnitPoints Unit = 1
	// UnitInch dimensions in inches.
	UnitInch Unit = 2
	// UnitMm dimensions in millimeters
	UnitMm Unit = 3
)

func marshalUnit(p uintptr) (interface{}, error) {
	return Unit(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// WidgetHelpType kinds of widget-specific help. Used by the ::show-help signal.
type WidgetHelpType int

const (
	// WidgetHelpTypeTooltip: tooltip.
	WidgetHelpTypeTooltip WidgetHelpType = 0
	// WidgetHelpTypeWhatsThis what’s this.
	WidgetHelpTypeWhatsThis WidgetHelpType = 1
)

func marshalWidgetHelpType(p uintptr) (interface{}, error) {
	return WidgetHelpType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// WindowPosition: window placement can be influenced using this enumeration.
// Note that using K_WIN_POS_CENTER_ALWAYS is almost always a bad idea. It won’t
// necessarily work well with all window managers or on all windowing systems.
type WindowPosition int

const (
	// WindowPositionNone: no influence is made on placement.
	WindowPositionNone WindowPosition = 0
	// WindowPositionCenter windows should be placed in the center of the
	// screen.
	WindowPositionCenter WindowPosition = 1
	// WindowPositionMouse windows should be placed at the current mouse
	// position.
	WindowPositionMouse WindowPosition = 2
	// WindowPositionCenterAlways: keep window centered as it changes size, etc.
	WindowPositionCenterAlways WindowPosition = 3
	// WindowPositionCenterOnParent: center the window on its transient parent
	// (see gtk_window_set_transient_for()).
	WindowPositionCenterOnParent WindowPosition = 4
)

func marshalWindowPosition(p uintptr) (interface{}, error) {
	return WindowPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// WindowType: a Window can be one of these types. Most things you’d consider a
// “window” should have type K_WINDOW_TOPLEVEL; windows with this type are
// managed by the window manager and have a frame by default (call
// gtk_window_set_decorated() to toggle the frame). Windows with type
// K_WINDOW_POPUP are ignored by the window manager; window manager keybindings
// won’t work on them, the window manager won’t decorate the window with a
// frame, many GTK+ features that rely on the window manager will not work (e.g.
// resize grips and maximization/minimization). K_WINDOW_POPUP is used to
// implement widgets such as Menu or tooltips that you normally don’t think of
// as windows per se. Nearly all windows should be K_WINDOW_TOPLEVEL. In
// particular, do not use K_WINDOW_POPUP just to turn off the window borders;
// use gtk_window_set_decorated() for that.
type WindowType int

const (
	// WindowTypeToplevel: a regular window, such as a dialog.
	WindowTypeToplevel WindowType = 0
	// WindowTypePopup: a special window such as a tooltip.
	WindowTypePopup WindowType = 1
)

func marshalWindowType(p uintptr) (interface{}, error) {
	return WindowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// WrapMode describes a type of line wrapping.
type WrapMode int

const (
	// WrapModeNone: do not wrap lines; just make the text area wider
	WrapModeNone WrapMode = 0
	// WrapModeChar: wrap text, breaking lines anywhere the cursor can appear
	// (between characters, usually - if you want to be technical, between
	// graphemes, see pango_get_log_attrs())
	WrapModeChar WrapMode = 1
	// WrapModeWord: wrap text, breaking lines in between words
	WrapModeWord WrapMode = 2
	// WrapModeWordChar: wrap text, breaking lines in between words, or if that
	// is not enough, also between graphemes
	WrapModeWordChar WrapMode = 3
)

func marshalWrapMode(p uintptr) (interface{}, error) {
	return WrapMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccelFlags: accelerator flags used with gtk_accel_group_connect().
type AccelFlags int

const (
	// AccelFlagsVisible: accelerator is visible
	AccelFlagsVisible AccelFlags = 1
	// AccelFlagsLocked: accelerator not removable
	AccelFlagsLocked AccelFlags = 2
	// AccelFlagsMask: mask
	AccelFlagsMask AccelFlags = 7
)

func marshalAccelFlags(p uintptr) (interface{}, error) {
	return AccelFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ApplicationInhibitFlags types of user actions that may be blocked by
// gtk_application_inhibit().
type ApplicationInhibitFlags int

const (
	// ApplicationInhibitFlagsLogout: inhibit ending the user session by logging
	// out or by shutting down the computer
	ApplicationInhibitFlagsLogout ApplicationInhibitFlags = 1
	// ApplicationInhibitFlagsSwitch: inhibit user switching
	ApplicationInhibitFlagsSwitch ApplicationInhibitFlags = 2
	// ApplicationInhibitFlagsSuspend: inhibit suspending the session or
	// computer
	ApplicationInhibitFlagsSuspend ApplicationInhibitFlags = 4
	// ApplicationInhibitFlagsIdle: inhibit the session being marked as idle
	// (and possibly locked)
	ApplicationInhibitFlagsIdle ApplicationInhibitFlags = 8
)

func marshalApplicationInhibitFlags(p uintptr) (interface{}, error) {
	return ApplicationInhibitFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AttachOptions denotes the expansion properties that a widget will have when
// it (or its parent) is resized.
type AttachOptions int

const (
	// AttachOptionsExpand: the widget should expand to take up any extra space
	// in its container that has been allocated.
	AttachOptionsExpand AttachOptions = 1
	// AttachOptionsShrink: the widget should shrink as and when possible.
	AttachOptionsShrink AttachOptions = 2
	// AttachOptionsFill: the widget should fill the space allocated to it.
	AttachOptionsFill AttachOptions = 4
)

func marshalAttachOptions(p uintptr) (interface{}, error) {
	return AttachOptions(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CalendarDisplayOptions: these options can be used to influence the display
// and behaviour of a Calendar.
type CalendarDisplayOptions int

const (
	// CalendarDisplayOptionsShowHeading specifies that the month and year
	// should be displayed.
	CalendarDisplayOptionsShowHeading CalendarDisplayOptions = 1
	// CalendarDisplayOptionsShowDayNames specifies that three letter day
	// descriptions should be present.
	CalendarDisplayOptionsShowDayNames CalendarDisplayOptions = 2
	// CalendarDisplayOptionsNoMonthChange prevents the user from switching
	// months with the calendar.
	CalendarDisplayOptionsNoMonthChange CalendarDisplayOptions = 4
	// CalendarDisplayOptionsShowWeekNumbers displays each week numbers of the
	// current year, down the left side of the calendar.
	CalendarDisplayOptionsShowWeekNumbers CalendarDisplayOptions = 8
	// CalendarDisplayOptionsShowDetails: just show an indicator, not the full
	// details text when details are provided. See
	// gtk_calendar_set_detail_func().
	CalendarDisplayOptionsShowDetails CalendarDisplayOptions = 32
)

func marshalCalendarDisplayOptions(p uintptr) (interface{}, error) {
	return CalendarDisplayOptions(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CellRendererState tells how a cell is to be rendered.
type CellRendererState int

const (
	// CellRendererStateSelected: the cell is currently selected, and probably
	// has a selection colored background to render to.
	CellRendererStateSelected CellRendererState = 1
	// CellRendererStatePrelit: the mouse is hovering over the cell.
	CellRendererStatePrelit CellRendererState = 2
	// CellRendererStateInsensitive: the cell is drawn in an insensitive manner
	CellRendererStateInsensitive CellRendererState = 4
	// CellRendererStateSorted: the cell is in a sorted row
	CellRendererStateSorted CellRendererState = 8
	// CellRendererStateFocused: the cell is in the focus row.
	CellRendererStateFocused CellRendererState = 16
	// CellRendererStateExpandable: the cell is in a row that can be expanded.
	// Since 3.4
	CellRendererStateExpandable CellRendererState = 32
	// CellRendererStateExpanded: the cell is in a row that is expanded. Since
	// 3.4
	CellRendererStateExpanded CellRendererState = 64
)

func marshalCellRendererState(p uintptr) (interface{}, error) {
	return CellRendererState(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

type DebugFlag int

const (
	DebugFlagMisc         DebugFlag = 1
	DebugFlagPlugsocket   DebugFlag = 2
	DebugFlagText         DebugFlag = 4
	DebugFlagTree         DebugFlag = 8
	DebugFlagUpdates      DebugFlag = 16
	DebugFlagKeybindings  DebugFlag = 32
	DebugFlagMultihead    DebugFlag = 64
	DebugFlagModules      DebugFlag = 128
	DebugFlagGeometry     DebugFlag = 256
	DebugFlagIcontheme    DebugFlag = 512
	DebugFlagPrinting     DebugFlag = 1024
	DebugFlagBuilder      DebugFlag = 2048
	DebugFlagSizeRequest  DebugFlag = 4096
	DebugFlagNoCSSCache   DebugFlag = 8192
	DebugFlagBaselines    DebugFlag = 16384
	DebugFlagPixelCache   DebugFlag = 32768
	DebugFlagNoPixelCache DebugFlag = 65536
	DebugFlagInteractive  DebugFlag = 131072
	DebugFlagTouchscreen  DebugFlag = 262144
	DebugFlagActions      DebugFlag = 524288
	DebugFlagResize       DebugFlag = 1048576
	DebugFlagLayout       DebugFlag = 2097152
)

func marshalDebugFlag(p uintptr) (interface{}, error) {
	return DebugFlag(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DestDefaults: the DestDefaults enumeration specifies the various types of
// action that will be taken on behalf of the user for a drag destination site.
type DestDefaults int

const (
	// DestDefaultsMotion: if set for a widget, GTK+, during a drag over this
	// widget will check if the drag matches this widget’s list of possible
	// targets and actions. GTK+ will then call gdk_drag_status() as
	// appropriate.
	DestDefaultsMotion DestDefaults = 1
	// DestDefaultsHighlight: if set for a widget, GTK+ will draw a highlight on
	// this widget as long as a drag is over this widget and the widget drag
	// format and action are acceptable.
	DestDefaultsHighlight DestDefaults = 2
	// DestDefaultsDrop: if set for a widget, when a drop occurs, GTK+ will will
	// check if the drag matches this widget’s list of possible targets and
	// actions. If so, GTK+ will call gtk_drag_get_data() on behalf of the
	// widget. Whether or not the drop is successful, GTK+ will call
	// gtk_drag_finish(). If the action was a move, then if the drag was
	// successful, then true will be passed for the @delete parameter to
	// gtk_drag_finish().
	DestDefaultsDrop DestDefaults = 4
	// DestDefaultsAll: if set, specifies that all default actions should be
	// taken.
	DestDefaultsAll DestDefaults = 7
)

func marshalDestDefaults(p uintptr) (interface{}, error) {
	return DestDefaults(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DialogFlags flags used to influence dialog construction.
type DialogFlags int

const (
	// DialogFlagsModal: make the constructed dialog modal, see
	// gtk_window_set_modal()
	DialogFlagsModal DialogFlags = 1
	// DialogFlagsDestroyWithParent: destroy the dialog when its parent is
	// destroyed, see gtk_window_set_destroy_with_parent()
	DialogFlagsDestroyWithParent DialogFlags = 2
	// DialogFlagsUseHeaderBar: create dialog with actions in header bar instead
	// of action area. Since 3.12.
	DialogFlagsUseHeaderBar DialogFlags = 4
)

func marshalDialogFlags(p uintptr) (interface{}, error) {
	return DialogFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EventControllerScrollFlags describes the behavior of a EventControllerScroll.
type EventControllerScrollFlags int

const (
	// EventControllerScrollFlagsNone: don't emit scroll.
	EventControllerScrollFlagsNone EventControllerScrollFlags = 0
	// EventControllerScrollFlagsVertical: emit scroll with vertical deltas.
	EventControllerScrollFlagsVertical EventControllerScrollFlags = 1
	// EventControllerScrollFlagsHorizontal: emit scroll with horizontal deltas.
	EventControllerScrollFlagsHorizontal EventControllerScrollFlags = 2
	// EventControllerScrollFlagsDiscrete: only emit deltas that are multiples
	// of 1.
	EventControllerScrollFlagsDiscrete EventControllerScrollFlags = 4
	// EventControllerScrollFlagsKinetic: emit EventControllerScroll::decelerate
	// after continuous scroll finishes.
	EventControllerScrollFlagsKinetic EventControllerScrollFlags = 8
	// EventControllerScrollFlagsBothAxes: emit scroll on both axes.
	EventControllerScrollFlagsBothAxes EventControllerScrollFlags = 3
)

func marshalEventControllerScrollFlags(p uintptr) (interface{}, error) {
	return EventControllerScrollFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileFilterFlags: these flags indicate what parts of a FileFilterInfo struct
// are filled or need to be filled.
type FileFilterFlags int

const (
	// FileFilterFlagsFilename: the filename of the file being tested
	FileFilterFlagsFilename FileFilterFlags = 1
	// FileFilterFlagsURI: the URI for the file being tested
	FileFilterFlagsURI FileFilterFlags = 2
	// FileFilterFlagsDisplayName: the string that will be used to display the
	// file in the file chooser
	FileFilterFlagsDisplayName FileFilterFlags = 4
	// FileFilterFlagsMIMEType: the mime type of the file
	FileFilterFlagsMIMEType FileFilterFlags = 8
)

func marshalFileFilterFlags(p uintptr) (interface{}, error) {
	return FileFilterFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FontChooserLevel: this enumeration specifies the granularity of font
// selection that is desired in a font chooser.
//
// This enumeration may be extended in the future; applications should ignore
// unknown values.
type FontChooserLevel int

const (
	// FontChooserLevelFamily: allow selecting a font family
	FontChooserLevelFamily FontChooserLevel = 0
	// FontChooserLevelStyle: allow selecting a specific font face
	FontChooserLevelStyle FontChooserLevel = 1
	// FontChooserLevelSize: allow selecting a specific font size
	FontChooserLevelSize       FontChooserLevel = 2
	FontChooserLevelVariations FontChooserLevel = 4
	// FontChooserLevelFeatures: allow selecting specific OpenType font features
	FontChooserLevelFeatures FontChooserLevel = 8
)

func marshalFontChooserLevel(p uintptr) (interface{}, error) {
	return FontChooserLevel(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconLookupFlags: used to specify options for gtk_icon_theme_lookup_icon()
type IconLookupFlags int

const (
	// IconLookupFlagsNoSvg: never get SVG icons, even if gdk-pixbuf supports
	// them. Cannot be used together with GTK_ICON_LOOKUP_FORCE_SVG.
	IconLookupFlagsNoSvg IconLookupFlags = 1
	// IconLookupFlagsForceSvg: get SVG icons, even if gdk-pixbuf doesn’t
	// support them. Cannot be used together with GTK_ICON_LOOKUP_NO_SVG.
	IconLookupFlagsForceSvg IconLookupFlags = 2
	// IconLookupFlagsUseBuiltin: when passed to gtk_icon_theme_lookup_icon()
	// includes builtin icons as well as files. For a builtin icon,
	// gtk_icon_info_get_filename() is nil and you need to call
	// gtk_icon_info_get_builtin_pixbuf().
	IconLookupFlagsUseBuiltin IconLookupFlags = 4
	// IconLookupFlagsGenericFallback: try to shorten icon name at '-'
	// characters before looking at inherited themes. This flag is only
	// supported in functions that take a single icon name. For more general
	// fallback, see gtk_icon_theme_choose_icon(). Since 2.12.
	IconLookupFlagsGenericFallback IconLookupFlags = 8
	// IconLookupFlagsForceSize always get the icon scaled to the requested
	// size. Since 2.14.
	IconLookupFlagsForceSize IconLookupFlags = 16
	// IconLookupFlagsForceRegular: try to always load regular icons, even when
	// symbolic icon names are given. Since 3.14.
	IconLookupFlagsForceRegular IconLookupFlags = 32
	// IconLookupFlagsForceSymbolic: try to always load symbolic icons, even
	// when regular icon names are given. Since 3.14.
	IconLookupFlagsForceSymbolic IconLookupFlags = 64
	// IconLookupFlagsDirLTR: try to load a variant of the icon for
	// left-to-right text direction. Since 3.14.
	IconLookupFlagsDirLTR IconLookupFlags = 128
	// IconLookupFlagsDirRTL: try to load a variant of the icon for
	// right-to-left text direction. Since 3.14.
	IconLookupFlagsDirRTL IconLookupFlags = 256
)

func marshalIconLookupFlags(p uintptr) (interface{}, error) {
	return IconLookupFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// InputHints describes hints that might be taken into account by input methods
// or applications. Note that input methods may already tailor their behaviour
// according to the InputPurpose of the entry.
//
// Some common sense is expected when using these flags - mixing
// @GTK_INPUT_HINT_LOWERCASE with any of the uppercase hints makes no sense.
//
// This enumeration may be extended in the future; input methods should ignore
// unknown values.
type InputHints int

const (
	// InputHintsNone: no special behaviour suggested
	InputHintsNone InputHints = 0
	// InputHintsSpellcheck: suggest checking for typos
	InputHintsSpellcheck InputHints = 1
	// InputHintsNoSpellcheck: suggest not checking for typos
	InputHintsNoSpellcheck InputHints = 2
	// InputHintsWordCompletion: suggest word completion
	InputHintsWordCompletion InputHints = 4
	// InputHintsLowercase: suggest to convert all text to lowercase
	InputHintsLowercase InputHints = 8
	// InputHintsUppercaseChars: suggest to capitalize all text
	InputHintsUppercaseChars InputHints = 16
	// InputHintsUppercaseWords: suggest to capitalize the first character of
	// each word
	InputHintsUppercaseWords InputHints = 32
	// InputHintsUppercaseSentences: suggest to capitalize the first word of
	// each sentence
	InputHintsUppercaseSentences InputHints = 64
	// InputHintsInhibitOsk: suggest to not show an onscreen keyboard (e.g for a
	// calculator that already has all the keys).
	InputHintsInhibitOsk InputHints = 128
	// InputHintsVerticalWriting: the text is vertical. Since 3.18
	InputHintsVerticalWriting InputHints = 256
	// InputHintsEmoji: suggest offering Emoji support. Since 3.22.20
	InputHintsEmoji InputHints = 512
	// InputHintsNoEmoji: suggest not offering Emoji support. Since 3.22.20
	InputHintsNoEmoji InputHints = 1024
)

func marshalInputHints(p uintptr) (interface{}, error) {
	return InputHints(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// JunctionSides describes how a rendered element connects to adjacent elements.
type JunctionSides int

const (
	// JunctionSidesNone: no junctions.
	JunctionSidesNone JunctionSides = 0
	// JunctionSidesCornerTopleft: element connects on the top-left corner.
	JunctionSidesCornerTopleft JunctionSides = 1
	// JunctionSidesCornerTopright: element connects on the top-right corner.
	JunctionSidesCornerTopright JunctionSides = 2
	// JunctionSidesCornerBottomleft: element connects on the bottom-left
	// corner.
	JunctionSidesCornerBottomleft JunctionSides = 4
	// JunctionSidesCornerBottomright: element connects on the bottom-right
	// corner.
	JunctionSidesCornerBottomright JunctionSides = 8
	// JunctionSidesTop: element connects on the top side.
	JunctionSidesTop JunctionSides = 3
	// JunctionSidesBottom: element connects on the bottom side.
	JunctionSidesBottom JunctionSides = 12
	// JunctionSidesLeft: element connects on the left side.
	JunctionSidesLeft JunctionSides = 5
	// JunctionSidesRight: element connects on the right side.
	JunctionSidesRight JunctionSides = 10
)

func marshalJunctionSides(p uintptr) (interface{}, error) {
	return JunctionSides(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PlacesOpenFlags: these flags serve two purposes. First, the application can
// call gtk_places_sidebar_set_open_flags() using these flags as a bitmask. This
// tells the sidebar that the application is able to open folders selected from
// the sidebar in various ways, for example, in new tabs or in new windows in
// addition to the normal mode.
//
// Second, when one of these values gets passed back to the application in the
// PlacesSidebar::open-location signal, it means that the application should
// open the selected location in the normal way, in a new tab, or in a new
// window. The sidebar takes care of determining the desired way to open the
// location, based on the modifier keys that the user is pressing at the time
// the selection is made.
//
// If the application never calls gtk_places_sidebar_set_open_flags(), then the
// sidebar will only use K_PLACES_OPEN_NORMAL in the
// PlacesSidebar::open-location signal. This is the default mode of operation.
type PlacesOpenFlags int

const (
	// PlacesOpenFlagsNormal: this is the default mode that PlacesSidebar uses
	// if no other flags are specified. It indicates that the calling
	// application should open the selected location in the normal way, for
	// example, in the folder view beside the sidebar.
	PlacesOpenFlagsNormal PlacesOpenFlags = 1
	// PlacesOpenFlagsNewTab: when passed to
	// gtk_places_sidebar_set_open_flags(), this indicates that the application
	// can open folders selected from the sidebar in new tabs. This value will
	// be passed to the PlacesSidebar::open-location signal when the user
	// selects that a location be opened in a new tab instead of in the standard
	// fashion.
	PlacesOpenFlagsNewTab PlacesOpenFlags = 2
	// PlacesOpenFlagsNewWindow: similar to @GTK_PLACES_OPEN_NEW_TAB, but
	// indicates that the application can open folders in new windows.
	PlacesOpenFlagsNewWindow PlacesOpenFlags = 4
)

func marshalPlacesOpenFlags(p uintptr) (interface{}, error) {
	return PlacesOpenFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RCFlags: deprecated
type RCFlags int

const (
	// RCFlagsFg: deprecated
	RCFlagsFg RCFlags = 1
	// RCFlagsBg: deprecated
	RCFlagsBg RCFlags = 2
	// RCFlagsText: deprecated
	RCFlagsText RCFlags = 4
	// RCFlagsBase: deprecated
	RCFlagsBase RCFlags = 8
)

func marshalRCFlags(p uintptr) (interface{}, error) {
	return RCFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RecentFilterFlags: these flags indicate what parts of a RecentFilterInfo
// struct are filled or need to be filled.
type RecentFilterFlags int

const (
	// RecentFilterFlagsURI: the URI of the file being tested
	RecentFilterFlagsURI RecentFilterFlags = 1
	// RecentFilterFlagsDisplayName: the string that will be used to display the
	// file in the recent chooser
	RecentFilterFlagsDisplayName RecentFilterFlags = 2
	// RecentFilterFlagsMIMEType: the mime type of the file
	RecentFilterFlagsMIMEType RecentFilterFlags = 4
	// RecentFilterFlagsApplication: the list of applications that have
	// registered the file
	RecentFilterFlagsApplication RecentFilterFlags = 8
	// RecentFilterFlagsGroup: the groups to which the file belongs to
	RecentFilterFlagsGroup RecentFilterFlags = 16
	// RecentFilterFlagsAge: the number of days elapsed since the file has been
	// registered
	RecentFilterFlagsAge RecentFilterFlags = 32
)

func marshalRecentFilterFlags(p uintptr) (interface{}, error) {
	return RecentFilterFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RegionFlags describes a region within a widget.
type RegionFlags int

const (
	// RegionFlagsEven: region has an even number within a set.
	RegionFlagsEven RegionFlags = 1
	// RegionFlagsOdd: region has an odd number within a set.
	RegionFlagsOdd RegionFlags = 2
	// RegionFlagsFirst: region is the first one within a set.
	RegionFlagsFirst RegionFlags = 4
	// RegionFlagsLast: region is the last one within a set.
	RegionFlagsLast RegionFlags = 8
	// RegionFlagsOnly: region is the only one within a set.
	RegionFlagsOnly RegionFlags = 16
	// RegionFlagsSorted: region is part of a sorted area.
	RegionFlagsSorted RegionFlags = 32
)

func marshalRegionFlags(p uintptr) (interface{}, error) {
	return RegionFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// StateFlags describes a widget state. Widget states are used to match the
// widget against CSS pseudo-classes. Note that GTK extends the regular CSS
// classes and sometimes uses different names.
type StateFlags int

const (
	// StateFlagsNormal: state during normal operation.
	StateFlagsNormal StateFlags = 0
	// StateFlagsActive: widget is active.
	StateFlagsActive StateFlags = 1
	// StateFlagsPrelight: widget has a mouse pointer over it.
	StateFlagsPrelight StateFlags = 2
	// StateFlagsSelected: widget is selected.
	StateFlagsSelected StateFlags = 4
	// StateFlagsInsensitive: widget is insensitive.
	StateFlagsInsensitive StateFlags = 8
	// StateFlagsInconsistent: widget is inconsistent.
	StateFlagsInconsistent StateFlags = 16
	// StateFlagsFocused: widget has the keyboard focus.
	StateFlagsFocused StateFlags = 32
	// StateFlagsBackdrop: widget is in a background toplevel window.
	StateFlagsBackdrop StateFlags = 64
	// StateFlagsDirLTR: widget is in left-to-right text direction. Since 3.8
	StateFlagsDirLTR StateFlags = 128
	// StateFlagsDirRTL: widget is in right-to-left text direction. Since 3.8
	StateFlagsDirRTL StateFlags = 256
	// StateFlagsLink: widget is a link. Since 3.12
	StateFlagsLink StateFlags = 512
	// StateFlagsVisited: the location the widget points to has already been
	// visited. Since 3.12
	StateFlagsVisited StateFlags = 1024
	// StateFlagsChecked: widget is checked. Since 3.14
	StateFlagsChecked StateFlags = 2048
	// StateFlagsDropActive: widget is highlighted as a drop target for DND.
	// Since 3.20
	StateFlagsDropActive StateFlags = 4096
)

func marshalStateFlags(p uintptr) (interface{}, error) {
	return StateFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// StyleContextPrintFlags flags that modify the behavior of
// gtk_style_context_to_string(). New values may be added to this enumeration.
type StyleContextPrintFlags int

const (
	StyleContextPrintFlagsNone StyleContextPrintFlags = 0
	// StyleContextPrintFlagsRecurse: print the entire tree of CSS nodes
	// starting at the style context's node
	StyleContextPrintFlagsRecurse StyleContextPrintFlags = 1
	// StyleContextPrintFlagsShowStyle: show the values of the CSS properties
	// for each node
	StyleContextPrintFlagsShowStyle StyleContextPrintFlags = 2
)

func marshalStyleContextPrintFlags(p uintptr) (interface{}, error) {
	return StyleContextPrintFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TargetFlags: the TargetFlags enumeration is used to specify constraints on a
// TargetEntry.
type TargetFlags int

const (
	// TargetFlagsSameApp: if this is set, the target will only be selected for
	// drags within a single application.
	TargetFlagsSameApp TargetFlags = 1
	// TargetFlagsSameWidget: if this is set, the target will only be selected
	// for drags within a single widget.
	TargetFlagsSameWidget TargetFlags = 2
	// TargetFlagsOtherApp: if this is set, the target will not be selected for
	// drags within a single application.
	TargetFlagsOtherApp TargetFlags = 4
	// TargetFlagsOtherWidget: if this is set, the target will not be selected
	// for drags withing a single widget.
	TargetFlagsOtherWidget TargetFlags = 8
)

func marshalTargetFlags(p uintptr) (interface{}, error) {
	return TargetFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextSearchFlags flags affecting how a search is done.
//
// If neither K_TEXT_SEARCH_VISIBLE_ONLY nor K_TEXT_SEARCH_TEXT_ONLY are
// enabled, the match must be exact; the special 0xFFFC character will match
// embedded pixbufs or child widgets.
type TextSearchFlags int

const (
	// TextSearchFlagsVisibleOnly: search only visible data. A search match may
	// have invisible text interspersed.
	TextSearchFlagsVisibleOnly TextSearchFlags = 1
	// TextSearchFlagsTextOnly: search only text. A match may have pixbufs or
	// child widgets mixed inside the matched range.
	TextSearchFlagsTextOnly TextSearchFlags = 2
	// TextSearchFlagsCaseInsensitive: the text will be matched regardless of
	// what case it is in.
	TextSearchFlagsCaseInsensitive TextSearchFlags = 4
)

func marshalTextSearchFlags(p uintptr) (interface{}, error) {
	return TextSearchFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ToolPaletteDragTargets flags used to specify the supported drag targets.
type ToolPaletteDragTargets int

const (
	// ToolPaletteDragTargetsItems: support drag of items.
	ToolPaletteDragTargetsItems ToolPaletteDragTargets = 1
	// ToolPaletteDragTargetsGroups: support drag of groups.
	ToolPaletteDragTargetsGroups ToolPaletteDragTargets = 2
)

func marshalToolPaletteDragTargets(p uintptr) (interface{}, error) {
	return ToolPaletteDragTargets(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TreeModelFlags: these flags indicate various properties of a TreeModel.
//
// They are returned by gtk_tree_model_get_flags(), and must be static for the
// lifetime of the object. A more complete description of
// K_TREE_MODEL_ITERS_PERSIST can be found in the overview of this section.
type TreeModelFlags int

const (
	// TreeModelFlagsItersPersist iterators survive all signals emitted by the
	// tree
	TreeModelFlagsItersPersist TreeModelFlags = 1
	// TreeModelFlagsListOnly: the model is a list only, and never has children
	TreeModelFlagsListOnly TreeModelFlags = 2
)

func marshalTreeModelFlags(p uintptr) (interface{}, error) {
	return TreeModelFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// UIManagerItemType: these enumeration values are used by
// gtk_ui_manager_add_ui() to determine what UI element to create.
type UIManagerItemType int

const (
	// UIManagerItemTypeAuto: pick the type of the UI element according to
	// context.
	UIManagerItemTypeAuto UIManagerItemType = 0
	// UIManagerItemTypeMenubar: create a menubar.
	UIManagerItemTypeMenubar UIManagerItemType = 1
	// UIManagerItemTypeMenu: create a menu.
	UIManagerItemTypeMenu UIManagerItemType = 2
	// UIManagerItemTypeToolbar: create a toolbar.
	UIManagerItemTypeToolbar UIManagerItemType = 4
	// UIManagerItemTypePlaceholder: insert a placeholder.
	UIManagerItemTypePlaceholder UIManagerItemType = 8
	// UIManagerItemTypePopup: create a popup menu.
	UIManagerItemTypePopup UIManagerItemType = 16
	// UIManagerItemTypeMenuitem: create a menuitem.
	UIManagerItemTypeMenuitem UIManagerItemType = 32
	// UIManagerItemTypeToolitem: create a toolitem.
	UIManagerItemTypeToolitem UIManagerItemType = 64
	// UIManagerItemTypeSeparator: create a separator.
	UIManagerItemTypeSeparator UIManagerItemType = 128
	// UIManagerItemTypeAccelerator: install an accelerator.
	UIManagerItemTypeAccelerator UIManagerItemType = 256
	// UIManagerItemTypePopupWithAccels: same as GTK_UI_MANAGER_POPUP, but the
	// actions’ accelerators are shown.
	UIManagerItemTypePopupWithAccels UIManagerItemType = 512
)

func marshalUIManagerItemType(p uintptr) (interface{}, error) {
	return UIManagerItemType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

func BuilderErrorQuark() {
	C.gtk_builder_error_quark()
}

func CSSProviderErrorQuark() {
	C.gtk_css_provider_error_quark()
}

// FileChooserErrorQuark registers an error quark for FileChooser if necessary.
func FileChooserErrorQuark() {
	C.gtk_file_chooser_error_quark()
}

func IconThemeErrorQuark() {
	C.gtk_icon_theme_error_quark()
}

// PrintErrorQuark registers an error quark for PrintOperation if necessary.
func PrintErrorQuark() {
	C.gtk_print_error_quark()
}

func RecentChooserErrorQuark() {
	C.gtk_recent_chooser_error_quark()
}

func RecentManagerErrorQuark() {
	C.gtk_recent_manager_error_quark()
}

// AppChooser is an interface that can be implemented by widgets which allow the
// user to choose an application (typically for the purpose of opening a file).
// The main objects that implement this interface are AppChooserWidget,
// AppChooserDialog and AppChooserButton.
//
// Applications are represented by GIO Info objects here. GIO has a concept of
// recommended and fallback applications for a given content type. Recommended
// applications are those that claim to handle the content type itself, while
// fallback also includes applications that handle a more generic content type.
// GIO also knows the default and last-used application for a given content
// type. The AppChooserWidget provides detailed control over whether the shown
// list of applications should include default, recommended or fallback
// applications.
//
// To obtain the application that has been selected in a AppChooser, use
// gtk_app_chooser_get_app_info().
type AppChooser interface {
	Widget

	// AppInfo returns the currently selected application.
	AppInfo(s AppChooser)
	// ContentType returns the current value of the AppChooser:content-type
	// property.
	ContentType(s AppChooser)
	// Refresh reloads the list of applications.
	Refresh(s AppChooser)
}

// appChooser implements the AppChooser interface.
type appChooser struct {
	Widget
}

var _ AppChooser = (*appChooser)(nil)

// WrapAppChooser wraps a GObject to a type that implements interface
// AppChooser. It is primarily used internally.
func WrapAppChooser(obj *externglib.Object) AppChooser {
	return AppChooser{
		Widget: WrapWidget(obj),
	}
}

func marshalAppChooser(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAppChooser(obj), nil
}

// AppInfo returns the currently selected application.
func (s appChooser) AppInfo(s AppChooser) {
	var arg0 *C.GtkAppChooser

	arg0 = (*C.GtkAppChooser)(unsafe.Pointer(s.Native()))

	C.gtk_app_chooser_get_app_info(arg0)
}

// ContentType returns the current value of the AppChooser:content-type
// property.
func (s appChooser) ContentType(s AppChooser) {
	var arg0 *C.GtkAppChooser

	arg0 = (*C.GtkAppChooser)(unsafe.Pointer(s.Native()))

	C.gtk_app_chooser_get_content_type(arg0)
}

// Refresh reloads the list of applications.
func (s appChooser) Refresh(s AppChooser) {
	var arg0 *C.GtkAppChooser

	arg0 = (*C.GtkAppChooser)(unsafe.Pointer(s.Native()))

	C.gtk_app_chooser_refresh(arg0)
}

// FileChooser is an interface that can be implemented by file selection
// widgets. In GTK+, the main objects that implement this interface are
// FileChooserWidget, FileChooserDialog, and FileChooserButton. You do not need
// to write an object that implements the FileChooser interface unless you are
// trying to adapt an existing file selector to expose a standard programming
// interface.
//
// FileChooser allows for shortcuts to various places in the filesystem. In the
// default implementation these are displayed in the left pane. It may be a bit
// confusing at first that these shortcuts come from various sources and in
// various flavours, so lets explain the terminology here:
//
// - Bookmarks: are created by the user, by dragging folders from the right pane
// to the left pane, or by using the “Add”. Bookmarks can be renamed and deleted
// by the user.
//
// - Shortcuts: can be provided by the application. For example, a Paint program
// may want to add a shortcut for a Clipart folder. Shortcuts cannot be modified
// by the user.
//
// - Volumes: are provided by the underlying filesystem abstraction. They are
// the “roots” of the filesystem.
//
//
// File Names and Encodings
//
// When the user is finished selecting files in a FileChooser, your program can
// get the selected names either as filenames or as URIs. For URIs, the normal
// escaping rules are applied if the URI contains non-ASCII characters. However,
// filenames are always returned in the character set specified by the
// `G_FILENAME_ENCODING` environment variable. Please see the GLib documentation
// for more details about this variable.
//
// This means that while you can pass the result of
// gtk_file_chooser_get_filename() to g_open() or g_fopen(), you may not be able
// to directly set it as the text of a Label widget unless you convert it first
// to UTF-8, which all GTK+ widgets expect. You should use g_filename_to_utf8()
// to convert filenames into strings that can be passed to GTK+ widgets.
//
//
// Adding a Preview Widget
//
// You can add a custom preview widget to a file chooser and then get
// notification about when the preview needs to be updated. To install a preview
// widget, use gtk_file_chooser_set_preview_widget(). Then, connect to the
// FileChooser::update-preview signal to get notified when you need to update
// the contents of the preview.
//
// Your callback should use gtk_file_chooser_get_preview_filename() to see what
// needs previewing. Once you have generated the preview for the corresponding
// file, you must call gtk_file_chooser_set_preview_widget_active() with a
// boolean flag that indicates whether your callback could successfully generate
// a preview.
//
// Example: Using a Preview Widget
//
//
//      GtkWidget *toggle;
//
//      ...
//
//      toggle = gtk_check_button_new_with_label ("Open file read-only");
//      gtk_widget_show (toggle);
//      gtk_file_chooser_set_extra_widget (my_file_chooser, toggle);
//    }
//
// If you want to set more than one extra widget in the file chooser, you can a
// container such as a Box or a Grid and include your widgets in it. Then, set
// the container as the whole extra widget.
type FileChooser interface {
	gextras.Objector

	// AddChoice adds a 'choice' to the file chooser. This is typically
	// implemented as a combobox or, for boolean choices, as a checkbutton. You
	// can select a value using gtk_file_chooser_set_choice() before the dialog
	// is shown, and you can obtain the user-selected value in the ::response
	// signal handler using gtk_file_chooser_get_choice().
	//
	// Compare gtk_file_chooser_set_extra_widget().
	AddChoice(c FileChooser, id string, label string, options []string, optionLabels []string)
	// AddFilter adds @filter to the list of filters that the user can select
	// between. When a filter is selected, only files that are passed by that
	// filter are displayed.
	//
	// Note that the @chooser takes ownership of the filter, so you have to ref
	// and sink it if you want to keep a reference.
	AddFilter(c FileChooser, filter FileFilter)
	// AddShortcutFolder adds a folder to be displayed with the shortcut folders
	// in a file chooser. Note that shortcut folders do not get saved, as they
	// are provided by the application. For example, you can use this to add a
	// “/usr/share/mydrawprogram/Clipart” folder to the volume list.
	AddShortcutFolder(c FileChooser, folder string) error
	// AddShortcutFolderURI adds a folder URI to be displayed with the shortcut
	// folders in a file chooser. Note that shortcut folders do not get saved,
	// as they are provided by the application. For example, you can use this to
	// add a “file:///usr/share/mydrawprogram/Clipart” folder to the volume
	// list.
	AddShortcutFolderURI(c FileChooser, uri string) error
	// Action gets the type of operation that the file chooser is performing;
	// see gtk_file_chooser_set_action().
	Action(c FileChooser)
	// Choice gets the currently selected option in the 'choice' with the given
	// ID.
	Choice(c FileChooser, id string)
	// CreateFolders gets whether file choser will offer to create new folders.
	// See gtk_file_chooser_set_create_folders().
	CreateFolders(c FileChooser) bool
	// CurrentFolder gets the current folder of @chooser as a local filename.
	// See gtk_file_chooser_set_current_folder().
	//
	// Note that this is the folder that the file chooser is currently
	// displaying (e.g. "/home/username/Documents"), which is not the same as
	// the currently-selected folder if the chooser is in
	// GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER mode (e.g.
	// "/home/username/Documents/selected-folder/". To get the
	// currently-selected folder in that mode, use gtk_file_chooser_get_uri() as
	// the usual way to get the selection.
	CurrentFolder(c FileChooser)
	// CurrentFolderFile gets the current folder of @chooser as #GFile. See
	// gtk_file_chooser_get_current_folder_uri().
	CurrentFolderFile(c FileChooser)
	// CurrentFolderURI gets the current folder of @chooser as an URI. See
	// gtk_file_chooser_set_current_folder_uri().
	//
	// Note that this is the folder that the file chooser is currently
	// displaying (e.g. "file:///home/username/Documents"), which is not the
	// same as the currently-selected folder if the chooser is in
	// GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER mode (e.g.
	// "file:///home/username/Documents/selected-folder/". To get the
	// currently-selected folder in that mode, use gtk_file_chooser_get_uri() as
	// the usual way to get the selection.
	CurrentFolderURI(c FileChooser)
	// CurrentName gets the current name in the file selector, as entered by the
	// user in the text entry for “Name”.
	//
	// This is meant to be used in save dialogs, to get the currently typed
	// filename when the file itself does not exist yet. For example, an
	// application that adds a custom extra widget to the file chooser for “file
	// format” may want to change the extension of the typed filename based on
	// the chosen format, say, from “.jpg” to “.png”.
	CurrentName(c FileChooser)
	// DoOverwriteConfirmation queries whether a file chooser is set to confirm
	// for overwriting when the user types a file name that already exists.
	DoOverwriteConfirmation(c FileChooser) bool
	// ExtraWidget gets the current extra widget; see
	// gtk_file_chooser_set_extra_widget().
	ExtraWidget(c FileChooser)
	// File gets the #GFile for the currently selected file in the file
	// selector. If multiple files are selected, one of the files will be
	// returned at random.
	//
	// If the file chooser is in folder mode, this function returns the selected
	// folder.
	File(c FileChooser)
	// Filename gets the filename for the currently selected file in the file
	// selector. The filename is returned as an absolute path. If multiple files
	// are selected, one of the filenames will be returned at random.
	//
	// If the file chooser is in folder mode, this function returns the selected
	// folder.
	Filename(c FileChooser)
	// Filenames lists all the selected files and subfolders in the current
	// folder of @chooser. The returned names are full absolute paths. If files
	// in the current folder cannot be represented as local filenames they will
	// be ignored. (See gtk_file_chooser_get_uris())
	Filenames(c FileChooser)
	// Files lists all the selected files and subfolders in the current folder
	// of @chooser as #GFile. An internal function, see
	// gtk_file_chooser_get_uris().
	Files(c FileChooser)
	// Filter gets the current filter; see gtk_file_chooser_set_filter().
	Filter(c FileChooser)
	// LocalOnly gets whether only local files can be selected in the file
	// selector. See gtk_file_chooser_set_local_only()
	LocalOnly(c FileChooser) bool
	// PreviewFile gets the #GFile that should be previewed in a custom preview
	// Internal function, see gtk_file_chooser_get_preview_uri().
	PreviewFile(c FileChooser)
	// PreviewFilename gets the filename that should be previewed in a custom
	// preview widget. See gtk_file_chooser_set_preview_widget().
	PreviewFilename(c FileChooser)
	// PreviewURI gets the URI that should be previewed in a custom preview
	// widget. See gtk_file_chooser_set_preview_widget().
	PreviewURI(c FileChooser)
	// PreviewWidget gets the current preview widget; see
	// gtk_file_chooser_set_preview_widget().
	PreviewWidget(c FileChooser)
	// PreviewWidgetActive gets whether the preview widget set by
	// gtk_file_chooser_set_preview_widget() should be shown for the current
	// filename. See gtk_file_chooser_set_preview_widget_active().
	PreviewWidgetActive(c FileChooser) bool
	// SelectMultiple gets whether multiple files can be selected in the file
	// selector. See gtk_file_chooser_set_select_multiple().
	SelectMultiple(c FileChooser) bool
	// ShowHidden gets whether hidden files and folders are displayed in the
	// file selector. See gtk_file_chooser_set_show_hidden().
	ShowHidden(c FileChooser) bool
	// URI gets the URI for the currently selected file in the file selector. If
	// multiple files are selected, one of the filenames will be returned at
	// random.
	//
	// If the file chooser is in folder mode, this function returns the selected
	// folder.
	URI(c FileChooser)
	// Uris lists all the selected files and subfolders in the current folder of
	// @chooser. The returned names are full absolute URIs.
	Uris(c FileChooser)
	// UsePreviewLabel gets whether a stock label should be drawn with the name
	// of the previewed file. See gtk_file_chooser_set_use_preview_label().
	UsePreviewLabel(c FileChooser) bool
	// ListFilters lists the current set of user-selectable filters; see
	// gtk_file_chooser_add_filter(), gtk_file_chooser_remove_filter().
	ListFilters(c FileChooser)
	// ListShortcutFolderUris queries the list of shortcut folders in the file
	// chooser, as set by gtk_file_chooser_add_shortcut_folder_uri().
	ListShortcutFolderUris(c FileChooser)
	// ListShortcutFolders queries the list of shortcut folders in the file
	// chooser, as set by gtk_file_chooser_add_shortcut_folder().
	ListShortcutFolders(c FileChooser)
	// RemoveChoice removes a 'choice' that has been added with
	// gtk_file_chooser_add_choice().
	RemoveChoice(c FileChooser, id string)
	// RemoveFilter removes @filter from the list of filters that the user can
	// select between.
	RemoveFilter(c FileChooser, filter FileFilter)
	// RemoveShortcutFolder removes a folder from a file chooser’s list of
	// shortcut folders.
	RemoveShortcutFolder(c FileChooser, folder string) error
	// RemoveShortcutFolderURI removes a folder URI from a file chooser’s list
	// of shortcut folders.
	RemoveShortcutFolderURI(c FileChooser, uri string) error
	// SelectAll selects all the files in the current folder of a file chooser.
	SelectAll(c FileChooser)
	// SelectFile selects the file referred to by @file. An internal function.
	// See _gtk_file_chooser_select_uri().
	SelectFile(c FileChooser, file gio.File) error
	// SelectFilename selects a filename. If the file name isn’t in the current
	// folder of @chooser, then the current folder of @chooser will be changed
	// to the folder containing @filename.
	SelectFilename(c FileChooser, filename string) bool
	// SelectURI selects the file to by @uri. If the URI doesn’t refer to a file
	// in the current folder of @chooser, then the current folder of @chooser
	// will be changed to the folder containing @filename.
	SelectURI(c FileChooser, uri string) bool
	// SetAction sets the type of operation that the chooser is performing; the
	// user interface is adapted to suit the selected action. For example, an
	// option to create a new folder might be shown if the action is
	// GTK_FILE_CHOOSER_ACTION_SAVE but not if the action is
	// GTK_FILE_CHOOSER_ACTION_OPEN.
	SetAction(c FileChooser, action FileChooserAction)
	// SetChoice selects an option in a 'choice' that has been added with
	// gtk_file_chooser_add_choice(). For a boolean choice, the possible options
	// are "true" and "false".
	SetChoice(c FileChooser, id string, option string)
	// SetCreateFolders sets whether file choser will offer to create new
	// folders. This is only relevant if the action is not set to be
	// GTK_FILE_CHOOSER_ACTION_OPEN.
	SetCreateFolders(c FileChooser, createFolders bool)
	// SetCurrentFolder sets the current folder for @chooser from a local
	// filename. The user will be shown the full contents of the current folder,
	// plus user interface elements for navigating to other folders.
	//
	// In general, you should not use this function. See the [section on setting
	// up a file chooser dialog][gtkfilechooserdialog-setting-up] for the
	// rationale behind this.
	SetCurrentFolder(c FileChooser, filename string) bool
	// SetCurrentFolderFile sets the current folder for @chooser from a #GFile.
	// Internal function, see gtk_file_chooser_set_current_folder_uri().
	SetCurrentFolderFile(c FileChooser, file gio.File) error
	// SetCurrentFolderURI sets the current folder for @chooser from an URI. The
	// user will be shown the full contents of the current folder, plus user
	// interface elements for navigating to other folders.
	//
	// In general, you should not use this function. See the [section on setting
	// up a file chooser dialog][gtkfilechooserdialog-setting-up] for the
	// rationale behind this.
	SetCurrentFolderURI(c FileChooser, uri string) bool
	// SetCurrentName sets the current name in the file selector, as if entered
	// by the user. Note that the name passed in here is a UTF-8 string rather
	// than a filename. This function is meant for such uses as a suggested name
	// in a “Save As...” dialog. You can pass “Untitled.doc” or a similarly
	// suitable suggestion for the @name.
	//
	// If you want to preselect a particular existing file, you should use
	// gtk_file_chooser_set_filename() or gtk_file_chooser_set_uri() instead.
	// Please see the documentation for those functions for an example of using
	// gtk_file_chooser_set_current_name() as well.
	SetCurrentName(c FileChooser, name string)
	// SetDoOverwriteConfirmation sets whether a file chooser in
	// GTK_FILE_CHOOSER_ACTION_SAVE mode will present a confirmation dialog if
	// the user types a file name that already exists. This is false by default.
	//
	// If set to true, the @chooser will emit the FileChooser::confirm-overwrite
	// signal when appropriate.
	//
	// If all you need is the stock confirmation dialog, set this property to
	// true. You can override the way confirmation is done by actually handling
	// the FileChooser::confirm-overwrite signal; please refer to its
	// documentation for the details.
	SetDoOverwriteConfirmation(c FileChooser, doOverwriteConfirmation bool)
	// SetExtraWidget sets an application-supplied widget to provide extra
	// options to the user.
	SetExtraWidget(c FileChooser, extraWidget Widget)
	// SetFile sets @file as the current filename for the file chooser, by
	// changing to the file’s parent folder and actually selecting the file in
	// list. If the @chooser is in GTK_FILE_CHOOSER_ACTION_SAVE mode, the file’s
	// base name will also appear in the dialog’s file name entry.
	//
	// If the file name isn’t in the current folder of @chooser, then the
	// current folder of @chooser will be changed to the folder containing
	// @filename. This is equivalent to a sequence of
	// gtk_file_chooser_unselect_all() followed by
	// gtk_file_chooser_select_filename().
	//
	// Note that the file must exist, or nothing will be done except for the
	// directory change.
	//
	// If you are implementing a save dialog, you should use this function if
	// you already have a file name to which the user may save; for example,
	// when the user opens an existing file and then does Save As... If you
	// don’t have a file name already — for example, if the user just created a
	// new file and is saving it for the first time, do not call this function.
	// Instead, use something similar to this:
	//
	//    if (document_is_new)
	//      {
	//        // the user just created a new document
	//        gtk_file_chooser_set_current_folder_file (chooser, default_file_for_saving);
	//        gtk_file_chooser_set_current_name (chooser, "Untitled document");
	//      }
	//    else
	//      {
	//        // the user edited an existing document
	//        gtk_file_chooser_set_file (chooser, existing_file);
	//      }
	SetFile(c FileChooser, file gio.File) error
	// SetFilename sets @filename as the current filename for the file chooser,
	// by changing to the file’s parent folder and actually selecting the file
	// in list; all other files will be unselected. If the @chooser is in
	// GTK_FILE_CHOOSER_ACTION_SAVE mode, the file’s base name will also appear
	// in the dialog’s file name entry.
	//
	// Note that the file must exist, or nothing will be done except for the
	// directory change.
	//
	// You should use this function only when implementing a save dialog for
	// which you already have a file name to which the user may save. For
	// example, when the user opens an existing file and then does Save As... to
	// save a copy or a modified version. If you don’t have a file name already
	// — for example, if the user just created a new file and is saving it for
	// the first time, do not call this function. Instead, use something similar
	// to this:
	//
	//    if (document_is_new)
	//      {
	//        // the user just created a new document
	//        gtk_file_chooser_set_current_name (chooser, "Untitled document");
	//      }
	//    else
	//      {
	//        // the user edited an existing document
	//        gtk_file_chooser_set_filename (chooser, existing_filename);
	//      }
	//
	// In the first case, the file chooser will present the user with useful
	// suggestions as to where to save his new file. In the second case, the
	// file’s existing location is already known, so the file chooser will use
	// it.
	SetFilename(c FileChooser, filename string) bool
	// SetFilter sets the current filter; only the files that pass the filter
	// will be displayed. If the user-selectable list of filters is non-empty,
	// then the filter should be one of the filters in that list. Setting the
	// current filter when the list of filters is empty is useful if you want to
	// restrict the displayed set of files without letting the user change it.
	SetFilter(c FileChooser, filter FileFilter)
	// SetLocalOnly sets whether only local files can be selected in the file
	// selector. If @local_only is true (the default), then the selected file or
	// files are guaranteed to be accessible through the operating systems
	// native file system and therefore the application only needs to worry
	// about the filename functions in FileChooser, like
	// gtk_file_chooser_get_filename(), rather than the URI functions like
	// gtk_file_chooser_get_uri(),
	//
	// On some systems non-native files may still be available using the native
	// filesystem via a userspace filesystem (FUSE).
	SetLocalOnly(c FileChooser, localOnly bool)
	// SetPreviewWidget sets an application-supplied widget to use to display a
	// custom preview of the currently selected file. To implement a preview,
	// after setting the preview widget, you connect to the
	// FileChooser::update-preview signal, and call
	// gtk_file_chooser_get_preview_filename() or
	// gtk_file_chooser_get_preview_uri() on each change. If you can display a
	// preview of the new file, update your widget and set the preview active
	// using gtk_file_chooser_set_preview_widget_active(). Otherwise, set the
	// preview inactive.
	//
	// When there is no application-supplied preview widget, or the
	// application-supplied preview widget is not active, the file chooser will
	// display no preview at all.
	SetPreviewWidget(c FileChooser, previewWidget Widget)
	// SetPreviewWidgetActive sets whether the preview widget set by
	// gtk_file_chooser_set_preview_widget() should be shown for the current
	// filename. When @active is set to false, the file chooser may display an
	// internally generated preview of the current file or it may display no
	// preview at all. See gtk_file_chooser_set_preview_widget() for more
	// details.
	SetPreviewWidgetActive(c FileChooser, active bool)
	// SetSelectMultiple sets whether multiple files can be selected in the file
	// selector. This is only relevant if the action is set to be
	// GTK_FILE_CHOOSER_ACTION_OPEN or GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER.
	SetSelectMultiple(c FileChooser, selectMultiple bool)
	// SetShowHidden sets whether hidden files and folders are displayed in the
	// file selector.
	SetShowHidden(c FileChooser, showHidden bool)
	// SetURI sets the file referred to by @uri as the current file for the file
	// chooser, by changing to the URI’s parent folder and actually selecting
	// the URI in the list. If the @chooser is GTK_FILE_CHOOSER_ACTION_SAVE
	// mode, the URI’s base name will also appear in the dialog’s file name
	// entry.
	//
	// Note that the URI must exist, or nothing will be done except for the
	// directory change.
	//
	// You should use this function only when implementing a save dialog for
	// which you already have a file name to which the user may save. For
	// example, when the user opens an existing file and then does Save As... to
	// save a copy or a modified version. If you don’t have a file name already
	// — for example, if the user just created a new file and is saving it for
	// the first time, do not call this function. Instead, use something similar
	// to this:
	//
	//    if (document_is_new)
	//      {
	//        // the user just created a new document
	//        gtk_file_chooser_set_current_name (chooser, "Untitled document");
	//      }
	//    else
	//      {
	//        // the user edited an existing document
	//        gtk_file_chooser_set_uri (chooser, existing_uri);
	//      }
	//
	// In the first case, the file chooser will present the user with useful
	// suggestions as to where to save his new file. In the second case, the
	// file’s existing location is already known, so the file chooser will use
	// it.
	SetURI(c FileChooser, uri string) bool
	// SetUsePreviewLabel sets whether the file chooser should display a stock
	// label with the name of the file that is being previewed; the default is
	// true. Applications that want to draw the whole preview area themselves
	// should set this to false and display the name themselves in their preview
	// widget.
	//
	// See also: gtk_file_chooser_set_preview_widget()
	SetUsePreviewLabel(c FileChooser, useLabel bool)
	// UnselectAll unselects all the files in the current folder of a file
	// chooser.
	UnselectAll(c FileChooser)
	// UnselectFile unselects the file referred to by @file. If the file is not
	// in the current directory, does not exist, or is otherwise not currently
	// selected, does nothing.
	UnselectFile(c FileChooser, file gio.File)
	// UnselectFilename unselects a currently selected filename. If the filename
	// is not in the current directory, does not exist, or is otherwise not
	// currently selected, does nothing.
	UnselectFilename(c FileChooser, filename string)
	// UnselectURI unselects the file referred to by @uri. If the file is not in
	// the current directory, does not exist, or is otherwise not currently
	// selected, does nothing.
	UnselectURI(c FileChooser, uri string)
}

// fileChooser implements the FileChooser interface.
type fileChooser struct {
	gextras.Objector
}

var _ FileChooser = (*fileChooser)(nil)

// WrapFileChooser wraps a GObject to a type that implements interface
// FileChooser. It is primarily used internally.
func WrapFileChooser(obj *externglib.Object) FileChooser {
	return FileChooser{
		Objector: obj,
	}
}

func marshalFileChooser(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileChooser(obj), nil
}

// AddChoice adds a 'choice' to the file chooser. This is typically
// implemented as a combobox or, for boolean choices, as a checkbutton. You
// can select a value using gtk_file_chooser_set_choice() before the dialog
// is shown, and you can obtain the user-selected value in the ::response
// signal handler using gtk_file_chooser_get_choice().
//
// Compare gtk_file_chooser_set_extra_widget().
func (c fileChooser) AddChoice(c FileChooser, id string, label string, options []string, optionLabels []string) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char
	var arg2 *C.char
	var arg3 **C.char
	var arg4 **C.char

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.char)(C.CString(id))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.char)(C.CString(label))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.malloc(len(options) * (unsafe.Sizeof(int(0)) + 1))
	defer C.free(unsafe.Pointer(arg3))

	{
		var out []*C.char
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg3), int(len(options)))

		for i := range options {
			out[i] = (*C.char)(C.CString(options[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}
	arg4 = C.malloc(len(optionLabels) * (unsafe.Sizeof(int(0)) + 1))
	defer C.free(unsafe.Pointer(arg4))

	{
		var out []*C.char
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg4), int(len(optionLabels)))

		for i := range optionLabels {
			out[i] = (*C.char)(C.CString(optionLabels[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.gtk_file_chooser_add_choice(arg0, arg1, arg2, arg3, arg4)
}

// AddFilter adds @filter to the list of filters that the user can select
// between. When a filter is selected, only files that are passed by that
// filter are displayed.
//
// Note that the @chooser takes ownership of the filter, so you have to ref
// and sink it if you want to keep a reference.
func (c fileChooser) AddFilter(c FileChooser, filter FileFilter) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.GtkFileFilter

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.GtkFileFilter)(unsafe.Pointer(filter.Native()))

	C.gtk_file_chooser_add_filter(arg0, arg1)
}

// AddShortcutFolder adds a folder to be displayed with the shortcut folders
// in a file chooser. Note that shortcut folders do not get saved, as they
// are provided by the application. For example, you can use this to add a
// “/usr/share/mydrawprogram/Clipart” folder to the volume list.
func (c fileChooser) AddShortcutFolder(c FileChooser, folder string) error {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.char)(C.CString(folder))
	defer C.free(unsafe.Pointer(arg1))

	var errout *C.GError
	var err error

	C.gtk_file_chooser_add_shortcut_folder(arg0, arg1, &errout)

	err = gerror.Take(unsafe.Pointer(errout))

	return err
}

// AddShortcutFolderURI adds a folder URI to be displayed with the shortcut
// folders in a file chooser. Note that shortcut folders do not get saved,
// as they are provided by the application. For example, you can use this to
// add a “file:///usr/share/mydrawprogram/Clipart” folder to the volume
// list.
func (c fileChooser) AddShortcutFolderURI(c FileChooser, uri string) error {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.char)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	var errout *C.GError
	var err error

	C.gtk_file_chooser_add_shortcut_folder_uri(arg0, arg1, &errout)

	err = gerror.Take(unsafe.Pointer(errout))

	return err
}

// Action gets the type of operation that the file chooser is performing;
// see gtk_file_chooser_set_action().
func (c fileChooser) Action(c FileChooser) {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	C.gtk_file_chooser_get_action(arg0)
}

// Choice gets the currently selected option in the 'choice' with the given
// ID.
func (c fileChooser) Choice(c FileChooser, id string) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.char)(C.CString(id))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_file_chooser_get_choice(arg0, arg1)
}

// CreateFolders gets whether file choser will offer to create new folders.
// See gtk_file_chooser_set_create_folders().
func (c fileChooser) CreateFolders(c FileChooser) bool {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_file_chooser_get_create_folders(arg0)

	if cret {
		ok = true
	}

	return ok
}

// CurrentFolder gets the current folder of @chooser as a local filename.
// See gtk_file_chooser_set_current_folder().
//
// Note that this is the folder that the file chooser is currently
// displaying (e.g. "/home/username/Documents"), which is not the same as
// the currently-selected folder if the chooser is in
// GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER mode (e.g.
// "/home/username/Documents/selected-folder/". To get the
// currently-selected folder in that mode, use gtk_file_chooser_get_uri() as
// the usual way to get the selection.
func (c fileChooser) CurrentFolder(c FileChooser) {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	C.gtk_file_chooser_get_current_folder(arg0)
}

// CurrentFolderFile gets the current folder of @chooser as #GFile. See
// gtk_file_chooser_get_current_folder_uri().
func (c fileChooser) CurrentFolderFile(c FileChooser) {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	C.gtk_file_chooser_get_current_folder_file(arg0)
}

// CurrentFolderURI gets the current folder of @chooser as an URI. See
// gtk_file_chooser_set_current_folder_uri().
//
// Note that this is the folder that the file chooser is currently
// displaying (e.g. "file:///home/username/Documents"), which is not the
// same as the currently-selected folder if the chooser is in
// GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER mode (e.g.
// "file:///home/username/Documents/selected-folder/". To get the
// currently-selected folder in that mode, use gtk_file_chooser_get_uri() as
// the usual way to get the selection.
func (c fileChooser) CurrentFolderURI(c FileChooser) {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	C.gtk_file_chooser_get_current_folder_uri(arg0)
}

// CurrentName gets the current name in the file selector, as entered by the
// user in the text entry for “Name”.
//
// This is meant to be used in save dialogs, to get the currently typed
// filename when the file itself does not exist yet. For example, an
// application that adds a custom extra widget to the file chooser for “file
// format” may want to change the extension of the typed filename based on
// the chosen format, say, from “.jpg” to “.png”.
func (c fileChooser) CurrentName(c FileChooser) {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	C.gtk_file_chooser_get_current_name(arg0)
}

// DoOverwriteConfirmation queries whether a file chooser is set to confirm
// for overwriting when the user types a file name that already exists.
func (c fileChooser) DoOverwriteConfirmation(c FileChooser) bool {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_file_chooser_get_do_overwrite_confirmation(arg0)

	if cret {
		ok = true
	}

	return ok
}

// ExtraWidget gets the current extra widget; see
// gtk_file_chooser_set_extra_widget().
func (c fileChooser) ExtraWidget(c FileChooser) {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	C.gtk_file_chooser_get_extra_widget(arg0)
}

// File gets the #GFile for the currently selected file in the file
// selector. If multiple files are selected, one of the files will be
// returned at random.
//
// If the file chooser is in folder mode, this function returns the selected
// folder.
func (c fileChooser) File(c FileChooser) {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	C.gtk_file_chooser_get_file(arg0)
}

// Filename gets the filename for the currently selected file in the file
// selector. The filename is returned as an absolute path. If multiple files
// are selected, one of the filenames will be returned at random.
//
// If the file chooser is in folder mode, this function returns the selected
// folder.
func (c fileChooser) Filename(c FileChooser) {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	C.gtk_file_chooser_get_filename(arg0)
}

// Filenames lists all the selected files and subfolders in the current
// folder of @chooser. The returned names are full absolute paths. If files
// in the current folder cannot be represented as local filenames they will
// be ignored. (See gtk_file_chooser_get_uris())
func (c fileChooser) Filenames(c FileChooser) {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	C.gtk_file_chooser_get_filenames(arg0)
}

// Files lists all the selected files and subfolders in the current folder
// of @chooser as #GFile. An internal function, see
// gtk_file_chooser_get_uris().
func (c fileChooser) Files(c FileChooser) {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	C.gtk_file_chooser_get_files(arg0)
}

// Filter gets the current filter; see gtk_file_chooser_set_filter().
func (c fileChooser) Filter(c FileChooser) {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	C.gtk_file_chooser_get_filter(arg0)
}

// LocalOnly gets whether only local files can be selected in the file
// selector. See gtk_file_chooser_set_local_only()
func (c fileChooser) LocalOnly(c FileChooser) bool {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_file_chooser_get_local_only(arg0)

	if cret {
		ok = true
	}

	return ok
}

// PreviewFile gets the #GFile that should be previewed in a custom preview
// Internal function, see gtk_file_chooser_get_preview_uri().
func (c fileChooser) PreviewFile(c FileChooser) {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	C.gtk_file_chooser_get_preview_file(arg0)
}

// PreviewFilename gets the filename that should be previewed in a custom
// preview widget. See gtk_file_chooser_set_preview_widget().
func (c fileChooser) PreviewFilename(c FileChooser) {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	C.gtk_file_chooser_get_preview_filename(arg0)
}

// PreviewURI gets the URI that should be previewed in a custom preview
// widget. See gtk_file_chooser_set_preview_widget().
func (c fileChooser) PreviewURI(c FileChooser) {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	C.gtk_file_chooser_get_preview_uri(arg0)
}

// PreviewWidget gets the current preview widget; see
// gtk_file_chooser_set_preview_widget().
func (c fileChooser) PreviewWidget(c FileChooser) {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	C.gtk_file_chooser_get_preview_widget(arg0)
}

// PreviewWidgetActive gets whether the preview widget set by
// gtk_file_chooser_set_preview_widget() should be shown for the current
// filename. See gtk_file_chooser_set_preview_widget_active().
func (c fileChooser) PreviewWidgetActive(c FileChooser) bool {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_file_chooser_get_preview_widget_active(arg0)

	if cret {
		ok = true
	}

	return ok
}

// SelectMultiple gets whether multiple files can be selected in the file
// selector. See gtk_file_chooser_set_select_multiple().
func (c fileChooser) SelectMultiple(c FileChooser) bool {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_file_chooser_get_select_multiple(arg0)

	if cret {
		ok = true
	}

	return ok
}

// ShowHidden gets whether hidden files and folders are displayed in the
// file selector. See gtk_file_chooser_set_show_hidden().
func (c fileChooser) ShowHidden(c FileChooser) bool {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_file_chooser_get_show_hidden(arg0)

	if cret {
		ok = true
	}

	return ok
}

// URI gets the URI for the currently selected file in the file selector. If
// multiple files are selected, one of the filenames will be returned at
// random.
//
// If the file chooser is in folder mode, this function returns the selected
// folder.
func (c fileChooser) URI(c FileChooser) {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	C.gtk_file_chooser_get_uri(arg0)
}

// Uris lists all the selected files and subfolders in the current folder of
// @chooser. The returned names are full absolute URIs.
func (c fileChooser) Uris(c FileChooser) {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	C.gtk_file_chooser_get_uris(arg0)
}

// UsePreviewLabel gets whether a stock label should be drawn with the name
// of the previewed file. See gtk_file_chooser_set_use_preview_label().
func (c fileChooser) UsePreviewLabel(c FileChooser) bool {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_file_chooser_get_use_preview_label(arg0)

	if cret {
		ok = true
	}

	return ok
}

// ListFilters lists the current set of user-selectable filters; see
// gtk_file_chooser_add_filter(), gtk_file_chooser_remove_filter().
func (c fileChooser) ListFilters(c FileChooser) {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	C.gtk_file_chooser_list_filters(arg0)
}

// ListShortcutFolderUris queries the list of shortcut folders in the file
// chooser, as set by gtk_file_chooser_add_shortcut_folder_uri().
func (c fileChooser) ListShortcutFolderUris(c FileChooser) {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	C.gtk_file_chooser_list_shortcut_folder_uris(arg0)
}

// ListShortcutFolders queries the list of shortcut folders in the file
// chooser, as set by gtk_file_chooser_add_shortcut_folder().
func (c fileChooser) ListShortcutFolders(c FileChooser) {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	C.gtk_file_chooser_list_shortcut_folders(arg0)
}

// RemoveChoice removes a 'choice' that has been added with
// gtk_file_chooser_add_choice().
func (c fileChooser) RemoveChoice(c FileChooser, id string) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.char)(C.CString(id))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_file_chooser_remove_choice(arg0, arg1)
}

// RemoveFilter removes @filter from the list of filters that the user can
// select between.
func (c fileChooser) RemoveFilter(c FileChooser, filter FileFilter) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.GtkFileFilter

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.GtkFileFilter)(unsafe.Pointer(filter.Native()))

	C.gtk_file_chooser_remove_filter(arg0, arg1)
}

// RemoveShortcutFolder removes a folder from a file chooser’s list of
// shortcut folders.
func (c fileChooser) RemoveShortcutFolder(c FileChooser, folder string) error {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.char)(C.CString(folder))
	defer C.free(unsafe.Pointer(arg1))

	var errout *C.GError
	var err error

	C.gtk_file_chooser_remove_shortcut_folder(arg0, arg1, &errout)

	err = gerror.Take(unsafe.Pointer(errout))

	return err
}

// RemoveShortcutFolderURI removes a folder URI from a file chooser’s list
// of shortcut folders.
func (c fileChooser) RemoveShortcutFolderURI(c FileChooser, uri string) error {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.char)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	var errout *C.GError
	var err error

	C.gtk_file_chooser_remove_shortcut_folder_uri(arg0, arg1, &errout)

	err = gerror.Take(unsafe.Pointer(errout))

	return err
}

// SelectAll selects all the files in the current folder of a file chooser.
func (c fileChooser) SelectAll(c FileChooser) {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	C.gtk_file_chooser_select_all(arg0)
}

// SelectFile selects the file referred to by @file. An internal function.
// See _gtk_file_chooser_select_uri().
func (c fileChooser) SelectFile(c FileChooser, file gio.File) error {
	var arg0 *C.GtkFileChooser
	var arg1 *C.GFile

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

	var errout *C.GError
	var err error

	C.gtk_file_chooser_select_file(arg0, arg1, &errout)

	err = gerror.Take(unsafe.Pointer(errout))

	return err
}

// SelectFilename selects a filename. If the file name isn’t in the current
// folder of @chooser, then the current folder of @chooser will be changed
// to the folder containing @filename.
func (c fileChooser) SelectFilename(c FileChooser, filename string) bool {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_file_chooser_select_filename(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// SelectURI selects the file to by @uri. If the URI doesn’t refer to a file
// in the current folder of @chooser, then the current folder of @chooser
// will be changed to the folder containing @filename.
func (c fileChooser) SelectURI(c FileChooser, uri string) bool {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.char)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_file_chooser_select_uri(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// SetAction sets the type of operation that the chooser is performing; the
// user interface is adapted to suit the selected action. For example, an
// option to create a new folder might be shown if the action is
// GTK_FILE_CHOOSER_ACTION_SAVE but not if the action is
// GTK_FILE_CHOOSER_ACTION_OPEN.
func (c fileChooser) SetAction(c FileChooser, action FileChooserAction) {
	var arg0 *C.GtkFileChooser
	var arg1 C.GtkFileChooserAction

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (C.GtkFileChooserAction)(action)

	C.gtk_file_chooser_set_action(arg0, arg1)
}

// SetChoice selects an option in a 'choice' that has been added with
// gtk_file_chooser_add_choice(). For a boolean choice, the possible options
// are "true" and "false".
func (c fileChooser) SetChoice(c FileChooser, id string, option string) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char
	var arg2 *C.char

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.char)(C.CString(id))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.char)(C.CString(option))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_file_chooser_set_choice(arg0, arg1, arg2)
}

// SetCreateFolders sets whether file choser will offer to create new
// folders. This is only relevant if the action is not set to be
// GTK_FILE_CHOOSER_ACTION_OPEN.
func (c fileChooser) SetCreateFolders(c FileChooser, createFolders bool) {
	var arg0 *C.GtkFileChooser
	var arg1 C.gboolean

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	if createFolders {
		arg1 = C.gboolean(1)
	}

	C.gtk_file_chooser_set_create_folders(arg0, arg1)
}

// SetCurrentFolder sets the current folder for @chooser from a local
// filename. The user will be shown the full contents of the current folder,
// plus user interface elements for navigating to other folders.
//
// In general, you should not use this function. See the [section on setting
// up a file chooser dialog][gtkfilechooserdialog-setting-up] for the
// rationale behind this.
func (c fileChooser) SetCurrentFolder(c FileChooser, filename string) bool {
	var arg0 *C.GtkFileChooser
	var arg1 *C.gchar

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_file_chooser_set_current_folder(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// SetCurrentFolderFile sets the current folder for @chooser from a #GFile.
// Internal function, see gtk_file_chooser_set_current_folder_uri().
func (c fileChooser) SetCurrentFolderFile(c FileChooser, file gio.File) error {
	var arg0 *C.GtkFileChooser
	var arg1 *C.GFile

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

	var errout *C.GError
	var err error

	C.gtk_file_chooser_set_current_folder_file(arg0, arg1, &errout)

	err = gerror.Take(unsafe.Pointer(errout))

	return err
}

// SetCurrentFolderURI sets the current folder for @chooser from an URI. The
// user will be shown the full contents of the current folder, plus user
// interface elements for navigating to other folders.
//
// In general, you should not use this function. See the [section on setting
// up a file chooser dialog][gtkfilechooserdialog-setting-up] for the
// rationale behind this.
func (c fileChooser) SetCurrentFolderURI(c FileChooser, uri string) bool {
	var arg0 *C.GtkFileChooser
	var arg1 *C.gchar

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_file_chooser_set_current_folder_uri(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// SetCurrentName sets the current name in the file selector, as if entered
// by the user. Note that the name passed in here is a UTF-8 string rather
// than a filename. This function is meant for such uses as a suggested name
// in a “Save As...” dialog. You can pass “Untitled.doc” or a similarly
// suitable suggestion for the @name.
//
// If you want to preselect a particular existing file, you should use
// gtk_file_chooser_set_filename() or gtk_file_chooser_set_uri() instead.
// Please see the documentation for those functions for an example of using
// gtk_file_chooser_set_current_name() as well.
func (c fileChooser) SetCurrentName(c FileChooser, name string) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.gchar

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_file_chooser_set_current_name(arg0, arg1)
}

// SetDoOverwriteConfirmation sets whether a file chooser in
// GTK_FILE_CHOOSER_ACTION_SAVE mode will present a confirmation dialog if
// the user types a file name that already exists. This is false by default.
//
// If set to true, the @chooser will emit the FileChooser::confirm-overwrite
// signal when appropriate.
//
// If all you need is the stock confirmation dialog, set this property to
// true. You can override the way confirmation is done by actually handling
// the FileChooser::confirm-overwrite signal; please refer to its
// documentation for the details.
func (c fileChooser) SetDoOverwriteConfirmation(c FileChooser, doOverwriteConfirmation bool) {
	var arg0 *C.GtkFileChooser
	var arg1 C.gboolean

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	if doOverwriteConfirmation {
		arg1 = C.gboolean(1)
	}

	C.gtk_file_chooser_set_do_overwrite_confirmation(arg0, arg1)
}

// SetExtraWidget sets an application-supplied widget to provide extra
// options to the user.
func (c fileChooser) SetExtraWidget(c FileChooser, extraWidget Widget) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(extraWidget.Native()))

	C.gtk_file_chooser_set_extra_widget(arg0, arg1)
}

// SetFile sets @file as the current filename for the file chooser, by
// changing to the file’s parent folder and actually selecting the file in
// list. If the @chooser is in GTK_FILE_CHOOSER_ACTION_SAVE mode, the file’s
// base name will also appear in the dialog’s file name entry.
//
// If the file name isn’t in the current folder of @chooser, then the
// current folder of @chooser will be changed to the folder containing
// @filename. This is equivalent to a sequence of
// gtk_file_chooser_unselect_all() followed by
// gtk_file_chooser_select_filename().
//
// Note that the file must exist, or nothing will be done except for the
// directory change.
//
// If you are implementing a save dialog, you should use this function if
// you already have a file name to which the user may save; for example,
// when the user opens an existing file and then does Save As... If you
// don’t have a file name already — for example, if the user just created a
// new file and is saving it for the first time, do not call this function.
// Instead, use something similar to this:
//
//    if (document_is_new)
//      {
//        // the user just created a new document
//        gtk_file_chooser_set_current_folder_file (chooser, default_file_for_saving);
//        gtk_file_chooser_set_current_name (chooser, "Untitled document");
//      }
//    else
//      {
//        // the user edited an existing document
//        gtk_file_chooser_set_file (chooser, existing_file);
//      }
func (c fileChooser) SetFile(c FileChooser, file gio.File) error {
	var arg0 *C.GtkFileChooser
	var arg1 *C.GFile

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

	var errout *C.GError
	var err error

	C.gtk_file_chooser_set_file(arg0, arg1, &errout)

	err = gerror.Take(unsafe.Pointer(errout))

	return err
}

// SetFilename sets @filename as the current filename for the file chooser,
// by changing to the file’s parent folder and actually selecting the file
// in list; all other files will be unselected. If the @chooser is in
// GTK_FILE_CHOOSER_ACTION_SAVE mode, the file’s base name will also appear
// in the dialog’s file name entry.
//
// Note that the file must exist, or nothing will be done except for the
// directory change.
//
// You should use this function only when implementing a save dialog for
// which you already have a file name to which the user may save. For
// example, when the user opens an existing file and then does Save As... to
// save a copy or a modified version. If you don’t have a file name already
// — for example, if the user just created a new file and is saving it for
// the first time, do not call this function. Instead, use something similar
// to this:
//
//    if (document_is_new)
//      {
//        // the user just created a new document
//        gtk_file_chooser_set_current_name (chooser, "Untitled document");
//      }
//    else
//      {
//        // the user edited an existing document
//        gtk_file_chooser_set_filename (chooser, existing_filename);
//      }
//
// In the first case, the file chooser will present the user with useful
// suggestions as to where to save his new file. In the second case, the
// file’s existing location is already known, so the file chooser will use
// it.
func (c fileChooser) SetFilename(c FileChooser, filename string) bool {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_file_chooser_set_filename(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// SetFilter sets the current filter; only the files that pass the filter
// will be displayed. If the user-selectable list of filters is non-empty,
// then the filter should be one of the filters in that list. Setting the
// current filter when the list of filters is empty is useful if you want to
// restrict the displayed set of files without letting the user change it.
func (c fileChooser) SetFilter(c FileChooser, filter FileFilter) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.GtkFileFilter

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.GtkFileFilter)(unsafe.Pointer(filter.Native()))

	C.gtk_file_chooser_set_filter(arg0, arg1)
}

// SetLocalOnly sets whether only local files can be selected in the file
// selector. If @local_only is true (the default), then the selected file or
// files are guaranteed to be accessible through the operating systems
// native file system and therefore the application only needs to worry
// about the filename functions in FileChooser, like
// gtk_file_chooser_get_filename(), rather than the URI functions like
// gtk_file_chooser_get_uri(),
//
// On some systems non-native files may still be available using the native
// filesystem via a userspace filesystem (FUSE).
func (c fileChooser) SetLocalOnly(c FileChooser, localOnly bool) {
	var arg0 *C.GtkFileChooser
	var arg1 C.gboolean

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	if localOnly {
		arg1 = C.gboolean(1)
	}

	C.gtk_file_chooser_set_local_only(arg0, arg1)
}

// SetPreviewWidget sets an application-supplied widget to use to display a
// custom preview of the currently selected file. To implement a preview,
// after setting the preview widget, you connect to the
// FileChooser::update-preview signal, and call
// gtk_file_chooser_get_preview_filename() or
// gtk_file_chooser_get_preview_uri() on each change. If you can display a
// preview of the new file, update your widget and set the preview active
// using gtk_file_chooser_set_preview_widget_active(). Otherwise, set the
// preview inactive.
//
// When there is no application-supplied preview widget, or the
// application-supplied preview widget is not active, the file chooser will
// display no preview at all.
func (c fileChooser) SetPreviewWidget(c FileChooser, previewWidget Widget) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(previewWidget.Native()))

	C.gtk_file_chooser_set_preview_widget(arg0, arg1)
}

// SetPreviewWidgetActive sets whether the preview widget set by
// gtk_file_chooser_set_preview_widget() should be shown for the current
// filename. When @active is set to false, the file chooser may display an
// internally generated preview of the current file or it may display no
// preview at all. See gtk_file_chooser_set_preview_widget() for more
// details.
func (c fileChooser) SetPreviewWidgetActive(c FileChooser, active bool) {
	var arg0 *C.GtkFileChooser
	var arg1 C.gboolean

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	if active {
		arg1 = C.gboolean(1)
	}

	C.gtk_file_chooser_set_preview_widget_active(arg0, arg1)
}

// SetSelectMultiple sets whether multiple files can be selected in the file
// selector. This is only relevant if the action is set to be
// GTK_FILE_CHOOSER_ACTION_OPEN or GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER.
func (c fileChooser) SetSelectMultiple(c FileChooser, selectMultiple bool) {
	var arg0 *C.GtkFileChooser
	var arg1 C.gboolean

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	if selectMultiple {
		arg1 = C.gboolean(1)
	}

	C.gtk_file_chooser_set_select_multiple(arg0, arg1)
}

// SetShowHidden sets whether hidden files and folders are displayed in the
// file selector.
func (c fileChooser) SetShowHidden(c FileChooser, showHidden bool) {
	var arg0 *C.GtkFileChooser
	var arg1 C.gboolean

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	if showHidden {
		arg1 = C.gboolean(1)
	}

	C.gtk_file_chooser_set_show_hidden(arg0, arg1)
}

// SetURI sets the file referred to by @uri as the current file for the file
// chooser, by changing to the URI’s parent folder and actually selecting
// the URI in the list. If the @chooser is GTK_FILE_CHOOSER_ACTION_SAVE
// mode, the URI’s base name will also appear in the dialog’s file name
// entry.
//
// Note that the URI must exist, or nothing will be done except for the
// directory change.
//
// You should use this function only when implementing a save dialog for
// which you already have a file name to which the user may save. For
// example, when the user opens an existing file and then does Save As... to
// save a copy or a modified version. If you don’t have a file name already
// — for example, if the user just created a new file and is saving it for
// the first time, do not call this function. Instead, use something similar
// to this:
//
//    if (document_is_new)
//      {
//        // the user just created a new document
//        gtk_file_chooser_set_current_name (chooser, "Untitled document");
//      }
//    else
//      {
//        // the user edited an existing document
//        gtk_file_chooser_set_uri (chooser, existing_uri);
//      }
//
// In the first case, the file chooser will present the user with useful
// suggestions as to where to save his new file. In the second case, the
// file’s existing location is already known, so the file chooser will use
// it.
func (c fileChooser) SetURI(c FileChooser, uri string) bool {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.char)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_file_chooser_set_uri(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// SetUsePreviewLabel sets whether the file chooser should display a stock
// label with the name of the file that is being previewed; the default is
// true. Applications that want to draw the whole preview area themselves
// should set this to false and display the name themselves in their preview
// widget.
//
// See also: gtk_file_chooser_set_preview_widget()
func (c fileChooser) SetUsePreviewLabel(c FileChooser, useLabel bool) {
	var arg0 *C.GtkFileChooser
	var arg1 C.gboolean

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	if useLabel {
		arg1 = C.gboolean(1)
	}

	C.gtk_file_chooser_set_use_preview_label(arg0, arg1)
}

// UnselectAll unselects all the files in the current folder of a file
// chooser.
func (c fileChooser) UnselectAll(c FileChooser) {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	C.gtk_file_chooser_unselect_all(arg0)
}

// UnselectFile unselects the file referred to by @file. If the file is not
// in the current directory, does not exist, or is otherwise not currently
// selected, does nothing.
func (c fileChooser) UnselectFile(c FileChooser, file gio.File) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.GFile

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

	C.gtk_file_chooser_unselect_file(arg0, arg1)
}

// UnselectFilename unselects a currently selected filename. If the filename
// is not in the current directory, does not exist, or is otherwise not
// currently selected, does nothing.
func (c fileChooser) UnselectFilename(c FileChooser, filename string) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_file_chooser_unselect_filename(arg0, arg1)
}

// UnselectURI unselects the file referred to by @uri. If the file is not in
// the current directory, does not exist, or is otherwise not currently
// selected, does nothing.
func (c fileChooser) UnselectURI(c FileChooser, uri string) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.char)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_file_chooser_unselect_uri(arg0, arg1)
}

// Clipboard: the Clipboard object represents a clipboard of data shared between
// different processes or between different widgets in the same process. Each
// clipboard is identified by a name encoded as a Atom. (Conversion to and from
// strings can be done with gdk_atom_intern() and gdk_atom_name().) The default
// clipboard corresponds to the “CLIPBOARD” atom; another commonly used
// clipboard is the “PRIMARY” clipboard, which, in X, traditionally contains the
// currently selected text.
//
// To support having a number of different formats on the clipboard at the same
// time, the clipboard mechanism allows providing callbacks instead of the
// actual data. When you set the contents of the clipboard, you can either
// supply the data directly (via functions like gtk_clipboard_set_text()), or
// you can supply a callback to be called at a later time when the data is
// needed (via gtk_clipboard_set_with_data() or gtk_clipboard_set_with_owner().)
// Providing a callback also avoids having to make copies of the data when it is
// not needed.
//
// gtk_clipboard_set_with_data() and gtk_clipboard_set_with_owner() are quite
// similar; the choice between the two depends mostly on which is more
// convenient in a particular situation. The former is most useful when you want
// to have a blob of data with callbacks to convert it into the various data
// types that you advertise. When the @clear_func you provided is called, you
// simply free the data blob. The latter is more useful when the contents of
// clipboard reflect the internal state of a #GObject (As an example, for the
// PRIMARY clipboard, when an entry widget provides the clipboard’s contents the
// contents are simply the text within the selected region.) If the contents
// change, the entry widget can call gtk_clipboard_set_with_owner() to update
// the timestamp for clipboard ownership, without having to worry about
// @clear_func being called.
//
// Requesting the data from the clipboard is essentially asynchronous. If the
// contents of the clipboard are provided within the same process, then a direct
// function call will be made to retrieve the data, but if they are provided by
// another process, then the data needs to be retrieved from the other process,
// which may take some time. To avoid blocking the user interface, the call to
// request the selection, gtk_clipboard_request_contents() takes a callback that
// will be called when the contents are received (or when the request fails.) If
// you don’t want to deal with providing a separate callback, you can also use
// gtk_clipboard_wait_for_contents(). What this does is run the GLib main loop
// recursively waiting for the contents. This can simplify the code flow, but
// you still have to be aware that other callbacks in your program can be called
// while this recursive mainloop is running.
//
// Along with the functions to get the clipboard contents as an arbitrary data
// chunk, there are also functions to retrieve it as text,
// gtk_clipboard_request_text() and gtk_clipboard_wait_for_text(). These
// functions take care of determining which formats are advertised by the
// clipboard provider, asking for the clipboard in the best available format and
// converting the results into the UTF-8 encoding. (The standard form for
// representing strings in GTK+.)
type Clipboard interface {
	gextras.Objector

	// Clear clears the contents of the clipboard. Generally this should only be
	// called between the time you call gtk_clipboard_set_with_owner() or
	// gtk_clipboard_set_with_data(), and when the @clear_func you supplied is
	// called. Otherwise, the clipboard may be owned by someone else.
	Clear(c Clipboard)
	// Display gets the Display associated with @clipboard
	Display(c Clipboard)
	// Owner: if the clipboard contents callbacks were set with
	// gtk_clipboard_set_with_owner(), and the gtk_clipboard_set_with_data() or
	// gtk_clipboard_clear() has not subsequently called, returns the owner set
	// by gtk_clipboard_set_with_owner().
	Owner(c Clipboard)
	// Selection gets the selection that this clipboard is for.
	Selection(c Clipboard)
	// RequestContents requests the contents of clipboard as the given target.
	// When the results of the result are later received the supplied callback
	// will be called.
	RequestContents(c Clipboard)
	// RequestImage requests the contents of the clipboard as image. When the
	// image is later received, it will be converted to a Pixbuf, and @callback
	// will be called.
	//
	// The @pixbuf parameter to @callback will contain the resulting Pixbuf if
	// the request succeeded, or nil if it failed. This could happen for various
	// reasons, in particular if the clipboard was empty or if the contents of
	// the clipboard could not be converted into an image.
	RequestImage(c Clipboard)
	// RequestRichText requests the contents of the clipboard as rich text. When
	// the rich text is later received, @callback will be called.
	//
	// The @text parameter to @callback will contain the resulting rich text if
	// the request succeeded, or nil if it failed. The @length parameter will
	// contain @text’s length. This function can fail for various reasons, in
	// particular if the clipboard was empty or if the contents of the clipboard
	// could not be converted into rich text form.
	RequestRichText(c Clipboard)
	// RequestTargets requests the contents of the clipboard as list of
	// supported targets. When the list is later received, @callback will be
	// called.
	//
	// The @targets parameter to @callback will contain the resulting targets if
	// the request succeeded, or nil if it failed.
	RequestTargets(c Clipboard)
	// RequestText requests the contents of the clipboard as text. When the text
	// is later received, it will be converted to UTF-8 if necessary, and
	// @callback will be called.
	//
	// The @text parameter to @callback will contain the resulting text if the
	// request succeeded, or nil if it failed. This could happen for various
	// reasons, in particular if the clipboard was empty or if the contents of
	// the clipboard could not be converted into text form.
	RequestText(c Clipboard)
	// RequestUris requests the contents of the clipboard as URIs. When the URIs
	// are later received @callback will be called.
	//
	// The @uris parameter to @callback will contain the resulting array of URIs
	// if the request succeeded, or nil if it failed. This could happen for
	// various reasons, in particular if the clipboard was empty or if the
	// contents of the clipboard could not be converted into URI form.
	RequestUris(c Clipboard)
	// SetCanStore hints that the clipboard data should be stored somewhere when
	// the application exits or when gtk_clipboard_store () is called.
	//
	// This value is reset when the clipboard owner changes. Where the clipboard
	// data is stored is platform dependent, see gdk_display_store_clipboard ()
	// for more information.
	SetCanStore(c Clipboard)
	// SetImage sets the contents of the clipboard to the given Pixbuf. GTK+
	// will take responsibility for responding for requests for the image, and
	// for converting the image into the requested format.
	SetImage(c Clipboard, pixbuf gdkpixbuf.Pixbuf)
	// SetText sets the contents of the clipboard to the given UTF-8 string.
	// GTK+ will make a copy of the text and take responsibility for responding
	// for requests for the text, and for converting the text into the requested
	// format.
	SetText(c Clipboard, text string, len int)
	// SetWithData: virtually sets the contents of the specified clipboard by
	// providing a list of supported formats for the clipboard data and a
	// function to call to get the actual data when it is requested.
	SetWithData(c Clipboard) bool
	// Store stores the current clipboard data somewhere so that it will stay
	// around after the application has quit.
	Store(c Clipboard)
	// WaitForContents requests the contents of the clipboard using the given
	// target. This function waits for the data to be received using the main
	// loop, so events, timeouts, etc, may be dispatched during the wait.
	WaitForContents(c Clipboard, target gdk.Atom)
	// WaitForImage requests the contents of the clipboard as image and converts
	// the result to a Pixbuf. This function waits for the data to be received
	// using the main loop, so events, timeouts, etc, may be dispatched during
	// the wait.
	WaitForImage(c Clipboard)
	// WaitForRichText requests the contents of the clipboard as rich text. This
	// function waits for the data to be received using the main loop, so
	// events, timeouts, etc, may be dispatched during the wait.
	WaitForRichText(c Clipboard, buffer TextBuffer) (format *gdk.Atom, length uint)
	// WaitForTargets returns a list of targets that are present on the
	// clipboard, or nil if there aren’t any targets available. The returned
	// list must be freed with g_free(). This function waits for the data to be
	// received using the main loop, so events, timeouts, etc, may be dispatched
	// during the wait.
	WaitForTargets(c Clipboard) bool
	// WaitForText requests the contents of the clipboard as text and converts
	// the result to UTF-8 if necessary. This function waits for the data to be
	// received using the main loop, so events, timeouts, etc, may be dispatched
	// during the wait.
	WaitForText(c Clipboard)
	// WaitForUris requests the contents of the clipboard as URIs. This function
	// waits for the data to be received using the main loop, so events,
	// timeouts, etc, may be dispatched during the wait.
	WaitForUris(c Clipboard)
	// WaitIsImageAvailable: test to see if there is an image available to be
	// pasted This is done by requesting the TARGETS atom and checking if it
	// contains any of the supported image targets. This function waits for the
	// data to be received using the main loop, so events, timeouts, etc, may be
	// dispatched during the wait.
	//
	// This function is a little faster than calling
	// gtk_clipboard_wait_for_image() since it doesn’t need to retrieve the
	// actual image data.
	WaitIsImageAvailable(c Clipboard) bool
	// WaitIsRichTextAvailable: test to see if there is rich text available to
	// be pasted This is done by requesting the TARGETS atom and checking if it
	// contains any of the supported rich text targets. This function waits for
	// the data to be received using the main loop, so events, timeouts, etc,
	// may be dispatched during the wait.
	//
	// This function is a little faster than calling
	// gtk_clipboard_wait_for_rich_text() since it doesn’t need to retrieve the
	// actual text.
	WaitIsRichTextAvailable(c Clipboard, buffer TextBuffer) bool
	// WaitIsTargetAvailable checks if a clipboard supports pasting data of a
	// given type. This function can be used to determine if a “Paste” menu item
	// should be insensitive or not.
	//
	// If you want to see if there’s text available on the clipboard, use
	// gtk_clipboard_wait_is_text_available () instead.
	WaitIsTargetAvailable(c Clipboard, target gdk.Atom) bool
	// WaitIsTextAvailable: test to see if there is text available to be pasted
	// This is done by requesting the TARGETS atom and checking if it contains
	// any of the supported text targets. This function waits for the data to be
	// received using the main loop, so events, timeouts, etc, may be dispatched
	// during the wait.
	//
	// This function is a little faster than calling
	// gtk_clipboard_wait_for_text() since it doesn’t need to retrieve the
	// actual text.
	WaitIsTextAvailable(c Clipboard) bool
	// WaitIsUrisAvailable: test to see if there is a list of URIs available to
	// be pasted This is done by requesting the TARGETS atom and checking if it
	// contains the URI targets. This function waits for the data to be received
	// using the main loop, so events, timeouts, etc, may be dispatched during
	// the wait.
	//
	// This function is a little faster than calling
	// gtk_clipboard_wait_for_uris() since it doesn’t need to retrieve the
	// actual URI data.
	WaitIsUrisAvailable(c Clipboard) bool
}

// clipboard implements the Clipboard interface.
type clipboard struct {
	gextras.Objector
}

var _ Clipboard = (*clipboard)(nil)

// WrapClipboard wraps a GObject to the right type. It is
// primarily used internally.
func WrapClipboard(obj *externglib.Object) Clipboard {
	return Clipboard{
		Objector: obj,
	}
}

func marshalClipboard(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapClipboard(obj), nil
}

// Clear clears the contents of the clipboard. Generally this should only be
// called between the time you call gtk_clipboard_set_with_owner() or
// gtk_clipboard_set_with_data(), and when the @clear_func you supplied is
// called. Otherwise, the clipboard may be owned by someone else.
func (c clipboard) Clear(c Clipboard) {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

	C.gtk_clipboard_clear(arg0)
}

// Display gets the Display associated with @clipboard
func (c clipboard) Display(c Clipboard) {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

	C.gtk_clipboard_get_display(arg0)
}

// Owner: if the clipboard contents callbacks were set with
// gtk_clipboard_set_with_owner(), and the gtk_clipboard_set_with_data() or
// gtk_clipboard_clear() has not subsequently called, returns the owner set
// by gtk_clipboard_set_with_owner().
func (c clipboard) Owner(c Clipboard) {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

	C.gtk_clipboard_get_owner(arg0)
}

// Selection gets the selection that this clipboard is for.
func (c clipboard) Selection(c Clipboard) {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

	C.gtk_clipboard_get_selection(arg0)
}

// RequestContents requests the contents of clipboard as the given target.
// When the results of the result are later received the supplied callback
// will be called.
func (c clipboard) RequestContents(c Clipboard) {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

	C.gtk_clipboard_request_contents(arg0, arg1, arg2, arg3)
}

// RequestImage requests the contents of the clipboard as image. When the
// image is later received, it will be converted to a Pixbuf, and @callback
// will be called.
//
// The @pixbuf parameter to @callback will contain the resulting Pixbuf if
// the request succeeded, or nil if it failed. This could happen for various
// reasons, in particular if the clipboard was empty or if the contents of
// the clipboard could not be converted into an image.
func (c clipboard) RequestImage(c Clipboard) {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

	C.gtk_clipboard_request_image(arg0, arg1, arg2)
}

// RequestRichText requests the contents of the clipboard as rich text. When
// the rich text is later received, @callback will be called.
//
// The @text parameter to @callback will contain the resulting rich text if
// the request succeeded, or nil if it failed. The @length parameter will
// contain @text’s length. This function can fail for various reasons, in
// particular if the clipboard was empty or if the contents of the clipboard
// could not be converted into rich text form.
func (c clipboard) RequestRichText(c Clipboard) {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

	C.gtk_clipboard_request_rich_text(arg0, arg1, arg2, arg3)
}

// RequestTargets requests the contents of the clipboard as list of
// supported targets. When the list is later received, @callback will be
// called.
//
// The @targets parameter to @callback will contain the resulting targets if
// the request succeeded, or nil if it failed.
func (c clipboard) RequestTargets(c Clipboard) {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

	C.gtk_clipboard_request_targets(arg0, arg1, arg2)
}

// RequestText requests the contents of the clipboard as text. When the text
// is later received, it will be converted to UTF-8 if necessary, and
// @callback will be called.
//
// The @text parameter to @callback will contain the resulting text if the
// request succeeded, or nil if it failed. This could happen for various
// reasons, in particular if the clipboard was empty or if the contents of
// the clipboard could not be converted into text form.
func (c clipboard) RequestText(c Clipboard) {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

	C.gtk_clipboard_request_text(arg0, arg1, arg2)
}

// RequestUris requests the contents of the clipboard as URIs. When the URIs
// are later received @callback will be called.
//
// The @uris parameter to @callback will contain the resulting array of URIs
// if the request succeeded, or nil if it failed. This could happen for
// various reasons, in particular if the clipboard was empty or if the
// contents of the clipboard could not be converted into URI form.
func (c clipboard) RequestUris(c Clipboard) {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

	C.gtk_clipboard_request_uris(arg0, arg1, arg2)
}

// SetCanStore hints that the clipboard data should be stored somewhere when
// the application exits or when gtk_clipboard_store () is called.
//
// This value is reset when the clipboard owner changes. Where the clipboard
// data is stored is platform dependent, see gdk_display_store_clipboard ()
// for more information.
func (c clipboard) SetCanStore(c Clipboard) {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

	C.gtk_clipboard_set_can_store(arg0, arg1, arg2)
}

// SetImage sets the contents of the clipboard to the given Pixbuf. GTK+
// will take responsibility for responding for requests for the image, and
// for converting the image into the requested format.
func (c clipboard) SetImage(c Clipboard, pixbuf gdkpixbuf.Pixbuf) {
	var arg0 *C.GtkClipboard
	var arg1 *C.GdkPixbuf

	arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))
	arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	C.gtk_clipboard_set_image(arg0, arg1)
}

// SetText sets the contents of the clipboard to the given UTF-8 string.
// GTK+ will make a copy of the text and take responsibility for responding
// for requests for the text, and for converting the text into the requested
// format.
func (c clipboard) SetText(c Clipboard, text string, len int) {
	var arg0 *C.GtkClipboard
	var arg1 *C.gchar
	var arg2 C.gint

	arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(len)

	C.gtk_clipboard_set_text(arg0, arg1, arg2)
}

// SetWithData: virtually sets the contents of the specified clipboard by
// providing a list of supported formats for the clipboard data and a
// function to call to get the actual data when it is requested.
func (c clipboard) SetWithData(c Clipboard) bool {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_clipboard_set_with_data(arg0, arg1, arg2, arg3, arg4, arg5)

	if cret {
		ok = true
	}

	return ok
}

// Store stores the current clipboard data somewhere so that it will stay
// around after the application has quit.
func (c clipboard) Store(c Clipboard) {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

	C.gtk_clipboard_store(arg0)
}

// WaitForContents requests the contents of the clipboard using the given
// target. This function waits for the data to be received using the main
// loop, so events, timeouts, etc, may be dispatched during the wait.
func (c clipboard) WaitForContents(c Clipboard, target gdk.Atom) {
	var arg0 *C.GtkClipboard
	var arg1 C.GdkAtom

	arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))
	arg1 = (C.GdkAtom)(unsafe.Pointer(target.Native()))

	C.gtk_clipboard_wait_for_contents(arg0, arg1)
}

// WaitForImage requests the contents of the clipboard as image and converts
// the result to a Pixbuf. This function waits for the data to be received
// using the main loop, so events, timeouts, etc, may be dispatched during
// the wait.
func (c clipboard) WaitForImage(c Clipboard) {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

	C.gtk_clipboard_wait_for_image(arg0)
}

// WaitForRichText requests the contents of the clipboard as rich text. This
// function waits for the data to be received using the main loop, so
// events, timeouts, etc, may be dispatched during the wait.
func (c clipboard) WaitForRichText(c Clipboard, buffer TextBuffer) (format *gdk.Atom, length uint) {
	var arg0 *C.GtkClipboard
	var arg1 *C.GtkTextBuffer

	arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))
	arg1 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	var arg2 C.GdkAtom
	var format *gdk.Atom
	var arg3 C.gsize
	var length uint

	C.gtk_clipboard_wait_for_rich_text(arg0, arg1, &arg2, &arg3)

	format = gdk.WrapAtom(unsafe.Pointer(&arg2))
	length = uint(&arg3)

	return format, length
}

// WaitForTargets returns a list of targets that are present on the
// clipboard, or nil if there aren’t any targets available. The returned
// list must be freed with g_free(). This function waits for the data to be
// received using the main loop, so events, timeouts, etc, may be dispatched
// during the wait.
func (c clipboard) WaitForTargets(c Clipboard) bool {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_clipboard_wait_for_targets(arg0, &arg1, &arg2)

	if cret {
		ok = true
	}

	return targets, nTargets, ok
}

// WaitForText requests the contents of the clipboard as text and converts
// the result to UTF-8 if necessary. This function waits for the data to be
// received using the main loop, so events, timeouts, etc, may be dispatched
// during the wait.
func (c clipboard) WaitForText(c Clipboard) {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

	C.gtk_clipboard_wait_for_text(arg0)
}

// WaitForUris requests the contents of the clipboard as URIs. This function
// waits for the data to be received using the main loop, so events,
// timeouts, etc, may be dispatched during the wait.
func (c clipboard) WaitForUris(c Clipboard) {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

	C.gtk_clipboard_wait_for_uris(arg0)
}

// WaitIsImageAvailable: test to see if there is an image available to be
// pasted This is done by requesting the TARGETS atom and checking if it
// contains any of the supported image targets. This function waits for the
// data to be received using the main loop, so events, timeouts, etc, may be
// dispatched during the wait.
//
// This function is a little faster than calling
// gtk_clipboard_wait_for_image() since it doesn’t need to retrieve the
// actual image data.
func (c clipboard) WaitIsImageAvailable(c Clipboard) bool {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_clipboard_wait_is_image_available(arg0)

	if cret {
		ok = true
	}

	return ok
}

// WaitIsRichTextAvailable: test to see if there is rich text available to
// be pasted This is done by requesting the TARGETS atom and checking if it
// contains any of the supported rich text targets. This function waits for
// the data to be received using the main loop, so events, timeouts, etc,
// may be dispatched during the wait.
//
// This function is a little faster than calling
// gtk_clipboard_wait_for_rich_text() since it doesn’t need to retrieve the
// actual text.
func (c clipboard) WaitIsRichTextAvailable(c Clipboard, buffer TextBuffer) bool {
	var arg0 *C.GtkClipboard
	var arg1 *C.GtkTextBuffer

	arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))
	arg1 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_clipboard_wait_is_rich_text_available(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// WaitIsTargetAvailable checks if a clipboard supports pasting data of a
// given type. This function can be used to determine if a “Paste” menu item
// should be insensitive or not.
//
// If you want to see if there’s text available on the clipboard, use
// gtk_clipboard_wait_is_text_available () instead.
func (c clipboard) WaitIsTargetAvailable(c Clipboard, target gdk.Atom) bool {
	var arg0 *C.GtkClipboard
	var arg1 C.GdkAtom

	arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))
	arg1 = (C.GdkAtom)(unsafe.Pointer(target.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_clipboard_wait_is_target_available(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// WaitIsTextAvailable: test to see if there is text available to be pasted
// This is done by requesting the TARGETS atom and checking if it contains
// any of the supported text targets. This function waits for the data to be
// received using the main loop, so events, timeouts, etc, may be dispatched
// during the wait.
//
// This function is a little faster than calling
// gtk_clipboard_wait_for_text() since it doesn’t need to retrieve the
// actual text.
func (c clipboard) WaitIsTextAvailable(c Clipboard) bool {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_clipboard_wait_is_text_available(arg0)

	if cret {
		ok = true
	}

	return ok
}

// WaitIsUrisAvailable: test to see if there is a list of URIs available to
// be pasted This is done by requesting the TARGETS atom and checking if it
// contains the URI targets. This function waits for the data to be received
// using the main loop, so events, timeouts, etc, may be dispatched during
// the wait.
//
// This function is a little faster than calling
// gtk_clipboard_wait_for_uris() since it doesn’t need to retrieve the
// actual URI data.
func (c clipboard) WaitIsUrisAvailable(c Clipboard) bool {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_clipboard_wait_is_uris_available(arg0)

	if cret {
		ok = true
	}

	return ok
}

// FileFilter: a GtkFileFilter can be used to restrict the files being shown in
// a FileChooser. Files can be filtered based on their name (with
// gtk_file_filter_add_pattern()), on their mime type (with
// gtk_file_filter_add_mime_type()), or by a custom filter function (with
// gtk_file_filter_add_custom()).
//
// Filtering by mime types handles aliasing and subclassing of mime types; e.g.
// a filter for text/plain also matches a file with mime type application/rtf,
// since application/rtf is a subclass of text/plain. Note that FileFilter
// allows wildcards for the subtype of a mime type, so you can e.g. filter for
// image/\*.
//
// Normally, filters are used by adding them to a FileChooser, see
// gtk_file_chooser_add_filter(), but it is also possible to manually use a
// filter on a file with gtk_file_filter_filter().
//
//
// GtkFileFilter as GtkBuildable
//
// The GtkFileFilter implementation of the GtkBuildable interface supports
// adding rules using the <mime-types>, <patterns> and <applications> elements
// and listing the rules within. Specifying a <mime-type> or <pattern> has the
// same effect as as calling gtk_file_filter_add_mime_type() or
// gtk_file_filter_add_pattern().
//
// An example of a UI definition fragment specifying GtkFileFilter rules:
//
//    <object class="GtkFileFilter">
//      <mime-types>
//        <mime-type>text/plain</mime-type>
//        <mime-type>image/ *</mime-type>
//      </mime-types>
//      <patterns>
//        <pattern>*.txt</pattern>
//        <pattern>*.png</pattern>
//      </patterns>
//    </object>
type FileFilter interface {
	gextras.Objector
	Buildable

	// AddCustom adds rule to a filter that allows files based on a custom
	// callback function. The bitfield @needed which is passed in provides
	// information about what sorts of information that the filter function
	// needs; this allows GTK+ to avoid retrieving expensive information when it
	// isn’t needed by the filter.
	AddCustom(f FileFilter)
	// AddMIMEType adds a rule allowing a given mime type to @filter.
	AddMIMEType(f FileFilter, mimeType string)
	// AddPattern adds a rule allowing a shell style glob to a filter.
	AddPattern(f FileFilter, pattern string)
	// AddPixbufFormats adds a rule allowing image files in the formats
	// supported by GdkPixbuf.
	AddPixbufFormats(f FileFilter)
	// Filter tests whether a file should be displayed according to @filter. The
	// FileFilterInfo @filter_info should include the fields returned from
	// gtk_file_filter_get_needed().
	//
	// This function will not typically be used by applications; it is intended
	// principally for use in the implementation of FileChooser.
	Filter(f FileFilter, filterInfo *FileFilterInfo) bool
	// Name gets the human-readable name for the filter. See
	// gtk_file_filter_set_name().
	Name(f FileFilter)
	// Needed gets the fields that need to be filled in for the FileFilterInfo
	// passed to gtk_file_filter_filter()
	//
	// This function will not typically be used by applications; it is intended
	// principally for use in the implementation of FileChooser.
	Needed(f FileFilter)
	// SetName sets the human-readable name of the filter; this is the string
	// that will be displayed in the file selector user interface if there is a
	// selectable list of filters.
	SetName(f FileFilter, name string)
	// ToGVariant: serialize a file filter to an a{sv} variant.
	ToGVariant(f FileFilter)
}

// fileFilter implements the FileFilter interface.
type fileFilter struct {
	gextras.Objector
	Buildable
}

var _ FileFilter = (*fileFilter)(nil)

// WrapFileFilter wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileFilter(obj *externglib.Object) FileFilter {
	return FileFilter{
		Objector:  obj,
		Buildable: WrapBuildable(obj),
	}
}

func marshalFileFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileFilter(obj), nil
}

// NewFileFilter constructs a class FileFilter.
func NewFileFilter() {
	C.gtk_file_filter_new()
}

// NewFileFilterFromGVariant constructs a class FileFilter.
func NewFileFilterFromGVariant(variant *glib.Variant) {
	var arg1 *C.GVariant

	arg1 = (*C.GVariant)(unsafe.Pointer(variant.Native()))

	C.gtk_file_filter_new_from_gvariant(arg1)
}

// AddCustom adds rule to a filter that allows files based on a custom
// callback function. The bitfield @needed which is passed in provides
// information about what sorts of information that the filter function
// needs; this allows GTK+ to avoid retrieving expensive information when it
// isn’t needed by the filter.
func (f fileFilter) AddCustom(f FileFilter) {
	var arg0 *C.GtkFileFilter

	arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))

	C.gtk_file_filter_add_custom(arg0, arg1, arg2, arg3, arg4)
}

// AddMIMEType adds a rule allowing a given mime type to @filter.
func (f fileFilter) AddMIMEType(f FileFilter, mimeType string) {
	var arg0 *C.GtkFileFilter
	var arg1 *C.gchar

	arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))
	arg1 = (*C.gchar)(C.CString(mimeType))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_file_filter_add_mime_type(arg0, arg1)
}

// AddPattern adds a rule allowing a shell style glob to a filter.
func (f fileFilter) AddPattern(f FileFilter, pattern string) {
	var arg0 *C.GtkFileFilter
	var arg1 *C.gchar

	arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))
	arg1 = (*C.gchar)(C.CString(pattern))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_file_filter_add_pattern(arg0, arg1)
}

// AddPixbufFormats adds a rule allowing image files in the formats
// supported by GdkPixbuf.
func (f fileFilter) AddPixbufFormats(f FileFilter) {
	var arg0 *C.GtkFileFilter

	arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))

	C.gtk_file_filter_add_pixbuf_formats(arg0)
}

// Filter tests whether a file should be displayed according to @filter. The
// FileFilterInfo @filter_info should include the fields returned from
// gtk_file_filter_get_needed().
//
// This function will not typically be used by applications; it is intended
// principally for use in the implementation of FileChooser.
func (f fileFilter) Filter(f FileFilter, filterInfo *FileFilterInfo) bool {
	var arg0 *C.GtkFileFilter
	var arg1 *C.GtkFileFilterInfo

	arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))
	arg1 = (*C.GtkFileFilterInfo)(unsafe.Pointer(filterInfo.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_file_filter_filter(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// Name gets the human-readable name for the filter. See
// gtk_file_filter_set_name().
func (f fileFilter) Name(f FileFilter) {
	var arg0 *C.GtkFileFilter

	arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))

	C.gtk_file_filter_get_name(arg0)
}

// Needed gets the fields that need to be filled in for the FileFilterInfo
// passed to gtk_file_filter_filter()
//
// This function will not typically be used by applications; it is intended
// principally for use in the implementation of FileChooser.
func (f fileFilter) Needed(f FileFilter) {
	var arg0 *C.GtkFileFilter

	arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))

	C.gtk_file_filter_get_needed(arg0)
}

// SetName sets the human-readable name of the filter; this is the string
// that will be displayed in the file selector user interface if there is a
// selectable list of filters.
func (f fileFilter) SetName(f FileFilter, name string) {
	var arg0 *C.GtkFileFilter
	var arg1 *C.gchar

	arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_file_filter_set_name(arg0, arg1)
}

// ToGVariant: serialize a file filter to an a{sv} variant.
func (f fileFilter) ToGVariant(f FileFilter) {
	var arg0 *C.GtkFileFilter

	arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))

	C.gtk_file_filter_to_gvariant(arg0)
}

// ModelButton: gtkModelButton is a button class that can use a #GAction as its
// model. In contrast to ToggleButton or RadioButton, which can also be backed
// by a #GAction via the Actionable:action-name property, GtkModelButton will
// adapt its appearance according to the kind of action it is backed by, and
// appear either as a plain, check or radio button.
//
// Model buttons are used when popovers from a menu model with
// gtk_popover_new_from_model(); they can also be used manually in a
// PopoverMenu.
//
// When the action is specified via the Actionable:action-name and
// Actionable:action-target properties, the role of the button (i.e. whether it
// is a plain, check or radio button) is determined by the type of the action
// and doesn't have to be explicitly specified with the ModelButton:role
// property.
//
// The content of the button is specified by the ModelButton:text and
// ModelButton:icon properties.
//
// The appearance of model buttons can be influenced with the
// ModelButton:centered and ModelButton:iconic properties.
//
// Model buttons have built-in support for submenus in PopoverMenu. To make a
// GtkModelButton that opens a submenu when activated, set the
// ModelButton:menu-name property. To make a button that goes back to the parent
// menu, you should set the ModelButton:inverted property to place the submenu
// indicator at the opposite side.
//
// Example
//
//    <object class="GtkPopoverMenu">
//      <child>
//        <object class="GtkBox">
//          <property name="visible">True</property>
//          <property name="margin">10</property>
//          <child>
//            <object class="GtkModelButton">
//              <property name="visible">True</property>
//              <property name="action-name">view.cut</property>
//              <property name="text" translatable="yes">Cut</property>
//            </object>
//          </child>
//          <child>
//            <object class="GtkModelButton">
//              <property name="visible">True</property>
//              <property name="action-name">view.copy</property>
//              <property name="text" translatable="yes">Copy</property>
//            </object>
//          </child>
//          <child>
//            <object class="GtkModelButton">
//              <property name="visible">True</property>
//              <property name="action-name">view.paste</property>
//              <property name="text" translatable="yes">Paste</property>
//            </object>
//          </child>
//        </object>
//      </child>
//    </object>
//
// CSS nodes
//
//    button.model
//    ├── <child>
//    ╰── check
//
// Iconic model buttons (see ModelButton:iconic) change the name of their main
// node to button and add a .model style class to it. The indicator subnode is
// invisible in this case.
type ModelButton interface {
	Button
	Actionable
	Activatable
	Buildable
}

// modelButton implements the ModelButton interface.
type modelButton struct {
	Button
	Actionable
	Activatable
	Buildable
}

var _ ModelButton = (*modelButton)(nil)

// WrapModelButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapModelButton(obj *externglib.Object) ModelButton {
	return ModelButton{
		Button:      WrapButton(obj),
		Actionable:  WrapActionable(obj),
		Activatable: WrapActivatable(obj),
		Buildable:   WrapBuildable(obj),
	}
}

func marshalModelButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapModelButton(obj), nil
}

// NewModelButton constructs a class ModelButton.
func NewModelButton() {
	C.gtk_model_button_new()
}

// PageSetup: a GtkPageSetup object stores the page size, orientation and
// margins. The idea is that you can get one of these from the page setup dialog
// and then pass it to the PrintOperation when printing. The benefit of
// splitting this out of the PrintSettings is that these affect the actual
// layout of the page, and thus need to be set long before user prints.
//
//
// Margins
//
// The margins specified in this object are the “print margins”, i.e. the parts
// of the page that the printer cannot print on. These are different from the
// layout margins that a word processor uses; they are typically used to
// determine the minimal size for the layout margins.
//
// To obtain a PageSetup use gtk_page_setup_new() to get the defaults, or use
// gtk_print_run_page_setup_dialog() to show the page setup dialog and receive
// the resulting page setup.
//
// A page setup dialog
//
//    static GtkPrintSettings *settings = NULL;
//    static GtkPageSetup *page_setup = NULL;
//
//    static void
//    do_page_setup (void)
//    {
//      GtkPageSetup *new_page_setup;
//
//      if (settings == NULL)
//        settings = gtk_print_settings_new ();
//
//      new_page_setup = gtk_print_run_page_setup_dialog (GTK_WINDOW (main_window),
//                                                        page_setup, settings);
//
//      if (page_setup)
//        g_object_unref (page_setup);
//
//      page_setup = new_page_setup;
//    }
//
// Printing support was added in GTK+ 2.10.
type PageSetup interface {
	gextras.Objector

	// Copy copies a PageSetup.
	Copy(o PageSetup)
	// BottomMargin gets the bottom margin in units of @unit.
	BottomMargin(s PageSetup, unit Unit)
	// LeftMargin gets the left margin in units of @unit.
	LeftMargin(s PageSetup, unit Unit)
	// Orientation gets the page orientation of the PageSetup.
	Orientation(s PageSetup)
	// PageHeight returns the page height in units of @unit.
	//
	// Note that this function takes orientation and margins into consideration.
	// See gtk_page_setup_get_paper_height().
	PageHeight(s PageSetup, unit Unit)
	// PageWidth returns the page width in units of @unit.
	//
	// Note that this function takes orientation and margins into consideration.
	// See gtk_page_setup_get_paper_width().
	PageWidth(s PageSetup, unit Unit)
	// PaperHeight returns the paper height in units of @unit.
	//
	// Note that this function takes orientation, but not margins into
	// consideration. See gtk_page_setup_get_page_height().
	PaperHeight(s PageSetup, unit Unit)
	// PaperSize gets the paper size of the PageSetup.
	PaperSize(s PageSetup)
	// PaperWidth returns the paper width in units of @unit.
	//
	// Note that this function takes orientation, but not margins into
	// consideration. See gtk_page_setup_get_page_width().
	PaperWidth(s PageSetup, unit Unit)
	// RightMargin gets the right margin in units of @unit.
	RightMargin(s PageSetup, unit Unit)
	// TopMargin gets the top margin in units of @unit.
	TopMargin(s PageSetup, unit Unit)
	// LoadFile reads the page setup from the file @file_name. See
	// gtk_page_setup_to_file().
	LoadFile(s PageSetup, fileName string) error
	// LoadKeyFile reads the page setup from the group @group_name in the key
	// file @key_file.
	LoadKeyFile(s PageSetup, keyFile *glib.KeyFile, groupName string) error
	// SetBottomMargin sets the bottom margin of the PageSetup.
	SetBottomMargin(s PageSetup, margin float64, unit Unit)
	// SetLeftMargin sets the left margin of the PageSetup.
	SetLeftMargin(s PageSetup, margin float64, unit Unit)
	// SetOrientation sets the page orientation of the PageSetup.
	SetOrientation(s PageSetup, orientation PageOrientation)
	// SetPaperSize sets the paper size of the PageSetup without changing the
	// margins. See gtk_page_setup_set_paper_size_and_default_margins().
	SetPaperSize(s PageSetup, size *PaperSize)
	// SetPaperSizeAndDefaultMargins sets the paper size of the PageSetup and
	// modifies the margins according to the new paper size.
	SetPaperSizeAndDefaultMargins(s PageSetup, size *PaperSize)
	// SetRightMargin sets the right margin of the PageSetup.
	SetRightMargin(s PageSetup, margin float64, unit Unit)
	// SetTopMargin sets the top margin of the PageSetup.
	SetTopMargin(s PageSetup, margin float64, unit Unit)
	// ToFile: this function saves the information from @setup to @file_name.
	ToFile(s PageSetup, fileName string) error
	// ToGVariant: serialize page setup to an a{sv} variant.
	ToGVariant(s PageSetup)
	// ToKeyFile: this function adds the page setup from @setup to @key_file.
	ToKeyFile(s PageSetup, keyFile *glib.KeyFile, groupName string)
}

// pageSetup implements the PageSetup interface.
type pageSetup struct {
	gextras.Objector
}

var _ PageSetup = (*pageSetup)(nil)

// WrapPageSetup wraps a GObject to the right type. It is
// primarily used internally.
func WrapPageSetup(obj *externglib.Object) PageSetup {
	return PageSetup{
		Objector: obj,
	}
}

func marshalPageSetup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPageSetup(obj), nil
}

// NewPageSetup constructs a class PageSetup.
func NewPageSetup() {
	C.gtk_page_setup_new()
}

// NewPageSetupFromFile constructs a class PageSetup.
func NewPageSetupFromFile(fileName string) error {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	var errout *C.GError
	var err error

	C.gtk_page_setup_new_from_file(arg1, &errout)

	err = gerror.Take(unsafe.Pointer(errout))

	return err
}

// NewPageSetupFromGVariant constructs a class PageSetup.
func NewPageSetupFromGVariant(variant *glib.Variant) {
	var arg1 *C.GVariant

	arg1 = (*C.GVariant)(unsafe.Pointer(variant.Native()))

	C.gtk_page_setup_new_from_gvariant(arg1)
}

// NewPageSetupFromKeyFile constructs a class PageSetup.
func NewPageSetupFromKeyFile(keyFile *glib.KeyFile, groupName string) error {
	var arg1 *C.GKeyFile
	var arg2 *C.gchar

	arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
	arg2 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg2))

	var errout *C.GError
	var err error

	C.gtk_page_setup_new_from_key_file(arg1, arg2, &errout)

	err = gerror.Take(unsafe.Pointer(errout))

	return err
}

// Copy copies a PageSetup.
func (o pageSetup) Copy(o PageSetup) {
	var arg0 *C.GtkPageSetup

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(o.Native()))

	C.gtk_page_setup_copy(arg0)
}

// BottomMargin gets the bottom margin in units of @unit.
func (s pageSetup) BottomMargin(s PageSetup, unit Unit) {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkUnit)(unit)

	C.gtk_page_setup_get_bottom_margin(arg0, arg1)
}

// LeftMargin gets the left margin in units of @unit.
func (s pageSetup) LeftMargin(s PageSetup, unit Unit) {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkUnit)(unit)

	C.gtk_page_setup_get_left_margin(arg0, arg1)
}

// Orientation gets the page orientation of the PageSetup.
func (s pageSetup) Orientation(s PageSetup) {
	var arg0 *C.GtkPageSetup

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))

	C.gtk_page_setup_get_orientation(arg0)
}

// PageHeight returns the page height in units of @unit.
//
// Note that this function takes orientation and margins into consideration.
// See gtk_page_setup_get_paper_height().
func (s pageSetup) PageHeight(s PageSetup, unit Unit) {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkUnit)(unit)

	C.gtk_page_setup_get_page_height(arg0, arg1)
}

// PageWidth returns the page width in units of @unit.
//
// Note that this function takes orientation and margins into consideration.
// See gtk_page_setup_get_paper_width().
func (s pageSetup) PageWidth(s PageSetup, unit Unit) {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkUnit)(unit)

	C.gtk_page_setup_get_page_width(arg0, arg1)
}

// PaperHeight returns the paper height in units of @unit.
//
// Note that this function takes orientation, but not margins into
// consideration. See gtk_page_setup_get_page_height().
func (s pageSetup) PaperHeight(s PageSetup, unit Unit) {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkUnit)(unit)

	C.gtk_page_setup_get_paper_height(arg0, arg1)
}

// PaperSize gets the paper size of the PageSetup.
func (s pageSetup) PaperSize(s PageSetup) {
	var arg0 *C.GtkPageSetup

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))

	C.gtk_page_setup_get_paper_size(arg0)
}

// PaperWidth returns the paper width in units of @unit.
//
// Note that this function takes orientation, but not margins into
// consideration. See gtk_page_setup_get_page_width().
func (s pageSetup) PaperWidth(s PageSetup, unit Unit) {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkUnit)(unit)

	C.gtk_page_setup_get_paper_width(arg0, arg1)
}

// RightMargin gets the right margin in units of @unit.
func (s pageSetup) RightMargin(s PageSetup, unit Unit) {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkUnit)(unit)

	C.gtk_page_setup_get_right_margin(arg0, arg1)
}

// TopMargin gets the top margin in units of @unit.
func (s pageSetup) TopMargin(s PageSetup, unit Unit) {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkUnit)(unit)

	C.gtk_page_setup_get_top_margin(arg0, arg1)
}

// LoadFile reads the page setup from the file @file_name. See
// gtk_page_setup_to_file().
func (s pageSetup) LoadFile(s PageSetup, fileName string) error {
	var arg0 *C.GtkPageSetup
	var arg1 *C.char

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	var errout *C.GError
	var err error

	C.gtk_page_setup_load_file(arg0, arg1, &errout)

	err = gerror.Take(unsafe.Pointer(errout))

	return err
}

// LoadKeyFile reads the page setup from the group @group_name in the key
// file @key_file.
func (s pageSetup) LoadKeyFile(s PageSetup, keyFile *glib.KeyFile, groupName string) error {
	var arg0 *C.GtkPageSetup
	var arg1 *C.GKeyFile
	var arg2 *C.gchar

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
	arg2 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg2))

	var errout *C.GError
	var err error

	C.gtk_page_setup_load_key_file(arg0, arg1, arg2, &errout)

	err = gerror.Take(unsafe.Pointer(errout))

	return err
}

// SetBottomMargin sets the bottom margin of the PageSetup.
func (s pageSetup) SetBottomMargin(s PageSetup, margin float64, unit Unit) {
	var arg0 *C.GtkPageSetup
	var arg1 C.gdouble
	var arg2 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = C.gdouble(margin)
	arg2 = (C.GtkUnit)(unit)

	C.gtk_page_setup_set_bottom_margin(arg0, arg1, arg2)
}

// SetLeftMargin sets the left margin of the PageSetup.
func (s pageSetup) SetLeftMargin(s PageSetup, margin float64, unit Unit) {
	var arg0 *C.GtkPageSetup
	var arg1 C.gdouble
	var arg2 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = C.gdouble(margin)
	arg2 = (C.GtkUnit)(unit)

	C.gtk_page_setup_set_left_margin(arg0, arg1, arg2)
}

// SetOrientation sets the page orientation of the PageSetup.
func (s pageSetup) SetOrientation(s PageSetup, orientation PageOrientation) {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkPageOrientation

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkPageOrientation)(orientation)

	C.gtk_page_setup_set_orientation(arg0, arg1)
}

// SetPaperSize sets the paper size of the PageSetup without changing the
// margins. See gtk_page_setup_set_paper_size_and_default_margins().
func (s pageSetup) SetPaperSize(s PageSetup, size *PaperSize) {
	var arg0 *C.GtkPageSetup
	var arg1 *C.GtkPaperSize

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkPaperSize)(unsafe.Pointer(size.Native()))

	C.gtk_page_setup_set_paper_size(arg0, arg1)
}

// SetPaperSizeAndDefaultMargins sets the paper size of the PageSetup and
// modifies the margins according to the new paper size.
func (s pageSetup) SetPaperSizeAndDefaultMargins(s PageSetup, size *PaperSize) {
	var arg0 *C.GtkPageSetup
	var arg1 *C.GtkPaperSize

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkPaperSize)(unsafe.Pointer(size.Native()))

	C.gtk_page_setup_set_paper_size_and_default_margins(arg0, arg1)
}

// SetRightMargin sets the right margin of the PageSetup.
func (s pageSetup) SetRightMargin(s PageSetup, margin float64, unit Unit) {
	var arg0 *C.GtkPageSetup
	var arg1 C.gdouble
	var arg2 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = C.gdouble(margin)
	arg2 = (C.GtkUnit)(unit)

	C.gtk_page_setup_set_right_margin(arg0, arg1, arg2)
}

// SetTopMargin sets the top margin of the PageSetup.
func (s pageSetup) SetTopMargin(s PageSetup, margin float64, unit Unit) {
	var arg0 *C.GtkPageSetup
	var arg1 C.gdouble
	var arg2 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = C.gdouble(margin)
	arg2 = (C.GtkUnit)(unit)

	C.gtk_page_setup_set_top_margin(arg0, arg1, arg2)
}

// ToFile: this function saves the information from @setup to @file_name.
func (s pageSetup) ToFile(s PageSetup, fileName string) error {
	var arg0 *C.GtkPageSetup
	var arg1 *C.char

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	var errout *C.GError
	var err error

	C.gtk_page_setup_to_file(arg0, arg1, &errout)

	err = gerror.Take(unsafe.Pointer(errout))

	return err
}

// ToGVariant: serialize page setup to an a{sv} variant.
func (s pageSetup) ToGVariant(s PageSetup) {
	var arg0 *C.GtkPageSetup

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))

	C.gtk_page_setup_to_gvariant(arg0)
}

// ToKeyFile: this function adds the page setup from @setup to @key_file.
func (s pageSetup) ToKeyFile(s PageSetup, keyFile *glib.KeyFile, groupName string) {
	var arg0 *C.GtkPageSetup
	var arg1 *C.GKeyFile
	var arg2 *C.gchar

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
	arg2 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_page_setup_to_key_file(arg0, arg1, arg2)
}

// PrintContext: a GtkPrintContext encapsulates context information that is
// required when drawing pages for printing, such as the cairo context and
// important parameters like page size and resolution. It also lets you easily
// create Layout and Context objects that match the font metrics of the cairo
// surface.
//
// GtkPrintContext objects gets passed to the PrintOperation::begin-print,
// PrintOperation::end-print, PrintOperation::request-page-setup and
// PrintOperation::draw-page signals on the PrintOperation.
//
// Using GtkPrintContext in a PrintOperation::draw-page callback
//
//    static void
//    draw_page (GtkPrintOperation *operation,
//    	   GtkPrintContext   *context,
//    	   int                page_nr)
//    {
//      cairo_t *cr;
//      PangoLayout *layout;
//      PangoFontDescription *desc;
//
//      cr = gtk_print_context_get_cairo_context (context);
//
//      // Draw a red rectangle, as wide as the paper (inside the margins)
//      cairo_set_source_rgb (cr, 1.0, 0, 0);
//      cairo_rectangle (cr, 0, 0, gtk_print_context_get_width (context), 50);
//
//      cairo_fill (cr);
//
//      // Draw some lines
//      cairo_move_to (cr, 20, 10);
//      cairo_line_to (cr, 40, 20);
//      cairo_arc (cr, 60, 60, 20, 0, M_PI);
//      cairo_line_to (cr, 80, 20);
//
//      cairo_set_source_rgb (cr, 0, 0, 0);
//      cairo_set_line_width (cr, 5);
//      cairo_set_line_cap (cr, CAIRO_LINE_CAP_ROUND);
//      cairo_set_line_join (cr, CAIRO_LINE_JOIN_ROUND);
//
//      cairo_stroke (cr);
//
//      // Draw some text
//      layout = gtk_print_context_create_pango_layout (context);
//      pango_layout_set_text (layout, "Hello World! Printing is easy", -1);
//      desc = pango_font_description_from_string ("sans 28");
//      pango_layout_set_font_description (layout, desc);
//      pango_font_description_free (desc);
//
//      cairo_move_to (cr, 30, 20);
//      pango_cairo_layout_path (cr, layout);
//
//      // Font Outline
//      cairo_set_source_rgb (cr, 0.93, 1.0, 0.47);
//      cairo_set_line_width (cr, 0.5);
//      cairo_stroke_preserve (cr);
//
//      // Font Fill
//      cairo_set_source_rgb (cr, 0, 0.0, 1.0);
//      cairo_fill (cr);
//
//      g_object_unref (layout);
//    }
//
// Printing support was added in GTK+ 2.10.
type PrintContext interface {
	gextras.Objector

	// CreatePangoContext creates a new Context that can be used with the
	// PrintContext.
	CreatePangoContext(c PrintContext)
	// CreatePangoLayout creates a new Layout that is suitable for use with the
	// PrintContext.
	CreatePangoLayout(c PrintContext)
	// CairoContext obtains the cairo context that is associated with the
	// PrintContext.
	CairoContext(c PrintContext)
	// DPIX obtains the horizontal resolution of the PrintContext, in dots per
	// inch.
	DPIX(c PrintContext)
	// DPIY obtains the vertical resolution of the PrintContext, in dots per
	// inch.
	DPIY(c PrintContext)
	// HardMargins obtains the hardware printer margins of the PrintContext, in
	// units.
	HardMargins(c PrintContext) (top float64, bottom float64, left float64, right float64, ok bool)
	// Height obtains the height of the PrintContext, in pixels.
	Height(c PrintContext)
	// PageSetup obtains the PageSetup that determines the page dimensions of
	// the PrintContext.
	PageSetup(c PrintContext)
	// PangoFontmap returns a FontMap that is suitable for use with the
	// PrintContext.
	PangoFontmap(c PrintContext)
	// Width obtains the width of the PrintContext, in pixels.
	Width(c PrintContext)
	// SetCairoContext sets a new cairo context on a print context.
	//
	// This function is intended to be used when implementing an internal print
	// preview, it is not needed for printing, since GTK+ itself creates a
	// suitable cairo context in that case.
	SetCairoContext(c PrintContext, cr *cairo.Context, dpiX float64, dpiY float64)
}

// printContext implements the PrintContext interface.
type printContext struct {
	gextras.Objector
}

var _ PrintContext = (*printContext)(nil)

// WrapPrintContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapPrintContext(obj *externglib.Object) PrintContext {
	return PrintContext{
		Objector: obj,
	}
}

func marshalPrintContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPrintContext(obj), nil
}

// CreatePangoContext creates a new Context that can be used with the
// PrintContext.
func (c printContext) CreatePangoContext(c PrintContext) {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	C.gtk_print_context_create_pango_context(arg0)
}

// CreatePangoLayout creates a new Layout that is suitable for use with the
// PrintContext.
func (c printContext) CreatePangoLayout(c PrintContext) {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	C.gtk_print_context_create_pango_layout(arg0)
}

// CairoContext obtains the cairo context that is associated with the
// PrintContext.
func (c printContext) CairoContext(c PrintContext) {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	C.gtk_print_context_get_cairo_context(arg0)
}

// DPIX obtains the horizontal resolution of the PrintContext, in dots per
// inch.
func (c printContext) DPIX(c PrintContext) {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	C.gtk_print_context_get_dpi_x(arg0)
}

// DPIY obtains the vertical resolution of the PrintContext, in dots per
// inch.
func (c printContext) DPIY(c PrintContext) {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	C.gtk_print_context_get_dpi_y(arg0)
}

// HardMargins obtains the hardware printer margins of the PrintContext, in
// units.
func (c printContext) HardMargins(c PrintContext) (top float64, bottom float64, left float64, right float64, ok bool) {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	var arg1 C.gdouble
	var top float64
	var arg2 C.gdouble
	var bottom float64
	var arg3 C.gdouble
	var left float64
	var arg4 C.gdouble
	var right float64
	var cret C.gboolean
	var ok bool

	cret = C.gtk_print_context_get_hard_margins(arg0, &arg1, &arg2, &arg3, &arg4)

	top = float64(&arg1)
	bottom = float64(&arg2)
	left = float64(&arg3)
	right = float64(&arg4)
	if cret {
		ok = true
	}

	return top, bottom, left, right, ok
}

// Height obtains the height of the PrintContext, in pixels.
func (c printContext) Height(c PrintContext) {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	C.gtk_print_context_get_height(arg0)
}

// PageSetup obtains the PageSetup that determines the page dimensions of
// the PrintContext.
func (c printContext) PageSetup(c PrintContext) {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	C.gtk_print_context_get_page_setup(arg0)
}

// PangoFontmap returns a FontMap that is suitable for use with the
// PrintContext.
func (c printContext) PangoFontmap(c PrintContext) {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	C.gtk_print_context_get_pango_fontmap(arg0)
}

// Width obtains the width of the PrintContext, in pixels.
func (c printContext) Width(c PrintContext) {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	C.gtk_print_context_get_width(arg0)
}

// SetCairoContext sets a new cairo context on a print context.
//
// This function is intended to be used when implementing an internal print
// preview, it is not needed for printing, since GTK+ itself creates a
// suitable cairo context in that case.
func (c printContext) SetCairoContext(c PrintContext, cr *cairo.Context, dpiX float64, dpiY float64) {
	var arg0 *C.GtkPrintContext
	var arg1 *C.cairo_t
	var arg2 C.double
	var arg3 C.double

	arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))
	arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	arg2 = C.double(dpiX)
	arg3 = C.double(dpiY)

	C.gtk_print_context_set_cairo_context(arg0, arg1, arg2, arg3)
}

// PrintSettings: a GtkPrintSettings object represents the settings of a print
// dialog in a system-independent way. The main use for this object is that once
// you’ve printed you can get a settings object that represents the settings the
// user chose, and the next time you print you can pass that object in so that
// the user doesn’t have to re-set all his settings.
//
// Its also possible to enumerate the settings so that you can easily save the
// settings for the next time your app runs, or even store them in a document.
// The predefined keys try to use shared values as much as possible so that
// moving such a document between systems still works.
//
// Printing support was added in GTK+ 2.10.
type PrintSettings interface {
	gextras.Objector

	// Copy copies a PrintSettings object.
	Copy(o PrintSettings)
	// Foreach calls @func for each key-value pair of @settings.
	Foreach(s PrintSettings)
	// Get looks up the string value associated with @key.
	Get(s PrintSettings, key string)
	// Bool returns the boolean represented by the value that is associated with
	// @key.
	//
	// The string “true” represents true, any other string false.
	Bool(s PrintSettings, key string) bool
	// Collate gets the value of GTK_PRINT_SETTINGS_COLLATE.
	Collate(s PrintSettings) bool
	// DefaultSource gets the value of GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
	DefaultSource(s PrintSettings)
	// Dither gets the value of GTK_PRINT_SETTINGS_DITHER.
	Dither(s PrintSettings)
	// Double returns the double value associated with @key, or 0.
	Double(s PrintSettings, key string)
	// DoubleWithDefault returns the floating point number represented by the
	// value that is associated with @key, or @default_val if the value does not
	// represent a floating point number.
	//
	// Floating point numbers are parsed with g_ascii_strtod().
	DoubleWithDefault(s PrintSettings, key string, def float64)
	// Duplex gets the value of GTK_PRINT_SETTINGS_DUPLEX.
	Duplex(s PrintSettings)
	// Finishings gets the value of GTK_PRINT_SETTINGS_FINISHINGS.
	Finishings(s PrintSettings)
	// Int returns the integer value of @key, or 0.
	Int(s PrintSettings, key string)
	// IntWithDefault returns the value of @key, interpreted as an integer, or
	// the default value.
	IntWithDefault(s PrintSettings, key string, def int)
	// Length returns the value associated with @key, interpreted as a length.
	// The returned value is converted to @units.
	Length(s PrintSettings, key string, unit Unit)
	// MediaType gets the value of GTK_PRINT_SETTINGS_MEDIA_TYPE.
	//
	// The set of media types is defined in PWG 5101.1-2002 PWG.
	MediaType(s PrintSettings)
	// NCopies gets the value of GTK_PRINT_SETTINGS_N_COPIES.
	NCopies(s PrintSettings)
	// NumberUp gets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
	NumberUp(s PrintSettings)
	// NumberUpLayout gets the value of GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT.
	NumberUpLayout(s PrintSettings)
	// Orientation: get the value of GTK_PRINT_SETTINGS_ORIENTATION, converted
	// to a PageOrientation.
	Orientation(s PrintSettings)
	// OutputBin gets the value of GTK_PRINT_SETTINGS_OUTPUT_BIN.
	OutputBin(s PrintSettings)
	// PageRanges gets the value of GTK_PRINT_SETTINGS_PAGE_RANGES.
	PageRanges(s PrintSettings) int
	// PageSet gets the value of GTK_PRINT_SETTINGS_PAGE_SET.
	PageSet(s PrintSettings)
	// PaperHeight gets the value of GTK_PRINT_SETTINGS_PAPER_HEIGHT, converted
	// to @unit.
	PaperHeight(s PrintSettings, unit Unit)
	// PaperSize gets the value of GTK_PRINT_SETTINGS_PAPER_FORMAT, converted to
	// a PaperSize.
	PaperSize(s PrintSettings)
	// PaperWidth gets the value of GTK_PRINT_SETTINGS_PAPER_WIDTH, converted to
	// @unit.
	PaperWidth(s PrintSettings, unit Unit)
	// PrintPages gets the value of GTK_PRINT_SETTINGS_PRINT_PAGES.
	PrintPages(s PrintSettings)
	// Printer: convenience function to obtain the value of
	// GTK_PRINT_SETTINGS_PRINTER.
	Printer(s PrintSettings)
	// PrinterLpi gets the value of GTK_PRINT_SETTINGS_PRINTER_LPI.
	PrinterLpi(s PrintSettings)
	// Quality gets the value of GTK_PRINT_SETTINGS_QUALITY.
	Quality(s PrintSettings)
	// Resolution gets the value of GTK_PRINT_SETTINGS_RESOLUTION.
	Resolution(s PrintSettings)
	// ResolutionX gets the value of GTK_PRINT_SETTINGS_RESOLUTION_X.
	ResolutionX(s PrintSettings)
	// ResolutionY gets the value of GTK_PRINT_SETTINGS_RESOLUTION_Y.
	ResolutionY(s PrintSettings)
	// Reverse gets the value of GTK_PRINT_SETTINGS_REVERSE.
	Reverse(s PrintSettings) bool
	// Scale gets the value of GTK_PRINT_SETTINGS_SCALE.
	Scale(s PrintSettings)
	// UseColor gets the value of GTK_PRINT_SETTINGS_USE_COLOR.
	UseColor(s PrintSettings) bool
	// HasKey returns true, if a value is associated with @key.
	HasKey(s PrintSettings, key string) bool
	// LoadFile reads the print settings from @file_name. If the file could not
	// be loaded then error is set to either a Error or FileError. See
	// gtk_print_settings_to_file().
	LoadFile(s PrintSettings, fileName string) error
	// LoadKeyFile reads the print settings from the group @group_name in
	// @key_file. If the file could not be loaded then error is set to either a
	// Error or FileError.
	LoadKeyFile(s PrintSettings, keyFile *glib.KeyFile, groupName string) error
	// Set associates @value with @key.
	Set(s PrintSettings, key string, value string)
	// SetBool sets @key to a boolean value.
	SetBool(s PrintSettings, key string, value bool)
	// SetCollate sets the value of GTK_PRINT_SETTINGS_COLLATE.
	SetCollate(s PrintSettings, collate bool)
	// SetDefaultSource sets the value of GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
	SetDefaultSource(s PrintSettings, defaultSource string)
	// SetDither sets the value of GTK_PRINT_SETTINGS_DITHER.
	SetDither(s PrintSettings, dither string)
	// SetDouble sets @key to a double value.
	SetDouble(s PrintSettings, key string, value float64)
	// SetDuplex sets the value of GTK_PRINT_SETTINGS_DUPLEX.
	SetDuplex(s PrintSettings, duplex PrintDuplex)
	// SetFinishings sets the value of GTK_PRINT_SETTINGS_FINISHINGS.
	SetFinishings(s PrintSettings, finishings string)
	// SetInt sets @key to an integer value.
	SetInt(s PrintSettings, key string, value int)
	// SetLength associates a length in units of @unit with @key.
	SetLength(s PrintSettings, key string, value float64, unit Unit)
	// SetMediaType sets the value of GTK_PRINT_SETTINGS_MEDIA_TYPE.
	//
	// The set of media types is defined in PWG 5101.1-2002 PWG.
	SetMediaType(s PrintSettings, mediaType string)
	// SetNCopies sets the value of GTK_PRINT_SETTINGS_N_COPIES.
	SetNCopies(s PrintSettings, numCopies int)
	// SetNumberUp sets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
	SetNumberUp(s PrintSettings, numberUp int)
	// SetNumberUpLayout sets the value of GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT.
	SetNumberUpLayout(s PrintSettings, numberUpLayout NumberUpLayout)
	// SetOrientation sets the value of GTK_PRINT_SETTINGS_ORIENTATION.
	SetOrientation(s PrintSettings, orientation PageOrientation)
	// SetOutputBin sets the value of GTK_PRINT_SETTINGS_OUTPUT_BIN.
	SetOutputBin(s PrintSettings, outputBin string)
	// SetPageRanges sets the value of GTK_PRINT_SETTINGS_PAGE_RANGES.
	SetPageRanges(s PrintSettings)
	// SetPageSet sets the value of GTK_PRINT_SETTINGS_PAGE_SET.
	SetPageSet(s PrintSettings, pageSet PageSet)
	// SetPaperHeight sets the value of GTK_PRINT_SETTINGS_PAPER_HEIGHT.
	SetPaperHeight(s PrintSettings, height float64, unit Unit)
	// SetPaperSize sets the value of GTK_PRINT_SETTINGS_PAPER_FORMAT,
	// GTK_PRINT_SETTINGS_PAPER_WIDTH and GTK_PRINT_SETTINGS_PAPER_HEIGHT.
	SetPaperSize(s PrintSettings, paperSize *PaperSize)
	// SetPaperWidth sets the value of GTK_PRINT_SETTINGS_PAPER_WIDTH.
	SetPaperWidth(s PrintSettings, width float64, unit Unit)
	// SetPrintPages sets the value of GTK_PRINT_SETTINGS_PRINT_PAGES.
	SetPrintPages(s PrintSettings, pages PrintPages)
	// SetPrinter: convenience function to set GTK_PRINT_SETTINGS_PRINTER to
	// @printer.
	SetPrinter(s PrintSettings, printer string)
	// SetPrinterLpi sets the value of GTK_PRINT_SETTINGS_PRINTER_LPI.
	SetPrinterLpi(s PrintSettings, lpi float64)
	// SetQuality sets the value of GTK_PRINT_SETTINGS_QUALITY.
	SetQuality(s PrintSettings, quality PrintQuality)
	// SetResolution sets the values of GTK_PRINT_SETTINGS_RESOLUTION,
	// GTK_PRINT_SETTINGS_RESOLUTION_X and GTK_PRINT_SETTINGS_RESOLUTION_Y.
	SetResolution(s PrintSettings, resolution int)
	// SetResolutionXY sets the values of GTK_PRINT_SETTINGS_RESOLUTION,
	// GTK_PRINT_SETTINGS_RESOLUTION_X and GTK_PRINT_SETTINGS_RESOLUTION_Y.
	SetResolutionXY(s PrintSettings, resolutionX int, resolutionY int)
	// SetReverse sets the value of GTK_PRINT_SETTINGS_REVERSE.
	SetReverse(s PrintSettings, reverse bool)
	// SetScale sets the value of GTK_PRINT_SETTINGS_SCALE.
	SetScale(s PrintSettings, scale float64)
	// SetUseColor sets the value of GTK_PRINT_SETTINGS_USE_COLOR.
	SetUseColor(s PrintSettings, useColor bool)
	// ToFile: this function saves the print settings from @settings to
	// @file_name. If the file could not be loaded then error is set to either a
	// Error or FileError.
	ToFile(s PrintSettings, fileName string) error
	// ToGVariant: serialize print settings to an a{sv} variant.
	ToGVariant(s PrintSettings)
	// ToKeyFile: this function adds the print settings from @settings to
	// @key_file.
	ToKeyFile(s PrintSettings, keyFile *glib.KeyFile, groupName string)
	// Unset removes any value associated with @key. This has the same effect as
	// setting the value to nil.
	Unset(s PrintSettings, key string)
}

// printSettings implements the PrintSettings interface.
type printSettings struct {
	gextras.Objector
}

var _ PrintSettings = (*printSettings)(nil)

// WrapPrintSettings wraps a GObject to the right type. It is
// primarily used internally.
func WrapPrintSettings(obj *externglib.Object) PrintSettings {
	return PrintSettings{
		Objector: obj,
	}
}

func marshalPrintSettings(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPrintSettings(obj), nil
}

// NewPrintSettings constructs a class PrintSettings.
func NewPrintSettings() {
	C.gtk_print_settings_new()
}

// NewPrintSettingsFromFile constructs a class PrintSettings.
func NewPrintSettingsFromFile(fileName string) error {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	var errout *C.GError
	var err error

	C.gtk_print_settings_new_from_file(arg1, &errout)

	err = gerror.Take(unsafe.Pointer(errout))

	return err
}

// NewPrintSettingsFromGVariant constructs a class PrintSettings.
func NewPrintSettingsFromGVariant(variant *glib.Variant) {
	var arg1 *C.GVariant

	arg1 = (*C.GVariant)(unsafe.Pointer(variant.Native()))

	C.gtk_print_settings_new_from_gvariant(arg1)
}

// NewPrintSettingsFromKeyFile constructs a class PrintSettings.
func NewPrintSettingsFromKeyFile(keyFile *glib.KeyFile, groupName string) error {
	var arg1 *C.GKeyFile
	var arg2 *C.gchar

	arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
	arg2 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg2))

	var errout *C.GError
	var err error

	C.gtk_print_settings_new_from_key_file(arg1, arg2, &errout)

	err = gerror.Take(unsafe.Pointer(errout))

	return err
}

// Copy copies a PrintSettings object.
func (o printSettings) Copy(o PrintSettings) {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(o.Native()))

	C.gtk_print_settings_copy(arg0)
}

// Foreach calls @func for each key-value pair of @settings.
func (s printSettings) Foreach(s PrintSettings) {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	C.gtk_print_settings_foreach(arg0, arg1, arg2)
}

// Get looks up the string value associated with @key.
func (s printSettings) Get(s PrintSettings, key string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_get(arg0, arg1)
}

// Bool returns the boolean represented by the value that is associated with
// @key.
//
// The string “true” represents true, any other string false.
func (s printSettings) Bool(s PrintSettings, key string) bool {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_print_settings_get_bool(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// Collate gets the value of GTK_PRINT_SETTINGS_COLLATE.
func (s printSettings) Collate(s PrintSettings) bool {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_print_settings_get_collate(arg0)

	if cret {
		ok = true
	}

	return ok
}

// DefaultSource gets the value of GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
func (s printSettings) DefaultSource(s PrintSettings) {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	C.gtk_print_settings_get_default_source(arg0)
}

// Dither gets the value of GTK_PRINT_SETTINGS_DITHER.
func (s printSettings) Dither(s PrintSettings) {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	C.gtk_print_settings_get_dither(arg0)
}

// Double returns the double value associated with @key, or 0.
func (s printSettings) Double(s PrintSettings, key string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_get_double(arg0, arg1)
}

// DoubleWithDefault returns the floating point number represented by the
// value that is associated with @key, or @default_val if the value does not
// represent a floating point number.
//
// Floating point numbers are parsed with g_ascii_strtod().
func (s printSettings) DoubleWithDefault(s PrintSettings, key string, def float64) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar
	var arg2 C.gdouble

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gdouble(def)

	C.gtk_print_settings_get_double_with_default(arg0, arg1, arg2)
}

// Duplex gets the value of GTK_PRINT_SETTINGS_DUPLEX.
func (s printSettings) Duplex(s PrintSettings) {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	C.gtk_print_settings_get_duplex(arg0)
}

// Finishings gets the value of GTK_PRINT_SETTINGS_FINISHINGS.
func (s printSettings) Finishings(s PrintSettings) {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	C.gtk_print_settings_get_finishings(arg0)
}

// Int returns the integer value of @key, or 0.
func (s printSettings) Int(s PrintSettings, key string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_get_int(arg0, arg1)
}

// IntWithDefault returns the value of @key, interpreted as an integer, or
// the default value.
func (s printSettings) IntWithDefault(s PrintSettings, key string, def int) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar
	var arg2 C.gint

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(def)

	C.gtk_print_settings_get_int_with_default(arg0, arg1, arg2)
}

// Length returns the value associated with @key, interpreted as a length.
// The returned value is converted to @units.
func (s printSettings) Length(s PrintSettings, key string, unit Unit) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar
	var arg2 C.GtkUnit

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GtkUnit)(unit)

	C.gtk_print_settings_get_length(arg0, arg1, arg2)
}

// MediaType gets the value of GTK_PRINT_SETTINGS_MEDIA_TYPE.
//
// The set of media types is defined in PWG 5101.1-2002 PWG.
func (s printSettings) MediaType(s PrintSettings) {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	C.gtk_print_settings_get_media_type(arg0)
}

// NCopies gets the value of GTK_PRINT_SETTINGS_N_COPIES.
func (s printSettings) NCopies(s PrintSettings) {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	C.gtk_print_settings_get_n_copies(arg0)
}

// NumberUp gets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
func (s printSettings) NumberUp(s PrintSettings) {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	C.gtk_print_settings_get_number_up(arg0)
}

// NumberUpLayout gets the value of GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT.
func (s printSettings) NumberUpLayout(s PrintSettings) {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	C.gtk_print_settings_get_number_up_layout(arg0)
}

// Orientation: get the value of GTK_PRINT_SETTINGS_ORIENTATION, converted
// to a PageOrientation.
func (s printSettings) Orientation(s PrintSettings) {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	C.gtk_print_settings_get_orientation(arg0)
}

// OutputBin gets the value of GTK_PRINT_SETTINGS_OUTPUT_BIN.
func (s printSettings) OutputBin(s PrintSettings) {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	C.gtk_print_settings_get_output_bin(arg0)
}

// PageRanges gets the value of GTK_PRINT_SETTINGS_PAGE_RANGES.
func (s printSettings) PageRanges(s PrintSettings) int {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var arg1 C.gint
	var numRanges int

	C.gtk_print_settings_get_page_ranges(arg0, &arg1)

	numRanges = int(&arg1)

	return numRanges
}

// PageSet gets the value of GTK_PRINT_SETTINGS_PAGE_SET.
func (s printSettings) PageSet(s PrintSettings) {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	C.gtk_print_settings_get_page_set(arg0)
}

// PaperHeight gets the value of GTK_PRINT_SETTINGS_PAPER_HEIGHT, converted
// to @unit.
func (s printSettings) PaperHeight(s PrintSettings, unit Unit) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkUnit)(unit)

	C.gtk_print_settings_get_paper_height(arg0, arg1)
}

// PaperSize gets the value of GTK_PRINT_SETTINGS_PAPER_FORMAT, converted to
// a PaperSize.
func (s printSettings) PaperSize(s PrintSettings) {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	C.gtk_print_settings_get_paper_size(arg0)
}

// PaperWidth gets the value of GTK_PRINT_SETTINGS_PAPER_WIDTH, converted to
// @unit.
func (s printSettings) PaperWidth(s PrintSettings, unit Unit) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkUnit)(unit)

	C.gtk_print_settings_get_paper_width(arg0, arg1)
}

// PrintPages gets the value of GTK_PRINT_SETTINGS_PRINT_PAGES.
func (s printSettings) PrintPages(s PrintSettings) {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	C.gtk_print_settings_get_print_pages(arg0)
}

// Printer: convenience function to obtain the value of
// GTK_PRINT_SETTINGS_PRINTER.
func (s printSettings) Printer(s PrintSettings) {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	C.gtk_print_settings_get_printer(arg0)
}

// PrinterLpi gets the value of GTK_PRINT_SETTINGS_PRINTER_LPI.
func (s printSettings) PrinterLpi(s PrintSettings) {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	C.gtk_print_settings_get_printer_lpi(arg0)
}

// Quality gets the value of GTK_PRINT_SETTINGS_QUALITY.
func (s printSettings) Quality(s PrintSettings) {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	C.gtk_print_settings_get_quality(arg0)
}

// Resolution gets the value of GTK_PRINT_SETTINGS_RESOLUTION.
func (s printSettings) Resolution(s PrintSettings) {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	C.gtk_print_settings_get_resolution(arg0)
}

// ResolutionX gets the value of GTK_PRINT_SETTINGS_RESOLUTION_X.
func (s printSettings) ResolutionX(s PrintSettings) {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	C.gtk_print_settings_get_resolution_x(arg0)
}

// ResolutionY gets the value of GTK_PRINT_SETTINGS_RESOLUTION_Y.
func (s printSettings) ResolutionY(s PrintSettings) {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	C.gtk_print_settings_get_resolution_y(arg0)
}

// Reverse gets the value of GTK_PRINT_SETTINGS_REVERSE.
func (s printSettings) Reverse(s PrintSettings) bool {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_print_settings_get_reverse(arg0)

	if cret {
		ok = true
	}

	return ok
}

// Scale gets the value of GTK_PRINT_SETTINGS_SCALE.
func (s printSettings) Scale(s PrintSettings) {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	C.gtk_print_settings_get_scale(arg0)
}

// UseColor gets the value of GTK_PRINT_SETTINGS_USE_COLOR.
func (s printSettings) UseColor(s PrintSettings) bool {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_print_settings_get_use_color(arg0)

	if cret {
		ok = true
	}

	return ok
}

// HasKey returns true, if a value is associated with @key.
func (s printSettings) HasKey(s PrintSettings, key string) bool {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_print_settings_has_key(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// LoadFile reads the print settings from @file_name. If the file could not
// be loaded then error is set to either a Error or FileError. See
// gtk_print_settings_to_file().
func (s printSettings) LoadFile(s PrintSettings, fileName string) error {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	var errout *C.GError
	var err error

	C.gtk_print_settings_load_file(arg0, arg1, &errout)

	err = gerror.Take(unsafe.Pointer(errout))

	return err
}

// LoadKeyFile reads the print settings from the group @group_name in
// @key_file. If the file could not be loaded then error is set to either a
// Error or FileError.
func (s printSettings) LoadKeyFile(s PrintSettings, keyFile *glib.KeyFile, groupName string) error {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.GKeyFile
	var arg2 *C.gchar

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
	arg2 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg2))

	var errout *C.GError
	var err error

	C.gtk_print_settings_load_key_file(arg0, arg1, arg2, &errout)

	err = gerror.Take(unsafe.Pointer(errout))

	return err
}

// Set associates @value with @key.
func (s printSettings) Set(s PrintSettings, key string, value string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_print_settings_set(arg0, arg1, arg2)
}

// SetBool sets @key to a boolean value.
func (s printSettings) SetBool(s PrintSettings, key string, value bool) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar
	var arg2 C.gboolean

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	if value {
		arg2 = C.gboolean(1)
	}

	C.gtk_print_settings_set_bool(arg0, arg1, arg2)
}

// SetCollate sets the value of GTK_PRINT_SETTINGS_COLLATE.
func (s printSettings) SetCollate(s PrintSettings, collate bool) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gboolean

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	if collate {
		arg1 = C.gboolean(1)
	}

	C.gtk_print_settings_set_collate(arg0, arg1)
}

// SetDefaultSource sets the value of GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
func (s printSettings) SetDefaultSource(s PrintSettings, defaultSource string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(defaultSource))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_set_default_source(arg0, arg1)
}

// SetDither sets the value of GTK_PRINT_SETTINGS_DITHER.
func (s printSettings) SetDither(s PrintSettings, dither string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(dither))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_set_dither(arg0, arg1)
}

// SetDouble sets @key to a double value.
func (s printSettings) SetDouble(s PrintSettings, key string, value float64) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar
	var arg2 C.gdouble

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gdouble(value)

	C.gtk_print_settings_set_double(arg0, arg1, arg2)
}

// SetDuplex sets the value of GTK_PRINT_SETTINGS_DUPLEX.
func (s printSettings) SetDuplex(s PrintSettings, duplex PrintDuplex) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkPrintDuplex

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkPrintDuplex)(duplex)

	C.gtk_print_settings_set_duplex(arg0, arg1)
}

// SetFinishings sets the value of GTK_PRINT_SETTINGS_FINISHINGS.
func (s printSettings) SetFinishings(s PrintSettings, finishings string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(finishings))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_set_finishings(arg0, arg1)
}

// SetInt sets @key to an integer value.
func (s printSettings) SetInt(s PrintSettings, key string, value int) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar
	var arg2 C.gint

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(value)

	C.gtk_print_settings_set_int(arg0, arg1, arg2)
}

// SetLength associates a length in units of @unit with @key.
func (s printSettings) SetLength(s PrintSettings, key string, value float64, unit Unit) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar
	var arg2 C.gdouble
	var arg3 C.GtkUnit

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gdouble(value)
	arg3 = (C.GtkUnit)(unit)

	C.gtk_print_settings_set_length(arg0, arg1, arg2, arg3)
}

// SetMediaType sets the value of GTK_PRINT_SETTINGS_MEDIA_TYPE.
//
// The set of media types is defined in PWG 5101.1-2002 PWG.
func (s printSettings) SetMediaType(s PrintSettings, mediaType string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(mediaType))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_set_media_type(arg0, arg1)
}

// SetNCopies sets the value of GTK_PRINT_SETTINGS_N_COPIES.
func (s printSettings) SetNCopies(s PrintSettings, numCopies int) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gint

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = C.gint(numCopies)

	C.gtk_print_settings_set_n_copies(arg0, arg1)
}

// SetNumberUp sets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
func (s printSettings) SetNumberUp(s PrintSettings, numberUp int) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gint

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = C.gint(numberUp)

	C.gtk_print_settings_set_number_up(arg0, arg1)
}

// SetNumberUpLayout sets the value of GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT.
func (s printSettings) SetNumberUpLayout(s PrintSettings, numberUpLayout NumberUpLayout) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkNumberUpLayout

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkNumberUpLayout)(numberUpLayout)

	C.gtk_print_settings_set_number_up_layout(arg0, arg1)
}

// SetOrientation sets the value of GTK_PRINT_SETTINGS_ORIENTATION.
func (s printSettings) SetOrientation(s PrintSettings, orientation PageOrientation) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkPageOrientation

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkPageOrientation)(orientation)

	C.gtk_print_settings_set_orientation(arg0, arg1)
}

// SetOutputBin sets the value of GTK_PRINT_SETTINGS_OUTPUT_BIN.
func (s printSettings) SetOutputBin(s PrintSettings, outputBin string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(outputBin))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_set_output_bin(arg0, arg1)
}

// SetPageRanges sets the value of GTK_PRINT_SETTINGS_PAGE_RANGES.
func (s printSettings) SetPageRanges(s PrintSettings) {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	C.gtk_print_settings_set_page_ranges(arg0, arg1, arg2)
}

// SetPageSet sets the value of GTK_PRINT_SETTINGS_PAGE_SET.
func (s printSettings) SetPageSet(s PrintSettings, pageSet PageSet) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkPageSet

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkPageSet)(pageSet)

	C.gtk_print_settings_set_page_set(arg0, arg1)
}

// SetPaperHeight sets the value of GTK_PRINT_SETTINGS_PAPER_HEIGHT.
func (s printSettings) SetPaperHeight(s PrintSettings, height float64, unit Unit) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gdouble
	var arg2 C.GtkUnit

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = C.gdouble(height)
	arg2 = (C.GtkUnit)(unit)

	C.gtk_print_settings_set_paper_height(arg0, arg1, arg2)
}

// SetPaperSize sets the value of GTK_PRINT_SETTINGS_PAPER_FORMAT,
// GTK_PRINT_SETTINGS_PAPER_WIDTH and GTK_PRINT_SETTINGS_PAPER_HEIGHT.
func (s printSettings) SetPaperSize(s PrintSettings, paperSize *PaperSize) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.GtkPaperSize

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkPaperSize)(unsafe.Pointer(paperSize.Native()))

	C.gtk_print_settings_set_paper_size(arg0, arg1)
}

// SetPaperWidth sets the value of GTK_PRINT_SETTINGS_PAPER_WIDTH.
func (s printSettings) SetPaperWidth(s PrintSettings, width float64, unit Unit) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gdouble
	var arg2 C.GtkUnit

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = C.gdouble(width)
	arg2 = (C.GtkUnit)(unit)

	C.gtk_print_settings_set_paper_width(arg0, arg1, arg2)
}

// SetPrintPages sets the value of GTK_PRINT_SETTINGS_PRINT_PAGES.
func (s printSettings) SetPrintPages(s PrintSettings, pages PrintPages) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkPrintPages

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkPrintPages)(pages)

	C.gtk_print_settings_set_print_pages(arg0, arg1)
}

// SetPrinter: convenience function to set GTK_PRINT_SETTINGS_PRINTER to
// @printer.
func (s printSettings) SetPrinter(s PrintSettings, printer string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(printer))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_set_printer(arg0, arg1)
}

// SetPrinterLpi sets the value of GTK_PRINT_SETTINGS_PRINTER_LPI.
func (s printSettings) SetPrinterLpi(s PrintSettings, lpi float64) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gdouble

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = C.gdouble(lpi)

	C.gtk_print_settings_set_printer_lpi(arg0, arg1)
}

// SetQuality sets the value of GTK_PRINT_SETTINGS_QUALITY.
func (s printSettings) SetQuality(s PrintSettings, quality PrintQuality) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkPrintQuality

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkPrintQuality)(quality)

	C.gtk_print_settings_set_quality(arg0, arg1)
}

// SetResolution sets the values of GTK_PRINT_SETTINGS_RESOLUTION,
// GTK_PRINT_SETTINGS_RESOLUTION_X and GTK_PRINT_SETTINGS_RESOLUTION_Y.
func (s printSettings) SetResolution(s PrintSettings, resolution int) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gint

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = C.gint(resolution)

	C.gtk_print_settings_set_resolution(arg0, arg1)
}

// SetResolutionXY sets the values of GTK_PRINT_SETTINGS_RESOLUTION,
// GTK_PRINT_SETTINGS_RESOLUTION_X and GTK_PRINT_SETTINGS_RESOLUTION_Y.
func (s printSettings) SetResolutionXY(s PrintSettings, resolutionX int, resolutionY int) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gint
	var arg2 C.gint

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = C.gint(resolutionX)
	arg2 = C.gint(resolutionY)

	C.gtk_print_settings_set_resolution_xy(arg0, arg1, arg2)
}

// SetReverse sets the value of GTK_PRINT_SETTINGS_REVERSE.
func (s printSettings) SetReverse(s PrintSettings, reverse bool) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gboolean

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	if reverse {
		arg1 = C.gboolean(1)
	}

	C.gtk_print_settings_set_reverse(arg0, arg1)
}

// SetScale sets the value of GTK_PRINT_SETTINGS_SCALE.
func (s printSettings) SetScale(s PrintSettings, scale float64) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gdouble

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = C.gdouble(scale)

	C.gtk_print_settings_set_scale(arg0, arg1)
}

// SetUseColor sets the value of GTK_PRINT_SETTINGS_USE_COLOR.
func (s printSettings) SetUseColor(s PrintSettings, useColor bool) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gboolean

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	if useColor {
		arg1 = C.gboolean(1)
	}

	C.gtk_print_settings_set_use_color(arg0, arg1)
}

// ToFile: this function saves the print settings from @settings to
// @file_name. If the file could not be loaded then error is set to either a
// Error or FileError.
func (s printSettings) ToFile(s PrintSettings, fileName string) error {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	var errout *C.GError
	var err error

	C.gtk_print_settings_to_file(arg0, arg1, &errout)

	err = gerror.Take(unsafe.Pointer(errout))

	return err
}

// ToGVariant: serialize print settings to an a{sv} variant.
func (s printSettings) ToGVariant(s PrintSettings) {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	C.gtk_print_settings_to_gvariant(arg0)
}

// ToKeyFile: this function adds the print settings from @settings to
// @key_file.
func (s printSettings) ToKeyFile(s PrintSettings, keyFile *glib.KeyFile, groupName string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.GKeyFile
	var arg2 *C.gchar

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
	arg2 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_print_settings_to_key_file(arg0, arg1, arg2)
}

// Unset removes any value associated with @key. This has the same effect as
// setting the value to nil.
func (s printSettings) Unset(s PrintSettings, key string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_unset(arg0, arg1)
}

// RecentFilter: a RecentFilter can be used to restrict the files being shown in
// a RecentChooser. Files can be filtered based on their name (with
// gtk_recent_filter_add_pattern()), on their mime type (with
// gtk_file_filter_add_mime_type()), on the application that has registered them
// (with gtk_recent_filter_add_application()), or by a custom filter function
// (with gtk_recent_filter_add_custom()).
//
// Filtering by mime type handles aliasing and subclassing of mime types; e.g. a
// filter for text/plain also matches a file with mime type application/rtf,
// since application/rtf is a subclass of text/plain. Note that RecentFilter
// allows wildcards for the subtype of a mime type, so you can e.g. filter for
// image/\*.
//
// Normally, filters are used by adding them to a RecentChooser, see
// gtk_recent_chooser_add_filter(), but it is also possible to manually use a
// filter on a file with gtk_recent_filter_filter().
//
// Recently used files are supported since GTK+ 2.10.
//
//
// GtkRecentFilter as GtkBuildable
//
// The GtkRecentFilter implementation of the GtkBuildable interface supports
// adding rules using the <mime-types>, <patterns> and <applications> elements
// and listing the rules within. Specifying a <mime-type>, <pattern> or
// <application> has the same effect as calling
// gtk_recent_filter_add_mime_type(), gtk_recent_filter_add_pattern() or
// gtk_recent_filter_add_application().
//
// An example of a UI definition fragment specifying GtkRecentFilter rules:
//
//    <object class="GtkRecentFilter">
//      <mime-types>
//        <mime-type>text/plain</mime-type>
//        <mime-type>image/png</mime-type>
//      </mime-types>
//      <patterns>
//        <pattern>*.txt</pattern>
//        <pattern>*.png</pattern>
//      </patterns>
//      <applications>
//        <application>gimp</application>
//        <application>gedit</application>
//        <application>glade</application>
//      </applications>
//    </object>
type RecentFilter interface {
	gextras.Objector
	Buildable

	// AddAge adds a rule that allows resources based on their age - that is,
	// the number of days elapsed since they were last modified.
	AddAge(f RecentFilter, days int)
	// AddApplication adds a rule that allows resources based on the name of the
	// application that has registered them.
	AddApplication(f RecentFilter, application string)
	// AddCustom adds a rule to a filter that allows resources based on a custom
	// callback function. The bitfield @needed which is passed in provides
	// information about what sorts of information that the filter function
	// needs; this allows GTK+ to avoid retrieving expensive information when it
	// isn’t needed by the filter.
	AddCustom(f RecentFilter)
	// AddGroup adds a rule that allows resources based on the name of the group
	// to which they belong
	AddGroup(f RecentFilter, group string)
	// AddMIMEType adds a rule that allows resources based on their registered
	// MIME type.
	AddMIMEType(f RecentFilter, mimeType string)
	// AddPattern adds a rule that allows resources based on a pattern matching
	// their display name.
	AddPattern(f RecentFilter, pattern string)
	// AddPixbufFormats adds a rule allowing image files in the formats
	// supported by GdkPixbuf.
	AddPixbufFormats(f RecentFilter)
	// Filter tests whether a file should be displayed according to @filter. The
	// RecentFilterInfo @filter_info should include the fields returned from
	// gtk_recent_filter_get_needed(), and must set the
	// RecentFilterInfo.contains field of @filter_info to indicate which fields
	// have been set.
	//
	// This function will not typically be used by applications; it is intended
	// principally for use in the implementation of RecentChooser.
	Filter(f RecentFilter, filterInfo *RecentFilterInfo) bool
	// Name gets the human-readable name for the filter. See
	// gtk_recent_filter_set_name().
	Name(f RecentFilter)
	// Needed gets the fields that need to be filled in for the RecentFilterInfo
	// passed to gtk_recent_filter_filter()
	//
	// This function will not typically be used by applications; it is intended
	// principally for use in the implementation of RecentChooser.
	Needed(f RecentFilter)
	// SetName sets the human-readable name of the filter; this is the string
	// that will be displayed in the recently used resources selector user
	// interface if there is a selectable list of filters.
	SetName(f RecentFilter, name string)
}

// recentFilter implements the RecentFilter interface.
type recentFilter struct {
	gextras.Objector
	Buildable
}

var _ RecentFilter = (*recentFilter)(nil)

// WrapRecentFilter wraps a GObject to the right type. It is
// primarily used internally.
func WrapRecentFilter(obj *externglib.Object) RecentFilter {
	return RecentFilter{
		Objector:  obj,
		Buildable: WrapBuildable(obj),
	}
}

func marshalRecentFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRecentFilter(obj), nil
}

// NewRecentFilter constructs a class RecentFilter.
func NewRecentFilter() {
	C.gtk_recent_filter_new()
}

// AddAge adds a rule that allows resources based on their age - that is,
// the number of days elapsed since they were last modified.
func (f recentFilter) AddAge(f RecentFilter, days int) {
	var arg0 *C.GtkRecentFilter
	var arg1 C.gint

	arg0 = (*C.GtkRecentFilter)(unsafe.Pointer(f.Native()))
	arg1 = C.gint(days)

	C.gtk_recent_filter_add_age(arg0, arg1)
}

// AddApplication adds a rule that allows resources based on the name of the
// application that has registered them.
func (f recentFilter) AddApplication(f RecentFilter, application string) {
	var arg0 *C.GtkRecentFilter
	var arg1 *C.gchar

	arg0 = (*C.GtkRecentFilter)(unsafe.Pointer(f.Native()))
	arg1 = (*C.gchar)(C.CString(application))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_recent_filter_add_application(arg0, arg1)
}

// AddCustom adds a rule to a filter that allows resources based on a custom
// callback function. The bitfield @needed which is passed in provides
// information about what sorts of information that the filter function
// needs; this allows GTK+ to avoid retrieving expensive information when it
// isn’t needed by the filter.
func (f recentFilter) AddCustom(f RecentFilter) {
	var arg0 *C.GtkRecentFilter

	arg0 = (*C.GtkRecentFilter)(unsafe.Pointer(f.Native()))

	C.gtk_recent_filter_add_custom(arg0, arg1, arg2, arg3, arg4)
}

// AddGroup adds a rule that allows resources based on the name of the group
// to which they belong
func (f recentFilter) AddGroup(f RecentFilter, group string) {
	var arg0 *C.GtkRecentFilter
	var arg1 *C.gchar

	arg0 = (*C.GtkRecentFilter)(unsafe.Pointer(f.Native()))
	arg1 = (*C.gchar)(C.CString(group))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_recent_filter_add_group(arg0, arg1)
}

// AddMIMEType adds a rule that allows resources based on their registered
// MIME type.
func (f recentFilter) AddMIMEType(f RecentFilter, mimeType string) {
	var arg0 *C.GtkRecentFilter
	var arg1 *C.gchar

	arg0 = (*C.GtkRecentFilter)(unsafe.Pointer(f.Native()))
	arg1 = (*C.gchar)(C.CString(mimeType))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_recent_filter_add_mime_type(arg0, arg1)
}

// AddPattern adds a rule that allows resources based on a pattern matching
// their display name.
func (f recentFilter) AddPattern(f RecentFilter, pattern string) {
	var arg0 *C.GtkRecentFilter
	var arg1 *C.gchar

	arg0 = (*C.GtkRecentFilter)(unsafe.Pointer(f.Native()))
	arg1 = (*C.gchar)(C.CString(pattern))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_recent_filter_add_pattern(arg0, arg1)
}

// AddPixbufFormats adds a rule allowing image files in the formats
// supported by GdkPixbuf.
func (f recentFilter) AddPixbufFormats(f RecentFilter) {
	var arg0 *C.GtkRecentFilter

	arg0 = (*C.GtkRecentFilter)(unsafe.Pointer(f.Native()))

	C.gtk_recent_filter_add_pixbuf_formats(arg0)
}

// Filter tests whether a file should be displayed according to @filter. The
// RecentFilterInfo @filter_info should include the fields returned from
// gtk_recent_filter_get_needed(), and must set the
// RecentFilterInfo.contains field of @filter_info to indicate which fields
// have been set.
//
// This function will not typically be used by applications; it is intended
// principally for use in the implementation of RecentChooser.
func (f recentFilter) Filter(f RecentFilter, filterInfo *RecentFilterInfo) bool {
	var arg0 *C.GtkRecentFilter
	var arg1 *C.GtkRecentFilterInfo

	arg0 = (*C.GtkRecentFilter)(unsafe.Pointer(f.Native()))
	arg1 = (*C.GtkRecentFilterInfo)(unsafe.Pointer(filterInfo.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_recent_filter_filter(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// Name gets the human-readable name for the filter. See
// gtk_recent_filter_set_name().
func (f recentFilter) Name(f RecentFilter) {
	var arg0 *C.GtkRecentFilter

	arg0 = (*C.GtkRecentFilter)(unsafe.Pointer(f.Native()))

	C.gtk_recent_filter_get_name(arg0)
}

// Needed gets the fields that need to be filled in for the RecentFilterInfo
// passed to gtk_recent_filter_filter()
//
// This function will not typically be used by applications; it is intended
// principally for use in the implementation of RecentChooser.
func (f recentFilter) Needed(f RecentFilter) {
	var arg0 *C.GtkRecentFilter

	arg0 = (*C.GtkRecentFilter)(unsafe.Pointer(f.Native()))

	C.gtk_recent_filter_get_needed(arg0)
}

// SetName sets the human-readable name of the filter; this is the string
// that will be displayed in the recently used resources selector user
// interface if there is a selectable list of filters.
func (f recentFilter) SetName(f RecentFilter, name string) {
	var arg0 *C.GtkRecentFilter
	var arg1 *C.gchar

	arg0 = (*C.GtkRecentFilter)(unsafe.Pointer(f.Native()))
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_recent_filter_set_name(arg0, arg1)
}

// Tooltip: basic tooltips can be realized simply by using
// gtk_widget_set_tooltip_text() or gtk_widget_set_tooltip_markup() without any
// explicit tooltip object.
//
// When you need a tooltip with a little more fancy contents, like adding an
// image, or you want the tooltip to have different contents per TreeView row or
// cell, you will have to do a little more work:
//
// - Set the Widget:has-tooltip property to true, this will make GTK+ monitor
// the widget for motion and related events which are needed to determine when
// and where to show a tooltip.
//
// - Connect to the Widget::query-tooltip signal. This signal will be emitted
// when a tooltip is supposed to be shown. One of the arguments passed to the
// signal handler is a GtkTooltip object. This is the object that we are about
// to display as a tooltip, and can be manipulated in your callback using
// functions like gtk_tooltip_set_icon(). There are functions for setting the
// tooltip’s markup, setting an image from a named icon, or even putting in a
// custom widget.
//
//    Return true from your query-tooltip handler. This causes the tooltip to be
//    show. If you return false, it will not be shown.
//
// In the probably rare case where you want to have even more control over the
// tooltip that is about to be shown, you can set your own Window which will be
// used as tooltip window. This works as follows:
//
// - Set Widget:has-tooltip and connect to Widget::query-tooltip as before. Use
// gtk_widget_set_tooltip_window() to set a Window created by you as tooltip
// window.
//
// - In the Widget::query-tooltip callback you can access your window using
// gtk_widget_get_tooltip_window() and manipulate as you wish. The semantics of
// the return value are exactly as before, return true to show the window, false
// to not show it.
type Tooltip interface {
	gextras.Objector

	// SetCustom replaces the widget packed into the tooltip with
	// @custom_widget. @custom_widget does not get destroyed when the tooltip
	// goes away. By default a box with a Image and Label is embedded in the
	// tooltip, which can be configured using gtk_tooltip_set_markup() and
	// gtk_tooltip_set_icon().
	SetCustom(t Tooltip, customWidget Widget)
	// SetIcon sets the icon of the tooltip (which is in front of the text) to
	// be @pixbuf. If @pixbuf is nil, the image will be hidden.
	SetIcon(t Tooltip, pixbuf gdkpixbuf.Pixbuf)
	// SetIconFromGIcon sets the icon of the tooltip (which is in front of the
	// text) to be the icon indicated by @gicon with the size indicated by
	// @size. If @gicon is nil, the image will be hidden.
	SetIconFromGIcon(t Tooltip, gicon gio.Icon, size int)
	// SetIconFromIconName sets the icon of the tooltip (which is in front of
	// the text) to be the icon indicated by @icon_name with the size indicated
	// by @size. If @icon_name is nil, the image will be hidden.
	SetIconFromIconName(t Tooltip, iconName string, size int)
	// SetIconFromStock sets the icon of the tooltip (which is in front of the
	// text) to be the stock item indicated by @stock_id with the size indicated
	// by @size. If @stock_id is nil, the image will be hidden.
	SetIconFromStock(t Tooltip, stockID string, size int)
	// SetMarkup sets the text of the tooltip to be @markup, which is marked up
	// with the [Pango text markup language][PangoMarkupFormat]. If @markup is
	// nil, the label will be hidden.
	SetMarkup(t Tooltip, markup string)
	// SetText sets the text of the tooltip to be @text. If @text is nil, the
	// label will be hidden. See also gtk_tooltip_set_markup().
	SetText(t Tooltip, text string)
	// SetTipArea sets the area of the widget, where the contents of this
	// tooltip apply, to be @rect (in widget coordinates). This is especially
	// useful for properly setting tooltips on TreeView rows and cells,
	// IconViews, etc.
	//
	// For setting tooltips on TreeView, please refer to the convenience
	// functions for this: gtk_tree_view_set_tooltip_row() and
	// gtk_tree_view_set_tooltip_cell().
	SetTipArea(t Tooltip, rect *gdk.Rectangle)
}

// tooltip implements the Tooltip interface.
type tooltip struct {
	gextras.Objector
}

var _ Tooltip = (*tooltip)(nil)

// WrapTooltip wraps a GObject to the right type. It is
// primarily used internally.
func WrapTooltip(obj *externglib.Object) Tooltip {
	return Tooltip{
		Objector: obj,
	}
}

func marshalTooltip(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTooltip(obj), nil
}

// SetCustom replaces the widget packed into the tooltip with
// @custom_widget. @custom_widget does not get destroyed when the tooltip
// goes away. By default a box with a Image and Label is embedded in the
// tooltip, which can be configured using gtk_tooltip_set_markup() and
// gtk_tooltip_set_icon().
func (t tooltip) SetCustom(t Tooltip, customWidget Widget) {
	var arg0 *C.GtkTooltip
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(customWidget.Native()))

	C.gtk_tooltip_set_custom(arg0, arg1)
}

// SetIcon sets the icon of the tooltip (which is in front of the text) to
// be @pixbuf. If @pixbuf is nil, the image will be hidden.
func (t tooltip) SetIcon(t Tooltip, pixbuf gdkpixbuf.Pixbuf) {
	var arg0 *C.GtkTooltip
	var arg1 *C.GdkPixbuf

	arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	C.gtk_tooltip_set_icon(arg0, arg1)
}

// SetIconFromGIcon sets the icon of the tooltip (which is in front of the
// text) to be the icon indicated by @gicon with the size indicated by
// @size. If @gicon is nil, the image will be hidden.
func (t tooltip) SetIconFromGIcon(t Tooltip, gicon gio.Icon, size int) {
	var arg0 *C.GtkTooltip
	var arg1 *C.GIcon
	var arg2 C.GtkIconSize

	arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GIcon)(unsafe.Pointer(gicon.Native()))
	arg2 = C.GtkIconSize(size)

	C.gtk_tooltip_set_icon_from_gicon(arg0, arg1, arg2)
}

// SetIconFromIconName sets the icon of the tooltip (which is in front of
// the text) to be the icon indicated by @icon_name with the size indicated
// by @size. If @icon_name is nil, the image will be hidden.
func (t tooltip) SetIconFromIconName(t Tooltip, iconName string, size int) {
	var arg0 *C.GtkTooltip
	var arg1 *C.gchar
	var arg2 C.GtkIconSize

	arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.GtkIconSize(size)

	C.gtk_tooltip_set_icon_from_icon_name(arg0, arg1, arg2)
}

// SetIconFromStock sets the icon of the tooltip (which is in front of the
// text) to be the stock item indicated by @stock_id with the size indicated
// by @size. If @stock_id is nil, the image will be hidden.
func (t tooltip) SetIconFromStock(t Tooltip, stockID string, size int) {
	var arg0 *C.GtkTooltip
	var arg1 *C.gchar
	var arg2 C.GtkIconSize

	arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	arg1 = (*C.gchar)(C.CString(stockID))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.GtkIconSize(size)

	C.gtk_tooltip_set_icon_from_stock(arg0, arg1, arg2)
}

// SetMarkup sets the text of the tooltip to be @markup, which is marked up
// with the [Pango text markup language][PangoMarkupFormat]. If @markup is
// nil, the label will be hidden.
func (t tooltip) SetMarkup(t Tooltip, markup string) {
	var arg0 *C.GtkTooltip
	var arg1 *C.gchar

	arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	arg1 = (*C.gchar)(C.CString(markup))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_tooltip_set_markup(arg0, arg1)
}

// SetText sets the text of the tooltip to be @text. If @text is nil, the
// label will be hidden. See also gtk_tooltip_set_markup().
func (t tooltip) SetText(t Tooltip, text string) {
	var arg0 *C.GtkTooltip
	var arg1 *C.gchar

	arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_tooltip_set_text(arg0, arg1)
}

// SetTipArea sets the area of the widget, where the contents of this
// tooltip apply, to be @rect (in widget coordinates). This is especially
// useful for properly setting tooltips on TreeView rows and cells,
// IconViews, etc.
//
// For setting tooltips on TreeView, please refer to the convenience
// functions for this: gtk_tree_view_set_tooltip_row() and
// gtk_tree_view_set_tooltip_cell().
func (t tooltip) SetTipArea(t Tooltip, rect *gdk.Rectangle) {
	var arg0 *C.GtkTooltip
	var arg1 *C.GdkRectangle

	arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GdkRectangle)(unsafe.Pointer(rect.Native()))

	C.gtk_tooltip_set_tip_area(arg0, arg1)
}
