// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk+-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_align_get_type()), F: marshalAlign},
		{T: externglib.Type(C.gtk_arrow_placement_get_type()), F: marshalArrowPlacement},
		{T: externglib.Type(C.gtk_arrow_type_get_type()), F: marshalArrowType},
		{T: externglib.Type(C.gtk_assistant_page_type_get_type()), F: marshalAssistantPageType},
		{T: externglib.Type(C.gtk_baseline_position_get_type()), F: marshalBaselinePosition},
		{T: externglib.Type(C.gtk_border_style_get_type()), F: marshalBorderStyle},
		{T: externglib.Type(C.gtk_builder_error_get_type()), F: marshalBuilderError},
		{T: externglib.Type(C.gtk_button_box_style_get_type()), F: marshalButtonBoxStyle},
		{T: externglib.Type(C.gtk_button_role_get_type()), F: marshalButtonRole},
		{T: externglib.Type(C.gtk_buttons_type_get_type()), F: marshalButtonsType},
		{T: externglib.Type(C.gtk_cell_renderer_accel_mode_get_type()), F: marshalCellRendererAccelMode},
		{T: externglib.Type(C.gtk_cell_renderer_mode_get_type()), F: marshalCellRendererMode},
		{T: externglib.Type(C.gtk_corner_type_get_type()), F: marshalCornerType},
		{T: externglib.Type(C.gtk_css_provider_error_get_type()), F: marshalCSSProviderError},
		{T: externglib.Type(C.gtk_css_section_type_get_type()), F: marshalCSSSectionType},
		{T: externglib.Type(C.gtk_delete_type_get_type()), F: marshalDeleteType},
		{T: externglib.Type(C.gtk_direction_type_get_type()), F: marshalDirectionType},
		{T: externglib.Type(C.gtk_drag_result_get_type()), F: marshalDragResult},
		{T: externglib.Type(C.gtk_entry_icon_position_get_type()), F: marshalEntryIconPosition},
		{T: externglib.Type(C.gtk_event_sequence_state_get_type()), F: marshalEventSequenceState},
		{T: externglib.Type(C.gtk_expander_style_get_type()), F: marshalExpanderStyle},
		{T: externglib.Type(C.gtk_file_chooser_action_get_type()), F: marshalFileChooserAction},
		{T: externglib.Type(C.gtk_file_chooser_confirmation_get_type()), F: marshalFileChooserConfirmation},
		{T: externglib.Type(C.gtk_file_chooser_error_get_type()), F: marshalFileChooserError},
		{T: externglib.Type(C.gtk_im_preedit_style_get_type()), F: marshalIMPreeditStyle},
		{T: externglib.Type(C.gtk_im_status_style_get_type()), F: marshalIMStatusStyle},
		{T: externglib.Type(C.gtk_icon_size_get_type()), F: marshalIconSize},
		{T: externglib.Type(C.gtk_icon_theme_error_get_type()), F: marshalIconThemeError},
		{T: externglib.Type(C.gtk_icon_view_drop_position_get_type()), F: marshalIconViewDropPosition},
		{T: externglib.Type(C.gtk_image_type_get_type()), F: marshalImageType},
		{T: externglib.Type(C.gtk_input_purpose_get_type()), F: marshalInputPurpose},
		{T: externglib.Type(C.gtk_justification_get_type()), F: marshalJustification},
		{T: externglib.Type(C.gtk_level_bar_mode_get_type()), F: marshalLevelBarMode},
		{T: externglib.Type(C.gtk_license_get_type()), F: marshalLicense},
		{T: externglib.Type(C.gtk_menu_direction_type_get_type()), F: marshalMenuDirectionType},
		{T: externglib.Type(C.gtk_message_type_get_type()), F: marshalMessageType},
		{T: externglib.Type(C.gtk_movement_step_get_type()), F: marshalMovementStep},
		{T: externglib.Type(C.gtk_notebook_tab_get_type()), F: marshalNotebookTab},
		{T: externglib.Type(C.gtk_number_up_layout_get_type()), F: marshalNumberUpLayout},
		{T: externglib.Type(C.gtk_orientation_get_type()), F: marshalOrientation},
		{T: externglib.Type(C.gtk_pack_direction_get_type()), F: marshalPackDirection},
		{T: externglib.Type(C.gtk_pack_type_get_type()), F: marshalPackType},
		{T: externglib.Type(C.gtk_pad_action_type_get_type()), F: marshalPadActionType},
		{T: externglib.Type(C.gtk_page_orientation_get_type()), F: marshalPageOrientation},
		{T: externglib.Type(C.gtk_page_set_get_type()), F: marshalPageSet},
		{T: externglib.Type(C.gtk_pan_direction_get_type()), F: marshalPanDirection},
		{T: externglib.Type(C.gtk_path_priority_type_get_type()), F: marshalPathPriorityType},
		{T: externglib.Type(C.gtk_path_type_get_type()), F: marshalPathType},
		{T: externglib.Type(C.gtk_policy_type_get_type()), F: marshalPolicyType},
		{T: externglib.Type(C.gtk_popover_constraint_get_type()), F: marshalPopoverConstraint},
		{T: externglib.Type(C.gtk_position_type_get_type()), F: marshalPositionType},
		{T: externglib.Type(C.gtk_print_duplex_get_type()), F: marshalPrintDuplex},
		{T: externglib.Type(C.gtk_print_error_get_type()), F: marshalPrintError},
		{T: externglib.Type(C.gtk_print_operation_action_get_type()), F: marshalPrintOperationAction},
		{T: externglib.Type(C.gtk_print_operation_result_get_type()), F: marshalPrintOperationResult},
		{T: externglib.Type(C.gtk_print_pages_get_type()), F: marshalPrintPages},
		{T: externglib.Type(C.gtk_print_quality_get_type()), F: marshalPrintQuality},
		{T: externglib.Type(C.gtk_print_status_get_type()), F: marshalPrintStatus},
		{T: externglib.Type(C.gtk_propagation_phase_get_type()), F: marshalPropagationPhase},
		{T: externglib.Type(C.gtk_rc_token_type_get_type()), F: marshalRCTokenType},
		{T: externglib.Type(C.gtk_recent_chooser_error_get_type()), F: marshalRecentChooserError},
		{T: externglib.Type(C.gtk_recent_manager_error_get_type()), F: marshalRecentManagerError},
		{T: externglib.Type(C.gtk_recent_sort_type_get_type()), F: marshalRecentSortType},
		{T: externglib.Type(C.gtk_relief_style_get_type()), F: marshalReliefStyle},
		{T: externglib.Type(C.gtk_resize_mode_get_type()), F: marshalResizeMode},
		{T: externglib.Type(C.gtk_response_type_get_type()), F: marshalResponseType},
		{T: externglib.Type(C.gtk_revealer_transition_type_get_type()), F: marshalRevealerTransitionType},
		{T: externglib.Type(C.gtk_scroll_step_get_type()), F: marshalScrollStep},
		{T: externglib.Type(C.gtk_scroll_type_get_type()), F: marshalScrollType},
		{T: externglib.Type(C.gtk_scrollable_policy_get_type()), F: marshalScrollablePolicy},
		{T: externglib.Type(C.gtk_selection_mode_get_type()), F: marshalSelectionMode},
		{T: externglib.Type(C.gtk_sensitivity_type_get_type()), F: marshalSensitivityType},
		{T: externglib.Type(C.gtk_shadow_type_get_type()), F: marshalShadowType},
		{T: externglib.Type(C.gtk_shortcut_type_get_type()), F: marshalShortcutType},
		{T: externglib.Type(C.gtk_size_group_mode_get_type()), F: marshalSizeGroupMode},
		{T: externglib.Type(C.gtk_size_request_mode_get_type()), F: marshalSizeRequestMode},
		{T: externglib.Type(C.gtk_sort_type_get_type()), F: marshalSortType},
		{T: externglib.Type(C.gtk_spin_button_update_policy_get_type()), F: marshalSpinButtonUpdatePolicy},
		{T: externglib.Type(C.gtk_spin_type_get_type()), F: marshalSpinType},
		{T: externglib.Type(C.gtk_stack_transition_type_get_type()), F: marshalStackTransitionType},
		{T: externglib.Type(C.gtk_state_type_get_type()), F: marshalStateType},
		{T: externglib.Type(C.gtk_text_buffer_target_info_get_type()), F: marshalTextBufferTargetInfo},
		{T: externglib.Type(C.gtk_text_direction_get_type()), F: marshalTextDirection},
		{T: externglib.Type(C.gtk_text_extend_selection_get_type()), F: marshalTextExtendSelection},
		{T: externglib.Type(C.gtk_text_view_layer_get_type()), F: marshalTextViewLayer},
		{T: externglib.Type(C.gtk_text_window_type_get_type()), F: marshalTextWindowType},
		{T: externglib.Type(C.gtk_toolbar_space_style_get_type()), F: marshalToolbarSpaceStyle},
		{T: externglib.Type(C.gtk_toolbar_style_get_type()), F: marshalToolbarStyle},
		{T: externglib.Type(C.gtk_tree_view_column_sizing_get_type()), F: marshalTreeViewColumnSizing},
		{T: externglib.Type(C.gtk_tree_view_drop_position_get_type()), F: marshalTreeViewDropPosition},
		{T: externglib.Type(C.gtk_tree_view_grid_lines_get_type()), F: marshalTreeViewGridLines},
		{T: externglib.Type(C.gtk_unit_get_type()), F: marshalUnit},
		{T: externglib.Type(C.gtk_widget_help_type_get_type()), F: marshalWidgetHelpType},
		{T: externglib.Type(C.gtk_window_position_get_type()), F: marshalWindowPosition},
		{T: externglib.Type(C.gtk_window_type_get_type()), F: marshalWindowType},
		{T: externglib.Type(C.gtk_wrap_mode_get_type()), F: marshalWrapMode},
		{T: externglib.Type(C.gtk_accel_flags_get_type()), F: marshalAccelFlags},
		{T: externglib.Type(C.gtk_application_inhibit_flags_get_type()), F: marshalApplicationInhibitFlags},
		{T: externglib.Type(C.gtk_attach_options_get_type()), F: marshalAttachOptions},
		{T: externglib.Type(C.gtk_calendar_display_options_get_type()), F: marshalCalendarDisplayOptions},
		{T: externglib.Type(C.gtk_cell_renderer_state_get_type()), F: marshalCellRendererState},
		{T: externglib.Type(C.gtk_debug_flag_get_type()), F: marshalDebugFlag},
		{T: externglib.Type(C.gtk_dest_defaults_get_type()), F: marshalDestDefaults},
		{T: externglib.Type(C.gtk_dialog_flags_get_type()), F: marshalDialogFlags},
		{T: externglib.Type(C.gtk_event_controller_scroll_flags_get_type()), F: marshalEventControllerScrollFlags},
		{T: externglib.Type(C.gtk_file_filter_flags_get_type()), F: marshalFileFilterFlags},
		{T: externglib.Type(C.gtk_font_chooser_level_get_type()), F: marshalFontChooserLevel},
		{T: externglib.Type(C.gtk_icon_lookup_flags_get_type()), F: marshalIconLookupFlags},
		{T: externglib.Type(C.gtk_input_hints_get_type()), F: marshalInputHints},
		{T: externglib.Type(C.gtk_junction_sides_get_type()), F: marshalJunctionSides},
		{T: externglib.Type(C.gtk_places_open_flags_get_type()), F: marshalPlacesOpenFlags},
		{T: externglib.Type(C.gtk_rc_flags_get_type()), F: marshalRCFlags},
		{T: externglib.Type(C.gtk_recent_filter_flags_get_type()), F: marshalRecentFilterFlags},
		{T: externglib.Type(C.gtk_region_flags_get_type()), F: marshalRegionFlags},
		{T: externglib.Type(C.gtk_state_flags_get_type()), F: marshalStateFlags},
		{T: externglib.Type(C.gtk_style_context_print_flags_get_type()), F: marshalStyleContextPrintFlags},
		{T: externglib.Type(C.gtk_target_flags_get_type()), F: marshalTargetFlags},
		{T: externglib.Type(C.gtk_text_search_flags_get_type()), F: marshalTextSearchFlags},
		{T: externglib.Type(C.gtk_tool_palette_drag_targets_get_type()), F: marshalToolPaletteDragTargets},
		{T: externglib.Type(C.gtk_tree_model_flags_get_type()), F: marshalTreeModelFlags},
		{T: externglib.Type(C.gtk_ui_manager_item_type_get_type()), F: marshalUIManagerItemType},
		{T: externglib.Type(C.gtk_file_chooser_get_type()), F: marshalFileChooser},
		{T: externglib.Type(C.gtk_clipboard_get_type()), F: marshalClipboard},
		{T: externglib.Type(C.gtk_file_filter_get_type()), F: marshalFileFilter},
		{T: externglib.Type(C.gtk_page_setup_get_type()), F: marshalPageSetup},
		{T: externglib.Type(C.gtk_print_context_get_type()), F: marshalPrintContext},
		{T: externglib.Type(C.gtk_print_settings_get_type()), F: marshalPrintSettings},
		{T: externglib.Type(C.gtk_recent_filter_get_type()), F: marshalRecentFilter},
		{T: externglib.Type(C.gtk_tooltip_get_type()), F: marshalTooltip},
	})
}

// Align controls how a widget deals with extra space in a single (x or y)
// dimension.
//
// Alignment only matters if the widget receives a “too large” allocation, for
// example if you packed the widget with the Widget:expand flag inside a Box,
// then the widget might get extra space. If you have for example a 16x16 icon
// inside a 32x32 space, the icon could be scaled and stretched, it could be
// centered, or it could be positioned to one side of the space.
//
// Note that in horizontal context @GTK_ALIGN_START and @GTK_ALIGN_END are
// interpreted relative to text direction.
//
// GTK_ALIGN_BASELINE support for it is optional for containers and widgets, and
// it is only supported for vertical alignment. When its not supported by a
// child or a container it is treated as @GTK_ALIGN_FILL.
type Align int

const (
	// AlignFill: stretch to fill all space if possible, center if no meaningful
	// way to stretch
	AlignFill Align = 0
	// AlignStart: snap to left or top side, leaving space on right or bottom
	AlignStart Align = 1
	// AlignEnd: snap to right or bottom side, leaving space on left or top
	AlignEnd Align = 2
	// AlignCenter: center natural width of widget inside the allocation
	AlignCenter Align = 3
	// AlignBaseline: align the widget according to the baseline. Since 3.10.
	AlignBaseline Align = 4
)

func marshalAlign(p uintptr) (interface{}, error) {
	return Align(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ArrowPlacement: used to specify the placement of scroll arrows in scrolling
// menus.
type ArrowPlacement int

const (
	// ArrowPlacementBoth: place one arrow on each end of the menu.
	ArrowPlacementBoth ArrowPlacement = 0
	// ArrowPlacementStart: place both arrows at the top of the menu.
	ArrowPlacementStart ArrowPlacement = 1
	// ArrowPlacementEnd: place both arrows at the bottom of the menu.
	ArrowPlacementEnd ArrowPlacement = 2
)

func marshalArrowPlacement(p uintptr) (interface{}, error) {
	return ArrowPlacement(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ArrowType: used to indicate the direction in which an arrow should point.
type ArrowType int

const (
	// ArrowTypeUp represents an upward pointing arrow.
	ArrowTypeUp ArrowType = 0
	// ArrowTypeDown represents a downward pointing arrow.
	ArrowTypeDown ArrowType = 1
	// ArrowTypeLeft represents a left pointing arrow.
	ArrowTypeLeft ArrowType = 2
	// ArrowTypeRight represents a right pointing arrow.
	ArrowTypeRight ArrowType = 3
	// ArrowTypeNone: no arrow. Since 2.10.
	ArrowTypeNone ArrowType = 4
)

func marshalArrowType(p uintptr) (interface{}, error) {
	return ArrowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AssistantPageType: an enum for determining the page role inside the
// Assistant. It's used to handle buttons sensitivity and visibility.
//
// Note that an assistant needs to end its page flow with a page of type
// GTK_ASSISTANT_PAGE_CONFIRM, GTK_ASSISTANT_PAGE_SUMMARY or
// GTK_ASSISTANT_PAGE_PROGRESS to be correct.
//
// The Cancel button will only be shown if the page isn’t “committed”. See
// gtk_assistant_commit() for details.
type AssistantPageType int

const (
	// AssistantPageTypeContent: the page has regular contents. Both the Back
	// and forward buttons will be shown.
	AssistantPageTypeContent AssistantPageType = 0
	// AssistantPageTypeIntro: the page contains an introduction to the
	// assistant task. Only the Forward button will be shown if there is a next
	// page.
	AssistantPageTypeIntro AssistantPageType = 1
	// AssistantPageTypeConfirm: the page lets the user confirm or deny the
	// changes. The Back and Apply buttons will be shown.
	AssistantPageTypeConfirm AssistantPageType = 2
	// AssistantPageTypeSummary: the page informs the user of the changes done.
	// Only the Close button will be shown.
	AssistantPageTypeSummary AssistantPageType = 3
	// AssistantPageTypeProgress: used for tasks that take a long time to
	// complete, blocks the assistant until the page is marked as complete. Only
	// the back button will be shown.
	AssistantPageTypeProgress AssistantPageType = 4
	// AssistantPageTypeCustom: used for when other page types are not
	// appropriate. No buttons will be shown, and the application must add its
	// own buttons through gtk_assistant_add_action_widget().
	AssistantPageTypeCustom AssistantPageType = 5
)

func marshalAssistantPageType(p uintptr) (interface{}, error) {
	return AssistantPageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BaselinePosition: whenever a container has some form of natural row it may
// align children in that row along a common typographical baseline. If the
// amount of verical space in the row is taller than the total requested height
// of the baseline-aligned children then it can use a BaselinePosition to select
// where to put the baseline inside the extra availible space.
type BaselinePosition int

const (
	// BaselinePositionTop: align the baseline at the top
	BaselinePositionTop BaselinePosition = 0
	// BaselinePositionCenter: center the baseline
	BaselinePositionCenter BaselinePosition = 1
	// BaselinePositionBottom: align the baseline at the bottom
	BaselinePositionBottom BaselinePosition = 2
)

func marshalBaselinePosition(p uintptr) (interface{}, error) {
	return BaselinePosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BorderStyle describes how the border of a UI element should be rendered.
type BorderStyle int

const (
	// BorderStyleNone: no visible border
	BorderStyleNone BorderStyle = 0
	// BorderStyleSolid: a single line segment
	BorderStyleSolid BorderStyle = 1
	// BorderStyleInset looks as if the content is sunken into the canvas
	BorderStyleInset BorderStyle = 2
	// BorderStyleOutset looks as if the content is coming out of the canvas
	BorderStyleOutset BorderStyle = 3
	// BorderStyleHidden: same as @GTK_BORDER_STYLE_NONE
	BorderStyleHidden BorderStyle = 4
	// BorderStyleDotted: a series of round dots
	BorderStyleDotted BorderStyle = 5
	// BorderStyleDashed: a series of square-ended dashes
	BorderStyleDashed BorderStyle = 6
	// BorderStyleDouble: two parallel lines with some space between them
	BorderStyleDouble BorderStyle = 7
	// BorderStyleGroove looks as if it were carved in the canvas
	BorderStyleGroove BorderStyle = 8
	// BorderStyleRidge looks as if it were coming out of the canvas
	BorderStyleRidge BorderStyle = 9
)

func marshalBorderStyle(p uintptr) (interface{}, error) {
	return BorderStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BuilderError: error codes that identify various errors that can occur while
// using Builder.
type BuilderError int

const (
	// BuilderErrorInvalidTypeFunction: a type-func attribute didn’t name a
	// function that returns a #GType.
	BuilderErrorInvalidTypeFunction BuilderError = 0
	// BuilderErrorUnhandledTag: the input contained a tag that Builder can’t
	// handle.
	BuilderErrorUnhandledTag BuilderError = 1
	// BuilderErrorMissingAttribute: an attribute that is required by Builder
	// was missing.
	BuilderErrorMissingAttribute BuilderError = 2
	// BuilderErrorInvalidAttribute: Builder found an attribute that it doesn’t
	// understand.
	BuilderErrorInvalidAttribute BuilderError = 3
	// BuilderErrorInvalidTag: Builder found a tag that it doesn’t understand.
	BuilderErrorInvalidTag BuilderError = 4
	// BuilderErrorMissingPropertyValue: a required property value was missing.
	BuilderErrorMissingPropertyValue BuilderError = 5
	// BuilderErrorInvalidValue: Builder couldn’t parse some attribute value.
	BuilderErrorInvalidValue BuilderError = 6
	// BuilderErrorVersionMismatch: the input file requires a newer version of
	// GTK+.
	BuilderErrorVersionMismatch BuilderError = 7
	// BuilderErrorDuplicateID: an object id occurred twice.
	BuilderErrorDuplicateID BuilderError = 8
	// BuilderErrorObjectTypeRefused: a specified object type is of the same
	// type or derived from the type of the composite class being extended with
	// builder XML.
	BuilderErrorObjectTypeRefused BuilderError = 9
	// BuilderErrorTemplateMismatch: the wrong type was specified in a composite
	// class’s template XML
	BuilderErrorTemplateMismatch BuilderError = 10
	// BuilderErrorInvalidProperty: the specified property is unknown for the
	// object class.
	BuilderErrorInvalidProperty BuilderError = 11
	// BuilderErrorInvalidSignal: the specified signal is unknown for the object
	// class.
	BuilderErrorInvalidSignal BuilderError = 12
	// BuilderErrorInvalidID: an object id is unknown
	BuilderErrorInvalidID BuilderError = 13
)

func marshalBuilderError(p uintptr) (interface{}, error) {
	return BuilderError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ButtonBoxStyle: used to dictate the style that a ButtonBox uses to layout the
// buttons it contains.
type ButtonBoxStyle int

const (
	// ButtonBoxStyleSpread buttons are evenly spread across the box.
	ButtonBoxStyleSpread ButtonBoxStyle = 1
	// ButtonBoxStyleEdge buttons are placed at the edges of the box.
	ButtonBoxStyleEdge ButtonBoxStyle = 2
	// ButtonBoxStyleStart buttons are grouped towards the start of the box, (on
	// the left for a HBox, or the top for a VBox).
	ButtonBoxStyleStart ButtonBoxStyle = 3
	// ButtonBoxStyleEnd buttons are grouped towards the end of the box, (on the
	// right for a HBox, or the bottom for a VBox).
	ButtonBoxStyleEnd ButtonBoxStyle = 4
	// ButtonBoxStyleCenter buttons are centered in the box. Since 2.12.
	ButtonBoxStyleCenter ButtonBoxStyle = 5
	// ButtonBoxStyleExpand buttons expand to fill the box. This entails giving
	// buttons a "linked" appearance, making button sizes homogeneous, and
	// setting spacing to 0 (same as calling gtk_box_set_homogeneous() and
	// gtk_box_set_spacing() manually). Since 3.12.
	ButtonBoxStyleExpand ButtonBoxStyle = 6
)

func marshalButtonBoxStyle(p uintptr) (interface{}, error) {
	return ButtonBoxStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ButtonRole: the role specifies the desired appearance of a ModelButton.
type ButtonRole int

const (
	// ButtonRoleNormal: a plain button
	ButtonRoleNormal ButtonRole = 0
	// ButtonRoleCheck: a check button
	ButtonRoleCheck ButtonRole = 1
	// ButtonRoleRadio: a radio button
	ButtonRoleRadio ButtonRole = 2
)

func marshalButtonRole(p uintptr) (interface{}, error) {
	return ButtonRole(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ButtonsType: prebuilt sets of buttons for the dialog. If none of these
// choices are appropriate, simply use GTK_BUTTONS_NONE then call
// gtk_dialog_add_buttons().
//
// > Please note that GTK_BUTTONS_OK, GTK_BUTTONS_YES_NO > and
// GTK_BUTTONS_OK_CANCEL are discouraged by the > GNOME Human Interface
// Guidelines (http://library.gnome.org/devel/hig-book/stable/).
type ButtonsType int

const (
	// ButtonsTypeNone: no buttons at all
	ButtonsTypeNone ButtonsType = 0
	// ButtonsTypeOk: an OK button
	ButtonsTypeOk ButtonsType = 1
	// ButtonsTypeClose: a Close button
	ButtonsTypeClose ButtonsType = 2
	// ButtonsTypeCancel: a Cancel button
	ButtonsTypeCancel ButtonsType = 3
	// ButtonsTypeYesNo yes and No buttons
	ButtonsTypeYesNo ButtonsType = 4
	// ButtonsTypeOkCancel: OK and Cancel buttons
	ButtonsTypeOkCancel ButtonsType = 5
)

func marshalButtonsType(p uintptr) (interface{}, error) {
	return ButtonsType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CellRendererAccelMode determines if the edited accelerators are GTK+
// accelerators. If they are, consumed modifiers are suppressed, only
// accelerators accepted by GTK+ are allowed, and the accelerators are rendered
// in the same way as they are in menus.
type CellRendererAccelMode int

const (
	// CellRendererAccelModeGTK: GTK+ accelerators mode
	CellRendererAccelModeGTK CellRendererAccelMode = 0
	// CellRendererAccelModeOther: other accelerator mode
	CellRendererAccelModeOther CellRendererAccelMode = 1
)

func marshalCellRendererAccelMode(p uintptr) (interface{}, error) {
	return CellRendererAccelMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CellRendererMode identifies how the user can interact with a particular cell.
type CellRendererMode int

const (
	// CellRendererModeInert: the cell is just for display and cannot be
	// interacted with. Note that this doesn’t mean that eg. the row being drawn
	// can’t be selected -- just that a particular element of it cannot be
	// individually modified.
	CellRendererModeInert CellRendererMode = 0
	// CellRendererModeActivatable: the cell can be clicked.
	CellRendererModeActivatable CellRendererMode = 1
	// CellRendererModeEditable: the cell can be edited or otherwise modified.
	CellRendererModeEditable CellRendererMode = 2
)

func marshalCellRendererMode(p uintptr) (interface{}, error) {
	return CellRendererMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CornerType specifies which corner a child widget should be placed in when
// packed into a ScrolledWindow. This is effectively the opposite of where the
// scroll bars are placed.
type CornerType int

const (
	// CornerTypeTopLeft: place the scrollbars on the right and bottom of the
	// widget (default behaviour).
	CornerTypeTopLeft CornerType = 0
	// CornerTypeBottomLeft: place the scrollbars on the top and right of the
	// widget.
	CornerTypeBottomLeft CornerType = 1
	// CornerTypeTopRight: place the scrollbars on the left and bottom of the
	// widget.
	CornerTypeTopRight CornerType = 2
	// CornerTypeBottomRight: place the scrollbars on the top and left of the
	// widget.
	CornerTypeBottomRight CornerType = 3
)

func marshalCornerType(p uintptr) (interface{}, error) {
	return CornerType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CSSProviderError: error codes for GTK_CSS_PROVIDER_ERROR.
type CSSProviderError int

const (
	// CSSProviderErrorFailed: failed.
	CSSProviderErrorFailed CSSProviderError = 0
	// CSSProviderErrorSyntax: syntax error.
	CSSProviderErrorSyntax CSSProviderError = 1
	// CSSProviderErrorImport: import error.
	CSSProviderErrorImport CSSProviderError = 2
	// CSSProviderErrorName: name error.
	CSSProviderErrorName CSSProviderError = 3
	// CSSProviderErrorDeprecated: deprecation error.
	CSSProviderErrorDeprecated CSSProviderError = 4
	// CSSProviderErrorUnknownValue: unknown value.
	CSSProviderErrorUnknownValue CSSProviderError = 5
)

func marshalCSSProviderError(p uintptr) (interface{}, error) {
	return CSSProviderError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CSSSectionType: the different types of sections indicate parts of a CSS
// document as parsed by GTK’s CSS parser. They are oriented towards the CSS
// Grammar (http://www.w3.org/TR/CSS21/grammar.html), but may contain
// extensions.
//
// More types might be added in the future as the parser incorporates more
// features.
type CSSSectionType int

const (
	// CSSSectionTypeDocument: the section describes a complete document. This
	// section time is the only one where gtk_css_section_get_parent() might
	// return nil.
	CSSSectionTypeDocument CSSSectionType = 0
	// CSSSectionTypeImport: the section defines an import rule.
	CSSSectionTypeImport CSSSectionType = 1
	// CSSSectionTypeColorDefinition: the section defines a color. This is a GTK
	// extension to CSS.
	CSSSectionTypeColorDefinition CSSSectionType = 2
	// CSSSectionTypeBindingSet: the section defines a binding set. This is a
	// GTK extension to CSS.
	CSSSectionTypeBindingSet CSSSectionType = 3
	// CSSSectionTypeRuleset: the section defines a CSS ruleset.
	CSSSectionTypeRuleset CSSSectionType = 4
	// CSSSectionTypeSelector: the section defines a CSS selector.
	CSSSectionTypeSelector CSSSectionType = 5
	// CSSSectionTypeDeclaration: the section defines the declaration of a CSS
	// variable.
	CSSSectionTypeDeclaration CSSSectionType = 6
	// CSSSectionTypeValue: the section defines the value of a CSS declaration.
	CSSSectionTypeValue CSSSectionType = 7
	// CSSSectionTypeKeyframes: the section defines keyframes. See [CSS
	// Animations](http://dev.w3.org/csswg/css3-animations/#keyframes) for
	// details. Since 3.6
	CSSSectionTypeKeyframes CSSSectionType = 8
)

func marshalCSSSectionType(p uintptr) (interface{}, error) {
	return CSSSectionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DeleteType: see also: Entry::delete-from-cursor.
type DeleteType int

const (
	// DeleteTypeChars: delete characters.
	DeleteTypeChars DeleteType = 0
	// DeleteTypeWordEnds: delete only the portion of the word to the left/right
	// of cursor if we’re in the middle of a word.
	DeleteTypeWordEnds DeleteType = 1
	// DeleteTypeWords: delete words.
	DeleteTypeWords DeleteType = 2
	// DeleteTypeDisplayLines: delete display-lines. Display-lines refers to the
	// visible lines, with respect to to the current line breaks. As opposed to
	// paragraphs, which are defined by line breaks in the input.
	DeleteTypeDisplayLines DeleteType = 3
	// DeleteTypeDisplayLineEnds: delete only the portion of the display-line to
	// the left/right of cursor.
	DeleteTypeDisplayLineEnds DeleteType = 4
	// DeleteTypeParagraphEnds: delete to the end of the paragraph. Like C-k in
	// Emacs (or its reverse).
	DeleteTypeParagraphEnds DeleteType = 5
	// DeleteTypeParagraphs: delete entire line. Like C-k in pico.
	DeleteTypeParagraphs DeleteType = 6
	// DeleteTypeWhitespace: delete only whitespace. Like M-\ in Emacs.
	DeleteTypeWhitespace DeleteType = 7
)

func marshalDeleteType(p uintptr) (interface{}, error) {
	return DeleteType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DirectionType focus movement types.
type DirectionType int

const (
	// DirectionTypeTabForward: move forward.
	DirectionTypeTabForward DirectionType = 0
	// DirectionTypeTabBackward: move backward.
	DirectionTypeTabBackward DirectionType = 1
	// DirectionTypeUp: move up.
	DirectionTypeUp DirectionType = 2
	// DirectionTypeDown: move down.
	DirectionTypeDown DirectionType = 3
	// DirectionTypeLeft: move left.
	DirectionTypeLeft DirectionType = 4
	// DirectionTypeRight: move right.
	DirectionTypeRight DirectionType = 5
)

func marshalDirectionType(p uintptr) (interface{}, error) {
	return DirectionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DragResult gives an indication why a drag operation failed. The value can by
// obtained by connecting to the Widget::drag-failed signal.
type DragResult int

const (
	// DragResultSuccess: the drag operation was successful.
	DragResultSuccess DragResult = 0
	// DragResultNoTarget: no suitable drag target.
	DragResultNoTarget DragResult = 1
	// DragResultUserCancelled: the user cancelled the drag operation.
	DragResultUserCancelled DragResult = 2
	// DragResultTimeoutExpired: the drag operation timed out.
	DragResultTimeoutExpired DragResult = 3
	// DragResultGrabBroken: the pointer or keyboard grab used for the drag
	// operation was broken.
	DragResultGrabBroken DragResult = 4
	// DragResultError: the drag operation failed due to some unspecified error.
	DragResultError DragResult = 5
)

func marshalDragResult(p uintptr) (interface{}, error) {
	return DragResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EntryIconPosition specifies the side of the entry at which an icon is placed.
type EntryIconPosition int

const (
	// EntryIconPositionPrimary: at the beginning of the entry (depending on the
	// text direction).
	EntryIconPositionPrimary EntryIconPosition = 0
	// EntryIconPositionSecondary: at the end of the entry (depending on the
	// text direction).
	EntryIconPositionSecondary EntryIconPosition = 1
)

func marshalEntryIconPosition(p uintptr) (interface{}, error) {
	return EntryIconPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EventSequenceState describes the state of a EventSequence in a Gesture.
type EventSequenceState int

const (
	// EventSequenceStateNone: the sequence is handled, but not grabbed.
	EventSequenceStateNone EventSequenceState = 0
	// EventSequenceStateClaimed: the sequence is handled and grabbed.
	EventSequenceStateClaimed EventSequenceState = 1
	// EventSequenceStateDenied: the sequence is denied.
	EventSequenceStateDenied EventSequenceState = 2
)

func marshalEventSequenceState(p uintptr) (interface{}, error) {
	return EventSequenceState(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ExpanderStyle: used to specify the style of the expanders drawn by a
// TreeView.
type ExpanderStyle int

const (
	// ExpanderStyleCollapsed: the style used for a collapsed subtree.
	ExpanderStyleCollapsed ExpanderStyle = 0
	// ExpanderStyleSemiCollapsed: intermediate style used during animation.
	ExpanderStyleSemiCollapsed ExpanderStyle = 1
	// ExpanderStyleSemiExpanded: intermediate style used during animation.
	ExpanderStyleSemiExpanded ExpanderStyle = 2
	// ExpanderStyleExpanded: the style used for an expanded subtree.
	ExpanderStyleExpanded ExpanderStyle = 3
)

func marshalExpanderStyle(p uintptr) (interface{}, error) {
	return ExpanderStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileChooserAction describes whether a FileChooser is being used to open
// existing files or to save to a possibly new file.
type FileChooserAction int

const (
	// FileChooserActionOpen indicates open mode. The file chooser will only let
	// the user pick an existing file.
	FileChooserActionOpen FileChooserAction = 0
	// FileChooserActionSave indicates save mode. The file chooser will let the
	// user pick an existing file, or type in a new filename.
	FileChooserActionSave FileChooserAction = 1
	// FileChooserActionSelectFolder indicates an Open mode for selecting
	// folders. The file chooser will let the user pick an existing folder.
	FileChooserActionSelectFolder FileChooserAction = 2
	// FileChooserActionCreateFolder indicates a mode for creating a new folder.
	// The file chooser will let the user name an existing or new folder.
	FileChooserActionCreateFolder FileChooserAction = 3
)

func marshalFileChooserAction(p uintptr) (interface{}, error) {
	return FileChooserAction(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileChooserConfirmation: used as a return value of handlers for the
// FileChooser::confirm-overwrite signal of a FileChooser. This value determines
// whether the file chooser will present the stock confirmation dialog, accept
// the user’s choice of a filename, or let the user choose another filename.
type FileChooserConfirmation int

const (
	// FileChooserConfirmationConfirm: the file chooser will present its stock
	// dialog to confirm about overwriting an existing file.
	FileChooserConfirmationConfirm FileChooserConfirmation = 0
	// FileChooserConfirmationAcceptFilename: the file chooser will terminate
	// and accept the user’s choice of a file name.
	FileChooserConfirmationAcceptFilename FileChooserConfirmation = 1
	// FileChooserConfirmationSelectAgain: the file chooser will continue
	// running, so as to let the user select another file name.
	FileChooserConfirmationSelectAgain FileChooserConfirmation = 2
)

func marshalFileChooserConfirmation(p uintptr) (interface{}, error) {
	return FileChooserConfirmation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileChooserError: these identify the various errors that can occur while
// calling FileChooser functions.
type FileChooserError int

const (
	// FileChooserErrorNonexistent indicates that a file does not exist.
	FileChooserErrorNonexistent FileChooserError = 0
	// FileChooserErrorBadFilename indicates a malformed filename.
	FileChooserErrorBadFilename FileChooserError = 1
	// FileChooserErrorAlreadyExists indicates a duplicate path (e.g. when
	// adding a bookmark).
	FileChooserErrorAlreadyExists FileChooserError = 2
	// FileChooserErrorIncompleteHostname indicates an incomplete hostname (e.g.
	// "http://foo" without a slash after that).
	FileChooserErrorIncompleteHostname FileChooserError = 3
)

func marshalFileChooserError(p uintptr) (interface{}, error) {
	return FileChooserError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IMPreeditStyle: style for input method preedit. See also
// Settings:gtk-im-preedit-style
type IMPreeditStyle int

const (
	// IMPreeditStyleNothing: deprecated
	IMPreeditStyleNothing IMPreeditStyle = 0
	// IMPreeditStyleCallback: deprecated
	IMPreeditStyleCallback IMPreeditStyle = 1
	// IMPreeditStyleNone: deprecated
	IMPreeditStyleNone IMPreeditStyle = 2
)

func marshalIMPreeditStyle(p uintptr) (interface{}, error) {
	return IMPreeditStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IMStatusStyle: style for input method status. See also
// Settings:gtk-im-status-style
type IMStatusStyle int

const (
	// IMStatusStyleNothing: deprecated
	IMStatusStyleNothing IMStatusStyle = 0
	// IMStatusStyleCallback: deprecated
	IMStatusStyleCallback IMStatusStyle = 1
	// IMStatusStyleNone: deprecated
	IMStatusStyleNone IMStatusStyle = 2
)

func marshalIMStatusStyle(p uintptr) (interface{}, error) {
	return IMStatusStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconSize: built-in stock icon sizes.
type IconSize int

const (
	// IconSizeInvalid: invalid size.
	IconSizeInvalid IconSize = 0
	// IconSizeMenu: size appropriate for menus (16px).
	IconSizeMenu IconSize = 1
	// IconSizeSmallToolbar: size appropriate for small toolbars (16px).
	IconSizeSmallToolbar IconSize = 2
	// IconSizeLargeToolbar: size appropriate for large toolbars (24px)
	IconSizeLargeToolbar IconSize = 3
	// IconSizeButton: size appropriate for buttons (16px)
	IconSizeButton IconSize = 4
	// IconSizeDnd: size appropriate for drag and drop (32px)
	IconSizeDnd IconSize = 5
	// IconSizeDialog: size appropriate for dialogs (48px)
	IconSizeDialog IconSize = 6
)

func marshalIconSize(p uintptr) (interface{}, error) {
	return IconSize(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconThemeError: error codes for GtkIconTheme operations.
type IconThemeError int

const (
	// IconThemeErrorNotFound: the icon specified does not exist in the theme
	IconThemeErrorNotFound IconThemeError = 0
	// IconThemeErrorFailed: an unspecified error occurred.
	IconThemeErrorFailed IconThemeError = 1
)

func marshalIconThemeError(p uintptr) (interface{}, error) {
	return IconThemeError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconViewDropPosition: an enum for determining where a dropped item goes.
type IconViewDropPosition int

const (
	// IconViewDropPositionNoDrop: no drop possible
	IconViewDropPositionNoDrop IconViewDropPosition = 0
	// IconViewDropPositionDropInto: dropped item replaces the item
	IconViewDropPositionDropInto IconViewDropPosition = 1
	// IconViewDropPositionDropLeft: droppped item is inserted to the left
	IconViewDropPositionDropLeft IconViewDropPosition = 2
	// IconViewDropPositionDropRight: dropped item is inserted to the right
	IconViewDropPositionDropRight IconViewDropPosition = 3
	// IconViewDropPositionDropAbove: dropped item is inserted above
	IconViewDropPositionDropAbove IconViewDropPosition = 4
	// IconViewDropPositionDropBelow: dropped item is inserted below
	IconViewDropPositionDropBelow IconViewDropPosition = 5
)

func marshalIconViewDropPosition(p uintptr) (interface{}, error) {
	return IconViewDropPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ImageType describes the image data representation used by a Image. If you
// want to get the image from the widget, you can only get the currently-stored
// representation. e.g. if the gtk_image_get_storage_type() returns
// K_IMAGE_PIXBUF, then you can call gtk_image_get_pixbuf() but not
// gtk_image_get_stock(). For empty images, you can request any storage type
// (call any of the "get" functions), but they will all return nil values.
type ImageType int

const (
	// ImageTypeEmpty: there is no image displayed by the widget
	ImageTypeEmpty ImageType = 0
	// ImageTypePixbuf: the widget contains a Pixbuf
	ImageTypePixbuf ImageType = 1
	// ImageTypeStock: the widget contains a [stock item name][gtkstock]
	ImageTypeStock ImageType = 2
	// ImageTypeIconSet: the widget contains a IconSet
	ImageTypeIconSet ImageType = 3
	// ImageTypeAnimation: the widget contains a PixbufAnimation
	ImageTypeAnimation ImageType = 4
	// ImageTypeIconName: the widget contains a named icon. This image type was
	// added in GTK+ 2.6
	ImageTypeIconName ImageType = 5
	// ImageTypeGIcon: the widget contains a #GIcon. This image type was added
	// in GTK+ 2.14
	ImageTypeGIcon ImageType = 6
	// ImageTypeSurface: the widget contains a #cairo_surface_t. This image type
	// was added in GTK+ 3.10
	ImageTypeSurface ImageType = 7
)

func marshalImageType(p uintptr) (interface{}, error) {
	return ImageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// InputPurpose describes primary purpose of the input widget. This information
// is useful for on-screen keyboards and similar input methods to decide which
// keys should be presented to the user.
//
// Note that the purpose is not meant to impose a totally strict rule about
// allowed characters, and does not replace input validation. It is fine for an
// on-screen keyboard to let the user override the character set restriction
// that is expressed by the purpose. The application is expected to validate the
// entry contents, even if it specified a purpose.
//
// The difference between @GTK_INPUT_PURPOSE_DIGITS and
// @GTK_INPUT_PURPOSE_NUMBER is that the former accepts only digits while the
// latter also some punctuation (like commas or points, plus, minus) and “e” or
// “E” as in 3.14E+000.
//
// This enumeration may be extended in the future; input methods should
// interpret unknown values as “free form”.
type InputPurpose int

const (
	// InputPurposeFreeForm: allow any character
	InputPurposeFreeForm InputPurpose = 0
	// InputPurposeAlpha: allow only alphabetic characters
	InputPurposeAlpha InputPurpose = 1
	// InputPurposeDigits: allow only digits
	InputPurposeDigits InputPurpose = 2
	// InputPurposeNumber: edited field expects numbers
	InputPurposeNumber InputPurpose = 3
	// InputPurposePhone: edited field expects phone number
	InputPurposePhone InputPurpose = 4
	// InputPurposeURL: edited field expects URL
	InputPurposeURL InputPurpose = 5
	// InputPurposeEmail: edited field expects email address
	InputPurposeEmail InputPurpose = 6
	// InputPurposeName: edited field expects the name of a person
	InputPurposeName InputPurpose = 7
	// InputPurposePassword: like @GTK_INPUT_PURPOSE_FREE_FORM, but characters
	// are hidden
	InputPurposePassword InputPurpose = 8
	// InputPurposePin: like @GTK_INPUT_PURPOSE_DIGITS, but characters are
	// hidden
	InputPurposePin InputPurpose = 9
	// InputPurposeTerminal: allow any character, in addition to control codes
	InputPurposeTerminal InputPurpose = 10
)

func marshalInputPurpose(p uintptr) (interface{}, error) {
	return InputPurpose(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Justification: used for justifying the text inside a Label widget. (See also
// Alignment).
type Justification int

const (
	// JustificationLeft: the text is placed at the left edge of the label.
	JustificationLeft Justification = 0
	// JustificationRight: the text is placed at the right edge of the label.
	JustificationRight Justification = 1
	// JustificationCenter: the text is placed in the center of the label.
	JustificationCenter Justification = 2
	// JustificationFill: the text is placed is distributed across the label.
	JustificationFill Justification = 3
)

func marshalJustification(p uintptr) (interface{}, error) {
	return Justification(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// LevelBarMode describes how LevelBar contents should be rendered. Note that
// this enumeration could be extended with additional modes in the future.
type LevelBarMode int

const (
	// LevelBarModeContinuous: the bar has a continuous mode
	LevelBarModeContinuous LevelBarMode = 0
	// LevelBarModeDiscrete: the bar has a discrete mode
	LevelBarModeDiscrete LevelBarMode = 1
)

func marshalLevelBarMode(p uintptr) (interface{}, error) {
	return LevelBarMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// License: the type of license for an application.
//
// This enumeration can be expanded at later date.
type License int

const (
	// LicenseUnknown: no license specified
	LicenseUnknown License = 0
	// LicenseCustom: a license text is going to be specified by the developer
	LicenseCustom License = 1
	// LicenseGpl20: the GNU General Public License, version 2.0 or later
	LicenseGpl20 License = 2
	// LicenseGpl30: the GNU General Public License, version 3.0 or later
	LicenseGpl30 License = 3
	// LicenseLgpl21: the GNU Lesser General Public License, version 2.1 or
	// later
	LicenseLgpl21 License = 4
	// LicenseLgpl30: the GNU Lesser General Public License, version 3.0 or
	// later
	LicenseLgpl30 License = 5
	// LicenseBsd: the BSD standard license
	LicenseBsd License = 6
	// LicenseMitX11: the MIT/X11 standard license
	LicenseMitX11 License = 7
	// LicenseArtistic: the Artistic License, version 2.0
	LicenseArtistic License = 8
	// LicenseGpl20Only: the GNU General Public License, version 2.0 only. Since
	// 3.12.
	LicenseGpl20Only License = 9
	// LicenseGpl30Only: the GNU General Public License, version 3.0 only. Since
	// 3.12.
	LicenseGpl30Only License = 10
	// LicenseLgpl21Only: the GNU Lesser General Public License, version 2.1
	// only. Since 3.12.
	LicenseLgpl21Only License = 11
	// LicenseLgpl30Only: the GNU Lesser General Public License, version 3.0
	// only. Since 3.12.
	LicenseLgpl30Only License = 12
	// LicenseAgpl30: the GNU Affero General Public License, version 3.0 or
	// later. Since: 3.22.
	LicenseAgpl30 License = 13
	// LicenseAgpl30Only: the GNU Affero General Public License, version 3.0
	// only. Since: 3.22.27.
	LicenseAgpl30Only License = 14
	// LicenseBsd3: the 3-clause BSD licence. Since: 3.24.20.
	LicenseBsd3 License = 15
	// LicenseApache20: the Apache License, version 2.0. Since: 3.24.20.
	LicenseApache20 License = 16
	// LicenseMpl20: the Mozilla Public License, version 2.0. Since: 3.24.20.
	LicenseMpl20 License = 17
)

func marshalLicense(p uintptr) (interface{}, error) {
	return License(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MenuDirectionType: an enumeration representing directional movements within a
// menu.
type MenuDirectionType int

const (
	// MenuDirectionTypeParent: to the parent menu shell
	MenuDirectionTypeParent MenuDirectionType = 0
	// MenuDirectionTypeChild: to the submenu, if any, associated with the item
	MenuDirectionTypeChild MenuDirectionType = 1
	// MenuDirectionTypeNext: to the next menu item
	MenuDirectionTypeNext MenuDirectionType = 2
	// MenuDirectionTypePrev: to the previous menu item
	MenuDirectionTypePrev MenuDirectionType = 3
)

func marshalMenuDirectionType(p uintptr) (interface{}, error) {
	return MenuDirectionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MessageType: the type of message being displayed in the dialog.
type MessageType int

const (
	// MessageTypeInfo: informational message
	MessageTypeInfo MessageType = 0
	// MessageTypeWarning: non-fatal warning message
	MessageTypeWarning MessageType = 1
	// MessageTypeQuestion: question requiring a choice
	MessageTypeQuestion MessageType = 2
	// MessageTypeError: fatal error message
	MessageTypeError MessageType = 3
	// MessageTypeOther: none of the above
	MessageTypeOther MessageType = 4
)

func marshalMessageType(p uintptr) (interface{}, error) {
	return MessageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

type MovementStep int

const (
	// MovementStepLogicalPositions: move forward or back by graphemes
	MovementStepLogicalPositions MovementStep = 0
	// MovementStepVisualPositions: move left or right by graphemes
	MovementStepVisualPositions MovementStep = 1
	// MovementStepWords: move forward or back by words
	MovementStepWords MovementStep = 2
	// MovementStepDisplayLines: move up or down lines (wrapped lines)
	MovementStepDisplayLines MovementStep = 3
	// MovementStepDisplayLineEnds: move to either end of a line
	MovementStepDisplayLineEnds MovementStep = 4
	// MovementStepParagraphs: move up or down paragraphs (newline-ended lines)
	MovementStepParagraphs MovementStep = 5
	// MovementStepParagraphEnds: move to either end of a paragraph
	MovementStepParagraphEnds MovementStep = 6
	// MovementStepPages: move by pages
	MovementStepPages MovementStep = 7
	// MovementStepBufferEnds: move to ends of the buffer
	MovementStepBufferEnds MovementStep = 8
	// MovementStepHorizontalPages: move horizontally by pages
	MovementStepHorizontalPages MovementStep = 9
)

func marshalMovementStep(p uintptr) (interface{}, error) {
	return MovementStep(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

type NotebookTab int

const (
	NotebookTabFirst NotebookTab = 0

	NotebookTabLast NotebookTab = 1
)

func marshalNotebookTab(p uintptr) (interface{}, error) {
	return NotebookTab(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// NumberUpLayout: used to determine the layout of pages on a sheet when
// printing multiple pages per sheet.
type NumberUpLayout int

const (
	// NumberUpLayoutLrtb: ! (layout-lrtb.png)
	NumberUpLayoutLrtb NumberUpLayout = 0
	// NumberUpLayoutLrbt: ! (layout-lrbt.png)
	NumberUpLayoutLrbt NumberUpLayout = 1
	// NumberUpLayoutRltb: ! (layout-rltb.png)
	NumberUpLayoutRltb NumberUpLayout = 2
	// NumberUpLayoutRlbt: ! (layout-rlbt.png)
	NumberUpLayoutRlbt NumberUpLayout = 3
	// NumberUpLayoutTblr: ! (layout-tblr.png)
	NumberUpLayoutTblr NumberUpLayout = 4
	// NumberUpLayoutTbrl: ! (layout-tbrl.png)
	NumberUpLayoutTbrl NumberUpLayout = 5
	// NumberUpLayoutBtlr: ! (layout-btlr.png)
	NumberUpLayoutBtlr NumberUpLayout = 6
	// NumberUpLayoutBtrl: ! (layout-btrl.png)
	NumberUpLayoutBtrl NumberUpLayout = 7
)

func marshalNumberUpLayout(p uintptr) (interface{}, error) {
	return NumberUpLayout(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Orientation represents the orientation of widgets and other objects which can
// be switched between horizontal and vertical orientation on the fly, like
// Toolbar or GesturePan.
type Orientation int

const (
	// OrientationHorizontal: the element is in horizontal orientation.
	OrientationHorizontal Orientation = 0
	// OrientationVertical: the element is in vertical orientation.
	OrientationVertical Orientation = 1
)

func marshalOrientation(p uintptr) (interface{}, error) {
	return Orientation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PackDirection determines how widgets should be packed inside menubars and
// menuitems contained in menubars.
type PackDirection int

const (
	// PackDirectionLTR widgets are packed left-to-right
	PackDirectionLTR PackDirection = 0
	// PackDirectionRTL widgets are packed right-to-left
	PackDirectionRTL PackDirection = 1
	// PackDirectionTtb widgets are packed top-to-bottom
	PackDirectionTtb PackDirection = 2
	// PackDirectionBtt widgets are packed bottom-to-top
	PackDirectionBtt PackDirection = 3
)

func marshalPackDirection(p uintptr) (interface{}, error) {
	return PackDirection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PackType represents the packing location Box children. (See: VBox, HBox, and
// ButtonBox).
type PackType int

const (
	// PackTypeStart: the child is packed into the start of the box
	PackTypeStart PackType = 0
	// PackTypeEnd: the child is packed into the end of the box
	PackTypeEnd PackType = 1
)

func marshalPackType(p uintptr) (interface{}, error) {
	return PackType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PadActionType: the type of a pad action.
type PadActionType int

const (
	// PadActionTypeButton: action is triggered by a pad button
	PadActionTypeButton PadActionType = 0
	// PadActionTypeRing: action is triggered by a pad ring
	PadActionTypeRing PadActionType = 1
	// PadActionTypeStrip: action is triggered by a pad strip
	PadActionTypeStrip PadActionType = 2
)

func marshalPadActionType(p uintptr) (interface{}, error) {
	return PadActionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PageOrientation: see also gtk_print_settings_set_orientation().
type PageOrientation int

const (
	// PageOrientationPortrait: portrait mode.
	PageOrientationPortrait PageOrientation = 0
	// PageOrientationLandscape: landscape mode.
	PageOrientationLandscape PageOrientation = 1
	// PageOrientationReversePortrait: reverse portrait mode.
	PageOrientationReversePortrait PageOrientation = 2
	// PageOrientationReverseLandscape: reverse landscape mode.
	PageOrientationReverseLandscape PageOrientation = 3
)

func marshalPageOrientation(p uintptr) (interface{}, error) {
	return PageOrientation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PageSet: see also gtk_print_job_set_page_set().
type PageSet int

const (
	// PageSetAll: all pages.
	PageSetAll PageSet = 0
	// PageSetEven: even pages.
	PageSetEven PageSet = 1
	// PageSetOdd: odd pages.
	PageSetOdd PageSet = 2
)

func marshalPageSet(p uintptr) (interface{}, error) {
	return PageSet(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PanDirection describes the panning direction of a GesturePan
type PanDirection int

const (
	// PanDirectionLeft: panned towards the left
	PanDirectionLeft PanDirection = 0
	// PanDirectionRight: panned towards the right
	PanDirectionRight PanDirection = 1
	// PanDirectionUp: panned upwards
	PanDirectionUp PanDirection = 2
	// PanDirectionDown: panned downwards
	PanDirectionDown PanDirection = 3
)

func marshalPanDirection(p uintptr) (interface{}, error) {
	return PanDirection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PathPriorityType priorities for path lookups. See also
// gtk_binding_set_add_path().
type PathPriorityType int

const (
	// PathPriorityTypeLowest: deprecated
	PathPriorityTypeLowest PathPriorityType = 0
	// PathPriorityTypeGTK: deprecated
	PathPriorityTypeGTK PathPriorityType = 4
	// PathPriorityTypeApplication: deprecated
	PathPriorityTypeApplication PathPriorityType = 8
	// PathPriorityTypeTheme: deprecated
	PathPriorityTypeTheme PathPriorityType = 10
	// PathPriorityTypeRC: deprecated
	PathPriorityTypeRC PathPriorityType = 12
	// PathPriorityTypeHighest: deprecated
	PathPriorityTypeHighest PathPriorityType = 15
)

func marshalPathPriorityType(p uintptr) (interface{}, error) {
	return PathPriorityType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PathType: widget path types. See also gtk_binding_set_add_path().
type PathType int

const (
	// PathTypeWidget: deprecated
	PathTypeWidget PathType = 0
	// PathTypeWidgetClass: deprecated
	PathTypeWidgetClass PathType = 1
	// PathTypeClass: deprecated
	PathTypeClass PathType = 2
)

func marshalPathType(p uintptr) (interface{}, error) {
	return PathType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PolicyType determines how the size should be computed to achieve the one of
// the visibility mode for the scrollbars.
type PolicyType int

const (
	// PolicyTypeAlways: the scrollbar is always visible. The view size is
	// independent of the content.
	PolicyTypeAlways PolicyType = 0
	// PolicyTypeAutomatic: the scrollbar will appear and disappear as
	// necessary. For example, when all of a TreeView can not be seen.
	PolicyTypeAutomatic PolicyType = 1
	// PolicyTypeNever: the scrollbar should never appear. In this mode the
	// content determines the size.
	PolicyTypeNever PolicyType = 2
	// PolicyTypeExternal: don't show a scrollbar, but don't force the size to
	// follow the content. This can be used e.g. to make multiple scrolled
	// windows share a scrollbar. Since: 3.16
	PolicyTypeExternal PolicyType = 3
)

func marshalPolicyType(p uintptr) (interface{}, error) {
	return PolicyType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PopoverConstraint describes constraints to positioning of popovers. More
// values may be added to this enumeration in the future.
type PopoverConstraint int

const (
	// PopoverConstraintNone: don't constrain the popover position beyond what
	// is imposed by the implementation
	PopoverConstraintNone PopoverConstraint = 0
	// PopoverConstraintWindow: constrain the popover to the boundaries of the
	// window that it is attached to
	PopoverConstraintWindow PopoverConstraint = 1
)

func marshalPopoverConstraint(p uintptr) (interface{}, error) {
	return PopoverConstraint(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PositionType describes which edge of a widget a certain feature is positioned
// at, e.g. the tabs of a Notebook, the handle of a HandleBox or the label of a
// Scale.
type PositionType int

const (
	// PositionTypeLeft: the feature is at the left edge.
	PositionTypeLeft PositionType = 0
	// PositionTypeRight: the feature is at the right edge.
	PositionTypeRight PositionType = 1
	// PositionTypeTop: the feature is at the top edge.
	PositionTypeTop PositionType = 2
	// PositionTypeBottom: the feature is at the bottom edge.
	PositionTypeBottom PositionType = 3
)

func marshalPositionType(p uintptr) (interface{}, error) {
	return PositionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintDuplex: see also gtk_print_settings_set_duplex().
type PrintDuplex int

const (
	// PrintDuplexSimplex: no duplex.
	PrintDuplexSimplex PrintDuplex = 0
	// PrintDuplexHorizontal: horizontal duplex.
	PrintDuplexHorizontal PrintDuplex = 1
	// PrintDuplexVertical: vertical duplex.
	PrintDuplexVertical PrintDuplex = 2
)

func marshalPrintDuplex(p uintptr) (interface{}, error) {
	return PrintDuplex(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintError: error codes that identify various errors that can occur while
// using the GTK+ printing support.
type PrintError int

const (
	// PrintErrorGeneral: an unspecified error occurred.
	PrintErrorGeneral PrintError = 0
	// PrintErrorInternalError: an internal error occurred.
	PrintErrorInternalError PrintError = 1
	// PrintErrorNomem: a memory allocation failed.
	PrintErrorNomem PrintError = 2
	// PrintErrorInvalidFile: an error occurred while loading a page setup or
	// paper size from a key file.
	PrintErrorInvalidFile PrintError = 3
)

func marshalPrintError(p uintptr) (interface{}, error) {
	return PrintError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintOperationAction: the @action parameter to gtk_print_operation_run()
// determines what action the print operation should perform.
type PrintOperationAction int

const (
	// PrintOperationActionPrintDialog: show the print dialog.
	PrintOperationActionPrintDialog PrintOperationAction = 0
	// PrintOperationActionPrint: start to print without showing the print
	// dialog, based on the current print settings.
	PrintOperationActionPrint PrintOperationAction = 1
	// PrintOperationActionPreview: show the print preview.
	PrintOperationActionPreview PrintOperationAction = 2
	// PrintOperationActionExport: export to a file. This requires the
	// export-filename property to be set.
	PrintOperationActionExport PrintOperationAction = 3
)

func marshalPrintOperationAction(p uintptr) (interface{}, error) {
	return PrintOperationAction(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintOperationResult: a value of this type is returned by
// gtk_print_operation_run().
type PrintOperationResult int

const (
	// PrintOperationResultError: an error has occurred.
	PrintOperationResultError PrintOperationResult = 0
	// PrintOperationResultApply: the print settings should be stored.
	PrintOperationResultApply PrintOperationResult = 1
	// PrintOperationResultCancel: the print operation has been canceled, the
	// print settings should not be stored.
	PrintOperationResultCancel PrintOperationResult = 2
	// PrintOperationResultInProgress: the print operation is not complete yet.
	// This value will only be returned when running asynchronously.
	PrintOperationResultInProgress PrintOperationResult = 3
)

func marshalPrintOperationResult(p uintptr) (interface{}, error) {
	return PrintOperationResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintPages: see also gtk_print_job_set_pages()
type PrintPages int

const (
	// PrintPagesAll: all pages.
	PrintPagesAll PrintPages = 0
	// PrintPagesCurrent: current page.
	PrintPagesCurrent PrintPages = 1
	// PrintPagesRanges: range of pages.
	PrintPagesRanges PrintPages = 2
	// PrintPagesSelection: selected pages.
	PrintPagesSelection PrintPages = 3
)

func marshalPrintPages(p uintptr) (interface{}, error) {
	return PrintPages(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintQuality: see also gtk_print_settings_set_quality().
type PrintQuality int

const (
	// PrintQualityLow: low quality.
	PrintQualityLow PrintQuality = 0
	// PrintQualityNormal: normal quality.
	PrintQualityNormal PrintQuality = 1
	// PrintQualityHigh: high quality.
	PrintQualityHigh PrintQuality = 2
	// PrintQualityDraft: draft quality.
	PrintQualityDraft PrintQuality = 3
)

func marshalPrintQuality(p uintptr) (interface{}, error) {
	return PrintQuality(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintStatus: the status gives a rough indication of the completion of a
// running print operation.
type PrintStatus int

const (
	// PrintStatusInitial: the printing has not started yet; this status is set
	// initially, and while the print dialog is shown.
	PrintStatusInitial PrintStatus = 0
	// PrintStatusPreparing: this status is set while the begin-print signal is
	// emitted and during pagination.
	PrintStatusPreparing PrintStatus = 1
	// PrintStatusGeneratingData: this status is set while the pages are being
	// rendered.
	PrintStatusGeneratingData PrintStatus = 2
	// PrintStatusSendingData: the print job is being sent off to the printer.
	PrintStatusSendingData PrintStatus = 3
	// PrintStatusPending: the print job has been sent to the printer, but is
	// not printed for some reason, e.g. the printer may be stopped.
	PrintStatusPending PrintStatus = 4
	// PrintStatusPendingIssue: some problem has occurred during printing, e.g.
	// a paper jam.
	PrintStatusPendingIssue PrintStatus = 5
	// PrintStatusPrinting: the printer is processing the print job.
	PrintStatusPrinting PrintStatus = 6
	// PrintStatusFinished: the printing has been completed successfully.
	PrintStatusFinished PrintStatus = 7
	// PrintStatusFinishedAborted: the printing has been aborted.
	PrintStatusFinishedAborted PrintStatus = 8
)

func marshalPrintStatus(p uintptr) (interface{}, error) {
	return PrintStatus(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PropagationPhase describes the stage at which events are fed into a
// EventController.
type PropagationPhase int

const (
	// PropagationPhaseNone events are not delivered automatically. Those can be
	// manually fed through gtk_event_controller_handle_event(). This should
	// only be used when full control about when, or whether the controller
	// handles the event is needed.
	PropagationPhaseNone PropagationPhase = 0
	// PropagationPhaseCapture events are delivered in the capture phase. The
	// capture phase happens before the bubble phase, runs from the toplevel
	// down to the event widget. This option should only be used on containers
	// that might possibly handle events before their children do.
	PropagationPhaseCapture PropagationPhase = 1
	// PropagationPhaseBubble events are delivered in the bubble phase. The
	// bubble phase happens after the capture phase, and before the default
	// handlers are run. This phase runs from the event widget, up to the
	// toplevel.
	PropagationPhaseBubble PropagationPhase = 2
	// PropagationPhaseTarget events are delivered in the default widget event
	// handlers, note that widget implementations must chain up on button,
	// motion, touch and grab broken handlers for controllers in this phase to
	// be run.
	PropagationPhaseTarget PropagationPhase = 3
)

func marshalPropagationPhase(p uintptr) (interface{}, error) {
	return PropagationPhase(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RCTokenType: the RcTokenType enumeration represents the tokens in the RC
// file. It is exposed so that theme engines can reuse these tokens when parsing
// the theme-engine specific portions of a RC file.
type RCTokenType int

const (
	// RCTokenTypeInvalid: deprecated
	RCTokenTypeInvalid RCTokenType = 270
	// RCTokenTypeInclude: deprecated
	RCTokenTypeInclude RCTokenType = 271
	// RCTokenTypeNormal: deprecated
	RCTokenTypeNormal RCTokenType = 272
	// RCTokenTypeActive: deprecated
	RCTokenTypeActive RCTokenType = 273
	// RCTokenTypePrelight: deprecated
	RCTokenTypePrelight RCTokenType = 274
	// RCTokenTypeSelected: deprecated
	RCTokenTypeSelected RCTokenType = 275
	// RCTokenTypeInsensitive: deprecated
	RCTokenTypeInsensitive RCTokenType = 276
	// RCTokenTypeFg: deprecated
	RCTokenTypeFg RCTokenType = 277
	// RCTokenTypeBg: deprecated
	RCTokenTypeBg RCTokenType = 278
	// RCTokenTypeText: deprecated
	RCTokenTypeText RCTokenType = 279
	// RCTokenTypeBase: deprecated
	RCTokenTypeBase RCTokenType = 280
	// RCTokenTypeXthickness: deprecated
	RCTokenTypeXthickness RCTokenType = 281
	// RCTokenTypeYthickness: deprecated
	RCTokenTypeYthickness RCTokenType = 282
	// RCTokenTypeFont: deprecated
	RCTokenTypeFont RCTokenType = 283
	// RCTokenTypeFontset: deprecated
	RCTokenTypeFontset RCTokenType = 284
	// RCTokenTypeFontName: deprecated
	RCTokenTypeFontName RCTokenType = 285
	// RCTokenTypeBgPixmap: deprecated
	RCTokenTypeBgPixmap RCTokenType = 286
	// RCTokenTypePixmapPath: deprecated
	RCTokenTypePixmapPath RCTokenType = 287
	// RCTokenTypeStyle: deprecated
	RCTokenTypeStyle RCTokenType = 288
	// RCTokenTypeBinding: deprecated
	RCTokenTypeBinding RCTokenType = 289
	// RCTokenTypeBind: deprecated
	RCTokenTypeBind RCTokenType = 290
	// RCTokenTypeWidget: deprecated
	RCTokenTypeWidget RCTokenType = 291
	// RCTokenTypeWidgetClass: deprecated
	RCTokenTypeWidgetClass RCTokenType = 292
	// RCTokenTypeClass: deprecated
	RCTokenTypeClass RCTokenType = 293
	// RCTokenTypeLowest: deprecated
	RCTokenTypeLowest RCTokenType = 294
	// RCTokenTypeGTK: deprecated
	RCTokenTypeGTK RCTokenType = 295
	// RCTokenTypeApplication: deprecated
	RCTokenTypeApplication RCTokenType = 296
	// RCTokenTypeTheme: deprecated
	RCTokenTypeTheme RCTokenType = 297
	// RCTokenTypeRC: deprecated
	RCTokenTypeRC RCTokenType = 298
	// RCTokenTypeHighest: deprecated
	RCTokenTypeHighest RCTokenType = 299
	// RCTokenTypeEngine: deprecated
	RCTokenTypeEngine RCTokenType = 300
	// RCTokenTypeModulePath: deprecated
	RCTokenTypeModulePath RCTokenType = 301
	// RCTokenTypeImModulePath: deprecated
	RCTokenTypeImModulePath RCTokenType = 302
	// RCTokenTypeImModuleFile: deprecated
	RCTokenTypeImModuleFile RCTokenType = 303
	// RCTokenTypeStock: deprecated
	RCTokenTypeStock RCTokenType = 304
	// RCTokenTypeLTR: deprecated
	RCTokenTypeLTR RCTokenType = 305
	// RCTokenTypeRTL: deprecated
	RCTokenTypeRTL RCTokenType = 306
	// RCTokenTypeColor: deprecated
	RCTokenTypeColor RCTokenType = 307
	// RCTokenTypeUnbind: deprecated
	RCTokenTypeUnbind RCTokenType = 308
	// RCTokenTypeLast: deprecated
	RCTokenTypeLast RCTokenType = 309
)

func marshalRCTokenType(p uintptr) (interface{}, error) {
	return RCTokenType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RecentChooserError: these identify the various errors that can occur while
// calling RecentChooser functions.
type RecentChooserError int

const (
	// RecentChooserErrorNotFound indicates that a file does not exist
	RecentChooserErrorNotFound RecentChooserError = 0
	// RecentChooserErrorInvalidURI indicates a malformed URI
	RecentChooserErrorInvalidURI RecentChooserError = 1
)

func marshalRecentChooserError(p uintptr) (interface{}, error) {
	return RecentChooserError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RecentManagerError: error codes for RecentManager operations
type RecentManagerError int

const (
	// RecentManagerErrorNotFound: the URI specified does not exists in the
	// recently used resources list.
	RecentManagerErrorNotFound RecentManagerError = 0
	// RecentManagerErrorInvalidURI: the URI specified is not valid.
	RecentManagerErrorInvalidURI RecentManagerError = 1
	// RecentManagerErrorInvalidEncoding: the supplied string is not UTF-8
	// encoded.
	RecentManagerErrorInvalidEncoding RecentManagerError = 2
	// RecentManagerErrorNotRegistered: no application has registered the
	// specified item.
	RecentManagerErrorNotRegistered RecentManagerError = 3
	// RecentManagerErrorRead: failure while reading the recently used resources
	// file.
	RecentManagerErrorRead RecentManagerError = 4
	// RecentManagerErrorWrite: failure while writing the recently used
	// resources file.
	RecentManagerErrorWrite RecentManagerError = 5
	// RecentManagerErrorUnknown: unspecified error.
	RecentManagerErrorUnknown RecentManagerError = 6
)

func marshalRecentManagerError(p uintptr) (interface{}, error) {
	return RecentManagerError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RecentSortType: used to specify the sorting method to be applyed to the
// recently used resource list.
type RecentSortType int

const (
	// RecentSortTypeNone: do not sort the returned list of recently used
	// resources.
	RecentSortTypeNone RecentSortType = 0
	// RecentSortTypeMru: sort the returned list with the most recently used
	// items first.
	RecentSortTypeMru RecentSortType = 1
	// RecentSortTypeLru: sort the returned list with the least recently used
	// items first.
	RecentSortTypeLru RecentSortType = 2
	// RecentSortTypeCustom: sort the returned list using a custom sorting
	// function passed using gtk_recent_chooser_set_sort_func().
	RecentSortTypeCustom RecentSortType = 3
)

func marshalRecentSortType(p uintptr) (interface{}, error) {
	return RecentSortType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ReliefStyle: indicated the relief to be drawn around a Button.
type ReliefStyle int

const (
	// ReliefStyleNormal: draw a normal relief.
	ReliefStyleNormal ReliefStyle = 0
	// ReliefStyleHalf: a half relief. Deprecated in 3.14, does the same as
	// @GTK_RELIEF_NORMAL
	ReliefStyleHalf ReliefStyle = 1
	// ReliefStyleNone: no relief.
	ReliefStyleNone ReliefStyle = 2
)

func marshalReliefStyle(p uintptr) (interface{}, error) {
	return ReliefStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

type ResizeMode int

const (
	// ResizeModeParent pass resize request to the parent
	ResizeModeParent ResizeMode = 0
	// ResizeModeQueue: queue resizes on this widget
	ResizeModeQueue ResizeMode = 1
	// ResizeModeImmediate: resize immediately. Deprecated.
	ResizeModeImmediate ResizeMode = 2
)

func marshalResizeMode(p uintptr) (interface{}, error) {
	return ResizeMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResponseType: predefined values for use as response ids in
// gtk_dialog_add_button(). All predefined values are negative; GTK+ leaves
// values of 0 or greater for application-defined response ids.
type ResponseType int

const (
	// ResponseTypeNone: returned if an action widget has no response id, or if
	// the dialog gets programmatically hidden or destroyed
	ResponseTypeNone ResponseType = -1
	// ResponseTypeReject: generic response id, not used by GTK+ dialogs
	ResponseTypeReject ResponseType = -2
	// ResponseTypeAccept: generic response id, not used by GTK+ dialogs
	ResponseTypeAccept ResponseType = -3
	// ResponseTypeDeleteEvent: returned if the dialog is deleted
	ResponseTypeDeleteEvent ResponseType = -4
	// ResponseTypeOk: returned by OK buttons in GTK+ dialogs
	ResponseTypeOk ResponseType = -5
	// ResponseTypeCancel: returned by Cancel buttons in GTK+ dialogs
	ResponseTypeCancel ResponseType = -6
	// ResponseTypeClose: returned by Close buttons in GTK+ dialogs
	ResponseTypeClose ResponseType = -7
	// ResponseTypeYes: returned by Yes buttons in GTK+ dialogs
	ResponseTypeYes ResponseType = -8
	// ResponseTypeNo: returned by No buttons in GTK+ dialogs
	ResponseTypeNo ResponseType = -9
	// ResponseTypeApply: returned by Apply buttons in GTK+ dialogs
	ResponseTypeApply ResponseType = -10
	// ResponseTypeHelp: returned by Help buttons in GTK+ dialogs
	ResponseTypeHelp ResponseType = -11
)

func marshalResponseType(p uintptr) (interface{}, error) {
	return ResponseType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RevealerTransitionType: these enumeration values describe the possible
// transitions when the child of a Revealer widget is shown or hidden.
type RevealerTransitionType int

const (
	// RevealerTransitionTypeNone: no transition
	RevealerTransitionTypeNone RevealerTransitionType = 0
	// RevealerTransitionTypeCrossfade: fade in
	RevealerTransitionTypeCrossfade RevealerTransitionType = 1
	// RevealerTransitionTypeSlideRight: slide in from the left
	RevealerTransitionTypeSlideRight RevealerTransitionType = 2
	// RevealerTransitionTypeSlideLeft: slide in from the right
	RevealerTransitionTypeSlideLeft RevealerTransitionType = 3
	// RevealerTransitionTypeSlideUp: slide in from the bottom
	RevealerTransitionTypeSlideUp RevealerTransitionType = 4
	// RevealerTransitionTypeSlideDown: slide in from the top
	RevealerTransitionTypeSlideDown RevealerTransitionType = 5
)

func marshalRevealerTransitionType(p uintptr) (interface{}, error) {
	return RevealerTransitionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

type ScrollStep int

const (
	// ScrollStepSteps: scroll in steps.
	ScrollStepSteps ScrollStep = 0
	// ScrollStepPages: scroll by pages.
	ScrollStepPages ScrollStep = 1
	// ScrollStepEnds: scroll to ends.
	ScrollStepEnds ScrollStep = 2
	// ScrollStepHorizontalSteps: scroll in horizontal steps.
	ScrollStepHorizontalSteps ScrollStep = 3
	// ScrollStepHorizontalPages: scroll by horizontal pages.
	ScrollStepHorizontalPages ScrollStep = 4
	// ScrollStepHorizontalEnds: scroll to the horizontal ends.
	ScrollStepHorizontalEnds ScrollStep = 5
)

func marshalScrollStep(p uintptr) (interface{}, error) {
	return ScrollStep(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ScrollType: scrolling types.
type ScrollType int

const (
	// ScrollTypeNone: no scrolling.
	ScrollTypeNone ScrollType = 0
	// ScrollTypeJump: jump to new location.
	ScrollTypeJump ScrollType = 1
	// ScrollTypeStepBackward: step backward.
	ScrollTypeStepBackward ScrollType = 2
	// ScrollTypeStepForward: step forward.
	ScrollTypeStepForward ScrollType = 3
	// ScrollTypePageBackward: page backward.
	ScrollTypePageBackward ScrollType = 4
	// ScrollTypePageForward: page forward.
	ScrollTypePageForward ScrollType = 5
	// ScrollTypeStepUp: step up.
	ScrollTypeStepUp ScrollType = 6
	// ScrollTypeStepDown: step down.
	ScrollTypeStepDown ScrollType = 7
	// ScrollTypePageUp: page up.
	ScrollTypePageUp ScrollType = 8
	// ScrollTypePageDown: page down.
	ScrollTypePageDown ScrollType = 9
	// ScrollTypeStepLeft: step to the left.
	ScrollTypeStepLeft ScrollType = 10
	// ScrollTypeStepRight: step to the right.
	ScrollTypeStepRight ScrollType = 11
	// ScrollTypePageLeft: page to the left.
	ScrollTypePageLeft ScrollType = 12
	// ScrollTypePageRight: page to the right.
	ScrollTypePageRight ScrollType = 13
	// ScrollTypeStart: scroll to start.
	ScrollTypeStart ScrollType = 14
	// ScrollTypeEnd: scroll to end.
	ScrollTypeEnd ScrollType = 15
)

func marshalScrollType(p uintptr) (interface{}, error) {
	return ScrollType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ScrollablePolicy defines the policy to be used in a scrollable widget when
// updating the scrolled window adjustments in a given orientation.
type ScrollablePolicy int

const (
	// ScrollablePolicyMinimum: scrollable adjustments are based on the minimum
	// size
	ScrollablePolicyMinimum ScrollablePolicy = 0
	// ScrollablePolicyNatural: scrollable adjustments are based on the natural
	// size
	ScrollablePolicyNatural ScrollablePolicy = 1
)

func marshalScrollablePolicy(p uintptr) (interface{}, error) {
	return ScrollablePolicy(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SelectionMode: used to control what selections users are allowed to make.
type SelectionMode int

const (
	// SelectionModeNone: no selection is possible.
	SelectionModeNone SelectionMode = 0
	// SelectionModeSingle: zero or one element may be selected.
	SelectionModeSingle SelectionMode = 1
	// SelectionModeBrowse: exactly one element is selected. In some
	// circumstances, such as initially or during a search operation, it’s
	// possible for no element to be selected with GTK_SELECTION_BROWSE. What is
	// really enforced is that the user can’t deselect a currently selected
	// element except by selecting another element.
	SelectionModeBrowse SelectionMode = 2
	// SelectionModeMultiple: any number of elements may be selected. The Ctrl
	// key may be used to enlarge the selection, and Shift key to select between
	// the focus and the child pointed to. Some widgets may also allow
	// Click-drag to select a range of elements.
	SelectionModeMultiple SelectionMode = 3
)

func marshalSelectionMode(p uintptr) (interface{}, error) {
	return SelectionMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SensitivityType determines how GTK+ handles the sensitivity of stepper arrows
// at the end of range widgets.
type SensitivityType int

const (
	// SensitivityTypeAuto: the arrow is made insensitive if the thumb is at the
	// end
	SensitivityTypeAuto SensitivityType = 0
	// SensitivityTypeOn: the arrow is always sensitive
	SensitivityTypeOn SensitivityType = 1
	// SensitivityTypeOff: the arrow is always insensitive
	SensitivityTypeOff SensitivityType = 2
)

func marshalSensitivityType(p uintptr) (interface{}, error) {
	return SensitivityType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ShadowType: used to change the appearance of an outline typically provided by
// a Frame.
//
// Note that many themes do not differentiate the appearance of the various
// shadow types: Either their is no visible shadow (@GTK_SHADOW_NONE), or there
// is (any other value).
type ShadowType int

const (
	// ShadowTypeNone: no outline.
	ShadowTypeNone ShadowType = 0
	// ShadowTypeIn: the outline is bevelled inwards.
	ShadowTypeIn ShadowType = 1
	// ShadowTypeOut: the outline is bevelled outwards like a button.
	ShadowTypeOut ShadowType = 2
	// ShadowTypeEtchedIn: the outline has a sunken 3d appearance.
	ShadowTypeEtchedIn ShadowType = 3
	// ShadowTypeEtchedOut: the outline has a raised 3d appearance.
	ShadowTypeEtchedOut ShadowType = 4
)

func marshalShadowType(p uintptr) (interface{}, error) {
	return ShadowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ShortcutType: gtkShortcutType specifies the kind of shortcut that is being
// described. More values may be added to this enumeration over time.
type ShortcutType int

const (
	// ShortcutTypeAccelerator: the shortcut is a keyboard accelerator. The
	// ShortcutsShortcut:accelerator property will be used.
	ShortcutTypeAccelerator ShortcutType = 0
	// ShortcutTypeGesturePinch: the shortcut is a pinch gesture. GTK+ provides
	// an icon and subtitle.
	ShortcutTypeGesturePinch ShortcutType = 1
	// ShortcutTypeGestureStretch: the shortcut is a stretch gesture. GTK+
	// provides an icon and subtitle.
	ShortcutTypeGestureStretch ShortcutType = 2
	// ShortcutTypeGestureRotateClockwise: the shortcut is a clockwise rotation
	// gesture. GTK+ provides an icon and subtitle.
	ShortcutTypeGestureRotateClockwise ShortcutType = 3
	// ShortcutTypeGestureRotateCounterclockwise: the shortcut is a
	// counterclockwise rotation gesture. GTK+ provides an icon and subtitle.
	ShortcutTypeGestureRotateCounterclockwise ShortcutType = 4
	// ShortcutTypeGestureTwoFingerSwipeLeft: the shortcut is a two-finger swipe
	// gesture. GTK+ provides an icon and subtitle.
	ShortcutTypeGestureTwoFingerSwipeLeft ShortcutType = 5
	// ShortcutTypeGestureTwoFingerSwipeRight: the shortcut is a two-finger
	// swipe gesture. GTK+ provides an icon and subtitle.
	ShortcutTypeGestureTwoFingerSwipeRight ShortcutType = 6
	// ShortcutTypeGesture: the shortcut is a gesture. The
	// ShortcutsShortcut:icon property will be used.
	ShortcutTypeGesture ShortcutType = 7
)

func marshalShortcutType(p uintptr) (interface{}, error) {
	return ShortcutType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SizeGroupMode: the mode of the size group determines the directions in which
// the size group affects the requested sizes of its component widgets.
type SizeGroupMode int

const (
	// SizeGroupModeNone: group has no effect
	SizeGroupModeNone SizeGroupMode = 0
	// SizeGroupModeHorizontal: group affects horizontal requisition
	SizeGroupModeHorizontal SizeGroupMode = 1
	// SizeGroupModeVertical: group affects vertical requisition
	SizeGroupModeVertical SizeGroupMode = 2
	// SizeGroupModeBoth: group affects both horizontal and vertical requisition
	SizeGroupModeBoth SizeGroupMode = 3
)

func marshalSizeGroupMode(p uintptr) (interface{}, error) {
	return SizeGroupMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SizeRequestMode specifies a preference for height-for-width or
// width-for-height geometry management.
type SizeRequestMode int

const (
	// SizeRequestModeHeightForWidth: prefer height-for-width geometry
	// management
	SizeRequestModeHeightForWidth SizeRequestMode = 0
	// SizeRequestModeWidthForHeight: prefer width-for-height geometry
	// management
	SizeRequestModeWidthForHeight SizeRequestMode = 1
	// SizeRequestModeConstantSize: don’t trade height-for-width or
	// width-for-height
	SizeRequestModeConstantSize SizeRequestMode = 2
)

func marshalSizeRequestMode(p uintptr) (interface{}, error) {
	return SizeRequestMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SortType determines the direction of a sort.
type SortType int

const (
	// SortTypeAscending: sorting is in ascending order.
	SortTypeAscending SortType = 0
	// SortTypeDescending: sorting is in descending order.
	SortTypeDescending SortType = 1
)

func marshalSortType(p uintptr) (interface{}, error) {
	return SortType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SpinButtonUpdatePolicy: the spin button update policy determines whether the
// spin button displays values even if they are outside the bounds of its
// adjustment. See gtk_spin_button_set_update_policy().
type SpinButtonUpdatePolicy int

const (
	// SpinButtonUpdatePolicyAlways: when refreshing your SpinButton, the value
	// is always displayed
	SpinButtonUpdatePolicyAlways SpinButtonUpdatePolicy = 0
	// SpinButtonUpdatePolicyIfValid: when refreshing your SpinButton, the value
	// is only displayed if it is valid within the bounds of the spin button's
	// adjustment
	SpinButtonUpdatePolicyIfValid SpinButtonUpdatePolicy = 1
)

func marshalSpinButtonUpdatePolicy(p uintptr) (interface{}, error) {
	return SpinButtonUpdatePolicy(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SpinType: the values of the GtkSpinType enumeration are used to specify the
// change to make in gtk_spin_button_spin().
type SpinType int

const (
	// SpinTypeStepForward: increment by the adjustments step increment.
	SpinTypeStepForward SpinType = 0
	// SpinTypeStepBackward: decrement by the adjustments step increment.
	SpinTypeStepBackward SpinType = 1
	// SpinTypePageForward: increment by the adjustments page increment.
	SpinTypePageForward SpinType = 2
	// SpinTypePageBackward: decrement by the adjustments page increment.
	SpinTypePageBackward SpinType = 3
	// SpinTypeHome: go to the adjustments lower bound.
	SpinTypeHome SpinType = 4
	// SpinTypeEnd: go to the adjustments upper bound.
	SpinTypeEnd SpinType = 5
	// SpinTypeUserDefined: change by a specified amount.
	SpinTypeUserDefined SpinType = 6
)

func marshalSpinType(p uintptr) (interface{}, error) {
	return SpinType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// StackTransitionType: these enumeration values describe the possible
// transitions between pages in a Stack widget.
//
// New values may be added to this enumeration over time.
type StackTransitionType int

const (
	// StackTransitionTypeNone: no transition
	StackTransitionTypeNone StackTransitionType = 0
	// StackTransitionTypeCrossfade: a cross-fade
	StackTransitionTypeCrossfade StackTransitionType = 1
	// StackTransitionTypeSlideRight: slide from left to right
	StackTransitionTypeSlideRight StackTransitionType = 2
	// StackTransitionTypeSlideLeft: slide from right to left
	StackTransitionTypeSlideLeft StackTransitionType = 3
	// StackTransitionTypeSlideUp: slide from bottom up
	StackTransitionTypeSlideUp StackTransitionType = 4
	// StackTransitionTypeSlideDown: slide from top down
	StackTransitionTypeSlideDown StackTransitionType = 5
	// StackTransitionTypeSlideLeftRight: slide from left or right according to
	// the children order
	StackTransitionTypeSlideLeftRight StackTransitionType = 6
	// StackTransitionTypeSlideUpDown: slide from top down or bottom up
	// according to the order
	StackTransitionTypeSlideUpDown StackTransitionType = 7
	// StackTransitionTypeOverUp: cover the old page by sliding up. Since 3.12
	StackTransitionTypeOverUp StackTransitionType = 8
	// StackTransitionTypeOverDown: cover the old page by sliding down. Since:
	// 3.12
	StackTransitionTypeOverDown StackTransitionType = 9
	// StackTransitionTypeOverLeft: cover the old page by sliding to the left.
	// Since: 3.12
	StackTransitionTypeOverLeft StackTransitionType = 10
	// StackTransitionTypeOverRight: cover the old page by sliding to the right.
	// Since: 3.12
	StackTransitionTypeOverRight StackTransitionType = 11
	// StackTransitionTypeUnderUp: uncover the new page by sliding up. Since
	// 3.12
	StackTransitionTypeUnderUp StackTransitionType = 12
	// StackTransitionTypeUnderDown: uncover the new page by sliding down.
	// Since: 3.12
	StackTransitionTypeUnderDown StackTransitionType = 13
	// StackTransitionTypeUnderLeft: uncover the new page by sliding to the
	// left. Since: 3.12
	StackTransitionTypeUnderLeft StackTransitionType = 14
	// StackTransitionTypeUnderRight: uncover the new page by sliding to the
	// right. Since: 3.12
	StackTransitionTypeUnderRight StackTransitionType = 15
	// StackTransitionTypeOverUpDown: cover the old page sliding up or uncover
	// the new page sliding down, according to order. Since: 3.12
	StackTransitionTypeOverUpDown StackTransitionType = 16
	// StackTransitionTypeOverDownUp: cover the old page sliding down or uncover
	// the new page sliding up, according to order. Since: 3.14
	StackTransitionTypeOverDownUp StackTransitionType = 17
	// StackTransitionTypeOverLeftRight: cover the old page sliding left or
	// uncover the new page sliding right, according to order. Since: 3.14
	StackTransitionTypeOverLeftRight StackTransitionType = 18
	// StackTransitionTypeOverRightLeft: cover the old page sliding right or
	// uncover the new page sliding left, according to order. Since: 3.14
	StackTransitionTypeOverRightLeft StackTransitionType = 19
)

func marshalStackTransitionType(p uintptr) (interface{}, error) {
	return StackTransitionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// StateType: this type indicates the current state of a widget; the state
// determines how the widget is drawn. The StateType enumeration is also used to
// identify different colors in a Style for drawing, so states can be used for
// subparts of a widget as well as entire widgets.
type StateType int

const (
	// StateTypeNormal: state during normal operation.
	StateTypeNormal StateType = 0
	// StateTypeActive: state of a currently active widget, such as a depressed
	// button.
	StateTypeActive StateType = 1
	// StateTypePrelight: state indicating that the mouse pointer is over the
	// widget and the widget will respond to mouse clicks.
	StateTypePrelight StateType = 2
	// StateTypeSelected: state of a selected item, such the selected row in a
	// list.
	StateTypeSelected StateType = 3
	// StateTypeInsensitive: state indicating that the widget is unresponsive to
	// user actions.
	StateTypeInsensitive StateType = 4
	// StateTypeInconsistent: the widget is inconsistent, such as checkbuttons
	// or radiobuttons that aren’t either set to true nor false, or buttons
	// requiring the user attention.
	StateTypeInconsistent StateType = 5
	// StateTypeFocused: the widget has the keyboard focus.
	StateTypeFocused StateType = 6
)

func marshalStateType(p uintptr) (interface{}, error) {
	return StateType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextBufferTargetInfo: these values are used as “info” for the targets
// contained in the lists returned by gtk_text_buffer_get_copy_target_list() and
// gtk_text_buffer_get_paste_target_list().
//
// The values counts down from `-1` to avoid clashes with application added drag
// destinations which usually start at 0.
type TextBufferTargetInfo int

const (
	// TextBufferTargetInfoBufferContents: buffer contents
	TextBufferTargetInfoBufferContents TextBufferTargetInfo = -1
	// TextBufferTargetInfoRichText: rich text
	TextBufferTargetInfoRichText TextBufferTargetInfo = -2
	// TextBufferTargetInfoText: text
	TextBufferTargetInfoText TextBufferTargetInfo = -3
)

func marshalTextBufferTargetInfo(p uintptr) (interface{}, error) {
	return TextBufferTargetInfo(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextDirection: reading directions for text.
type TextDirection int

const (
	// TextDirectionNone: no direction.
	TextDirectionNone TextDirection = 0
	// TextDirectionLTR: left to right text direction.
	TextDirectionLTR TextDirection = 1
	// TextDirectionRTL: right to left text direction.
	TextDirectionRTL TextDirection = 2
)

func marshalTextDirection(p uintptr) (interface{}, error) {
	return TextDirection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextExtendSelection: granularity types that extend the text selection. Use
// the TextView::extend-selection signal to customize the selection.
type TextExtendSelection int

const (
	// TextExtendSelectionWord selects the current word. It is triggered by a
	// double-click for example.
	TextExtendSelectionWord TextExtendSelection = 0
	// TextExtendSelectionLine selects the current line. It is triggered by a
	// triple-click for example.
	TextExtendSelectionLine TextExtendSelection = 1
)

func marshalTextExtendSelection(p uintptr) (interface{}, error) {
	return TextExtendSelection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextViewLayer: used to reference the layers of TextView for the purpose of
// customized drawing with the ::draw_layer vfunc.
type TextViewLayer int

const (
	// TextViewLayerBelow: old deprecated layer, use
	// GTK_TEXT_VIEW_LAYER_BELOW_TEXT instead
	TextViewLayerBelow TextViewLayer = 0
	// TextViewLayerAbove: old deprecated layer, use
	// GTK_TEXT_VIEW_LAYER_ABOVE_TEXT instead
	TextViewLayerAbove TextViewLayer = 1
	// TextViewLayerBelowText: the layer rendered below the text (but above the
	// background). Since: 3.20
	TextViewLayerBelowText TextViewLayer = 2
	// TextViewLayerAboveText: the layer rendered above the text. Since: 3.20
	TextViewLayerAboveText TextViewLayer = 3
)

func marshalTextViewLayer(p uintptr) (interface{}, error) {
	return TextViewLayer(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextWindowType: used to reference the parts of TextView.
type TextWindowType int

const (
	// TextWindowTypePrivate: invalid value, used as a marker
	TextWindowTypePrivate TextWindowType = 0
	// TextWindowTypeWidget: window that floats over scrolling areas.
	TextWindowTypeWidget TextWindowType = 1
	// TextWindowTypeText: scrollable text window.
	TextWindowTypeText TextWindowType = 2
	// TextWindowTypeLeft: left side border window.
	TextWindowTypeLeft TextWindowType = 3
	// TextWindowTypeRight: right side border window.
	TextWindowTypeRight TextWindowType = 4
	// TextWindowTypeTop: top border window.
	TextWindowTypeTop TextWindowType = 5
	// TextWindowTypeBottom: bottom border window.
	TextWindowTypeBottom TextWindowType = 6
)

func marshalTextWindowType(p uintptr) (interface{}, error) {
	return TextWindowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ToolbarSpaceStyle: whether spacers are vertical lines or just blank.
type ToolbarSpaceStyle int

const (
	// ToolbarSpaceStyleEmpty: use blank spacers.
	ToolbarSpaceStyleEmpty ToolbarSpaceStyle = 0
	// ToolbarSpaceStyleLine: use vertical lines for spacers.
	ToolbarSpaceStyleLine ToolbarSpaceStyle = 1
)

func marshalToolbarSpaceStyle(p uintptr) (interface{}, error) {
	return ToolbarSpaceStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ToolbarStyle: used to customize the appearance of a Toolbar. Note that
// setting the toolbar style overrides the user’s preferences for the default
// toolbar style. Note that if the button has only a label set and
// GTK_TOOLBAR_ICONS is used, the label will be visible, and vice versa.
type ToolbarStyle int

const (
	// ToolbarStyleIcons buttons display only icons in the toolbar.
	ToolbarStyleIcons ToolbarStyle = 0
	// ToolbarStyleText buttons display only text labels in the toolbar.
	ToolbarStyleText ToolbarStyle = 1
	// ToolbarStyleBoth buttons display text and icons in the toolbar.
	ToolbarStyleBoth ToolbarStyle = 2
	// ToolbarStyleBothHoriz buttons display icons and text alongside each
	// other, rather than vertically stacked
	ToolbarStyleBothHoriz ToolbarStyle = 3
)

func marshalToolbarStyle(p uintptr) (interface{}, error) {
	return ToolbarStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TreeViewColumnSizing: the sizing method the column uses to determine its
// width. Please note that @GTK_TREE_VIEW_COLUMN_AUTOSIZE are inefficient for
// large views, and can make columns appear choppy.
type TreeViewColumnSizing int

const (
	// TreeViewColumnSizingGrowOnly columns only get bigger in reaction to
	// changes in the model
	TreeViewColumnSizingGrowOnly TreeViewColumnSizing = 0
	// TreeViewColumnSizingAutosize columns resize to be the optimal size
	// everytime the model changes.
	TreeViewColumnSizingAutosize TreeViewColumnSizing = 1
	// TreeViewColumnSizingFixed columns are a fixed numbers of pixels wide.
	TreeViewColumnSizingFixed TreeViewColumnSizing = 2
)

func marshalTreeViewColumnSizing(p uintptr) (interface{}, error) {
	return TreeViewColumnSizing(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TreeViewDropPosition: an enum for determining where a dropped row goes.
type TreeViewDropPosition int

const (
	// TreeViewDropPositionBefore: dropped row is inserted before
	TreeViewDropPositionBefore TreeViewDropPosition = 0
	// TreeViewDropPositionAfter: dropped row is inserted after
	TreeViewDropPositionAfter TreeViewDropPosition = 1
	// TreeViewDropPositionIntoOrBefore: dropped row becomes a child or is
	// inserted before
	TreeViewDropPositionIntoOrBefore TreeViewDropPosition = 2
	// TreeViewDropPositionIntoOrAfter: dropped row becomes a child or is
	// inserted after
	TreeViewDropPositionIntoOrAfter TreeViewDropPosition = 3
)

func marshalTreeViewDropPosition(p uintptr) (interface{}, error) {
	return TreeViewDropPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TreeViewGridLines: used to indicate which grid lines to draw in a tree view.
type TreeViewGridLines int

const (
	// TreeViewGridLinesNone: no grid lines.
	TreeViewGridLinesNone TreeViewGridLines = 0
	// TreeViewGridLinesHorizontal: horizontal grid lines.
	TreeViewGridLinesHorizontal TreeViewGridLines = 1
	// TreeViewGridLinesVertical: vertical grid lines.
	TreeViewGridLinesVertical TreeViewGridLines = 2
	// TreeViewGridLinesBoth: horizontal and vertical grid lines.
	TreeViewGridLinesBoth TreeViewGridLines = 3
)

func marshalTreeViewGridLines(p uintptr) (interface{}, error) {
	return TreeViewGridLines(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Unit: see also gtk_print_settings_set_paper_width().
type Unit int

const (
	// UnitNone: no units.
	UnitNone Unit = 0
	// UnitPoints dimensions in points.
	UnitPoints Unit = 1
	// UnitInch dimensions in inches.
	UnitInch Unit = 2
	// UnitMm dimensions in millimeters
	UnitMm Unit = 3
)

func marshalUnit(p uintptr) (interface{}, error) {
	return Unit(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// WidgetHelpType kinds of widget-specific help. Used by the ::show-help signal.
type WidgetHelpType int

const (
	// WidgetHelpTypeTooltip: tooltip.
	WidgetHelpTypeTooltip WidgetHelpType = 0
	// WidgetHelpTypeWhatsThis what’s this.
	WidgetHelpTypeWhatsThis WidgetHelpType = 1
)

func marshalWidgetHelpType(p uintptr) (interface{}, error) {
	return WidgetHelpType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// WindowPosition: window placement can be influenced using this enumeration.
// Note that using K_WIN_POS_CENTER_ALWAYS is almost always a bad idea. It won’t
// necessarily work well with all window managers or on all windowing systems.
type WindowPosition int

const (
	// WindowPositionNone: no influence is made on placement.
	WindowPositionNone WindowPosition = 0
	// WindowPositionCenter windows should be placed in the center of the
	// screen.
	WindowPositionCenter WindowPosition = 1
	// WindowPositionMouse windows should be placed at the current mouse
	// position.
	WindowPositionMouse WindowPosition = 2
	// WindowPositionCenterAlways: keep window centered as it changes size, etc.
	WindowPositionCenterAlways WindowPosition = 3
	// WindowPositionCenterOnParent: center the window on its transient parent
	// (see gtk_window_set_transient_for()).
	WindowPositionCenterOnParent WindowPosition = 4
)

func marshalWindowPosition(p uintptr) (interface{}, error) {
	return WindowPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// WindowType: a Window can be one of these types. Most things you’d consider a
// “window” should have type K_WINDOW_TOPLEVEL; windows with this type are
// managed by the window manager and have a frame by default (call
// gtk_window_set_decorated() to toggle the frame). Windows with type
// K_WINDOW_POPUP are ignored by the window manager; window manager keybindings
// won’t work on them, the window manager won’t decorate the window with a
// frame, many GTK+ features that rely on the window manager will not work (e.g.
// resize grips and maximization/minimization). K_WINDOW_POPUP is used to
// implement widgets such as Menu or tooltips that you normally don’t think of
// as windows per se. Nearly all windows should be K_WINDOW_TOPLEVEL. In
// particular, do not use K_WINDOW_POPUP just to turn off the window borders;
// use gtk_window_set_decorated() for that.
type WindowType int

const (
	// WindowTypeToplevel: a regular window, such as a dialog.
	WindowTypeToplevel WindowType = 0
	// WindowTypePopup: a special window such as a tooltip.
	WindowTypePopup WindowType = 1
)

func marshalWindowType(p uintptr) (interface{}, error) {
	return WindowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// WrapMode describes a type of line wrapping.
type WrapMode int

const (
	// WrapModeNone: do not wrap lines; just make the text area wider
	WrapModeNone WrapMode = 0
	// WrapModeChar: wrap text, breaking lines anywhere the cursor can appear
	// (between characters, usually - if you want to be technical, between
	// graphemes, see pango_get_log_attrs())
	WrapModeChar WrapMode = 1
	// WrapModeWord: wrap text, breaking lines in between words
	WrapModeWord WrapMode = 2
	// WrapModeWordChar: wrap text, breaking lines in between words, or if that
	// is not enough, also between graphemes
	WrapModeWordChar WrapMode = 3
)

func marshalWrapMode(p uintptr) (interface{}, error) {
	return WrapMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccelFlags: accelerator flags used with gtk_accel_group_connect().
type AccelFlags int

const (
	// AccelFlagsVisible: accelerator is visible
	AccelFlagsVisible AccelFlags = 0b1
	// AccelFlagsLocked: accelerator not removable
	AccelFlagsLocked AccelFlags = 0b10
	// AccelFlagsMask: mask
	AccelFlagsMask AccelFlags = 0b111
)

func marshalAccelFlags(p uintptr) (interface{}, error) {
	return AccelFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ApplicationInhibitFlags types of user actions that may be blocked by
// gtk_application_inhibit().
type ApplicationInhibitFlags int

const (
	// ApplicationInhibitFlagsLogout: inhibit ending the user session by logging
	// out or by shutting down the computer
	ApplicationInhibitFlagsLogout ApplicationInhibitFlags = 0b1
	// ApplicationInhibitFlagsSwitch: inhibit user switching
	ApplicationInhibitFlagsSwitch ApplicationInhibitFlags = 0b10
	// ApplicationInhibitFlagsSuspend: inhibit suspending the session or
	// computer
	ApplicationInhibitFlagsSuspend ApplicationInhibitFlags = 0b100
	// ApplicationInhibitFlagsIdle: inhibit the session being marked as idle
	// (and possibly locked)
	ApplicationInhibitFlagsIdle ApplicationInhibitFlags = 0b1000
)

func marshalApplicationInhibitFlags(p uintptr) (interface{}, error) {
	return ApplicationInhibitFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AttachOptions denotes the expansion properties that a widget will have when
// it (or its parent) is resized.
type AttachOptions int

const (
	// AttachOptionsExpand: the widget should expand to take up any extra space
	// in its container that has been allocated.
	AttachOptionsExpand AttachOptions = 0b1
	// AttachOptionsShrink: the widget should shrink as and when possible.
	AttachOptionsShrink AttachOptions = 0b10
	// AttachOptionsFill: the widget should fill the space allocated to it.
	AttachOptionsFill AttachOptions = 0b100
)

func marshalAttachOptions(p uintptr) (interface{}, error) {
	return AttachOptions(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CalendarDisplayOptions: these options can be used to influence the display
// and behaviour of a Calendar.
type CalendarDisplayOptions int

const (
	// CalendarDisplayOptionsShowHeading specifies that the month and year
	// should be displayed.
	CalendarDisplayOptionsShowHeading CalendarDisplayOptions = 0b1
	// CalendarDisplayOptionsShowDayNames specifies that three letter day
	// descriptions should be present.
	CalendarDisplayOptionsShowDayNames CalendarDisplayOptions = 0b10
	// CalendarDisplayOptionsNoMonthChange prevents the user from switching
	// months with the calendar.
	CalendarDisplayOptionsNoMonthChange CalendarDisplayOptions = 0b100
	// CalendarDisplayOptionsShowWeekNumbers displays each week numbers of the
	// current year, down the left side of the calendar.
	CalendarDisplayOptionsShowWeekNumbers CalendarDisplayOptions = 0b1000
	// CalendarDisplayOptionsShowDetails: just show an indicator, not the full
	// details text when details are provided. See
	// gtk_calendar_set_detail_func().
	CalendarDisplayOptionsShowDetails CalendarDisplayOptions = 0b100000
)

func marshalCalendarDisplayOptions(p uintptr) (interface{}, error) {
	return CalendarDisplayOptions(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CellRendererState tells how a cell is to be rendered.
type CellRendererState int

const (
	// CellRendererStateSelected: the cell is currently selected, and probably
	// has a selection colored background to render to.
	CellRendererStateSelected CellRendererState = 0b1
	// CellRendererStatePrelit: the mouse is hovering over the cell.
	CellRendererStatePrelit CellRendererState = 0b10
	// CellRendererStateInsensitive: the cell is drawn in an insensitive manner
	CellRendererStateInsensitive CellRendererState = 0b100
	// CellRendererStateSorted: the cell is in a sorted row
	CellRendererStateSorted CellRendererState = 0b1000
	// CellRendererStateFocused: the cell is in the focus row.
	CellRendererStateFocused CellRendererState = 0b10000
	// CellRendererStateExpandable: the cell is in a row that can be expanded.
	// Since 3.4
	CellRendererStateExpandable CellRendererState = 0b100000
	// CellRendererStateExpanded: the cell is in a row that is expanded. Since
	// 3.4
	CellRendererStateExpanded CellRendererState = 0b1000000
)

func marshalCellRendererState(p uintptr) (interface{}, error) {
	return CellRendererState(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

type DebugFlag int

const (
	DebugFlagMisc DebugFlag = 0b1

	DebugFlagPlugsocket DebugFlag = 0b10

	DebugFlagText DebugFlag = 0b100

	DebugFlagTree DebugFlag = 0b1000

	DebugFlagUpdates DebugFlag = 0b10000

	DebugFlagKeybindings DebugFlag = 0b100000

	DebugFlagMultihead DebugFlag = 0b1000000

	DebugFlagModules DebugFlag = 0b10000000

	DebugFlagGeometry DebugFlag = 0b100000000

	DebugFlagIcontheme DebugFlag = 0b1000000000

	DebugFlagPrinting DebugFlag = 0b10000000000

	DebugFlagBuilder DebugFlag = 0b100000000000

	DebugFlagSizeRequest DebugFlag = 0b1000000000000

	DebugFlagNoCSSCache DebugFlag = 0b10000000000000

	DebugFlagBaselines DebugFlag = 0b100000000000000

	DebugFlagPixelCache DebugFlag = 0b1000000000000000

	DebugFlagNoPixelCache DebugFlag = 0b10000000000000000

	DebugFlagInteractive DebugFlag = 0b100000000000000000

	DebugFlagTouchscreen DebugFlag = 0b1000000000000000000

	DebugFlagActions DebugFlag = 0b10000000000000000000

	DebugFlagResize DebugFlag = 0b100000000000000000000

	DebugFlagLayout DebugFlag = 0b1000000000000000000000
)

func marshalDebugFlag(p uintptr) (interface{}, error) {
	return DebugFlag(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DestDefaults: the DestDefaults enumeration specifies the various types of
// action that will be taken on behalf of the user for a drag destination site.
type DestDefaults int

const (
	// DestDefaultsMotion: if set for a widget, GTK+, during a drag over this
	// widget will check if the drag matches this widget’s list of possible
	// targets and actions. GTK+ will then call gdk_drag_status() as
	// appropriate.
	DestDefaultsMotion DestDefaults = 0b1
	// DestDefaultsHighlight: if set for a widget, GTK+ will draw a highlight on
	// this widget as long as a drag is over this widget and the widget drag
	// format and action are acceptable.
	DestDefaultsHighlight DestDefaults = 0b10
	// DestDefaultsDrop: if set for a widget, when a drop occurs, GTK+ will will
	// check if the drag matches this widget’s list of possible targets and
	// actions. If so, GTK+ will call gtk_drag_get_data() on behalf of the
	// widget. Whether or not the drop is successful, GTK+ will call
	// gtk_drag_finish(). If the action was a move, then if the drag was
	// successful, then true will be passed for the @delete parameter to
	// gtk_drag_finish().
	DestDefaultsDrop DestDefaults = 0b100
	// DestDefaultsAll: if set, specifies that all default actions should be
	// taken.
	DestDefaultsAll DestDefaults = 0b111
)

func marshalDestDefaults(p uintptr) (interface{}, error) {
	return DestDefaults(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DialogFlags flags used to influence dialog construction.
type DialogFlags int

const (
	// DialogFlagsModal: make the constructed dialog modal, see
	// gtk_window_set_modal()
	DialogFlagsModal DialogFlags = 0b1
	// DialogFlagsDestroyWithParent: destroy the dialog when its parent is
	// destroyed, see gtk_window_set_destroy_with_parent()
	DialogFlagsDestroyWithParent DialogFlags = 0b10
	// DialogFlagsUseHeaderBar: create dialog with actions in header bar instead
	// of action area. Since 3.12.
	DialogFlagsUseHeaderBar DialogFlags = 0b100
)

func marshalDialogFlags(p uintptr) (interface{}, error) {
	return DialogFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EventControllerScrollFlags describes the behavior of a EventControllerScroll.
type EventControllerScrollFlags int

const (
	// EventControllerScrollFlagsNone: don't emit scroll.
	EventControllerScrollFlagsNone EventControllerScrollFlags = 0b0
	// EventControllerScrollFlagsVertical: emit scroll with vertical deltas.
	EventControllerScrollFlagsVertical EventControllerScrollFlags = 0b1
	// EventControllerScrollFlagsHorizontal: emit scroll with horizontal deltas.
	EventControllerScrollFlagsHorizontal EventControllerScrollFlags = 0b10
	// EventControllerScrollFlagsDiscrete: only emit deltas that are multiples
	// of 1.
	EventControllerScrollFlagsDiscrete EventControllerScrollFlags = 0b100
	// EventControllerScrollFlagsKinetic: emit EventControllerScroll::decelerate
	// after continuous scroll finishes.
	EventControllerScrollFlagsKinetic EventControllerScrollFlags = 0b1000
	// EventControllerScrollFlagsBothAxes: emit scroll on both axes.
	EventControllerScrollFlagsBothAxes EventControllerScrollFlags = 0b11
)

func marshalEventControllerScrollFlags(p uintptr) (interface{}, error) {
	return EventControllerScrollFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileFilterFlags: these flags indicate what parts of a FileFilterInfo struct
// are filled or need to be filled.
type FileFilterFlags int

const (
	// FileFilterFlagsFilename: the filename of the file being tested
	FileFilterFlagsFilename FileFilterFlags = 0b1
	// FileFilterFlagsURI: the URI for the file being tested
	FileFilterFlagsURI FileFilterFlags = 0b10
	// FileFilterFlagsDisplayName: the string that will be used to display the
	// file in the file chooser
	FileFilterFlagsDisplayName FileFilterFlags = 0b100
	// FileFilterFlagsMIMEType: the mime type of the file
	FileFilterFlagsMIMEType FileFilterFlags = 0b1000
)

func marshalFileFilterFlags(p uintptr) (interface{}, error) {
	return FileFilterFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FontChooserLevel: this enumeration specifies the granularity of font
// selection that is desired in a font chooser.
//
// This enumeration may be extended in the future; applications should ignore
// unknown values.
type FontChooserLevel int

const (
	// FontChooserLevelFamily: allow selecting a font family
	FontChooserLevelFamily FontChooserLevel = 0b0
	// FontChooserLevelStyle: allow selecting a specific font face
	FontChooserLevelStyle FontChooserLevel = 0b1
	// FontChooserLevelSize: allow selecting a specific font size
	FontChooserLevelSize FontChooserLevel = 0b10

	FontChooserLevelVariations FontChooserLevel = 0b100
	// FontChooserLevelFeatures: allow selecting specific OpenType font features
	FontChooserLevelFeatures FontChooserLevel = 0b1000
)

func marshalFontChooserLevel(p uintptr) (interface{}, error) {
	return FontChooserLevel(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconLookupFlags: used to specify options for gtk_icon_theme_lookup_icon()
type IconLookupFlags int

const (
	// IconLookupFlagsNoSvg: never get SVG icons, even if gdk-pixbuf supports
	// them. Cannot be used together with GTK_ICON_LOOKUP_FORCE_SVG.
	IconLookupFlagsNoSvg IconLookupFlags = 0b1
	// IconLookupFlagsForceSvg: get SVG icons, even if gdk-pixbuf doesn’t
	// support them. Cannot be used together with GTK_ICON_LOOKUP_NO_SVG.
	IconLookupFlagsForceSvg IconLookupFlags = 0b10
	// IconLookupFlagsUseBuiltin: when passed to gtk_icon_theme_lookup_icon()
	// includes builtin icons as well as files. For a builtin icon,
	// gtk_icon_info_get_filename() is nil and you need to call
	// gtk_icon_info_get_builtin_pixbuf().
	IconLookupFlagsUseBuiltin IconLookupFlags = 0b100
	// IconLookupFlagsGenericFallback: try to shorten icon name at '-'
	// characters before looking at inherited themes. This flag is only
	// supported in functions that take a single icon name. For more general
	// fallback, see gtk_icon_theme_choose_icon(). Since 2.12.
	IconLookupFlagsGenericFallback IconLookupFlags = 0b1000
	// IconLookupFlagsForceSize always get the icon scaled to the requested
	// size. Since 2.14.
	IconLookupFlagsForceSize IconLookupFlags = 0b10000
	// IconLookupFlagsForceRegular: try to always load regular icons, even when
	// symbolic icon names are given. Since 3.14.
	IconLookupFlagsForceRegular IconLookupFlags = 0b100000
	// IconLookupFlagsForceSymbolic: try to always load symbolic icons, even
	// when regular icon names are given. Since 3.14.
	IconLookupFlagsForceSymbolic IconLookupFlags = 0b1000000
	// IconLookupFlagsDirLTR: try to load a variant of the icon for
	// left-to-right text direction. Since 3.14.
	IconLookupFlagsDirLTR IconLookupFlags = 0b10000000
	// IconLookupFlagsDirRTL: try to load a variant of the icon for
	// right-to-left text direction. Since 3.14.
	IconLookupFlagsDirRTL IconLookupFlags = 0b100000000
)

func marshalIconLookupFlags(p uintptr) (interface{}, error) {
	return IconLookupFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// InputHints describes hints that might be taken into account by input methods
// or applications. Note that input methods may already tailor their behaviour
// according to the InputPurpose of the entry.
//
// Some common sense is expected when using these flags - mixing
// @GTK_INPUT_HINT_LOWERCASE with any of the uppercase hints makes no sense.
//
// This enumeration may be extended in the future; input methods should ignore
// unknown values.
type InputHints int

const (
	// InputHintsNone: no special behaviour suggested
	InputHintsNone InputHints = 0b0
	// InputHintsSpellcheck: suggest checking for typos
	InputHintsSpellcheck InputHints = 0b1
	// InputHintsNoSpellcheck: suggest not checking for typos
	InputHintsNoSpellcheck InputHints = 0b10
	// InputHintsWordCompletion: suggest word completion
	InputHintsWordCompletion InputHints = 0b100
	// InputHintsLowercase: suggest to convert all text to lowercase
	InputHintsLowercase InputHints = 0b1000
	// InputHintsUppercaseChars: suggest to capitalize all text
	InputHintsUppercaseChars InputHints = 0b10000
	// InputHintsUppercaseWords: suggest to capitalize the first character of
	// each word
	InputHintsUppercaseWords InputHints = 0b100000
	// InputHintsUppercaseSentences: suggest to capitalize the first word of
	// each sentence
	InputHintsUppercaseSentences InputHints = 0b1000000
	// InputHintsInhibitOsk: suggest to not show an onscreen keyboard (e.g for a
	// calculator that already has all the keys).
	InputHintsInhibitOsk InputHints = 0b10000000
	// InputHintsVerticalWriting: the text is vertical. Since 3.18
	InputHintsVerticalWriting InputHints = 0b100000000
	// InputHintsEmoji: suggest offering Emoji support. Since 3.22.20
	InputHintsEmoji InputHints = 0b1000000000
	// InputHintsNoEmoji: suggest not offering Emoji support. Since 3.22.20
	InputHintsNoEmoji InputHints = 0b10000000000
)

func marshalInputHints(p uintptr) (interface{}, error) {
	return InputHints(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// JunctionSides describes how a rendered element connects to adjacent elements.
type JunctionSides int

const (
	// JunctionSidesNone: no junctions.
	JunctionSidesNone JunctionSides = 0b0
	// JunctionSidesCornerTopleft: element connects on the top-left corner.
	JunctionSidesCornerTopleft JunctionSides = 0b1
	// JunctionSidesCornerTopright: element connects on the top-right corner.
	JunctionSidesCornerTopright JunctionSides = 0b10
	// JunctionSidesCornerBottomleft: element connects on the bottom-left
	// corner.
	JunctionSidesCornerBottomleft JunctionSides = 0b100
	// JunctionSidesCornerBottomright: element connects on the bottom-right
	// corner.
	JunctionSidesCornerBottomright JunctionSides = 0b1000
	// JunctionSidesTop: element connects on the top side.
	JunctionSidesTop JunctionSides = 0b11
	// JunctionSidesBottom: element connects on the bottom side.
	JunctionSidesBottom JunctionSides = 0b1100
	// JunctionSidesLeft: element connects on the left side.
	JunctionSidesLeft JunctionSides = 0b101
	// JunctionSidesRight: element connects on the right side.
	JunctionSidesRight JunctionSides = 0b1010
)

func marshalJunctionSides(p uintptr) (interface{}, error) {
	return JunctionSides(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PlacesOpenFlags: these flags serve two purposes. First, the application can
// call gtk_places_sidebar_set_open_flags() using these flags as a bitmask. This
// tells the sidebar that the application is able to open folders selected from
// the sidebar in various ways, for example, in new tabs or in new windows in
// addition to the normal mode.
//
// Second, when one of these values gets passed back to the application in the
// PlacesSidebar::open-location signal, it means that the application should
// open the selected location in the normal way, in a new tab, or in a new
// window. The sidebar takes care of determining the desired way to open the
// location, based on the modifier keys that the user is pressing at the time
// the selection is made.
//
// If the application never calls gtk_places_sidebar_set_open_flags(), then the
// sidebar will only use K_PLACES_OPEN_NORMAL in the
// PlacesSidebar::open-location signal. This is the default mode of operation.
type PlacesOpenFlags int

const (
	// PlacesOpenFlagsNormal: this is the default mode that PlacesSidebar uses
	// if no other flags are specified. It indicates that the calling
	// application should open the selected location in the normal way, for
	// example, in the folder view beside the sidebar.
	PlacesOpenFlagsNormal PlacesOpenFlags = 0b1
	// PlacesOpenFlagsNewTab: when passed to
	// gtk_places_sidebar_set_open_flags(), this indicates that the application
	// can open folders selected from the sidebar in new tabs. This value will
	// be passed to the PlacesSidebar::open-location signal when the user
	// selects that a location be opened in a new tab instead of in the standard
	// fashion.
	PlacesOpenFlagsNewTab PlacesOpenFlags = 0b10
	// PlacesOpenFlagsNewWindow: similar to @GTK_PLACES_OPEN_NEW_TAB, but
	// indicates that the application can open folders in new windows.
	PlacesOpenFlagsNewWindow PlacesOpenFlags = 0b100
)

func marshalPlacesOpenFlags(p uintptr) (interface{}, error) {
	return PlacesOpenFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RCFlags: deprecated
type RCFlags int

const (
	// RCFlagsFg: deprecated
	RCFlagsFg RCFlags = 0b1
	// RCFlagsBg: deprecated
	RCFlagsBg RCFlags = 0b10
	// RCFlagsText: deprecated
	RCFlagsText RCFlags = 0b100
	// RCFlagsBase: deprecated
	RCFlagsBase RCFlags = 0b1000
)

func marshalRCFlags(p uintptr) (interface{}, error) {
	return RCFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RecentFilterFlags: these flags indicate what parts of a RecentFilterInfo
// struct are filled or need to be filled.
type RecentFilterFlags int

const (
	// RecentFilterFlagsURI: the URI of the file being tested
	RecentFilterFlagsURI RecentFilterFlags = 0b1
	// RecentFilterFlagsDisplayName: the string that will be used to display the
	// file in the recent chooser
	RecentFilterFlagsDisplayName RecentFilterFlags = 0b10
	// RecentFilterFlagsMIMEType: the mime type of the file
	RecentFilterFlagsMIMEType RecentFilterFlags = 0b100
	// RecentFilterFlagsApplication: the list of applications that have
	// registered the file
	RecentFilterFlagsApplication RecentFilterFlags = 0b1000
	// RecentFilterFlagsGroup: the groups to which the file belongs to
	RecentFilterFlagsGroup RecentFilterFlags = 0b10000
	// RecentFilterFlagsAge: the number of days elapsed since the file has been
	// registered
	RecentFilterFlagsAge RecentFilterFlags = 0b100000
)

func marshalRecentFilterFlags(p uintptr) (interface{}, error) {
	return RecentFilterFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RegionFlags describes a region within a widget.
type RegionFlags int

const (
	// RegionFlagsEven: region has an even number within a set.
	RegionFlagsEven RegionFlags = 0b1
	// RegionFlagsOdd: region has an odd number within a set.
	RegionFlagsOdd RegionFlags = 0b10
	// RegionFlagsFirst: region is the first one within a set.
	RegionFlagsFirst RegionFlags = 0b100
	// RegionFlagsLast: region is the last one within a set.
	RegionFlagsLast RegionFlags = 0b1000
	// RegionFlagsOnly: region is the only one within a set.
	RegionFlagsOnly RegionFlags = 0b10000
	// RegionFlagsSorted: region is part of a sorted area.
	RegionFlagsSorted RegionFlags = 0b100000
)

func marshalRegionFlags(p uintptr) (interface{}, error) {
	return RegionFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// StateFlags describes a widget state. Widget states are used to match the
// widget against CSS pseudo-classes. Note that GTK extends the regular CSS
// classes and sometimes uses different names.
type StateFlags int

const (
	// StateFlagsNormal: state during normal operation.
	StateFlagsNormal StateFlags = 0b0
	// StateFlagsActive: widget is active.
	StateFlagsActive StateFlags = 0b1
	// StateFlagsPrelight: widget has a mouse pointer over it.
	StateFlagsPrelight StateFlags = 0b10
	// StateFlagsSelected: widget is selected.
	StateFlagsSelected StateFlags = 0b100
	// StateFlagsInsensitive: widget is insensitive.
	StateFlagsInsensitive StateFlags = 0b1000
	// StateFlagsInconsistent: widget is inconsistent.
	StateFlagsInconsistent StateFlags = 0b10000
	// StateFlagsFocused: widget has the keyboard focus.
	StateFlagsFocused StateFlags = 0b100000
	// StateFlagsBackdrop: widget is in a background toplevel window.
	StateFlagsBackdrop StateFlags = 0b1000000
	// StateFlagsDirLTR: widget is in left-to-right text direction. Since 3.8
	StateFlagsDirLTR StateFlags = 0b10000000
	// StateFlagsDirRTL: widget is in right-to-left text direction. Since 3.8
	StateFlagsDirRTL StateFlags = 0b100000000
	// StateFlagsLink: widget is a link. Since 3.12
	StateFlagsLink StateFlags = 0b1000000000
	// StateFlagsVisited: the location the widget points to has already been
	// visited. Since 3.12
	StateFlagsVisited StateFlags = 0b10000000000
	// StateFlagsChecked: widget is checked. Since 3.14
	StateFlagsChecked StateFlags = 0b100000000000
	// StateFlagsDropActive: widget is highlighted as a drop target for DND.
	// Since 3.20
	StateFlagsDropActive StateFlags = 0b1000000000000
)

func marshalStateFlags(p uintptr) (interface{}, error) {
	return StateFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// StyleContextPrintFlags flags that modify the behavior of
// gtk_style_context_to_string(). New values may be added to this enumeration.
type StyleContextPrintFlags int

const (
	StyleContextPrintFlagsNone StyleContextPrintFlags = 0b0
	// StyleContextPrintFlagsRecurse: print the entire tree of CSS nodes
	// starting at the style context's node
	StyleContextPrintFlagsRecurse StyleContextPrintFlags = 0b1
	// StyleContextPrintFlagsShowStyle: show the values of the CSS properties
	// for each node
	StyleContextPrintFlagsShowStyle StyleContextPrintFlags = 0b10
)

func marshalStyleContextPrintFlags(p uintptr) (interface{}, error) {
	return StyleContextPrintFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TargetFlags: the TargetFlags enumeration is used to specify constraints on a
// TargetEntry.
type TargetFlags int

const (
	// TargetFlagsSameApp: if this is set, the target will only be selected for
	// drags within a single application.
	TargetFlagsSameApp TargetFlags = 0b1
	// TargetFlagsSameWidget: if this is set, the target will only be selected
	// for drags within a single widget.
	TargetFlagsSameWidget TargetFlags = 0b10
	// TargetFlagsOtherApp: if this is set, the target will not be selected for
	// drags within a single application.
	TargetFlagsOtherApp TargetFlags = 0b100
	// TargetFlagsOtherWidget: if this is set, the target will not be selected
	// for drags withing a single widget.
	TargetFlagsOtherWidget TargetFlags = 0b1000
)

func marshalTargetFlags(p uintptr) (interface{}, error) {
	return TargetFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextSearchFlags flags affecting how a search is done.
//
// If neither K_TEXT_SEARCH_VISIBLE_ONLY nor K_TEXT_SEARCH_TEXT_ONLY are
// enabled, the match must be exact; the special 0xFFFC character will match
// embedded pixbufs or child widgets.
type TextSearchFlags int

const (
	// TextSearchFlagsVisibleOnly: search only visible data. A search match may
	// have invisible text interspersed.
	TextSearchFlagsVisibleOnly TextSearchFlags = 0b1
	// TextSearchFlagsTextOnly: search only text. A match may have pixbufs or
	// child widgets mixed inside the matched range.
	TextSearchFlagsTextOnly TextSearchFlags = 0b10
	// TextSearchFlagsCaseInsensitive: the text will be matched regardless of
	// what case it is in.
	TextSearchFlagsCaseInsensitive TextSearchFlags = 0b100
)

func marshalTextSearchFlags(p uintptr) (interface{}, error) {
	return TextSearchFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ToolPaletteDragTargets flags used to specify the supported drag targets.
type ToolPaletteDragTargets int

const (
	// ToolPaletteDragTargetsItems: support drag of items.
	ToolPaletteDragTargetsItems ToolPaletteDragTargets = 0b1
	// ToolPaletteDragTargetsGroups: support drag of groups.
	ToolPaletteDragTargetsGroups ToolPaletteDragTargets = 0b10
)

func marshalToolPaletteDragTargets(p uintptr) (interface{}, error) {
	return ToolPaletteDragTargets(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TreeModelFlags: these flags indicate various properties of a TreeModel.
//
// They are returned by gtk_tree_model_get_flags(), and must be static for the
// lifetime of the object. A more complete description of
// K_TREE_MODEL_ITERS_PERSIST can be found in the overview of this section.
type TreeModelFlags int

const (
	// TreeModelFlagsItersPersist iterators survive all signals emitted by the
	// tree
	TreeModelFlagsItersPersist TreeModelFlags = 0b1
	// TreeModelFlagsListOnly: the model is a list only, and never has children
	TreeModelFlagsListOnly TreeModelFlags = 0b10
)

func marshalTreeModelFlags(p uintptr) (interface{}, error) {
	return TreeModelFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// UIManagerItemType: these enumeration values are used by
// gtk_ui_manager_add_ui() to determine what UI element to create.
type UIManagerItemType int

const (
	// UIManagerItemTypeAuto: pick the type of the UI element according to
	// context.
	UIManagerItemTypeAuto UIManagerItemType = 0b0
	// UIManagerItemTypeMenubar: create a menubar.
	UIManagerItemTypeMenubar UIManagerItemType = 0b1
	// UIManagerItemTypeMenu: create a menu.
	UIManagerItemTypeMenu UIManagerItemType = 0b10
	// UIManagerItemTypeToolbar: create a toolbar.
	UIManagerItemTypeToolbar UIManagerItemType = 0b100
	// UIManagerItemTypePlaceholder: insert a placeholder.
	UIManagerItemTypePlaceholder UIManagerItemType = 0b1000
	// UIManagerItemTypePopup: create a popup menu.
	UIManagerItemTypePopup UIManagerItemType = 0b10000
	// UIManagerItemTypeMenuitem: create a menuitem.
	UIManagerItemTypeMenuitem UIManagerItemType = 0b100000
	// UIManagerItemTypeToolitem: create a toolitem.
	UIManagerItemTypeToolitem UIManagerItemType = 0b1000000
	// UIManagerItemTypeSeparator: create a separator.
	UIManagerItemTypeSeparator UIManagerItemType = 0b10000000
	// UIManagerItemTypeAccelerator: install an accelerator.
	UIManagerItemTypeAccelerator UIManagerItemType = 0b100000000
	// UIManagerItemTypePopupWithAccels: same as GTK_UI_MANAGER_POPUP, but the
	// actions’ accelerators are shown.
	UIManagerItemTypePopupWithAccels UIManagerItemType = 0b1000000000
)

func marshalUIManagerItemType(p uintptr) (interface{}, error) {
	return UIManagerItemType(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

func BuilderErrorQuark() glib.Quark {
	ret := C.gtk_builder_error_quark()

	var ret0 glib.Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

func CSSProviderErrorQuark() glib.Quark {
	ret := C.gtk_css_provider_error_quark()

	var ret0 glib.Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

// FileChooserErrorQuark registers an error quark for FileChooser if necessary.
func FileChooserErrorQuark() glib.Quark {
	ret := C.gtk_file_chooser_error_quark()

	var ret0 glib.Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

func IconThemeErrorQuark() glib.Quark {
	ret := C.gtk_icon_theme_error_quark()

	var ret0 glib.Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

// PrintErrorQuark registers an error quark for PrintOperation if necessary.
func PrintErrorQuark() glib.Quark {
	ret := C.gtk_print_error_quark()

	var ret0 glib.Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

func RecentChooserErrorQuark() glib.Quark {
	ret := C.gtk_recent_chooser_error_quark()

	var ret0 glib.Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

func RecentManagerErrorQuark() glib.Quark {
	ret := C.gtk_recent_manager_error_quark()

	var ret0 glib.Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

// FileChooser is an interface that can be implemented by file selection
// widgets. In GTK+, the main objects that implement this interface are
// FileChooserWidget, FileChooserDialog, and FileChooserButton. You do not need
// to write an object that implements the FileChooser interface unless you are
// trying to adapt an existing file selector to expose a standard programming
// interface.
//
// FileChooser allows for shortcuts to various places in the filesystem. In the
// default implementation these are displayed in the left pane. It may be a bit
// confusing at first that these shortcuts come from various sources and in
// various flavours, so lets explain the terminology here:
//
// - Bookmarks: are created by the user, by dragging folders from the right pane
// to the left pane, or by using the “Add”. Bookmarks can be renamed and deleted
// by the user.
//
// - Shortcuts: can be provided by the application. For example, a Paint program
// may want to add a shortcut for a Clipart folder. Shortcuts cannot be modified
// by the user.
//
// - Volumes: are provided by the underlying filesystem abstraction. They are
// the “roots” of the filesystem.
//
//
// File Names and Encodings
//
// When the user is finished selecting files in a FileChooser, your program can
// get the selected names either as filenames or as URIs. For URIs, the normal
// escaping rules are applied if the URI contains non-ASCII characters. However,
// filenames are always returned in the character set specified by the
// `G_FILENAME_ENCODING` environment variable. Please see the GLib documentation
// for more details about this variable.
//
// This means that while you can pass the result of
// gtk_file_chooser_get_filename() to g_open() or g_fopen(), you may not be able
// to directly set it as the text of a Label widget unless you convert it first
// to UTF-8, which all GTK+ widgets expect. You should use g_filename_to_utf8()
// to convert filenames into strings that can be passed to GTK+ widgets.
//
//
// Adding a Preview Widget
//
// You can add a custom preview widget to a file chooser and then get
// notification about when the preview needs to be updated. To install a preview
// widget, use gtk_file_chooser_set_preview_widget(). Then, connect to the
// FileChooser::update-preview signal to get notified when you need to update
// the contents of the preview.
//
// Your callback should use gtk_file_chooser_get_preview_filename() to see what
// needs previewing. Once you have generated the preview for the corresponding
// file, you must call gtk_file_chooser_set_preview_widget_active() with a
// boolean flag that indicates whether your callback could successfully generate
// a preview.
//
// Example: Using a Preview Widget
//
//
//      GtkWidget *toggle;
//
//      ...
//
//      toggle = gtk_check_button_new_with_label ("Open file read-only");
//      gtk_widget_show (toggle);
//      gtk_file_chooser_set_extra_widget (my_file_chooser, toggle);
//    }
//
// If you want to set more than one extra widget in the file chooser, you can a
// container such as a Box or a Grid and include your widgets in it. Then, set
// the container as the whole extra widget.
type FileChooser interface {
	gextras.Objector

	// AddChoice adds a 'choice' to the file chooser. This is typically
	// implemented as a combobox or, for boolean choices, as a checkbutton. You
	// can select a value using gtk_file_chooser_set_choice() before the dialog
	// is shown, and you can obtain the user-selected value in the ::response
	// signal handler using gtk_file_chooser_get_choice().
	//
	// Compare gtk_file_chooser_set_extra_widget().
	AddChoice(id string, label string, options []string, optionLabels []string)
	// AddFilter adds @filter to the list of filters that the user can select
	// between. When a filter is selected, only files that are passed by that
	// filter are displayed.
	//
	// Note that the @chooser takes ownership of the filter, so you have to ref
	// and sink it if you want to keep a reference.
	AddFilter(filter FileFilter)
	// AddShortcutFolder adds a folder to be displayed with the shortcut folders
	// in a file chooser. Note that shortcut folders do not get saved, as they
	// are provided by the application. For example, you can use this to add a
	// “/usr/share/mydrawprogram/Clipart” folder to the volume list.
	AddShortcutFolder(folder string) error
	// AddShortcutFolderURI adds a folder URI to be displayed with the shortcut
	// folders in a file chooser. Note that shortcut folders do not get saved,
	// as they are provided by the application. For example, you can use this to
	// add a “file:///usr/share/mydrawprogram/Clipart” folder to the volume
	// list.
	AddShortcutFolderURI(uri string) error
	// Action gets the type of operation that the file chooser is performing;
	// see gtk_file_chooser_set_action().
	Action() FileChooserAction
	// Choice gets the currently selected option in the 'choice' with the given
	// ID.
	Choice(id string) string
	// CreateFolders gets whether file choser will offer to create new folders.
	// See gtk_file_chooser_set_create_folders().
	CreateFolders() bool
	// CurrentFolder gets the current folder of @chooser as a local filename.
	// See gtk_file_chooser_set_current_folder().
	//
	// Note that this is the folder that the file chooser is currently
	// displaying (e.g. "/home/username/Documents"), which is not the same as
	// the currently-selected folder if the chooser is in
	// GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER mode (e.g.
	// "/home/username/Documents/selected-folder/". To get the
	// currently-selected folder in that mode, use gtk_file_chooser_get_uri() as
	// the usual way to get the selection.
	CurrentFolder() string
	// CurrentFolderFile gets the current folder of @chooser as #GFile. See
	// gtk_file_chooser_get_current_folder_uri().
	CurrentFolderFile() gio.File
	// CurrentFolderURI gets the current folder of @chooser as an URI. See
	// gtk_file_chooser_set_current_folder_uri().
	//
	// Note that this is the folder that the file chooser is currently
	// displaying (e.g. "file:///home/username/Documents"), which is not the
	// same as the currently-selected folder if the chooser is in
	// GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER mode (e.g.
	// "file:///home/username/Documents/selected-folder/". To get the
	// currently-selected folder in that mode, use gtk_file_chooser_get_uri() as
	// the usual way to get the selection.
	CurrentFolderURI() string
	// CurrentName gets the current name in the file selector, as entered by the
	// user in the text entry for “Name”.
	//
	// This is meant to be used in save dialogs, to get the currently typed
	// filename when the file itself does not exist yet. For example, an
	// application that adds a custom extra widget to the file chooser for “file
	// format” may want to change the extension of the typed filename based on
	// the chosen format, say, from “.jpg” to “.png”.
	CurrentName() string
	// DoOverwriteConfirmation queries whether a file chooser is set to confirm
	// for overwriting when the user types a file name that already exists.
	DoOverwriteConfirmation() bool
	// ExtraWidget gets the current extra widget; see
	// gtk_file_chooser_set_extra_widget().
	ExtraWidget() Widget
	// File gets the #GFile for the currently selected file in the file
	// selector. If multiple files are selected, one of the files will be
	// returned at random.
	//
	// If the file chooser is in folder mode, this function returns the selected
	// folder.
	File() gio.File
	// Filename gets the filename for the currently selected file in the file
	// selector. The filename is returned as an absolute path. If multiple files
	// are selected, one of the filenames will be returned at random.
	//
	// If the file chooser is in folder mode, this function returns the selected
	// folder.
	Filename() string
	// Filenames lists all the selected files and subfolders in the current
	// folder of @chooser. The returned names are full absolute paths. If files
	// in the current folder cannot be represented as local filenames they will
	// be ignored. (See gtk_file_chooser_get_uris())
	Filenames() *glib.SList
	// Files lists all the selected files and subfolders in the current folder
	// of @chooser as #GFile. An internal function, see
	// gtk_file_chooser_get_uris().
	Files() *glib.SList
	// Filter gets the current filter; see gtk_file_chooser_set_filter().
	Filter() FileFilter
	// LocalOnly gets whether only local files can be selected in the file
	// selector. See gtk_file_chooser_set_local_only()
	LocalOnly() bool
	// PreviewFile gets the #GFile that should be previewed in a custom preview
	// Internal function, see gtk_file_chooser_get_preview_uri().
	PreviewFile() gio.File
	// PreviewFilename gets the filename that should be previewed in a custom
	// preview widget. See gtk_file_chooser_set_preview_widget().
	PreviewFilename() string
	// PreviewURI gets the URI that should be previewed in a custom preview
	// widget. See gtk_file_chooser_set_preview_widget().
	PreviewURI() string
	// PreviewWidget gets the current preview widget; see
	// gtk_file_chooser_set_preview_widget().
	PreviewWidget() Widget
	// PreviewWidgetActive gets whether the preview widget set by
	// gtk_file_chooser_set_preview_widget() should be shown for the current
	// filename. See gtk_file_chooser_set_preview_widget_active().
	PreviewWidgetActive() bool
	// SelectMultiple gets whether multiple files can be selected in the file
	// selector. See gtk_file_chooser_set_select_multiple().
	SelectMultiple() bool
	// ShowHidden gets whether hidden files and folders are displayed in the
	// file selector. See gtk_file_chooser_set_show_hidden().
	ShowHidden() bool
	// URI gets the URI for the currently selected file in the file selector. If
	// multiple files are selected, one of the filenames will be returned at
	// random.
	//
	// If the file chooser is in folder mode, this function returns the selected
	// folder.
	URI() string
	// Uris lists all the selected files and subfolders in the current folder of
	// @chooser. The returned names are full absolute URIs.
	Uris() *glib.SList
	// UsePreviewLabel gets whether a stock label should be drawn with the name
	// of the previewed file. See gtk_file_chooser_set_use_preview_label().
	UsePreviewLabel() bool
	// ListFilters lists the current set of user-selectable filters; see
	// gtk_file_chooser_add_filter(), gtk_file_chooser_remove_filter().
	ListFilters() *glib.SList
	// ListShortcutFolderUris queries the list of shortcut folders in the file
	// chooser, as set by gtk_file_chooser_add_shortcut_folder_uri().
	ListShortcutFolderUris() *glib.SList
	// ListShortcutFolders queries the list of shortcut folders in the file
	// chooser, as set by gtk_file_chooser_add_shortcut_folder().
	ListShortcutFolders() *glib.SList
	// RemoveChoice removes a 'choice' that has been added with
	// gtk_file_chooser_add_choice().
	RemoveChoice(id string)
	// RemoveFilter removes @filter from the list of filters that the user can
	// select between.
	RemoveFilter(filter FileFilter)
	// RemoveShortcutFolder removes a folder from a file chooser’s list of
	// shortcut folders.
	RemoveShortcutFolder(folder string) error
	// RemoveShortcutFolderURI removes a folder URI from a file chooser’s list
	// of shortcut folders.
	RemoveShortcutFolderURI(uri string) error
	// SelectAll selects all the files in the current folder of a file chooser.
	SelectAll()
	// SelectFile selects the file referred to by @file. An internal function.
	// See _gtk_file_chooser_select_uri().
	SelectFile(file gio.File) error
	// SelectFilename selects a filename. If the file name isn’t in the current
	// folder of @chooser, then the current folder of @chooser will be changed
	// to the folder containing @filename.
	SelectFilename(filename string) bool
	// SelectURI selects the file to by @uri. If the URI doesn’t refer to a file
	// in the current folder of @chooser, then the current folder of @chooser
	// will be changed to the folder containing @filename.
	SelectURI(uri string) bool
	// SetAction sets the type of operation that the chooser is performing; the
	// user interface is adapted to suit the selected action. For example, an
	// option to create a new folder might be shown if the action is
	// GTK_FILE_CHOOSER_ACTION_SAVE but not if the action is
	// GTK_FILE_CHOOSER_ACTION_OPEN.
	SetAction(action FileChooserAction)
	// SetChoice selects an option in a 'choice' that has been added with
	// gtk_file_chooser_add_choice(). For a boolean choice, the possible options
	// are "true" and "false".
	SetChoice(id string, option string)
	// SetCreateFolders sets whether file choser will offer to create new
	// folders. This is only relevant if the action is not set to be
	// GTK_FILE_CHOOSER_ACTION_OPEN.
	SetCreateFolders(createFolders bool)
	// SetCurrentFolder sets the current folder for @chooser from a local
	// filename. The user will be shown the full contents of the current folder,
	// plus user interface elements for navigating to other folders.
	//
	// In general, you should not use this function. See the [section on setting
	// up a file chooser dialog][gtkfilechooserdialog-setting-up] for the
	// rationale behind this.
	SetCurrentFolder(filename string) bool
	// SetCurrentFolderFile sets the current folder for @chooser from a #GFile.
	// Internal function, see gtk_file_chooser_set_current_folder_uri().
	SetCurrentFolderFile(file gio.File) error
	// SetCurrentFolderURI sets the current folder for @chooser from an URI. The
	// user will be shown the full contents of the current folder, plus user
	// interface elements for navigating to other folders.
	//
	// In general, you should not use this function. See the [section on setting
	// up a file chooser dialog][gtkfilechooserdialog-setting-up] for the
	// rationale behind this.
	SetCurrentFolderURI(uri string) bool
	// SetCurrentName sets the current name in the file selector, as if entered
	// by the user. Note that the name passed in here is a UTF-8 string rather
	// than a filename. This function is meant for such uses as a suggested name
	// in a “Save As...” dialog. You can pass “Untitled.doc” or a similarly
	// suitable suggestion for the @name.
	//
	// If you want to preselect a particular existing file, you should use
	// gtk_file_chooser_set_filename() or gtk_file_chooser_set_uri() instead.
	// Please see the documentation for those functions for an example of using
	// gtk_file_chooser_set_current_name() as well.
	SetCurrentName(name string)
	// SetDoOverwriteConfirmation sets whether a file chooser in
	// GTK_FILE_CHOOSER_ACTION_SAVE mode will present a confirmation dialog if
	// the user types a file name that already exists. This is false by default.
	//
	// If set to true, the @chooser will emit the FileChooser::confirm-overwrite
	// signal when appropriate.
	//
	// If all you need is the stock confirmation dialog, set this property to
	// true. You can override the way confirmation is done by actually handling
	// the FileChooser::confirm-overwrite signal; please refer to its
	// documentation for the details.
	SetDoOverwriteConfirmation(doOverwriteConfirmation bool)
	// SetExtraWidget sets an application-supplied widget to provide extra
	// options to the user.
	SetExtraWidget(extraWidget Widget)
	// SetFile sets @file as the current filename for the file chooser, by
	// changing to the file’s parent folder and actually selecting the file in
	// list. If the @chooser is in GTK_FILE_CHOOSER_ACTION_SAVE mode, the file’s
	// base name will also appear in the dialog’s file name entry.
	//
	// If the file name isn’t in the current folder of @chooser, then the
	// current folder of @chooser will be changed to the folder containing
	// @filename. This is equivalent to a sequence of
	// gtk_file_chooser_unselect_all() followed by
	// gtk_file_chooser_select_filename().
	//
	// Note that the file must exist, or nothing will be done except for the
	// directory change.
	//
	// If you are implementing a save dialog, you should use this function if
	// you already have a file name to which the user may save; for example,
	// when the user opens an existing file and then does Save As... If you
	// don’t have a file name already — for example, if the user just created a
	// new file and is saving it for the first time, do not call this function.
	// Instead, use something similar to this:
	//
	//    if (document_is_new)
	//      {
	//        // the user just created a new document
	//        gtk_file_chooser_set_current_folder_file (chooser, default_file_for_saving);
	//        gtk_file_chooser_set_current_name (chooser, "Untitled document");
	//      }
	//    else
	//      {
	//        // the user edited an existing document
	//        gtk_file_chooser_set_file (chooser, existing_file);
	//      }
	SetFile(file gio.File) error
	// SetFilename sets @filename as the current filename for the file chooser,
	// by changing to the file’s parent folder and actually selecting the file
	// in list; all other files will be unselected. If the @chooser is in
	// GTK_FILE_CHOOSER_ACTION_SAVE mode, the file’s base name will also appear
	// in the dialog’s file name entry.
	//
	// Note that the file must exist, or nothing will be done except for the
	// directory change.
	//
	// You should use this function only when implementing a save dialog for
	// which you already have a file name to which the user may save. For
	// example, when the user opens an existing file and then does Save As... to
	// save a copy or a modified version. If you don’t have a file name already
	// — for example, if the user just created a new file and is saving it for
	// the first time, do not call this function. Instead, use something similar
	// to this:
	//
	//    if (document_is_new)
	//      {
	//        // the user just created a new document
	//        gtk_file_chooser_set_current_name (chooser, "Untitled document");
	//      }
	//    else
	//      {
	//        // the user edited an existing document
	//        gtk_file_chooser_set_filename (chooser, existing_filename);
	//      }
	//
	// In the first case, the file chooser will present the user with useful
	// suggestions as to where to save his new file. In the second case, the
	// file’s existing location is already known, so the file chooser will use
	// it.
	SetFilename(filename string) bool
	// SetFilter sets the current filter; only the files that pass the filter
	// will be displayed. If the user-selectable list of filters is non-empty,
	// then the filter should be one of the filters in that list. Setting the
	// current filter when the list of filters is empty is useful if you want to
	// restrict the displayed set of files without letting the user change it.
	SetFilter(filter FileFilter)
	// SetLocalOnly sets whether only local files can be selected in the file
	// selector. If @local_only is true (the default), then the selected file or
	// files are guaranteed to be accessible through the operating systems
	// native file system and therefore the application only needs to worry
	// about the filename functions in FileChooser, like
	// gtk_file_chooser_get_filename(), rather than the URI functions like
	// gtk_file_chooser_get_uri(),
	//
	// On some systems non-native files may still be available using the native
	// filesystem via a userspace filesystem (FUSE).
	SetLocalOnly(localOnly bool)
	// SetPreviewWidget sets an application-supplied widget to use to display a
	// custom preview of the currently selected file. To implement a preview,
	// after setting the preview widget, you connect to the
	// FileChooser::update-preview signal, and call
	// gtk_file_chooser_get_preview_filename() or
	// gtk_file_chooser_get_preview_uri() on each change. If you can display a
	// preview of the new file, update your widget and set the preview active
	// using gtk_file_chooser_set_preview_widget_active(). Otherwise, set the
	// preview inactive.
	//
	// When there is no application-supplied preview widget, or the
	// application-supplied preview widget is not active, the file chooser will
	// display no preview at all.
	SetPreviewWidget(previewWidget Widget)
	// SetPreviewWidgetActive sets whether the preview widget set by
	// gtk_file_chooser_set_preview_widget() should be shown for the current
	// filename. When @active is set to false, the file chooser may display an
	// internally generated preview of the current file or it may display no
	// preview at all. See gtk_file_chooser_set_preview_widget() for more
	// details.
	SetPreviewWidgetActive(active bool)
	// SetSelectMultiple sets whether multiple files can be selected in the file
	// selector. This is only relevant if the action is set to be
	// GTK_FILE_CHOOSER_ACTION_OPEN or GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER.
	SetSelectMultiple(selectMultiple bool)
	// SetShowHidden sets whether hidden files and folders are displayed in the
	// file selector.
	SetShowHidden(showHidden bool)
	// SetURI sets the file referred to by @uri as the current file for the file
	// chooser, by changing to the URI’s parent folder and actually selecting
	// the URI in the list. If the @chooser is GTK_FILE_CHOOSER_ACTION_SAVE
	// mode, the URI’s base name will also appear in the dialog’s file name
	// entry.
	//
	// Note that the URI must exist, or nothing will be done except for the
	// directory change.
	//
	// You should use this function only when implementing a save dialog for
	// which you already have a file name to which the user may save. For
	// example, when the user opens an existing file and then does Save As... to
	// save a copy or a modified version. If you don’t have a file name already
	// — for example, if the user just created a new file and is saving it for
	// the first time, do not call this function. Instead, use something similar
	// to this:
	//
	//    if (document_is_new)
	//      {
	//        // the user just created a new document
	//        gtk_file_chooser_set_current_name (chooser, "Untitled document");
	//      }
	//    else
	//      {
	//        // the user edited an existing document
	//        gtk_file_chooser_set_uri (chooser, existing_uri);
	//      }
	//
	// In the first case, the file chooser will present the user with useful
	// suggestions as to where to save his new file. In the second case, the
	// file’s existing location is already known, so the file chooser will use
	// it.
	SetURI(uri string) bool
	// SetUsePreviewLabel sets whether the file chooser should display a stock
	// label with the name of the file that is being previewed; the default is
	// true. Applications that want to draw the whole preview area themselves
	// should set this to false and display the name themselves in their preview
	// widget.
	//
	// See also: gtk_file_chooser_set_preview_widget()
	SetUsePreviewLabel(useLabel bool)
	// UnselectAll unselects all the files in the current folder of a file
	// chooser.
	UnselectAll()
	// UnselectFile unselects the file referred to by @file. If the file is not
	// in the current directory, does not exist, or is otherwise not currently
	// selected, does nothing.
	UnselectFile(file gio.File)
	// UnselectFilename unselects a currently selected filename. If the filename
	// is not in the current directory, does not exist, or is otherwise not
	// currently selected, does nothing.
	UnselectFilename(filename string)
	// UnselectURI unselects the file referred to by @uri. If the file is not in
	// the current directory, does not exist, or is otherwise not currently
	// selected, does nothing.
	UnselectURI(uri string)
}

// fileChooser implements the FileChooser interface.
type fileChooser struct {
	gextras.Objector
}

var _ FileChooser = (*fileChooser)(nil)

// WrapFileChooser wraps a GObject to a type that implements interface
// FileChooser. It is primarily used internally.
func WrapFileChooser(obj *externglib.Object) FileChooser {
	return FileChooser{
		Objector: obj,
	}
}

func marshalFileChooser(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileChooser(obj), nil
}

// AddChoice adds a 'choice' to the file chooser. This is typically
// implemented as a combobox or, for boolean choices, as a checkbutton. You
// can select a value using gtk_file_chooser_set_choice() before the dialog
// is shown, and you can obtain the user-selected value in the ::response
// signal handler using gtk_file_chooser_get_choice().
//
// Compare gtk_file_chooser_set_extra_widget().
func (c fileChooser) AddChoice(id string, label string, options []string, optionLabels []string) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char
	var arg2 *C.char
	var arg3 **C.char
	var arg4 **C.char

	arg0 = (*C.GtkFileChooser)(c.Native())
	arg1 = (*C.gchar)(C.CString(id))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg2))
	{
		var dst []*C.char
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(options) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(options)
		sliceHeader.Cap = len(options)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(options); i++ {
			src := options[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg3 = (**C.char)(unsafe.Pointer(ptr))
	}
	{
		var dst []*C.char
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(optionLabels) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(optionLabels)
		sliceHeader.Cap = len(optionLabels)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(optionLabels); i++ {
			src := optionLabels[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg4 = (**C.char)(unsafe.Pointer(ptr))
	}

	C.gtk_file_chooser_add_choice(arg0, arg1, arg2, arg3, arg4)
}

// AddFilter adds @filter to the list of filters that the user can select
// between. When a filter is selected, only files that are passed by that
// filter are displayed.
//
// Note that the @chooser takes ownership of the filter, so you have to ref
// and sink it if you want to keep a reference.
func (c fileChooser) AddFilter(filter FileFilter) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.GtkFileFilter

	arg0 = (*C.GtkFileChooser)(c.Native())
	arg1 = (*C.GtkFileFilter)(filter.Native())

	C.gtk_file_chooser_add_filter(arg0, arg1)
}

// AddShortcutFolder adds a folder to be displayed with the shortcut folders
// in a file chooser. Note that shortcut folders do not get saved, as they
// are provided by the application. For example, you can use this to add a
// “/usr/share/mydrawprogram/Clipart” folder to the volume list.
func (c fileChooser) AddShortcutFolder(folder string) error {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char
	var gError *C.GError

	arg0 = (*C.GtkFileChooser)(c.Native())
	arg1 = (*C.gchar)(C.CString(folder))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_file_chooser_add_shortcut_folder(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// AddShortcutFolderURI adds a folder URI to be displayed with the shortcut
// folders in a file chooser. Note that shortcut folders do not get saved,
// as they are provided by the application. For example, you can use this to
// add a “file:///usr/share/mydrawprogram/Clipart” folder to the volume
// list.
func (c fileChooser) AddShortcutFolderURI(uri string) error {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char
	var gError *C.GError

	arg0 = (*C.GtkFileChooser)(c.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_file_chooser_add_shortcut_folder_uri(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// Action gets the type of operation that the file chooser is performing;
// see gtk_file_chooser_set_action().
func (c fileChooser) Action() FileChooserAction {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(c.Native())

	ret := C.gtk_file_chooser_get_action(arg0)

	var ret0 FileChooserAction

	ret0 = FileChooserAction(ret)

	return ret0
}

// Choice gets the currently selected option in the 'choice' with the given
// ID.
func (c fileChooser) Choice(id string) string {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char

	arg0 = (*C.GtkFileChooser)(c.Native())
	arg1 = (*C.gchar)(C.CString(id))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_file_chooser_get_choice(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// CreateFolders gets whether file choser will offer to create new folders.
// See gtk_file_chooser_set_create_folders().
func (c fileChooser) CreateFolders() bool {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(c.Native())

	ret := C.gtk_file_chooser_get_create_folders(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// CurrentFolder gets the current folder of @chooser as a local filename.
// See gtk_file_chooser_set_current_folder().
//
// Note that this is the folder that the file chooser is currently
// displaying (e.g. "/home/username/Documents"), which is not the same as
// the currently-selected folder if the chooser is in
// GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER mode (e.g.
// "/home/username/Documents/selected-folder/". To get the
// currently-selected folder in that mode, use gtk_file_chooser_get_uri() as
// the usual way to get the selection.
func (c fileChooser) CurrentFolder() string {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(c.Native())

	ret := C.gtk_file_chooser_get_current_folder(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// CurrentFolderFile gets the current folder of @chooser as #GFile. See
// gtk_file_chooser_get_current_folder_uri().
func (c fileChooser) CurrentFolderFile() gio.File {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(c.Native())

	ret := C.gtk_file_chooser_get_current_folder_file(arg0)

	var ret0 gio.File

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gio.File)

	return ret0
}

// CurrentFolderURI gets the current folder of @chooser as an URI. See
// gtk_file_chooser_set_current_folder_uri().
//
// Note that this is the folder that the file chooser is currently
// displaying (e.g. "file:///home/username/Documents"), which is not the
// same as the currently-selected folder if the chooser is in
// GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER mode (e.g.
// "file:///home/username/Documents/selected-folder/". To get the
// currently-selected folder in that mode, use gtk_file_chooser_get_uri() as
// the usual way to get the selection.
func (c fileChooser) CurrentFolderURI() string {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(c.Native())

	ret := C.gtk_file_chooser_get_current_folder_uri(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// CurrentName gets the current name in the file selector, as entered by the
// user in the text entry for “Name”.
//
// This is meant to be used in save dialogs, to get the currently typed
// filename when the file itself does not exist yet. For example, an
// application that adds a custom extra widget to the file chooser for “file
// format” may want to change the extension of the typed filename based on
// the chosen format, say, from “.jpg” to “.png”.
func (c fileChooser) CurrentName() string {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(c.Native())

	ret := C.gtk_file_chooser_get_current_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// DoOverwriteConfirmation queries whether a file chooser is set to confirm
// for overwriting when the user types a file name that already exists.
func (c fileChooser) DoOverwriteConfirmation() bool {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(c.Native())

	ret := C.gtk_file_chooser_get_do_overwrite_confirmation(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// ExtraWidget gets the current extra widget; see
// gtk_file_chooser_set_extra_widget().
func (c fileChooser) ExtraWidget() Widget {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(c.Native())

	ret := C.gtk_file_chooser_get_extra_widget(arg0)

	var ret0 Widget

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Widget)

	return ret0
}

// File gets the #GFile for the currently selected file in the file
// selector. If multiple files are selected, one of the files will be
// returned at random.
//
// If the file chooser is in folder mode, this function returns the selected
// folder.
func (c fileChooser) File() gio.File {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(c.Native())

	ret := C.gtk_file_chooser_get_file(arg0)

	var ret0 gio.File

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gio.File)

	return ret0
}

// Filename gets the filename for the currently selected file in the file
// selector. The filename is returned as an absolute path. If multiple files
// are selected, one of the filenames will be returned at random.
//
// If the file chooser is in folder mode, this function returns the selected
// folder.
func (c fileChooser) Filename() string {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(c.Native())

	ret := C.gtk_file_chooser_get_filename(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Filenames lists all the selected files and subfolders in the current
// folder of @chooser. The returned names are full absolute paths. If files
// in the current folder cannot be represented as local filenames they will
// be ignored. (See gtk_file_chooser_get_uris())
func (c fileChooser) Filenames() *glib.SList {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(c.Native())

	ret := C.gtk_file_chooser_get_filenames(arg0)

	var ret0 *glib.SList

	{
		ret0 = glib.WrapSList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.SList) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Files lists all the selected files and subfolders in the current folder
// of @chooser as #GFile. An internal function, see
// gtk_file_chooser_get_uris().
func (c fileChooser) Files() *glib.SList {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(c.Native())

	ret := C.gtk_file_chooser_get_files(arg0)

	var ret0 *glib.SList

	{
		ret0 = glib.WrapSList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.SList) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Filter gets the current filter; see gtk_file_chooser_set_filter().
func (c fileChooser) Filter() FileFilter {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(c.Native())

	ret := C.gtk_file_chooser_get_filter(arg0)

	var ret0 FileFilter

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(FileFilter)

	return ret0
}

// LocalOnly gets whether only local files can be selected in the file
// selector. See gtk_file_chooser_set_local_only()
func (c fileChooser) LocalOnly() bool {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(c.Native())

	ret := C.gtk_file_chooser_get_local_only(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// PreviewFile gets the #GFile that should be previewed in a custom preview
// Internal function, see gtk_file_chooser_get_preview_uri().
func (c fileChooser) PreviewFile() gio.File {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(c.Native())

	ret := C.gtk_file_chooser_get_preview_file(arg0)

	var ret0 gio.File

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gio.File)

	return ret0
}

// PreviewFilename gets the filename that should be previewed in a custom
// preview widget. See gtk_file_chooser_set_preview_widget().
func (c fileChooser) PreviewFilename() string {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(c.Native())

	ret := C.gtk_file_chooser_get_preview_filename(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// PreviewURI gets the URI that should be previewed in a custom preview
// widget. See gtk_file_chooser_set_preview_widget().
func (c fileChooser) PreviewURI() string {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(c.Native())

	ret := C.gtk_file_chooser_get_preview_uri(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// PreviewWidget gets the current preview widget; see
// gtk_file_chooser_set_preview_widget().
func (c fileChooser) PreviewWidget() Widget {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(c.Native())

	ret := C.gtk_file_chooser_get_preview_widget(arg0)

	var ret0 Widget

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Widget)

	return ret0
}

// PreviewWidgetActive gets whether the preview widget set by
// gtk_file_chooser_set_preview_widget() should be shown for the current
// filename. See gtk_file_chooser_set_preview_widget_active().
func (c fileChooser) PreviewWidgetActive() bool {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(c.Native())

	ret := C.gtk_file_chooser_get_preview_widget_active(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// SelectMultiple gets whether multiple files can be selected in the file
// selector. See gtk_file_chooser_set_select_multiple().
func (c fileChooser) SelectMultiple() bool {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(c.Native())

	ret := C.gtk_file_chooser_get_select_multiple(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// ShowHidden gets whether hidden files and folders are displayed in the
// file selector. See gtk_file_chooser_set_show_hidden().
func (c fileChooser) ShowHidden() bool {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(c.Native())

	ret := C.gtk_file_chooser_get_show_hidden(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// URI gets the URI for the currently selected file in the file selector. If
// multiple files are selected, one of the filenames will be returned at
// random.
//
// If the file chooser is in folder mode, this function returns the selected
// folder.
func (c fileChooser) URI() string {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(c.Native())

	ret := C.gtk_file_chooser_get_uri(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Uris lists all the selected files and subfolders in the current folder of
// @chooser. The returned names are full absolute URIs.
func (c fileChooser) Uris() *glib.SList {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(c.Native())

	ret := C.gtk_file_chooser_get_uris(arg0)

	var ret0 *glib.SList

	{
		ret0 = glib.WrapSList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.SList) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// UsePreviewLabel gets whether a stock label should be drawn with the name
// of the previewed file. See gtk_file_chooser_set_use_preview_label().
func (c fileChooser) UsePreviewLabel() bool {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(c.Native())

	ret := C.gtk_file_chooser_get_use_preview_label(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// ListFilters lists the current set of user-selectable filters; see
// gtk_file_chooser_add_filter(), gtk_file_chooser_remove_filter().
func (c fileChooser) ListFilters() *glib.SList {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(c.Native())

	ret := C.gtk_file_chooser_list_filters(arg0)

	var ret0 *glib.SList

	{
		ret0 = glib.WrapSList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.SList) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// ListShortcutFolderUris queries the list of shortcut folders in the file
// chooser, as set by gtk_file_chooser_add_shortcut_folder_uri().
func (c fileChooser) ListShortcutFolderUris() *glib.SList {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(c.Native())

	ret := C.gtk_file_chooser_list_shortcut_folder_uris(arg0)

	var ret0 *glib.SList

	{
		ret0 = glib.WrapSList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.SList) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// ListShortcutFolders queries the list of shortcut folders in the file
// chooser, as set by gtk_file_chooser_add_shortcut_folder().
func (c fileChooser) ListShortcutFolders() *glib.SList {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(c.Native())

	ret := C.gtk_file_chooser_list_shortcut_folders(arg0)

	var ret0 *glib.SList

	{
		ret0 = glib.WrapSList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.SList) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// RemoveChoice removes a 'choice' that has been added with
// gtk_file_chooser_add_choice().
func (c fileChooser) RemoveChoice(id string) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char

	arg0 = (*C.GtkFileChooser)(c.Native())
	arg1 = (*C.gchar)(C.CString(id))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_file_chooser_remove_choice(arg0, arg1)
}

// RemoveFilter removes @filter from the list of filters that the user can
// select between.
func (c fileChooser) RemoveFilter(filter FileFilter) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.GtkFileFilter

	arg0 = (*C.GtkFileChooser)(c.Native())
	arg1 = (*C.GtkFileFilter)(filter.Native())

	C.gtk_file_chooser_remove_filter(arg0, arg1)
}

// RemoveShortcutFolder removes a folder from a file chooser’s list of
// shortcut folders.
func (c fileChooser) RemoveShortcutFolder(folder string) error {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char
	var gError *C.GError

	arg0 = (*C.GtkFileChooser)(c.Native())
	arg1 = (*C.gchar)(C.CString(folder))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_file_chooser_remove_shortcut_folder(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// RemoveShortcutFolderURI removes a folder URI from a file chooser’s list
// of shortcut folders.
func (c fileChooser) RemoveShortcutFolderURI(uri string) error {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char
	var gError *C.GError

	arg0 = (*C.GtkFileChooser)(c.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_file_chooser_remove_shortcut_folder_uri(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SelectAll selects all the files in the current folder of a file chooser.
func (c fileChooser) SelectAll() {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(c.Native())

	C.gtk_file_chooser_select_all(arg0)
}

// SelectFile selects the file referred to by @file. An internal function.
// See _gtk_file_chooser_select_uri().
func (c fileChooser) SelectFile(file gio.File) error {
	var arg0 *C.GtkFileChooser
	var arg1 *C.GFile
	var gError *C.GError

	arg0 = (*C.GtkFileChooser)(c.Native())
	arg1 = (*C.GFile)(file.Native())

	ret := C.gtk_file_chooser_select_file(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SelectFilename selects a filename. If the file name isn’t in the current
// folder of @chooser, then the current folder of @chooser will be changed
// to the folder containing @filename.
func (c fileChooser) SelectFilename(filename string) bool {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char

	arg0 = (*C.GtkFileChooser)(c.Native())
	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_file_chooser_select_filename(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// SelectURI selects the file to by @uri. If the URI doesn’t refer to a file
// in the current folder of @chooser, then the current folder of @chooser
// will be changed to the folder containing @filename.
func (c fileChooser) SelectURI(uri string) bool {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char

	arg0 = (*C.GtkFileChooser)(c.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_file_chooser_select_uri(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// SetAction sets the type of operation that the chooser is performing; the
// user interface is adapted to suit the selected action. For example, an
// option to create a new folder might be shown if the action is
// GTK_FILE_CHOOSER_ACTION_SAVE but not if the action is
// GTK_FILE_CHOOSER_ACTION_OPEN.
func (c fileChooser) SetAction(action FileChooserAction) {
	var arg0 *C.GtkFileChooser
	var arg1 C.GtkFileChooserAction

	arg0 = (*C.GtkFileChooser)(c.Native())
	arg1 = (C.GtkFileChooserAction)(action)

	C.gtk_file_chooser_set_action(arg0, arg1)
}

// SetChoice selects an option in a 'choice' that has been added with
// gtk_file_chooser_add_choice(). For a boolean choice, the possible options
// are "true" and "false".
func (c fileChooser) SetChoice(id string, option string) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char
	var arg2 *C.char

	arg0 = (*C.GtkFileChooser)(c.Native())
	arg1 = (*C.gchar)(C.CString(id))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(option))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_file_chooser_set_choice(arg0, arg1, arg2)
}

// SetCreateFolders sets whether file choser will offer to create new
// folders. This is only relevant if the action is not set to be
// GTK_FILE_CHOOSER_ACTION_OPEN.
func (c fileChooser) SetCreateFolders(createFolders bool) {
	var arg0 *C.GtkFileChooser
	var arg1 C.gboolean

	arg0 = (*C.GtkFileChooser)(c.Native())
	if createFolders {
		arg1 = C.TRUE
	}

	C.gtk_file_chooser_set_create_folders(arg0, arg1)
}

// SetCurrentFolder sets the current folder for @chooser from a local
// filename. The user will be shown the full contents of the current folder,
// plus user interface elements for navigating to other folders.
//
// In general, you should not use this function. See the [section on setting
// up a file chooser dialog][gtkfilechooserdialog-setting-up] for the
// rationale behind this.
func (c fileChooser) SetCurrentFolder(filename string) bool {
	var arg0 *C.GtkFileChooser
	var arg1 *C.gchar

	arg0 = (*C.GtkFileChooser)(c.Native())
	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_file_chooser_set_current_folder(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// SetCurrentFolderFile sets the current folder for @chooser from a #GFile.
// Internal function, see gtk_file_chooser_set_current_folder_uri().
func (c fileChooser) SetCurrentFolderFile(file gio.File) error {
	var arg0 *C.GtkFileChooser
	var arg1 *C.GFile
	var gError *C.GError

	arg0 = (*C.GtkFileChooser)(c.Native())
	arg1 = (*C.GFile)(file.Native())

	ret := C.gtk_file_chooser_set_current_folder_file(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SetCurrentFolderURI sets the current folder for @chooser from an URI. The
// user will be shown the full contents of the current folder, plus user
// interface elements for navigating to other folders.
//
// In general, you should not use this function. See the [section on setting
// up a file chooser dialog][gtkfilechooserdialog-setting-up] for the
// rationale behind this.
func (c fileChooser) SetCurrentFolderURI(uri string) bool {
	var arg0 *C.GtkFileChooser
	var arg1 *C.gchar

	arg0 = (*C.GtkFileChooser)(c.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_file_chooser_set_current_folder_uri(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// SetCurrentName sets the current name in the file selector, as if entered
// by the user. Note that the name passed in here is a UTF-8 string rather
// than a filename. This function is meant for such uses as a suggested name
// in a “Save As...” dialog. You can pass “Untitled.doc” or a similarly
// suitable suggestion for the @name.
//
// If you want to preselect a particular existing file, you should use
// gtk_file_chooser_set_filename() or gtk_file_chooser_set_uri() instead.
// Please see the documentation for those functions for an example of using
// gtk_file_chooser_set_current_name() as well.
func (c fileChooser) SetCurrentName(name string) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.gchar

	arg0 = (*C.GtkFileChooser)(c.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_file_chooser_set_current_name(arg0, arg1)
}

// SetDoOverwriteConfirmation sets whether a file chooser in
// GTK_FILE_CHOOSER_ACTION_SAVE mode will present a confirmation dialog if
// the user types a file name that already exists. This is false by default.
//
// If set to true, the @chooser will emit the FileChooser::confirm-overwrite
// signal when appropriate.
//
// If all you need is the stock confirmation dialog, set this property to
// true. You can override the way confirmation is done by actually handling
// the FileChooser::confirm-overwrite signal; please refer to its
// documentation for the details.
func (c fileChooser) SetDoOverwriteConfirmation(doOverwriteConfirmation bool) {
	var arg0 *C.GtkFileChooser
	var arg1 C.gboolean

	arg0 = (*C.GtkFileChooser)(c.Native())
	if doOverwriteConfirmation {
		arg1 = C.TRUE
	}

	C.gtk_file_chooser_set_do_overwrite_confirmation(arg0, arg1)
}

// SetExtraWidget sets an application-supplied widget to provide extra
// options to the user.
func (c fileChooser) SetExtraWidget(extraWidget Widget) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkFileChooser)(c.Native())
	arg1 = (*C.GtkWidget)(extraWidget.Native())

	C.gtk_file_chooser_set_extra_widget(arg0, arg1)
}

// SetFile sets @file as the current filename for the file chooser, by
// changing to the file’s parent folder and actually selecting the file in
// list. If the @chooser is in GTK_FILE_CHOOSER_ACTION_SAVE mode, the file’s
// base name will also appear in the dialog’s file name entry.
//
// If the file name isn’t in the current folder of @chooser, then the
// current folder of @chooser will be changed to the folder containing
// @filename. This is equivalent to a sequence of
// gtk_file_chooser_unselect_all() followed by
// gtk_file_chooser_select_filename().
//
// Note that the file must exist, or nothing will be done except for the
// directory change.
//
// If you are implementing a save dialog, you should use this function if
// you already have a file name to which the user may save; for example,
// when the user opens an existing file and then does Save As... If you
// don’t have a file name already — for example, if the user just created a
// new file and is saving it for the first time, do not call this function.
// Instead, use something similar to this:
//
//    if (document_is_new)
//      {
//        // the user just created a new document
//        gtk_file_chooser_set_current_folder_file (chooser, default_file_for_saving);
//        gtk_file_chooser_set_current_name (chooser, "Untitled document");
//      }
//    else
//      {
//        // the user edited an existing document
//        gtk_file_chooser_set_file (chooser, existing_file);
//      }
func (c fileChooser) SetFile(file gio.File) error {
	var arg0 *C.GtkFileChooser
	var arg1 *C.GFile
	var gError *C.GError

	arg0 = (*C.GtkFileChooser)(c.Native())
	arg1 = (*C.GFile)(file.Native())

	ret := C.gtk_file_chooser_set_file(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SetFilename sets @filename as the current filename for the file chooser,
// by changing to the file’s parent folder and actually selecting the file
// in list; all other files will be unselected. If the @chooser is in
// GTK_FILE_CHOOSER_ACTION_SAVE mode, the file’s base name will also appear
// in the dialog’s file name entry.
//
// Note that the file must exist, or nothing will be done except for the
// directory change.
//
// You should use this function only when implementing a save dialog for
// which you already have a file name to which the user may save. For
// example, when the user opens an existing file and then does Save As... to
// save a copy or a modified version. If you don’t have a file name already
// — for example, if the user just created a new file and is saving it for
// the first time, do not call this function. Instead, use something similar
// to this:
//
//    if (document_is_new)
//      {
//        // the user just created a new document
//        gtk_file_chooser_set_current_name (chooser, "Untitled document");
//      }
//    else
//      {
//        // the user edited an existing document
//        gtk_file_chooser_set_filename (chooser, existing_filename);
//      }
//
// In the first case, the file chooser will present the user with useful
// suggestions as to where to save his new file. In the second case, the
// file’s existing location is already known, so the file chooser will use
// it.
func (c fileChooser) SetFilename(filename string) bool {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char

	arg0 = (*C.GtkFileChooser)(c.Native())
	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_file_chooser_set_filename(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// SetFilter sets the current filter; only the files that pass the filter
// will be displayed. If the user-selectable list of filters is non-empty,
// then the filter should be one of the filters in that list. Setting the
// current filter when the list of filters is empty is useful if you want to
// restrict the displayed set of files without letting the user change it.
func (c fileChooser) SetFilter(filter FileFilter) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.GtkFileFilter

	arg0 = (*C.GtkFileChooser)(c.Native())
	arg1 = (*C.GtkFileFilter)(filter.Native())

	C.gtk_file_chooser_set_filter(arg0, arg1)
}

// SetLocalOnly sets whether only local files can be selected in the file
// selector. If @local_only is true (the default), then the selected file or
// files are guaranteed to be accessible through the operating systems
// native file system and therefore the application only needs to worry
// about the filename functions in FileChooser, like
// gtk_file_chooser_get_filename(), rather than the URI functions like
// gtk_file_chooser_get_uri(),
//
// On some systems non-native files may still be available using the native
// filesystem via a userspace filesystem (FUSE).
func (c fileChooser) SetLocalOnly(localOnly bool) {
	var arg0 *C.GtkFileChooser
	var arg1 C.gboolean

	arg0 = (*C.GtkFileChooser)(c.Native())
	if localOnly {
		arg1 = C.TRUE
	}

	C.gtk_file_chooser_set_local_only(arg0, arg1)
}

// SetPreviewWidget sets an application-supplied widget to use to display a
// custom preview of the currently selected file. To implement a preview,
// after setting the preview widget, you connect to the
// FileChooser::update-preview signal, and call
// gtk_file_chooser_get_preview_filename() or
// gtk_file_chooser_get_preview_uri() on each change. If you can display a
// preview of the new file, update your widget and set the preview active
// using gtk_file_chooser_set_preview_widget_active(). Otherwise, set the
// preview inactive.
//
// When there is no application-supplied preview widget, or the
// application-supplied preview widget is not active, the file chooser will
// display no preview at all.
func (c fileChooser) SetPreviewWidget(previewWidget Widget) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkFileChooser)(c.Native())
	arg1 = (*C.GtkWidget)(previewWidget.Native())

	C.gtk_file_chooser_set_preview_widget(arg0, arg1)
}

// SetPreviewWidgetActive sets whether the preview widget set by
// gtk_file_chooser_set_preview_widget() should be shown for the current
// filename. When @active is set to false, the file chooser may display an
// internally generated preview of the current file or it may display no
// preview at all. See gtk_file_chooser_set_preview_widget() for more
// details.
func (c fileChooser) SetPreviewWidgetActive(active bool) {
	var arg0 *C.GtkFileChooser
	var arg1 C.gboolean

	arg0 = (*C.GtkFileChooser)(c.Native())
	if active {
		arg1 = C.TRUE
	}

	C.gtk_file_chooser_set_preview_widget_active(arg0, arg1)
}

// SetSelectMultiple sets whether multiple files can be selected in the file
// selector. This is only relevant if the action is set to be
// GTK_FILE_CHOOSER_ACTION_OPEN or GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER.
func (c fileChooser) SetSelectMultiple(selectMultiple bool) {
	var arg0 *C.GtkFileChooser
	var arg1 C.gboolean

	arg0 = (*C.GtkFileChooser)(c.Native())
	if selectMultiple {
		arg1 = C.TRUE
	}

	C.gtk_file_chooser_set_select_multiple(arg0, arg1)
}

// SetShowHidden sets whether hidden files and folders are displayed in the
// file selector.
func (c fileChooser) SetShowHidden(showHidden bool) {
	var arg0 *C.GtkFileChooser
	var arg1 C.gboolean

	arg0 = (*C.GtkFileChooser)(c.Native())
	if showHidden {
		arg1 = C.TRUE
	}

	C.gtk_file_chooser_set_show_hidden(arg0, arg1)
}

// SetURI sets the file referred to by @uri as the current file for the file
// chooser, by changing to the URI’s parent folder and actually selecting
// the URI in the list. If the @chooser is GTK_FILE_CHOOSER_ACTION_SAVE
// mode, the URI’s base name will also appear in the dialog’s file name
// entry.
//
// Note that the URI must exist, or nothing will be done except for the
// directory change.
//
// You should use this function only when implementing a save dialog for
// which you already have a file name to which the user may save. For
// example, when the user opens an existing file and then does Save As... to
// save a copy or a modified version. If you don’t have a file name already
// — for example, if the user just created a new file and is saving it for
// the first time, do not call this function. Instead, use something similar
// to this:
//
//    if (document_is_new)
//      {
//        // the user just created a new document
//        gtk_file_chooser_set_current_name (chooser, "Untitled document");
//      }
//    else
//      {
//        // the user edited an existing document
//        gtk_file_chooser_set_uri (chooser, existing_uri);
//      }
//
// In the first case, the file chooser will present the user with useful
// suggestions as to where to save his new file. In the second case, the
// file’s existing location is already known, so the file chooser will use
// it.
func (c fileChooser) SetURI(uri string) bool {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char

	arg0 = (*C.GtkFileChooser)(c.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_file_chooser_set_uri(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// SetUsePreviewLabel sets whether the file chooser should display a stock
// label with the name of the file that is being previewed; the default is
// true. Applications that want to draw the whole preview area themselves
// should set this to false and display the name themselves in their preview
// widget.
//
// See also: gtk_file_chooser_set_preview_widget()
func (c fileChooser) SetUsePreviewLabel(useLabel bool) {
	var arg0 *C.GtkFileChooser
	var arg1 C.gboolean

	arg0 = (*C.GtkFileChooser)(c.Native())
	if useLabel {
		arg1 = C.TRUE
	}

	C.gtk_file_chooser_set_use_preview_label(arg0, arg1)
}

// UnselectAll unselects all the files in the current folder of a file
// chooser.
func (c fileChooser) UnselectAll() {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(c.Native())

	C.gtk_file_chooser_unselect_all(arg0)
}

// UnselectFile unselects the file referred to by @file. If the file is not
// in the current directory, does not exist, or is otherwise not currently
// selected, does nothing.
func (c fileChooser) UnselectFile(file gio.File) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.GFile

	arg0 = (*C.GtkFileChooser)(c.Native())
	arg1 = (*C.GFile)(file.Native())

	C.gtk_file_chooser_unselect_file(arg0, arg1)
}

// UnselectFilename unselects a currently selected filename. If the filename
// is not in the current directory, does not exist, or is otherwise not
// currently selected, does nothing.
func (c fileChooser) UnselectFilename(filename string) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char

	arg0 = (*C.GtkFileChooser)(c.Native())
	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_file_chooser_unselect_filename(arg0, arg1)
}

// UnselectURI unselects the file referred to by @uri. If the file is not in
// the current directory, does not exist, or is otherwise not currently
// selected, does nothing.
func (c fileChooser) UnselectURI(uri string) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char

	arg0 = (*C.GtkFileChooser)(c.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_file_chooser_unselect_uri(arg0, arg1)
}

// Clipboard: the Clipboard object represents a clipboard of data shared between
// different processes or between different widgets in the same process. Each
// clipboard is identified by a name encoded as a Atom. (Conversion to and from
// strings can be done with gdk_atom_intern() and gdk_atom_name().) The default
// clipboard corresponds to the “CLIPBOARD” atom; another commonly used
// clipboard is the “PRIMARY” clipboard, which, in X, traditionally contains the
// currently selected text.
//
// To support having a number of different formats on the clipboard at the same
// time, the clipboard mechanism allows providing callbacks instead of the
// actual data. When you set the contents of the clipboard, you can either
// supply the data directly (via functions like gtk_clipboard_set_text()), or
// you can supply a callback to be called at a later time when the data is
// needed (via gtk_clipboard_set_with_data() or gtk_clipboard_set_with_owner().)
// Providing a callback also avoids having to make copies of the data when it is
// not needed.
//
// gtk_clipboard_set_with_data() and gtk_clipboard_set_with_owner() are quite
// similar; the choice between the two depends mostly on which is more
// convenient in a particular situation. The former is most useful when you want
// to have a blob of data with callbacks to convert it into the various data
// types that you advertise. When the @clear_func you provided is called, you
// simply free the data blob. The latter is more useful when the contents of
// clipboard reflect the internal state of a #GObject (As an example, for the
// PRIMARY clipboard, when an entry widget provides the clipboard’s contents the
// contents are simply the text within the selected region.) If the contents
// change, the entry widget can call gtk_clipboard_set_with_owner() to update
// the timestamp for clipboard ownership, without having to worry about
// @clear_func being called.
//
// Requesting the data from the clipboard is essentially asynchronous. If the
// contents of the clipboard are provided within the same process, then a direct
// function call will be made to retrieve the data, but if they are provided by
// another process, then the data needs to be retrieved from the other process,
// which may take some time. To avoid blocking the user interface, the call to
// request the selection, gtk_clipboard_request_contents() takes a callback that
// will be called when the contents are received (or when the request fails.) If
// you don’t want to deal with providing a separate callback, you can also use
// gtk_clipboard_wait_for_contents(). What this does is run the GLib main loop
// recursively waiting for the contents. This can simplify the code flow, but
// you still have to be aware that other callbacks in your program can be called
// while this recursive mainloop is running.
//
// Along with the functions to get the clipboard contents as an arbitrary data
// chunk, there are also functions to retrieve it as text,
// gtk_clipboard_request_text() and gtk_clipboard_wait_for_text(). These
// functions take care of determining which formats are advertised by the
// clipboard provider, asking for the clipboard in the best available format and
// converting the results into the UTF-8 encoding. (The standard form for
// representing strings in GTK+.)
type Clipboard interface {
	gextras.Objector

	// Clear clears the contents of the clipboard. Generally this should only be
	// called between the time you call gtk_clipboard_set_with_owner() or
	// gtk_clipboard_set_with_data(), and when the @clear_func you supplied is
	// called. Otherwise, the clipboard may be owned by someone else.
	Clear()
	// Display gets the Display associated with @clipboard
	Display() gdk.Display
	// Owner: if the clipboard contents callbacks were set with
	// gtk_clipboard_set_with_owner(), and the gtk_clipboard_set_with_data() or
	// gtk_clipboard_clear() has not subsequently called, returns the owner set
	// by gtk_clipboard_set_with_owner().
	Owner() gextras.Objector
	// Selection gets the selection that this clipboard is for.
	Selection() gdk.Atom
	// RequestContents requests the contents of clipboard as the given target.
	// When the results of the result are later received the supplied callback
	// will be called.
	RequestContents(target gdk.Atom, callback ClipboardReceivedFunc)
	// RequestImage requests the contents of the clipboard as image. When the
	// image is later received, it will be converted to a Pixbuf, and @callback
	// will be called.
	//
	// The @pixbuf parameter to @callback will contain the resulting Pixbuf if
	// the request succeeded, or nil if it failed. This could happen for various
	// reasons, in particular if the clipboard was empty or if the contents of
	// the clipboard could not be converted into an image.
	RequestImage(callback ClipboardImageReceivedFunc)
	// RequestRichText requests the contents of the clipboard as rich text. When
	// the rich text is later received, @callback will be called.
	//
	// The @text parameter to @callback will contain the resulting rich text if
	// the request succeeded, or nil if it failed. The @length parameter will
	// contain @text’s length. This function can fail for various reasons, in
	// particular if the clipboard was empty or if the contents of the clipboard
	// could not be converted into rich text form.
	RequestRichText(buffer TextBuffer, callback ClipboardRichTextReceivedFunc)
	// RequestTargets requests the contents of the clipboard as list of
	// supported targets. When the list is later received, @callback will be
	// called.
	//
	// The @targets parameter to @callback will contain the resulting targets if
	// the request succeeded, or nil if it failed.
	RequestTargets(callback ClipboardTargetsReceivedFunc)
	// RequestText requests the contents of the clipboard as text. When the text
	// is later received, it will be converted to UTF-8 if necessary, and
	// @callback will be called.
	//
	// The @text parameter to @callback will contain the resulting text if the
	// request succeeded, or nil if it failed. This could happen for various
	// reasons, in particular if the clipboard was empty or if the contents of
	// the clipboard could not be converted into text form.
	RequestText(callback ClipboardTextReceivedFunc)
	// RequestUris requests the contents of the clipboard as URIs. When the URIs
	// are later received @callback will be called.
	//
	// The @uris parameter to @callback will contain the resulting array of URIs
	// if the request succeeded, or nil if it failed. This could happen for
	// various reasons, in particular if the clipboard was empty or if the
	// contents of the clipboard could not be converted into URI form.
	RequestUris(callback ClipboardURIReceivedFunc)
	// SetCanStore hints that the clipboard data should be stored somewhere when
	// the application exits or when gtk_clipboard_store () is called.
	//
	// This value is reset when the clipboard owner changes. Where the clipboard
	// data is stored is platform dependent, see gdk_display_store_clipboard ()
	// for more information.
	SetCanStore(targets []TargetEntry)
	// SetImage sets the contents of the clipboard to the given Pixbuf. GTK+
	// will take responsibility for responding for requests for the image, and
	// for converting the image into the requested format.
	SetImage(pixbuf gdkpixbuf.Pixbuf)
	// SetText sets the contents of the clipboard to the given UTF-8 string.
	// GTK+ will make a copy of the text and take responsibility for responding
	// for requests for the text, and for converting the text into the requested
	// format.
	SetText(text string, len int)
	// Store stores the current clipboard data somewhere so that it will stay
	// around after the application has quit.
	Store()
	// WaitForContents requests the contents of the clipboard using the given
	// target. This function waits for the data to be received using the main
	// loop, so events, timeouts, etc, may be dispatched during the wait.
	WaitForContents(target gdk.Atom) *SelectionData
	// WaitForImage requests the contents of the clipboard as image and converts
	// the result to a Pixbuf. This function waits for the data to be received
	// using the main loop, so events, timeouts, etc, may be dispatched during
	// the wait.
	WaitForImage() gdkpixbuf.Pixbuf
	// WaitForRichText requests the contents of the clipboard as rich text. This
	// function waits for the data to be received using the main loop, so
	// events, timeouts, etc, may be dispatched during the wait.
	WaitForRichText(buffer TextBuffer) (format gdk.Atom, length uint, guint8s []byte)
	// WaitForTargets returns a list of targets that are present on the
	// clipboard, or nil if there aren’t any targets available. The returned
	// list must be freed with g_free(). This function waits for the data to be
	// received using the main loop, so events, timeouts, etc, may be dispatched
	// during the wait.
	WaitForTargets() (targets []*gdk.Atom, nTargets int, ok bool)
	// WaitForText requests the contents of the clipboard as text and converts
	// the result to UTF-8 if necessary. This function waits for the data to be
	// received using the main loop, so events, timeouts, etc, may be dispatched
	// during the wait.
	WaitForText() string
	// WaitForUris requests the contents of the clipboard as URIs. This function
	// waits for the data to be received using the main loop, so events,
	// timeouts, etc, may be dispatched during the wait.
	WaitForUris() []string
	// WaitIsImageAvailable: test to see if there is an image available to be
	// pasted This is done by requesting the TARGETS atom and checking if it
	// contains any of the supported image targets. This function waits for the
	// data to be received using the main loop, so events, timeouts, etc, may be
	// dispatched during the wait.
	//
	// This function is a little faster than calling
	// gtk_clipboard_wait_for_image() since it doesn’t need to retrieve the
	// actual image data.
	WaitIsImageAvailable() bool
	// WaitIsRichTextAvailable: test to see if there is rich text available to
	// be pasted This is done by requesting the TARGETS atom and checking if it
	// contains any of the supported rich text targets. This function waits for
	// the data to be received using the main loop, so events, timeouts, etc,
	// may be dispatched during the wait.
	//
	// This function is a little faster than calling
	// gtk_clipboard_wait_for_rich_text() since it doesn’t need to retrieve the
	// actual text.
	WaitIsRichTextAvailable(buffer TextBuffer) bool
	// WaitIsTargetAvailable checks if a clipboard supports pasting data of a
	// given type. This function can be used to determine if a “Paste” menu item
	// should be insensitive or not.
	//
	// If you want to see if there’s text available on the clipboard, use
	// gtk_clipboard_wait_is_text_available () instead.
	WaitIsTargetAvailable(target gdk.Atom) bool
	// WaitIsTextAvailable: test to see if there is text available to be pasted
	// This is done by requesting the TARGETS atom and checking if it contains
	// any of the supported text targets. This function waits for the data to be
	// received using the main loop, so events, timeouts, etc, may be dispatched
	// during the wait.
	//
	// This function is a little faster than calling
	// gtk_clipboard_wait_for_text() since it doesn’t need to retrieve the
	// actual text.
	WaitIsTextAvailable() bool
	// WaitIsUrisAvailable: test to see if there is a list of URIs available to
	// be pasted This is done by requesting the TARGETS atom and checking if it
	// contains the URI targets. This function waits for the data to be received
	// using the main loop, so events, timeouts, etc, may be dispatched during
	// the wait.
	//
	// This function is a little faster than calling
	// gtk_clipboard_wait_for_uris() since it doesn’t need to retrieve the
	// actual URI data.
	WaitIsUrisAvailable() bool
}

// clipboard implements the Clipboard interface.
type clipboard struct {
	gextras.Objector
}

var _ Clipboard = (*clipboard)(nil)

// WrapClipboard wraps a GObject to the right type. It is
// primarily used internally.
func WrapClipboard(obj *externglib.Object) Clipboard {
	return Clipboard{
		Objector: obj,
	}
}

func marshalClipboard(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapClipboard(obj), nil
}

// Clear clears the contents of the clipboard. Generally this should only be
// called between the time you call gtk_clipboard_set_with_owner() or
// gtk_clipboard_set_with_data(), and when the @clear_func you supplied is
// called. Otherwise, the clipboard may be owned by someone else.
func (c clipboard) Clear() {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(c.Native())

	C.gtk_clipboard_clear(arg0)
}

// Display gets the Display associated with @clipboard
func (c clipboard) Display() gdk.Display {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(c.Native())

	ret := C.gtk_clipboard_get_display(arg0)

	var ret0 gdk.Display

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gdk.Display)

	return ret0
}

// Owner: if the clipboard contents callbacks were set with
// gtk_clipboard_set_with_owner(), and the gtk_clipboard_set_with_data() or
// gtk_clipboard_clear() has not subsequently called, returns the owner set
// by gtk_clipboard_set_with_owner().
func (c clipboard) Owner() gextras.Objector {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(c.Native())

	ret := C.gtk_clipboard_get_owner(arg0)

	var ret0 gextras.Objector

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gextras.Objector)

	return ret0
}

// Selection gets the selection that this clipboard is for.
func (c clipboard) Selection() gdk.Atom {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(c.Native())

	ret := C.gtk_clipboard_get_selection(arg0)

	var ret0 gdk.Atom

	{
		ret0 = gdk.WrapAtom(unsafe.Pointer(ret))
	}

	return ret0
}

// RequestContents requests the contents of clipboard as the given target.
// When the results of the result are later received the supplied callback
// will be called.
func (c clipboard) RequestContents(target gdk.Atom, callback ClipboardReceivedFunc) {
	var arg0 *C.GtkClipboard
	var arg1 C.GdkAtom
	var arg2 C.GtkClipboardReceivedFunc
	var arg3 C.gpointer

	arg0 = (*C.GtkClipboard)(c.Native())
	arg1 = (C.GdkAtom)(target.Native())
	arg2 = (*[0]byte)(C.gotk4_ClipboardReceivedFunc)
	arg3 = C.gpointer(box.Assign(callback))

	C.gtk_clipboard_request_contents(arg0, arg1, arg2, arg3)
}

// RequestImage requests the contents of the clipboard as image. When the
// image is later received, it will be converted to a Pixbuf, and @callback
// will be called.
//
// The @pixbuf parameter to @callback will contain the resulting Pixbuf if
// the request succeeded, or nil if it failed. This could happen for various
// reasons, in particular if the clipboard was empty or if the contents of
// the clipboard could not be converted into an image.
func (c clipboard) RequestImage(callback ClipboardImageReceivedFunc) {
	var arg0 *C.GtkClipboard
	var arg1 C.GtkClipboardImageReceivedFunc
	var arg2 C.gpointer

	arg0 = (*C.GtkClipboard)(c.Native())
	arg1 = (*[0]byte)(C.gotk4_ClipboardImageReceivedFunc)
	arg2 = C.gpointer(box.Assign(callback))

	C.gtk_clipboard_request_image(arg0, arg1, arg2)
}

// RequestRichText requests the contents of the clipboard as rich text. When
// the rich text is later received, @callback will be called.
//
// The @text parameter to @callback will contain the resulting rich text if
// the request succeeded, or nil if it failed. The @length parameter will
// contain @text’s length. This function can fail for various reasons, in
// particular if the clipboard was empty or if the contents of the clipboard
// could not be converted into rich text form.
func (c clipboard) RequestRichText(buffer TextBuffer, callback ClipboardRichTextReceivedFunc) {
	var arg0 *C.GtkClipboard
	var arg1 *C.GtkTextBuffer
	var arg2 C.GtkClipboardRichTextReceivedFunc
	var arg3 C.gpointer

	arg0 = (*C.GtkClipboard)(c.Native())
	arg1 = (*C.GtkTextBuffer)(buffer.Native())
	arg2 = (*[0]byte)(C.gotk4_ClipboardRichTextReceivedFunc)
	arg3 = C.gpointer(box.Assign(callback))

	C.gtk_clipboard_request_rich_text(arg0, arg1, arg2, arg3)
}

// RequestTargets requests the contents of the clipboard as list of
// supported targets. When the list is later received, @callback will be
// called.
//
// The @targets parameter to @callback will contain the resulting targets if
// the request succeeded, or nil if it failed.
func (c clipboard) RequestTargets(callback ClipboardTargetsReceivedFunc) {
	var arg0 *C.GtkClipboard
	var arg1 C.GtkClipboardTargetsReceivedFunc
	var arg2 C.gpointer

	arg0 = (*C.GtkClipboard)(c.Native())
	arg1 = (*[0]byte)(C.gotk4_ClipboardTargetsReceivedFunc)
	arg2 = C.gpointer(box.Assign(callback))

	C.gtk_clipboard_request_targets(arg0, arg1, arg2)
}

// RequestText requests the contents of the clipboard as text. When the text
// is later received, it will be converted to UTF-8 if necessary, and
// @callback will be called.
//
// The @text parameter to @callback will contain the resulting text if the
// request succeeded, or nil if it failed. This could happen for various
// reasons, in particular if the clipboard was empty or if the contents of
// the clipboard could not be converted into text form.
func (c clipboard) RequestText(callback ClipboardTextReceivedFunc) {
	var arg0 *C.GtkClipboard
	var arg1 C.GtkClipboardTextReceivedFunc
	var arg2 C.gpointer

	arg0 = (*C.GtkClipboard)(c.Native())
	arg1 = (*[0]byte)(C.gotk4_ClipboardTextReceivedFunc)
	arg2 = C.gpointer(box.Assign(callback))

	C.gtk_clipboard_request_text(arg0, arg1, arg2)
}

// RequestUris requests the contents of the clipboard as URIs. When the URIs
// are later received @callback will be called.
//
// The @uris parameter to @callback will contain the resulting array of URIs
// if the request succeeded, or nil if it failed. This could happen for
// various reasons, in particular if the clipboard was empty or if the
// contents of the clipboard could not be converted into URI form.
func (c clipboard) RequestUris(callback ClipboardURIReceivedFunc) {
	var arg0 *C.GtkClipboard
	var arg1 C.GtkClipboardURIReceivedFunc
	var arg2 C.gpointer

	arg0 = (*C.GtkClipboard)(c.Native())
	arg1 = (*[0]byte)(C.gotk4_ClipboardURIReceivedFunc)
	arg2 = C.gpointer(box.Assign(callback))

	C.gtk_clipboard_request_uris(arg0, arg1, arg2)
}

// SetCanStore hints that the clipboard data should be stored somewhere when
// the application exits or when gtk_clipboard_store () is called.
//
// This value is reset when the clipboard owner changes. Where the clipboard
// data is stored is platform dependent, see gdk_display_store_clipboard ()
// for more information.
func (c clipboard) SetCanStore(targets []TargetEntry) {
	var arg0 *C.GtkClipboard
	var arg1 *C.GtkTargetEntry
	var arg2 C.gint

	arg0 = (*C.GtkClipboard)(c.Native())
	{
		var dst []C.GtkTargetEntry
		ptr := C.malloc(C.sizeof_GtkTargetEntry * len(targets))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(targets)
		sliceHeader.Cap = len(targets)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(targets); i++ {
			src := targets[i]
			dst[i] = (C.GtkTargetEntry)(src.Native())
		}

		arg1 = (*C.GtkTargetEntry)(unsafe.Pointer(ptr))
		arg2 = len(targets)
	}

	C.gtk_clipboard_set_can_store(arg0, arg1, arg2)
}

// SetImage sets the contents of the clipboard to the given Pixbuf. GTK+
// will take responsibility for responding for requests for the image, and
// for converting the image into the requested format.
func (c clipboard) SetImage(pixbuf gdkpixbuf.Pixbuf) {
	var arg0 *C.GtkClipboard
	var arg1 *C.GdkPixbuf

	arg0 = (*C.GtkClipboard)(c.Native())
	arg1 = (*C.GdkPixbuf)(pixbuf.Native())

	C.gtk_clipboard_set_image(arg0, arg1)
}

// SetText sets the contents of the clipboard to the given UTF-8 string.
// GTK+ will make a copy of the text and take responsibility for responding
// for requests for the text, and for converting the text into the requested
// format.
func (c clipboard) SetText(text string, len int) {
	var arg0 *C.GtkClipboard
	var arg1 *C.gchar
	var arg2 C.gint

	arg0 = (*C.GtkClipboard)(c.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(len)

	C.gtk_clipboard_set_text(arg0, arg1, arg2)
}

// Store stores the current clipboard data somewhere so that it will stay
// around after the application has quit.
func (c clipboard) Store() {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(c.Native())

	C.gtk_clipboard_store(arg0)
}

// WaitForContents requests the contents of the clipboard using the given
// target. This function waits for the data to be received using the main
// loop, so events, timeouts, etc, may be dispatched during the wait.
func (c clipboard) WaitForContents(target gdk.Atom) *SelectionData {
	var arg0 *C.GtkClipboard
	var arg1 C.GdkAtom

	arg0 = (*C.GtkClipboard)(c.Native())
	arg1 = (C.GdkAtom)(target.Native())

	ret := C.gtk_clipboard_wait_for_contents(arg0, arg1)

	var ret0 *SelectionData

	{
		ret0 = WrapSelectionData(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *SelectionData) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// WaitForImage requests the contents of the clipboard as image and converts
// the result to a Pixbuf. This function waits for the data to be received
// using the main loop, so events, timeouts, etc, may be dispatched during
// the wait.
func (c clipboard) WaitForImage() gdkpixbuf.Pixbuf {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(c.Native())

	ret := C.gtk_clipboard_wait_for_image(arg0)

	var ret0 gdkpixbuf.Pixbuf

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gdkpixbuf.Pixbuf)

	return ret0
}

// WaitForRichText requests the contents of the clipboard as rich text. This
// function waits for the data to be received using the main loop, so
// events, timeouts, etc, may be dispatched during the wait.
func (c clipboard) WaitForRichText(buffer TextBuffer) (format gdk.Atom, length uint, guint8s []byte) {
	var arg0 *C.GtkClipboard
	var arg1 *C.GtkTextBuffer
	var arg2 *C.GdkAtom // out
	var arg3 *C.gsize   // out

	arg0 = (*C.GtkClipboard)(c.Native())
	arg1 = (*C.GtkTextBuffer)(buffer.Native())

	ret := C.gtk_clipboard_wait_for_rich_text(arg0, arg1, &arg2, &arg3)

	var ret0 *gdk.Atom
	var ret1 uint
	var ret2 []byte

	{
		ret0 = gdk.WrapAtom(unsafe.Pointer(arg2))
	}

	ret1 = uint(arg3)

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret2))
		sliceHeader.Data = uintptr(unsafe.Pointer(ret))
		sliceHeader.Len = arg3
		sliceHeader.Cap = arg3
		runtime.SetFinalizer(&ret, func() {
			C.free(unsafe.Pointer(ret))
		})
		defer runtime.KeepAlive(ret)
	}

	return ret0, ret1, ret2
}

// WaitForTargets returns a list of targets that are present on the
// clipboard, or nil if there aren’t any targets available. The returned
// list must be freed with g_free(). This function waits for the data to be
// received using the main loop, so events, timeouts, etc, may be dispatched
// during the wait.
func (c clipboard) WaitForTargets() (targets []*gdk.Atom, nTargets int, ok bool) {
	var arg0 *C.GtkClipboard
	var arg1 **C.GdkAtom // out
	var arg2 *C.gint     // out

	arg0 = (*C.GtkClipboard)(c.Native())

	ret := C.gtk_clipboard_wait_for_targets(arg0, &arg1, &arg2)

	var ret0 []*gdk.Atom
	var ret1 int
	var ret2 bool

	{
		ret0 = make([]*gdk.Atom, arg2)
		for i := 0; i < uintptr(arg2); i++ {
			src := (*C.GdkAtom)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			{
				ret0[i] = gdk.WrapAtom(unsafe.Pointer(src))
			}
		}
	}

	ret1 = int(arg2)

	ret2 = C.bool(ret) != C.false

	return ret0, ret1, ret2
}

// WaitForText requests the contents of the clipboard as text and converts
// the result to UTF-8 if necessary. This function waits for the data to be
// received using the main loop, so events, timeouts, etc, may be dispatched
// during the wait.
func (c clipboard) WaitForText() string {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(c.Native())

	ret := C.gtk_clipboard_wait_for_text(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// WaitForUris requests the contents of the clipboard as URIs. This function
// waits for the data to be received using the main loop, so events,
// timeouts, etc, may be dispatched during the wait.
func (c clipboard) WaitForUris() []string {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(c.Native())

	ret := C.gtk_clipboard_wait_for_uris(arg0)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// WaitIsImageAvailable: test to see if there is an image available to be
// pasted This is done by requesting the TARGETS atom and checking if it
// contains any of the supported image targets. This function waits for the
// data to be received using the main loop, so events, timeouts, etc, may be
// dispatched during the wait.
//
// This function is a little faster than calling
// gtk_clipboard_wait_for_image() since it doesn’t need to retrieve the
// actual image data.
func (c clipboard) WaitIsImageAvailable() bool {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(c.Native())

	ret := C.gtk_clipboard_wait_is_image_available(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// WaitIsRichTextAvailable: test to see if there is rich text available to
// be pasted This is done by requesting the TARGETS atom and checking if it
// contains any of the supported rich text targets. This function waits for
// the data to be received using the main loop, so events, timeouts, etc,
// may be dispatched during the wait.
//
// This function is a little faster than calling
// gtk_clipboard_wait_for_rich_text() since it doesn’t need to retrieve the
// actual text.
func (c clipboard) WaitIsRichTextAvailable(buffer TextBuffer) bool {
	var arg0 *C.GtkClipboard
	var arg1 *C.GtkTextBuffer

	arg0 = (*C.GtkClipboard)(c.Native())
	arg1 = (*C.GtkTextBuffer)(buffer.Native())

	ret := C.gtk_clipboard_wait_is_rich_text_available(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// WaitIsTargetAvailable checks if a clipboard supports pasting data of a
// given type. This function can be used to determine if a “Paste” menu item
// should be insensitive or not.
//
// If you want to see if there’s text available on the clipboard, use
// gtk_clipboard_wait_is_text_available () instead.
func (c clipboard) WaitIsTargetAvailable(target gdk.Atom) bool {
	var arg0 *C.GtkClipboard
	var arg1 C.GdkAtom

	arg0 = (*C.GtkClipboard)(c.Native())
	arg1 = (C.GdkAtom)(target.Native())

	ret := C.gtk_clipboard_wait_is_target_available(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// WaitIsTextAvailable: test to see if there is text available to be pasted
// This is done by requesting the TARGETS atom and checking if it contains
// any of the supported text targets. This function waits for the data to be
// received using the main loop, so events, timeouts, etc, may be dispatched
// during the wait.
//
// This function is a little faster than calling
// gtk_clipboard_wait_for_text() since it doesn’t need to retrieve the
// actual text.
func (c clipboard) WaitIsTextAvailable() bool {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(c.Native())

	ret := C.gtk_clipboard_wait_is_text_available(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// WaitIsUrisAvailable: test to see if there is a list of URIs available to
// be pasted This is done by requesting the TARGETS atom and checking if it
// contains the URI targets. This function waits for the data to be received
// using the main loop, so events, timeouts, etc, may be dispatched during
// the wait.
//
// This function is a little faster than calling
// gtk_clipboard_wait_for_uris() since it doesn’t need to retrieve the
// actual URI data.
func (c clipboard) WaitIsUrisAvailable() bool {
	var arg0 *C.GtkClipboard

	arg0 = (*C.GtkClipboard)(c.Native())

	ret := C.gtk_clipboard_wait_is_uris_available(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// FileFilter: a GtkFileFilter can be used to restrict the files being shown in
// a FileChooser. Files can be filtered based on their name (with
// gtk_file_filter_add_pattern()), on their mime type (with
// gtk_file_filter_add_mime_type()), or by a custom filter function (with
// gtk_file_filter_add_custom()).
//
// Filtering by mime types handles aliasing and subclassing of mime types; e.g.
// a filter for text/plain also matches a file with mime type application/rtf,
// since application/rtf is a subclass of text/plain. Note that FileFilter
// allows wildcards for the subtype of a mime type, so you can e.g. filter for
// image/\*.
//
// Normally, filters are used by adding them to a FileChooser, see
// gtk_file_chooser_add_filter(), but it is also possible to manually use a
// filter on a file with gtk_file_filter_filter().
//
//
// GtkFileFilter as GtkBuildable
//
// The GtkFileFilter implementation of the GtkBuildable interface supports
// adding rules using the <mime-types>, <patterns> and <applications> elements
// and listing the rules within. Specifying a <mime-type> or <pattern> has the
// same effect as as calling gtk_file_filter_add_mime_type() or
// gtk_file_filter_add_pattern().
//
// An example of a UI definition fragment specifying GtkFileFilter rules:
//
//    <object class="GtkFileFilter">
//      <mime-types>
//        <mime-type>text/plain</mime-type>
//        <mime-type>image/ *</mime-type>
//      </mime-types>
//      <patterns>
//        <pattern>*.txt</pattern>
//        <pattern>*.png</pattern>
//      </patterns>
//    </object>
type FileFilter interface {
	gextras.Objector
	Buildable

	// AddCustom adds rule to a filter that allows files based on a custom
	// callback function. The bitfield @needed which is passed in provides
	// information about what sorts of information that the filter function
	// needs; this allows GTK+ to avoid retrieving expensive information when it
	// isn’t needed by the filter.
	AddCustom(needed FileFilterFlags, fn FileFilterFunc)
	// AddMIMEType adds a rule allowing a given mime type to @filter.
	AddMIMEType(mimeType string)
	// AddPattern adds a rule allowing a shell style glob to a filter.
	AddPattern(pattern string)
	// AddPixbufFormats adds a rule allowing image files in the formats
	// supported by GdkPixbuf.
	AddPixbufFormats()
	// Filter tests whether a file should be displayed according to @filter. The
	// FileFilterInfo @filter_info should include the fields returned from
	// gtk_file_filter_get_needed().
	//
	// This function will not typically be used by applications; it is intended
	// principally for use in the implementation of FileChooser.
	Filter(filterInfo *FileFilterInfo) bool
	// Name gets the human-readable name for the filter. See
	// gtk_file_filter_set_name().
	Name() string
	// Needed gets the fields that need to be filled in for the FileFilterInfo
	// passed to gtk_file_filter_filter()
	//
	// This function will not typically be used by applications; it is intended
	// principally for use in the implementation of FileChooser.
	Needed() FileFilterFlags
	// SetName sets the human-readable name of the filter; this is the string
	// that will be displayed in the file selector user interface if there is a
	// selectable list of filters.
	SetName(name string)
	// ToGVariant: serialize a file filter to an a{sv} variant.
	ToGVariant() *glib.Variant
}

// fileFilter implements the FileFilter interface.
type fileFilter struct {
	gextras.Objector
	Buildable
}

var _ FileFilter = (*fileFilter)(nil)

// WrapFileFilter wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileFilter(obj *externglib.Object) FileFilter {
	return FileFilter{
		Objector:  obj,
		Buildable: WrapBuildable(obj),
	}
}

func marshalFileFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileFilter(obj), nil
}

// NewFileFilter constructs a class FileFilter.
func NewFileFilter() FileFilter {
	ret := C.gtk_file_filter_new()

	var ret0 FileFilter

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(FileFilter)

	return ret0
}

// NewFileFilterFromGVariant constructs a class FileFilter.
func NewFileFilterFromGVariant(variant *glib.Variant) FileFilter {
	var arg1 *C.GVariant

	arg1 = (*C.GVariant)(variant.Native())

	ret := C.gtk_file_filter_new_from_gvariant(arg1)

	var ret0 FileFilter

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(FileFilter)

	return ret0
}

// AddCustom adds rule to a filter that allows files based on a custom
// callback function. The bitfield @needed which is passed in provides
// information about what sorts of information that the filter function
// needs; this allows GTK+ to avoid retrieving expensive information when it
// isn’t needed by the filter.
func (f fileFilter) AddCustom(needed FileFilterFlags, fn FileFilterFunc) {
	var arg0 *C.GtkFileFilter
	var arg1 C.GtkFileFilterFlags
	var arg2 C.GtkFileFilterFunc
	var arg3 C.gpointer
	var arg4 C.GDestroyNotify

	arg0 = (*C.GtkFileFilter)(f.Native())
	arg1 = (C.GtkFileFilterFlags)(needed)
	arg2 = (*[0]byte)(C.gotk4_FileFilterFunc)
	arg3 = C.gpointer(box.Assign(fn))
	arg4 = (*[0]byte)(C.callbackDelete)

	C.gtk_file_filter_add_custom(arg0, arg1, arg2, arg3, arg4)
}

// AddMIMEType adds a rule allowing a given mime type to @filter.
func (f fileFilter) AddMIMEType(mimeType string) {
	var arg0 *C.GtkFileFilter
	var arg1 *C.gchar

	arg0 = (*C.GtkFileFilter)(f.Native())
	arg1 = (*C.gchar)(C.CString(mimeType))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_file_filter_add_mime_type(arg0, arg1)
}

// AddPattern adds a rule allowing a shell style glob to a filter.
func (f fileFilter) AddPattern(pattern string) {
	var arg0 *C.GtkFileFilter
	var arg1 *C.gchar

	arg0 = (*C.GtkFileFilter)(f.Native())
	arg1 = (*C.gchar)(C.CString(pattern))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_file_filter_add_pattern(arg0, arg1)
}

// AddPixbufFormats adds a rule allowing image files in the formats
// supported by GdkPixbuf.
func (f fileFilter) AddPixbufFormats() {
	var arg0 *C.GtkFileFilter

	arg0 = (*C.GtkFileFilter)(f.Native())

	C.gtk_file_filter_add_pixbuf_formats(arg0)
}

// Filter tests whether a file should be displayed according to @filter. The
// FileFilterInfo @filter_info should include the fields returned from
// gtk_file_filter_get_needed().
//
// This function will not typically be used by applications; it is intended
// principally for use in the implementation of FileChooser.
func (f fileFilter) Filter(filterInfo *FileFilterInfo) bool {
	var arg0 *C.GtkFileFilter
	var arg1 *C.GtkFileFilterInfo

	arg0 = (*C.GtkFileFilter)(f.Native())
	arg1 = (*C.GtkFileFilterInfo)(filterInfo.Native())

	ret := C.gtk_file_filter_filter(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// Name gets the human-readable name for the filter. See
// gtk_file_filter_set_name().
func (f fileFilter) Name() string {
	var arg0 *C.GtkFileFilter

	arg0 = (*C.GtkFileFilter)(f.Native())

	ret := C.gtk_file_filter_get_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Needed gets the fields that need to be filled in for the FileFilterInfo
// passed to gtk_file_filter_filter()
//
// This function will not typically be used by applications; it is intended
// principally for use in the implementation of FileChooser.
func (f fileFilter) Needed() FileFilterFlags {
	var arg0 *C.GtkFileFilter

	arg0 = (*C.GtkFileFilter)(f.Native())

	ret := C.gtk_file_filter_get_needed(arg0)

	var ret0 FileFilterFlags

	ret0 = FileFilterFlags(ret)

	return ret0
}

// SetName sets the human-readable name of the filter; this is the string
// that will be displayed in the file selector user interface if there is a
// selectable list of filters.
func (f fileFilter) SetName(name string) {
	var arg0 *C.GtkFileFilter
	var arg1 *C.gchar

	arg0 = (*C.GtkFileFilter)(f.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_file_filter_set_name(arg0, arg1)
}

// ToGVariant: serialize a file filter to an a{sv} variant.
func (f fileFilter) ToGVariant() *glib.Variant {
	var arg0 *C.GtkFileFilter

	arg0 = (*C.GtkFileFilter)(f.Native())

	ret := C.gtk_file_filter_to_gvariant(arg0)

	var ret0 *glib.Variant

	{
		ret0 = glib.WrapVariant(unsafe.Pointer(ret))
	}

	return ret0
}

// PageSetup: a GtkPageSetup object stores the page size, orientation and
// margins. The idea is that you can get one of these from the page setup dialog
// and then pass it to the PrintOperation when printing. The benefit of
// splitting this out of the PrintSettings is that these affect the actual
// layout of the page, and thus need to be set long before user prints.
//
//
// Margins
//
// The margins specified in this object are the “print margins”, i.e. the parts
// of the page that the printer cannot print on. These are different from the
// layout margins that a word processor uses; they are typically used to
// determine the minimal size for the layout margins.
//
// To obtain a PageSetup use gtk_page_setup_new() to get the defaults, or use
// gtk_print_run_page_setup_dialog() to show the page setup dialog and receive
// the resulting page setup.
//
// A page setup dialog
//
//    static GtkPrintSettings *settings = NULL;
//    static GtkPageSetup *page_setup = NULL;
//
//    static void
//    do_page_setup (void)
//    {
//      GtkPageSetup *new_page_setup;
//
//      if (settings == NULL)
//        settings = gtk_print_settings_new ();
//
//      new_page_setup = gtk_print_run_page_setup_dialog (GTK_WINDOW (main_window),
//                                                        page_setup, settings);
//
//      if (page_setup)
//        g_object_unref (page_setup);
//
//      page_setup = new_page_setup;
//    }
//
// Printing support was added in GTK+ 2.10.
type PageSetup interface {
	gextras.Objector

	// Copy copies a PageSetup.
	Copy() PageSetup
	// BottomMargin gets the bottom margin in units of @unit.
	BottomMargin(unit Unit) float64
	// LeftMargin gets the left margin in units of @unit.
	LeftMargin(unit Unit) float64
	// Orientation gets the page orientation of the PageSetup.
	Orientation() PageOrientation
	// PageHeight returns the page height in units of @unit.
	//
	// Note that this function takes orientation and margins into consideration.
	// See gtk_page_setup_get_paper_height().
	PageHeight(unit Unit) float64
	// PageWidth returns the page width in units of @unit.
	//
	// Note that this function takes orientation and margins into consideration.
	// See gtk_page_setup_get_paper_width().
	PageWidth(unit Unit) float64
	// PaperHeight returns the paper height in units of @unit.
	//
	// Note that this function takes orientation, but not margins into
	// consideration. See gtk_page_setup_get_page_height().
	PaperHeight(unit Unit) float64
	// PaperSize gets the paper size of the PageSetup.
	PaperSize() *PaperSize
	// PaperWidth returns the paper width in units of @unit.
	//
	// Note that this function takes orientation, but not margins into
	// consideration. See gtk_page_setup_get_page_width().
	PaperWidth(unit Unit) float64
	// RightMargin gets the right margin in units of @unit.
	RightMargin(unit Unit) float64
	// TopMargin gets the top margin in units of @unit.
	TopMargin(unit Unit) float64
	// LoadFile reads the page setup from the file @file_name. See
	// gtk_page_setup_to_file().
	LoadFile(fileName string) error
	// LoadKeyFile reads the page setup from the group @group_name in the key
	// file @key_file.
	LoadKeyFile(keyFile *glib.KeyFile, groupName string) error
	// SetBottomMargin sets the bottom margin of the PageSetup.
	SetBottomMargin(margin float64, unit Unit)
	// SetLeftMargin sets the left margin of the PageSetup.
	SetLeftMargin(margin float64, unit Unit)
	// SetOrientation sets the page orientation of the PageSetup.
	SetOrientation(orientation PageOrientation)
	// SetPaperSize sets the paper size of the PageSetup without changing the
	// margins. See gtk_page_setup_set_paper_size_and_default_margins().
	SetPaperSize(size *PaperSize)
	// SetPaperSizeAndDefaultMargins sets the paper size of the PageSetup and
	// modifies the margins according to the new paper size.
	SetPaperSizeAndDefaultMargins(size *PaperSize)
	// SetRightMargin sets the right margin of the PageSetup.
	SetRightMargin(margin float64, unit Unit)
	// SetTopMargin sets the top margin of the PageSetup.
	SetTopMargin(margin float64, unit Unit)
	// ToFile: this function saves the information from @setup to @file_name.
	ToFile(fileName string) error
	// ToGVariant: serialize page setup to an a{sv} variant.
	ToGVariant() *glib.Variant
	// ToKeyFile: this function adds the page setup from @setup to @key_file.
	ToKeyFile(keyFile *glib.KeyFile, groupName string)
}

// pageSetup implements the PageSetup interface.
type pageSetup struct {
	gextras.Objector
}

var _ PageSetup = (*pageSetup)(nil)

// WrapPageSetup wraps a GObject to the right type. It is
// primarily used internally.
func WrapPageSetup(obj *externglib.Object) PageSetup {
	return PageSetup{
		Objector: obj,
	}
}

func marshalPageSetup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPageSetup(obj), nil
}

// NewPageSetup constructs a class PageSetup.
func NewPageSetup() PageSetup {
	ret := C.gtk_page_setup_new()

	var ret0 PageSetup

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(PageSetup)

	return ret0
}

// NewPageSetupFromFile constructs a class PageSetup.
func NewPageSetupFromFile(fileName string) (pageSetup PageSetup, err error) {
	var arg1 *C.gchar
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_page_setup_new_from_file(arg1, &gError)

	var ret0 PageSetup
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(PageSetup)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// NewPageSetupFromGVariant constructs a class PageSetup.
func NewPageSetupFromGVariant(variant *glib.Variant) PageSetup {
	var arg1 *C.GVariant

	arg1 = (*C.GVariant)(variant.Native())

	ret := C.gtk_page_setup_new_from_gvariant(arg1)

	var ret0 PageSetup

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(PageSetup)

	return ret0
}

// NewPageSetupFromKeyFile constructs a class PageSetup.
func NewPageSetupFromKeyFile(keyFile *glib.KeyFile, groupName string) (pageSetup PageSetup, err error) {
	var arg1 *C.GKeyFile
	var arg2 *C.gchar
	var gError *C.GError

	arg1 = (*C.GKeyFile)(keyFile.Native())
	arg2 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_page_setup_new_from_key_file(arg1, arg2, &gError)

	var ret0 PageSetup
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(PageSetup)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Copy copies a PageSetup.
func (o pageSetup) Copy() PageSetup {
	var arg0 *C.GtkPageSetup

	arg0 = (*C.GtkPageSetup)(o.Native())

	ret := C.gtk_page_setup_copy(arg0)

	var ret0 PageSetup

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(PageSetup)

	return ret0
}

// BottomMargin gets the bottom margin in units of @unit.
func (s pageSetup) BottomMargin(unit Unit) float64 {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(s.Native())
	arg1 = (C.GtkUnit)(unit)

	ret := C.gtk_page_setup_get_bottom_margin(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// LeftMargin gets the left margin in units of @unit.
func (s pageSetup) LeftMargin(unit Unit) float64 {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(s.Native())
	arg1 = (C.GtkUnit)(unit)

	ret := C.gtk_page_setup_get_left_margin(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// Orientation gets the page orientation of the PageSetup.
func (s pageSetup) Orientation() PageOrientation {
	var arg0 *C.GtkPageSetup

	arg0 = (*C.GtkPageSetup)(s.Native())

	ret := C.gtk_page_setup_get_orientation(arg0)

	var ret0 PageOrientation

	ret0 = PageOrientation(ret)

	return ret0
}

// PageHeight returns the page height in units of @unit.
//
// Note that this function takes orientation and margins into consideration.
// See gtk_page_setup_get_paper_height().
func (s pageSetup) PageHeight(unit Unit) float64 {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(s.Native())
	arg1 = (C.GtkUnit)(unit)

	ret := C.gtk_page_setup_get_page_height(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// PageWidth returns the page width in units of @unit.
//
// Note that this function takes orientation and margins into consideration.
// See gtk_page_setup_get_paper_width().
func (s pageSetup) PageWidth(unit Unit) float64 {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(s.Native())
	arg1 = (C.GtkUnit)(unit)

	ret := C.gtk_page_setup_get_page_width(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// PaperHeight returns the paper height in units of @unit.
//
// Note that this function takes orientation, but not margins into
// consideration. See gtk_page_setup_get_page_height().
func (s pageSetup) PaperHeight(unit Unit) float64 {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(s.Native())
	arg1 = (C.GtkUnit)(unit)

	ret := C.gtk_page_setup_get_paper_height(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// PaperSize gets the paper size of the PageSetup.
func (s pageSetup) PaperSize() *PaperSize {
	var arg0 *C.GtkPageSetup

	arg0 = (*C.GtkPageSetup)(s.Native())

	ret := C.gtk_page_setup_get_paper_size(arg0)

	var ret0 *PaperSize

	{
		ret0 = WrapPaperSize(unsafe.Pointer(ret))
	}

	return ret0
}

// PaperWidth returns the paper width in units of @unit.
//
// Note that this function takes orientation, but not margins into
// consideration. See gtk_page_setup_get_page_width().
func (s pageSetup) PaperWidth(unit Unit) float64 {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(s.Native())
	arg1 = (C.GtkUnit)(unit)

	ret := C.gtk_page_setup_get_paper_width(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// RightMargin gets the right margin in units of @unit.
func (s pageSetup) RightMargin(unit Unit) float64 {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(s.Native())
	arg1 = (C.GtkUnit)(unit)

	ret := C.gtk_page_setup_get_right_margin(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// TopMargin gets the top margin in units of @unit.
func (s pageSetup) TopMargin(unit Unit) float64 {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(s.Native())
	arg1 = (C.GtkUnit)(unit)

	ret := C.gtk_page_setup_get_top_margin(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// LoadFile reads the page setup from the file @file_name. See
// gtk_page_setup_to_file().
func (s pageSetup) LoadFile(fileName string) error {
	var arg0 *C.GtkPageSetup
	var arg1 *C.char
	var gError *C.GError

	arg0 = (*C.GtkPageSetup)(s.Native())
	arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_page_setup_load_file(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// LoadKeyFile reads the page setup from the group @group_name in the key
// file @key_file.
func (s pageSetup) LoadKeyFile(keyFile *glib.KeyFile, groupName string) error {
	var arg0 *C.GtkPageSetup
	var arg1 *C.GKeyFile
	var arg2 *C.gchar
	var gError *C.GError

	arg0 = (*C.GtkPageSetup)(s.Native())
	arg1 = (*C.GKeyFile)(keyFile.Native())
	arg2 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_page_setup_load_key_file(arg0, arg1, arg2, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SetBottomMargin sets the bottom margin of the PageSetup.
func (s pageSetup) SetBottomMargin(margin float64, unit Unit) {
	var arg0 *C.GtkPageSetup
	var arg1 C.gdouble
	var arg2 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(s.Native())
	arg1 = C.gdouble(margin)
	arg2 = (C.GtkUnit)(unit)

	C.gtk_page_setup_set_bottom_margin(arg0, arg1, arg2)
}

// SetLeftMargin sets the left margin of the PageSetup.
func (s pageSetup) SetLeftMargin(margin float64, unit Unit) {
	var arg0 *C.GtkPageSetup
	var arg1 C.gdouble
	var arg2 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(s.Native())
	arg1 = C.gdouble(margin)
	arg2 = (C.GtkUnit)(unit)

	C.gtk_page_setup_set_left_margin(arg0, arg1, arg2)
}

// SetOrientation sets the page orientation of the PageSetup.
func (s pageSetup) SetOrientation(orientation PageOrientation) {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkPageOrientation

	arg0 = (*C.GtkPageSetup)(s.Native())
	arg1 = (C.GtkPageOrientation)(orientation)

	C.gtk_page_setup_set_orientation(arg0, arg1)
}

// SetPaperSize sets the paper size of the PageSetup without changing the
// margins. See gtk_page_setup_set_paper_size_and_default_margins().
func (s pageSetup) SetPaperSize(size *PaperSize) {
	var arg0 *C.GtkPageSetup
	var arg1 *C.GtkPaperSize

	arg0 = (*C.GtkPageSetup)(s.Native())
	arg1 = (*C.GtkPaperSize)(size.Native())

	C.gtk_page_setup_set_paper_size(arg0, arg1)
}

// SetPaperSizeAndDefaultMargins sets the paper size of the PageSetup and
// modifies the margins according to the new paper size.
func (s pageSetup) SetPaperSizeAndDefaultMargins(size *PaperSize) {
	var arg0 *C.GtkPageSetup
	var arg1 *C.GtkPaperSize

	arg0 = (*C.GtkPageSetup)(s.Native())
	arg1 = (*C.GtkPaperSize)(size.Native())

	C.gtk_page_setup_set_paper_size_and_default_margins(arg0, arg1)
}

// SetRightMargin sets the right margin of the PageSetup.
func (s pageSetup) SetRightMargin(margin float64, unit Unit) {
	var arg0 *C.GtkPageSetup
	var arg1 C.gdouble
	var arg2 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(s.Native())
	arg1 = C.gdouble(margin)
	arg2 = (C.GtkUnit)(unit)

	C.gtk_page_setup_set_right_margin(arg0, arg1, arg2)
}

// SetTopMargin sets the top margin of the PageSetup.
func (s pageSetup) SetTopMargin(margin float64, unit Unit) {
	var arg0 *C.GtkPageSetup
	var arg1 C.gdouble
	var arg2 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(s.Native())
	arg1 = C.gdouble(margin)
	arg2 = (C.GtkUnit)(unit)

	C.gtk_page_setup_set_top_margin(arg0, arg1, arg2)
}

// ToFile: this function saves the information from @setup to @file_name.
func (s pageSetup) ToFile(fileName string) error {
	var arg0 *C.GtkPageSetup
	var arg1 *C.char
	var gError *C.GError

	arg0 = (*C.GtkPageSetup)(s.Native())
	arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_page_setup_to_file(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// ToGVariant: serialize page setup to an a{sv} variant.
func (s pageSetup) ToGVariant() *glib.Variant {
	var arg0 *C.GtkPageSetup

	arg0 = (*C.GtkPageSetup)(s.Native())

	ret := C.gtk_page_setup_to_gvariant(arg0)

	var ret0 *glib.Variant

	{
		ret0 = glib.WrapVariant(unsafe.Pointer(ret))
	}

	return ret0
}

// ToKeyFile: this function adds the page setup from @setup to @key_file.
func (s pageSetup) ToKeyFile(keyFile *glib.KeyFile, groupName string) {
	var arg0 *C.GtkPageSetup
	var arg1 *C.GKeyFile
	var arg2 *C.gchar

	arg0 = (*C.GtkPageSetup)(s.Native())
	arg1 = (*C.GKeyFile)(keyFile.Native())
	arg2 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_page_setup_to_key_file(arg0, arg1, arg2)
}

// PrintContext: a GtkPrintContext encapsulates context information that is
// required when drawing pages for printing, such as the cairo context and
// important parameters like page size and resolution. It also lets you easily
// create Layout and Context objects that match the font metrics of the cairo
// surface.
//
// GtkPrintContext objects gets passed to the PrintOperation::begin-print,
// PrintOperation::end-print, PrintOperation::request-page-setup and
// PrintOperation::draw-page signals on the PrintOperation.
//
// Using GtkPrintContext in a PrintOperation::draw-page callback
//
//    static void
//    draw_page (GtkPrintOperation *operation,
//    	   GtkPrintContext   *context,
//    	   int                page_nr)
//    {
//      cairo_t *cr;
//      PangoLayout *layout;
//      PangoFontDescription *desc;
//
//      cr = gtk_print_context_get_cairo_context (context);
//
//      // Draw a red rectangle, as wide as the paper (inside the margins)
//      cairo_set_source_rgb (cr, 1.0, 0, 0);
//      cairo_rectangle (cr, 0, 0, gtk_print_context_get_width (context), 50);
//
//      cairo_fill (cr);
//
//      // Draw some lines
//      cairo_move_to (cr, 20, 10);
//      cairo_line_to (cr, 40, 20);
//      cairo_arc (cr, 60, 60, 20, 0, M_PI);
//      cairo_line_to (cr, 80, 20);
//
//      cairo_set_source_rgb (cr, 0, 0, 0);
//      cairo_set_line_width (cr, 5);
//      cairo_set_line_cap (cr, CAIRO_LINE_CAP_ROUND);
//      cairo_set_line_join (cr, CAIRO_LINE_JOIN_ROUND);
//
//      cairo_stroke (cr);
//
//      // Draw some text
//      layout = gtk_print_context_create_pango_layout (context);
//      pango_layout_set_text (layout, "Hello World! Printing is easy", -1);
//      desc = pango_font_description_from_string ("sans 28");
//      pango_layout_set_font_description (layout, desc);
//      pango_font_description_free (desc);
//
//      cairo_move_to (cr, 30, 20);
//      pango_cairo_layout_path (cr, layout);
//
//      // Font Outline
//      cairo_set_source_rgb (cr, 0.93, 1.0, 0.47);
//      cairo_set_line_width (cr, 0.5);
//      cairo_stroke_preserve (cr);
//
//      // Font Fill
//      cairo_set_source_rgb (cr, 0, 0.0, 1.0);
//      cairo_fill (cr);
//
//      g_object_unref (layout);
//    }
//
// Printing support was added in GTK+ 2.10.
type PrintContext interface {
	gextras.Objector

	// CreatePangoContext creates a new Context that can be used with the
	// PrintContext.
	CreatePangoContext() pango.Context
	// CreatePangoLayout creates a new Layout that is suitable for use with the
	// PrintContext.
	CreatePangoLayout() pango.Layout
	// CairoContext obtains the cairo context that is associated with the
	// PrintContext.
	CairoContext() *cairo.Context
	// DPIX obtains the horizontal resolution of the PrintContext, in dots per
	// inch.
	DPIX() float64
	// DPIY obtains the vertical resolution of the PrintContext, in dots per
	// inch.
	DPIY() float64
	// HardMargins obtains the hardware printer margins of the PrintContext, in
	// units.
	HardMargins() (top float64, bottom float64, left float64, right float64, ok bool)
	// Height obtains the height of the PrintContext, in pixels.
	Height() float64
	// PageSetup obtains the PageSetup that determines the page dimensions of
	// the PrintContext.
	PageSetup() PageSetup
	// PangoFontmap returns a FontMap that is suitable for use with the
	// PrintContext.
	PangoFontmap() pango.FontMap
	// Width obtains the width of the PrintContext, in pixels.
	Width() float64
	// SetCairoContext sets a new cairo context on a print context.
	//
	// This function is intended to be used when implementing an internal print
	// preview, it is not needed for printing, since GTK+ itself creates a
	// suitable cairo context in that case.
	SetCairoContext(cr *cairo.Context, dpiX float64, dpiY float64)
}

// printContext implements the PrintContext interface.
type printContext struct {
	gextras.Objector
}

var _ PrintContext = (*printContext)(nil)

// WrapPrintContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapPrintContext(obj *externglib.Object) PrintContext {
	return PrintContext{
		Objector: obj,
	}
}

func marshalPrintContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPrintContext(obj), nil
}

// CreatePangoContext creates a new Context that can be used with the
// PrintContext.
func (c printContext) CreatePangoContext() pango.Context {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(c.Native())

	ret := C.gtk_print_context_create_pango_context(arg0)

	var ret0 pango.Context

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(pango.Context)

	return ret0
}

// CreatePangoLayout creates a new Layout that is suitable for use with the
// PrintContext.
func (c printContext) CreatePangoLayout() pango.Layout {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(c.Native())

	ret := C.gtk_print_context_create_pango_layout(arg0)

	var ret0 pango.Layout

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(pango.Layout)

	return ret0
}

// CairoContext obtains the cairo context that is associated with the
// PrintContext.
func (c printContext) CairoContext() *cairo.Context {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(c.Native())

	ret := C.gtk_print_context_get_cairo_context(arg0)

	var ret0 *cairo.Context

	{
		ret0 = cairo.WrapContext(unsafe.Pointer(ret))
	}

	return ret0
}

// DPIX obtains the horizontal resolution of the PrintContext, in dots per
// inch.
func (c printContext) DPIX() float64 {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(c.Native())

	ret := C.gtk_print_context_get_dpi_x(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// DPIY obtains the vertical resolution of the PrintContext, in dots per
// inch.
func (c printContext) DPIY() float64 {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(c.Native())

	ret := C.gtk_print_context_get_dpi_y(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// HardMargins obtains the hardware printer margins of the PrintContext, in
// units.
func (c printContext) HardMargins() (top float64, bottom float64, left float64, right float64, ok bool) {
	var arg0 *C.GtkPrintContext
	var arg1 *C.gdouble // out
	var arg2 *C.gdouble // out
	var arg3 *C.gdouble // out
	var arg4 *C.gdouble // out

	arg0 = (*C.GtkPrintContext)(c.Native())

	ret := C.gtk_print_context_get_hard_margins(arg0, &arg1, &arg2, &arg3, &arg4)

	var ret0 float64
	var ret1 float64
	var ret2 float64
	var ret3 float64
	var ret4 bool

	ret0 = float64(arg1)

	ret1 = float64(arg2)

	ret2 = float64(arg3)

	ret3 = float64(arg4)

	ret4 = C.bool(ret) != C.false

	return ret0, ret1, ret2, ret3, ret4
}

// Height obtains the height of the PrintContext, in pixels.
func (c printContext) Height() float64 {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(c.Native())

	ret := C.gtk_print_context_get_height(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// PageSetup obtains the PageSetup that determines the page dimensions of
// the PrintContext.
func (c printContext) PageSetup() PageSetup {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(c.Native())

	ret := C.gtk_print_context_get_page_setup(arg0)

	var ret0 PageSetup

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(PageSetup)

	return ret0
}

// PangoFontmap returns a FontMap that is suitable for use with the
// PrintContext.
func (c printContext) PangoFontmap() pango.FontMap {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(c.Native())

	ret := C.gtk_print_context_get_pango_fontmap(arg0)

	var ret0 pango.FontMap

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(pango.FontMap)

	return ret0
}

// Width obtains the width of the PrintContext, in pixels.
func (c printContext) Width() float64 {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(c.Native())

	ret := C.gtk_print_context_get_width(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// SetCairoContext sets a new cairo context on a print context.
//
// This function is intended to be used when implementing an internal print
// preview, it is not needed for printing, since GTK+ itself creates a
// suitable cairo context in that case.
func (c printContext) SetCairoContext(cr *cairo.Context, dpiX float64, dpiY float64) {
	var arg0 *C.GtkPrintContext
	var arg1 *C.cairo_t
	var arg2 C.double
	var arg3 C.double

	arg0 = (*C.GtkPrintContext)(c.Native())
	arg1 = (*C.cairo_t)(cr.Native())
	arg2 = C.double(dpiX)
	arg3 = C.double(dpiY)

	C.gtk_print_context_set_cairo_context(arg0, arg1, arg2, arg3)
}

// PrintSettings: a GtkPrintSettings object represents the settings of a print
// dialog in a system-independent way. The main use for this object is that once
// you’ve printed you can get a settings object that represents the settings the
// user chose, and the next time you print you can pass that object in so that
// the user doesn’t have to re-set all his settings.
//
// Its also possible to enumerate the settings so that you can easily save the
// settings for the next time your app runs, or even store them in a document.
// The predefined keys try to use shared values as much as possible so that
// moving such a document between systems still works.
//
// Printing support was added in GTK+ 2.10.
type PrintSettings interface {
	gextras.Objector

	// Copy copies a PrintSettings object.
	Copy() PrintSettings
	// Foreach calls @func for each key-value pair of @settings.
	Foreach(fn PrintSettingsFunc)
	// Get looks up the string value associated with @key.
	Get(key string) string
	// Bool returns the boolean represented by the value that is associated with
	// @key.
	//
	// The string “true” represents true, any other string false.
	Bool(key string) bool
	// Collate gets the value of GTK_PRINT_SETTINGS_COLLATE.
	Collate() bool
	// DefaultSource gets the value of GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
	DefaultSource() string
	// Dither gets the value of GTK_PRINT_SETTINGS_DITHER.
	Dither() string
	// Double returns the double value associated with @key, or 0.
	Double(key string) float64
	// DoubleWithDefault returns the floating point number represented by the
	// value that is associated with @key, or @default_val if the value does not
	// represent a floating point number.
	//
	// Floating point numbers are parsed with g_ascii_strtod().
	DoubleWithDefault(key string, def float64) float64
	// Duplex gets the value of GTK_PRINT_SETTINGS_DUPLEX.
	Duplex() PrintDuplex
	// Finishings gets the value of GTK_PRINT_SETTINGS_FINISHINGS.
	Finishings() string
	// Int returns the integer value of @key, or 0.
	Int(key string) int
	// IntWithDefault returns the value of @key, interpreted as an integer, or
	// the default value.
	IntWithDefault(key string, def int) int
	// Length returns the value associated with @key, interpreted as a length.
	// The returned value is converted to @units.
	Length(key string, unit Unit) float64
	// MediaType gets the value of GTK_PRINT_SETTINGS_MEDIA_TYPE.
	//
	// The set of media types is defined in PWG 5101.1-2002 PWG.
	MediaType() string
	// NCopies gets the value of GTK_PRINT_SETTINGS_N_COPIES.
	NCopies() int
	// NumberUp gets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
	NumberUp() int
	// NumberUpLayout gets the value of GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT.
	NumberUpLayout() NumberUpLayout
	// Orientation: get the value of GTK_PRINT_SETTINGS_ORIENTATION, converted
	// to a PageOrientation.
	Orientation() PageOrientation
	// OutputBin gets the value of GTK_PRINT_SETTINGS_OUTPUT_BIN.
	OutputBin() string
	// PageRanges gets the value of GTK_PRINT_SETTINGS_PAGE_RANGES.
	PageRanges() (numRanges int, pageRanges []PageRange)
	// PageSet gets the value of GTK_PRINT_SETTINGS_PAGE_SET.
	PageSet() PageSet
	// PaperHeight gets the value of GTK_PRINT_SETTINGS_PAPER_HEIGHT, converted
	// to @unit.
	PaperHeight(unit Unit) float64
	// PaperSize gets the value of GTK_PRINT_SETTINGS_PAPER_FORMAT, converted to
	// a PaperSize.
	PaperSize() *PaperSize
	// PaperWidth gets the value of GTK_PRINT_SETTINGS_PAPER_WIDTH, converted to
	// @unit.
	PaperWidth(unit Unit) float64
	// PrintPages gets the value of GTK_PRINT_SETTINGS_PRINT_PAGES.
	PrintPages() PrintPages
	// Printer: convenience function to obtain the value of
	// GTK_PRINT_SETTINGS_PRINTER.
	Printer() string
	// PrinterLpi gets the value of GTK_PRINT_SETTINGS_PRINTER_LPI.
	PrinterLpi() float64
	// Quality gets the value of GTK_PRINT_SETTINGS_QUALITY.
	Quality() PrintQuality
	// Resolution gets the value of GTK_PRINT_SETTINGS_RESOLUTION.
	Resolution() int
	// ResolutionX gets the value of GTK_PRINT_SETTINGS_RESOLUTION_X.
	ResolutionX() int
	// ResolutionY gets the value of GTK_PRINT_SETTINGS_RESOLUTION_Y.
	ResolutionY() int
	// Reverse gets the value of GTK_PRINT_SETTINGS_REVERSE.
	Reverse() bool
	// Scale gets the value of GTK_PRINT_SETTINGS_SCALE.
	Scale() float64
	// UseColor gets the value of GTK_PRINT_SETTINGS_USE_COLOR.
	UseColor() bool
	// HasKey returns true, if a value is associated with @key.
	HasKey(key string) bool
	// LoadFile reads the print settings from @file_name. If the file could not
	// be loaded then error is set to either a Error or FileError. See
	// gtk_print_settings_to_file().
	LoadFile(fileName string) error
	// LoadKeyFile reads the print settings from the group @group_name in
	// @key_file. If the file could not be loaded then error is set to either a
	// Error or FileError.
	LoadKeyFile(keyFile *glib.KeyFile, groupName string) error
	// Set associates @value with @key.
	Set(key string, value string)
	// SetBool sets @key to a boolean value.
	SetBool(key string, value bool)
	// SetCollate sets the value of GTK_PRINT_SETTINGS_COLLATE.
	SetCollate(collate bool)
	// SetDefaultSource sets the value of GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
	SetDefaultSource(defaultSource string)
	// SetDither sets the value of GTK_PRINT_SETTINGS_DITHER.
	SetDither(dither string)
	// SetDouble sets @key to a double value.
	SetDouble(key string, value float64)
	// SetDuplex sets the value of GTK_PRINT_SETTINGS_DUPLEX.
	SetDuplex(duplex PrintDuplex)
	// SetFinishings sets the value of GTK_PRINT_SETTINGS_FINISHINGS.
	SetFinishings(finishings string)
	// SetInt sets @key to an integer value.
	SetInt(key string, value int)
	// SetLength associates a length in units of @unit with @key.
	SetLength(key string, value float64, unit Unit)
	// SetMediaType sets the value of GTK_PRINT_SETTINGS_MEDIA_TYPE.
	//
	// The set of media types is defined in PWG 5101.1-2002 PWG.
	SetMediaType(mediaType string)
	// SetNCopies sets the value of GTK_PRINT_SETTINGS_N_COPIES.
	SetNCopies(numCopies int)
	// SetNumberUp sets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
	SetNumberUp(numberUp int)
	// SetNumberUpLayout sets the value of GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT.
	SetNumberUpLayout(numberUpLayout NumberUpLayout)
	// SetOrientation sets the value of GTK_PRINT_SETTINGS_ORIENTATION.
	SetOrientation(orientation PageOrientation)
	// SetOutputBin sets the value of GTK_PRINT_SETTINGS_OUTPUT_BIN.
	SetOutputBin(outputBin string)
	// SetPageRanges sets the value of GTK_PRINT_SETTINGS_PAGE_RANGES.
	SetPageRanges(pageRanges []PageRange)
	// SetPageSet sets the value of GTK_PRINT_SETTINGS_PAGE_SET.
	SetPageSet(pageSet PageSet)
	// SetPaperHeight sets the value of GTK_PRINT_SETTINGS_PAPER_HEIGHT.
	SetPaperHeight(height float64, unit Unit)
	// SetPaperSize sets the value of GTK_PRINT_SETTINGS_PAPER_FORMAT,
	// GTK_PRINT_SETTINGS_PAPER_WIDTH and GTK_PRINT_SETTINGS_PAPER_HEIGHT.
	SetPaperSize(paperSize *PaperSize)
	// SetPaperWidth sets the value of GTK_PRINT_SETTINGS_PAPER_WIDTH.
	SetPaperWidth(width float64, unit Unit)
	// SetPrintPages sets the value of GTK_PRINT_SETTINGS_PRINT_PAGES.
	SetPrintPages(pages PrintPages)
	// SetPrinter: convenience function to set GTK_PRINT_SETTINGS_PRINTER to
	// @printer.
	SetPrinter(printer string)
	// SetPrinterLpi sets the value of GTK_PRINT_SETTINGS_PRINTER_LPI.
	SetPrinterLpi(lpi float64)
	// SetQuality sets the value of GTK_PRINT_SETTINGS_QUALITY.
	SetQuality(quality PrintQuality)
	// SetResolution sets the values of GTK_PRINT_SETTINGS_RESOLUTION,
	// GTK_PRINT_SETTINGS_RESOLUTION_X and GTK_PRINT_SETTINGS_RESOLUTION_Y.
	SetResolution(resolution int)
	// SetResolutionXY sets the values of GTK_PRINT_SETTINGS_RESOLUTION,
	// GTK_PRINT_SETTINGS_RESOLUTION_X and GTK_PRINT_SETTINGS_RESOLUTION_Y.
	SetResolutionXY(resolutionX int, resolutionY int)
	// SetReverse sets the value of GTK_PRINT_SETTINGS_REVERSE.
	SetReverse(reverse bool)
	// SetScale sets the value of GTK_PRINT_SETTINGS_SCALE.
	SetScale(scale float64)
	// SetUseColor sets the value of GTK_PRINT_SETTINGS_USE_COLOR.
	SetUseColor(useColor bool)
	// ToFile: this function saves the print settings from @settings to
	// @file_name. If the file could not be loaded then error is set to either a
	// Error or FileError.
	ToFile(fileName string) error
	// ToGVariant: serialize print settings to an a{sv} variant.
	ToGVariant() *glib.Variant
	// ToKeyFile: this function adds the print settings from @settings to
	// @key_file.
	ToKeyFile(keyFile *glib.KeyFile, groupName string)
	// Unset removes any value associated with @key. This has the same effect as
	// setting the value to nil.
	Unset(key string)
}

// printSettings implements the PrintSettings interface.
type printSettings struct {
	gextras.Objector
}

var _ PrintSettings = (*printSettings)(nil)

// WrapPrintSettings wraps a GObject to the right type. It is
// primarily used internally.
func WrapPrintSettings(obj *externglib.Object) PrintSettings {
	return PrintSettings{
		Objector: obj,
	}
}

func marshalPrintSettings(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPrintSettings(obj), nil
}

// NewPrintSettings constructs a class PrintSettings.
func NewPrintSettings() PrintSettings {
	ret := C.gtk_print_settings_new()

	var ret0 PrintSettings

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(PrintSettings)

	return ret0
}

// NewPrintSettingsFromFile constructs a class PrintSettings.
func NewPrintSettingsFromFile(fileName string) (printSettings PrintSettings, err error) {
	var arg1 *C.gchar
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_print_settings_new_from_file(arg1, &gError)

	var ret0 PrintSettings
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(PrintSettings)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// NewPrintSettingsFromGVariant constructs a class PrintSettings.
func NewPrintSettingsFromGVariant(variant *glib.Variant) PrintSettings {
	var arg1 *C.GVariant

	arg1 = (*C.GVariant)(variant.Native())

	ret := C.gtk_print_settings_new_from_gvariant(arg1)

	var ret0 PrintSettings

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(PrintSettings)

	return ret0
}

// NewPrintSettingsFromKeyFile constructs a class PrintSettings.
func NewPrintSettingsFromKeyFile(keyFile *glib.KeyFile, groupName string) (printSettings PrintSettings, err error) {
	var arg1 *C.GKeyFile
	var arg2 *C.gchar
	var gError *C.GError

	arg1 = (*C.GKeyFile)(keyFile.Native())
	arg2 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_print_settings_new_from_key_file(arg1, arg2, &gError)

	var ret0 PrintSettings
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(PrintSettings)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Copy copies a PrintSettings object.
func (o printSettings) Copy() PrintSettings {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(o.Native())

	ret := C.gtk_print_settings_copy(arg0)

	var ret0 PrintSettings

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(PrintSettings)

	return ret0
}

// Foreach calls @func for each key-value pair of @settings.
func (s printSettings) Foreach(fn PrintSettingsFunc) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkPrintSettingsFunc
	var arg2 C.gpointer

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = (*[0]byte)(C.gotk4_PrintSettingsFunc)
	arg2 = C.gpointer(box.Assign(fn))

	C.gtk_print_settings_foreach(arg0, arg1, arg2)
}

// Get looks up the string value associated with @key.
func (s printSettings) Get(key string) string {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_print_settings_get(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Bool returns the boolean represented by the value that is associated with
// @key.
//
// The string “true” represents true, any other string false.
func (s printSettings) Bool(key string) bool {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_print_settings_get_bool(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// Collate gets the value of GTK_PRINT_SETTINGS_COLLATE.
func (s printSettings) Collate() bool {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(s.Native())

	ret := C.gtk_print_settings_get_collate(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// DefaultSource gets the value of GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
func (s printSettings) DefaultSource() string {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(s.Native())

	ret := C.gtk_print_settings_get_default_source(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Dither gets the value of GTK_PRINT_SETTINGS_DITHER.
func (s printSettings) Dither() string {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(s.Native())

	ret := C.gtk_print_settings_get_dither(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Double returns the double value associated with @key, or 0.
func (s printSettings) Double(key string) float64 {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_print_settings_get_double(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// DoubleWithDefault returns the floating point number represented by the
// value that is associated with @key, or @default_val if the value does not
// represent a floating point number.
//
// Floating point numbers are parsed with g_ascii_strtod().
func (s printSettings) DoubleWithDefault(key string, def float64) float64 {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar
	var arg2 C.gdouble

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gdouble(def)

	ret := C.gtk_print_settings_get_double_with_default(arg0, arg1, arg2)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// Duplex gets the value of GTK_PRINT_SETTINGS_DUPLEX.
func (s printSettings) Duplex() PrintDuplex {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(s.Native())

	ret := C.gtk_print_settings_get_duplex(arg0)

	var ret0 PrintDuplex

	ret0 = PrintDuplex(ret)

	return ret0
}

// Finishings gets the value of GTK_PRINT_SETTINGS_FINISHINGS.
func (s printSettings) Finishings() string {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(s.Native())

	ret := C.gtk_print_settings_get_finishings(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Int returns the integer value of @key, or 0.
func (s printSettings) Int(key string) int {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_print_settings_get_int(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// IntWithDefault returns the value of @key, interpreted as an integer, or
// the default value.
func (s printSettings) IntWithDefault(key string, def int) int {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar
	var arg2 C.gint

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(def)

	ret := C.gtk_print_settings_get_int_with_default(arg0, arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Length returns the value associated with @key, interpreted as a length.
// The returned value is converted to @units.
func (s printSettings) Length(key string, unit Unit) float64 {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar
	var arg2 C.GtkUnit

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GtkUnit)(unit)

	ret := C.gtk_print_settings_get_length(arg0, arg1, arg2)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// MediaType gets the value of GTK_PRINT_SETTINGS_MEDIA_TYPE.
//
// The set of media types is defined in PWG 5101.1-2002 PWG.
func (s printSettings) MediaType() string {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(s.Native())

	ret := C.gtk_print_settings_get_media_type(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// NCopies gets the value of GTK_PRINT_SETTINGS_N_COPIES.
func (s printSettings) NCopies() int {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(s.Native())

	ret := C.gtk_print_settings_get_n_copies(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// NumberUp gets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
func (s printSettings) NumberUp() int {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(s.Native())

	ret := C.gtk_print_settings_get_number_up(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// NumberUpLayout gets the value of GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT.
func (s printSettings) NumberUpLayout() NumberUpLayout {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(s.Native())

	ret := C.gtk_print_settings_get_number_up_layout(arg0)

	var ret0 NumberUpLayout

	ret0 = NumberUpLayout(ret)

	return ret0
}

// Orientation: get the value of GTK_PRINT_SETTINGS_ORIENTATION, converted
// to a PageOrientation.
func (s printSettings) Orientation() PageOrientation {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(s.Native())

	ret := C.gtk_print_settings_get_orientation(arg0)

	var ret0 PageOrientation

	ret0 = PageOrientation(ret)

	return ret0
}

// OutputBin gets the value of GTK_PRINT_SETTINGS_OUTPUT_BIN.
func (s printSettings) OutputBin() string {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(s.Native())

	ret := C.gtk_print_settings_get_output_bin(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// PageRanges gets the value of GTK_PRINT_SETTINGS_PAGE_RANGES.
func (s printSettings) PageRanges() (numRanges int, pageRanges []PageRange) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gint // out

	arg0 = (*C.GtkPrintSettings)(s.Native())

	ret := C.gtk_print_settings_get_page_ranges(arg0, &arg1)

	var ret0 int
	var ret1 []PageRange

	ret0 = int(arg1)

	{
		ret1 = make([]PageRange, arg1)
		for i := 0; i < uintptr(arg1); i++ {
			src := (C.GtkPageRange)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			{
				ret1[i] = WrapPageRange(unsafe.Pointer(src))
				runtime.SetFinalizer(&ret1[i], func(v *PageRange) {
					C.free(unsafe.Pointer(v.Native()))
				})
			}
		}
	}

	return ret0, ret1
}

// PageSet gets the value of GTK_PRINT_SETTINGS_PAGE_SET.
func (s printSettings) PageSet() PageSet {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(s.Native())

	ret := C.gtk_print_settings_get_page_set(arg0)

	var ret0 PageSet

	ret0 = PageSet(ret)

	return ret0
}

// PaperHeight gets the value of GTK_PRINT_SETTINGS_PAPER_HEIGHT, converted
// to @unit.
func (s printSettings) PaperHeight(unit Unit) float64 {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = (C.GtkUnit)(unit)

	ret := C.gtk_print_settings_get_paper_height(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// PaperSize gets the value of GTK_PRINT_SETTINGS_PAPER_FORMAT, converted to
// a PaperSize.
func (s printSettings) PaperSize() *PaperSize {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(s.Native())

	ret := C.gtk_print_settings_get_paper_size(arg0)

	var ret0 *PaperSize

	{
		ret0 = WrapPaperSize(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *PaperSize) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// PaperWidth gets the value of GTK_PRINT_SETTINGS_PAPER_WIDTH, converted to
// @unit.
func (s printSettings) PaperWidth(unit Unit) float64 {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = (C.GtkUnit)(unit)

	ret := C.gtk_print_settings_get_paper_width(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// PrintPages gets the value of GTK_PRINT_SETTINGS_PRINT_PAGES.
func (s printSettings) PrintPages() PrintPages {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(s.Native())

	ret := C.gtk_print_settings_get_print_pages(arg0)

	var ret0 PrintPages

	ret0 = PrintPages(ret)

	return ret0
}

// Printer: convenience function to obtain the value of
// GTK_PRINT_SETTINGS_PRINTER.
func (s printSettings) Printer() string {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(s.Native())

	ret := C.gtk_print_settings_get_printer(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// PrinterLpi gets the value of GTK_PRINT_SETTINGS_PRINTER_LPI.
func (s printSettings) PrinterLpi() float64 {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(s.Native())

	ret := C.gtk_print_settings_get_printer_lpi(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// Quality gets the value of GTK_PRINT_SETTINGS_QUALITY.
func (s printSettings) Quality() PrintQuality {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(s.Native())

	ret := C.gtk_print_settings_get_quality(arg0)

	var ret0 PrintQuality

	ret0 = PrintQuality(ret)

	return ret0
}

// Resolution gets the value of GTK_PRINT_SETTINGS_RESOLUTION.
func (s printSettings) Resolution() int {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(s.Native())

	ret := C.gtk_print_settings_get_resolution(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ResolutionX gets the value of GTK_PRINT_SETTINGS_RESOLUTION_X.
func (s printSettings) ResolutionX() int {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(s.Native())

	ret := C.gtk_print_settings_get_resolution_x(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ResolutionY gets the value of GTK_PRINT_SETTINGS_RESOLUTION_Y.
func (s printSettings) ResolutionY() int {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(s.Native())

	ret := C.gtk_print_settings_get_resolution_y(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Reverse gets the value of GTK_PRINT_SETTINGS_REVERSE.
func (s printSettings) Reverse() bool {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(s.Native())

	ret := C.gtk_print_settings_get_reverse(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// Scale gets the value of GTK_PRINT_SETTINGS_SCALE.
func (s printSettings) Scale() float64 {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(s.Native())

	ret := C.gtk_print_settings_get_scale(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// UseColor gets the value of GTK_PRINT_SETTINGS_USE_COLOR.
func (s printSettings) UseColor() bool {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(s.Native())

	ret := C.gtk_print_settings_get_use_color(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// HasKey returns true, if a value is associated with @key.
func (s printSettings) HasKey(key string) bool {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_print_settings_has_key(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// LoadFile reads the print settings from @file_name. If the file could not
// be loaded then error is set to either a Error or FileError. See
// gtk_print_settings_to_file().
func (s printSettings) LoadFile(fileName string) error {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_print_settings_load_file(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// LoadKeyFile reads the print settings from the group @group_name in
// @key_file. If the file could not be loaded then error is set to either a
// Error or FileError.
func (s printSettings) LoadKeyFile(keyFile *glib.KeyFile, groupName string) error {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.GKeyFile
	var arg2 *C.gchar
	var gError *C.GError

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = (*C.GKeyFile)(keyFile.Native())
	arg2 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_print_settings_load_key_file(arg0, arg1, arg2, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// Set associates @value with @key.
func (s printSettings) Set(key string, value string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_print_settings_set(arg0, arg1, arg2)
}

// SetBool sets @key to a boolean value.
func (s printSettings) SetBool(key string, value bool) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar
	var arg2 C.gboolean

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	if value {
		arg2 = C.TRUE
	}

	C.gtk_print_settings_set_bool(arg0, arg1, arg2)
}

// SetCollate sets the value of GTK_PRINT_SETTINGS_COLLATE.
func (s printSettings) SetCollate(collate bool) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gboolean

	arg0 = (*C.GtkPrintSettings)(s.Native())
	if collate {
		arg1 = C.TRUE
	}

	C.gtk_print_settings_set_collate(arg0, arg1)
}

// SetDefaultSource sets the value of GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
func (s printSettings) SetDefaultSource(defaultSource string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = (*C.gchar)(C.CString(defaultSource))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_set_default_source(arg0, arg1)
}

// SetDither sets the value of GTK_PRINT_SETTINGS_DITHER.
func (s printSettings) SetDither(dither string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = (*C.gchar)(C.CString(dither))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_set_dither(arg0, arg1)
}

// SetDouble sets @key to a double value.
func (s printSettings) SetDouble(key string, value float64) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar
	var arg2 C.gdouble

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gdouble(value)

	C.gtk_print_settings_set_double(arg0, arg1, arg2)
}

// SetDuplex sets the value of GTK_PRINT_SETTINGS_DUPLEX.
func (s printSettings) SetDuplex(duplex PrintDuplex) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkPrintDuplex

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = (C.GtkPrintDuplex)(duplex)

	C.gtk_print_settings_set_duplex(arg0, arg1)
}

// SetFinishings sets the value of GTK_PRINT_SETTINGS_FINISHINGS.
func (s printSettings) SetFinishings(finishings string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = (*C.gchar)(C.CString(finishings))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_set_finishings(arg0, arg1)
}

// SetInt sets @key to an integer value.
func (s printSettings) SetInt(key string, value int) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar
	var arg2 C.gint

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(value)

	C.gtk_print_settings_set_int(arg0, arg1, arg2)
}

// SetLength associates a length in units of @unit with @key.
func (s printSettings) SetLength(key string, value float64, unit Unit) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar
	var arg2 C.gdouble
	var arg3 C.GtkUnit

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gdouble(value)
	arg3 = (C.GtkUnit)(unit)

	C.gtk_print_settings_set_length(arg0, arg1, arg2, arg3)
}

// SetMediaType sets the value of GTK_PRINT_SETTINGS_MEDIA_TYPE.
//
// The set of media types is defined in PWG 5101.1-2002 PWG.
func (s printSettings) SetMediaType(mediaType string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = (*C.gchar)(C.CString(mediaType))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_set_media_type(arg0, arg1)
}

// SetNCopies sets the value of GTK_PRINT_SETTINGS_N_COPIES.
func (s printSettings) SetNCopies(numCopies int) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gint

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = C.gint(numCopies)

	C.gtk_print_settings_set_n_copies(arg0, arg1)
}

// SetNumberUp sets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
func (s printSettings) SetNumberUp(numberUp int) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gint

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = C.gint(numberUp)

	C.gtk_print_settings_set_number_up(arg0, arg1)
}

// SetNumberUpLayout sets the value of GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT.
func (s printSettings) SetNumberUpLayout(numberUpLayout NumberUpLayout) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkNumberUpLayout

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = (C.GtkNumberUpLayout)(numberUpLayout)

	C.gtk_print_settings_set_number_up_layout(arg0, arg1)
}

// SetOrientation sets the value of GTK_PRINT_SETTINGS_ORIENTATION.
func (s printSettings) SetOrientation(orientation PageOrientation) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkPageOrientation

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = (C.GtkPageOrientation)(orientation)

	C.gtk_print_settings_set_orientation(arg0, arg1)
}

// SetOutputBin sets the value of GTK_PRINT_SETTINGS_OUTPUT_BIN.
func (s printSettings) SetOutputBin(outputBin string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = (*C.gchar)(C.CString(outputBin))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_set_output_bin(arg0, arg1)
}

// SetPageRanges sets the value of GTK_PRINT_SETTINGS_PAGE_RANGES.
func (s printSettings) SetPageRanges(pageRanges []PageRange) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.GtkPageRange
	var arg2 C.gint

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = (*C.GtkPageRange)(unsafe.Pointer(&pageRanges[0]))
	arg2 = len(pageRanges)
	defer runtime.KeepAlive(pageRanges)

	C.gtk_print_settings_set_page_ranges(arg0, arg1, arg2)
}

// SetPageSet sets the value of GTK_PRINT_SETTINGS_PAGE_SET.
func (s printSettings) SetPageSet(pageSet PageSet) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkPageSet

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = (C.GtkPageSet)(pageSet)

	C.gtk_print_settings_set_page_set(arg0, arg1)
}

// SetPaperHeight sets the value of GTK_PRINT_SETTINGS_PAPER_HEIGHT.
func (s printSettings) SetPaperHeight(height float64, unit Unit) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gdouble
	var arg2 C.GtkUnit

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = C.gdouble(height)
	arg2 = (C.GtkUnit)(unit)

	C.gtk_print_settings_set_paper_height(arg0, arg1, arg2)
}

// SetPaperSize sets the value of GTK_PRINT_SETTINGS_PAPER_FORMAT,
// GTK_PRINT_SETTINGS_PAPER_WIDTH and GTK_PRINT_SETTINGS_PAPER_HEIGHT.
func (s printSettings) SetPaperSize(paperSize *PaperSize) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.GtkPaperSize

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = (*C.GtkPaperSize)(paperSize.Native())

	C.gtk_print_settings_set_paper_size(arg0, arg1)
}

// SetPaperWidth sets the value of GTK_PRINT_SETTINGS_PAPER_WIDTH.
func (s printSettings) SetPaperWidth(width float64, unit Unit) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gdouble
	var arg2 C.GtkUnit

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = C.gdouble(width)
	arg2 = (C.GtkUnit)(unit)

	C.gtk_print_settings_set_paper_width(arg0, arg1, arg2)
}

// SetPrintPages sets the value of GTK_PRINT_SETTINGS_PRINT_PAGES.
func (s printSettings) SetPrintPages(pages PrintPages) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkPrintPages

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = (C.GtkPrintPages)(pages)

	C.gtk_print_settings_set_print_pages(arg0, arg1)
}

// SetPrinter: convenience function to set GTK_PRINT_SETTINGS_PRINTER to
// @printer.
func (s printSettings) SetPrinter(printer string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = (*C.gchar)(C.CString(printer))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_set_printer(arg0, arg1)
}

// SetPrinterLpi sets the value of GTK_PRINT_SETTINGS_PRINTER_LPI.
func (s printSettings) SetPrinterLpi(lpi float64) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gdouble

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = C.gdouble(lpi)

	C.gtk_print_settings_set_printer_lpi(arg0, arg1)
}

// SetQuality sets the value of GTK_PRINT_SETTINGS_QUALITY.
func (s printSettings) SetQuality(quality PrintQuality) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkPrintQuality

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = (C.GtkPrintQuality)(quality)

	C.gtk_print_settings_set_quality(arg0, arg1)
}

// SetResolution sets the values of GTK_PRINT_SETTINGS_RESOLUTION,
// GTK_PRINT_SETTINGS_RESOLUTION_X and GTK_PRINT_SETTINGS_RESOLUTION_Y.
func (s printSettings) SetResolution(resolution int) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gint

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = C.gint(resolution)

	C.gtk_print_settings_set_resolution(arg0, arg1)
}

// SetResolutionXY sets the values of GTK_PRINT_SETTINGS_RESOLUTION,
// GTK_PRINT_SETTINGS_RESOLUTION_X and GTK_PRINT_SETTINGS_RESOLUTION_Y.
func (s printSettings) SetResolutionXY(resolutionX int, resolutionY int) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gint
	var arg2 C.gint

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = C.gint(resolutionX)
	arg2 = C.gint(resolutionY)

	C.gtk_print_settings_set_resolution_xy(arg0, arg1, arg2)
}

// SetReverse sets the value of GTK_PRINT_SETTINGS_REVERSE.
func (s printSettings) SetReverse(reverse bool) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gboolean

	arg0 = (*C.GtkPrintSettings)(s.Native())
	if reverse {
		arg1 = C.TRUE
	}

	C.gtk_print_settings_set_reverse(arg0, arg1)
}

// SetScale sets the value of GTK_PRINT_SETTINGS_SCALE.
func (s printSettings) SetScale(scale float64) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gdouble

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = C.gdouble(scale)

	C.gtk_print_settings_set_scale(arg0, arg1)
}

// SetUseColor sets the value of GTK_PRINT_SETTINGS_USE_COLOR.
func (s printSettings) SetUseColor(useColor bool) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gboolean

	arg0 = (*C.GtkPrintSettings)(s.Native())
	if useColor {
		arg1 = C.TRUE
	}

	C.gtk_print_settings_set_use_color(arg0, arg1)
}

// ToFile: this function saves the print settings from @settings to
// @file_name. If the file could not be loaded then error is set to either a
// Error or FileError.
func (s printSettings) ToFile(fileName string) error {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar
	var gError *C.GError

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_print_settings_to_file(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// ToGVariant: serialize print settings to an a{sv} variant.
func (s printSettings) ToGVariant() *glib.Variant {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(s.Native())

	ret := C.gtk_print_settings_to_gvariant(arg0)

	var ret0 *glib.Variant

	{
		ret0 = glib.WrapVariant(unsafe.Pointer(ret))
	}

	return ret0
}

// ToKeyFile: this function adds the print settings from @settings to
// @key_file.
func (s printSettings) ToKeyFile(keyFile *glib.KeyFile, groupName string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.GKeyFile
	var arg2 *C.gchar

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = (*C.GKeyFile)(keyFile.Native())
	arg2 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_print_settings_to_key_file(arg0, arg1, arg2)
}

// Unset removes any value associated with @key. This has the same effect as
// setting the value to nil.
func (s printSettings) Unset(key string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.gchar

	arg0 = (*C.GtkPrintSettings)(s.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_unset(arg0, arg1)
}

// RecentFilter: a RecentFilter can be used to restrict the files being shown in
// a RecentChooser. Files can be filtered based on their name (with
// gtk_recent_filter_add_pattern()), on their mime type (with
// gtk_file_filter_add_mime_type()), on the application that has registered them
// (with gtk_recent_filter_add_application()), or by a custom filter function
// (with gtk_recent_filter_add_custom()).
//
// Filtering by mime type handles aliasing and subclassing of mime types; e.g. a
// filter for text/plain also matches a file with mime type application/rtf,
// since application/rtf is a subclass of text/plain. Note that RecentFilter
// allows wildcards for the subtype of a mime type, so you can e.g. filter for
// image/\*.
//
// Normally, filters are used by adding them to a RecentChooser, see
// gtk_recent_chooser_add_filter(), but it is also possible to manually use a
// filter on a file with gtk_recent_filter_filter().
//
// Recently used files are supported since GTK+ 2.10.
//
//
// GtkRecentFilter as GtkBuildable
//
// The GtkRecentFilter implementation of the GtkBuildable interface supports
// adding rules using the <mime-types>, <patterns> and <applications> elements
// and listing the rules within. Specifying a <mime-type>, <pattern> or
// <application> has the same effect as calling
// gtk_recent_filter_add_mime_type(), gtk_recent_filter_add_pattern() or
// gtk_recent_filter_add_application().
//
// An example of a UI definition fragment specifying GtkRecentFilter rules:
//
//    <object class="GtkRecentFilter">
//      <mime-types>
//        <mime-type>text/plain</mime-type>
//        <mime-type>image/png</mime-type>
//      </mime-types>
//      <patterns>
//        <pattern>*.txt</pattern>
//        <pattern>*.png</pattern>
//      </patterns>
//      <applications>
//        <application>gimp</application>
//        <application>gedit</application>
//        <application>glade</application>
//      </applications>
//    </object>
type RecentFilter interface {
	gextras.Objector
	Buildable

	// AddAge adds a rule that allows resources based on their age - that is,
	// the number of days elapsed since they were last modified.
	AddAge(days int)
	// AddApplication adds a rule that allows resources based on the name of the
	// application that has registered them.
	AddApplication(application string)
	// AddCustom adds a rule to a filter that allows resources based on a custom
	// callback function. The bitfield @needed which is passed in provides
	// information about what sorts of information that the filter function
	// needs; this allows GTK+ to avoid retrieving expensive information when it
	// isn’t needed by the filter.
	AddCustom(needed RecentFilterFlags, fn RecentFilterFunc)
	// AddGroup adds a rule that allows resources based on the name of the group
	// to which they belong
	AddGroup(group string)
	// AddMIMEType adds a rule that allows resources based on their registered
	// MIME type.
	AddMIMEType(mimeType string)
	// AddPattern adds a rule that allows resources based on a pattern matching
	// their display name.
	AddPattern(pattern string)
	// AddPixbufFormats adds a rule allowing image files in the formats
	// supported by GdkPixbuf.
	AddPixbufFormats()
	// Filter tests whether a file should be displayed according to @filter. The
	// RecentFilterInfo @filter_info should include the fields returned from
	// gtk_recent_filter_get_needed(), and must set the
	// RecentFilterInfo.contains field of @filter_info to indicate which fields
	// have been set.
	//
	// This function will not typically be used by applications; it is intended
	// principally for use in the implementation of RecentChooser.
	Filter(filterInfo *RecentFilterInfo) bool
	// Name gets the human-readable name for the filter. See
	// gtk_recent_filter_set_name().
	Name() string
	// Needed gets the fields that need to be filled in for the RecentFilterInfo
	// passed to gtk_recent_filter_filter()
	//
	// This function will not typically be used by applications; it is intended
	// principally for use in the implementation of RecentChooser.
	Needed() RecentFilterFlags
	// SetName sets the human-readable name of the filter; this is the string
	// that will be displayed in the recently used resources selector user
	// interface if there is a selectable list of filters.
	SetName(name string)
}

// recentFilter implements the RecentFilter interface.
type recentFilter struct {
	gextras.Objector
	Buildable
}

var _ RecentFilter = (*recentFilter)(nil)

// WrapRecentFilter wraps a GObject to the right type. It is
// primarily used internally.
func WrapRecentFilter(obj *externglib.Object) RecentFilter {
	return RecentFilter{
		Objector:  obj,
		Buildable: WrapBuildable(obj),
	}
}

func marshalRecentFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRecentFilter(obj), nil
}

// NewRecentFilter constructs a class RecentFilter.
func NewRecentFilter() RecentFilter {
	ret := C.gtk_recent_filter_new()

	var ret0 RecentFilter

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(RecentFilter)

	return ret0
}

// AddAge adds a rule that allows resources based on their age - that is,
// the number of days elapsed since they were last modified.
func (f recentFilter) AddAge(days int) {
	var arg0 *C.GtkRecentFilter
	var arg1 C.gint

	arg0 = (*C.GtkRecentFilter)(f.Native())
	arg1 = C.gint(days)

	C.gtk_recent_filter_add_age(arg0, arg1)
}

// AddApplication adds a rule that allows resources based on the name of the
// application that has registered them.
func (f recentFilter) AddApplication(application string) {
	var arg0 *C.GtkRecentFilter
	var arg1 *C.gchar

	arg0 = (*C.GtkRecentFilter)(f.Native())
	arg1 = (*C.gchar)(C.CString(application))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_recent_filter_add_application(arg0, arg1)
}

// AddCustom adds a rule to a filter that allows resources based on a custom
// callback function. The bitfield @needed which is passed in provides
// information about what sorts of information that the filter function
// needs; this allows GTK+ to avoid retrieving expensive information when it
// isn’t needed by the filter.
func (f recentFilter) AddCustom(needed RecentFilterFlags, fn RecentFilterFunc) {
	var arg0 *C.GtkRecentFilter
	var arg1 C.GtkRecentFilterFlags
	var arg2 C.GtkRecentFilterFunc
	var arg3 C.gpointer
	var arg4 C.GDestroyNotify

	arg0 = (*C.GtkRecentFilter)(f.Native())
	arg1 = (C.GtkRecentFilterFlags)(needed)
	arg2 = (*[0]byte)(C.gotk4_RecentFilterFunc)
	arg3 = C.gpointer(box.Assign(fn))
	arg4 = (*[0]byte)(C.callbackDelete)

	C.gtk_recent_filter_add_custom(arg0, arg1, arg2, arg3, arg4)
}

// AddGroup adds a rule that allows resources based on the name of the group
// to which they belong
func (f recentFilter) AddGroup(group string) {
	var arg0 *C.GtkRecentFilter
	var arg1 *C.gchar

	arg0 = (*C.GtkRecentFilter)(f.Native())
	arg1 = (*C.gchar)(C.CString(group))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_recent_filter_add_group(arg0, arg1)
}

// AddMIMEType adds a rule that allows resources based on their registered
// MIME type.
func (f recentFilter) AddMIMEType(mimeType string) {
	var arg0 *C.GtkRecentFilter
	var arg1 *C.gchar

	arg0 = (*C.GtkRecentFilter)(f.Native())
	arg1 = (*C.gchar)(C.CString(mimeType))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_recent_filter_add_mime_type(arg0, arg1)
}

// AddPattern adds a rule that allows resources based on a pattern matching
// their display name.
func (f recentFilter) AddPattern(pattern string) {
	var arg0 *C.GtkRecentFilter
	var arg1 *C.gchar

	arg0 = (*C.GtkRecentFilter)(f.Native())
	arg1 = (*C.gchar)(C.CString(pattern))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_recent_filter_add_pattern(arg0, arg1)
}

// AddPixbufFormats adds a rule allowing image files in the formats
// supported by GdkPixbuf.
func (f recentFilter) AddPixbufFormats() {
	var arg0 *C.GtkRecentFilter

	arg0 = (*C.GtkRecentFilter)(f.Native())

	C.gtk_recent_filter_add_pixbuf_formats(arg0)
}

// Filter tests whether a file should be displayed according to @filter. The
// RecentFilterInfo @filter_info should include the fields returned from
// gtk_recent_filter_get_needed(), and must set the
// RecentFilterInfo.contains field of @filter_info to indicate which fields
// have been set.
//
// This function will not typically be used by applications; it is intended
// principally for use in the implementation of RecentChooser.
func (f recentFilter) Filter(filterInfo *RecentFilterInfo) bool {
	var arg0 *C.GtkRecentFilter
	var arg1 *C.GtkRecentFilterInfo

	arg0 = (*C.GtkRecentFilter)(f.Native())
	arg1 = (*C.GtkRecentFilterInfo)(filterInfo.Native())

	ret := C.gtk_recent_filter_filter(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// Name gets the human-readable name for the filter. See
// gtk_recent_filter_set_name().
func (f recentFilter) Name() string {
	var arg0 *C.GtkRecentFilter

	arg0 = (*C.GtkRecentFilter)(f.Native())

	ret := C.gtk_recent_filter_get_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Needed gets the fields that need to be filled in for the RecentFilterInfo
// passed to gtk_recent_filter_filter()
//
// This function will not typically be used by applications; it is intended
// principally for use in the implementation of RecentChooser.
func (f recentFilter) Needed() RecentFilterFlags {
	var arg0 *C.GtkRecentFilter

	arg0 = (*C.GtkRecentFilter)(f.Native())

	ret := C.gtk_recent_filter_get_needed(arg0)

	var ret0 RecentFilterFlags

	ret0 = RecentFilterFlags(ret)

	return ret0
}

// SetName sets the human-readable name of the filter; this is the string
// that will be displayed in the recently used resources selector user
// interface if there is a selectable list of filters.
func (f recentFilter) SetName(name string) {
	var arg0 *C.GtkRecentFilter
	var arg1 *C.gchar

	arg0 = (*C.GtkRecentFilter)(f.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_recent_filter_set_name(arg0, arg1)
}

// Tooltip: basic tooltips can be realized simply by using
// gtk_widget_set_tooltip_text() or gtk_widget_set_tooltip_markup() without any
// explicit tooltip object.
//
// When you need a tooltip with a little more fancy contents, like adding an
// image, or you want the tooltip to have different contents per TreeView row or
// cell, you will have to do a little more work:
//
// - Set the Widget:has-tooltip property to true, this will make GTK+ monitor
// the widget for motion and related events which are needed to determine when
// and where to show a tooltip.
//
// - Connect to the Widget::query-tooltip signal. This signal will be emitted
// when a tooltip is supposed to be shown. One of the arguments passed to the
// signal handler is a GtkTooltip object. This is the object that we are about
// to display as a tooltip, and can be manipulated in your callback using
// functions like gtk_tooltip_set_icon(). There are functions for setting the
// tooltip’s markup, setting an image from a named icon, or even putting in a
// custom widget.
//
//    Return true from your query-tooltip handler. This causes the tooltip to be
//    show. If you return false, it will not be shown.
//
// In the probably rare case where you want to have even more control over the
// tooltip that is about to be shown, you can set your own Window which will be
// used as tooltip window. This works as follows:
//
// - Set Widget:has-tooltip and connect to Widget::query-tooltip as before. Use
// gtk_widget_set_tooltip_window() to set a Window created by you as tooltip
// window.
//
// - In the Widget::query-tooltip callback you can access your window using
// gtk_widget_get_tooltip_window() and manipulate as you wish. The semantics of
// the return value are exactly as before, return true to show the window, false
// to not show it.
type Tooltip interface {
	gextras.Objector

	// SetCustom replaces the widget packed into the tooltip with
	// @custom_widget. @custom_widget does not get destroyed when the tooltip
	// goes away. By default a box with a Image and Label is embedded in the
	// tooltip, which can be configured using gtk_tooltip_set_markup() and
	// gtk_tooltip_set_icon().
	SetCustom(customWidget Widget)
	// SetIcon sets the icon of the tooltip (which is in front of the text) to
	// be @pixbuf. If @pixbuf is nil, the image will be hidden.
	SetIcon(pixbuf gdkpixbuf.Pixbuf)
	// SetIconFromGIcon sets the icon of the tooltip (which is in front of the
	// text) to be the icon indicated by @gicon with the size indicated by
	// @size. If @gicon is nil, the image will be hidden.
	SetIconFromGIcon(gicon gio.Icon, size int)
	// SetIconFromIconName sets the icon of the tooltip (which is in front of
	// the text) to be the icon indicated by @icon_name with the size indicated
	// by @size. If @icon_name is nil, the image will be hidden.
	SetIconFromIconName(iconName string, size int)
	// SetIconFromStock sets the icon of the tooltip (which is in front of the
	// text) to be the stock item indicated by @stock_id with the size indicated
	// by @size. If @stock_id is nil, the image will be hidden.
	SetIconFromStock(stockID string, size int)
	// SetMarkup sets the text of the tooltip to be @markup, which is marked up
	// with the [Pango text markup language][PangoMarkupFormat]. If @markup is
	// nil, the label will be hidden.
	SetMarkup(markup string)
	// SetText sets the text of the tooltip to be @text. If @text is nil, the
	// label will be hidden. See also gtk_tooltip_set_markup().
	SetText(text string)
	// SetTipArea sets the area of the widget, where the contents of this
	// tooltip apply, to be @rect (in widget coordinates). This is especially
	// useful for properly setting tooltips on TreeView rows and cells,
	// IconViews, etc.
	//
	// For setting tooltips on TreeView, please refer to the convenience
	// functions for this: gtk_tree_view_set_tooltip_row() and
	// gtk_tree_view_set_tooltip_cell().
	SetTipArea(rect *gdk.Rectangle)
}

// tooltip implements the Tooltip interface.
type tooltip struct {
	gextras.Objector
}

var _ Tooltip = (*tooltip)(nil)

// WrapTooltip wraps a GObject to the right type. It is
// primarily used internally.
func WrapTooltip(obj *externglib.Object) Tooltip {
	return Tooltip{
		Objector: obj,
	}
}

func marshalTooltip(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTooltip(obj), nil
}

// SetCustom replaces the widget packed into the tooltip with
// @custom_widget. @custom_widget does not get destroyed when the tooltip
// goes away. By default a box with a Image and Label is embedded in the
// tooltip, which can be configured using gtk_tooltip_set_markup() and
// gtk_tooltip_set_icon().
func (t tooltip) SetCustom(customWidget Widget) {
	var arg0 *C.GtkTooltip
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkTooltip)(t.Native())
	arg1 = (*C.GtkWidget)(customWidget.Native())

	C.gtk_tooltip_set_custom(arg0, arg1)
}

// SetIcon sets the icon of the tooltip (which is in front of the text) to
// be @pixbuf. If @pixbuf is nil, the image will be hidden.
func (t tooltip) SetIcon(pixbuf gdkpixbuf.Pixbuf) {
	var arg0 *C.GtkTooltip
	var arg1 *C.GdkPixbuf

	arg0 = (*C.GtkTooltip)(t.Native())
	arg1 = (*C.GdkPixbuf)(pixbuf.Native())

	C.gtk_tooltip_set_icon(arg0, arg1)
}

// SetIconFromGIcon sets the icon of the tooltip (which is in front of the
// text) to be the icon indicated by @gicon with the size indicated by
// @size. If @gicon is nil, the image will be hidden.
func (t tooltip) SetIconFromGIcon(gicon gio.Icon, size int) {
	var arg0 *C.GtkTooltip
	var arg1 *C.GIcon
	var arg2 C.GtkIconSize

	arg0 = (*C.GtkTooltip)(t.Native())
	arg1 = (*C.GIcon)(gicon.Native())
	arg2 = C.GtkIconSize(size)

	C.gtk_tooltip_set_icon_from_gicon(arg0, arg1, arg2)
}

// SetIconFromIconName sets the icon of the tooltip (which is in front of
// the text) to be the icon indicated by @icon_name with the size indicated
// by @size. If @icon_name is nil, the image will be hidden.
func (t tooltip) SetIconFromIconName(iconName string, size int) {
	var arg0 *C.GtkTooltip
	var arg1 *C.gchar
	var arg2 C.GtkIconSize

	arg0 = (*C.GtkTooltip)(t.Native())
	arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.GtkIconSize(size)

	C.gtk_tooltip_set_icon_from_icon_name(arg0, arg1, arg2)
}

// SetIconFromStock sets the icon of the tooltip (which is in front of the
// text) to be the stock item indicated by @stock_id with the size indicated
// by @size. If @stock_id is nil, the image will be hidden.
func (t tooltip) SetIconFromStock(stockID string, size int) {
	var arg0 *C.GtkTooltip
	var arg1 *C.gchar
	var arg2 C.GtkIconSize

	arg0 = (*C.GtkTooltip)(t.Native())
	arg1 = (*C.gchar)(C.CString(stockID))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.GtkIconSize(size)

	C.gtk_tooltip_set_icon_from_stock(arg0, arg1, arg2)
}

// SetMarkup sets the text of the tooltip to be @markup, which is marked up
// with the [Pango text markup language][PangoMarkupFormat]. If @markup is
// nil, the label will be hidden.
func (t tooltip) SetMarkup(markup string) {
	var arg0 *C.GtkTooltip
	var arg1 *C.gchar

	arg0 = (*C.GtkTooltip)(t.Native())
	arg1 = (*C.gchar)(C.CString(markup))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_tooltip_set_markup(arg0, arg1)
}

// SetText sets the text of the tooltip to be @text. If @text is nil, the
// label will be hidden. See also gtk_tooltip_set_markup().
func (t tooltip) SetText(text string) {
	var arg0 *C.GtkTooltip
	var arg1 *C.gchar

	arg0 = (*C.GtkTooltip)(t.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_tooltip_set_text(arg0, arg1)
}

// SetTipArea sets the area of the widget, where the contents of this
// tooltip apply, to be @rect (in widget coordinates). This is especially
// useful for properly setting tooltips on TreeView rows and cells,
// IconViews, etc.
//
// For setting tooltips on TreeView, please refer to the convenience
// functions for this: gtk_tree_view_set_tooltip_row() and
// gtk_tree_view_set_tooltip_cell().
func (t tooltip) SetTipArea(rect *gdk.Rectangle) {
	var arg0 *C.GtkTooltip
	var arg1 *C.GdkRectangle

	arg0 = (*C.GtkTooltip)(t.Native())
	arg1 = (*C.GdkRectangle)(rect.Native())

	C.gtk_tooltip_set_tip_area(arg0, arg1)
}
